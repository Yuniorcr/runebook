<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="ember">
    <body>
      <group id="ember">
        <trans-unit id="23489b054c9d1e661085fd7ade8acb2475375094" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt;&lt;code&gt;{{component}}&lt;/code&gt;&lt;/a&gt; helper can be used to defer the selection of a component to run time. The &lt;code&gt;{{my-component}}&lt;/code&gt; syntax always renders the same component, while using the &lt;code&gt;{{component}}&lt;/code&gt; helper allows choosing a component to render on the fly. This is useful in cases where you want to interact with different external libraries depending on the data. Using the &lt;code&gt;{{component}}&lt;/code&gt; helper would allow you to keep different logic well separated.</source>
          <target state="translated">的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt; &lt;code&gt;{{component}}&lt;/code&gt; &lt;/a&gt;辅助可被用于推迟到运行时组件的选择。该 &lt;code&gt;{{my-component}}&lt;/code&gt; 语法总是呈现相同的部件，在使用 &lt;code&gt;{{component}}&lt;/code&gt; 帮手允许选择一个组件以使对飞。如果要根据数据与不同的外部库进行交互，这很有用。使用 &lt;code&gt;{{component}}&lt;/code&gt; 帮助器可以使不同的逻辑保持良好的分离。</target>
        </trans-unit>
        <trans-unit id="80ffe12423c4f4418b92c52ce25e13ca8840255f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_debugger&quot;&gt;&lt;code&gt;{{debugger}}&lt;/code&gt;&lt;/a&gt; helper provides a handlebars equivalent to JavaScript's &lt;code&gt;debugger&lt;/code&gt; keyword. It will halt execution inside the debugger helper and give you the ability to inspect the current rendering context:</source>
          <target state="translated">该&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_debugger&quot;&gt; &lt;code&gt;{{debugger}}&lt;/code&gt; &lt;/a&gt;助手提供了等同于JavaScript的一个车把 &lt;code&gt;debugger&lt;/code&gt; 关键字。它将暂停调试器帮助器内的执行，并让您能够检查当前渲染上下文：</target>
        </trans-unit>
        <trans-unit id="8c8f61b48bfab920e95655c42840396a2f3f8014" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt;&lt;code&gt;{{#each}}&lt;/code&gt;&lt;/a&gt; helper can have a corresponding &lt;code&gt;{{else}}&lt;/code&gt;. The contents of this block will render if the array passed to &lt;code&gt;{{#each}}&lt;/code&gt; is empty:</source>
          <target state="translated">该&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt; &lt;code&gt;{{#each}}&lt;/code&gt; &lt;/a&gt;帮手可以有一个相应的 &lt;code&gt;{{else}}&lt;/code&gt; 。如果传递给 &lt;code&gt;{{#each}}&lt;/code&gt; 的数组为空，则此块的内容将呈现：</target>
        </trans-unit>
        <trans-unit id="6a5dfe3aacaf09268ef43166eeb9e8edcded68ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each-in&quot;&gt;&lt;code&gt;{{#each-in}}&lt;/code&gt;&lt;/a&gt; helper can have a matching &lt;code&gt;{{else}}&lt;/code&gt;. The contents of this block will render if the object is empty, null, or undefined:</source>
          <target state="translated">该&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each-in&quot;&gt; &lt;code&gt;{{#each-in}}&lt;/code&gt; &lt;/a&gt;帮手可以有一个匹配 &lt;code&gt;{{else}}&lt;/code&gt; 。如果对象为空，null或未定义，则此块的内容将呈现：</target>
        </trans-unit>
        <trans-unit id="b327dbd565eb9fdd986c4b054241ad5e30065698" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_get&quot;&gt;&lt;code&gt;{{get}}&lt;/code&gt;&lt;/a&gt; helper makes it easy to dynamically send the value of a variable to another helper or component. This can be useful if you want to output one of several values based on the result of a computed property.</source>
          <target state="translated">该&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_get&quot;&gt; &lt;code&gt;{{get}}&lt;/code&gt; &lt;/a&gt;帮手让您轻松变量的值动态地发送到另一个助手或组件。如果要基于已计算属性的结果输出多个值之一，这将很有用。</target>
        </trans-unit>
        <trans-unit id="61302d7882e1a4a6e553fe68b02feeeae75416e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;&lt;code&gt;{{input}}&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt;&lt;code&gt;{{textarea}}&lt;/code&gt;&lt;/a&gt; helpers in Ember.js are the easiest way to create common form controls. Using these helpers, you can create form controls that are almost identical to the native HTML &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; elements, but are aware of Ember's two-way bindings and can automatically update.</source>
          <target state="translated">该&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt; &lt;code&gt;{{input}}&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_textarea&quot;&gt; &lt;code&gt;{{textarea}}&lt;/code&gt; &lt;/a&gt;在Ember.js助手是创建常见窗体控件的最简单的方法。使用这些帮助器，您可以创建与本地HTML &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 元素几乎相同的表单控件，但是知道Ember的双向绑定并且可以自动更新。</target>
        </trans-unit>
        <trans-unit id="b85d9f0441c7c29d7da9b855a389e22f68bcf461" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_log&quot;&gt;&lt;code&gt;{{log}}&lt;/code&gt;&lt;/a&gt; helper makes it easy to output variables or expressions in the current rendering context into your browser's console:</source>
          <target state="translated">使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_log&quot;&gt; &lt;code&gt;{{log}}&lt;/code&gt; &lt;/a&gt;帮助程序可以轻松地将当前呈现上下文中的变量或表达式输出到浏览器的控制台中：</target>
        </trans-unit>
        <trans-unit id="17f528362a0405c2911a3e6d031edc5b960dfd08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_fillIn&quot;&gt;&lt;code&gt;fillIn&lt;/code&gt;&lt;/a&gt; helper &quot;fills in&quot; the given text into an input field matching the given selector.</source>
          <target state="translated">该&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_fillIn&quot;&gt; &lt;code&gt;fillIn&lt;/code&gt; &lt;/a&gt;帮手&amp;ldquo;填补&amp;rdquo;给定的文本到给定的选择相匹配的输入字段。</target>
        </trans-unit>
        <trans-unit id="fadd4ef675168e49d87ffb530f6637c11e100846" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_keyEvent&quot;&gt;&lt;code&gt;keyEvent&lt;/code&gt;&lt;/a&gt; helper sends a key stroke event to the UI, simulating the user typing a key.</source>
          <target state="translated">该&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_keyEvent&quot;&gt; &lt;code&gt;keyEvent&lt;/code&gt; &lt;/a&gt;辅助发送键击事件的UI，模拟用户输入一个密钥。</target>
        </trans-unit>
        <trans-unit id="0aef6d62598e457e26c06a939a5185bf766acd4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;DS.JSONAPIAdapter&lt;/a&gt; has a handful of hooks that are commonly used to extend it to work with non-standard backends.</source>
          <target state="translated">该&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;DS.JSONAPIAdapter&lt;/a&gt;有常用于它与非标准后端延伸到工作挂钩了一把。</target>
        </trans-unit>
        <trans-unit id="484456215b5f899d8ed5e829d7551272461d51b9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/tutorial&quot;&gt;Google Maps API&lt;/a&gt; requires us to reference its library from a remote script. In this case we'll provide this script to our Ember app via an Addon called &lt;code&gt;ember-simple-google-maps&lt;/code&gt;.</source>
          <target state="translated">在&lt;a href=&quot;https://developers.google.com/maps/documentation/javascript/tutorial&quot;&gt;谷歌地图API&lt;/a&gt;需要我们从远程脚本中引用的库。在这种情况下，我们将通过名为 &lt;code&gt;ember-simple-google-maps&lt;/code&gt; 的插件将此脚本提供给Ember应用程序。</target>
        </trans-unit>
        <trans-unit id="721d0aca3cae4958efdc2c786984eea8d65f5f0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://guides.emberjs.com/addons-and-dependencies/managing-dependencies/#toc_other-assets&quot;&gt;&lt;code&gt;vendor&lt;/code&gt; directory&lt;/a&gt; in Ember is a special directory where you can include content that gets compiled into your application. When Ember CLI builds our app from our source code, it copies &lt;code&gt;ember-tutorial.css&lt;/code&gt; into a file called &lt;code&gt;vendor.css&lt;/code&gt;.</source>
          <target state="translated">Ember中的&lt;a href=&quot;https://guides.emberjs.com/addons-and-dependencies/managing-dependencies/#toc_other-assets&quot;&gt; &lt;code&gt;vendor&lt;/code&gt; 目录&lt;/a&gt;是一个特殊目录，您可以在其中包含编译到应用程序中的内容。当Ember CLI从源代码构建我们的应用程序时，它将 &lt;code&gt;ember-tutorial.css&lt;/code&gt; 复制到一个名为 &lt;code&gt;vendor.css&lt;/code&gt; 的文件中。</target>
        </trans-unit>
        <trans-unit id="f3296c43c92a794424bfcbe162e716bebeab8f9f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://guides.emberjs.com/object-model/&quot;&gt;Object Model&lt;/a&gt; section of the Guides describes how to write computed properties, observers, and bindings without prototype extensions. Below you can learn about how to convert existing code to the format now encouraged.</source>
          <target state="translated">《指南》的&amp;ldquo; &lt;a href=&quot;https://guides.emberjs.com/object-model/&quot;&gt;对象模型&amp;rdquo;&lt;/a&gt;部分描述了如何编写没有原型扩展的计算属性，观察者和绑定。您可以在下面了解如何将现有代码转换为现在鼓励的格式。</target>
        </trans-unit>
        <trans-unit id="3016cd065a1ea33674454f4b4409c5a76ecee77d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ApplicationInstance&lt;/code&gt; encapsulates all of the stateful aspects of a running &lt;code&gt;Application&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;ApplicationInstance&lt;/code&gt; 封装了所有的运行的状态方面 &lt;code&gt;Application&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f930fd3f23af023ef9f744a703e14d94dcebcaeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BlogPost&lt;/code&gt; model would have properties like:</source>
          <target state="translated">该 &lt;code&gt;BlogPost&lt;/code&gt; 的模型应该像属性：</target>
        </trans-unit>
        <trans-unit id="fae849844f7c3ca3ad9b933a44e600ae65479143" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BroadwayStar&lt;/code&gt; class contains three methods: &lt;code&gt;say()&lt;/code&gt;, &lt;code&gt;sing()&lt;/code&gt;, and &lt;code&gt;dance()&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;BroadwayStar&lt;/code&gt; 类包含三个方法： &lt;code&gt;say()&lt;/code&gt; ， &lt;code&gt;sing()&lt;/code&gt; ，和 &lt;code&gt;dance()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d63f1b0f445b29ddfc61aeec73fb12eb211d5567" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ContainerDebugAdapter&lt;/code&gt; helps the container and resolver interface with tools that debug Ember such as the &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;Ember Inspector&lt;/a&gt; for Chrome and Firefox.</source>
          <target state="translated">该 &lt;code&gt;ContainerDebugAdapter&lt;/code&gt; 有助于工具，调试灰烬，如容器和变压器接口&lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;灰烬督察&lt;/a&gt; Chrome和Firefox浏览器。</target>
        </trans-unit>
        <trans-unit id="2b819ff65f7652ad8943fa82a80ca24f474b2a1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.BooleanTransform&lt;/code&gt; class is used to serialize and deserialize boolean attributes on Ember Data record objects. This transform is used when &lt;code&gt;boolean&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function.</source>
          <target state="translated">该 &lt;code&gt;DS.BooleanTransform&lt;/code&gt; 类用于序列化和反序列化的灰烬数据记录对象的布尔属性。将 &lt;code&gt;boolean&lt;/code&gt; 作为类型参数传递给&lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt;函数时，将使用此转换。</target>
        </trans-unit>
        <trans-unit id="bd3e9a0eed710efe4a88384528b918c339217700" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.DateTransform&lt;/code&gt; class is used to serialize and deserialize date attributes on Ember Data record objects. This transform is used when &lt;code&gt;date&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function. It uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;&lt;code&gt;ISO 8601&lt;/code&gt;&lt;/a&gt; standard.</source>
          <target state="translated">该 &lt;code&gt;DS.DateTransform&lt;/code&gt; 类用于序列化和灰烬数据记录对象的反序列化日期属性。将 &lt;code&gt;date&lt;/code&gt; 作为类型参数传递给&lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt;函数时，将使用此转换。它使用&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt; &lt;code&gt;ISO 8601&lt;/code&gt; &lt;/a&gt;标准。</target>
        </trans-unit>
        <trans-unit id="2982cc3dc82ca2b47f88e8fdbe38cb683d0cbfa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.Model&lt;/code&gt; states are themselves stateless. What that means is that, the hierarchical states that each of &lt;em&gt;those&lt;/em&gt; points to is a shared data structure. For performance reasons, instead of each record getting its own copy of the hierarchy of states, each record points to this global, immutable shared instance. How does a state know which record it should be acting on? We pass the record instance into the state's event handlers as the first argument.</source>
          <target state="translated">该 &lt;code&gt;DS.Model&lt;/code&gt; 状态本身无状态的。这意味着，每个&lt;em&gt;这些&lt;/em&gt;指向的层次结构状态都是共享数据结构。出于性能原因，每个记录都指向该全局的，不变的共享实例，而不是每个记录都获得自己的状态层次结构副本。一个州如何知道它应该对哪个记录进行操作？我们将记录实例作为第一个参数传递到状态的事件处理程序中。</target>
        </trans-unit>
        <trans-unit id="f0eb91368a9212981a5c1132e3c4cf949c7a59b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.NumberTransform&lt;/code&gt; class is used to serialize and deserialize numeric attributes on Ember Data record objects. This transform is used when &lt;code&gt;number&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function.</source>
          <target state="translated">该 &lt;code&gt;DS.NumberTransform&lt;/code&gt; 类用于序列化和反序列化的灰烬数据记录对象的数值属性。将 &lt;code&gt;number&lt;/code&gt; 作为类型参数传递给&lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt;函数时，将使用此转换。</target>
        </trans-unit>
        <trans-unit id="57ede3918d3480e3b06e6aa03ddac19ce5a83194" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.StringTransform&lt;/code&gt; class is used to serialize and deserialize string attributes on Ember Data record objects. This transform is used when &lt;code&gt;string&lt;/code&gt; is passed as the type parameter to the &lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt; function.</source>
          <target state="translated">该 &lt;code&gt;DS.StringTransform&lt;/code&gt; 类用于序列化和灰烬数据记录对象的反序列化字符串属性。将 &lt;code&gt;string&lt;/code&gt; 作为类型参数传递给&lt;a href=&quot;https://emberjs.com/api/ember-data/data#method_attr&quot;&gt;DS.attr&lt;/a&gt;函数时，将使用此转换。</target>
        </trans-unit>
        <trans-unit id="4c7d84bb5ae36b5bebe679b64273fe856da64324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DS.Transform&lt;/code&gt; class is used to serialize and deserialize model attributes when they are saved or loaded from an adapter. Subclassing &lt;code&gt;DS.Transform&lt;/code&gt; is useful for creating custom attributes. All subclasses of &lt;code&gt;DS.Transform&lt;/code&gt; must implement a &lt;code&gt;serialize&lt;/code&gt; and a &lt;code&gt;deserialize&lt;/code&gt; method.</source>
          <target state="translated">从适配器保存或加载模型属性时， &lt;code&gt;DS.Transform&lt;/code&gt; 类用于对模型属性进行序列化和反序列化。子类化 &lt;code&gt;DS.Transform&lt;/code&gt; 对于创建自定义属性很有用。 &lt;code&gt;DS.Transform&lt;/code&gt; 的所有子类都必须实现 &lt;code&gt;serialize&lt;/code&gt; 和 &lt;code&gt;deserialize&lt;/code&gt; 序列化方法。</target>
        </trans-unit>
        <trans-unit id="e00a79faab114e9901c4f0599964d16729665318" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DataAdapter&lt;/code&gt; helps a data persistence library interface with tools that debug Ember such as the &lt;a href=&quot;https://github.com/tildeio/ember-extension&quot;&gt;Ember Extension&lt;/a&gt; for Chrome and Firefox.</source>
          <target state="translated">该 &lt;code&gt;DataAdapter&lt;/code&gt; 的帮助数据持久性与工具，调试灰烬，如库接口&lt;a href=&quot;https://github.com/tildeio/ember-extension&quot;&gt;灰烬扩展&lt;/a&gt;的Chrome和Firefox。</target>
        </trans-unit>
        <trans-unit id="319307645bea1fa807d738e83c0a90cd1cf5ef96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; responsible for delegating events to this application's views.</source>
          <target state="translated">该 &lt;code&gt;Ember.EventDispatcher&lt;/code&gt; 负责事件委托给该应用程序的意见。</target>
        </trans-unit>
        <trans-unit id="5a1153767edf9a9bc5406d38e28481d0c34bda34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.Mixin&lt;/code&gt; class allows you to create mixins, whose properties can be added to other classes. For instance,</source>
          <target state="translated">该 &lt;code&gt;Ember.Mixin&lt;/code&gt; 类允许你创建的混入，其属性可以被添加到其他类。例如，</target>
        </trans-unit>
        <trans-unit id="6a4036df61adabd029b6eba87bb294575bc9d7bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.Route&lt;/code&gt; class is used to define individual routes. Refer to the &lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;routing guide&lt;/a&gt; for documentation.</source>
          <target state="translated">该 &lt;code&gt;Ember.Route&lt;/code&gt; 类用于定义个别路线。请参阅&lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;路由指南&lt;/a&gt;以获取文档。</target>
        </trans-unit>
        <trans-unit id="885e6e3f5749d0e1ec5e434cb9dfa2078fb80a8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.Router&lt;/code&gt; class manages the application state and URLs. Refer to the &lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;routing guide&lt;/a&gt; for documentation.</source>
          <target state="translated">该 &lt;code&gt;Ember.Router&lt;/code&gt; 类管理应用程序状态和URL。请参阅&lt;a href=&quot;https://emberjs.com/guides/routing/&quot;&gt;路由指南&lt;/a&gt;以获取文档。</target>
        </trans-unit>
        <trans-unit id="211a8a0ab63aee094d2b679406429c9861efd416" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Ember.run&lt;/code&gt; method can be used to create a run loop. In this example, jQuery and &lt;code&gt;Ember.run&lt;/code&gt; are used to handle a click event and run some Ember code.</source>
          <target state="translated">该 &lt;code&gt;Ember.run&lt;/code&gt; 方法可用于创建一个运行循环。在此示例中，jQuery和 &lt;code&gt;Ember.run&lt;/code&gt; 用于处理click事件并运行一些Ember代码。</target>
        </trans-unit>
        <trans-unit id="3c7c53858dc783a25f5941955654a26b7b31a8c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Engine&lt;/code&gt; class contains core functionality for both applications and engines.</source>
          <target state="translated">该 &lt;code&gt;Engine&lt;/code&gt; 类包含应用程序和引擎核心功能。</target>
        </trans-unit>
        <trans-unit id="14638c0630a0a3cff87817f36c2554b1c8d6490b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EngineInstance&lt;/code&gt; encapsulates all of the stateful aspects of a running &lt;code&gt;Engine&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;EngineInstance&lt;/code&gt; 封装了所有的运行的状态方面 &lt;code&gt;Engine&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef790b8517960a1d3695e93af0bd1b8f3839440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPIAdapter&lt;/code&gt; is smart enough to determine the URLs it communicates with based on the name of the model. For example, if you ask for a &lt;code&gt;Post&lt;/code&gt; by ID:</source>
          <target state="translated">该 &lt;code&gt;JSONAPIAdapter&lt;/code&gt; 是足够聪明，以确定它与基于模型的名称通信的URL。例如，如果您要求按ID &lt;code&gt;Post&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c950fbe2c97da63e2b034eaca1b0c609b4171279" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPIAdapter&lt;/code&gt; is the default adapter used by Ember Data. It is responsible for transforming the store's requests into HTTP requests that follow the &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API&lt;/a&gt; format.</source>
          <target state="translated">该 &lt;code&gt;JSONAPIAdapter&lt;/code&gt; 是灰烬的数据使用默认的适配器。它负责将商店的请求转换为遵循&lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API&lt;/a&gt;格式的HTTP请求。</target>
        </trans-unit>
        <trans-unit id="34c3733779dc0df0421669354af118f5e875520e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPISerializer&lt;/code&gt; expects the backend to return a JSON API Document that follows the JSON API specification and the conventions of the examples found on &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;http://jsonapi.org/format&lt;/a&gt;. This means all type names should be pluralized and attribute and relationship names should be dash-cased. For example, if you request a record from &lt;code&gt;/people/123&lt;/code&gt;, the response should look like this:</source>
          <target state="translated">所述 &lt;code&gt;JSONAPISerializer&lt;/code&gt; 预计后端返回下面的JSON API说明书和的上发现的实施例中的约定的JSON API文献&lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;http://jsonapi.org/format&lt;/a&gt;。这意味着所有类型名称都应该是复数形式，属性和关系名称应该用短划线表示。例如，如果您从 &lt;code&gt;/people/123&lt;/code&gt; 请求记录，则响应应如下所示：</target>
        </trans-unit>
        <trans-unit id="a163a2de99844b44ded1af52c454ec8cb95bad1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONAPISerializer&lt;/code&gt; is built on top of the &lt;code&gt;JSONSerializer&lt;/code&gt; so they share many of the same hooks for customizing the behavior of the serialization process. Be sure to check out the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONSerializer.html&quot;&gt;API docs&lt;/a&gt; for a full list of methods and properties.</source>
          <target state="translated">该 &lt;code&gt;JSONAPISerializer&lt;/code&gt; 是建立在之上 &lt;code&gt;JSONSerializer&lt;/code&gt; ，使他们共享许多相同的钩用于自定义序列化进程的行为。请务必查看&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONSerializer.html&quot;&gt;API文档&lt;/a&gt;，以获取方法和属性的完整列表。</target>
        </trans-unit>
        <trans-unit id="2372e29f3591a6e06a86749f11f23bc152d06ae0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JSONSerializer&lt;/code&gt; normalization process follows these steps:</source>
          <target state="translated">所述 &lt;code&gt;JSONSerializer&lt;/code&gt; 归一化处理步骤如下：</target>
        </trans-unit>
        <trans-unit id="b8d7134db8562c548ba83e1398f6d35393db9323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last Update: {{lastUpdateTimestamp}}&lt;/code&gt; will be rendered in place of the &lt;code&gt;{{yield}}&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;Last Update: {{lastUpdateTimestamp}}&lt;/code&gt; 将替代被渲染 &lt;code&gt;{{yield}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="595ef6a646450a473c800b0f4386c1825ddf018a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ManyArray&lt;/code&gt; is instantiated lazily the first time the relationship is requested.</source>
          <target state="translated">该 &lt;code&gt;ManyArray&lt;/code&gt; 是懒洋洋地实例化的第一次请求的关系。</target>
        </trans-unit>
        <trans-unit id="0dfb03cf2957c12e3cd48a12a2a6c5c0716c3419" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Router.map&lt;/code&gt; function allows you to define mappings from URLs to routes in your application. These mappings are defined within the supplied callback function using &lt;code&gt;this.route&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;Router.map&lt;/code&gt; 功能可让您从URL中定义映射到应用程序中的路线。这些映射是使用 &lt;code&gt;this.route&lt;/code&gt; 在提供的回调函数中定义的。</target>
        </trans-unit>
        <trans-unit id="2b94bcc514f833c5ef1923bb0c25457ea933534f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;action&lt;/code&gt; helper allows you to add event listeners to elements and call named functions. By default, the &lt;code&gt;action&lt;/code&gt; helper adds a &lt;code&gt;click&lt;/code&gt; event listener, but it can be used to listen for any element event. Now, when the &lt;code&gt;li&lt;/code&gt; element is clicked a &lt;code&gt;showPerson&lt;/code&gt; function will be called from the &lt;code&gt;actions&lt;/code&gt; object in the &lt;code&gt;people-list&lt;/code&gt; component. Think of this like calling &lt;code&gt;this.actions.showPerson(person)&lt;/code&gt; from our template.</source>
          <target state="translated">该 &lt;code&gt;action&lt;/code&gt; 助手允许你添加事件侦听器的元素，并调用命名的功能。默认情况下， &lt;code&gt;action&lt;/code&gt; 帮助器会添加一个 &lt;code&gt;click&lt;/code&gt; 事件侦听器，但可用于侦听任何元素事件。现在，当单击 &lt;code&gt;li&lt;/code&gt; 元素时，将从 &lt;code&gt;people-list&lt;/code&gt; 组件中的 &lt;code&gt;actions&lt;/code&gt; 对象调用 &lt;code&gt;showPerson&lt;/code&gt; 函数。可以将其想象为从我们的模板中调用 &lt;code&gt;this.actions.showPerson(person)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6781996b5d8528d30fde9ec99ae34a524c6762c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;actions&lt;/code&gt; hash will inherit action handlers from the &lt;code&gt;actions&lt;/code&gt; hash defined on extended parent classes or mixins rather than just replace the entire hash, e.g.:</source>
          <target state="translated">该 &lt;code&gt;actions&lt;/code&gt; 哈希将继承动作处理 &lt;code&gt;actions&lt;/code&gt; 的散列上扩展父类或混入定义，而不是仅仅更换整个哈希，例如：</target>
        </trans-unit>
        <trans-unit id="9f0188c56bfb8d604ed462187f6484e25c179952" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;actions&lt;/code&gt; queue is the general work queue and will typically contain scheduled tasks e.g. promises.</source>
          <target state="translated">该 &lt;code&gt;actions&lt;/code&gt; 队列是一般的工作队列，并通常会含有预定任务如承诺。</target>
        </trans-unit>
        <trans-unit id="41ff0eeabf56cfc059010cc4c18262f67f627814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;afterRender&lt;/code&gt; queue contains jobs meant to be run after all previously scheduled render tasks are complete. This is often good for 3rd-party DOM manipulation libraries, that should only be run after an entire tree of DOM has been updated.</source>
          <target state="translated">在 &lt;code&gt;afterRender&lt;/code&gt; 队列包含意味着就业机会毕竟以前计划的渲染任务完成后要运行。这通常对第三方DOM操作库很有用，仅应在更新整个DOM树之后运行。</target>
        </trans-unit>
        <trans-unit id="95d664e2d1d83fcd6e5b1affc99d006e5870087d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;andThen&lt;/code&gt; helper will wait for all preceding asynchronous helpers to complete prior to progressing forward. Let's take a look at the following example.</source>
          <target state="translated">该 &lt;code&gt;andThen&lt;/code&gt; 助手将等待所有先前的异步助手之前进步向前来完成。让我们看下面的例子。</target>
        </trans-unit>
        <trans-unit id="4d4a81e4ca7c1ec493df5706886873c52cf64207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;application&lt;/code&gt; route is entered when your app first boots up. Like other routes, it will load a template with the same name (&lt;code&gt;application&lt;/code&gt; in this case) by default. You should put your header, footer, and any other decorative content here. All other routes will render their templates into the &lt;code&gt;application.hbs&lt;/code&gt; template's &lt;code&gt;{{outlet}}&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;application&lt;/code&gt; 路径输入时，你的应用程序第一次启动时。与其他路由一样，默认情况下它将加载具有相同名称的模板（在本例中为 &lt;code&gt;application&lt;/code&gt; ）。您应该在此处放置页眉，页脚和任何其他装饰内容。所有其他路由会将其模板呈现到 &lt;code&gt;application.hbs&lt;/code&gt; 模板的 &lt;code&gt;{{outlet}}&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="4a5ab553a8d271896a510ee5268f14190264cb5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; object can be used to declare a simple mapping between property names on &lt;code&gt;DS.Model&lt;/code&gt; records and payload keys in the serialized JSON object representing the record. An object with the property &lt;code&gt;key&lt;/code&gt; can also be used to designate the attribute's key on the response payload.</source>
          <target state="translated">所述 &lt;code&gt;attrs&lt;/code&gt; 对象可用于声明对属性名称之间一个简单的映射 &lt;code&gt;DS.Model&lt;/code&gt; 记录和有效载荷密钥在序列化JSON对象表示记录。具有属性 &lt;code&gt;key&lt;/code&gt; 的对象也可以用于在响应有效负载上指定属性的键。</target>
        </trans-unit>
        <trans-unit id="6dc40241d339c1bb5c98150382b9bbb509e1494e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; option for a resource &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; is shorthand for:</source>
          <target state="translated">资源 &lt;code&gt;{ embedded: 'always' }&lt;/code&gt; 的 &lt;code&gt;attrs&lt;/code&gt; 选项是以下内容的简写：</target>
        </trans-unit>
        <trans-unit id="d11fb7ffee10a29dcba72e4be14a34886533a524" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;attrs&lt;/code&gt; property can be set on the &lt;code&gt;ApplicationSerializer&lt;/code&gt; or a per-type serializer.</source>
          <target state="translated">所述 &lt;code&gt;attrs&lt;/code&gt; 属性可以在被设置 &lt;code&gt;ApplicationSerializer&lt;/code&gt; 或每个类型串行器。</target>
        </trans-unit>
        <trans-unit id="91ff220601d5dc8de2569eafda2d847e2de3da0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;backgroundReload&lt;/code&gt; option is used to prevent the fetching of the destroyed record, since &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt;&lt;code&gt;findRecord()&lt;/code&gt;&lt;/a&gt; automatically schedules a fetch of the record from the adapter.</source>
          <target state="translated">该 &lt;code&gt;backgroundReload&lt;/code&gt; 选项用于防止破坏记录的抓取，因为&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt; &lt;code&gt;findRecord()&lt;/code&gt; &lt;/a&gt;自动安排取回从适配器的记录。</target>
        </trans-unit>
        <trans-unit id="a4f5e918a009088b91687277e637fe04016877fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;boolean&lt;/code&gt; transform can handle values other than &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. The strings &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;t&quot;&lt;/code&gt; in any casing, &lt;code&gt;&quot;1&quot;&lt;/code&gt;, and the number &lt;code&gt;1&lt;/code&gt; will all coerce to &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">该 &lt;code&gt;boolean&lt;/code&gt; 变换可以处理比其他值 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。任何大小写形式中的字符串 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;t&quot;&lt;/code&gt; ， &lt;code&gt;&quot;1&quot;&lt;/code&gt; 和数字 &lt;code&gt;1&lt;/code&gt; 都将强制转换为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71a103dc62034f2f7cae2908b76c1995a2fd8b2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;build&lt;/code&gt; command packages up all of the assets that make up your application&amp;mdash;JavaScript, templates, CSS, web fonts, images, and more.</source>
          <target state="translated">在 &lt;code&gt;build&lt;/code&gt; 命令封装了所有让您的应用程序的JavaScript，模板，CSS，网页字体，图像和更多的资产。</target>
        </trans-unit>
        <trans-unit id="84d78207fa37bb2b65a91e18bf5316cd6ed67a48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;checked&lt;/code&gt; attribute of an &lt;code&gt;Ember.Checkbox&lt;/code&gt; object should always be set through the Ember object or by interacting with its rendered element representation via the mouse, keyboard, or touch. Updating the value of the checkbox via jQuery will result in the checked value of the object and its element losing synchronization.</source>
          <target state="translated">&lt;code&gt;Ember.Checkbox&lt;/code&gt; 对象的 &lt;code&gt;checked&lt;/code&gt; 属性应始终通过Ember对象设置，或通过鼠标，键盘或触摸与其呈现的元素表示进行交互来设置。通过jQuery更新复选框的值将导致对象及其元素的检查值失去同步。</target>
        </trans-unit>
        <trans-unit id="388167e41998946f805b5e706d65af0e5c7f26f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;component&lt;/code&gt; helper can be used to package a component path with initial attrs. The included attrs can then be merged during the final invocation. For example, given a &lt;code&gt;person-form&lt;/code&gt; component with the following template:</source>
          <target state="translated">的 &lt;code&gt;component&lt;/code&gt; 的辅助可用于包装用初始ATTRS一个组件的路径。然后可以在最终调用期间合并包含的attrs。例如，给定具有以下模板 &lt;code&gt;person-form&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="4c34fbc331365e1345b641ddb67e8318a5245aaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context&lt;/code&gt; argument allows you to optionally specify the &lt;code&gt;this&lt;/code&gt; with which your callback will be invoked.</source>
          <target state="translated">该 &lt;code&gt;context&lt;/code&gt; 参数允许您选择指定 &lt;code&gt;this&lt;/code&gt; 与你的回调将被调用。</target>
        </trans-unit>
        <trans-unit id="89d688b3c007bc970797daf54bb128d1ea052cf8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; on line #17 creates an &lt;em&gt;instance&lt;/em&gt; of the &lt;code&gt;Soldier&lt;/code&gt; class. The &lt;code&gt;extend()&lt;/code&gt; on line #8 creates a &lt;em&gt;subclass&lt;/em&gt; of &lt;code&gt;Person&lt;/code&gt;. Any instance of the &lt;code&gt;Person&lt;/code&gt; class will &lt;em&gt;not&lt;/em&gt; have the &lt;code&gt;march()&lt;/code&gt; method.</source>
          <target state="translated">在 &lt;code&gt;create()&lt;/code&gt; 上线＃17创建一个&lt;em&gt;实例&lt;/em&gt;中的 &lt;code&gt;Soldier&lt;/code&gt; 类。的 &lt;code&gt;extend()&lt;/code&gt; 在线路＃8创建一个&lt;em&gt;子类&lt;/em&gt;的 &lt;code&gt;Person&lt;/code&gt; 。在任何情况下 &lt;code&gt;Person&lt;/code&gt; 类将&lt;em&gt;不会&lt;/em&gt;有 &lt;code&gt;march()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c49797066693990d496ec9bb1f4d6f26783f06a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;createRecord&lt;/code&gt; method serializes the record and makes an Ajax (HTTP POST) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;createRecord&lt;/code&gt; 方法序列化记录并使得一个Ajax（HTTP POST）请求到由计算的URL &lt;code&gt;buildURL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9a93643d5938fe543825d7c0628e35429505c3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;date&lt;/code&gt; transform will transform an &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt; string to a JavaScript date object.</source>
          <target state="translated">该 &lt;code&gt;date&lt;/code&gt; 变换将改变的&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601&lt;/a&gt;字符串到JavaScript日期对象。</target>
        </trans-unit>
        <trans-unit id="e80e5ce5365720cc0f4de3729b802465bc83fe09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultSerializer&lt;/code&gt; property can be used to specify the serializer that will be used by this adapter. This is only used when a model specific serializer or &lt;code&gt;serializer:application&lt;/code&gt; are not defined.</source>
          <target state="translated">该 &lt;code&gt;defaultSerializer&lt;/code&gt; 属性可用于指定将通过该适配器使用的串行器。仅在未定义特定于模型的序列化器或 &lt;code&gt;serializer:application&lt;/code&gt; 时使用。</target>
        </trans-unit>
        <trans-unit id="47279489597e5ac74e3e86c13c5db07112deff0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deleteRecord&lt;/code&gt; method makes an Ajax (HTTP DELETE) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;deleteRecord&lt;/code&gt; 方法使得一个Ajax（HTTP DELETE）请求由计算的URL &lt;code&gt;buildURL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c30f86ae15c9c161bf558adf4801995e475ede16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;destroy&lt;/code&gt; queue contains jobs to finish the teardown of objects other jobs have scheduled to destroy.</source>
          <target state="translated">该 &lt;code&gt;destroy&lt;/code&gt; 队列包含作业完成对象的其他工作已经安排到破坏的拆卸。</target>
        </trans-unit>
        <trans-unit id="dec8ac796a650bf4f17575a944af8c803f7569ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;didRender&lt;/code&gt; hook is called during both render and re-render after the template has rendered and the DOM updated. You can leverage this hook to perform post-processing on the DOM of a component after it's been updated.</source>
          <target state="translated">该 &lt;code&gt;didRender&lt;/code&gt; 挂钩过程中调用都渲染和重新渲染模板已经渲染和DOM更新后。更新组件后，您可以利用此挂钩对组件的DOM进行后处理。</target>
        </trans-unit>
        <trans-unit id="58ea898b33c2a437dd96438a1f46ae35d27a088e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;didTransition&lt;/code&gt; action is fired after a transition has successfully been completed. This occurs after the normal model hooks (&lt;code&gt;beforeModel&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, &lt;code&gt;afterModel&lt;/code&gt;, &lt;code&gt;setupController&lt;/code&gt;) have resolved. The &lt;code&gt;didTransition&lt;/code&gt; action has no arguments, however, it can be useful for tracking page views or resetting state on the controller.</source>
          <target state="translated">该 &lt;code&gt;didTransition&lt;/code&gt; 的过渡已成功完成后的动作被触发。这在 &lt;code&gt;beforeModel&lt;/code&gt; 了常规模型挂钩（beforeModel， &lt;code&gt;model&lt;/code&gt; ， &lt;code&gt;afterModel&lt;/code&gt; ， &lt;code&gt;setupController&lt;/code&gt; ）之后发生。该 &lt;code&gt;didTransition&lt;/code&gt; 动作没有参数，但它可以为控制器上的追踪页面访问量或恢复状态很有用。</target>
        </trans-unit>
        <trans-unit id="d29eb3566c4cfb0d03f10d6c75bd7952980a0abf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; event</source>
          <target state="translated">该 &lt;code&gt;error&lt;/code&gt; 事件</target>
        </trans-unit>
        <trans-unit id="3dc3d2be3a232d5f74fd199e8ed0506d40b409b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errors&lt;/code&gt; property us useful for displaying error messages to the user.</source>
          <target state="translated">该 &lt;code&gt;errors&lt;/code&gt; 性质我们显示错误信息对用户有用的。</target>
        </trans-unit>
        <trans-unit id="115d726ddd808f785aca1eceaa420a26f06ecae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filter&lt;/code&gt; function is passed in by the calling object. This is a pattern known as &lt;a href=&quot;https://guides.emberjs.com/components/triggering-changes-with-actions/#toc_passing-the-action-to-the-component&quot;&gt;closure actions&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;filter&lt;/code&gt; 的功能是通过调用对象传递英寸 这是一种称为&lt;a href=&quot;https://guides.emberjs.com/components/triggering-changes-with-actions/#toc_passing-the-action-to-the-component&quot;&gt;关闭动作&lt;/a&gt;的模式。</target>
        </trans-unit>
        <trans-unit id="387361e1d1ae1eef1a52fa056d048c8cd9b110ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findAll()&lt;/code&gt; method is used to retrieve all records for a given type.</source>
          <target state="translated">该 &lt;code&gt;findAll()&lt;/code&gt; 方法用于检索给定类型的所有记录。</target>
        </trans-unit>
        <trans-unit id="602c663ac51ac56be167a8f4fb8f2bd27b6e2b2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findAll&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">所述 &lt;code&gt;findAll&lt;/code&gt; 方法使得一个Ajax（HTTP GET）请求由计算的URL &lt;code&gt;buildURL&lt;/code&gt; ，并返回所得到的有效载荷的承诺。</target>
        </trans-unit>
        <trans-unit id="ce7f071cf50d33d185134e7eba5ac98888f204a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findBelongsTo&lt;/code&gt; method will make an Ajax (HTTP GET) request to the originally specified URL.</source>
          <target state="translated">该 &lt;code&gt;findBelongsTo&lt;/code&gt; 方法将使一个Ajax（HTTP GET）请求原先指定的URL。</target>
        </trans-unit>
        <trans-unit id="f44dcd4f85b2dd0552451d53e497afcda8a7a1c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findHasMany&lt;/code&gt; method will make an Ajax (HTTP GET) request to the originally specified URL.</source>
          <target state="translated">该 &lt;code&gt;findHasMany&lt;/code&gt; 方法将使一个Ajax（HTTP GET）请求原先指定的URL。</target>
        </trans-unit>
        <trans-unit id="ae10eeaf2c63ca125251ac98e9be799c680141ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findMany&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">该 &lt;code&gt;findMany&lt;/code&gt; 方法使得一个Ajax（HTTP GET）请求由计算的URL &lt;code&gt;buildURL&lt;/code&gt; ，并返回所得到的有效载荷的承诺。</target>
        </trans-unit>
        <trans-unit id="7a08ab933ff65b656dd2d84e9309be457ddf1cf0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord()&lt;/code&gt; method is invoked when the store is asked for a record that has not previously been loaded. In response to &lt;code&gt;findRecord()&lt;/code&gt; being called, you should query your persistence layer for a record with the given ID. The &lt;code&gt;findRecord&lt;/code&gt; method should return a promise that will resolve to a JavaScript object that will be normalized by the serializer.</source>
          <target state="translated">该 &lt;code&gt;findRecord()&lt;/code&gt; 当商店被要求为先前没有被加载的记录方法被调用。作为对 &lt;code&gt;findRecord()&lt;/code&gt; 的响应，您应该在持久层中查询具有给定ID的记录。该 &lt;code&gt;findRecord&lt;/code&gt; 方法应该返回将解析将由串行器归一化的JavaScript对象的承诺。</target>
        </trans-unit>
        <trans-unit id="4a203cdf205b6bed873c25d04719c09b1c068376" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord&lt;/code&gt; method makes an Ajax request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">该 &lt;code&gt;findRecord&lt;/code&gt; 方法使得Ajax请求到由计算的URL &lt;code&gt;buildURL&lt;/code&gt; ，并返回所得到的有效载荷的承诺。</target>
        </trans-unit>
        <trans-unit id="d296cef402c6e9fdee3e60b6eab8186006e33659" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord&lt;/code&gt; method will always resolve its promise with the same object for a given type and &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">对于给定的类型和 &lt;code&gt;id&lt;/code&gt; ， &lt;code&gt;findRecord&lt;/code&gt; 方法将始终使用相同的对象来解决其诺言。</target>
        </trans-unit>
        <trans-unit id="8946fd1a72779985021b67a58d0554338af6fd98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;findRecord&lt;/code&gt; method will always return a &lt;strong&gt;promise&lt;/strong&gt; that will be resolved with the record.</source>
          <target state="translated">该 &lt;code&gt;findRecord&lt;/code&gt; 方法将总是返回&lt;strong&gt;承诺&lt;/strong&gt;，将与记录来解决。</target>
        </trans-unit>
        <trans-unit id="70a1277075e83917b1e91129c777128de706c278" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; properties are read from the context (the application controller in this case), and rendered inside the &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; HTML tag.</source>
          <target state="translated">所述 &lt;code&gt;firstName&lt;/code&gt; 和 &lt;code&gt;lastName&lt;/code&gt; 的属性是从上下文（在这种情况下，应用控制器）读取，并且内呈现 &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; HTML标签。</target>
        </trans-unit>
        <trans-unit id="e2cd1e74db759e699d89efeb874150a69a9ce052" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;generateIdForRecord()&lt;/code&gt; method will be invoked with the requesting store as the first parameter and the newly created record as the second parameter:</source>
          <target state="translated">所述 &lt;code&gt;generateIdForRecord()&lt;/code&gt; 方法将与请求存储作为第一个参数和新创建的记录的第二个参数被调用：</target>
        </trans-unit>
        <trans-unit id="9d6dcd303e28c2f50e7fa209f969128e6c261668" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hash&lt;/code&gt; option uses the URL's anchor to load the starting state of your application and will keep it in sync as you move around. At present, this relies on a &lt;a href=&quot;http://caniuse.com/hashchange&quot;&gt;hashchange&lt;/a&gt; event existing in the browser.</source>
          <target state="translated">该 &lt;code&gt;hash&lt;/code&gt; 选项使用URL的锚加载应用程序的起始状态，并保持同步，你走动。目前，这依赖于浏览器中存在的&lt;a href=&quot;http://caniuse.com/hashchange&quot;&gt;hashchange&lt;/a&gt;事件。</target>
        </trans-unit>
        <trans-unit id="efb3ddd1dd864b1ccd297455ce4d0857982f5192" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;namespace&lt;/code&gt; attributes will be used if defined, and are optional.</source>
          <target state="translated">该 &lt;code&gt;host&lt;/code&gt; 和 &lt;code&gt;namespace&lt;/code&gt; ，如果定义的属性将被使用，并且是可选的。</target>
        </trans-unit>
        <trans-unit id="726d76cd26c3550c4a16d511675ea50195fe236a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of the record that this reference refers to.</source>
          <target state="translated">该引用引用的记录的 &lt;code&gt;id&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e484f981133bd6e9e051ecd67de8179c1ab49e1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id&lt;/code&gt; of the record that this reference refers to. Together, the &lt;code&gt;type()&lt;/code&gt; and &lt;code&gt;id()&lt;/code&gt; methods form a composite key for the identity map. This can be used to access the id of an async relationship without triggering a fetch that would normally happen if you attempted to use &lt;code&gt;record.get('relationship.id')&lt;/code&gt;.</source>
          <target state="translated">该引用引用的记录的 &lt;code&gt;id&lt;/code&gt; 。在一起时， &lt;code&gt;type()&lt;/code&gt; 和 &lt;code&gt;id()&lt;/code&gt; 方法形成用于恒等映射的复合密钥。这可用于访问异步关系的ID，而不会触发通常在您尝试使用 &lt;code&gt;record.get('relationship.id')&lt;/code&gt; 时发生的提取。</target>
        </trans-unit>
        <trans-unit id="0b8ddb4404d56063acf9b99af25e8cc6e7326302" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; helper allows you to conditionally render one of two branches, depending on the &quot;truthiness&quot; of a property. For example the following values are all falsey: &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;undefined&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;&quot;&quot;&lt;/code&gt;, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; or an empty array.</source>
          <target state="translated">该 &lt;code&gt;if&lt;/code&gt; 助手允许有条件地呈现两个分支之一，这取决于物业的&amp;ldquo;感实性&amp;rdquo;。例如，以下值均为 &lt;code&gt;false&lt;/code&gt; ：false， &lt;code&gt;undefined&lt;/code&gt; ， &lt;code&gt;null&lt;/code&gt; ， &lt;code&gt;&quot;&quot;&lt;/code&gt; ， &lt;code&gt;0&lt;/code&gt; ， &lt;code&gt;NaN&lt;/code&gt; 或空数组。</target>
        </trans-unit>
        <trans-unit id="7f533c5c4a9490cabd083312090b309dba8b8080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; route, which we've set up to redirect to the &lt;code&gt;rentals&lt;/code&gt; route.</source>
          <target state="translated">该 &lt;code&gt;index&lt;/code&gt; 的路线，我们已经建立了重定向到 &lt;code&gt;rentals&lt;/code&gt; 路线。</target>
        </trans-unit>
        <trans-unit id="a37a3988ddfb70864ed4f197d72873cd75421874" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; template will be rendered into the &lt;code&gt;{{outlet}}&lt;/code&gt; in the &lt;code&gt;application&lt;/code&gt; template. If the user navigates to &lt;code&gt;/favorites&lt;/code&gt;, Ember will replace the &lt;code&gt;index&lt;/code&gt; template with the &lt;code&gt;favorites&lt;/code&gt; template.</source>
          <target state="translated">该 &lt;code&gt;index&lt;/code&gt; 模板将被渲染到 &lt;code&gt;{{outlet}}&lt;/code&gt; 在 &lt;code&gt;application&lt;/code&gt; 模板。如果用户导航到 &lt;code&gt;/favorites&lt;/code&gt; ，子玉将取代 &lt;code&gt;index&lt;/code&gt; 与模板 &lt;code&gt;favorites&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="894fed72e604e69d2c832ed37e77607f8aedfc96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isDone&lt;/code&gt; property of any of the objects in the &lt;code&gt;todos&lt;/code&gt; array changes.</source>
          <target state="translated">&lt;code&gt;todos&lt;/code&gt; 数组中任何对象的 &lt;code&gt;isDone&lt;/code&gt; 属性都会更改。</target>
        </trans-unit>
        <trans-unit id="2e33c9e0c11bc81e1d1a61b55510989fd637ce87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key-up&lt;/code&gt; property will be bound to the &lt;code&gt;handleFilterEntry&lt;/code&gt; action.</source>
          <target state="translated">该 &lt;code&gt;key-up&lt;/code&gt; 属性将被绑定到 &lt;code&gt;handleFilterEntry&lt;/code&gt; 行动。</target>
        </trans-unit>
        <trans-unit id="936bd94b4aebf6a1e14654f35827f1ee229e7066" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; option is used to tell Ember how to determine if the array being iterated over with &lt;code&gt;{{#each}}&lt;/code&gt; has changed between renders. By helping Ember detect that some elements in the array are the same, DOM elements can be re-used, significantly improving rendering speed.</source>
          <target state="translated">该 &lt;code&gt;key&lt;/code&gt; 选项用于告诉灰烬如何确定阵列上迭代与 &lt;code&gt;{{#each}}&lt;/code&gt; 改变渲染之间。通过帮助Ember检测到数组中的某些元素相同，可以重复使用DOM元素，从而显着提高渲染速度。</target>
        </trans-unit>
        <trans-unit id="a8f5fca5b000aac4891ae81f3df31b8436f67cee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link-to&lt;/code&gt; helper supports specifying query params using the &lt;code&gt;query-params&lt;/code&gt; subexpression helper.</source>
          <target state="translated">该 &lt;code&gt;link-to&lt;/code&gt; 帮助支持指定使用查询参数 &lt;code&gt;query-params&lt;/code&gt; 子表达式帮手。</target>
        </trans-unit>
        <trans-unit id="1769aac2882e47d76fb4a9a01749791965335a0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link-to&lt;/code&gt; helper takes into account query parameters when determining its &quot;active&quot; state, and will set the class appropriately. The active state is determined by calculating whether the query params end up the same after clicking a link. You don't have to supply all of the current, active query params for this to be true.</source>
          <target state="translated">的 &lt;code&gt;link-to&lt;/code&gt; 确定其&amp;ldquo;活动&amp;rdquo;状态时辅助考虑到查询参数，并且将适当地设置的类。通过计算单击链接后查询参数是否最终相同来确定活动状态。您不必提供所有当前的活动查询参数即可。</target>
        </trans-unit>
        <trans-unit id="ce7461f1dc052dfdd78139e56ef3705e2ee872bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;live-updating-chart&lt;/code&gt; component will be appended when &lt;code&gt;isMarketOpen&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and the &lt;code&gt;market-close-summary&lt;/code&gt; component will be appended when &lt;code&gt;isMarketOpen&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. If the value changes while the app is running, the component will be automatically swapped out accordingly. Note: You should not use this helper when you are consistently rendering the same component. In that case, use standard component syntax, for example:</source>
          <target state="translated">在 &lt;code&gt;live-updating-chart&lt;/code&gt; 时，组件将被追加 &lt;code&gt;isMarketOpen&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ，和 &lt;code&gt;market-close-summary&lt;/code&gt; 时，组件将被追加 &lt;code&gt;isMarketOpen&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。如果在应用程序运行时该值发生更改，该组件将相应地自动换出。注意：始终渲染同一组件时，不应使用此帮助程序。在这种情况下，请使用标准组件语法，例如：</target>
        </trans-unit>
        <trans-unit id="d5bb787fdea75d1b00a27bb3674ec987c8aaa6ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loading&lt;/code&gt; action is fired on the route when a route's &lt;code&gt;model&lt;/code&gt; hook returns a promise that is not already resolved. The current &lt;code&gt;Transition&lt;/code&gt; object is the first parameter and the route that triggered the loading event is the second parameter.</source>
          <target state="translated">在 &lt;code&gt;loading&lt;/code&gt; 时，路由的行动路线上的发射 &lt;code&gt;model&lt;/code&gt; 钩子返回一个尚未解决的承诺。当前的 &lt;code&gt;Transition&lt;/code&gt; 对象是第一个参数，触发加载事件的路由是第二个参数。</target>
        </trans-unit>
        <trans-unit id="62709da4cb7722dd75455fa1b4a1e73beda37c01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loading&lt;/code&gt; event</source>
          <target state="translated">在 &lt;code&gt;loading&lt;/code&gt; 事件</target>
        </trans-unit>
        <trans-unit id="51f4b8a7cab225c00b8bad7fe9f237a843ec218c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;location&lt;/code&gt; property determines the type of URL's that your application will use.</source>
          <target state="translated">该 &lt;code&gt;location&lt;/code&gt; 属性决定URL类型的应用程序将使用。</target>
        </trans-unit>
        <trans-unit id="9eb2d558c702885a649840fb36c05bc2fa210e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max&lt;/code&gt; attribute of input element used with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; or &lt;code&gt;type=&quot;range&quot;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; 或 &lt;code&gt;type=&quot;range&quot;&lt;/code&gt; 一起使用的输入元素的 &lt;code&gt;max&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="761d8a8dfab983312074a19ca9afd183bd59ab2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; attribute of input element used with &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; or &lt;code&gt;type=&quot;range&quot;&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;type=&quot;number&quot;&lt;/code&gt; 或 &lt;code&gt;type=&quot;range&quot;&lt;/code&gt; 一起使用的输入元素的 &lt;code&gt;min&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="6a16647d6821ede1b677029aeacce468053baa77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;model&lt;/code&gt;, &lt;code&gt;beforeModel&lt;/code&gt;, and &lt;code&gt;afterModel&lt;/code&gt; hooks described in &lt;a href=&quot;../asynchronous-routing&quot;&gt;Asynchronous Routing&lt;/a&gt; each get called with a transition object. This makes it possible for destination routes to abort attempted transitions.</source>
          <target state="translated">&lt;a href=&quot;../asynchronous-routing&quot;&gt;异步路由中&lt;/a&gt;描述的 &lt;code&gt;model&lt;/code&gt; ， &lt;code&gt;beforeModel&lt;/code&gt; 和 &lt;code&gt;afterModel&lt;/code&gt; 挂钩分别通过转换对象调用。这使得目标路由可以中止尝试的转换。</target>
        </trans-unit>
        <trans-unit id="7a07d77d0d198d3536ee44ea45215a0d56f6c718" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;moduleForComponent&lt;/code&gt; helper will find the component by name (&lt;code&gt;pretty-color&lt;/code&gt;) and its template (if available). Make sure to set &lt;code&gt;integration: true&lt;/code&gt; to enable integration test capability.</source>
          <target state="translated">该 &lt;code&gt;moduleForComponent&lt;/code&gt; 助手将找到名称（组件 &lt;code&gt;pretty-color&lt;/code&gt; ）和它的模板（如果可用）。确保设置 &lt;code&gt;integration: true&lt;/code&gt; 以启用集成测试功能。</target>
        </trans-unit>
        <trans-unit id="644ef1f7a187d6716007454db3fc278899d36342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper changes the &lt;code&gt;totalClicks&lt;/code&gt; value to what was provided as the action argument.</source>
          <target state="translated">该 &lt;code&gt;mut&lt;/code&gt; 帮手改变 &lt;code&gt;totalClicks&lt;/code&gt; 值什么作为动作参数提供。</target>
        </trans-unit>
        <trans-unit id="edbf9526f6f8f8b4f51d74862e43afb24dca9baa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper lets you &lt;strong&gt;clearly specify&lt;/strong&gt; that a child &lt;code&gt;Component&lt;/code&gt; can update the (mutable) value passed to it, which will &lt;strong&gt;change the value of the parent component&lt;/strong&gt;.</source>
          <target state="translated">该 &lt;code&gt;mut&lt;/code&gt; 助手可以让你&lt;strong&gt;清楚地说明&lt;/strong&gt;，一个孩子 &lt;code&gt;Component&lt;/code&gt; 可以更新传递给它的（可变）值，这将&lt;strong&gt;改变父组件的价值&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="47f4565230c7ebd7ee1ea8d2cea1cd329802f14d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mut&lt;/code&gt; helper, when used with &lt;code&gt;action&lt;/code&gt;, will return a function that sets the value passed to &lt;code&gt;mut&lt;/code&gt; to its first argument. This works like any other closure action and interacts with the other features &lt;code&gt;action&lt;/code&gt; provides. As an example, we can create a button that increments a value passing the value directly to the &lt;code&gt;action&lt;/code&gt;:</source>
          <target state="translated">该 &lt;code&gt;mut&lt;/code&gt; 帮手，当用于 &lt;code&gt;action&lt;/code&gt; ，将返回一个函数，将值传递给 &lt;code&gt;mut&lt;/code&gt; 它的第一个参数。该工作方式与其他任何关闭操作一样，并与 &lt;code&gt;action&lt;/code&gt; 提供的其他功能交互。例如，我们可以创建一个按钮来增加一个值，将值直接传递给 &lt;code&gt;action&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4e89da7babb87da3e213ca546f7a89e9c5ec5c0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;namespace&lt;/code&gt; property can be used to prefix requests with a specific url namespace.</source>
          <target state="translated">该 &lt;code&gt;namespace&lt;/code&gt; 属性可以用于前缀与特定的URL命名空间的请求。</target>
        </trans-unit>
        <trans-unit id="bfed5d466aa02a365425fe10dfe05ec1cbdf595d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; command generates a project structure with the following files and directories:</source>
          <target state="translated">在 &lt;code&gt;new&lt;/code&gt; 命令生成包含以下文件和目录的项目结构：</target>
        </trans-unit>
        <trans-unit id="ed24ef77b982f52329f6db5f8b171af6032be5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;newValue&lt;/code&gt; parameter thus becomes the &lt;code&gt;target.value&lt;/code&gt; property of the event object, which is the value of the input field the user typed. (e.g 'Foo Fighters')</source>
          <target state="translated">因此， &lt;code&gt;newValue&lt;/code&gt; 参数成为事件对象的 &lt;code&gt;target.value&lt;/code&gt; 属性，它是用户键入的输入字段的值。（例如&amp;ldquo; Foo Fighters&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="3b9f3dead33374ca86a671206cb69b9ea69de17d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalize&lt;/code&gt; method is used to convert a payload received from your external data source into the normalized form &lt;code&gt;store.push()&lt;/code&gt; expects. You should override this method, munge the hash and return the normalized payload.</source>
          <target state="translated">的 &lt;code&gt;normalize&lt;/code&gt; 方法用于从外部数据源接收的有效载荷转换成归一化的形式 &lt;code&gt;store.push()&lt;/code&gt; 的期望。您应该重写此方法，修改哈希值并返回标准化的有效负载。</target>
        </trans-unit>
        <trans-unit id="20e85f3eb6d6503ba01eeae172d760d7f90937b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalize&lt;/code&gt; method will be called three times:</source>
          <target state="translated">该 &lt;code&gt;normalize&lt;/code&gt; 方法将被调用了三次：</target>
        </trans-unit>
        <trans-unit id="1d0fd3bcdefae28cf2e583c51b6f6f637f4b37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;normalizeResponse&lt;/code&gt; method is used to normalize a payload from the server to a JSON-API Document.</source>
          <target state="translated">该 &lt;code&gt;normalizeResponse&lt;/code&gt; 方法用于从服务器向一个JSON-API文献正常化的有效载荷。</target>
        </trans-unit>
        <trans-unit id="0c2db818043d2ecfecb9f10542f615aa9bab50e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;observes&lt;/code&gt; extension of Javascript's Function prototype is available when &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; is true, which is the default.</source>
          <target state="translated">该 &lt;code&gt;observes&lt;/code&gt; JavaScript的函数原型的扩展时可用 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 或 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; 是真实的，这是默认的。</target>
        </trans-unit>
        <trans-unit id="0f03013d375dee1ad0017ee24be6c12bc6613607" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;on&lt;/code&gt; extension of Javascript's Function prototype is available when &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; is true, which is the default.</source>
          <target state="translated">当 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 或 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; 为true时，可以使用Java函数原型的 &lt;code&gt;on&lt;/code&gt; 扩展，这是默认设置。</target>
        </trans-unit>
        <trans-unit id="297b35be5fa3a29b2bfdd9b1aca553208fd9387a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; hash is passed as second argument to a transforms' &lt;code&gt;serialize&lt;/code&gt; and &lt;code&gt;deserialize&lt;/code&gt; method. This allows to configure a transformation and adapt the corresponding value, based on the config:</source>
          <target state="translated">该 &lt;code&gt;options&lt;/code&gt; 散列作为第二个参数的变换传递 &lt;code&gt;serialize&lt;/code&gt; 和 &lt;code&gt;deserialize&lt;/code&gt; 方法。这允许基于config配置转换并调整相应的值：</target>
        </trans-unit>
        <trans-unit id="a48eca6e5279e14ea0ca6e2582655554ba9b2b05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;partial&lt;/code&gt; helper renders another template without changing the template context:</source>
          <target state="translated">该 &lt;code&gt;partial&lt;/code&gt; 的辅助渲染另一个模板而不更改模板背景：</target>
        </trans-unit>
        <trans-unit id="9dab6744a08664ce82b1d25a8cd8dabeafdb4d4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; attribute of input element.</source>
          <target state="translated">输入元素的 &lt;code&gt;pattern&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="beed0cd468b2c43cc334c3ee15857caebfa7e869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;person&lt;/code&gt; model we generated earlier didn't have any attributes. Let's add first and last name, as well as the birthday, using &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.html#method_attr&quot;&gt;&lt;code&gt;DS.attr&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">我们之前生成的 &lt;code&gt;person&lt;/code&gt; 模型没有任何属性。让我们使用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.html#method_attr&quot;&gt; &lt;code&gt;DS.attr&lt;/code&gt; &lt;/a&gt;添加名字和姓氏以及生日：</target>
        </trans-unit>
        <trans-unit id="c726fa5adf1c99c0bbb0555060826f16888f5c7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;primaryKey&lt;/code&gt; is used when serializing and deserializing data. Ember Data always uses the &lt;code&gt;id&lt;/code&gt; property to store the id of the record. The external source may not always follow this convention. In these cases it is useful to override the &lt;code&gt;primaryKey&lt;/code&gt; property to match the &lt;code&gt;primaryKey&lt;/code&gt; of your external store.</source>
          <target state="translated">所述 &lt;code&gt;primaryKey&lt;/code&gt; 序列化和反序列化数据时使用。灰烬数据始终使用 &lt;code&gt;id&lt;/code&gt; 属性存储记录的ID。外部来源可能并不总是遵循此约定。在这些情况下，重写 &lt;code&gt;primaryKey&lt;/code&gt; 属性以匹配外部存储的 &lt;code&gt;primaryKey&lt;/code&gt; 很有用。</target>
        </trans-unit>
        <trans-unit id="1ddda9eaba646249c47555954c9e00b3441e3959" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;property&lt;/code&gt; extension of Javascript's Function prototype is available when &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which is the default.</source>
          <target state="translated">当 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 或 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Function&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，可以使用Javascript函数原型的 &lt;code&gt;property&lt;/code&gt; 扩展名，这是默认值。</target>
        </trans-unit>
        <trans-unit id="741ea22ea557846205bbcb6432415861ed43b265" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;push()&lt;/code&gt; method is also important when working with complex endpoints. You may find your application has an endpoint that performs some business logic then creates several records. This likely does not map cleanly to Ember Data's existing &lt;code&gt;save()&lt;/code&gt; API which is structured around persisting a single record. Instead you should make your own custom AJAX request and push the resulting model data into the store so it can be accessed by other parts of your application.</source>
          <target state="translated">当处理复杂的端点时， &lt;code&gt;push()&lt;/code&gt; 方法也很重要。您可能会发现您的应用程序具有执行某些业务逻辑的端点，然后创建了多个记录。这可能无法清晰地映射到Ember Data现有的 &lt;code&gt;save()&lt;/code&gt; API，该API是围绕持久保存一条记录而构造的。相反，您应该提出自己的自定义AJAX请求，并将结果模型数据推送到存储中，以便应用程序的其他部分可以访问它们。</target>
        </trans-unit>
        <trans-unit id="aba7f7dcf3bc1a43f03c260d10824580744e938c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query()&lt;/code&gt; and &lt;code&gt;queryRecord()&lt;/code&gt; methods each take a &lt;code&gt;query&lt;/code&gt; argument that is serialized directly into the URL query string and the &lt;code&gt;include&lt;/code&gt; parameter may form part of that argument. For example:</source>
          <target state="translated">的 &lt;code&gt;query()&lt;/code&gt; 和 &lt;code&gt;queryRecord()&lt;/code&gt; 的每个方法都有一个 &lt;code&gt;query&lt;/code&gt; 是直接序列化到URL查询字符串和参数 &lt;code&gt;include&lt;/code&gt; 参数可形成参数的一部分。例如：</target>
        </trans-unit>
        <trans-unit id="40ae82990914385fed7743c850d721020c13355a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query-params&lt;/code&gt; helper can be used to set query params on a link:</source>
          <target state="translated">该 &lt;code&gt;query-params&lt;/code&gt; 助手可用于链路上的一组查询参数：</target>
        </trans-unit>
        <trans-unit id="a8fe29792accf52f26efa3e35355502b262e7a69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query&lt;/code&gt; argument is a simple JavaScript object that will be passed directly to the server as parameters.</source>
          <target state="translated">该 &lt;code&gt;query&lt;/code&gt; 的说法是，将直接传递到服务器作为参数的简单的JavaScript对象。</target>
        </trans-unit>
        <trans-unit id="3bceeb7be0a9c6e0f887c2b26aab4a16695618f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;query&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">该 &lt;code&gt;query&lt;/code&gt; 方法使得一个Ajax（HTTP GET）请求由计算的URL &lt;code&gt;buildURL&lt;/code&gt; ，并返回所得到的有效载荷的承诺。</target>
        </trans-unit>
        <trans-unit id="ac86f04028c107b848f45d261d4b4fb39028dabb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queryRecord()&lt;/code&gt; method is invoked when the store is asked for a single record through a query object.</source>
          <target state="translated">所述 &lt;code&gt;queryRecord()&lt;/code&gt; 当商店被要求用于通过查询对象的单个记录方法被调用。</target>
        </trans-unit>
        <trans-unit id="5f566f5912a6205cfc53d29bb1ff422d225d2210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;queryRecord&lt;/code&gt; method makes an Ajax (HTTP GET) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;, and returns a promise for the resulting payload.</source>
          <target state="translated">该 &lt;code&gt;queryRecord&lt;/code&gt; 方法使得一个Ajax（HTTP GET）请求由计算的URL &lt;code&gt;buildURL&lt;/code&gt; ，并返回所得到的有效载荷的承诺。</target>
        </trans-unit>
        <trans-unit id="d4ea793c0781cfc5c0cec6bad75f521580c0c469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; queue contains jobs meant for rendering, these will typically update the DOM.</source>
          <target state="translated">在 &lt;code&gt;render&lt;/code&gt; 队列包含的意思进行渲染，这些通常会更新DOM工作。</target>
        </trans-unit>
        <trans-unit id="c7f84a235783d75983b71d54f1ff2d957db34aa0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rental_id&lt;/code&gt; will now be passed to the route.</source>
          <target state="translated">现在， &lt;code&gt;rental_id&lt;/code&gt; 将传递到路线。</target>
        </trans-unit>
        <trans-unit id="2ab02947d511f36cd80dcd1ce1d3df5d48a3288d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rootElement&lt;/code&gt; can be either a DOM element or a jQuery-compatible selector string. Note that &lt;em&gt;views appended to the DOM outside the root element will not receive events.&lt;/em&gt; If you specify a custom root element, make sure you only append views inside it!</source>
          <target state="translated">的 &lt;code&gt;rootElement&lt;/code&gt; 的可以是DOM元素或一个jQuery兼容选择字符串。请注意，&lt;em&gt;附加到根元素外部的DOM的视图将不会接收事件。&lt;/em&gt;如果指定自定义根元素，请确保仅在其中添加视图！</target>
        </trans-unit>
        <trans-unit id="6cb53ef77e44dde0ccc9cdeab769f0e6ab2e0202" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;routerTransitions&lt;/code&gt; queue contains transition jobs in the router.</source>
          <target state="translated">该 &lt;code&gt;routerTransitions&lt;/code&gt; 队列包含在路由器过渡工作。</target>
        </trans-unit>
        <trans-unit id="914db6574906c68800e0d33d2e398128993fa468" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; action handler would be called with a single argument containing the post model:</source>
          <target state="translated">在 &lt;code&gt;select&lt;/code&gt; 操作处理程序将使用一个包含Post模型的单一参数来调用：</target>
        </trans-unit>
        <trans-unit id="df2eb6d01d9ec8f4cdf6e2424d4b714982ede9b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sender&lt;/code&gt; is the object that changed. The &lt;code&gt;key&lt;/code&gt; is the property that changes. The &lt;code&gt;value&lt;/code&gt; property is currently reserved and unused. The &lt;code&gt;rev&lt;/code&gt; is the last property revision of the object when it changed, which you can use to detect if the key value has really changed or not.</source>
          <target state="translated">的 &lt;code&gt;sender&lt;/code&gt; 是改变的对象。的 &lt;code&gt;key&lt;/code&gt; 是改变性质。该 &lt;code&gt;value&lt;/code&gt; 酒店目前保留的和未使用。该 &lt;code&gt;rev&lt;/code&gt; 是当它改变了对象，你可以用它来检测，如果该键值确实改变与否的最后一个属性的修订。</target>
        </trans-unit>
        <trans-unit id="320d415a375ebee02086a1803913992fa35a52e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;serialize&lt;/code&gt; and &lt;code&gt;deserialize&lt;/code&gt; keys support 3 values:</source>
          <target state="translated">该 &lt;code&gt;serialize&lt;/code&gt; 和 &lt;code&gt;deserialize&lt;/code&gt; 键支持3个值：</target>
        </trans-unit>
        <trans-unit id="6f25c439a903f72adbb9b751611fc24318fc0bef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;serialize&lt;/code&gt; method is used when a record is saved in order to convert the record into the form that your external data source expects.</source>
          <target state="translated">在 &lt;code&gt;serialize&lt;/code&gt; 时保存记录，以记录转换成您的外部数据源预计形式使用的方法。</target>
        </trans-unit>
        <trans-unit id="ca79fc713fd97bd184a81e559e72c3c10e563ff9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set&lt;/code&gt; function should accept two parameters, &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;. The value returned from &lt;code&gt;set&lt;/code&gt; will be the new value of the property.</source>
          <target state="translated">该 &lt;code&gt;set&lt;/code&gt; 函数应接受两个参数， &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 。从 &lt;code&gt;set&lt;/code&gt; 返回的值将是该属性的新值。</target>
        </trans-unit>
        <trans-unit id="e2b783248728ef736c417d1b8a02ac7a76ba4c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setProps&lt;/code&gt; action directly sets one property, and calls the method to set the other. In our generated test, ember-cli already uses the &lt;code&gt;moduleFor&lt;/code&gt; helper to set up a test container:</source>
          <target state="translated">该 &lt;code&gt;setProps&lt;/code&gt; 动作直接设置一个属性，并调用设置其他的方法。在我们生成的测试中，ember-cli已经使用 &lt;code&gt;moduleFor&lt;/code&gt; 助手来设置测试容器：</target>
        </trans-unit>
        <trans-unit id="a7a5bc8047dfc31a806acf70a107363435688016" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signUp&lt;/code&gt; action is simply a function defined on the &lt;code&gt;actions&lt;/code&gt; hash of a component. Since the action is assigned to an inline handler, the function definition can define the event object as its first parameter.</source>
          <target state="translated">的 &lt;code&gt;signUp&lt;/code&gt; 动作是简单地在所定义的功能 &lt;code&gt;actions&lt;/code&gt; 散列一个组分。由于操作已分配给内联处理程序，因此函数定义可以将事件对象定义为其第一个参数。</target>
        </trans-unit>
        <trans-unit id="905ce447cd074e63c0b217b907cdbd799228dbdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; of the text field in characters.</source>
          <target state="translated">文本字段的 &lt;code&gt;size&lt;/code&gt; （以字符为单位）。</target>
        </trans-unit>
        <trans-unit id="60ce209fb9d274970aad161ade621ac9ba4ac11c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;store&lt;/code&gt; property is the application's &lt;code&gt;store&lt;/code&gt; that contains all records. It can be used to look up serializers for other model types that may be nested inside the payload response.</source>
          <target state="translated">该 &lt;code&gt;store&lt;/code&gt; 属性是应用程序的 &lt;code&gt;store&lt;/code&gt; ，它包含的所有记录。它可用于查找可能嵌套在有效负载响应中的其他模型类型的序列化器。</target>
        </trans-unit>
        <trans-unit id="296139528fe79390dc0a604c903db62d7f189968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sync&lt;/code&gt; queue contains binding synchronization jobs.</source>
          <target state="translated">在 &lt;code&gt;sync&lt;/code&gt; 队列包含结合同步作业。</target>
        </trans-unit>
        <trans-unit id="3ff37492a4d1b522cbb2957ffd8cce10aa8ee652" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;todos&lt;/code&gt; property of the component is changed to a different array.</source>
          <target state="translated">组件的 &lt;code&gt;todos&lt;/code&gt; 属性更改为另一个数组。</target>
        </trans-unit>
        <trans-unit id="131b771f6ba43c138d365e36164154f5cb2e8c6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; attribute of the input element.</source>
          <target state="translated">输入元素的 &lt;code&gt;type&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="4c5bc75c3e6f8899fec6ea16cb876d5a2fdd47fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unbound&lt;/code&gt; helper only accepts a single argument, and it return an unbound value.</source>
          <target state="translated">将 &lt;code&gt;unbound&lt;/code&gt; 助手只接受一个参数，并返回一个未绑定的值。</target>
        </trans-unit>
        <trans-unit id="efdf958209e8428c763eee6028027f027891e782" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;updateRecord&lt;/code&gt; method serializes the record and makes an Ajax (HTTP PUT) request to a URL computed by &lt;code&gt;buildURL&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;updateRecord&lt;/code&gt; 方法序列化记录并使得一个Ajax（HTTP PUT）请求由计算的URL &lt;code&gt;buildURL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b6470eade078efa5a7597b68a9c894e7656a268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; attribute of the input element. As the user inputs text, this property is updated live.</source>
          <target state="translated">输入元素的 &lt;code&gt;value&lt;/code&gt; 属性。当用户输入文本时，此属性将实时更新。</target>
        </trans-unit>
        <trans-unit id="89d5c88cd2756f1f000db7d6ac6178bf03b70a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wait&lt;/code&gt; helper is built into &lt;code&gt;registerAsyncHelper&lt;/code&gt; by default. You will not need to &lt;code&gt;return app.testHelpers.wait();&lt;/code&gt; - the wait behavior is provided for you.</source>
          <target state="translated">默认情况下， &lt;code&gt;wait&lt;/code&gt; helper内置在 &lt;code&gt;registerAsyncHelper&lt;/code&gt; 中。您无需 &lt;code&gt;return app.testHelpers.wait();&lt;/code&gt; -为您提供了等待行为。</target>
        </trans-unit>
        <trans-unit id="2a3d56e189d128908470bf74976b11ba03b8229c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;willTransition&lt;/code&gt; action is fired at the beginning of any attempted transition with a &lt;code&gt;Transition&lt;/code&gt; object as the sole argument. This action can be used for aborting, redirecting, or decorating the transition from the currently active routes.</source>
          <target state="translated">该 &lt;code&gt;willTransition&lt;/code&gt; 动作在与任何试图转变的开始解雇 &lt;code&gt;Transition&lt;/code&gt; 对象作为唯一的参数。此操作可用于中止，重定向或修饰从当前活动路由的过渡。</target>
        </trans-unit>
        <trans-unit id="816958a0f032f49a594b1d8da2c79bf4235daf44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{#each}}&lt;/code&gt; helper loops over elements in a collection. It is an extension of the base Handlebars &lt;code&gt;{{#each}}&lt;/code&gt; helper. The default behavior of &lt;code&gt;{{#each}}&lt;/code&gt; is to yield its inner block once for every item in an array passing the item as the first block parameter.</source>
          <target state="translated">该 &lt;code&gt;{{#each}}&lt;/code&gt; 帮手遍历集合中的元素。它是基础Handlebars &lt;code&gt;{{#each}}&lt;/code&gt; 帮助程序的扩展。 &lt;code&gt;{{#each}}&lt;/code&gt; 的默认行为是，将数组中的每个项目作为第一个块参数传递给该项目，以一次产生其内部块。</target>
        </trans-unit>
        <trans-unit id="c79d6054773867f3779b96924372f54a35225401" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{action}}&lt;/code&gt; helper provides a way to pass triggers for behavior (usually just a function) between components, and into components from controllers.</source>
          <target state="translated">的 &lt;code&gt;{{action}}&lt;/code&gt; 助手提供了一种方式来传递部件之间，用于行为触发（通常只是一个函数），并且进入从控制器组件。</target>
        </trans-unit>
        <trans-unit id="2188ae955717f0311ee55bfeb274d37ec4fab50a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{component}}&lt;/code&gt; helper lets you add instances of &lt;code&gt;Ember.Component&lt;/code&gt; to a template. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember.Component&lt;/a&gt; for additional information on how a &lt;code&gt;Component&lt;/code&gt; functions. &lt;code&gt;{{component}}&lt;/code&gt;'s primary use is for cases where you want to dynamically change which type of component is rendered as the state of your application changes. This helper has three modes: inline, block, and nested.</source>
          <target state="translated">使用 &lt;code&gt;{{component}}&lt;/code&gt; 帮助程序，您可以将 &lt;code&gt;Ember.Component&lt;/code&gt; 实例添加到模板中。有关 &lt;code&gt;Component&lt;/code&gt; 如何工作的其他信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Component.html&quot;&gt;Ember.Component&lt;/a&gt;。 &lt;code&gt;{{component}}&lt;/code&gt; 的主要用途是要在应用程序状态更改时动态更改要呈现的组件类型的情况。该帮助器具有三种模式：内联，块和嵌套。</target>
        </trans-unit>
        <trans-unit id="ccb3abeccf1d3935a6c118b1810a1a10f67f5fd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{each-in}}&lt;/code&gt; helper loops over properties on an object.</source>
          <target state="translated">的 &lt;code&gt;{{each-in}}&lt;/code&gt; 辅助环上的对象的属性。</target>
        </trans-unit>
        <trans-unit id="3212095109428b4cbc3365440b62953596163903" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{get}}&lt;/code&gt; helper allows you to dynamically specify which property to bind, while the &lt;code&gt;{{mut}}&lt;/code&gt; helper allows the binding to be updated from the input. See the respective helper documentation for more detail.</source>
          <target state="translated">该 &lt;code&gt;{{get}}&lt;/code&gt; 助手允许你动态地指定属性的绑定，而 &lt;code&gt;{{mut}}&lt;/code&gt; 助手允许的结合从输入更新。有关更多详细信息，请参见相应的帮助程序文档。</target>
        </trans-unit>
        <trans-unit id="3b4f5775189e04e5beb9481aaf74caccbff888df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{get}}&lt;/code&gt; helper can also respect mutable values itself. For example:</source>
          <target state="translated">该 &lt;code&gt;{{get}}&lt;/code&gt; 帮手也可以尊重可变值本身。例如：</target>
        </trans-unit>
        <trans-unit id="bd0b47992fc4b78b9df9bbf1e6731c7ed45259f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{input}}&lt;/code&gt; helper lets you create an HTML &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; component. It causes an &lt;code&gt;Ember.TextField&lt;/code&gt; component to be rendered. For more info, see the &lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;Ember.TextField&lt;/a&gt; docs and the &lt;a href=&quot;https://emberjs.com/guides/templates/input-helpers/&quot;&gt;templates guide&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;{{input}}&lt;/code&gt; 帮助程序，您可以创建HTML &lt;code&gt;&amp;lt;input /&amp;gt;&lt;/code&gt; 组件。这将导致呈现 &lt;code&gt;Ember.TextField&lt;/code&gt; 组件。有关更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;Ember.TextField&lt;/a&gt;文档和&lt;a href=&quot;https://emberjs.com/guides/templates/input-helpers/&quot;&gt;模板指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a7acad9bb4a31001b61e35a4c0adf75c035da764" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; Component</source>
          <target state="translated">该 &lt;code&gt;{{link-to}}&lt;/code&gt; 组件</target>
        </trans-unit>
        <trans-unit id="3ea57e523caa15a38446ec50b9e79ddf92910c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; component renders a link to the supplied &lt;code&gt;routeName&lt;/code&gt; passing an optionally supplied model to the route as its &lt;code&gt;model&lt;/code&gt; context of the route. The block for &lt;code&gt;{{link-to}}&lt;/code&gt; becomes the innerHTML of the rendered element:</source>
          <target state="translated">的 &lt;code&gt;{{link-to}}&lt;/code&gt; 组件呈现一个链接到供给 &lt;code&gt;routeName&lt;/code&gt; 传递一个任选供给模型来作为其路径 &lt;code&gt;model&lt;/code&gt; 的路由上下文。 &lt;code&gt;{{link-to}}&lt;/code&gt; 的块成为呈现元素的innerHTML：</target>
        </trans-unit>
        <trans-unit id="e774d713fb0f90f4a303ddde2564100df64e2437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; component takes one or two arguments:</source>
          <target state="translated">的 &lt;code&gt;{{link-to}}&lt;/code&gt; 部件接受一个或两个参数：</target>
        </trans-unit>
        <trans-unit id="39dd886ddbed7524e4a83856c25fa9788916f62d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{link-to}}&lt;/code&gt; helper will also add an &lt;code&gt;active&lt;/code&gt; class to the link that points to the currently active route.</source>
          <target state="translated">该 &lt;code&gt;{{link-to}}&lt;/code&gt; 帮手也将增加一个 &lt;code&gt;active&lt;/code&gt; 的链接类，指向当前活动的路线。</target>
        </trans-unit>
        <trans-unit id="90bfcd41e8565432c07cbbddf8858b5ba91f619a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{log}}&lt;/code&gt; helper also accepts primitive types such as strings or numbers.</source>
          <target state="translated">的 &lt;code&gt;{{log}}&lt;/code&gt; 助手也接受原语类型，如字符串或数字。</target>
        </trans-unit>
        <trans-unit id="e201996bfd3ba8afd0712fffee879e9357d52b69" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{mount}}&lt;/code&gt; helper lets you embed a routeless engine in a template. Mounting an engine will cause an instance to be booted and its &lt;code&gt;application&lt;/code&gt; template to be rendered.</source>
          <target state="translated">使用 &lt;code&gt;{{mount}}&lt;/code&gt; 帮助程序，您可以在模板中嵌入无路由引擎。挂载引擎将导致实例被启动并呈现其 &lt;code&gt;application&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="31eeebbd0adb9055cb1d8e00dfafd1d5331e5d95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{outlet}}&lt;/code&gt; helper lets you specify where a child route will render in your template. An important use of the &lt;code&gt;{{outlet}}&lt;/code&gt; helper is in your application's &lt;code&gt;application.hbs&lt;/code&gt; file:</source>
          <target state="translated">使用 &lt;code&gt;{{outlet}}&lt;/code&gt; 帮助程序，您可以指定子路径将在模板中呈现的位置。 &lt;code&gt;{{outlet}}&lt;/code&gt; 助手的重要用途是在应用程序的 &lt;code&gt;application.hbs&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="0ebbf8fe3922c7aefb3561c65af8dc306db37942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;{{unbound}}&lt;/code&gt; helper disconnects the one-way binding of a property, essentially freezing its value at the moment of rendering. For example, in this example the display of the variable &lt;code&gt;name&lt;/code&gt; will not change even if it is set with a new value:</source>
          <target state="translated">该 &lt;code&gt;{{unbound}}&lt;/code&gt; 帮手断开单向属性的结合，在渲染的时刻基本上是冻结其价值。例如，在此示例中，即使将变量 &lt;code&gt;name&lt;/code&gt; 设置为新值，其显示也不会更改：</target>
        </trans-unit>
        <trans-unit id="1c3bbef8d77a015f1b44f113e8413c77e1d8e3ae" translate="yes" xml:space="preserve">
          <source>The CLI &lt;code&gt;generate util&lt;/code&gt; command will create a utility file and a unit test. We'll delete the unit test since we don't want to test Google code.</source>
          <target state="translated">CLI &lt;code&gt;generate util&lt;/code&gt; 命令将创建一个实用程序文件和一个单元测试。由于我们不想测试Google代码，因此我们将删除单元测试。</target>
        </trans-unit>
        <trans-unit id="314686d9ca63241b41addc06dbaf29e1f9de2111" translate="yes" xml:space="preserve">
          <source>The CSS class name used for active classes can be customized for a single use of &lt;code&gt;{{link-to}}&lt;/code&gt; by passing an &lt;code&gt;activeClass&lt;/code&gt; option:</source>
          <target state="translated">可以通过传递 &lt;code&gt;activeClass&lt;/code&gt; 选项，为 &lt;code&gt;{{link-to}}&lt;/code&gt; 的单次使用自定义用于活动类的CSS类名称：</target>
        </trans-unit>
        <trans-unit id="a18277d28224fe13bf61456994d23cdddba18d00" translate="yes" xml:space="preserve">
          <source>The CSS class to apply to &lt;code&gt;LinkComponent&lt;/code&gt;'s element when its &lt;code&gt;active&lt;/code&gt; property is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当其 &lt;code&gt;active&lt;/code&gt; 属性为 &lt;code&gt;true&lt;/code&gt; 时，应用于 &lt;code&gt;LinkComponent&lt;/code&gt; 元素的CSS类。</target>
        </trans-unit>
        <trans-unit id="3560d1810ba6a290f018a30acb7a6abe17dc478d" translate="yes" xml:space="preserve">
          <source>The Component Lifecycle</source>
          <target state="translated">组件生命周期</target>
        </trans-unit>
        <trans-unit id="be34b5a31efa66b89e017638eee272b8df985bde" translate="yes" xml:space="preserve">
          <source>The DOM events for which the event dispatcher should listen.</source>
          <target state="translated">事件分配器应该监听的DOM事件。</target>
        </trans-unit>
        <trans-unit id="16262c4e9109f80339ca991e19c44c9238c16f0c" translate="yes" xml:space="preserve">
          <source>The Data tab is kept in sync with the data loaded in your application. Any record additions, deletions, or changes are reflected immediately. If you have unsaved records, they will be displayed in green by clicking on the New pill.</source>
          <target state="translated">数据选项卡与您的应用程序中加载的数据保持同步。任何记录的添加、删除或更改都会立即反映出来。如果您有未保存的记录,点击 &quot;新药丸&quot;,它们将以绿色显示。</target>
        </trans-unit>
        <trans-unit id="d52fbf4800c86d55bd033e9092c8b9094d06aa21" translate="yes" xml:space="preserve">
          <source>The DefaultResolver defines the default lookup rules to resolve container lookups before consulting the container for registered items:</source>
          <target state="translated">DefaultResolver定义了默认的查找规则,以便在查询容器中的注册项目之前解析容器查找。</target>
        </trans-unit>
        <trans-unit id="c29711481fa25b48f2527c2fa7d8f0b8bed7a3b1" translate="yes" xml:space="preserve">
          <source>The Development Server</source>
          <target state="translated">开发服务器</target>
        </trans-unit>
        <trans-unit id="ed05a3cd2719814bf85e78b39e4626d5b1cd6abf" translate="yes" xml:space="preserve">
          <source>The Duration column displays the render time for a given template, including the template's children.</source>
          <target state="translated">Duration列显示给定模板的渲染时间,包括模板的子模板。</target>
        </trans-unit>
        <trans-unit id="2ea15e43ed02f23a492330509b7d70ff1b380882" translate="yes" xml:space="preserve">
          <source>The ENV object contains three important keys:</source>
          <target state="translated">ENV对象包含三个重要的键。</target>
        </trans-unit>
        <trans-unit id="0f945314114021b149d52673626a64f4c3fb7096" translate="yes" xml:space="preserve">
          <source>The Ember Data store provides an interface for retrieving records of a single type.</source>
          <target state="translated">Ember数据存储提供了一个检索单一类型记录的接口。</target>
        </trans-unit>
        <trans-unit id="487c17cf393eda62f1f2c80da81270c64a1b3885" translate="yes" xml:space="preserve">
          <source>The Ember Inspector is a browser add-on designed to help you understand and debug your Ember applications. You can install it on &lt;a href=&quot;installation#toc_google-chrome&quot;&gt;Google Chrome&lt;/a&gt;, &lt;a href=&quot;installation#toc_firefox&quot;&gt;Firefox&lt;/a&gt; and &lt;a href=&quot;installation#toc_via-bookmarklet&quot;&gt;other browsers&lt;/a&gt; (via a bookmarklet)</source>
          <target state="translated">Ember Inspector是一个浏览器附加程序，旨在帮助您理解和调试Ember应用程序。您可以将其安装在&lt;a href=&quot;installation#toc_google-chrome&quot;&gt;Google Chrome&lt;/a&gt;，&lt;a href=&quot;installation#toc_firefox&quot;&gt;Firefox&lt;/a&gt;和&lt;a href=&quot;installation#toc_via-bookmarklet&quot;&gt;其他浏览器上&lt;/a&gt;（通过书签）</target>
        </trans-unit>
        <trans-unit id="b5ad72511f1a7b31a3a54993b2baf0d48b44720c" translate="yes" xml:space="preserve">
          <source>The Ember Router allows you to provide feedback that a route is loading, as well as when an error occurs in loading a route.</source>
          <target state="translated">Ember Router允许您提供途径正在加载的反馈,以及在加载途径时发生的错误。</target>
        </trans-unit>
        <trans-unit id="d259bb541551f92c36e45ba009a06cd16a1ca136" translate="yes" xml:space="preserve">
          <source>The Ember application is inside a sandboxed iframe with no url (if you are using JS Bin, follow &lt;a href=&quot;#toc_using-the-inspector-with-js-bin&quot;&gt;these steps&lt;/a&gt;.</source>
          <target state="translated">Ember应用程序位于没有网址的沙盒iframe中（如果您使用的是JS Bin，请按照&lt;a href=&quot;#toc_using-the-inspector-with-js-bin&quot;&gt;以下步骤操作&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf6333e738da626887805c4ba5c1a1355ba0d71f" translate="yes" xml:space="preserve">
          <source>The Ember community values collaboration and building common tools that everyone relies on. If you're interested in deploying your app to production in a fast and reliable way, check out the &lt;a href=&quot;http://ember-cli-deploy.com/&quot;&gt;Ember CLI Deploy&lt;/a&gt; addon.</source>
          <target state="translated">Ember社区重视协作并建立每个人都依赖的通用工具。如果您有兴趣以快速可靠的方式将应用程序部署到生产环境，请查看&lt;a href=&quot;http://ember-cli-deploy.com/&quot;&gt;Ember CLI Deploy&lt;/a&gt;插件。</target>
        </trans-unit>
        <trans-unit id="dd16b48b3b7627eda9a94aaf81db356a438f0ccb" translate="yes" xml:space="preserve">
          <source>The Ember router has four options to manage your application's URL: &lt;code&gt;history&lt;/code&gt;, which uses the HTML5 History API; &lt;code&gt;hash&lt;/code&gt;, which uses anchor-based URLs; &lt;code&gt;auto&lt;/code&gt;, which uses &lt;code&gt;history&lt;/code&gt; if supported by the user's browser, and falls back to &lt;code&gt;hash&lt;/code&gt; otherwise; and &lt;code&gt;none&lt;/code&gt;, which doesn't update the URL. By default, Ember CLI configures the router to use &lt;code&gt;auto&lt;/code&gt;. You can change this option in &lt;code&gt;config/environment.js&lt;/code&gt; under &lt;code&gt;ENV.locationType&lt;/code&gt;.</source>
          <target state="translated">Ember路由器有四个选项来管理应用程序的URL： &lt;code&gt;history&lt;/code&gt; ，它使用HTML5 History API； &lt;code&gt;hash&lt;/code&gt; ，它使用基于锚的URL； &lt;code&gt;auto&lt;/code&gt; ，如果用户浏览器支持，则使用 &lt;code&gt;history&lt;/code&gt; ，否则返回 &lt;code&gt;hash&lt;/code&gt; ；和 &lt;code&gt;none&lt;/code&gt; ，这不会更新URL。默认情况下，Ember CLI将路由器配置为使用 &lt;code&gt;auto&lt;/code&gt; 。您可以在 &lt;code&gt;config/environment.js&lt;/code&gt; 中的 &lt;code&gt;ENV.locationType&lt;/code&gt; 下更改此选项。</target>
        </trans-unit>
        <trans-unit id="a7a78387322a36a85c1c5009f5fb0f7c35f76084" translate="yes" xml:space="preserve">
          <source>The Guides are intended to contain practical explanations of how to build Ember apps, focusing on the most widely-used features of Ember.js. For comprehensive documentation of every Ember feature and API, see the &lt;a href=&quot;http://emberjs.com/api/&quot;&gt;Ember.js API documentation&lt;/a&gt;.</source>
          <target state="translated">这些指南旨在包含有关如何构建Ember应用程序的实用说明，重点是Ember.js的最广泛使用的功能。有关每个Ember功能和API的全面文档，请参阅&lt;a href=&quot;http://emberjs.com/api/&quot;&gt;Ember.js API文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f275cf778b6d119ab020c3d01e5250ad0219426" translate="yes" xml:space="preserve">
          <source>The Guides begin with an explanation of how to get started with Ember, followed by a tutorial on how to build your first Ember app. If you're brand new to Ember, we recommend you start off by following along with these first two sections of the Guides.</source>
          <target state="translated">本指南首先解释如何开始使用Ember,然后是如何建立你的第一个Ember应用的教程。如果你是Ember的新手,我们建议你从指南的前两部分开始学习。</target>
        </trans-unit>
        <trans-unit id="3c07d3314a98bd2f32c93ed811bdc5e03c2e9eb7" translate="yes" xml:space="preserve">
          <source>The HTML &lt;code&gt;class&lt;/code&gt; attribute of a component's tag can be set by providing a &lt;code&gt;classNames&lt;/code&gt; property that is set to an array of strings:</source>
          <target state="translated">可以通过提供设置为字符串数组的 &lt;code&gt;classNames&lt;/code&gt; 属性来设置组件标签的HTML &lt;code&gt;class&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="712c891dbe91ea95b6ed85832f3affbadeaa1d8c" translate="yes" xml:space="preserve">
          <source>The HTML &lt;code&gt;id&lt;/code&gt; of the component's element in the DOM. You can provide this value yourself but it must be unique (just as in HTML):</source>
          <target state="translated">DOM中组件元素的HTML &lt;code&gt;id&lt;/code&gt; 。您可以自己提供此值，但它必须是唯一的（就像在HTML中一样）：</target>
        </trans-unit>
        <trans-unit id="77babb069a61a648d0e212eb50fbca403ad78359" translate="yes" xml:space="preserve">
          <source>The HTML &lt;code&gt;id&lt;/code&gt; of the view's element in the DOM. You can provide this value yourself but it must be unique (just as in HTML):</source>
          <target state="translated">DOM中视图元素的HTML &lt;code&gt;id&lt;/code&gt; 。您可以自己提供此值，但它必须是唯一的（就像在HTML中一样）：</target>
        </trans-unit>
        <trans-unit id="d5ce9a853ceec8935a32736d2ed256b8ef580453" translate="yes" xml:space="preserve">
          <source>The HTML attribute section of a component's tag can be set by providing an &lt;code&gt;attributeBindings&lt;/code&gt; property set to an array of property names on the component. The return value of these properties will be used as the value of the component's HTML associated attribute:</source>
          <target state="translated">可以通过将 &lt;code&gt;attributeBindings&lt;/code&gt; 属性设置为组件上属性名称的数组来设置组件标签的HTML属性部分。这些属性的返回值将用作组件的HTML关联属性的值：</target>
        </trans-unit>
        <trans-unit id="f3ca8096b2b2a08769eef8f9d51a7c386381b928" translate="yes" xml:space="preserve">
          <source>The IDs will be passed as a URL-encoded Array of IDs, in this form:</source>
          <target state="translated">IDs将以URL编码的IDs数组形式传递,形式如下。</target>
        </trans-unit>
        <trans-unit id="c9440c491aa7e5a5571ef8d623370fad7dc61a99" translate="yes" xml:space="preserve">
          <source>The Inspector displays the parent objects and mixins that are composed into the chosen object, including the inherited properties.</source>
          <target state="translated">检查器显示组成所选对象的父对象和混合体,包括继承的属性。</target>
        </trans-unit>
        <trans-unit id="751510e2504c4b774d23cdd66c8c40b91042175d" translate="yes" xml:space="preserve">
          <source>The Inspector displays these routes:</source>
          <target state="translated">检查员会显示这些路线。</target>
        </trans-unit>
        <trans-unit id="690c38e1e0e3e9aad8aa3afc61469ec327e5aab8" translate="yes" xml:space="preserve">
          <source>The Inspector highlights the currently active routes. However, if your app has grown too large for this to be useful, you can use the &lt;code&gt;Current Route Only&lt;/code&gt; checkbox to hide all routes except the currently active ones.</source>
          <target state="translated">检查器突出显示当前活动的路线。但是，如果您的应用程序变得太大而无法使用，则可以使用&amp;ldquo; &lt;code&gt;Current Route Only&lt;/code&gt; 复选框隐藏除当前活动路由以外的所有路由。</target>
        </trans-unit>
        <trans-unit id="f30f50f616f12ec02246e464e631a2ca7d407d6d" translate="yes" xml:space="preserve">
          <source>The Inspector includes a panel that allows you to view and interact with your Ember objects. To open it, click on any Ember object. You can then view the object's properties.</source>
          <target state="translated">检查器包括一个面板,允许你查看并与你的Ember对象互动。要打开它,点击任何Ember对象。然后你可以查看对象的属性。</target>
        </trans-unit>
        <trans-unit id="b07f0c70b2f17b1a0937f0084ad1769ae1c7b677" translate="yes" xml:space="preserve">
          <source>The Inspector provides a way to look at all Promises created in your application. Click on the &lt;code&gt;Promises&lt;/code&gt; menu to start inspecting them.</source>
          <target state="translated">检查器提供了一种查看应用程序中创建的所有Promise的方法。单击&amp;ldquo; &lt;code&gt;Promises&lt;/code&gt; 菜单以开始检查它们。</target>
        </trans-unit>
        <trans-unit id="62cf4d7c67083a3006feaede174affa0b51ea132" translate="yes" xml:space="preserve">
          <source>The Inspector provides a way to view a Promise's stack trace. Tracing Promises is disabled by default for performance reasons. To enable tracing, check the &lt;code&gt;Trace promise&lt;/code&gt; checkbox. You may want to reload to trace existing Promises.</source>
          <target state="translated">检查器提供了一种查看Promise堆栈跟踪的方法。由于性能原因，默认情况下禁用跟踪承诺。要启用跟踪，请选中&amp;ldquo; &lt;code&gt;Trace promise&lt;/code&gt; 复选框。您可能需要重新加载以跟踪现有的Promises。</target>
        </trans-unit>
        <trans-unit id="a817980043f7fb6f67f44a551dd1bc461d4d9f8e" translate="yes" xml:space="preserve">
          <source>The JSON API adapter will automatically send a &lt;code&gt;GET&lt;/code&gt; request to &lt;code&gt;/posts/1&lt;/code&gt;.</source>
          <target state="translated">JSON API适配器将自动将 &lt;code&gt;GET&lt;/code&gt; 请求发送到 &lt;code&gt;/posts/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="010af95fc7f9a5c21dd89196b646d7c1093ea5b8" translate="yes" xml:space="preserve">
          <source>The JSON payload should be an object that contains the record inside a root property. For example, in response to a &lt;code&gt;GET&lt;/code&gt; request for &lt;code&gt;/posts/1&lt;/code&gt;, the JSON should look like this:</source>
          <target state="translated">JSON有效负载应该是一个包含根属性内记录的对象。例如，响应对 &lt;code&gt;/posts/1&lt;/code&gt; 的 &lt;code&gt;GET&lt;/code&gt; 请求，JSON应如下所示：</target>
        </trans-unit>
        <trans-unit id="01e0b389167fcbb21b9dfab152a2b6136aa145d1" translate="yes" xml:space="preserve">
          <source>The JSON returned should look like this:</source>
          <target state="translated">返回的JSON应该是这样的。</target>
        </trans-unit>
        <trans-unit id="04d2c141e4adc4849c1a9d91f7f144599c2898c1" translate="yes" xml:space="preserve">
          <source>The JSON should encode the relationship as an ID to another record:</source>
          <target state="translated">JSON应该将关系编码为另一条记录的ID。</target>
        </trans-unit>
        <trans-unit id="8b9146885924e80940db37b81326f9209df93900" translate="yes" xml:space="preserve">
          <source>The JSON should encode the relationship as an array of IDs and types:</source>
          <target state="translated">JSON应该将关系编码为一个ID和类型的数组。</target>
        </trans-unit>
        <trans-unit id="aa6abe7bb9f4b0f9e54508fdc1d5224614314c01" translate="yes" xml:space="preserve">
          <source>The JSONAPIAdapter uses JSON API conventions for building the url for a record and selecting the HTTP verb to use with a request. The actions you can take on a record map onto the following URLs in the JSON API adapter:</source>
          <target state="translated">JSONAPIAdapter使用JSON API约定来构建记录的URL,并选择HTTP动词来使用请求。在JSON API适配器中,你可以对记录采取的操作映射到以下URL。</target>
        </trans-unit>
        <trans-unit id="319a4c20db8f22613ffca3673ffd0b4f116cbd53" translate="yes" xml:space="preserve">
          <source>The JSONAPIAdapter will consider a success any response with a status code of the 2xx family (&quot;Success&quot;), as well as 304 (&quot;Not Modified&quot;). Any other status code will be considered a failure.</source>
          <target state="translated">JSONAPIAdapter将认为任何状态码为2xx系列(&quot;Success&quot;)以及304(&quot;Not Modified&quot;)的响应都是成功的。任何其他状态码将被视为失败。</target>
        </trans-unit>
        <trans-unit id="487ab77d5dbd345e6346d5f74c302b58d482236b" translate="yes" xml:space="preserve">
          <source>The Model Hook</source>
          <target state="translated">模型钩</target>
        </trans-unit>
        <trans-unit id="97c09292b53b45afc09c57770f7220ff9a4c953a" translate="yes" xml:space="preserve">
          <source>The NativeArray mixin contains the properties needed to make the native Array support Ember.MutableArray and all of its dependent APIs. Unless you have &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; or &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Array&lt;/code&gt; set to false, this will be applied automatically. Otherwise you can apply the mixin at anytime by calling &lt;code&gt;Ember.NativeArray.apply(Array.prototype)&lt;/code&gt;.</source>
          <target state="translated">NativeArray mixin包含使本机数组支持Ember.MutableArray及其所有相关API所需的属性。除非您将 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 或 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES.Array&lt;/code&gt; 设置为false，否则它将自动应用。否则，您可以随时通过调用 &lt;code&gt;Ember.NativeArray.apply(Array.prototype)&lt;/code&gt; 来应用mixin 。</target>
        </trans-unit>
        <trans-unit id="f728d39e800e681d2478973af1aacfb873e272e4" translate="yes" xml:space="preserve">
          <source>The Parent Route</source>
          <target state="translated">母线</target>
        </trans-unit>
        <trans-unit id="8e7bb3b57567e2227a221f010574edc6b4965cd1" translate="yes" xml:space="preserve">
          <source>The REST adapter allows your store to communicate with an HTTP server by transmitting JSON via XHR. Most Ember.js apps that consume a JSON API should use the REST adapter.</source>
          <target state="translated">REST适配器允许你的商店通过XHR传输JSON与HTTP服务器通信。大多数消耗JSON API的Ember.js应用程序应该使用REST适配器。</target>
        </trans-unit>
        <trans-unit id="fc6f2d961e0e8648bf62845bef00cfd62c181e1b" translate="yes" xml:space="preserve">
          <source>The REST adapter expects the JSON returned from your server to follow these conventions.</source>
          <target state="translated">REST适配器希望从您的服务器返回的JSON遵循这些约定。</target>
        </trans-unit>
        <trans-unit id="5ebe4d3849e4f0595a2c49dc9cebb6616874d70b" translate="yes" xml:space="preserve">
          <source>The REST adapter will consider a success any response with a status code of the 2xx family (&quot;Success&quot;), as well as 304 (&quot;Not Modified&quot;). Any other status code will be considered a failure.</source>
          <target state="translated">REST适配器将认为任何状态码为2xx系列(&quot;Success&quot;)以及304(&quot;Not Modified&quot;)的响应都是成功的。任何其他状态码将被视为失败。</target>
        </trans-unit>
        <trans-unit id="3172f22137802d4a8642cfa5668354ec4d3eeea5" translate="yes" xml:space="preserve">
          <source>The Router Pauses for Promises</source>
          <target state="translated">路由器暂停承诺</target>
        </trans-unit>
        <trans-unit id="efc37914e3487c9ca3df5d1d763f3449e864fe55" translate="yes" xml:space="preserve">
          <source>The Router service is the public API that provides component/view layer access to the router.</source>
          <target state="translated">Router服务是提供组件/视图层访问路由器的公共API。</target>
        </trans-unit>
        <trans-unit id="0c9d4cff939b6e9fcde57c63e9fa2dc698d186a0" translate="yes" xml:space="preserve">
          <source>The Routes tab displays a list of your application's routes.</source>
          <target state="translated">Routes(路由)选项卡显示应用程序的路由列表。</target>
        </trans-unit>
        <trans-unit id="84729b1e90f85ba399f1de4cfa6c0e4c113086c4" translate="yes" xml:space="preserve">
          <source>The Run Loop</source>
          <target state="translated">奔跑环线</target>
        </trans-unit>
        <trans-unit id="c32cedc8b4658f5a2c9ec3fd3e53275c0943aca6" translate="yes" xml:space="preserve">
          <source>The SOLID principles of good design tell us that objects should have a single responsibility. The responsibility of a component should be presenting model data to the user, not fetching the model.</source>
          <target state="translated">SOLID的良好设计原则告诉我们,对象应该只有一个责任。组件的责任应该是向用户呈现模型数据,而不是获取模型。</target>
        </trans-unit>
        <trans-unit id="2750c3a85432d63bf43d76ed414a487327be0ac0" translate="yes" xml:space="preserve">
          <source>The Store and a Single Source of Truth</source>
          <target state="translated">商店和单一的真理之源</target>
        </trans-unit>
        <trans-unit id="9f42b50dcb01303923e39ca4b080e7c21fefec38" translate="yes" xml:space="preserve">
          <source>The URL can be set in a few ways:</source>
          <target state="translated">URL可以通过几种方式进行设置。</target>
        </trans-unit>
        <trans-unit id="0bcc0cf43c5c46031ea589d18baa3c4b454de17b" translate="yes" xml:space="preserve">
          <source>The View Tree</source>
          <target state="translated">景观树</target>
        </trans-unit>
        <trans-unit id="41ef7117b31fdc6690fac73d0b81e21453b46c57" translate="yes" xml:space="preserve">
          <source>The View Tree ignores components and inline views by default. To load these into the View Tree check the &lt;code&gt;Components&lt;/code&gt; and &lt;code&gt;All Views&lt;/code&gt; checkboxes.</source>
          <target state="translated">默认情况下，&amp;ldquo;视图树&amp;rdquo;会忽略组件和嵌入式视图。要将它们加载到&amp;ldquo;视图树&amp;rdquo;中，请选中&amp;ldquo; &lt;code&gt;Components&lt;/code&gt; 和 &lt;code&gt;All Views&lt;/code&gt; 复选框。</target>
        </trans-unit>
        <trans-unit id="b3bb30d409dd94a905d7278b4f7300834afaa9d8" translate="yes" xml:space="preserve">
          <source>The WAI-ARIA role of the control represented by this view. For example, a button may have a role of type 'button', or a pane may have a role of type 'alertdialog'. This property is used by assistive software to help visually challenged users navigate rich web applications.</source>
          <target state="translated">该视图所代表的控件的 WAI-ARIA 角色。例如,按钮的角色类型为 &quot;button&quot;,而窗格的角色类型为 &quot;alertdialog&quot;。此属性被辅助软件用于帮助视觉障碍用户浏览丰富的 Web 应用程序。</target>
        </trans-unit>
        <trans-unit id="599db392fb52dd7a9d9ebf1a02ad877e6dc24952" translate="yes" xml:space="preserve">
          <source>The ability to consume a growing ecosystem of &lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Addons&lt;/a&gt;.</source>
          <target state="translated">消耗不断增长的&lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Addons&lt;/a&gt;生态系统的能力。</target>
        </trans-unit>
        <trans-unit id="236eb25e1509b24135c459c63eaaa974644a72a7" translate="yes" xml:space="preserve">
          <source>The above code will allow you invoke the &lt;code&gt;sum()&lt;/code&gt; function as a &lt;code&gt;{{sum}}&lt;/code&gt; handlebars &quot;helper&quot; in your templates:</source>
          <target state="translated">上面的代码将允许您在模板中将 &lt;code&gt;sum()&lt;/code&gt; 函数作为 &lt;code&gt;{{sum}}&lt;/code&gt; 句柄&amp;ldquo;助手&amp;rdquo;来调用：</target>
        </trans-unit>
        <trans-unit id="17aff5f3819b34917a219ca60e2165bb9008b501" translate="yes" xml:space="preserve">
          <source>The above example contains two arguments:</source>
          <target state="translated">上面的例子包含两个参数。</target>
        </trans-unit>
        <trans-unit id="4f30b8685376aad3470d0d8bc20b92baa1adf445" translate="yes" xml:space="preserve">
          <source>The above example returns the original arguments (after your customizations) back to the parent class, so it can continue with its normal operations.</source>
          <target state="translated">上面的例子将原始参数(在你的自定义之后)返回到父类,所以它可以继续它的正常操作。</target>
        </trans-unit>
        <trans-unit id="0de72be9fc4a958c468aab5fce926f1c1d8e1f2a" translate="yes" xml:space="preserve">
          <source>The above example template will render a template named &quot;-nav&quot;, which has the same context as the parent template it's rendered into, so if the &quot;-nav&quot; template also referenced &lt;code&gt;{{foo}}&lt;/code&gt;, it would print the same thing as the &lt;code&gt;{{foo}}&lt;/code&gt; in the above example.</source>
          <target state="translated">上面的示例模板将呈现一个名为&amp;ldquo; -nav&amp;rdquo;的模板，该模板具有与其所呈现的父模板相同的上下文，因此，如果该&amp;ldquo; -nav&amp;rdquo;模板也引用了 &lt;code&gt;{{foo}}&lt;/code&gt; ，则它将打印与上例中的 &lt;code&gt;{{foo}}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b5a49ec8b75cd43831c857a7b5a6f317839e3550" translate="yes" xml:space="preserve">
          <source>The above example will look up the value of &lt;code&gt;someTemplateName&lt;/code&gt; on the template context (e.g. a controller) and use that value as the name of the template to render. If the resolved value is falsy, nothing will be rendered. If &lt;code&gt;someTemplateName&lt;/code&gt; changes, the partial will be re-rendered using the new template name.</source>
          <target state="translated">上面的示例将在模板上下文（例如，控制器）上查找 &lt;code&gt;someTemplateName&lt;/code&gt; 的值，并将该值用作要渲染的模板的名称。如果解析的值是虚假的，则不会呈现任何内容。如果 &lt;code&gt;someTemplateName&lt;/code&gt; 更改，将使用新的模板名称重新渲染部分。</target>
        </trans-unit>
        <trans-unit id="4a17372c1a6f0d338afcba08934ad438cff05188" translate="yes" xml:space="preserve">
          <source>The above example will print a list like this:</source>
          <target state="translated">上面的例子将打印出这样一个列表。</target>
        </trans-unit>
        <trans-unit id="14759cf8b76d4ce53586ecc24fe64560891c5d11" translate="yes" xml:space="preserve">
          <source>The above template and controller render as the following HTML:</source>
          <target state="translated">上述模板和控制器呈现为以下HTML。</target>
        </trans-unit>
        <trans-unit id="647c3ca2996d871bb4527f63fd867d23a1ddf4a8" translate="yes" xml:space="preserve">
          <source>The above template will render HTML like this:</source>
          <target state="translated">上面的模板会呈现这样的HTML。</target>
        </trans-unit>
        <trans-unit id="1b6db4d979bea0f132b8aecf3e051e28b2ff75cb" translate="yes" xml:space="preserve">
          <source>The above will result in the following HTML output:</source>
          <target state="translated">上述内容将导致以下HTML输出。</target>
        </trans-unit>
        <trans-unit id="1f4cb9f31c2595e4f16286bd14d0a1224fdd7a4e" translate="yes" xml:space="preserve">
          <source>The action &lt;code&gt;deleteUser&lt;/code&gt; is in quotes, since &lt;code&gt;system-preferences-editor&lt;/code&gt; is where the action is defined now. Quotes indicate that the action should be looked for in &lt;code&gt;actions&lt;/code&gt; local to that component, rather than in those that have been passed from a parent.</source>
          <target state="translated">操作 &lt;code&gt;deleteUser&lt;/code&gt; 用引号引起来，因为 &lt;code&gt;system-preferences-editor&lt;/code&gt; 是现在定义该操作的位置。引号表示应在该组件本地的操作中查找该 &lt;code&gt;actions&lt;/code&gt; ，而不是在从父级传递的操作中查找。</target>
        </trans-unit>
        <trans-unit id="bc124545536eb0f1b78bc91d3e1823a25158f2d9" translate="yes" xml:space="preserve">
          <source>The action to trigger</source>
          <target state="translated">触发的行动</target>
        </trans-unit>
        <trans-unit id="fffafad4245d122f1f8b1d4f82482f6c6e9972ee" translate="yes" xml:space="preserve">
          <source>The actions &quot;play&quot; and &quot;stop&quot; must be passed to this &lt;code&gt;play-button&lt;/code&gt; component:</source>
          <target state="translated">必须将操作&amp;ldquo;播放&amp;rdquo;和&amp;ldquo;停止&amp;rdquo;传递给此 &lt;code&gt;play-button&lt;/code&gt; 组件：</target>
        </trans-unit>
        <trans-unit id="b15d60efde70e42a8401dc81cb70c844a7ab5b07" translate="yes" xml:space="preserve">
          <source>The actions you can take on a record map onto the following URLs in the JSON API adapter:</source>
          <target state="translated">在JSON API适配器中,你可以对记录进行的操作映射到以下URL。</target>
        </trans-unit>
        <trans-unit id="61f498285f596848fc23f04d9e51276702a760d4" translate="yes" xml:space="preserve">
          <source>The adapter is responsible for answering all of these questions. Whenever your app asks the store for a record that it doesn't have cached, it will ask the adapter for it. If you change a record and save it, the store will hand the record to the adapter to send the appropriate data to your server and confirm that the save was successful.</source>
          <target state="translated">适配器负责回答所有这些问题。每当您的应用程序向商店询问一条没有缓存的记录时,它都会向适配器询问。如果你修改了一条记录并保存了它,商店会把记录交给适配器,让它向你的服务器发送相应的数据,并确认保存成功。</target>
        </trans-unit>
        <trans-unit id="ad248e90ac6d8ba6c4d90263b68bd3e56fc49c63" translate="yes" xml:space="preserve">
          <source>The adapter passes in &lt;code&gt;includeId: true&lt;/code&gt; when serializing a record for &lt;code&gt;createRecord&lt;/code&gt;, but not for &lt;code&gt;updateRecord&lt;/code&gt;.</source>
          <target state="translated">序列化 &lt;code&gt;createRecord&lt;/code&gt; 而不是 &lt;code&gt;updateRecord&lt;/code&gt; 的记录时，适配器传入 &lt;code&gt;includeId: true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efdf679155c7a3919c2945e73db79499e695fec9" translate="yes" xml:space="preserve">
          <source>The adapter will need to be registered in the application's container as &lt;code&gt;container-debug-adapter:main&lt;/code&gt;.</source>
          <target state="translated">适配器将需要在应用程序的容器中注册为 &lt;code&gt;container-debug-adapter:main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="131e20e9576979fea3838369ca8bebc9bee71a7f" translate="yes" xml:space="preserve">
          <source>The adapter will need to be registered in the application's container as &lt;code&gt;dataAdapter:main&lt;/code&gt;.</source>
          <target state="translated">适配器将需要在应用程序的容器中注册为 &lt;code&gt;dataAdapter:main&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="de1f8ea65a9d062ad63b311606da2e19fac5c593" translate="yes" xml:space="preserve">
          <source>The advantage of an async helper is that it will not run until the last async helper has completed. All async helpers after it will wait for it complete before running.</source>
          <target state="translated">异步助手的优点是,在最后一个异步助手完成之前,它不会运行。在它之后的所有异步助手都会等待它完成后再运行。</target>
        </trans-unit>
        <trans-unit id="132b17863e2451dad65a1fc69e5aa6a2e2be4784" translate="yes" xml:space="preserve">
          <source>The algorithm works this way:</source>
          <target state="translated">算法是这样的。</target>
        </trans-unit>
        <trans-unit id="5ff582d708a589904a1b030c787773bd60458940" translate="yes" xml:space="preserve">
          <source>The alternative syntax, with prototype extensions, might look like:</source>
          <target state="translated">另一种语法,加上原型扩展,可能是这样的:</target>
        </trans-unit>
        <trans-unit id="5c3682b20b3168f59d213bbd7233481e751bc3ef" translate="yes" xml:space="preserve">
          <source>The amount to decrement by. Defaults to 1</source>
          <target state="translated">要递减的数量。默认值为1。</target>
        </trans-unit>
        <trans-unit id="5b7201edf1c359c10f638704266bcb43f6ade922" translate="yes" xml:space="preserve">
          <source>The amount to increment by. Defaults to 1</source>
          <target state="translated">要递增的数量。默认值为1。</target>
        </trans-unit>
        <trans-unit id="ed509f29503bfd3d0043d389191e47926618eace" translate="yes" xml:space="preserve">
          <source>The application instance is passed to Ember's instance initializer hooks and it is added as the &quot;owner&quot; of each object that was instantiated by the application instance.</source>
          <target state="translated">应用实例被传递给Ember的实例初始化钩子,它被添加为应用实例实例化的每个对象的 &quot;所有者&quot;。</target>
        </trans-unit>
        <trans-unit id="355a1c859de0828ab927049176efde71ae67825a" translate="yes" xml:space="preserve">
          <source>The application route</source>
          <target state="translated">申请途径</target>
        </trans-unit>
        <trans-unit id="bc69913b03727770065706d5ae763881554440df" translate="yes" xml:space="preserve">
          <source>The arguments to pass to the method</source>
          <target state="translated">要传递给方法的参数</target>
        </trans-unit>
        <trans-unit id="e850ec910ddafcfd153f778405adf847a5eaecec" translate="yes" xml:space="preserve">
          <source>The array represents the diff of the canonical state with the local state of the model. Note: if the model is created locally, the canonical state is empty since the adapter hasn't acknowledged the attributes yet:</source>
          <target state="translated">这个数组表示模型的标准状态与本地状态的差异。注意:如果模型是在本地创建的,那么规范状态是空的,因为适配器还没有确认属性。</target>
        </trans-unit>
        <trans-unit id="7876ec17eeb81f6ca541bc1ef63a2af2ef9b1f5a" translate="yes" xml:space="preserve">
          <source>The attrs options object can use more specific instruction for extracting and serializing. When serializing, an option to embed &lt;code&gt;ids&lt;/code&gt;, &lt;code&gt;ids-and-types&lt;/code&gt; or &lt;code&gt;records&lt;/code&gt; can be set. When extracting the only option is &lt;code&gt;records&lt;/code&gt;.</source>
          <target state="translated">attrs选项对象可以使用更特定的指令来提取和序列化。序列化时，可以设置嵌入 &lt;code&gt;ids&lt;/code&gt; ， &lt;code&gt;ids-and-types&lt;/code&gt; 或 &lt;code&gt;records&lt;/code&gt; 的选项。提取时，唯一的选择是 &lt;code&gt;records&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="692cb52572458fcee0dcfc7ce5597337ffbedcc6" translate="yes" xml:space="preserve">
          <source>The block expression can then use block params to bind names to any yielded values for use in the block. This allows for template customization when using a component, where the markup is provided by the consuming template, but any event handling behavior implemented in the component is retained such as &lt;code&gt;click()&lt;/code&gt; handlers.</source>
          <target state="translated">然后，块表达式可以使用块参数将名称绑定到任何产生的值，以供在块中使用。这允许在使用组件时自定义模板，其中使用方的模板提供标记，但是保留了组件中实现的任何事件处理行为，例如 &lt;code&gt;click()&lt;/code&gt; 处理程序。</target>
        </trans-unit>
        <trans-unit id="230b18f150ea432b7fc63ef20d6f97b9cd3ebdce" translate="yes" xml:space="preserve">
          <source>The block form of helpers allows you to control how the UI is created based on the values of properties. A third form of helper is called &quot;nested&quot;. For example here the concat helper will add &quot; Doe&quot; to a displayed name if the person has no last name:</source>
          <target state="translated">助手的块形式允许你根据属性的值来控制UI的创建方式。第三种形式的助记符叫做 &quot;嵌套&quot;。例如,这里的concat帮助程序将在显示的名字中添加 &quot;无名氏&quot;,如果这个人没有姓的话。</target>
        </trans-unit>
        <trans-unit id="cdafa2c9116008ccf0ab97418b925c097c3252ac" translate="yes" xml:space="preserve">
          <source>The blog post list scrolls to position a new post at the top of the viewport.</source>
          <target state="translated">博客文章列表滚动定位新文章在视口的顶部。</target>
        </trans-unit>
        <trans-unit id="af6e26b49064e993b28a797e047db6b65613464e" translate="yes" xml:space="preserve">
          <source>The cached value of the computed property, if any</source>
          <target state="translated">计算属性的缓存值,如果有的话。</target>
        </trans-unit>
        <trans-unit id="70f3ab63a321edca05f8d7fe826eff4a7da47248" translate="yes" xml:space="preserve">
          <source>The call made to the server, using a Rails backend, will look something like this:</source>
          <target state="translated">使用 Rails 后台对服务器进行的调用将是这样的。</target>
        </trans-unit>
        <trans-unit id="939bb0a279b018152f9c264171bbf1c866b675ab" translate="yes" xml:space="preserve">
          <source>The call to the function &lt;code&gt;this.inject.service&lt;/code&gt;&lt;a href=&quot;https://guides.emberjs.com/applications/dependency-injection/#toc_ad-hoc-injections&quot;&gt;injects&lt;/a&gt; the service we just registered into the context of the tests, so each test may access it through &lt;code&gt;this.get('mapsService')&lt;/code&gt;. In the example we assert that &lt;code&gt;calledWithLocation&lt;/code&gt; in our stub is set to the location we passed to the component.</source>
          <target state="translated">对函数 &lt;code&gt;this.inject.service&lt;/code&gt; 的调用会将我们刚刚注册的服务&lt;a href=&quot;https://guides.emberjs.com/applications/dependency-injection/#toc_ad-hoc-injections&quot;&gt;注入&lt;/a&gt;到测试的上下文中，因此每个测试都可以通过 &lt;code&gt;this.get('mapsService')&lt;/code&gt; 访问它。在示例中，我们断言存根中的 &lt;code&gt;calledWithLocation&lt;/code&gt; 设置为传递给组件的位置。</target>
        </trans-unit>
        <trans-unit id="6165fe98748987844899c6930403c4c1ab5d19eb" translate="yes" xml:space="preserve">
          <source>The call to the server, using a Rails backend, will look something like this:</source>
          <target state="translated">使用Rails后端对服务器的调用将是这样的。</target>
        </trans-unit>
        <trans-unit id="7d0699b4fba58c3f4df0d8bbb8c406317b7efb2c" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature (all parameters are optional):</source>
          <target state="translated">你提供的回调方法应该有以下签名(所有参数都是可选的)。</target>
        </trans-unit>
        <trans-unit id="7db19daead06e2c546317e025647247b05e290f5" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature. &lt;code&gt;item&lt;/code&gt; is the current item in the iteration. &lt;code&gt;index&lt;/code&gt; is the integer index of the current item in the iteration.</source>
          <target state="translated">您提供的回调方法应具有以下签名。 &lt;code&gt;item&lt;/code&gt; 是迭代中的当前项目。 &lt;code&gt;index&lt;/code&gt; 是迭代中当前项目的整数索引。</target>
        </trans-unit>
        <trans-unit id="e6388916ece31666bfa3bce621dc9190d0851704" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature. &lt;code&gt;item&lt;/code&gt; is the current item in the iteration. &lt;code&gt;index&lt;/code&gt; is the integer index of the current item in the iteration. &lt;code&gt;array&lt;/code&gt; is the dependant array itself.</source>
          <target state="translated">您提供的回调方法应具有以下签名。 &lt;code&gt;item&lt;/code&gt; 是迭代中的当前项目。 &lt;code&gt;index&lt;/code&gt; 是迭代中当前项目的整数索引。 &lt;code&gt;array&lt;/code&gt; 是从属数组本身。</target>
        </trans-unit>
        <trans-unit id="747b58783f30aeed09a97bff68b7a7ed7e662bd5" translate="yes" xml:space="preserve">
          <source>The callback method you provide should have the following signature:</source>
          <target state="translated">你提供的回调方法应该有以下签名。</target>
        </trans-unit>
        <trans-unit id="3d86eb979382fa479d1f0e875f699adf9c61634f" translate="yes" xml:space="preserve">
          <source>The callback to execute</source>
          <target state="translated">执行的回调</target>
        </trans-unit>
        <trans-unit id="378f4ac8c5402e27d2f5c1371ff15299fb646fad" translate="yes" xml:space="preserve">
          <source>The callback will receive the current application as an argument.</source>
          <target state="translated">回调将接收当前应用程序作为参数。</target>
        </trans-unit>
        <trans-unit id="107b78d2e608ef92e8a7f001aab1e580890d2636" translate="yes" xml:space="preserve">
          <source>The capitalized string.</source>
          <target state="translated">大写的字符串。</target>
        </trans-unit>
        <trans-unit id="dbbb92bec845d62ef32b3b4db4795ff8fb8678df" translate="yes" xml:space="preserve">
          <source>The child &lt;code&gt;Component&lt;/code&gt; can then modify the parent's value just by modifying its own property:</source>
          <target state="translated">然后，子 &lt;code&gt;Component&lt;/code&gt; 可以通过修改其自己的属性来修改父组件的值：</target>
        </trans-unit>
        <trans-unit id="257db548c086357f7aead64fe919a39c98588cac" translate="yes" xml:space="preserve">
          <source>The child &lt;code&gt;Component&lt;/code&gt; would invoke the action with the new click value:</source>
          <target state="translated">子 &lt;code&gt;Component&lt;/code&gt; 将使用新的点击值调用操作：</target>
        </trans-unit>
        <trans-unit id="01b4ccc47f51a076e5b8b5bc1b2f43c46487fa20" translate="yes" xml:space="preserve">
          <source>The class of a model might be useful if you want to get a list of all the relationship names of the model, see &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#property_relationshipNames&quot;&gt;&lt;code&gt;relationshipNames&lt;/code&gt;&lt;/a&gt; for example.</source>
          <target state="translated">如果要获取模型的所有关系名称的列表，则模型的类可能很有用，例如，请参见&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Model.html#property_relationshipNames&quot;&gt; &lt;code&gt;relationshipNames&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="48f539537c66e244c744c84eda7209879551eaf4" translate="yes" xml:space="preserve">
          <source>The code below is the deprecation-workflow file with the first deprecation set to throw an exception on occurrence. The image demonstrates what that deprecation looks like when you run your tests.</source>
          <target state="translated">下面的代码是deprecation-workflow文件,第一个deprecation设置为发生时抛出异常。这张图演示了当你运行测试时,该弃用是什么样子的。</target>
        </trans-unit>
        <trans-unit id="93cd13234a3187a294d47fbdde9fd0427c708c5b" translate="yes" xml:space="preserve">
          <source>The collection of functions, keyed by name, available on this &lt;code&gt;ActionHandler&lt;/code&gt; as action targets.</source>
          <target state="translated">在此 &lt;code&gt;ActionHandler&lt;/code&gt; 上可以使用按操作名称命名的功能集合作为操作目标。</target>
        </trans-unit>
        <trans-unit id="9d2bfcf3313d4bc0a7bda43e5de7a8ef0369007f" translate="yes" xml:space="preserve">
          <source>The command will generate the following output, showing that it created a single file called &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt;.</source>
          <target state="translated">该命令将生成以下输出，显示该命令创建了一个名为 &lt;code&gt;tests/acceptance/list-rentals-test.js&lt;/code&gt; 的文件。</target>
        </trans-unit>
        <trans-unit id="1a6bdd19a4196300d3fed3ccaf29bc7c89c1afa5" translate="yes" xml:space="preserve">
          <source>The component below takes a list of items and displays them on the screen. Additionally, it takes an object representing which item is selected and will select and set the scroll top to that item.</source>
          <target state="translated">下面的组件接收一个项目列表并将其显示在屏幕上。此外,它还接受一个对象,代表被选中的项目,并将选择和设置滚动顶部到该项目。</target>
        </trans-unit>
        <trans-unit id="00924038d9acbd0206114498f918d95680c59534" translate="yes" xml:space="preserve">
          <source>The component should show details about the rental</source>
          <target state="translated">该组件应显示有关租赁的详细信息</target>
        </trans-unit>
        <trans-unit id="03d4f32bac2eee953b37844aa3ddbdccc1b00e16" translate="yes" xml:space="preserve">
          <source>The component should toggle the existence of a wide class on click, to expand and shrink the photo of the rental.</source>
          <target state="translated">该组件应在点击时切换宽类的存在,对租借的照片进行展开和缩小。</target>
        </trans-unit>
        <trans-unit id="bb8277dc02802176f96c31e5577dcf1f7ddceafa" translate="yes" xml:space="preserve">
          <source>The component template will have a button and a div that shows the confirmation dialog based on the value of &lt;code&gt;confirmShown&lt;/code&gt;.</source>
          <target state="translated">组件模板将具有一个按钮和一个div，以基于 &lt;code&gt;confirmShown&lt;/code&gt; 的值显示确认对话框。</target>
        </trans-unit>
        <trans-unit id="d3e02882f24ccee1b6087710e6540fa437584878" translate="yes" xml:space="preserve">
          <source>The component's element has been both created and inserted into the DOM.</source>
          <target state="translated">组件的元素已经被创建并插入到DOM中。</target>
        </trans-unit>
        <trans-unit id="4cc0a17e4b5e6b7c7ced86a1cc438b4160335bc6" translate="yes" xml:space="preserve">
          <source>The component's element is accessible via the component's &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#method__&quot;&gt;&lt;code&gt;$()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">可通过组件的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#method__&quot;&gt; &lt;code&gt;$()&lt;/code&gt; &lt;/a&gt;方法访问组件的元素。</target>
        </trans-unit>
        <trans-unit id="f87081eb897d1fd3835c5c46606eabc3f8f40d2c" translate="yes" xml:space="preserve">
          <source>The computed macros expect you to use an array, so there is no need to use the &lt;code&gt;[]&lt;/code&gt; key in these cases. However, building your own custom computed property requires you to tell Ember.js that it is watching for array changes, which is where the &lt;code&gt;[]&lt;/code&gt; key comes in handy.</source>
          <target state="translated">计算的宏期望您使用数组，因此在这种情况下无需使用 &lt;code&gt;[]&lt;/code&gt; 键。但是，构建自己的自定义计算属性要求您告诉Ember.js，它正在监视数组更改，这是 &lt;code&gt;[]&lt;/code&gt; 键派上用场的地方。</target>
        </trans-unit>
        <trans-unit id="c04629937de1c7126ae68322907abae8ecd667fc" translate="yes" xml:space="preserve">
          <source>The container calls this object's &lt;code&gt;resolve&lt;/code&gt; method with the &lt;code&gt;fullName&lt;/code&gt; argument.</source>
          <target state="translated">容器使用 &lt;code&gt;fullName&lt;/code&gt; 参数调用该对象的 &lt;code&gt;resolve&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="dedba2d51f22aac0e2c4ffa20bbb5629c1192057" translate="yes" xml:space="preserve">
          <source>The container-debug-adapter which is used to list all models.</source>
          <target state="translated">容器-debug-适配器,用于列出所有模型。</target>
        </trans-unit>
        <trans-unit id="71bc08d35f4aa7dfc82186fc932b83df95fed7ce" translate="yes" xml:space="preserve">
          <source>The controller associated with this route.</source>
          <target state="translated">与该途径相关的控制器。</target>
        </trans-unit>
        <trans-unit id="8b3eab1e8d1492edcda2af7cd55a05ab06f81f5f" translate="yes" xml:space="preserve">
          <source>The controller instance must already have been created, either through entering the associated route or using &lt;code&gt;generateController&lt;/code&gt;.</source>
          <target state="translated">通过输入关联的路由或使用 &lt;code&gt;generateController&lt;/code&gt; ，必须已经创建了控制器实例。</target>
        </trans-unit>
        <trans-unit id="d996ccba50d2a03192ad84043d699c49c674c9d6" translate="yes" xml:space="preserve">
          <source>The controller receives a single property from the Route &amp;ndash; &lt;code&gt;model&lt;/code&gt; &amp;ndash; which is the return value of the Route's &lt;code&gt;model()&lt;/code&gt; method.</source>
          <target state="translated">控制器从Route &amp;ndash; &lt;code&gt;model&lt;/code&gt; &amp;ndash; 接收单个属性，该属性是Route的 &lt;code&gt;model()&lt;/code&gt; 方法的返回值。</target>
        </trans-unit>
        <trans-unit id="9805ee9f09f7a6c9f18fe8f84f7390a97217c750" translate="yes" xml:space="preserve">
          <source>The controller's current model. When retrieving or modifying a controller's model, this property should be used instead of the &lt;code&gt;content&lt;/code&gt; property.</source>
          <target state="translated">控制器的当前模型。检索或修改控制器模型时，应使用此属性代替 &lt;code&gt;content&lt;/code&gt; 属性。</target>
        </trans-unit>
        <trans-unit id="301f36390a7be64dbf55d036bcf24116fa60dea1" translate="yes" xml:space="preserve">
          <source>The copied object</source>
          <target state="translated">被复制的对象</target>
        </trans-unit>
        <trans-unit id="dc497b43d9a73eae6ffff08e5aaad7d8aea85919" translate="yes" xml:space="preserve">
          <source>The current set of flags are defined below. If you want to add a new flag, in addition to the area below, you will also need to declare it in the &lt;code&gt;DS.Model&lt;/code&gt; class.</source>
          <target state="translated">当前标志集在下面定义。如果要添加新标志，除了下面的区域外，还需要在 &lt;code&gt;DS.Model&lt;/code&gt; 类中声明它。</target>
        </trans-unit>
        <trans-unit id="0524bb6abfd181d72da352389fd69941fb6778cc" translate="yes" xml:space="preserve">
          <source>The currently active URL.</source>
          <target state="translated">当前活动的URL。</target>
        </trans-unit>
        <trans-unit id="64c535e9f2e1008eed7eb1be8de9fd6230cf64a1" translate="yes" xml:space="preserve">
          <source>The currently active path.</source>
          <target state="translated">当前活动的路径。</target>
        </trans-unit>
        <trans-unit id="e4b1d59e80066fe1a38250044448beb82d44ec54" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;serialize&lt;/code&gt; method will insert the model's &lt;code&gt;id&lt;/code&gt; into the route's dynamic segment (in this case, &lt;code&gt;:post_id&lt;/code&gt;) if the segment contains '_id'. If the route has multiple dynamic segments or does not contain '_id', &lt;code&gt;serialize&lt;/code&gt; will return &lt;code&gt;Ember.getProperties(model, params)&lt;/code&gt;</source>
          <target state="translated">如果段中包含'_id' ，则默认的 &lt;code&gt;serialize&lt;/code&gt; 方法会将模型的 &lt;code&gt;id&lt;/code&gt; 插入路由的动态段（在本例中为 &lt;code&gt;:post_id&lt;/code&gt; ）。如果路由具有多个动态段或不包含&amp;ldquo; _id&amp;rdquo;，则 &lt;code&gt;serialize&lt;/code&gt; 将返回 &lt;code&gt;Ember.getProperties(model, params)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9804540a4930794a37fbff41c2089e9b1c714b1" translate="yes" xml:space="preserve">
          <source>The default HTML tag name used for a component's DOM representation is &lt;code&gt;div&lt;/code&gt;. This can be customized by setting the &lt;code&gt;tagName&lt;/code&gt; property. The following component class:</source>
          <target state="translated">用于组件的DOM表示的默认HTML标记名称是 &lt;code&gt;div&lt;/code&gt; 。可以通过设置 &lt;code&gt;tagName&lt;/code&gt; 属性来自定义。以下组件类：</target>
        </trans-unit>
        <trans-unit id="ba661251bae2c58457a6583501ea31468be49e4e" translate="yes" xml:space="preserve">
          <source>The default adapter to use to communicate to a backend server or other persistence layer. This will be overridden by an application adapter if present.</source>
          <target state="translated">用于与后端服务器或其他持久层通信的默认适配器。如果存在的话,会被应用适配器覆盖。</target>
        </trans-unit>
        <trans-unit id="d48ca495b259e7b4f0c08e2c8e0b6fc93859dce8" translate="yes" xml:space="preserve">
          <source>The default behavior for &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_link-to&quot;&gt;&lt;code&gt;link-to&lt;/code&gt;&lt;/a&gt; is to add entries to the browser's history when transitioning between the routes. However, to replace the current entry in the browser's history you can use the &lt;code&gt;replace=true&lt;/code&gt; option:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_link-to&quot;&gt; &lt;code&gt;link-to&lt;/code&gt; &lt;/a&gt;的默认行为是在路径之间转换时将条目添加到浏览器的历史记录中。但是，要替换浏览器历史记录中的当前条目，可以使用 &lt;code&gt;replace=true&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="028b9616eef359dc09d07d3be87a5ac87b8aea59" translate="yes" xml:space="preserve">
          <source>The default behavior is for lookup to return a singleton instance. The singleton is scoped to the container, allowing multiple containers to all have their own locally scoped singletons.</source>
          <target state="translated">默认的行为是让查找返回一个单子实例,单子的作用域是容器,允许多个容器都有自己的本地作用域单子。单子的作用域是容器,允许多个容器都有自己的本地作用域单子。</target>
        </trans-unit>
        <trans-unit id="33cd28df250e1a3d71b927a14510954a829fa40c" translate="yes" xml:space="preserve">
          <source>The default implementation returns the records as a single group.</source>
          <target state="translated">默认的实现是将记录作为一个组返回。</target>
        </trans-unit>
        <trans-unit id="6d55dd2f84ce398a6b7ca904972aeeb8f8ea5d4c" translate="yes" xml:space="preserve">
          <source>The default serialization would create a JSON object like:</source>
          <target state="translated">默认的序列化将创建一个JSON对象,如。</target>
        </trans-unit>
        <trans-unit id="9726fa72bad036507b0c7e1f772d49c8a42328a7" translate="yes" xml:space="preserve">
          <source>The denodified function inherits from the original function. It works in all environments, except IE 10 and below. Consequently all properties of the original function are available to you. However, any properties you change on the denodeified function won't be changed on the original function. Example:</source>
          <target state="translated">去编码后的函数继承自原始函数。它适用于所有环境,除了IE 10及以下。因此,您可以使用原始函数的所有属性。但是,您在去代码化函数中更改的任何属性将不会在原函数中被更改。例如</target>
        </trans-unit>
        <trans-unit id="a81bacb27ef7a7c4a59cca0a9ad3aa5799647431" translate="yes" xml:space="preserve">
          <source>The deprecation handler API was released in Ember 2.1. If you would like to leverage this API in a prior release of Ember you can install the &lt;a href=&quot;http://emberobserver.com/addons/ember-debug-handlers-polyfill&quot;&gt;ember-debug-handlers-polyfill&lt;/a&gt; addon into your project.</source>
          <target state="translated">弃用处理程序API在Ember 2.1中发布。如果您想在Ember的&lt;a href=&quot;http://emberobserver.com/addons/ember-debug-handlers-polyfill&quot;&gt;早期&lt;/a&gt;版本中使用此API，则可以在项目中安装ember-debug-handlers-polyfill插件。</target>
        </trans-unit>
        <trans-unit id="d14be1f3c6637fd072ea31a6dbb848736f0f9b4c" translate="yes" xml:space="preserve">
          <source>The deserialized value</source>
          <target state="translated">反序列化值</target>
        </trans-unit>
        <trans-unit id="61863b6efe342207f2c2beda0291c57e7b350c15" translate="yes" xml:space="preserve">
          <source>The easiest way to create a two-way binding is to use a &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_alias&quot;&gt;&lt;code&gt;computed.alias()&lt;/code&gt;&lt;/a&gt;, that specifies the path to another object.</source>
          <target state="translated">创建双向绑定的最简单方法是使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html#method_alias&quot;&gt; &lt;code&gt;computed.alias()&lt;/code&gt; &lt;/a&gt;，它指定到另一个对象的路径。</target>
        </trans-unit>
        <trans-unit id="51b9dfe652430a47b7813879322835fda06a5e1e" translate="yes" xml:space="preserve">
          <source>The easiest way to create an &lt;code&gt;Ember.Component&lt;/code&gt; is via a template. If you name a template &lt;code&gt;app/components/my-foo.hbs&lt;/code&gt;, you will be able to use &lt;code&gt;{{my-foo}}&lt;/code&gt; in other templates, which will make an instance of the isolated component.</source>
          <target state="translated">创建 &lt;code&gt;Ember.Component&lt;/code&gt; 的最简单方法是通过模板。如果将模板命名为 &lt;code&gt;app/components/my-foo.hbs&lt;/code&gt; ，则可以在其他模板中使用 &lt;code&gt;{{my-foo}}&lt;/code&gt; ，这将成为隔离组件的实例。</target>
        </trans-unit>
        <trans-unit id="1a90adc5ebc180395b92d51213f2e4db5db7c4d5" translate="yes" xml:space="preserve">
          <source>The ember-cli-deprecation-workflow addon provides a command that will collect deprecations from your console and generate JavaScript code listing its findings.</source>
          <target state="translated">ember-cli-deprecation-workflow addon提供了一个命令,它将从你的控制台中收集弃用信息,并生成列出其发现的JavaScript代码。</target>
        </trans-unit>
        <trans-unit id="c08d687a1f142539937b2a75e02478a1de2910c4" translate="yes" xml:space="preserve">
          <source>The enumerable API follows ECMAScript specifications as much as possible. This minimizes incompatibility with other libraries, and allows Ember.js to use the native browser implementations in arrays where available.</source>
          <target state="translated">可枚举的API尽可能地遵循ECMAScript规范。这最大限度地减少了与其他库的不兼容,并允许Ember.js在可用的情况下使用本机浏览器在数组中的实现。</target>
        </trans-unit>
        <trans-unit id="2f251a4ec622923c4684a280b97957e070d1f3fc" translate="yes" xml:space="preserve">
          <source>The event dispatcher is created by the application at initialization time and sets up event listeners on the DOM element described by the application's &lt;code&gt;rootElement&lt;/code&gt; property.</source>
          <target state="translated">事件分配器由应用程序在初始化时创建，并在由应用程序的 &lt;code&gt;rootElement&lt;/code&gt; 属性描述的DOM元素上设置事件侦听器。</target>
        </trans-unit>
        <trans-unit id="053c279c50f244b9eb896230e5a90c90796a9df5" translate="yes" xml:space="preserve">
          <source>The event handling examples described above respond to one set of events. The names of the built-in events are listed below. Custom events can be registered by using &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Application.html#property_customEvents&quot;&gt;Ember.Application.customEvents&lt;/a&gt;.</source>
          <target state="translated">上述事件处理示例将响应一组事件。内置事件的名称在下面列出。可以使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Application.html#property_customEvents&quot;&gt;Ember.Application.customEvents&lt;/a&gt;注册自定义事件。</target>
        </trans-unit>
        <trans-unit id="b863b4625ecf29a56bcdfb71eee44abd26ee138c" translate="yes" xml:space="preserve">
          <source>The event type to be triggered.</source>
          <target state="translated">要触发的事件类型。</target>
        </trans-unit>
        <trans-unit id="5e377f2c4a3dec86abf2ac3efcc334847d1f52b8" translate="yes" xml:space="preserve">
          <source>The exception to be raised.</source>
          <target state="translated">要提出的例外。</target>
        </trans-unit>
        <trans-unit id="2422f0ff43e6667a702a73460791a92f8d19db60" translate="yes" xml:space="preserve">
          <source>The feature to check</source>
          <target state="translated">检查的功能</target>
        </trans-unit>
        <trans-unit id="95787b699dfdd06e98ccefd8263560e2e6b5a8f1" translate="yes" xml:space="preserve">
          <source>The filterFunction is a function used to test records from the store to determine if they should be part of the record array.</source>
          <target state="translated">filterFunction是一个用于测试存储中的记录,以确定它们是否应该成为记录数组的一部分的函数。</target>
        </trans-unit>
        <trans-unit id="62e163152ac939e91938ed4bba47c089f566a9f1" translate="yes" xml:space="preserve">
          <source>The final test should look as follows:</source>
          <target state="translated">最后的测试应该是这样的:</target>
        </trans-unit>
        <trans-unit id="251b44a6daaf2e9098e7b6561f96f4b93ffee050" translate="yes" xml:space="preserve">
          <source>The find method is called on the model class with the value of the dynamic segment.</source>
          <target state="translated">查找方法在模型类上调用动态段的值。</target>
        </trans-unit>
        <trans-unit id="1c6ab5f4ba11276c830d14ace1931f03db22503d" translate="yes" xml:space="preserve">
          <source>The first argument (&lt;code&gt;model&lt;/code&gt;) was curried over, and the run-time argument (&lt;code&gt;event&lt;/code&gt;) becomes a second argument. Action calls can be nested this way because each simply returns a function. Any function can be passed to the &lt;code&gt;{{action}}&lt;/code&gt; helper, including other actions.</source>
          <target state="translated">重写了第一个参数（ &lt;code&gt;model&lt;/code&gt; ），运行时参数（ &lt;code&gt;event&lt;/code&gt; ）成为第二个参数。可以以这种方式嵌套操作调用，因为每个操作调用仅返回一个函数。可以将任何功能（包括其他操作）传递给 &lt;code&gt;{{action}}&lt;/code&gt; 帮助器。</target>
        </trans-unit>
        <trans-unit id="ed7c239cf4e865e182877517567062ddaf11cb4e" translate="yes" xml:space="preserve">
          <source>The first nested route to generate will be the index route. An index nested route works similarly to the base index route. It is the default route that renders when no route is provided. Therefore in our case, when we navigate to &lt;code&gt;/rentals&lt;/code&gt;, Ember will attempt to load the rentals index route as a nested route.</source>
          <target state="translated">生成的第一个嵌套路由将是索引路由。索引嵌套路由的工作方式与基本索引路由类似。它是没有提供任何路由时呈现的默认路由。因此，在本例中，当我们导航到 &lt;code&gt;/rentals&lt;/code&gt; 时，Ember将尝试将租金指数路线加载为嵌套路线。</target>
        </trans-unit>
        <trans-unit id="983c3b259f765a841e0ba8fde3f9e8cb7899878d" translate="yes" xml:space="preserve">
          <source>The first parameter is the name of the route which is used by default as the path name as well.</source>
          <target state="translated">第一个参数是路由的名称,默认情况下,它也被用作路径名称。</target>
        </trans-unit>
        <trans-unit id="9105fbebbf22cf85d2b2f209a6496fbe8783578b" translate="yes" xml:space="preserve">
          <source>The first parameter of the helper is the name of a component to render, as a string. So &lt;code&gt;{{component 'blog-post'}}&lt;/code&gt; is the same as using &lt;code&gt;{{blog-post}}&lt;/code&gt;.</source>
          <target state="translated">助手的第一个参数是要呈现的组件的名称，以字符串形式。因此 &lt;code&gt;{{component 'blog-post'}}&lt;/code&gt; 与使用 &lt;code&gt;{{blog-post}}&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="d5209e6f0bdb73ab73f04317f2793d14718036b7" translate="yes" xml:space="preserve">
          <source>The first style of invocation is &lt;strong&gt;inline invocation&lt;/strong&gt;. This looks similar to displaying a property, but helpers accept arguments. For example:</source>
          <target state="translated">第一种调用方式是&lt;strong&gt;内联调用&lt;/strong&gt;。这看起来类似于显示属性，但是助手接受参数。例如：</target>
        </trans-unit>
        <trans-unit id="75890c317887371b09062eb2031229122ca2996b" translate="yes" xml:space="preserve">
          <source>The first thing we want to do in our new project is to remove the welcome screen. We do this by simply opening up the application template file located at &lt;code&gt;app/templates/application.hbs&lt;/code&gt;.</source>
          <target state="translated">我们要在新项目中做的第一件事是删除欢迎屏幕。为此，我们只需打开位于 &lt;code&gt;app/templates/application.hbs&lt;/code&gt; 的应用程序模板文件即可。</target>
        </trans-unit>
        <trans-unit id="2f64cb4a633c43e464c1ff818f86a7f51cbaf2da" translate="yes" xml:space="preserve">
          <source>The first time your application asks the store for a record, the store sees that it doesn't have a local copy and requests it from your adapter. Your adapter will go and retrieve the record from your persistence layer; typically, this will be a JSON representation of the record served from an HTTP server.</source>
          <target state="translated">当您的应用程序第一次向存储请求记录时,存储会发现它没有本地副本,并向您的适配器请求它。你的适配器将从你的持久层中检索记录;通常,这将是一个从HTTP服务器上提供的记录的JSON表示。</target>
        </trans-unit>
        <trans-unit id="bd9a731b8654e32704a346674674446e3d3a69b4" translate="yes" xml:space="preserve">
          <source>The flag status in the generated build is controlled by the &lt;a href=&quot;https://github.com/emberjs/ember.js/blob/master/features.json&quot;&gt;&lt;code&gt;features.json&lt;/code&gt;&lt;/a&gt; file in the root of the Ember.js project. This file lists all new features and their current status.</source>
          <target state="translated">生成的内部版本中的标志状态由Ember.js项目根目录中的&lt;a href=&quot;https://github.com/emberjs/ember.js/blob/master/features.json&quot;&gt; &lt;code&gt;features.json&lt;/code&gt; &lt;/a&gt;文件控制。此文件列出了所有新功能及其当前状态。</target>
        </trans-unit>
        <trans-unit id="eb3cef84c92085a6d2d883851701837207c0ed5e" translate="yes" xml:space="preserve">
          <source>The flag to signal a &lt;code&gt;RecordArray&lt;/code&gt; is currently loading data.</source>
          <target state="translated">用于指示 &lt;code&gt;RecordArray&lt;/code&gt; 的标志当前正在加载数据。</target>
        </trans-unit>
        <trans-unit id="53188ffd1056282eaa9b367801d327c2d664d389" translate="yes" xml:space="preserve">
          <source>The flag to signal a &lt;code&gt;RecordArray&lt;/code&gt; is finished loading data.</source>
          <target state="translated">用于指示 &lt;code&gt;RecordArray&lt;/code&gt; 的标志已完成数据加载。</target>
        </trans-unit>
        <trans-unit id="39accfabc1616fbff84cfef1e2405eff54644354" translate="yes" xml:space="preserve">
          <source>The following HTML attributes can be set via the helper:</source>
          <target state="translated">以下HTML属性可以通过帮助程序进行设置。</target>
        </trans-unit>
        <trans-unit id="eb79dc0afa03345796e1814d66f43dab53b2351b" translate="yes" xml:space="preserve">
          <source>The following HTML attributes can be set:</source>
          <target state="translated">可以设置以下HTML属性。</target>
        </trans-unit>
        <trans-unit id="44fc4180b9b05e8989204eb9f584bb53e9d638f4" translate="yes" xml:space="preserve">
          <source>The following HTML would be rendered:</source>
          <target state="translated">将会呈现以下HTML。</target>
        </trans-unit>
        <trans-unit id="1f0a3c7a9779e06c8201841fbe9265d91073f48e" translate="yes" xml:space="preserve">
          <source>The following chart is a visual representation of what takes place when the escape key is pressed in this scenario:</source>
          <target state="translated">下图是这种情况下按下回车键时发生的情况的直观表现。</target>
        </trans-unit>
        <trans-unit id="37c67db7954be266e8e6d6ff4e4e5081f2a3c808" translate="yes" xml:space="preserve">
          <source>The following code injects the &lt;code&gt;shopping-cart&lt;/code&gt; service on the &lt;code&gt;cart-contents&lt;/code&gt; component as the property &lt;code&gt;cart&lt;/code&gt;:</source>
          <target state="translated">以下代码将 &lt;code&gt;shopping-cart&lt;/code&gt; 服务作为属性 &lt;code&gt;cart&lt;/code&gt; 注入到 &lt;code&gt;cart-contents&lt;/code&gt; 组件上：</target>
        </trans-unit>
        <trans-unit id="729b7f0e23b374cb4e57a6cdd204d250859aaf3b" translate="yes" xml:space="preserve">
          <source>The following controller code:</source>
          <target state="translated">以下是控制器代码。</target>
        </trans-unit>
        <trans-unit id="5f70fdd699bda0ef491d01141402f07249723c95" translate="yes" xml:space="preserve">
          <source>The following demonstrates how you can override both the scope and the query param URL key of a single controller query param property:</source>
          <target state="translated">下面演示了如何覆盖单个控制器查询参数属性的范围和查询参数URL键。</target>
        </trans-unit>
        <trans-unit id="c25fcb78f8ce32888e37289c4e3ec48b550205a2" translate="yes" xml:space="preserve">
          <source>The following equivalent default options will be applied when the Route calls &lt;code&gt;render&lt;/code&gt;:</source>
          <target state="translated">当Route调用 &lt;code&gt;render&lt;/code&gt; 时，将应用以下等效的默认选项：</target>
        </trans-unit>
        <trans-unit id="1c4f56e0c501f86b7a8f875bd1a2f2ae5dfd1313" translate="yes" xml:space="preserve">
          <source>The following example creates a tag like &lt;code&gt;&amp;lt;div priority=&quot;high&quot; /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">以下示例创建一个 &lt;code&gt;&amp;lt;div priority=&quot;high&quot; /&amp;gt;&lt;/code&gt; 类的标记。</target>
        </trans-unit>
        <trans-unit id="1e094e921fd819fa5e76624b61faecd882472c2a" translate="yes" xml:space="preserve">
          <source>The following example creates markup like &lt;code&gt;&amp;lt;div visible /&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">以下示例创建类似于 &lt;code&gt;&amp;lt;div visible /&amp;gt;&lt;/code&gt; 的标记。</target>
        </trans-unit>
        <trans-unit id="afdab8293445b11ec924bd3e51d6a5d98083d81e" translate="yes" xml:space="preserve">
          <source>The following location types are currently available:</source>
          <target state="translated">目前有以下地点类型:</target>
        </trans-unit>
        <trans-unit id="7a04ae17d99bdb1ca3ff7d3f029873e55f621ebc" translate="yes" xml:space="preserve">
          <source>The format of your &lt;code&gt;links&lt;/code&gt; value will influence the final request URL via the &lt;code&gt;urlPrefix&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;links&lt;/code&gt; 值的格式将通过 &lt;code&gt;urlPrefix&lt;/code&gt; 方法影响最终请求URL ：</target>
        </trans-unit>
        <trans-unit id="609b07ebd91a9564a1e401e69867af9f43852ebd" translate="yes" xml:space="preserve">
          <source>The full list of valid WAI-ARIA roles is available at: &lt;a href=&quot;http://www.w3.org/TR/wai-aria/roles#roles_categorization&quot;&gt;http://www.w3.org/TR/wai-aria/roles#roles_categorization&lt;/a&gt;</source>
          <target state="translated">有效的WAI-ARIA角色的完整列表可在以下位置获得：&lt;a href=&quot;http://www.w3.org/TR/wai-aria/roles#roles_categorization&quot;&gt;http&lt;/a&gt; : //www.w3.org/TR/wai-aria/roles#roles_categorization</target>
        </trans-unit>
        <trans-unit id="9511008deb941834774d3d5ef5d5eb87d148f334" translate="yes" xml:space="preserve">
          <source>The function of the subscription</source>
          <target state="translated">认购的功能</target>
        </trans-unit>
        <trans-unit id="b0cd84bb592c3813b530b12d48aa8e49154cd375" translate="yes" xml:space="preserve">
          <source>The function to be called.</source>
          <target state="translated">要调用的函数。</target>
        </trans-unit>
        <trans-unit id="082ed932b0ef334e05715d349323974d215f0f06" translate="yes" xml:space="preserve">
          <source>The function to be executed.</source>
          <target state="translated">要执行的功能。</target>
        </trans-unit>
        <trans-unit id="fb1e00c09e0f91fcfb54af8c8c11530f8722ad41" translate="yes" xml:space="preserve">
          <source>The function used to resolve the promise.</source>
          <target state="translated">用于解析承诺的函数。</target>
        </trans-unit>
        <trans-unit id="79464200d9e3ddbdb2fe8367a586a4583bb4305d" translate="yes" xml:space="preserve">
          <source>The globals provided by some assets (like &lt;code&gt;moment&lt;/code&gt; in the below example) can be used in your application without the need to &lt;code&gt;import&lt;/code&gt; them. Provide the asset path as the first and only argument.</source>
          <target state="translated">某些资产提供的全局变量（例如下面示例中的 &lt;code&gt;moment&lt;/code&gt; ）可以在您的应用程序中使用，而无需 &lt;code&gt;import&lt;/code&gt; 它们。提供资产路径作为第一个也是唯一的参数。</target>
        </trans-unit>
        <trans-unit id="933a1192be634af8a21616acc066822633b90230" translate="yes" xml:space="preserve">
          <source>The goal of initializers should be to register dependencies and injections. This phase runs once. Because these initializers may load code, they are allowed to defer application readiness and advance it. If you need to access the container or store you should use an InstanceInitializer that will be run after all initializers and therefore after all code is loaded and the app is ready.</source>
          <target state="translated">初始化器的目标应该是注册依赖和注入。这个阶段运行一次。因为这些初始化器可能会加载代码,所以它们被允许推迟应用程序的准备时间,并将其提前。如果你需要访问容器或存储,你应该使用一个InstanceInitializer,它将在所有初始化器之后运行,因此在所有代码加载和应用程序准备好之后。</target>
        </trans-unit>
        <trans-unit id="b9c39dbd4973fde26a84eeab934b9541d4d9d411" translate="yes" xml:space="preserve">
          <source>The handler function takes the following arguments:</source>
          <target state="translated">处理函数接受以下参数:</target>
        </trans-unit>
        <trans-unit id="d9976137b5fc46c82802f55ca4a18f19ec76f045" translate="yes" xml:space="preserve">
          <source>The hash of enabled Canary features. Add to this, any canary features before creating your application.</source>
          <target state="translated">启用金丝雀功能的哈希。在创建你的应用程序之前,将任何金丝雀功能添加到其中。</target>
        </trans-unit>
        <trans-unit id="f1f5d4f4f7e10915f4694e587719c74a6240d5a1" translate="yes" xml:space="preserve">
          <source>The hash that you pass to the &lt;code&gt;meta()&lt;/code&gt; function will be saved on the computed property descriptor under the &lt;code&gt;_meta&lt;/code&gt; key. Ember runtime exposes a public API for retrieving these values from classes, via the &lt;code&gt;metaForProperty()&lt;/code&gt; function.</source>
          <target state="translated">传递给 &lt;code&gt;meta()&lt;/code&gt; 函数的哈希将保存在 &lt;code&gt;_meta&lt;/code&gt; 键下的已计算属性描述符中。Ember运行时公开了一个公共API，用于通过 &lt;code&gt;metaForProperty()&lt;/code&gt; 函数从类中检索这些值。</target>
        </trans-unit>
        <trans-unit id="ca21eb1ac808b66726237aab6478d493b882f2e4" translate="yes" xml:space="preserve">
          <source>The helper allows some user events to send actions.</source>
          <target state="translated">该助手允许一些用户事件发送动作。</target>
        </trans-unit>
        <trans-unit id="a9bc08f7454fc33317953aa1d0764e69128fbd18" translate="yes" xml:space="preserve">
          <source>The helper can send multiple actions based on user events. The action property defines the action which is send when the user presses the return key.</source>
          <target state="translated">帮助程序可以根据用户事件发送多个动作。动作属性定义了当用户按下返回键时发送的动作。</target>
        </trans-unit>
        <trans-unit id="467dd7598d6007e1305b827d35702192c6fb827f" translate="yes" xml:space="preserve">
          <source>The helper can send multiple actions based on user events. The action property defines the action which is sent when the user presses the return key.</source>
          <target state="translated">帮助程序可以根据用户事件发送多个动作。动作属性定义了当用户按下返回键时发送的动作。</target>
        </trans-unit>
        <trans-unit id="fd3ae270075b46e8c72806c87f05194a68ec4531" translate="yes" xml:space="preserve">
          <source>The helper function</source>
          <target state="translated">助手功能</target>
        </trans-unit>
        <trans-unit id="a7b07a977cc772121d830f7df8058bbfdf781828" translate="yes" xml:space="preserve">
          <source>The helper method will always be called with the current Application as the first parameter.</source>
          <target state="translated">助手方法总是以当前Application作为第一个参数被调用。</target>
        </trans-unit>
        <trans-unit id="d352679de326e446da8bcf7ae02cdf1d2b388cc3" translate="yes" xml:space="preserve">
          <source>The helper method will always be called with the current Application as the first parameter. Other parameters, such as assert, need to be provided when calling the helper. Helpers need to be registered prior to calling &lt;code&gt;startApp&lt;/code&gt;, but ember-cli will take care of it for you.</source>
          <target state="translated">将始终以当前应用程序作为第一个参数来调用helper方法。调用帮助程序时，需要提供其他参数，例如assert。调用 &lt;code&gt;startApp&lt;/code&gt; 之前，必须先注册辅助程序，但是ember-cli将为您处理它。</target>
        </trans-unit>
        <trans-unit id="20ee84ece384b1c7bf0a5f88c860139387c74bc6" translate="yes" xml:space="preserve">
          <source>The helper to remove.</source>
          <target state="translated">助手去掉。</target>
        </trans-unit>
        <trans-unit id="d01c5bd098982ca73ec7c55be9abde28b9b34a69" translate="yes" xml:space="preserve">
          <source>The hierarchy of valid states that ship with ember data looks like this:</source>
          <target state="translated">运送微光数据的有效状态的层次结构是这样的。</target>
        </trans-unit>
        <trans-unit id="f6e2f5503b24777429c126a35c56b33d77b5055f" translate="yes" xml:space="preserve">
          <source>The id of the record in this belongsTo relationship.</source>
          <target state="translated">这个 belongsTo关系中记录的id。</target>
        </trans-unit>
        <trans-unit id="8d93476bc0286bac3afbab171f7e9f39fc33828a" translate="yes" xml:space="preserve">
          <source>The id of the record.</source>
          <target state="translated">记录的id。</target>
        </trans-unit>
        <trans-unit id="71fe696ada77a1df388294168858e15ad016bb74" translate="yes" xml:space="preserve">
          <source>The index of the item to return.</source>
          <target state="translated">要返回的项目的索引。</target>
        </trans-unit>
        <trans-unit id="bf6c6f036f009d345c5f9f4a01b236f9acff2d54" translate="yes" xml:space="preserve">
          <source>The index to retrieve.</source>
          <target state="translated">要检索的索引。</target>
        </trans-unit>
        <trans-unit id="a59b1536c7b56b8fd58d1ea97c5500491fd87390" translate="yes" xml:space="preserve">
          <source>The initial URL to navigate to</source>
          <target state="translated">导航到的初始URL</target>
        </trans-unit>
        <trans-unit id="6ec073e684d780eaf847bfcf50ff16099c381dae" translate="yes" xml:space="preserve">
          <source>The inline &lt;code&gt;if&lt;/code&gt; helper conditionally renders a single property or string.</source>
          <target state="translated">内联 &lt;code&gt;if&lt;/code&gt; 助手有条件地呈现单个属性或字符串。</target>
        </trans-unit>
        <trans-unit id="d6d29959063e476cd6d120667a761a34e0a62dbb" translate="yes" xml:space="preserve">
          <source>The inline &lt;code&gt;unless&lt;/code&gt; helper conditionally renders a single property or string. This helper acts like a ternary operator. If the first property is falsy, the second argument will be displayed, otherwise, the third argument will be displayed</source>
          <target state="translated">内联 &lt;code&gt;unless&lt;/code&gt; 帮助程序有条件地呈现单个属性或字符串。该助手的作用类似于三元运算符。如果第一个属性为falsy，则将显示第二个参数，否则，将显示第三个参数</target>
        </trans-unit>
        <trans-unit id="875191874130e97e6feff5b21de2bc9eb0a9019c" translate="yes" xml:space="preserve">
          <source>The internal class used to create text inputs when the &lt;code&gt;{{input}}&lt;/code&gt; helper is used with &lt;code&gt;type&lt;/code&gt; of &lt;code&gt;checkbox&lt;/code&gt;.</source>
          <target state="translated">内部类使用时，创建的文本输入 &lt;code&gt;{{input}}&lt;/code&gt; 助手与使用 &lt;code&gt;type&lt;/code&gt; 的 &lt;code&gt;checkbox&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fdad83afa3d51d43a413c1abadbd70ea9c1b3b9" translate="yes" xml:space="preserve">
          <source>The internal class used to create text inputs when the &lt;code&gt;{{input}}&lt;/code&gt; helper is used with &lt;code&gt;type&lt;/code&gt; of &lt;code&gt;text&lt;/code&gt;. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt; for usage details.</source>
          <target state="translated">内部类使用时，创建的文本输入 &lt;code&gt;{{input}}&lt;/code&gt; 助手与使用 &lt;code&gt;type&lt;/code&gt; 的 &lt;code&gt;text&lt;/code&gt; 。有关用法的详细信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Templates.helpers.html#method_input&quot;&gt;Ember.Templates.helpers.input&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d607ba34fe18795114b4f433109ab02b90bb0adf" translate="yes" xml:space="preserve">
          <source>The internal class used to create textarea element when the &lt;code&gt;{{textarea}}&lt;/code&gt; helper is used.</source>
          <target state="translated">使用 &lt;code&gt;{{textarea}}&lt;/code&gt; 帮助程序时，用于创建textarea元素的内部类。</target>
        </trans-unit>
        <trans-unit id="8d750dea4a93a39d4b9db6798a523e5e15dcbad1" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;{{if}}&lt;/code&gt; is &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt;&lt;code&gt;{{unless}}&lt;/code&gt;&lt;/a&gt;, which can be used in the same three styles of invocation. For example, this template only shows an amount due when the user has not paid:</source>
          <target state="translated">&lt;code&gt;{{if}}&lt;/code&gt; 的倒数是&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_unless&quot;&gt; &lt;code&gt;{{unless}}&lt;/code&gt; &lt;/a&gt;，可以在相同的三种调用样式中使用。例如，此模板仅显示用户未付款时的应付金额：</target>
        </trans-unit>
        <trans-unit id="d45de9e199e155b8777a207a094e041487a424da" translate="yes" xml:space="preserve">
          <source>The key &lt;code&gt;detail&lt;/code&gt; provides a textual description of the problem. Alternatively, the key &lt;code&gt;title&lt;/code&gt; can be used for the same purpose.</source>
          <target state="translated">关键 &lt;code&gt;detail&lt;/code&gt; 提供了该问题的文本描述。或者，可以将关键字 &lt;code&gt;title&lt;/code&gt; 用于相同的目的。</target>
        </trans-unit>
        <trans-unit id="4b7555d5282e96bd6e24cc32840ea3424b4844f1" translate="yes" xml:space="preserve">
          <source>The key to observe</source>
          <target state="translated">观察的关键</target>
        </trans-unit>
        <trans-unit id="bda81920321dffb71626e245008601afdbbd6199" translate="yes" xml:space="preserve">
          <source>The key to set</source>
          <target state="translated">设置的关键</target>
        </trans-unit>
        <trans-unit id="a6ee319d67963224e6cc6a893a3f09344964cfb2" translate="yes" xml:space="preserve">
          <source>The link Ember Data will use to fetch or reload this belongs-to relationship.</source>
          <target state="translated">Ember Data将用来获取或重载这个所属关系的链接。</target>
        </trans-unit>
        <trans-unit id="df6a49096075b75f24d4bda7b0d30a1279be1940" translate="yes" xml:space="preserve">
          <source>The link Ember Data will use to fetch or reload this has-many relationship.</source>
          <target state="translated">Ember Data将用来获取或重载这个has-many关系的链接。</target>
        </trans-unit>
        <trans-unit id="fb4639de6bdd5d693c4936a26db0f36475d3d91c" translate="yes" xml:space="preserve">
          <source>The loading state of this array</source>
          <target state="translated">这个数组的加载状态</target>
        </trans-unit>
        <trans-unit id="c19c7109c687fbc9fcd386c8c0b1f5cabb138c0a" translate="yes" xml:space="preserve">
          <source>The location in the cache has been &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_camelize&quot;&gt;&lt;code&gt;camelized&lt;/code&gt;&lt;/a&gt; (line 30), so that it may be used as a key to look up our element. This matches the behavior in &lt;code&gt;getMapElement&lt;/code&gt; when city has not yet been cached.</source>
          <target state="translated">缓存中的位置已被&lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_camelize&quot;&gt; &lt;code&gt;camelized&lt;/code&gt; &lt;/a&gt;（第30行），因此可以用作查找元素的键。当城市尚未缓存时，这与 &lt;code&gt;getMapElement&lt;/code&gt; 中的行为匹配。</target>
        </trans-unit>
        <trans-unit id="a788518ddcd9fbbee4defbf1d862f0e936c78c17" translate="yes" xml:space="preserve">
          <source>The mapped array.</source>
          <target state="translated">映射数组。</target>
        </trans-unit>
        <trans-unit id="18d8bcb9bddd16b3086b442996831dcaa439d784" translate="yes" xml:space="preserve">
          <source>The meta data for the belongs-to relationship.</source>
          <target state="translated">归属关系的元数据。</target>
        </trans-unit>
        <trans-unit id="a85e08823b46b35e1ce946c3b00a085d8f560820" translate="yes" xml:space="preserve">
          <source>The meta information for the belongs-oo relationship.</source>
          <target state="translated">belongs-oo关系的元信息。</target>
        </trans-unit>
        <trans-unit id="34f2833b8151391b99f9c680911406631b2b6fdd" translate="yes" xml:space="preserve">
          <source>The meta information for the has-many relationship.</source>
          <target state="translated">有多关系的元信息。</target>
        </trans-unit>
        <trans-unit id="49369103b0464b44493cf84cb646510c7e94536a" translate="yes" xml:space="preserve">
          <source>The method name to check for</source>
          <target state="translated">要检查的方法名称</target>
        </trans-unit>
        <trans-unit id="0263e067489f60c9e685cbc3d24f7b8e48689a36" translate="yes" xml:space="preserve">
          <source>The method to invoke</source>
          <target state="translated">要调用的方法</target>
        </trans-unit>
        <trans-unit id="19540d3f9bb05ef81877198fb53c8953af81b641" translate="yes" xml:space="preserve">
          <source>The method to invoke. If you pass a string it will be resolved on the target at the time the method is invoked.</source>
          <target state="translated">要调用的方法。如果你传递了一个字符串,它将在方法被调用时在目标上被解析。</target>
        </trans-unit>
        <trans-unit id="0de0091a090dc150acbc0fbf24a9397407d002b0" translate="yes" xml:space="preserve">
          <source>The method to invoke. If you pass a string it will be resolved on the target object at the time the scheduled item is invoked allowing you to change the target function.</source>
          <target state="translated">要调用的方法。如果你传递了一个字符串,它将在预定项目被调用时在目标对象上被解析,允许你改变目标函数。</target>
        </trans-unit>
        <trans-unit id="3506db6058e732c49d0d84aa3928be98489273e0" translate="yes" xml:space="preserve">
          <source>The method to invoke. May be a function or a string. If you pass a string then it will be looked up on the passed target.</source>
          <target state="translated">要调用的方法。可以是一个函数或一个字符串。如果你传递了一个字符串,那么它将在传递的目标上被查找。</target>
        </trans-unit>
        <trans-unit id="d11f6516cbacb45fdea866478b595ee9ed7bf1d3" translate="yes" xml:space="preserve">
          <source>The methods likely to be overridden are:</source>
          <target state="translated">可能被推翻的方法有:</target>
        </trans-unit>
        <trans-unit id="eb3c70dade0bce9d1ab411df82e04ea62f4ddfac" translate="yes" xml:space="preserve">
          <source>The methods of this object are designed to be easy to override in a subclass. For example, you could enhance how a template is resolved like so:</source>
          <target state="translated">这个对象的方法被设计成易于在子类中覆盖。例如,你可以像这样增强模板的解析方式。</target>
        </trans-unit>
        <trans-unit id="f9047c74c1590bc009ee5e6df824e3a60a2c8e26" translate="yes" xml:space="preserve">
          <source>The model class is determined from the segment (&lt;code&gt;post_id&lt;/code&gt;'s class is &lt;code&gt;App.Post&lt;/code&gt;)</source>
          <target state="translated">根据类别确定模型类（ &lt;code&gt;post_id&lt;/code&gt; 的类为 &lt;code&gt;App.Post&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5da58253b88e1c437a81d76ece8cc0c89fc0db69" translate="yes" xml:space="preserve">
          <source>The model class that all Ember Data records descend from. This is the public API of Ember Data models. If you are using Ember Data in your application, this is the class you should use. If you are working on Ember Data internals, you most likely want to be dealing with &lt;code&gt;InternalModel&lt;/code&gt;</source>
          <target state="translated">所有Ember Data记录所属的模型类。这是Ember Data模型的公共API。如果您在应用程序中使用Ember Data，则应使用该类。如果您使用的是Ember Data内部构件，则很可能要处理 &lt;code&gt;InternalModel&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e351f80cd5556cb6da014791c372d237924a3b0" translate="yes" xml:space="preserve">
          <source>The model for the &lt;code&gt;post&lt;/code&gt; route is &lt;code&gt;store.findRecord('post', params.post_id)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;post&lt;/code&gt; 路线的模型是 &lt;code&gt;store.findRecord('post', params.post_id)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61a80d68a8a250e49493ed6f67e0f4faa9238b3d" translate="yes" xml:space="preserve">
          <source>The model hooks (&lt;code&gt;beforeModel&lt;/code&gt;, &lt;code&gt;model&lt;/code&gt;, and &lt;code&gt;afterModel&lt;/code&gt;) of an error substate are not called. Only the &lt;code&gt;setupController&lt;/code&gt; method of the error substate is called with the &lt;code&gt;error&lt;/code&gt; as the model. See example below:</source>
          <target state="translated">错误子状态的模型挂钩（ &lt;code&gt;beforeModel&lt;/code&gt; ， &lt;code&gt;model&lt;/code&gt; 和 &lt;code&gt;afterModel&lt;/code&gt; ）不会被调用。仅将错误子状态的 &lt;code&gt;setupController&lt;/code&gt; 方法与 &lt;code&gt;error&lt;/code&gt; 作为模型一起调用。请参见下面的示例：</target>
        </trans-unit>
        <trans-unit id="19ae229adfd578f13d92ff0a6a38ca5deaa02ad7" translate="yes" xml:space="preserve">
          <source>The model name.</source>
          <target state="translated">模型名称。</target>
        </trans-unit>
        <trans-unit id="280c3aad18626cc5e1384613f6c69059889e22fc" translate="yes" xml:space="preserve">
          <source>The model's relationships as a map, keyed on the type of the relationship. The value of each entry is an array containing a descriptor for each relationship with that type, describing the name of the relationship as well as the type.</source>
          <target state="translated">模型的关系图,以关系的类型为键。每个条目的值是一个数组,包含该类型的每个关系的描述符,描述关系的名称和类型。</target>
        </trans-unit>
        <trans-unit id="d0e3568f7b5ea35bae50803475ef2f179bff0fad" translate="yes" xml:space="preserve">
          <source>The modelClass represented by this record array.</source>
          <target state="translated">这个记录数组所代表的modelClass。</target>
        </trans-unit>
        <trans-unit id="06574cdcebf2b12553ee5033ae390a06647355df" translate="yes" xml:space="preserve">
          <source>The most common case for using the run loop is integrating with a non-Ember API that includes some sort of asynchronous callback. For example:</source>
          <target state="translated">使用运行循环最常见的情况是与非Ember API集成,该API包含某种异步回调。比如说</target>
        </trans-unit>
        <trans-unit id="cacb8b5741c18afe5abd31963d74c05c17355b34" translate="yes" xml:space="preserve">
          <source>The most common place you'll want to access &lt;code&gt;modelName&lt;/code&gt; is in your serializer's &lt;code&gt;payloadKeyFromModelName&lt;/code&gt; method. For example, to change payload keys to underscore (instead of dasherized), you might use the following code:</source>
          <target state="translated">您要访问 &lt;code&gt;modelName&lt;/code&gt; 的最常见位置是序列化程序的有效 &lt;code&gt;payloadKeyFromModelName&lt;/code&gt; 方法。例如，要将有效负载密钥更改为下划线（而不是反斜线），可以使用以下代码：</target>
        </trans-unit>
        <trans-unit id="4860165ddeb1c56516173150ded5daec90a22733" translate="yes" xml:space="preserve">
          <source>The name of a route. In this example, it would be &lt;code&gt;index&lt;/code&gt;, &lt;code&gt;photos&lt;/code&gt;, or &lt;code&gt;photos.edit&lt;/code&gt;.</source>
          <target state="translated">路线名称。在此示例中，它将是 &lt;code&gt;index&lt;/code&gt; ， &lt;code&gt;photos&lt;/code&gt; 或 &lt;code&gt;photos.edit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f70391ad509d6330a846870500a48929f3fe644d" translate="yes" xml:space="preserve">
          <source>The name of the controller to associate with this route.</source>
          <target state="translated">与该途径相关联的控制器的名称。</target>
        </trans-unit>
        <trans-unit id="8a0f4ba13feddd8f7a0fcb578c4a64ee25577bba" translate="yes" xml:space="preserve">
          <source>The name of the currently active route.</source>
          <target state="translated">当前活动途径的名称。</target>
        </trans-unit>
        <trans-unit id="2d5cd10d5efb705d95ff6ef881164cb30052e176" translate="yes" xml:space="preserve">
          <source>The name of the event</source>
          <target state="translated">活动名称</target>
        </trans-unit>
        <trans-unit id="79193a57dbbc3246321cf5ba9ea7e09896c27a92" translate="yes" xml:space="preserve">
          <source>The name of the helper method to add.</source>
          <target state="translated">要添加的辅助方法的名称。</target>
        </trans-unit>
        <trans-unit id="0be317d734b30c2e8a916f8992d44b13a519d341" translate="yes" xml:space="preserve">
          <source>The name of the model type for this payload</source>
          <target state="translated">该有效载荷的模型类型名称。</target>
        </trans-unit>
        <trans-unit id="48937d3df342f8b3c9377985edf9ceb5b1837454" translate="yes" xml:space="preserve">
          <source>The name of the property to decrement</source>
          <target state="translated">递减的财产名称</target>
        </trans-unit>
        <trans-unit id="a664383b45acf8957aaf6e6f496db9828833977d" translate="yes" xml:space="preserve">
          <source>The name of the property to increment</source>
          <target state="translated">要增量的财产名称</target>
        </trans-unit>
        <trans-unit id="8a46946ba08b63ffb9945d5218fd4eaab85e6281" translate="yes" xml:space="preserve">
          <source>The name of the property to retrieve</source>
          <target state="translated">要检索的属性名称</target>
        </trans-unit>
        <trans-unit id="645bc5da9840b9064b59ef1eef330781affe8068" translate="yes" xml:space="preserve">
          <source>The name of the property to toggle</source>
          <target state="translated">要切换的属性名称</target>
        </trans-unit>
        <trans-unit id="5fb100cec0ff90d54ebe800238fc00ef6238601d" translate="yes" xml:space="preserve">
          <source>The name of the queue to schedule against. Default queues are 'sync' and 'actions'</source>
          <target state="translated">要调度的队列名称。默认队列是 &quot;同步 &quot;和 &quot;行动&quot;。</target>
        </trans-unit>
        <trans-unit id="4c90a724a69d75c22285140dd18e22630ce627af" translate="yes" xml:space="preserve">
          <source>The name of the queue to schedule against. Default queues are 'sync' and 'actions'.</source>
          <target state="translated">要调度的队列名称。默认队列是 &quot;同步 &quot;和 &quot;行动&quot;。</target>
        </trans-unit>
        <trans-unit id="92bd55fef05773932c03eea0113227b4aea76072" translate="yes" xml:space="preserve">
          <source>The name of the remote type. This should either be &quot;link&quot; or &quot;id&quot;</source>
          <target state="translated">远程类型的名称。应该是 &quot;link &quot;或 &quot;id&quot;。</target>
        </trans-unit>
        <trans-unit id="a7278ab5074a42a98d664c4226440fce451e40e3" translate="yes" xml:space="preserve">
          <source>The name of the remote type. This should either be &quot;link&quot; or &quot;ids&quot;</source>
          <target state="translated">远程类型的名称。应该是 &quot;链接 &quot;或 &quot;ids&quot;</target>
        </trans-unit>
        <trans-unit id="15f44cca7344c2cf48a11e2ee934769fefd135d2" translate="yes" xml:space="preserve">
          <source>The name of the route, defined by the router, is &lt;code&gt;post&lt;/code&gt;.</source>
          <target state="translated">路由器定义的路由名称是 &lt;code&gt;post&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08a86bad24be595b560f010d3688c6353e6a3adf" translate="yes" xml:space="preserve">
          <source>The name of the route, dot-delimited.</source>
          <target state="translated">途径的名称,以点为界。</target>
        </trans-unit>
        <trans-unit id="289954f9d601b7db9c6b62df2307ce4028bd72f5" translate="yes" xml:space="preserve">
          <source>The name of the template to render minus the leading underscore.</source>
          <target state="translated">要渲染的模板名称,去掉前面的下划线。</target>
        </trans-unit>
        <trans-unit id="585502711f2ed284be4b7d4f4cbfdd64b80f43da" translate="yes" xml:space="preserve">
          <source>The name of the template to use by default when rendering this routes template.</source>
          <target state="translated">渲染该路由模板时默认使用的模板名称。</target>
        </trans-unit>
        <trans-unit id="66bd3365f2c2e07363112e9b122a98da62e8cf5e" translate="yes" xml:space="preserve">
          <source>The named arguments to the helper</source>
          <target state="translated">助手的命名参数</target>
        </trans-unit>
        <trans-unit id="a509b315f0cde9d1bc56906fc1ff01f0fa7cd5eb" translate="yes" xml:space="preserve">
          <source>The names are bound in the order that they are passed to &lt;code&gt;yield&lt;/code&gt; in the component template.</source>
          <target state="translated">名称按照它们传递以在组件模板中 &lt;code&gt;yield&lt;/code&gt; 的顺序进行绑定。</target>
        </trans-unit>
        <trans-unit id="af735066725f72033af215f7de9ba3c390ea1309" translate="yes" xml:space="preserve">
          <source>The nested helper is called first returning &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; only if &lt;code&gt;isFueled&lt;/code&gt; is true. Then the inline expression is called, rendering the nested helper's value (&lt;code&gt;&quot;zoooom&quot;&lt;/code&gt;) only if &lt;code&gt;isFast&lt;/code&gt; is true.</source>
          <target state="translated">仅当 &lt;code&gt;isFueled&lt;/code&gt; 为true时，嵌套帮助程序 &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; 称为首先返回&amp;ldquo; zoooom&amp;rdquo;。然后调用内联表达式，仅当 &lt;code&gt;isFast&lt;/code&gt; 为true时，才渲染嵌套的帮助程序的值（ &lt;code&gt;&quot;zoooom&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d1a53ba45425a490db9af03715c5bdb612eaf800" translate="yes" xml:space="preserve">
          <source>The nested keys &lt;code&gt;source.pointer&lt;/code&gt; detail which specific element of the request data was invalid.</source>
          <target state="translated">嵌套键 &lt;code&gt;source.pointer&lt;/code&gt; 详细说明请求数据的哪个特定元素无效。</target>
        </trans-unit>
        <trans-unit id="6c12d2d252b58333d9ab6aaa11b78422d2a1172e" translate="yes" xml:space="preserve">
          <source>The new owner object of the object instance.</source>
          <target state="translated">对象实例的新所有者对象。</target>
        </trans-unit>
        <trans-unit id="0086db850d74927843eccf283540af44ecddc2fe" translate="yes" xml:space="preserve">
          <source>The new property value</source>
          <target state="translated">新的财产价值</target>
        </trans-unit>
        <trans-unit id="7f13234869d6044bbe39065b2ac29afdf278e2d5" translate="yes" xml:space="preserve">
          <source>The normal behavior for a function defined in &lt;code&gt;actions&lt;/code&gt; does not receive the browser event as an argument. So, the function definition for the action cannot define an event parameter. The following example demonstrates the default behavior using an action.</source>
          <target state="translated">&lt;code&gt;actions&lt;/code&gt; 中定义的功能的正常行为不会将浏览器事件作为参数接收。因此，操作的函数定义无法定义事件参数。下面的示例演示使用操作的默认行为。</target>
        </trans-unit>
        <trans-unit id="ba645aaa52d49d720b744b7458d92f0fa898b311" translate="yes" xml:space="preserve">
          <source>The normalized JSON format that Ember Data expects is a &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; document with a couple of additional restrictions.</source>
          <target state="translated">Ember Data期望的规范化JSON格式是&lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt;文档，其中还有一些其他限制。</target>
        </trans-unit>
        <trans-unit id="7c8de9de7d8715fcd640ec12ea5f6988255f2d0e" translate="yes" xml:space="preserve">
          <source>The normalized JSON object that Ember Data expects a serializer to return looks like this:</source>
          <target state="translated">Ember Data期望序列化器返回的标准化JSON对象是这样的。</target>
        </trans-unit>
        <trans-unit id="00b1abab6fd9ec65b4425bed0a462ed09048b6e0" translate="yes" xml:space="preserve">
          <source>The normalized payload</source>
          <target state="translated">归一化有效载荷</target>
        </trans-unit>
        <trans-unit id="a349a314b9df21dfbe3354d6dd9d45d18d122cff" translate="yes" xml:space="preserve">
          <source>The number of items that were added. If you pass `null` assumes 0.</source>
          <target state="translated">增加的项目数。如果你通过`null`,则假设为0。</target>
        </trans-unit>
        <trans-unit id="2d2399ceba6066f06edc5df6a7ec02fa87dba439" translate="yes" xml:space="preserve">
          <source>The number of items that were removed. If you pass `null` assumes 0</source>
          <target state="translated">被删除的项目数。如果传递 &quot;null&quot;,则假设为0。</target>
        </trans-unit>
        <trans-unit id="91de528748ecbc74aef2c6d96b0c6e4f03f6131b" translate="yes" xml:space="preserve">
          <source>The number of items that will be added. If you pass `null` assumes 0.</source>
          <target state="translated">要添加的项目数。如果你通过`null`,则假设为0。</target>
        </trans-unit>
        <trans-unit id="975c27e833e6ea26acbcf63ae5b7ecc849744c75" translate="yes" xml:space="preserve">
          <source>The number of items that will be removed. If you pass `null` assumes 0</source>
          <target state="translated">要删除的项目数。如果你通过 &quot;null&quot;,则假设为0。</target>
        </trans-unit>
        <trans-unit id="639768cbeb0d904ac01029f55e97c377a305a71d" translate="yes" xml:space="preserve">
          <source>The object containing named arguments is passed as the second argument to the helper function. Here is our example from above, updated to support the optional &lt;code&gt;sign&lt;/code&gt; option:</source>
          <target state="translated">包含命名参数的对象将作为第二个参数传递给辅助函数。这是上面的示例，已更新为支持可选的 &lt;code&gt;sign&lt;/code&gt; 选项：</target>
        </trans-unit>
        <trans-unit id="c51a687fc71aeecf9c4dd958d6df740581650633" translate="yes" xml:space="preserve">
          <source>The object observing the array.</source>
          <target state="translated">观察阵列的对象。</target>
        </trans-unit>
        <trans-unit id="1f67ed68402a22d74098c4257ec3b53cafc15f90" translate="yes" xml:space="preserve">
          <source>The object returned from &lt;code&gt;RSVP.defer&lt;/code&gt; is a plain object with three properties:</source>
          <target state="translated">从 &lt;code&gt;RSVP.defer&lt;/code&gt; 返回的对象是具有三个属性的普通对象：</target>
        </trans-unit>
        <trans-unit id="dcce5060e65cd2c99b0f4c620ad0472078d080ff" translate="yes" xml:space="preserve">
          <source>The object stays intact until the end of the run loop at which point the &lt;code&gt;isDestroyed&lt;/code&gt; flag is set.</source>
          <target state="translated">该对象将保持不变，直到运行循环结束为止，此时将设置 &lt;code&gt;isDestroyed&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="95c8a20f0925b5bbf96fad0499bac57039d137a8" translate="yes" xml:space="preserve">
          <source>The object to add to the enumerable.</source>
          <target state="translated">要添加到enumerable中的对象。</target>
        </trans-unit>
        <trans-unit id="3cf4a0d87f7ef69ab445296f735a615e0fc9dd1e" translate="yes" xml:space="preserve">
          <source>The object to assign into</source>
          <target state="translated">要分配到的对象</target>
        </trans-unit>
        <trans-unit id="8af03bf022efd9a0cec5228d3be213b9c85f758e" translate="yes" xml:space="preserve">
          <source>The object to check for the method</source>
          <target state="translated">要检查方法的对象</target>
        </trans-unit>
        <trans-unit id="0955c243cfd3d12d78e568b378af83363f51f222" translate="yes" xml:space="preserve">
          <source>The object to clone</source>
          <target state="translated">要克隆的对象</target>
        </trans-unit>
        <trans-unit id="39bee534497a07212f93576f4aad1e60752a86d9" translate="yes" xml:space="preserve">
          <source>The object to copy properties from</source>
          <target state="translated">要从对象中复制属性</target>
        </trans-unit>
        <trans-unit id="65d2fc606502a1327b27b00711f4cf8c80ff80d1" translate="yes" xml:space="preserve">
          <source>The object to merge into</source>
          <target state="translated">要合并的对象</target>
        </trans-unit>
        <trans-unit id="e4f8472045258fdd0fca12c9ca54919b2134defc" translate="yes" xml:space="preserve">
          <source>The object to modify.</source>
          <target state="translated">要修改的对象。</target>
        </trans-unit>
        <trans-unit id="79abb60263af3837b02a264e27ebb51b2ad3b831" translate="yes" xml:space="preserve">
          <source>The object to remove from the enumerable.</source>
          <target state="translated">要从enumerable中删除的对象。</target>
        </trans-unit>
        <trans-unit id="01c87d6a0a7d961661808d6108688f7202e3182f" translate="yes" xml:space="preserve">
          <source>The object to retrieve from.</source>
          <target state="translated">要检索的对象。</target>
        </trans-unit>
        <trans-unit id="2bb20788eae84e07081d526563f29dae4b083856" translate="yes" xml:space="preserve">
          <source>The object to search for.</source>
          <target state="translated">要搜索的对象。</target>
        </trans-unit>
        <trans-unit id="85154a5e735c921ec2b690de03758de42871ced1" translate="yes" xml:space="preserve">
          <source>The object to set</source>
          <target state="translated">要设置的对象</target>
        </trans-unit>
        <trans-unit id="c3f77d96cdc8b56e6910e3df6d5a9f1c5613f0e4" translate="yes" xml:space="preserve">
          <source>The object to test</source>
          <target state="translated">要测试的对象</target>
        </trans-unit>
        <trans-unit id="2bf3733b3229286b376b10082612e1163e376d99" translate="yes" xml:space="preserve">
          <source>The object to which actions from the view should be sent.</source>
          <target state="translated">视图中的操作应发送到哪个对象。</target>
        </trans-unit>
        <trans-unit id="dd986381270f07f0062f1ef0c9b835aa255c1311" translate="yes" xml:space="preserve">
          <source>The objects to copy properties from</source>
          <target state="translated">要复制属性的对象</target>
        </trans-unit>
        <trans-unit id="372e877cd43ae664673ebc043c2112a916e22b72" translate="yes" xml:space="preserve">
          <source>The observer object.</source>
          <target state="translated">观察者对象;</target>
        </trans-unit>
        <trans-unit id="711d7a87524d1dd84793229cd8b47d431d1d8180" translate="yes" xml:space="preserve">
          <source>The options passed into the &lt;code&gt;DS.attr&lt;/code&gt; function when the attribute is declared on the model is also available in the transform.</source>
          <target state="translated">在模型上声明属性时传递给 &lt;code&gt;DS.attr&lt;/code&gt; 函数的选项在转换中也可用。</target>
        </trans-unit>
        <trans-unit id="c4f866c519a5e8c630cd9a5e6dd63f20316368ea" translate="yes" xml:space="preserve">
          <source>The options to be passed to jQuery.Event.</source>
          <target state="translated">传递给jQuery.Event的选项。</target>
        </trans-unit>
        <trans-unit id="56c3cd7a661678595c73eb270a9318b5eac13978" translate="yes" xml:space="preserve">
          <source>The other major benefit to the above approach is that &lt;code&gt;run.next&lt;/code&gt; introduces an element of non-determinism, which can make things much harder to test, due to its reliance on &lt;code&gt;setTimeout&lt;/code&gt;; it's much harder to guarantee the order of scheduled operations when they are scheduled outside of the current run loop, i.e. with &lt;code&gt;run.next&lt;/code&gt;.</source>
          <target state="translated">上述方法的另一个主要优点是 &lt;code&gt;run.next&lt;/code&gt; 引入了不确定性元素，由于它依赖于 &lt;code&gt;setTimeout&lt;/code&gt; ，因此使事情变得很难测试。当调度的操作在当前运行循环之外进行调度（例如，使用 &lt;code&gt;run.next&lt;/code&gt; 进行调度）时，要保证它们的顺序要困难得多。</target>
        </trans-unit>
        <trans-unit id="c14211cb494d4ea352d68e2ab9fb3c84186d8bce" translate="yes" xml:space="preserve">
          <source>The other one is &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt;&lt;code&gt;replaceWith()&lt;/code&gt;&lt;/a&gt; which works the same way as &lt;code&gt;transitionTo()&lt;/code&gt;. The only difference between them is how they manage history. &lt;code&gt;replaceWith()&lt;/code&gt; substitutes the current route entry and replaces it with that of the route we are redirecting to, while &lt;code&gt;transitionTo()&lt;/code&gt; leaves the entry for the current route and creates a new one for the redirection.</source>
          <target state="translated">另一个是&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_replaceWith&quot;&gt; &lt;code&gt;replaceWith()&lt;/code&gt; &lt;/a&gt;，其工作方式与 &lt;code&gt;transitionTo()&lt;/code&gt; 相同。它们之间的唯一区别是它们如何管理历史记录。 &lt;code&gt;replaceWith()&lt;/code&gt; 替换当前路由条目，并用我们重定向到的路由条目替换它，而 &lt;code&gt;transitionTo()&lt;/code&gt; 保留当前路由条目，并为重定向创建一个新条目。</target>
        </trans-unit>
        <trans-unit id="acc6d06fca4a644df1fa4d9b90eb32abb2585f8e" translate="yes" xml:space="preserve">
          <source>The output of the above would be:</source>
          <target state="translated">上面的输出将是:</target>
        </trans-unit>
        <trans-unit id="3ab0c6bf981d7228ae87a74eeb932536510cc267" translate="yes" xml:space="preserve">
          <source>The parameter supplied to &lt;code&gt;partial&lt;/code&gt; can also be a path to a property containing a template name, e.g.:</source>
          <target state="translated">提供给 &lt;code&gt;partial&lt;/code&gt; 的参数也可以是包含模板名称的属性的路径，例如：</target>
        </trans-unit>
        <trans-unit id="efd37fb222c7e149dff6b49705240fe10a539217" translate="yes" xml:space="preserve">
          <source>The parameters can be referred to just like named parameters:</source>
          <target state="translated">参数可以像命名参数一样被引用。</target>
        </trans-unit>
        <trans-unit id="a227f12b3522d68730e7b36f0fc78aec0552a35a" translate="yes" xml:space="preserve">
          <source>The parameters can then be referred to by enumerating over the list:</source>
          <target state="translated">然后可以通过列举列表来引用参数。</target>
        </trans-unit>
        <trans-unit id="42fc8fe2689da3394272f78c6f0c5ad6c77884c6" translate="yes" xml:space="preserve">
          <source>The parent engine instance.</source>
          <target state="translated">父引擎实例。</target>
        </trans-unit>
        <trans-unit id="c4808789947bb1b66c38cf5e3bcb54bc1949343c" translate="yes" xml:space="preserve">
          <source>The passed in hash</source>
          <target state="translated">传入的哈希值</target>
        </trans-unit>
        <trans-unit id="15aed930cca97a392fc79410e1ca9b8700445feb" translate="yes" xml:space="preserve">
          <source>The passed value</source>
          <target state="translated">通过的值</target>
        </trans-unit>
        <trans-unit id="91af4f77ef8ac669f3229c88e3020c84a9befbfd" translate="yes" xml:space="preserve">
          <source>The path to the 'from' side of the binding. Must be relative to obj or a global path.</source>
          <target state="translated">通往绑定的 &quot;from &quot;侧的路径。必须是相对于obj或全局路径。</target>
        </trans-unit>
        <trans-unit id="c9f763dddcc9c776652d4d1ccb6796bf300cbcd8" translate="yes" xml:space="preserve">
          <source>The path to the 'to' side of the binding. Must be relative to obj.</source>
          <target state="translated">通往绑定 &quot;to &quot;端的路径。必须是相对于obj的。</target>
        </trans-unit>
        <trans-unit id="3646b2c1a754bb29df7ef8518480d66f2cd86f09" translate="yes" xml:space="preserve">
          <source>The positional arguments to the helper</source>
          <target state="translated">帮手的位置论证</target>
        </trans-unit>
        <trans-unit id="9b2ab9413880d940f49d12c1781a196be650c645" translate="yes" xml:space="preserve">
          <source>The post's comments would then be available in your template as &lt;code&gt;model.comments&lt;/code&gt;.</source>
          <target state="translated">该帖子的评论将在您的模板中作为 &lt;code&gt;model.comments&lt;/code&gt; 提供。</target>
        </trans-unit>
        <trans-unit id="8884e5a83dfe81deaf4fd5eb5cc8081003657de6" translate="yes" xml:space="preserve">
          <source>The primary purpose of this class is to create hooks that can be implemented by an adapter for various test frameworks.</source>
          <target state="translated">该类的主要目的是创建可由适配器实现的钩子,用于各种测试框架。</target>
        </trans-unit>
        <trans-unit id="7c9ce1bc115a79248bbaed83eaf438de9db2bc44" translate="yes" xml:space="preserve">
          <source>The primary way of interacting with a promise is through its &lt;code&gt;then&lt;/code&gt; method, which registers callbacks to receive either a promise's eventual value or the reason why the promise cannot be fulfilled.</source>
          <target state="translated">与承诺进行交互的主要方式是通过其 &lt;code&gt;then&lt;/code&gt; 方法，该方法注册回调以接收承诺的最终值或承诺无法实现的原因。</target>
        </trans-unit>
        <trans-unit id="59d128dbc75fda5894fb5dea6412a07651640a9e" translate="yes" xml:space="preserve">
          <source>The process of removing the feature flags from the resulting build output is handled by &lt;a href=&quot;https://github.com/thomasboyt/defeatureify&quot;&gt;&lt;code&gt;defeatureify&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从得到的构建输出中删除功能标志的过程由&lt;a href=&quot;https://github.com/thomasboyt/defeatureify&quot;&gt; &lt;code&gt;defeatureify&lt;/code&gt; &lt;/a&gt;处理。</target>
        </trans-unit>
        <trans-unit id="291f652ab49a4eb74576b1a1bb6950593d5373e8" translate="yes" xml:space="preserve">
          <source>The promise whose fulfillment value is being proxied by this object.</source>
          <target state="translated">承诺的实现值被此对象代理。</target>
        </trans-unit>
        <trans-unit id="cc7758b607302e53a0da31210b9497cab24a954d" translate="yes" xml:space="preserve">
          <source>The property key to be notified about.</source>
          <target state="translated">要通知的房产钥匙。</target>
        </trans-unit>
        <trans-unit id="11ef23efc9663b08bd99db214c95e5dc5d1cd5ea" translate="yes" xml:space="preserve">
          <source>The property key to retrieve</source>
          <target state="translated">检索的属性键</target>
        </trans-unit>
        <trans-unit id="841185ba10823f766df7d71131c49e92c5b6ee9e" translate="yes" xml:space="preserve">
          <source>The property key to set</source>
          <target state="translated">要设置的属性键</target>
        </trans-unit>
        <trans-unit id="37b81ff8e5f127d9996f4e45ec5e0deebeaf6ce8" translate="yes" xml:space="preserve">
          <source>The property path to set</source>
          <target state="translated">要设置的属性路径</target>
        </trans-unit>
        <trans-unit id="fb6eddea047f11a03af1d5ee0f7e00977dfd358c" translate="yes" xml:space="preserve">
          <source>The property to retrieve</source>
          <target state="translated">要检索的属性</target>
        </trans-unit>
        <trans-unit id="8611964c338d3f650ff1f5dffbfb19d6cfa92a6b" translate="yes" xml:space="preserve">
          <source>The property to set</source>
          <target state="translated">要设置的属性</target>
        </trans-unit>
        <trans-unit id="34a11ee7cca8e3277193e578a732c953c3658ceb" translate="yes" xml:space="preserve">
          <source>The property value or the defaultValue.</source>
          <target state="translated">属性值或默认值。</target>
        </trans-unit>
        <trans-unit id="bb368158afde88e0d072275a3061843e6612c710" translate="yes" xml:space="preserve">
          <source>The property value or undefined.</source>
          <target state="translated">属性值或未定义。</target>
        </trans-unit>
        <trans-unit id="19f5671dd388019c1e7b9993c2e1610d92a167e3" translate="yes" xml:space="preserve">
          <source>The provided controller will be one resolved based on the name of this route.</source>
          <target state="translated">所提供的控制器将是根据该途径的名称解析的控制器。</target>
        </trans-unit>
        <trans-unit id="43f2ede5675faaa434d556fbe9e5fc7a71392d4b" translate="yes" xml:space="preserve">
          <source>The purpose of the Ember Instrumentation module is to provide efficient, general-purpose instrumentation for Ember.</source>
          <target state="translated">Ember Instrumentation模块的目的是为Ember提供高效、通用的仪表。</target>
        </trans-unit>
        <trans-unit id="423ed4fcc7c2521ed4d18b49830304fce9133a79" translate="yes" xml:space="preserve">
          <source>The real value of &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt;&lt;code&gt;{{component}}&lt;/code&gt;&lt;/a&gt; comes from being able to dynamically pick the component being rendered. Below is an example of using the helper as a means of choosing different components for displaying different kinds of posts:</source>
          <target state="translated">&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_component&quot;&gt; &lt;code&gt;{{component}}&lt;/code&gt; &lt;/a&gt;的真正价值在于能够动态选择要渲染的组件。下面是使用帮助程序作为选择不同组件以显示不同类型帖子的一种示例：</target>
        </trans-unit>
        <trans-unit id="94d0b948c12d2a0e9c041073d0e9e25cd67c32bc" translate="yes" xml:space="preserve">
          <source>The record passed as the first parameter is where you should stash state about the record if needed; you should never store data on the state object itself.</source>
          <target state="translated">作为第一个参数传递的记录是你在需要的时候应该存储关于记录的状态的地方,你永远不应该在状态对象本身存储数据。</target>
        </trans-unit>
        <trans-unit id="0e847eeb0e7b887a5ab5a982823e0c83a639d123" translate="yes" xml:space="preserve">
          <source>The reduced value.</source>
          <target state="translated">减少的价值。</target>
        </trans-unit>
        <trans-unit id="6e588a2c9e2c86b51f204f41c83c576f838e6536" translate="yes" xml:space="preserve">
          <source>The relationship descriptor argument is an object with the following properties.</source>
          <target state="translated">关系描述符参数是一个具有以下属性的对象。</target>
        </trans-unit>
        <trans-unit id="f282f5d1355901b15ca747b3a5ab165ce7bc1457" translate="yes" xml:space="preserve">
          <source>The reload behavior is configured either via the passed &lt;code&gt;options&lt;/code&gt; hash or the result of the adapter's &lt;code&gt;shouldReloadRecord&lt;/code&gt;.</source>
          <target state="translated">可通过传递的 &lt;code&gt;options&lt;/code&gt; 哈希值或适配器的 &lt;code&gt;shouldReloadRecord&lt;/code&gt; 的结果来配置重载行为。</target>
        </trans-unit>
        <trans-unit id="db525ceb99e1840957b4e97df93348fb6ea8f6f3" translate="yes" xml:space="preserve">
          <source>The request is made through the adapters' &lt;code&gt;queryRecord&lt;/code&gt;:</source>
          <target state="translated">该请求是通过适配器的 &lt;code&gt;queryRecord&lt;/code&gt; 发出的：</target>
        </trans-unit>
        <trans-unit id="41441812d681fe9fb5a2b27e3821d50566b0e53f" translate="yes" xml:space="preserve">
          <source>The resolver instance of the application being debugged. This property will be injected on creation.</source>
          <target state="translated">被调试的应用程序的解析器实例。此属性将在创建时注入。</target>
        </trans-unit>
        <trans-unit id="473773a9f0ae3a524717a98bf2bff757a44c072d" translate="yes" xml:space="preserve">
          <source>The resulting template render logic would be:</source>
          <target state="translated">由此产生的模板渲染逻辑将是。</target>
        </trans-unit>
        <trans-unit id="64e24c1771c3d34bfc6f390eb86af08b179c758c" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;then&lt;/code&gt; is itself a promise. This second, 'downstream' promise is resolved with the return value of the first promise's fulfillment or rejection handler, or rejected if the handler throws an exception.</source>
          <target state="translated">&lt;code&gt;then&lt;/code&gt; 的返回值本身就是一个承诺。第二个&amp;ldquo;下游&amp;rdquo;承诺将通过第一个承诺的履行或拒绝处理程序的返回值来解决，如果处理程序抛出异常，则将其拒绝。</target>
        </trans-unit>
        <trans-unit id="8d20833918be8aaca0fedabee7a9e43ef5581cff" translate="yes" xml:space="preserve">
          <source>The returned promise is fulfilled with a hash that has the same key names as the &lt;code&gt;promises&lt;/code&gt; object argument. If any of the values in the object are not promises, they will be copied over to the fulfilled object and marked with state 'fulfilled'.</source>
          <target state="translated">返回的promise通过哈希实现，该哈希具有与 &lt;code&gt;promises&lt;/code&gt; 对象参数相同的键名。如果对象中的任何值都不是promise，则将它们复制到已实现的对象并标记为状态&amp;ldquo;已实现&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="8735a66c3c58858c4137385dfcf321c94c6cd283" translate="yes" xml:space="preserve">
          <source>The returned value is placed where the &lt;code&gt;{{}}&lt;/code&gt; is called. The above style is called &quot;inline&quot;. A second style of helper usage is called &quot;block&quot;. For example:</source>
          <target state="translated">返回的值放在调用 &lt;code&gt;{{}}&lt;/code&gt; 的位置。上面的样式称为&amp;ldquo;内联&amp;rdquo;。辅助使用的第二种样式称为&amp;ldquo;块&amp;rdquo;。例如：</target>
        </trans-unit>
        <trans-unit id="7e2e21dc44f676bf1bd060e0463dcf7e7e820d3a" translate="yes" xml:space="preserve">
          <source>The root DOM element of the Application. This can be specified as an element or a &lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery-compatible selector string&lt;/a&gt;.</source>
          <target state="translated">应用程序的根DOM元素。可以将其指定为元素或&lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery兼容的选择器字符串&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eecac9c9d2d99121f7c3692d02975aa4bfbc76ff" translate="yes" xml:space="preserve">
          <source>The root object of the transform.</source>
          <target state="translated">变换的根对象。</target>
        </trans-unit>
        <trans-unit id="1bb1190332a9040ced62948350a42acdb8d03375" translate="yes" xml:space="preserve">
          <source>The route defined above will by default use the &lt;code&gt;blog-post.js&lt;/code&gt; route handler, the &lt;code&gt;blog-post.hbs&lt;/code&gt; template, and be referred to as &lt;code&gt;blog-post&lt;/code&gt; in any &lt;code&gt;{{link-to}}&lt;/code&gt; helpers.</source>
          <target state="translated">上面定义的路由默认情况下将使用 &lt;code&gt;blog-post.js&lt;/code&gt; 路由处理程序， &lt;code&gt;blog-post.hbs&lt;/code&gt; 模板，并且在任何 &lt;code&gt;{{link-to}}&lt;/code&gt; 帮助器中都称为 &lt;code&gt;blog-post&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1547b257edc696cf9d97b9973174fdd903d969e5" translate="yes" xml:space="preserve">
          <source>The route handler then typically does two things:</source>
          <target state="translated">然后,路由处理程序通常做两件事。</target>
        </trans-unit>
        <trans-unit id="5a25dcb793cf10fb01f14c9659469d0ea089350c" translate="yes" xml:space="preserve">
          <source>The route that triggered the loading event</source>
          <target state="translated">触发加载事件的途径</target>
        </trans-unit>
        <trans-unit id="40ef35919f724f529657ab517634c7e128df098d" translate="yes" xml:space="preserve">
          <source>The route will then set the return value from the &lt;code&gt;model&lt;/code&gt; hook as the &lt;code&gt;model&lt;/code&gt; property of the controller. You will then be able to access the controller's &lt;code&gt;model&lt;/code&gt; property in your template:</source>
          <target state="translated">然后，该路线将从 &lt;code&gt;model&lt;/code&gt; 挂钩中设置返回值作为控制器的 &lt;code&gt;model&lt;/code&gt; 属性。然后，您将能够在模板中访问控制器的 &lt;code&gt;model&lt;/code&gt; 属性：</target>
        </trans-unit>
        <trans-unit id="d9055510d33898a55dfaabcdf80c77508cc19202" translate="yes" xml:space="preserve">
          <source>The router considers any object with a &lt;code&gt;then()&lt;/code&gt; method defined on it to be a promise.</source>
          <target state="translated">路由器将定义了 &lt;code&gt;then()&lt;/code&gt; 方法的任何对象视为承诺。</target>
        </trans-unit>
        <trans-unit id="20ae5f1ef171342e36f277fd6cd573513d476f32" translate="yes" xml:space="preserve">
          <source>The run loop API calls that &lt;em&gt;schedule&lt;/em&gt; work, i.e. &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_schedule&quot;&gt;&lt;code&gt;run.schedule&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce&quot;&gt;&lt;code&gt;run.scheduleOnce&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt;&lt;code&gt;run.once&lt;/code&gt;&lt;/a&gt; have the property that they will approximate a run loop for you if one does not already exist. These automatically created run loops we call &lt;em&gt;autoruns&lt;/em&gt;.</source>
          <target state="translated">运行循环API调用该&lt;em&gt;调度&lt;/em&gt;工作，即&lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_schedule&quot;&gt; &lt;code&gt;run.schedule&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_scheduleOnce&quot;&gt; &lt;code&gt;run.scheduleOnce&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt; &lt;code&gt;run.once&lt;/code&gt; &lt;/a&gt;具有以下属性：如果一个运行循环不存在，它们将为您近似一个运行循环。这些自动创建的运行循环我们称为&lt;em&gt;autoruns&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="aab8740741c5d7b401984a17e059a4e0f2aa2178" translate="yes" xml:space="preserve">
          <source>The same applies to &lt;code&gt;belongsTo&lt;/code&gt; relationships:</source>
          <target state="translated">这同样适用于 &lt;code&gt;belongsTo&lt;/code&gt; 关系：</target>
        </trans-unit>
        <trans-unit id="79f91cf22c7dca84c509c4f77da4cb434629965b" translate="yes" xml:space="preserve">
          <source>The same rules apply to arrays of primitives.</source>
          <target state="translated">同样的规则也适用于基元数组。</target>
        </trans-unit>
        <trans-unit id="fd7b8fd9eac5480b43026cdd22b54a66a4559b81" translate="yes" xml:space="preserve">
          <source>The scroll happens on &lt;code&gt;didRender&lt;/code&gt;, where it will scroll the component's container to the element with the selected class name.</source>
          <target state="translated">滚动发生在 &lt;code&gt;didRender&lt;/code&gt; 上，它将组件的容器滚动到具有选定类名的元素。</target>
        </trans-unit>
        <trans-unit id="0d4cba2063c093b6e0028f97cd82cdeaa6816998" translate="yes" xml:space="preserve">
          <source>The second parameter is the optional options hash. Available options are:</source>
          <target state="translated">第二个参数是可选的选项哈希。可用的选项有:</target>
        </trans-unit>
        <trans-unit id="8b090381a04a9e48621d42bb0bf53fa4cba4f1e4" translate="yes" xml:space="preserve">
          <source>The semantic version</source>
          <target state="translated">语义版本</target>
        </trans-unit>
        <trans-unit id="5f38bd2b1df14793a918cfb86c695e7bb1738385" translate="yes" xml:space="preserve">
          <source>The serialized value</source>
          <target state="translated">序列化值</target>
        </trans-unit>
        <trans-unit id="1441caa2180aa5deaa1d21c6c8bad5b37a9eaf47" translate="yes" xml:space="preserve">
          <source>The serializer properly converts the blog request payload into a blog post model object.</source>
          <target state="translated">序列器正确地将博客请求有效载荷转换为博客文章模型对象。</target>
        </trans-unit>
        <trans-unit id="c14938d7774e56e262de01aeb6eb9013ddc6fc80" translate="yes" xml:space="preserve">
          <source>The setup is largely similar to how Ember works out-of-the-box. Normally, Ember will boot a default instance for your Application on &quot;DOM ready&quot;. However, you can customize this behavior by disabling &lt;code&gt;autoboot&lt;/code&gt;.</source>
          <target state="translated">该设置与Ember开箱即用的工作方式非常相似。通常，Ember将在&amp;ldquo; DOM ready&amp;rdquo;上为您的应用程序启动默认实例。但是，您可以通过禁用 &lt;code&gt;autoboot&lt;/code&gt; 来自定义此行为。</target>
        </trans-unit>
        <trans-unit id="44bd33d4e5c5dbd425e1b01d352cce7c15b457b1" translate="yes" xml:space="preserve">
          <source>The sorted array.</source>
          <target state="translated">排序后的数组。</target>
        </trans-unit>
        <trans-unit id="8bbcdf9dc99641ff8f9df51339a76d30dd24a554" translate="yes" xml:space="preserve">
          <source>The starting index in the array that did change.</source>
          <target state="translated">数组中确实发生变化的起始索引。</target>
        </trans-unit>
        <trans-unit id="edab6dfda8b0a675cd3b277a658515192ee54ac2" translate="yes" xml:space="preserve">
          <source>The starting index in the array that will change.</source>
          <target state="translated">数组中将要改变的起始索引。</target>
        </trans-unit>
        <trans-unit id="565a8bbec3976cbbd11685d7a0db28bb110f442f" translate="yes" xml:space="preserve">
          <source>The store contains all of the data for records loaded from the server. It is also responsible for creating instances of &lt;code&gt;DS.Model&lt;/code&gt; that wrap the individual data for a record, so that they can be bound to in your Handlebars templates.</source>
          <target state="translated">存储中包含从服务器加载的记录的所有数据。它还负责创建 &lt;code&gt;DS.Model&lt;/code&gt; 实例，该实例将单个数据包装成一条记录，以便可以将它们绑定到您的Handlebars模板中。</target>
        </trans-unit>
        <trans-unit id="bd1641cbe5dc00ca11bff91f0a9e4a4c7d1b52e6" translate="yes" xml:space="preserve">
          <source>The store object is available in controllers and routes using &lt;code&gt;this.get('store')&lt;/code&gt;.</source>
          <target state="translated">store对象在控制器中可用，并且可以使用 &lt;code&gt;this.get('store')&lt;/code&gt; 进行路由。</target>
        </trans-unit>
        <trans-unit id="b9b1269778250371106783075e2d9ba12e8b0581" translate="yes" xml:space="preserve">
          <source>The store provides multiple ways to create new record objects. They have some subtle differences in their use which are detailed below:</source>
          <target state="translated">商店提供了多种创建新记录对象的方法。它们在使用上有一些细微的差别,下面将详细介绍。</target>
        </trans-unit>
        <trans-unit id="c2c599c05627277afc6c6ecc983a68b24eda3344" translate="yes" xml:space="preserve">
          <source>The store then takes that JSON, initializes the record with the JSON data, and resolves the promise returned to your application with the newly-loaded record.</source>
          <target state="translated">然后,存储会接受该JSON,用JSON数据初始化该记录,并用新加载的记录解析返回给你的应用的承诺。</target>
        </trans-unit>
        <trans-unit id="41b68f114ba57e357ad03f70aa549d7262c8caa5" translate="yes" xml:space="preserve">
          <source>The store will automatically cache records for you. If a record had already been loaded, asking for it a second time will always return the same object instance. This minimizes the number of round-trips to the server, and allows your application to render its UI to the user as fast as possible.</source>
          <target state="translated">商店会自动为你缓存记录。如果一条记录已经被加载了,第二次请求它将总是返回相同的对象实例。这样可以最大限度地减少到服务器的往返次数,让您的应用程序以最快的速度向用户呈现其UI。</target>
        </trans-unit>
        <trans-unit id="01207237cd4ccf3b900d21e60db5b725e70f8924" translate="yes" xml:space="preserve">
          <source>The store will call &lt;code&gt;findMany&lt;/code&gt; instead of multiple &lt;code&gt;findRecord&lt;/code&gt; requests to find multiple records at once if coalesceFindRequests is true.</source>
          <target state="translated">如果coalesceFindRequests为true，则存储将调用 &lt;code&gt;findMany&lt;/code&gt; 而不是多个 &lt;code&gt;findRecord&lt;/code&gt; 请求来一次查找多个记录。</target>
        </trans-unit>
        <trans-unit id="d2f69dc65e213b2fb8cdb1b7cbc4e005ab648a25" translate="yes" xml:space="preserve">
          <source>The store's &lt;code&gt;push()&lt;/code&gt; method is a low level API which accepts a JSON API document with a few important differences from the JSON API document that the JSONAPISerializer accepts. The type name in the JSON API document must match the type name of the model exactly (In the example above the type is &lt;code&gt;album&lt;/code&gt; because the model is defined in &lt;code&gt;app/models/album.js&lt;/code&gt;). Attributes and relationship names must match the casing of the properties defined on the Model class.</source>
          <target state="translated">商店的 &lt;code&gt;push()&lt;/code&gt; 方法是一个低级API，它接受的JSON API文档与JSONAPISerializer接受的JSON API文档有一些重要区别。 JSON API文档中的类型名称必须与模型的类型名称完全匹配（在上面的示例中，该类型为 &lt;code&gt;album&lt;/code&gt; 因为模型是在 &lt;code&gt;app/models/album.js&lt;/code&gt; 中定义的）。属性和关系名称必须与Model类上定义的属性的大小写匹配。</target>
        </trans-unit>
        <trans-unit id="ba2337f1b869281822cbec365330fc6ed3a87eb9" translate="yes" xml:space="preserve">
          <source>The string to camelize.</source>
          <target state="translated">的字符串,以camelize。</target>
        </trans-unit>
        <trans-unit id="e2b9d608f0fe83dbf1e7d9c07afcec863203911e" translate="yes" xml:space="preserve">
          <source>The string to capitalize.</source>
          <target state="translated">要大写的字符串。</target>
        </trans-unit>
        <trans-unit id="6562d656544896269e6510021a24eb0fe047f8cd" translate="yes" xml:space="preserve">
          <source>The string to dasherize.</source>
          <target state="translated">要涂抹的字符串。</target>
        </trans-unit>
        <trans-unit id="827deb88bf3cf7b323e93ba14d05290d5e8a6b48" translate="yes" xml:space="preserve">
          <source>The string to decamelize.</source>
          <target state="translated">要解焦的字符串。</target>
        </trans-unit>
        <trans-unit id="8aef10dc78a1b6b0b047d67f1b41e8c2eacf1322" translate="yes" xml:space="preserve">
          <source>The string to format</source>
          <target state="translated">要格式化的字符串</target>
        </trans-unit>
        <trans-unit id="2b0b9ffa844d16267c8115855979ed48b6d4bc64" translate="yes" xml:space="preserve">
          <source>The string to format.</source>
          <target state="translated">要格式化的字符串。</target>
        </trans-unit>
        <trans-unit id="8bb5d2b6d14eab5fb11c8b4cd7eded396880eafd" translate="yes" xml:space="preserve">
          <source>The string to split</source>
          <target state="translated">要分割的字符串</target>
        </trans-unit>
        <trans-unit id="504f1fdddf0d3ae9e6968c1488e9aaed471044e1" translate="yes" xml:space="preserve">
          <source>The string to underscore.</source>
          <target state="translated">下划线的字符串。</target>
        </trans-unit>
        <trans-unit id="6b2ca2bba7cfc3b3d4f9eb164041ee4b3f478da7" translate="yes" xml:space="preserve">
          <source>The string values provided for the template name, and controller will eventually pass through to the resolver for lookup. See Ember.Resolver for how these are mapped to JavaScript objects in your application. The template to render into needs to be related to either the current route or one of its ancestors.</source>
          <target state="translated">为模板名称和控制器提供的字符串值将最终传递给解析器进行查找。请参阅Ember.Resolver,了解如何将这些值映射到应用程序中的JavaScript对象。要渲染到的模板需要与当前路由或其祖先之一相关。</target>
        </trans-unit>
        <trans-unit id="1c15310baae72447d4757eb2e55e534acbbc316b" translate="yes" xml:space="preserve">
          <source>The target object to invoke</source>
          <target state="translated">要调用的目标对象</target>
        </trans-unit>
        <trans-unit id="de10ba709439df9674dd354fe1c515eac06ba807" translate="yes" xml:space="preserve">
          <source>The target object to use</source>
          <target state="translated">要使用的目标对象</target>
        </trans-unit>
        <trans-unit id="54d029f20e1dadec96b103ccc865dfcca39add60" translate="yes" xml:space="preserve">
          <source>The target of the method to invoke.</source>
          <target state="translated">要调用的方法的目标。</target>
        </trans-unit>
        <trans-unit id="e2ed41e561ef82bfe2b3a4d933412915eae9db07" translate="yes" xml:space="preserve">
          <source>The target of the subscription</source>
          <target state="translated">认购的对象</target>
        </trans-unit>
        <trans-unit id="4ceffd13443beb5575ab1e4483fbd512664207b4" translate="yes" xml:space="preserve">
          <source>The template contains an &lt;a href=&quot;https://guides.emberjs.com/templates/input-helpers&quot;&gt;&lt;code&gt;{{input}}&lt;/code&gt;&lt;/a&gt; helper that renders as a text field, in which the user can type a pattern to filter the list of cities used in a search. The &lt;code&gt;value&lt;/code&gt; property of the &lt;code&gt;input&lt;/code&gt; will be kept in sync with the &lt;code&gt;value&lt;/code&gt; property in the component.</source>
          <target state="translated">该模板包含一个&lt;a href=&quot;https://guides.emberjs.com/templates/input-helpers&quot;&gt; &lt;code&gt;{{input}}&lt;/code&gt; &lt;/a&gt;帮助器，该帮助器呈现为文本字段，用户可以在其中键入模式来过滤搜索中使用的城市列表。的 &lt;code&gt;value&lt;/code&gt; 的属性的 &lt;code&gt;input&lt;/code&gt; 将被保持在同步与 &lt;code&gt;value&lt;/code&gt; 在组件属性。</target>
        </trans-unit>
        <trans-unit id="d74f4833f85af93d253619500c9b82c2db0b7e23" translate="yes" xml:space="preserve">
          <source>The template inside of the &lt;code&gt;{{#each-in}}&lt;/code&gt; block is repeated once for each key in the passed object. The first block parameter (&lt;code&gt;category&lt;/code&gt; in the above example) is the key for this iteration, while the second block parameter (&lt;code&gt;products&lt;/code&gt;) is the actual value of that key.</source>
          <target state="translated">对于传递的对象中的每个键， &lt;code&gt;{{#each-in}}&lt;/code&gt; 块内部的模板都重复一次。第一个块参数（上例中的 &lt;code&gt;category&lt;/code&gt; ）是此迭代的键，而第二个块参数（ &lt;code&gt;products&lt;/code&gt; ）是该键的实际值。</target>
        </trans-unit>
        <trans-unit id="722bc70d44379d1b5cfee1e8ad82e651eaf53bd8" translate="yes" xml:space="preserve">
          <source>The template inside of the &lt;code&gt;{{#each}}&lt;/code&gt; block will be repeated once for each item in the array, with the each item set to the &lt;code&gt;person&lt;/code&gt; block param.</source>
          <target state="translated">&lt;code&gt;{{#each}}&lt;/code&gt; 块内部的模板将针对数组中的每个项目重复一次，并且每个项目都设置为 &lt;code&gt;person&lt;/code&gt; 块参数。</target>
        </trans-unit>
        <trans-unit id="e14b256b8bf613a58dde6fd95e9abcd1338adcd7" translate="yes" xml:space="preserve">
          <source>The test locates the results of the search by finding elements with a class of &lt;code&gt;listing&lt;/code&gt;, which we gave to our &lt;code&gt;rental-listing&lt;/code&gt; component in the &lt;a href=&quot;../simple-component&quot;&gt;&quot;Building a Simple Component&quot;&lt;/a&gt; section of the tutorial.</source>
          <target state="translated">该测试通过查找带有 &lt;code&gt;listing&lt;/code&gt; 类的元素来定位搜索结果，我们在本教程的&lt;a href=&quot;../simple-component&quot;&gt;&amp;ldquo;构建简单组件&amp;rdquo;&lt;/a&gt;部分中将其提供给了 &lt;code&gt;rental-listing&lt;/code&gt; 组件。</target>
        </trans-unit>
        <trans-unit id="2a64607c214ef37d87d8ad67e76908fa5af07f02" translate="yes" xml:space="preserve">
          <source>The test verifies that after filling in the search input with &quot;Seattle&quot;, the rental list reduces from 3 to 1, and the item displayed shows &quot;Seattle&quot; as the location.</source>
          <target state="translated">测试验证,在搜索输入中填写 &quot;西雅图 &quot;后,租房列表从3个减少到1个,显示的项目显示为 &quot;西雅图 &quot;的位置。</target>
        </trans-unit>
        <trans-unit id="89d72c69007c893df81d99979fa6b2e66b8f23a3" translate="yes" xml:space="preserve">
          <source>The test would call the &lt;code&gt;calc&lt;/code&gt; method and assert it gets back the correct value.</source>
          <target state="translated">测试将调用 &lt;code&gt;calc&lt;/code&gt; 方法并断言它会返回正确的值。</target>
        </trans-unit>
        <trans-unit id="9e4b46dc9e309d54bfec19901f419a3f701c4206" translate="yes" xml:space="preserve">
          <source>The third context of the &lt;code&gt;{{action}}&lt;/code&gt; helper can be called &quot;element space&quot;. For example:</source>
          <target state="translated">&lt;code&gt;{{action}}&lt;/code&gt; 帮助程序的第三个上下文可以称为&amp;ldquo;元素空间&amp;rdquo;。例如：</target>
        </trans-unit>
        <trans-unit id="37d7a55f997fe0c18460ae452e7f09adc66aa219" translate="yes" xml:space="preserve">
          <source>The third form of helper usage is &lt;strong&gt;block invocation&lt;/strong&gt;. Use block helpers to render only part of a template. Block invocation of a helper can be recognized by the &lt;code&gt;#&lt;/code&gt; before the helper name, and the closing &lt;code&gt;{{/&lt;/code&gt; double curly brace at the end of the invocation.</source>
          <target state="translated">帮助程序用法的第三种形式是&lt;strong&gt;块调用&lt;/strong&gt;。使用块帮助器仅渲染模板的一部分。可以通过在助手名称之前的 &lt;code&gt;#&lt;/code&gt; 来识别助手的块调用，并在调用结束时使用 &lt;code&gt;{{/&lt;/code&gt; 双大括号括起来。</target>
        </trans-unit>
        <trans-unit id="944b09433ee6559023c1be9d8df4b25f0ac83680" translate="yes" xml:space="preserve">
          <source>The third parameter is a function, which can be used to nest routes. Nested routes, by default, will have the parent route tree's route name and path prepended to it's own.</source>
          <target state="translated">第三个参数是一个函数,可以用来嵌套路由。嵌套的路由,在默认情况下,会将父路由树的路由名和路径预置到自己的路由树上。</target>
        </trans-unit>
        <trans-unit id="147526a2a9e7840b61e7afb24045b79c209cc65d" translate="yes" xml:space="preserve">
          <source>The type. e.g. &quot;model&quot;, &quot;controller&quot;, &quot;route&quot;.</source>
          <target state="translated">类型,如 &quot;模型&quot;、&quot;控制器&quot;、&quot;路线&quot;。</target>
        </trans-unit>
        <trans-unit id="4f039fe10b59dfaf945a628a511ceac52bce6aa9" translate="yes" xml:space="preserve">
          <source>The updateRecord method is expected to return a promise that will resolve with the serialized record. This allows the backend to inform the Ember Data store the current state of this record after the update. If it is not possible to return a serialized record the updateRecord promise can also resolve with &lt;code&gt;undefined&lt;/code&gt; and the Ember Data store will assume all of the updates were successfully applied on the backend.</source>
          <target state="translated">预计updateRecord方法将返回一个将与序列化记录一起解析的promise。这允许后端在更新后通知Ember数据存储该记录的当前状态。如果不可能返回序列化的记录，则updateRecord承诺也可以使用 &lt;code&gt;undefined&lt;/code&gt; 解析，并且Ember Data存储将假定所有更新都已成功应用于后端。</target>
        </trans-unit>
        <trans-unit id="51de670ab53c3db59ec8a0666e66364d58ad96c2" translate="yes" xml:space="preserve">
          <source>The user changes the URL manually, such as by clicking the back button or by editing the address bar.</source>
          <target state="translated">用户手动更改URL,如点击返回按钮或编辑地址栏。</target>
        </trans-unit>
        <trans-unit id="5351613497c3004771812d248a543cbdc66656b3" translate="yes" xml:space="preserve">
          <source>The user clicks a link within the app.</source>
          <target state="translated">用户点击应用内的链接。</target>
        </trans-unit>
        <trans-unit id="9921d7f5710f25509ee88606a85dee5d311bd63d" translate="yes" xml:space="preserve">
          <source>The user loads the app for the first time.</source>
          <target state="translated">用户第一次加载应用。</target>
        </trans-unit>
        <trans-unit id="74e880123198891577360a791645732bdf32b1e5" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;isWide&lt;/code&gt; comes from our component's JavaScript file, in this case &lt;code&gt;rental-listing.js&lt;/code&gt;. Since we want the image to be smaller at first, we will set the property to start as &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;isWide&lt;/code&gt; 的值来自组件的JavaScript文件，在本例中为 &lt;code&gt;rental-listing.js&lt;/code&gt; 。因为我们希望图像首先变小，所以我们将属性设置为 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d23a5a16f505fa5c0bc4c22ed6862d2f7cf30588" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;my-controller-name&lt;/code&gt; must match the name of the Route that renders it. So a Route named &lt;code&gt;blog-post&lt;/code&gt; would have a matching Controller named &lt;code&gt;blog-post&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;my-controller-name&lt;/code&gt; 的值必须与呈现它的Route的名称匹配。因此，一个名为 &lt;code&gt;blog-post&lt;/code&gt; 的路由将具有一个匹配的Controller，名为 &lt;code&gt;blog-post&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd1f47d5724e57f16f4762fa4b7b499056b744cd" translate="yes" xml:space="preserve">
          <source>The value to be returned.</source>
          <target state="translated">要返回的值。</target>
        </trans-unit>
        <trans-unit id="04a60bcf4638b39535e993d6cbd42eae6ce46172" translate="yes" xml:space="preserve">
          <source>The value to return if the property value is undefined</source>
          <target state="translated">如果属性值未定义,返回的值。</target>
        </trans-unit>
        <trans-unit id="9571ab424dffa7c5f376c7c97c04d87fb698a99b" translate="yes" xml:space="preserve">
          <source>The value to set</source>
          <target state="translated">要设置的值</target>
        </trans-unit>
        <trans-unit id="cc012a4e9d5bd52a06928e9abc8926ab3ec9e9e2" translate="yes" xml:space="preserve">
          <source>The value to set or `null`.</source>
          <target state="translated">要设置的值或 &quot;无&quot;。</target>
        </trans-unit>
        <trans-unit id="66ed92b099921e39838f582833afc6fe6e27756e" translate="yes" xml:space="preserve">
          <source>Then it checks for the presence of a type-specific instance method of the form &lt;code&gt;resolve[Type]&lt;/code&gt; and calls it if it exists. For example if it was resolving 'template:post', it would call the &lt;code&gt;resolveTemplate&lt;/code&gt; method.</source>
          <target state="translated">然后，它检查是否存在形式为 &lt;code&gt;resolve[Type]&lt;/code&gt; 的类型特定的实例方法，如果存在，则将其调用。例如，如果要解析&amp;ldquo; template：post&amp;rdquo;，它将调用 &lt;code&gt;resolveTemplate&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="124bbec613e0740a2add94968e72e7ab45cd285a" translate="yes" xml:space="preserve">
          <source>Then make sure the &quot;Display the Tomster icon when a site runs Ember.js&quot; checkbox is checked.</source>
          <target state="translated">然后确保 &quot;当网站运行Ember.js时显示Tomster图标 &quot;复选框被选中。</target>
        </trans-unit>
        <trans-unit id="0963cd90e4c018ee024de78af4821e7b2fb93a50" translate="yes" xml:space="preserve">
          <source>Then our &lt;code&gt;system-preferences-editor&lt;/code&gt; template passes its local &lt;code&gt;deleteUser&lt;/code&gt; action into the &lt;code&gt;user-profile&lt;/code&gt; as that component's &lt;code&gt;deleteCurrentUser&lt;/code&gt; property.</source>
          <target state="translated">然后，我们的 &lt;code&gt;system-preferences-editor&lt;/code&gt; 模板将其本地 &lt;code&gt;deleteUser&lt;/code&gt; 操作作为该组件的 &lt;code&gt;deleteCurrentUser&lt;/code&gt; 属性传递到 &lt;code&gt;user-profile&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="b94c945aa553087e491135e87e7caa5e6c5b7883" translate="yes" xml:space="preserve">
          <source>Then you can use the &lt;code&gt;surge&lt;/code&gt; command to deploy your application. Note you will also need to rename index.html to 200.html to enable Ember's client-side routing.</source>
          <target state="translated">然后，您可以使用 &lt;code&gt;surge&lt;/code&gt; 命令来部署您的应用程序。请注意，您还需要将index.html重命名为200.html才能启用Ember的客户端路由。</target>
        </trans-unit>
        <trans-unit id="0d901353d4e943cc8e0760df4cb86a77339d4096" translate="yes" xml:space="preserve">
          <source>Then you can use the attributes in the component exactly as if they had been passed in like &lt;code&gt;{{blog-post title=post.title body=post.body}}&lt;/code&gt;.</source>
          <target state="translated">然后，您可以像在 &lt;code&gt;{{blog-post title=post.title body=post.body}}&lt;/code&gt; 中那样传入属性，完全使用组件中的属性。</target>
        </trans-unit>
        <trans-unit id="c92853aa810fa69277504403a7af77504ee617b3" translate="yes" xml:space="preserve">
          <source>Then you could test that the relationship is wired up correctly with this test.</source>
          <target state="translated">那么你就可以通过这个测试来测试双方的关系是否接线正确。</target>
        </trans-unit>
        <trans-unit id="6aaeabca116411bcf4c1a7398dff6575fb20c9cb" translate="yes" xml:space="preserve">
          <source>There are a few things to note about the &lt;code&gt;didInsertElement()&lt;/code&gt; hook:</source>
          <target state="translated">关于 &lt;code&gt;didInsertElement()&lt;/code&gt; 挂钩，需要注意以下几点：</target>
        </trans-unit>
        <trans-unit id="f4a72425f5f9b4159f6c94de9e4fbddbb71a0684" translate="yes" xml:space="preserve">
          <source>There are also a number of hooks that you might find useful to define across-the-board rules for your payload. These rules will be useful if your server is consistent, or if you're building an adapter for an infrastructure service, like Firebase, and want to encode service conventions.</source>
          <target state="translated">还有一些钩子,你可能会发现对你的有效载荷定义全面的规则很有用。如果你的服务器是一致的,或者如果你正在为一个基础设施服务(如Firebase)构建一个适配器,并希望对服务约定进行编码,这些规则将非常有用。</target>
        </trans-unit>
        <trans-unit id="578096648c11d6a69dd22171bb32ab27d9d7328e" translate="yes" xml:space="preserve">
          <source>There are many other reasons you probably want to have the last word on whether a user can or cannot access a certain page. Ember allows you to control that access with a combination of hooks and methods in your route.</source>
          <target state="translated">还有很多其他的原因,你可能想对用户是否可以或不能访问某个页面有最后的决定权。Ember允许你在路由中结合钩子和方法来控制这种访问。</target>
        </trans-unit>
        <trans-unit id="3e116b7284a783a93524c56507c577f15c7f8f3a" translate="yes" xml:space="preserve">
          <source>There are some typical properties for &lt;code&gt;JSONAPI&lt;/code&gt; payload:</source>
          <target state="translated">&lt;code&gt;JSONAPI&lt;/code&gt; 有效负载具有一些典型属性：</target>
        </trans-unit>
        <trans-unit id="fa40a8819696a1f893c91e0074003303e8e955ba" translate="yes" xml:space="preserve">
          <source>There are three contexts an action helper can be used in. The first two contexts to discuss are attribute context, and Handlebars value context.</source>
          <target state="translated">一个动作助手可以在三种上下文中使用。首先要讨论的两个上下文是属性上下文和手柄栏值上下文。</target>
        </trans-unit>
        <trans-unit id="eb35d84a7b28ef37fc1f3ad04e7b79de4e7986bd" translate="yes" xml:space="preserve">
          <source>There are three different classifications of tests that you will need: &lt;strong&gt;Acceptance&lt;/strong&gt;, &lt;strong&gt;Unit&lt;/strong&gt;, and &lt;strong&gt;Integration&lt;/strong&gt;.</source>
          <target state="translated">您将需要三种不同的测试分类：&lt;strong&gt;验收&lt;/strong&gt;，&lt;strong&gt;单位&lt;/strong&gt;和&lt;strong&gt;集成&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="7367662dcdee81e54f51c21bbee10f32226fbf53" translate="yes" xml:space="preserve">
          <source>There are times when dealing with promises that it seems like any errors are being 'swallowed', and not properly raised. This makes it extremely difficult to track down where a given issue is coming from. Thankfully, &lt;code&gt;RSVP&lt;/code&gt; has a solution for this problem built in.</source>
          <target state="translated">有时，兑现承诺似乎是&amp;ldquo;吞噬&amp;rdquo;了所有错误，并且未正确提出。这使得追踪给定问题的来源变得极为困难。幸运的是， &lt;code&gt;RSVP&lt;/code&gt; 内置了针对此问题的解决方案。</target>
        </trans-unit>
        <trans-unit id="44cfec86f1ebe6d62f3d92a60b1b8d46e0ac4e6e" translate="yes" xml:space="preserve">
          <source>There are two types of initializers: application initializers and application instance initializers.</source>
          <target state="translated">初始化器有两种类型:应用初始化器和应用实例初始化器。</target>
        </trans-unit>
        <trans-unit id="9c93293573cc4730e6f6925ce1aadc37cf558354" translate="yes" xml:space="preserve">
          <source>There is also a &lt;em&gt;tight coupling&lt;/em&gt; between your application's UI and the network code. If the url or the format of the JSON payload changes, it is likely to break all of your UI components in ways that are hard to track down.</source>
          <target state="translated">应用程序的UI和网络代码之间也存在&lt;em&gt;紧密&lt;/em&gt;的联系。如果URL或JSON有效负载的格式发生更改，则很可能会导致难以跟踪的方式破坏您的所有UI组件。</target>
        </trans-unit>
        <trans-unit id="4d05d80fad77d5b9ca545ded611a63131b8dfe96" translate="yes" xml:space="preserve">
          <source>There is also a way to share data within your blog post component with the content it is wrapping. In our blog post component we want to provide a way for the user to configure what type of style they want to write their post in. We will give them the option to specify either &lt;code&gt;markdown-style&lt;/code&gt; or &lt;code&gt;html-style&lt;/code&gt;.</source>
          <target state="translated">还有一种方法可以在博客文章组件中与其包装的内容共享数据。在我们的博客文章组件中，我们希望为用户提供一种方法，让他们可以配置他们想以哪种类型编写文章。我们将为他们提供选项，以指定 &lt;code&gt;markdown-style&lt;/code&gt; 或 &lt;code&gt;html-style&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bce1dba6eb8d20d25b8d3b47eeeb56679f7d843" translate="yes" xml:space="preserve">
          <source>There is an option of not embedding JSON in the serialized payload by using serialize: 'ids'. If you do not want the relationship sent at all, you can use &lt;code&gt;serialize: false&lt;/code&gt;.</source>
          <target state="translated">通过使用serialize：'ids'，可以选择不将JSON嵌入序列化的有效负载中。如果您根本不希望发送该关系，则可以使用 &lt;code&gt;serialize: false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c0962f2c7df03fd0ed2a6aa0f4eb2fdab83af0e" translate="yes" xml:space="preserve">
          <source>Therefore, if this function is comparing some numeric values, simple &lt;code&gt;itemA - itemB&lt;/code&gt; or &lt;code&gt;itemA.get( 'foo' ) - itemB.get( 'foo' )&lt;/code&gt; can be used instead of series of &lt;code&gt;if&lt;/code&gt;.</source>
          <target state="translated">因此，如果此函数正在比较某些数值，则可以使用简单的 &lt;code&gt;itemA - itemB&lt;/code&gt; 或 &lt;code&gt;itemA.get( 'foo' ) - itemB.get( 'foo' )&lt;/code&gt; 代替 &lt;code&gt;if&lt;/code&gt; 系列。</target>
        </trans-unit>
        <trans-unit id="0c0660d5302de3d7014b6613e931596da4023437" translate="yes" xml:space="preserve">
          <source>These are both languages that compile to JavaScript. You're able to write your code using the syntax they offer and when ready you compile your TypeScript or CoffeeScript into JavaScript.</source>
          <target state="translated">这两种语言都可以编译成JavaScript。你可以使用它们提供的语法来编写你的代码,当你准备好时,你可以将你的TypeScript或CoffeeScript编译成JavaScript。</target>
        </trans-unit>
        <trans-unit id="2f634da40a54ec867094862d4220f2487fe12f5b" translate="yes" xml:space="preserve">
          <source>These commands run your tests using &lt;a href=&quot;https://github.com/airportyh/testem&quot;&gt;Testem&lt;/a&gt; to make testing multiple browsers very easy. You can configure Testem using the &lt;code&gt;testem.js&lt;/code&gt; file in your application root.</source>
          <target state="translated">这些命令使用&lt;a href=&quot;https://github.com/airportyh/testem&quot;&gt;Testem&lt;/a&gt;运行测试，以使测试多个浏览器变得非常容易。您可以在应用程序根目录中使用 &lt;code&gt;testem.js&lt;/code&gt; 文件配置Testem 。</target>
        </trans-unit>
        <trans-unit id="3ac140f85fac47671e02dda468bad7f3d465b715" translate="yes" xml:space="preserve">
          <source>These functions will be invoked when a matching &lt;code&gt;{{action}}&lt;/code&gt; is triggered from within a template and the application's current route is this route.</source>
          <target state="translated">当从模板内部触发匹配的 &lt;code&gt;{{action}}&lt;/code&gt; 且应用程序的当前路径为该路径时，将调用这些功能。</target>
        </trans-unit>
        <trans-unit id="f000050ca0200e805c16a0913f8c1fad925ae6a7" translate="yes" xml:space="preserve">
          <source>These tips will help you identify problems early so they can be addressed systematically, rather than in a last-minute scramble.</source>
          <target state="translated">这些技巧将帮助你及早发现问题,以便系统地解决这些问题,而不是在最后一刻争分夺秒。</target>
        </trans-unit>
        <trans-unit id="eb68b862cfa676cabebaff85159658805baa3a42" translate="yes" xml:space="preserve">
          <source>Third-party APIs.</source>
          <target state="translated">第三方API。</target>
        </trans-unit>
        <trans-unit id="ddfb0ac04a55327aee053575597c9dda63adb165" translate="yes" xml:space="preserve">
          <source>Third-party JavaScript not available as an addon or Bower package should be placed in the &lt;code&gt;vendor/&lt;/code&gt; folder in your project.</source>
          <target state="translated">第三方JavaScript不能作为插件或Bower软件包使用，应放置在项目的 &lt;code&gt;vendor/&lt;/code&gt; 文件夹中。</target>
        </trans-unit>
        <trans-unit id="4ffb1109d5b126cb0663125d9dacbb7624bde715" translate="yes" xml:space="preserve">
          <source>Third-party assets that are not added via &lt;code&gt;import()&lt;/code&gt; will not be present in the final build.</source>
          <target state="translated">未通过 &lt;code&gt;import()&lt;/code&gt; 添加的第三方资产将不会出现在最终版本中。</target>
        </trans-unit>
        <trans-unit id="452f64b3ac568069b0d3fb42cc4172b03c430605" translate="yes" xml:space="preserve">
          <source>This API allows you to provide a reference with new data. The simplest usage of this API is similar to &lt;code&gt;store.push&lt;/code&gt;: you provide a normalized hash of data and the object represented by the reference will update.</source>
          <target state="translated">通过此API，您可以提供有关新数据的参考。此API的最简单用法类似于 &lt;code&gt;store.push&lt;/code&gt; ：您提供数据的规范化哈希，并且引用所表示的对象将更新。</target>
        </trans-unit>
        <trans-unit id="37ffc8f135d22f0957ffebde87903095e52c78e0" translate="yes" xml:space="preserve">
          <source>This Ember.js hook allows an object to be notified when a property is defined.</source>
          <target state="translated">这个Ember.js钩子允许对象在定义一个属性时得到通知。</target>
        </trans-unit>
        <trans-unit id="b6b8e36a48ff33ef3a57b6d9dd97582f0dfd4fca" translate="yes" xml:space="preserve">
          <source>This adapter does not make any assumptions as to the format of the &lt;code&gt;errors&lt;/code&gt; object. It will simply be passed along as is, wrapped in an instance of &lt;code&gt;DS.InvalidError&lt;/code&gt; or &lt;code&gt;DS.AdapterError&lt;/code&gt;. The serializer can interpret it afterwards.</source>
          <target state="translated">该适配器不对 &lt;code&gt;errors&lt;/code&gt; 对象的格式做任何假设。它将直接按原样传递，包装在 &lt;code&gt;DS.InvalidError&lt;/code&gt; 或 &lt;code&gt;DS.AdapterError&lt;/code&gt; 的实例中。序列化程序之后可以对其进行解释。</target>
        </trans-unit>
        <trans-unit id="ad2124edee9f5095f02b332c56318c024bf9499a" translate="yes" xml:space="preserve">
          <source>This adapter is designed around the idea that the JSON exchanged with the server should be conventional.</source>
          <target state="translated">这个适配器是围绕着与服务器交换的JSON应该是常规的这一理念设计的。</target>
        </trans-unit>
        <trans-unit id="853904908c1556303a04442689a343ac7e65fed7" translate="yes" xml:space="preserve">
          <source>This adapter will extend the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt;&lt;code&gt;JSONAPIAdapter&lt;/code&gt;&lt;/a&gt; base class from Ember Data:</source>
          <target state="translated">此适配器将从Ember Data 扩展&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html&quot;&gt; &lt;code&gt;JSONAPIAdapter&lt;/code&gt; &lt;/a&gt;基类：</target>
        </trans-unit>
        <trans-unit id="3d5dbdc061173e19b17b6f110fb18cfb4cd22c55" translate="yes" xml:space="preserve">
          <source>This affects query param behavior in two ways:</source>
          <target state="translated">这将以两种方式影响查询参数的行为。</target>
        </trans-unit>
        <trans-unit id="9236129e7ad8572a6f3cfa7ce7b534bcdc1773a8" translate="yes" xml:space="preserve">
          <source>This allows ember-testing to play nicely with other asynchronous events, such as an application that is waiting for a CSS3 transition or an IndexDB transaction. The waiter runs periodically after each async helper (i.e. &lt;code&gt;click&lt;/code&gt;, &lt;code&gt;andThen&lt;/code&gt;, &lt;code&gt;visit&lt;/code&gt;, etc) has executed, until the returning result is truthy. After the waiters finish, the next async helper is executed and the process repeats.</source>
          <target state="translated">这使余烬测试可以与其他异步事件（例如，正在等待CSS3转换的应用程序或IndexDB事务）很好地配合使用。在每个异步帮助程序（即 &lt;code&gt;click&lt;/code&gt; ，然后 &lt;code&gt;andThen&lt;/code&gt; ， &lt;code&gt;visit&lt;/code&gt; 等）执行后，服务程序会定期运行，直到返回的结果是真实的。服务员完成后，将执行下一个异步帮助程序，并重复该过程。</target>
        </trans-unit>
        <trans-unit id="d63f6d895f9dbaa7a1f0c7f4aab7d30d5d8234cc" translate="yes" xml:space="preserve">
          <source>This allows the original method to continue operating as it normally would.</source>
          <target state="translated">这样就可以让原来的方法继续正常运行。</target>
        </trans-unit>
        <trans-unit id="283d55de2d3a0d1c60968c365e7a92f311d2ac8a" translate="yes" xml:space="preserve">
          <source>This allows you to do whatever kind of munging you need, and is especially useful if your server is inconsistent and you need to do munging differently for many different kinds of responses.</source>
          <target state="translated">这允许你做任何你需要的munging,如果你的服务器不稳定,你需要为许多不同类型的响应做不同的munging,这特别有用。</target>
        </trans-unit>
        <trans-unit id="fd87b224bfacdd8f67d689202e0b6d11b295e8ca" translate="yes" xml:space="preserve">
          <source>This allows you to perform asynchronous setup logic and defer booting your application until the setup has finished.</source>
          <target state="translated">这允许您执行异步设置逻辑,并推迟启动应用程序,直到设置完成。</target>
        </trans-unit>
        <trans-unit id="8cdde2b5de75dbd9f848f898dbadf64aaba67fae" translate="yes" xml:space="preserve">
          <source>This argument will become the model context of the linked route:</source>
          <target state="translated">这个论点将成为链接路线的模型上下文。</target>
        </trans-unit>
        <trans-unit id="941f661a9bdc6020b125f022848bfff58eb9c9a2" translate="yes" xml:space="preserve">
          <source>This behavior extends to object creation as well. Continuing the above example:</source>
          <target state="translated">这种行为也延伸到对象创建中。继续上面的例子。</target>
        </trans-unit>
        <trans-unit id="53fa6c0fd3b00088bf6ab65b06527f4d9856bb1d" translate="yes" xml:space="preserve">
          <source>This behavior is not available during object &lt;code&gt;create&lt;/code&gt; calls. It is only available at &lt;code&gt;extend&lt;/code&gt; time.</source>
          <target state="translated">对象 &lt;code&gt;create&lt;/code&gt; 调用期间，此行为不可用。它仅在 &lt;code&gt;extend&lt;/code&gt; 时间可用。</target>
        </trans-unit>
        <trans-unit id="b10353972c333adf35b656d7d67ecb6081d088a1" translate="yes" xml:space="preserve">
          <source>This behaviour can be easily customized by extending this method.</source>
          <target state="translated">这种行为可以通过扩展该方法轻松定制。</target>
        </trans-unit>
        <trans-unit id="7087d2aa7e0c9dbae55ad8456ac0ed7c2474bcbd" translate="yes" xml:space="preserve">
          <source>This behaviour is similar to &lt;code&gt;link-to&lt;/code&gt;, which also lets you opt into a &lt;code&gt;replaceState&lt;/code&gt; transition via &lt;code&gt;replace=true&lt;/code&gt;.</source>
          <target state="translated">此行为类似于 &lt;code&gt;link-to&lt;/code&gt; ，它也使您可以通过 &lt;code&gt;replace=true&lt;/code&gt; 来选择 &lt;code&gt;replaceState&lt;/code&gt; 过渡。</target>
        </trans-unit>
        <trans-unit id="646b88b52695fd5b351e17ed4f20ebf3a312b1da" translate="yes" xml:space="preserve">
          <source>This callback will be called whenever an async operation has completed.</source>
          <target state="translated">每当一个异步操作完成后,这个回调就会被调用。</target>
        </trans-unit>
        <trans-unit id="9d3decb642e6ed5fe3151ae228c0dab60ea9dbcb" translate="yes" xml:space="preserve">
          <source>This callback will be called whenever an async operation is about to start.</source>
          <target state="translated">每当一个异步操作即将开始时,这个回调就会被调用。</target>
        </trans-unit>
        <trans-unit id="6e4f6495a0bfd49c0b770ee29b970fcdc0b8a129" translate="yes" xml:space="preserve">
          <source>This can be achieved by configuring the &lt;code&gt;rootURL&lt;/code&gt; property on &lt;code&gt;ENV&lt;/code&gt;:</source>
          <target state="translated">这可以通过在 &lt;code&gt;ENV&lt;/code&gt; 上配置 &lt;code&gt;rootURL&lt;/code&gt; 属性来实现：</target>
        </trans-unit>
        <trans-unit id="592e84b1e0b4e61032446b865d26f0c9377deab5" translate="yes" xml:space="preserve">
          <source>This can be done on the result of a &lt;code&gt;store.query()&lt;/code&gt; call:</source>
          <target state="translated">这可以在 &lt;code&gt;store.query()&lt;/code&gt; 调用的结果上完成：</target>
        </trans-unit>
        <trans-unit id="b3f869a4e4a76d784deb8c0310fd8160dedadf6c" translate="yes" xml:space="preserve">
          <source>This class can also be useful as a layer to transform the contents of an array, as they are accessed. This can be done by overriding &lt;code&gt;objectAtContent&lt;/code&gt;:</source>
          <target state="translated">此类在访问数组时也可以用作转换数组内容的层。这可以通过重写 &lt;code&gt;objectAtContent&lt;/code&gt; 来完成：</target>
        </trans-unit>
        <trans-unit id="5c735fa315afadd4e939bc22605b4168dc7fd925" translate="yes" xml:space="preserve">
          <source>This class can be extended by a custom resolver implementer to override some of the methods with library-specific code.</source>
          <target state="translated">这个类可以通过自定义的解析器实现者来扩展,用特定库的代码覆盖一些方法。</target>
        </trans-unit>
        <trans-unit id="3106dd228ae8524f2463f5eb418ced8f6f5d8666" translate="yes" xml:space="preserve">
          <source>This class implements the methods defined by Ember.Test.Adapter for the QUnit testing framework.</source>
          <target state="translated">这个类实现了Ember.Test.Adapter为QUnit测试框架定义的方法。</target>
        </trans-unit>
        <trans-unit id="320b5810ffa80935692e4a814095e9bb406c7d7d" translate="yes" xml:space="preserve">
          <source>This class will be extended by a persistence library which will override some of the methods with library-specific code.</source>
          <target state="translated">这个类将被一个持久化库扩展,它将用库的特定代码覆盖一些方法。</target>
        </trans-unit>
        <trans-unit id="674eb11f18e5896906fc06f889797fc9a66d2250" translate="yes" xml:space="preserve">
          <source>This code example uses the latest features in JavaScript, some of which you may not be familiar with. Learn more with this &lt;a href=&quot;https://ponyfoo.com/articles/es6&quot;&gt;overview of the newest JavaScript features&lt;/a&gt;.</source>
          <target state="translated">此代码示例使用JavaScript中的最新功能，您可能不熟悉其中的某些功能。通过此&lt;a href=&quot;https://ponyfoo.com/articles/es6&quot;&gt;最新JavaScript功能概述&lt;/a&gt;了解更多信息。</target>
        </trans-unit>
        <trans-unit id="0fc86456128b2bec3fcb1e1970d2427a1fdb6365" translate="yes" xml:space="preserve">
          <source>This component would render the following:</source>
          <target state="translated">该组件将呈现以下内容:</target>
        </trans-unit>
        <trans-unit id="e42d35491e18c0eb8d5095f19ff074a10aab3fc5" translate="yes" xml:space="preserve">
          <source>This computed property would return a map describing these relationships, like this:</source>
          <target state="translated">这个计算后的属性会返回一个描述这些关系的地图,像这样。</target>
        </trans-unit>
        <trans-unit id="ec813caf1f669a427b25e6f09bf93ba65ce6c773" translate="yes" xml:space="preserve">
          <source>This creates a route file at &lt;code&gt;app/routes/route-name.js&lt;/code&gt;, a template for the route at &lt;code&gt;app/templates/route-name.hbs&lt;/code&gt;, and a unit test file at &lt;code&gt;tests/unit/routes/route-name-test.js&lt;/code&gt;. It also adds the route to the router.</source>
          <target state="translated">这将在 &lt;code&gt;app/routes/route-name.js&lt;/code&gt; 处创建一个路由文件，在 &lt;code&gt;app/templates/route-name.hbs&lt;/code&gt; 处创建该路由的模板，并在 &lt;code&gt;tests/unit/routes/route-name-test.js&lt;/code&gt; 处创建一个单元测试文件。 js。它还将路由添加到路由器。</target>
        </trans-unit>
        <trans-unit id="91ce519eb8ba59c7f3b8c3662743cb9f43554cc3" translate="yes" xml:space="preserve">
          <source>This declares &lt;code&gt;fullName&lt;/code&gt; to be a computed property, with &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; as the properties it depends on. The first time you access the &lt;code&gt;fullName&lt;/code&gt; property, the function will be called and the results will be cached. Subsequent access of &lt;code&gt;fullName&lt;/code&gt; will read from the cache without calling the function. Changing any of the dependent properties causes the cache to invalidate, so that the computed function runs again on the next access.</source>
          <target state="translated">这声明 &lt;code&gt;fullName&lt;/code&gt; 是一个计算的属性，并且 &lt;code&gt;firstName&lt;/code&gt; 和 &lt;code&gt;lastName&lt;/code&gt; 是它依赖的属性。首次访问 &lt;code&gt;fullName&lt;/code&gt; 属性时，将调用该函数并将结果缓存。随后对 &lt;code&gt;fullName&lt;/code&gt; 的访问将从缓存中读取，而无需调用该函数。更改任何从属属性都会导致高速缓存失效，从而使计算的函数在下次访问时再次运行。</target>
        </trans-unit>
        <trans-unit id="31bb2006f39cafcc9484e2a81a9f308f7180aef7" translate="yes" xml:space="preserve">
          <source>This defines a new &lt;code&gt;Person&lt;/code&gt; class with a &lt;code&gt;say()&lt;/code&gt; method.</source>
          <target state="translated">这将使用 &lt;code&gt;say()&lt;/code&gt; 方法定义一个新的 &lt;code&gt;Person&lt;/code&gt; 类。</target>
        </trans-unit>
        <trans-unit id="116d968a917da2cb6719f721c279bfccee4349ce" translate="yes" xml:space="preserve">
          <source>This defines a new subclass of Ember.Object: &lt;code&gt;Person&lt;/code&gt;. It contains one method: &lt;code&gt;say()&lt;/code&gt;.</source>
          <target state="translated">这定义了一个新的Ember.Object子类： &lt;code&gt;Person&lt;/code&gt; 。它包含一个方法： &lt;code&gt;say()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4af4dccef2a80a69c041a6f95a959661b8e03a9" translate="yes" xml:space="preserve">
          <source>This doesn't usually affect application code because computed properties are almost always observed at the same time as they are fetched. For example, you get the value of a computed property, put it in DOM (or draw it with D3), and then observe it so you can update the DOM once the property changes.</source>
          <target state="translated">这通常不会影响应用程序代码,因为计算出的属性几乎总是在获取它们的同时被观察。例如,你得到一个计算过的属性的值,把它放在DOM中(或者用D3画出来),然后观察它,这样你就可以在属性变化时更新DOM。</target>
        </trans-unit>
        <trans-unit id="784b0ed31150b193e479ab80ab41ebf62f83f1ec" translate="yes" xml:space="preserve">
          <source>This error would then be returned by an adapter's &lt;code&gt;handleResponse&lt;/code&gt; method:</source>
          <target state="translated">然后，适配器的 &lt;code&gt;handleResponse&lt;/code&gt; 方法将返回此错误：</target>
        </trans-unit>
        <trans-unit id="b6170d3568edf87d92c7c80728ddd942353f0af6" translate="yes" xml:space="preserve">
          <source>This event is triggered when the router completely exits this route. It is not executed when the model for the route changes.</source>
          <target state="translated">路由器完全退出该路由时,会触发该事件。路由的模型发生变化时,不执行该事件。</target>
        </trans-unit>
        <trans-unit id="4b0c96e516f34305bd6b72b775ae4db9e3545500" translate="yes" xml:space="preserve">
          <source>This event is triggered when the router enters the route. It is not executed when the model for the route changes.</source>
          <target state="translated">路由器进入路由时,会触发该事件。路由的模型发生变化时,不执行该事件。</target>
        </trans-unit>
        <trans-unit id="cab4a8f298d62a398a20d8205ec2eba83599f69c" translate="yes" xml:space="preserve">
          <source>This example of a post model has many comments:</source>
          <target state="translated">这个职位模型的例子有很多评论。</target>
        </trans-unit>
        <trans-unit id="9fe7ed9c19bb8a7f1cbe6b019c963a036d9478fe" translate="yes" xml:space="preserve">
          <source>This example of an author model belongs to a post model:</source>
          <target state="translated">这个作者模型的例子属于岗位模型。</target>
        </trans-unit>
        <trans-unit id="7ccc911768f0da88e6ef9f3cf49eef3b432ed969" translate="yes" xml:space="preserve">
          <source>This example uses the &lt;code&gt;=&amp;gt;&lt;/code&gt; function syntax, which is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;new ES2015 syntax for callback functions&lt;/a&gt; that provides a lexical &lt;code&gt;this&lt;/code&gt;. If this syntax is new, think of it as a function that has the same &lt;code&gt;this&lt;/code&gt; as the context it is defined in.</source>
          <target state="translated">本示例使用 &lt;code&gt;=&amp;gt;&lt;/code&gt; 函数语法，这是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;回调函数的ES2015新语法&lt;/a&gt;，提供了词法 &lt;code&gt;this&lt;/code&gt; 。如果这句法是新的，把它看作具有相同的功能 &lt;code&gt;this&lt;/code&gt; ，因为它是在规定范围内。</target>
        </trans-unit>
        <trans-unit id="ff609b107eeeef59c10a02a7f765526a45b3b82b" translate="yes" xml:space="preserve">
          <source>This example will create a &lt;code&gt;posts&lt;/code&gt; property on the &lt;code&gt;post&lt;/code&gt; controller that looks up the &lt;code&gt;posts&lt;/code&gt; controller in the container, making it easy to reference other controllers. This is functionally equivalent to:</source>
          <target state="translated">这个例子将创建一个 &lt;code&gt;posts&lt;/code&gt; 的财产 &lt;code&gt;post&lt;/code&gt; 控制器，查找该 &lt;code&gt;posts&lt;/code&gt; 在容器控制器，使其易于引用其他控制器。在功能上等效于：</target>
        </trans-unit>
        <trans-unit id="49855cd9123878194ff56a8b6fd54aa27e05b647" translate="yes" xml:space="preserve">
          <source>This example will create an &lt;code&gt;authManager&lt;/code&gt; property on the application route that looks up the &lt;code&gt;auth&lt;/code&gt; service in the container, making it easily accessible in the &lt;code&gt;model&lt;/code&gt; hook.</source>
          <target state="translated">本示例将在应用程序路由上创建一个 &lt;code&gt;authManager&lt;/code&gt; 属性，该属性在容器中查找 &lt;code&gt;auth&lt;/code&gt; 服务，从而使其可以在 &lt;code&gt;model&lt;/code&gt; 挂钩中轻松访问。</target>
        </trans-unit>
        <trans-unit id="6567df05d4a192c48cd4c99f719e2addb19ced5a" translate="yes" xml:space="preserve">
          <source>This example would create the font file in &lt;code&gt;dist/font-awesome/fonts/fontawesome-webfont.ttf&lt;/code&gt;.</source>
          <target state="translated">本示例将在 &lt;code&gt;dist/font-awesome/fonts/fontawesome-webfont.ttf&lt;/code&gt; 中创建字体文件。</target>
        </trans-unit>
        <trans-unit id="487dfa2fb498fbeeecec5ffef779e77c25b4bf73" translate="yes" xml:space="preserve">
          <source>This feature is available for you to use throughout the Ember object model, although typical app developers are likely to use it infrequently. Since it changes expectations about behavior of properties, you should properly document its usage in each individual concatenated property (to not mislead your users to think they can override the property in a subclass).</source>
          <target state="translated">这个功能可以供你在整个Ember对象模型中使用,尽管典型的应用程序开发人员可能不经常使用它。因为它改变了对属性行为的期望,所以你应该在每个单独的连通属性中正确地记录它的用法(以避免误导你的用户认为他们可以在子类中覆盖该属性)。</target>
        </trans-unit>
        <trans-unit id="0e9e3a7edaabb385dc159a68dfa2582b6dd6bf05" translate="yes" xml:space="preserve">
          <source>This feature is available for you to use throughout the Ember object model, although typical app developers are likely to use it infrequently. Since it changes expectations about behavior of properties, you should properly document its usage in each individual merged property (to not mislead your users to think they can override the property in a subclass).</source>
          <target state="translated">这个功能可供您在整个Ember对象模型中使用,尽管典型的应用程序开发人员可能不经常使用它。由于它改变了对属性行为的期望,你应该在每个单独的合并属性中正确地记录它的用法(以避免误导你的用户认为他们可以在子类中覆盖该属性)。</target>
        </trans-unit>
        <trans-unit id="d8a914b8d45890e4d1608c302453e2c8af0f22d0" translate="yes" xml:space="preserve">
          <source>This feature is backed by &lt;a href=&quot;https://github.com/ai/browserslist&quot;&gt;Browserlist&lt;/a&gt; and &lt;a href=&quot;http://caniuse.com/&quot;&gt;Can I Use&lt;/a&gt;. These websites track usage stats of browsers, so you can use complex queries based on the user base of every browser.</source>
          <target state="translated">此功能由&lt;a href=&quot;https://github.com/ai/browserslist&quot;&gt;Browserlist&lt;/a&gt;和&lt;a href=&quot;http://caniuse.com/&quot;&gt;&amp;ldquo;我可以使用&amp;rdquo;支持&lt;/a&gt;。这些网站跟踪浏览器的使用情况统计信息，因此您可以根据每个浏览器的用户群使用复杂的查询。</target>
        </trans-unit>
        <trans-unit id="ecc77b26d29bca9f5a5a76e216f7aa3707d9f628" translate="yes" xml:space="preserve">
          <source>This function should return negative number (e.g. &lt;code&gt;-1&lt;/code&gt;) when &lt;code&gt;itemA&lt;/code&gt; should come before &lt;code&gt;itemB&lt;/code&gt;. It should return positive number (e.g. &lt;code&gt;1&lt;/code&gt;) when &lt;code&gt;itemA&lt;/code&gt; should come after &lt;code&gt;itemB&lt;/code&gt;. If the &lt;code&gt;itemA&lt;/code&gt; and &lt;code&gt;itemB&lt;/code&gt; are equal this function should return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;itemA&lt;/code&gt; 在 &lt;code&gt;itemB&lt;/code&gt; 之前时，此函数应返回负数（例如 &lt;code&gt;-1&lt;/code&gt; ）。当 &lt;code&gt;itemA&lt;/code&gt; 应该在 &lt;code&gt;itemB&lt;/code&gt; 之后时，它应该返回正数（例如 &lt;code&gt;1&lt;/code&gt; ）。如果 &lt;code&gt;itemA&lt;/code&gt; 和 &lt;code&gt;itemB&lt;/code&gt; 相等，则此函数应返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f30316f73cbc0d1bc15eef0cddcc2f8521c3da8f" translate="yes" xml:space="preserve">
          <source>This function takes an optional 2nd argument that will become the &quot;this&quot; value for the callback. If this argument is passed then the 3rd argument becomes the function.</source>
          <target state="translated">这个函数需要一个可选的第2个参数,它将成为回调的 &quot;this &quot;值。如果这个参数被传递,那么第3个参数就会成为函数的值。</target>
        </trans-unit>
        <trans-unit id="f4f4cb957931dcfb537731cc8f27357bfd707b9e" translate="yes" xml:space="preserve">
          <source>This generates the following HTML:</source>
          <target state="translated">这将产生以下HTML。</target>
        </trans-unit>
        <trans-unit id="b56834d4d36dbad6e5fe72083562d1d2e8904eaf" translate="yes" xml:space="preserve">
          <source>This generates this file:</source>
          <target state="translated">这就产生了这个文件。</target>
        </trans-unit>
        <trans-unit id="acffd8287f5f7fa62edb1b3b419955bbdbbac080" translate="yes" xml:space="preserve">
          <source>This gives you the flexibility to compute a value &lt;em&gt;before&lt;/em&gt; it is passed in as an argument or an attribute of another.</source>
          <target state="translated">这使您可以灵活地在将值作为另一个参数或属性传递&lt;em&gt;之前&lt;/em&gt;计算该值。</target>
        </trans-unit>
        <trans-unit id="f3fcb44dfac184e5f4739827479344f6a392ecca" translate="yes" xml:space="preserve">
          <source>This guide doesn't intend to fully delve into all the different ways promises can be used, but if you'd like a more thorough introduction, take a look at the readme for &lt;a href=&quot;https://github.com/tildeio/rsvp.js&quot;&gt;RSVP&lt;/a&gt;, the promise library that Ember uses.</source>
          <target state="translated">本指南并不打算全面研究使用Promise的所有不同方式，但是如果您想要更全面的介绍，请阅读Ember使用的Promise库&lt;a href=&quot;https://github.com/tildeio/rsvp.js&quot;&gt;RSVP&lt;/a&gt;的自述文件。</target>
        </trans-unit>
        <trans-unit id="e0e66094f6d943792b41d17683719c61a494f26d" translate="yes" xml:space="preserve">
          <source>This guide will teach you how to build a simple app using Ember from scratch.</source>
          <target state="translated">本指南将教你如何使用Ember从头开始构建一个简单的应用程序。</target>
        </trans-unit>
        <trans-unit id="30d220e5292c20d9ac340b310df750f8c7cfdd17" translate="yes" xml:space="preserve">
          <source>This happens if you are using a version of Ember &amp;lt; 1.3.</source>
          <target state="translated">如果您使用的Ember &amp;lt;1.3版本，就会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="02c316553c03e6bb16963930257b1149ad1c5f21" translate="yes" xml:space="preserve">
          <source>This has the effect of providing a default template when using a component in the non-block form but providing yielded values for use with block params when using a block expression.</source>
          <target state="translated">这样做的效果是,当在非块形式中使用组件时,提供一个默认模板,但当使用块表达式时,提供屈服值供块参数使用。</target>
        </trans-unit>
        <trans-unit id="d69577f3c578c6eabf0c4658463bd74f9978c696" translate="yes" xml:space="preserve">
          <source>This helper can later be called without arguments because it will be called with &lt;code&gt;app&lt;/code&gt; as the first parameter.</source>
          <target state="translated">稍后可以在不带参数的情况下调用此帮助器，因为它将以 &lt;code&gt;app&lt;/code&gt; 作为第一个参数来调用。</target>
        </trans-unit>
        <trans-unit id="9980bdea2787a4277e138ccf5100590320a94254" translate="yes" xml:space="preserve">
          <source>This helper has two forms, block and inline.</source>
          <target state="translated">这个助手有两种形式,block和inline。</target>
        </trans-unit>
        <trans-unit id="78766705ae99c240131efc47a151aeeb110c957c" translate="yes" xml:space="preserve">
          <source>This helper returns a new property descriptor that wraps the passed computed property function. You can use this helper to define properties with mixins or via &lt;code&gt;Ember.defineProperty()&lt;/code&gt;.</source>
          <target state="translated">该帮助程序返回一个新的属性描述符，该描述符包装了传递的计算属性函数。您可以使用此帮助器通过mixins或通过 &lt;code&gt;Ember.defineProperty()&lt;/code&gt; 定义属性。</target>
        </trans-unit>
        <trans-unit id="10ab382783ea15303c4f3ab1e310527699744871" translate="yes" xml:space="preserve">
          <source>This helper will output a value of &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="translated">该助手将输出值 &lt;code&gt;6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c987e5674d133f7c1af95e69f41a85eb2745738" translate="yes" xml:space="preserve">
          <source>This hook defers the readiness of the application, so that you can start the app when your tests are ready to run. It also sets the router's location to 'none', so that the window's location will not be modified (preventing both accidental leaking of state between tests and interference with your testing framework). &lt;code&gt;setupForTesting&lt;/code&gt; should only be called after setting a custom &lt;code&gt;router&lt;/code&gt; class (for example &lt;code&gt;App.Router = Router.extend(&lt;/code&gt;).</source>
          <target state="translated">该挂钩使应用程序准备就绪，因此您可以在准备运行测试时启动应用程序。它还将路由器的位置设置为&amp;ldquo; none&amp;rdquo;，从而不会修改窗口的位置（防止测试之间的状态意外泄漏和对测试框架的干扰）。 &lt;code&gt;setupForTesting&lt;/code&gt; 应该只设置自定义后调用 &lt;code&gt;router&lt;/code&gt; 类（例如 &lt;code&gt;App.Router = Router.extend(&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9f3850932b6cdc771f8eba24e4c0356c191dabae" translate="yes" xml:space="preserve">
          <source>This hook follows the asynchronous/promise semantics described in the documentation for &lt;code&gt;beforeModel&lt;/code&gt;. In particular, if a promise returned from &lt;code&gt;model&lt;/code&gt; fails, the error will be handled by the &lt;code&gt;error&lt;/code&gt; hook on &lt;code&gt;Ember.Route&lt;/code&gt;.</source>
          <target state="translated">该挂钩遵循 &lt;code&gt;beforeModel&lt;/code&gt; 文档中描述的异步/承诺语义。特别是，如果从 &lt;code&gt;model&lt;/code&gt; 返回的承诺失败，则错误将由 &lt;code&gt;Ember.Route&lt;/code&gt; 上的 &lt;code&gt;error&lt;/code&gt; 钩子处理。</target>
        </trans-unit>
        <trans-unit id="a8ee41feb9ddc3fa7957fac4385c3669d97c9aa0" translate="yes" xml:space="preserve">
          <source>This hook is called after this route's model has resolved. It follows identical async/promise semantics to &lt;code&gt;beforeModel&lt;/code&gt; but is provided the route's resolved model in addition to the &lt;code&gt;transition&lt;/code&gt;, and is therefore suited to performing logic that can only take place after the model has already resolved.</source>
          <target state="translated">解决此路由的模型后，将调用此挂钩。它遵循与 &lt;code&gt;beforeModel&lt;/code&gt; 相同的异步/承诺语义，但是除了 &lt;code&gt;transition&lt;/code&gt; 之外，还提供了路由的解析模型，因此适合执行只能在模型已经解析之后发生的逻辑。</target>
        </trans-unit>
        <trans-unit id="eabb2494e26202e5215d9e0f9642c252667f7896" translate="yes" xml:space="preserve">
          <source>This hook is executed when the router completely exits this route. It is not executed when the model for the route changes.</source>
          <target state="translated">路由器完全退出该路由时,会执行这个钩子。路由的模型发生变化时,不执行此钩子。</target>
        </trans-unit>
        <trans-unit id="ab287814fce6cc5b5c9f8e315d84a3c408dbd520" translate="yes" xml:space="preserve">
          <source>This hook is executed when the router enters the route. It is not executed when the model for the route changes.</source>
          <target state="translated">这个钩子在路由器进入路由时执行。路由的模型发生变化时,不执行此钩子。</target>
        </trans-unit>
        <trans-unit id="6ed5112cc8742b9d70e3846b62e3c7a4f35140f1" translate="yes" xml:space="preserve">
          <source>This hook is provided the current &lt;code&gt;transition&lt;/code&gt; attempt as a parameter, which can be used to &lt;code&gt;.abort()&lt;/code&gt; the transition, save it for a later &lt;code&gt;.retry()&lt;/code&gt;, or retrieve values set on it from a previous hook. You can also just call &lt;code&gt;this.transitionTo&lt;/code&gt; to another route to implicitly abort the &lt;code&gt;transition&lt;/code&gt;.</source>
          <target state="translated">当前 &lt;code&gt;transition&lt;/code&gt; 尝试作为参数提供给该挂钩，该挂钩可用于 &lt;code&gt;.abort()&lt;/code&gt; 转换，将其保存以供以后的 &lt;code&gt;.retry()&lt;/code&gt; 或从先前的挂钩中检索在其上设置的值。您也可以只调用 &lt;code&gt;this.transitionTo&lt;/code&gt; 到另一个路由以隐式中止 &lt;code&gt;transition&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03eecee84bea910e6f484a02d840e085770096a0" translate="yes" xml:space="preserve">
          <source>This hook is the first of the route entry validation hooks called when an attempt is made to transition into a route or one of its children. It is called before &lt;code&gt;model&lt;/code&gt; and &lt;code&gt;afterModel&lt;/code&gt;, and is appropriate for cases when:</source>
          <target state="translated">尝试转换为一条路线或其子节点之一时，此钩子是路由条目验证钩子中的第一个。在 &lt;code&gt;model&lt;/code&gt; 和 &lt;code&gt;afterModel&lt;/code&gt; 之前调用它，适用于以下情况：</target>
        </trans-unit>
        <trans-unit id="77e8a262fef81666b48b6131a8b3be017a044f7d" translate="yes" xml:space="preserve">
          <source>This hook passes the class being set up, as well as the key and value being defined. So, for example, when the user does this:</source>
          <target state="translated">这个钩子传递了被设置的类,以及被定义的键和值。因此,例如,当用户这样做时。</target>
        </trans-unit>
        <trans-unit id="b11aa29d15777ceef5c81c577245a76748891249" translate="yes" xml:space="preserve">
          <source>This hook would be called with &quot;parent&quot; as the key and the computed property returned by &lt;code&gt;DS.belongsTo&lt;/code&gt; as the value.</source>
          <target state="translated">将使用&amp;ldquo; parent&amp;rdquo;作为键并使用 &lt;code&gt;DS.belongsTo&lt;/code&gt; 返回的计算属性作为值来调用此挂钩。</target>
        </trans-unit>
        <trans-unit id="3fc7a1f064649acf207da18e9b59a14b7d7c2ed5" translate="yes" xml:space="preserve">
          <source>This illustrates that once you change a query param, it is stored and tied to the model loaded into the route.</source>
          <target state="translated">这说明,一旦你改变了一个查询参数,它就会被存储并与加载到路由中的模型绑定。</target>
        </trans-unit>
        <trans-unit id="94954009755f7b62385acf4ff8569cb1a9193610" translate="yes" xml:space="preserve">
          <source>This implementation groups together records that have the same base URL but differing ids. For example &lt;code&gt;/comments/1&lt;/code&gt; and &lt;code&gt;/comments/2&lt;/code&gt; will be grouped together because we know findMany can coalesce them together as &lt;code&gt;/comments?ids[]=1&amp;amp;ids[]=2&lt;/code&gt;</source>
          <target state="translated">此实现将具有相同基本URL但ID不同的记录分组在一起。例如， &lt;code&gt;/comments/1&lt;/code&gt; 和 &lt;code&gt;/comments/2&lt;/code&gt; 将组合在一起，因为我们知道findMany可以将它们合并为 &lt;code&gt;/comments?ids[]=1&amp;amp;ids[]=2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc9ad364e420bf1a681684a934117cc1159d58e2" translate="yes" xml:space="preserve">
          <source>This injects the shopping cart service into the component and makes it available as the &lt;code&gt;cart&lt;/code&gt; property.</source>
          <target state="translated">这会将购物车服务注入到组件中，并使其可以作为 &lt;code&gt;cart&lt;/code&gt; 属性使用。</target>
        </trans-unit>
        <trans-unit id="918384a3831377bfd82a1b852b04244ee7f5702c" translate="yes" xml:space="preserve">
          <source>This injects the test helpers into the &lt;code&gt;helperContainer&lt;/code&gt; object. If an object is provided it will be used as the helperContainer. If &lt;code&gt;helperContainer&lt;/code&gt; is not set it will default to &lt;code&gt;window&lt;/code&gt;. If a function of the same name has already been defined it will be cached (so that it can be reset if the helper is removed with &lt;code&gt;unregisterHelper&lt;/code&gt; or &lt;code&gt;removeTestHelpers&lt;/code&gt;).</source>
          <target state="translated">这 &lt;code&gt;helperContainer&lt;/code&gt; 测试帮助程序注入到helperContainer对象中。如果提供了一个对象，它将用作helperContainer。如果未设置 &lt;code&gt;helperContainer&lt;/code&gt; ，则默认为 &lt;code&gt;window&lt;/code&gt; 。如果已经定义了同名的函数，则将对其进行缓存（这样，如果使用 &lt;code&gt;unregisterHelper&lt;/code&gt; 或 &lt;code&gt;removeTestHelpers&lt;/code&gt; 删除了助手，则可以将其重置）。</target>
        </trans-unit>
        <trans-unit id="f723a6881e5d6d4df77092077259b1e266ea97bd" translate="yes" xml:space="preserve">
          <source>This is a concept that typically means providing JavaScript which tests for features that are missing (prototypes not defined, etc) and &quot;fills&quot; them by providing an implementation.</source>
          <target state="translated">这是一个概念,通常是指提供JavaScript,测试缺少的功能(没有定义原型等),并通过提供一个实现来 &quot;填补 &quot;它们。</target>
        </trans-unit>
        <trans-unit id="b176511dc82a11995524ba7ee6d3eaf35d75f683" translate="yes" xml:space="preserve">
          <source>This is a container for an assortment of testing related functionality:</source>
          <target state="translated">这是一个测试相关功能的容器。</target>
        </trans-unit>
        <trans-unit id="822a2e55a49b0a3ce1602c9de4a12deec4027902" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.all&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;RSVP.Promise.all&lt;/code&gt; 的方便别名。</target>
        </trans-unit>
        <trans-unit id="a49db288a4492f38be2239b9a4aecd51132e4df3" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.race&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;RSVP.Promise.race&lt;/code&gt; 的方便别名。</target>
        </trans-unit>
        <trans-unit id="c5311bad197bc2e95ae7fce155d89195d60075c0" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.reject&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;RSVP.Promise.reject&lt;/code&gt; 的方便别名。</target>
        </trans-unit>
        <trans-unit id="302b1ad84c9db80e1b5c3df3fe7952f0681a2eae" translate="yes" xml:space="preserve">
          <source>This is a convenient alias for &lt;code&gt;RSVP.Promise.resolve&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;RSVP.Promise.resolve&lt;/code&gt; 的方便别名。</target>
        </trans-unit>
        <trans-unit id="4971ebf34a654ca424132ff11439c59713fb5e6b" translate="yes" xml:space="preserve">
          <source>This is a great way to use the parent context to load something that you want. Using &lt;code&gt;paramsFor&lt;/code&gt; will also give you the query params defined on that route's controller. This method could also be used to look up the current route's parameters from an action or another method on the route, and in that case we have a shortcut: &lt;code&gt;this.paramsFor(this.routeName)&lt;/code&gt;.</source>
          <target state="translated">这是使用父上下文加载所需内容的好方法。使用 &lt;code&gt;paramsFor&lt;/code&gt; 还可以为您提供在该路由的控制器上定义的查询参数。此方法还可以用于从操作或路由上的其他方法中查找当前路由的参数，在这种情况下，我们有一个快捷方式： &lt;code&gt;this.paramsFor(this.routeName)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55cd0539422e5b82b20c0cc8f62bbdbb7052339e" translate="yes" xml:space="preserve">
          <source>This is a helper to be used in conjunction with the link-to helper. It will supply url query parameters to the target route.</source>
          <target state="translated">这是一个与 link-to helper 配合使用的辅助工具。它将为目标路由提供url查询参数。</target>
        </trans-unit>
        <trans-unit id="05915bea473f3b9dca751ce1d38f16283b7858bd" translate="yes" xml:space="preserve">
          <source>This is a more semantically meaningful alias of &lt;code&gt;computed.oneWay&lt;/code&gt;, whose name is somewhat ambiguous as to which direction the data flows.</source>
          <target state="translated">这是一个更语义上有意义的别名 &lt;code&gt;computed.oneWay&lt;/code&gt; ，其名称是哪个方向的数据流有些模糊。</target>
        </trans-unit>
        <trans-unit id="46a94c8f55595ad1f21083bd7fb3718a4dbf03a0" translate="yes" xml:space="preserve">
          <source>This is a stamp for the Ember Inspector to differentiate between the versions to be able to support older versions too.</source>
          <target state="translated">这是Ember Inspector的一个印章,用于区分不同的版本,以便能够支持旧版本。</target>
        </trans-unit>
        <trans-unit id="ec2df623b6ecc9f4e570340c54e42cd3266c977a" translate="yes" xml:space="preserve">
          <source>This is actually used internally by the &lt;code&gt;keyEvent&lt;/code&gt; helper like so:</source>
          <target state="translated">实际上，这是 &lt;code&gt;keyEvent&lt;/code&gt; 帮助器在内部使用的，如下所示：</target>
        </trans-unit>
        <trans-unit id="308ba443f81e87e775aa3ae34fbf288a703e8c5c" translate="yes" xml:space="preserve">
          <source>This is an interface class that exists purely to document the available options; you do not need to construct it manually. Simply pass a regular JavaScript object containing the desired options into methods that require one of these options object:</source>
          <target state="translated">这是一个纯粹为了记录可用选项而存在的接口类;你不需要手动构建它。只需将一个包含所需选项的常规JavaScript对象传递到需要这些选项对象之一的方法中即可。</target>
        </trans-unit>
        <trans-unit id="306dec7bd8c7954e508c1735c09535d1dd8b815e" translate="yes" xml:space="preserve">
          <source>This is especially useful when you depend on properties of an object, since it allows you to replace:</source>
          <target state="translated">当你依赖一个对象的属性时,这特别有用,因为它允许你替换。</target>
        </trans-unit>
        <trans-unit id="c46a6c0ebb4282802f95e4e63e750434a46d6914" translate="yes" xml:space="preserve">
          <source>This is exactly equivalent to the &lt;code&gt;format-currency&lt;/code&gt; example above. You can think of the function version as a shorthand for the longer class form if it does not require dependency injection.</source>
          <target state="translated">这与上面的 &lt;code&gt;format-currency&lt;/code&gt; 示例完全等效。如果不需要依赖注入，则可以将函数版本视为较长类形式的简写形式。</target>
        </trans-unit>
        <trans-unit id="80b9a9d98da12b68b0c4b2e6f44b4b81fb921c26" translate="yes" xml:space="preserve">
          <source>This is generally used internally from the acceptance/integration test infrastructure.</source>
          <target state="translated">这一般是从验收/集成测试基础架构的内部使用。</target>
        </trans-unit>
        <trans-unit id="a02623baf101f6c1f72c8f3ddff6f2d7a7b7ddbb" translate="yes" xml:space="preserve">
          <source>This is guaranteed to work because the parent route is loaded. But if you tried to do &lt;code&gt;paramsFor&lt;/code&gt; on a sibling route, you wouldn't have the results you expected.</source>
          <target state="translated">由于父路由已加载，因此可以保证这样做。但是，如果您尝试在同级路由上执行 &lt;code&gt;paramsFor&lt;/code&gt; ，则不会获得预期的结果。</target>
        </trans-unit>
        <trans-unit id="fa36d77986525618ad7065da5d31723d28369a95" translate="yes" xml:space="preserve">
          <source>This is most often used as the return value for the helper functions (see 'click', 'fillIn','visit',etc). However, there is a method to register a test helper which utilizes this method without the need to actually call &lt;code&gt;wait()&lt;/code&gt; in your helpers.</source>
          <target state="translated">这通常用作辅助函数的返回值（请参见&amp;ldquo;单击&amp;rdquo;，&amp;ldquo; fillIn&amp;rdquo;，&amp;ldquo;访问&amp;rdquo;等）。但是，有一种方法可以注册测试帮助程序，该方法可以利用此方法，而无需在帮助程序中实际调用 &lt;code&gt;wait()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e012518624cc2f89b04d821689a88883b2eadb7c" translate="yes" xml:space="preserve">
          <source>This is not an Ember application</source>
          <target state="translated">这不是一个Ember应用程序</target>
        </trans-unit>
        <trans-unit id="c62cbb1d5e63e1e37b85a51686c003fd0001230a" translate="yes" xml:space="preserve">
          <source>This is not just a performance optimization. If an attribute has not changed, it is important not to clobber the element's &quot;hidden state&quot;. For example, if you set an input's &lt;code&gt;value&lt;/code&gt; to the same value as before, it will clobber selection state and cursor position. In other words, setting an attribute is not &lt;strong&gt;always&lt;/strong&gt; idempotent.</source>
          <target state="translated">这不仅仅是性能优化。如果属性未更改，则重要的是不要破坏元素的&amp;ldquo;隐藏状态&amp;rdquo;。例如，如果将输入的 &lt;code&gt;value&lt;/code&gt; 设置为与以前相同的值，它将破坏选择器状态和光标位置。换句话说，设置属性并不&lt;strong&gt;总是&lt;/strong&gt;幂等的。</target>
        </trans-unit>
        <trans-unit id="bfe703d974f911cefa2119330aa9316aad45d5a9" translate="yes" xml:space="preserve">
          <source>This is one of the primitives you must implement to support &lt;code&gt;Ember.Array&lt;/code&gt;. If your object supports retrieving the value of an array item using &lt;code&gt;get()&lt;/code&gt; (i.e. &lt;code&gt;myArray.get(0)&lt;/code&gt;), then you do not need to implement this method yourself.</source>
          <target state="translated">这是您必须实现以支持 &lt;code&gt;Ember.Array&lt;/code&gt; 的原语之一。如果您的对象支持使用 &lt;code&gt;get()&lt;/code&gt; （即 &lt;code&gt;myArray.get(0)&lt;/code&gt; ）检索数组项的值，则您无需自己实现此方法。</target>
        </trans-unit>
        <trans-unit id="e9a9fd73a9f803dbe1cc43144f590d9b54349043" translate="yes" xml:space="preserve">
          <source>This is one of the primitives you must implement to support &lt;code&gt;Ember.Array&lt;/code&gt;. You should replace amt objects started at idx with the objects in the passed array. You should also call &lt;code&gt;this.enumerableContentDidChange()&lt;/code&gt;</source>
          <target state="translated">这是您必须实现以支持 &lt;code&gt;Ember.Array&lt;/code&gt; 的原语之一。您应该将以idx开头的amt对象替换为传递的数组中的对象。您还应该调用 &lt;code&gt;this.enumerableContentDidChange()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f356f63243afe37729165e88f111f35dc1627c0e" translate="yes" xml:space="preserve">
          <source>This is particularly useful for polymorphic relationships where records don't share the same table and the &lt;code&gt;id&lt;/code&gt; is not enough information.</source>
          <target state="translated">这对于记录不共享同一表且 &lt;code&gt;id&lt;/code&gt; 信息不足的多态关系特别有用。</target>
        </trans-unit>
        <trans-unit id="202d339791e806b1e70147736eb9208a5f3911be" translate="yes" xml:space="preserve">
          <source>This is primarily used when syncing bindings, which may try to update after an object has been destroyed.</source>
          <target state="translated">这主要是在同步绑定时使用,它可能会在对象被销毁后尝试更新。</target>
        </trans-unit>
        <trans-unit id="daeaceef80ff296a12644de6285774c59ae74c52" translate="yes" xml:space="preserve">
          <source>This is the core method used to register an observer for a property.</source>
          <target state="translated">这是为一个属性注册观察者的核心方法。</target>
        </trans-unit>
        <trans-unit id="bac9760d303007d38afed39bbecd73ad9b39f5bb" translate="yes" xml:space="preserve">
          <source>This is the element that will be passed to the Application's, &lt;code&gt;eventDispatcher&lt;/code&gt;, which sets up the listeners for event delegation. Every view in your application should be a child of the element you specify here.</source>
          <target state="translated">这是将传递给应用程序的 &lt;code&gt;eventDispatcher&lt;/code&gt; 的元素，该元素为事件委托设置侦听器。应用程序中的每个视图都应该是您在此处指定的元素的子视图。</target>
        </trans-unit>
        <trans-unit id="decc32c6cf9850c53e2f6bac9e782138a3406ae1" translate="yes" xml:space="preserve">
          <source>This is the extent to which Ember.js enhances native prototypes. We have carefully weighed the tradeoffs involved with changing these prototypes, and recommend that most Ember.js developers use them. These extensions significantly reduce the amount of boilerplate code that must be typed.</source>
          <target state="translated">这是Ember.js增强原生原型的程度。我们仔细权衡了改变这些原型所涉及的权衡,并建议大多数Ember.js开发者使用它们。这些扩展大大减少了必须输入的模板代码量。</target>
        </trans-unit>
        <trans-unit id="94928a1a6bed0b1e582ca40e9000c55b3eb6631f" translate="yes" xml:space="preserve">
          <source>This is the handler for the special array content property. If you get this property, it will return this. If you set this property to a new array, it will replace the current content.</source>
          <target state="translated">这是特殊数组内容属性的处理程序。如果你得到这个属性,它将返回这个。如果你把这个属性设置为一个新的数组,它将替换当前的内容。</target>
        </trans-unit>
        <trans-unit id="dada04f5800d31f549425491d1886c63a016bd11" translate="yes" xml:space="preserve">
          <source>This is typically a paid service you can use to get great performance for your app. Many CDNs act as caching proxies to your origin server; some require you to upload your assets to them. They give you a URL for each resource in your app. This URL will resolve differently for folks depending on where they're browsing.</source>
          <target state="translated">这通常是一种付费服务,您可以使用它来为您的应用程序获得出色的性能。许多CDN充当您的源服务器的缓存代理;一些CDN要求您将您的资产上传到它们那里。他们为您的应用程序中的每个资源提供一个URL。这个URL会根据人们浏览的位置不同而有不同的解析。</target>
        </trans-unit>
        <trans-unit id="9029cd114fa0d3c8586307b8eff931586da2bfe7" translate="yes" xml:space="preserve">
          <source>This is useful if you have a good sense of what records the user will need next. When they click on a link, instead of waiting for a network request to finish, Ember.js can render the new template immediately. It feels instantaneous.</source>
          <target state="translated">如果你对用户下一步需要哪些记录有很好的感觉,这就很有用。当他们点击一个链接时,Ember.js可以立即呈现新的模板,而不是等待网络请求完成。这感觉是瞬间的。</target>
        </trans-unit>
        <trans-unit id="9c0e2a474431ea68ddf5ecf51a7ea34a70a0a409" translate="yes" xml:space="preserve">
          <source>This is useful in many ways, as the controller specified will be:</source>
          <target state="translated">这在很多方面都很有用,因为指定的控制器会。</target>
        </trans-unit>
        <trans-unit id="6ade33abb6fdd45e411d88ae2ac98039f0bf103b" translate="yes" xml:space="preserve">
          <source>This is why all Ember's test helpers are wrapped in code that ensures Ember is back in a synchronized state when it makes its assertions. It saves you from having to wrap everything in code that does that, and it makes it easier to read your tests because there's less boilerplate in them.</source>
          <target state="translated">这就是为什么所有Ember的测试助手都被包装在代码中,以确保Ember在进行断言时回到同步状态。这让你不必把所有的东西都包裹在代码中,而且因为其中的模板较少,所以更容易阅读你的测试。</target>
        </trans-unit>
        <trans-unit id="373629a051fd9d6a82479c3fb955dcff38bff20a" translate="yes" xml:space="preserve">
          <source>This list of attributes is inherited from the component's superclasses, as well.</source>
          <target state="translated">这个属性列表也是从组件的超类中继承的。</target>
        </trans-unit>
        <trans-unit id="9d2978c3cf092adf7f085027707c1fa11a58cc84" translate="yes" xml:space="preserve">
          <source>This list of properties is inherited from the component's superclasses as well.</source>
          <target state="translated">这个属性列表也是从组件的超类中继承的。</target>
        </trans-unit>
        <trans-unit id="fb5f23b5212bb7243dee0fb723c49f54d8ba342c" translate="yes" xml:space="preserve">
          <source>This may be helpful for keeping links active for:</source>
          <target state="translated">这可能有助于保持链接的活跃性。</target>
        </trans-unit>
        <trans-unit id="627b891473247bd5815547809011482806305c21" translate="yes" xml:space="preserve">
          <source>This method allows you to push a payload containing top-level collections of records organized per type.</source>
          <target state="translated">这个方法允许你推送一个包含按类型组织的顶层记录集合的有效载荷。</target>
        </trans-unit>
        <trans-unit id="eb9e9c872a5cfd75bae202c4ea4839d24085215a" translate="yes" xml:space="preserve">
          <source>This method also takes a hash of boot-time configuration options for customizing the instance's behavior. See the documentation on &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; for details.</source>
          <target state="translated">此方法还采用启动时配置选项的哈希值，以自定义实例的行为。有关详细信息，请参见 &lt;code&gt;Ember.ApplicationInstance.BootOptions&lt;/code&gt; 上的文档。</target>
        </trans-unit>
        <trans-unit id="0d3f7722b1918a033bfc704ab024b6e1cf5c8659" translate="yes" xml:space="preserve">
          <source>This method can be overridden to set up and render additional or alternative templates.</source>
          <target state="translated">该方法可以被重写,以设置和渲染附加或替代模板。</target>
        </trans-unit>
        <trans-unit id="75131c915bde03ba240c1d475bfd5896ca45f619" translate="yes" xml:space="preserve">
          <source>This method can be used both to push in brand new records, as well as to update existing records.</source>
          <target state="translated">这种方法既可以用来推送全新的记录,也可以用来更新现有的记录。</target>
        </trans-unit>
        <trans-unit id="2f6b399d017a3f3f52b041707517412999041988" translate="yes" xml:space="preserve">
          <source>This method can be used both to push in brand new records, as well as to update existing records. You can push in more than one type of object at once. All objects should be in the format expected by the serializer.</source>
          <target state="translated">这个方法既可以用来推送全新的记录,也可以用来更新现有的记录。你可以同时推送多种类型的对象。所有对象都应该是序列化器所期望的格式。</target>
        </trans-unit>
        <trans-unit id="b02dc4cad6cf02610e6058c95d7caebe5eb539eb" translate="yes" xml:space="preserve">
          <source>This method can be used when it is certain that the server will return a single object for the primary data.</source>
          <target state="translated">当确定服务器将返回主数据的单一对象时,可以使用此方法。</target>
        </trans-unit>
        <trans-unit id="31a10777d9035c12a3fcba90767411843e07f906" translate="yes" xml:space="preserve">
          <source>This method delegates a query to the adapter. This is the one place where adapter-level semantics are exposed to the application.</source>
          <target state="translated">该方法将查询委托给适配器。这是一个将适配器级语义暴露给应用程序的地方。</target>
        </trans-unit>
        <trans-unit id="7ae3f2f0c751efc8927d65bfd222cb31c552601f" translate="yes" xml:space="preserve">
          <source>This method delegates to a more specific normalize method based on the &lt;code&gt;requestType&lt;/code&gt;.</source>
          <target state="translated">该方法委托基于 &lt;code&gt;requestType&lt;/code&gt; 的更具体的规范化方法。</target>
        </trans-unit>
        <trans-unit id="a25d67dc575ed0fba225af931e94045db1b5a8f9" translate="yes" xml:space="preserve">
          <source>This method expects normalized &lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt; document. This means you have to follow &lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API specification&lt;/a&gt; with few minor adjustments:</source>
          <target state="translated">此方法需要标准化的&lt;a href=&quot;http://jsonapi.org/&quot;&gt;JSON API&lt;/a&gt;文档。这意味着您必须遵循&lt;a href=&quot;http://jsonapi.org/format/&quot;&gt;JSON API规范，&lt;/a&gt;并进行少量调整：</target>
        </trans-unit>
        <trans-unit id="7df7b83c336ab5cbac360f1c5c272ebe13752bdd" translate="yes" xml:space="preserve">
          <source>This method is &lt;em&gt;only&lt;/em&gt; checked by the store when the store is returning a cached record array.</source>
          <target state="translated">&lt;em&gt;仅&lt;/em&gt;当商店返回缓存的记录数组时，商店&lt;em&gt;才会&lt;/em&gt;检查此方法。</target>
        </trans-unit>
        <trans-unit id="e8062e08f7c0f7fcdf86622114e1823949507341" translate="yes" xml:space="preserve">
          <source>This method is &lt;em&gt;only&lt;/em&gt; checked by the store when the store is returning a cached record.</source>
          <target state="translated">&lt;em&gt;仅&lt;/em&gt;当商店返回缓存的记录时，商店&lt;em&gt;才会&lt;/em&gt;检查此方法。</target>
        </trans-unit>
        <trans-unit id="3509ace1db000a92db88fe8a1836ad0b7713cbb8" translate="yes" xml:space="preserve">
          <source>This method is called via the container's resolver method. It parses the provided &lt;code&gt;fullName&lt;/code&gt; and then looks up and returns the appropriate template or class.</source>
          <target state="translated">通过容器的resolver方法调用此方法。它解析提供的 &lt;code&gt;fullName&lt;/code&gt; ，然后查找并返回适当的模板或类。</target>
        </trans-unit>
        <trans-unit id="9ce28964f15279cf3d730ef68345532b784ce703" translate="yes" xml:space="preserve">
          <source>This method is called when &lt;code&gt;transitionTo&lt;/code&gt; is called with a context in order to populate the URL.</source>
          <target state="translated">当使用上下文调用 &lt;code&gt;transitionTo&lt;/code&gt; 以填充URL 时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="f0c4ee83b8e7fbb139652d78dd5741771d80faf6" translate="yes" xml:space="preserve">
          <source>This method is called when you call &lt;code&gt;query&lt;/code&gt; on the store.</source>
          <target state="translated">当您在商店上调用 &lt;code&gt;query&lt;/code&gt; 时，将调用此方法。</target>
        </trans-unit>
        <trans-unit id="13a7fe79d0533fe9608f31da98b7023d71e69453" translate="yes" xml:space="preserve">
          <source>This method is called with the controller for the current route and the model supplied by the &lt;code&gt;model&lt;/code&gt; hook.</source>
          <target state="translated">控制器针对当前路线和 &lt;code&gt;model&lt;/code&gt; 挂钩提供的模型调用此方法。</target>
        </trans-unit>
        <trans-unit id="bbedcce78155921a2bf55755fabf12698cc38674" translate="yes" xml:space="preserve">
          <source>This method is called with the controller for the current route and the model supplied by the &lt;code&gt;model&lt;/code&gt; hook. By default, it renders the route's template, configured with the controller for the route.</source>
          <target state="translated">控制器针对当前路线和 &lt;code&gt;model&lt;/code&gt; 挂钩提供的模型调用此方法。默认情况下，它呈现路由的模板，该模板已使用该路由的控制器进行配置。</target>
        </trans-unit>
        <trans-unit id="c6d0b6398b87777d58312eba81fe646f7810a695" translate="yes" xml:space="preserve">
          <source>This method is generally very similar to calling &lt;code&gt;object[&quot;key&quot;] = value&lt;/code&gt; or &lt;code&gt;object.key = value&lt;/code&gt;, except that it provides support for computed properties, the &lt;code&gt;setUnknownProperty()&lt;/code&gt; method and property observers.</source>
          <target state="translated">此方法通常与调用 &lt;code&gt;object[&quot;key&quot;] = value&lt;/code&gt; 或 &lt;code&gt;object.key = value&lt;/code&gt; 非常相似，除了它提供对计算属性， &lt;code&gt;setUnknownProperty()&lt;/code&gt; 方法和属性观察器的支持。</target>
        </trans-unit>
        <trans-unit id="74bd84dac410bdb6c99add62a62d5417953e7c5c" translate="yes" xml:space="preserve">
          <source>This method is handy for performing intermediate transitions on the way to a final destination route, and is called internally by the default implementations of the &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;loading&lt;/code&gt; handlers.</source>
          <target state="translated">此方法非常适合在通往最终目的地路线的途中执行中间过渡，并且由 &lt;code&gt;error&lt;/code&gt; 和 &lt;code&gt;loading&lt;/code&gt; 处理程序的默认实现在内部调用。</target>
        </trans-unit>
        <trans-unit id="aa05443efe853cc3f28766f6d6fb9fe7a13a6090" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload a record after the &lt;code&gt;store.findRecord&lt;/code&gt; method resolves a cached record.</source>
          <target state="translated">商店使用此方法确定在 &lt;code&gt;store.findRecord&lt;/code&gt; 方法解析缓存的记录之后，商店是否应重新加载记录。</target>
        </trans-unit>
        <trans-unit id="ba3f4183468eab98d1908948e41cd0eef07925e8" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload a record array after the &lt;code&gt;store.findAll&lt;/code&gt; method resolves with a cached record array.</source>
          <target state="translated">商店使用此方法确定在 &lt;code&gt;store.findAll&lt;/code&gt; 方法使用缓存的记录数组解析后，商店是否应重新加载记录数组。</target>
        </trans-unit>
        <trans-unit id="0dc1d4e602a3dbc746be228073f7c5e9072291ae" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload a record from the adapter when a record is requested by &lt;code&gt;store.findRecord&lt;/code&gt;.</source>
          <target state="translated">存储使用此方法来确定 &lt;code&gt;store.findRecord&lt;/code&gt; 请求记录时，存储是否应从适配器重新加载记录。</target>
        </trans-unit>
        <trans-unit id="8ce64195ca8b7e509dff95556cc7ab216203e10e" translate="yes" xml:space="preserve">
          <source>This method is used by the store to determine if the store should reload all records from the adapter when records are requested by &lt;code&gt;store.findAll&lt;/code&gt;.</source>
          <target state="translated">存储使用此方法来确定 &lt;code&gt;store.findAll&lt;/code&gt; 请求记录时，存储是否应从适配器重新加载所有记录。</target>
        </trans-unit>
        <trans-unit id="726a13d031eb08fa1d97022da145454908c66cf3" translate="yes" xml:space="preserve">
          <source>This method is used to convert each JSON root key in the payload into a modelName that it can use to look up the appropriate model for that part of the payload.</source>
          <target state="translated">该方法用于将有效载荷中的每个JSON根键转换为modelName,它可以用来查找有效载荷中该部分的适当模型。</target>
        </trans-unit>
        <trans-unit id="6c5bbd7f853651246ca39c9ea5a7bd46d3c9d051" translate="yes" xml:space="preserve">
          <source>This method is usually similar to using &lt;code&gt;object[keyName]&lt;/code&gt; or &lt;code&gt;object.keyName&lt;/code&gt;, however it supports both computed properties and the unknownProperty handler.</source>
          <target state="translated">此方法通常类似于使用 &lt;code&gt;object[keyName]&lt;/code&gt; 或 &lt;code&gt;object.keyName&lt;/code&gt; ，但是它同时支持计算属性和unknownProperty处理程序。</target>
        </trans-unit>
        <trans-unit id="b114921bcf8d16e2e444b824deee9fc587f6fb2a" translate="yes" xml:space="preserve">
          <source>This method makes a request for one record, where the &lt;code&gt;id&lt;/code&gt; is not known beforehand (if the &lt;code&gt;id&lt;/code&gt; is known, use &lt;a href=&quot;#method_findRecord&quot;&gt;&lt;code&gt;findRecord&lt;/code&gt;&lt;/a&gt; instead).</source>
          <target state="translated">该方法使得一个请求为一个记录，其中，所述 &lt;code&gt;id&lt;/code&gt; 是事先不知道（如果该 &lt;code&gt;id&lt;/code&gt; 是已知的，使用&lt;a href=&quot;#method_findRecord&quot;&gt; &lt;code&gt;findRecord&lt;/code&gt; &lt;/a&gt;代替）。</target>
        </trans-unit>
        <trans-unit id="fe413c14bf4da8f3d5f53d8ded6cddab3dfd4a8c" translate="yes" xml:space="preserve">
          <source>This method normalizes a modelName into the format Ember Data uses internally.</source>
          <target state="translated">此方法将modelName标准化为Ember Data内部使用的格式。</target>
        </trans-unit>
        <trans-unit id="08631e46477a7a941a13e8472a1d4934d0dfbb83" translate="yes" xml:space="preserve">
          <source>This method performs an HTTP &lt;code&gt;GET&lt;/code&gt; request with the id provided as part of the query string.</source>
          <target state="translated">此方法执行HTTP &lt;code&gt;GET&lt;/code&gt; 请求，其ID作为查询字符串的一部分提供。</target>
        </trans-unit>
        <trans-unit id="7856b76816169cfe893ef391554413f9b77a695b" translate="yes" xml:space="preserve">
          <source>This method provides a way to read an element's attribute and also update the last value Ember knows about at the same time. This makes setting an attribute idempotent.</source>
          <target state="translated">这个方法提供了一种方法来读取一个元素的属性,同时也更新Ember知道的最后一个值。这使得设置一个属性是幂等的。</target>
        </trans-unit>
        <trans-unit id="1be81e576abbc9f8bf07bfebbb5d7035d8f905c9" translate="yes" xml:space="preserve">
          <source>This method receives the &lt;code&gt;store&lt;/code&gt;, the Model class for the request, the payload, the id of the record request (or &lt;code&gt;null&lt;/code&gt; if there is no id associated with the request), and the request type (a string with the possible values of: &lt;code&gt;'findRecord'&lt;/code&gt;, &lt;code&gt;'queryRecord'&lt;/code&gt;, &lt;code&gt;'findAll'&lt;/code&gt;, &lt;code&gt;'findBelongsTo'&lt;/code&gt;, &lt;code&gt;'findHasMany'&lt;/code&gt;, &lt;code&gt;'findMany'&lt;/code&gt;, &lt;code&gt;'query'&lt;/code&gt;, &lt;code&gt;'createRecord'&lt;/code&gt;, &lt;code&gt;'deleteRecord'&lt;/code&gt;, and &lt;code&gt;'updateRecord'&lt;/code&gt;) as arguments.</source>
          <target state="translated">该方法接收 &lt;code&gt;store&lt;/code&gt; ，请求的Model类，有效负载，记录请求的ID（如果没有与该请求关联的ID，则为 &lt;code&gt;null&lt;/code&gt; ）以及请求类型（可能值为： &lt;code&gt;'findRecord'&lt;/code&gt; 的字符串findRecord&amp;rdquo;， &lt;code&gt;'queryRecord'&lt;/code&gt; ， &lt;code&gt;'findAll'&lt;/code&gt; ， &lt;code&gt;'findBelongsTo'&lt;/code&gt; ， &lt;code&gt;'findHasMany'&lt;/code&gt; ， &lt;code&gt;'findMany'&lt;/code&gt; ， &lt;code&gt;'query'&lt;/code&gt; ， &lt;code&gt;'createRecord'&lt;/code&gt; ， &lt;code&gt;'deleteRecord'&lt;/code&gt; 和 &lt;code&gt;'updateRecord'&lt;/code&gt; ）作为参数。</target>
        </trans-unit>
        <trans-unit id="83cfea1ccac994b0f515944e96fac8ec32c2f20c" translate="yes" xml:space="preserve">
          <source>This method returns a filtered array that contains all of the known records for a given type in the store.</source>
          <target state="translated">此方法返回一个过滤后的数组,该数组包含了存储库中给定类型的所有已知记录。</target>
        </trans-unit>
        <trans-unit id="6a6a5fc1791645c2940034d3812b1b516a3835b0" translate="yes" xml:space="preserve">
          <source>This method returns a manager which can be used for introspection of the factory's class or for the creation of factory instances with initial properties. The manager is an object with the following properties:</source>
          <target state="translated">本方法返回一个管理器,它可以用来反省工厂的类或创建具有初始属性的工厂实例。管理器是一个具有以下属性的对象。</target>
        </trans-unit>
        <trans-unit id="b23b68987e06baaee9d2d14013a12d56a2d0b3b3" translate="yes" xml:space="preserve">
          <source>This method returns a promise, which is resolved with an &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.AdapterPopulatedRecordArray.html&quot;&gt;&lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt;&lt;/a&gt; once the server returns.</source>
          <target state="translated">此方法返回一个&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.AdapterPopulatedRecordArray.html&quot;&gt; &lt;code&gt;AdapterPopulatedRecordArray&lt;/code&gt; &lt;/a&gt;一旦服务器返回，将使用AdapterPopulatedRecordArray解决。</target>
        </trans-unit>
        <trans-unit id="eed4c7cdb29f6c03f0723f0629feb07c3656376e" translate="yes" xml:space="preserve">
          <source>This method returns a promise, which resolves with the found record.</source>
          <target state="translated">这个方法返回一个承诺,它与找到的记录一起解析。</target>
        </trans-unit>
        <trans-unit id="a9ee61f9f9c7e39cc14b2113ef18411dc61a4eca" translate="yes" xml:space="preserve">
          <source>This method returns a record for a given type and id combination.</source>
          <target state="translated">这个方法返回一个给定类型和id组合的记录。</target>
        </trans-unit>
        <trans-unit id="5addfbbe95b2a58af44bf1bdcf2499db95fe3c02" translate="yes" xml:space="preserve">
          <source>This method returns true if a record for a given modelName and id is already loaded in the store. Use this function to know beforehand if a findRecord() will result in a request or that it will be a cache hit.</source>
          <target state="translated">如果 store 中已经加载了给定 modelName 和 id 的记录,此方法返回 true。使用这个函数可以事先知道findRecord()是否会导致一个请求,或者它将是一个缓存命中。</target>
        </trans-unit>
        <trans-unit id="29ad6b6ad91ee119d75a9bab0ee8ae0631edf987" translate="yes" xml:space="preserve">
          <source>This method should be returned by async helpers such as &lt;code&gt;wait&lt;/code&gt;.</source>
          <target state="translated">异步帮助程序（如 &lt;code&gt;wait&lt;/code&gt; )应返回此方法。</target>
        </trans-unit>
        <trans-unit id="df6dcf687152ce38d873a2ff72a1326ba3f69cb3" translate="yes" xml:space="preserve">
          <source>This method should be used when an event may be called multiple times but the action should only be called once when the event is done firing. A common example is for scroll events where you only want updates to happen once scrolling has ceased.</source>
          <target state="translated">当一个事件可能被多次调用,但在事件完成后只需调用一次动作时,就应该使用这个方法。一个常见的例子是滚动事件,当滚动停止后,你只想让更新发生。</target>
        </trans-unit>
        <trans-unit id="1b7af68bf1d14a0a7494d03c440d73e28a4b7190" translate="yes" xml:space="preserve">
          <source>This method unloads all records in the store. It schedules unloading to happen during the next run loop.</source>
          <target state="translated">这个方法可以卸载存储中的所有记录。它将卸载安排在下一个运行循环中进行。</target>
        </trans-unit>
        <trans-unit id="f68e595b779d29ca69cd56edd16cad0978ac86aa" translate="yes" xml:space="preserve">
          <source>This method will be called with the parent record and &lt;code&gt;/people/1/group&lt;/code&gt;.</source>
          <target state="translated">将使用父记录和 &lt;code&gt;/people/1/group&lt;/code&gt; 调用此方法。</target>
        </trans-unit>
        <trans-unit id="90e07dd7b94be524253c05e8e1714813e05bd28a" translate="yes" xml:space="preserve">
          <source>This method will be called with the parent record and &lt;code&gt;/posts/1/comments&lt;/code&gt;.</source>
          <target state="translated">将使用父记录和 &lt;code&gt;/posts/1/comments&lt;/code&gt; 调用此方法。</target>
        </trans-unit>
        <trans-unit id="105f0e895ac617988c6c362e0f459352f9da2718" translate="yes" xml:space="preserve">
          <source>This method will only be called if content is non-&lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">仅当content为非 &lt;code&gt;null&lt;/code&gt; 时,才调用此方法。</target>
        </trans-unit>
        <trans-unit id="657150ab50b85204bae3030b7eec6fc817ac1dfb" translate="yes" xml:space="preserve">
          <source>This method will synchronously return the record if it is available in the store, otherwise it will return &lt;code&gt;null&lt;/code&gt;. A record is available if it has been fetched earlier, or pushed manually into the store.</source>
          <target state="translated">如果该记录在存储中可用，则此方法将同步返回记录，否则将返回 &lt;code&gt;null&lt;/code&gt; 。如果一条记录已被较早提取或手动推入存储中，则该记录可用。</target>
        </trans-unit>
        <trans-unit id="5d308bedb05bb7d9b40bb5a78f093cc80094bac4" translate="yes" xml:space="preserve">
          <source>This method works much like the more generic &lt;code&gt;find()&lt;/code&gt; method.</source>
          <target state="translated">此方法的工作方式与更通用的 &lt;code&gt;find()&lt;/code&gt; 方法非常相似。</target>
        </trans-unit>
        <trans-unit id="28c70fd4104148a561dcde3c0978e4acb10eaa64" translate="yes" xml:space="preserve">
          <source>This method would ensure that whenever you do &lt;code&gt;store.findAll('ticket')&lt;/code&gt; you will always get a list of tickets that are no more than 20 minutes old. In case a cached version is more than 20 minutes old, &lt;code&gt;findAll&lt;/code&gt; will not resolve until you fetched the latest versions.</source>
          <target state="translated">此方法将确保您每次 &lt;code&gt;store.findAll('ticket')&lt;/code&gt; 时，始终可以获得不超过20分钟的票证列表。如果缓存版本的时间超过20分钟，则在您获取最新版本之前， &lt;code&gt;findAll&lt;/code&gt; 将无法解析。</target>
        </trans-unit>
        <trans-unit id="2678263a74a0b565310ba1599428e1ae18b8c295" translate="yes" xml:space="preserve">
          <source>This method would ensure that whenever you do &lt;code&gt;store.findRecord('ticket',
id)&lt;/code&gt; you will always get a ticket that is no more than 20 minutes old. In case the cached version is more than 20 minutes old, &lt;code&gt;findRecord&lt;/code&gt; will not resolve until you fetched the latest version.</source>
          <target state="translated">此方法将确保您每次 &lt;code&gt;store.findRecord('ticket', id)&lt;/code&gt; 时，始终会获得不超过20分钟的票证。如果缓存的版本超过20分钟，则在您获取最新版本之前， &lt;code&gt;findRecord&lt;/code&gt; 将无法解析。</target>
        </trans-unit>
        <trans-unit id="ec834c3e944edee230a4909331939d62bcbb6301" translate="yes" xml:space="preserve">
          <source>This mixin allows for Ember objects to subscribe to and emit events.</source>
          <target state="translated">这个 mixin 允许 Ember 对象订阅和发射事件。</target>
        </trans-unit>
        <trans-unit id="0bf4568e2d4c8f66ef058891e43df4c9d7beb31a" translate="yes" xml:space="preserve">
          <source>This mixin defines the API for modifying array-like objects. These methods can be applied only to a collection that keeps its items in an ordered set. It builds upon the Array mixin and adds methods to modify the array. One concrete implementations of this class include ArrayProxy.</source>
          <target state="translated">这个 mixin 定义了修改数组类对象的 API。这些方法只能应用于将其项目保持在一个有序集合中的集合。它在Array mixin的基础上,增加了修改数组的方法。这个类的一个具体实现包括ArrayProxy。</target>
        </trans-unit>
        <trans-unit id="0c9ab29a7ae181e083871bfe59c6eb5fa8dee6de" translate="yes" xml:space="preserve">
          <source>This mixin defines the API for modifying generic enumerables. These methods can be applied to an object regardless of whether it is ordered or unordered.</source>
          <target state="translated">这个 mixin 定义了修改通用枚举的 API。这些方法可以应用于一个对象,无论它是有序的还是无序的。</target>
        </trans-unit>
        <trans-unit id="c505b5abe483be3c71930f0a0c5dfa5e8fc1384e" translate="yes" xml:space="preserve">
          <source>This mixin defines the common interface implemented by enumerable objects in Ember. Most of these methods follow the standard Array iteration API defined up to JavaScript 1.8 (excluding language-specific features that cannot be emulated in older versions of JavaScript).</source>
          <target state="translated">这个 mixin 定义了 Ember 中可枚举对象实现的通用接口。这些方法中的大部分都遵循了直到JavaScript 1.8的标准数组迭代API(不包括在旧版本JavaScript中无法模拟的特定语言功能)。</target>
        </trans-unit>
        <trans-unit id="a9d0130ce13b8d50b5ddf38e1dae3ada3564de2d" translate="yes" xml:space="preserve">
          <source>This mixin implements Observer-friendly Array-like behavior. It is not a concrete implementation, but it can be used up by other classes that want to appear like arrays.</source>
          <target state="translated">这个 mixin 实现了观察者友好的 Array-like 行为。它并不是一个具体的实现,但它可以被其他希望像数组一样出现的类使用。</target>
        </trans-unit>
        <trans-unit id="6d8916c9cfd84a7db880c63d8afc0d632f773b4d" translate="yes" xml:space="preserve">
          <source>This mixin is applied automatically to the Array class on page load, so you can use any of these methods on simple arrays. If Array already implements one of these methods, the mixin will not override them.</source>
          <target state="translated">这个mixin会在页面加载时自动应用到Array类中,所以你可以在简单的数组上使用这些方法。如果Array已经实现了其中的一个方法,那么这个混搭就不会覆盖它们。</target>
        </trans-unit>
        <trans-unit id="763268c55e99fe8d5e6cfe80a692c9e9a1ec4278" translate="yes" xml:space="preserve">
          <source>This mixin provides properties and property observing functionality, core features of the Ember object model.</source>
          <target state="translated">这个 mixin 提供了属性和属性观察功能,是 Ember 对象模型的核心功能。</target>
        </trans-unit>
        <trans-unit id="16c6c4f7af60f66230f7ffba2118c188148ccc3d" translate="yes" xml:space="preserve">
          <source>This namespace contains all Ember methods and functions. Future versions of Ember may overwrite this namespace and therefore, you should avoid adding any new properties.</source>
          <target state="translated">这个命名空间包含了所有的Ember方法和函数,未来的Ember版本可能会覆盖这个命名空间,因此你应该避免添加任何新的属性。未来的Ember版本可能会覆盖这个命名空间,因此,你应该避免添加任何新的属性。</target>
        </trans-unit>
        <trans-unit id="5c0f1fb8cd697c512e05d5434c4202f674808490" translate="yes" xml:space="preserve">
          <source>This one command will create a new directory called &lt;code&gt;ember-quickstart&lt;/code&gt; and set up a new Ember application inside of it. Out of the box, your application will include:</source>
          <target state="translated">此命令将创建一个名为 &lt;code&gt;ember-quickstart&lt;/code&gt; 的新目录，并在其中建立一个新的Ember应用程序。开箱即用，您的应用程序将包括：</target>
        </trans-unit>
        <trans-unit id="1d1ae48e7202427b88a954866fa91e5d3ebf6ba4" translate="yes" xml:space="preserve">
          <source>This only works on primitive data types, e.g. Strings, Numbers, etc.</source>
          <target state="translated">这只适用于原始数据类型,如字符串、数字等。</target>
        </trans-unit>
        <trans-unit id="308984791a98ba4402203e44b8c501a854c6be67" translate="yes" xml:space="preserve">
          <source>This option logs all the lookups that are done to the console. Custom objects you've created yourself have a tick, and Ember generated ones don't.</source>
          <target state="translated">这个选项会将所有的查找记录到控制台。你自己创建的自定义对象有勾选,而Ember生成的则没有。</target>
        </trans-unit>
        <trans-unit id="864837a696f2c980e81e10f2eb17aa9ee09a9e87" translate="yes" xml:space="preserve">
          <source>This pause-on-promise behavior is extremely valuable for when you need to guarantee that a route's data has fully loaded before displaying a new template.</source>
          <target state="translated">当您需要保证在显示新模板之前,路由的数据已经完全加载完毕时,这种暂停承诺的行为是非常有价值的。</target>
        </trans-unit>
        <trans-unit id="68b70d5b5dbc2ccc714f22b801fc4c2b2e2527d0" translate="yes" xml:space="preserve">
          <source>This prevents the reverse flow, and also throws an exception when it occurs.</source>
          <target state="translated">这样可以防止逆向流动,也可以在逆向流动发生时抛出异常。</target>
        </trans-unit>
        <trans-unit id="f188f197791f50828cb93afbcf35a833dccb3e89" translate="yes" xml:space="preserve">
          <source>This property can be specified as either an element or a &lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery-compatible selector string&lt;/a&gt;.</source>
          <target state="translated">可以将此属性指定为元素或&lt;a href=&quot;http://api.jquery.com/category/selectors/&quot;&gt;jQuery兼容选择器字符串&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="259eb851af0e49aa172ab983617f64d1b8524d4e" translate="yes" xml:space="preserve">
          <source>This property contains the testing helpers for the current application. These are created once you call &lt;code&gt;injectTestHelpers&lt;/code&gt; on your &lt;code&gt;Ember.Application&lt;/code&gt; instance. The included helpers are also available on the &lt;code&gt;window&lt;/code&gt; object by default, but can be used from this object on the individual application also.</source>
          <target state="translated">此属性包含当前应用程序的测试助手。一旦在 &lt;code&gt;Ember.Application&lt;/code&gt; 实例上调用 &lt;code&gt;injectTestHelpers&lt;/code&gt; ，就会创建它们。默认情况下，所包含的帮助器也可在 &lt;code&gt;window&lt;/code&gt; 对象上使用，但也可以在单个应用程序中从此对象使用。</target>
        </trans-unit>
        <trans-unit id="880b36e1d1b71d83f727290b52d71974b054fd06" translate="yes" xml:space="preserve">
          <source>This property holds the &lt;code&gt;DS.AdapterError&lt;/code&gt; object with which last adapter operation was rejected.</source>
          <target state="translated">此属性保存拒绝最后一个适配器操作的 &lt;code&gt;DS.AdapterError&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="c2672723b4000e8dc3a4be8a1dec2e30fc2e556d" translate="yes" xml:space="preserve">
          <source>This property indicates whether or not this application is currently in testing mode. This is set when &lt;code&gt;setupForTesting&lt;/code&gt; is called on the current application.</source>
          <target state="translated">此属性指示此应用程序当前是否处于测试模式。在当前应用程序上调用 &lt;code&gt;setupForTesting&lt;/code&gt; 时设置。</target>
        </trans-unit>
        <trans-unit id="1d61da15319a8f6d477ea54281d1f750de320a8d" translate="yes" xml:space="preserve">
          <source>This property must be specified upon creation, and should not be changed once created.</source>
          <target state="translated">此属性必须在创建时指定,一旦创建就不应更改。</target>
        </trans-unit>
        <trans-unit id="7cb254d7e44a7f93fba2ee853638d58a655e0c55" translate="yes" xml:space="preserve">
          <source>This property overrides the default property defined in &lt;code&gt;Ember.Enumerable&lt;/code&gt;.</source>
          <target state="translated">此属性将覆盖 &lt;code&gt;Ember.Enumerable&lt;/code&gt; 中定义的默认属性。</target>
        </trans-unit>
        <trans-unit id="9773d501349ee6511de2ee684d6598a19311be0d" translate="yes" xml:space="preserve">
          <source>This property would contain the following:</source>
          <target state="translated">该财产将包含以下内容:</target>
        </trans-unit>
        <trans-unit id="d20b59f6a96b6617ee0085cdddc214c8c3d28af2" translate="yes" xml:space="preserve">
          <source>This removes all helpers that have been registered, and resets and functions that were overridden by the helpers.</source>
          <target state="translated">这将删除所有已注册的帮手,并重置被帮手覆盖的功能。</target>
        </trans-unit>
        <trans-unit id="f3b7c25a3f2e20075045c10f4cbaf58f922adbe5" translate="yes" xml:space="preserve">
          <source>This results in the creation of a model file and a test file:</source>
          <target state="translated">这将导致创建一个模型文件和一个测试文件。</target>
        </trans-unit>
        <trans-unit id="3d2448d5cbbd2264adc36cdc0345ffb2188196cb" translate="yes" xml:space="preserve">
          <source>This returns a string that represents how the reference will be looked up when it is loaded. If the relationship has a link it will use the &quot;link&quot; otherwise it defaults to &quot;id&quot;.</source>
          <target state="translated">这将返回一个字符串,表示当它被加载时,引用将如何被查找。如果关系有链接,它将使用 &quot;链接&quot;,否则默认为 &quot;id&quot;。</target>
        </trans-unit>
        <trans-unit id="f4a77f92e2016358406f536036ee528d0389ad89" translate="yes" xml:space="preserve">
          <source>This returns a thenable tailored for testing. It catches failed &lt;code&gt;onSuccess&lt;/code&gt; callbacks and invokes the &lt;code&gt;Ember.Test.adapter.exception&lt;/code&gt; callback in the last chained then.</source>
          <target state="translated">这将返回可定制的测试版本。它捕获失败的 &lt;code&gt;onSuccess&lt;/code&gt; 回调，然后在最后一个链接的链中调用 &lt;code&gt;Ember.Test.adapter.exception&lt;/code&gt; 回调。</target>
        </trans-unit>
        <trans-unit id="50faf92dba9f3a4835092fca1ed3e0228234be67" translate="yes" xml:space="preserve">
          <source>This returns the objects at the specified indexes, using &lt;code&gt;objectAt&lt;/code&gt;.</source>
          <target state="translated">这将使用 &lt;code&gt;objectAt&lt;/code&gt; 返回指定索引处的对象。</target>
        </trans-unit>
        <trans-unit id="f1e3aaaf80637b6eaa622e8df1944a99aa521731" translate="yes" xml:space="preserve">
          <source>This route is part of every application, so you don't need to specify it in your &lt;code&gt;app/router.js&lt;/code&gt;.</source>
          <target state="translated">该路由是每个应用程序的一部分，因此您无需在 &lt;code&gt;app/router.js&lt;/code&gt; 中指定它。</target>
        </trans-unit>
        <trans-unit id="03d7bba0ebc44c5b5992d770552d3d3655e4353b" translate="yes" xml:space="preserve">
          <source>This router creates a route for &lt;code&gt;/posts&lt;/code&gt; and for &lt;code&gt;/posts/new&lt;/code&gt;. When a user visits &lt;code&gt;/posts&lt;/code&gt;, they'll simply see the &lt;code&gt;posts.hbs&lt;/code&gt; template. (Below, &lt;a href=&quot;#toc_index-routes&quot;&gt;index routes&lt;/a&gt; explains an important addition to this.) When the user visits &lt;code&gt;posts/new&lt;/code&gt;, they'll see the &lt;code&gt;posts/new.hbs&lt;/code&gt; template rendered into the &lt;code&gt;{{outlet}}&lt;/code&gt; of the &lt;code&gt;posts&lt;/code&gt; template.</source>
          <target state="translated">该路由器为 &lt;code&gt;/posts&lt;/code&gt; 和 &lt;code&gt;/posts/new&lt;/code&gt; 创建路由。用户访问 &lt;code&gt;/posts&lt;/code&gt; 时，他们只会看到 &lt;code&gt;posts.hbs&lt;/code&gt; 模板。 （下面，&lt;a href=&quot;#toc_index-routes&quot;&gt;指数航线&lt;/a&gt;解释的重要补充，这一点）。当用户访问 &lt;code&gt;posts/new&lt;/code&gt; ，他们会看到 &lt;code&gt;posts/new.hbs&lt;/code&gt; 模板渲染到 &lt;code&gt;{{outlet}}&lt;/code&gt; 的的 &lt;code&gt;posts&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="2682ff7e745a9f583a877a94603b3a194f20069b" translate="yes" xml:space="preserve">
          <source>This section covers some more advanced features of the router and its capability for handling complex async logic within your app.</source>
          <target state="translated">本节介绍了路由器的一些更高级的功能,以及它在应用程序中处理复杂异步逻辑的能力。</target>
        </trans-unit>
        <trans-unit id="7d03de60bffa51d324cefb82c172247484bdd27e" translate="yes" xml:space="preserve">
          <source>This separation of concerns not only clarifies the architecture of your app, it can also improve its efficiency. This is particularly true when your app needs to be booted repeatedly during testing and / or server-rendering (e.g. via &lt;a href=&quot;https://github.com/tildeio/ember-cli-fastboot&quot;&gt;FastBoot&lt;/a&gt;). The configuration of a single &lt;code&gt;Application&lt;/code&gt; can be done once and shared among multiple stateful &lt;code&gt;ApplicationInstance&lt;/code&gt; instances. These instances can be discarded once they're no longer needed (e.g. when a test has run or FastBoot request has finished).</source>
          <target state="translated">关注点的分离不仅阐明了应用程序的体系结构，还可以提高其效率。当您的应用程序需要在测试和/或服务器渲染（例如，通过&lt;a href=&quot;https://github.com/tildeio/ember-cli-fastboot&quot;&gt;FastBoot&lt;/a&gt;）期间重复启动时，尤其如此。单个 &lt;code&gt;Application&lt;/code&gt; 的配置可以完成一次，并在多个有状态 &lt;code&gt;ApplicationInstance&lt;/code&gt; 实例之间共享。一旦不再需要这些实例（例如，运行测试或FastBoot请求已完成），便可以将其丢弃。</target>
        </trans-unit>
        <trans-unit id="789aeba7e703a9b9f8a1615849db9c70a791d7f5" translate="yes" xml:space="preserve">
          <source>This serializer expects this &lt;code&gt;errors&lt;/code&gt; object to be an Array similar to the following, compliant with the JSON-API specification:</source>
          <target state="translated">该序列化程序期望此 &lt;code&gt;errors&lt;/code&gt; 对象是一个类似于以下内容的数组，并符合JSON-API规范：</target>
        </trans-unit>
        <trans-unit id="bb8c0ec823dbba7a7a2ed2b41b55cb5e08ee937a" translate="yes" xml:space="preserve">
          <source>This serializer normalizes a JSON API payload that looks like:</source>
          <target state="translated">这个序列化器对JSON API有效载荷进行了规范化处理,看起来像。</target>
        </trans-unit>
        <trans-unit id="6ae149f60b66b9e03410e34d8b8dd68ba195fe2d" translate="yes" xml:space="preserve">
          <source>This serializer will generate JSON that looks like this:</source>
          <target state="translated">这个序列器会生成类似这样的JSON。</target>
        </trans-unit>
        <trans-unit id="a037d496c03267daf854fbff115ff2ed3892a36d" translate="yes" xml:space="preserve">
          <source>This sets up a binding between the &lt;code&gt;category&lt;/code&gt; query param in the URL, and the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt;. In other words, once the &lt;code&gt;articles&lt;/code&gt; route has been entered, any changes to the &lt;code&gt;category&lt;/code&gt; query param in the URL will update the &lt;code&gt;category&lt;/code&gt; property on &lt;code&gt;controller:articles&lt;/code&gt;, and vice versa. Note that you can't bind &lt;code&gt;queryParams&lt;/code&gt; to computed properties, they have to be values.</source>
          <target state="translated">这将在URL中的 &lt;code&gt;category&lt;/code&gt; 查询参数与 &lt;code&gt;controller:articles&lt;/code&gt; 上的 &lt;code&gt;category&lt;/code&gt; 属性之间建立绑定。换句话说，一旦输入了 &lt;code&gt;articles&lt;/code&gt; 路线，对URL中的 &lt;code&gt;category&lt;/code&gt; 查询参数的任何更改都会更新 &lt;code&gt;controller:articles&lt;/code&gt; 上的 &lt;code&gt;category&lt;/code&gt; 属性，反之亦然。请注意，您不能将 &lt;code&gt;queryParams&lt;/code&gt; 绑定到计算属性，它们必须是值。</target>
        </trans-unit>
        <trans-unit id="c4fca12a79c237845effaba4d5f11c49b9077507" translate="yes" xml:space="preserve">
          <source>This setup allows you to run the routing layer of your Ember app in a server environment using Node.js and completely disable rendering. This allows you to simulate and discover the resources (i.e. AJAX requests) needed to fulfill a given request and eagerly &quot;push&quot; these resources to the client.</source>
          <target state="translated">这个设置允许您在服务器环境中使用Node.js运行Ember应用的路由层,并完全禁用渲染。这允许您模拟和发现满足给定请求所需的资源(即AJAX请求),并急切地将这些资源 &quot;推送 &quot;给客户端。</target>
        </trans-unit>
        <trans-unit id="02dd78ab18220d6a23d424669cd9bfd4688435b6" translate="yes" xml:space="preserve">
          <source>This setup allows you to run your Ember app in a server environment using Node.js and render its content into static HTML for SEO purposes.</source>
          <target state="translated">这种设置允许您在服务器环境中使用Node.js运行您的Ember应用程序,并将其内容渲染成静态HTML以达到SEO目的。</target>
        </trans-unit>
        <trans-unit id="0fc8bfa537605301181bc268ec1121a0fff7f530" translate="yes" xml:space="preserve">
          <source>This shows the literal string &lt;code&gt;&amp;lt;b&amp;gt;Hello world&amp;lt;/b&amp;gt;&lt;/code&gt; to the user, rather than the text in bold as you probably intended. We can tell Ember not to escape the return value (that is, that it is &lt;em&gt;safe&lt;/em&gt;) by using the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_htmlSafe&quot;&gt;&lt;code&gt;htmlSafe&lt;/code&gt;&lt;/a&gt; string utility:</source>
          <target state="translated">这会向用户显示文字字符串 &lt;code&gt;&amp;lt;b&amp;gt;Hello world&amp;lt;/b&amp;gt;&lt;/code&gt; ，而不是您可能想要的粗体文本。我们可以使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.String.html#method_htmlSafe&quot;&gt; &lt;code&gt;htmlSafe&lt;/code&gt; &lt;/a&gt;字符串实用工具告诉Ember不要转义返回值（即，它是&lt;em&gt;safe&lt;/em&gt;）：</target>
        </trans-unit>
        <trans-unit id="14461f490d3629183001df3471224dbd1beb7332" translate="yes" xml:space="preserve">
          <source>This snippet says &quot;take the &lt;code&gt;userDidDeleteAccount&lt;/code&gt; action from the parent and make it available on the child component as the property &lt;code&gt;onConfirm&lt;/code&gt;.&quot; Note the use here of the &lt;code&gt;action&lt;/code&gt; helper, which serves to return the function named &lt;code&gt;&quot;userDidDeleteAccount&quot;&lt;/code&gt; that we are passing to the component.</source>
          <target state="translated">此代码段显示&amp;ldquo; 从父级执行 &lt;code&gt;userDidDeleteAccount&lt;/code&gt; 操作，并将其作为 &lt;code&gt;onConfirm&lt;/code&gt; 属性在子级组件上可用&amp;rdquo;。请注意此处使用的 &lt;code&gt;action&lt;/code&gt; 帮助器，它用于返回传递给组件的名为 &lt;code&gt;&quot;userDidDeleteAccount&quot;&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="10aa9c950fe3b173b7fe0ffb80e1c78f6a244f66" translate="yes" xml:space="preserve">
          <source>This synchronous behavior can also lead to observers being fired multiple times when observing multiple properties:</source>
          <target state="translated">这种同步行为也会导致观察者在观察多个属性时被多次发射。</target>
        </trans-unit>
        <trans-unit id="3ca7bb302863b1f3661818e192c30d8b7af3c091" translate="yes" xml:space="preserve">
          <source>This syntax offers the convenience to add a class if a property is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">如果属性为 &lt;code&gt;false&lt;/code&gt; ,则此语法为添加类提供了便利：</target>
        </trans-unit>
        <trans-unit id="eee93099eea962e7715594aebb65f2ee2649df43" translate="yes" xml:space="preserve">
          <source>This template would display all properties on the &lt;code&gt;user&lt;/code&gt; object in a list:</source>
          <target state="translated">此模板将在列表中显示 &lt;code&gt;user&lt;/code&gt; 对象上的所有属性：</target>
        </trans-unit>
        <trans-unit id="afccb08d1ac5974f56f2db8b4c4a83dee7fac93b" translate="yes" xml:space="preserve">
          <source>This time when we setup our &lt;code&gt;moduleFor&lt;/code&gt; we need to pass an options object as our third argument that has the controller's &lt;code&gt;needs&lt;/code&gt;.</source>
          <target state="translated">这次，当我们设置 &lt;code&gt;moduleFor&lt;/code&gt; 时,我们需要传递一个options对象作为具有控制器 &lt;code&gt;needs&lt;/code&gt; 第三个参数。</target>
        </trans-unit>
        <trans-unit id="320e20ec08a17dd14b114fefba162280a1a8e762" translate="yes" xml:space="preserve">
          <source>This way the &lt;code&gt;{{action}}&lt;/code&gt; will fire when clicking with the alt key pressed down.</source>
          <target state="translated">这样，在按住alt键的情况下单击时， &lt;code&gt;{{action}}&lt;/code&gt; 将触发。</target>
        </trans-unit>
        <trans-unit id="e963dddd92986a8f66f2f216766871bc0c689a3c" translate="yes" xml:space="preserve">
          <source>This way the action will fire when clicking with the alt key pressed down. Alternatively, supply &quot;any&quot; to the &lt;code&gt;allowedKeys&lt;/code&gt; option to accept any combination of modifier keys.</source>
          <target state="translated">这样，在按住alt键的情况下单击时，动作将触发。或者，向 &lt;code&gt;allowedKeys&lt;/code&gt; 选项提供&amp;ldquo; any&amp;rdquo; 以接受修饰键的任何组合。</target>
        </trans-unit>
        <trans-unit id="bedb78f365050fbd4069b91241e79e0fffc66905" translate="yes" xml:space="preserve">
          <source>This will be set to the Application instance when it is created.</source>
          <target state="translated">这将在创建应用程序实例时被设置为应用程序实例。</target>
        </trans-unit>
        <trans-unit id="b0d2a0761856747c7bdf1757594db900c323b0ab" translate="yes" xml:space="preserve">
          <source>This will bind checked state of this checkbox to the value of &lt;code&gt;isEmberized&lt;/code&gt; -- if either one changes, it will be reflected in the other.</source>
          <target state="translated">这会将此复选框的选中状态绑定到 &lt;code&gt;isEmberized&lt;/code&gt; 的值-如果任何一个更改，它将反映在另一个中。</target>
        </trans-unit>
        <trans-unit id="25e3b1918ed474cee33c724ea48d9dc47b998531" translate="yes" xml:space="preserve">
          <source>This will call the &lt;code&gt;targetAction&lt;/code&gt; method on the &lt;code&gt;targetObject&lt;/code&gt; whenever the value of the &lt;code&gt;propertyKey&lt;/code&gt; changes.</source>
          <target state="translated">每当 &lt;code&gt;propertyKey&lt;/code&gt; 的值更改时，这将在 &lt;code&gt;targetObject&lt;/code&gt; 上调用 &lt;code&gt;targetAction&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="1112ad430de08e3a9e5b258697086fe3531f93eb" translate="yes" xml:space="preserve">
          <source>This will cause changes to the &lt;code&gt;controller:articles&lt;/code&gt;'s &lt;code&gt;category&lt;/code&gt; property to update the &lt;code&gt;articles_category&lt;/code&gt; query param, and vice versa.</source>
          <target state="translated">这将导致对 &lt;code&gt;controller:articles&lt;/code&gt; 的 &lt;code&gt;category&lt;/code&gt; 属性的更改，以更新 &lt;code&gt;articles_category&lt;/code&gt; 查询参数，反之亦然。</target>
        </trans-unit>
        <trans-unit id="01abb5b2dee8f3eadfbf27cf12dc694c82c9b0fa" translate="yes" xml:space="preserve">
          <source>This will combine the values of the enumerator into a single value. It is a useful way to collect a summary value from an enumeration. This corresponds to the &lt;code&gt;reduce()&lt;/code&gt; method defined in JavaScript 1.8.</source>
          <target state="translated">这会将枚举器的值合并为一个值。这是从枚举中收集汇总值的有用方法。这对应于JavaScript 1.8中定义的 &lt;code&gt;reduce()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="4d8eee678a37c71d0c8bd12462d3862f9e24bd5a" translate="yes" xml:space="preserve">
          <source>This will create a new &lt;code&gt;comment&lt;/code&gt; record and save it to the server. Ember Data will also update the blogPost to include our newly created comment in its &lt;code&gt;comments&lt;/code&gt; relationship.</source>
          <target state="translated">这将创建一个新的 &lt;code&gt;comment&lt;/code&gt; 记录并将其保存到服务器。Ember Data还将更新blogPost，以将我们新创建的评论纳入其 &lt;code&gt;comments&lt;/code&gt; 关系中。</target>
        </trans-unit>
        <trans-unit id="33c9e6435e1c4f883e5e4bdb72fe6185866b3577" translate="yes" xml:space="preserve">
          <source>This will create two files, our helper and its related test:</source>
          <target state="translated">这将创建两个文件,我们的助手和它的相关测试。</target>
        </trans-unit>
        <trans-unit id="06a61beff59c9a238e101b8d830b62a3ba3f1d36" translate="yes" xml:space="preserve">
          <source>This will display the result of &lt;code&gt;this.get('foo.item1')&lt;/code&gt; when index is 1, and &lt;code&gt;this.get('foo.item2')&lt;/code&gt; when index is 2, etc.</source>
          <target state="translated">这将显示的结果 &lt;code&gt;this.get('foo.item1')&lt;/code&gt; 时指标为1，和 &lt;code&gt;this.get('foo.item2')&lt;/code&gt; 当索引为2，等等。</target>
        </trans-unit>
        <trans-unit id="a9259ca0bb82d89e48df977ef1e42ddeb57457e8" translate="yes" xml:space="preserve">
          <source>This will generate the following file:</source>
          <target state="translated">这将产生以下文件。</target>
        </trans-unit>
        <trans-unit id="906404e31e56fa309043de215463e96251e5794e" translate="yes" xml:space="preserve">
          <source>This will only work if the record has already finished loading.</source>
          <target state="translated">这只有在记录已经完成加载的情况下才会生效。</target>
        </trans-unit>
        <trans-unit id="d8d929b9d0335a3ed5cf736b11bdf433272222ee" translate="yes" xml:space="preserve">
          <source>This will result in a posts.new url of &lt;code&gt;/#/posts/new&lt;/code&gt;.</source>
          <target state="translated">这将导致 &lt;code&gt;/#/posts/new&lt;/code&gt; 的posts.new网址。</target>
        </trans-unit>
        <trans-unit id="29fb1351e61c41fb104416f7850a8b5069cdd3f6" translate="yes" xml:space="preserve">
          <source>This will result in a posts.new url of &lt;code&gt;/posts/new&lt;/code&gt; for modern browsers that support the &lt;code&gt;history&lt;/code&gt; api or &lt;code&gt;/#/posts/new&lt;/code&gt; for older ones, like Internet Explorer 9 and below.</source>
          <target state="translated">这将导致的posts.new URL &lt;code&gt;/posts/new&lt;/code&gt; 为支持现代浏览器的 &lt;code&gt;history&lt;/code&gt; API或 &lt;code&gt;/#/posts/new&lt;/code&gt; 的旧的，如Internet Explorer 9和表。</target>
        </trans-unit>
        <trans-unit id="ef38bf8c063d320ef5caf31e346a8a11963ad798" translate="yes" xml:space="preserve">
          <source>This will result in a posts.new url of &lt;code&gt;/posts/new&lt;/code&gt;.</source>
          <target state="translated">这将导致 &lt;code&gt;/posts/new&lt;/code&gt; 的posts.new网址。</target>
        </trans-unit>
        <trans-unit id="a594b83e2729c4c06fe483d9931d88196c8ca620" translate="yes" xml:space="preserve">
          <source>This will tell the JSON API adapter that requests for &lt;code&gt;formula&lt;/code&gt; should go to &lt;code&gt;/formulae/1&lt;/code&gt; instead of &lt;code&gt;/formulas/1&lt;/code&gt;, and that requests for &lt;code&gt;advice&lt;/code&gt; should go to &lt;code&gt;/advice/1&lt;/code&gt; instead of &lt;code&gt;/advices/1&lt;/code&gt;.</source>
          <target state="translated">这将告诉JSON API适配器，对 &lt;code&gt;formula&lt;/code&gt; 请求应转到 &lt;code&gt;/formulae/1&lt;/code&gt; 而不是 &lt;code&gt;/formulas/1&lt;/code&gt; ，并且对 &lt;code&gt;advice&lt;/code&gt; 请求应该转到 &lt;code&gt;/advice/1&lt;/code&gt; 而不是 &lt;code&gt;/advices/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="388cb66fb1ec711f83c1701450ba620236ebbe6b" translate="yes" xml:space="preserve">
          <source>This will use the primitive &lt;code&gt;replace()&lt;/code&gt; method to insert an object at the specified index.</source>
          <target state="translated">这将使用原始的 &lt;code&gt;replace()&lt;/code&gt; 方法在指定的索引处插入一个对象。</target>
        </trans-unit>
        <trans-unit id="43bffd1dffcb32d458aa58f02d05febe38e1f4a7" translate="yes" xml:space="preserve">
          <source>This works great for the &lt;code&gt;list-of-drafts&lt;/code&gt; component. However, your app is likely made up of many different components. On another page you may want a component to display the number of drafts. You may be tempted to copy and paste your existing &lt;code&gt;willRender&lt;/code&gt; code into the new component.</source>
          <target state="translated">这对于 &lt;code&gt;list-of-drafts&lt;/code&gt; 组件非常有用。但是，您的应用程序可能由许多不同的组件组成。在另一个页面上，您可能希望组件显示草稿数。您可能会想将现有的 &lt;code&gt;willRender&lt;/code&gt; 代码复制并粘贴到新组件中。</target>
        </trans-unit>
        <trans-unit id="14da4507e84203e01b9ae7da382b3a00aaae7fdc" translate="yes" xml:space="preserve">
          <source>This would render this HTML when no title is passed to the component:</source>
          <target state="translated">当没有向组件传递标题时,这将渲染这个HTML。</target>
        </trans-unit>
        <trans-unit id="8336ed0cc011aca5ef8d79b9105deaab281f7bb6" translate="yes" xml:space="preserve">
          <source>This would render this HTML:</source>
          <target state="translated">这样就可以呈现这个HTML。</target>
        </trans-unit>
        <trans-unit id="84006ec1fbe089f93f04790646a82cbef861bb3e" translate="yes" xml:space="preserve">
          <source>Thus when the div is clicked, the action on that context is called. Because the &lt;code&gt;actionFunction&lt;/code&gt; is just a function, closure actions can be passed between components and still execute in the correct context.</source>
          <target state="translated">因此，当单击div时，将调用对该上下文的操作。因为 &lt;code&gt;actionFunction&lt;/code&gt; 只是一个函数，所以可以在组件之间传递闭包动作，并且仍然可以在正确的上下文中执行。</target>
        </trans-unit>
        <trans-unit id="777fb441ed8a221e3154f33948c533e6c0b3cd66" translate="yes" xml:space="preserve">
          <source>Thus, many of Ember's built-in helpers (as well as your custom helpers) can be used in nested form.</source>
          <target state="translated">因此,许多Ember的内置帮助程序(以及您的自定义帮助程序)可以以嵌套形式使用。</target>
        </trans-unit>
        <trans-unit id="bc09fd602f6d10a4673777c6b4fc42a255573839" translate="yes" xml:space="preserve">
          <source>Thus, the output of these combined helpers is &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">因此，这些组合的助手的输出为 &lt;code&gt;10&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8708c4922aad6bc5f7d4fb439f5a35edf457ec9" translate="yes" xml:space="preserve">
          <source>Timer information for use in canceling, see `run.cancel`.</source>
          <target state="translated">取消时使用的定时器信息,见`run.cancel`。</target>
        </trans-unit>
        <trans-unit id="ad8314f52b2f4c62535401de872ed1002612344d" translate="yes" xml:space="preserve">
          <source>Timer object to cancel</source>
          <target state="translated">要取消的定时器对象</target>
        </trans-unit>
        <trans-unit id="d393dc0e4b2a5c2cc44ef7e4ef9df6956f16e16f" translate="yes" xml:space="preserve">
          <source>To access a service, you can inject it in any container-resolved object such as a component or another service using the &lt;code&gt;Ember.inject.service&lt;/code&gt; function. There are two ways to use this function. You can either invoke it with no arguments, or you can pass it the registered name of the service. When no arguments are passed, the service is loaded based on the name of the variable key. You can load the shopping cart service with no arguments like below.</source>
          <target state="translated">要访问服务，可以使用 &lt;code&gt;Ember.inject.service&lt;/code&gt; 函数将其注入任何容器解析的对象中，例如组件或其他服务。有两种使用此功能的方法。您可以不带任何参数调用它，也可以将服务的注册名称传递给它。如果未传递任何参数，则根据变量键的名称加载服务。您可以不带任何参数加载购物车服务，如下所示。</target>
        </trans-unit>
        <trans-unit id="ad4e497b4d36c647d22f988a7c0708a0614aef99" translate="yes" xml:space="preserve">
          <source>To add a &lt;code&gt;category&lt;/code&gt; query parameter that will filter out all the articles that haven't been categorized as popular we'd specify &lt;code&gt;'category'&lt;/code&gt; as one of &lt;code&gt;controller:article&lt;/code&gt;'s &lt;code&gt;queryParams&lt;/code&gt;:</source>
          <target state="translated">为了添加一个 &lt;code&gt;category&lt;/code&gt; 查询参数，该参数将过滤掉所有未被归类为流行的文章，我们将指定 &lt;code&gt;'category'&lt;/code&gt; 作为 &lt;code&gt;controller:article&lt;/code&gt; 的 &lt;code&gt;queryParams&lt;/code&gt; 之一：</target>
        </trans-unit>
        <trans-unit id="64b4906525b4bd262e5a9d0ce454f20e5241165a" translate="yes" xml:space="preserve">
          <source>To add a new helper, create a file with the name of the helper you want (e.g. &lt;code&gt;format-currency.js&lt;/code&gt;) in your application's &lt;code&gt;helpers&lt;/code&gt; directory. You can also have Ember generate the file for you from the command line:</source>
          <target state="translated">要添加新的助手，请在应用程序的 &lt;code&gt;helpers&lt;/code&gt; 目录中创建一个具有所需助手名称的文件（例如 &lt;code&gt;format-currency.js&lt;/code&gt; ）。您还可以让Ember从命令行为您生成文件：</target>
        </trans-unit>
        <trans-unit id="ccf70d0371c2fbff368e75db67c4c62218610aa5" translate="yes" xml:space="preserve">
          <source>To add an object to an enumerable, use the &lt;code&gt;addObject()&lt;/code&gt; method. This method will only add the object to the enumerable if the object is not already present and is of a type supported by the enumerable.</source>
          <target state="translated">要将对象添加到可枚举，请使用 &lt;code&gt;addObject()&lt;/code&gt; 方法。仅当该对象尚不存在并且属于可枚举支持的类型时，此方法才将其添加到可枚举。</target>
        </trans-unit>
        <trans-unit id="612437c7a9dd2aab848343a115ff82b4a3a49077" translate="yes" xml:space="preserve">
          <source>To add an observer for a property, call:</source>
          <target state="translated">要为一个属性添加一个观察者,调用。</target>
        </trans-unit>
        <trans-unit id="64f77ec9361b31e70af01b3aeed99d505520fad8" translate="yes" xml:space="preserve">
          <source>To add functions and properties to instances of a constructor by extending the constructor's prototype see &lt;code&gt;reopen&lt;/code&gt;</source>
          <target state="translated">通过扩展构造函数的原型向构造函数的实例添加函数和属性，请参见 &lt;code&gt;reopen&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbc1d24b350815efa8e5ebb0581fbf2701efa8fd" translate="yes" xml:space="preserve">
          <source>To add functions and properties to the constructor itself, see &lt;code&gt;reopenClass&lt;/code&gt;</source>
          <target state="translated">要将函数和属性添加到构造函数本身，请参见 &lt;code&gt;reopenClass&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e1f6f236f185a772efb6540307b2e949361e3c1" translate="yes" xml:space="preserve">
          <source>To add new events to be listened to:</source>
          <target state="translated">要添加新的事件来监听。</target>
        </trans-unit>
        <trans-unit id="dd74399dd3c625fbe38e2a7a93a9e1356892dc03" translate="yes" xml:space="preserve">
          <source>To allow the &lt;code&gt;willTransition&lt;/code&gt; event to continue bubbling to the parent route, use &lt;code&gt;return true;&lt;/code&gt;. When the &lt;code&gt;willTransition&lt;/code&gt; method has a return value of &lt;code&gt;true&lt;/code&gt; then the parent route's &lt;code&gt;willTransition&lt;/code&gt; method will be fired, enabling &quot;bubbling&quot; behavior for the event.</source>
          <target state="translated">要允许 &lt;code&gt;willTransition&lt;/code&gt; 事件继续冒泡到父路由，请使用 &lt;code&gt;return true;&lt;/code&gt; ;。。当 &lt;code&gt;willTransition&lt;/code&gt; 方法的返回值为 &lt;code&gt;true&lt;/code&gt; 时，将触发父路由的 &lt;code&gt;willTransition&lt;/code&gt; 方法，从而为事件启用&amp;ldquo;冒泡&amp;rdquo;行为。</target>
        </trans-unit>
        <trans-unit id="f55c6421e541207d1e25237aa0749707b6d2ce1f" translate="yes" xml:space="preserve">
          <source>To allow the user to widen the image, we will need to add an action that toggles the value of &lt;code&gt;isWide&lt;/code&gt;. Let's call this action &lt;code&gt;toggleImageSize&lt;/code&gt;</source>
          <target state="translated">为了允许用户加宽图像，我们将需要添加一个操作来切换 &lt;code&gt;isWide&lt;/code&gt; 的值。我们将此动作 &lt;code&gt;toggleImageSize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3893ea84ac6eb7bbc9a0aae0f524ff440385112a" translate="yes" xml:space="preserve">
          <source>To annotate computed properties, use the &lt;code&gt;Ember.computed()&lt;/code&gt; method to wrap the function:</source>
          <target state="translated">要注释计算的属性，请使用 &lt;code&gt;Ember.computed()&lt;/code&gt; 方法包装函数：</target>
        </trans-unit>
        <trans-unit id="8fe75361f7d4d895b287bf14c5b819b85797d1a1" translate="yes" xml:space="preserve">
          <source>To avoid this behavior, it is encouraged to initialize those arrays and object properties during &lt;code&gt;init()&lt;/code&gt;. Doing so ensures each instance will be unique.</source>
          <target state="translated">为了避免这种行为，建议在 &lt;code&gt;init()&lt;/code&gt; 期间初始化这些数组和对象属性。这样做可以确保每个实例都是唯一的。</target>
        </trans-unit>
        <trans-unit id="7023afe6c467f1d9d8a77531b4eee7ffb2d113e8" translate="yes" xml:space="preserve">
          <source>To begin, let's generate our new component. We'll call this component &lt;code&gt;list-filter&lt;/code&gt;, since all we want our component to do is filter the list of rentals based on input.</source>
          <target state="translated">首先，让我们生成我们的新组件。我们将这个组件称为 &lt;code&gt;list-filter&lt;/code&gt; ，因为我们希望我们的组件要做的就是根据输入来过滤租赁列表。</target>
        </trans-unit>
        <trans-unit id="2041c7e5184639b6652b147ff7731d4861370040" translate="yes" xml:space="preserve">
          <source>To browse addons, visit the &lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Observer&lt;/a&gt; website. It catalogs and categorizes Ember addons that have been published to NPM and assigns them a score based on a variety of criteria.</source>
          <target state="translated">要浏览插件，请访问&lt;a href=&quot;https://emberobserver.com/&quot;&gt;Ember Observer&lt;/a&gt;网站。它对已发布到NPM的Ember插件进行分类和分类，并根据各种标准为其分配分数。</target>
        </trans-unit>
        <trans-unit id="5d2de65aa264859c42ccec965b16380ce611d54d" translate="yes" xml:space="preserve">
          <source>To change the format of the data that is sent to the backend store, you can use the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_serialize&quot;&gt;&lt;code&gt;serialize()&lt;/code&gt;&lt;/a&gt; hook. Let's say that we have this JSON API response from Ember Data:</source>
          <target state="translated">若要更改发送到后端存储的数据格式，可以使用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_serialize&quot;&gt; &lt;code&gt;serialize()&lt;/code&gt; &lt;/a&gt;挂钩。假设我们有来自Ember Data的JSON API响应：</target>
        </trans-unit>
        <trans-unit id="8147260956e1d80c68ae4385b8dfaf8e846f2a9f" translate="yes" xml:space="preserve">
          <source>To check that rentals are listed with an automated test, we will create a test to visit the index route and check that the results show 3 listings.</source>
          <target state="translated">为了用自动测试来检查是否有出租房源,我们将创建一个测试来访问索引路线,并检查结果显示3个房源。</target>
        </trans-unit>
        <trans-unit id="1f8255d58ff45b69a2cfcbdef10d629721ba8fc6" translate="yes" xml:space="preserve">
          <source>To clear the currently logged Promises, click on the clear icon on the top left of the tab.</source>
          <target state="translated">要清除当前记录的承诺,请点击标签左上方的清除图标。</target>
        </trans-unit>
        <trans-unit id="29f27b12694ecb81b431f0d90751a5300c28c856" translate="yes" xml:space="preserve">
          <source>To collect deprecations, first run your in-browser test suite by starting your development server and navigating to &lt;a href=&quot;http://localhost:4200/tests&quot;&gt;&lt;code&gt;http://localhost:4200/tests&lt;/code&gt;&lt;/a&gt;. If your test suite isn't fully covering your app's functionality, you may also manually exercise functionality within your app where needed. Once you've exercised the app to your satisfaction, run the following command within your browser console: &lt;code&gt;deprecationWorkflow.flushDeprecations()&lt;/code&gt;. This will print to the console JavaScript code, which you should then copy to a new file in your project called &lt;code&gt;/config/deprecation-workflow.js&lt;/code&gt;</source>
          <target state="translated">要收集不赞成使用的内容，请首先通过启动开发服务器并导航到&lt;a href=&quot;http://localhost:4200/tests&quot;&gt; &lt;code&gt;http://localhost:4200/tests&lt;/code&gt; &lt;/a&gt;来运行浏览器内测试套件。如果您的测试套件没有完全涵盖您应用程序的功能，则您还可以在需要时手动在应用程序内行使功能。对应用程序进行满意的锻炼之后，请在浏览器控制台中运行以下命令： &lt;code&gt;deprecationWorkflow.flushDeprecations()&lt;/code&gt; 。这将打印到控制台JavaScript代码，然后应将其复制到项目中名为 &lt;code&gt;/config/deprecation-workflow.js&lt;/code&gt; 的新文件中。</target>
        </trans-unit>
        <trans-unit id="3175b38418b12c2d580746cc8cc19dc3a953fab7" translate="yes" xml:space="preserve">
          <source>To create a class-based helper, rather than exporting a simple function, you should export a subclass of &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt;&lt;code&gt;Ember.Helper&lt;/code&gt;&lt;/a&gt;. Helper classes must contain a &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_compute&quot;&gt;&lt;code&gt;compute&lt;/code&gt;&lt;/a&gt; method that behaves the same as the function passed to &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_helper&quot;&gt;&lt;code&gt;Ember.Helper.helper&lt;/code&gt;&lt;/a&gt;. In order to access a service, you must first inject it into the class-based helper. Once added, you can call the service's methods or access its properties from within the &lt;code&gt;compute()&lt;/code&gt; method.</source>
          <target state="translated">要创建基于类的帮助程序，而不是导出简单的函数，您应该导出&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html&quot;&gt; &lt;code&gt;Ember.Helper&lt;/code&gt; &lt;/a&gt;的子类。Helper类必须包含一个行为与传递给&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_helper&quot;&gt; &lt;code&gt;Ember.Helper.helper&lt;/code&gt; &lt;/a&gt;的函数相同的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Helper.html#method_compute&quot;&gt; &lt;code&gt;compute&lt;/code&gt; &lt;/a&gt;方法。为了访问服务，您必须首先将其注入基于类的帮助器中。添加后，您可以调用服务的方法或从 &lt;code&gt;compute()&lt;/code&gt; 方法内部访问其属性。</target>
        </trans-unit>
        <trans-unit id="483b244a408fb90428d0b9a44c7fe6d9ad8692be" translate="yes" xml:space="preserve">
          <source>To create a custom error to signal a specific error state in communicating with an external API, extend the &lt;code&gt;DS.AdapterError&lt;/code&gt;. For example if the external API exclusively used HTTP &lt;code&gt;503 Service Unavailable&lt;/code&gt; to indicate it was closed for maintenance:</source>
          <target state="translated">要创建自定义错误以在与外部API通信时发出特定的错误状态信号，请扩展 &lt;code&gt;DS.AdapterError&lt;/code&gt; 。例如，如果外部API仅使用HTTP &lt;code&gt;503 Service Unavailable&lt;/code&gt; 用来表示已关闭以进行维护：</target>
        </trans-unit>
        <trans-unit id="5f58871b9ab756fa7fbfd2a0634d267d3a4ce8ae" translate="yes" xml:space="preserve">
          <source>To create a new instance of a &lt;code&gt;Post&lt;/code&gt; that has a relationship with a &lt;code&gt;User&lt;/code&gt; record:</source>
          <target state="translated">要创建与 &lt;code&gt;User&lt;/code&gt; 记录有关系的新 &lt;code&gt;Post&lt;/code&gt; 实例：</target>
        </trans-unit>
        <trans-unit id="0e61e0cae04fd9ad56d0c4c5698e8faa32a1f269" translate="yes" xml:space="preserve">
          <source>To create a new instance of a &lt;code&gt;Post&lt;/code&gt;:</source>
          <target state="translated">要创建 &lt;code&gt;Post&lt;/code&gt; 的新实例：</target>
        </trans-unit>
        <trans-unit id="7fa82787ae3f63115905a224cbbd4da31001a607" translate="yes" xml:space="preserve">
          <source>To create a new project using Ember CLI, use the &lt;code&gt;new&lt;/code&gt; command. In preparation for the tutorial in the next section, you can make an app called &lt;code&gt;super-rentals&lt;/code&gt;.</source>
          <target state="translated">要使用Ember CLI创建新项目，请使用 &lt;code&gt;new&lt;/code&gt; 命令。在准备下一节的教程时，您可以制作一个名为 &lt;code&gt;super-rentals&lt;/code&gt; 的应用程序。</target>
        </trans-unit>
        <trans-unit id="0507bf8200bc0fc65ea17fae004600ec931bee74" translate="yes" xml:space="preserve">
          <source>To create an acceptance test, run &lt;code&gt;ember generate acceptance-test &amp;lt;name&amp;gt;&lt;/code&gt;. For example:</source>
          <target state="translated">要创建验收测试，请运行 &lt;code&gt;ember generate acceptance-test &amp;lt;name&amp;gt;&lt;/code&gt; 。例如：</target>
        </trans-unit>
        <trans-unit id="6546ce366ebc2a0397c0ab3926caf7dfba659cf6" translate="yes" xml:space="preserve">
          <source>To create an index nested route, run the following command:</source>
          <target state="translated">要创建索引嵌套路由,请运行以下命令。</target>
        </trans-unit>
        <trans-unit id="f16533be33b27f3dabd74f1c1a59b9369d04e94e" translate="yes" xml:space="preserve">
          <source>To customize how &lt;code&gt;JSONSerializer&lt;/code&gt; normalizes a specific response from the server, use one of the many specific &lt;code&gt;normalizeResponse&lt;/code&gt; hooks.</source>
          <target state="translated">要自定义 &lt;code&gt;JSONSerializer&lt;/code&gt; 如何规范来自服务器的特定响应，请使用许多特定的 &lt;code&gt;normalizeResponse&lt;/code&gt; 挂钩之一。</target>
        </trans-unit>
        <trans-unit id="efffbb69cac955b484ca11b4daebd1d8a4b7475b" translate="yes" xml:space="preserve">
          <source>To customize how &lt;code&gt;JSONSerializer&lt;/code&gt; normalizes the whole server response, use the &lt;code&gt;normalizeResponse&lt;/code&gt; hook.</source>
          <target state="translated">要自定义 &lt;code&gt;JSONSerializer&lt;/code&gt; 如何标准化整个服务器响应，请使用 &lt;code&gt;normalizeResponse&lt;/code&gt; 挂钩。</target>
        </trans-unit>
        <trans-unit id="85f903926c89b490fde43d23a09ec470fcb5dc60" translate="yes" xml:space="preserve">
          <source>To customize how &lt;code&gt;JSONSerializer&lt;/code&gt; normalizes your id, attributes or relationships, use the &lt;code&gt;extractId&lt;/code&gt;, &lt;code&gt;extractAttributes&lt;/code&gt; and &lt;code&gt;extractRelationships&lt;/code&gt; hooks.</source>
          <target state="translated">要定制 &lt;code&gt;JSONSerializer&lt;/code&gt; 标准化您的ID，属性或关系，使用 &lt;code&gt;extractId&lt;/code&gt; ， &lt;code&gt;extractAttributes&lt;/code&gt; 和 &lt;code&gt;extractRelationships&lt;/code&gt; 挂钩。</target>
        </trans-unit>
        <trans-unit id="ba373f1b978a32c09a08e1c1a2055e76267a7a9f" translate="yes" xml:space="preserve">
          <source>To customize how a single record is normalized, use the &lt;code&gt;normalize&lt;/code&gt; hook.</source>
          <target state="translated">要自定义单个记录的标准化方式，请使用 &lt;code&gt;normalize&lt;/code&gt; 挂钩。</target>
        </trans-unit>
        <trans-unit id="896f7618df1a2c5ae15b21da0d539bcce0c86fef" translate="yes" xml:space="preserve">
          <source>To customize metadata extraction, check out the documentation for your serializer.</source>
          <target state="translated">要自定义元数据提取,请查看你的序列化器的文档。</target>
        </trans-unit>
        <trans-unit id="d00f2a82ea97d7698e61579522a38bad982a0f6f" translate="yes" xml:space="preserve">
          <source>To declare a many-to-many relationship between two models, use &lt;code&gt;DS.hasMany&lt;/code&gt;:</source>
          <target state="translated">要声明两个模型之间的多对多关系，请使用 &lt;code&gt;DS.hasMany&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f384718df6203efdfa0de22885112131e57b9ef5" translate="yes" xml:space="preserve">
          <source>To declare a one-to-many relationship between two models, use &lt;code&gt;DS.belongsTo&lt;/code&gt; in combination with &lt;code&gt;DS.hasMany&lt;/code&gt;, like this:</source>
          <target state="translated">要声明两个模型之间的一对多关系， &lt;code&gt;DS.belongsTo&lt;/code&gt; 与 &lt;code&gt;DS.hasMany&lt;/code&gt; 结合使用，如下所示：</target>
        </trans-unit>
        <trans-unit id="fd45271172de2827aec0b66ded46c1526981e4f0" translate="yes" xml:space="preserve">
          <source>To declare a one-to-one relationship between two models, use &lt;code&gt;DS.belongsTo&lt;/code&gt;:</source>
          <target state="translated">要声明两个模型之间的一对一关系，请使用 &lt;code&gt;DS.belongsTo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="22bb95d7016d3a82a771c01b24a90740704cb355" translate="yes" xml:space="preserve">
          <source>To define a Controller, run:</source>
          <target state="translated">要定义一个控制器,请运行。</target>
        </trans-unit>
        <trans-unit id="537f62c13bb7ffd878dfd54110b3a5a612606ee8" translate="yes" xml:space="preserve">
          <source>To define a component, run:</source>
          <target state="translated">要定义一个组件,运行。</target>
        </trans-unit>
        <trans-unit id="284d1b21151d2a0f19c15e660bf3d35370f288b5" translate="yes" xml:space="preserve">
          <source>To define a new Ember &lt;em&gt;class&lt;/em&gt;, call the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_extend&quot;&gt;&lt;code&gt;extend()&lt;/code&gt;&lt;/a&gt; method on &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html&quot;&gt;&lt;code&gt;Ember.Object&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">要定义一个新的Ember &lt;em&gt;类&lt;/em&gt;，请在&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html&quot;&gt; &lt;code&gt;Ember.Object&lt;/code&gt; &lt;/a&gt;上调用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Object.html#method_extend&quot;&gt; &lt;code&gt;extend()&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="820da85f7f75fe525eb448c437bc45950e1f888d" translate="yes" xml:space="preserve">
          <source>To define a route, run</source>
          <target state="translated">要定义途径,请运行</target>
        </trans-unit>
        <trans-unit id="e7d7b2d08cd1de85998600ba46809350abc299b9" translate="yes" xml:space="preserve">
          <source>To deploy an Ember application simply transfer the output from &lt;code&gt;ember build&lt;/code&gt; to a web server. This can be done with standard Unix file transfer tools such as &lt;code&gt;rsync&lt;/code&gt; or &lt;code&gt;scp&lt;/code&gt;. There are also services that will let you deploy easily.</source>
          <target state="translated">要部署Ember应用程序，只需将输出从 &lt;code&gt;ember build&lt;/code&gt; 传输到Web服务器即可。这可以使用标准的Unix文件传输工具（例如 &lt;code&gt;rsync&lt;/code&gt; 或 &lt;code&gt;scp&lt;/code&gt; )来完成。还有一些服务可以使您轻松部署。</target>
        </trans-unit>
        <trans-unit id="065fd99d1476baffa1b82c4b08460d031141cb32" translate="yes" xml:space="preserve">
          <source>To deploy to the same URL after making changes, perform the same steps, reusing the same domain as before.</source>
          <target state="translated">如果要在进行更改后部署到相同的URL,请执行相同的步骤,重新使用与之前相同的域名。</target>
        </trans-unit>
        <trans-unit id="6734a6e5bb3c4c06ddac515519b73ca33307818c" translate="yes" xml:space="preserve">
          <source>To disable bubbling with closure style actions you must create your own wrapper helper that makes use of &lt;code&gt;event.stopPropagation()&lt;/code&gt;:</source>
          <target state="translated">要使用闭合样式操作禁用冒泡，您必须创建自己的使用 &lt;code&gt;event.stopPropagation()&lt;/code&gt; 的包装助手：</target>
        </trans-unit>
        <trans-unit id="03d431777776d94843205036e89382929b67b7df" translate="yes" xml:space="preserve">
          <source>To disable bubbling, pass &lt;code&gt;bubbles=false&lt;/code&gt; to the helper:</source>
          <target state="translated">要禁用冒泡，请将 &lt;code&gt;bubbles=false&lt;/code&gt; 传递给助手：</target>
        </trans-unit>
        <trans-unit id="83f92bbd711ff46b48c7b3053ad6815ca742a2e1" translate="yes" xml:space="preserve">
          <source>To dispatch an action on specific events, such as &lt;code&gt;enter&lt;/code&gt; or &lt;code&gt;key-press&lt;/code&gt;, use the following</source>
          <target state="translated">要针对特定​​事件（例如 &lt;code&gt;enter&lt;/code&gt; 或 &lt;code&gt;key-press&lt;/code&gt; )调度操作，请使用以下命令</target>
        </trans-unit>
        <trans-unit id="53be2d3cee464dda29e541bcc47ec4c0a39972d4" translate="yes" xml:space="preserve">
          <source>To do so, run the following command:</source>
          <target state="translated">为此,请运行以下命令。</target>
        </trans-unit>
        <trans-unit id="0711a711e6a702ee3f035ad582cb0f83d0ea3111" translate="yes" xml:space="preserve">
          <source>To do so, simply set the &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; flag to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">为此，只需将 &lt;code&gt;EmberENV.EXTEND_PROTOTYPES&lt;/code&gt; 标志设置为 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="642b3e926c752f7b1f53ecb9a54d25f0d597ad8b" translate="yes" xml:space="preserve">
          <source>To do that, replace occurrences of &lt;code&gt;/list-rentals&lt;/code&gt; in the generated test with &lt;code&gt;/&lt;/code&gt;. The test will start our app at the base url, &lt;code&gt;http://localhost:4200/&lt;/code&gt;, and then do a basic check that the page has finished loading and that the url is what we want it to be.</source>
          <target state="translated">为此，将生成的测试中 &lt;code&gt;/list-rentals&lt;/code&gt; 的出现替换为 &lt;code&gt;/&lt;/code&gt; 。该测试将在基本URL &lt;code&gt;http://localhost:4200/&lt;/code&gt; 处启动我们的应用程序，然后进行基本检查，以确保页面已完成加载并且该URL是我们想要的URL。</target>
        </trans-unit>
        <trans-unit id="1df522ee440a55de68e6a9dd8378f737af37e593" translate="yes" xml:space="preserve">
          <source>To do that, we modify our route as follows:</source>
          <target state="translated">为此,我们修改我们的路由如下。</target>
        </trans-unit>
        <trans-unit id="077ff282e23889aeeea0b97f0141bf14b2b23e54" translate="yes" xml:space="preserve">
          <source>To do that, we'll use a &lt;a href=&quot;https://guides.emberjs.com/templates/links/&quot;&gt;&lt;code&gt;{{link-to}}&lt;/code&gt;&lt;/a&gt; helper that Ember provides that makes it easy to link between our routes. Let's adjust our &lt;code&gt;about.hbs&lt;/code&gt; file:</source>
          <target state="translated">为此，我们将使用Ember提供的&lt;a href=&quot;https://guides.emberjs.com/templates/links/&quot;&gt; &lt;code&gt;{{link-to}}&lt;/code&gt; &lt;/a&gt;帮助程序，以使我们的路线之间的链接变得容易。让我们调整 &lt;code&gt;about.hbs&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="d87c2ae1d29eef6f28426678419f6574ae578e14" translate="yes" xml:space="preserve">
          <source>To embed the &lt;code&gt;ids&lt;/code&gt; for a related object (using a hasMany relationship):</source>
          <target state="translated">嵌入相关对象的 &lt;code&gt;ids&lt;/code&gt; （使用hasMany关系）：</target>
        </trans-unit>
        <trans-unit id="7b266ec9d9020d51490a793b222a2e15e77408c1" translate="yes" xml:space="preserve">
          <source>To embed the relationship as a collection of objects with &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; keys, set &lt;code&gt;ids-and-types&lt;/code&gt; for the related object.</source>
          <target state="translated">要将关系嵌入为具有 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;type&lt;/code&gt; 键的对象的集合，请为相关对象设置 &lt;code&gt;ids-and-types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4dbe3553d2c10be5b18402a6280f709c7557952" translate="yes" xml:space="preserve">
          <source>To enable support for data attributes an attribute binding must be added to the component, e.g. &lt;a href=&quot;http://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt;&lt;code&gt;Ember.LinkComponent&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;http://emberjs.com/api/classes/Ember.TextField.html&quot;&gt;&lt;code&gt;Ember.TextField&lt;/code&gt;&lt;/a&gt; for the specific attribute:</source>
          <target state="translated">为了启用对数据属性的支持，必须将属性绑定添加到组件，例如，特定属性的&lt;a href=&quot;http://emberjs.com/api/classes/Ember.LinkComponent.html&quot;&gt; &lt;code&gt;Ember.LinkComponent&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;http://emberjs.com/api/classes/Ember.TextField.html&quot;&gt; &lt;code&gt;Ember.TextField&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="cb5f57bc075f6cf1a9892170f5cc300d7a2ec2da" translate="yes" xml:space="preserve">
          <source>To enable the Tomster icon to show up in the URL bar whenever you are visiting a site that uses Ember visit &lt;code&gt;about:addons&lt;/code&gt;.</source>
          <target state="translated">要使Tomster图标在您访问使用Ember的网站时显示在URL栏中，请访问 &lt;code&gt;about:addons&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="52c2b2d458eaa991122169345b898417f6372aad" translate="yes" xml:space="preserve">
          <source>To enable this mode you can set:</source>
          <target state="translated">要启用该模式,您可以设置。</target>
        </trans-unit>
        <trans-unit id="d3e54ffc59a679009cd71018fbf20dc2908c33d0" translate="yes" xml:space="preserve">
          <source>To enumerate all the values of an enumerable object, use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_forEach&quot;&gt;&lt;code&gt;forEach()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">要枚举可枚举对象的所有值，请使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_forEach&quot;&gt; &lt;code&gt;forEach()&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="e247d282c81bce4351bac12e80aee643f2064371" translate="yes" xml:space="preserve">
          <source>To facilitate pluralizing model names when generating route urls Ember Data comes bundled with &lt;a href=&quot;https://github.com/stefanpenner/ember-inflector&quot;&gt;Ember Inflector&lt;/a&gt;, an ActiveSupport::Inflector compatible library for inflecting words between plural and singular forms. Irregular or uncountable pluralizations can be specified via &lt;code&gt;Ember.Inflector.inflector&lt;/code&gt;. A common way to do this is:</source>
          <target state="translated">为了在生成路线网址时促进模型名称的多元化，Ember Data与&lt;a href=&quot;https://github.com/stefanpenner/ember-inflector&quot;&gt;Ember Inflector&lt;/a&gt;捆绑在一起，Ember Inflector是一个ActiveSupport :: Inflector兼容库，用于在复数形式和单数形式之间转换单词。可以通过 &lt;code&gt;Ember.Inflector.inflector&lt;/code&gt; 指定不规则或不可数的复数。常用的方法是：</target>
        </trans-unit>
        <trans-unit id="89387035491e2b9779d432c33ff0f9bc1db9ee30" translate="yes" xml:space="preserve">
          <source>To facilitate this, Ember provides the &lt;code&gt;@each&lt;/code&gt; key illustrated below:</source>
          <target state="translated">为方便 &lt;code&gt;@each&lt;/code&gt; ，Ember提供了如下所示的@each键：</target>
        </trans-unit>
        <trans-unit id="d181f0d9ef256075afc193e940cb2778cc125a3c" translate="yes" xml:space="preserve">
          <source>To fetch an instantiated factory from the running application you can call the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup&quot;&gt;&lt;code&gt;lookup&lt;/code&gt;&lt;/a&gt; method on an application instance. This method takes a string to identify a factory and returns the appropriate object.</source>
          <target state="translated">要从正在运行的应用程序中获取实例化的工厂，可以在应用程序实例上调用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.ApplicationInstance.html#method_lookup&quot;&gt; &lt;code&gt;lookup&lt;/code&gt; &lt;/a&gt;方法。此方法采用字符串来标识工厂，并返回适当的对象。</target>
        </trans-unit>
        <trans-unit id="8d1f23fd8117e1414f047abb53730ce2c42e57e9" translate="yes" xml:space="preserve">
          <source>To filter the logs, type a query in the search box.</source>
          <target state="translated">要过滤日志,请在搜索框中输入查询。</target>
        </trans-unit>
        <trans-unit id="b9c9e9ecb077e7d53718dabf283948eae57a0fe4" translate="yes" xml:space="preserve">
          <source>To find out whether at least one item in an enumerable matches some condition, you can use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_any&quot;&gt;&lt;code&gt;any()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">要找出可枚举中的至少一项是否符合某个条件，可以使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_any&quot;&gt; &lt;code&gt;any()&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="4c63511432e85445a8b4de943b86b4ff86b52bda" translate="yes" xml:space="preserve">
          <source>To find out whether every item in an enumerable matches some condition, you can use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_every&quot;&gt;&lt;code&gt;every()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">要确定可枚举中的每个项目是否都符合某个条件，可以使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Enumerable.html#method_every&quot;&gt; &lt;code&gt;every()&lt;/code&gt; &lt;/a&gt;方法：</target>
        </trans-unit>
        <trans-unit id="06062dde08f65defee01d144c5693a07b8897c5e" translate="yes" xml:space="preserve">
          <source>To find the elements that have a class called &lt;code&gt;listing&lt;/code&gt;, we'll use a test helper called &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_find&quot;&gt;find&lt;/a&gt;. The &lt;code&gt;find&lt;/code&gt; function returns the elements that match the given &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors&quot;&gt;CSS selector&lt;/a&gt;. In this case it will return an array of all the elements with a class called &lt;code&gt;listing&lt;/code&gt;.</source>
          <target state="translated">要查找具有名为 &lt;code&gt;listing&lt;/code&gt; 的类的元素，我们将使用一个名为&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Test.html#method_find&quot;&gt;find&lt;/a&gt;的测试助手。在 &lt;code&gt;find&lt;/code&gt; 函数返回给定匹配元素&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors&quot;&gt;的CSS选择器&lt;/a&gt;。在这种情况下，它将返回所有元素的数组，并带有一个名为 &lt;code&gt;listing&lt;/code&gt; 的类。</target>
        </trans-unit>
        <trans-unit id="2fd9f8a52de87bee0c288eaed67d1f195e5f6ddf" translate="yes" xml:space="preserve">
          <source>To fix this add a file called '.htaccess' to the root folder of your website. Add these lines:</source>
          <target state="translated">为了解决这个问题,在你的网站根目录下添加一个名为'.htaccess'的文件。添加这些行。</target>
        </trans-unit>
        <trans-unit id="dc22e48a36a2fa58e492a5c1d7190654605ab3b1" translate="yes" xml:space="preserve">
          <source>To get around these problems, you should make use of &lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt;&lt;code&gt;Ember.run.once()&lt;/code&gt;&lt;/a&gt;. This will ensure that any processing you need to do only happens once, and happens in the next run loop once all bindings are synchronized:</source>
          <target state="translated">要解决这些问题，您应该使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.run.html#method_once&quot;&gt; &lt;code&gt;Ember.run.once()&lt;/code&gt; &lt;/a&gt;。这将确保您需要执行的任何处理仅发生一次，并且在所有绑定都同步后在下一个运行循环中发生：</target>
        </trans-unit>
        <trans-unit id="0c5c7f3992c8b26c72a8ca9516e0759dd90b734e" translate="yes" xml:space="preserve">
          <source>To get different &lt;em&gt;pages&lt;/em&gt; of data, you'd simply change your offset in increments of 10. So far, so good. But how do you know how many pages of data you have? Your server would need to return the total number of records as a piece of metadata.</source>
          <target state="translated">要获取不同的数据&lt;em&gt;页&lt;/em&gt;，您只需以10为增量更改偏移量即可。到目前为止，一切都很好。但是，您如何知道您有多少页数据？您的服务器将需要返回记录总数作为一条元数据。</target>
        </trans-unit>
        <trans-unit id="f2a4e5cc694d3be2b7e400ea560253d1f71eaa5c" translate="yes" xml:space="preserve">
          <source>To get multiple properties at once, call &lt;code&gt;Ember.getProperties&lt;/code&gt; with an object followed by a list of strings or an array:</source>
          <target state="translated">要一次获取多个属性，请调用 &lt;code&gt;Ember.getProperties&lt;/code&gt; ，方法是先对象，后跟字符串或数组列表：</target>
        </trans-unit>
        <trans-unit id="52ae9585ef4ff335f0b0a68e5513ed3dbe6488ec" translate="yes" xml:space="preserve">
          <source>To get started, let's generate a helper for &lt;code&gt;rental-property-type&lt;/code&gt;:</source>
          <target state="translated">首先，让我们为 &lt;code&gt;rental-property-type&lt;/code&gt; 生成一个帮助器：</target>
        </trans-unit>
        <trans-unit id="73b15a2e4a984f27699d34f68a905af2183041a0" translate="yes" xml:space="preserve">
          <source>To get the most use out of a component, it is important to understand these lifecycle methods.</source>
          <target state="translated">要想最大限度地利用一个组件,了解这些生命周期方法很重要。</target>
        </trans-unit>
        <trans-unit id="8e28feb25417f98b442624123c65f66c40e988f2" translate="yes" xml:space="preserve">
          <source>To get the values of multiple properties at once, call &lt;code&gt;getProperties&lt;/code&gt; with a list of strings or an array:</source>
          <target state="translated">要一次获取多个属性的值，请使用字符串列表或数组调用 &lt;code&gt;getProperties&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7806e1c587e05f08b69393f6478019cb19942b1e" translate="yes" xml:space="preserve">
          <source>To handle this function call you need to modify the &lt;code&gt;people-list&lt;/code&gt; component file to add the function to be called. In the component, add an &lt;code&gt;actions&lt;/code&gt; object with a &lt;code&gt;showPerson&lt;/code&gt; function that alerts the first argument.</source>
          <target state="translated">要处理此函数，您需要修改 &lt;code&gt;people-list&lt;/code&gt; 组件文件以添加要调用的函数。在该组件中，添加带有 &lt;code&gt;showPerson&lt;/code&gt; 函数的 &lt;code&gt;actions&lt;/code&gt; 对象，该对象将警告第一个参数。</target>
        </trans-unit>
        <trans-unit id="5416b7eb8dce5acb1c8efef4e78276fe44c883b2" translate="yes" xml:space="preserve">
          <source>To have your route do something beyond render a template with the same name, you'll need to create a route handler. The following guides will explore the different features of route handlers. For more information on routes, see the API documentation for &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html&quot;&gt;the router&lt;/a&gt; and for &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html&quot;&gt;route handlers&lt;/a&gt;.</source>
          <target state="translated">要让您的路线做一些事情，而不仅仅是渲染具有相同名称的模板，您需要创建一个路线处理程序。以下指南将探讨路由处理程序的不同功能。有关路由的更多信息，请参阅&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Router.html&quot;&gt;路由器&lt;/a&gt;和&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html&quot;&gt;路由处理程序&lt;/a&gt;的API文档。</target>
        </trans-unit>
        <trans-unit id="37017a8822c89a19516c602dcc48cbd220d1dbfb" translate="yes" xml:space="preserve">
          <source>To implement the &lt;code&gt;filter&lt;/code&gt; function to do the actual filter of rentals by city, we'll create a &lt;code&gt;rentals&lt;/code&gt; controller. &lt;a href=&quot;https://guides.emberjs.com/controllers/&quot;&gt;Controllers&lt;/a&gt; contain actions and properties available to the template of its corresponding route. In our case we want to generate a controller called &lt;code&gt;rentals&lt;/code&gt;. Ember will know that a controller with the name of &lt;code&gt;rentals&lt;/code&gt; will apply to the route with the same name.</source>
          <target state="translated">为了实现 &lt;code&gt;filter&lt;/code&gt; 功能以按城市对租金进行实际过滤，我们将创建一个 &lt;code&gt;rentals&lt;/code&gt; 控制器。&lt;a href=&quot;https://guides.emberjs.com/controllers/&quot;&gt;控制器&lt;/a&gt;包含可用于其相应路由的模板的操作和属性。在我们的例子中，我们要生成一个称为 &lt;code&gt;rentals&lt;/code&gt; 的控制器。Ember知道，具有 &lt;code&gt;rentals&lt;/code&gt; 名称的控制器将应用于具有相同名称的路由。</target>
        </trans-unit>
        <trans-unit id="db39c8ec99de08b269bbe4798a73309f9f804b4b" translate="yes" xml:space="preserve">
          <source>To improve the network performance of your application, you can optimize your adapter by overriding these lower-level methods:</source>
          <target state="translated">为了提高应用程序的网络性能,您可以通过覆盖这些低级方法来优化您的适配器。</target>
        </trans-unit>
        <trans-unit id="8cdcf89a4a448babacd6de864831466ba71fbff2" translate="yes" xml:space="preserve">
          <source>To iterate over a list of items, use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt;&lt;code&gt;{{#each}}&lt;/code&gt;&lt;/a&gt; helper. The first argument to this helper is the array to be iterated, and the value being iterated is yielded as a block param. Block params are only available inside the block of their helper.</source>
          <target state="translated">要遍历项目列表，请使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Templates.helpers.html#method_each&quot;&gt; &lt;code&gt;{{#each}}&lt;/code&gt; &lt;/a&gt;帮助器。此帮助程序的第一个参数是要迭代的数组，并且要迭代的值作为块参数产生。块参数仅在其帮助器的块内可用。</target>
        </trans-unit>
        <trans-unit id="05f24d5f6782acbbef958bb70776badee1ad078d" translate="yes" xml:space="preserve">
          <source>To learn more about the events Ember components use, see &lt;a href=&quot;https://guides.emberjs.com/v2.6.0/components/handling-events/#toc_event-names&quot;&gt;components/handling-events&lt;/a&gt;.</source>
          <target state="translated">要了解有关Ember组件使用的事件的更多信息，请参阅&lt;a href=&quot;https://guides.emberjs.com/v2.6.0/components/handling-events/#toc_event-names&quot;&gt;component / handling-events&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1d4e80f03459d1f52f2363e1225daa9d4f187cf" translate="yes" xml:space="preserve">
          <source>To limit the test to validating only its own behavior and not the service, we'll take advantage of the registration API to register a stub maps service. That way when Ember injects the map service into the component, it uses our fake service instead of the real one.</source>
          <target state="translated">为了限制测试只验证自己的行为而不是服务,我们将利用注册API来注册一个残缺的地图服务。这样,当Ember将地图服务注入组件时,它就会使用我们的假服务而不是真服务。</target>
        </trans-unit>
        <trans-unit id="77755e062047f1b190e24cc4c004d477b633a1d4" translate="yes" xml:space="preserve">
          <source>To load a model for the &lt;code&gt;favorite-posts&lt;/code&gt; route, you would use the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_model&quot;&gt;&lt;code&gt;model()&lt;/code&gt;&lt;/a&gt; hook in the &lt;code&gt;favorite-posts&lt;/code&gt; route handler:</source>
          <target state="translated">要为 &lt;code&gt;favorite-posts&lt;/code&gt; 路线加载模型，您可以在 &lt;code&gt;favorite-posts&lt;/code&gt; 路线处理程序中使用&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Route.html#method_model&quot;&gt; &lt;code&gt;model()&lt;/code&gt; &lt;/a&gt;挂钩：</target>
        </trans-unit>
        <trans-unit id="f654c2cf3da300af867e72e2bd26f7caf007cd2a" translate="yes" xml:space="preserve">
          <source>To make the most out of the guides, you should have a working knowledge of:</source>
          <target state="translated">为了最大限度地利用这些指南,你应该掌握以下知识:</target>
        </trans-unit>
        <trans-unit id="c0de715ec4bdc05fe56d9fee36be46b5f31b2be4" translate="yes" xml:space="preserve">
          <source>To make your own custom class enumerable, you need two items:</source>
          <target state="translated">要制作自己的自定义类枚举,你需要两个项目。</target>
        </trans-unit>
        <trans-unit id="1c466dfb41d5e397019aa3e58144514a595ced70" translate="yes" xml:space="preserve">
          <source>To match multiple routes 'space-separate' the routes:</source>
          <target state="translated">匹配多个路由时,要将路由 &quot;隔开&quot;。</target>
        </trans-unit>
        <trans-unit id="13060a627addc391f25235a99ca3db1518034089" translate="yes" xml:space="preserve">
          <source>To measure components and templates that are rendered on initial application boot, click on the &quot;Reload&quot; button at the top. This button ensures that the Inspector starts measuring render times when your app boots.</source>
          <target state="translated">要测量应用程序初始启动时渲染的组件和模板,请单击顶部的 &quot;重新加载 &quot;按钮。该按钮可确保在应用程序启动时,检查员开始测量渲染时间。</target>
        </trans-unit>
        <trans-unit id="dc09e7ab0122ed1f10aad8febf2686e9ee8f8063" translate="yes" xml:space="preserve">
          <source>To normalize only a single model, you can use the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalize&quot;&gt;&lt;code&gt;normalize()&lt;/code&gt;&lt;/a&gt; hook similarly.</source>
          <target state="translated">要仅规范化一个模型，可以类似地使用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.JSONAPISerializer.html#method_normalize&quot;&gt; &lt;code&gt;normalize()&lt;/code&gt; &lt;/a&gt;挂钩。</target>
        </trans-unit>
        <trans-unit id="b36d9c0d96220aa91e734666c278c544e5c33712" translate="yes" xml:space="preserve">
          <source>To open the Inspector, click on the new bookmark. Safari blocks popups by default, so you'll need to enable popups before using the bookmarklet.</source>
          <target state="translated">要打开检查器,点击新书签。Safari 默认情况下会阻止弹出窗口,所以你需要在使用书签前启用弹出窗口。</target>
        </trans-unit>
        <trans-unit id="e32951622e512a5e2dbbf6daeb91928456978164" translate="yes" xml:space="preserve">
          <source>To override this method with a custom one, make sure to call &lt;code&gt;return this._super(store, primaryModelClass, payload, id, requestType)&lt;/code&gt; with your pre-processed data.</source>
          <target state="translated">要使用自定义方法覆盖此方法，请确保使用预处理后的数据调用 &lt;code&gt;return this._super(store, primaryModelClass, payload, id, requestType)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="643424ccbff431db940e6db1682aad8fbb931a53" translate="yes" xml:space="preserve">
          <source>To override this option for your entire application, see &quot;Overriding Application-wide Defaults&quot;.</source>
          <target state="translated">要为整个应用程序覆盖此选项,请参阅 &quot;覆盖应用程序范围的默认值&quot;。</target>
        </trans-unit>
        <trans-unit id="e7b7de1f5b2acd114aa92dfc71c79109066e6419" translate="yes" xml:space="preserve">
          <source>To pass multiple arguments to a helper, add them as a space-separated list after the helper name:</source>
          <target state="translated">要将多个参数传递给助记器,可以在助记器名称后添加一个以空格分隔的列表。</target>
        </trans-unit>
        <trans-unit id="782db8348bb156313d7ba95741850dae22fcade0" translate="yes" xml:space="preserve">
          <source>To prevent Ember from setting up a listener for a default event, specify the event name with a &lt;code&gt;null&lt;/code&gt; value in the &lt;code&gt;customEvents&lt;/code&gt; property:</source>
          <target state="translated">为了防止Ember为默认事件设置侦听器，请在 &lt;code&gt;customEvents&lt;/code&gt; 属性中使用 &lt;code&gt;null&lt;/code&gt; 值指定事件名称：</target>
        </trans-unit>
        <trans-unit id="7ad2dcdf74eb53253ee43f5d7112c03d7ee0c5cc" translate="yes" xml:space="preserve">
          <source>To prevent default events from being listened to:</source>
          <target state="translated">防止默认事件被监听。</target>
        </trans-unit>
        <trans-unit id="d140dc02f52e1fafe21fbb1f3e0a87899ed55913" translate="yes" xml:space="preserve">
          <source>To prevent setting an attribute altogether, use &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; as the return value of the &lt;code&gt;attributeBindings&lt;/code&gt; monitored property:</source>
          <target state="translated">为避免完全设置属性，请使用 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 作为 &lt;code&gt;attributeBindings&lt;/code&gt; 监视属性的返回值：</target>
        </trans-unit>
        <trans-unit id="88949b439b77da8a131b94c8c49c2264eabd59cf" translate="yes" xml:space="preserve">
          <source>To protect your application from cross-site scripting attacks (XSS), Ember automatically escapes any value you return from a helper so that the browser will not interpret it as HTML.</source>
          <target state="translated">为了保护您的应用程序免受跨站脚本攻击(XSS),Ember会自动转义您从帮助程序返回的任何值,这样浏览器就不会将其解释为HTML。</target>
        </trans-unit>
        <trans-unit id="410e671fa5ad1d60ce482717f4854a77655715ac" translate="yes" xml:space="preserve">
          <source>To provide a &lt;code&gt;firstName&lt;/code&gt; and &lt;code&gt;lastName&lt;/code&gt; to the above template, properties must be added to the application controller. If you are following along with an Ember CLI application, you may need to create this file:</source>
          <target state="translated">要为上述模板提供一个 &lt;code&gt;firstName&lt;/code&gt; 和 &lt;code&gt;lastName&lt;/code&gt; ，必须将属性添加到应用程序控制器。如果要跟随Ember CLI应用程序一起使用，则可能需要创建此文件：</target>
        </trans-unit>
        <trans-unit id="29f27a0e8e02bfdfa170f1d9c3e3d514551a7d10" translate="yes" xml:space="preserve">
          <source>To push a record into the store, call the store's &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_push&quot;&gt;&lt;code&gt;push()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">要将记录推入商店，请调用商店的&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_push&quot;&gt; &lt;code&gt;push()&lt;/code&gt; &lt;/a&gt;方法。</target>
        </trans-unit>
        <trans-unit id="9a185e83c481228539f24bb1c09c6b0245f73852" translate="yes" xml:space="preserve">
          <source>To remove a &lt;code&gt;belongsTo&lt;/code&gt; relationship, we can set it to &lt;code&gt;null&lt;/code&gt;, which will also remove it from the &lt;code&gt;hasMany&lt;/code&gt; side:</source>
          <target state="translated">要删除一个 &lt;code&gt;belongsTo&lt;/code&gt; 关系，我们可以将其设置为 &lt;code&gt;null&lt;/code&gt; ，这也会从 &lt;code&gt;hasMany&lt;/code&gt; 端将其删除：</target>
        </trans-unit>
        <trans-unit id="432349a69d598accb34ee2c2bc3e7748a2394e9f" translate="yes" xml:space="preserve">
          <source>To remove an object from an enumerable, use the &lt;code&gt;removeObject()&lt;/code&gt; method. This will only remove the object if it is present in the enumerable, otherwise this method has no effect.</source>
          <target state="translated">要从可枚举中删除对象，请使用 &lt;code&gt;removeObject()&lt;/code&gt; 方法。如果该对象存在于枚举中，则只会删除该对象，否则此方法无效。</target>
        </trans-unit>
        <trans-unit id="7d9de26d22f9d5fddcc6b008df4be9a302d40e54" translate="yes" xml:space="preserve">
          <source>To represent the children as IDs:</source>
          <target state="translated">要把孩子们表示成ID。</target>
        </trans-unit>
        <trans-unit id="96baf3260095c6e999a09f07d2439de39521a921" translate="yes" xml:space="preserve">
          <source>To represent the children relationship as a URL:</source>
          <target state="translated">用URL来表示子女关系。</target>
        </trans-unit>
        <trans-unit id="61b2e6985c9d49eab39fc6b2473ca71648f4f595" translate="yes" xml:space="preserve">
          <source>To run a subset of your tests by title use the &lt;code&gt;--filter&lt;/code&gt; option. Quickly test your current work &lt;code&gt;ember test --filter=&quot;dashboard&quot;&lt;/code&gt;, or only run a certain type of test &lt;code&gt;ember test --filter=&quot;integration&quot;&lt;/code&gt;. When using QUnit it is possible to exclude tests by adding an exclamation point to the beginning of the filter &lt;code&gt;ember test --filter=&quot;!acceptance&quot;&lt;/code&gt;.</source>
          <target state="translated">要按标题运行测试的子集，请使用 &lt;code&gt;--filter&lt;/code&gt; 选项。快速测试您当前的工作 &lt;code&gt;ember test --filter=&quot;dashboard&quot;&lt;/code&gt; ，或仅运行某种类型的测试 &lt;code&gt;ember test --filter=&quot;integration&quot;&lt;/code&gt; 。使用QUnit时，可以通过在过滤器 &lt;code&gt;ember test --filter=&quot;!acceptance&quot;&lt;/code&gt; 的开头添加感叹号来排除测试。</target>
        </trans-unit>
        <trans-unit id="1886972c9e7e9a4f558bbcd67fc568ef5594acf6" translate="yes" xml:space="preserve">
          <source>To see a list of libraries used in your application, click on the &lt;code&gt;Info&lt;/code&gt; menu. This view displays the libraries used, along with their version.</source>
          <target state="translated">若要查看您的应用程序中使用的库的列表，请单击&amp;ldquo; &lt;code&gt;Info&lt;/code&gt; 菜单。此视图显示所使用的库及其版本。</target>
        </trans-unit>
        <trans-unit id="bd3f95548b425d3595dc1e5a7a281f78a35f8f4c" translate="yes" xml:space="preserve">
          <source>To see how a template was rendered by Ember, click on the template in the View Tree. If you're using Chrome or Firefox, you'll be sent to the Elements panel with that DOM element selected.</source>
          <target state="translated">要查看一个模板是如何被Ember渲染的,点击视图树中的模板。如果你使用的是Chrome或Firefox,你会被发送到元素面板,并选择该DOM元素。</target>
        </trans-unit>
        <trans-unit id="e44b68c60f76b61bbdf60c921597a9cf8aad1469" translate="yes" xml:space="preserve">
          <source>To see the full list of computed property macros, have a look at &lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;the API documentation&lt;/a&gt;</source>
          <target state="translated">要查看计算的属性宏的完整列表，请查看&lt;a href=&quot;http://emberjs.com/api/classes/Ember.computed.html&quot;&gt;API文档&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10d1aa4aa9fe506d80116cddb13e609d02185dad" translate="yes" xml:space="preserve">
          <source>To set the component up to receive parameters this way, you need to set the &lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams&quot;&gt;&lt;code&gt;positionalParams&lt;/code&gt;&lt;/a&gt; attribute in your component class.</source>
          <target state="translated">要设置组件以这种方式接收参数，您需要在组件类中设置&lt;a href=&quot;http://emberjs.com/api/classes/Ember.Component.html#property_positionalParams&quot;&gt; &lt;code&gt;positionalParams&lt;/code&gt; &lt;/a&gt;属性。</target>
        </trans-unit>
        <trans-unit id="844e0103c86e1064d969400e55f8cbd4212c42ec" translate="yes" xml:space="preserve">
          <source>To set up embedded records, include the mixin when extending a serializer then define and configure embedded relationships.</source>
          <target state="translated">要设置嵌入式记录,请在扩展序列器时包含 mixin,然后定义和配置嵌入式关系。</target>
        </trans-unit>
        <trans-unit id="7823165518baac275622086e0a64947c8412aa36" translate="yes" xml:space="preserve">
          <source>To set up embedded records, include the mixin when extending a serializer, then define and configure embedded (model) relationships.</source>
          <target state="translated">要设置嵌入式记录,请在扩展序列器时加入 mixin,然后定义和配置嵌入式(模型)关系。</target>
        </trans-unit>
        <trans-unit id="04b6c1283408d9d9cea206ac24ad417174a73fb9" translate="yes" xml:space="preserve">
          <source>To show an error from the server related to the &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;content&lt;/code&gt; properties your adapter could return a promise that rejects with a &lt;code&gt;DS.InvalidError&lt;/code&gt; object that looks like this:</source>
          <target state="translated">为了显示来自服务器的与 &lt;code&gt;title&lt;/code&gt; 和 &lt;code&gt;content&lt;/code&gt; 属性有关的错误，您的适配器可以返回一个承诺，该承诺被 &lt;code&gt;DS.InvalidError&lt;/code&gt; 对象拒绝，如下所示：</target>
        </trans-unit>
        <trans-unit id="4d22fb46ffa697dab0c28d5708fe886c943fb273" translate="yes" xml:space="preserve">
          <source>To show something on every page, we can use the application template (which we edited earlier). Let's open it again (&lt;code&gt;/app/templates/application.hbs&lt;/code&gt;) and replace its contents with the following:</source>
          <target state="translated">为了在每个页面上显示内容，我们可以使用应用程序模板（我们先前已对其进行编辑）。让我们再次打开它（ &lt;code&gt;/app/templates/application.hbs&lt;/code&gt; ）并将其内容替换为以下内容：</target>
        </trans-unit>
        <trans-unit id="ce4f53072b200771a6bd1a485f9c6358e79dc97f" translate="yes" xml:space="preserve">
          <source>To show the basic setup of an Ember application, we'll walk through building an app for a property rental site called Super Rentals. We'll start with a homepage, an about page and a contact page.</source>
          <target state="translated">为了展示Ember应用的基本设置,我们将为一个名为Super Rentals的房产租赁网站搭建一个应用。我们将从一个主页、一个关于页面和一个联系页面开始。</target>
        </trans-unit>
        <trans-unit id="1c27517c0e2be0e963976ab64dbcdf375c7c6419" translate="yes" xml:space="preserve">
          <source>To specify that a parameter is mutable, when invoking the child &lt;code&gt;Component&lt;/code&gt;:</source>
          <target state="translated">在调用子 &lt;code&gt;Component&lt;/code&gt; 时指定一个可变参数：</target>
        </trans-unit>
        <trans-unit id="7ca79710a45c8aed09d51d44e598c3593126facf" translate="yes" xml:space="preserve">
          <source>To stub the location service in your test, create a local stub object that extends &lt;code&gt;Ember.Service&lt;/code&gt;, and register the stub as the service your tests need in the beforeEach function. In this case we initially force location to New York.</source>
          <target state="translated">要在测试中对定位服务进行存根，请创建扩展 &lt;code&gt;Ember.Service&lt;/code&gt; 的本地存根对象，然后在beforeEach函数中将存根注册为测试所需的服务。在这种情况下，我们最初将地点强制为纽约。</target>
        </trans-unit>
        <trans-unit id="83c3a034dda372c47a7e55506b94a499dd11f2f5" translate="yes" xml:space="preserve">
          <source>To successfully extract and serialize embedded records the model relationships must be setup correcty. See the &lt;a href=&quot;https://emberjs.com/guides/models/defining-models/#toc_defining-relationships&quot;&gt;defining relationships&lt;/a&gt; section of the &lt;strong&gt;Defining Models&lt;/strong&gt; guide page.</source>
          <target state="translated">为了成功提取和序列化嵌入式记录，必须正确设置模型关系。请参阅&amp;ldquo; &lt;strong&gt;定义模型&amp;rdquo;&lt;/strong&gt;指南页面的&amp;ldquo; &lt;a href=&quot;https://emberjs.com/guides/models/defining-models/#toc_defining-relationships&quot;&gt;定义关系&amp;rdquo;&lt;/a&gt;部分。&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6f5b7a5feba70d7bbd8e7ea599c7843b8360f83" translate="yes" xml:space="preserve">
          <source>To support &lt;code&gt;Ember.Array&lt;/code&gt; in your own class, you must override two primitives to use it: &lt;code&gt;length()&lt;/code&gt; and &lt;code&gt;objectAt()&lt;/code&gt;.</source>
          <target state="translated">为了在自己的类中支持 &lt;code&gt;Ember.Array&lt;/code&gt; ，必须重写两个原语才能使用它： &lt;code&gt;length()&lt;/code&gt; 和 &lt;code&gt;objectAt()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="284156262ec009225218096a34db99fe111eef94" translate="yes" xml:space="preserve">
          <source>To tell the application which rental we want to access, we need to replace the &lt;code&gt;show&lt;/code&gt; route path with the ID of the rental listing. We also want to simplify the URL so that it looks more like this: &lt;code&gt;localhost:4200/rentals/id-for-rental&lt;/code&gt;.</source>
          <target state="translated">为了告诉应用程序我们要访问哪个租赁，我们需要用租赁清单的ID 替换 &lt;code&gt;show&lt;/code&gt; 路线路径。我们还想简化URL，使其看起来像这样： &lt;code&gt;localhost:4200/rentals/id-for-rental&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb8bdc2ee12cbad5bed5fddb2deaabca492791bd" translate="yes" xml:space="preserve">
          <source>To test it, we create an instance of our class &lt;code&gt;SomeThing&lt;/code&gt; as defined above, call the &lt;code&gt;testMethod&lt;/code&gt; method and assert that the internal state is correct as a result of the method call.</source>
          <target state="translated">为了测试它，我们创建了上面定义的类 &lt;code&gt;SomeThing&lt;/code&gt; 的实例，调用 &lt;code&gt;testMethod&lt;/code&gt; 方法，并断言该方法调用的内部状态正确。</target>
        </trans-unit>
        <trans-unit id="5469506e055e796f8450fa42672d0e80ba255641" translate="yes" xml:space="preserve">
          <source>To trace a Promise, click on the &lt;code&gt;Trace&lt;/code&gt; button next to the label, which will send the Promise stack trace to the console.</source>
          <target state="translated">要跟踪Promise，请单击标签旁边的&amp;ldquo; &lt;code&gt;Trace&lt;/code&gt; 按钮，这会将Promise堆栈跟踪发送到控制台。</target>
        </trans-unit>
        <trans-unit id="81efb30747bfc7cc6e140692ae70701b93384146" translate="yes" xml:space="preserve">
          <source>To trigger this event:</source>
          <target state="translated">要触发该事件。</target>
        </trans-unit>
        <trans-unit id="48d77718e1db6d457932cf1dfee14241b04544bc" translate="yes" xml:space="preserve">
          <source>To use a tag other than &lt;code&gt;div&lt;/code&gt;, subclass &lt;code&gt;Ember.Component&lt;/code&gt; and assign it a &lt;code&gt;tagName&lt;/code&gt; property. This property can be any valid HTML5 tag name as a string.</source>
          <target state="translated">要使用除 &lt;code&gt;div&lt;/code&gt; 之外的其他标签，请为 &lt;code&gt;Ember.Component&lt;/code&gt; 子类化并为其分配 &lt;code&gt;tagName&lt;/code&gt; 属性。此属性可以是任何有效的HTML5标记名称（字符串）。</target>
        </trans-unit>
        <trans-unit id="3a10e85d71bb02f30ffa65660d976a2614878268" translate="yes" xml:space="preserve">
          <source>To use it in your application you will need to define a &lt;code&gt;serializer:application&lt;/code&gt; that extends the &lt;code&gt;JSONSerializer&lt;/code&gt;.</source>
          <target state="translated">要在您的应用程序中使用它，您需要定义一个扩展 &lt;code&gt;JSONSerializer&lt;/code&gt; 的 &lt;code&gt;serializer:application&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ac55d23e3de772ab700ee1e89d91af6e27bd4d1" translate="yes" xml:space="preserve">
          <source>To use it, pass the conditional value to the &lt;code&gt;if&lt;/code&gt; helper, using the block form to wrap the section of template you want to conditionally render. Like so:</source>
          <target state="translated">要使用它，请将条件值传递给 &lt;code&gt;if&lt;/code&gt; 助手，使用块形式包装要有条件呈现的模板部分。像这样：</target>
        </trans-unit>
        <trans-unit id="d4ed92f3e127472a3aa889d5c0b4781b9d9a78db" translate="yes" xml:space="preserve">
          <source>To use our new Ember Data Model object, we need to update the &lt;code&gt;model&lt;/code&gt; function we &lt;a href=&quot;../model-hook&quot;&gt;previously defined&lt;/a&gt; in our route handler. Delete the hard-coded JavaScript Array, and replace it with the following call to the &lt;a href=&quot;https://guides.emberjs.com/models/#toc_the-store-and-a-single-source-of-truth&quot;&gt;Ember Data Store service&lt;/a&gt;. The &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html&quot;&gt;store service&lt;/a&gt; is injected into all routes and components in Ember. It is the main interface you use to interact with Ember Data. In this case, call the &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt;&lt;code&gt;findAll&lt;/code&gt;&lt;/a&gt; function on the store and provide it with the name of your newly created rental model class.</source>
          <target state="translated">要使用新的Ember Data Model对象，我们需要更新&lt;a href=&quot;../model-hook&quot;&gt;先前&lt;/a&gt;在路由处理程序中定义的 &lt;code&gt;model&lt;/code&gt; 函数。删除硬编码的JavaScript数组，然后将其替换为对&lt;a href=&quot;https://guides.emberjs.com/models/#toc_the-store-and-a-single-source-of-truth&quot;&gt;Ember Data Store服务&lt;/a&gt;的以下调用。该&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html&quot;&gt;存储服务&lt;/a&gt;注入到灰烬所有路线和组件。它是您用于与Ember Data进行交互的主要界面。在这种情况下，请在商店上调用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt; &lt;code&gt;findAll&lt;/code&gt; &lt;/a&gt;函数，并为其提供新创建的租赁模型类的名称。</target>
        </trans-unit>
        <trans-unit id="a1bd3b7a10987c576e4b3e5ef0d1eb55854bd669" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;format-currency&lt;/code&gt; helper, you call it using curly braces in your template:</source>
          <target state="translated">要使用 &lt;code&gt;format-currency&lt;/code&gt; 帮助程序，请在模板中使用花括号将其调用：</target>
        </trans-unit>
        <trans-unit id="ff265ce4f656a5022fc0eb3e3b6a48bcf6f66b72" translate="yes" xml:space="preserve">
          <source>To use the &lt;code&gt;meta&lt;/code&gt; data outside of the &lt;code&gt;model&lt;/code&gt; hook, you need to return it:</source>
          <target state="translated">要在 &lt;code&gt;model&lt;/code&gt; 挂钩之外使用 &lt;code&gt;meta&lt;/code&gt; 数据，您需要将其返回：</target>
        </trans-unit>
        <trans-unit id="6c97e84d6c7f8dbcc0f576804dd9a172f8ea4443" translate="yes" xml:space="preserve">
          <source>To use the Inspector with the &lt;code&gt;file://&lt;/code&gt; protocol, visit &lt;code&gt;chrome://extensions&lt;/code&gt; in Chrome and check the &quot;Allow access to file URLs&quot; checkbox:</source>
          <target state="translated">要将Inspector与 &lt;code&gt;file://&lt;/code&gt; 协议一起使用，请访问 &lt;code&gt;chrome://extensions&lt;/code&gt; 并选中&amp;ldquo;允许访问文件URL&amp;rdquo;复选框：</target>
        </trans-unit>
        <trans-unit id="5b4b9b0f7d1081e76bebbad8d407bc61b550eeac" translate="yes" xml:space="preserve">
          <source>To use the block form, add a &lt;code&gt;#&lt;/code&gt; character to the beginning of the component name, then make sure to add a closing tag.</source>
          <target state="translated">要使用块形式，请在组件名称的开头添加 &lt;code&gt;#&lt;/code&gt; 字符，然后确保添加结束标记。</target>
        </trans-unit>
        <trans-unit id="2b34f2fce983b8f7e66aeba0dcd54687c1641fe4" translate="yes" xml:space="preserve">
          <source>To use url building, include the mixin when extending an adapter, and call &lt;code&gt;buildURL&lt;/code&gt; where needed. The default behaviour is designed for RESTAdapter.</source>
          <target state="translated">要使用url构建，请在扩展适配器时包括mixin，并在需要时调用 &lt;code&gt;buildURL&lt;/code&gt; 。默认行为是为RESTAdapter设计的。</target>
        </trans-unit>
        <trans-unit id="b06bc5d392cd3c4ae056891cbe7f6e4fea87f456" translate="yes" xml:space="preserve">
          <source>To utilize an &lt;code&gt;event&lt;/code&gt; object as a function parameter:</source>
          <target state="translated">要将 &lt;code&gt;event&lt;/code&gt; 对象用作功能参数：</target>
        </trans-unit>
        <trans-unit id="c8e7168cd76584331b5822b4bec75e170927b9af" translate="yes" xml:space="preserve">
          <source>To verify that your installation was successful, run:</source>
          <target state="translated">要验证您的安装是否成功,请运行。</target>
        </trans-unit>
        <trans-unit id="4c45291da01a2d21f8e4e871bb2b3b252689cfbd" translate="yes" xml:space="preserve">
          <source>To view the list of deprecations in an app, click on the &lt;code&gt;Deprecations&lt;/code&gt; menu.</source>
          <target state="translated">要查看应用程序中的弃用列表，请单击&amp;ldquo; &lt;code&gt;Deprecations&lt;/code&gt; 菜单。</target>
        </trans-unit>
        <trans-unit id="bc6b3697807941cf644d0c3ddef26bebd3c914d3" translate="yes" xml:space="preserve">
          <source>Together, the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; properties form a composite key for the identity map.</source>
          <target state="translated">在一起时， &lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;id&lt;/code&gt; 属性形成用于恒等映射的复合密钥。</target>
        </trans-unit>
        <trans-unit id="212af41073666530ad8bf245becce259a0964242" translate="yes" xml:space="preserve">
          <source>Toolbar</source>
          <target state="translated">Toolbar</target>
        </trans-unit>
        <trans-unit id="c201b38fdebbb9bb45b78e75ce5a39c7cd55dd3a" translate="yes" xml:space="preserve">
          <source>Total number of errors.</source>
          <target state="translated">错误总数:</target>
        </trans-unit>
        <trans-unit id="feca6ac147fe6946560ac4f3352301d8cb402e31" translate="yes" xml:space="preserve">
          <source>Touch events:</source>
          <target state="translated">触摸事件。</target>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="0cef4df4d340703594fc301669e90430e959441b" translate="yes" xml:space="preserve">
          <source>Transforms</source>
          <target state="translated">Transforms</target>
        </trans-unit>
        <trans-unit id="ee9a7401cfdf77cbfcfa276345967663f2ed541e" translate="yes" xml:space="preserve">
          <source>Transforms are not required. If you do not specify a transform name Ember Data will do no additional processing of the value.</source>
          <target state="translated">变换是不需要的。如果您没有指定变换名称,Ember Data将不对该值进行额外处理。</target>
        </trans-unit>
        <trans-unit id="4ead496f48fa5f6d2d96f52143b2d7c60b4140d3" translate="yes" xml:space="preserve">
          <source>Transition</source>
          <target state="translated">Transition</target>
        </trans-unit>
        <trans-unit id="3a38dd0e80493ddad0a8b9fc31e36c252b5d7258" translate="yes" xml:space="preserve">
          <source>Transition Plans</source>
          <target state="translated">过渡计划</target>
        </trans-unit>
        <trans-unit id="58d6d64ea8820023309981d51b607f7cb4f0da7e" translate="yes" xml:space="preserve">
          <source>Transition into another route while replacing the current URL, if possible. The route may be either a single route or route path:</source>
          <target state="translated">如果可能的话,在替换当前URL的同时,过渡到另一个途径。途径可以是单一途径,也可以是途径路径。</target>
        </trans-unit>
        <trans-unit id="bc1b0e501d34e708fc9cc731a2b3c2033acc8b08" translate="yes" xml:space="preserve">
          <source>Transition into another route while replacing the current URL, if possible. This will replace the current history entry instead of adding a new one. Beside that, it is identical to &lt;code&gt;transitionTo&lt;/code&gt; in all other respects. See 'transitionTo' for additional information regarding multiple models.</source>
          <target state="translated">如果可能，请在替换当前URL的同时过渡到另一条路由。这将替换当前的历史记录条目，而不是添加一个新的历史记录条目。除此之外，在所有其他方面都与 &lt;code&gt;transitionTo&lt;/code&gt; 相同。有关多个模型的更多信息，请参见&amp;ldquo; transitionTo&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3817345cd736105fd19da678c761e0ee0dc1d3d6" translate="yes" xml:space="preserve">
          <source>Transition into another route while replacing the current URL, if possible. This will replace the current history entry instead of adding a new one. Beside that, it is identical to &lt;code&gt;transitionToRoute&lt;/code&gt; in all other respects.</source>
          <target state="translated">如果可能，请在替换当前URL的同时过渡到另一条路由。这将替换当前的历史记录条目，而不是添加一个新的历史记录条目。除此之外，在所有其他方面都与 &lt;code&gt;transitionToRoute&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="f9fbe2b3f5c5cd05ac457782cac8426ace4067da" translate="yes" xml:space="preserve">
          <source>Transition the application into another route. The route may be either a single route or route path:</source>
          <target state="translated">将申请过渡到另一个途径。途径可以是单一途径,也可以是途径路径。</target>
        </trans-unit>
        <trans-unit id="09485928bf975e30a09112e580ae8b87390ef25d" translate="yes" xml:space="preserve">
          <source>Transition to a nested route</source>
          <target state="translated">向嵌套途径过渡</target>
        </trans-unit>
        <trans-unit id="2e8d1954c6e263dec2af78024bacfdd651c85cb4" translate="yes" xml:space="preserve">
          <source>Transitioning After the Model is Known</source>
          <target state="translated">模型已知后的过渡</target>
        </trans-unit>
        <trans-unit id="8eeb89d7f7b67faed7cc1a366a765420b6ef9289" translate="yes" xml:space="preserve">
          <source>Transitioning Before the Model is Known</source>
          <target state="translated">在模式未定之前的过渡</target>
        </trans-unit>
        <trans-unit id="b867dfc8d8f207f8f4c1fbcb4af23d1d9288622d" translate="yes" xml:space="preserve">
          <source>Transpile</source>
          <target state="translated">Transpile</target>
        </trans-unit>
        <trans-unit id="7be9134d32caa15cd71ab9ecd34dc5705a1ebaf0" translate="yes" xml:space="preserve">
          <source>Treating a function like a property is useful because they can work with bindings, just like any other property.</source>
          <target state="translated">像对待一个属性一样对待一个函数是很有用的,因为它们可以像任何其他属性一样与绑定一起工作。</target>
        </trans-unit>
        <trans-unit id="6b82a6a604ce871413a50334f0f8ba973ba15b4b" translate="yes" xml:space="preserve">
          <source>Trigger the function on the leading instead of the trailing edge of the wait interval. Defaults to false.</source>
          <target state="translated">在等待间隔的前缘而不是后缘触发函数。默认值为false。</target>
        </trans-unit>
        <trans-unit id="6bd621dbfc252949948e1fe15e02e3b79027c1b3" translate="yes" xml:space="preserve">
          <source>Trigger the function on the leading instead of the trailing edge of the wait interval. Defaults to true.</source>
          <target state="translated">在等待间隔的前缘而不是后缘触发函数。默认为true。</target>
        </trans-unit>
        <trans-unit id="a2759c77b24ab94668e8d1b8b501df3aeb5de2d0" translate="yes" xml:space="preserve">
          <source>Triggering Changes with Actions</source>
          <target state="translated">用动作触发变化</target>
        </trans-unit>
        <trans-unit id="05c0c58fbbc9f0cf9c0bb880afe8c0b49d825dcd" translate="yes" xml:space="preserve">
          <source>Triggers a fetch for the backing entity based on its &lt;code&gt;remoteType&lt;/code&gt; (see &lt;code&gt;remoteType&lt;/code&gt; definitions per reference type).</source>
          <target state="translated">根据其 &lt;code&gt;remoteType&lt;/code&gt; 触发对后备实体的获取（请参见每种引用类型的 &lt;code&gt;remoteType&lt;/code&gt; 定义）。</target>
        </trans-unit>
        <trans-unit id="1f7ec6fd588f66e0f74bc20fe04496819936427e" translate="yes" xml:space="preserve">
          <source>Triggers a named action on the &lt;code&gt;ActionHandler&lt;/code&gt;. Any parameters supplied after the &lt;code&gt;actionName&lt;/code&gt; string will be passed as arguments to the action target function.</source>
          <target state="translated">在 &lt;code&gt;ActionHandler&lt;/code&gt; 上触发命名动作。在 &lt;code&gt;actionName&lt;/code&gt; 字符串之后提供的任何参数都将作为参数传递给操作目标函数。</target>
        </trans-unit>
        <trans-unit id="caf81df837a77ea1a1597867231d2fd92f696d66" translate="yes" xml:space="preserve">
          <source>Triggers a named event for the object. Any additional arguments will be passed as parameters to the functions that are subscribed to the event.</source>
          <target state="translated">触发对象的命名事件。任何额外的参数将作为参数传递给订阅该事件的函数。</target>
        </trans-unit>
        <trans-unit id="b37a90c35c25e5423f4922a95a3be6ba46a762f1" translate="yes" xml:space="preserve">
          <source>Triggers a reload of the value in this relationship. If the remoteType is &lt;code&gt;&quot;link&quot;&lt;/code&gt; Ember Data will use the relationship link to reload the relationship. Otherwise it will reload the record by its id.</source>
          <target state="translated">触发此关系中的值的重新加载。如果remoteType是 &lt;code&gt;&quot;link&quot;&lt;/code&gt; Ember Data将使用关系链接来重新加载关系。否则，它将通过其ID重新加载记录。</target>
        </trans-unit>
        <trans-unit id="90ab4ebeae51b5fd454cba0691dd4c85d5df4631" translate="yes" xml:space="preserve">
          <source>Triggers the given DOM event on the element identified by the provided selector. Example:</source>
          <target state="translated">在所提供的选择器所识别的元素上触发给定的DOM事件。例子:</target>
        </trans-unit>
        <trans-unit id="b3c7ae9f5129772a579c1a689085b260b5f7a672" translate="yes" xml:space="preserve">
          <source>Triggers the given event, e.g. &lt;code&gt;blur&lt;/code&gt;, &lt;code&gt;dblclick&lt;/code&gt; on the element identified by the provided selector.</source>
          <target state="translated">触发给定事件，例如 &lt;code&gt;blur&lt;/code&gt; ， &lt;code&gt;dblclick&lt;/code&gt; 提供的选择器标识的元素。</target>
        </trans-unit>
        <trans-unit id="88ede053a62e801fe94c3f39f9283bc95d7953b4" translate="yes" xml:space="preserve">
          <source>Triggers the router level &lt;code&gt;didTransition&lt;/code&gt; hook.</source>
          <target state="translated">触发路由器级别的 &lt;code&gt;didTransition&lt;/code&gt; 挂钩。</target>
        </trans-unit>
        <trans-unit id="fd1c5125e97b8ef7401e3054a46c338003dc15f5" translate="yes" xml:space="preserve">
          <source>Triggers the router level &lt;code&gt;willTransition&lt;/code&gt; hook.</source>
          <target state="translated">触发路由器级别的 &lt;code&gt;willTransition&lt;/code&gt; 钩子。</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="3afd3167184bdb3baea996bf37e014fc89cdadc8" translate="yes" xml:space="preserve">
          <source>Turn on resolver resolution logging</source>
          <target state="translated">开启解析器解析记录</target>
        </trans-unit>
        <trans-unit id="171dc559b8c86e4b5f59e4b10965ed25793a055c" translate="yes" xml:space="preserve">
          <source>Tweaking the Default JSON</source>
          <target state="translated">调整默认的JSON</target>
        </trans-unit>
        <trans-unit id="59ae438323ad843da4c143e3db72fa92cf8f29ed" translate="yes" xml:space="preserve">
          <source>Typical Example:</source>
          <target state="translated">典型例子:</target>
        </trans-unit>
        <trans-unit id="1016393aae80d0b7e8ffa293c223fee10559838d" translate="yes" xml:space="preserve">
          <source>Typically, most models are loaded from and saved to a server that uses a database to store data. Usually you will send JSON representations of models back and forth to an HTTP server that you have written. However, Ember makes it easy to use other durable storage, such as saving to the user's hard disk with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB&lt;/a&gt;, or hosted storage solutions that let you avoid writing and hosting your own servers.</source>
          <target state="translated">通常，大多数模型是从使用数据库存储数据的服务器加载并保存到服务器的。通常，您会将模型的JSON表示来回发送到已编写的HTTP服务器。但是，Ember使使用其他持久性存储变得容易，例如使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB&lt;/a&gt;保存到用户的硬盘上，或者使您避免编写和托管自己的服务器的托管存储解决方案。</target>
        </trans-unit>
        <trans-unit id="d0f00d1a5e9139be33f8866b6b8f269ded268029" translate="yes" xml:space="preserve">
          <source>Typically, the &lt;code&gt;model&lt;/code&gt; hook should return an &lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;Ember Data&lt;/a&gt; record, but it can also return any &lt;a href=&quot;https://www.promisejs.org/&quot;&gt;promise&lt;/a&gt; object (Ember Data records are promises), or a plain JavaScript object or array. Ember will wait until the data finishes loading (until the promise is resolved) before rendering the template.</source>
          <target state="translated">通常， &lt;code&gt;model&lt;/code&gt; 挂钩应该返回&lt;a href=&quot;https://guides.emberjs.com/models/&quot;&gt;Ember Data&lt;/a&gt;记录，但是它也可以返回任何&lt;a href=&quot;https://www.promisejs.org/&quot;&gt;Promise&lt;/a&gt;对象（Ember Data记录是Promise）或纯JavaScript对象或数组。在呈现模板之前，Ember将等待数据完成加载（直到兑现承诺为止）。</target>
        </trans-unit>
        <trans-unit id="90f6a780943179d8b1aae6e03c66f89fa92e7702" translate="yes" xml:space="preserve">
          <source>Typically, the application object is the only global variable. All other classes in your app should be properties on the &lt;code&gt;Ember.Application&lt;/code&gt; instance, which highlights its first role: a global namespace.</source>
          <target state="translated">通常，应用程序对象是唯一的全局变量。应用程序中的所有其他类都应该是 &lt;code&gt;Ember.Application&lt;/code&gt; 实例的属性，该实例突出了它的第一个角色：全局名称空间。</target>
        </trans-unit>
        <trans-unit id="9a9cecfe60e474fbd88d57ddf86af2698a9750c5" translate="yes" xml:space="preserve">
          <source>Typos, missing words, and code samples with errors are all considered documentation bugs. If you spot one of them, or want to otherwise improve the existing guides, we are happy to help you help us!</source>
          <target state="translated">错别字、缺字和有错误的代码样本都被认为是文档错误。如果你发现了其中的一个问题,或者想以其他方式改进现有的指南,我们很乐意帮助你,帮助我们</target>
        </trans-unit>
        <trans-unit id="9d57875196c613785a1eee010c55223a0f1aa821" translate="yes" xml:space="preserve">
          <source>UI</source>
          <target state="translated">UI</target>
        </trans-unit>
        <trans-unit id="56ec268e73f8f2ff103ef53a9916b081ba7f3172" translate="yes" xml:space="preserve">
          <source>UI stands for User Interface and is essentially what the user sees and interacts with on a device. In terms of the web, the UI is generally composed of a series of pages containing visual elements such as buttons and icons that a user can interact with to perform a specific function.</source>
          <target state="translated">UI是用户界面的缩写,本质上是用户在设备上看到的和与之交互的东西。就网络而言,用户界面一般由一系列包含按钮和图标等视觉元素的页面组成,用户可以通过与这些元素互动来实现特定功能。</target>
        </trans-unit>
        <trans-unit id="25ba44ec3b391ba4ce5fbbd2979635e254775e7d" translate="yes" xml:space="preserve">
          <source>UNKNOWN</source>
          <target state="translated">UNKNOWN</target>
        </trans-unit>
        <trans-unit id="0e2d9b0777a485c1276de0803c12a7d76fbc5c39" translate="yes" xml:space="preserve">
          <source>URL</source>
          <target state="translated">URL</target>
        </trans-unit>
        <trans-unit id="2a78301c31a5cdf1806010201d9c88a248b6e24f" translate="yes" xml:space="preserve">
          <source>URL Conventions</source>
          <target state="translated">URL约定</target>
        </trans-unit>
        <trans-unit id="1d0b24ed134011a2aa230bdbb865f186a7f4281a" translate="yes" xml:space="preserve">
          <source>Unbound:</source>
          <target state="translated">Unbound:</target>
        </trans-unit>
        <trans-unit id="adcff83915dac1afac720f25d1f1be8c41ff4bd5" translate="yes" xml:space="preserve">
          <source>Unconsumed Computed Properties Do Not Trigger Observers</source>
          <target state="translated">未消耗的计算属性不会触发观察者。</target>
        </trans-unit>
        <trans-unit id="b2cf9e638539bf147e1afc2be86aae23bea12dca" translate="yes" xml:space="preserve">
          <source>Unfortunately we don't have control over the Firefox review process, so if you need the latest Inspector version, download and install it manually from &lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;GitHub&lt;/a&gt;.</source>
          <target state="translated">不幸的是，我们无法控制Firefox的审核过程，因此，如果您需要最新的Inspector版本，请从&lt;a href=&quot;https://github.com/emberjs/ember-inspector&quot;&gt;GitHub&lt;/a&gt;手动下载并安装它。</target>
        </trans-unit>
        <trans-unit id="2cac43b24a13e42d8cce322b40984d5b87556749" translate="yes" xml:space="preserve">
          <source>Unfortunately, the app will now make two separate requests for the same information. Not only is the redundant data fetching costly in terms of wasted bandwidth and affecting the perceived speed of your app, it's easy for the two values to get out-of-sync. You yourself have probably used a web application where the list of items gets out of sync with the counter in a toolbar, leading to a frustrating and inconsistent experience.</source>
          <target state="translated">不幸的是,应用程序现在会对同一信息发出两个独立的请求。冗余的数据获取不仅在浪费带宽和影响应用程序的感知速度方面代价高昂,而且很容易使两个值不同步。你自己可能使用过一个web应用,其中的项目列表与工具栏中的计数器不同步,导致令人沮丧和不一致的体验。</target>
        </trans-unit>
        <trans-unit id="435a0121b4b4da7be6794568d5ff9daf201cc903" translate="yes" xml:space="preserve">
          <source>Unit Testing Basics</source>
          <target state="translated">单元测试基础知识</target>
        </trans-unit>
        <trans-unit id="55319d93decd49524c6577ad2944aab8499b8def" translate="yes" xml:space="preserve">
          <source>Unit Tests</source>
          <target state="translated">单元测试</target>
        </trans-unit>
        <trans-unit id="93ff14f84e553511a6d925afc2fd312d4a69fdf2" translate="yes" xml:space="preserve">
          <source>Unit testing a Service</source>
          <target state="translated">单元测试服务</target>
        </trans-unit>
        <trans-unit id="e953abafc0e9309d7c5083375c031969ba683421" translate="yes" xml:space="preserve">
          <source>Unit testing controllers is very simple using the unit test helper which is part of the ember-qunit framework.</source>
          <target state="translated">使用单元测试助手可以非常简单地对控制器进行单元测试,它是ember-qunit框架的一部分。</target>
        </trans-unit>
        <trans-unit id="4f2e8408bfaa4887c87ced8532981f549a2f0ac1" translate="yes" xml:space="preserve">
          <source>Unit tests are generally used to test a small piece of code and ensure that it is doing what was intended. Unlike acceptance tests, they are narrow in scope and do not require the Ember application to be running.</source>
          <target state="translated">单元测试通常用于测试一小段代码,并确保它在做预期的事情。与验收测试不同的是,单元测试的范围很窄,不需要Ember应用程序运行。</target>
        </trans-unit>
        <trans-unit id="cb68db7729e7a12b83a5c5895b39431e1671922d" translate="yes" xml:space="preserve">
          <source>Unit tests are used to test isolated chunks of functionality, or &quot;units&quot;. They can be written against any isolated application logic.</source>
          <target state="translated">单元测试用于测试孤立的功能块,或 &quot;单元&quot;。它们可以针对任何孤立的应用逻辑来编写。</target>
        </trans-unit>
        <trans-unit id="17909e26819874f7405577d82491e99531963e55" translate="yes" xml:space="preserve">
          <source>Unit tests use the function called &lt;code&gt;this.subject&lt;/code&gt; to instantiate the object to test, and lets the test pass in initial values as arguments. In our case we are passing in our fake map utility object in the first test, and passing a cache object for the second test.</source>
          <target state="translated">单元测试使用名为 &lt;code&gt;this.subject&lt;/code&gt; 的函数实例化要测试的对象，并让测试将初始值作为参数传递。在本例中，我们在第一个测试中传递了伪造的地图实用程序对象，并在第二个测试中传递了一个缓存对象。</target>
        </trans-unit>
        <trans-unit id="699a683faaa9485bee8084684b0d1eae07aa0ba1" translate="yes" xml:space="preserve">
          <source>Unknown Properties</source>
          <target state="translated">未知属性</target>
        </trans-unit>
        <trans-unit id="e645e94764f04f4c7f3e561913a7d9a2e676183b" translate="yes" xml:space="preserve">
          <source>Unless you have specific needs for &lt;code&gt;CoreView&lt;/code&gt;, you will use &lt;code&gt;Ember.Component&lt;/code&gt; in your applications.</source>
          <target state="translated">除非对 &lt;code&gt;CoreView&lt;/code&gt; 有特定需求，否则将在应用程序中使用 &lt;code&gt;Ember.Component&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1dc9a4536b97fe5b5d22858d040db7f2f7b9e35" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;https://guides.emberjs.com/components/defining-a-component/&quot;&gt;components&lt;/a&gt;, which require a dash in the name to follow the Custom Element spec, helper names can be single or multi-word. If your helper's name is multi-word, it should be dasherized as the examples on this page.</source>
          <target state="translated">与&lt;a href=&quot;https://guides.emberjs.com/components/defining-a-component/&quot;&gt;components&lt;/a&gt;不同，components要求名称中必须包含破折号才能遵循&amp;ldquo;自定义元素&amp;rdquo;规范，而helper名称可以是单个或多个单词。如果您的帮助者的名字是多词，则应将其反斜线作为此页面上的示例。</target>
        </trans-unit>
        <trans-unit id="0ba71c17b8be5769afabb31b692ab4883feaae70" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Ember.Enumerable,&lt;/code&gt; this mixin defines methods specifically for collections that provide index-ordered access to their contents. When you are designing code that needs to accept any kind of Array-like object, you should use these methods instead of Array primitives because these will properly notify observers of changes to the array.</source>
          <target state="translated">与 &lt;code&gt;Ember.Enumerable,&lt;/code&gt; 不同，此mixin定义了专门用于集合的方法，这些方法提供对其内容进行索引排序的访问。在设计需要接受任何类型的类似于Array的对象的代码时，应使用这些方法而不是Array原语，因为这些方法可以正确地将数组更改通知给观察者。</target>
        </trans-unit>
        <trans-unit id="c2346a7015c8d7f54cbe428fcb6f3328b3d12eff" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;Ember.typeOf&lt;/code&gt; this method returns true even if the passed object is not formally an array but appears to be array-like (i.e. implements &lt;code&gt;Ember.Array&lt;/code&gt;)</source>
          <target state="translated">与 &lt;code&gt;Ember.typeOf&lt;/code&gt; 不同，此方法即使传递的对象不是形式上为数组而是看起来像数组（即实现 &lt;code&gt;Ember.Array&lt;/code&gt; ），也返回true。</target>
        </trans-unit>
        <trans-unit id="48f1b9ff4d1a0458244d8e86c4b05ccfa10f68f1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;RSVP.all&lt;/code&gt; or &lt;code&gt;RSVP.hash&lt;/code&gt;, which implement a fail-fast method, but like &lt;code&gt;RSVP.allSettled&lt;/code&gt;, &lt;code&gt;hashSettled&lt;/code&gt; waits until all the constituent promises have returned and then shows you all the results with their states and values/reasons. This is useful if you want to handle multiple promises' failure states together as a set.</source>
          <target state="translated">与实现故障快速方法的 &lt;code&gt;RSVP.all&lt;/code&gt; 或 &lt;code&gt;RSVP.hash&lt;/code&gt; 不同，但与 &lt;code&gt;RSVP.allSettled&lt;/code&gt; 一样， &lt;code&gt;hashSettled&lt;/code&gt; 会等到所有组成的承诺都返回后，再向您显示所有结果及其状态和值/原因。如果您要一起处理多个promise的失败状态，这将很有用。</target>
        </trans-unit>
        <trans-unit id="9bee6d6d59812dc43ec15a1949e4a9aea2e5d664" translate="yes" xml:space="preserve">
          <source>Unlike callbacks, promises are great composable primitives.</source>
          <target state="translated">与回调不同,承诺是很好的可组合基元。</target>
        </trans-unit>
        <trans-unit id="e43318987c768f8fb9f16d1a9218b08aab2bb57f" translate="yes" xml:space="preserve">
          <source>Unlike most other frameworks that include some sort of binding implementation, bindings in Ember.js can be used with any object. That said, bindings are most often used within the Ember framework itself, and for most problems Ember app developers face, computed properties are the appropriate solution.</source>
          <target state="translated">与大多数其他框架包含某种绑定实现不同,Ember.js中的绑定可以用于任何对象。也就是说,绑定最常被用于Ember框架本身,对于Ember应用开发者面临的大多数问题,计算属性是合适的解决方案。</target>
        </trans-unit>
        <trans-unit id="17e1fed215e92f510045ef5c63c8abbeeddb605f" translate="yes" xml:space="preserve">
          <source>Unlike the other route handlers we've made so far, the &lt;code&gt;index&lt;/code&gt; route is special: it does NOT require an entry in the router's mapping. We'll learn more about why the entry isn't required later on when we look at &lt;a href=&quot;../subroutes&quot;&gt;nested routes&lt;/a&gt; in Ember.</source>
          <target state="translated">与到目前为止我们做过的其他路由处理程序不同， &lt;code&gt;index&lt;/code&gt; 路由是特殊的：它不需要在路由器映射中输入任何内容。我们以后将在Ember中查看&lt;a href=&quot;../subroutes&quot;&gt;嵌套路线&lt;/a&gt;时，将了解有关为何不需要该条目的更多信息。</target>
        </trans-unit>
        <trans-unit id="0a31d24114be4656ec50e863002c0179157848ce" translate="yes" xml:space="preserve">
          <source>Unloads the record from the store. This will cause the record to be destroyed and freed up for garbage collection.</source>
          <target state="translated">从存储中卸载记录。这将导致该记录被销毁,并腾出空间用于收集垃圾。</target>
        </trans-unit>
        <trans-unit id="43070cef7aeb427607d411dd1ba9004d00927bf7" translate="yes" xml:space="preserve">
          <source>Unregister a factory.</source>
          <target state="translated">解除工厂注册。</target>
        </trans-unit>
        <trans-unit id="4f9491f2acb9ac489a58e64c4620334de6474d19" translate="yes" xml:space="preserve">
          <source>Unshift an object to start of array. Works just like &lt;code&gt;unshift()&lt;/code&gt; but it is KVO-compliant.</source>
          <target state="translated">取消移动对象以开始数组。就像 &lt;code&gt;unshift()&lt;/code&gt; 一样工作，但是它符合KVO。</target>
        </trans-unit>
        <trans-unit id="164f698a644916b960657c8f2ff6769690a513d0" translate="yes" xml:space="preserve">
          <source>Up to this point, we've generated four top level routes.</source>
          <target state="translated">至此,我们已经生成了四条顶级路线。</target>
        </trans-unit>
        <trans-unit id="fb91e24fa52d8d2b32937bf04d843f730319a902" translate="yes" xml:space="preserve">
          <source>Update</source>
          <target state="translated">Update</target>
        </trans-unit>
        <trans-unit id="1cfa49d59018eef26ef97632e877b7882570010a" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;postRecord.save()&lt;/code&gt;</source>
          <target state="translated">更新 &lt;code&gt;postRecord.save()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac2e17800a0ab0d112375860107fae65bea51067" translate="yes" xml:space="preserve">
          <source>Update URL with &lt;code&gt;replaceState&lt;/code&gt; instead</source>
          <target state="translated">改为使用 &lt;code&gt;replaceState&lt;/code&gt; 更新URL</target>
        </trans-unit>
        <trans-unit id="f40768a6e2c45ddd1db6d9752d413302ad8b03c7" translate="yes" xml:space="preserve">
          <source>Update the content of the integration test to the following to fix it:</source>
          <target state="translated">将集成测试的内容更新为以下内容进行修正。</target>
        </trans-unit>
        <trans-unit id="af48d19b99946eb85b1c250ae52baaf10a9733dd" translate="yes" xml:space="preserve">
          <source>Updates to the property of an attribute binding will result in automatic update of the HTML attribute in the component's rendered HTML representation. &lt;code&gt;attributeBindings&lt;/code&gt; is a concatenated property. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt; documentation for more information about concatenated properties.</source>
          <target state="translated">属性绑定属性的更新将导致组件呈现的HTML表示中的HTML属性自动更新。 &lt;code&gt;attributeBindings&lt;/code&gt; 是一个串联的属性。有关串联属性的更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="85553080c5bd51708efff543f11a80f132dd3bad" translate="yes" xml:space="preserve">
          <source>Updates to the value of a class name binding will result in automatic update of the HTML &lt;code&gt;class&lt;/code&gt; attribute in the component's rendered HTML representation. If the value becomes &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; the class name will be removed. Both &lt;code&gt;classNames&lt;/code&gt; and &lt;code&gt;classNameBindings&lt;/code&gt; are concatenated properties. See &lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt; documentation for more information about concatenated properties.</source>
          <target state="translated">更新类名称绑定的值将导致组件的呈现HTML表示形式中的HTML &lt;code&gt;class&lt;/code&gt; 属性自动更新。如果该值变为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; ，则将删除类名。这两个 &lt;code&gt;classNames&lt;/code&gt; 和 &lt;code&gt;classNameBindings&lt;/code&gt; 是级联特性。有关串联属性的更多信息，请参见&lt;a href=&quot;https://emberjs.com/api/classes/Ember.Object.html&quot;&gt;Ember.Object&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="1a89fee8955539e6cbec654a32c63f6e50462e63" translate="yes" xml:space="preserve">
          <source>Updating Existing Records</source>
          <target state="translated">更新现有记录</target>
        </trans-unit>
        <trans-unit id="e5b09343b2238bb74ea50d37eff3231b6eb0978f" translate="yes" xml:space="preserve">
          <source>Updating Records</source>
          <target state="translated">更新记录</target>
        </trans-unit>
        <trans-unit id="a3c251798976c1a4eaea1b25759d885d99218eb3" translate="yes" xml:space="preserve">
          <source>Updating the Model Hook</source>
          <target state="translated">更新模型挂钩</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="9629fc5be7eebf84f66a1a4fe14d7eee29fbc498" translate="yes" xml:space="preserve">
          <source>Usage Example:</source>
          <target state="translated">用例。</target>
        </trans-unit>
        <trans-unit id="5babfd7f28c97261be5d747a98ff927af4a35448" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;ds.jsonserializer&quot;&gt;DS.JSONSerializer&lt;/a&gt; to get the JSON representation of a record.</source>
          <target state="translated">使用&lt;a href=&quot;ds.jsonserializer&quot;&gt;DS.JSONSerializer&lt;/a&gt;获取记录的JSON表示形式。</target>
        </trans-unit>
        <trans-unit id="79babe4a58b3c5377a30d47b99f3a166cc374c1c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt;&lt;code&gt;store.findAll()&lt;/code&gt;&lt;/a&gt; to retrieve all of the records for a given type:</source>
          <target state="translated">使用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findAll&quot;&gt; &lt;code&gt;store.findAll()&lt;/code&gt; &lt;/a&gt;检索给定类型的所有记录：</target>
        </trans-unit>
        <trans-unit id="1eeddfe464eb2a59d11d65139e6a152e23204fe3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt;&lt;code&gt;store.findRecord()&lt;/code&gt;&lt;/a&gt; to retrieve a record by its type and ID. This will return a promise that fulfills with the requested record:</source>
          <target state="translated">使用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_findRecord&quot;&gt; &lt;code&gt;store.findRecord()&lt;/code&gt; &lt;/a&gt;来按记录的类型和ID检索记录。这将返回一个满足要求记录的承诺：</target>
        </trans-unit>
        <trans-unit id="cdebe1f775b156e00e0b7192c360b92d672f22ea" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekAll&quot;&gt;&lt;code&gt;store.peekAll()&lt;/code&gt;&lt;/a&gt; to retrieve all of the records for a given type that are already loaded into the store, without making a network request:</source>
          <target state="translated">使用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekAll&quot;&gt; &lt;code&gt;store.peekAll()&lt;/code&gt; &lt;/a&gt;检索给定类型的所有记录，这些记录已经加载到商店中，而无需发出网络请求：</target>
        </trans-unit>
        <trans-unit id="b6be3a24df2cc3843f7fe4f0b083c1f949820c19" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekRecord&quot;&gt;&lt;code&gt;store.peekRecord()&lt;/code&gt;&lt;/a&gt; to retrieve a record by its type and ID, without making a network request. This will return the record only if it is already present in the store:</source>
          <target state="translated">使用&lt;a href=&quot;http://emberjs.com/api/data/classes/DS.Store.html#method_peekRecord&quot;&gt; &lt;code&gt;store.peekRecord()&lt;/code&gt; &lt;/a&gt;可以按记录的类型和ID检索记录，而无需发出网络请求。仅当存储中已存在该记录时，才返回该记录：</target>
        </trans-unit>
        <trans-unit id="00e000124add0ce9217af1c895a1ba1b021e403c" translate="yes" xml:space="preserve">
          <source>Use a custom (type) serializer for the post model to configure embedded author</source>
          <target state="translated">使用自定义(类型)序列器为职位模型配置嵌入式作者</target>
        </trans-unit>
        <trans-unit id="2822b36d55ca0f281fdd5caf6ce712c478b4c480" translate="yes" xml:space="preserve">
          <source>Use a custom (type) serializer for the post model to configure embedded comments</source>
          <target state="translated">为帖子模型使用自定义(类型)序列器来配置嵌入式注释</target>
        </trans-unit>
        <trans-unit id="18a2f23148493346b4dfeba036baa75787a6bab3" translate="yes" xml:space="preserve">
          <source>Use of Observable Methods and Properties</source>
          <target state="translated">可观测方法和属性的使用</target>
        </trans-unit>
        <trans-unit id="97fdbc8ed53b640b746052deb57d44ffe6c429d2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;{{hash}}&lt;/code&gt; helper to create a hash to pass as an option to your components. This is specially useful for contextual components where you can just yield a hash:</source>
          <target state="translated">使用 &lt;code&gt;{{hash}}&lt;/code&gt; 助手来创建一个哈希，以作为选项传递给您的组件。这对于仅产生哈希值的上下文组件特别有用：</target>
        </trans-unit>
        <trans-unit id="8e7ccd90e8cfeff420ef08923c36a50e99640cd2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;{{with}}&lt;/code&gt; helper when you want to alias a property to a new name. This is helpful for semantic clarity as it allows you to retain default scope or to reference a property from another &lt;code&gt;{{with}}&lt;/code&gt; block.</source>
          <target state="translated">要将属性别名为新名称时，请使用 &lt;code&gt;{{with}}&lt;/code&gt; 帮助器。这有助于使语义清晰，因为它允许您保留默认范围或引用另一个 &lt;code&gt;{{with}}&lt;/code&gt; 块中的属性。</target>
        </trans-unit>
        <trans-unit id="b101cb1e03e8a43550840a8c7fd20af20f00b55b" translate="yes" xml:space="preserve">
          <source>Use the tips described in &lt;a href=&quot;../object-inspector&quot;&gt;Object Inspector&lt;/a&gt; to inspect models and controllers. See below for templates and components.</source>
          <target state="translated">使用&lt;a href=&quot;../object-inspector&quot;&gt;对象检查器中&lt;/a&gt;描述的技巧检查模型和控制器。请参阅下面的模板和组件。</target>
        </trans-unit>
        <trans-unit id="7830b0609b9584de5bbebc9de314d759ef55371b" translate="yes" xml:space="preserve">
          <source>Use this instead of the built-in &lt;code&gt;typeof&lt;/code&gt; to get the type of an item. It will return the same result across all browsers and includes a bit more detail. Here is what will be returned:</source>
          <target state="translated">使用它而不是内置的 &lt;code&gt;typeof&lt;/code&gt; 来获取项目的类型。它将在所有浏览器中返回相同的结果，并包含更多细节。这是将返回的内容：</target>
        </trans-unit>
        <trans-unit id="c645581e547e78cc873442313071c5e0586bcb0f" translate="yes" xml:space="preserve">
          <source>Use this to defer readiness until some condition is true.</source>
          <target state="translated">用这个来推迟准备时间,直到某个条件为真。</target>
        </trans-unit>
        <trans-unit id="306cbcab821af23dfb473fbf6d987c353799e01a" translate="yes" xml:space="preserve">
          <source>Use with Ember.Component</source>
          <target state="translated">与Ember.Component一起使用</target>
        </trans-unit>
        <trans-unit id="542d6ad86b7eee775bf26a301d712477fe03a84b" translate="yes" xml:space="preserve">
          <source>Used this way, the &lt;code&gt;{{action}}&lt;/code&gt; helper provides a useful shortcut for registering an HTML element in a template for a single DOM event and forwarding that interaction to the template's context (controller or component). If the context of a template is a controller, actions used this way will bubble to routes when the controller does not implement the specified action. Once an action hits a route, it will bubble through the route hierarchy.</source>
          <target state="translated">&lt;code&gt;{{action}}&lt;/code&gt; 帮助器以这种方式使用，为在单个DOM事件中的模板中注册HTML元素并将该交互转发到模板的上下文（控制器或组件）提供了有用的快捷方式。如果模板的上下文是控制器，则当控制器未执行指定的操作时，以这种方式使用的操作将冒泡到路由。动作触及路线后，它将在路线层次结构中冒泡。</target>
        </trans-unit>
        <trans-unit id="4c7c0d10b10d1e9407fe7fd091a42e7426902b37" translate="yes" xml:space="preserve">
          <source>Used to allow ember-testing to communicate with a specific testing framework.</source>
          <target state="translated">用于允许微光测试与特定的测试框架进行通信。</target>
        </trans-unit>
        <trans-unit id="2522c403a71c0acbdd066953587aaea739ffa591" translate="yes" xml:space="preserve">
          <source>Used to determine when this &lt;code&gt;LinkComponent&lt;/code&gt; is active.</source>
          <target state="translated">用于确定此 &lt;code&gt;LinkComponent&lt;/code&gt; 何时处于活动状态。</target>
        </trans-unit>
        <trans-unit id="e06eb9fc01574fd7225f291066780d472903fee4" translate="yes" xml:space="preserve">
          <source>Used to get the latest version of all of the records in this array from the adapter.</source>
          <target state="translated">用于从适配器获取该数组中所有记录的最新版本。</target>
        </trans-unit>
        <trans-unit id="b625a63d0e499059d2ca14c82e5df7615a107612" translate="yes" xml:space="preserve">
          <source>Used to register callbacks to be fired whenever &lt;code&gt;App.injectTestHelpers&lt;/code&gt; is called.</source>
          <target state="translated">用于注册每当 &lt;code&gt;App.injectTestHelpers&lt;/code&gt; 时将触发的回调。</target>
        </trans-unit>
        <trans-unit id="cb7f2badb8e4d94f6c7118903ad2f323f4cc77e3" translate="yes" xml:space="preserve">
          <source>User/session authentication.</source>
          <target state="translated">用户/会话认证。</target>
        </trans-unit>
        <trans-unit id="16bc4c4d7d89c3b988308786cd8619cfd3a339a8" translate="yes" xml:space="preserve">
          <source>Uses:</source>
          <target state="translated">Uses:</target>
        </trans-unit>
        <trans-unit id="9b8970c914983383f99e53ae30acfba6c7f27456" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;HashLocation&lt;/code&gt; results in URLs with a &lt;code&gt;#&lt;/code&gt; (hash sign) separating the server side URL portion of the URL from the portion that is used by Ember.</source>
          <target state="translated">使用 &lt;code&gt;HashLocation&lt;/code&gt; 会生成带有 &lt;code&gt;#&lt;/code&gt; （哈希符号）的URL，该URL 会将 URL 的服务器端URL部分与Ember使用的部分分开。</target>
        </trans-unit>
        <trans-unit id="2e374626d7a0702cc9f9268ad2fdcfaaf4d3ebb8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;HistoryLocation&lt;/code&gt; results in URLs that are indistinguishable from a standard URL. This relies upon the browser's &lt;code&gt;history&lt;/code&gt; API.</source>
          <target state="translated">使用 &lt;code&gt;HistoryLocation&lt;/code&gt; 会产生与标准URL不可区分的URL。这取决于浏览器的 &lt;code&gt;history&lt;/code&gt; API。</target>
        </trans-unit>
        <trans-unit id="b274154b8cd2e420cefe87ab03d519a29e9efd6b" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;NoneLocation&lt;/code&gt; causes Ember to not store the applications URL state in the actual URL. This is generally used for testing purposes, and is one of the changes made when calling &lt;code&gt;App.setupForTesting()&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;NoneLocation&lt;/code&gt; 使Ember不在实际URL中存储应用程序URL状态。这通常用于测试目的，并且是在调用 &lt;code&gt;App.setupForTesting()&lt;/code&gt; 时所做的更改之一。</target>
        </trans-unit>
        <trans-unit id="60d8d1f0299627d742dc7cc43fee81d677009b4e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;denodeify&lt;/code&gt; makes it easier to compose asynchronous operations instead of using callbacks. For example, instead of:</source>
          <target state="translated">使用 &lt;code&gt;denodeify&lt;/code&gt; 可以更轻松地组成异步操作，而不是使用回调。例如，代替：</target>
        </trans-unit>
        <trans-unit id="f5822b7870a8d5523c5615715941fb03bf4b2289" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;set()&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;set()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8109d0339990f1783cd0634fdca5b574393894cb" translate="yes" xml:space="preserve">
          <source>Using Block Params</source>
          <target state="translated">使用块参数</target>
        </trans-unit>
        <trans-unit id="74f837326f24cf10cc05302b64d55360b8652855" translate="yes" xml:space="preserve">
          <source>Using BuildURLMixin</source>
          <target state="translated">使用BuildURLMixin</target>
        </trans-unit>
        <trans-unit id="e8517af265fabf196c410cce740af7a7b6bec59d" translate="yes" xml:space="preserve">
          <source>Using Embedded Records</source>
          <target state="translated">使用嵌入式记录</target>
        </trans-unit>
        <trans-unit id="165fcfc43ecaff89929b038e0b256dd0b70e6794" translate="yes" xml:space="preserve">
          <source>Using Ember Data</source>
          <target state="translated">使用Ember数据</target>
        </trans-unit>
        <trans-unit id="fb2881f07ad66266580a01fb816b0dce10a1a576" translate="yes" xml:space="preserve">
          <source>Using Ember Enumeration with Other Libraries</source>
          <target state="translated">与其他库一起使用Ember Enumeration。</target>
        </trans-unit>
        <trans-unit id="32288de7b5b629b3ca02d918cfe820a4ecaf3608" translate="yes" xml:space="preserve">
          <source>Using Ember helpers</source>
          <target state="translated">使用Ember助手</target>
        </trans-unit>
        <trans-unit id="ca7a4602a2a74d46f96031f6b4efa287c3f5c2c8" translate="yes" xml:space="preserve">
          <source>Using a helper to get a property dynamically</source>
          <target state="translated">使用帮助程序动态获取属性</target>
        </trans-unit>
        <trans-unit id="9059eac12c500c79a5a3d1134418440b0c07e282" translate="yes" xml:space="preserve">
          <source>Using a string instead of an array allows for an arbitrary number of parameters:</source>
          <target state="translated">使用字符串而不是数组允许任意数量的参数。</target>
        </trans-unit>
        <trans-unit id="5e7f18de2a8e24c22728aa51e8b3f677f7daf728" translate="yes" xml:space="preserve">
          <source>Using an Application Instance Within an Instance Initializer</source>
          <target state="translated">在实例初始化器中使用应用程序实例</target>
        </trans-unit>
        <trans-unit id="34b9681fe55a7ecfb5a0c7ea34a9b1845ae5fc03" translate="yes" xml:space="preserve">
          <source>Using an identity map is important because it ensures that changes you make in one part of your UI are propagated to other parts of the UI. It also means that you don't have to manually keep records in sync&amp;mdash;you can ask for a record by ID and not have to worry about whether other parts of your application have already asked for and loaded it.</source>
          <target state="translated">使用身份映射非常重要，因为它可以确保将您在UI的一部分中所做的更改传播到UI的其他部分。这也意味着您不必手动保持记录同步-您可以按ID要求记录，而不必担心应用程序的其他部分是否已经请求并加载了它。</target>
        </trans-unit>
        <trans-unit id="6fad29eae11c2c19b66190933f6cc057fc210083" translate="yes" xml:space="preserve">
          <source>Using jQuery to simulate user click events might lead to unexpected test results as the action can potentially be called twice.</source>
          <target state="translated">使用jQuery来模拟用户点击事件可能会导致意外的测试结果,因为该动作可能会被调用两次。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
