<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="lua">
    <body>
      <group id="lua">
        <trans-unit id="aa39944ec03b1ec2d3455e9418607f7822bf72a3" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, its first upvalue is set to the value of the global environment stored at index &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; in the registry (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;). When loading main chunks, this upvalue will be the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">如果生成的函数具有升值，则其第一个升值将设置为存储在注册表中的索引 &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; 的全局环境的值（请参见&lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;）。加载主要块时，此升值将是 &lt;code&gt;_ENV&lt;/code&gt; 变量（请参见&lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;）。其他升值使用&lt;b&gt;nil&lt;/b&gt;初始化。</target>
        </trans-unit>
        <trans-unit id="afde979ca5fc178b1fdd97cd1a0eb2a3d73cbc9c" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, its first upvalue is set to the value of the global environment stored at index &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; in the registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). When loading main chunks, this upvalue will be the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">如果生成的函数具有升值，则其第一个升值将设置为存储在注册表中的索引 &lt;code&gt;LUA_RIDX_GLOBALS&lt;/code&gt; 的全局环境的值（请参见第&lt;a href=&quot;#4.5&quot;&gt;4.5节&lt;/a&gt;）。加载主要块时，此升值将是 &lt;code&gt;_ENV&lt;/code&gt; 变量（请参见&lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;）。其他升值使用&lt;b&gt;nil&lt;/b&gt;初始化。</target>
        </trans-unit>
        <trans-unit id="275e9e5485299a94935ea18cd6064e91a7392a15" translate="yes" xml:space="preserve">
          <source>If the resulting function has upvalues, the first upvalue is set to the value of &lt;code&gt;env&lt;/code&gt;, if that parameter is given, or to the value of the global environment. Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;. (When you load a main chunk, the resulting function will always have exactly one upvalue, the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). However, when you load a binary chunk created from a function (see &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt;), the resulting function can have an arbitrary number of upvalues.) All upvalues are fresh, that is, they are not shared with any other function.</source>
          <target state="translated">如果结果函数具有升值，则将第一个升值设置为 &lt;code&gt;env&lt;/code&gt; 的值（如果给出了该参数）或全局环境的值。其他升值使用&lt;b&gt;nil&lt;/b&gt;初始化。（当加载一个主块时，结果函数将始终具有一个升值 &lt;code&gt;_ENV&lt;/code&gt; 变量（请参见&lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;）。但是，当加载从一个函数创建的二进制块时（请参见&lt;a href=&quot;#pdf-string.dump&quot;&gt; &lt;code&gt;string.dump&lt;/code&gt; &lt;/a&gt;），结果函数可以具有任意数量的upvalue。）所有upvalue都是新鲜的，也就是说，它们不与任何其他函数共享。</target>
        </trans-unit>
        <trans-unit id="2440107420c56013ca178ce5e9d33aaab09429e6" translate="yes" xml:space="preserve">
          <source>If the third expression (the step) is absent, then a step of 1 is used.</source>
          <target state="translated">如果第三个表达式(步长)不存在,则使用1的步长。</target>
        </trans-unit>
        <trans-unit id="b6867da3d50ebe1ffe1a4f6e7b8d21bdab6c2e11" translate="yes" xml:space="preserve">
          <source>If the userdata does not have that value, pushes &lt;b&gt;nil&lt;/b&gt; and returns &lt;a href=&quot;#pdf-LUA_TNONE&quot;&gt;&lt;code&gt;LUA_TNONE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果userdata没有该值，则推&lt;b&gt;nil&lt;/b&gt;并返回&lt;a href=&quot;#pdf-LUA_TNONE&quot;&gt; &lt;code&gt;LUA_TNONE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="30fdcf02dde9756f746a6d73d9bf8f5049261a0f" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;x&lt;/code&gt; is convertible to an integer, returns that integer. Otherwise, returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">如果值 &lt;code&gt;x&lt;/code&gt; 可转换为整数，则返回该整数。否则，返回&lt;b&gt;失败&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="876e4bd473070df65d9eb13c67cd61272830f8dd" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;x&lt;/code&gt; is convertible to an integer, returns that integer. Otherwise, returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">如果值 &lt;code&gt;x&lt;/code&gt; 可转换为整数，则返回该整数。否则，返回&lt;b&gt;nil&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="94b7f8b2fd53356736681842c541a85531d3f0c6" translate="yes" xml:space="preserve">
          <source>If the value at the given index has a metatable, the function pushes that metatable onto the stack and returns 1. Otherwise, the function returns 0 and pushes nothing on the stack.</source>
          <target state="translated">如果给定索引处的值有元数据,函数将元数据推到栈上并返回1。否则,函数返回0,并且不在堆栈上推送任何内容。</target>
        </trans-unit>
        <trans-unit id="9441049c218d493b700b38a8bccd81b0ab58775b" translate="yes" xml:space="preserve">
          <source>If the value at the given index is a full userdata, returns its block address. If the value is a light userdata, returns its pointer. Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">如果给定索引处的值是完整的用户数据，则返回其块地址。如果该值为轻量级用户数据，则返回其指针。否则，返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c5badf0b625046b21174cf23ead77965326f8cc" translate="yes" xml:space="preserve">
          <source>If the value at the given index is a full userdata, returns its memory-block address. If the value is a light userdata, returns its value (a pointer). Otherwise, returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">如果给定索引处的值是完整的用户数据，则返回其内存块地址。如果该值是一个轻量级用户数据，则返回其值（一个指针）。否则，返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4632120bcb257e680797b7d6b495d6ae5165f498" translate="yes" xml:space="preserve">
          <source>If the value has a metatable with a &lt;code&gt;__tostring&lt;/code&gt; field, then &lt;code&gt;luaL_tolstring&lt;/code&gt; calls the corresponding metamethod with the value as argument, and uses the result of the call as its result.</source>
          <target state="translated">如果该值具有带有 &lt;code&gt;__tostring&lt;/code&gt; 字段的元表，则 &lt;code&gt;luaL_tolstring&lt;/code&gt; 会以该值作为参数调用相应的元方法，并将调用结果用作结果。</target>
        </trans-unit>
        <trans-unit id="d98fc2205300b7d347d732dbb4a9c377f9f7a2f3" translate="yes" xml:space="preserve">
          <source>If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;nil&lt;/b&gt;, then there is no replacement (that is, the original match is kept in the string).</source>
          <target state="translated">如果表查询或函数调用返回的值是字符串或数字，则将其用作替换字符串；否则，它将用作替换字符串。否则，如果它为&lt;b&gt;false&lt;/b&gt;或&lt;b&gt;nil&lt;/b&gt;，则不进行替换（即，原始匹配项保留在字符串中）。</target>
        </trans-unit>
        <trans-unit id="ff3df837749e4825f721110ceca71ee53b60c2f6" translate="yes" xml:space="preserve">
          <source>If there are no syntactic errors, &lt;code&gt;load&lt;/code&gt; returns the compiled chunk as a function; otherwise, it returns &lt;b&gt;fail&lt;/b&gt; plus the error message.</source>
          <target state="translated">如果没有语法错误，则 &lt;code&gt;load&lt;/code&gt; 将已编译的块作为函数返回；否则，将返回已编译的块。否则，它将返回&lt;b&gt;失败&lt;/b&gt;和错误消息。</target>
        </trans-unit>
        <trans-unit id="ed5b55c4ebb32433c98e6d7ba29a004a9265213b" translate="yes" xml:space="preserve">
          <source>If there are no syntactic errors, returns the compiled chunk as a function; otherwise, returns &lt;b&gt;nil&lt;/b&gt; plus the error message.</source>
          <target state="translated">如果没有语法错误，则将已编译的块作为函数返回；否则，返回已编译的块。否则，返回&lt;b&gt;nil&lt;/b&gt;和错误消息。</target>
        </trans-unit>
        <trans-unit id="94d76ea95ae9d04310650a4926fa6e03a91eead5" translate="yes" xml:space="preserve">
          <source>If there is any error loading or running the module, or if it cannot find any loader for the module, then &lt;code&gt;require&lt;/code&gt; raises an error.</source>
          <target state="translated">如果在加载或运行模块时发生任何错误，或者找不到模块的任何加载程序，则 &lt;code&gt;require&lt;/code&gt; 会引发错误。</target>
        </trans-unit>
        <trans-unit id="ce92cea2e328d0390d4ad8b2857051594fc6df6d" translate="yes" xml:space="preserve">
          <source>If there is any error while running a closing method, that error is handled like an error in the regular code where the variable was defined. However, Lua may call the method one more time.</source>
          <target state="translated">如果在运行关闭方法时出现任何错误,该错误会像定义变量的常规代码中的错误一样被处理。但是,Lua可以再调用一次该方法。</target>
        </trans-unit>
        <trans-unit id="0a6dbd64b84e48ca7300b890ff312675543ee0f6" translate="yes" xml:space="preserve">
          <source>If there is no script in the call, the interpreter name goes to index 0, followed by the other arguments. For instance, the call</source>
          <target state="translated">如果在调用中没有脚本,解释器的名称将转到索引0,然后是其他参数。例如,调用</target>
        </trans-unit>
        <trans-unit id="2f77907008466a9df684a2c79024f9604e714a0c" translate="yes" xml:space="preserve">
          <source>If this option is given together with option '&lt;code&gt;f&lt;/code&gt;', its table is pushed after the function.</source>
          <target state="translated">如果将此选项与选项' &lt;code&gt;f&lt;/code&gt; ' 一起提供，则将其表推送到该函数之后。</target>
        </trans-unit>
        <trans-unit id="232d4cb58dd3dc6d647132e58f5ddab6d89f9ef6" translate="yes" xml:space="preserve">
          <source>If you know beforehand the maximum size of the resulting string, you can use the buffer like this:</source>
          <target state="translated">如果你事先知道结果字符串的最大尺寸,你可以像这样使用缓冲区。</target>
        </trans-unit>
        <trans-unit id="eda48319758ff6bba8bcf8cb507f6d311265837c" translate="yes" xml:space="preserve">
          <source>If you know beforehand the total size of the resulting string, you can use the buffer like this:</source>
          <target state="translated">如果你事先知道结果字符串的总大小,你可以像这样使用缓冲区。</target>
        </trans-unit>
        <trans-unit id="0e57af394dbc6d5a626668daa30c3f8e2018059e" translate="yes" xml:space="preserve">
          <source>If you set the step multiplier to a very large number (larger than 10% of the maximum number of bytes that the program may use), the collector behaves like a stop-the-world collector. If you then set the pause to 200, the collector behaves as in old Lua versions, doing a complete collection every time Lua doubles its memory usage.</source>
          <target state="translated">如果你将步长乘数设置为一个非常大的数字(大于程序可能使用的最大字节数的10%),收集器的行为就像一个停止世界的收集器。如果你再将暂停设置为200,收集器的行为就像旧版Lua中的一样,每当Lua将其内存使用量增加一倍时,就会进行一次完整的收集。</target>
        </trans-unit>
        <trans-unit id="29af696fcc1cdd39d14ec551ccbd633c6f06b895" translate="yes" xml:space="preserve">
          <source>If, after the translation of negative indices, &lt;code&gt;i&lt;/code&gt; is less than 1, it is corrected to 1. If &lt;code&gt;j&lt;/code&gt; is greater than the string length, it is corrected to that length. If, after these corrections, &lt;code&gt;i&lt;/code&gt; is greater than &lt;code&gt;j&lt;/code&gt;, the function returns the empty string.</source>
          <target state="translated">如果在转换负索引后 &lt;code&gt;i&lt;/code&gt; 小于1，则将其校正为1。如果 &lt;code&gt;j&lt;/code&gt; 大于字符串长度，则将其校正为该长度。经过这些校正后，如果 &lt;code&gt;i&lt;/code&gt; 大于 &lt;code&gt;j&lt;/code&gt; ，则该函数返回空字符串。</target>
        </trans-unit>
        <trans-unit id="a9f42e3411c1cd363cce85bb39824046e38afc0c" translate="yes" xml:space="preserve">
          <source>In POSIX systems, this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).</source>
          <target state="translated">在POSIX系统中,为了避免安全隐患,这个函数也会用这个名字创建一个文件。(别人可能会在获得文件名和创建文件之间的时间内用错误的权限创建文件)。你仍然必须打开文件才能使用它和删除它(即使你不使用它)。</target>
        </trans-unit>
        <trans-unit id="6e188c4467182589f4f24a348f7b82d5dc4eb843" translate="yes" xml:space="preserve">
          <source>In a conversion from integer to float, if the integer value has an exact representation as a float, that is the result. Otherwise, the conversion gets the nearest higher or the nearest lower representable value. This kind of conversion never fails.</source>
          <target state="translated">在从整数到浮点的转换中,如果整数值有一个准确的浮点表示,那就是结果。否则,转换得到最接近的高值或低值。这种转换从来没有失败过。</target>
        </trans-unit>
        <trans-unit id="ea37a32b7be8a539051904217ddd263915df9e9c" translate="yes" xml:space="preserve">
          <source>In a function call, first prefixexp and args are evaluated. If the value of prefixexp has type &lt;em&gt;function&lt;/em&gt;, then this function is called with the given arguments. Otherwise, if present, the prefixexp &lt;code&gt;__call&lt;/code&gt; metamethod is called: its first argument is the value of prefixexp, followed by the original call arguments (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">在函数调用中，将对第一个prefixexp和args进行求值。如果prefixexp的值具有type&lt;em&gt;函数&lt;/em&gt;，则使用给定参数调用此函数。否则，如果存在，则调用prefixexp &lt;code&gt;__call&lt;/code&gt; 元方法：其第一个参数是prefixexp的值，后跟原始的调用参数（请参见&lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="97b9aa4de4630491dcb4d24142294547e0b16cc1" translate="yes" xml:space="preserve">
          <source>In a function call, first prefixexp and args are evaluated. If the value of prefixexp has type &lt;em&gt;function&lt;/em&gt;, then this function is called with the given arguments. Otherwise, the prefixexp &quot;call&quot; metamethod is called, having as first parameter the value of prefixexp, followed by the original call arguments (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">在函数调用中，将对第一个prefixexp和args进行求值。如果prefixexp的值具有type &lt;em&gt;函数&lt;/em&gt;，则使用给定参数调用此函数。否则，将调用prefixexp&amp;ldquo;调用&amp;rdquo;元方法，其第一个参数是prefixexp的值，后跟原始调用参数（请参见&lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="49949926795e2c68295a80e05d4c59850e0ba7a4" translate="yes" xml:space="preserve">
          <source>In addition to the previous list, the interpreter also respects the following keys in metatables: &lt;code&gt;__gc&lt;/code&gt; (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;), &lt;code&gt;__close&lt;/code&gt; (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;), &lt;code&gt;__mode&lt;/code&gt; (see &lt;a href=&quot;#2.5.4&quot;&gt;&amp;sect;2.5.4&lt;/a&gt;), and &lt;code&gt;__name&lt;/code&gt;. (The entry &lt;code&gt;__name&lt;/code&gt;, when it contains a string, may be used by &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt; and in error messages.)</source>
          <target state="translated">除了前面的列表，解释也尊重在元表下面的键： &lt;code&gt;__gc&lt;/code&gt; （参见&lt;a href=&quot;#2.5.3&quot;&gt;2.5.3节&lt;/a&gt;）， &lt;code&gt;__close&lt;/code&gt; （见&lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;）， &lt;code&gt;__mode&lt;/code&gt; （参见&lt;a href=&quot;#2.5.4&quot;&gt;2.5.4节&lt;/a&gt;），并 &lt;code&gt;__name&lt;/code&gt; 。（条目 &lt;code&gt;__name&lt;/code&gt; 包含字符串时，可能被&lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; 使用&lt;/a&gt;并在错误消息中使用。）</target>
        </trans-unit>
        <trans-unit id="62eebdc1879c0b1be4e46a0d6b0e9bcf316566f7" translate="yes" xml:space="preserve">
          <source>In any case, if the pattern specifies no captures, then it behaves as if the whole pattern was inside a capture.</source>
          <target state="translated">在任何情况下,如果模式没有指定捕获,那么它的行为就像整个模式在捕获中一样。</target>
        </trans-unit>
        <trans-unit id="2bb9e40f7423d9d013509578590213e990081254" translate="yes" xml:space="preserve">
          <source>In both cases pushes onto the stack the final value associated with &lt;code&gt;tname&lt;/code&gt; in the registry.</source>
          <target state="translated">在这两种情况下，都将与 &lt;code&gt;tname&lt;/code&gt; 关联的最终值压入堆栈。</target>
        </trans-unit>
        <trans-unit id="2fdfe218bfd306e46380cb987820b12f4c22a7cd" translate="yes" xml:space="preserve">
          <source>In both cases, the function pushes onto the stack the final value associated with &lt;code&gt;tname&lt;/code&gt; in the registry.</source>
          <target state="translated">在这两种情况下，函数都会将与 &lt;code&gt;tname&lt;/code&gt; 关联的最终值压入堆栈。</target>
        </trans-unit>
        <trans-unit id="745fa42e653c44e85ff99efe0906a4b1ecb00bd0" translate="yes" xml:space="preserve">
          <source>In case of errors opening the file, this function raises the error, instead of returning an error code.</source>
          <target state="translated">如果打开文件出错,这个函数会引发错误,而不是返回一个错误代码。</target>
        </trans-unit>
        <trans-unit id="529481951babb324dab477372f5c6d52890e6006" translate="yes" xml:space="preserve">
          <source>In case of errors this function raises the error, instead of returning an error code.</source>
          <target state="translated">如果出现错误,这个函数会引发错误,而不是返回错误代码。</target>
        </trans-unit>
        <trans-unit id="f30334a63968b6ddb7bb2b4604dd500f34422267" translate="yes" xml:space="preserve">
          <source>In case of errors, the stack is not unwound, so you can use the debug API over it. The error object is on the top of the stack.</source>
          <target state="translated">如果发生错误,堆栈不会被解开,所以你可以在上面使用调试API。错误对象在栈的顶部。</target>
        </trans-unit>
        <trans-unit id="467db70feecc1c4f6d135a7d76a384db5dda44c8" translate="yes" xml:space="preserve">
          <source>In case of overflows in integer arithmetic, all operations &lt;em&gt;wrap around&lt;/em&gt;, according to the usual rules of two-complement arithmetic. (In other words, they return the unique representable integer that is equal modulo &lt;em&gt;2&lt;sup&gt;64&lt;/sup&gt;&lt;/em&gt; to the mathematical result.)</source>
          <target state="translated">如果出现整数运算溢出的情况，则所有运算都&lt;em&gt;将&lt;/em&gt;根据2补码运算的通常规则进行&lt;em&gt;环绕&lt;/em&gt;。（换句话说，它们将唯一可表示的整数与&lt;em&gt;2 &lt;sup&gt;64&lt;/sup&gt;&lt;/em&gt;取模&lt;em&gt;2&lt;/em&gt;等于数学结果。）</target>
        </trans-unit>
        <trans-unit id="e042bc5ef9c39f04e2c4f57f3960a9657ca9b2b3" translate="yes" xml:space="preserve">
          <source>In case of overflows in integer arithmetic, all operations &lt;em&gt;wrap around&lt;/em&gt;.</source>
          <target state="translated">如果发生整数运算溢出，则所有操作都&lt;em&gt;将环绕&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="4404e49caab8b46532d3c1ccdfde90bff4f9337a" translate="yes" xml:space="preserve">
          <source>In case of success, &lt;code&gt;seek&lt;/code&gt; returns the final file position, measured in bytes from the beginning of the file. If &lt;code&gt;seek&lt;/code&gt; fails, it returns &lt;b&gt;fail&lt;/b&gt;, plus a string describing the error.</source>
          <target state="translated">如果成功， &lt;code&gt;seek&lt;/code&gt; 返回文件的最终位置，以从文件开头开始的字节数为单位。如果 &lt;code&gt;seek&lt;/code&gt; 失败，则返回&lt;b&gt;fail&lt;/b&gt;，外加描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="af2e9f70152b7436cb1235e5607b1026adf8b4df" translate="yes" xml:space="preserve">
          <source>In case of success, &lt;code&gt;seek&lt;/code&gt; returns the final file position, measured in bytes from the beginning of the file. If &lt;code&gt;seek&lt;/code&gt; fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error.</source>
          <target state="translated">如果成功， &lt;code&gt;seek&lt;/code&gt; 返回文件的最终位置，以从文件开头开始的字节数为单位。如果 &lt;code&gt;seek&lt;/code&gt; 失败，则返回&lt;b&gt;nil&lt;/b&gt;，外加描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="8ce8027efe413a45818ec783d9d3bd6228742c83" translate="yes" xml:space="preserve">
          <source>In case of success, returns a handle for a temporary file. This file is opened in update mode and it is automatically removed when the program ends.</source>
          <target state="translated">如果成功,返回一个临时文件的句柄。这个文件是在更新模式下打开的,并且在程序结束时自动删除。</target>
        </trans-unit>
        <trans-unit id="6be35cfe80694e8f2a500c5ffa60712ba072cc6f" translate="yes" xml:space="preserve">
          <source>In case of success, this function returns &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">如果成功，此函数将返回 &lt;code&gt;file&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6a86eee5d971d25767843d4dbdef34e84774cef" translate="yes" xml:space="preserve">
          <source>In case of success, this function returns &lt;code&gt;file&lt;/code&gt;. Otherwise it returns &lt;b&gt;nil&lt;/b&gt; plus a string describing the error.</source>
          <target state="translated">如果成功，此函数将返回 &lt;code&gt;file&lt;/code&gt; 。否则，它返回&lt;b&gt;nil&lt;/b&gt;加上描述错误的字符串。</target>
        </trans-unit>
        <trans-unit id="8c632a9fad5564d87f459215e17e926cda31f0ee" translate="yes" xml:space="preserve">
          <source>In case of unprotected errors in the script, the interpreter reports the error to the standard error stream. If the error object is not a string but has a metamethod &lt;code&gt;__tostring&lt;/code&gt;, the interpreter calls this metamethod to produce the final message. Otherwise, the interpreter converts the error object to a string and adds a stack traceback to it.</source>
          <target state="translated">如果脚本中出现不受保护的错误，解释器会将错误报告给标准错误流。如果错误对象不是字符串而是具有元方法 &lt;code&gt;__tostring&lt;/code&gt; ，则解释器将调用此元方法以生成最终消息。否则，解释器将错误对象转换为字符串，并向其添加堆栈回溯。</target>
        </trans-unit>
        <trans-unit id="bea04697f039ec14dc1ee8265502eaa4d56df50c" translate="yes" xml:space="preserve">
          <source>In case of unprotected errors in the script, the interpreter reports the error to the standard error stream. If the error object is not a string but has a metamethod &lt;code&gt;__tostring&lt;/code&gt;, the interpreter calls this metamethod to produce the final message. Otherwise, the interpreter converts the error object to a string and adds a stack traceback to it. When warnings are on, they are simply printed in the standard error output.</source>
          <target state="translated">如果脚本中出现不受保护的错误，解释器会将错误报告给标准错误流。如果错误对象不是字符串而是具有元方法 &lt;code&gt;__tostring&lt;/code&gt; ，则解释器将调用此元方法以生成最终消息。否则，解释器将错误对象转换为字符串，并向其添加堆栈回溯。警告打开时，它们仅打印在标准错误输出中。</target>
        </trans-unit>
        <trans-unit id="07f47d88fa41a69cbb5505a94710be0b6ddd4668" translate="yes" xml:space="preserve">
          <source>In general, Lua's garbage collection can free or move internal memory and then invalidate pointers to internal strings. To allow a safe use of these pointers, The API guarantees that any pointer to a string in a stack index is valid while the value at that index is neither modified nor popped. When the index is a pseudo-index (referring to an upvalue), the pointer is valid while the corresponding call is active and the corresponding upvalue is not modified.</source>
          <target state="translated">一般来说,Lua的垃圾回收可以释放或移动内部内存,然后使内部字符串的指针无效。为了允许安全使用这些指针,API保证任何指向堆栈索引中的字符串的指针都是有效的,同时该索引处的值既不被修改也不被弹出。当索引是一个伪索引(指一个上值)时,当相应的调用处于活动状态且相应的上值不被修改时,该指针是有效的。</target>
        </trans-unit>
        <trans-unit id="ea95e591f583f4a7ef86223f97f4160fc20ef3bf" translate="yes" xml:space="preserve">
          <source>In generational mode, the collector does frequent &lt;em&gt;minor&lt;/em&gt; collections, which traverses only objects recently created. If after a minor collection the use of memory is still above a limit, the collector does a stop-the-world &lt;em&gt;major&lt;/em&gt; collection, which traverses all objects. The generational mode uses two parameters: the &lt;em&gt;minor multiplier&lt;/em&gt; and the &lt;em&gt;the major multiplier&lt;/em&gt;.</source>
          <target state="translated">在分代模式下，收集器频繁执行&lt;em&gt;次要&lt;/em&gt;收集，仅遍历最近创建的对象。如果在次要收集之后对内存的使用仍然超出限制，则收集器将进行一次世界停止的&lt;em&gt;主要&lt;/em&gt;收集，该遍历将遍历所有对象。世代模式使用两个参数：&lt;em&gt;次要乘数&lt;/em&gt;和&lt;em&gt;主要乘数&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="dd00f2668545ca027b5cc5fd8421e849fff38797" translate="yes" xml:space="preserve">
          <source>In incremental mode, each GC cycle performs a mark-and-sweep collection in small steps interleaved with the program's execution. In this mode, the collector uses three numbers to control its garbage-collection cycles: the &lt;em&gt;garbage-collector pause&lt;/em&gt;, the &lt;em&gt;garbage-collector step multiplier&lt;/em&gt;, and the &lt;em&gt;garbage-collector step size&lt;/em&gt;.</source>
          <target state="translated">在增量模式下，每个GC周期在与程序执行交错的小步中执行标记清除扫描。在此模式下，收集器使用三个数字来控制其垃圾收集周期：&lt;em&gt;垃圾收集器暂停&lt;/em&gt;，&lt;em&gt;垃圾收集器步骤乘数&lt;/em&gt;和&lt;em&gt;垃圾收集器步骤大小&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="bae459100d0f219cfd74a53f2eb34f96a6176512" translate="yes" xml:space="preserve">
          <source>In interactive mode, Lua repeatedly prompts and waits for a line. After reading a line, Lua first try to interpret the line as an expression. If it succeeds, it prints its value. Otherwise, it interprets the line as a statement. If you write an incomplete statement, the interpreter waits for its completion by issuing a different prompt.</source>
          <target state="translated">在交互模式下,Lua会反复提示并等待一行字。读取一行后,Lua首先尝试将该行解释为一个表达式。如果成功,它就会打印出它的值。否则,它将该行解释为一个语句。如果你写了一个不完整的语句,解释器会通过发出不同的提示来等待它的完成。</target>
        </trans-unit>
        <trans-unit id="63d381d8ee2b95ac5052d39e95b78fbc9ea8d9fb" translate="yes" xml:space="preserve">
          <source>In order to communicate properly with Lua, a C function must use the following protocol, which defines the way parameters and results are passed: a C function receives its arguments from Lua in its stack in direct order (the first argument is pushed first). So, when the function starts, &lt;code&gt;lua_gettop(L)&lt;/code&gt; returns the number of arguments received by the function. The first argument (if any) is at index 1 and its last argument is at index &lt;code&gt;lua_gettop(L)&lt;/code&gt;. To return values to Lua, a C function just pushes them onto the stack, in direct order (the first result is pushed first), and returns in C the number of results. Any other value in the stack below the results will be properly discarded by Lua. Like a Lua function, a C function called by Lua can also return many results.</source>
          <target state="translated">为了与Lua正确通信，C函数必须使用以下协议，该协议定义了传递参数和结果的方式：C函数以直接顺序从Lua的堆栈中接收其参数（第一个参数首先被压入）。因此，当函数启动时， &lt;code&gt;lua_gettop(L)&lt;/code&gt; 返回函数接收的参数数量。第一个参数（如果有）在索引1处，而最后一个参数在索引 &lt;code&gt;lua_gettop(L)&lt;/code&gt; 处。要将值返回给Lua，C函数仅将它们按直接顺序推入堆栈（第一个结果先被推入），然后在C中返回结果数。 Lua会适当地丢弃堆栈中低于结果的任何其他值。像Lua函数一样，Lua调用的C函数也可以返回许多结果。</target>
        </trans-unit>
        <trans-unit id="08b57c85f9e4681ef2b296b47dfe58462b42111a" translate="yes" xml:space="preserve">
          <source>In order to communicate properly with Lua, a C function must use the following protocol, which defines the way parameters and results are passed: a C function receives its arguments from Lua in its stack in direct order (the first argument is pushed first). So, when the function starts, &lt;code&gt;lua_gettop(L)&lt;/code&gt; returns the number of arguments received by the function. The first argument (if any) is at index 1 and its last argument is at index &lt;code&gt;lua_gettop(L)&lt;/code&gt;. To return values to Lua, a C function just pushes them onto the stack, in direct order (the first result is pushed first), and returns the number of results. Any other value in the stack below the results will be properly discarded by Lua. Like a Lua function, a C function called by Lua can also return many results.</source>
          <target state="translated">为了与Lua正确通信，C函数必须使用以下协议，该协议定义了传递参数和结果的方式：C函数以直接顺序从其栈中的Lua接收其自变量（第一个自变量首先被压入）。因此，当函数启动时， &lt;code&gt;lua_gettop(L)&lt;/code&gt; 返回函数接收的参数数量。第一个参数（如果有）在索引1处，而最后一个参数在索引 &lt;code&gt;lua_gettop(L)&lt;/code&gt; 处。要将值返回给Lua，C函数仅按直接顺序将它们压入堆栈（第一个结果先压入），然后返回结果数。 Lua会适当地丢弃堆栈中低于结果的任何其他值。像Lua函数一样，Lua调用的C函数也可以返回许多结果。</target>
        </trans-unit>
        <trans-unit id="1509d2ba42008705f892c900bc91b5bc201ddc1e" translate="yes" xml:space="preserve">
          <source>In the &lt;b&gt;repeat&lt;/b&gt;&amp;ndash;&lt;b&gt;until&lt;/b&gt; loop, the inner block does not end at the &lt;b&gt;until&lt;/b&gt; keyword, but only after the condition. So, the condition can refer to local variables declared inside the loop block.</source>
          <target state="translated">在&lt;b&gt;重复&lt;/b&gt; &amp;ndash; &lt;b&gt;直到&lt;/b&gt;循环中，内部块不会在&lt;b&gt;直到&lt;/b&gt;关键字&lt;b&gt;之前&lt;/b&gt;结束，而仅在条件之后结束。因此，条件可以引用在循环块内部声明的局部变量。</target>
        </trans-unit>
        <trans-unit id="82f098174293e606c23ea050f8d7e73e0153453e" translate="yes" xml:space="preserve">
          <source>In the above code, the new function &lt;code&gt;k&lt;/code&gt; is a &lt;em&gt;continuation function&lt;/em&gt; (with type &lt;a href=&quot;#lua_KFunction&quot;&gt;&lt;code&gt;lua_KFunction&lt;/code&gt;&lt;/a&gt;), which should do all the work that the original function was doing after calling &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;. Now, we must inform Lua that it must call &lt;code&gt;k&lt;/code&gt; if the Lua code being executed by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; gets interrupted in some way (errors or yielding), so we rewrite the code as here, replacing &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; by &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在上面的代码中，新函数 &lt;code&gt;k&lt;/code&gt; 是一个&lt;em&gt;延续函数&lt;/em&gt;（类型为&lt;a href=&quot;#lua_KFunction&quot;&gt; &lt;code&gt;lua_KFunction&lt;/code&gt; &lt;/a&gt;），该&lt;em&gt;函数&lt;/em&gt;应在调用&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;后完成原始函数所做的所有工作。现在，我们必须告诉Lua中，它必须调用 &lt;code&gt;k&lt;/code&gt; 如果Lua代码被执行&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;以某种方式被中断（错误或收益），所以我们重写代码一样，这里更换&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;通过&lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="1a9834b08661ce8efa680d14f8d2efb7c60bfccf" translate="yes" xml:space="preserve">
          <source>In the case of an out-of-memory error, the value in the given index is immediately closed, as if it was already marked.</source>
          <target state="translated">在内存出错的情况下,给定索引中的值会被立即关闭,就像它已经被标记一样。</target>
        </trans-unit>
        <trans-unit id="06f49d50825ba7a2c55ba6aba66f792c4da727cd" translate="yes" xml:space="preserve">
          <source>In the first case, the parameter &lt;code&gt;ar&lt;/code&gt; must be a valid activation record that was filled by a previous call to &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; or given as argument to a hook (see &lt;a href=&quot;#lua_Hook&quot;&gt;&lt;code&gt;lua_Hook&lt;/code&gt;&lt;/a&gt;). The index &lt;code&gt;n&lt;/code&gt; selects which local variable to inspect; see &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt;&lt;code&gt;debug.getlocal&lt;/code&gt;&lt;/a&gt; for details about variable indices and names.</source>
          <target state="translated">在第一种情况下，参数 &lt;code&gt;ar&lt;/code&gt; 必须是有效的激活记录，该记录由先前对&lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; 的&lt;/a&gt;调用填充或作为钩子的参数提供（请参见&lt;a href=&quot;#lua_Hook&quot;&gt; &lt;code&gt;lua_Hook&lt;/code&gt; &lt;/a&gt;）。索引 &lt;code&gt;n&lt;/code&gt; 选择要检查的局部变量；有关变量索引和名称的详细信息，请参见&lt;a href=&quot;#pdf-debug.getlocal&quot;&gt; &lt;code&gt;debug.getlocal&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="41a440753f8786d13a87f3b118280fbe98ed6aa7" translate="yes" xml:space="preserve">
          <source>In the second case, &lt;code&gt;ar&lt;/code&gt; must be &lt;code&gt;NULL&lt;/code&gt; and the function to be inspected must be at the top of the stack. In this case, only parameters of Lua functions are visible (as there is no information about what variables are active) and no values are pushed onto the stack.</source>
          <target state="translated">在第二种情况下， &lt;code&gt;ar&lt;/code&gt; 必须为 &lt;code&gt;NULL&lt;/code&gt; ,并且要检查的函数必须在堆栈的顶部。在这种情况下，只有Lua函数的参数可见（因为没有有关活动变量的信息），也没有值被压入堆栈。</target>
        </trans-unit>
        <trans-unit id="5b74c4ab2ab9491434583e802b1853e197a9999c" translate="yes" xml:space="preserve">
          <source>In the second case, &lt;code&gt;ar&lt;/code&gt; must be &lt;code&gt;NULL&lt;/code&gt; and the function to be inspected must be on the top of the stack. In this case, only parameters of Lua functions are visible (as there is no information about what variables are active) and no values are pushed onto the stack.</source>
          <target state="translated">在第二种情况下， &lt;code&gt;ar&lt;/code&gt; 必须为 &lt;code&gt;NULL&lt;/code&gt; ,并且要检查的函数必须在堆栈的顶部。在这种情况下，只有Lua函数的参数可见（因为没有有关活动变量的信息），并且没有值被压入堆栈。</target>
        </trans-unit>
        <trans-unit id="431335cf2ea122b520413c8e75c042e2443dd934" translate="yes" xml:space="preserve">
          <source>In this case, all returned values are thrown away. Function calls are explained in &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，所有返回的值都将被丢弃。函数调用在第&lt;a href=&quot;#3.4.10&quot;&gt;3.4.10节中&lt;/a&gt;进行了说明。</target>
        </trans-unit>
        <trans-unit id="789e39d8c294634d33eb6b9c165293b5343c70b0" translate="yes" xml:space="preserve">
          <source>In words, a border is any (natural) index in a table where a non-nil value is followed by a nil value (or zero, when index 1 is nil).</source>
          <target state="translated">换句话说,边框是表中的任何(自然)索引,其中一个非零值后面跟着一个零值(或零,当索引1为零时)。</target>
        </trans-unit>
        <trans-unit id="46873fd5ff052b8cbb9d6a8125368950d99d54a9" translate="yes" xml:space="preserve">
          <source>In words, a border is any (natural) index present in the table that is followed by an absent index (or zero, when index 1 is absent).</source>
          <target state="translated">换句话说,边框是指表格中存在的任何(自然)索引,该索引后面有一个不存在的索引(或零,当索引1不存在时)。</target>
        </trans-unit>
        <trans-unit id="da8e5fd662c079ec4e558198c08627aa99e4ddde" translate="yes" xml:space="preserve">
          <source>In words, if the argument &lt;code&gt;arg&lt;/code&gt; is nil or absent, the macro results in the default &lt;code&gt;dflt&lt;/code&gt;. Otherwise, it results in the result of calling &lt;code&gt;func&lt;/code&gt; with the state &lt;code&gt;L&lt;/code&gt; and the argument index &lt;code&gt;arg&lt;/code&gt; as arguments. Note that it evaluates the expression &lt;code&gt;dflt&lt;/code&gt; only if needed.</source>
          <target state="translated">换句话说，如果参数 &lt;code&gt;arg&lt;/code&gt; 为nil或不存在，则宏将导致默认值 &lt;code&gt;dflt&lt;/code&gt; 。否则，将导致以状态 &lt;code&gt;L&lt;/code&gt; 和参数索引 &lt;code&gt;arg&lt;/code&gt; 作为参数调用 &lt;code&gt;func&lt;/code&gt; 的结果。请注意，仅在需要时才对表达式 &lt;code&gt;dflt&lt;/code&gt; 求值。</target>
        </trans-unit>
        <trans-unit id="1d61c65c4df032dfd4680710a9c5e29989e4f8c3" translate="yes" xml:space="preserve">
          <source>In words, if the argument &lt;code&gt;arg&lt;/code&gt; is nil or absent, the macro results in the default &lt;code&gt;dflt&lt;/code&gt;. Otherwise, it results in the result of calling &lt;code&gt;func&lt;/code&gt; with the state &lt;code&gt;L&lt;/code&gt; and the argument index &lt;code&gt;arg&lt;/code&gt; as parameters. Note that it evaluates the expression &lt;code&gt;dflt&lt;/code&gt; only if needed.</source>
          <target state="translated">换句话说，如果参数 &lt;code&gt;arg&lt;/code&gt; 为nil或不存在，则宏将导致默认值 &lt;code&gt;dflt&lt;/code&gt; 。否则，将导致以状态 &lt;code&gt;L&lt;/code&gt; 和参数索引 &lt;code&gt;arg&lt;/code&gt; 作为参数调用 &lt;code&gt;func&lt;/code&gt; 的结果。请注意，仅在需要时才对表达式 &lt;code&gt;dflt&lt;/code&gt; 求值。</target>
        </trans-unit>
        <trans-unit id="01a07bfb5ef11a02986679665264fe04ed7927b3" translate="yes" xml:space="preserve">
          <source>Incremental Garbage Collection</source>
          <target state="translated">递增式垃圾收集</target>
        </trans-unit>
        <trans-unit id="bea01033355ce358e0c79f805090383ef4dadccc" translate="yes" xml:space="preserve">
          <source>Initializes a buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). This function does not allocate any space; the buffer must be declared as a variable.</source>
          <target state="translated">初始化缓冲区 &lt;code&gt;B&lt;/code&gt; （请参见&lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt;）。该函数不分配任何空间；缓冲区必须声明为变量。</target>
        </trans-unit>
        <trans-unit id="67c7955edf181aeadc7e61f0904d3690ad3a91fb" translate="yes" xml:space="preserve">
          <source>Initializes a buffer &lt;code&gt;B&lt;/code&gt;. This function does not allocate any space; the buffer must be declared as a variable (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">初始化缓冲器 &lt;code&gt;B&lt;/code&gt; 。该函数不分配任何空间；必须将缓冲区声明为变量（请参见&lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0abea9e11cfbbca6718360dab7feca24a7e28d57" translate="yes" xml:space="preserve">
          <source>Inserts element &lt;code&gt;value&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, shifting up the elements &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt;. The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list+1&lt;/code&gt;, so that a call &lt;code&gt;table.insert(t,x)&lt;/code&gt; inserts &lt;code&gt;x&lt;/code&gt; at the end of list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">插入物元素 &lt;code&gt;value&lt;/code&gt; 在位置 &lt;code&gt;pos&lt;/code&gt; 在 &lt;code&gt;list&lt;/code&gt; ，上移的元素 &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; 。作为默认值 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;#list+1&lt;/code&gt; ，以使得呼叫 &lt;code&gt;table.insert(t,x)&lt;/code&gt; 插入 &lt;code&gt;x&lt;/code&gt; 在列表末尾 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97337f3db6c1f37e6b68c3a033b725e785a46913" translate="yes" xml:space="preserve">
          <source>Inserts element &lt;code&gt;value&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt; in &lt;code&gt;list&lt;/code&gt;, shifting up the elements &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt;. The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list+1&lt;/code&gt;, so that a call &lt;code&gt;table.insert(t,x)&lt;/code&gt; inserts &lt;code&gt;x&lt;/code&gt; at the end of the list &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">插入物元素 &lt;code&gt;value&lt;/code&gt; 在位置 &lt;code&gt;pos&lt;/code&gt; 在 &lt;code&gt;list&lt;/code&gt; ，上移的元素 &lt;code&gt;list[pos], list[pos+1], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; 。作为默认值 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;#list+1&lt;/code&gt; ，以使得呼叫 &lt;code&gt;table.insert(t,x)&lt;/code&gt; 插入 &lt;code&gt;x&lt;/code&gt; 在列表的末尾 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3151191ed07199be567c359ddf6e784a4e531a23" translate="yes" xml:space="preserve">
          <source>Inside a C function you can raise an error by calling &lt;a href=&quot;#lua_error&quot;&gt;&lt;code&gt;lua_error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在C函数内部，可以通过调用&lt;a href=&quot;#lua_error&quot;&gt; &lt;code&gt;lua_error&lt;/code&gt; &lt;/a&gt;引发错误。</target>
        </trans-unit>
        <trans-unit id="f7de63f7ebba7b4f1b63972998e3589e858efeb5" translate="yes" xml:space="preserve">
          <source>Inside a C function you can raise an error explicitly by calling &lt;a href=&quot;#lua_error&quot;&gt;&lt;code&gt;lua_error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在C函数内部，可以通过调用&lt;a href=&quot;#lua_error&quot;&gt; &lt;code&gt;lua_error&lt;/code&gt; &lt;/a&gt;显式引发错误。</target>
        </trans-unit>
        <trans-unit id="85b166ec01ff2a0e99bcb49337529aa50cdf9ed8" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to handle errors. (Lua will use exceptions if you compile it as C++; search for &lt;code&gt;LUAI_THROW&lt;/code&gt; in the source code for details.) When Lua faces any error (such as a memory allocation error or a type error) it &lt;em&gt;raises&lt;/em&gt; an error; that is, it does a long jump. A &lt;em&gt;protected environment&lt;/em&gt; uses &lt;code&gt;setjmp&lt;/code&gt; to set a recovery point; any error jumps to the most recent active recovery point.</source>
          <target state="translated">在内部，Lua使用C &lt;code&gt;longjmp&lt;/code&gt; 工具来处理错误。 （如果将Lua编译为C ++，它将使用异常；在源代码中搜索 &lt;code&gt;LUAI_THROW&lt;/code&gt; 以获取详细信息。）当Lua遇到任何错误（例如内存分配错误或类型错误）时，它将&lt;em&gt;引发&lt;/em&gt;错误；也就是说，它跳远了。一个&lt;em&gt;受保护的环境&lt;/em&gt;使用 &lt;code&gt;setjmp&lt;/code&gt; 调用设置一个恢复点;任何错误都将跳至最近的活动恢复点。</target>
        </trans-unit>
        <trans-unit id="5b482879524a2f9c14e638942f5681b2d3a687a1" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to handle errors. (Lua will use exceptions if you compile it as C++; search for &lt;code&gt;LUAI_THROW&lt;/code&gt; in the source code for details.) When Lua faces any error, such as a memory allocation error or a type error, it &lt;em&gt;raises&lt;/em&gt; an error; that is, it does a long jump. A &lt;em&gt;protected environment&lt;/em&gt; uses &lt;code&gt;setjmp&lt;/code&gt; to set a recovery point; any error jumps to the most recent active recovery point.</source>
          <target state="translated">在内部，Lua使用C &lt;code&gt;longjmp&lt;/code&gt; 工具来处理错误。 （如果将Lua编译为C ++，它将使用异常；在源代码中搜索 &lt;code&gt;LUAI_THROW&lt;/code&gt; 以获取详细信息。）当Lua遇到任何错误（例如内存分配错误或类型错误）时，它将&lt;em&gt;引发&lt;/em&gt;错误；也就是说，它跳远了。一个&lt;em&gt;受保护的环境&lt;/em&gt;使用 &lt;code&gt;setjmp&lt;/code&gt; 调用设置一个恢复点;任何错误都将跳至最近的活动恢复点。</target>
        </trans-unit>
        <trans-unit id="8519c30b2fe0a1d5b4b757f31a04911a4641884f" translate="yes" xml:space="preserve">
          <source>Internally, Lua uses the C &lt;code&gt;longjmp&lt;/code&gt; facility to yield a coroutine. Therefore, if a C function &lt;code&gt;foo&lt;/code&gt; calls an API function and this API function yields (directly or indirectly by calling another function that yields), Lua cannot return to &lt;code&gt;foo&lt;/code&gt; any more, because the &lt;code&gt;longjmp&lt;/code&gt; removes its frame from the C stack.</source>
          <target state="translated">在内部，Lua使用C &lt;code&gt;longjmp&lt;/code&gt; 工具生成协程。因此，如果C函数 &lt;code&gt;foo&lt;/code&gt; 调用了一个API函数，并且该API函数产生了（直接或间接通过调用另一个产生该函数的函数），Lua将不再返回 &lt;code&gt;foo&lt;/code&gt; ，因为 &lt;code&gt;longjmp&lt;/code&gt; 从C堆栈中删除了它的框架。</target>
        </trans-unit>
        <trans-unit id="7b4e8ed077aa1747843eb727cc8f6e4bfe8b0b8a" translate="yes" xml:space="preserve">
          <source>It can only be called from the main coroutine (thread);</source>
          <target state="translated">它只能从主coroutine(线程)中调用。</target>
        </trans-unit>
        <trans-unit id="ad02c3ff1e54045c9f87d15faf0f433734a4ee16" translate="yes" xml:space="preserve">
          <source>It cannot be called while handling a stack-overflow error;</source>
          <target state="translated">在处理堆栈溢出错误时不能调用它。</target>
        </trans-unit>
        <trans-unit id="ffa29374aa14b1802d3041c63b03777bfa3568ee" translate="yes" xml:space="preserve">
          <source>It is a good practice to add all needed metamethods to a table before setting it as a metatable of some object. In particular, the &lt;code&gt;__gc&lt;/code&gt; metamethod works only when this order is followed (see &lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt;).</source>
          <target state="translated">在将表设置为某个对象的元表之前，将所有需要的元方法添加到表中是一个好习惯。特别是， &lt;code&gt;__gc&lt;/code&gt; 元方法的工作原理，只有当这个命令之后（见&lt;a href=&quot;#2.5.1&quot;&gt;&amp;sect;2.5.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2ea190191ffd1383568cdfab371917a78dd082eb" translate="yes" xml:space="preserve">
          <source>It is a good practice to add all needed metamethods to a table before setting it as a metatable of some object. In particular, the &lt;code&gt;__gc&lt;/code&gt; metamethod works only when this order is followed (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;). It is also a good practice to set the metatable of an object right after its creation.</source>
          <target state="translated">在将表设置为某个对象的元表之前，将所有需要的元方法添加到表中是一种很好的做法。特别是， &lt;code&gt;__gc&lt;/code&gt; 元方法的工作原理，只有当这个命令之后（参见&lt;a href=&quot;#2.5.3&quot;&gt;2.5.3节&lt;/a&gt;）。在对象创建后立即设置其元表也是一种好习惯。</target>
        </trans-unit>
        <trans-unit id="1db3cf420aeec740d5b98f3c2218fb5a839f1cb0" translate="yes" xml:space="preserve">
          <source>It is implemented as a macro. The array &lt;code&gt;l&lt;/code&gt; must be the actual array, not a pointer to it.</source>
          <target state="translated">它被实现为宏。数组 &lt;code&gt;l&lt;/code&gt; 必须是实际数组，而不是指向它的指针。</target>
        </trans-unit>
        <trans-unit id="c9afa0ea65ace9886d214c45b938bb7c94f5de0d" translate="yes" xml:space="preserve">
          <source>It is implemented as the following macro:</source>
          <target state="translated">它的实现方式如下宏。</target>
        </trans-unit>
        <trans-unit id="783b6db8dfbf8f740fac86413ecee3fd449cddff" translate="yes" xml:space="preserve">
          <source>It is safe to load malformed binary chunks; &lt;code&gt;load&lt;/code&gt; signals an appropriate error. However, Lua does not check the consistency of the code inside binary chunks; running maliciously crafted bytecode can crash the interpreter.</source>
          <target state="translated">加载格式错误的二进制块是安全的； &lt;code&gt;load&lt;/code&gt; 表示适当的错误。但是，Lua不会检查二进制块中代码的一致性。运行恶意制作的字节码可能会使解释器崩溃。</target>
        </trans-unit>
        <trans-unit id="190f1a01da6183ca61829ab46d875cc8475bbf31" translate="yes" xml:space="preserve">
          <source>It returns &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; if there are no errors, or an error code in case of errors (see &lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt;).</source>
          <target state="translated">如果没有错误，则返回&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; ,&lt;/a&gt;如果有错误，则返回错误代码（请参见&lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2562ec974531de3f4ff5f92b1e35fb5384a96e25" translate="yes" xml:space="preserve">
          <source>It returns false if there are no errors or true in case of errors.</source>
          <target state="translated">如果没有错误则返回false,如果有错误则返回true。</target>
        </trans-unit>
        <trans-unit id="53569202de7b24893f55608fc3a251509d5c5ed1" translate="yes" xml:space="preserve">
          <source>Labels and empty statements are called &lt;em&gt;void statements&lt;/em&gt;, as they perform no actions.</source>
          <target state="translated">标签和空语句称为&lt;em&gt;空语句&lt;/em&gt;，因为它们不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="34328aff9c833379f4f7362578f7f6f3c35f336b" translate="yes" xml:space="preserve">
          <source>Language constructs will be explained using the usual extended BNF notation, in which {&lt;em&gt;a&lt;/em&gt;} means 0 or more &lt;em&gt;a&lt;/em&gt;'s, and [&lt;em&gt;a&lt;/em&gt;] means an optional &lt;em&gt;a&lt;/em&gt;. Non-terminals are shown like non-terminal, keywords are shown like &lt;b&gt;kword&lt;/b&gt;, and other terminal symbols are shown like &amp;lsquo;&lt;b&gt;=&lt;/b&gt;&amp;rsquo;. The complete syntax of Lua can be found in &lt;a href=&quot;#9&quot;&gt;&amp;sect;9&lt;/a&gt; at the end of this manual.</source>
          <target state="translated">语言构造将使用通常的扩展BNF表示法进行解释，其中{ &lt;em&gt;a&lt;/em&gt; }表示0或多个&lt;em&gt;a&lt;/em&gt;，而[ &lt;em&gt;a&lt;/em&gt; ]表示可选的&lt;em&gt;a&lt;/em&gt;。非终结符显示为非终结符，关键字显示为&lt;b&gt;kword&lt;/b&gt;，其他终结符显示为' &lt;b&gt;=&lt;/b&gt; '。Lua的完整语法可以在本手册末尾的&lt;a href=&quot;#9&quot;&gt;&amp;sect;9&lt;/a&gt;中找到。</target>
        </trans-unit>
        <trans-unit id="b15777583b377cc227a5505487783a1d631969a6" translate="yes" xml:space="preserve">
          <source>Leaves a copy of the module on the stack.</source>
          <target state="translated">在堆栈上留下一个模块的副本。</target>
        </trans-unit>
        <trans-unit id="c282589ab5afc326acf6f1bd9d84cafcef993944" translate="yes" xml:space="preserve">
          <source>Level 0 is the running function, level 1 is the function that called the running function, etc.</source>
          <target state="translated">0级是运行函数,1级是调用运行函数的函数,等等。</target>
        </trans-unit>
        <trans-unit id="bd2f93f70d8b01be186bad25b37a58b9b3ce91ea" translate="yes" xml:space="preserve">
          <source>Lexical Conventions</source>
          <target state="translated">词汇公约</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="63d6bf8afb548c458acc9de58d99159419a5b08e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine. Any arguments passed to this function go as extra arguments to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; returns all the values returned by &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, except the first one (the boolean error code). Unlike &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; does not catch errors; any error is propagated to the caller.</source>
          <target state="translated">像&lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; &lt;/a&gt;一样，&lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt;函数也创建了一个协程，但是它不返回协程本身，而是返回一个函数，该函数在被调用时将恢复协程。传递给此函数的所有参数都将作为&lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 的&lt;/a&gt;附加参数。&lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; 这个&lt;/a&gt;返回的所有值由返回&lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 时&lt;/a&gt;，除了第一个（布尔错误代码）。与&lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt;不同，&lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt;不会捕获错误。任何错误都会传播到调用方。</target>
        </trans-unit>
        <trans-unit id="9f39f04881560be91c1cf898317730aebddff532" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; function also creates a coroutine, but instead of returning the coroutine itself, it returns a function that, when called, resumes the coroutine. Any arguments passed to this function go as extra arguments to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; returns all the values returned by &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, except the first one (the boolean error code). Unlike &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, the function created by &lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt;&lt;code&gt;coroutine.wrap&lt;/code&gt;&lt;/a&gt; propagates any error to the caller. In this case, the function also closes the coroutine (see &lt;a href=&quot;#pdf-coroutine.close&quot;&gt;&lt;code&gt;coroutine.close&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">像&lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; &lt;/a&gt;一样，&lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt;函数也创建了一个协程，但是它不返回协程本身，而是返回一个函数，该函数在被调用时将恢复协程。传递给此函数的所有参数都将作为&lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 的&lt;/a&gt;附加参数。&lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; 这个&lt;/a&gt;返回的所有值由返回&lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 时&lt;/a&gt;，除了第一个（布尔错误代码）。与&lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt;不同，coroutine.wrap创建的函数&lt;a href=&quot;#pdf-coroutine.wrap&quot;&gt; &lt;code&gt;coroutine.wrap&lt;/code&gt; &lt;/a&gt;任何错误传播给调用方。在这种情况下，该函数还会关闭协程（请参见&lt;a href=&quot;#pdf-coroutine.close&quot;&gt; &lt;code&gt;coroutine.close&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="589bb9a9b2f8417c5c99beaf7b463ed9bff7b7a8" translate="yes" xml:space="preserve">
          <source>Like any other reference manual, this document is dry in places. For a discussion of the decisions behind the design of Lua, see the technical papers available at Lua's web site. For a detailed introduction to programming in Lua, see Roberto's book, &lt;em&gt;Programming in Lua&lt;/em&gt;.</source>
          <target state="translated">与任何其他参考手册一样，本文档在某些地方干燥。有关Lua设计背后的决策的讨论，请参见Lua网站上提供的技术论文。有关Lua中编程的详细介绍，请参见Roberto的书，《&lt;em&gt;Lua中的编程》&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="0685b0afda8aac522f92e3eb98e6860f9fdecb1c" translate="yes" xml:space="preserve">
          <source>Like indices, the values of table fields can be of any type. In particular, because functions are first-class values, table fields can contain functions. Thus tables can also carry &lt;em&gt;methods&lt;/em&gt; (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;).</source>
          <target state="translated">像索引一样，表字段的值可以是任何类型。特别是，因为函数是一等值，所以表字段可以包含函数。因此，表也可以包含&lt;em&gt;方法&lt;/em&gt;（请参见第&lt;a href=&quot;#3.4.11&quot;&gt;3.4.11节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8afe6c1d451218575629deb4965cb995c2e958ea" translate="yes" xml:space="preserve">
          <source>Like with indexing, the metamethod for this event can be either a function or a table. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; as arguments. If it is a table, Lua does an indexing assignment to this table with the same key and value. (This assignment is regular, not raw, and therefore can trigger another metamethod.)</source>
          <target state="translated">与索引一样，此事件的元方法可以是函数或表。如果它是一个函数，则以 &lt;code&gt;table&lt;/code&gt; ， &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 作为参数来调用。如果是表，Lua将使用相同的键和值对该表进行索引分配。 （此分配是常规的，不是原始的，因此可以触发另一种元方法。）</target>
        </trans-unit>
        <trans-unit id="b37120a70be7b7e2fa099662ff64ecef444b9310" translate="yes" xml:space="preserve">
          <source>Like with indexing, the metavalue for this event can be either a function, a table, or any value with an &lt;code&gt;__newindex&lt;/code&gt; metavalue. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt;, &lt;code&gt;key&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; as arguments. Otherwise, Lua repeats the indexing assignment over this metavalue with the same key and value. This assignment is regular, not raw, and therefore can trigger another &lt;code&gt;__newindex&lt;/code&gt; metavalue.</source>
          <target state="translated">与索引一样，此事件的元值可以是函数，表或具有 &lt;code&gt;__newindex&lt;/code&gt; 元值的任何值。如果它是一个函数，则使用 &lt;code&gt;table&lt;/code&gt; ， &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 作为参数来调用它。否则，Lua将使用相同的键和值对该元值重复索引分配。此分配是常规的，而不是原始的，因此可以触发另一个 &lt;code&gt;__newindex&lt;/code&gt; 元值。</target>
        </trans-unit>
        <trans-unit id="86fb0e6b085882445de9a7a2409c78eb9059df37" translate="yes" xml:space="preserve">
          <source>Literal decimal integer constants that overflow are read as floats, instead of wrapping around. You can use hexadecimal notation for such constants if you want the old behavior (reading them as integers with wrap around).</source>
          <target state="translated">溢出的十进制整数常量会被读取为浮点数,而不是环绕。如果你想保持以前的行为,你可以对这些常量使用十六进制符号(将它们作为整数读取,并进行包围)。</target>
        </trans-unit>
        <trans-unit id="5cf4bcbf4e9a4c997d9f25e1a4ebd39ad823de69" translate="yes" xml:space="preserve">
          <source>Literal strings can also be defined using a long format enclosed by &lt;em&gt;long brackets&lt;/em&gt;. We define an &lt;em&gt;opening long bracket of level &lt;em&gt;n&lt;/em&gt;&lt;/em&gt; as an opening square bracket followed by &lt;em&gt;n&lt;/em&gt; equal signs followed by another opening square bracket. So, an opening long bracket of level 0 is written as &lt;code&gt;[[&lt;/code&gt;, an opening long bracket of level 1 is written as &lt;code&gt;[=[&lt;/code&gt;, and so on. A &lt;em&gt;closing long bracket&lt;/em&gt; is defined similarly; for instance, a closing long bracket of level 4 is written as &lt;code&gt;]====]&lt;/code&gt;. A &lt;em&gt;long literal&lt;/em&gt; starts with an opening long bracket of any level and ends at the first closing long bracket of the same level. It can contain any text except a closing bracket of the same level. Literals in this bracketed form can run for several lines, do not interpret any escape sequences, and ignore long brackets of any other level. Any kind of end-of-line sequence (carriage return, newline, carriage return followed by newline, or newline followed by carriage return) is converted to a simple newline.</source>
          <target state="translated">文字字符串也可以使用&lt;em&gt;长括号&lt;/em&gt;括起来的长格式定义。我们将&lt;em&gt;级别&lt;em&gt;n&lt;/em&gt;&lt;/em&gt;的&lt;em&gt;开头长括号&lt;/em&gt;定义为开头方括号，后跟&lt;em&gt;n个&lt;/em&gt;等号，再跟另一个开头方括号。因此，级别0的左括号被写成 &lt;code&gt;[[&lt;/code&gt; ，级别1的左括号被写成 &lt;code&gt;[=[&lt;/code&gt; ，依此类推。甲&lt;em&gt;长括号&lt;/em&gt;被类似地定义;例如，级别4的右方括号写为 &lt;code&gt;]====]&lt;/code&gt; 。一个&lt;em&gt;长的文字&lt;/em&gt;从任何级别的一个开放的长括号开始，到同级别的第一个封闭的长括号结束。它可以包含除同一级别的右括号之外的任何文本。以方括号括起来的形式的文字可以运行多行，不会解释任何转义序列，并且会忽略任何其他级别的长括号。任何类型的行尾序列（回车，换行，回车后跟换行，或换行后跟回车）都将转换为简单换行。</target>
        </trans-unit>
        <trans-unit id="7806930c3347438897b185e0ff1d0adc3021f8d3" translate="yes" xml:space="preserve">
          <source>Literal strings can also be defined using a long format enclosed by &lt;em&gt;long brackets&lt;/em&gt;. We define an &lt;em&gt;opening long bracket of level &lt;em&gt;n&lt;/em&gt;&lt;/em&gt; as an opening square bracket followed by &lt;em&gt;n&lt;/em&gt; equal signs followed by another opening square bracket. So, an opening long bracket of level 0 is written as &lt;code&gt;[[&lt;/code&gt;, an opening long bracket of level 1 is written as &lt;code&gt;[=[&lt;/code&gt;, and so on. A &lt;em&gt;closing long bracket&lt;/em&gt; is defined similarly; for instance, a closing long bracket of level 4 is written as &lt;code&gt;]====]&lt;/code&gt;. A &lt;em&gt;long literal&lt;/em&gt; starts with an opening long bracket of any level and ends at the first closing long bracket of the same level. It can contain any text except a closing bracket of the same level. Literals in this bracketed form can run for several lines, do not interpret any escape sequences, and ignore long brackets of any other level. Any kind of end-of-line sequence (carriage return, newline, carriage return followed by newline, or newline followed by carriage return) is converted to a simple newline. When the opening long bracket is immediately followed by a newline, the newline is not included in the string.</source>
          <target state="translated">文字字符串也可以使用&lt;em&gt;长括号&lt;/em&gt;括起来的长格式定义。我们将&lt;em&gt;级别&lt;em&gt;n&lt;/em&gt;&lt;/em&gt;的&lt;em&gt;开头长括号&lt;/em&gt;定义为开头方括号，后跟&lt;em&gt;n个&lt;/em&gt;等号，再后面是另一个开头方括号。因此，级别0的左括号被写成 &lt;code&gt;[[&lt;/code&gt; ，级别1的左括号被写成 &lt;code&gt;[=[&lt;/code&gt; ，依此类推。相似地定义了一个&lt;em&gt;长括号&lt;/em&gt;。例如，级别4的右方括号写为 &lt;code&gt;]====]&lt;/code&gt; 。一个&lt;em&gt;长的文字&lt;/em&gt;从任何级别的一个开放的长括号开始，到同级别的第一个封闭的长括号结束。它可以包含除同一级别的右括号之外的任何文本。以方括号括起来的形式的文字可以运行多行，不会解释任何转义序列，并且会忽略任何其他级别的长括号。任何类型的行尾序列（回车，换行，回车后跟换行，或换行后跟回车）都将转换为简单换行。当左方括号后跟换行符时，该换行符将不包含在字符串中。</target>
        </trans-unit>
        <trans-unit id="e1021ae8c4b84ca4a4e3486abedfb8d10587c094" translate="yes" xml:space="preserve">
          <source>Loads a Lua chunk without running it. If there are no errors, &lt;code&gt;lua_load&lt;/code&gt; pushes the compiled chunk as a Lua function on top of the stack. Otherwise, it pushes an error message.</source>
          <target state="translated">加载Lua块而不运行它。如果没有错误， &lt;code&gt;lua_load&lt;/code&gt; 将编译后的块作为Lua函数推入栈顶。否则，它将推送错误消息。</target>
        </trans-unit>
        <trans-unit id="d5d5fd2502388f4bdbfdc40480095cb9940c91fb" translate="yes" xml:space="preserve">
          <source>Loads a buffer as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the buffer pointed to by &lt;code&gt;buff&lt;/code&gt; with size &lt;code&gt;sz&lt;/code&gt;.</source>
          <target state="translated">加载一个缓冲区作为Lua块。该函数使用&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;将块加载到大小为 &lt;code&gt;sz&lt;/code&gt; 的 &lt;code&gt;buff&lt;/code&gt; 指向的缓冲区中。</target>
        </trans-unit>
        <trans-unit id="014ceb5ba979a3f7460e80adaf03760442d4492f" translate="yes" xml:space="preserve">
          <source>Loads a chunk.</source>
          <target state="translated">加载一大块。</target>
        </trans-unit>
        <trans-unit id="8dd06506aefef93d24f715ed25819bedec96323c" translate="yes" xml:space="preserve">
          <source>Loads a file as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the file named &lt;code&gt;filename&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, then it loads from the standard input. The first line in the file is ignored if it starts with a &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">将文件作为Lua块加载。此函数使用&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;将块加载到名为 &lt;code&gt;filename&lt;/code&gt; 的文件中。如果 &lt;code&gt;filename&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; ，那么它将从标准输入加载。如果文件的第一行以 &lt;code&gt;#&lt;/code&gt; 开头，则会被忽略。</target>
        </trans-unit>
        <trans-unit id="f640ebe64a89ecb5b9bd56467fcc7e3fb5298535" translate="yes" xml:space="preserve">
          <source>Loads a string as a Lua chunk. This function uses &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; to load the chunk in the zero-terminated string &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">将字符串作为Lua块加载。此函数使用&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;将块加载到以零结尾的字符串 &lt;code&gt;s&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="601f4f126ff0dc3c88078602ece1575bc60b38da" translate="yes" xml:space="preserve">
          <source>Loads and runs the given file. It is defined as the following macro:</source>
          <target state="translated">加载并运行给定文件。它被定义为以下宏。</target>
        </trans-unit>
        <trans-unit id="41daddb6c30d8daa7aa997ef002e9682aa252572" translate="yes" xml:space="preserve">
          <source>Loads and runs the given string. It is defined as the following macro:</source>
          <target state="translated">加载并运行给定的字符串。它被定义为以下宏。</target>
        </trans-unit>
        <trans-unit id="07953018574342518cc4ef6ce0bb634e54cd3232" translate="yes" xml:space="preserve">
          <source>Loads the given module. The function starts by looking into the &lt;a href=&quot;#pdf-package.loaded&quot;&gt;&lt;code&gt;package.loaded&lt;/code&gt;&lt;/a&gt; table to determine whether &lt;code&gt;modname&lt;/code&gt; is already loaded. If it is, then &lt;code&gt;require&lt;/code&gt; returns the value stored at &lt;code&gt;package.loaded[modname]&lt;/code&gt;. (The absence of a second result in this case signals that this call did not have to load the module.) Otherwise, it tries to find a &lt;em&gt;loader&lt;/em&gt; for the module.</source>
          <target state="translated">加载给定的模块。该函数从查看&lt;a href=&quot;#pdf-package.loaded&quot;&gt; &lt;code&gt;package.loaded&lt;/code&gt; &lt;/a&gt;表开始，以确定是否已加载 &lt;code&gt;modname&lt;/code&gt; 。如果是，则 &lt;code&gt;require&lt;/code&gt; 返回存储在 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 的值。 （在这种情况下，如果没有第二个结果，则表明此调用不必加载模块。）否则，它将尝试为模块找到一个&lt;em&gt;加载器&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="5754e2c7cbb7348e49d26f5b052dec66fe41474e" translate="yes" xml:space="preserve">
          <source>Loads the given module. The function starts by looking into the &lt;a href=&quot;#pdf-package.loaded&quot;&gt;&lt;code&gt;package.loaded&lt;/code&gt;&lt;/a&gt; table to determine whether &lt;code&gt;modname&lt;/code&gt; is already loaded. If it is, then &lt;code&gt;require&lt;/code&gt; returns the value stored at &lt;code&gt;package.loaded[modname]&lt;/code&gt;. Otherwise, it tries to find a &lt;em&gt;loader&lt;/em&gt; for the module.</source>
          <target state="translated">加载给定的模块。该函数从查看&lt;a href=&quot;#pdf-package.loaded&quot;&gt; &lt;code&gt;package.loaded&lt;/code&gt; &lt;/a&gt;表开始，以确定是否已加载 &lt;code&gt;modname&lt;/code&gt; 。如果是，则 &lt;code&gt;require&lt;/code&gt; 返回存储在 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 的值。否则，它将尝试为模块找到&lt;em&gt;装载程序&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="675ad816883ad3050b77c4af165af0c382872da3" translate="yes" xml:space="preserve">
          <source>Local Declarations</source>
          <target state="translated">地方宣言</target>
        </trans-unit>
        <trans-unit id="e74ccb9aead3e3f9b1bc796bf321e14c551c0f2e" translate="yes" xml:space="preserve">
          <source>Local variables can be declared anywhere inside a block. The declaration can include an initial assignment:</source>
          <target state="translated">局部变量可以在块内的任何地方进行声明。声明中可以包含一个初始赋值。</target>
        </trans-unit>
        <trans-unit id="c10d9e4965c7bd64f801ff5a335aa4dea4e1bdf4" translate="yes" xml:space="preserve">
          <source>Local variables can be declared anywhere inside a block. The declaration can include an initialization:</source>
          <target state="translated">局部变量可以在块内的任何地方进行声明。声明中可以包含一个初始化。</target>
        </trans-unit>
        <trans-unit id="65eac6118ebdd55aa38b41f70efdf532e567ffd8" translate="yes" xml:space="preserve">
          <source>Logical Operators</source>
          <target state="translated">逻辑运算符</target>
        </trans-unit>
        <trans-unit id="f3c2c12151d04fbe64aef12442234645ff418818" translate="yes" xml:space="preserve">
          <source>Looks for the first &lt;em&gt;match&lt;/em&gt; of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds one, then &lt;code&gt;match&lt;/code&gt; returns the captures from the pattern; otherwise it returns &lt;b&gt;nil&lt;/b&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is returned. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative.</source>
          <target state="translated">在字符串 &lt;code&gt;s&lt;/code&gt; 中&lt;a href=&quot;#6.4.1&quot;&gt;查找&lt;/a&gt; &lt;code&gt;pattern&lt;/code&gt; 的第一个&lt;em&gt;匹配&lt;/em&gt;项（请参见第6.4.1节）。如果找到一个，则 &lt;code&gt;match&lt;/code&gt; 返回从模式中捕获的内容；否则返回&lt;b&gt;nil&lt;/b&gt;。如果 &lt;code&gt;pattern&lt;/code&gt; 未指定捕获，则返回整个匹配项。第三个可选数字参数 &lt;code&gt;init&lt;/code&gt; 指定从何处开始搜索；其默认值为1，并且可以为负。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8c9988ddc14961cb0c52bb6cea07ce6c02324d47" translate="yes" xml:space="preserve">
          <source>Looks for the first &lt;em&gt;match&lt;/em&gt; of the &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds one, then &lt;code&gt;match&lt;/code&gt; returns the captures from the pattern; otherwise it returns &lt;b&gt;fail&lt;/b&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is returned. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative.</source>
          <target state="translated">在字符串 &lt;code&gt;s&lt;/code&gt; 中&lt;a href=&quot;#6.4.1&quot;&gt;查找&lt;/a&gt; &lt;code&gt;pattern&lt;/code&gt; 的第一个&lt;em&gt;匹配&lt;/em&gt;项（请参见第6.4.1节）。如果找到一个，则 &lt;code&gt;match&lt;/code&gt; 从模式中返回捕获结果；否则，返回结果。否则返回&lt;b&gt;失败&lt;/b&gt;。如果 &lt;code&gt;pattern&lt;/code&gt; 未指定捕获，则返回整个匹配项。第三个可选的数字参数 &lt;code&gt;init&lt;/code&gt; 指定从何处开始搜索；其默认值为1，并且可以为负。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ac72aba64827a6df2b943b8e5302e4719c3c812b" translate="yes" xml:space="preserve">
          <source>Looks for the first match of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds a match, then &lt;code&gt;find&lt;/code&gt; returns the indices of &lt;code&gt;s&lt;/code&gt; where this occurrence starts and ends; otherwise, it returns &lt;b&gt;fail&lt;/b&gt;. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative. A value of &lt;b&gt;true&lt;/b&gt; as a fourth, optional argument &lt;code&gt;plain&lt;/code&gt; turns off the pattern matching facilities, so the function does a plain &quot;find substring&quot; operation, with no characters in &lt;code&gt;pattern&lt;/code&gt; being considered magic.</source>
          <target state="translated">在字符串 &lt;code&gt;s&lt;/code&gt; 中&lt;a href=&quot;#6.4.1&quot;&gt;查找&lt;/a&gt; &lt;code&gt;pattern&lt;/code&gt; 的第一个匹配项（请参见&amp;sect;6.4.1）。如果找到匹配项，则 &lt;code&gt;find&lt;/code&gt; 返回此事件开始和结束的 &lt;code&gt;s&lt;/code&gt; 的索引；否则，它返回&lt;b&gt;fail&lt;/b&gt;。第三个可选的数字参数 &lt;code&gt;init&lt;/code&gt; 指定从何处开始搜索；其默认值为1，并且可以为负。值为&lt;b&gt;true&lt;/b&gt;作为第四个可选参数 &lt;code&gt;plain&lt;/code&gt; 会关闭模式匹配功能，因此该函数会执行普通的&amp;ldquo; find substring&amp;rdquo;操作，而 &lt;code&gt;pattern&lt;/code&gt; 中的任何字符都不会被认为是不可思议的。&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0531dd8559629f728382a45e8fa0141160f819b2" translate="yes" xml:space="preserve">
          <source>Looks for the first match of &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) in the string &lt;code&gt;s&lt;/code&gt;. If it finds a match, then &lt;code&gt;find&lt;/code&gt; returns the indices of &lt;code&gt;s&lt;/code&gt; where this occurrence starts and ends; otherwise, it returns &lt;b&gt;nil&lt;/b&gt;. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative. A value of &lt;b&gt;true&lt;/b&gt; as a fourth, optional argument &lt;code&gt;plain&lt;/code&gt; turns off the pattern matching facilities, so the function does a plain &quot;find substring&quot; operation, with no characters in &lt;code&gt;pattern&lt;/code&gt; being considered magic. Note that if &lt;code&gt;plain&lt;/code&gt; is given, then &lt;code&gt;init&lt;/code&gt; must be given as well.</source>
          <target state="translated">在字符串 &lt;code&gt;s&lt;/code&gt; 中&lt;a href=&quot;#6.4.1&quot;&gt;查找&lt;/a&gt; &lt;code&gt;pattern&lt;/code&gt; 的第一个匹配项（请参见第6.4.1节）。如果找到匹配项，则 &lt;code&gt;find&lt;/code&gt; 返回此事件开始和结束的 &lt;code&gt;s&lt;/code&gt; 的索引；否则，返回&lt;b&gt;nil&lt;/b&gt;。第三个可选的数字参数 &lt;code&gt;init&lt;/code&gt; 指定从何处开始搜索；其默认值为1，并且可以为负。值为&lt;b&gt;true&lt;/b&gt;作为第四个可选参数 &lt;code&gt;plain&lt;/code&gt; 会关闭模式匹配功能，因此该函数执行普通的&amp;ldquo; find substring&amp;rdquo;操作，而 &lt;code&gt;pattern&lt;/code&gt; 中的任何字符都不会被视为魔术。请注意，如果给出 &lt;code&gt;plain&lt;/code&gt; 格式，则&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt; &lt;code&gt;init&lt;/code&gt; 必须给出。</target>
        </trans-unit>
        <trans-unit id="b0832074630eb731d7fbe8074de48a90cd9bb220" translate="yes" xml:space="preserve">
          <source>Lua</source>
          <target state="translated">Lua</target>
        </trans-unit>
        <trans-unit id="74935e355c6d4299b6901e869daba41fae3ae4f2" translate="yes" xml:space="preserve">
          <source>Lua 5.3 Reference Manual</source>
          <target state="translated">Lua 5.3参考手册</target>
        </trans-unit>
        <trans-unit id="1c9ec46a65315e465f99f9adf0e3977cea4a15cf" translate="yes" xml:space="preserve">
          <source>Lua 5.4 Reference Manual</source>
          <target state="translated">Lua 5.4参考手册</target>
        </trans-unit>
        <trans-unit id="e8957a41e15b0eb53aad63ef201700fe8063f094" translate="yes" xml:space="preserve">
          <source>Lua allows multiple assignments. Therefore, the syntax for assignment defines a list of variables on the left side and a list of expressions on the right side. The elements in both lists are separated by commas:</source>
          <target state="translated">Lua允许多次赋值。因此,赋值的语法在左边定义了一个变量列表,在右边定义了一个表达式列表。两个列表中的元素用逗号分隔。</target>
        </trans-unit>
        <trans-unit id="1e02808cd690aaf7df864db5c4c452af196be013" translate="yes" xml:space="preserve">
          <source>Lua also converts strings to numbers, whenever a number is expected.</source>
          <target state="translated">Lua还可以将字符串转换为数字,只要是预期的数字。</target>
        </trans-unit>
        <trans-unit id="93377de262ae6c56472bd1d07591e21435ec1e52" translate="yes" xml:space="preserve">
          <source>Lua also defines the constants &lt;a id=&quot;pdf-LUA_MININTEGER&quot;&gt;&lt;code&gt;LUA_MININTEGER&lt;/code&gt;&lt;/a&gt; and &lt;a id=&quot;pdf-LUA_MAXINTEGER&quot;&gt;&lt;code&gt;LUA_MAXINTEGER&lt;/code&gt;&lt;/a&gt;, with the minimum and the maximum values that fit in this type.</source>
          <target state="translated">Lua还定义了常量&lt;a id=&quot;pdf-LUA_MININTEGER&quot;&gt; &lt;code&gt;LUA_MININTEGER&lt;/code&gt; &lt;/a&gt;和&lt;a id=&quot;pdf-LUA_MAXINTEGER&quot;&gt; &lt;code&gt;LUA_MAXINTEGER&lt;/code&gt; &lt;/a&gt;，并带有适合该类型的最小值和最大值。</target>
        </trans-unit>
        <trans-unit id="801090e92a322f968636387436cbfb91aa33b154" translate="yes" xml:space="preserve">
          <source>Lua also has a &lt;b&gt;for&lt;/b&gt; statement, in two flavors (see &lt;a href=&quot;#3.3.5&quot;&gt;&amp;sect;3.3.5&lt;/a&gt;).</source>
          <target state="translated">Lua也有两种形式的&lt;b&gt;for&lt;/b&gt;语句（请参见&lt;a href=&quot;#3.3.5&quot;&gt;&amp;sect;3.3.5&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b8bd17007ccbbeb2e48374787c45da4db96657dd" translate="yes" xml:space="preserve">
          <source>Lua also offers a system of &lt;em&gt;warnings&lt;/em&gt; (see &lt;a href=&quot;#pdf-warn&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt;). Unlike errors, warnings do not interfere in any way with program execution. They typically only generate a message to the user, although this behavior can be adapted from C (see &lt;a href=&quot;#lua_setwarnf&quot;&gt;&lt;code&gt;lua_setwarnf&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Lua还提供了一个&lt;em&gt;警告&lt;/em&gt;系统（请参阅&lt;a href=&quot;#pdf-warn&quot;&gt; &lt;code&gt;warn&lt;/code&gt; &lt;/a&gt;）。与错误不同，警告不会以任何方式干扰程序的执行。它们通常仅向用户生成一条消息，尽管可以从C修改此行为（请参见&lt;a href=&quot;#lua_setwarnf&quot;&gt; &lt;code&gt;lua_setwarnf&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3da908593ea7c1cd8a16b5d87a2733072f9be916" translate="yes" xml:space="preserve">
          <source>Lua assumes the following behavior from the allocator function:</source>
          <target state="translated">Lua假设分配器函数的行为如下。</target>
        </trans-unit>
        <trans-unit id="ebffede5db745b98cdaa093a245240704c9e96b1" translate="yes" xml:space="preserve">
          <source>Lua can call (and manipulate) functions written in Lua and functions written in C (see &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;). Both are represented by the type &lt;em&gt;function&lt;/em&gt;.</source>
          <target state="translated">Lua可以调用（和操纵）用Lua编写的函数和用C编写的函数（请参见第&lt;a href=&quot;#3.4.10&quot;&gt;3.4.10节&lt;/a&gt;）。两者都由类型&lt;em&gt;函数&lt;/em&gt;表示。</target>
        </trans-unit>
        <trans-unit id="95c6862384367c489829b9fcf5d130d494969aa1" translate="yes" xml:space="preserve">
          <source>Lua code can explicitly generate an error by calling the &lt;a href=&quot;#pdf-error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function. If you need to catch errors in Lua, you can use &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; to call a given function in &lt;em&gt;protected mode&lt;/em&gt;.</source>
          <target state="translated">Lua代码可以通过调用&lt;a href=&quot;#pdf-error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt;函数显式生成错误。如果需要在Lua中捕获错误，则可以使用&lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt;在&lt;em&gt;保护模式下&lt;/em&gt;调用给定的函数。</target>
        </trans-unit>
        <trans-unit id="1dc01b0813afb0e9f0eaf4570d6c6a76184553b6" translate="yes" xml:space="preserve">
          <source>Lua code can explicitly raise an error by calling the &lt;a href=&quot;#pdf-error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; function. (This function never returns.)</source>
          <target state="translated">Lua代码可以通过调用&lt;a href=&quot;#pdf-error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt;函数显式地引发错误。（此函数永不返回。）</target>
        </trans-unit>
        <trans-unit id="1864a075a2790c597421da62110c2e5ddf9a0670" translate="yes" xml:space="preserve">
          <source>Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode with a register-based virtual machine, and has automatic memory management with a generational garbage collection, making it ideal for configuration, scripting, and rapid prototyping.</source>
          <target state="translated">Lua将简单的程序语法与强大的基于关联数组和可扩展语义的数据描述结构相结合。Lua是动态类型化的,通过解释字节码与基于寄存器的虚拟机运行,并具有自动内存管理与代际垃圾收集功能,使其成为配置、脚本和快速原型设计的理想选择。</target>
        </trans-unit>
        <trans-unit id="55000944726bac35e3a7a8c2c659ce8ea827ae88" translate="yes" xml:space="preserve">
          <source>Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode with a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.</source>
          <target state="translated">Lua将简单的程序语法与基于关联数组和可扩展语义的强大数据描述结构相结合。Lua是动态类型化的,通过基于寄存器的虚拟机解释字节码来运行,并且具有增量垃圾收集的自动内存管理功能,使其成为配置、脚本和快速原型开发的理想选择。</target>
        </trans-unit>
        <trans-unit id="8c26f824cf75010655e9550b8fde705425a3784c" translate="yes" xml:space="preserve">
          <source>Lua does not check the consistency of binary chunks. Maliciously crafted binary chunks can crash the interpreter.</source>
          <target state="translated">Lua不检查二进制块的一致性。恶意制作的二进制块会使解释器崩溃。</target>
        </trans-unit>
        <trans-unit id="1a5e8dc647ce5f791a0e6cc5be4cbed5172328da" translate="yes" xml:space="preserve">
          <source>Lua handles a chunk as the body of an anonymous function with a variable number of arguments (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;). As such, chunks can define local variables, receive arguments, and return values. Moreover, such anonymous function is compiled as in the scope of an external local variable called &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). The resulting function always has &lt;code&gt;_ENV&lt;/code&gt; as its only external variable, even if it does not use that variable.</source>
          <target state="translated">Lua将块作为具有可变数量参数的匿名函数的主体来处理（请参见第&lt;a href=&quot;#3.4.11&quot;&gt;3.4.11节&lt;/a&gt;）。这样，块可以定义局部变量，接收参数和返回值。而且，这种匿名函数的编译方式在称为 &lt;code&gt;_ENV&lt;/code&gt; 的外部局部变量的范围内（请参见&lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;）。结果函数始终将 &lt;code&gt;_ENV&lt;/code&gt; 作为其唯一的外部变量，即使它不使用该变量也是如此。</target>
        </trans-unit>
        <trans-unit id="35b65ab36f2f47f5954bb270f0f9be36cfe1a6ba" translate="yes" xml:space="preserve">
          <source>Lua handles a chunk as the body of an anonymous function with a variable number of arguments (see &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;). As such, chunks can define local variables, receive arguments, and return values. Moreover, such anonymous function is compiled as in the scope of an external local variable called &lt;code&gt;_ENV&lt;/code&gt; (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). The resulting function always has &lt;code&gt;_ENV&lt;/code&gt; as its only upvalue, even if it does not use that variable.</source>
          <target state="translated">Lua将块作为具有可变数量参数的匿名函数的主体来处理（请参见第&lt;a href=&quot;#3.4.11&quot;&gt;3.4.11节&lt;/a&gt;）。这样，块可以定义局部变量，接收参数和返回值。而且，此类匿名函数的编译方式在称为 &lt;code&gt;_ENV&lt;/code&gt; 的外部局部变量的范围内（请参见&lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;）。结果函数始终将 &lt;code&gt;_ENV&lt;/code&gt; 作为其唯一的升值，即使它不使用该变量也是如此。</target>
        </trans-unit>
        <trans-unit id="7bb5694782dd5240f5a360755736e520cb7caddd" translate="yes" xml:space="preserve">
          <source>Lua has &lt;em&gt;empty statements&lt;/em&gt; that allow you to separate statements with semicolons, start a block with a semicolon or write two semicolons in sequence:</source>
          <target state="translated">Lua &lt;em&gt;有空的语句&lt;/em&gt;，可让您用分号分隔语句，以分号开头的块或依次编写两个分号：</target>
        </trans-unit>
        <trans-unit id="3e19bed5c0654df07eeefc8d0dbcff0cc7fb976e" translate="yes" xml:space="preserve">
          <source>Lua has explicit rules about when each subtype is used, but it also converts between them automatically as needed (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;). Therefore, the programmer may choose to mostly ignore the difference between integers and floats or to assume complete control over the representation of each number.</source>
          <target state="translated">Lua有关于何时使用每个子类型的明确规则，但是它也会根据需要在它们之间自动转换（请参见第&lt;a href=&quot;#3.4.3&quot;&gt;3.4.3节&lt;/a&gt;）。因此，程序员可以选择忽略整数和浮点数之间的差异，或者选择完全控制每个数字的表示形式。</target>
        </trans-unit>
        <trans-unit id="08b67a26f91c4bb6ecbeaabc79499925202576c4" translate="yes" xml:space="preserve">
          <source>Lua has no built-in debugging facilities. Instead, it offers a special interface by means of functions and &lt;em&gt;hooks&lt;/em&gt;. This interface allows the construction of different kinds of debuggers, profilers, and other tools that need &quot;inside information&quot; from the interpreter.</source>
          <target state="translated">Lua没有内置的调试工具。相反，它通过功能和&lt;em&gt;钩子&lt;/em&gt;提供了特殊的接口。该接口允许构造各种类型的调试器，分析器和其他需要解释器&amp;ldquo;内部信息&amp;rdquo;的工具。</target>
        </trans-unit>
        <trans-unit id="ab53ba5d8b707a086c1f55306a5e491b7ca0c834" translate="yes" xml:space="preserve">
          <source>Lua implements an incremental mark-and-sweep collector. It uses two numbers to control its garbage-collection cycles: the &lt;em&gt;garbage-collector pause&lt;/em&gt; and the &lt;em&gt;garbage-collector step multiplier&lt;/em&gt;. Both use percentage points as units (e.g., a value of 100 means an internal value of 1).</source>
          <target state="translated">Lua实现了增量标记和清除收集器。它使用两个数字来控制其垃圾收集周期：&lt;em&gt;垃圾收集器暂停&lt;/em&gt;和&lt;em&gt;垃圾收集器步骤乘数&lt;/em&gt;。两者均以百分比为单位（例如，值100表示​​内部值为1）。</target>
        </trans-unit>
        <trans-unit id="ad855bd45416f0333645541d1257309374015262" translate="yes" xml:space="preserve">
          <source>Lua initializes its pseudo-random generator with the equivalent of a call to &lt;a href=&quot;#pdf-math.randomseed&quot;&gt;&lt;code&gt;math.randomseed&lt;/code&gt;&lt;/a&gt; with no arguments, so that &lt;code&gt;math.random&lt;/code&gt; should generate different sequences of results each time the program runs.</source>
          <target state="translated">Lua的伪随机生成器初始化为没有参数的对&lt;a href=&quot;#pdf-math.randomseed&quot;&gt; &lt;code&gt;math.randomseed&lt;/code&gt; &lt;/a&gt;的调用，因此每次程序运行时 &lt;code&gt;math.random&lt;/code&gt; 都应生成不同的结果序列。</target>
        </trans-unit>
        <trans-unit id="4be60237bd80620e268374029f3211e510b05c17" translate="yes" xml:space="preserve">
          <source>Lua initializes the C path &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; in the same way it initializes the Lua path &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;, using the environment variable &lt;a id=&quot;pdf-LUA_CPATH_5_3&quot;&gt;&lt;code&gt;LUA_CPATH_5_3&lt;/code&gt;&lt;/a&gt;, or the environment variable &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt;&lt;code&gt;LUA_CPATH&lt;/code&gt;&lt;/a&gt;, or a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">Lua 使用环境变量&lt;a id=&quot;pdf-LUA_CPATH_5_3&quot;&gt; &lt;code&gt;LUA_CPATH_5_3&lt;/code&gt; &lt;/a&gt;或环境变量&lt;a id=&quot;pdf-LUA_CPATH&quot;&gt; &lt;code&gt;LUA_CPATH&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;luaconf.h&lt;/code&gt; 中定义的默认路径，以与初始化Lua path &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt;相同的方式初始化C路径&lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9dd87e2bc11c5d748dd2ecd3b8a3e7dcc5b9ccfa" translate="yes" xml:space="preserve">
          <source>Lua initializes the C path &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; in the same way it initializes the Lua path &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;, using the environment variable &lt;a id=&quot;pdf-LUA_CPATH_5_4&quot;&gt;&lt;code&gt;LUA_CPATH_5_4&lt;/code&gt;&lt;/a&gt;, or the environment variable &lt;a id=&quot;pdf-LUA_CPATH&quot;&gt;&lt;code&gt;LUA_CPATH&lt;/code&gt;&lt;/a&gt;, or a default path defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">Lua使用环境变量&lt;a id=&quot;pdf-LUA_CPATH_5_4&quot;&gt; &lt;code&gt;LUA_CPATH_5_4&lt;/code&gt; &lt;/a&gt;或环境变量&lt;a id=&quot;pdf-LUA_CPATH&quot;&gt; &lt;code&gt;LUA_CPATH&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;luaconf.h&lt;/code&gt; 中定义的默认路径，以与初始化Lua path &lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt;相同的方式初始化C路径&lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4714009f33265bf1fc4688da888d62c97c45d7b7" translate="yes" xml:space="preserve">
          <source>Lua initializes this table with four searcher functions.</source>
          <target state="translated">Lua用四个搜索器函数初始化这个表。</target>
        </trans-unit>
        <trans-unit id="ef9edf704545b26dfa394b151700f2e58198d961" translate="yes" xml:space="preserve">
          <source>Lua is a &lt;em&gt;dynamically typed language&lt;/em&gt;. This means that variables do not have types; only values do. There are no type definitions in the language. All values carry their own type.</source>
          <target state="translated">Lua是一种&lt;em&gt;动态类型的语言&lt;/em&gt;。这意味着变量没有类型。只有价值观。语言中没有类型定义。所有值都带有自己的类型。</target>
        </trans-unit>
        <trans-unit id="768b1dfa86b0332cedc5bdb9fcc8e17166f9ef47" translate="yes" xml:space="preserve">
          <source>Lua is a case-sensitive language: &lt;code&gt;and&lt;/code&gt; is a reserved word, but &lt;code&gt;And&lt;/code&gt; and &lt;code&gt;AND&lt;/code&gt; are two different, valid names. As a convention, programs should avoid creating names that start with an underscore followed by one or more uppercase letters (such as &lt;a href=&quot;#pdf-_VERSION&quot;&gt;&lt;code&gt;_VERSION&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Lua是区分大小写的语言： &lt;code&gt;and&lt;/code&gt; 是保留词，但是 &lt;code&gt;And&lt;/code&gt; 和 &lt;code&gt;AND&lt;/code&gt; 是两个不同的有效名称。按照惯例，程序应避免创建以下划线开头，后跟一个或多个大写字母（例如&lt;a href=&quot;#pdf-_VERSION&quot;&gt; &lt;code&gt;_VERSION&lt;/code&gt; &lt;/a&gt;）的名称。</target>
        </trans-unit>
        <trans-unit id="14462b481cdd16dd35942cf7ea65c476fc81dc92" translate="yes" xml:space="preserve">
          <source>Lua is a dynamically typed language. This means that variables do not have types; only values do. There are no type definitions in the language. All values carry their own type.</source>
          <target state="translated">Lua是一种动态类型的语言。这意味着变量没有类型,只有值有。语言中没有类型定义。所有的值都有自己的类型。</target>
        </trans-unit>
        <trans-unit id="5747aeb4d5eff65fa7549c62e63b2802c05d28fa" translate="yes" xml:space="preserve">
          <source>Lua is a free-form language. It ignores spaces (including new lines) and comments between lexical elements (tokens), except as delimiters between names and keywords.</source>
          <target state="translated">Lua是一种自由形式的语言。它忽略了空格(包括新行)和词素(标记)之间的注释,除了作为名称和关键字之间的定界符。</target>
        </trans-unit>
        <trans-unit id="d6fc1e0827574e83666a7aeb884cd5cd48ccb329" translate="yes" xml:space="preserve">
          <source>Lua is a free-form language. It ignores spaces and comments between lexical elements (tokens), except as delimiters between two tokens. In source code, Lua recognizes as spaces the standard ASCII whitespace characters space, form feed, newline, carriage return, horizontal tab, and vertical tab.</source>
          <target state="translated">Lua是一种自由形式的语言。它忽略了词素(标记)之间的空格和注释,除了作为两个标记之间的定界符。在源代码中,Lua将标准的ASCII空格字符空格、换行、换行、回车、水平制表符和垂直制表符识别为空格。</target>
        </trans-unit>
        <trans-unit id="10cf3931978ad3da8f2a0c2e42a3bc57db1befcb" translate="yes" xml:space="preserve">
          <source>Lua is a lexically scoped language. The scope of a local variable begins at the first statement after its declaration and lasts until the last non-void statement of the innermost block that includes the declaration. Consider the following example:</source>
          <target state="translated">Lua是一种词法范围的语言。局部变量的作用域从其声明后的第一条语句开始,一直到包含声明的最内部块的最后一条非void语句为止。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="64997c71b569a923ad45e14df6ef4a0a98b01aef" translate="yes" xml:space="preserve">
          <source>Lua is a powerful, efficient, lightweight, embeddable scripting language. It supports procedural programming, object-oriented programming, functional programming, data-driven programming, and data description.</source>
          <target state="translated">Lua是一种强大、高效、轻量级、可嵌入的脚本语言。它支持程序化编程、面向对象编程、函数式编程、数据驱动编程和数据描述。</target>
        </trans-unit>
        <trans-unit id="6525b86788861e011c88cf07f7294dd56f02830d" translate="yes" xml:space="preserve">
          <source>Lua is free software, and is provided as usual with no guarantees, as stated in its license. The implementation described in this manual is available at Lua's official web site, &lt;code&gt;www.lua.org&lt;/code&gt;.</source>
          <target state="translated">Lua是免费软件，并且照其许可证中所述，照常提供且不作任何保证。可在Lua的官方网站 &lt;code&gt;www.lua.org&lt;/code&gt; 上获得本手册中描述的实现。</target>
        </trans-unit>
        <trans-unit id="bf89f8ce15263309be1a18939b1bc8b312081d0b" translate="yes" xml:space="preserve">
          <source>Lua is implemented as a library, written in &lt;em&gt;clean C&lt;/em&gt;, the common subset of Standard C and C++. The Lua distribution includes a host program called &lt;code&gt;lua&lt;/code&gt;, which uses the Lua library to offer a complete, standalone Lua interpreter, for interactive or batch use. Lua is intended to be used both as a powerful, lightweight, embeddable scripting language for any program that needs one, and as a powerful but lightweight and efficient stand-alone language.</source>
          <target state="translated">Lua被实现为一个库，它用标准C和C ++的通用子集&lt;em&gt;clean C&lt;/em&gt;编写。Lua发行版包含一个名为 &lt;code&gt;lua&lt;/code&gt; 的主机程序，该程序使用Lua库提供用于交互或批处理使用的完整的独立Lua解释器。Lua既可用作功能强大，轻量级，可嵌入的脚本语言，用于需要一个程序的任何程序，也可用作功能强大但轻量级且高效的独立语言。</target>
        </trans-unit>
        <trans-unit id="d706bcd1ff8f8bec50ed4b63b5fce0e2915787d3" translate="yes" xml:space="preserve">
          <source>Lua keeps a distinguished environment called the &lt;em&gt;global environment&lt;/em&gt;. This value is kept at a special index in the C registry (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;). In Lua, the global variable &lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is initialized with this same value. (&lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is never used internally, so changing its value will affect only your own code.)</source>
          <target state="translated">Lua保留着一个称为&lt;em&gt;全球环境&lt;/em&gt;的杰出&lt;em&gt;环境&lt;/em&gt;。此值保存在C注册表中的特殊索引处（请参见&lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;）。在Lua中，全局变量&lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt;初始化为相同的值。（&lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt;从未在内部使用，因此更改其值只会影响您自己的代码。）</target>
        </trans-unit>
        <trans-unit id="766bf2f3607b0c894574e1db0930518cd452197d" translate="yes" xml:space="preserve">
          <source>Lua keeps a distinguished environment called the &lt;em&gt;global environment&lt;/em&gt;. This value is kept at a special index in the C registry (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). In Lua, the global variable &lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is initialized with this same value. (&lt;a href=&quot;#pdf-_G&quot;&gt;&lt;code&gt;_G&lt;/code&gt;&lt;/a&gt; is never used internally.)</source>
          <target state="translated">Lua保留着一个称为&lt;em&gt;全球环境&lt;/em&gt;的杰出&lt;em&gt;环境&lt;/em&gt;。该值保存在C注册表中的特殊索引处（请参阅第&lt;a href=&quot;#4.5&quot;&gt;4.5节&lt;/a&gt;）。在Lua中，全局变量&lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt;使用相同的值初始化。（&lt;a href=&quot;#pdf-_G&quot;&gt; &lt;code&gt;_G&lt;/code&gt; &lt;/a&gt;从未在内部使用。）</target>
        </trans-unit>
        <trans-unit id="50a6344d2469ab6de8e8a3709a57a990d508f2b9" translate="yes" xml:space="preserve">
          <source>Lua performs automatic memory management. This means that you do not have to worry about allocating memory for new objects or freeing it when the objects are no longer needed. Lua manages memory automatically by running a &lt;em&gt;garbage collector&lt;/em&gt; to collect all &lt;em&gt;dead objects&lt;/em&gt; (that is, objects that are no longer accessible from Lua). All memory used by Lua is subject to automatic management: strings, tables, userdata, functions, threads, internal structures, etc.</source>
          <target state="translated">Lua执行自动内存管理。这意味着您不必担心为新对象分配内存或在不再需要对象时释放内存。 Lua通过运行&lt;em&gt;垃圾收集器&lt;/em&gt;来收集所有&lt;em&gt;死对象&lt;/em&gt;（即不再可以从Lua访问的对象）来自动管理内存。 Lua使用的所有内存均受自动管理：字符串，表，用户数据，函数，线程，内部结构等。</target>
        </trans-unit>
        <trans-unit id="a37183d7def474e8ad0a40034770f88144395901" translate="yes" xml:space="preserve">
          <source>Lua performs automatic memory management. This means that you do not have to worry about allocating memory for new objects or freeing it when the objects are no longer needed. Lua manages memory automatically by running a &lt;em&gt;garbage collector&lt;/em&gt; to collect all &lt;em&gt;dead&lt;/em&gt; objects. All memory used by Lua is subject to automatic management: strings, tables, userdata, functions, threads, internal structures, etc.</source>
          <target state="translated">Lua执行自动内存管理。这意味着您不必担心为新对象分配内存或在不再需要对象时释放内存。Lua通过运行&lt;em&gt;垃圾收集器&lt;/em&gt;来收集所有&lt;em&gt;失效&lt;/em&gt;对象，从而自动管理内存。Lua使用的所有内存均受自动管理：字符串，表，用户数据，函数，线程，内部结构等。</target>
        </trans-unit>
        <trans-unit id="304c36d43ad643a3a401b38816464fd6feff69ef" translate="yes" xml:space="preserve">
          <source>Lua provides a &lt;em&gt;registry&lt;/em&gt;, a predefined table that can be used by any C code to store whatever Lua values it needs to store. The registry table is always accessible at pseudo-index &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt;&lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt;&lt;/a&gt;. Any C library can store data into this table, but it must take care to choose keys that are different from those used by other libraries, to avoid collisions. Typically, you should use as key a string containing your library name, or a light userdata with the address of a C object in your code, or any Lua object created by your code. As with variable names, string keys starting with an underscore followed by uppercase letters are reserved for Lua.</source>
          <target state="translated">Lua提供了一个&lt;em&gt;注册表&lt;/em&gt;，一个预定义的表，任何C代码都可以使用该表来存储需要存储的Lua值。注册表始终可通过伪索引&lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt; &lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt; 访问&lt;/a&gt;。任何C库都可以将数据存储到该表中，但是必须小心选择与其他库所使用的键不同的键，以避免发生冲突。通常，您应该使用包含库名称的字符串，包含代码中C对象地址的轻量用户数据或由代码创建的任何Lua对象作为键。与变量名一样，Lua保留以下划线开头，后跟大写字母的字符串键。</target>
        </trans-unit>
        <trans-unit id="ff53c69b14f5a971156b01cea314fe8462f1fb40" translate="yes" xml:space="preserve">
          <source>Lua provides a &lt;em&gt;registry&lt;/em&gt;, a predefined table that can be used by any C code to store whatever Lua values it needs to store. The registry table is always located at pseudo-index &lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt;&lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt;&lt;/a&gt;. Any C library can store data into this table, but it must take care to choose keys that are different from those used by other libraries, to avoid collisions. Typically, you should use as key a string containing your library name, or a light userdata with the address of a C object in your code, or any Lua object created by your code. As with variable names, string keys starting with an underscore followed by uppercase letters are reserved for Lua.</source>
          <target state="translated">Lua提供了一个&lt;em&gt;注册表&lt;/em&gt;，一个预定义的表，任何C代码都可以使用该表来存储需要存储的Lua值。注册表表始终位于伪索引&lt;a id=&quot;pdf-LUA_REGISTRYINDEX&quot;&gt; &lt;code&gt;LUA_REGISTRYINDEX&lt;/code&gt; &lt;/a&gt;。任何C库都可以将数据存储到该表中，但是必须小心选择与其他库所使用的键不同的键，以避免冲突。通常，您应该使用包含库名称的字符串，包含代码中C对象的地址的轻量用户数据或由代码创建的任何Lua对象作为键。与变量名一样，Lua保留以下划线开头，大写字母开头的字符串键。</target>
        </trans-unit>
        <trans-unit id="c7ec27426739f62c59f6fb19adc0cf4fd8e79bdf" translate="yes" xml:space="preserve">
          <source>Lua provides some automatic conversions between some types and representations at run time. Bitwise operators always convert float operands to integers. Exponentiation and float division always convert integer operands to floats. All other arithmetic operations applied to mixed numbers (integers and floats) convert the integer operand to a float. The C API also converts both integers to floats and floats to integers, as needed. Moreover, string concatenation accepts numbers as arguments, besides strings.</source>
          <target state="translated">Lua在运行时提供了一些类型和表示方法之间的自动转换。位运算符总是将浮动操作数转换为整数。指数和浮点数除法总是将整数操作数转换为浮点数。所有其他应用于混合数(整数和浮点数)的算术运算都会将整数操作数转换为浮点数。C API还可以根据需要将整数转换为浮点数,将浮点数转换为整数。此外,字符串连接除了字符串外,还接受数字作为参数。</target>
        </trans-unit>
        <trans-unit id="8aebea72c222a51d9f5c90460286acb8ff7bd836" translate="yes" xml:space="preserve">
          <source>Lua provides some automatic conversions between some types and representations at run time. Bitwise operators always convert float operands to integers. Exponentiation and float division always convert integer operands to floats. All other arithmetic operations applied to mixed numbers (integers and floats) convert the integer operand to a float; this is called the &lt;em&gt;usual rule&lt;/em&gt;. The C API also converts both integers to floats and floats to integers, as needed. Moreover, string concatenation accepts numbers as arguments, besides strings.</source>
          <target state="translated">Lua在运行时提供了一些类型和表示形式之间的自动转换。按位运算符始终将浮点操作数转换为整数。求幂和浮点除法始终将整数操作数转换为浮点数。应用于整数（整数和浮点数）的所有其他算术运算将整数操作数转换为浮点数；这就是&lt;em&gt;通常的规则&lt;/em&gt;。 C API还根据需要将两个整数都转换为浮点数，并将浮点数转换为整数。此外，字符串串联除字符串外，还接受数字作为参数。</target>
        </trans-unit>
        <trans-unit id="fc88527d32d4eef52fab883602cc5a04e027d076" translate="yes" xml:space="preserve">
          <source>Lua supports an almost conventional set of statements, similar to those in Pascal or C. This set includes assignments, control structures, function calls, and variable declarations.</source>
          <target state="translated">Lua支持几乎传统的语句集,类似于Pascal或C语言中的语句,这套语句集包括赋值、控制结构、函数调用和变量声明。</target>
        </trans-unit>
        <trans-unit id="91dafa2daf60652dca7a18b91e3e12584dce5ecb" translate="yes" xml:space="preserve">
          <source>Lua supports an almost conventional set of statements, similar to those in other conventional languages. This set includes blocks, assignments, control structures, function calls, and variable declarations.</source>
          <target state="translated">Lua支持几乎常规的语句集,类似于其他常规语言中的语句集。这套语句包括块、赋值、控制结构、函数调用和变量声明。</target>
        </trans-unit>
        <trans-unit id="d24c360e7097470e8a9eb4284ea5f5a81791560b" translate="yes" xml:space="preserve">
          <source>Lua supports coroutines, also called &lt;em&gt;collaborative multithreading&lt;/em&gt;. A coroutine in Lua represents an independent thread of execution. Unlike threads in multithread systems, however, a coroutine only suspends its execution by explicitly calling a yield function.</source>
          <target state="translated">Lua支持协程，也称为&lt;em&gt;协作多线程&lt;/em&gt;。Lua中的协程代表独立的执行线程。但是，与多线程系统中的线程不同，协程仅通过显式调用yield函数来挂起其执行。</target>
        </trans-unit>
        <trans-unit id="3591c85e3de8f7bdc4a45d500a8261a9e6ec09be" translate="yes" xml:space="preserve">
          <source>Lua supports the following arithmetic operators:</source>
          <target state="translated">Lua支持以下算术运算符。</target>
        </trans-unit>
        <trans-unit id="f0e5bf2dcec5e267f3660839f8aee19d34a65569" translate="yes" xml:space="preserve">
          <source>Lua supports the following bitwise operators:</source>
          <target state="translated">Lua支持以下位运算符。</target>
        </trans-unit>
        <trans-unit id="681beb7c86ad47856fd70c3b7329189c44c67f13" translate="yes" xml:space="preserve">
          <source>Lua supports the following relational operators:</source>
          <target state="translated">Lua支持以下关系运算符。</target>
        </trans-unit>
        <trans-unit id="ea7647f42e558dda5334904038fac1e7ced0aeee" translate="yes" xml:space="preserve">
          <source>Lua treats the continuation function as if it were the original function. The continuation function receives the same Lua stack from the original function, in the same state it would be if the callee function had returned. (For instance, after a &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; the function and its arguments are removed from the stack and replaced by the results from the call.) It also has the same upvalues. Whatever it returns is handled by Lua as if it were the return of the original function.</source>
          <target state="translated">Lua将继续功能视为原始功能。连续函数从原始函数接收相同的Lua堆栈，处于与被调用函数已返回的状态相同的状态。（例如，在&lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; 之后,&lt;/a&gt;该函数及其参数从堆栈中删除，并由调用的结果替换。）它也具有相同的升值。它返回的所有内容都由Lua处理，就好像它是原始函数的返回一样。</target>
        </trans-unit>
        <trans-unit id="8d18554a7115d65153a0cecb32181cd5cd13b803" translate="yes" xml:space="preserve">
          <source>Lua uses a &lt;em&gt;virtual stack&lt;/em&gt; to pass values to and from C. Each element in this stack represents a Lua value (&lt;b&gt;nil&lt;/b&gt;, number, string, etc.). Functions in the API can access this stack through the Lua state parameter that they receive.</source>
          <target state="translated">Lua使用&lt;em&gt;虚拟堆栈&lt;/em&gt;将值传递给C和从C传递值。此堆栈中的每个元素代表一个Lua值（&lt;b&gt;nil&lt;/b&gt;，数字，字符串等）。API中的函数可以通过收到的Lua状态参数访问此堆栈。</target>
        </trans-unit>
        <trans-unit id="9ab5b312f28e26ecbcf6e086d97bd76369eeeb34" translate="yes" xml:space="preserve">
          <source>Lua versions can always change the C API in ways that do not imply source-code changes in a program, such as the numeric values for constants or the implementation of functions as macros. Therefore, you should never assume that binaries are compatible between different Lua versions. Always recompile clients of the Lua API when using a new version.</source>
          <target state="translated">Lua版本总是可以改变C API的方式,但并不意味着程序中源代码的改变,例如常量的数值或作为宏的函数的实现。因此,您永远不应该假设二进制文件在不同的Lua版本之间是兼容的。当使用新版本时,一定要重新编译Lua API的客户端。</target>
        </trans-unit>
        <trans-unit id="225017af8d199117d297936391565191b16afd75" translate="yes" xml:space="preserve">
          <source>Lua versions can always change the C API in ways that do not imply source-code changes in a program, such as the numeric values for constants or the implementation of functions as macros. Therefore, you should not assume that binaries are compatible between different Lua versions. Always recompile clients of the Lua API when using a new version.</source>
          <target state="translated">Lua版本总是可以改变C API的方式,而不意味着程序中源代码的改变,例如常量的数值或函数作为宏的实现。因此,你不应该假设二进制文件在不同的Lua版本之间是兼容的。当使用新版本时,请务必重新编译Lua API的客户端。</target>
        </trans-unit>
        <trans-unit id="d9819702e70f7dce9f1483706cfae2f70bcb9e32" translate="yes" xml:space="preserve">
          <source>Macros to project non-default integer types (&lt;code&gt;luaL_checkint&lt;/code&gt;, &lt;code&gt;luaL_optint&lt;/code&gt;, &lt;code&gt;luaL_checklong&lt;/code&gt;, &lt;code&gt;luaL_optlong&lt;/code&gt;) were deprecated. Use their equivalent over &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt; with a type cast (or, when possible, use &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt; in your code).</source>
          <target state="translated">不建议使用用于投影非默认整数类型（ &lt;code&gt;luaL_checkint&lt;/code&gt; ， &lt;code&gt;luaL_optint&lt;/code&gt; ， &lt;code&gt;luaL_checklong&lt;/code&gt; ， &lt;code&gt;luaL_optlong&lt;/code&gt; ）的宏。在类型转换上对&lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt;使用它们的等效项（或者，如果可能，在代码中使用&lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b77ee37c1b7bd6807618cb75d302c1c6fbf5df15" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;n1&lt;/code&gt;-th upvalue of the Lua closure &lt;code&gt;f1&lt;/code&gt; refer to the &lt;code&gt;n2&lt;/code&gt;-th upvalue of the Lua closure &lt;code&gt;f2&lt;/code&gt;.</source>
          <target state="translated">使Lua闭包 &lt;code&gt;f1&lt;/code&gt; 的第 &lt;code&gt;n1&lt;/code&gt; 个上值参考Lua闭包 &lt;code&gt;f2&lt;/code&gt; 的第 &lt;code&gt;n2&lt;/code&gt; 个上值。</target>
        </trans-unit>
        <trans-unit id="62787e3133e3f8c1540f23ea948a696e338e2fa1" translate="yes" xml:space="preserve">
          <source>Make the &lt;code&gt;n1&lt;/code&gt;-th upvalue of the Lua closure at index &lt;code&gt;funcindex1&lt;/code&gt; refer to the &lt;code&gt;n2&lt;/code&gt;-th upvalue of the Lua closure at index &lt;code&gt;funcindex2&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;n1&lt;/code&gt; 在指数的Lua封个的upvalue &lt;code&gt;funcindex1&lt;/code&gt; 指的是 &lt;code&gt;n2&lt;/code&gt; 的Lua的封个的upvalue在指数 &lt;code&gt;funcindex2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f45634619c3458c08eba16dfa423d4f5456e189b" translate="yes" xml:space="preserve">
          <source>Marks the given index in the stack as a to-be-closed &quot;variable&quot; (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;). Like a to-be-closed variable in Lua, the value at that index in the stack will be closed when it goes out of scope. Here, in the context of a C function, to go out of scope means that the running function returns to Lua, there is an error, or the index is removed from the stack through &lt;a href=&quot;#lua_settop&quot;&gt;&lt;code&gt;lua_settop&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pop&quot;&gt;&lt;code&gt;lua_pop&lt;/code&gt;&lt;/a&gt;. An index marked as to-be-closed should not be removed from the stack by any other function in the API except &lt;a href=&quot;#lua_settop&quot;&gt;&lt;code&gt;lua_settop&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pop&quot;&gt;&lt;code&gt;lua_pop&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">将堆栈中的给定索引标记为要关闭的&amp;ldquo;变量&amp;rdquo;（请参见&lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;）。就像Lua中将要关闭的变量一样，当超出范围时，堆栈中该索引处的值将被关闭。在这里，在C函数的上下文中，超出范围意味着正在运行的函数返回Lua，出现错误，或者通过&lt;a href=&quot;#lua_settop&quot;&gt; &lt;code&gt;lua_settop&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#lua_pop&quot;&gt; &lt;code&gt;lua_pop&lt;/code&gt; &lt;/a&gt;从堆栈中删除了索引。除了&lt;a href=&quot;#lua_settop&quot;&gt; &lt;code&gt;lua_settop&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#lua_pop&quot;&gt; &lt;code&gt;lua_pop&lt;/code&gt; &lt;/a&gt;之外，API中的任何其他函数都不应从堆栈中删除标记为要关闭的索引。</target>
        </trans-unit>
        <trans-unit id="e0580c95da4f3ceb84abf5c18ee164021809ea4c" translate="yes" xml:space="preserve">
          <source>Metatables and Metamethods</source>
          <target state="translated">元数据表和元方法</target>
        </trans-unit>
        <trans-unit id="4feff686bfbdf59cf154d1294db67c187b9f7489" translate="yes" xml:space="preserve">
          <source>Modulo is defined as the remainder of a division that rounds the quotient towards minus infinity (floor division).</source>
          <target state="translated">模数的定义是将商四舍五入到负无穷大的除法的余数(底数除法)。</target>
        </trans-unit>
        <trans-unit id="71e2b3ce8af16f1677267e51894cb5b57ee61429" translate="yes" xml:space="preserve">
          <source>Moreover, with a &lt;code&gt;count&lt;/code&gt; different from zero, the hook is called also after every &lt;code&gt;count&lt;/code&gt; instructions.</source>
          <target state="translated">而且，如果 &lt;code&gt;count&lt;/code&gt; 不为零，则在每个 &lt;code&gt;count&lt;/code&gt; 指令之后也会调用该挂钩。</target>
        </trans-unit>
        <trans-unit id="68a5432576b0a8367df52ec04ef603f754149162" translate="yes" xml:space="preserve">
          <source>Most functions in the API can raise an error, for instance due to a memory allocation error. The documentation for each function indicates whether it can raise errors.</source>
          <target state="translated">API中的大多数函数都可能引发错误,例如由于内存分配错误。每个函数的文档都会指出它是否会引发错误。</target>
        </trans-unit>
        <trans-unit id="211349efeacad71bfc6580d063e630f7c7ac8b51" translate="yes" xml:space="preserve">
          <source>Moves elements from table &lt;code&gt;a1&lt;/code&gt; to table &lt;code&gt;a2&lt;/code&gt;, performing the equivalent to the following multiple assignment: &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt;. The default for &lt;code&gt;a2&lt;/code&gt; is &lt;code&gt;a1&lt;/code&gt;. The destination range can overlap with the source range. The number of elements to be moved must fit in a Lua integer.</source>
          <target state="translated">将元素从表 &lt;code&gt;a1&lt;/code&gt; 移动到表 &lt;code&gt;a2&lt;/code&gt; ，执行与以下多重分配等效的操作： &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt; 。 &lt;code&gt;a2&lt;/code&gt; 的默认值为 &lt;code&gt;a1&lt;/code&gt; 。目标范围可以与源范围重叠。要移动的元素数必须适合Lua整数。</target>
        </trans-unit>
        <trans-unit id="510e5879338c47950130f12189e321dcf4ce36c2" translate="yes" xml:space="preserve">
          <source>Moves elements from the table &lt;code&gt;a1&lt;/code&gt; to the table &lt;code&gt;a2&lt;/code&gt;, performing the equivalent to the following multiple assignment: &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt;. The default for &lt;code&gt;a2&lt;/code&gt; is &lt;code&gt;a1&lt;/code&gt;. The destination range can overlap with the source range. The number of elements to be moved must fit in a Lua integer.</source>
          <target state="translated">将元素从表 &lt;code&gt;a1&lt;/code&gt; 移动到表 &lt;code&gt;a2&lt;/code&gt; ，执行与以下多重分配等效的操作： &lt;code&gt;a2[t],&amp;middot;&amp;middot;&amp;middot; = a1[f],&amp;middot;&amp;middot;&amp;middot;,a1[e]&lt;/code&gt; 。 &lt;code&gt;a2&lt;/code&gt; 的默认值为 &lt;code&gt;a1&lt;/code&gt; 。目标范围可以与源范围重叠。要移动的元素数必须适合Lua整数。</target>
        </trans-unit>
        <trans-unit id="7f2bdd0bd3d59fce772f98ee9eb7eb0b3b6d4a93" translate="yes" xml:space="preserve">
          <source>Moves the top element into the given valid index without shifting any element (therefore replacing the value at that given index), and then pops the top element.</source>
          <target state="translated">将顶部元素移动到给定的有效索引中,而不移动任何元素(因此替换该给定索引的值),然后弹出顶部元素。</target>
        </trans-unit>
        <trans-unit id="4e0c82df95dd4d912151141c645e29919783b9cd" translate="yes" xml:space="preserve">
          <source>Moves the top element into the given valid index, shifting up the elements above this index to open space. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">将顶层元素移动到给定的有效索引中,将该索引上方的元素移到空位。这个函数不能与伪索引一起调用,因为伪索引不是一个实际的堆栈位置。</target>
        </trans-unit>
        <trans-unit id="391a0967919882d8d7da074ecd835868b9ad0813" translate="yes" xml:space="preserve">
          <source>Multiple matches:</source>
          <target state="translated">多次匹配。</target>
        </trans-unit>
        <trans-unit id="f3ebf3f60d00dc82250b0b628b803e44dd494422" translate="yes" xml:space="preserve">
          <source>Name denotes identifiers (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;).</source>
          <target state="translated">名称表示标识符（请参阅第&lt;a href=&quot;#3.1&quot;&gt;3.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="53b225abd3f0033a18a8e56044eee89e7ebbd191" translate="yes" xml:space="preserve">
          <source>Name denotes identifiers, as defined in &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;.</source>
          <target state="translated">名称表示标识符，如&lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1中&lt;/a&gt;所定义。</target>
        </trans-unit>
        <trans-unit id="132dfdc791b8ee51cdbc214b5f4f4d7ac599cf90" translate="yes" xml:space="preserve">
          <source>Native endianness assumes that the whole system is either big or little endian. The packing functions will not emulate correctly the behavior of mixed-endian formats.</source>
          <target state="translated">原生endianess假设整个系统是大endian或小endian。包装函数不能正确地模拟混合二烯格式的行为。</target>
        </trans-unit>
        <trans-unit id="0ff07f80cb3da5ffaa1ac22e6dac9b937f6ab24f" translate="yes" xml:space="preserve">
          <source>Nonetheless, it is always a good practice not to rely on these implicit coercions, as they are not always applied; in particular, &lt;code&gt;&quot;1&quot;==1&lt;/code&gt; is false and &lt;code&gt;&quot;1&quot;&amp;lt;1&lt;/code&gt; raises an error (see &lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt;). These coercions exist mainly for compatibility and may be removed in future versions of the language.</source>
          <target state="translated">但是，不依赖于这些隐式强制，因为并不总是可以应用，所以始终是一种好习惯。特别是， &lt;code&gt;&quot;1&quot;==1&lt;/code&gt; 为false，而 &lt;code&gt;&quot;1&quot;&amp;lt;1&lt;/code&gt; 引发错误（请参见&lt;a href=&quot;#3.4.4&quot;&gt;&amp;sect;3.4.4&lt;/a&gt;）。这些强制性的存在主要是出于兼容性考虑，可能会在该语言的将来版本中删除。</target>
        </trans-unit>
        <trans-unit id="14931c9658b2e9143b168a9666b173cd80e49603" translate="yes" xml:space="preserve">
          <source>Note that Standard C ensures that &lt;code&gt;free(NULL)&lt;/code&gt; has no effect and that &lt;code&gt;realloc(NULL,size)&lt;/code&gt; is equivalent to &lt;code&gt;malloc(size)&lt;/code&gt;.</source>
          <target state="translated">请注意，标准C确保 &lt;code&gt;free(NULL)&lt;/code&gt; 无效，并且 &lt;code&gt;realloc(NULL,size)&lt;/code&gt; 等效于 &lt;code&gt;malloc(size)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fb92775055c34d37036245800bd4e66793f8802" translate="yes" xml:space="preserve">
          <source>Note that Standard C ensures that &lt;code&gt;free(NULL)&lt;/code&gt; has no effect and that &lt;code&gt;realloc(NULL,size)&lt;/code&gt; is equivalent to &lt;code&gt;malloc(size)&lt;/code&gt;. This code assumes that &lt;code&gt;realloc&lt;/code&gt; does not fail when shrinking a block. (Although Standard C does not ensure this behavior, it seems to be a safe assumption.)</source>
          <target state="translated">请注意，标准C确保 &lt;code&gt;free(NULL)&lt;/code&gt; 无效，并且 &lt;code&gt;realloc(NULL,size)&lt;/code&gt; 等效于 &lt;code&gt;malloc(size)&lt;/code&gt; 。该代码假定缩小块时 &lt;code&gt;realloc&lt;/code&gt; 不会失败。（尽管标准C不能保证这种行为，但这似乎是一个安全的假设。）</target>
        </trans-unit>
        <trans-unit id="7a567518fb3007e639daf24d7ac35ede7aba1d84" translate="yes" xml:space="preserve">
          <source>Note that commands for &lt;code&gt;debug.debug&lt;/code&gt; are not lexically nested within any function and so have no direct access to local variables.</source>
          <target state="translated">请注意， &lt;code&gt;debug.debug&lt;/code&gt; 的命令未按词法嵌套在任何函数中，因此无法直接访问局部变量。</target>
        </trans-unit>
        <trans-unit id="a3819f26854d326b0f73d55f7e4a2133dc45716a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;comp&lt;/code&gt; function must define a strict partial order over the elements in the list; that is, it must be asymmetric and transitive. Otherwise, no valid sort may be possible.</source>
          <target state="translated">请注意， &lt;code&gt;comp&lt;/code&gt; 函数必须在列表中的元素上定义严格的偏序。也就是说，它必须是不对称的和可传递的。否则，可能无法进行有效排序。</target>
        </trans-unit>
        <trans-unit id="1dab5c0bc6e3b7d33e45552977787711c9e9cd82" translate="yes" xml:space="preserve">
          <source>Note that the code above is &lt;em&gt;balanced&lt;/em&gt;: at its end, the stack is back to its original configuration. This is considered good programming practice.</source>
          <target state="translated">请注意，上面的代码是&lt;em&gt;平衡的&lt;/em&gt;：在结束时，堆栈返回到其原始配置。这被认为是好的编程习惯。</target>
        </trans-unit>
        <trans-unit id="27456ef634a2ef274b5d4e632f792b2f499755a1" translate="yes" xml:space="preserve">
          <source>Note that, both in case of errors and of a regular return, by the time the &lt;code&gt;__close&lt;/code&gt; metamethod runs, the C stack was already unwound, so that any automatic C variable declared in the calling function will be out of scope.</source>
          <target state="translated">请注意，无论是发生错误还是定期返回，在 &lt;code&gt;__close&lt;/code&gt; 元方法运行时，C堆栈都已解开，因此在调用函数中声明的任何自动C变量都将超出范围。</target>
        </trans-unit>
        <trans-unit id="f095d9ef1108e5d2ebeb20830f7a9cdf31641d73" translate="yes" xml:space="preserve">
          <source>Note the external, explicit call to the continuation: Lua will call the continuation only if needed, that is, in case of errors or resuming after a yield. If the called function returns normally without ever yielding, &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;) will also return normally. (Of course, instead of calling the continuation in that case, you can do the equivalent work directly inside the original function.)</source>
          <target state="translated">注意外部的，对延续的显式调用：Lua仅在需要时才调用延续，即在发生错误或在yield之后恢复时。如果被调用的函数正常返回而没有屈服，&lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt;（和&lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt;）也将正常返回。（当然，在这种情况下，您可以直接在原始函数中执行等效的工作，而不是在这种情况下调用延续）。</target>
        </trans-unit>
        <trans-unit id="20d78a8e421517dfc8501178399cb2a435e63306" translate="yes" xml:space="preserve">
          <source>Note the following:</source>
          <target state="translated">请注意以下几点:</target>
        </trans-unit>
        <trans-unit id="143069908049a001ca51a83cef0a8d3fcbe11397" translate="yes" xml:space="preserve">
          <source>Notice that each execution of a &lt;b&gt;local&lt;/b&gt; statement defines new local variables. Consider the following example:</source>
          <target state="translated">注意，每次执行&lt;b&gt;局部&lt;/b&gt;语句都会定义新的局部变量。考虑以下示例：</target>
        </trans-unit>
        <trans-unit id="fcc164423a09d2953e5486a056f1e10293de0711" translate="yes" xml:space="preserve">
          <source>Notice that, in a declaration like &lt;code&gt;local x = x&lt;/code&gt;, the new &lt;code&gt;x&lt;/code&gt; being declared is not in scope yet, and so the second &lt;code&gt;x&lt;/code&gt; refers to the outside variable.</source>
          <target state="translated">请注意，在类似 &lt;code&gt;local x = x&lt;/code&gt; 的声明中，要声明的新 &lt;code&gt;x&lt;/code&gt; 不在范围内，因此第二个 &lt;code&gt;x&lt;/code&gt; 引用了外部变量。</target>
        </trans-unit>
        <trans-unit id="d213f09117ec25cd2306bbea812a90e0c2b8aabb" translate="yes" xml:space="preserve">
          <source>Now we want to allow the Lua code being run by &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; to yield. First, we can rewrite our function like here:</source>
          <target state="translated">现在我们要允许&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;运行的Lua代码产生。首先，我们可以像下面这样重写我们的函数：</target>
        </trans-unit>
        <trans-unit id="754d929d0f6f3e09a813d3e11d5cb6448eada594" translate="yes" xml:space="preserve">
          <source>Numerals and literal strings are explained in &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;; variables are explained in &lt;a href=&quot;#3.2&quot;&gt;&amp;sect;3.2&lt;/a&gt;; function definitions are explained in &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;; function calls are explained in &lt;a href=&quot;#3.4.10&quot;&gt;&amp;sect;3.4.10&lt;/a&gt;; table constructors are explained in &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt;. Vararg expressions, denoted by three dots ('&lt;code&gt;...&lt;/code&gt;'), can only be used when directly inside a vararg function; they are explained in &lt;a href=&quot;#3.4.11&quot;&gt;&amp;sect;3.4.11&lt;/a&gt;.</source>
          <target state="translated">数字和文字字符串在第&lt;a href=&quot;#3.1&quot;&gt;3.1节中&lt;/a&gt;进行了说明；变量在第&lt;a href=&quot;#3.2&quot;&gt;3.2节中&lt;/a&gt;进行了说明；功能定义在第&lt;a href=&quot;#3.4.11&quot;&gt;3.4.11节中&lt;/a&gt;进行了说明；函数调用在第&lt;a href=&quot;#3.4.10&quot;&gt;3.4.10节中&lt;/a&gt;进行了说明；表构造函数在第&lt;a href=&quot;#3.4.9&quot;&gt;3.4.9节中&lt;/a&gt;进行了说明。由三个点（' &lt;code&gt;...&lt;/code&gt; '）表示的Vararg表达式只能在直接位于vararg函数内部时使用；它们在第&lt;a href=&quot;#3.4.11&quot;&gt;3.4.11节中&lt;/a&gt;进行了说明。</target>
        </trans-unit>
        <trans-unit id="4ef3b305c58fad6f6199b8fc85c384f4f0aec1bf" translate="yes" xml:space="preserve">
          <source>Numeric codes are not necessarily portable across platforms.</source>
          <target state="translated">数字代码不一定可以跨平台移植。</target>
        </trans-unit>
        <trans-unit id="b0a0e9260ed5a6d09f75bd0cd4a96d473084f65f" translate="yes" xml:space="preserve">
          <source>Of course, the location of the Lua interpreter may be different in your machine. If &lt;code&gt;lua&lt;/code&gt; is in your &lt;code&gt;PATH&lt;/code&gt;, then</source>
          <target state="translated">当然，Lua解释器的位置在您的计算机中可能会有所不同。如果 &lt;code&gt;lua&lt;/code&gt; 在您的 &lt;code&gt;PATH&lt;/code&gt; 中，则</target>
        </trans-unit>
        <trans-unit id="b1e9a773eef8de621ab2c2acf9814098928b38f7" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this function also creates a file with that name, to avoid security risks. (Someone else might create the file with wrong permissions in the time between getting the name and creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).</source>
          <target state="translated">在POSIX系统上,为了避免安全风险,这个函数也会创建一个以该名称命名的文件。(别人可能会在获得文件名和创建文件之间的时间内用错误的权限创建文件)。你仍然必须打开文件才能使用它和删除它(即使你不使用它)。</target>
        </trans-unit>
        <trans-unit id="b4eb9b31d3cdaa19214342b44ace3c1948a9b1c8" translate="yes" xml:space="preserve">
          <source>On non-POSIX systems, this function may be not thread safe because of its reliance on C function &lt;code&gt;gmtime&lt;/code&gt; and C function &lt;code&gt;localtime&lt;/code&gt;.</source>
          <target state="translated">在非POSIX系统上，由于此函数依赖于C函数 &lt;code&gt;gmtime&lt;/code&gt; 和C函数 &lt;code&gt;localtime&lt;/code&gt; ，因此可能不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="327d9d40cc45661d18c144b659d732ccb083e105" translate="yes" xml:space="preserve">
          <source>On several platforms, you may not need to call this function, because all resources are naturally released when the host program ends. On the other hand, long-running programs that create multiple states, such as daemons or web servers, will probably need to close states as soon as they are not needed.</source>
          <target state="translated">在一些平台上,你可能不需要调用这个函数,因为当主机程序结束时,所有的资源都会自然释放。另一方面,创建多个状态的长期运行的程序,如守护进程或Web服务器,可能需要在不需要时尽快关闭状态。</target>
        </trans-unit>
        <trans-unit id="087e8ef073a71f75716b2985ce5b0a8533e700f2" translate="yes" xml:space="preserve">
          <source>Once a loader is found, &lt;code&gt;require&lt;/code&gt; calls the loader with two arguments: &lt;code&gt;modname&lt;/code&gt; and an extra value dependent on how it got the loader. (If the loader came from a file, this extra value is the file name.) If the loader returns any non-nil value, &lt;code&gt;require&lt;/code&gt; assigns the returned value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;. If the loader does not return a non-nil value and has not assigned any value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;, then &lt;code&gt;require&lt;/code&gt; assigns &lt;b&gt;true&lt;/b&gt; to this entry. In any case, &lt;code&gt;require&lt;/code&gt; returns the final value of &lt;code&gt;package.loaded[modname]&lt;/code&gt;.</source>
          <target state="translated">找到装载程序后， &lt;code&gt;require&lt;/code&gt; 会使用两个参数调用装载程序： &lt;code&gt;modname&lt;/code&gt; 和一个取决于它如何获得装载程序的额外值。 （如果加载程序来自文件，则该额外值是文件名。）如果加载程序返回任何非null值，则 &lt;code&gt;require&lt;/code&gt; 将返回的值分配给 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 。如果加载器没有返回非nil值，并且未将任何值分配给 &lt;code&gt;package.loaded[modname]&lt;/code&gt; ，那么 &lt;code&gt;require&lt;/code&gt; 会为该条目分配&lt;b&gt;true&lt;/b&gt;。无论如何， &lt;code&gt;require&lt;/code&gt; 返回 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 的最终值。</target>
        </trans-unit>
        <trans-unit id="cf51682813139c6b06902191dce5e737d2d9c9a1" translate="yes" xml:space="preserve">
          <source>Once a loader is found, &lt;code&gt;require&lt;/code&gt; calls the loader with two arguments: &lt;code&gt;modname&lt;/code&gt; and an extra value, a &lt;em&gt;loader data&lt;/em&gt;, also returned by the searcher. The loader data can be any value useful to the module; for the default searchers, it indicates where the loader was found. (For instance, if the loader came from a file, this extra value is the file path.) If the loader returns any non-nil value, &lt;code&gt;require&lt;/code&gt; assigns the returned value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;. If the loader does not return a non-nil value and has not assigned any value to &lt;code&gt;package.loaded[modname]&lt;/code&gt;, then &lt;code&gt;require&lt;/code&gt; assigns &lt;b&gt;true&lt;/b&gt; to this entry. In any case, &lt;code&gt;require&lt;/code&gt; returns the final value of &lt;code&gt;package.loaded[modname]&lt;/code&gt;. Besides that value, &lt;code&gt;require&lt;/code&gt; also returns as a second result the loader data returned by the searcher, which indicates how &lt;code&gt;require&lt;/code&gt; found the module.</source>
          <target state="translated">找到装载程序后， &lt;code&gt;require&lt;/code&gt; 会使用两个参数调用装载程序： &lt;code&gt;modname&lt;/code&gt; 和一个额外的值，即&lt;em&gt;装载程序data&lt;/em&gt;，也由搜索者返回。加载器数据可以是对模块有用的任何值；对于默认搜索者，它指示在哪里找到装载程序。 （例如，如果加载器来自文件，则此额外值是文件路径。）如果加载器返回任何非null值，则 &lt;code&gt;require&lt;/code&gt; 将返回的值分配给 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 。如果加载器没有返回非nil值，并且未将任何值分配给 &lt;code&gt;package.loaded[modname]&lt;/code&gt; ，那么 &lt;code&gt;require&lt;/code&gt; 将该条目分配为&lt;b&gt;true&lt;/b&gt;。无论如何， &lt;code&gt;require&lt;/code&gt; 返回 &lt;code&gt;package.loaded[modname]&lt;/code&gt; 的最终值。除了该值之外， &lt;code&gt;require&lt;/code&gt; 还作为搜索结果返回的第二个结果返回搜索者返回的加载器数据，该数据指示 &lt;code&gt;require&lt;/code&gt; 是如何找到该模块的。</target>
        </trans-unit>
        <trans-unit id="c0f13732846387f19dd5d62a467bb6af8a9e77c4" translate="yes" xml:space="preserve">
          <source>Only objects that have an explicit construction are removed from weak tables. Values, such as numbers and light C functions, are not subject to garbage collection, and therefore are not removed from weak tables (unless their associated values are collected). Although strings are subject to garbage collection, they do not have an explicit construction and their equality is by value; they behave more like values than like objects. Therefore, they are not removed from weak tables.</source>
          <target state="translated">只有具有显式构造的对象才会从弱表中删除。值,如数字和轻量级C函数,不受垃圾收集的限制,因此不会从弱表中删除(除非它们的相关值被收集)。虽然字符串会受到垃圾收集,但它们没有显式构造,而且它们的平等是通过值来实现的;它们的行为更像值而不是对象。因此,它们不会被从弱表中删除。</target>
        </trans-unit>
        <trans-unit id="dd79eaea9e398294fa6609bcc37919375540b811" translate="yes" xml:space="preserve">
          <source>Only objects that have an explicit construction are removed from weak tables. Values, such as numbers and light C functions, are not subject to garbage collection, and therefore are not removed from weak tables (unless their associated values are collected). Although strings are subject to garbage collection, they do not have an explicit construction, and therefore are not removed from weak tables.</source>
          <target state="translated">只有具有显式构造的对象才会从弱表中删除。值,如数字和轻量级C函数,不受垃圾收集的限制,因此不会从弱表中删除(除非它们的相关值被收集)。虽然字符串是垃圾收集的对象,但它们没有显式结构,因此不会从弱表中删除。</target>
        </trans-unit>
        <trans-unit id="b08de619674921c221a144a642faade8131401ce" translate="yes" xml:space="preserve">
          <source>Opens all standard Lua libraries into the given state.</source>
          <target state="translated">打开所有标准Lua库进入给定状态。</target>
        </trans-unit>
        <trans-unit id="fed8115b8cb0d575a6d2ddd5024ea0f4b7c2651d" translate="yes" xml:space="preserve">
          <source>Opens the given file name in read mode and returns an iterator function that works like &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; over the opened file. When the iterator function detects the end of file, it returns no values (to finish the loop) and automatically closes the file.</source>
          <target state="translated">在读取模式下打开给定的文件名，并在打开的文件上返回一个类似于 &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; 的迭代器函数。当迭代器函数检测到文件结尾时，它不返回任何值（以完成循环）并自动关闭文件。</target>
        </trans-unit>
        <trans-unit id="94b0d085d949942fdb3fb646a2df4ce4d0e5c72f" translate="yes" xml:space="preserve">
          <source>Opens the given file name in read mode and returns an iterator function that works like &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; over the opened file. When the iterator function fails to read any value, it automatically closes the file. Besides the iterator function, &lt;code&gt;io.lines&lt;/code&gt; returns three other values: two &lt;b&gt;nil&lt;/b&gt; values as placeholders, plus the created file handle. Therefore, when used in a generic &lt;b&gt;for&lt;/b&gt; loop, the file is closed also if the loop is interrupted by an error or a &lt;b&gt;break&lt;/b&gt;.</source>
          <target state="translated">在读取模式下打开给定的文件名，并在打开的文件上返回一个类似于 &lt;code&gt;file:lines(&amp;middot;&amp;middot;&amp;middot;)&lt;/code&gt; 的迭代器函数。当迭代器函数无法读取任何值时，它将自动关闭文件。除了迭代器函数外， &lt;code&gt;io.lines&lt;/code&gt; 还返回其他三个值：两个&lt;b&gt;nil&lt;/b&gt;值作为占位符，以及创建的文件句柄。因此，当在通用的&lt;b&gt;for&lt;/b&gt;循环中使用时，如果循环因错误或&lt;b&gt;break&lt;/b&gt;中断，文件也会关闭。</target>
        </trans-unit>
        <trans-unit id="6c9790a0effb3e0767d24700689fb5bce0eb0f23" translate="yes" xml:space="preserve">
          <source>Opens the named file and executes its content as a Lua chunk. When called without arguments, &lt;code&gt;dofile&lt;/code&gt; executes the content of the standard input (&lt;code&gt;stdin&lt;/code&gt;). Returns all values returned by the chunk. In case of errors, &lt;code&gt;dofile&lt;/code&gt; propagates the error to its caller. (That is, &lt;code&gt;dofile&lt;/code&gt; does not run in protected mode.)</source>
          <target state="translated">打开命名的文件，并将其内容作为Lua块执行。当不带参数调用时， &lt;code&gt;dofile&lt;/code&gt; 将执行标准输入（ &lt;code&gt;stdin&lt;/code&gt; ）的内容。返回块返回的所有值。发生错误时， &lt;code&gt;dofile&lt;/code&gt; 会将错误传播到其调用者。（即， &lt;code&gt;dofile&lt;/code&gt; 不在保护模式下运行。）</target>
        </trans-unit>
        <trans-unit id="4996bd3a029769976e9b98ed2378b1547c48ce7d" translate="yes" xml:space="preserve">
          <source>Opens the named file and executes its contents as a Lua chunk. When called without arguments, &lt;code&gt;dofile&lt;/code&gt; executes the contents of the standard input (&lt;code&gt;stdin&lt;/code&gt;). Returns all values returned by the chunk. In case of errors, &lt;code&gt;dofile&lt;/code&gt; propagates the error to its caller (that is, &lt;code&gt;dofile&lt;/code&gt; does not run in protected mode).</source>
          <target state="translated">打开命名的文件，并将其内容作为Lua块执行。当不带参数调用时， &lt;code&gt;dofile&lt;/code&gt; 将执行标准输入（ &lt;code&gt;stdin&lt;/code&gt; ）的内容。返回块返回的所有值。发生错误时， &lt;code&gt;dofile&lt;/code&gt; 会将错误传播到其调用者（即， &lt;code&gt;dofile&lt;/code&gt; 不在保护模式下运行）。</target>
        </trans-unit>
        <trans-unit id="1b77184a8e40f826198903ec77c88ff94fba7356" translate="yes" xml:space="preserve">
          <source>Operator precedence in Lua follows the table below, from lower to higher priority:</source>
          <target state="translated">Lua中的操作符优先级按照下表从低到高排列。</target>
        </trans-unit>
        <trans-unit id="5d68118be76331913c2ce7bb079ac0bdce1e02a7" translate="yes" xml:space="preserve">
          <source>Option &lt;code&gt;s&lt;/code&gt; expects a string; if its argument is not a string, it is converted to one following the same rules of &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;. If the option has any modifier (flags, width, length), the string argument should not contain embedded zeros.</source>
          <target state="translated">Option &lt;code&gt;s&lt;/code&gt; 需要一个字符串；如果其参数不是字符串，则按照&lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt;的相同规则将其转换为一个。如果选项具有任何修饰符（标志，宽度，长度），则字符串参数不应包含嵌入式零。</target>
        </trans-unit>
        <trans-unit id="87ca1fbe6a8feba28ed3fc6964e861a77643303f" translate="yes" xml:space="preserve">
          <source>Option names in &lt;a href=&quot;#pdf-io.read&quot;&gt;&lt;code&gt;io.read&lt;/code&gt;&lt;/a&gt; do not have a starting '&lt;code&gt;*&lt;/code&gt;' anymore. For compatibility, Lua will continue to accept (and ignore) this character.</source>
          <target state="translated">&lt;a href=&quot;#pdf-io.read&quot;&gt; &lt;code&gt;io.read&lt;/code&gt; 中的&lt;/a&gt;选项名称不再以' &lt;code&gt;*&lt;/code&gt; ' 开头。为了兼容性，Lua将继续接受（并忽略）此字符。</target>
        </trans-unit>
        <trans-unit id="b8e36de59136b88fc2be5c019f1c1af0d901d853" translate="yes" xml:space="preserve">
          <source>Options &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, and &lt;code&gt;g&lt;/code&gt; all expect a number as argument. Options &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; expect an integer. When Lua is compiled with a C89 compiler, options &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; (hexadecimal floats) do not support any modifier (flags, width, length).</source>
          <target state="translated">选项 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;E&lt;/code&gt; ， &lt;code&gt;e&lt;/code&gt; ， &lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;G&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 都期望数字作为参数。选项 &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;d&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;o&lt;/code&gt; ， &lt;code&gt;u&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 期望为整数。用C89编译器编译Lua时，选项 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; （十六进制浮点数）不支持任何修饰符（标志，宽度，长度）。</target>
        </trans-unit>
        <trans-unit id="8a1abeaa4ebe74d5340ad5d927126ab129362a92" translate="yes" xml:space="preserve">
          <source>Otherwise, returns three values: the &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; function, the table &lt;code&gt;t&lt;/code&gt;, and &lt;b&gt;nil&lt;/b&gt;, so that the construction</source>
          <target state="translated">否则，返回三个值：&lt;a href=&quot;#pdf-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;函数，表 &lt;code&gt;t&lt;/code&gt; 和&lt;b&gt;nil&lt;/b&gt;，以便构造</target>
        </trans-unit>
        <trans-unit id="178c0a8da555da3fb52bb9fe10047627cb505e75" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;ar&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">参数 &lt;code&gt;ar&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 与&lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; &lt;/a&gt;函数相同。</target>
        </trans-unit>
        <trans-unit id="8dc64fc2f4cd99c0ced65561a7ce6e7af2b4bf51" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;ar&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in the function &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">参数 &lt;code&gt;ar&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 与&lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; &lt;/a&gt;函数中的一样。</target>
        </trans-unit>
        <trans-unit id="6ea29796519b03e49b8f299281d87fde989109ec" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;n&lt;/code&gt; cannot be greater than the number of upvalues.</source>
          <target state="translated">参数 &lt;code&gt;funcindex&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 与&lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt;函数中的参数相同，但 &lt;code&gt;n&lt;/code&gt; 不能大于升值的数量。</target>
        </trans-unit>
        <trans-unit id="430e32c1c643e4f1d035c6b28b1a7ed4bf4a0eac" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">参数 &lt;code&gt;funcindex&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 与&lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt;函数相同。</target>
        </trans-unit>
        <trans-unit id="bc00bbb5ef17f161e882643cc3eb1de5624c1761" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in the function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;n&lt;/code&gt; cannot be greater than the number of upvalues.</source>
          <target state="translated">参数 &lt;code&gt;funcindex&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 与&lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt;函数中的参数相同，但 &lt;code&gt;n&lt;/code&gt; 不能大于升值的数量。</target>
        </trans-unit>
        <trans-unit id="d4fbfbc25528bfc37258607c935be76b6d23f936" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;funcindex&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are as in the function &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">参数 &lt;code&gt;funcindex&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 与&lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt;函数中的一样。</target>
        </trans-unit>
        <trans-unit id="ed5ec09aef437013e06ea8a8354f4fd26022ed2a" translate="yes" xml:space="preserve">
          <source>Parameters act as local variables that are initialized with the argument values:</source>
          <target state="translated">参数作为局部变量,用参数值初始化。</target>
        </trans-unit>
        <trans-unit id="448ecaf1d946410d7f3122c5e30729943106812b" translate="yes" xml:space="preserve">
          <source>Pattern Item:</source>
          <target state="translated">模式项目。</target>
        </trans-unit>
        <trans-unit id="5da899e9024f2b8d94cc4514fe33d4ff85310e83" translate="yes" xml:space="preserve">
          <source>Pattern:</source>
          <target state="translated">Pattern:</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="8d2dcea1a0ef2ec1d9376ec9b8afe27c3f59c3e3" translate="yes" xml:space="preserve">
          <source>Patterns in Lua are described by regular strings, which are interpreted as patterns by the pattern-matching functions &lt;a href=&quot;#pdf-string.find&quot;&gt;&lt;code&gt;string.find&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.gmatch&quot;&gt;&lt;code&gt;string.gmatch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.gsub&quot;&gt;&lt;code&gt;string.gsub&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-string.match&quot;&gt;&lt;code&gt;string.match&lt;/code&gt;&lt;/a&gt;. This section describes the syntax and the meaning (that is, what they match) of these strings.</source>
          <target state="translated">Lua中的模式由常规字符串描述，这些字符串由模式匹配功能&lt;a href=&quot;#pdf-string.find&quot;&gt; &lt;code&gt;string.find&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-string.gmatch&quot;&gt; &lt;code&gt;string.gmatch&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-string.gsub&quot;&gt; &lt;code&gt;string.gsub&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-string.match&quot;&gt; &lt;code&gt;string.match&lt;/code&gt; &lt;/a&gt;解释为模式。本节描述这些字符串的语法和含义（即它们匹配的内容）。</target>
        </trans-unit>
        <trans-unit id="dc7394297e26f026260d375d7cd96592fbd9339e" translate="yes" xml:space="preserve">
          <source>Performs an arithmetic or bitwise operation over the two values (or one, in the case of negations) at the top of the stack, with the value at the top being the second operand, pops these values, and pushes the result of the operation. The function follows the semantics of the corresponding Lua operator (that is, it may call metamethods).</source>
          <target state="translated">对堆栈顶部的两个值(如果是否定值,则为一个)进行算术或位运算,顶部的值为第二个操作数,弹出这些值,并推送运算结果。该函数遵循相应的Lua操作符的语义(也就是说,它可以调用元方法)。</target>
        </trans-unit>
        <trans-unit id="1fd5e0033b4343c024b4c61550d5dda42703ec57" translate="yes" xml:space="preserve">
          <source>Performs an arithmetic or bitwise operation over the two values (or one, in the case of negations) at the top of the stack, with the value on the top being the second operand, pops these values, and pushes the result of the operation. The function follows the semantics of the corresponding Lua operator (that is, it may call metamethods).</source>
          <target state="translated">对堆栈顶部的两个值(如果是否定值,则为一个)进行算术或位运算,顶部的值为第二个操作数,弹出这些值,并推送运算结果。该函数遵循相应的Lua操作符的语义(也就是说,它可以调用元方法)。</target>
        </trans-unit>
        <trans-unit id="ee7dc30bd933bbb4baaecee808c6149d39035466" translate="yes" xml:space="preserve">
          <source>Pointers to strings</source>
          <target state="translated">字符串指针</target>
        </trans-unit>
        <trans-unit id="1299b0bc498833db75f9cf0fffff3c4bae0facff" translate="yes" xml:space="preserve">
          <source>Pops &lt;code&gt;n&lt;/code&gt; elements from the stack.</source>
          <target state="translated">从堆栈中弹出 &lt;code&gt;n&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="fcc747279637a2d8a447881433d9aea7cb9cb559" translate="yes" xml:space="preserve">
          <source>Pops a key from the stack, and pushes a key&amp;ndash;value pair from the table at the given index (the &quot;next&quot; pair after the given key). If there are no more elements in the table, then &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt; returns 0 (and pushes nothing).</source>
          <target state="translated">从堆栈中弹出一个键，并从表中按给定索引推送键-值对（给定键之后的&amp;ldquo;下一个&amp;rdquo;对）。如果表中没有其他元素，则&lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; &lt;/a&gt;返回0（并且不进行任何操作）。</target>
        </trans-unit>
        <trans-unit id="d60cca5dd50e4b83932b42fd8d8d9fbffe7a1bc8" translate="yes" xml:space="preserve">
          <source>Pops a key from the stack, and pushes a key&amp;ndash;value pair from the table at the given index, the &quot;next&quot; pair after the given key. If there are no more elements in the table, then &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt; returns 0 and pushes nothing.</source>
          <target state="translated">从堆栈中弹出一个键，并从表中按给定索引推入一个键-值对，在给定键之后推入&amp;ldquo;下一个&amp;rdquo;对。如果表中没有其他元素，则&lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; &lt;/a&gt;返回0且不进行任何操作。</target>
        </trans-unit>
        <trans-unit id="38ce2b2d648784be385652bd2405ecdc4f5fbdbc" translate="yes" xml:space="preserve">
          <source>Pops a table from the stack and sets it as the new metatable for the value at the given index.</source>
          <target state="translated">从堆栈中弹出一个表,并将其设置为给定索引值的新元数据。</target>
        </trans-unit>
        <trans-unit id="3748a23e8606e10be9753871f0543fd3b3c035b8" translate="yes" xml:space="preserve">
          <source>Pops a table or &lt;b&gt;nil&lt;/b&gt; from the stack and sets that value as the new metatable for the value at the given index. (&lt;b&gt;nil&lt;/b&gt; means no metatable.)</source>
          <target state="translated">从堆栈中弹出一个表或&lt;b&gt;nil&lt;/b&gt;并将该值设置为给定索引处的值的新元表。（&lt;b&gt;nil&lt;/b&gt;表示没有metatable。）</target>
        </trans-unit>
        <trans-unit id="02cbea7516afa5834e8becd7f7d4a828165b122a" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new &lt;code&gt;n&lt;/code&gt;-th user value associated to the full userdata at the given index. Returns 0 if the userdata does not have that value.</source>
          <target state="translated">从堆栈中弹出一个值，并将其设置为与给定索引处的完整userdata关联的新的第 &lt;code&gt;n&lt;/code&gt; 个用户值。如果userdata没有该值，则返回0。</target>
        </trans-unit>
        <trans-unit id="9e0a9d18a088445b817b9df7884bfcb32d185882" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new value associated to the full userdata at the given index.</source>
          <target state="translated">从堆栈中弹出一个值,并将其设置为与给定索引的完整用户数据相关联的新值。</target>
        </trans-unit>
        <trans-unit id="e2b2f785858d2ccd19fa2b3c3174e4f53334d580" translate="yes" xml:space="preserve">
          <source>Pops a value from the stack and sets it as the new value of global &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">从堆栈中弹出一个值，并将其设置为全局 &lt;code&gt;name&lt;/code&gt; 的新值。</target>
        </trans-unit>
        <trans-unit id="ab86fb82a986460447b29bbb55ca5b9bf867bad6" translate="yes" xml:space="preserve">
          <source>Precedence</source>
          <target state="translated">Precedence</target>
        </trans-unit>
        <trans-unit id="38891db011f7fa7075e0b3b67c891847a651262c" translate="yes" xml:space="preserve">
          <source>Pushes a C function onto the stack. This function is equivalent to &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; with no upvalues.</source>
          <target state="translated">将C函数压入堆栈。此函数等效于&lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt;带升值的lua_pushcclosure。</target>
        </trans-unit>
        <trans-unit id="6069e3ce33f065015c2dc7cf19747d682b66d1cb" translate="yes" xml:space="preserve">
          <source>Pushes a C function onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type &lt;code&gt;function&lt;/code&gt; that, when called, invokes the corresponding C function.</source>
          <target state="translated">将C函数压入堆栈。该函数接收指向C函数的指针，并将类型 &lt;code&gt;function&lt;/code&gt; 的Lua值压入堆栈，该Lua值在调用时将调用相应的C函数。</target>
        </trans-unit>
        <trans-unit id="225557cebb89115cc93c59763f61b47f6e9246c5" translate="yes" xml:space="preserve">
          <source>Pushes a boolean value with value &lt;code&gt;b&lt;/code&gt; onto the stack.</source>
          <target state="translated">将具有值 &lt;code&gt;b&lt;/code&gt; 的布尔值压入堆栈。</target>
        </trans-unit>
        <trans-unit id="894000f061d35d3982475e83383dc72799631571" translate="yes" xml:space="preserve">
          <source>Pushes a copy of the element at the given index onto the stack.</source>
          <target state="translated">将给定索引的元素副本推送到堆栈中。</target>
        </trans-unit>
        <trans-unit id="b6ff7b2e435c0e0bd4a4dbe8af13548197a7ba1c" translate="yes" xml:space="preserve">
          <source>Pushes a float with value &lt;code&gt;n&lt;/code&gt; onto the stack.</source>
          <target state="translated">将值 &lt;code&gt;n&lt;/code&gt; 的浮点数压入堆栈。</target>
        </trans-unit>
        <trans-unit id="1b7c742fb6acbbb7614fff04126bb1d65108509f" translate="yes" xml:space="preserve">
          <source>Pushes a light userdata onto the stack.</source>
          <target state="translated">将一个轻量级的用户数据推到堆栈上。</target>
        </trans-unit>
        <trans-unit id="f9640c606650c6c3b185fb6d556165b919470195" translate="yes" xml:space="preserve">
          <source>Pushes a new C closure onto the stack.</source>
          <target state="translated">将一个新的C闭环推到堆栈上。</target>
        </trans-unit>
        <trans-unit id="783ef23f706b3af65f922bb64840e0a1f3a3b44a" translate="yes" xml:space="preserve">
          <source>Pushes a new C closure onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type &lt;code&gt;function&lt;/code&gt; that, when called, invokes the corresponding C function. The parameter &lt;code&gt;n&lt;/code&gt; tells how many upvalues this function will have (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;).</source>
          <target state="translated">将新的C闭包推入堆栈。该函数接收指向C函数的指针，并将类型 &lt;code&gt;function&lt;/code&gt; 的Lua值压入堆栈，该Lua值在被调用时将调用相应的C函数。参数 &lt;code&gt;n&lt;/code&gt; 告诉此函数将具有多少个上值（请参见第&lt;a href=&quot;#4.2&quot;&gt;4.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f1a59444f671b252069eb2dc564dace63fe90d50" translate="yes" xml:space="preserve">
          <source>Pushes a nil value onto the stack.</source>
          <target state="translated">将一个nil值推到堆栈上。</target>
        </trans-unit>
        <trans-unit id="2ac334edd538c29ffe856d049cab16b02559c4e6" translate="yes" xml:space="preserve">
          <source>Pushes an integer with value &lt;code&gt;n&lt;/code&gt; onto the stack.</source>
          <target state="translated">将值为 &lt;code&gt;n&lt;/code&gt; 的整数压入堆栈。</target>
        </trans-unit>
        <trans-unit id="f8ab0829fe517855f739ffae026b3c01efbb88ce" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a formatted string and returns a pointer to this string (see &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt;). It is similar to the ISO C function &lt;code&gt;sprintf&lt;/code&gt;, but has two important differences. First, you do not have to allocate space for the result; the result is a Lua string and Lua takes care of memory allocation (and deallocation, through garbage collection). Second, the conversion specifiers are quite restricted. There are no flags, widths, or precisions. The conversion specifiers can only be '&lt;code&gt;%%&lt;/code&gt;' (inserts the character '&lt;code&gt;%&lt;/code&gt;'), '&lt;code&gt;%s&lt;/code&gt;' (inserts a zero-terminated string, with no size restrictions), '&lt;code&gt;%f&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%I&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%p&lt;/code&gt;' (inserts a pointer), '&lt;code&gt;%d&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt;), '&lt;code&gt;%c&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt; as a one-byte character), and '&lt;code&gt;%U&lt;/code&gt;' (inserts a &lt;code&gt;long int&lt;/code&gt; as a UTF-8 byte sequence).</source>
          <target state="translated">将格式化的字符串压入堆栈，并返回指向该字符串的指针（请参见第&lt;a href=&quot;#4.1.3&quot;&gt;4.1.3节&lt;/a&gt;）。它与ISO C函数 &lt;code&gt;sprintf&lt;/code&gt; 相似，但有两个重要区别。首先，您不必为结果分配空间；结果是一个Lua字符串，而Lua负责内存分配（以及通过垃圾回收进行的重新分配）。其次，转换说明符非常受限制。没有标志，宽度或精度。转换说明符只能是' &lt;code&gt;%%&lt;/code&gt; '（插入字符' &lt;code&gt;%&lt;/code&gt; '），' &lt;code&gt;%s&lt;/code&gt; '（插入以零结尾的字符串，没有大小限制），' &lt;code&gt;%f&lt;/code&gt; '（插入&lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt;），' &lt;code&gt;%I&lt;/code&gt; '（插入一个&lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt;），' &lt;code&gt;%p&lt;/code&gt; '（插入一个指针），' &lt;code&gt;%d&lt;/code&gt; '（插入一个 &lt;code&gt;int&lt;/code&gt; ），' &lt;code&gt;%c&lt;/code&gt; '（将一个 &lt;code&gt;int&lt;/code&gt; 作为一个字节的字符插入）和' &lt;code&gt;%U&lt;/code&gt; '（将一个 &lt;code&gt;long int&lt;/code&gt; 插入为UTF-8字节序列）。</target>
        </trans-unit>
        <trans-unit id="ebf2182a4bd44a4ababe6986cdc0d46624511d6f" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a formatted string and returns a pointer to this string. It is similar to the ISO C function &lt;code&gt;sprintf&lt;/code&gt;, but has some important differences:</source>
          <target state="translated">将格式化的字符串压入堆栈，并返回指向该字符串的指针。它类似于ISO C函数 &lt;code&gt;sprintf&lt;/code&gt; ，但有一些重要区别：</target>
        </trans-unit>
        <trans-unit id="e3eb6979dbbec2441c887e7c302c341c3e2193b2" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack a string identifying the current position of the control at level &lt;code&gt;lvl&lt;/code&gt; in the call stack. Typically this string has the following format:</source>
          <target state="translated">将一个字符串推入堆栈，该字符串标识调用堆栈中级别 &lt;code&gt;lvl&lt;/code&gt; 处控件的当前位置。通常，此字符串具有以下格式：</target>
        </trans-unit>
        <trans-unit id="31d25d3d93b7e126c80bd4b8ac83684541597116" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the &lt;code&gt;n&lt;/code&gt;-th user value associated with the full userdata at the given index and returns the type of the pushed value.</source>
          <target state="translated">在给定索引处将与完整用户数据关联的第 &lt;code&gt;n&lt;/code&gt; 个用户值压入堆栈，并返回压入值的类型。</target>
        </trans-unit>
        <trans-unit id="1400d6038d9c13c6266dab4b80bdcdd7fc31a04b" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the Lua value associated with the full userdata at the given index.</source>
          <target state="translated">将给定索引中与完整用户数据相关联的Lua值推送到栈中。</target>
        </trans-unit>
        <trans-unit id="96d78a717bd5f3b49461732d2e8f02559185b11e" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the field &lt;code&gt;e&lt;/code&gt; from the metatable of the object at index &lt;code&gt;obj&lt;/code&gt; and returns the type of pushed value. If the object does not have a metatable, or if the metatable does not have this field, pushes nothing and returns &lt;code&gt;LUA_TNIL&lt;/code&gt;.</source>
          <target state="translated">将来自对象的元表的索引 &lt;code&gt;obj&lt;/code&gt; 处的字段 &lt;code&gt;e&lt;/code&gt; 压入堆栈，并返回压入值的类型。如果对象没有元表，或者该元表不具有此字段，则不进行任何操作并返回 &lt;code&gt;LUA_TNIL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d063d65f8ebdd7680c71182f22ecc37ef6878b23" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the field &lt;code&gt;e&lt;/code&gt; from the metatable of the object at index &lt;code&gt;obj&lt;/code&gt; and returns the type of the pushed value. If the object does not have a metatable, or if the metatable does not have this field, pushes nothing and returns &lt;code&gt;LUA_TNIL&lt;/code&gt;.</source>
          <target state="translated">将来自对象的元表的索引 &lt;code&gt;obj&lt;/code&gt; 处的字段 &lt;code&gt;e&lt;/code&gt; 压入堆栈，并返回压入值的类型。如果对象没有元表，或者该元表不具有此字段，则不进行任何操作并返回 &lt;code&gt;LUA_TNIL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6a3ae7b655cf9df13c5b9cf6975aa8b58442402" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;) (&lt;b&gt;nil&lt;/b&gt; if there is no metatable associated with that name). Returns the type of the pushed value.</source>
          <target state="translated">在注册表&lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt;与名称 &lt;code&gt;tname&lt;/code&gt; 关联的元表推入堆栈（请参见luaL_newmetatable）（如果没有与该名称关联的元表，则为&lt;b&gt;nil&lt;/b&gt;）。返回推送值的类型。</target>
        </trans-unit>
        <trans-unit id="c76c4d4c11e0c9e0d1f805bd491ba2da9880963e" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the metatable associated with the name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;), or &lt;b&gt;nil&lt;/b&gt; if there is no metatable associated with that name. Returns the type of the pushed value.</source>
          <target state="translated">将与注册表中的名称 &lt;code&gt;tname&lt;/code&gt; 关联的元表推入堆栈（请参见&lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt;），如果没有与该名称关联的元表，则为&lt;b&gt;nil&lt;/b&gt;。返回推送值的类型。</target>
        </trans-unit>
        <trans-unit id="3681d4e1cdd569fb3b2f3300755bb4d0cfb69c67" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[i]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">将值 &lt;code&gt;t[i]&lt;/code&gt; 入堆栈，其中 &lt;code&gt;t&lt;/code&gt; 是给定索引处的值。与Lua中一样，此函数可能会触发&amp;ldquo;索引&amp;rdquo;事件的元方法（请参阅第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="160cbb51fcadb575239ec804bbd26447a616f853" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;k&lt;/code&gt; is the pointer &lt;code&gt;p&lt;/code&gt; represented as a light userdata. The access is raw; that is, it does not invoke the &lt;code&gt;__index&lt;/code&gt; metamethod.</source>
          <target state="translated">将值 &lt;code&gt;t[k]&lt;/code&gt; 入堆栈，其中 &lt;code&gt;t&lt;/code&gt; 是给定索引处的表， &lt;code&gt;k&lt;/code&gt; 是表示为轻量用户数据的指针 &lt;code&gt;p&lt;/code&gt; 。访问是原始的；也就是说，它不会调用 &lt;code&gt;__index&lt;/code&gt; 元方法。</target>
        </trans-unit>
        <trans-unit id="f758b684030c5bdc751c5b58b931a7f7b9972806" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index and &lt;code&gt;k&lt;/code&gt; is the pointer &lt;code&gt;p&lt;/code&gt; represented as a light userdata. The access is raw; that is, it does not use the &lt;code&gt;__index&lt;/code&gt; metavalue.</source>
          <target state="translated">将值 &lt;code&gt;t[k]&lt;/code&gt; 入堆栈，其中 &lt;code&gt;t&lt;/code&gt; 是给定索引处的表， &lt;code&gt;k&lt;/code&gt; 是表示为轻量用户数据的指针 &lt;code&gt;p&lt;/code&gt; 。访问是原始的；也就是说，它不使用 &lt;code&gt;__index&lt;/code&gt; 元值。</target>
        </trans-unit>
        <trans-unit id="9ba28c13e89d272d19c50f5e767726525d936e21" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;k&lt;/code&gt; is the value at the top of the stack.</source>
          <target state="translated">将值 &lt;code&gt;t[k]&lt;/code&gt; 入堆栈，其中 &lt;code&gt;t&lt;/code&gt; 是给定索引处的值， &lt;code&gt;k&lt;/code&gt; 是堆栈顶部的值。</target>
        </trans-unit>
        <trans-unit id="2c9f6ce9bcbe6e782d6892ed66ce333a49c1c0f5" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index and &lt;code&gt;k&lt;/code&gt; is the value on the top of the stack.</source>
          <target state="translated">将值 &lt;code&gt;t[k]&lt;/code&gt; 入堆栈，其中 &lt;code&gt;t&lt;/code&gt; 是给定索引处的值， &lt;code&gt;k&lt;/code&gt; 是堆栈顶部的值。</target>
        </trans-unit>
        <trans-unit id="d433d1f4953100bc2a0c9d7a8e8e092f7c0a5c2a" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[k]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the value at the given index. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">将值 &lt;code&gt;t[k]&lt;/code&gt; 入堆栈，其中 &lt;code&gt;t&lt;/code&gt; 是给定索引处的值。与Lua中一样，此函数可能会触发&amp;ldquo;索引&amp;rdquo;事件的元方法（请参阅第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="27c3e32a80e22fb604cbe4557acc820d3c5231a7" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[n]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index. The access is raw, that is, it does not invoke the &lt;code&gt;__index&lt;/code&gt; metamethod.</source>
          <target state="translated">将值 &lt;code&gt;t[n]&lt;/code&gt; 入堆栈，其中 &lt;code&gt;t&lt;/code&gt; 是给定索引处的表。该访问是原始的，也就是说，它不调用 &lt;code&gt;__index&lt;/code&gt; 元方法。</target>
        </trans-unit>
        <trans-unit id="dbeb4c059af4ccf3fb9e1fdfc5784413b8117212" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value &lt;code&gt;t[n]&lt;/code&gt;, where &lt;code&gt;t&lt;/code&gt; is the table at the given index. The access is raw, that is, it does not use the &lt;code&gt;__index&lt;/code&gt; metavalue.</source>
          <target state="translated">将值 &lt;code&gt;t[n]&lt;/code&gt; 入堆栈，其中 &lt;code&gt;t&lt;/code&gt; 是给定索引处的表。该访问是原始的，也就是说，它不使用 &lt;code&gt;__index&lt;/code&gt; 元值。</target>
        </trans-unit>
        <trans-unit id="3adeb92584bb85f61e3f56627b5522106f4dd7b4" translate="yes" xml:space="preserve">
          <source>Pushes onto the stack the value of the global &lt;code&gt;name&lt;/code&gt;. Returns the type of that value.</source>
          <target state="translated">将全局 &lt;code&gt;name&lt;/code&gt; 的值压入堆栈。返回该值的类型。</target>
        </trans-unit>
        <trans-unit id="d5f71bf51568746d5ff514f34182d2dde3178d9d" translate="yes" xml:space="preserve">
          <source>Pushes the &lt;b&gt;fail&lt;/b&gt; value onto the stack (see &lt;a href=&quot;#6&quot;&gt;&amp;sect;6&lt;/a&gt;).</source>
          <target state="translated">将&lt;b&gt;失败&lt;/b&gt;值压入堆栈（请参见&lt;a href=&quot;#6&quot;&gt;&amp;sect;6&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="96bb89f8fd253dc6a3b3b23f64ce3135d6817db4" translate="yes" xml:space="preserve">
          <source>Pushes the global environment onto the stack.</source>
          <target state="translated">将全局环境推到堆栈上。</target>
        </trans-unit>
        <trans-unit id="b8b8e3282a4a6ab4f3ed7c29929c1ea38215b0e1" translate="yes" xml:space="preserve">
          <source>Pushes the string pointed to by &lt;code&gt;s&lt;/code&gt; with size &lt;code&gt;len&lt;/code&gt; onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns. The string can contain any binary data, including embedded zeros.</source>
          <target state="translated">将大小为 &lt;code&gt;len&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 指向的字符串压入堆栈。Lua制作（或重用）给定字符串的内部副本，因此可以在函数返回后立即释放或重用 &lt;code&gt;s&lt;/code&gt; 处的内存。该字符串可以包含任何二进制数据，包括嵌入的零。</target>
        </trans-unit>
        <trans-unit id="5639aa8221a13af71464ab360f3a38097209c56d" translate="yes" xml:space="preserve">
          <source>Pushes the string pointed to by &lt;code&gt;s&lt;/code&gt; with size &lt;code&gt;len&lt;/code&gt; onto the stack. Lua will make or reuse an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns. The string can contain any binary data, including embedded zeros.</source>
          <target state="translated">将大小为 &lt;code&gt;len&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 指向的字符串压入堆栈。Lua将创建或重用给定字符串的内部副本，因此可以在函数返回后立即释放或重用 &lt;code&gt;s&lt;/code&gt; 处的内存。该字符串可以包含任何二进制数据，包括嵌入的零。</target>
        </trans-unit>
        <trans-unit id="b6b66a7bc8fe80fa098dee231f5eaec5a6ccedfa" translate="yes" xml:space="preserve">
          <source>Pushes the thread represented by &lt;code&gt;L&lt;/code&gt; onto the stack. Returns 1 if this thread is the main thread of its state.</source>
          <target state="translated">将 &lt;code&gt;L&lt;/code&gt; 表示的线程推入堆栈。如果此线程是其状态的主线程，则返回1。</target>
        </trans-unit>
        <trans-unit id="4854f8dce1b3efb397d0da3cc0315b1cfb867e30" translate="yes" xml:space="preserve">
          <source>Pushes the zero-terminated string pointed to by &lt;code&gt;s&lt;/code&gt; onto the stack. Lua makes (or reuses) an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns.</source>
          <target state="translated">将 &lt;code&gt;s&lt;/code&gt; 所指向的零终止字符串推入堆栈。Lua制作（或重用）给定字符串的内部副本，因此可以在函数返回后立即释放或重用 &lt;code&gt;s&lt;/code&gt; 处的内存。</target>
        </trans-unit>
        <trans-unit id="8860aa35b65cff58872a8601fb6de276a53dc538" translate="yes" xml:space="preserve">
          <source>Pushes the zero-terminated string pointed to by &lt;code&gt;s&lt;/code&gt; onto the stack. Lua will make or reuse an internal copy of the given string, so the memory at &lt;code&gt;s&lt;/code&gt; can be freed or reused immediately after the function returns.</source>
          <target state="translated">将 &lt;code&gt;s&lt;/code&gt; 所指向的零终止字符串推入堆栈。Lua将创建或重用给定字符串的内部副本，因此可以在函数返回后立即释放或重用 &lt;code&gt;s&lt;/code&gt; 处的内存。</target>
        </trans-unit>
        <trans-unit id="8cfffe2498f662da17fd436630bb5c185a5f3013" translate="yes" xml:space="preserve">
          <source>Raises a Lua error, using the value on the top of the stack as the error object. This function does a long jump, and therefore never returns (see &lt;a href=&quot;#luaL_error&quot;&gt;&lt;code&gt;luaL_error&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">使用堆栈顶部的值作为错误对象，引发Lua错误。该函数跳远，因此从不返回（请参见&lt;a href=&quot;#luaL_error&quot;&gt; &lt;code&gt;luaL_error&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6a9d1916a4b52d4c954d6611c2265a068aa73389" translate="yes" xml:space="preserve">
          <source>Raises a type error for the argument &lt;code&gt;arg&lt;/code&gt; of the C function that called it, using a standard message; &lt;code&gt;tname&lt;/code&gt; is a &quot;name&quot; for the expected type. This function never returns.</source>
          <target state="translated">使用标准消息，为调用它的C函数的参数 &lt;code&gt;arg&lt;/code&gt; 引发类型错误； &lt;code&gt;tname&lt;/code&gt; 是预期类型的​​&amp;ldquo;名称&amp;rdquo;。该函数永不返回。</target>
        </trans-unit>
        <trans-unit id="9b9354a43204b93a4330b1af0c9ff798523b53da" translate="yes" xml:space="preserve">
          <source>Raises an error (see &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;) with @{message} as the error object. This function never returns.</source>
          <target state="translated">使用@ {message}作为错误对象引发错误（请参见&lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;）。该函数永不返回。</target>
        </trans-unit>
        <trans-unit id="bf358ba5588da456b49a6b3b1276c902731720d9" translate="yes" xml:space="preserve">
          <source>Raises an error if the value of its argument &lt;code&gt;v&lt;/code&gt; is false (i.e., &lt;b&gt;nil&lt;/b&gt; or &lt;b&gt;false&lt;/b&gt;); otherwise, returns all its arguments. In case of error, &lt;code&gt;message&lt;/code&gt; is the error object; when absent, it defaults to &quot;&lt;code&gt;assertion failed!&lt;/code&gt;&quot;</source>
          <target state="translated">如果其参数 &lt;code&gt;v&lt;/code&gt; 的值为false（即&lt;b&gt;nil&lt;/b&gt;或&lt;b&gt;false&lt;/b&gt;），则引发错误；否则，返回其所有参数。发生错误时， &lt;code&gt;message&lt;/code&gt; 是错误对象；缺席时，默认为&amp;ldquo; &lt;code&gt;assertion failed!&lt;/code&gt; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="fc0763820b54eedcf07407cf791911e6a4435f20" translate="yes" xml:space="preserve">
          <source>Raises an error reporting a problem with argument &lt;code&gt;arg&lt;/code&gt; of the C function that called it, using a standard message that includes &lt;code&gt;extramsg&lt;/code&gt; as a comment:</source>
          <target state="translated">使用包含 &lt;code&gt;extramsg&lt;/code&gt; 作为注释的标准消息，引发报告调用它的C函数的参数 &lt;code&gt;arg&lt;/code&gt; 有问题的错误：</target>
        </trans-unit>
        <trans-unit id="2195072e1ce816af3985bb81599b653639e6d200" translate="yes" xml:space="preserve">
          <source>Raises an error. The error message format is given by &lt;code&gt;fmt&lt;/code&gt; plus any extra arguments, following the same rules of &lt;a href=&quot;#lua_pushfstring&quot;&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;. It also adds at the beginning of the message the file name and the line number where the error occurred, if this information is available.</source>
          <target state="translated">引发错误。错误消息格式由 &lt;code&gt;fmt&lt;/code&gt; 加上任何其他参数给出，遵循&lt;a href=&quot;#lua_pushfstring&quot;&gt; &lt;code&gt;lua_pushfstring&lt;/code&gt; &lt;/a&gt;的相同规则。如果此信息可用，它还将在消息的开头添加发生错误的文件名和行号。</target>
        </trans-unit>
        <trans-unit id="e31b0fedf40d60473a1681a9f95cd0f5ccee72ff" translate="yes" xml:space="preserve">
          <source>Reads the file &lt;code&gt;file&lt;/code&gt;, according to the given formats, which specify what to read. For each format, the function returns a string or a number with the characters read, or &lt;b&gt;fail&lt;/b&gt; if it cannot read data with the specified format. (In this latter case, the function does not read subsequent formats.) When called without arguments, it uses a default format that reads the next line (see below).</source>
          <target state="translated">根据给定的格式读取文件 &lt;code&gt;file&lt;/code&gt; ，该格式指定要读取的内容。对于每种格式，该函数均返回带有已读取字符的字符串或数字，如果无法读取具有指定格式的数据，则该函数将&lt;b&gt;失败&lt;/b&gt;。（在后一种情况下，该函数不会读取后续格式。）在不带参数的情况下调用该函数时，它将使用读取下一行的默认格式（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="76a33dab1cf51144cd77abed8a485f73ea3a2319" translate="yes" xml:space="preserve">
          <source>Reads the file &lt;code&gt;file&lt;/code&gt;, according to the given formats, which specify what to read. For each format, the function returns a string or a number with the characters read, or &lt;b&gt;nil&lt;/b&gt; if it cannot read data with the specified format. (In this latter case, the function does not read subsequent formats.) When called without formats, it uses a default format that reads the next line (see below).</source>
          <target state="translated">根据给定的格式读取文件 &lt;code&gt;file&lt;/code&gt; ，该格式指定要读取的内容。对于每种格式，该函数均返回带有已读取字符的字符串或数字，如果无法读取具有指定格式的数据，则返回&lt;b&gt;nil&lt;/b&gt;。（在后一种情况下，该函数不读取后续格式。）在不带格式的情况下调用该函数时，它将使用读取下一行的默认格式（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="19c5c64f58aecd561b0cc1876786dfe7cb5a0fec" translate="yes" xml:space="preserve">
          <source>Receives a string and returns a copy of this string with all lowercase letters changed to uppercase. All other characters are left unchanged. The definition of what a lowercase letter is depends on the current locale.</source>
          <target state="translated">接收一个字符串并返回这个字符串的副本,将所有小写字母改为大写。所有其他字符保持不变。小写字母的定义取决于当前的语言环境。</target>
        </trans-unit>
        <trans-unit id="540aac1cb2574351ee99baa96641925cd5f56a55" translate="yes" xml:space="preserve">
          <source>Receives a string and returns a copy of this string with all uppercase letters changed to lowercase. All other characters are left unchanged. The definition of what an uppercase letter is depends on the current locale.</source>
          <target state="translated">接收一个字符串,并返回这个字符串的副本,将所有大写字母改为小写。所有其他字符保持不变。大写字母的定义取决于当前的语言环境。</target>
        </trans-unit>
        <trans-unit id="b890d3f853acc49ad9cf651903e6eb6cdf33901a" translate="yes" xml:space="preserve">
          <source>Receives a string and returns its length. The empty string &lt;code&gt;&quot;&quot;&lt;/code&gt; has length 0. Embedded zeros are counted, so &lt;code&gt;&quot;a\000bc\000&quot;&lt;/code&gt; has length 5.</source>
          <target state="translated">接收字符串并返回其长度。空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; 长度为0。对嵌入的零进行计数，因此 &lt;code&gt;&quot;a\000bc\000&quot;&lt;/code&gt; 长度为5。</target>
        </trans-unit>
        <trans-unit id="d82851b5722eeb1a4807bb839e4ddddefaeb2a1b" translate="yes" xml:space="preserve">
          <source>Receives a value of any type and converts it to a string in a human-readable format.</source>
          <target state="translated">接收任何类型的值,并将其转换为人类可读格式的字符串。</target>
        </trans-unit>
        <trans-unit id="525f707997f87240ceb1b2b5bdf4cfc009a704fc" translate="yes" xml:space="preserve">
          <source>Receives a value of any type and converts it to a string in a human-readable format. (For complete control of how numbers are converted, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">接收任何类型的值，并将其转换为人类可读格式的字符串。（要完全控制数字的转换方式，请使用&lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="f08637f98da65a6c936ab18edfd8700b8df77cb5" translate="yes" xml:space="preserve">
          <source>Receives any number of arguments and prints their values to &lt;code&gt;stdout&lt;/code&gt;, converting each argument to a string following the same rules of &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">接收任意数量的参数并将其值打印到 &lt;code&gt;stdout&lt;/code&gt; ，按照相同的&lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt;规则将每个参数转换为字符串。</target>
        </trans-unit>
        <trans-unit id="4a03622d8f97ccec5d5f7daa5dac73af6b7c7028" translate="yes" xml:space="preserve">
          <source>Receives any number of arguments and prints their values to &lt;code&gt;stdout&lt;/code&gt;, using the &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt; function to convert each argument to a string. &lt;code&gt;print&lt;/code&gt; is not intended for formatted output, but only as a quick way to show a value, for instance for debugging. For complete control over the output, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.write&quot;&gt;&lt;code&gt;io.write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">接收任意数量的参数，并将其值打印到 &lt;code&gt;stdout&lt;/code&gt; ，使用&lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt;函数将每个参数转换为字符串。 &lt;code&gt;print&lt;/code&gt; 不是用于格式化输出，而仅是一种显示值的快速方法，例如用于调试。要完全控制输出，请使用&lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-io.write&quot;&gt; &lt;code&gt;io.write&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b2cf76b7f314d7be6b1d5b068287552d8871811e" translate="yes" xml:space="preserve">
          <source>Receives zero or more integers, converts each one to its corresponding UTF-8 byte sequence and returns a string with the concatenation of all these sequences.</source>
          <target state="translated">接收0个或更多的整数,将每个整数转换为相应的UTF-8字节序列,并返回一个由所有这些序列连接而成的字符串。</target>
        </trans-unit>
        <trans-unit id="cb0dfce9b4c27c4105f7ed0248bef997f2d2f7bb" translate="yes" xml:space="preserve">
          <source>Receives zero or more integers. Returns a string with length equal to the number of arguments, in which each character has the internal numeric code equal to its corresponding argument.</source>
          <target state="translated">接收零或多个整数。返回一个长度等于参数数的字符串,其中每个字符的内部数字代码等于其对应的参数。</target>
        </trans-unit>
        <trans-unit id="ac1a2088772d8a0274c1a663c003fac03a83bcc4" translate="yes" xml:space="preserve">
          <source>Regardless, if the resulting function has any upvalues, its first upvalue is set to the value of &lt;code&gt;env&lt;/code&gt;, if that parameter is given, or to the value of the global environment. Other upvalues are initialized with &lt;b&gt;nil&lt;/b&gt;. All upvalues are fresh, that is, they are not shared with any other function.</source>
          <target state="translated">无论如何，如果结果函数具有任何上值，则将其第一个上值设置为 &lt;code&gt;env&lt;/code&gt; 的值（如果已指定该参数）或全局环境的值。其他升值使用&lt;b&gt;nil&lt;/b&gt;初始化。所有升值都是新鲜的，也就是说，它们不与任何其他函数共享。</target>
        </trans-unit>
        <trans-unit id="ba50e88a283776123b7b75fd12714beb6542b84c" translate="yes" xml:space="preserve">
          <source>Registers all functions in the array &lt;code&gt;l&lt;/code&gt; (see &lt;a href=&quot;#luaL_Reg&quot;&gt;&lt;code&gt;luaL_Reg&lt;/code&gt;&lt;/a&gt;) into the table on the top of the stack (below optional upvalues, see next).</source>
          <target state="translated">将数组 &lt;code&gt;l&lt;/code&gt; 中的所有函数（请参见&lt;a href=&quot;#luaL_Reg&quot;&gt; &lt;code&gt;luaL_Reg&lt;/code&gt; &lt;/a&gt;）注册到堆栈顶部的表中（在可选的upvalue下方，请参见下一个）。</target>
        </trans-unit>
        <trans-unit id="354032ada697719ccb58ca87cd221831508c42b3" translate="yes" xml:space="preserve">
          <source>Relational Operators</source>
          <target state="translated">关系运算符</target>
        </trans-unit>
        <trans-unit id="7d652aafaa213ccec3954206dc0a95e5d151cad3" translate="yes" xml:space="preserve">
          <source>Releases reference &lt;code&gt;ref&lt;/code&gt; from the table at index &lt;code&gt;t&lt;/code&gt; (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;). The entry is removed from the table, so that the referred object can be collected. The reference &lt;code&gt;ref&lt;/code&gt; is also freed to be used again.</source>
          <target state="translated">从表的索引 &lt;code&gt;t&lt;/code&gt; 释放引用 &lt;code&gt;ref&lt;/code&gt; （请参见&lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt;）。该条目已从表中删除，因此可以收集所引用的对象。参考 &lt;code&gt;ref&lt;/code&gt; 也可以自由使用。</target>
        </trans-unit>
        <trans-unit id="af7c5beadc65cf6aecf24cf7287288561cb7ead7" translate="yes" xml:space="preserve">
          <source>Releases the reference &lt;code&gt;ref&lt;/code&gt; from the table at index &lt;code&gt;t&lt;/code&gt; (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;). The entry is removed from the table, so that the referred object can be collected. The reference &lt;code&gt;ref&lt;/code&gt; is also freed to be used again.</source>
          <target state="translated">从表的索引 &lt;code&gt;t&lt;/code&gt; 释放引用 &lt;code&gt;ref&lt;/code&gt; （请参见&lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt;）。该条目已从表中删除，因此可以收集所引用的对象。参考 &lt;code&gt;ref&lt;/code&gt; 也可以自由使用。</target>
        </trans-unit>
        <trans-unit id="1f21ed8cdd38e88c74187592dabfbf9189cec444" translate="yes" xml:space="preserve">
          <source>Remember that, whenever an operation needs the length of a table, all caveats about the length operator apply (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). All functions ignore non-numeric keys in the tables given as arguments.</source>
          <target state="translated">请记住，每当一个操作需要表的长度时，关于长度运算符的所有警告都适用（请参见第&lt;a href=&quot;#3.4.7&quot;&gt;3.4.7节&lt;/a&gt;）。所有函数都忽略作为参数给出的表中的非数字键。</target>
        </trans-unit>
        <trans-unit id="50df2da2a4204c47a50a5f2a2a11c7eea37ba603" translate="yes" xml:space="preserve">
          <source>Removes &lt;code&gt;n&lt;/code&gt; bytes from the the buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). The buffer must have at least that many bytes.</source>
          <target state="translated">从缓冲区 &lt;code&gt;B&lt;/code&gt; 中删除 &lt;code&gt;n&lt;/code&gt; 个字节（请参见&lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt;）。缓冲区必须至少有那么多字节。</target>
        </trans-unit>
        <trans-unit id="d0dd440324a053f93400815574d10e0db636ed3b" translate="yes" xml:space="preserve">
          <source>Removes from &lt;code&gt;list&lt;/code&gt; the element at position &lt;code&gt;pos&lt;/code&gt;, returning the value of the removed element. When &lt;code&gt;pos&lt;/code&gt; is an integer between 1 and &lt;code&gt;#list&lt;/code&gt;, it shifts down the elements &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; and erases element &lt;code&gt;list[#list]&lt;/code&gt;; The index &lt;code&gt;pos&lt;/code&gt; can also be 0 when &lt;code&gt;#list&lt;/code&gt; is 0, or &lt;code&gt;#list + 1&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;list&lt;/code&gt; 移除位置 &lt;code&gt;pos&lt;/code&gt; 的元素，返回已移除元素的值。当 &lt;code&gt;pos&lt;/code&gt; 是1到 &lt;code&gt;#list&lt;/code&gt; 之间的整数时，它将下移元素 &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; 并擦除元素 &lt;code&gt;list[#list]&lt;/code&gt; ；当 &lt;code&gt;#list&lt;/code&gt; 为0或 &lt;code&gt;#list + 1&lt;/code&gt; 时，索引 &lt;code&gt;pos&lt;/code&gt; 也可以为0 。</target>
        </trans-unit>
        <trans-unit id="78486a859650e2590601f8f6a90106add4cefb81" translate="yes" xml:space="preserve">
          <source>Removes from &lt;code&gt;list&lt;/code&gt; the element at position &lt;code&gt;pos&lt;/code&gt;, returning the value of the removed element. When &lt;code&gt;pos&lt;/code&gt; is an integer between 1 and &lt;code&gt;#list&lt;/code&gt;, it shifts down the elements &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; and erases element &lt;code&gt;list[#list]&lt;/code&gt;; The index &lt;code&gt;pos&lt;/code&gt; can also be 0 when &lt;code&gt;#list&lt;/code&gt; is 0, or &lt;code&gt;#list + 1&lt;/code&gt;; in those cases, the function erases the element &lt;code&gt;list[pos]&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;list&lt;/code&gt; 移除位置 &lt;code&gt;pos&lt;/code&gt; 的元素，返回已移除元素的值。当 &lt;code&gt;pos&lt;/code&gt; 是1到 &lt;code&gt;#list&lt;/code&gt; 之间的整数时，它将下移元素 &lt;code&gt;list[pos+1], list[pos+2], &amp;middot;&amp;middot;&amp;middot;, list[#list]&lt;/code&gt; 并擦除元素 &lt;code&gt;list[#list]&lt;/code&gt; ；当 &lt;code&gt;#list&lt;/code&gt; 为0或 &lt;code&gt;#list + 1&lt;/code&gt; 时，索引 &lt;code&gt;pos&lt;/code&gt; 也可以为0 ；在这种情况下，该函数将删除元素 &lt;code&gt;list[pos]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11e20bb227ba77f3bb86f13b7935abd6f4634200" translate="yes" xml:space="preserve">
          <source>Removes the element at the given valid index, shifting down the elements above this index to fill the gap. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">移除给定有效索引的元素,向下移动高于该索引的元素以填补空缺。这个函数不能与伪索引一起调用,因为伪索引不是一个实际的堆栈位置。</target>
        </trans-unit>
        <trans-unit id="1d1ad46541c1bc833d763b9872ae152506b03c2a" translate="yes" xml:space="preserve">
          <source>Renames the file or directory named &lt;code&gt;oldname&lt;/code&gt; to &lt;code&gt;newname&lt;/code&gt;. If this function fails, it returns &lt;b&gt;fail&lt;/b&gt;, plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="translated">将名为 &lt;code&gt;oldname&lt;/code&gt; 的文件或目录重命名为 &lt;code&gt;newname&lt;/code&gt; 。如果此函数失败，则返回&lt;b&gt;fail&lt;/b&gt;，外加描述错误和错误代码的字符串。否则，它返回true。</target>
        </trans-unit>
        <trans-unit id="57bc261321eacee5a6b51aa33ad8b6bdff0d2216" translate="yes" xml:space="preserve">
          <source>Renames the file or directory named &lt;code&gt;oldname&lt;/code&gt; to &lt;code&gt;newname&lt;/code&gt;. If this function fails, it returns &lt;b&gt;nil&lt;/b&gt;, plus a string describing the error and the error code. Otherwise, it returns true.</source>
          <target state="translated">将名为 &lt;code&gt;oldname&lt;/code&gt; 的文件或目录重命名为 &lt;code&gt;newname&lt;/code&gt; 。如果此函数失败，则返回&lt;b&gt;nil&lt;/b&gt;，加上描述错误和错误代码的字符串。否则，它返回true。</target>
        </trans-unit>
        <trans-unit id="6fa4b690dd13963596a568015e6ef34dfd9eea75" translate="yes" xml:space="preserve">
          <source>Resets a thread, cleaning its call stack and closing all pending to-be-closed variables. Returns a status code: &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; for no errors in closing methods, or an error status otherwise. In case of error, leaves the error object on the top of the stack,</source>
          <target state="translated">重置线程，清理其调用堆栈并关闭所有待处理的待关闭变量。返回状态码：&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt;，表示关闭方法没有错误，否则返回错误状态。如果发生错误，请将错误对象保留在堆栈的顶部，</target>
        </trans-unit>
        <trans-unit id="0ce3bd88cc94ffb61167bb8f7b9e843c7604f13b" translate="yes" xml:space="preserve">
          <source>Results are returned using the &lt;b&gt;return&lt;/b&gt; statement (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;). If control reaches the end of a function without encountering a &lt;b&gt;return&lt;/b&gt; statement, then the function returns with no results.</source>
          <target state="translated">使用&lt;b&gt;return&lt;/b&gt;语句返回结果（请参见第&lt;a href=&quot;#3.3.4&quot;&gt;3.3.4节&lt;/a&gt;）。如果控制在未遇到&lt;b&gt;return&lt;/b&gt;语句的情况下到达了函数的末尾，则该函数将不返回任何结果。</target>
        </trans-unit>
        <trans-unit id="244c963cdbd920ed3e3a03fe837b76f265d0a0b8" translate="yes" xml:space="preserve">
          <source>Resurrected objects (that is, objects being finalized and objects accessible only through objects being finalized) have a special behavior in weak tables. They are removed from weak values before running their finalizers, but are removed from weak keys only in the next collection after running their finalizers, when such objects are actually freed. This behavior allows the finalizer to access properties associated with the object through weak tables.</source>
          <target state="translated">复活的对象(即被定型的对象和只能通过被定型的对象访问的对象)在弱表中具有特殊的行为。它们在运行它们的定稿器之前从弱值中删除,但只有在运行它们的定稿器之后的下一个集合中才会从弱键中删除,此时这类对象才会真正被释放。这种行为允许定型器通过弱表访问与对象相关的属性。</target>
        </trans-unit>
        <trans-unit id="d0a2349b7422351122e89416a8339b7ba9df8537" translate="yes" xml:space="preserve">
          <source>Returns &quot;&lt;code&gt;integer&lt;/code&gt;&quot; if &lt;code&gt;x&lt;/code&gt; is an integer, &quot;&lt;code&gt;float&lt;/code&gt;&quot; if it is a float, or &lt;b&gt;fail&lt;/b&gt; if &lt;code&gt;x&lt;/code&gt; is not a number.</source>
          <target state="translated">返回&amp;ldquo; &lt;code&gt;integer&lt;/code&gt; &amp;rdquo;如果 &lt;code&gt;x&lt;/code&gt; 是一个整数，&amp;ldquo; &lt;code&gt;float&lt;/code&gt; &amp;rdquo;，如果它是一个浮子，或&lt;b&gt;失败&lt;/b&gt;如果 &lt;code&gt;x&lt;/code&gt; 不是数字。</target>
        </trans-unit>
        <trans-unit id="03118cc39c1e81c1c438cef7d116290590135b5a" translate="yes" xml:space="preserve">
          <source>Returns &quot;&lt;code&gt;integer&lt;/code&gt;&quot; if &lt;code&gt;x&lt;/code&gt; is an integer, &quot;&lt;code&gt;float&lt;/code&gt;&quot; if it is a float, or &lt;b&gt;nil&lt;/b&gt; if &lt;code&gt;x&lt;/code&gt; is not a number.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是一个整数，则返回&amp;ldquo; &lt;code&gt;integer&lt;/code&gt; &amp;rdquo;；如果它是一个浮点数，则返回&amp;ldquo; &lt;code&gt;float&lt;/code&gt; &amp;rdquo;；如果 &lt;code&gt;x&lt;/code&gt; 不是一个数字，则返回&lt;b&gt;nil&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ec136d49176b1dfa086d0b59ff735d87f5d8b25c" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given coroutine can yield, and 0 otherwise.</source>
          <target state="translated">如果给定的coroutine可以产生,则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="36a260eb163a20a6982a495d8fcda57196ae377b" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given index is not valid or if the value at this index is &lt;b&gt;nil&lt;/b&gt;, and 0 otherwise.</source>
          <target state="translated">如果给定索引无效或该索引处的值为&lt;b&gt;nil&lt;/b&gt;，则返回1，否则返回0。</target>
        </trans-unit>
        <trans-unit id="8a03c180e8267d605c7828397144f7c543874d2c" translate="yes" xml:space="preserve">
          <source>Returns 1 if the given index is not valid, and 0 otherwise.</source>
          <target state="translated">如果给定的索引无效,则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="8d7984f5b9d91f61d05816274d72ac1e8b987b70" translate="yes" xml:space="preserve">
          <source>Returns 1 if the two values in indices &lt;code&gt;index1&lt;/code&gt; and &lt;code&gt;index2&lt;/code&gt; are primitively equal (that is, equal without calling the &lt;code&gt;__eq&lt;/code&gt; metamethod). Otherwise returns 0. Also returns 0 if any of the indices are not valid.</source>
          <target state="translated">如果索引 &lt;code&gt;index1&lt;/code&gt; 和 &lt;code&gt;index2&lt;/code&gt; 中的两个值最初相等（即不调用 &lt;code&gt;__eq&lt;/code&gt; 元方法就等于），则返回1 。否则返回0。如果任何索引无效，也返回0。</target>
        </trans-unit>
        <trans-unit id="4abb71a0bd2d89035111fe1406578f64ee99f1cd" translate="yes" xml:space="preserve">
          <source>Returns 1 if the two values in indices &lt;code&gt;index1&lt;/code&gt; and &lt;code&gt;index2&lt;/code&gt; are primitively equal (that is, without calling the &lt;code&gt;__eq&lt;/code&gt; metamethod). Otherwise returns 0. Also returns 0 if any of the indices are not valid.</source>
          <target state="translated">如果索引 &lt;code&gt;index1&lt;/code&gt; 和 &lt;code&gt;index2&lt;/code&gt; 中的两个值基本相等（即，不调用 &lt;code&gt;__eq&lt;/code&gt; 元方法），则返回1 。否则返回0。如果任何索引无效，也返回0。</target>
        </trans-unit>
        <trans-unit id="77b6c0faff8f019e54587bee38b27269e8ece2d8" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is &lt;b&gt;nil&lt;/b&gt;, and 0 otherwise.</source>
          <target state="translated">如果给定索引处的值为&lt;b&gt;nil&lt;/b&gt;，则返回1，否则返回0。</target>
        </trans-unit>
        <trans-unit id="acad229e61c0f7b3cf84876f85fd1aed4340fdeb" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a C function, and 0 otherwise.</source>
          <target state="translated">如果给定索引的值是一个C函数,则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="c6d1286ca58fd2bca52facd7ccf6f424aa47dca4" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a boolean, and 0 otherwise.</source>
          <target state="translated">如果给定索引的值是布尔值,则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="04d4d0a8fc1e9ff9c642f37982cd6541f074eaf2" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a function (either C or Lua), and 0 otherwise.</source>
          <target state="translated">如果给定索引处的值是一个函数(C或Lua),则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="85c97cef398c89971e6d5d95362f5833c0efeb94" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a light userdata, and 0 otherwise.</source>
          <target state="translated">如果给定索引处的值是一个轻量级用户数据,则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="293be583246b5c6f5755824ebef65496d84be9b9" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a number or a string convertible to a number, and 0 otherwise.</source>
          <target state="translated">如果给定索引的值是一个数字或可转换为数字的字符串,则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="1ef629a2e4c4bd109da15d0096305f549d521e11" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a string or a number (which is always convertible to a string), and 0 otherwise.</source>
          <target state="translated">如果给定索引的值是字符串或数字(总是可以转换为字符串),则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="b24b734f996f24f0d2edcb352efb5d0a8733d485" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a table, and 0 otherwise.</source>
          <target state="translated">如果给定索引处的值是一个表,则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="6452edfae9b54954154513a55afe95f60e75b4fa" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a thread, and 0 otherwise.</source>
          <target state="translated">如果给定索引的值是线程,则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="fbf8a110fe7143ca6d907ca070a5c03ffa0f2050" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is a userdata (either full or light), and 0 otherwise.</source>
          <target state="translated">如果给定索引处的值是用户数据(full或light),则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="83893644ee4437282f1a7daf1d6a53c7e83643da" translate="yes" xml:space="preserve">
          <source>Returns 1 if the value at the given index is an integer (that is, the value is a number and is represented as an integer), and 0 otherwise.</source>
          <target state="translated">如果给定索引的值是一个整数(也就是说,该值是一个数字,并以整数表示),则返回1,否则返回0。</target>
        </trans-unit>
        <trans-unit id="671cca4567b26fcc0ceb0e43e3d2829f1469cdbb" translate="yes" xml:space="preserve">
          <source>Returns &lt;b&gt;fail&lt;/b&gt; if there is no active hook.</source>
          <target state="translated">如果没有活动的钩子，则返回&lt;b&gt;失败&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="e0d04eca2996cc50939c173c775d0d5f069d8627" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pops nothing) when the index &lt;code&gt;n&lt;/code&gt; is greater than the number of upvalues.</source>
          <target state="translated">当索引 &lt;code&gt;n&lt;/code&gt; 大于上限值的数量时，返回 &lt;code&gt;NULL&lt;/code&gt; （并且不弹出任何内容）。</target>
        </trans-unit>
        <trans-unit id="f56ddb3bc18ad7e4888cfe9050da5f11bd833971" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pops nothing) when the index is greater than the number of active local variables.</source>
          <target state="translated">当索引大于活动局部变量的数量时，返回 &lt;code&gt;NULL&lt;/code&gt; （并且不弹出任何内容）。</target>
        </trans-unit>
        <trans-unit id="57d7205f6585ea512d11e87992ca7441e1e7627e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;NULL&lt;/code&gt; (and pushes nothing) when the index is greater than the number of active local variables.</source>
          <target state="translated">当索引大于活动局部变量的数量时，返回 &lt;code&gt;NULL&lt;/code&gt; （并且不进行任何操作）。</target>
        </trans-unit>
        <trans-unit id="33a341b65f8f92cdfebf70c0c2e075fb9c61bdea" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;udata&lt;/code&gt;, or &lt;b&gt;fail&lt;/b&gt; if the userdata does not have that value.</source>
          <target state="translated">返回 &lt;code&gt;udata&lt;/code&gt; ，如果userdata没有该值，则&lt;b&gt;失败&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="cfcdfcdeac01eab8c7e33e91fd9027aed705b576" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;udata&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;udata&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95b61d5c1d6df056ea18d8531706d5088a5cc2ec" translate="yes" xml:space="preserve">
          <source>Returns a binary string containing the values &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt;, etc. packed (that is, serialized in binary form) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="translated">返回一个二进制字符串，其中包含值 &lt;code&gt;v1&lt;/code&gt; ， &lt;code&gt;v2&lt;/code&gt; 等。根据格式字符串 &lt;code&gt;fmt&lt;/code&gt; （请参见&lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;）打包（即以二进制形式序列化）。</target>
        </trans-unit>
        <trans-unit id="b9eaabee84b326fc38aa7a158662184bb8db15f9" translate="yes" xml:space="preserve">
          <source>Returns a binary string containing the values &lt;code&gt;v1&lt;/code&gt;, &lt;code&gt;v2&lt;/code&gt;, etc. serialized in binary form (packed) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="translated">返回一个包含值 &lt;code&gt;v1&lt;/code&gt; ， &lt;code&gt;v2&lt;/code&gt; 等的二进制字符串，该值按照格式字符串 &lt;code&gt;fmt&lt;/code&gt; （请参见第&lt;a href=&quot;#6.4.2&quot;&gt;6.4.2节&lt;/a&gt;）以二进制形式（打包）进行序列化（打包）。</target>
        </trans-unit>
        <trans-unit id="34fa3ab9c6fcc7c0b0e41c857bf1c60b601f5344" translate="yes" xml:space="preserve">
          <source>Returns a boolean, true if and only if integer &lt;code&gt;m&lt;/code&gt; is below integer &lt;code&gt;n&lt;/code&gt; when they are compared as unsigned integers.</source>
          <target state="translated">返回一个布尔值，当且仅当整数 &lt;code&gt;m&lt;/code&gt; 低于整数 &lt;code&gt;n&lt;/code&gt; 当他们为无符号整数比较。</target>
        </trans-unit>
        <trans-unit id="83c4b62eb52291289917793f1a6cc1b8ea7a62cf" translate="yes" xml:space="preserve">
          <source>Returns a copy of &lt;code&gt;s&lt;/code&gt; in which all (or the first &lt;code&gt;n&lt;/code&gt;, if given) occurrences of the &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) have been replaced by a replacement string specified by &lt;code&gt;repl&lt;/code&gt;, which can be a string, a table, or a function. &lt;code&gt;gsub&lt;/code&gt; also returns, as its second value, the total number of matches that occurred. The name &lt;code&gt;gsub&lt;/code&gt; comes from &lt;em&gt;Global SUBstitution&lt;/em&gt;.</source>
          <target state="translated">返回的一个副本 &lt;code&gt;s&lt;/code&gt; ，其中所有（或第一 &lt;code&gt;n&lt;/code&gt; ，如果给出）的的出现 &lt;code&gt;pattern&lt;/code&gt; （见&lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;）已被替换，通过指定一个替换字符串 &lt;code&gt;repl&lt;/code&gt; ，它可以是一个字符串，一个表，或者功能。 &lt;code&gt;gsub&lt;/code&gt; 还返回发生的匹配总数作为第二个值。这个名字 &lt;code&gt;gsub&lt;/code&gt; 来自&lt;em&gt;全局替换&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="2ddd8b557487a7047dc27604858d100902c9eec4" translate="yes" xml:space="preserve">
          <source>Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the ISO C function &lt;code&gt;sprintf&lt;/code&gt;. The only differences are that the options/modifiers &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt; are not supported and that there is an extra option, &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">根据第一个参数（必须是字符串）中给出的描述，返回其可变数量的参数的格式版本。格式字符串遵循与ISO C函数 &lt;code&gt;sprintf&lt;/code&gt; 相同的规则。唯一的区别是不支持选项/修饰符 &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; ，并且还有一个附加选项 &lt;code&gt;q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf32d68131adf8c84f92b82d86f22e200e2d442a" translate="yes" xml:space="preserve">
          <source>Returns a formatted version of its variable number of arguments following the description given in its first argument, which must be a string. The format string follows the same rules as the ISO C function &lt;code&gt;sprintf&lt;/code&gt;. The only differences are that the conversion specifiers and modifiers &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;h&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; are not supported and that there is an extra specifier, &lt;code&gt;q&lt;/code&gt;.</source>
          <target state="translated">按照其第一个参数中给出的描述，返回其可变数量的参数的格式版本，该参数必须是字符串。格式字符串遵循与ISO C函数 &lt;code&gt;sprintf&lt;/code&gt; 相同的规则。唯一的区别是不支持转换说明符和修饰符 &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;h&lt;/code&gt; ， &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; ，并且还有一个额外的说明符 &lt;code&gt;q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="48dde3bd411386a559edd6defab289be69c364ab" translate="yes" xml:space="preserve">
          <source>Returns a new table with all arguments stored into keys 1, 2, etc. and with a field &quot;&lt;code&gt;n&lt;/code&gt;&quot; with the total number of arguments. Note that the resulting table may not be a sequence, if some arguments are &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">返回一个新表，其中所有参数都存储在键1、2等中，字段&amp;ldquo; &lt;code&gt;n&lt;/code&gt; &amp;rdquo;中包含参数总数。请注意，如果某些参数为&lt;b&gt;nil&lt;/b&gt;，则结果表可能不是序列。</target>
        </trans-unit>
        <trans-unit id="4e8f9acfbbc61db53d975814a02f1c9aab94a23d" translate="yes" xml:space="preserve">
          <source>Returns a new table with all parameters stored into keys 1, 2, etc. and with a field &quot;&lt;code&gt;n&lt;/code&gt;&quot; with the total number of parameters. Note that the resulting table may not be a sequence.</source>
          <target state="translated">返回一个新表，该表的所有参数都存储在键1、2等中，并且带有参数总数的字段&amp;ldquo; &lt;code&gt;n&lt;/code&gt; &amp;rdquo;。请注意，结果表可能不是序列。</target>
        </trans-unit>
        <trans-unit id="04445fdc39272b542d188c106147fa8b6a611119" translate="yes" xml:space="preserve">
          <source>Returns a pointer to a raw memory area associated with the given Lua state. The application can use this area for any purpose; Lua does not use it for anything.</source>
          <target state="translated">返回与给定Lua状态相关联的原始内存区域的指针。应用程序可以将该区域用于任何目的;Lua不会将其用于任何目的。</target>
        </trans-unit>
        <trans-unit id="45395b391aa23f00e9e4439bd741094c423c0b46" translate="yes" xml:space="preserve">
          <source>Returns a pointer to the internal copy of the string (see &lt;a href=&quot;#4.1.3&quot;&gt;&amp;sect;4.1.3&lt;/a&gt;).</source>
          <target state="translated">返回一个指向字符串内部副本的指针（请参见第&lt;a href=&quot;#4.1.3&quot;&gt;4.1.3节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4f4330812b83811a6da51b5ddf77a1c753b5a3f8" translate="yes" xml:space="preserve">
          <source>Returns a pointer to the internal copy of the string.</source>
          <target state="translated">返回指向字符串内部副本的指针。</target>
        </trans-unit>
        <trans-unit id="110bc8230211fc8ab3a4f90c96eb53b6ace38d6f" translate="yes" xml:space="preserve">
          <source>Returns a string containing a binary representation (a &lt;em&gt;binary chunk&lt;/em&gt;) of the given function, so that a later &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; on this string returns a copy of the function (but with new upvalues). If &lt;code&gt;strip&lt;/code&gt; is a true value, the binary representation may not include all debug information about the function, to save space.</source>
          <target state="translated">返回一个字符串，其中包含给定函数的二进制表示形式（&lt;em&gt;二进制大块&lt;/em&gt;），以便此字符串上的后续&lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt;返回该函数的副本（但具有新的upvalue）。如果 &lt;code&gt;strip&lt;/code&gt; 是一个真值，则二进制表示形式可能不包含有关该函数的所有调试信息，以节省空间。</target>
        </trans-unit>
        <trans-unit id="7785dcf0d96ed76232f8ceff4782113f5d891ebc" translate="yes" xml:space="preserve">
          <source>Returns a string or a table containing date and time, formatted according to the given string &lt;code&gt;format&lt;/code&gt;.</source>
          <target state="translated">返回一个字符串或一个包含日期和时间的表，其格式按照给定的string &lt;code&gt;format&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e96b629efb1e60f437ca5030afcaedd1ef526018" translate="yes" xml:space="preserve">
          <source>Returns a string that is the concatenation of &lt;code&gt;n&lt;/code&gt; copies of the string &lt;code&gt;s&lt;/code&gt; separated by the string &lt;code&gt;sep&lt;/code&gt;. The default value for &lt;code&gt;sep&lt;/code&gt; is the empty string (that is, no separator). Returns the empty string if &lt;code&gt;n&lt;/code&gt; is not positive.</source>
          <target state="translated">返回一个字符串，该字符串 &lt;code&gt;s&lt;/code&gt; 由字符串 &lt;code&gt;sep&lt;/code&gt; 分隔的字符串s的 &lt;code&gt;n&lt;/code&gt; 个副本的串联。 &lt;code&gt;sep&lt;/code&gt; 的默认值为空字符串（即没有分隔符）。如果 &lt;code&gt;n&lt;/code&gt; 不为正，则返回空字符串。</target>
        </trans-unit>
        <trans-unit id="c23b06e9809db45e6323880c87aa7252a0bafcb4" translate="yes" xml:space="preserve">
          <source>Returns a string that is the string &lt;code&gt;s&lt;/code&gt; reversed.</source>
          <target state="translated">返回与 &lt;code&gt;s&lt;/code&gt; 反向的字符串。</target>
        </trans-unit>
        <trans-unit id="fc7ced1cf6bbd4c86f0ee87b0d833bbb93586b07" translate="yes" xml:space="preserve">
          <source>Returns a string with a file name that can be used for a temporary file. The file must be explicitly opened before its use and explicitly removed when no longer needed.</source>
          <target state="translated">返回一个带有文件名的字符串,可用于临时文件。文件在使用前必须明确打开,不再需要时明确删除。</target>
        </trans-unit>
        <trans-unit id="aa92524d06f459f4bfe53bf566701137d5986c99" translate="yes" xml:space="preserve">
          <source>Returns a table with information about a function. You can give the function directly or you can give a number as the value of &lt;code&gt;f&lt;/code&gt;, which means the function running at level &lt;code&gt;f&lt;/code&gt; of the call stack of the given thread: level 0 is the current function (&lt;code&gt;getinfo&lt;/code&gt; itself); level 1 is the function that called &lt;code&gt;getinfo&lt;/code&gt; (except for tail calls, which do not count in the stack); and so on. If &lt;code&gt;f&lt;/code&gt; is a number greater than the number of active functions, then &lt;code&gt;getinfo&lt;/code&gt; returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">返回包含有关函数信息的表。您可以直接给出函数，也可以给出一个数字作为 &lt;code&gt;f&lt;/code&gt; 的值，这意味着该函数在给定线程的调用堆栈的 &lt;code&gt;f&lt;/code&gt; 级运行：0级是当前函数（ &lt;code&gt;getinfo&lt;/code&gt; 本身）；1级是调用 &lt;code&gt;getinfo&lt;/code&gt; 的函数（尾调用除外，该调用不计入堆栈）；等等。如果 &lt;code&gt;f&lt;/code&gt; 是大于活动函数数的数字，则 &lt;code&gt;getinfo&lt;/code&gt; 返回&lt;b&gt;fail&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="41736de9eba1b5a23348a72c73555dbf11b75db2" translate="yes" xml:space="preserve">
          <source>Returns a table with information about a function. You can give the function directly or you can give a number as the value of &lt;code&gt;f&lt;/code&gt;, which means the function running at level &lt;code&gt;f&lt;/code&gt; of the call stack of the given thread: level 0 is the current function (&lt;code&gt;getinfo&lt;/code&gt; itself); level 1 is the function that called &lt;code&gt;getinfo&lt;/code&gt; (except for tail calls, which do not count on the stack); and so on. If &lt;code&gt;f&lt;/code&gt; is a number larger than the number of active functions, then &lt;code&gt;getinfo&lt;/code&gt; returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">返回包含有关函数信息的表。您可以直接给出函数，也可以给出一个数字作为 &lt;code&gt;f&lt;/code&gt; 的值，这意味着函数在给定线程的调用堆栈的 &lt;code&gt;f&lt;/code&gt; 级运行：0级是当前函数（ &lt;code&gt;getinfo&lt;/code&gt; 本身）；1级是调用 &lt;code&gt;getinfo&lt;/code&gt; 的函数（尾部调用除外，该调用不计入堆栈）；等等。如果 &lt;code&gt;f&lt;/code&gt; 是一个大于活动函数数量的数字，则 &lt;code&gt;getinfo&lt;/code&gt; 返回&lt;b&gt;nil&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="10b30ad1ae8da522aed09e1a02ace7921e1f51a6" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier (as a light userdata) for the upvalue numbered &lt;code&gt;n&lt;/code&gt; from the given function.</source>
          <target state="translated">从给定函数返回唯一的标识符（作为轻量级用户数据），该标识符是升值 &lt;code&gt;n&lt;/code&gt; 的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="0b3fe57552c933213408135c6244c0db831931eb" translate="yes" xml:space="preserve">
          <source>Returns a unique identifier for the upvalue numbered &lt;code&gt;n&lt;/code&gt; from the closure at index &lt;code&gt;funcindex&lt;/code&gt;.</source>
          <target state="translated">从索引 &lt;code&gt;funcindex&lt;/code&gt; 的闭包返回升值 &lt;code&gt;n&lt;/code&gt; 的唯一标识符。</target>
        </trans-unit>
        <trans-unit id="bee587bfd0df43f919edb6f2e537b30c2fff9e47" translate="yes" xml:space="preserve">
          <source>Returns an address to a space of size &lt;code&gt;sz&lt;/code&gt; where you can copy a string to be added to buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). After copying the string into this space you must call &lt;a href=&quot;#luaL_addsize&quot;&gt;&lt;code&gt;luaL_addsize&lt;/code&gt;&lt;/a&gt; with the size of the string to actually add it to the buffer.</source>
          <target state="translated">将地址返回到 &lt;code&gt;sz&lt;/code&gt; 大小的空间，您可以在其中复制要添加到缓冲区 &lt;code&gt;B&lt;/code&gt; 的字符串（请参见&lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt;）。将字符串复制到此空间后，必须使用字符串的大小调用&lt;a href=&quot;#luaL_addsize&quot;&gt; &lt;code&gt;luaL_addsize&lt;/code&gt; &lt;/a&gt;，以将其实际添加到缓冲区中。</target>
        </trans-unit>
        <trans-unit id="aee809e239d975376124c38ef9a8bbd38533ebb2" translate="yes" xml:space="preserve">
          <source>Returns an approximation of the amount in seconds of CPU time used by the program, as returned by the underlying ISO C function &lt;code&gt;clock&lt;/code&gt;.</source>
          <target state="translated">返回底层ISO C函数 &lt;code&gt;clock&lt;/code&gt; 所返回的程序使用的CPU时间的近似值（以秒为单位）。</target>
        </trans-unit>
        <trans-unit id="791d30f65759aca9bc8c2ab0c81b3414394fb75d" translate="yes" xml:space="preserve">
          <source>Returns an approximation of the amount in seconds of CPU time used by the program.</source>
          <target state="translated">返回程序使用的CPU时间的近似值(以秒为单位)。</target>
        </trans-unit>
        <trans-unit id="ed3bd9acca66b3345ff64ecf82770701deaf6e39" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, reads the file according to the given formats. When no format is given, uses &quot;&lt;code&gt;l&lt;/code&gt;&quot; as a default. As an example, the construction</source>
          <target state="translated">返回一个迭代器函数，该函数每次被调用时，都会根据给定的格式读取文件。如果未指定格式，则默认使用&amp;ldquo; &lt;code&gt;l&lt;/code&gt; &amp;rdquo;。例如，建筑</target>
        </trans-unit>
        <trans-unit id="9502ef377c9031927e39c05f93ef446921a0becd" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, returns the next captures from &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) over the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is produced in each call.</source>
          <target state="translated">返回一个迭代器函数，每次调用该迭代器函数，都将在字符串 &lt;code&gt;s&lt;/code&gt; 上从 &lt;code&gt;pattern&lt;/code&gt; （请参见&lt;a href=&quot;#6.4.1&quot;&gt;6.4.1节&lt;/a&gt;）返回下一个捕获。如果 &lt;code&gt;pattern&lt;/code&gt; 未指定捕获，则在每次调用中都会产生整个匹配项。</target>
        </trans-unit>
        <trans-unit id="45001f49f50b2b70b2e8422ff32e20831e96980c" translate="yes" xml:space="preserve">
          <source>Returns an iterator function that, each time it is called, returns the next captures from &lt;code&gt;pattern&lt;/code&gt; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;) over the string &lt;code&gt;s&lt;/code&gt;. If &lt;code&gt;pattern&lt;/code&gt; specifies no captures, then the whole match is produced in each call. A third, optional numeric argument &lt;code&gt;init&lt;/code&gt; specifies where to start the search; its default value is 1 and can be negative.</source>
          <target state="translated">返回一个迭代器函数，每次调用该迭代器函数，都将在字符串 &lt;code&gt;s&lt;/code&gt; 上从 &lt;code&gt;pattern&lt;/code&gt; （请参见&lt;a href=&quot;#6.4.1&quot;&gt;6.4.1节&lt;/a&gt;）返回下一个捕获。如果 &lt;code&gt;pattern&lt;/code&gt; 未指定捕获，则在每次调用中都会产生整个匹配项。第三个可选的数字参数 &lt;code&gt;init&lt;/code&gt; 指定从何处开始搜索；其默认值为1，并且可以为负。</target>
        </trans-unit>
        <trans-unit id="a6d0a5b7853c9d4da9293e66e82d86cf0df6305f" translate="yes" xml:space="preserve">
          <source>Returns the &quot;length&quot; of the value at the given index as a number; it is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). Raises an error if the result of the operation is not an integer. (This case can only happen through metamethods.)</source>
          <target state="translated">以数字形式返回给定索引处的值的&amp;ldquo;长度&amp;rdquo;；它等效于Lua中的' &lt;code&gt;#&lt;/code&gt; '运算符（请参见第&lt;a href=&quot;#3.4.7&quot;&gt;3.4.7节&lt;/a&gt;）。如果运算结果不是整数，则会引发错误。（这种情况只能通过元方法发生。）</target>
        </trans-unit>
        <trans-unit id="ea5fe629e50500647001f1530cb02685325af73a" translate="yes" xml:space="preserve">
          <source>Returns the &quot;length&quot; of the value at the given index as a number; it is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;). Raises an error if the result of the operation is not an integer. (This case only can happen through metamethods.)</source>
          <target state="translated">以数字形式返回给定索引处值的&amp;ldquo;长度&amp;rdquo;；它等效于Lua中的' &lt;code&gt;#&lt;/code&gt; '运算符（请参见第&lt;a href=&quot;#3.4.7&quot;&gt;3.4.7节&lt;/a&gt;）。如果运算结果不是整数，则会引发错误。（这种情况只能通过元方法发生。）</target>
        </trans-unit>
        <trans-unit id="f1e0f7037fc97a264b1135ee9cbbd443e4839b55" translate="yes" xml:space="preserve">
          <source>Returns the &lt;code&gt;n&lt;/code&gt;-th user value associated to the userdata &lt;code&gt;u&lt;/code&gt; plus a boolean, &lt;b&gt;false&lt;/b&gt; if the userdata does not have that value.</source>
          <target state="translated">返回与用户数据 &lt;code&gt;u&lt;/code&gt; 关联的第 &lt;code&gt;n&lt;/code&gt; 个用户值以及一个布尔值，如果用户数据不具有该值，则返回&lt;b&gt;false&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="db78771d6acbed28111d58cf748f20e4959f1e52" translate="yes" xml:space="preserve">
          <source>Returns the Lua value associated to &lt;code&gt;u&lt;/code&gt;. If &lt;code&gt;u&lt;/code&gt; is not a full userdata, returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">返回与 &lt;code&gt;u&lt;/code&gt; 关联的Lua值。如果 &lt;code&gt;u&lt;/code&gt; 不是完整的用户数据，则返回&lt;b&gt;nil&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="d1851a04bfd13cc05cd523998c36bdc322db17e1" translate="yes" xml:space="preserve">
          <source>Returns the absolute value of &lt;code&gt;x&lt;/code&gt;. (integer/float)</source>
          <target state="translated">返回 &lt;code&gt;x&lt;/code&gt; 的绝对值。（整数/浮点数）</target>
        </trans-unit>
        <trans-unit id="043e0287b11b1a9c8f88357339923c8234440ef7" translate="yes" xml:space="preserve">
          <source>Returns the address of the current content of buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;). Note that any addition to the buffer may invalidate this address.</source>
          <target state="translated">返回缓冲区 &lt;code&gt;B&lt;/code&gt; 当前内容的地址（请参见&lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt;）。请注意，对缓冲区的任何添加都可能使该地址无效。</target>
        </trans-unit>
        <trans-unit id="19e9a2e3f9c2da4b70e14502d18cc907361074e9" translate="yes" xml:space="preserve">
          <source>Returns the address of the version number (a C static variable) stored in the Lua core. When called with a valid &lt;a href=&quot;#lua_State&quot;&gt;&lt;code&gt;lua_State&lt;/code&gt;&lt;/a&gt;, returns the address of the version used to create that state. When called with &lt;code&gt;NULL&lt;/code&gt;, returns the address of the version running the call.</source>
          <target state="translated">返回存储在Lua核心中的版本号的地址（C静态变量）。当使用有效的&lt;a href=&quot;#lua_State&quot;&gt; &lt;code&gt;lua_State&lt;/code&gt; 调用时&lt;/a&gt;，返回用于创建该状态的版本的地址。使用 &lt;code&gt;NULL&lt;/code&gt; 调用时，返回运行调用的版本的地址。</target>
        </trans-unit>
        <trans-unit id="d492dc5dd4aa5f92735d2073fff7474e1a6b394e" translate="yes" xml:space="preserve">
          <source>Returns the arc cosine of &lt;code&gt;x&lt;/code&gt; (in radians).</source>
          <target state="translated">返回 &lt;code&gt;x&lt;/code&gt; 的反余弦（以弧度为单位）。</target>
        </trans-unit>
        <trans-unit id="f089a8dff08d67188de1f7c5039f149b9fa4a377" translate="yes" xml:space="preserve">
          <source>Returns the arc sine of &lt;code&gt;x&lt;/code&gt; (in radians).</source>
          <target state="translated">返回 &lt;code&gt;x&lt;/code&gt; 的反正弦（以弧度为单位）。</target>
        </trans-unit>
        <trans-unit id="fa1247ba15c62e976046573c6ccc1feeee2f5b6b" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (in radians), but uses the signs of both arguments to find the quadrant of the result. It also handles correctly the case of &lt;code&gt;x&lt;/code&gt; being zero.</source>
          <target state="translated">返回 &lt;code&gt;y/x&lt;/code&gt; 的反正切（以弧度为单位），但使用两个参数的符号查找结果的象限。它还可以正确处理 &lt;code&gt;x&lt;/code&gt; 为零的情况。</target>
        </trans-unit>
        <trans-unit id="94a36782eb1a80f58363dabc61ceebcb41f258d2" translate="yes" xml:space="preserve">
          <source>Returns the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (in radians), but uses the signs of both parameters to find the quadrant of the result. (It also handles correctly the case of &lt;code&gt;x&lt;/code&gt; being zero.)</source>
          <target state="translated">返回 &lt;code&gt;y/x&lt;/code&gt; 的反正切值（以弧度为单位），但使用两个参数的符号查找结果的象限。（它也可以正确处理 &lt;code&gt;x&lt;/code&gt; 为零的情况。）</target>
        </trans-unit>
        <trans-unit id="54bafb79a60778cdf93eb8dffe6dc26866068180" translate="yes" xml:space="preserve">
          <source>Returns the argument with the maximum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">根据Lua运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; 返回具有最大值的参数。</target>
        </trans-unit>
        <trans-unit id="de4793305a62a7e062a99c696537172768770061" translate="yes" xml:space="preserve">
          <source>Returns the argument with the maximum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;. (integer/float)</source>
          <target state="translated">根据Lua运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; 返回具有最大值的参数。（整数/浮点数）</target>
        </trans-unit>
        <trans-unit id="d704759b0150aa7e291bb40d3b9e1aa860586ad0" translate="yes" xml:space="preserve">
          <source>Returns the argument with the minimum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">根据Lua运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; 返回具有最小值的参数。</target>
        </trans-unit>
        <trans-unit id="23b18e62742fdde277f18684dd6adb5af258b562" translate="yes" xml:space="preserve">
          <source>Returns the argument with the minimum value, according to the Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt;. (integer/float)</source>
          <target state="translated">根据Lua运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; 返回具有最小值的参数。（整数/浮点数）</target>
        </trans-unit>
        <trans-unit id="e0191dad2cae73c27ef7de25f92860dda78cff8d" translate="yes" xml:space="preserve">
          <source>Returns the code points (as integers) from all characters in &lt;code&gt;s&lt;/code&gt; that start between byte position &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both included). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. It raises an error if it meets any invalid byte sequence.</source>
          <target state="translated">从字节位置 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; （包括两者）开始的 &lt;code&gt;s&lt;/code&gt; 中所有字符返回代码点（作为整数）。 &lt;code&gt;i&lt;/code&gt; 的默认值为1， &lt;code&gt;j&lt;/code&gt; 的默认值为 &lt;code&gt;i&lt;/code&gt; 。如果遇到任何无效的字节序列，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="008974cf3ea7a0e47cc66825ae9db754a6215ba2" translate="yes" xml:space="preserve">
          <source>Returns the codepoints (as integers) from all characters in &lt;code&gt;s&lt;/code&gt; that start between byte position &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both included). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. It raises an error if it meets any invalid byte sequence.</source>
          <target state="translated">从 &lt;code&gt;s&lt;/code&gt; 的所有字符（从字节位置 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; （包括两者）开始）返回代码点（作为整数）。 &lt;code&gt;i&lt;/code&gt; 的默认值为1， &lt;code&gt;j&lt;/code&gt; 的默认值为 &lt;code&gt;i&lt;/code&gt; 。如果遇到任何无效的字节序列，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="4e9e95635ca72435ec1e4654b329133fcb9b67b6" translate="yes" xml:space="preserve">
          <source>Returns the cosine of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">返回 &lt;code&gt;x&lt;/code&gt; 的余弦（假定为弧度）。</target>
        </trans-unit>
        <trans-unit id="d63943c503fbdbc9daf70eb8b368eb63c603cce5" translate="yes" xml:space="preserve">
          <source>Returns the current hook count.</source>
          <target state="translated">返回当前的钩子数量。</target>
        </trans-unit>
        <trans-unit id="91adc8b466cf6e5462daa3cdcd2555a890c15635" translate="yes" xml:space="preserve">
          <source>Returns the current hook function.</source>
          <target state="translated">返回当前的钩子函数。</target>
        </trans-unit>
        <trans-unit id="77c0c811e0708693f332c243247f1f4509702b82" translate="yes" xml:space="preserve">
          <source>Returns the current hook mask.</source>
          <target state="translated">返回当前的钩子掩码。</target>
        </trans-unit>
        <trans-unit id="dfa58fd57235ee80a6d63769d911723e3534cac8" translate="yes" xml:space="preserve">
          <source>Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count (as set by the &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; function).</source>
          <target state="translated">返回线程的当前钩子设置，为三个值：当前钩子函数，当前钩子掩码和当前钩子计数（由&lt;a href=&quot;#pdf-debug.sethook&quot;&gt; &lt;code&gt;debug.sethook&lt;/code&gt; &lt;/a&gt;函数设置）。</target>
        </trans-unit>
        <trans-unit id="732a0eb24511cdffe2ee8db1f2a63d0d03797e0b" translate="yes" xml:space="preserve">
          <source>Returns the current hook settings of the thread, as three values: the current hook function, the current hook mask, and the current hook count, as set by the &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">返回当前线程的钩子设置，为三个值：当前的钩子函数，当前的钩子掩码和当前的钩子计数（由&lt;a href=&quot;#pdf-debug.sethook&quot;&gt; &lt;code&gt;debug.sethook&lt;/code&gt; &lt;/a&gt;函数设置）。</target>
        </trans-unit>
        <trans-unit id="a4984b9b007c5eee4f424cfbc9e8ac599f7bc3b2" translate="yes" xml:space="preserve">
          <source>Returns the current time when called without arguments, or a time representing the local date and time specified by the given table. This table must have fields &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, and &lt;code&gt;day&lt;/code&gt;, and may have fields &lt;code&gt;hour&lt;/code&gt; (default is 12), &lt;code&gt;min&lt;/code&gt; (default is 0), &lt;code&gt;sec&lt;/code&gt; (default is 0), and &lt;code&gt;isdst&lt;/code&gt; (default is &lt;b&gt;nil&lt;/b&gt;). Other fields are ignored. For a description of these fields, see the &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">不带参数调用时返回当前时间，或表示给定表指定的本地日期和时间的时间。该表必须具有字段 &lt;code&gt;year&lt;/code&gt; ， &lt;code&gt;month&lt;/code&gt; 和 &lt;code&gt;day&lt;/code&gt; ，并且可能具有字段 &lt;code&gt;hour&lt;/code&gt; （默认值为12）， &lt;code&gt;min&lt;/code&gt; （默认值为0）， &lt;code&gt;sec&lt;/code&gt; （默认值为0）和 &lt;code&gt;isdst&lt;/code&gt; （默认值为&lt;b&gt;nil&lt;/b&gt;）。其他字段将被忽略。有关这些字段的说明，请参见&lt;a href=&quot;#pdf-os.date&quot;&gt; &lt;code&gt;os.date&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="1b56d9d3e264bf539db578bb8f6317e05525f18e" translate="yes" xml:space="preserve">
          <source>Returns the destination table &lt;code&gt;a2&lt;/code&gt;.</source>
          <target state="translated">返回目标表 &lt;code&gt;a2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a89ca3dbaee05fa9562365bbb11bd2987b8b36f" translate="yes" xml:space="preserve">
          <source>Returns the difference, in seconds, from time &lt;code&gt;t1&lt;/code&gt; to time &lt;code&gt;t2&lt;/code&gt; (where the times are values returned by &lt;a href=&quot;#pdf-os.time&quot;&gt;&lt;code&gt;os.time&lt;/code&gt;&lt;/a&gt;). In POSIX, Windows, and some other systems, this value is exactly &lt;code&gt;t2&lt;/code&gt;&lt;em&gt;-&lt;/em&gt;&lt;code&gt;t1&lt;/code&gt;.</source>
          <target state="translated">返回从时间 &lt;code&gt;t1&lt;/code&gt; 到时间 &lt;code&gt;t2&lt;/code&gt; 的差（以秒为单位）（其中时间是&lt;a href=&quot;#pdf-os.time&quot;&gt; &lt;code&gt;os.time&lt;/code&gt; &lt;/a&gt;返回的值）。在POSIX，Windows和某些其他系统中，此值恰好是 &lt;code&gt;t2&lt;/code&gt; &lt;em&gt;- &lt;/em&gt; &lt;code&gt;t1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74ef8f0d43907d8993cbf07845e98c64309c4c57" translate="yes" xml:space="preserve">
          <source>Returns the elements from the given list. This function is equivalent to</source>
          <target state="translated">返回给定列表中的元素。这个函数相当于</target>
        </trans-unit>
        <trans-unit id="a0ecb44d1768c16defe86a7226eb7cdb677c4d76" translate="yes" xml:space="preserve">
          <source>Returns the index of the top element in the stack. Because indices start at 1, this result is equal to the number of elements in the stack; in particular, 0 means an empty stack.</source>
          <target state="translated">返回堆栈中顶部元素的索引。因为索引从1开始,所以这个结果等于堆栈中的元素数,特别是0表示是空堆栈。</target>
        </trans-unit>
        <trans-unit id="aae1a98a2afe7e2f6164ed56d98f2c5601c177ce" translate="yes" xml:space="preserve">
          <source>Returns the integral part of &lt;code&gt;x&lt;/code&gt; and the fractional part of &lt;code&gt;x&lt;/code&gt;. Its second result is always a float.</source>
          <target state="translated">返回的组成部分， &lt;code&gt;x&lt;/code&gt; 和小数部分 &lt;code&gt;x&lt;/code&gt; 。第二个结果始终是浮点数。</target>
        </trans-unit>
        <trans-unit id="d07d66699f96edb0b840ccb7b505ca206ea713f8" translate="yes" xml:space="preserve">
          <source>Returns the internal numeric codes of the characters &lt;code&gt;s[i]&lt;/code&gt;, &lt;code&gt;s[i+1]&lt;/code&gt;, ..., &lt;code&gt;s[j]&lt;/code&gt;. The default value for &lt;code&gt;i&lt;/code&gt; is 1; the default value for &lt;code&gt;j&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;. These indices are corrected following the same rules of function &lt;a href=&quot;#pdf-string.sub&quot;&gt;&lt;code&gt;string.sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回字符 &lt;code&gt;s[i]&lt;/code&gt; ， &lt;code&gt;s[i+1]&lt;/code&gt; ，...， &lt;code&gt;s[j]&lt;/code&gt; 的内部数字代码。 &lt;code&gt;i&lt;/code&gt; 的默认值为1；默认值为1。默认值 &lt;code&gt;j&lt;/code&gt; 是 &lt;code&gt;i&lt;/code&gt; 。这些索引将按照功能&lt;a href=&quot;#pdf-string.sub&quot;&gt; &lt;code&gt;string.sub&lt;/code&gt; &lt;/a&gt;的相同规则进行更正。</target>
        </trans-unit>
        <trans-unit id="b30312394bff808c7607188052990ddfc3f0af18" translate="yes" xml:space="preserve">
          <source>Returns the largest integral value less than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">返回小于或等于 &lt;code&gt;x&lt;/code&gt; 的最大整数值。</target>
        </trans-unit>
        <trans-unit id="37a74944cfaba1cf96089aa04c3aab36bd768194" translate="yes" xml:space="preserve">
          <source>Returns the largest integral value smaller than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">返回小于或等于 &lt;code&gt;x&lt;/code&gt; 的最大整数值。</target>
        </trans-unit>
        <trans-unit id="6b65eebb8bdbd39036e0d29924f25daa397f311e" translate="yes" xml:space="preserve">
          <source>Returns the length of the current content of buffer &lt;code&gt;B&lt;/code&gt; (see &lt;a href=&quot;#luaL_Buffer&quot;&gt;&lt;code&gt;luaL_Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">返回缓冲区 &lt;code&gt;B&lt;/code&gt; 当前内容的长度（请参见&lt;a href=&quot;#luaL_Buffer&quot;&gt; &lt;code&gt;luaL_Buffer&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a82986faba63c6df7b4a7e1f2c3e8675bebec131" translate="yes" xml:space="preserve">
          <source>Returns the length of the object &lt;code&gt;v&lt;/code&gt;, which must be a table or a string, without invoking the &lt;code&gt;__len&lt;/code&gt; metamethod. Returns an integer.</source>
          <target state="translated">返回对象 &lt;code&gt;v&lt;/code&gt; 的长度，该对象必须是表或字符串，而不调用 &lt;code&gt;__len&lt;/code&gt; 元方法。返回一个整数。</target>
        </trans-unit>
        <trans-unit id="4d195539511c55ff9d09810f9cb9cabd46d5d2c6" translate="yes" xml:space="preserve">
          <source>Returns the length of the value at the given index. It is equivalent to the '&lt;code&gt;#&lt;/code&gt;' operator in Lua (see &lt;a href=&quot;#3.4.7&quot;&gt;&amp;sect;3.4.7&lt;/a&gt;) and may trigger a metamethod for the &quot;length&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). The result is pushed on the stack.</source>
          <target state="translated">返回给定索引处的值的长度。它等效于Lua中的' &lt;code&gt;#&lt;/code&gt; '运算符（请参阅第&lt;a href=&quot;#3.4.7&quot;&gt;3.4.7节&lt;/a&gt;），并且可能会触发&amp;ldquo;长度&amp;rdquo;事件的元方法（请参阅第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。结果被压入堆栈。</target>
        </trans-unit>
        <trans-unit id="ca18490544ebe4ab9d2b88782ccfa4bfa597d5c6" translate="yes" xml:space="preserve">
          <source>Returns the logarithm of &lt;code&gt;x&lt;/code&gt; in the given base. The default for &lt;code&gt;base&lt;/code&gt; is &lt;em&gt;e&lt;/em&gt; (so that the function returns the natural logarithm of &lt;code&gt;x&lt;/code&gt;).</source>
          <target state="translated">返回给定底数的 &lt;code&gt;x&lt;/code&gt; 的对数。 &lt;code&gt;base&lt;/code&gt; 的默认值为&lt;em&gt;e&lt;/em&gt;（以便该函数返回 &lt;code&gt;x&lt;/code&gt; 的自然对数）。</target>
        </trans-unit>
        <trans-unit id="d77d922681562ed53526ab1cca990af72395285d" translate="yes" xml:space="preserve">
          <source>Returns the maximum value between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;-x&lt;/code&gt;. (integer/float)</source>
          <target state="translated">返回 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;-x&lt;/code&gt; 之间的最大值。（整数/浮点数）</target>
        </trans-unit>
        <trans-unit id="d3cb57918cd0fd4016648ae402c7074bcd73a43b" translate="yes" xml:space="preserve">
          <source>Returns the memory-allocation function of a given state. If &lt;code&gt;ud&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, Lua stores in &lt;code&gt;*ud&lt;/code&gt; the opaque pointer given when the memory-allocator function was set.</source>
          <target state="translated">返回给定状态的内存分配函数。如果 &lt;code&gt;ud&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; ，则Lua将在设置内存分配器函数时给出的不透明指针存储在 &lt;code&gt;*ud&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="274b26f09340089c109b77fcaa34ab85c7b27be3" translate="yes" xml:space="preserve">
          <source>Returns the metatable of the given &lt;code&gt;value&lt;/code&gt; or &lt;b&gt;nil&lt;/b&gt; if it does not have a metatable.</source>
          <target state="translated">返回的元表给定的 &lt;code&gt;value&lt;/code&gt; 或者&lt;b&gt;为零&lt;/b&gt;，如果它没有元表。</target>
        </trans-unit>
        <trans-unit id="f827b993d336f39e4e067ba1cd00ca433786753f" translate="yes" xml:space="preserve">
          <source>Returns the name of the type encoded by the value &lt;code&gt;tp&lt;/code&gt;, which must be one the values returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回由值 &lt;code&gt;tp&lt;/code&gt; 编码的类型的名称，该值必须是&lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; &lt;/a&gt;返回的值之一。</target>
        </trans-unit>
        <trans-unit id="b5d2c5467f6b31c133d151a482f437390192631a" translate="yes" xml:space="preserve">
          <source>Returns the name of the type of the value at the given index.</source>
          <target state="translated">返回给定索引处的值的类型名称。</target>
        </trans-unit>
        <trans-unit id="09f17fbeecb99d8ceed703c8e378ebf644bfa53e" translate="yes" xml:space="preserve">
          <source>Returns the new state, or &lt;code&gt;NULL&lt;/code&gt; if there is a memory allocation error.</source>
          <target state="translated">返回新状态，如果存在内存分配错误，则返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d43b7f45fadd64b442bc6cb030aac62b5fed9b46" translate="yes" xml:space="preserve">
          <source>Returns the number of UTF-8 characters in string &lt;code&gt;s&lt;/code&gt; that start between positions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both inclusive). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is -1. If it finds any invalid byte sequence, returns &lt;b&gt;fail&lt;/b&gt; plus the position of the first invalid byte.</source>
          <target state="translated">返回在位置 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; （包括两端）之间的字符串 &lt;code&gt;s&lt;/code&gt; 中的UTF-8字符数。 &lt;code&gt;i&lt;/code&gt; 的默认值为1， &lt;code&gt;j&lt;/code&gt; 的默认值为-1。如果找到任何无效字节序列，则返回&lt;b&gt;失败&lt;/b&gt;加上第一个无效字节的位置。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1fac8d97901da4fcfa21c51273c8ade3e30d4960" translate="yes" xml:space="preserve">
          <source>Returns the number of UTF-8 characters in string &lt;code&gt;s&lt;/code&gt; that start between positions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; (both inclusive). The default for &lt;code&gt;i&lt;/code&gt; is 1 and for &lt;code&gt;j&lt;/code&gt; is -1. If it finds any invalid byte sequence, returns a false value plus the position of the first invalid byte.</source>
          <target state="translated">返回在位置 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; （包括两端）之间的字符串 &lt;code&gt;s&lt;/code&gt; 中的UTF-8字符数。 &lt;code&gt;i&lt;/code&gt; 的默认值为1， &lt;code&gt;j&lt;/code&gt; 的默认值为-1。如果找到任何无效字节序列，则返回一个假值加上第一个无效字节的位置。</target>
        </trans-unit>
        <trans-unit id="84f83acaebe526961dfec0323624b3e5b62c9fd0" translate="yes" xml:space="preserve">
          <source>Returns the position (in bytes) where the encoding of the &lt;code&gt;n&lt;/code&gt;-th character of &lt;code&gt;s&lt;/code&gt; (counting from position &lt;code&gt;i&lt;/code&gt;) starts. A negative &lt;code&gt;n&lt;/code&gt; gets characters before position &lt;code&gt;i&lt;/code&gt;. The default for &lt;code&gt;i&lt;/code&gt; is 1 when &lt;code&gt;n&lt;/code&gt; is non-negative and &lt;code&gt;#s + 1&lt;/code&gt; otherwise, so that &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; gets the offset of the &lt;code&gt;n&lt;/code&gt;-th character from the end of the string. If the specified character is neither in the subject nor right after its end, the function returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">返回 &lt;code&gt;s&lt;/code&gt; 的第 &lt;code&gt;n&lt;/code&gt; 个字符（从位置 &lt;code&gt;i&lt;/code&gt; 开始）的编码开始的位置（以字节为单位）。负数 &lt;code&gt;n&lt;/code&gt; 在位置 &lt;code&gt;i&lt;/code&gt; 之前得到字符。当 &lt;code&gt;n&lt;/code&gt; 为非负数时， &lt;code&gt;i&lt;/code&gt; 的默认值为1，否则为 &lt;code&gt;#s + 1&lt;/code&gt; ，因此 &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; 获得第 &lt;code&gt;n&lt;/code&gt; 个字符到字符串末尾的偏移量。如果指定的字符既不在主题中也不在其结尾之后，则该函数返回&lt;b&gt;fail&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="56c4cc904851482307ead3085d1ccd1030454da6" translate="yes" xml:space="preserve">
          <source>Returns the position (in bytes) where the encoding of the &lt;code&gt;n&lt;/code&gt;-th character of &lt;code&gt;s&lt;/code&gt; (counting from position &lt;code&gt;i&lt;/code&gt;) starts. A negative &lt;code&gt;n&lt;/code&gt; gets characters before position &lt;code&gt;i&lt;/code&gt;. The default for &lt;code&gt;i&lt;/code&gt; is 1 when &lt;code&gt;n&lt;/code&gt; is non-negative and &lt;code&gt;#s + 1&lt;/code&gt; otherwise, so that &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; gets the offset of the &lt;code&gt;n&lt;/code&gt;-th character from the end of the string. If the specified character is neither in the subject nor right after its end, the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">返回 &lt;code&gt;s&lt;/code&gt; 的第 &lt;code&gt;n&lt;/code&gt; 个字符的编码（从位置 &lt;code&gt;i&lt;/code&gt; 开始）的位置（以字节为单位）。负数 &lt;code&gt;n&lt;/code&gt; 在位置 &lt;code&gt;i&lt;/code&gt; 之前得到字符。当 &lt;code&gt;n&lt;/code&gt; 为非负数时， &lt;code&gt;i&lt;/code&gt; 的默认值为1，否则为 &lt;code&gt;#s + 1&lt;/code&gt; ，因此 &lt;code&gt;utf8.offset(s, -n)&lt;/code&gt; 获得第 &lt;code&gt;n&lt;/code&gt; 个字符到字符串末尾的偏移量。如果指定的字符既不在主题中也不在其结尾之后，则该函数返回&lt;b&gt;nil&lt;/b&gt;。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="1e3fa00427da0e5f4dcde3c242518db402bf818a" translate="yes" xml:space="preserve">
          <source>Returns the pseudo-index that represents the &lt;code&gt;i&lt;/code&gt;-th upvalue of the running function (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;). &lt;code&gt;i&lt;/code&gt; must be in the range &lt;em&gt;[1,256]&lt;/em&gt;.</source>
          <target state="translated">返回表示正在运行的函数的第 &lt;code&gt;i&lt;/code&gt; 个上限值的伪索引（请参见&lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;）。 &lt;code&gt;i&lt;/code&gt; 必须在&lt;em&gt;[1,256]&lt;/em&gt;范围内。</target>
        </trans-unit>
        <trans-unit id="bc45c511f20e727c297897c4a412e04b9bb492de" translate="yes" xml:space="preserve">
          <source>Returns the pseudo-index that represents the &lt;code&gt;i&lt;/code&gt;-th upvalue of the running function (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;).</source>
          <target state="translated">返回表示正在运行的函数的第 &lt;code&gt;i&lt;/code&gt; 个上限值的伪索引（请参见&lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="33f56655c8e98bdcbd9254da5f1e14cc5e047720" translate="yes" xml:space="preserve">
          <source>Returns the raw &quot;length&quot; of the value at the given index: for strings, this is the string length; for tables, this is the result of the length operator ('&lt;code&gt;#&lt;/code&gt;') with no metamethods; for userdata, this is the size of the block of memory allocated for the userdata. For other values, this call returns 0.</source>
          <target state="translated">返回给定索引处值的原始&amp;ldquo;长度&amp;rdquo;：对于字符串，这是字符串长度；对于字符串，这是字符串长度。对于表，这是没有元方法的长度运算符（' &lt;code&gt;#&lt;/code&gt; '）的结果；对于用户数据，这是为用户数据分配的内存块的大小。对于其他值，此调用返回0。</target>
        </trans-unit>
        <trans-unit id="39d8bb977f9b8a6f1742fd3f9dc45db22e1fcb68" translate="yes" xml:space="preserve">
          <source>Returns the raw &quot;length&quot; of the value at the given index: for strings, this is the string length; for tables, this is the result of the length operator ('&lt;code&gt;#&lt;/code&gt;') with no metamethods; for userdata, this is the size of the block of memory allocated for the userdata; for other values, it is 0.</source>
          <target state="translated">返回给定索引处值的原始&amp;ldquo;长度&amp;rdquo;：对于字符串，这是字符串长度；对于字符串，这是字符串长度。对于表，这是没有元方法的长度运算符（' &lt;code&gt;#&lt;/code&gt; '）的结果；对于用户数据，这是为用户数据分配的内存块的大小；其他值则为0。</target>
        </trans-unit>
        <trans-unit id="94fe4847ff4993fa7c4fb27d617dd7c02c05a931" translate="yes" xml:space="preserve">
          <source>Returns the registry table (see &lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;).</source>
          <target state="translated">返回注册表表（请参见&lt;a href=&quot;#4.3&quot;&gt;&amp;sect;4.3&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a4878c08432faeac78e45f44f0026ebddb8749ef" translate="yes" xml:space="preserve">
          <source>Returns the registry table (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="translated">返回注册表表（请参见&lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1f182d1d0910847b92e9f446a7345b1cf7e93ffa" translate="yes" xml:space="preserve">
          <source>Returns the remainder of the division of &lt;code&gt;x&lt;/code&gt; by &lt;code&gt;y&lt;/code&gt; that rounds the quotient towards zero. (integer/float)</source>
          <target state="translated">返回 &lt;code&gt;x&lt;/code&gt; 除以 &lt;code&gt;y&lt;/code&gt; 的余数，该余数将商四舍五入为零。（整数/浮点数）</target>
        </trans-unit>
        <trans-unit id="568e6f5ede477aed12d9d477add4ad442b3fde9c" translate="yes" xml:space="preserve">
          <source>Returns the resulting name of the first file that it can open in read mode (after closing the file), or &lt;b&gt;fail&lt;/b&gt; plus an error message if none succeeds. (This error message lists all file names it tried to open.)</source>
          <target state="translated">返回可以在读取模式下打开（关闭文件后）的第一个文件的结果名称，如果没有成功则返回&lt;b&gt;失败&lt;/b&gt;和错误消息。（此错误消息列出了它尝试打开的所有文件名。）</target>
        </trans-unit>
        <trans-unit id="7d00adfd429e9ecb79de1d7e05907584e1f561cc" translate="yes" xml:space="preserve">
          <source>Returns the resulting name of the first file that it can open in read mode (after closing the file), or &lt;b&gt;nil&lt;/b&gt; plus an error message if none succeeds. (This error message lists all file names it tried to open.)</source>
          <target state="translated">返回它可以在读取模式下打开的第一个文件的结果名称（关闭文件后）；如果没有成功，则返回&lt;b&gt;nil&lt;/b&gt;和错误消息。（此错误消息列出了它尝试打开的所有文件名。）</target>
        </trans-unit>
        <trans-unit id="0cafeada936b9b3c536bfda3d7c114159746bc82" translate="yes" xml:space="preserve">
          <source>Returns the running coroutine plus a boolean, true when the running coroutine is the main one.</source>
          <target state="translated">Returns the running coroutine plus a boolean,true when the running coroutine is the main one。</target>
        </trans-unit>
        <trans-unit id="f520f4734dbc499082a5c134aebb7e5257b19210" translate="yes" xml:space="preserve">
          <source>Returns the sine of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">返回 &lt;code&gt;x&lt;/code&gt; 的正弦（假定为弧度）。</target>
        </trans-unit>
        <trans-unit id="da558ef5afc0fc9c0d21911a38e825ff24dcf0a2" translate="yes" xml:space="preserve">
          <source>Returns the size of a string resulting from &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt; with the given format. The format string cannot have the variable-length options '&lt;code&gt;s&lt;/code&gt;' or '&lt;code&gt;z&lt;/code&gt;' (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;).</source>
          <target state="translated">以给定格式返回从&lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt;生成的字符串的大小。格式字符串不能具有可变长度选项&amp;ldquo; &lt;code&gt;s&lt;/code&gt; &amp;rdquo;或&amp;ldquo; &lt;code&gt;z&lt;/code&gt; &amp;rdquo;（请参见第&lt;a href=&quot;#6.4.2&quot;&gt;6.4.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8a271ccad0d5f1305d18e3f34055196791089e29" translate="yes" xml:space="preserve">
          <source>Returns the smallest integral value greater than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">返回大于或等于 &lt;code&gt;x&lt;/code&gt; 的最小整数值。</target>
        </trans-unit>
        <trans-unit id="33b392e0c4352ffea2f8586f23e071e85ca1ffec" translate="yes" xml:space="preserve">
          <source>Returns the smallest integral value larger than or equal to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">返回大于或等于 &lt;code&gt;x&lt;/code&gt; 的最小整数值。</target>
        </trans-unit>
        <trans-unit id="a156517157e4cb0343c49c32e737cf3b8fa30ca3" translate="yes" xml:space="preserve">
          <source>Returns the square root of &lt;code&gt;x&lt;/code&gt;. (You can also use the expression &lt;code&gt;x^0.5&lt;/code&gt; to compute this value.)</source>
          <target state="translated">返回 &lt;code&gt;x&lt;/code&gt; 的平方根。（您也可以使用表达式 &lt;code&gt;x^0.5&lt;/code&gt; 计算该值。）</target>
        </trans-unit>
        <trans-unit id="92c7a785497146b5964e3cfcb16d7bf24c7763b5" translate="yes" xml:space="preserve">
          <source>Returns the status of coroutine &lt;code&gt;co&lt;/code&gt;, as a string: &lt;code&gt;&quot;running&quot;&lt;/code&gt;, if the coroutine is running (that is, it called &lt;code&gt;status&lt;/code&gt;); &lt;code&gt;&quot;suspended&quot;&lt;/code&gt;, if the coroutine is suspended in a call to &lt;code&gt;yield&lt;/code&gt;, or if it has not started running yet; &lt;code&gt;&quot;normal&quot;&lt;/code&gt; if the coroutine is active but not running (that is, it has resumed another coroutine); and &lt;code&gt;&quot;dead&quot;&lt;/code&gt; if the coroutine has finished its body function, or if it has stopped with an error.</source>
          <target state="translated">如果协程正在运行（即称为 &lt;code&gt;status&lt;/code&gt; ），则以字符串形式返回协程 &lt;code&gt;co&lt;/code&gt; 的状态： &lt;code&gt;&quot;running&quot;&lt;/code&gt; 。 &lt;code&gt;&quot;suspended&quot;&lt;/code&gt; ，如果协程在调用 &lt;code&gt;yield&lt;/code&gt; 的过程中被暂停，或者尚未开始运行； &lt;code&gt;&quot;normal&quot;&lt;/code&gt; 如果协程处于活动状态但未运行（也就是说，它已恢复另一个协程）；与 &lt;code&gt;&quot;dead&quot;&lt;/code&gt; 如果协程完成其身体功能，或者如果它已停止错误。</target>
        </trans-unit>
        <trans-unit id="ae60fb59b3fcc2ee3f16755978255651eb156610" translate="yes" xml:space="preserve">
          <source>Returns the status of the coroutine &lt;code&gt;co&lt;/code&gt;, as a string: &lt;code&gt;&quot;running&quot;&lt;/code&gt;, if the coroutine is running (that is, it is the one that called &lt;code&gt;status&lt;/code&gt;); &lt;code&gt;&quot;suspended&quot;&lt;/code&gt;, if the coroutine is suspended in a call to &lt;code&gt;yield&lt;/code&gt;, or if it has not started running yet; &lt;code&gt;&quot;normal&quot;&lt;/code&gt; if the coroutine is active but not running (that is, it has resumed another coroutine); and &lt;code&gt;&quot;dead&quot;&lt;/code&gt; if the coroutine has finished its body function, or if it has stopped with an error.</source>
          <target state="translated">如果协程正在运行（即称为 &lt;code&gt;status&lt;/code&gt; 的协程），则以字符串形式返回协程 &lt;code&gt;co&lt;/code&gt; 的状态： &lt;code&gt;&quot;running&quot;&lt;/code&gt; 。 &lt;code&gt;&quot;suspended&quot;&lt;/code&gt; ，如果协程在调用 &lt;code&gt;yield&lt;/code&gt; 的过程中被暂停，或者尚未开始运行；如果协程处于活动状态但未运行（即已恢复另一个协程），则为 &lt;code&gt;&quot;normal&quot;&lt;/code&gt; ；与 &lt;code&gt;&quot;dead&quot;&lt;/code&gt; 如果协程完成其身体功能，或者如果它已停止错误。</target>
        </trans-unit>
        <trans-unit id="6643f34f054d2169fc15059330c9797cabe4b0f8" translate="yes" xml:space="preserve">
          <source>Returns the status of the thread &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">返回线程 &lt;code&gt;L&lt;/code&gt; 的状态。</target>
        </trans-unit>
        <trans-unit id="ce13df23b5d839e4a1b3c62a7a51b8e7083872ff" translate="yes" xml:space="preserve">
          <source>Returns the substring of &lt;code&gt;s&lt;/code&gt; that starts at &lt;code&gt;i&lt;/code&gt; and continues until &lt;code&gt;j&lt;/code&gt;; &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; can be negative. If &lt;code&gt;j&lt;/code&gt; is absent, then it is assumed to be equal to -1 (which is the same as the string length). In particular, the call &lt;code&gt;string.sub(s,1,j)&lt;/code&gt; returns a prefix of &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;j&lt;/code&gt;, and &lt;code&gt;string.sub(s, -i)&lt;/code&gt; (for a positive &lt;code&gt;i&lt;/code&gt;) returns a suffix of &lt;code&gt;s&lt;/code&gt; with length &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">返回 &lt;code&gt;s&lt;/code&gt; 的子字符串，该子字符串从 &lt;code&gt;i&lt;/code&gt; 开始并一直持续到 &lt;code&gt;j&lt;/code&gt; ； &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 可以为负。如果 &lt;code&gt;j&lt;/code&gt; 不存在，则假定它等于-1（与字符串长度相同）。特别是，调用 &lt;code&gt;string.sub(s,1,j)&lt;/code&gt; 返回长度为 &lt;code&gt;j&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 的前缀，而 &lt;code&gt;string.sub(s, -i)&lt;/code&gt; （对于正数 &lt;code&gt;i&lt;/code&gt; ）返回长度为 &lt;code&gt;i&lt;/code&gt; 的 &lt;code&gt;s&lt;/code&gt; 的后缀。</target>
        </trans-unit>
        <trans-unit id="0d879230a982638cb3037d087aec816766d1bff4" translate="yes" xml:space="preserve">
          <source>Returns the tangent of &lt;code&gt;x&lt;/code&gt; (assumed to be in radians).</source>
          <target state="translated">返回 &lt;code&gt;x&lt;/code&gt; 的切线（假定为弧度）。</target>
        </trans-unit>
        <trans-unit id="aeb49cdc670f656ecf94cc356e8482541619f67b" translate="yes" xml:space="preserve">
          <source>Returns the type of its only argument, coded as a string. The possible results of this function are &quot;&lt;code&gt;nil&lt;/code&gt;&quot; (a string, not the value &lt;b&gt;nil&lt;/b&gt;), &quot;&lt;code&gt;number&lt;/code&gt;&quot;, &quot;&lt;code&gt;string&lt;/code&gt;&quot;, &quot;&lt;code&gt;boolean&lt;/code&gt;&quot;, &quot;&lt;code&gt;table&lt;/code&gt;&quot;, &quot;&lt;code&gt;function&lt;/code&gt;&quot;, &quot;&lt;code&gt;thread&lt;/code&gt;&quot;, and &quot;&lt;code&gt;userdata&lt;/code&gt;&quot;.</source>
          <target state="translated">返回其唯一参数的类型，编码为字符串。该函数的可能结果是&amp;ldquo; &lt;code&gt;nil&lt;/code&gt; &amp;rdquo;（字符串，而不是值&lt;b&gt;nil&lt;/b&gt;），&amp;ldquo; &lt;code&gt;number&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;string&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;boolean&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;table&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;function&lt;/code&gt; &amp;rdquo;，&amp;ldquo; &lt;code&gt;thread&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;userdata&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="b7cc3af32266285b487ea68c1fc6ffc164e146f6" translate="yes" xml:space="preserve">
          <source>Returns the type of the pushed value.</source>
          <target state="translated">返回推送值的类型。</target>
        </trans-unit>
        <trans-unit id="11efeaa1a0a1dad64efc60561b86e6d305ce3e58" translate="yes" xml:space="preserve">
          <source>Returns the type of the value in the given valid index, or &lt;code&gt;LUA_TNONE&lt;/code&gt; for a non-valid (but acceptable) index. The types returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt; are coded by the following constants defined in &lt;code&gt;lua.h&lt;/code&gt;: &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt;&lt;code&gt;LUA_TNIL&lt;/code&gt;&lt;/a&gt; (0), &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt;&lt;code&gt;LUA_TNUMBER&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt;&lt;code&gt;LUA_TBOOLEAN&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt;&lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回给定有效索引中值的类型，或者 &lt;code&gt;LUA_TNONE&lt;/code&gt; 无效（但可接受）索引的LUA_TNONE。&lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; &lt;/a&gt;返回的类型由 &lt;code&gt;lua.h&lt;/code&gt; 中定义的以下常量编码：&lt;a id=&quot;pdf-LUA_TNIL&quot;&gt; &lt;code&gt;LUA_TNIL&lt;/code&gt; &lt;/a&gt;（0），&lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt; &lt;code&gt;LUA_TNUMBER&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt; &lt;code&gt;LUA_TBOOLEAN&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt; &lt;code&gt;LUA_TSTRING&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt; &lt;code&gt;LUA_TTABLE&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt; &lt;code&gt;LUA_TFUNCTION&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt; &lt;code&gt;LUA_TUSERDATA&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt; &lt;code&gt;LUA_TTHREAD&lt;/code&gt; &lt;/a&gt;和&lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt; &lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="386a1f58fe55c34012815a8391ceb7917714f28e" translate="yes" xml:space="preserve">
          <source>Returns the type of the value in the given valid index, or &lt;code&gt;LUA_TNONE&lt;/code&gt; for a non-valid but acceptable index. The types returned by &lt;a href=&quot;#lua_type&quot;&gt;&lt;code&gt;lua_type&lt;/code&gt;&lt;/a&gt; are coded by the following constants defined in &lt;code&gt;lua.h&lt;/code&gt;: &lt;a id=&quot;pdf-LUA_TNIL&quot;&gt;&lt;code&gt;LUA_TNIL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt;&lt;code&gt;LUA_TNUMBER&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt;&lt;code&gt;LUA_TBOOLEAN&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt;&lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回给定有效索引中值的类型，或者 &lt;code&gt;LUA_TNONE&lt;/code&gt; 无效但可接受的索引的LUA_TNONE。&lt;a href=&quot;#lua_type&quot;&gt; &lt;code&gt;lua_type&lt;/code&gt; &lt;/a&gt;返回的类型由 &lt;code&gt;lua.h&lt;/code&gt; 中定义的以下常量编码：&lt;a id=&quot;pdf-LUA_TNIL&quot;&gt; &lt;code&gt;LUA_TNIL&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TNUMBER&quot;&gt; &lt;code&gt;LUA_TNUMBER&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TBOOLEAN&quot;&gt; &lt;code&gt;LUA_TBOOLEAN&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TSTRING&quot;&gt; &lt;code&gt;LUA_TSTRING&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TTABLE&quot;&gt; &lt;code&gt;LUA_TTABLE&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TFUNCTION&quot;&gt; &lt;code&gt;LUA_TFUNCTION&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TUSERDATA&quot;&gt; &lt;code&gt;LUA_TUSERDATA&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_TTHREAD&quot;&gt; &lt;code&gt;LUA_TTHREAD&lt;/code&gt; &lt;/a&gt;和&lt;a id=&quot;pdf-LUA_TLIGHTUSERDATA&quot;&gt; &lt;code&gt;LUA_TLIGHTUSERDATA&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c355c772b6a7cd3959fe3ff1b22ce6913ee6b493" translate="yes" xml:space="preserve">
          <source>Returns the value &lt;em&gt;e&lt;sup&gt;x&lt;/sup&gt;&lt;/em&gt; (where &lt;code&gt;e&lt;/code&gt; is the base of natural logarithms).</source>
          <target state="translated">返回值&lt;em&gt;e &lt;sup&gt;x&lt;/sup&gt;&lt;/em&gt;（其中 &lt;code&gt;e&lt;/code&gt; 是自然对数的底数）。</target>
        </trans-unit>
        <trans-unit id="0fb28ceb3afa0ab32151ee21709c9aa0178b4cd0" translate="yes" xml:space="preserve">
          <source>Returns the value of the process environment variable &lt;code&gt;varname&lt;/code&gt; or &lt;b&gt;fail&lt;/b&gt; if the variable is not defined.</source>
          <target state="translated">将处理返回环境变量的值 &lt;code&gt;varname&lt;/code&gt; 或&lt;b&gt;失败&lt;/b&gt;如果没有定义的变量。</target>
        </trans-unit>
        <trans-unit id="a1f640b6a2396fe00ff3c46e513b55ada5898623" translate="yes" xml:space="preserve">
          <source>Returns the value of the process environment variable &lt;code&gt;varname&lt;/code&gt;, or &lt;b&gt;nil&lt;/b&gt; if the variable is not defined.</source>
          <target state="translated">返回流程环境变量 &lt;code&gt;varname&lt;/code&gt; 的值，如果未定义，则返回&lt;b&gt;nil&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="f3b86e22b7e07287e106fe5463ecf2e5e16d5d52" translate="yes" xml:space="preserve">
          <source>Returns the values packed in string &lt;code&gt;s&lt;/code&gt; (see &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;) according to the format string &lt;code&gt;fmt&lt;/code&gt; (see &lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;). An optional &lt;code&gt;pos&lt;/code&gt; marks where to start reading in &lt;code&gt;s&lt;/code&gt; (default is 1). After the read values, this function also returns the index of the first unread byte in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">根据格式字符串 &lt;code&gt;fmt&lt;/code&gt; （请参见&lt;a href=&quot;#6.4.2&quot;&gt;&amp;sect;6.4.2&lt;/a&gt;），返回打包在字符串 &lt;code&gt;s&lt;/code&gt; （请参见&lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt;）中的值。可选的 &lt;code&gt;pos&lt;/code&gt; 标记从 &lt;code&gt;s&lt;/code&gt; 开始读取的位置（默认为1）。在读取值之后，此函数还返回 &lt;code&gt;s&lt;/code&gt; 中第一个未读取字节的索引。</target>
        </trans-unit>
        <trans-unit id="9da6ffc3c7ea901268412d4b32b6956c0cf722ea" translate="yes" xml:space="preserve">
          <source>Returns the version number of this core.</source>
          <target state="translated">返回该核心的版本号。</target>
        </trans-unit>
        <trans-unit id="bcc3adbac55a1cae7b7dbc056f59867a7e653730" translate="yes" xml:space="preserve">
          <source>Returns three values (an iterator function, the table &lt;code&gt;t&lt;/code&gt;, and 0) so that the construction</source>
          <target state="translated">返回三个值（迭代器函数，表 &lt;code&gt;t&lt;/code&gt; 和0），以便构造</target>
        </trans-unit>
        <trans-unit id="fd4f281c2403b2b4ec6dfa198827f4141e53f9ac" translate="yes" xml:space="preserve">
          <source>Returns true when the coroutine &lt;code&gt;co&lt;/code&gt; can yield. The default for &lt;code&gt;co&lt;/code&gt; is the running coroutine.</source>
          <target state="translated">当协程 &lt;code&gt;co&lt;/code&gt; 可以屈服时返回true 。 &lt;code&gt;co&lt;/code&gt; 的默认值是运行的协程。</target>
        </trans-unit>
        <trans-unit id="7db585fd6f4edc4d15ef6261e32bad83a4e3fc94" translate="yes" xml:space="preserve">
          <source>Returns true when the running coroutine can yield.</source>
          <target state="translated">当运行中的coroutine可以产出时返回true。</target>
        </trans-unit>
        <trans-unit id="86872d97a4648c727afb8bd8743402fb113d9d79" translate="yes" xml:space="preserve">
          <source>Returns values so that the construction</source>
          <target state="translated">返回值,以便构造</target>
        </trans-unit>
        <trans-unit id="c0dd5c1f0b221305574b2b927c5b76675e55a510" translate="yes" xml:space="preserve">
          <source>Rotates the stack elements between the valid index &lt;code&gt;idx&lt;/code&gt; and the top of the stack. The elements are rotated &lt;code&gt;n&lt;/code&gt; positions in the direction of the top, for a positive &lt;code&gt;n&lt;/code&gt;, or &lt;code&gt;-n&lt;/code&gt; positions in the direction of the bottom, for a negative &lt;code&gt;n&lt;/code&gt;. The absolute value of &lt;code&gt;n&lt;/code&gt; must not be greater than the size of the slice being rotated. This function cannot be called with a pseudo-index, because a pseudo-index is not an actual stack position.</source>
          <target state="translated">在有效索引 &lt;code&gt;idx&lt;/code&gt; 和堆栈顶部之间旋转堆栈元素。元素在顶部方向上旋转 &lt;code&gt;n&lt;/code&gt; 个位置（对于正数 &lt;code&gt;n&lt;/code&gt; )，在-底部方向上旋转 &lt;code&gt;-n&lt;/code&gt; 位置，对于负数 &lt;code&gt;n&lt;/code&gt; 。 &lt;code&gt;n&lt;/code&gt; 的绝对值不得大于要旋转的切片的大小。不能使用伪索引调用此函数，因为伪索引不是实际的堆栈位置。</target>
        </trans-unit>
        <trans-unit id="cb167298f69784fe48c5d2a384e7c877c8d9492d" translate="yes" xml:space="preserve">
          <source>Saves any written data to &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">将所有书面数据保存到 &lt;code&gt;file&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="920400471986593c15fc84e450728648c16819e7" translate="yes" xml:space="preserve">
          <source>Searchers should raise no errors and have no side effects in Lua. (They may have side effects in C, for instance by linking the application with a library.)</source>
          <target state="translated">搜索器在Lua中应该不会产生错误,也不会产生副作用。(在C语言中可能会有副作用,例如通过将应用程序与库链接)。</target>
        </trans-unit>
        <trans-unit id="3440752ad05f6155ff5680caecbafde2dc649d9b" translate="yes" xml:space="preserve">
          <source>Searches for the given &lt;code&gt;name&lt;/code&gt; in the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">在给定 &lt;code&gt;path&lt;/code&gt; 搜索给定 &lt;code&gt;name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94692e4b88a2528c0b5e86368b0213b54dbd9884" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt; for more details about garbage collection and some of these options.</source>
          <target state="translated">有关垃圾回收和其中一些选项的更多详细信息，请参见&lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2a18ffdb89ed379138be3152d18086f1d55d2a3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pdf-debug.getlocal&quot;&gt;&lt;code&gt;debug.getlocal&lt;/code&gt;&lt;/a&gt; for more information about variable indices and names.</source>
          <target state="translated">有关变量索引和名称的更多信息，请参见&lt;a href=&quot;#pdf-debug.getlocal&quot;&gt; &lt;code&gt;debug.getlocal&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c68ceaa8d812b1b10a7eea6ccb5e07ce5de30a37" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pdf-debug.getupvalue&quot;&gt;&lt;code&gt;debug.getupvalue&lt;/code&gt;&lt;/a&gt; for more information about upvalues.</source>
          <target state="translated">有关&lt;a href=&quot;#pdf-debug.getupvalue&quot;&gt; &lt;code&gt;debug.getupvalue&lt;/code&gt; &lt;/a&gt;的更多信息，请参见debug.getupvalue。</target>
        </trans-unit>
        <trans-unit id="8806221244780430f4dab1be1efe9e1deb956088" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#pdf-warn&quot;&gt;&lt;code&gt;warn&lt;/code&gt;&lt;/a&gt; for more details about warnings.</source>
          <target state="translated">有关&lt;a href=&quot;#pdf-warn&quot;&gt; &lt;code&gt;warn&lt;/code&gt; &lt;/a&gt;的更多详细信息，请参阅警告。</target>
        </trans-unit>
        <trans-unit id="c3360426ce5422bc56d751e0aa6008fce46fc70e" translate="yes" xml:space="preserve">
          <source>See function &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; for the caveats of modifying the table during its traversal.</source>
          <target state="translated">有关在遍历过程中修改表的注意事项，请参见&lt;a href=&quot;#pdf-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="19f37898f520273219e289bdee9a8581baa73269" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;x&lt;/code&gt; as the &quot;seed&quot; for the pseudo-random generator: equal seeds produce equal sequences of numbers.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 设置为伪随机数生成器的&amp;ldquo;种子&amp;rdquo;：相等的种子产生相等的数字序列。</target>
        </trans-unit>
        <trans-unit id="0d4c31b081bb4e342a5c7b04bb15e6651ad21d58" translate="yes" xml:space="preserve">
          <source>Sets a new limit for the C stack. This limit controls how deeply nested calls can go in Lua, with the intent of avoiding a stack overflow. A limit too small restricts recursive calls pointlessly; a limit too large exposes the interpreter to stack-overflow crashes. Unfortunately, there is no way to know a priori the maximum safe limit for a platform.</source>
          <target state="translated">设置C栈的新限制。这个限制控制了Lua中嵌套调用的深度,目的是避免堆栈溢出。过小的限制会毫无意义地限制递归调用;过大的限制会使解释器面临堆栈溢出的崩溃。不幸的是,没有办法先验地知道一个平台的最大安全限制。</target>
        </trans-unit>
        <trans-unit id="7966d7ba898208a4bfff8332d8d2ce5eab98e952" translate="yes" xml:space="preserve">
          <source>Sets a new limit for the C stack. This limit controls how deeply nested calls can go in Lua, with the intent of avoiding a stack overflow. Returns the old limit in case of success, or zero in case of error. For more details about this function, see &lt;a href=&quot;#pdf-debug.setcstacklimit&quot;&gt;&lt;code&gt;debug.setcstacklimit&lt;/code&gt;&lt;/a&gt;, its equivalent in the standard library.</source>
          <target state="translated">设置C堆栈的新限制。此限制控制嵌套调用可以在Lua中进行的深度，目的是避免堆栈溢出。如果成功，则返回旧限制；如果错误，则返回零。有关此函数的更多详细信息，请参见&lt;a href=&quot;#pdf-debug.setcstacklimit&quot;&gt; &lt;code&gt;debug.setcstacklimit&lt;/code&gt; &lt;/a&gt;，它在标准库中的等效项。</target>
        </trans-unit>
        <trans-unit id="5ffaec0474c3c12ab33648528a0c531a28325cf4" translate="yes" xml:space="preserve">
          <source>Sets a new panic function and returns the old one (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;).</source>
          <target state="translated">设置一个新的应急函数并返回旧的应急函数（请参见&lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="0b2903d5c5e2f6aac5cee42b812f29848f11b229" translate="yes" xml:space="preserve">
          <source>Sets a new panic function and returns the old one (see &lt;a href=&quot;#4.6&quot;&gt;&amp;sect;4.6&lt;/a&gt;).</source>
          <target state="translated">设置新的应急函数并返回旧的应急函数（请参见第&lt;a href=&quot;#4.6&quot;&gt;4.6节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="10482f8b5b12a1f1db635550932f8faad32fd81b" translate="yes" xml:space="preserve">
          <source>Sets and gets the file position, measured from the beginning of the file, to the position given by &lt;code&gt;offset&lt;/code&gt; plus a base specified by the string &lt;code&gt;whence&lt;/code&gt;, as follows:</source>
          <target state="translated">设置并获取文件位置（从文件开头开始测量）到 &lt;code&gt;offset&lt;/code&gt; 加上字符串 &lt;code&gt;whence&lt;/code&gt; 指定的基数所指定的位置，如下所示：</target>
        </trans-unit>
        <trans-unit id="c75eca40914b6c7ff395b6a435b1b2509e75386b" translate="yes" xml:space="preserve">
          <source>Sets the C function &lt;code&gt;f&lt;/code&gt; as the new value of global &lt;code&gt;name&lt;/code&gt;. It is defined as a macro:</source>
          <target state="translated">将C函数 &lt;code&gt;f&lt;/code&gt; 设置为global &lt;code&gt;name&lt;/code&gt; 的新值。它定义为宏：</target>
        </trans-unit>
        <trans-unit id="081317fb6ecee7ae4baa46c02f924ee275f76a03" translate="yes" xml:space="preserve">
          <source>Sets the buffering mode for a file. There are three available modes:</source>
          <target state="translated">设置文件的缓冲模式。有三种可用的模式。</target>
        </trans-unit>
        <trans-unit id="de2f1f4dd9362493d0d4861f3dfe60cc83af4578" translate="yes" xml:space="preserve">
          <source>Sets the buffering mode for an output file. There are three available modes:</source>
          <target state="translated">设置输出文件的缓冲模式。有三种可用的模式。</target>
        </trans-unit>
        <trans-unit id="47362e1529f7af535b225ac5e5e41ff2aab64e46" translate="yes" xml:space="preserve">
          <source>Sets the current locale of the program. &lt;code&gt;locale&lt;/code&gt; is a system-dependent string specifying a locale; &lt;code&gt;category&lt;/code&gt; is an optional string describing which category to change: &lt;code&gt;&quot;all&quot;&lt;/code&gt;, &lt;code&gt;&quot;collate&quot;&lt;/code&gt;, &lt;code&gt;&quot;ctype&quot;&lt;/code&gt;, &lt;code&gt;&quot;monetary&quot;&lt;/code&gt;, &lt;code&gt;&quot;numeric&quot;&lt;/code&gt;, or &lt;code&gt;&quot;time&quot;&lt;/code&gt;; the default category is &lt;code&gt;&quot;all&quot;&lt;/code&gt;. The function returns the name of the new locale, or &lt;b&gt;fail&lt;/b&gt; if the request cannot be honored.</source>
          <target state="translated">设置程序的当前语言环境。 &lt;code&gt;locale&lt;/code&gt; 是与系统有关的字符串，用于指定语言环境； &lt;code&gt;category&lt;/code&gt; 是一个可选字符串，描述了要更改的类别： &lt;code&gt;&quot;all&quot;&lt;/code&gt; ， &lt;code&gt;&quot;collate&quot;&lt;/code&gt; ， &lt;code&gt;&quot;ctype&quot;&lt;/code&gt; ， &lt;code&gt;&quot;monetary&quot;&lt;/code&gt; ， &lt;code&gt;&quot;numeric&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;time&quot;&lt;/code&gt; ；默认类别为 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 。该函数返回新语言环境的名称，如果无法接受该请求，则该函数&lt;b&gt;失败&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="772769933fe32ebc8452718b212f21e2ae3b3d0a" translate="yes" xml:space="preserve">
          <source>Sets the current locale of the program. &lt;code&gt;locale&lt;/code&gt; is a system-dependent string specifying a locale; &lt;code&gt;category&lt;/code&gt; is an optional string describing which category to change: &lt;code&gt;&quot;all&quot;&lt;/code&gt;, &lt;code&gt;&quot;collate&quot;&lt;/code&gt;, &lt;code&gt;&quot;ctype&quot;&lt;/code&gt;, &lt;code&gt;&quot;monetary&quot;&lt;/code&gt;, &lt;code&gt;&quot;numeric&quot;&lt;/code&gt;, or &lt;code&gt;&quot;time&quot;&lt;/code&gt;; the default category is &lt;code&gt;&quot;all&quot;&lt;/code&gt;. The function returns the name of the new locale, or &lt;b&gt;nil&lt;/b&gt; if the request cannot be honored.</source>
          <target state="translated">设置程序的当前语言环境。 &lt;code&gt;locale&lt;/code&gt; 是一个系统相关的字符串，指定一个语言环境； &lt;code&gt;category&lt;/code&gt; 是描述要更改的类别的可选字符串： &lt;code&gt;&quot;all&quot;&lt;/code&gt; ， &lt;code&gt;&quot;collate&quot;&lt;/code&gt; ， &lt;code&gt;&quot;ctype&quot;&lt;/code&gt; ， &lt;code&gt;&quot;monetary&quot;&lt;/code&gt; ， &lt;code&gt;&quot;numeric&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;time&quot;&lt;/code&gt; ; 默认类别为 &lt;code&gt;&quot;all&quot;&lt;/code&gt; 。该函数返回新语言环境的名称，如果不能接受该请求，则返回&lt;b&gt;nil&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="577d8bdc520c0556720156fb048d7cc9591b0b65" translate="yes" xml:space="preserve">
          <source>Sets the debugging hook function.</source>
          <target state="translated">设置调试钩子功能。</target>
        </trans-unit>
        <trans-unit id="0e50f7de74529ef0127c0979e57072500795bcf0" translate="yes" xml:space="preserve">
          <source>Sets the given &lt;code&gt;value&lt;/code&gt; as the &lt;code&gt;n&lt;/code&gt;-th user value associated to the given &lt;code&gt;udata&lt;/code&gt;. &lt;code&gt;udata&lt;/code&gt; must be a full userdata.</source>
          <target state="translated">设置给定 &lt;code&gt;value&lt;/code&gt; 作为 &lt;code&gt;n&lt;/code&gt; 与给定个用户价值 &lt;code&gt;udata&lt;/code&gt; 。 &lt;code&gt;udata&lt;/code&gt; 必须是完整的用户数据。</target>
        </trans-unit>
        <trans-unit id="292ec4e82927af4194013aa2f75932b01e97689c" translate="yes" xml:space="preserve">
          <source>Sets the given &lt;code&gt;value&lt;/code&gt; as the Lua value associated to the given &lt;code&gt;udata&lt;/code&gt;. &lt;code&gt;udata&lt;/code&gt; must be a full userdata.</source>
          <target state="translated">将给定 &lt;code&gt;value&lt;/code&gt; 设置为与给定 &lt;code&gt;udata&lt;/code&gt; 关联的Lua值。 &lt;code&gt;udata&lt;/code&gt; 必须是完整的用户数据。</target>
        </trans-unit>
        <trans-unit id="0f680b53b706554348285320cb60fd7dd4bf3ce4" translate="yes" xml:space="preserve">
          <source>Sets the given function as a hook. The string &lt;code&gt;mask&lt;/code&gt; and the number &lt;code&gt;count&lt;/code&gt; describe when the hook will be called. The string mask may have any combination of the following characters, with the given meaning:</source>
          <target state="translated">将给定函数设置为钩子。字符串 &lt;code&gt;mask&lt;/code&gt; 和数字 &lt;code&gt;count&lt;/code&gt; 描述何时调用该挂钩。字符串掩码可以具有以下字符的任意组合，具有给定的含义：</target>
        </trans-unit>
        <trans-unit id="cfa457abdfe638a1c05389781b6cb767699e3f5e" translate="yes" xml:space="preserve">
          <source>Sets the given function as the debug hook. The string &lt;code&gt;mask&lt;/code&gt; and the number &lt;code&gt;count&lt;/code&gt; describe when the hook will be called. The string mask may have any combination of the following characters, with the given meaning:</source>
          <target state="translated">将给定函数设置为调试钩子。字符串 &lt;code&gt;mask&lt;/code&gt; 和数字 &lt;code&gt;count&lt;/code&gt; 描述何时调用该挂钩。字符串掩码可以具有以下字符的任意组合，具有给定的含义：</target>
        </trans-unit>
        <trans-unit id="d7b8a030605b64f54e56dc4eb6882692a1e86465" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given &lt;code&gt;value&lt;/code&gt; to the given &lt;code&gt;table&lt;/code&gt; (which can be &lt;b&gt;nil&lt;/b&gt;). Returns &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">将给定 &lt;code&gt;value&lt;/code&gt; 的元表设置为给定 &lt;code&gt;table&lt;/code&gt; （可以为&lt;b&gt;nil&lt;/b&gt;）。返回 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc55fa8aad2a6ef152d3844b1dbc7d9854df5817" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given table. (To change the metatable of other types from Lua code, you must use the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).) If &lt;code&gt;metatable&lt;/code&gt; is &lt;b&gt;nil&lt;/b&gt;, removes the metatable of the given table. If the original metatable has a &lt;code&gt;__metatable&lt;/code&gt; field, raises an error.</source>
          <target state="translated">设置给定表的元表。（要从Lua代码中更改其他类型的元表，必须使用调试库（第&lt;a href=&quot;#6.10&quot;&gt;6.10节&lt;/a&gt;）。）如果 &lt;code&gt;metatable&lt;/code&gt; 为&lt;b&gt;nil&lt;/b&gt;，则删除给定表的元表。如果原始元表具有 &lt;code&gt;__metatable&lt;/code&gt; 字段，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="a0ebfc6ec4adb4b51d14e3fb506f43ec69d2311e" translate="yes" xml:space="preserve">
          <source>Sets the metatable for the given table. If &lt;code&gt;metatable&lt;/code&gt; is &lt;b&gt;nil&lt;/b&gt;, removes the metatable of the given table. If the original metatable has a &lt;code&gt;__metatable&lt;/code&gt; field, raises an error.</source>
          <target state="translated">设置给定表的元表。如果 &lt;code&gt;metatable&lt;/code&gt; 为&lt;b&gt;nil&lt;/b&gt;，则删除给定表的元表。如果原始元表具有 &lt;code&gt;__metatable&lt;/code&gt; 字段，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="587b6bacfd61f3dd529496795bf4b5531bf0411f" translate="yes" xml:space="preserve">
          <source>Sets the metatable of the object at the top of the stack as the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">将位于堆栈顶部的对象的元表设置为与注册表中名称 &lt;code&gt;tname&lt;/code&gt; 关联的元表（请参阅&lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d22790332cf1d45f6a8843c4ad039244e90ff99f" translate="yes" xml:space="preserve">
          <source>Sets the metatable of the object on the top of the stack as the metatable associated with name &lt;code&gt;tname&lt;/code&gt; in the registry (see &lt;a href=&quot;#luaL_newmetatable&quot;&gt;&lt;code&gt;luaL_newmetatable&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">将对象顶部的元表设置为与注册表中名称 &lt;code&gt;tname&lt;/code&gt; 关联的元表（请参见&lt;a href=&quot;#luaL_newmetatable&quot;&gt; &lt;code&gt;luaL_newmetatable&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="980d28e7c69235ce8818955ee39047b99459cc45" translate="yes" xml:space="preserve">
          <source>Sets the real value of &lt;code&gt;table[index]&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, without invoking the &lt;code&gt;__newindex&lt;/code&gt; metamethod. &lt;code&gt;table&lt;/code&gt; must be a table, &lt;code&gt;index&lt;/code&gt; any value different from &lt;b&gt;nil&lt;/b&gt; and NaN, and &lt;code&gt;value&lt;/code&gt; any Lua value.</source>
          <target state="translated">将 &lt;code&gt;table[index]&lt;/code&gt; 的实际值设置为 &lt;code&gt;value&lt;/code&gt; ，而不调用 &lt;code&gt;__newindex&lt;/code&gt; 元方法。 &lt;code&gt;table&lt;/code&gt; 必须是一个表， &lt;code&gt;index&lt;/code&gt; 从任何值不同&lt;b&gt;零&lt;/b&gt;和NaN，并且 &lt;code&gt;value&lt;/code&gt; 任何的Lua值。</target>
        </trans-unit>
        <trans-unit id="83fb6edb67ceac4c3bec94b60202ea6ff8ecd172" translate="yes" xml:space="preserve">
          <source>Sets the real value of &lt;code&gt;table[index]&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, without using the &lt;code&gt;__newindex&lt;/code&gt; metavalue. &lt;code&gt;table&lt;/code&gt; must be a table, &lt;code&gt;index&lt;/code&gt; any value different from &lt;b&gt;nil&lt;/b&gt; and NaN, and &lt;code&gt;value&lt;/code&gt; any Lua value.</source>
          <target state="translated">将 &lt;code&gt;table[index]&lt;/code&gt; 的实际值设置为 &lt;code&gt;value&lt;/code&gt; ，而不使用 &lt;code&gt;__newindex&lt;/code&gt; 元值。 &lt;code&gt;table&lt;/code&gt; 必须是一个表， &lt;code&gt;index&lt;/code&gt; 任何与&lt;b&gt;nil&lt;/b&gt;和NaN不同的 &lt;code&gt;value&lt;/code&gt; ，并为Lua值赋值。</target>
        </trans-unit>
        <trans-unit id="64764244caf680f963cbe34576ef7f19047e51d8" translate="yes" xml:space="preserve">
          <source>Sets the value of a closure's upvalue. It assigns the value at the top of the stack to the upvalue and returns its name. It also pops the value from the stack.</source>
          <target state="translated">设置闭包的upvalue值。它将堆栈顶部的值分配给upvalue,并返回其名称。它还从堆栈中弹出值。</target>
        </trans-unit>
        <trans-unit id="a4f7f3cdc50e6225c7b313befabe93f7ca2bf356" translate="yes" xml:space="preserve">
          <source>Sets the value of a closure's upvalue. It assigns the value on the top of the stack to the upvalue and returns its name. It also pops the value from the stack.</source>
          <target state="translated">设置闭包的upvalue值。它将堆栈顶部的值分配给upvalue,并返回其名称。它还从堆栈中弹出值。</target>
        </trans-unit>
        <trans-unit id="ffba6d217c9340ff452d0b26d7bde601a75effed" translate="yes" xml:space="preserve">
          <source>Sets the value of a local variable of a given activation record. It assigns the value at the top of the stack to the variable and returns its name. It also pops the value from the stack.</source>
          <target state="translated">设置给定激活记录的局部变量的值。它将堆栈顶部的值分配给变量,并返回其名称。它还从堆栈中弹出该值。</target>
        </trans-unit>
        <trans-unit id="7f22679a70311edfc5f50384a42d2ab7fff23fa6" translate="yes" xml:space="preserve">
          <source>Sets the value of a local variable of a given activation record. It assigns the value on the top of the stack to the variable and returns its name. It also pops the value from the stack.</source>
          <target state="translated">设置给定激活记录的局部变量的值。它将堆栈顶部的值分配给变量并返回其名称。它还从堆栈中弹出该值。</target>
        </trans-unit>
        <trans-unit id="b03940c1d1ac3a2bf1547c98b0cbe03f39d14377" translate="yes" xml:space="preserve">
          <source>Sets the warning function to be used by Lua to emit warnings (see &lt;a href=&quot;#lua_WarnFunction&quot;&gt;&lt;code&gt;lua_WarnFunction&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;ud&lt;/code&gt; parameter sets the value &lt;code&gt;ud&lt;/code&gt; passed to the warning function.</source>
          <target state="translated">设置Lua用来发出警告的警告功能（请参阅&lt;a href=&quot;#lua_WarnFunction&quot;&gt; &lt;code&gt;lua_WarnFunction&lt;/code&gt; &lt;/a&gt;）。该 &lt;code&gt;ud&lt;/code&gt; 参数集值 &lt;code&gt;ud&lt;/code&gt; 传递给报警功能。</target>
        </trans-unit>
        <trans-unit id="e346a8f5ef11e0659f9d13d2fd20c5971760ec54" translate="yes" xml:space="preserve">
          <source>Several functions in the API return pointers (&lt;code&gt;const char*&lt;/code&gt;) to Lua strings in the stack. (See &lt;a href=&quot;#lua_pushfstring&quot;&gt;&lt;code&gt;lua_pushfstring&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pushlstring&quot;&gt;&lt;code&gt;lua_pushlstring&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_pushstring&quot;&gt;&lt;code&gt;lua_pushstring&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt;. See also &lt;a href=&quot;#luaL_checklstring&quot;&gt;&lt;code&gt;luaL_checklstring&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#luaL_checkstring&quot;&gt;&lt;code&gt;luaL_checkstring&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#luaL_tolstring&quot;&gt;&lt;code&gt;luaL_tolstring&lt;/code&gt;&lt;/a&gt; in the auxiliary library.)</source>
          <target state="translated">API中的几个函数返回指向堆栈中Lua字符串的指针（ &lt;code&gt;const char*&lt;/code&gt; ）。（参见&lt;a href=&quot;#lua_pushfstring&quot;&gt; &lt;code&gt;lua_pushfstring&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#lua_pushlstring&quot;&gt; &lt;code&gt;lua_pushlstring&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#lua_pushstring&quot;&gt; &lt;code&gt;lua_pushstring&lt;/code&gt; &lt;/a&gt;，和&lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt;。还参见&lt;a href=&quot;#luaL_checklstring&quot;&gt; &lt;code&gt;luaL_checklstring&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#luaL_checkstring&quot;&gt; &lt;code&gt;luaL_checkstring&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#luaL_tolstring&quot;&gt; &lt;code&gt;luaL_tolstring&lt;/code&gt; &lt;/a&gt;在辅助库）。</target>
        </trans-unit>
        <trans-unit id="13dfadc7fc1e60158ee478b1d01c15a1a262b8f8" translate="yes" xml:space="preserve">
          <source>Several functions in the auxiliary library are used to check C function arguments. Because the error message is formatted for arguments (e.g., &quot;&lt;code&gt;bad argument #1&lt;/code&gt;&quot;), you should not use these functions for other stack values.</source>
          <target state="translated">辅助库中的几个函数用于检查C函数参数。因为错误消息是为参数设置的格式（例如，&amp;ldquo; &lt;code&gt;bad argument #1&lt;/code&gt; &amp;rdquo;），所以不应将这些函数用于其他堆栈值。</target>
        </trans-unit>
        <trans-unit id="d7d26a3bd3ccc1bc11907697040007c09639a73d" translate="yes" xml:space="preserve">
          <source>Several functions in the auxiliary library use internally some extra stack slots. When a function in the auxiliary library uses less than five slots, it does not check the stack size; it simply assumes that there are enough slots.</source>
          <target state="translated">辅助库中的一些函数在内部使用了一些额外的栈槽。当辅助库中的一个函数使用少于5个槽时,它不会检查栈的大小,它只是假设有足够的槽。</target>
        </trans-unit>
        <trans-unit id="1a5b014735ed16f1ba36e3785a0f441d0242e3d9" translate="yes" xml:space="preserve">
          <source>Several functions that report errors in the API use the following status codes to indicate different kinds of errors or other conditions:</source>
          <target state="translated">在API中报告错误的几个函数使用以下状态码来表示不同类型的错误或其他情况。</target>
        </trans-unit>
        <trans-unit id="08d00af90d2bbbb33d085cc5ef987064ed22d642" translate="yes" xml:space="preserve">
          <source>Several operations in Lua can &lt;em&gt;raise&lt;/em&gt; an error. An error interrupts the normal flow of the program, which can continue by &lt;em&gt;catching&lt;/em&gt; the error.</source>
          <target state="translated">Lua中的一些操作可能会&lt;em&gt;引发&lt;/em&gt;错误。错误会中断程序的正常流程，该流程可以通过&lt;em&gt;捕获&lt;/em&gt;错误来继续进行。</target>
        </trans-unit>
        <trans-unit id="db95dfa9c967586d03ebee139b1fb3b17b47718b" translate="yes" xml:space="preserve">
          <source>Several places in Lua coerce strings to numbers when necessary. In particular, the string library sets metamethods that try to coerce strings to numbers in all arithmetic operations. If the conversion fails, the library calls the metamethod of the other operand (if present) or it raises an error. Note that bitwise operators do not do this coercion.</source>
          <target state="translated">Lua中的几个地方在必要时将字符串胁迫为数字。特别是字符串库设置了元方法,试图在所有算术操作中把字符串胁迫为数字。如果转换失败,库会调用另一个操作数的元方法(如果存在的话),否则就会引发错误。请注意,位运算符不做这种胁迫。</target>
        </trans-unit>
        <trans-unit id="4e6f5999f6739678269276a1253783f2e33caacc" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#lua_gettable&quot;&gt;&lt;code&gt;lua_gettable&lt;/code&gt;&lt;/a&gt;, but does a raw access (i.e., without metamethods).</source>
          <target state="translated">与&lt;a href=&quot;#lua_gettable&quot;&gt; &lt;code&gt;lua_gettable&lt;/code&gt; &lt;/a&gt;相似，但是进行原始访问（即，没有元方法）。</target>
        </trans-unit>
        <trans-unit id="98d6dc9d6d25a6a5bcf82cd4cb364da6adb19bc6" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#lua_settable&quot;&gt;&lt;code&gt;lua_settable&lt;/code&gt;&lt;/a&gt;, but does a raw assignment (i.e., without metamethods).</source>
          <target state="translated">与&lt;a href=&quot;#lua_settable&quot;&gt; &lt;code&gt;lua_settable&lt;/code&gt; &lt;/a&gt;相似，但是执行原始分配（即，没有元方法）。</target>
        </trans-unit>
        <trans-unit id="bb8fabad1f82bd899f79eae459334cf7e778fcba" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#pdf-io.input&quot;&gt;&lt;code&gt;io.input&lt;/code&gt;&lt;/a&gt;, but operates over the default output file.</source>
          <target state="translated">与&lt;a href=&quot;#pdf-io.input&quot;&gt; &lt;code&gt;io.input&lt;/code&gt; &lt;/a&gt;相似，但对默认输出文件进行操作。</target>
        </trans-unit>
        <trans-unit id="be9918f302436d602e28315cc5eff3fc1e73bb44" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;, but gets the chunk from file &lt;code&gt;filename&lt;/code&gt; or from the standard input, if no file name is given.</source>
          <target state="translated">与&lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt;相似，但是如果未提供文件名，则从文件文件 &lt;code&gt;filename&lt;/code&gt; 或标准输入获取块。</target>
        </trans-unit>
        <trans-unit id="26f694e9b1074e2724d2aeb68c0547978de3e666" translate="yes" xml:space="preserve">
          <source>Similarly, Lua versions can always change the internal representation of precompiled chunks; precompiled chunks are not compatible between different Lua versions.</source>
          <target state="translated">同样,Lua版本可以随时改变预编译块的内部表示,预编译块在不同Lua版本之间是不兼容的。</target>
        </trans-unit>
        <trans-unit id="fbd85d6dbfcd7a9c4f67b15fec97031a2abeaf4f" translate="yes" xml:space="preserve">
          <source>Some functions in the debug interface also return pointers to strings, namely &lt;a href=&quot;#lua_getlocal&quot;&gt;&lt;code&gt;lua_getlocal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_getupvalue&quot;&gt;&lt;code&gt;lua_getupvalue&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_setlocal&quot;&gt;&lt;code&gt;lua_setlocal&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_setupvalue&quot;&gt;&lt;code&gt;lua_setupvalue&lt;/code&gt;&lt;/a&gt;. For these functions, the pointer is guaranteed to be valid while the caller function is active and the given closure (if one was given) is in the stack.</source>
          <target state="translated">调试接口中的某些函数还返回指向字符串的指针，即&lt;a href=&quot;#lua_getlocal&quot;&gt; &lt;code&gt;lua_getlocal&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#lua_getupvalue&quot;&gt; &lt;code&gt;lua_getupvalue&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#lua_setlocal&quot;&gt; &lt;code&gt;lua_setlocal&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#lua_setupvalue&quot;&gt; &lt;code&gt;lua_setupvalue&lt;/code&gt; &lt;/a&gt;。对于这些函数，在调用者函数处于活动状态并且给定的闭包（如果已给出）在堆栈中时，保证指针是有效的。</target>
        </trans-unit>
        <trans-unit id="91f7e308fa2ec755f5b9629aa68bea063366955f" translate="yes" xml:space="preserve">
          <source>Sorts list elements in a given order, &lt;em&gt;in-place&lt;/em&gt;, from &lt;code&gt;list[1]&lt;/code&gt; to &lt;code&gt;list[#list]&lt;/code&gt;. If &lt;code&gt;comp&lt;/code&gt; is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order (so that, after the sort, &lt;code&gt;i &amp;lt; j&lt;/code&gt; implies &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt;). If &lt;code&gt;comp&lt;/code&gt; is not given, then the standard Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt; is used instead.</source>
          <target state="translated">在一个给定的顺序进行排序的列表元素，&lt;em&gt;就地&lt;/em&gt;，从 &lt;code&gt;list[1]&lt;/code&gt; 到 &lt;code&gt;list[#list]&lt;/code&gt; 。如果给出了 &lt;code&gt;comp&lt;/code&gt; ，则它必须是一个接收两个列表元素并在第一个元素必须按最终顺序排在第二个元素之前时返回true的函数（因此，在排序之后， &lt;code&gt;i &amp;lt; j&lt;/code&gt; 表示 &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt; ）。如果没有给出 &lt;code&gt;comp&lt;/code&gt; ，则使用标准的Lua运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0517f4c6665e2b52991a1cccc3781c492c0e6b1" translate="yes" xml:space="preserve">
          <source>Sorts the list elements in a given order, &lt;em&gt;in-place&lt;/em&gt;, from &lt;code&gt;list[1]&lt;/code&gt; to &lt;code&gt;list[#list]&lt;/code&gt;. If &lt;code&gt;comp&lt;/code&gt; is given, then it must be a function that receives two list elements and returns true when the first element must come before the second in the final order (so that, after the sort, &lt;code&gt;i &amp;lt; j&lt;/code&gt; implies &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt;). If &lt;code&gt;comp&lt;/code&gt; is not given, then the standard Lua operator &lt;code&gt;&amp;lt;&lt;/code&gt; is used instead.</source>
          <target state="translated">排序在一个给定的顺序列表中的元素，&lt;em&gt;就地&lt;/em&gt;，从 &lt;code&gt;list[1]&lt;/code&gt; 到 &lt;code&gt;list[#list]&lt;/code&gt; 。如果给定 &lt;code&gt;comp&lt;/code&gt; ，则它必须是一个接收两个列表元素并在第一个元素必须按最终顺序排在第二个元素之前时返回true的函数（因此，在排序之后， &lt;code&gt;i &amp;lt; j&lt;/code&gt; 表示 &lt;code&gt;not comp(list[j],list[i])&lt;/code&gt; ）。如果没有给出 &lt;code&gt;comp&lt;/code&gt; ，则使用标准的Lua运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a010f7f7cdbd4258d79a8a94cbe56bc77bf2b5e7" translate="yes" xml:space="preserve">
          <source>Square brackets are used to index a table:</source>
          <target state="translated">方括号用于编制表的索引。</target>
        </trans-unit>
        <trans-unit id="15f3db96858a0b179ed1ef035b7c3729debc1d46" translate="yes" xml:space="preserve">
          <source>Stack Size</source>
          <target state="translated">堆栈大小</target>
        </trans-unit>
        <trans-unit id="a8857dbe9de4909ed5c2183cf91102dab19f054b" translate="yes" xml:space="preserve">
          <source>Standard Libraries</source>
          <target state="translated">标准图书馆</target>
        </trans-unit>
        <trans-unit id="3aa420e36a031586ffcaad7595673c265cb89fc8" translate="yes" xml:space="preserve">
          <source>Starts and resumes a coroutine in the given thread &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">在给定线程 &lt;code&gt;L&lt;/code&gt; 中启动和恢复协程。</target>
        </trans-unit>
        <trans-unit id="d40756a05671d2e92d48621babd1cb1ebcde9165" translate="yes" xml:space="preserve">
          <source>Starts or continues the execution of coroutine &lt;code&gt;co&lt;/code&gt;. The first time you resume a coroutine, it starts running its body. The values &lt;code&gt;val1&lt;/code&gt;, ... are passed as the arguments to the body function. If the coroutine has yielded, &lt;code&gt;resume&lt;/code&gt; restarts it; the values &lt;code&gt;val1&lt;/code&gt;, ... are passed as the results from the yield.</source>
          <target state="translated">开始或继续执行协程 &lt;code&gt;co&lt;/code&gt; 。第一次恢复协程时，它会开始运行它的身体。值 &lt;code&gt;val1&lt;/code&gt; ，...作为参数传递给body函数。如果协程已屈服，则 &lt;code&gt;resume&lt;/code&gt; 重新启动它；否则，重新启动协程。值 &lt;code&gt;val1&lt;/code&gt; ，...作为产量的结果传递。</target>
        </trans-unit>
        <trans-unit id="fdcf228dfc0fc5649ba85944b97fefcca7ffe43a" translate="yes" xml:space="preserve">
          <source>Starts program &lt;code&gt;prog&lt;/code&gt; in a separated process and returns a file handle that you can use to read data from this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;r&quot;&lt;/code&gt;, the default) or to write data to this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;w&quot;&lt;/code&gt;).</source>
          <target state="translated">在一个单独的进程中启动程序 &lt;code&gt;prog&lt;/code&gt; 并返回一个文件句柄，您可以使用该文件句柄从该程序读取数据（如果 &lt;code&gt;mode&lt;/code&gt; 为默认值 &lt;code&gt;&quot;r&quot;&lt;/code&gt; ）或向该程序写入数据（如果 &lt;code&gt;mode&lt;/code&gt; 为 &lt;code&gt;&quot;w&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fe31e15bdd22d691294377c44baf7ad2201f9aed" translate="yes" xml:space="preserve">
          <source>Starts the program &lt;code&gt;prog&lt;/code&gt; in a separated process and returns a file handle that you can use to read data from this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;r&quot;&lt;/code&gt;, the default) or to write data to this program (if &lt;code&gt;mode&lt;/code&gt; is &lt;code&gt;&quot;w&quot;&lt;/code&gt;).</source>
          <target state="translated">在一个单独的进程中启动程序 &lt;code&gt;prog&lt;/code&gt; 并返回一个文件句柄，您可以使用该文件句柄从该程序读取数据（如果 &lt;code&gt;mode&lt;/code&gt; 为默认值 &lt;code&gt;&quot;r&quot;&lt;/code&gt; ）或向该程序写入数据（如果 &lt;code&gt;mode&lt;/code&gt; 为 &lt;code&gt;&quot;w&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5653cebc057d4791ce07031ad9286e729de6d691" translate="yes" xml:space="preserve">
          <source>Statements</source>
          <target state="translated">Statements</target>
        </trans-unit>
        <trans-unit id="7f5583f5096a76c834c0bcc4f4885ffca8fe34cd" translate="yes" xml:space="preserve">
          <source>Status Codes</source>
          <target state="translated">状态码</target>
        </trans-unit>
        <trans-unit id="4a3601848fbaa157ee7ad1bf17ef71628017fcdf" translate="yes" xml:space="preserve">
          <source>Suppose the running thread yields while executing the callee function. After the thread resumes, it eventually will finish running the callee function. However, the callee function cannot return to the original function, because its frame in the C stack was destroyed by the yield. Instead, Lua calls a &lt;em&gt;continuation function&lt;/em&gt;, which was given as an argument to the callee function. As the name implies, the continuation function should continue the task of the original function.</source>
          <target state="translated">假设正在执行被调用方函数时正在运行的线程屈服。线程恢复后，它将最终完成运行被调用函数。但是，被调用方函数无法返回到原始函数，因为C堆栈中其框架已被yield破坏。相反，Lua调用了&lt;em&gt;延续函数&lt;/em&gt;，该&lt;em&gt;函数&lt;/em&gt;作为被调用函数的参数提供。顾名思义，延续功能应继续原始功能的任务。</target>
        </trans-unit>
        <trans-unit id="e83b7d557c46acb05b744857e11a6cfdb7f1df00" translate="yes" xml:space="preserve">
          <source>Suspends the execution of the calling coroutine. Any arguments to &lt;code&gt;yield&lt;/code&gt; are passed as extra results to &lt;code&gt;resume&lt;/code&gt;.</source>
          <target state="translated">暂停调用协程的执行。传递 &lt;code&gt;yield&lt;/code&gt; 的任何参数作为要 &lt;code&gt;resume&lt;/code&gt; 额外结果。</target>
        </trans-unit>
        <trans-unit id="cf68697aa23858afae69b1650bbb5ac00b4caade" translate="yes" xml:space="preserve">
          <source>Table Constructors</source>
          <target state="translated">表格构造器</target>
        </trans-unit>
        <trans-unit id="ddade22015227084f0c0a4b0fb958ac23eef35ed" translate="yes" xml:space="preserve">
          <source>Table constructors are expressions that create tables. Every time a constructor is evaluated, a new table is created. A constructor can be used to create an empty table or to create a table and initialize some of its fields. The general syntax for constructors is</source>
          <target state="translated">表构造函数是创建表的表达式。每当一个构造函数被评估时,就会创建一个新表。构造函数可以用来创建一个空表,或者创建一个表并初始化它的一些字段。构造函数的一般语法是</target>
        </trans-unit>
        <trans-unit id="8eb8356b5217b3ad22882eb75be685d15131abcf" translate="yes" xml:space="preserve">
          <source>Tables and full userdata have individual metatables (although multiple tables and userdata can share their metatables). Values of all other types share one single metatable per type; that is, there is one single metatable for all numbers, one for all strings, etc. By default, a value has no metatable, but the string library sets a metatable for the string type (see &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt;).</source>
          <target state="translated">表和完整的用户数据具有单独的元表（尽管多个表和用户数据可以共享其元表）。所有其他类型的值每种类型共享一个单一的元表；也就是说，所有数字都有一个单一的元表，所有字符串都有一个，等等。默认情况下，值没有元表，但是字符串库为字符串类型设置了元表（请参见&lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a43eec2139292b4bea0916e6b1d5992b76b7800a" translate="yes" xml:space="preserve">
          <source>Tables and full userdata have individual metatables, although multiple tables and userdata can share their metatables. Values of all other types share one single metatable per type; that is, there is one single metatable for all numbers, one for all strings, etc. By default, a value has no metatable, but the string library sets a metatable for the string type (see &lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt;).</source>
          <target state="translated">表和完整的用户数据具有单独的元表，尽管多个表和用户数据可以共享其元表。所有其他类型的值每种类型共享一个单一的元表；也就是说，所有数字都有一个单个的元表，所有字符串都有一个，等等。默认情况下，值没有元表，但是字符串库为字符串类型设置了一个元表（请参见&lt;a href=&quot;#6.4&quot;&gt;&amp;sect;6.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="790df16e07d28fbd0bc25fd6c6058d692af71b40" translate="yes" xml:space="preserve">
          <source>Tables are the sole data-structuring mechanism in Lua; they can be used to represent ordinary arrays, lists, symbol tables, sets, records, graphs, trees, etc. To represent records, Lua uses the field name as an index. The language supports this representation by providing &lt;code&gt;a.name&lt;/code&gt; as syntactic sugar for &lt;code&gt;a[&quot;name&quot;]&lt;/code&gt;. There are several convenient ways to create tables in Lua (see &lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt;).</source>
          <target state="translated">表是Lua中唯一的数据结构机制。它们可以用来表示普通的数组，列表，符号表，集合，记录，图形，树等。为了表示记录，Lua使用字段名称作为索引。该语言通过提供 &lt;code&gt;a.name&lt;/code&gt; 作为 &lt;code&gt;a[&quot;name&quot;]&lt;/code&gt; 语法糖来支持这种表示。有几种在Lua中创建表的便捷方法（请参见&lt;a href=&quot;#3.4.9&quot;&gt;&amp;sect;3.4.9&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="e421a06df75071a6abebc4fb3581855738824adb" translate="yes" xml:space="preserve">
          <source>Tables, functions, threads, and (full) userdata values are &lt;em&gt;objects&lt;/em&gt;: variables do not actually &lt;em&gt;contain&lt;/em&gt; these values, only &lt;em&gt;references&lt;/em&gt; to them. Assignment, parameter passing, and function returns always manipulate references to such values; these operations do not imply any kind of copy.</source>
          <target state="translated">表，函数，线程和（完整）用户数据值是&lt;em&gt;对象&lt;/em&gt;：变量实际上并不&lt;em&gt;包含&lt;/em&gt;这些值，而仅&lt;em&gt;包含&lt;/em&gt;对它们的&lt;em&gt;引用&lt;/em&gt;。赋值，参数传递和函数返回总是操纵对此类值的引用；这些操作并不意味着任何形式的复制。</target>
        </trans-unit>
        <trans-unit id="669e76ec887de715ba103acde30a3797fae1f331" translate="yes" xml:space="preserve">
          <source>Tables, userdata, and threads are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, a userdata, or a thread), this new object is different from any previously existing object. A function is always equal to itself. Functions with any detectable difference (different behavior, different definition) are always different. Functions created at different times but with no detectable differences may be classified as equal or not (depending on internal caching details).</source>
          <target state="translated">表、用户数据和线程是通过引用来比较的:只有当两个对象是同一个对象时,它们才被认为是相等的。每次创建一个新的对象(一个表、一个用户数据或一个线程),这个新的对象与之前存在的任何对象都是不同的。一个函数总是与自己相等。具有任何可检测到的差异(不同的行为,不同的定义)的函数总是不同的。在不同时间创建的函数,但没有可检测到的差异,可能被归为相等或不相等(取决于内部缓存的细节)。</target>
        </trans-unit>
        <trans-unit id="99385b30015343b5b8e00056e58a762956df3e7d" translate="yes" xml:space="preserve">
          <source>Tables, userdata, and threads are compared by reference: two objects are considered equal only if they are the same object. Every time you create a new object (a table, userdata, or thread), this new object is different from any previously existing object. Closures with the same reference are always equal. Closures with any detectable difference (different behavior, different definition) are always different.</source>
          <target state="translated">表、用户数据和线程是通过引用来比较的:只有当两个对象是同一个对象时,它们才被认为是相等的。每次创建一个新对象(表、用户数据或线程)时,这个新对象都与之前存在的任何对象不同。具有相同引用的闭包总是相等的。具有任何可检测的差异(不同的行为、不同的定义)的闭包总是不同的。</target>
        </trans-unit>
        <trans-unit id="446beb4016f56d03fb7aeada345cb1a7a86ea482" translate="yes" xml:space="preserve">
          <source>Terminates the last protected function called and returns &lt;code&gt;message&lt;/code&gt; as the error object. Function &lt;code&gt;error&lt;/code&gt; never returns.</source>
          <target state="translated">终止最后一个受保护的函数，并将 &lt;code&gt;message&lt;/code&gt; 作为错误对象返回。函数 &lt;code&gt;error&lt;/code&gt; 永不返回。</target>
        </trans-unit>
        <trans-unit id="aad621a873e57ea830369714dc4bd782c2449476" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; function returns one of the following constants (defined in &lt;code&gt;lua.h&lt;/code&gt;):</source>
          <target state="translated">的&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;函数返回下列常数之一（定义在 &lt;code&gt;lua.h&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="c9f4dcc9b6adcf3724a0f1527ff15ababb77be1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt; function returns one of the following status codes: &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_ERRRUN&quot;&gt;&lt;code&gt;LUA_ERRRUN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt;&lt;code&gt;LUA_ERRMEM&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#pdf-LUA_ERRERR&quot;&gt;&lt;code&gt;LUA_ERRERR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">的&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;函数返回以下状态代码之一：&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-LUA_ERRRUN&quot;&gt; &lt;code&gt;LUA_ERRRUN&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-LUA_ERRMEM&quot;&gt; &lt;code&gt;LUA_ERRMEM&lt;/code&gt; &lt;/a&gt;，或&lt;a href=&quot;#pdf-LUA_ERRERR&quot;&gt; &lt;code&gt;LUA_ERRERR&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1d59a96e495b4ed1314e7a452acf7cf2be3dd16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pdf-ipairs&quot;&gt;&lt;code&gt;ipairs&lt;/code&gt;&lt;/a&gt; iterator now respects metamethods and its &lt;code&gt;__ipairs&lt;/code&gt; metamethod has been deprecated.</source>
          <target state="translated">该&lt;a href=&quot;#pdf-ipairs&quot;&gt; &lt;code&gt;ipairs&lt;/code&gt; &lt;/a&gt;迭代器现在尊重元方法及其 &lt;code&gt;__ipairs&lt;/code&gt; 元方法已被弃用。</target>
        </trans-unit>
        <trans-unit id="bc47dc2ae4b1f24c3a3899f4b1f9405cda8bd057" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;break&lt;/b&gt; statement terminates the execution of a &lt;b&gt;while&lt;/b&gt;, &lt;b&gt;repeat&lt;/b&gt;, or &lt;b&gt;for&lt;/b&gt; loop, skipping to the next statement after the loop:</source>
          <target state="translated">在&lt;b&gt;休息&lt;/b&gt;的语句终止执行&lt;b&gt;，同时&lt;/b&gt;，&lt;b&gt;重复&lt;/b&gt;，或&lt;b&gt;用于&lt;/b&gt;循环，跳到循环之后的下一条语句：</target>
        </trans-unit>
        <trans-unit id="be57b4db5d11ecd50b150a3c2c7baa57bca94b87" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;for&lt;/b&gt; statement has two forms: one numerical and one generic.</source>
          <target state="translated">该&lt;b&gt;对&lt;/b&gt;语句有两种形式：一个数字和一个通用的。</target>
        </trans-unit>
        <trans-unit id="b061702cc21366ebd955da1cbb0818c2844543b8" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;goto&lt;/b&gt; statement transfers the program control to a label. For syntactical reasons, labels in Lua are considered statements too:</source>
          <target state="translated">将&lt;b&gt;跳转&lt;/b&gt;语句将程序控制的标签。出于语法原因，Lua中的标签也被视为语句：</target>
        </trans-unit>
        <trans-unit id="eeaa513ac2a2fd15596d8309fe530d856f6a61e0" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement can only be written as the last statement of a block. If it is necessary to &lt;b&gt;return&lt;/b&gt; in the middle of a block, then an explicit inner block can be used, as in the idiom &lt;code&gt;do return end&lt;/code&gt;, because now &lt;b&gt;return&lt;/b&gt; is the last statement in its (inner) block.</source>
          <target state="translated">在&lt;b&gt;返回&lt;/b&gt;语句只能写成块的最后陈述。如果必须在一个块的中间&lt;b&gt;返回&lt;/b&gt;，则可以使用一个显式的内部块，就像在习惯用法中 &lt;code&gt;do return end&lt;/code&gt; ，因为现在&lt;b&gt;return&lt;/b&gt;是其（内部）块中的最后一条语句。</target>
        </trans-unit>
        <trans-unit id="b8c9f54acbc996a7d79b7252d182ed631a6a317f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement can only be written as the last statement of a block. If it is really necessary to &lt;b&gt;return&lt;/b&gt; in the middle of a block, then an explicit inner block can be used, as in the idiom &lt;code&gt;do return end&lt;/code&gt;, because now &lt;b&gt;return&lt;/b&gt; is the last statement in its (inner) block.</source>
          <target state="translated">在&lt;b&gt;返回&lt;/b&gt;语句只能写成块的最后陈述。如果确实有必要在一个块的中间&lt;b&gt;返回&lt;/b&gt;，那么可以使用一个显式的内部块，就像在习惯用法中 &lt;code&gt;do return end&lt;/code&gt; ，因为现在&lt;b&gt;return&lt;/b&gt;是其（内部）块中的最后一条语句。</target>
        </trans-unit>
        <trans-unit id="c44e88f5118a01354e009d7fa35997d3c87c7c1a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement is used to return values from a function or a chunk (which is an anonymous function). Functions can return more than one value, so the syntax for the &lt;b&gt;return&lt;/b&gt; statement is</source>
          <target state="translated">该&lt;b&gt;返回&lt;/b&gt;语句用来从一功能或一组块（这是一个匿名功能）返回值。函数可以返回多个值，因此&lt;b&gt;return&lt;/b&gt;语句的语法为</target>
        </trans-unit>
        <trans-unit id="50d916d7e4fcf57b5d8ca62cda2c1b54e390dceb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;return&lt;/b&gt; statement is used to return values from a function or a chunk (which is handled as an anonymous function). Functions can return more than one value, so the syntax for the &lt;b&gt;return&lt;/b&gt; statement is</source>
          <target state="translated">该&lt;b&gt;返回&lt;/b&gt;语句用来从一功能或一组块（其被作为一个匿名函数处理）返回值。函数可以返回多个值，因此&lt;b&gt;return&lt;/b&gt;语句的语法为</target>
        </trans-unit>
        <trans-unit id="2b646ffbbdcd054326d494ba2f5c649f95d36297" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bit32&lt;/code&gt; library has been deprecated. It is easy to require a compatible external library or, better yet, to replace its functions with appropriate bitwise operations. (Keep in mind that &lt;code&gt;bit32&lt;/code&gt; operates on 32-bit integers, while the bitwise operators in Lua 5.3 operate on Lua integers, which by default have 64 bits.)</source>
          <target state="translated">该 &lt;code&gt;bit32&lt;/code&gt; 库已被弃用。需要兼容的外部库很容易，或者更好的是，用适当的按位运算来替换其功能。（请记住， &lt;code&gt;bit32&lt;/code&gt; 使用32位整数，而Lua 5.3中的按位运算符则使用Lua整数（默认情况下为64位）。）</target>
        </trans-unit>
        <trans-unit id="768417f6f84362fdef7cb578c8c372a00d6776b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chunkname&lt;/code&gt; argument gives a name to the chunk, which is used for error messages and in debug information (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">所述 &lt;code&gt;chunkname&lt;/code&gt; 参数给出一个名称组块，其用于错误消息和在调试信息（见&lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3c35b56166af83b28a7e0e22c5d357b538f84788" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chunkname&lt;/code&gt; argument gives a name to the chunk, which is used for error messages and in debug information (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;).</source>
          <target state="translated">所述 &lt;code&gt;chunkname&lt;/code&gt; 参数给出一个名称组块，其用于错误消息和在调试信息（见&lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bae62f5a0575c4f5ff2aabe5bf99d9776f3199b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lua_load&lt;/code&gt; function uses a user-supplied &lt;code&gt;reader&lt;/code&gt; function to read the chunk (see &lt;a href=&quot;#lua_Reader&quot;&gt;&lt;code&gt;lua_Reader&lt;/code&gt;&lt;/a&gt;). The &lt;code&gt;data&lt;/code&gt; argument is an opaque value passed to the reader function.</source>
          <target state="translated">所述 &lt;code&gt;lua_load&lt;/code&gt; 函数使用用户提供的 &lt;code&gt;reader&lt;/code&gt; 功能读取该块（见&lt;a href=&quot;#lua_Reader&quot;&gt; &lt;code&gt;lua_Reader&lt;/code&gt; &lt;/a&gt;）。该 &lt;code&gt;data&lt;/code&gt; 参数是传递给阅读器功能的不透明值。</target>
        </trans-unit>
        <trans-unit id="85f9907ce6878c8dc7e267337764d4964c7fae3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; string can also have a '&lt;code&gt;b&lt;/code&gt;' at the end, which is needed in some systems to open the file in binary mode.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 字符串的末尾也可以有一个' &lt;code&gt;b&lt;/code&gt; '，在某些系统中，以二进制模式打开文件时需要使用该字符串。</target>
        </trans-unit>
        <trans-unit id="2688f69f4c7b22c66219e46ee16c2eac721dcdfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; string can be any of the following:</source>
          <target state="translated">该 &lt;code&gt;mode&lt;/code&gt; 字符串可以是任何如下：</target>
        </trans-unit>
        <trans-unit id="dcce9d1975851c844f7c2f304003970e38bff938" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;q&lt;/code&gt; option formats a string between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call</source>
          <target state="translated">该 &lt;code&gt;q&lt;/code&gt; 选项格式双引号之间的字符串，使用转义序列在必要的时候，以确保它可以安全地通过Lua解释读回。例如，通话</target>
        </trans-unit>
        <trans-unit id="ab9206bbe0932c07e692d615d61a36493a13a496" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;auxiliary library&lt;/em&gt; provides several convenient functions to interface C with Lua. While the basic API provides the primitive functions for all interactions between C and Lua, the auxiliary library provides higher-level functions for some common tasks.</source>
          <target state="translated">所述&lt;em&gt;辅助库&lt;/em&gt;提供了几个方便的功能的接口下用的Lua。基本API为C和Lua之间的所有交互提供了原始函数，而辅助库为某些常见任务提供了更高级别的函数。</target>
        </trans-unit>
        <trans-unit id="8ab6afc13be0118f613c20671f20dcaa66bf50fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;block&lt;/em&gt; is repeated for &lt;em&gt;name&lt;/em&gt; starting at the value of the first &lt;em&gt;exp&lt;/em&gt;, until it passes the second &lt;em&gt;exp&lt;/em&gt; by steps of the third &lt;em&gt;exp&lt;/em&gt;. More precisely, a &lt;b&gt;for&lt;/b&gt; statement like</source>
          <target state="translated">该&lt;em&gt;块&lt;/em&gt;被重复&lt;em&gt;名称&lt;/em&gt;起始于第一值&lt;em&gt;EXP&lt;/em&gt;，直到其通过所述第二&lt;em&gt;EXP&lt;/em&gt;由第三步骤&lt;em&gt;EXP&lt;/em&gt;。更确切地说，&lt;b&gt;for&lt;/b&gt;语句像</target>
        </trans-unit>
        <trans-unit id="d3b254f35dcb5161307fc6d343f99ec868c9f36b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;colon&lt;/em&gt; syntax is used for defining &lt;em&gt;methods&lt;/em&gt;, that is, functions that have an implicit extra parameter &lt;code&gt;self&lt;/code&gt;. Thus, the statement</source>
          <target state="translated">在&lt;em&gt;结肠&lt;/em&gt;语法用于定义&lt;em&gt;方法&lt;/em&gt;，即，具有一个隐含的额外的参数函数 &lt;code&gt;self&lt;/code&gt; 。因此，该声明</target>
        </trans-unit>
        <trans-unit id="f572f282cad30118a92f64a8c2a8e8b7d0ba81c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;colon&lt;/em&gt; syntax is used to emulate &lt;em&gt;methods&lt;/em&gt;, adding an implicit extra parameter &lt;code&gt;self&lt;/code&gt; to the function. Thus, the statement</source>
          <target state="translated">在&lt;em&gt;结肠&lt;/em&gt;语法用于仿真&lt;em&gt;的方法&lt;/em&gt;，增加一种隐含的额外的参数 &lt;code&gt;self&lt;/code&gt; 给该函数。因此，该声明</target>
        </trans-unit>
        <trans-unit id="6d7a7980421d2b17bd0aed9b9a529fd71ecec0a9" translate="yes" xml:space="preserve">
          <source>The I/O library provides two different styles for file manipulation. The first one uses implicit file handles; that is, there are operations to set a default input file and a default output file, and all input/output operations are done over these default files. The second style uses explicit file handles.</source>
          <target state="translated">I/O库提供了两种不同风格的文件操作。第一种使用隐式文件句柄,即有设置默认输入文件和默认输出文件的操作,所有的输入/输出操作都在这些默认文件上完成。第二种风格使用显式文件句柄。</target>
        </trans-unit>
        <trans-unit id="171411617a28d7de2b0226c80067f77ec30897f7" translate="yes" xml:space="preserve">
          <source>The I/O library provides two different styles for file manipulation. The first one uses implicit file handles; that is, there are operations to set a default input file and a default output file, and all input/output operations are over these default files. The second style uses explicit file handles.</source>
          <target state="translated">I/O库提供了两种不同风格的文件操作。第一种使用隐式文件句柄,即有设置默认输入文件和默认输出文件的操作,所有的输入/输出操作都在这些默认文件之上。第二种风格使用显式文件句柄。</target>
        </trans-unit>
        <trans-unit id="fe26bd92623ecffd0ef5b0b7681c64345000ef38" translate="yes" xml:space="preserve">
          <source>The Length Operator</source>
          <target state="translated">长度运算符</target>
        </trans-unit>
        <trans-unit id="b46439f6fc2b5220d043e60a0c5b1b7e77db627e" translate="yes" xml:space="preserve">
          <source>The Lua library is fully reentrant: it has no global variables. It keeps all information it needs in a dynamic structure, called the &lt;em&gt;Lua state&lt;/em&gt;.</source>
          <target state="translated">Lua库是完全可重入的：它没有全局变量。它将所需的所有信息保持在动态结构中，称为&lt;em&gt;Lua状态&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="07b128e0f94f3f9a107ec1b9a4411b8083a41fce" translate="yes" xml:space="preserve">
          <source>The Table library now respects metamethods for setting and getting elements.</source>
          <target state="translated">表库现在尊重设置和获取元素的元方法。</target>
        </trans-unit>
        <trans-unit id="eb554fe048e1c8b347ad8a3da87d434c8b60f5db" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding of a Unicode character can be inserted in a literal string with the escape sequence &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (note the mandatory enclosing brackets), where &lt;em&gt;XXX&lt;/em&gt; is a sequence of one or more hexadecimal digits representing the character code point.</source>
          <target state="translated">Unicode字符的UTF-8编码可以插入带有转义序列 &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; 的文字字符串中（请注意必填括号），其中&lt;em&gt;XXX&lt;/em&gt;是一个或多个十六进制数字的序列，代表字符代码点。</target>
        </trans-unit>
        <trans-unit id="133b64cb1acd8fa4b0993eef50a3ec5beecc6e3a" translate="yes" xml:space="preserve">
          <source>The UTF-8 encoding of a Unicode character can be inserted in a literal string with the escape sequence &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; (with mandatory enclosing braces), where &lt;em&gt;XXX&lt;/em&gt; is a sequence of one or more hexadecimal digits representing the character code point. This code point can be any value less than &lt;em&gt;2&lt;sup&gt;31&lt;/sup&gt;&lt;/em&gt;. (Lua uses the original UTF-8 specification here, which is not restricted to valid Unicode code points.)</source>
          <target state="translated">Unicode字符的UTF-8编码可以使用转义序列 &lt;code&gt;\u{&lt;em&gt;XXX&lt;/em&gt;}&lt;/code&gt; （带有必需的大括号）插入文字字符串中，其中&lt;em&gt;XXX&lt;/em&gt;是一个或多个十六进制数字的序列，代表字符代码点。该代码点可以是小于&lt;em&gt;2 &lt;sup&gt;31的&lt;/sup&gt;&lt;/em&gt;任何值。（Lua在此使用原始的UTF-8规范，该规范不限于有效的Unicode代码点。）</target>
        </trans-unit>
        <trans-unit id="3e71c6008a2054b02c7458c10af8db199b93e0fc" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;l&lt;/code&gt; must be the actual array, not a pointer to it.</source>
          <target state="translated">数组 &lt;code&gt;l&lt;/code&gt; 必须是实际数组，而不是指向它的指针。</target>
        </trans-unit>
        <trans-unit id="ec4ef8ac03868996fbe27096f10720a2a635fd47" translate="yes" xml:space="preserve">
          <source>The assignment statement first evaluates all its expressions and only then the assignments are performed. Thus the code</source>
          <target state="translated">赋值语句首先对其所有表达式进行评估,然后才进行赋值。因此,这段代码</target>
        </trans-unit>
        <trans-unit id="63ea036976be25a6fccc44715a31648a894a2cd9" translate="yes" xml:space="preserve">
          <source>The available formats are</source>
          <target state="translated">可用的格式有</target>
        </trans-unit>
        <trans-unit id="1bf5ee36dda4ba103acec9799a8f08fe38658693" translate="yes" xml:space="preserve">
          <source>The basic expressions in Lua are the following:</source>
          <target state="translated">Lua中的基本表达式如下。</target>
        </trans-unit>
        <trans-unit id="a90f0e6ef32f54b398b228c2483c97e99f92d4d7" translate="yes" xml:space="preserve">
          <source>The basic library provides core functions to Lua. If you do not include this library in your application, you should check carefully whether you need to provide implementations for some of its facilities.</source>
          <target state="translated">基本库为Lua提供了核心功能,如果你不在你的应用程序中包含这个库,你应该仔细检查是否需要为它的一些功能提供实现。如果你不在你的应用程序中包含这个库,你应该仔细检查你是否需要为它的一些设施提供实现。</target>
        </trans-unit>
        <trans-unit id="6a4e9c1cd28f7989f62ba005ba19f087fc3592ba" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;next&lt;/code&gt; is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields.</source>
          <target state="translated">如果在遍历期间将任何值分配给表中的不存在字段，则 &lt;code&gt;next&lt;/code&gt; 的行为是不确定的。但是，您可以修改现有字段。特别是，您可以清除现有字段。</target>
        </trans-unit>
        <trans-unit id="ff207200b1250dc2b47ca5a7a827de1d648909f3" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;code&gt;next&lt;/code&gt; is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may set existing fields to nil.</source>
          <target state="translated">如果在遍历期间将任何值分配给表中不存在的字段，则 &lt;code&gt;next&lt;/code&gt; 的行为是不确定的。但是，您可以修改现有字段。特别是，您可以将现有字段设置为nil。</target>
        </trans-unit>
        <trans-unit id="0dc90ae531b088f04f67083e165dbcb68af23283" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;collectgarbage(&quot;count&quot;)&lt;/code&gt; now returns only one result. (You can compute that second result from the fractional part of the first result.)</source>
          <target state="translated">调用 &lt;code&gt;collectgarbage(&quot;count&quot;)&lt;/code&gt; 现在仅返回一个结果。（您可以根据第一个结果的小数部分来计算第二个结果。）</target>
        </trans-unit>
        <trans-unit id="c68441a4203b3cd2bfe34776a10e03a400a467cb" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;io.lines()&lt;/code&gt; (with no file name) is equivalent to &lt;code&gt;io.input():lines(&quot;*l&quot;)&lt;/code&gt;; that is, it iterates over the lines of the default input file. In this case it does not close the file when the loop ends.</source>
          <target state="translated">调用 &lt;code&gt;io.lines()&lt;/code&gt; （没有文件名）等效于 &lt;code&gt;io.input():lines(&quot;*l&quot;)&lt;/code&gt; ；也就是说，迭代默认输入文件的各行。在这种情况下，循环结束时它不会关闭文件。</target>
        </trans-unit>
        <trans-unit id="56312b3ed08e17201e15d0358b34f5524a82475c" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;io.lines()&lt;/code&gt; (with no file name) is equivalent to &lt;code&gt;io.input():lines(&quot;l&quot;)&lt;/code&gt;; that is, it iterates over the lines of the default input file. In this case, the iterator does not close the file when the loop ends.</source>
          <target state="translated">调用 &lt;code&gt;io.lines()&lt;/code&gt; （没有文件名）等效于 &lt;code&gt;io.input():lines(&quot;l&quot;)&lt;/code&gt; ；也就是说，迭代默认输入文件的各行。在这种情况下，循环结束时，迭代器不会关闭文件。</target>
        </trans-unit>
        <trans-unit id="3e4ad773c547ffbe50168aed20636ff53516332e" translate="yes" xml:space="preserve">
          <source>The closing value behaves like a to-be-closed variable (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;), which can be used to release resources when the loop ends. Otherwise, it does not interfere with the loop.</source>
          <target state="translated">结束值的行为类似于要关闭的变量（请参见第&lt;a href=&quot;#3.3.8&quot;&gt;3.3.8节&lt;/a&gt;），可以在循环结束时用于释放资源。否则，它不会干扰循环。</target>
        </trans-unit>
        <trans-unit id="798511549246488486c822aec3e1cc74d4fe6a5b" translate="yes" xml:space="preserve">
          <source>The coercion of strings to numbers in arithmetic and bitwise operations has been removed from the core language. The string library does a similar job for arithmetic (but not for bitwise) operations using the string metamethods. However, unlike in previous versions, the new implementation preserves the implicit type of the numeral in the string. For instance, the result of &lt;code&gt;&quot;1&quot; + &quot;2&quot;&lt;/code&gt; now is an integer, not a float.</source>
          <target state="translated">从算术和按位运算中将字符串强制转换为数字已从核心语言中删除。字符串库使用字符串元方法对算术（但不是按位）操作执行类似的工作。但是，与以前的版本不同，新的实现保留了字符串中数字的隐式类型。例如，结果 &lt;code&gt;&quot;1&quot; + &quot;2&quot;&lt;/code&gt; 现在是整数，而不是浮点数。</target>
        </trans-unit>
        <trans-unit id="ef37fdd6b0b5e41eab32a9928b1d9217a2a5737b" translate="yes" xml:space="preserve">
          <source>The computation of the length of a table has a guaranteed worst time of &lt;em&gt;O(log n)&lt;/em&gt;, where &lt;em&gt;n&lt;/em&gt; is the largest natural key in the table.</source>
          <target state="translated">表长度的计算具有保证的最差时间&lt;em&gt;O（log n）&lt;/em&gt;，其中&lt;em&gt;n&lt;/em&gt;是表中最大的自然键。</target>
        </trans-unit>
        <trans-unit id="0b56d75e0be562bbdd8ce192220fca509ed349d6" translate="yes" xml:space="preserve">
          <source>The condition expression of a control structure can return any value. Both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; are considered false. All values different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; are considered true (in particular, the number 0 and the empty string are also true).</source>
          <target state="translated">控制结构的条件表达式可以返回任何值。这两种&lt;b&gt;假&lt;/b&gt;和&lt;b&gt;零&lt;/b&gt;被认为是假的。所有不同于&lt;b&gt;nil&lt;/b&gt;和&lt;b&gt;false的&lt;/b&gt;值都被视为true（特别是数字0和空字符串也为true）。</target>
        </trans-unit>
        <trans-unit id="3b920454c4c1d2c03393d9ac78ec720b9fbaa526" translate="yes" xml:space="preserve">
          <source>The condition expression of a control structure can return any value. Both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; test false. All values different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; test true. In particular, the number 0 and the empty string also test true.</source>
          <target state="translated">控制结构的条件表达式可以返回任何值。这两种&lt;b&gt;假&lt;/b&gt;和&lt;b&gt;零&lt;/b&gt;测试假的。所有不同于&lt;b&gt;nil&lt;/b&gt;和&lt;b&gt;false的&lt;/b&gt;值都测试为true。特别是，数字0和空字符串也测试为true。</target>
        </trans-unit>
        <trans-unit id="ec24a70490264f051fb6d0ae4a587a4f8d0e22eb" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; was removed. Errors in finalizers are never propagated; instead, they generate a warning.</source>
          <target state="translated">常量 &lt;code&gt;LUA_ERRGCMM&lt;/code&gt; 被删除。终结器中的错误永远不会传播。相反，它们会生成警告。</target>
        </trans-unit>
        <trans-unit id="c3733f14fe1543e4589c9195fb66e8ff53166d2c" translate="yes" xml:space="preserve">
          <source>The control structures &lt;b&gt;if&lt;/b&gt;, &lt;b&gt;while&lt;/b&gt;, and &lt;b&gt;repeat&lt;/b&gt; have the usual meaning and familiar syntax:</source>
          <target state="translated">控件结构&lt;b&gt;if&lt;/b&gt;，&lt;b&gt;while&lt;/b&gt;和&lt;b&gt;repeat&lt;/b&gt;具有通常的含义和熟悉的语法：</target>
        </trans-unit>
        <trans-unit id="fd0c2e7539b39e7334ffb646988e686084be276b" translate="yes" xml:space="preserve">
          <source>The conversion from float to integer checks whether the float has an exact representation as an integer (that is, the float has an integral value and it is in the range of integer representation). If it does, that representation is the result. Otherwise, the conversion fails.</source>
          <target state="translated">从float到整数的转换检查float是否有整数的精确表示(即float有一个积分值,并且它在整数表示的范围内)。如果有,则是该表示法的结果。否则,转换失败。</target>
        </trans-unit>
        <trans-unit id="2672e5ddb4380b4a0e9162708d0ffacc1d9552f5" translate="yes" xml:space="preserve">
          <source>The conversion from numbers to strings uses a non-specified human-readable format. For complete control over how numbers are converted to strings, use the &lt;code&gt;format&lt;/code&gt; function from the string library (see &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">从数字到字符串的转换使用非指定的人类可读格式。要完全控制如何将数字转换为字符串，请使用字符串库中的 &lt;code&gt;format&lt;/code&gt; 函数（请参阅&lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d7eef57d5a172c39981c5ce7311c830825d6249b" translate="yes" xml:space="preserve">
          <source>The conversion from numbers to strings uses a non-specified human-readable format. To convert numbers to strings in any specific way, use the function &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从数字到字符串的转换使用非指定的人类可读格式。要将数字以任何特定方式转换为字符串，请使用函数&lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4fc8189f226b883ce5f116eb5b865021736d178" translate="yes" xml:space="preserve">
          <source>The conversion from strings to numbers goes as follows: First, the string is converted to an integer or a float, following its syntax and the rules of the Lua lexer. (The string may have also leading and trailing spaces and a sign.) Then, the resulting number (float or integer) is converted to the type (float or integer) required by the context (e.g., the operation that forced the conversion).</source>
          <target state="translated">从字符串到数字的转换过程如下。首先,按照其语法和Lua词典的规则,将字符串转换为整数或浮点数。(字符串可能还有前导空格、尾部空格和符号。)然后,将得到的数字(float或整数)转换为上下文所要求的类型(float或整数)(例如,强制转换的操作)。</target>
        </trans-unit>
        <trans-unit id="f171e574fe61e971bf96a3990d066bb469d0ea25" translate="yes" xml:space="preserve">
          <source>The conversion of a float to a string now adds a &lt;code&gt;.0&lt;/code&gt; suffix to the result if it looks like an integer. (For instance, the float 2.0 will be printed as &lt;code&gt;2.0&lt;/code&gt;, not as &lt;code&gt;2&lt;/code&gt;.) You should always use an explicit format when you need a specific format for numbers.</source>
          <target state="translated">如果看起来像整数，则将float转换为字符串现在会向结果添加 &lt;code&gt;.0&lt;/code&gt; 后缀。（例如，float 2.0将被打印为 &lt;code&gt;2.0&lt;/code&gt; ，而不是 &lt;code&gt;2&lt;/code&gt; 。）当您需要数字的特定格式时，应始终使用显式格式。</target>
        </trans-unit>
        <trans-unit id="fde25091233105fea6baa5683b61b7b5603b3cd0" translate="yes" xml:space="preserve">
          <source>The conversion of strings can result in integers or floats, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). (The string may have leading and trailing spaces and a sign.)</source>
          <target state="translated">根据Lua的词汇约定，字符串的转换可能导致整数或浮点数（请参阅第&lt;a href=&quot;#3.1&quot;&gt;3.1节&lt;/a&gt;）。 （字符串可能具有前导和尾随空格以及一个符号。）</target>
        </trans-unit>
        <trans-unit id="8a7deb37cbfaea7e8697ec963b8057a9bed112e3" translate="yes" xml:space="preserve">
          <source>The conversion of strings can result in integers or floats, according to the lexical conventions of Lua (see &lt;a href=&quot;#3.1&quot;&gt;&amp;sect;3.1&lt;/a&gt;). The string may have leading and trailing spaces and a sign.</source>
          <target state="translated">根据Lua的词汇约定，字符串的转换可以导致整数或浮点数（请参阅第&lt;a href=&quot;#3.1&quot;&gt;3.1节&lt;/a&gt;）。该字符串可能具有前导和尾随空格以及一个符号。</target>
        </trans-unit>
        <trans-unit id="2779abe0bdda569ab2443dd1aeb2c757f08c9877" translate="yes" xml:space="preserve">
          <source>The conversion specifiers &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, and &lt;code&gt;g&lt;/code&gt; all expect a number as argument. The specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;o&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;x&lt;/code&gt; expect an integer. When Lua is compiled with a C89 compiler, the specifiers &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; (hexadecimal floats) do not support modifiers.</source>
          <target state="translated">转换说明符 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;E&lt;/code&gt; ， &lt;code&gt;e&lt;/code&gt; ， &lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;G&lt;/code&gt; 和 &lt;code&gt;g&lt;/code&gt; 都期望数字作为参数。说明符 &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;d&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;o&lt;/code&gt; ， &lt;code&gt;u&lt;/code&gt; ， &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 期望为整数。当使用C89编译器编译Lua时，说明符 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; （十六进制浮点数）不支持修饰符。</target>
        </trans-unit>
        <trans-unit id="4a41a1a32246a11826a5d6e075e45733f76f3306" translate="yes" xml:space="preserve">
          <source>The conversion specifiers are quite restricted. There are no flags, widths, or precisions. The conversion specifiers can only be '&lt;code&gt;%%&lt;/code&gt;' (inserts the character '&lt;code&gt;%&lt;/code&gt;'), '&lt;code&gt;%s&lt;/code&gt;' (inserts a zero-terminated string, with no size restrictions), '&lt;code&gt;%f&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Number&quot;&gt;&lt;code&gt;lua_Number&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%I&lt;/code&gt;' (inserts a &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;), '&lt;code&gt;%p&lt;/code&gt;' (inserts a pointer as a hexadecimal numeral), '&lt;code&gt;%d&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt;), '&lt;code&gt;%c&lt;/code&gt;' (inserts an &lt;code&gt;int&lt;/code&gt; as a one-byte character), and '&lt;code&gt;%U&lt;/code&gt;' (inserts a &lt;code&gt;long int&lt;/code&gt; as a UTF-8 byte sequence).</source>
          <target state="translated">转换说明符非常受限制。没有标志，宽度或精度。转换说明符只能是' &lt;code&gt;%%&lt;/code&gt; '（插入字符' &lt;code&gt;%&lt;/code&gt; '），' &lt;code&gt;%s&lt;/code&gt; '（插入零终止字符串，没有大小限制），' &lt;code&gt;%f&lt;/code&gt; '（插入&lt;a href=&quot;#lua_Number&quot;&gt; &lt;code&gt;lua_Number&lt;/code&gt; &lt;/a&gt;），' &lt;code&gt;%I&lt;/code&gt; '（插入&lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt;），' &lt;code&gt;%p&lt;/code&gt; '（将指针插入为十六进制数字），' &lt;code&gt;%d&lt;/code&gt; '（插入 &lt;code&gt;int&lt;/code&gt; ），' &lt;code&gt;%c&lt;/code&gt; '（将 &lt;code&gt;int&lt;/code&gt; 作为一个字节的字符插入）和' &lt;code&gt;%U&lt;/code&gt; &amp;ldquo;（将 &lt;code&gt;long int&lt;/code&gt; 插入为UTF-8字节序列）。</target>
        </trans-unit>
        <trans-unit id="4a2b4eab7e7e8e47540c45b140f9d1c1edf8fd79" translate="yes" xml:space="preserve">
          <source>The current parser always sees such constructions in the first way, interpreting the open parenthesis as the start of the arguments to a call. To avoid this ambiguity, it is a good practice to always precede with a semicolon statements that start with a parenthesis:</source>
          <target state="translated">当前的解析器总是以第一种方式来看待这种结构,将打开的括号解释为调用的参数的开始。为了避免这种歧义,一个好的做法是总是在以小括号开头的语句前加上分号。</target>
        </trans-unit>
        <trans-unit id="c9bf869e4f0cbfc39ea3983d219f80c93e648f82" translate="yes" xml:space="preserve">
          <source>The default GC mode with the default parameters are adequate for most uses. However, programs that waste a large proportion of their time allocating and freeing memory can benefit from other settings. Keep in mind that the GC behavior is non-portable both across platforms and across different Lua releases; therefore, optimal settings are also non-portable.</source>
          <target state="translated">默认的GC模式与默认的参数足以满足大多数用途。但是,对于那些浪费了大量时间分配和释放内存的程序,可以从其他设置中受益。请记住,GC行为在不同的平台和不同的Lua版本中是不可移植的;因此,最佳设置也是不可移植的。</target>
        </trans-unit>
        <trans-unit id="1273a024b1e39aac89ab0ab6781ebe040b7fbcc0" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;, so that a call &lt;code&gt;table.remove(l)&lt;/code&gt; removes the last element of list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">为默认值 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;#list&lt;/code&gt; ，使呼叫 &lt;code&gt;table.remove(l)&lt;/code&gt; 删除列表中的最后一个元素 &lt;code&gt;l&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29c63af20a776235dbc6fd94c8529980ff13aa8a" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;pos&lt;/code&gt; is &lt;code&gt;#list&lt;/code&gt;, so that a call &lt;code&gt;table.remove(l)&lt;/code&gt; removes the last element of the list &lt;code&gt;l&lt;/code&gt;.</source>
          <target state="translated">为默认值 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;#list&lt;/code&gt; ，使呼叫 &lt;code&gt;table.remove(l)&lt;/code&gt; 删除列表中的最后一个元素 &lt;code&gt;l&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13c08370b3a28f0fd5960d5a4c5c48fa16e93a96" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;whence&lt;/code&gt; is &lt;code&gt;&quot;cur&quot;&lt;/code&gt;, and for &lt;code&gt;offset&lt;/code&gt; is 0. Therefore, the call &lt;code&gt;file:seek()&lt;/code&gt; returns the current file position, without changing it; the call &lt;code&gt;file:seek(&quot;set&quot;)&lt;/code&gt; sets the position to the beginning of the file (and returns 0); and the call &lt;code&gt;file:seek(&quot;end&quot;)&lt;/code&gt; sets the position to the end of the file, and returns its size.</source>
          <target state="translated">作为默认值 &lt;code&gt;whence&lt;/code&gt; 是 &lt;code&gt;&quot;cur&quot;&lt;/code&gt; ，和用于 &lt;code&gt;offset&lt;/code&gt; 是0，因此，呼叫 &lt;code&gt;file:seek()&lt;/code&gt; 返回当前文件的位置，而不改变它; 调用 &lt;code&gt;file:seek(&quot;set&quot;)&lt;/code&gt; 将位置设置为文件的开头（并返回0）；调用 &lt;code&gt;file:seek(&quot;end&quot;)&lt;/code&gt; 将位置设置为文件的末尾，并返回其大小。</target>
        </trans-unit>
        <trans-unit id="6bc56dc8d299b9d15b00a924ab6b6763132d6c6e" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;x&lt;/code&gt; is 1, so that the call &lt;code&gt;math.atan(y)&lt;/code&gt; returns the arc tangent of &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">作为默认值 &lt;code&gt;x&lt;/code&gt; 为1，以使得呼叫 &lt;code&gt;math.atan(y)&lt;/code&gt; 返回的反正切值 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c1119d71f1c451d5f2fe0db217d85e8a5bba94c" translate="yes" xml:space="preserve">
          <source>The definitions of letter, space, and other character groups depend on the current locale. In particular, the class &lt;code&gt;[a-z]&lt;/code&gt; may not be equivalent to &lt;code&gt;%l&lt;/code&gt;.</source>
          <target state="translated">字母，空格和其他字符组的定义取决于当前的语言环境。特别地，类 &lt;code&gt;[a-z]&lt;/code&gt; 可能不等同于 &lt;code&gt;%l&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f71cbe788ea609ab97e549ccaa27836b38cc887d" translate="yes" xml:space="preserve">
          <source>The field list can have an optional trailing separator, as a convenience for machine-generated code.</source>
          <target state="translated">字段列表可以有一个可选的尾部分隔符,以方便机器生成的代码。</target>
        </trans-unit>
        <trans-unit id="e2dc2a9366caaece55ab74f5902257c1d9cc63e9" translate="yes" xml:space="preserve">
          <source>The fields of &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; have the following meaning:</source>
          <target state="translated">&lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt;的字段具有以下含义：</target>
        </trans-unit>
        <trans-unit id="5cf6a1464c2f6d6211946c68accd0138255e9433" translate="yes" xml:space="preserve">
          <source>The fifth line is a mark to ignore all text after it when building the &lt;code&gt;luaopen_&lt;/code&gt; function name. Default is '&lt;code&gt;-&lt;/code&gt;'.</source>
          <target state="translated">第五行是构建 &lt;code&gt;luaopen_&lt;/code&gt; 函数名称时忽略其后所有文本的标记。默认值为&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d550e1bb0cbfc7b8de8aa9f3e58a6e8b1e903f3a" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;a href=&quot;#pdf-string.pack&quot;&gt;&lt;code&gt;string.pack&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-string.packsize&quot;&gt;&lt;code&gt;string.packsize&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-string.unpack&quot;&gt;&lt;code&gt;string.unpack&lt;/code&gt;&lt;/a&gt; is a format string, which describes the layout of the structure being created or read.</source>
          <target state="translated">&lt;a href=&quot;#pdf-string.pack&quot;&gt; &lt;code&gt;string.pack&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-string.packsize&quot;&gt; &lt;code&gt;string.packsize&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-string.unpack&quot;&gt; &lt;code&gt;string.unpack&lt;/code&gt; &lt;/a&gt;的第一个参数是格式字符串，它描述了正在创建或读取的结构的布局。</target>
        </trans-unit>
        <trans-unit id="35b2be930dbf43b40449e98f73501827b087ff5f" translate="yes" xml:space="preserve">
          <source>The first field, &lt;code&gt;o&lt;/code&gt;, is how many elements the function pops from the stack. The second field, &lt;code&gt;p&lt;/code&gt;, is how many elements the function pushes onto the stack. (Any function always pushes its results after popping its arguments.) A field in the form &lt;code&gt;x|y&lt;/code&gt; means the function can push (or pop) &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; elements, depending on the situation; an interrogation mark '&lt;code&gt;?&lt;/code&gt;' means that we cannot know how many elements the function pops/pushes by looking only at its arguments (e.g., they may depend on what is on the stack). The third field, &lt;code&gt;x&lt;/code&gt;, tells whether the function may raise errors: '&lt;code&gt;-&lt;/code&gt;' means the function never raises any error; '&lt;code&gt;m&lt;/code&gt;' means the function may raise out-of-memory errors and errors running a &lt;code&gt;__gc&lt;/code&gt; metamethod; '&lt;code&gt;e&lt;/code&gt;' means the function may raise any errors (it can run arbitrary Lua code, either directly or through metamethods); '&lt;code&gt;v&lt;/code&gt;' means the function may raise an error on purpose.</source>
          <target state="translated">第一个字段 &lt;code&gt;o&lt;/code&gt; 是函数从堆栈中弹出多少个元素。第二个字段 &lt;code&gt;p&lt;/code&gt; 是函数将多少个元素压入堆栈。 （任何函数总是在弹出其参数后才推送其结果。）形式为 &lt;code&gt;x|y&lt;/code&gt; 字段表示该函数可以根据情况推送（或弹出） &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 元素。讯问标记' &lt;code&gt;?&lt;/code&gt; '意味着我们仅通过查看其参数就无法知道函数弹出/推入了多少个元素（例如，它们可能取决于堆栈中的内容）。第三个字段 &lt;code&gt;x&lt;/code&gt; 指示该函数是否可能引发错误：' &lt;code&gt;-&lt;/code&gt; '表示该函数从不引发任何错误； &amp;ldquo; &lt;code&gt;m&lt;/code&gt; '表示该函数可能会引发内存不足错误和运行 &lt;code&gt;__gc&lt;/code&gt; 元方法的错误；' &lt;code&gt;e&lt;/code&gt; '表示该函数可能会引发任何错误（它可以直接或通过元方法运行任意的Lua代码）；&amp;ldquo; &lt;code&gt;v&lt;/code&gt; &amp;rdquo;表示该函数可能会故意引发错误。</target>
        </trans-unit>
        <trans-unit id="0c89478a55ea6827ef7574f90e0b65d3a882b531" translate="yes" xml:space="preserve">
          <source>The first field, &lt;code&gt;o&lt;/code&gt;, is how many elements the function pops from the stack. The second field, &lt;code&gt;p&lt;/code&gt;, is how many elements the function pushes onto the stack. (Any function always pushes its results after popping its arguments.) A field in the form &lt;code&gt;x|y&lt;/code&gt; means the function can push (or pop) &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; elements, depending on the situation; an interrogation mark '&lt;code&gt;?&lt;/code&gt;' means that we cannot know how many elements the function pops/pushes by looking only at its arguments. (For instance, they may depend on what is in the stack.) The third field, &lt;code&gt;x&lt;/code&gt;, tells whether the function may raise errors: '&lt;code&gt;-&lt;/code&gt;' means the function never raises any error; '&lt;code&gt;m&lt;/code&gt;' means the function may raise only out-of-memory errors; '&lt;code&gt;v&lt;/code&gt;' means the function may raise the errors explained in the text; '&lt;code&gt;e&lt;/code&gt;' means the function can run arbitrary Lua code, either directly or through metamethods, and therefore may raise any errors.</source>
          <target state="translated">第一个字段 &lt;code&gt;o&lt;/code&gt; 是函数从堆栈中弹出多少个元素。第二个字段 &lt;code&gt;p&lt;/code&gt; 是函数将多少个元素压入堆栈。 （任何函数总是在弹出其参数后才推送其结果。）形式为 &lt;code&gt;x|y&lt;/code&gt; 字段表示该函数可以根据情况推送（或弹出） &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 元素。讯问标记' &lt;code&gt;?&lt;/code&gt; &amp;rdquo;表示我们仅通过查看其参数就无法知道该函数弹出/推入了多少个元素。 （例如，它们可能取决于堆栈中的内容。）第三个字段 &lt;code&gt;x&lt;/code&gt; 告诉该函数是否可能引发错误：' &lt;code&gt;-&lt;/code&gt; '表示该函数从不引发任何错误； ' &lt;code&gt;m&lt;/code&gt; '表示该函数仅可能引发内存不足错误； &amp;ldquo; &lt;code&gt;v&lt;/code&gt; &amp;rdquo;表示该函数可能会引起文本中解释的错误； ' &lt;code&gt;e&lt;/code&gt; '表示该函数可以直接或通过元方法运行任意Lua代码，因此可能会引发任何错误。</target>
        </trans-unit>
        <trans-unit id="080894d3f355773389e870abdc64bf22951aa7fd" translate="yes" xml:space="preserve">
          <source>The first line is the directory separator string. Default is '&lt;code&gt;\&lt;/code&gt;' for Windows and '&lt;code&gt;/&lt;/code&gt;' for all other systems.</source>
          <target state="translated">第一行是目录分隔符字符串。对于Windows，默认值为' &lt;code&gt;\&lt;/code&gt; '，对于所有其他系统，默认值为' &lt;code&gt;/&lt;/code&gt; '。</target>
        </trans-unit>
        <trans-unit id="618ae404e5e9c891f664deb6c2fb8fab741ce902" translate="yes" xml:space="preserve">
          <source>The first parameter or local variable has index 1, and so on, following the order that they are declared in the code, counting only the variables that are active in the current scope of the function. Compile-time constants may not appear in this listing, if they were optimized away by the compiler. Negative indices refer to vararg arguments; -1 is the first vararg argument. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no variable with the given index, and raises an error when called with a level out of range. (You can call &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt;&lt;code&gt;debug.getinfo&lt;/code&gt;&lt;/a&gt; to check whether the level is valid.)</source>
          <target state="translated">第一个参数或局部变量的索引为1，依此类推，遵循它们在代码中声明的顺序，仅计算在函数当前范围内处于活动状态的变量。如果编译时常量对其进行了优化，则编译时常量可能不会出现在此列表中。负索引指的是vararg参数。-1是第一个vararg参数。如果没有给定索引的变量，该函数将返回&lt;b&gt;失败&lt;/b&gt;，并在级别超出范围的情况下调用时引发错误。（您可以调用&lt;a href=&quot;#pdf-debug.getinfo&quot;&gt; &lt;code&gt;debug.getinfo&lt;/code&gt; &lt;/a&gt;来检查级别是否有效。）</target>
        </trans-unit>
        <trans-unit id="b927b10bd57d8d0d9d2adab8cf882393f87f3f97" translate="yes" xml:space="preserve">
          <source>The first parameter or local variable has index 1, and so on, following the order that they are declared in the code, counting only the variables that are active in the current scope of the function. Negative indices refer to vararg parameters; -1 is the first vararg parameter. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no variable with the given index, and raises an error when called with a level out of range. (You can call &lt;a href=&quot;#pdf-debug.getinfo&quot;&gt;&lt;code&gt;debug.getinfo&lt;/code&gt;&lt;/a&gt; to check whether the level is valid.)</source>
          <target state="translated">第一个参数或局部变量的索引为1，依此类推，遵循它们在代码中声明的顺序，仅计算在函数当前范围内处于活动状态的变量。负索引指的是vararg参数；-1是第一个vararg参数。如果没有给定索引的变量，该函数将返回&lt;b&gt;nil&lt;/b&gt;，并且在级别超出范围的情况下调用时会引发错误。（您可以调用&lt;a href=&quot;#pdf-debug.getinfo&quot;&gt; &lt;code&gt;debug.getinfo&lt;/code&gt; &lt;/a&gt;来检查级别是否有效。）</target>
        </trans-unit>
        <trans-unit id="ee8f303d70c303dd14cac48bd1f16c3b0dcbcc40" translate="yes" xml:space="preserve">
          <source>The first searcher simply looks for a loader in the &lt;a href=&quot;#pdf-package.preload&quot;&gt;&lt;code&gt;package.preload&lt;/code&gt;&lt;/a&gt; table.</source>
          <target state="translated">第一个搜索器只是在&lt;a href=&quot;#pdf-package.preload&quot;&gt; &lt;code&gt;package.preload&lt;/code&gt; &lt;/a&gt;表中查找装载程序。</target>
        </trans-unit>
        <trans-unit id="62aececc4ee40da1a864200ef2a0c8a1bcbfc8f7" translate="yes" xml:space="preserve">
          <source>The float value &lt;code&gt;HUGE_VAL&lt;/code&gt;, a value greater than any other numeric value.</source>
          <target state="translated">浮点值 &lt;code&gt;HUGE_VAL&lt;/code&gt; ，该值大于任何其他数字值。</target>
        </trans-unit>
        <trans-unit id="d265942ec96276d66e6ab599ec30b3a3b29815fd" translate="yes" xml:space="preserve">
          <source>The float value &lt;code&gt;HUGE_VAL&lt;/code&gt;, a value larger than any other numeric value.</source>
          <target state="translated">浮点值 &lt;code&gt;HUGE_VAL&lt;/code&gt; ，该值大于任何其他数值。</target>
        </trans-unit>
        <trans-unit id="196211405f17ee844517a47f2e8b2cb60db3f8ce" translate="yes" xml:space="preserve">
          <source>The following &lt;em&gt;keywords&lt;/em&gt; are reserved and cannot be used as names:</source>
          <target state="translated">以下&lt;em&gt;关键字&lt;/em&gt;是保留&lt;em&gt;关键字&lt;/em&gt;，不能用作名称：</target>
        </trans-unit>
        <trans-unit id="ab8a72a62eca0d1ef8ee4d0f5f153c9b1519bd5d" translate="yes" xml:space="preserve">
          <source>The following example shows how the host program can do the equivalent to this Lua code:</source>
          <target state="translated">下面的例子显示了主机程序如何做相当于这段Lua代码的工作。</target>
        </trans-unit>
        <trans-unit id="278e2855a1845e2a26526bc29fe7fac6d57babe0" translate="yes" xml:space="preserve">
          <source>The following functions were deprecated in the mathematical library: &lt;code&gt;atan2&lt;/code&gt;, &lt;code&gt;cosh&lt;/code&gt;, &lt;code&gt;sinh&lt;/code&gt;, &lt;code&gt;tanh&lt;/code&gt;, &lt;code&gt;pow&lt;/code&gt;, &lt;code&gt;frexp&lt;/code&gt;, and &lt;code&gt;ldexp&lt;/code&gt;. You can replace &lt;code&gt;math.pow(x,y)&lt;/code&gt; with &lt;code&gt;x^y&lt;/code&gt;; you can replace &lt;code&gt;math.atan2&lt;/code&gt; with &lt;code&gt;math.atan&lt;/code&gt;, which now accepts one or two parameters; you can replace &lt;code&gt;math.ldexp(x,exp)&lt;/code&gt; with &lt;code&gt;x * 2.0^exp&lt;/code&gt;. For the other operations, you can either use an external library or implement them in Lua.</source>
          <target state="translated">数学库中不推荐使用以下函数： &lt;code&gt;atan2&lt;/code&gt; ， &lt;code&gt;cosh&lt;/code&gt; ， &lt;code&gt;sinh&lt;/code&gt; ， &lt;code&gt;tanh&lt;/code&gt; ， &lt;code&gt;pow&lt;/code&gt; ， &lt;code&gt;frexp&lt;/code&gt; 和 &lt;code&gt;ldexp&lt;/code&gt; 。您可以用 &lt;code&gt;x^y&lt;/code&gt; 替换 &lt;code&gt;math.pow(x,y)&lt;/code&gt; ；您可以将 &lt;code&gt;math.atan2&lt;/code&gt; 替换为 &lt;code&gt;math.atan&lt;/code&gt; ，现在可以接受一个或两个参数；您可以替换 &lt;code&gt;math.ldexp(x,exp)&lt;/code&gt; 与 &lt;code&gt;x * 2.0^exp&lt;/code&gt; 。对于其他操作，您可以使用外部库或在Lua中实现它们。</target>
        </trans-unit>
        <trans-unit id="525a807668897271f1a9b9de59f3fdf8f64551a7" translate="yes" xml:space="preserve">
          <source>The following strings denote other tokens:</source>
          <target state="translated">以下字符串表示其他令牌。</target>
        </trans-unit>
        <trans-unit id="ba13fb8d8389b33ab088d4fc65f5ec35b8d33e18" translate="yes" xml:space="preserve">
          <source>The following syntactic sugar simplifies function definitions:</source>
          <target state="translated">下面的语法糖简化了函数定义。</target>
        </trans-unit>
        <trans-unit id="af2cb037b897b34b24d5a23238cf877011ea082c" translate="yes" xml:space="preserve">
          <source>The form</source>
          <target state="translated">形式</target>
        </trans-unit>
        <trans-unit id="7a0c21abdce99c6d3820ba447237185fd89bfedf" translate="yes" xml:space="preserve">
          <source>The formats &quot;&lt;code&gt;l&lt;/code&gt;&quot; and &quot;&lt;code&gt;L&lt;/code&gt;&quot; should be used only for text files.</source>
          <target state="translated">格式&amp;ldquo; &lt;code&gt;l&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;L&lt;/code&gt; &amp;rdquo;应仅用于文本文件。</target>
        </trans-unit>
        <trans-unit id="dd4c785119c8c33799dde8b20447ed83f6ee2b11" translate="yes" xml:space="preserve">
          <source>The fourth line is a string that, in a path in Windows, is replaced by the executable's directory. Default is '&lt;code&gt;!&lt;/code&gt;'.</source>
          <target state="translated">第四行是一个字符串，在Windows的路径中，该字符串被可执行文件的目录替换。默认为' &lt;code&gt;!&lt;/code&gt; '。</target>
        </trans-unit>
        <trans-unit id="c4934c1b60689ce3f2c3bcb8e146450b0295d47d" translate="yes" xml:space="preserve">
          <source>The fourth searcher tries an &lt;em&gt;all-in-one loader&lt;/em&gt;. It searches the C path for a library for the root name of the given module. For instance, when requiring &lt;code&gt;a.b.c&lt;/code&gt;, it will search for a C library for &lt;code&gt;a&lt;/code&gt;. If found, it looks into it for an open function for the submodule; in our example, that would be &lt;code&gt;luaopen_a_b_c&lt;/code&gt;. With this facility, a package can pack several C submodules into one single library, with each submodule keeping its original open function.</source>
          <target state="translated">第四个搜索器尝试一个&lt;em&gt;多合一的加载器&lt;/em&gt;。它在C路径中搜索给定模块的根名称的库。例如，当需要时 &lt;code&gt;a.b.c&lt;/code&gt; ，它会搜索C库的 &lt;code&gt;a&lt;/code&gt; 。如果找到，它将在其中寻找子模块的打开功能；在我们的示例中，它将是 &lt;code&gt;luaopen_a_b_c&lt;/code&gt; 。借助此功能，一个程序包可以将多个C子模块打包到一个库中，每个子模块保持其原始的打开功能。</target>
        </trans-unit>
        <trans-unit id="0b073a91442e0e0571f6fed07833298243fbd91c" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; has an extra parameter. This out parameter returns the number of values on the top of the stack that were yielded or returned by the coroutine. (In previous versions, those values were the entire stack.)</source>
          <target state="translated">函数&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;具有一个额外的参数。这个out参数返回协程产生或返回的栈顶值的数量。（在以前的版本中，这些值是整个堆栈。）</target>
        </trans-unit>
        <trans-unit id="3c583d7e5932250cb3b5f290df0a3aa69c7e5671" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#lua_version&quot;&gt;&lt;code&gt;lua_version&lt;/code&gt;&lt;/a&gt; returns the version number, instead of an address of the version number. The Lua core should work correctly with libraries using their own static copies of the same core, so there is no need to check whether they are using the same address space.</source>
          <target state="translated">函数&lt;a href=&quot;#lua_version&quot;&gt; &lt;code&gt;lua_version&lt;/code&gt; &lt;/a&gt;返回版本号，而不是版本号的地址。Lua核心应该使用它们自己的相同核心的静态副本与库一起正确使用，因此无需检查它们是否使用了相同的地址空间。</target>
        </trans-unit>
        <trans-unit id="b3e053a7fc1423644f26201e21114115843c06a5" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#pdf-io.lines&quot;&gt;&lt;code&gt;io.lines&lt;/code&gt;&lt;/a&gt; now returns four values, instead of just one. That can be a problem when it is used as the sole argument to another function that has optional parameters, such as in &lt;code&gt;load(io.lines(filename, &quot;L&quot;))&lt;/code&gt;. To fix that issue, you can wrap the call into parentheses, to adjust its number of results to one.</source>
          <target state="translated">现在，函数&lt;a href=&quot;#pdf-io.lines&quot;&gt; &lt;code&gt;io.lines&lt;/code&gt; &lt;/a&gt;返回四个值，而不仅仅是一个值。当它用作另一个具有可选参数的函数（例如在 &lt;code&gt;load(io.lines(filename, &quot;L&quot;))&lt;/code&gt; 的唯一参数时，可能会出现问题。要解决该问题，您可以将调用包装在括号中，以将其结果数调整为一个。</target>
        </trans-unit>
        <trans-unit id="ecc8b5fcb7191e1242fe3f17f70a609a4340afa3" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#pdf-print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; does not call &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt; to format its arguments; instead, it has this functionality hardwired. You should use &lt;code&gt;__tostring&lt;/code&gt; to modify how values are printed.</source>
          <target state="translated">函数&lt;a href=&quot;#pdf-print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;不调用&lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt;格式化其参数；相反，它具有硬连线的此功能。您应该使用 &lt;code&gt;__tostring&lt;/code&gt; 修改值的打印方式。</target>
        </trans-unit>
        <trans-unit id="0263ab6ca26086df9c4e35bef1b518910d2dc151" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#pdf-string.gsub&quot;&gt;&lt;code&gt;string.gsub&lt;/code&gt;&lt;/a&gt; and the iterator &lt;a href=&quot;#pdf-string.gmatch&quot;&gt;&lt;code&gt;string.gmatch&lt;/code&gt;&lt;/a&gt; match multiple occurrences of the given pattern in the subject. For these functions, a new match is considered valid only if it ends at least one byte after the end of the previous match. In other words, the pattern machine never accepts the empty string as a match immediately after another match. As an example, consider the results of the following code:</source>
          <target state="translated">函数&lt;a href=&quot;#pdf-string.gsub&quot;&gt; &lt;code&gt;string.gsub&lt;/code&gt; &lt;/a&gt;和迭代器&lt;a href=&quot;#pdf-string.gmatch&quot;&gt; &lt;code&gt;string.gmatch&lt;/code&gt; &lt;/a&gt;匹配主题中给定模式的多次出现。对于这些功能，只有在前一个匹配结束后至少一个字节结束时，新匹配才被认为是有效的。换句话说，模式机绝不会在另一个匹配之后立即接受空字符串作为匹配。例如，请考虑以下代码的结果：</target>
        </trans-unit>
        <trans-unit id="14ef273b64fc52356a4906b3e7d6eabe19ee71ea" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;print&lt;/code&gt; is not intended for formatted output, but only as a quick way to show a value, for instance for debugging. For complete control over the output, use &lt;a href=&quot;#pdf-string.format&quot;&gt;&lt;code&gt;string.format&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.write&quot;&gt;&lt;code&gt;io.write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">函数 &lt;code&gt;print&lt;/code&gt; 不用于格式化输出，而仅是一种显示值的快速方法，例如用于调试。要完全控制输出，请使用&lt;a href=&quot;#pdf-string.format&quot;&gt; &lt;code&gt;string.format&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-io.write&quot;&gt; &lt;code&gt;io.write&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="220aaa9b01b5620d0798784b861e1408f8a717e8" translate="yes" xml:space="preserve">
          <source>The function returns the address of the block of memory. Lua ensures that this address is valid as long as the corresponding userdata is alive (see &lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;). Moreover, if the userdata is marked for finalization (see &lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;), its address is valid at least until the call to its finalizer.</source>
          <target state="translated">该函数返回内存块的地址。只要相应的用户数据处于活动状态，Lua就会确保该地址有效（请参见&lt;a href=&quot;#2.5&quot;&gt;&amp;sect;2.5&lt;/a&gt;）。而且，如果将userdata标记为要终结（请参见&lt;a href=&quot;#2.5.3&quot;&gt;&amp;sect;2.5.3&lt;/a&gt;），则其地址至少在调用其终结器之前一直有效。</target>
        </trans-unit>
        <trans-unit id="cc98f5bacbd5d5c9b5f87b48eedc41b8165ed273" translate="yes" xml:space="preserve">
          <source>The garbage collector (GC) in Lua can work in two modes: incremental and generational.</source>
          <target state="translated">Lua中的垃圾收集器(GC)可以以两种模式工作:增量式和生成式。</target>
        </trans-unit>
        <trans-unit id="f3fbd703ec3951b9eef95d2b7d4e3956a139b1f1" translate="yes" xml:space="preserve">
          <source>The garbage-collector pause controls how long the collector waits before starting a new cycle. Larger values make the collector less aggressive. Values smaller than 100 mean the collector will not wait to start a new cycle. A value of 200 means that the collector waits for the total memory in use to double before starting a new cycle.</source>
          <target state="translated">垃圾收集器暂停控制了收集器在开始新的循环之前等待的时间。数值越大,收集器的积极性越低。小于100的值意味着收集器不会等待开始一个新的循环。值为200表示收集器在开始新的循环之前,会等待使用的总内存增加一倍。</target>
        </trans-unit>
        <trans-unit id="9930e7ac93649b09106490695fbc0f2072543bb0" translate="yes" xml:space="preserve">
          <source>The garbage-collector pause controls how long the collector waits before starting a new cycle. The collector starts a new cycle when the use of memory hits &lt;em&gt;n%&lt;/em&gt; of the use after the previous collection. Larger values make the collector less aggressive. Values equal to or less than 100 mean the collector will not wait to start a new cycle. A value of 200 means that the collector waits for the total memory in use to double before starting a new cycle. The default value is 200; the maximum value is 1000.</source>
          <target state="translated">垃圾收集器暂停控制着收集器在开始新循环之前要等待多长时间。当内存使用量达到前一次收集后的使用量的&lt;em&gt;n％&lt;/em&gt;时，收集器将开始一个新的周期。值越大，收集器的攻击性越小。等于或小于100的值表示收集器将不等待开始新的循环。值200表示收集器在开始新的循环之前等待使用的总内存增加一倍。预设值为200；最大值为1000。</target>
        </trans-unit>
        <trans-unit id="3da0189eddd3acd188369ff8e9890d24f44cba07" translate="yes" xml:space="preserve">
          <source>The garbage-collector step multiplier controls the relative speed of the collector relative to memory allocation. Larger values make the collector more aggressive but also increase the size of each incremental step. You should not use values smaller than 100, because they make the collector too slow and can result in the collector never finishing a cycle. The default is 200, which means that the collector runs at &quot;twice&quot; the speed of memory allocation.</source>
          <target state="translated">垃圾收集器步骤乘数控制收集器相对于内存分配的相对速度。较大的值会使收集器更加激进,但也会增加每个增量步骤的大小。您不应该使用小于100的值,因为它们会使收集器太慢,并可能导致收集器永远无法完成一个周期。默认值是200,这意味着收集器以内存分配速度的 &quot;两倍 &quot;运行。</target>
        </trans-unit>
        <trans-unit id="edd02666b7bd31dec27098654c590c3963c3039b" translate="yes" xml:space="preserve">
          <source>The garbage-collector step multiplier controls the speed of the collector relative to memory allocation, that is, how many elements it marks or sweeps for each kilobyte of memory allocated. Larger values make the collector more aggressive but also increase the size of each incremental step. You should not use values less than 100, because they make the collector too slow and can result in the collector never finishing a cycle. The default value is 100; the maximum value is 1000.</source>
          <target state="translated">垃圾收集器步骤乘数控制了收集器相对于内存分配的速度,也就是说,每分配一千字节的内存,它就标记或扫描多少个元素。值越大,收集器越激进,但也会增加每个增量步长的大小。您不应该使用小于100的值,因为它们会使收集器速度太慢,并可能导致收集器永远无法完成一个周期。默认值为100;最大值为1000。</target>
        </trans-unit>
        <trans-unit id="e9a660cf022dffa05c59d7259e6adabb7cdd6f67" translate="yes" xml:space="preserve">
          <source>The garbage-collector step size controls the size of each incremental step, specifically how many bytes the interpreter allocates before performing a step. This parameter is logarithmic: A value of &lt;em&gt;n&lt;/em&gt; means the interpreter will allocate &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; bytes between steps and perform equivalent work during the step. A large value (e.g., 60) makes the collector a stop-the-world (non-incremental) collector. The default value is 13, which means steps of approximately 8 Kbytes.</source>
          <target state="translated">垃圾收集器步骤的大小控制每个增量步骤的大小，特别是解释器在执行步骤之前分配多少字节。此参数是对数的：&lt;em&gt;n&lt;/em&gt;值表示解释器将在步骤之间分配&lt;em&gt;2 &lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt;个字节，并在该步骤中执行等效的工作。较大的值（例如60）使收集器成为停止运行的（非增量）收集器。默认值为13，这意味着大约8 KB的步长。</target>
        </trans-unit>
        <trans-unit id="9dc362bec1b0383d76bda32165a279742df9516d" translate="yes" xml:space="preserve">
          <source>The generational mode for the garbage collector was removed. (It was an experimental feature in Lua 5.2.)</source>
          <target state="translated">垃圾收集器的生成模式被移除。(这是Lua 5.2中的一个实验性功能。)</target>
        </trans-unit>
        <trans-unit id="d89e31ab18c670e311841a5e28477ef95d2189d8" translate="yes" xml:space="preserve">
          <source>The generic &lt;b&gt;for&lt;/b&gt; loop</source>
          <target state="translated">通用的&lt;b&gt;for&lt;/b&gt;循环</target>
        </trans-unit>
        <trans-unit id="3906554899c83e568ddf64f2f5b8f01161ffbe7d" translate="yes" xml:space="preserve">
          <source>The generic &lt;b&gt;for&lt;/b&gt; statement works over functions, called &lt;em&gt;iterators&lt;/em&gt;. On each iteration, the iterator function is called to produce a new value, stopping when this new value is &lt;b&gt;nil&lt;/b&gt;. The generic &lt;b&gt;for&lt;/b&gt; loop has the following syntax:</source>
          <target state="translated">通用的&lt;b&gt;for&lt;/b&gt;语句对称为&lt;em&gt;迭代器的&lt;/em&gt;函数起作用。在每次迭代中，将调用迭代器函数以生成一个新值，并在该新值为&lt;b&gt;nil&lt;/b&gt;时停止。通用的&lt;b&gt;for&lt;/b&gt;循环具有以下语法：</target>
        </trans-unit>
        <trans-unit id="856007e1c22ba68bdc34a47c09a357751a2f6c62" translate="yes" xml:space="preserve">
          <source>The given identifier (Name) defines the control variable, which is a new variable local to the loop body (&lt;em&gt;block&lt;/em&gt;).</source>
          <target state="translated">给定的标识符（名称）定义了控制变量，该变量是循环体（&lt;em&gt;块&lt;/em&gt;）局部的新变量。</target>
        </trans-unit>
        <trans-unit id="dd954aa3fd6697b79eaabbdef5d75d8c6c7ba3dc" translate="yes" xml:space="preserve">
          <source>The grammar could see it in two ways:</source>
          <target state="translated">语法可以从两个方面来看。</target>
        </trans-unit>
        <trans-unit id="65c328f00080b0011f18aa3b0ed9224892f98cda" translate="yes" xml:space="preserve">
          <source>The grammar could see this fragment in two ways:</source>
          <target state="translated">语法可以从两个方面来看这个片段。</target>
        </trans-unit>
        <trans-unit id="4a4c9ed6f872e82764d4027ec65c0b5bc05fccbd" translate="yes" xml:space="preserve">
          <source>The indexing of tables follows the definition of raw equality in the language. The expressions &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;a[j]&lt;/code&gt; denote the same table element if and only if &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are raw equal (that is, equal without metamethods). In particular, floats with integral values are equal to their respective integers (e.g., &lt;code&gt;1.0 == 1&lt;/code&gt;). To avoid ambiguities, any float used as a key that is equal to an integer is converted to that integer. For instance, if you write &lt;code&gt;a[2.0] = true&lt;/code&gt;, the actual key inserted into the table will be the integer &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">表的索引遵循该语言中原始相等性的定义。表达式 &lt;code&gt;a[i]&lt;/code&gt; 和 &lt;code&gt;a[j]&lt;/code&gt; 表示相同的表元素，并且仅当 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 原始等于（即，没有元方法的情况下等于）时。特别是，具有整数值的浮点数等于它们各自的整数（例如 &lt;code&gt;1.0 == 1&lt;/code&gt; ）。为避免歧义，将用作等于整数的键的任何浮点数转换为该整数。例如，如果您编写 &lt;code&gt;a[2.0] = true&lt;/code&gt; ，则插入表中的实际键将是整数 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c16256befb5f873dad0793713187bd7e83a270f1" translate="yes" xml:space="preserve">
          <source>The indexing of tables follows the definition of raw equality in the language. The expressions &lt;code&gt;a[i]&lt;/code&gt; and &lt;code&gt;a[j]&lt;/code&gt; denote the same table element if and only if &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; are raw equal (that is, equal without metamethods). In particular, floats with integral values are equal to their respective integers (e.g., &lt;code&gt;1.0 == 1&lt;/code&gt;). To avoid ambiguities, any float with integral value used as a key is converted to its respective integer. For instance, if you write &lt;code&gt;a[2.0] = true&lt;/code&gt;, the actual key inserted into the table will be the integer &lt;code&gt;2&lt;/code&gt;. (On the other hand, 2 and &quot;&lt;code&gt;2&lt;/code&gt;&quot; are different Lua values and therefore denote different table entries.)</source>
          <target state="translated">表的索引遵循该语言中原始相等性的定义。表达式 &lt;code&gt;a[i]&lt;/code&gt; 和 &lt;code&gt;a[j]&lt;/code&gt; 表示相同的表元素，并且仅当 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 原始等于（即，没有元方法时等于）时。特别是，具有整数值的浮点数等于它们各自的整数（例如 &lt;code&gt;1.0 == 1&lt;/code&gt; ）。为避免歧义，任何将整数值用作键的浮点数都将转换为其各自的整数。例如，如果您编写 &lt;code&gt;a[2.0] = true&lt;/code&gt; ，则插入表中的实际键将是整数 &lt;code&gt;2&lt;/code&gt; 。 （另一方面，2和&amp;ldquo; &lt;code&gt;2&lt;/code&gt; &amp;rdquo;是不同的Lua值，因此表示不同的表条目。）</target>
        </trans-unit>
        <trans-unit id="63673ee512e5ce79f47a34ae0e3f5ac37fa01bb2" translate="yes" xml:space="preserve">
          <source>The integer keys in the registry are used by the reference mechanism (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;) and by some predefined values. Therefore, integer keys in the registry must not be used for other purposes.</source>
          <target state="translated">注册表中的整数键由引用机制（请参阅&lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt;）和一些预定义的值使用。因此，注册表中的整数键不得用于其他目的。</target>
        </trans-unit>
        <trans-unit id="7b21a8105ceb5ba09152263fc96b9536c63b0161" translate="yes" xml:space="preserve">
          <source>The integer keys in the registry are used by the reference mechanism (see &lt;a href=&quot;#luaL_ref&quot;&gt;&lt;code&gt;luaL_ref&lt;/code&gt;&lt;/a&gt;) and by some predefined values. Therefore, integer keys must not be used for other purposes.</source>
          <target state="translated">注册表中的整数键由引用机制（请参阅&lt;a href=&quot;#luaL_ref&quot;&gt; &lt;code&gt;luaL_ref&lt;/code&gt; &lt;/a&gt;）和一些预定义的值使用。因此，整数键不得用于其他目的。</target>
        </trans-unit>
        <trans-unit id="9e586180c1379ce5751eba407cc18f08a9cdeaf0" translate="yes" xml:space="preserve">
          <source>The interaction between ranges and classes is not defined. Therefore, patterns like &lt;code&gt;[%a-z]&lt;/code&gt; or &lt;code&gt;[a-%%]&lt;/code&gt; have no meaning.</source>
          <target state="translated">范围和类之间的交互未定义。因此， &lt;code&gt;[%a-z]&lt;/code&gt; 或 &lt;code&gt;[a-%%]&lt;/code&gt; 之类的模式没有意义。</target>
        </trans-unit>
        <trans-unit id="6dede3b6c4c93cdc9b3511ce20065bb16da883ae" translate="yes" xml:space="preserve">
          <source>The key for each event in a metatable is a string with the event name prefixed by two underscores; the corresponding value is called a &lt;em&gt;metavalue&lt;/em&gt;. For most events, the metavalue must be a function, which is then called a &lt;em&gt;metamethod&lt;/em&gt;. In the previous example, the key is the string &quot;&lt;code&gt;__add&lt;/code&gt;&quot; and the metamethod is the function that performs the addition. Unless stated otherwise, a metamethod may in fact be any callable value, which is either a function or a value with a &lt;code&gt;__call&lt;/code&gt; metamethod.</source>
          <target state="translated">元表中每个事件的关键字是一个字符串，其事件名称以两个下划线为前缀；相应的值称为&lt;em&gt;元值&lt;/em&gt;。对于大多数事件，元值必须是一个函数，然后将其称为&lt;em&gt;metamethod&lt;/em&gt;。在前面的示例中，键是字符串&amp;ldquo; &lt;code&gt;__add&lt;/code&gt; &amp;rdquo;，元方法是执行加法的函数。除非另有说明，否则元方法实际上可以是任何可调用的值，它可以是函数或具有 &lt;code&gt;__call&lt;/code&gt; 元方法的值。</target>
        </trans-unit>
        <trans-unit id="f2c90b056889f7693fbb491e97825cdc7458b557" translate="yes" xml:space="preserve">
          <source>The key for each event in a metatable is a string with the event name prefixed by two underscores; the corresponding values are called &lt;em&gt;metamethods&lt;/em&gt;. In the previous example, the key is &quot;&lt;code&gt;__add&lt;/code&gt;&quot; and the metamethod is the function that performs the addition.</source>
          <target state="translated">元表中每个事件的键是一个字符串，其事件名称以两个下划线为前缀；相应的值称为&lt;em&gt;元方法&lt;/em&gt;。在前面的示例中，键为&amp;ldquo; &lt;code&gt;__add&lt;/code&gt; &amp;rdquo;，元方法为执行加法的函数。</target>
        </trans-unit>
        <trans-unit id="a1e3c58922162233ff6ef255d5df925e8da6f663" translate="yes" xml:space="preserve">
          <source>The length of a string is its number of bytes (that is, the usual meaning of string length when each character is one byte).</source>
          <target state="translated">字符串的长度就是它的字节数(也就是通常意义上的字符串长度,当每个字符是一个字节时)。</target>
        </trans-unit>
        <trans-unit id="d1dc4024a9680b5759a0dab678db12d3202b04ba" translate="yes" xml:space="preserve">
          <source>The length of a string is its number of bytes. (That is the usual meaning of string length when each character is one byte.)</source>
          <target state="translated">字符串的长度是指它的字节数,(当每个字符是一个字节时,这是字符串长度的通常含义)。当每个字符为一个字节时,这就是字符串长度的通常含义)。</target>
        </trans-unit>
        <trans-unit id="01dac97eea86a239bf3254b898850f4681c59248" translate="yes" xml:space="preserve">
          <source>The length operator applied on a table returns a border in that table. A &lt;em&gt;border&lt;/em&gt; in a table &lt;code&gt;t&lt;/code&gt; is any natural number that satisfies the following condition:</source>
          <target state="translated">应用于表的长度运算符返回该表中的边框。一个&lt;em&gt;边界&lt;/em&gt;表中的 &lt;code&gt;t&lt;/code&gt; 是任何自然数满足以下条件：</target>
        </trans-unit>
        <trans-unit id="3a0004633e5acb8c29842421799433ea833432d7" translate="yes" xml:space="preserve">
          <source>The length operator is denoted by the unary prefix operator &lt;code&gt;#&lt;/code&gt;.</source>
          <target state="translated">长度运算符由一元前缀运算符 &lt;code&gt;#&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="13a462f71ac26baf154dba8703e365c0df2ac20a" translate="yes" xml:space="preserve">
          <source>The library function &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; returns a string describing the type of a given value (see &lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt;).</source>
          <target state="translated">库函数&lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;返回描述给定值类型的字符串（请参见&lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5fc003c63a59472e6941a3dc3f9e6ddca58cd50e" translate="yes" xml:space="preserve">
          <source>The library function &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; returns a string describing the type of a given value (see &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">库函数&lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;返回描述给定值类型的字符串（请参见&lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6144a62a4a0e6d0612f6eb91c540d8aa8bcf7d08" translate="yes" xml:space="preserve">
          <source>The logical operators in Lua are &lt;b&gt;and&lt;/b&gt;, &lt;b&gt;or&lt;/b&gt;, and &lt;b&gt;not&lt;/b&gt;. Like the control structures (see &lt;a href=&quot;#3.3.4&quot;&gt;&amp;sect;3.3.4&lt;/a&gt;), all logical operators consider both &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;nil&lt;/b&gt; as false and anything else as true.</source>
          <target state="translated">Lua中的逻辑运算符&lt;b&gt;和&lt;/b&gt;，&lt;b&gt;或&lt;/b&gt;和&lt;b&gt;不&lt;/b&gt;。与控制结构一样（请参见第&lt;a href=&quot;#3.3.4&quot;&gt;3.3.4节&lt;/a&gt;），所有逻辑运算符都将&lt;b&gt;false&lt;/b&gt;和&lt;b&gt;nil都&lt;/b&gt;视为false，并将其他任何内容都视为true。</target>
        </trans-unit>
        <trans-unit id="50f9701ab78d887f6625cde402aefbda0aeac6cc" translate="yes" xml:space="preserve">
          <source>The loop creates ten closures (that is, ten instances of the anonymous function). Each of these closures uses a different &lt;code&gt;y&lt;/code&gt; variable, while all of them share the same &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">该循环创建十个闭包（即，十个匿名函数实例）。每个闭包使用不同的 &lt;code&gt;y&lt;/code&gt; 变量，而它们都共享相同的 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1f770e06bb0b2e653c2173ac5aacca6b0af5ebd" translate="yes" xml:space="preserve">
          <source>The loop starts by evaluating &lt;em&gt;explist&lt;/em&gt; to produce four values: an &lt;em&gt;iterator function&lt;/em&gt;, a &lt;em&gt;state&lt;/em&gt;, an initial value for the control variable, and a &lt;em&gt;closing value&lt;/em&gt;.</source>
          <target state="translated">循环从评估&lt;em&gt;explist&lt;/em&gt;开始以产生四个值：&lt;em&gt;迭代器函数&lt;/em&gt;，&lt;em&gt;状态&lt;/em&gt;，控制变量的初始值和&lt;em&gt;结束值&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="6a3ff1f0aa94e8024327de7dc633ad7a75222d95" translate="yes" xml:space="preserve">
          <source>The loop starts by evaluating once the three control expressions. Their values are called respectively the &lt;em&gt;initial value&lt;/em&gt;, the &lt;em&gt;limit&lt;/em&gt;, and the &lt;em&gt;step&lt;/em&gt;. If the step is absent, it defaults to 1.</source>
          <target state="translated">循环从对三个控制表达式进行一次求值开始。它们的值分别称为&lt;em&gt;初始值&lt;/em&gt;，&lt;em&gt;极限&lt;/em&gt;和&lt;em&gt;步长&lt;/em&gt;。如果没有该步骤，则默认为1。</target>
        </trans-unit>
        <trans-unit id="4fdc614cc4ad6f49d0283a9ba3115c9056932e8c" translate="yes" xml:space="preserve">
          <source>The loop variable &lt;code&gt;v&lt;/code&gt; is local to the loop body. If you need its value after the loop, assign it to another variable before exiting the loop.</source>
          <target state="translated">循环变量 &lt;code&gt;v&lt;/code&gt; 对循环体而言是局部的。如果在循环后需要它的值，请在退出循环前将其分配给另一个变量。</target>
        </trans-unit>
        <trans-unit id="939c85d0694beae03ef42c252fc95eeaad38dd40" translate="yes" xml:space="preserve">
          <source>The loop variables &lt;code&gt;&lt;em&gt;var_i&lt;/em&gt;&lt;/code&gt; are local to the loop; you cannot use their values after the &lt;b&gt;for&lt;/b&gt; ends. If you need these values, then assign them to other variables before breaking or exiting the loop.</source>
          <target state="translated">循环变量 &lt;code&gt;&lt;em&gt;var_i&lt;/em&gt;&lt;/code&gt; 是循环的局部变量；您不能在&lt;b&gt;for&lt;/b&gt;结束后使用它们的值。如果需要这些值，请在中断或退出循环之前将它们分配给其他变量。</target>
        </trans-unit>
        <trans-unit id="b244dd1c7e2205379de1905e2e723510ea200bac" translate="yes" xml:space="preserve">
          <source>The main difference between Lua 5.2 and Lua 5.3 is the introduction of an integer subtype for numbers. Although this change should not affect &quot;normal&quot; computations, some computations (mainly those that involve some kind of overflow) can give different results.</source>
          <target state="translated">Lua 5.2和Lua 5.3的主要区别是为数字引入了一个整数子类型。虽然这个变化不应该影响 &quot;正常 &quot;的计算,但一些计算(主要是那些涉及某种溢出的计算)会产生不同的结果。</target>
        </trans-unit>
        <trans-unit id="3024413e5d3167e329701cbe9f0df4ab1bc0ec8a" translate="yes" xml:space="preserve">
          <source>The major multiplier controls the frequency of major collections. For a major multiplier &lt;em&gt;x&lt;/em&gt;, a new major collection will be done when memory grows &lt;em&gt;x%&lt;/em&gt; larger than the memory in use after the previous major collection. For instance, for a multiplier of 100, the collector will do a major collection when the use of memory gets larger than twice the use after the previous collection. The default value is 100; the maximum value is 1000.</source>
          <target state="translated">主乘数控制主集合的频率。对于主乘数&lt;em&gt;x&lt;/em&gt;，当内存增长到前一个主集合之后使用的内存大&lt;em&gt;x％&lt;/em&gt;时，将进行新的主集合。例如，对于100的乘数，当内存使用量大于上一个收集之后的两倍时，收集器将进行主收集。默认值为100；默认值为100。最大值为1000。</target>
        </trans-unit>
        <trans-unit id="fc3afb9da0c5e976f755e7c1da0bc9514acc6c24" translate="yes" xml:space="preserve">
          <source>The maximum value for &lt;code&gt;n&lt;/code&gt; is 255.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 的最大值为255。</target>
        </trans-unit>
        <trans-unit id="ffedb8611bd2219ed1341ed93dfa610c03d14160" translate="yes" xml:space="preserve">
          <source>The meaning of accesses to table fields can be changed via metatables (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">可以通过元表更改对表字段的访问的含义（请参见&lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ab795f1f93d86887860588306bf3a809576817cd" translate="yes" xml:space="preserve">
          <source>The meaning of accesses to table fields can be changed via metatables. An access to an indexed variable &lt;code&gt;t[i]&lt;/code&gt; is equivalent to a call &lt;code&gt;gettable_event(t,i)&lt;/code&gt;. (See &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; for a complete description of the &lt;code&gt;gettable_event&lt;/code&gt; function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.)</source>
          <target state="translated">可以通过元表更改对表字段的访问的含义。访问索引变量 &lt;code&gt;t[i]&lt;/code&gt; 等效于调用 &lt;code&gt;gettable_event(t,i)&lt;/code&gt; 。 （参见&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;的完整描述 &lt;code&gt;gettable_event&lt;/code&gt; 功能，该功能不会在Lua中定义或调用。我们在这里使用它只是为了便于说明。）</target>
        </trans-unit>
        <trans-unit id="51f3fb78699ea2b9989d6abd1980c0cbe4cf6630" translate="yes" xml:space="preserve">
          <source>The meaning of assignments to global variables and table fields can be changed via metatables. An assignment to an indexed variable &lt;code&gt;t[i] = val&lt;/code&gt; is equivalent to &lt;code&gt;settable_event(t,i,val)&lt;/code&gt;. (See &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt; for a complete description of the &lt;code&gt;settable_event&lt;/code&gt; function. This function is not defined or callable in Lua. We use it here only for explanatory purposes.)</source>
          <target state="translated">可以通过元表更改全局变量和表字段的赋值含义。对索引变量 &lt;code&gt;t[i] = val&lt;/code&gt; 的赋值等效于 &lt;code&gt;settable_event(t,i,val)&lt;/code&gt; 。 （有关 &lt;code&gt;settable_event&lt;/code&gt; 函数的完整说明，请参见&lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;。此函数未在Lua中定义或调用。我们在这里仅将其用于解释目的。）</target>
        </trans-unit>
        <trans-unit id="9a2953cd0234cc021c9ceb35ae45458389e231cf" translate="yes" xml:space="preserve">
          <source>The meaning of assignments to table fields and global variables (which are actually table fields, too) can be changed via metatables (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">可以通过元表更改表字段和全局变量（实际上也是表字段）的赋值含义（请参见第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="476f7f8ec4dc606dda756c2c57f4d79d5157eb87" translate="yes" xml:space="preserve">
          <source>The metatable for file handles provides metamethods for &lt;code&gt;__gc&lt;/code&gt; and &lt;code&gt;__close&lt;/code&gt; that try to close the file when called.</source>
          <target state="translated">文件句柄的元表为 &lt;code&gt;__gc&lt;/code&gt; 和 &lt;code&gt;__close&lt;/code&gt; 提供了尝试在调用时关闭文件的元方法。</target>
        </trans-unit>
        <trans-unit id="a517aff7a09be0502b296b4a746e4f103b62d5ad" translate="yes" xml:space="preserve">
          <source>The metavalue for this event can be either a function, a table, or any value with an &lt;code&gt;__index&lt;/code&gt; metavalue. If it is a function, it is called with &lt;code&gt;table&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; as arguments, and the result of the call (adjusted to one value) is the result of the operation. Otherwise, the final result is the result of indexing this metavalue with &lt;code&gt;key&lt;/code&gt;. This indexing is regular, not raw, and therefore can trigger another &lt;code&gt;__index&lt;/code&gt; metavalue.</source>
          <target state="translated">此事件的元值可以是函数，表或带有 &lt;code&gt;__index&lt;/code&gt; 元值的任何值。如果它是一个函数，则以 &lt;code&gt;table&lt;/code&gt; 和 &lt;code&gt;key&lt;/code&gt; 作为参数来调用，并且调用的结果（调整为一个值）是操作的结果。否则，最终结果是使用 &lt;code&gt;key&lt;/code&gt; 索引此元值的结果。此索引是常规索引，不是原始索引，因此可以触发另一个 &lt;code&gt;__index&lt;/code&gt; 元值。</target>
        </trans-unit>
        <trans-unit id="8a54b38487e5e67e3c97a44903b55794c2a39219" translate="yes" xml:space="preserve">
          <source>The minor multiplier controls the frequency of minor collections. For a minor multiplier &lt;em&gt;x&lt;/em&gt;, a new minor collection will be done when memory grows &lt;em&gt;x%&lt;/em&gt; larger than the memory in use after the previous major collection. For instance, for a multiplier of 20, the collector will do a minor collection when the use of memory gets 20% larger than the use after the previous major collection. The default value is 20; the maximum value is 200.</source>
          <target state="translated">次要乘数控制次要收集的频率。对于次要乘数&lt;em&gt;x&lt;/em&gt;，当内存增长到前一个主要集合之后使用的内存大&lt;em&gt;x％&lt;/em&gt;时，将进行新的次要集合。例如，对于20的乘数，当内存使用量比上一个主收集之后的使用量大20％时，收集器将进行次要收集。默认值为20；默认值为20。最大值为200。</target>
        </trans-unit>
        <trans-unit id="15199f2dd863423c43df4649876d6a87282f6752" translate="yes" xml:space="preserve">
          <source>The names &lt;em&gt;var_i&lt;/em&gt; declare loop variables local to the loop body. The first of these variables is the &lt;em&gt;control variable&lt;/em&gt;.</source>
          <target state="translated">名称&lt;em&gt;var_i&lt;/em&gt;声明了局部于循环主体的循环变量。这些变量中的第一个是&lt;em&gt;控制变量&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="e0fe8ffeb58ed09038372ff537610ec6335cea78" translate="yes" xml:space="preserve">
          <source>The negation operator &lt;b&gt;not&lt;/b&gt; always returns &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;true&lt;/b&gt;. The conjunction operator &lt;b&gt;and&lt;/b&gt; returns its first argument if this value is &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;nil&lt;/b&gt;; otherwise, &lt;b&gt;and&lt;/b&gt; returns its second argument. The disjunction operator &lt;b&gt;or&lt;/b&gt; returns its first argument if this value is different from &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt;; otherwise, &lt;b&gt;or&lt;/b&gt; returns its second argument. Both &lt;b&gt;and&lt;/b&gt; and &lt;b&gt;or&lt;/b&gt; use short-circuit evaluation; that is, the second operand is evaluated only if necessary. Here are some examples:</source>
          <target state="translated">否定运算符&lt;b&gt;并不&lt;/b&gt;总是返回&lt;b&gt;false&lt;/b&gt;或&lt;b&gt;true&lt;/b&gt;。联合运算符&lt;b&gt;，&lt;/b&gt;如果该值为&lt;b&gt;false&lt;/b&gt;或&lt;b&gt;nil&lt;/b&gt;，则返回其第一个参数；否则，&lt;b&gt;并且&lt;/b&gt;返回第二个参数。如果此值不同于&lt;b&gt;nil&lt;/b&gt;和&lt;b&gt;false&lt;/b&gt;，则析取运算符&lt;b&gt;或&lt;/b&gt;返回其第一个参数；否则，&lt;b&gt;或&lt;/b&gt;返回其第二个参数。既&lt;b&gt;与&lt;/b&gt;和&lt;b&gt;或&lt;/b&gt;使用短路评价;也就是说，仅在必要时才对第二个操作数求值。这里有些例子：&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="38ec12da384a6d35f4d20d38b437d28efd6741c1" translate="yes" xml:space="preserve">
          <source>The next example collects all pairs &lt;code&gt;key=value&lt;/code&gt; from the given string into a table:</source>
          <target state="translated">下一个示例将给定字符串中的所有对 &lt;code&gt;key=value&lt;/code&gt; 收集到一个表中：</target>
        </trans-unit>
        <trans-unit id="116b01f4d99ddb42293ee136ce9aea24e5e4cfa4" translate="yes" xml:space="preserve">
          <source>The notation &lt;b&gt;fail&lt;/b&gt; means a false value representing some kind of failure. (Currently, &lt;b&gt;fail&lt;/b&gt; is equal to &lt;b&gt;nil&lt;/b&gt;, but that may change in future versions. The recommendation is to always test the success of these functions with &lt;code&gt;(not status)&lt;/code&gt;, instead of &lt;code&gt;(status == nil)&lt;/code&gt;.)</source>
          <target state="translated">&lt;b&gt;失败&lt;/b&gt;符号表示表示某种&lt;b&gt;失败&lt;/b&gt;的错误值。（当前，&lt;b&gt;fail&lt;/b&gt;等于&lt;b&gt;nil&lt;/b&gt;，但是在将来的版本中可能会改变。建议始终使用 &lt;code&gt;(not status)&lt;/code&gt; 而不是 &lt;code&gt;(status == nil)&lt;/code&gt; 来测试这些功能的成功。）</target>
        </trans-unit>
        <trans-unit id="71396a651a41b41de0bb0db4aedd5e23034b53f6" translate="yes" xml:space="preserve">
          <source>The numerical &lt;b&gt;for&lt;/b&gt; loop</source>
          <target state="translated">数值&lt;b&gt;for&lt;/b&gt;循环</target>
        </trans-unit>
        <trans-unit id="b8808774c2b04bca424be7db4bdcbf672bc791b6" translate="yes" xml:space="preserve">
          <source>The numerical &lt;b&gt;for&lt;/b&gt; loop repeats a block of code while a control variable goes through an arithmetic progression. It has the following syntax:</source>
          <target state="translated">当控制变量进行算术级数运算时，数字&lt;b&gt;for&lt;/b&gt;循环会重复代码块。它具有以下语法：</target>
        </trans-unit>
        <trans-unit id="eb025962461d05ecdc613ae74134730113e392ef" translate="yes" xml:space="preserve">
          <source>The numerical &lt;b&gt;for&lt;/b&gt; loop repeats a block of code while a control variable runs through an arithmetic progression. It has the following syntax:</source>
          <target state="translated">当控制变量通过算术级数运行时，数字&lt;b&gt;for&lt;/b&gt;循环会重复代码块。它具有以下语法：</target>
        </trans-unit>
        <trans-unit id="17ab43bf243843bc19a105d07ba039f8f3f1779b" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;~=&lt;/code&gt; is exactly the negation of equality (&lt;code&gt;==&lt;/code&gt;).</source>
          <target state="translated">运算符 &lt;code&gt;~=&lt;/code&gt; 完全等于等号（ &lt;code&gt;==&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3db0143b2ada0fe6ef4d1b484bfc03ef679605a8" translate="yes" xml:space="preserve">
          <source>The options &quot;&lt;code&gt;setpause&lt;/code&gt;&quot; and &quot;&lt;code&gt;setstepmul&lt;/code&gt;&quot; of the function &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt; are deprecated. You should use the new option &quot;&lt;code&gt;incremental&lt;/code&gt;&quot; to set them.</source>
          <target state="translated">不推荐使用函数&lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; &lt;/a&gt;的选项&amp;ldquo; &lt;code&gt;setpause&lt;/code&gt; &amp;rdquo;和&amp;ldquo; &lt;code&gt;setstepmul&lt;/code&gt; &amp;rdquo; 。您应该使用新选项&amp;ldquo; &lt;code&gt;incremental&lt;/code&gt; &amp;rdquo;进行设置。</target>
        </trans-unit>
        <trans-unit id="47866a087f6f3e0b29ca9d79b5ace30fa7e691fb" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;-e&lt;/code&gt;, &lt;code&gt;-l&lt;/code&gt;, and &lt;code&gt;-W&lt;/code&gt; are handled in the order they appear. For instance, an invocation like</source>
          <target state="translated">选项 &lt;code&gt;-e&lt;/code&gt; ， &lt;code&gt;-l&lt;/code&gt; 和 &lt;code&gt;-W&lt;/code&gt; 按照它们出现的顺序进行处理。例如，像这样的调用</target>
        </trans-unit>
        <trans-unit id="a3cd1dd677d9388e84d76eced4474c97bac8b4fd" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt; and &lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt; of the function &lt;a href=&quot;#lua_gc&quot;&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt; are deprecated. You should use the new option &lt;code&gt;LUA_GCINC&lt;/code&gt; to set them.</source>
          <target state="translated">不建议使用函数&lt;a href=&quot;#lua_gc&quot;&gt; &lt;code&gt;lua_gc&lt;/code&gt; &lt;/a&gt;的选项 &lt;code&gt;LUA_GCSETPAUSE&lt;/code&gt; 和 &lt;code&gt;LUA_GCSETSTEPMUL&lt;/code&gt; 。您应该使用新的选项 &lt;code&gt;LUA_GCINC&lt;/code&gt; 进行设置。</target>
        </trans-unit>
        <trans-unit id="dbc030680dac1e5576f7a0a32beac02271b1de9f" translate="yes" xml:space="preserve">
          <source>The options are:</source>
          <target state="translated">这些选择是:</target>
        </trans-unit>
        <trans-unit id="c0e99c83b2c086ff1b9d5a58745baab04d9e1b8a" translate="yes" xml:space="preserve">
          <source>The order in which the indices are enumerated is not specified, &lt;em&gt;even for numeric indices&lt;/em&gt;. (To traverse a table in numerical order, use a numerical &lt;b&gt;for&lt;/b&gt;.)</source>
          <target state="translated">&lt;em&gt;甚至对于数字索引&lt;/em&gt;，&lt;em&gt;也&lt;/em&gt;未指定索引的枚举顺序。（要按数字顺序遍历表，请将数字&lt;b&gt;用于&lt;/b&gt;。）</target>
        </trans-unit>
        <trans-unit id="30b30ff9b28bb0a62b9d5eaa0e7b9c185acec6fd" translate="yes" xml:space="preserve">
          <source>The order of the assignments in a constructor is undefined. (This order would be relevant only when there are repeated keys.)</source>
          <target state="translated">构造函数中赋值的顺序是未定义的。(这种顺序只有在有重复键的情况下才有意义)。</target>
        </trans-unit>
        <trans-unit id="e03d986c8e2482e4650648398c1e744ca72bdc4f" translate="yes" xml:space="preserve">
          <source>The order operators work as follows. If both arguments are numbers, then they are compared according to their mathematical values (regardless of their subtypes). Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the &quot;lt&quot; or the &quot;le&quot; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). A comparison &lt;code&gt;a &amp;gt; b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt; a&lt;/code&gt; and &lt;code&gt;a &amp;gt;= b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt;= a&lt;/code&gt;.</source>
          <target state="translated">订单操作员的工作方式如下。如果两个参数都是数字，则将根据其数学值（无论其子类型如何）对它们进行比较。否则，如果两个参数都是字符串，则将根据当前语言环境比较它们的值。否则，Lua尝试调用&amp;ldquo; lt&amp;rdquo;或&amp;ldquo; le&amp;rdquo;元方法（请参见第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。比较 &lt;code&gt;a &amp;gt; b&lt;/code&gt; 转换为 &lt;code&gt;b &amp;lt; a&lt;/code&gt; 而 &lt;code&gt;a &amp;gt;= b&lt;/code&gt; 转换为 &lt;code&gt;b &amp;lt;= a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16d32560c1bc7362c02c6c6224e74a5d3dda3efc" translate="yes" xml:space="preserve">
          <source>The order operators work as follows. If both arguments are numbers, then they are compared according to their mathematical values, regardless of their subtypes. Otherwise, if both arguments are strings, then their values are compared according to the current locale. Otherwise, Lua tries to call the &lt;code&gt;__lt&lt;/code&gt; or the &lt;code&gt;__le&lt;/code&gt; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). A comparison &lt;code&gt;a &amp;gt; b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt; a&lt;/code&gt; and &lt;code&gt;a &amp;gt;= b&lt;/code&gt; is translated to &lt;code&gt;b &amp;lt;= a&lt;/code&gt;.</source>
          <target state="translated">订单操作员的工作方式如下。如果两个参数都是数字，则根据它们的数学值比较它们，而不管它们的子类型是什么。否则，如果两个参数都是字符串，则将根据当前语言环境对它们的值进行比较。否则，Lua尝试调用 &lt;code&gt;__lt&lt;/code&gt; 或 &lt;code&gt;__le&lt;/code&gt; 元方法（请参见第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。比较 &lt;code&gt;a &amp;gt; b&lt;/code&gt; 转换为 &lt;code&gt;b &amp;lt; a&lt;/code&gt; 而 &lt;code&gt;a &amp;gt;= b&lt;/code&gt; 转换为 &lt;code&gt;b &amp;lt;= a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a0cda038c86954689aa106e41f099cb177ac64c" translate="yes" xml:space="preserve">
          <source>The package library provides basic facilities for loading modules in Lua. It exports one function directly in the global environment: &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;. Everything else is exported in a table &lt;a id=&quot;pdf-package&quot;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">软件包库提供了在Lua中加载模块的基本功能。它直接在全局环境中导出一个函数：&lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;。其他所有内容都以表&lt;a id=&quot;pdf-package&quot;&gt; &lt;code&gt;package&lt;/code&gt; &lt;/a&gt;形式导出。</target>
        </trans-unit>
        <trans-unit id="fa03a4bf443ac88c87678b3c72b93c4aa7015676" translate="yes" xml:space="preserve">
          <source>The package library provides basic facilities for loading modules in Lua. It exports one function directly in the global environment: &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;. Everything else is exported in the table &lt;a id=&quot;pdf-package&quot;&gt;&lt;code&gt;package&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">软件包库提供了在Lua中加载模块的基本功能。它直接在全局环境中导出一个函数：&lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;。其他所有内容都在表&lt;a id=&quot;pdf-package&quot;&gt; &lt;code&gt;package&lt;/code&gt; &lt;/a&gt;导出。</target>
        </trans-unit>
        <trans-unit id="31abba930e733e4da53e00b6f03a89251bd121d5" translate="yes" xml:space="preserve">
          <source>The panic function runs as if it were a message handler (see &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;); in particular, the error object is at the top of the stack. However, there is no guarantee about stack space. To push anything on the stack, the panic function must first check the available space (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;).</source>
          <target state="translated">panic函数就像是消息处理程序一样运行（请参见&lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;）；特别是，错误对象位于堆栈的顶部。但是，不能保证堆栈空间。为了将任何东西压入堆栈，应急函数必须首先检查可用空间（请参见第&lt;a href=&quot;#4.2&quot;&gt;4.2节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="b28207f33d009ff23a6c3b0471b814b49c1801a0" translate="yes" xml:space="preserve">
          <source>The panic function runs as if it were a message handler (see &lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;); in particular, the error object is on the top of the stack. However, there is no guarantee about stack space. To push anything on the stack, the panic function must first check the available space (see &lt;a href=&quot;#4.1.1&quot;&gt;&amp;sect;4.1.1&lt;/a&gt;).</source>
          <target state="translated">panic函数就像是消息处理程序一样运行（请参见&lt;a href=&quot;#2.3&quot;&gt;&amp;sect;2.3&lt;/a&gt;）；特别是，错误对象位于堆栈的顶部。但是，不能保证堆栈空间。为了将任何东西压入堆栈，应急函数必须首先检查可用空间（请参见第&lt;a href=&quot;#4.1.1&quot;&gt;4.1.1节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="248c6c24d6328dcec1eced4a5902bd1ca25c30a6" translate="yes" xml:space="preserve">
          <source>The panic function, as its name implies, is a mechanism of last resort. Programs should avoid it. As a general rule, when a C function is called by Lua with a Lua state, it can do whatever it wants on that Lua state, as it should be already protected. However, when C code operates on other Lua states (e.g., a Lua parameter to the function, a Lua state stored in the registry, or the result of &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;), it should use them only in API calls that cannot raise errors.</source>
          <target state="translated">顾名思义，应急功能是不得已的机制。程序应避免这种情况。通常，当Lua以Lua状态调用C函数时，它可以在该Lua状态上执行任何所需的操作，因为它应该已经受到保护。但是，当C代码在其他Lua状态（例如，函数的Lua参数，存储在注册表中的Lua状态或&lt;a href=&quot;#lua_newthread&quot;&gt; &lt;code&gt;lua_newthread&lt;/code&gt; &lt;/a&gt;的结果）上操作时，它应仅在不会引发错误的API调用中使用它们。</target>
        </trans-unit>
        <trans-unit id="7cd9dea0b0f86a65a80b1cdf11372d51ac94ffd8" translate="yes" xml:space="preserve">
          <source>The panic function, as its name implies, is a mechanism of last resort. Programs should avoid it. As a general rule, when a C function is called by Lua with a Lua state, it can do whatever it wants on that Lua state, as it should be already protected. However, when C code operates on other Lua states (e.g., a Lua-state argument to the function, a Lua state stored in the registry, or the result of &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;), it should use them only in API calls that cannot raise errors.</source>
          <target state="translated">顾名思义，恐慌功能是不得已的机制。程序应避免这种情况。通常，当Lua用Lua状态调用C函数时，它可以在该Lua状态上执行任何所需的操作，因为它应该已经受到保护。但是，当C代码对其他Lua状态（例如，函数的Lua状态参数，注册表中存储的Lua状态或&lt;a href=&quot;#lua_newthread&quot;&gt; &lt;code&gt;lua_newthread&lt;/code&gt; &lt;/a&gt;的结果）进行操作时，它应仅在不会引发错误的API调用中使用它们。</target>
        </trans-unit>
        <trans-unit id="af1c6d6c99e2e0d628fe3fc7ee1c5062d171bd6d" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;f&lt;/code&gt; may also be a function. In that case, &lt;code&gt;getlocal&lt;/code&gt; returns only the name of function parameters.</source>
          <target state="translated">参数 &lt;code&gt;f&lt;/code&gt; 也可以是一个函数。在这种情况下， &lt;code&gt;getlocal&lt;/code&gt; 仅返回函数参数的名称。</target>
        </trans-unit>
        <trans-unit id="2ee0f1d943cdb63fea614a28b80243ba707db6c6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;from&lt;/code&gt; represents the coroutine that is resuming &lt;code&gt;L&lt;/code&gt;. If there is no such coroutine, this parameter can be &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">参数 &lt;code&gt;from&lt;/code&gt; 表示被恢复协程 &lt;code&gt;L&lt;/code&gt; 。如果没有这样的协程，则此参数可以为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65650656d52c148c40e15fc089970d7544c3c111" translate="yes" xml:space="preserve">
          <source>The path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a C loader.</source>
          <target state="translated">&lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;用于搜索C加载程序的路径。</target>
        </trans-unit>
        <trans-unit id="a62c3b69148e7d0643526b28757764d931f17eab" translate="yes" xml:space="preserve">
          <source>The path used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; to search for a Lua loader.</source>
          <target state="translated">&lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;用于搜索Lua加载程序的路径。</target>
        </trans-unit>
        <trans-unit id="c5695907c31c4cdbe5adbf65f538570d9f4bbc4f" translate="yes" xml:space="preserve">
          <source>The pattern (a string, not a function) &quot;&lt;code&gt;[\0-\x7F\xC2-\xF4][\x80-\xBF]*&lt;/code&gt;&quot; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;), which matches exactly one UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string.</source>
          <target state="translated">模式（一个字符串，不是一个函数）&amp;ldquo; &lt;code&gt;[\0-\x7F\xC2-\xF4][\x80-\xBF]*&lt;/code&gt; &amp;rdquo;（请参见&lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;），它与一个UTF-8字节序列完全匹配，假设主题是有效的UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="44576e42d538a0d4f15232ab1f12c35467c5f2ae" translate="yes" xml:space="preserve">
          <source>The pattern (a string, not a function) &quot;&lt;code&gt;[\0-\x7F\xC2-\xFD][\x80-\xBF]*&lt;/code&gt;&quot; (see &lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;), which matches exactly one UTF-8 byte sequence, assuming that the subject is a valid UTF-8 string.</source>
          <target state="translated">模式（一个字符串，不是一个函数）&amp;ldquo; &lt;code&gt;[\0-\x7F\xC2-\xFD][\x80-\xBF]*&lt;/code&gt; &amp;rdquo;（请参见&lt;a href=&quot;#6.4.1&quot;&gt;&amp;sect;6.4.1&lt;/a&gt;），它与一个UTF-8字节序列完全匹配，假设主题是有效的UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="87cd937e99e46145262ab909bbf52a9d51f4acf0" translate="yes" xml:space="preserve">
          <source>The pseudo-random number generator used by the function &lt;a href=&quot;#pdf-math.random&quot;&gt;&lt;code&gt;math.random&lt;/code&gt;&lt;/a&gt; now starts with a somewhat random seed. Moreover, it uses a different algorithm.</source>
          <target state="translated">函数&lt;a href=&quot;#pdf-math.random&quot;&gt; &lt;code&gt;math.random&lt;/code&gt; &lt;/a&gt;现在使用的伪随机数生成器以某种随机种子开始。此外，它使用不同的算法。</target>
        </trans-unit>
        <trans-unit id="4807ffe56b89f96d5345484b52e6277f351113a1" translate="yes" xml:space="preserve">
          <source>The reader function used by &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. Every time &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; needs another piece of the chunk, it calls the reader, passing along its &lt;code&gt;data&lt;/code&gt; parameter. The reader must return a pointer to a block of memory with a new piece of the chunk and set &lt;code&gt;size&lt;/code&gt; to the block size. The block must exist until the reader function is called again. To signal the end of the chunk, the reader must return &lt;code&gt;NULL&lt;/code&gt; or set &lt;code&gt;size&lt;/code&gt; to zero. The reader function may return pieces of any size greater than zero.</source>
          <target state="translated">&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;使用的阅读器功能。每次&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;需要另一个块时，它都会调用读取器，并传递其 &lt;code&gt;data&lt;/code&gt; 参数。读取器必须使用一块新的块将指针返回到内存块，并将 &lt;code&gt;size&lt;/code&gt; 设置为块大小。该块必须存在，直到再次调用阅读器功能为止。要发信号通知块的末尾，读取器必须返回 &lt;code&gt;NULL&lt;/code&gt; 或将 &lt;code&gt;size&lt;/code&gt; 设置为零。阅读器函数可以返回大于零的任何大小的片段。</target>
        </trans-unit>
        <trans-unit id="94196df3b0309cd7d7af8dbae4fe9b55da3dd1ee" translate="yes" xml:space="preserve">
          <source>The reader function used by &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. Every time it needs another piece of the chunk, &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; calls the reader, passing along its &lt;code&gt;data&lt;/code&gt; parameter. The reader must return a pointer to a block of memory with a new piece of the chunk and set &lt;code&gt;size&lt;/code&gt; to the block size. The block must exist until the reader function is called again. To signal the end of the chunk, the reader must return &lt;code&gt;NULL&lt;/code&gt; or set &lt;code&gt;size&lt;/code&gt; to zero. The reader function may return pieces of any size greater than zero.</source>
          <target state="translated">&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;使用的阅读器功能。每次需要另一个块时，&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; 都会&lt;/a&gt;调用读取器，并传递其 &lt;code&gt;data&lt;/code&gt; 参数。读取器必须使用一块新的块将指针返回到内存块，并将 &lt;code&gt;size&lt;/code&gt; 设置为块大小。该块必须存在，直到再次调用阅读器功能为止。要发信号通知块的结尾，读取器必须返回 &lt;code&gt;NULL&lt;/code&gt; 或将 &lt;code&gt;size&lt;/code&gt; 设置为零。读取器函数可以返回大于零的任何大小的片段。</target>
        </trans-unit>
        <trans-unit id="37f620be9ce9c46f8c6dc3707673277eb2ba004c" translate="yes" xml:space="preserve">
          <source>The return values of &lt;code&gt;lua_load&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;lua_load&lt;/code&gt; 的返回值为：</target>
        </trans-unit>
        <trans-unit id="2b6bd9b2d65f7c99bb3fd044a11a11e501baf7b6" translate="yes" xml:space="preserve">
          <source>The returned table can contain all the fields returned by &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;, with the string &lt;code&gt;what&lt;/code&gt; describing which fields to fill in. The default for &lt;code&gt;what&lt;/code&gt; is to get all information available, except the table of valid lines. If present, the option '&lt;code&gt;f&lt;/code&gt;' adds a field named &lt;code&gt;func&lt;/code&gt; with the function itself. If present, the option '&lt;code&gt;L&lt;/code&gt;' adds a field named &lt;code&gt;activelines&lt;/code&gt; with the table of valid lines.</source>
          <target state="translated">返回的表可以包含所有返回的字段&lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; &lt;/a&gt;，以字符串 &lt;code&gt;what&lt;/code&gt; 说明哪些字段填写。对于默认 &lt;code&gt;what&lt;/code&gt; 是让所有可用的信息，除了有效线路表。如果存在，选项&amp;ldquo; &lt;code&gt;f&lt;/code&gt; &amp;rdquo;会在函数本身中添加一个名为 &lt;code&gt;func&lt;/code&gt; 的字段。如果存在，选项&amp;ldquo; &lt;code&gt;L&lt;/code&gt; &amp;rdquo;会在有效行表中添加一个名为 &lt;code&gt;activelines&lt;/code&gt; 的字段。</target>
        </trans-unit>
        <trans-unit id="f55f8b6574e5379a6bf6381df42f2bd48b5ec87a" translate="yes" xml:space="preserve">
          <source>The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other systems, this number counts the number of seconds since some given start time (the &quot;epoch&quot;). In other systems, the meaning is not specified, and the number returned by &lt;code&gt;time&lt;/code&gt; can be used only as an argument to &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-os.difftime&quot;&gt;&lt;code&gt;os.difftime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">返回值是一个数字，其含义取决于您的系统。在POSIX，Windows和某些其他系统中，此数字计算自某个给定的开始时间（&amp;ldquo;纪元&amp;rdquo;）以来的秒数。在其他系统中，未指定含义，并且 &lt;code&gt;time&lt;/code&gt; 返回的数字只能用作&lt;a href=&quot;#pdf-os.date&quot;&gt; &lt;code&gt;os.date&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-os.difftime&quot;&gt; &lt;code&gt;os.difftime&lt;/code&gt; &lt;/a&gt;的参数。</target>
        </trans-unit>
        <trans-unit id="cfbc7fd540fdc9556b78c0aa760e8e168374c2f5" translate="yes" xml:space="preserve">
          <source>The searcher for C loaders used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; changed the way it handles versioned names. Now, the version should come after the module name (as is usual in most other tools). For compatibility, that searcher still tries the old format if it cannot find an open function according to the new style. (Lua 5.2 already worked that way, but it did not document the change.)</source>
          <target state="translated">&lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;使用的C加载程序的搜索器更改了其处理版本名称的方式。现在，版本应该在模块名称之后（与其他大多数工具一样）。为了兼容，如果该搜索器无法根据新样式找到打开的函数，则仍尝试使用旧格式。（Lua 5.2已经以这种方式工作，但是没有记录更改。）</target>
        </trans-unit>
        <trans-unit id="9d03150830b6678b3746886a32e87ec44fd83128" translate="yes" xml:space="preserve">
          <source>The second and third results come from Lua matching an empty string after '&lt;code&gt;b&lt;/code&gt;' and another one after '&lt;code&gt;c&lt;/code&gt;'. Lua does not match an empty string after '&lt;code&gt;a&lt;/code&gt;', because it would end at the same position of the previous match.</source>
          <target state="translated">第二个和第三个结果来自Lua，它匹配在' &lt;code&gt;b&lt;/code&gt; '之后的空字符串和在' &lt;code&gt;c&lt;/code&gt; '之后的另一个字符串。Lua与' &lt;code&gt;a&lt;/code&gt; '后面的空字符串不匹配，因为它会在上一个匹配项的相同位置结束。</target>
        </trans-unit>
        <trans-unit id="d15f5fb6601ee9ab09f9a53d09100cffc80fdb3d" translate="yes" xml:space="preserve">
          <source>The second line is the character that separates templates in a path. Default is '&lt;code&gt;;&lt;/code&gt;'.</source>
          <target state="translated">第二行是分隔路径中模板的字符。默认为' &lt;code&gt;;&lt;/code&gt; '。</target>
        </trans-unit>
        <trans-unit id="98a2720d48fa26f6e8827171e22966063e194996" translate="yes" xml:space="preserve">
          <source>The second searcher looks for a loader as a Lua library, using the path stored at &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt;. The search is done as described in function &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">第二个搜索者使用存储在&lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; 中&lt;/a&gt;的路径来寻找一个装载器作为Lua库。如功能&lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; 中&lt;/a&gt;所述完成搜索。</target>
        </trans-unit>
        <trans-unit id="137238d8dbd009a149982e6efcc20bad727cfcef" translate="yes" xml:space="preserve">
          <source>The semantics of the numerical &lt;b&gt;for&lt;/b&gt; loop over integers changed in some details. In particular, the control variable never wraps around.</source>
          <target state="translated">关于整数的数字&lt;b&gt;for&lt;/b&gt;循环的语义在某些细节上有所更改。特别是，控制变量永远不会回绕。</target>
        </trans-unit>
        <trans-unit id="ff10cde6ef36b0ce8ea3feff1924805fea5410a7" translate="yes" xml:space="preserve">
          <source>The sort algorithm is not stable: elements considered equal by the given order may have their relative positions changed by the sort.</source>
          <target state="translated">排序算法并不稳定:被给定顺序认为相等的元素可能会因为排序而改变其相对位置。</target>
        </trans-unit>
        <trans-unit id="f130a0a60b21f9cce2226de0fac2751f12370d42" translate="yes" xml:space="preserve">
          <source>The specific behavior of each mode is non portable; check the underlying ISO C function &lt;code&gt;setvbuf&lt;/code&gt; in your platform for more details.</source>
          <target state="translated">每种模式的特定行为都是不可移植的。有关更多详细信息，请检查平台中的基础ISO C函数 &lt;code&gt;setvbuf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a64ebff4c2ef0f4608bbc1604d0fba5b08a8c95" translate="yes" xml:space="preserve">
          <source>The specifier &lt;code&gt;p&lt;/code&gt; formats the pointer returned by &lt;a href=&quot;#lua_topointer&quot;&gt;&lt;code&gt;lua_topointer&lt;/code&gt;&lt;/a&gt;. That gives a unique string identifier for tables, userdata, threads, strings, and functions. For other values (numbers, nil, booleans), this specifier results in a string representing the pointer &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">说明符 &lt;code&gt;p&lt;/code&gt; 格式化&lt;a href=&quot;#lua_topointer&quot;&gt; &lt;code&gt;lua_topointer&lt;/code&gt; &lt;/a&gt;返回的指针。这样就为表，用户数据，线程，字符串和函数提供了唯一的字符串标识符。对于其他值（数字，nil，布尔值），此说明符将导致一个表示指针 &lt;code&gt;NULL&lt;/code&gt; 的字符串。</target>
        </trans-unit>
        <trans-unit id="092e708e29157a676fc8263f0a955c36a4f68199" translate="yes" xml:space="preserve">
          <source>The specifier &lt;code&gt;q&lt;/code&gt; formats booleans, nil, numbers, and strings in a way that the result is a valid constant in Lua source code. Booleans and nil are written in the obvious way (&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt;). Floats are written in hexadecimal, to preserve full precision. A string is written between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call</source>
          <target state="translated">说明符 &lt;code&gt;q&lt;/code&gt; 格式化布尔值，nil，数字和字符串，其方式是结果是Lua源代码中的有效常数。布尔值和nil以明显的方式（ &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;nil&lt;/code&gt; ）编写。浮点数以十六进制表示，以保持完整的精度。在双引号之间写入一个字符串，必要时使用转义序列以确保Lua解释器可以安全地读取该字符串。例如，通话</target>
        </trans-unit>
        <trans-unit id="98e415d3f3923dae036c196db9c13a7408c478cc" translate="yes" xml:space="preserve">
          <source>The specifier &lt;code&gt;s&lt;/code&gt; expects a string; if its argument is not a string, it is converted to one following the same rules of &lt;a href=&quot;#pdf-tostring&quot;&gt;&lt;code&gt;tostring&lt;/code&gt;&lt;/a&gt;. If the specifier has any modifier, the corresponding string argument should not contain embedded zeros.</source>
          <target state="translated">说明符 &lt;code&gt;s&lt;/code&gt; 需要一个字符串；如果其参数不是字符串，则按照&lt;a href=&quot;#pdf-tostring&quot;&gt; &lt;code&gt;tostring&lt;/code&gt; &lt;/a&gt;的相同规则将其转换为一个。如果说明符具有任何修饰符，则相应的字符串参数不应包含嵌入的零。</target>
        </trans-unit>
        <trans-unit id="5106e7eaf9b7ca3b362e6dc6b36e589c34ea6d05" translate="yes" xml:space="preserve">
          <source>The standard Lua libraries provide useful functions that are implemented directly through the C API. Some of these functions provide essential services to the language (e.g., &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt;); others provide access to &quot;outside&quot; services (e.g., I/O); and others could be implemented in Lua itself, but are quite useful or have critical performance requirements that deserve an implementation in C (e.g., &lt;a href=&quot;#pdf-table.sort&quot;&gt;&lt;code&gt;table.sort&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">标准的Lua库提供了直接通过C API实现的有用功能。其中一些功能为语言提供了必要的服务（例如，&lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt;）；其他提供对&amp;ldquo;外部&amp;rdquo;服务（例如I / O）的访问；其他的可以在Lua本身中实现，但是它们非常有用，或者具有关键的性能要求，值得在C中实现（例如&lt;a href=&quot;#pdf-table.sort&quot;&gt; &lt;code&gt;table.sort&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4f9a410557c9b2b1485364215e1b8ab3d88af66f" translate="yes" xml:space="preserve">
          <source>The standard Lua libraries provide useful functions that are implemented in C through the C API. Some of these functions provide essential services to the language (e.g., &lt;a href=&quot;#pdf-type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt;); others provide access to outside services (e.g., I/O); and others could be implemented in Lua itself, but that for different reasons deserve an implementation in C (e.g., &lt;a href=&quot;#pdf-table.sort&quot;&gt;&lt;code&gt;table.sort&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">标准的Lua库提供了有用的功能，这些功能通过C API在C中实现。其中一些功能为语言提供了必要的服务（例如，&lt;a href=&quot;#pdf-type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt;）；其他提供对外部服务（例如，I / O）的访问；其他方法可以在Lua本身中实现，但是出于不同的原因，值得在C中实现（例如&lt;a href=&quot;#pdf-table.sort&quot;&gt; &lt;code&gt;table.sort&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f42f392bd799378902334c3d54a3414a4cf4d102" translate="yes" xml:space="preserve">
          <source>The standard paths in the official distribution may change between versions.</source>
          <target state="translated">官方发行版中的标准路径可能会在不同版本之间发生变化。</target>
        </trans-unit>
        <trans-unit id="eaeb2de6b243d1a84e816fda80b831d0cddcf07f" translate="yes" xml:space="preserve">
          <source>The standard representation for file handles used by the standard I/O library.</source>
          <target state="translated">标准I/O库使用的文件句柄的标准表示法。</target>
        </trans-unit>
        <trans-unit id="bb7020ccdbf4af39d9ada89f1f68b18c849ca42e" translate="yes" xml:space="preserve">
          <source>The standard representation for file handles, which is used by the standard I/O library.</source>
          <target state="translated">文件句柄的标准表示法,由标准I/O库使用。</target>
        </trans-unit>
        <trans-unit id="9fd3499f821fa1f3548e8129d6b35f2161cdaff1" translate="yes" xml:space="preserve">
          <source>The statement</source>
          <target state="translated">该声明</target>
        </trans-unit>
        <trans-unit id="b51c68cae2ce99f1a793fe977a6ed087cdabd1ba" translate="yes" xml:space="preserve">
          <source>The status can be 0 (&lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;) for a normal thread, an error code if the thread finished the execution of a &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; with an error, or &lt;a id=&quot;pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the thread is suspended.</source>
          <target state="translated">对于正常线程，状态可以为0（&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt;），如果线程以错误结束了&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;的执行，则状态为错误代码；如果线程被挂起，则状态为&lt;a id=&quot;pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ba591c4d2347c93e195f1809555bf57c5b0e8a4a" translate="yes" xml:space="preserve">
          <source>The status can be &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; for a normal thread, an error code if the thread finished the execution of a &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; with an error, or &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the thread is suspended.</source>
          <target state="translated">对于正常线程，状态可以是&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt;，如果线程以错误结束了&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;的执行，则状态为错误代码，如果线程被挂起，则状态为&lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6107c417c0095d03331e66cca35b7fc41f404ee" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; controls whether the chunk can be text or binary (that is, a precompiled chunk). It may be the string &quot;&lt;code&gt;b&lt;/code&gt;&quot; (only binary chunks), &quot;&lt;code&gt;t&lt;/code&gt;&quot; (only text chunks), or &quot;&lt;code&gt;bt&lt;/code&gt;&quot; (both binary and text). The default is &quot;&lt;code&gt;bt&lt;/code&gt;&quot;.</source>
          <target state="translated">字符串 &lt;code&gt;mode&lt;/code&gt; 控制块可以是文本还是二进制（即，预编译的块）。它可以是字符串&amp;ldquo; &lt;code&gt;b&lt;/code&gt; &amp;rdquo;（仅二进制块），&amp;ldquo; &lt;code&gt;t&lt;/code&gt; &amp;rdquo;（仅文本块）或&amp;ldquo; &lt;code&gt;bt&lt;/code&gt; &amp;rdquo;（二进制和文本）。默认值为&amp;ldquo; &lt;code&gt;bt&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="eb61b3491c7ef29459d2f5f3b4868e8b5f23f56b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符串 &lt;code&gt;mode&lt;/code&gt; 工作方式与&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;函数相同。</target>
        </trans-unit>
        <trans-unit id="beb93a28bba84bfd321ab6652fb3b4fded30346b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;mode&lt;/code&gt; works as in the function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">字符串 &lt;code&gt;mode&lt;/code&gt; 工作方式与&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;函数相同。</target>
        </trans-unit>
        <trans-unit id="4f5be0aef9b83b79d571f55826d5a136dfb44d41" translate="yes" xml:space="preserve">
          <source>The string concatenation operator in Lua is denoted by two dots ('&lt;code&gt;..&lt;/code&gt;'). If both operands are strings or numbers, then the numbers are converted to strings in a non-specified format (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;). Otherwise, the &lt;code&gt;__concat&lt;/code&gt; metamethod is called (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Lua中的字符串连接运算符由两个点（' &lt;code&gt;..&lt;/code&gt; '）表示。如果两个操作数都是字符串或数字，则数字将以非指定格式转换为字符串（请参见第&lt;a href=&quot;#3.4.3&quot;&gt;3.4.3节&lt;/a&gt;）。否则，将 &lt;code&gt;__concat&lt;/code&gt; __concat元方法（请参见第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8627952ee0ea9e9e84752d1eff85ae25a6b8cff5" translate="yes" xml:space="preserve">
          <source>The string concatenation operator in Lua is denoted by two dots ('&lt;code&gt;..&lt;/code&gt;'). If both operands are strings or numbers, then they are converted to strings according to the rules described in &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;. Otherwise, the &lt;code&gt;__concat&lt;/code&gt; metamethod is called (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">Lua中的字符串连接运算符由两个点（' &lt;code&gt;..&lt;/code&gt; '）表示。如果两个操作数都是字符串或数字，则根据&lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3中&lt;/a&gt;描述的规则将它们转换为字符串。否则，将 &lt;code&gt;__concat&lt;/code&gt; __concat元方法（请参见第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9045fd903c161a4ac7a29583b9b8dcf0e5541479" translate="yes" xml:space="preserve">
          <source>The string library assumes one-byte character encodings.</source>
          <target state="translated">字符串库假定为一字节字符编码。</target>
        </trans-unit>
        <trans-unit id="b2b7ec0f9126a815843a8b6eedc7a7a4064d3eb8" translate="yes" xml:space="preserve">
          <source>The string library provides all its functions inside the table &lt;a id=&quot;pdf-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt;. It also sets a metatable for strings where the &lt;code&gt;__index&lt;/code&gt; field points to the &lt;code&gt;string&lt;/code&gt; table. Therefore, you can use the string functions in object-oriented style. For instance, &lt;code&gt;string.byte(s,i)&lt;/code&gt; can be written as &lt;code&gt;s:byte(i)&lt;/code&gt;.</source>
          <target state="translated">字符串库在表&lt;a id=&quot;pdf-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;提供了其所有功能。它还会为 &lt;code&gt;__index&lt;/code&gt; 字段指向 &lt;code&gt;string&lt;/code&gt; 表的字符串设置一个元表。因此，您可以使用面向对象样式的字符串函数。例如， &lt;code&gt;string.byte(s,i)&lt;/code&gt; 可以写为 &lt;code&gt;s:byte(i)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10a50517543fae51ebb08fb2ec16c2bc73963b6e" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;var.Name&lt;/code&gt; is just syntactic sugar for &lt;code&gt;var[&quot;Name&quot;]&lt;/code&gt;:</source>
          <target state="translated">语法 &lt;code&gt;var.Name&lt;/code&gt; 只是 &lt;code&gt;var[&quot;Name&quot;]&lt;/code&gt; 语法糖：</target>
        </trans-unit>
        <trans-unit id="050ff8b5782f01590c86d4091d6bf58f847c8377" translate="yes" xml:space="preserve">
          <source>The syntax for function definition is</source>
          <target state="translated">函数定义的语法是</target>
        </trans-unit>
        <trans-unit id="632eb45dbc253afb0e4d9a6d182579e0f0a1fc32" translate="yes" xml:space="preserve">
          <source>The table &lt;code&gt;io&lt;/code&gt; also provides three predefined file handles with their usual meanings from C: &lt;a id=&quot;pdf-io.stdin&quot;&gt;&lt;code&gt;io.stdin&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-io.stdout&quot;&gt;&lt;code&gt;io.stdout&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-io.stderr&quot;&gt;&lt;code&gt;io.stderr&lt;/code&gt;&lt;/a&gt;. The I/O library never closes these files.</source>
          <target state="translated">表 &lt;code&gt;io&lt;/code&gt; 还提供了三个预定义的文件句柄，它们具有C的通常含义：&lt;a id=&quot;pdf-io.stdin&quot;&gt; &lt;code&gt;io.stdin&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-io.stdout&quot;&gt; &lt;code&gt;io.stdout&lt;/code&gt; &lt;/a&gt;和&lt;a id=&quot;pdf-io.stderr&quot;&gt; &lt;code&gt;io.stderr&lt;/code&gt; &lt;/a&gt;。I / O库从不关闭这些文件。</target>
        </trans-unit>
        <trans-unit id="a5bb6863eedf039eb3411f3dbe0637455e54c4cb" translate="yes" xml:space="preserve">
          <source>The third line is the string that marks the substitution points in a template. Default is '&lt;code&gt;?&lt;/code&gt;'.</source>
          <target state="translated">第三行是标记模板中替换点的字符串。默认值为' &lt;code&gt;?&lt;/code&gt; '。</target>
        </trans-unit>
        <trans-unit id="2123107d9c2b8fa74113fcb8969ea618ea87943f" translate="yes" xml:space="preserve">
          <source>The third searcher looks for a loader as a C library, using the path given by the variable &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt;. Again, the search is done as described in function &lt;a href=&quot;#pdf-package.searchpath&quot;&gt;&lt;code&gt;package.searchpath&lt;/code&gt;&lt;/a&gt;. For instance, if the C path is the string</source>
          <target state="translated">第三个搜索器使用变量&lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt;给出的路径将装载程序作为C库进行查找。同样，按照功能&lt;a href=&quot;#pdf-package.searchpath&quot;&gt; &lt;code&gt;package.searchpath&lt;/code&gt; 中的&lt;/a&gt;描述进行搜索。例如，如果C路径是字符串</target>
        </trans-unit>
        <trans-unit id="addd796f69c05ccc4f282e63f096edaf0f445ae8" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;number&lt;/em&gt; represents both integer numbers and real (floating-point) numbers, using two subtypes: &lt;em&gt;integer&lt;/em&gt; and &lt;em&gt;float&lt;/em&gt;. Standard Lua uses 64-bit integers and double-precision (64-bit) floats, but you can also compile Lua so that it uses 32-bit integers and/or single-precision (32-bit) floats. The option with 32 bits for both integers and floats is particularly attractive for small machines and embedded systems. (See macro &lt;code&gt;LUA_32BITS&lt;/code&gt; in file &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">类型&lt;em&gt;号&lt;/em&gt;使用两个子类型表示整数和实数（浮点数），它们分别是&lt;em&gt;integer&lt;/em&gt;和&lt;em&gt;float&lt;/em&gt;。标准Lua使用64位整数和双精度（64位）浮点数，但您也可以编译Lua，使其使用32位整数和/或单精度（32位）浮点数。具有32位整数和浮点数的选项对于小型机器和嵌入式系统特别有吸引力。 （见宏 &lt;code&gt;LUA_32BITS&lt;/code&gt; 文件 &lt;code&gt;luaconf.h&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="8accc1fdc3658380909273543cc837dcd9d22775" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;number&lt;/em&gt; uses two internal representations, or two subtypes, one called &lt;em&gt;integer&lt;/em&gt; and the other called &lt;em&gt;float&lt;/em&gt;. Lua has explicit rules about when each representation is used, but it also converts between them automatically as needed (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;). Therefore, the programmer may choose to mostly ignore the difference between integers and floats or to assume complete control over the representation of each number. Standard Lua uses 64-bit integers and double-precision (64-bit) floats, but you can also compile Lua so that it uses 32-bit integers and/or single-precision (32-bit) floats. The option with 32 bits for both integers and floats is particularly attractive for small machines and embedded systems. (See macro &lt;code&gt;LUA_32BITS&lt;/code&gt; in file &lt;code&gt;luaconf.h&lt;/code&gt;.)</source>
          <target state="translated">类型&lt;em&gt;号&lt;/em&gt;使用两个内部表示形式或两个子类型，一个称为&lt;em&gt;整数&lt;/em&gt;，另一个称为&lt;em&gt;float&lt;/em&gt;。 Lua有关于何时使用每种表示形式的明确规则，但是它也会根据需要在它们之间自动转换（请参见第&lt;a href=&quot;#3.4.3&quot;&gt;3.4.3节&lt;/a&gt;）。因此，程序员可以选择忽略整数和浮点数之间的差异，或者选择完全控制每个数字的表示形式。标准Lua使用64位整数和双精度（64位）浮点数，但您也可以编译Lua，使其使用32位整数和/或单精度（32位）浮点数。具有32位整数和浮点数的选项对于小型机器和嵌入式系统特别有吸引力。 （请参见宏 &lt;code&gt;LUA_32BITS&lt;/code&gt; 文件中的 &lt;code&gt;luaconf.h&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="c9782558cfd51d05e29ec07247ff6f0f3156a12c" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;string&lt;/em&gt; represents immutable sequences of bytes. Lua is 8-bit clean: strings can contain any 8-bit value, including embedded zeros ('&lt;code&gt;\0&lt;/code&gt;'). Lua is also encoding-agnostic; it makes no assumptions about the contents of a string. The length of any string in Lua must fit in a Lua integer.</source>
          <target state="translated">类型&lt;em&gt;字符串&lt;/em&gt;表示字节的不可变序列。 Lua是8位整洁的：字符串可以包含任何8位值，包括嵌入的零（' &lt;code&gt;\0&lt;/code&gt; '）。 Lua也与编码无关。它不对字符串的内容做任何假设。 Lua中任何字符串的长度必须适合Lua整数。</target>
        </trans-unit>
        <trans-unit id="afb6b5b3a4f6e457499e2efa89d3127e8a5239e3" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;table&lt;/em&gt; implements associative arrays, that is, arrays that can be indexed not only with numbers, but with any Lua value except &lt;b&gt;nil&lt;/b&gt; and NaN. (&lt;em&gt;Not a Number&lt;/em&gt; is a special value used to represent undefined or unrepresentable numerical results, such as &lt;code&gt;0/0&lt;/code&gt;.) Tables can be &lt;em&gt;heterogeneous&lt;/em&gt;; that is, they can contain values of all types (except &lt;b&gt;nil&lt;/b&gt;). Any key with value &lt;b&gt;nil&lt;/b&gt; is not considered part of the table. Conversely, any key that is not part of a table has an associated value &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">类型&lt;em&gt;表&lt;/em&gt;实现关联数组，即，不仅可以使用数字索引，而且可以使用除&lt;b&gt;nil&lt;/b&gt;和NaN 之外的任何Lua值索引的数组。（&amp;ldquo; &lt;em&gt;非数字&amp;rdquo;&lt;/em&gt;是用于表示未定义或无法表示的数值结果的特殊值，例如 &lt;code&gt;0/0&lt;/code&gt; 。）表可以是&lt;em&gt;异构的&lt;/em&gt;；也就是说，它们可以包含所有类型的值（&lt;b&gt;nil&lt;/b&gt;除外）。任何值为&lt;b&gt;nil的&lt;/b&gt;键均不视为表的一部分。相反，任何不属于表的键都具有关联值&lt;b&gt;nil&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="30d0477a11463f9ad22a4a02ea0328499a10323e" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;table&lt;/em&gt; implements associative arrays, that is, arrays that can have as indices not only numbers, but any Lua value except &lt;b&gt;nil&lt;/b&gt; and NaN. (&lt;em&gt;Not a Number&lt;/em&gt; is a special floating-point value used by the IEEE 754 standard to represent undefined numerical results, such as &lt;code&gt;0/0&lt;/code&gt;.) Tables can be &lt;em&gt;heterogeneous&lt;/em&gt;; that is, they can contain values of all types (except &lt;b&gt;nil&lt;/b&gt;). Any key associated to the value &lt;b&gt;nil&lt;/b&gt; is not considered part of the table. Conversely, any key that is not part of a table has an associated value &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">类型&lt;em&gt;表&lt;/em&gt;实现关联数组，即不仅可以将数字而且可以将除&lt;b&gt;nil&lt;/b&gt;和NaN之外的任何Lua值作为索引的数组。 （&lt;em&gt;不是一个数字&lt;/em&gt;是由IEEE 754标准来表示未定义的数值结果中使用的特殊的浮点值，例如 &lt;code&gt;0/0&lt;/code&gt; 。）表可以是&lt;em&gt;异质&lt;/em&gt;;也就是说，它们可以包含所有类型的值（&lt;b&gt;nil&lt;/b&gt;除外）。与值&lt;b&gt;nil&lt;/b&gt;相关的任何键均不视为表的一部分。相反，任何不属于表的键都具有关联值&lt;b&gt;nil&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="4d9440269930bed052fd86cfbac01a1a963271db" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;thread&lt;/em&gt; represents independent threads of execution and it is used to implement coroutines (see &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt;). Lua threads are not related to operating-system threads. Lua supports coroutines on all systems, even those that do not support threads natively.</source>
          <target state="translated">类型&lt;em&gt;线程&lt;/em&gt;表示独立的执行线程，它用于实现协程（请参见&lt;a href=&quot;#2.6&quot;&gt;2.6节&lt;/a&gt;）。 Lua线程与操作系统线程无关。 Lua在所有系统上都支持协程，即使那些本机不支持线程的协程也是如此。</target>
        </trans-unit>
        <trans-unit id="8121e5be3e303e17463413ad6f8abdbed524db9a" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;userdata&lt;/em&gt; is provided to allow arbitrary C data to be stored in Lua variables. A userdata value represents a block of raw memory. There are two kinds of userdata: &lt;em&gt;full userdata&lt;/em&gt;, which is an object with a block of memory managed by Lua, and &lt;em&gt;light userdata&lt;/em&gt;, which is simply a C pointer value. Userdata has no predefined operations in Lua, except assignment and identity test. By using &lt;em&gt;metatables&lt;/em&gt;, the programmer can define operations for full userdata values (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). Userdata values cannot be created or modified in Lua, only through the C API. This guarantees the integrity of data owned by the host program and C libraries.</source>
          <target state="translated">提供了&lt;em&gt;userdata&lt;/em&gt;类型，以允许将任意C数据存储在Lua变量中。 userdata值表示原始内存块。用户数据有两种：&lt;em&gt;完全用户数据&lt;/em&gt;（这是一个由Lua管理的具有一块内存的对象）和&lt;em&gt;轻用户数据&lt;/em&gt;（它只是一个C指针值）。除了赋值和身份测试外，Userdata在Lua中没有预定义的操作。通过使用&lt;em&gt;元表&lt;/em&gt;，程序员可以为完整的userdata值定义操作（请参见&lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;）。只能通过C API无法在Lua中创建或修改Userdata值。这保证了主机程序和C库所拥有的数据的完整性。</target>
        </trans-unit>
        <trans-unit id="549971961a231ddc4a1edb8a913953e6d0ac1c5d" translate="yes" xml:space="preserve">
          <source>The type &lt;em&gt;userdata&lt;/em&gt; is provided to allow arbitrary C data to be stored in Lua variables. A userdata value represents a block of raw memory. There are two kinds of userdata: &lt;em&gt;full userdata&lt;/em&gt;, which is an object with a block of memory managed by Lua, and &lt;em&gt;light userdata&lt;/em&gt;, which is simply a C pointer value. Userdata has no predefined operations in Lua, except assignment and identity test. By using &lt;em&gt;metatables&lt;/em&gt;, the programmer can define operations for full userdata values (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). Userdata values cannot be created or modified in Lua, only through the C API. This guarantees the integrity of data owned by the host program.</source>
          <target state="translated">提供了&lt;em&gt;userdata&lt;/em&gt;类型，以允许将任意C数据存储在Lua变量中。 userdata值表示原始内存块。用户数据有两种：&lt;em&gt;完全用户数据&lt;/em&gt;（这是一个由Lua管理的具有一块内存的对象）和&lt;em&gt;轻用户数据&lt;/em&gt;（它只是一个C指针值）。除了赋值和身份测试外，Userdata在Lua中没有预定义的操作。通过使用&lt;em&gt;元表&lt;/em&gt;，程序员可以为完整的userdata值定义操作（请参见第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。只能通过C API在Lua中无法创建或修改Userdata值。这保证了主机程序拥有的数据的完整性。</target>
        </trans-unit>
        <trans-unit id="cb2dae663cd0b88537f77f62b52ecd0fdceb5eb7" translate="yes" xml:space="preserve">
          <source>The type for continuation-function contexts. It must be a numeric type. This type is defined as &lt;code&gt;intptr_t&lt;/code&gt; when &lt;code&gt;intptr_t&lt;/code&gt; is available, so that it can store pointers too. Otherwise, it is defined as &lt;code&gt;ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">延续功能上下文的类型。它必须是数字类型。当 &lt;code&gt;intptr_t&lt;/code&gt; 可用时，此类型定义为 &lt;code&gt;intptr_t&lt;/code&gt; ，以便它也可以存储指针。否则，将其定义为 &lt;code&gt;ptrdiff_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b81ea3cf634f923ceea25ead913b80cfce712bbf" translate="yes" xml:space="preserve">
          <source>The type of floats in Lua.</source>
          <target state="translated">Lua中的浮动类型。</target>
        </trans-unit>
        <trans-unit id="7bd0bf99561dfbd918dc1bdb99594d59c184307f" translate="yes" xml:space="preserve">
          <source>The type of integers in Lua.</source>
          <target state="translated">Lua中的整数类型。</target>
        </trans-unit>
        <trans-unit id="f3373938fcc3069867ceda08c5889260b4eb48bd" translate="yes" xml:space="preserve">
          <source>The type of the memory-allocation function used by Lua states. The allocator function must provide a functionality similar to &lt;code&gt;realloc&lt;/code&gt;, but not exactly the same. Its arguments are &lt;code&gt;ud&lt;/code&gt;, an opaque pointer passed to &lt;a href=&quot;#lua_newstate&quot;&gt;&lt;code&gt;lua_newstate&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;ptr&lt;/code&gt;, a pointer to the block being allocated/reallocated/freed; &lt;code&gt;osize&lt;/code&gt;, the original size of the block or some code about what is being allocated; and &lt;code&gt;nsize&lt;/code&gt;, the new size of the block.</source>
          <target state="translated">Lua状态使用的内存分配函数的类型。分配器功能必须提供类似于 &lt;code&gt;realloc&lt;/code&gt; 的功能，但不完全相同。它的参数是 &lt;code&gt;ud&lt;/code&gt; ，它是传递给&lt;a href=&quot;#lua_newstate&quot;&gt; &lt;code&gt;lua_newstate&lt;/code&gt; &lt;/a&gt;的不透明指针； &lt;code&gt;ptr&lt;/code&gt; ，指向要分配/重新分配/释放的块的指针； &lt;code&gt;osize&lt;/code&gt; ，块的原始大小或有关正在分配的内容的一些代码；和 &lt;code&gt;nsize&lt;/code&gt; ，块的新大小。</target>
        </trans-unit>
        <trans-unit id="1df269fdb1511aeac5ae2230ae20c7d3efe5a527" translate="yes" xml:space="preserve">
          <source>The type of the writer function used by &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;. Every time &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; produces another piece of chunk, it calls the writer, passing along the buffer to be written (&lt;code&gt;p&lt;/code&gt;), its size (&lt;code&gt;sz&lt;/code&gt;), and the &lt;code&gt;ud&lt;/code&gt; parameter supplied to &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt;使用的writer函数的类型。每次&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt;产生另一个块时，它都会调用编写器，并传递要写入的缓冲区（ &lt;code&gt;p&lt;/code&gt; ），其大小（ &lt;code&gt;sz&lt;/code&gt; ）和提供给&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;ud&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="ea2467b4ef42d2fed95d1a97e4a127587c63bf40" translate="yes" xml:space="preserve">
          <source>The type of the writer function used by &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;. Every time it produces another piece of chunk, &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; calls the writer, passing along the buffer to be written (&lt;code&gt;p&lt;/code&gt;), its size (&lt;code&gt;sz&lt;/code&gt;), and the &lt;code&gt;data&lt;/code&gt; parameter supplied to &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt;使用的writer函数的类型。每次生成另一个块时，&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; 都会&lt;/a&gt;调用writer，并传递要写入的缓冲区（ &lt;code&gt;p&lt;/code&gt; ），其大小（ &lt;code&gt;sz&lt;/code&gt; ）和提供给&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;data&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="d018270dc227693da93d9f0a8f9276ac74a821c3" translate="yes" xml:space="preserve">
          <source>The type of warning functions, called by Lua to emit warnings. The first parameter is an opaque pointer set by &lt;a href=&quot;#lua_setwarnf&quot;&gt;&lt;code&gt;lua_setwarnf&lt;/code&gt;&lt;/a&gt;. The second parameter is the warning message. The third parameter is a boolean that indicates whether the message is to be continued by the message in the next call.</source>
          <target state="translated">警告函数的类型，由Lua调用以发出警告。第一个参数是&lt;a href=&quot;#lua_setwarnf&quot;&gt; &lt;code&gt;lua_setwarnf&lt;/code&gt; &lt;/a&gt;设置的不透明指针。第二个参数是警告消息。第三个参数是一个布尔值，指示该消息是否在下一个调用中由该消息继续。</target>
        </trans-unit>
        <trans-unit id="979b7ad2557665ac8c789bc0692eee0412bef53c" translate="yes" xml:space="preserve">
          <source>The unit of compilation of Lua is called a &lt;em&gt;chunk&lt;/em&gt;. Syntactically, a chunk is simply a block:</source>
          <target state="translated">Lua的编译单元称为&lt;em&gt;块&lt;/em&gt;。从句法上讲，块只是一个块：</target>
        </trans-unit>
        <trans-unit id="1fd90de9694cbc90328b75bdffaf97623ca0a9b7" translate="yes" xml:space="preserve">
          <source>The unsigned version of &lt;a href=&quot;#lua_Integer&quot;&gt;&lt;code&gt;lua_Integer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#lua_Integer&quot;&gt; &lt;code&gt;lua_Integer&lt;/code&gt; &lt;/a&gt;的无符号版本。</target>
        </trans-unit>
        <trans-unit id="5f42098ee42cafd687bbe509745646e96e9e3b55" translate="yes" xml:space="preserve">
          <source>The use of the &lt;code&gt;__lt&lt;/code&gt; metamethod to emulate &lt;code&gt;__le&lt;/code&gt; has been removed. When needed, this metamethod must be explicitly defined.</source>
          <target state="translated">删除了使用 &lt;code&gt;__lt&lt;/code&gt; 元方法模拟 &lt;code&gt;__le&lt;/code&gt; 的使用。在需要时，必须明确定义此元方法。</target>
        </trans-unit>
        <trans-unit id="ee895c6fec2956941edfd9074d2ad8c6a07996da" translate="yes" xml:space="preserve">
          <source>The value assigned to a to-be-closed variable must have a &lt;code&gt;__close&lt;/code&gt; metamethod or be a false value. (&lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; are ignored as to-be-closed values.)</source>
          <target state="translated">分配给要关闭的变量的值必须具有 &lt;code&gt;__close&lt;/code&gt; 元方法或为假值。（&lt;b&gt;nil&lt;/b&gt;和&lt;b&gt;false&lt;/b&gt;被忽略为要关闭的值。）</target>
        </trans-unit>
        <trans-unit id="ea5edb4c646d2befa84cf3aa4de94da00e72b361" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;op&lt;/code&gt; must be one of the following constants:</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 的值必须是以下常量之一：</target>
        </trans-unit>
        <trans-unit id="afade59d4e86a697bf216612fdf19b790b49ed5e" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;&amp;pi;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&amp;pi;&lt;/em&gt;的值。</target>
        </trans-unit>
        <trans-unit id="9dc3bab908539601286c9612ae1893b48ba8219b" translate="yes" xml:space="preserve">
          <source>The value returned is the error code returned by the last call to the writer; 0 means no errors.</source>
          <target state="translated">返回的值是上次调用写入器时返回的错误代码,0表示没有错误。</target>
        </trans-unit>
        <trans-unit id="112b2baa6655f11d826fd17791c335badbd32d34" translate="yes" xml:space="preserve">
          <source>The values in these fields do not need to be inside their valid ranges. For instance, if &lt;code&gt;sec&lt;/code&gt; is -10, it means -10 seconds from the time specified by the other fields; if &lt;code&gt;hour&lt;/code&gt; is 1000, it means +1000 hours from the time specified by the other fields.</source>
          <target state="translated">这些字段中的值不必在其有效范围内。例如，如果 &lt;code&gt;sec&lt;/code&gt; 为-10，则表示从其他字段指定的时间开始为-10秒；如果 &lt;code&gt;hour&lt;/code&gt; 是1000，则表示从其他字段指定的时间开始+1000小时。</target>
        </trans-unit>
        <trans-unit id="a99a66eb862f6556290fc79e5e1c7450f919252a" translate="yes" xml:space="preserve">
          <source>The visibility rules for local variables are explained in &lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#3.5&quot;&gt;&amp;sect;3.5&lt;/a&gt;中解释了局部变量的可见性规则。</target>
        </trans-unit>
        <trans-unit id="1638bbae2e91cad1bcbf2314b579efab5e69fee7" translate="yes" xml:space="preserve">
          <source>The writer returns an error code: 0 means no errors; any other value means an error and stops &lt;a href=&quot;#lua_dump&quot;&gt;&lt;code&gt;lua_dump&lt;/code&gt;&lt;/a&gt; from calling the writer again.</source>
          <target state="translated">编写器返回错误代码：0表示没有错误；其他任何值均表示错误，并阻止&lt;a href=&quot;#lua_dump&quot;&gt; &lt;code&gt;lua_dump&lt;/code&gt; &lt;/a&gt;再次调用writer。</target>
        </trans-unit>
        <trans-unit id="e53998e37ed2ba9b38d4b4c370361cd1f8e85f86" translate="yes" xml:space="preserve">
          <source>Then add string pieces to the buffer calling any of the &lt;code&gt;luaL_add*&lt;/code&gt; functions.</source>
          <target state="translated">然后将字符串添加到调用 &lt;code&gt;luaL_add*&lt;/code&gt; 函数的缓冲区中。</target>
        </trans-unit>
        <trans-unit id="58d5ea479608da6d358fd4117e4c1650306f8953" translate="yes" xml:space="preserve">
          <source>Then copy the string into that space.</source>
          <target state="translated">然后将该字符串复制到该空格中。</target>
        </trans-unit>
        <trans-unit id="c38aad0ad68cbec114bc022549a75392e5ff942b" translate="yes" xml:space="preserve">
          <source>Then initialize it and preallocate a space of size &lt;code&gt;sz&lt;/code&gt; with a call &lt;code&gt;luaL_buffinitsize(L, &amp;amp;b, sz)&lt;/code&gt;.</source>
          <target state="translated">然后对其进行初始化，并通过调用 &lt;code&gt;luaL_buffinitsize(L, &amp;amp;b, sz)&lt;/code&gt; 预分配大小为 &lt;code&gt;sz&lt;/code&gt; 的空间。</target>
        </trans-unit>
        <trans-unit id="7fde5c748e0c5d875fb24467538da27e6356bfa2" translate="yes" xml:space="preserve">
          <source>Then initialize it with a call &lt;code&gt;luaL_buffinit(L, &amp;amp;b)&lt;/code&gt;.</source>
          <target state="translated">然后通过调用 &lt;code&gt;luaL_buffinit(L, &amp;amp;b)&lt;/code&gt; 对其进行初始化。</target>
        </trans-unit>
        <trans-unit id="4a6ac0ddbec77a0c5d75add2623e877e243218e1" translate="yes" xml:space="preserve">
          <source>Then produce the string into that space.</source>
          <target state="translated">然后把字符串制作成那个空间。</target>
        </trans-unit>
        <trans-unit id="20602b0df785d59b7a2fc157ec725f513e02a1fe" translate="yes" xml:space="preserve">
          <source>Then, at each iteration, Lua calls the iterator function with two arguments: the state and the control variable. The results from this call are then assigned to the loop variables, following the rules of multiple assignments (see &lt;a href=&quot;#3.3.3&quot;&gt;&amp;sect;3.3.3&lt;/a&gt;). If the control variable becomes &lt;b&gt;nil&lt;/b&gt;, the loop terminates. Otherwise, the body is executed and the loop goes to the next iteration.</source>
          <target state="translated">然后，在每次迭代中，Lua用两个参数调用迭代器函数：状态和控制变量。然后，根据多次分配的规则（参见第&lt;a href=&quot;#3.3.3&quot;&gt;3.3.3节&lt;/a&gt;），将来自此调用的结果分配给循环变量。如果控制变量变为&lt;b&gt;nil&lt;/b&gt;，则循环终止。否则，将执行主体，然后循环进入下一个迭代。</target>
        </trans-unit>
        <trans-unit id="7c089f6502b4ba313710d9bbf20645416ed3a409" translate="yes" xml:space="preserve">
          <source>Then, we have the following mapping from arguments to parameters and to the vararg expression:</source>
          <target state="translated">然后,我们有以下从参数到参数以及到vararg表达式的映射。</target>
        </trans-unit>
        <trans-unit id="589d73d8b2db93fee46410c9d04b6ddf513bc616" translate="yes" xml:space="preserve">
          <source>There are eight basic types in Lua: &lt;em&gt;nil&lt;/em&gt;, &lt;em&gt;boolean&lt;/em&gt;, &lt;em&gt;number&lt;/em&gt;, &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;function&lt;/em&gt;, &lt;em&gt;userdata&lt;/em&gt;, &lt;em&gt;thread&lt;/em&gt;, and &lt;em&gt;table&lt;/em&gt;. The type &lt;em&gt;nil&lt;/em&gt; has one single value, &lt;b&gt;nil&lt;/b&gt;, whose main property is to be different from any other value; it often represents the absence of a useful value. The type &lt;em&gt;boolean&lt;/em&gt; has two values, &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;true&lt;/b&gt;. Both &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; make a condition false; they are collectively called &lt;em&gt;false values&lt;/em&gt;. Any other value makes a condition true.</source>
          <target state="translated">Lua中有八种基本类型：&lt;em&gt;nil&lt;/em&gt;，&lt;em&gt;boolean&lt;/em&gt;，&lt;em&gt;number&lt;/em&gt;，&lt;em&gt;string&lt;/em&gt;，&lt;em&gt;function&lt;/em&gt;，&lt;em&gt;userdata&lt;/em&gt;，&lt;em&gt;thread&lt;/em&gt;和&lt;em&gt;table&lt;/em&gt;。类型&lt;em&gt;nil&lt;/em&gt;有一个单一值&lt;b&gt;nil&lt;/b&gt;，其主要属性将与任何其他值不同。它通常表示缺乏有用的价值。&lt;em&gt;布尔&lt;/em&gt;类型具有两个值&lt;b&gt;false&lt;/b&gt;和&lt;b&gt;true&lt;/b&gt;。两个&lt;b&gt;零&lt;/b&gt;和&lt;b&gt;假&lt;/b&gt;赚了条件为假;它们统称为&lt;em&gt;虚假值&lt;/em&gt;。任何其他值都使条件成立。</target>
        </trans-unit>
        <trans-unit id="08f15568d44d3dd2fb189f12b0a139775af30148" translate="yes" xml:space="preserve">
          <source>There are eight basic types in Lua: &lt;em&gt;nil&lt;/em&gt;, &lt;em&gt;boolean&lt;/em&gt;, &lt;em&gt;number&lt;/em&gt;, &lt;em&gt;string&lt;/em&gt;, &lt;em&gt;function&lt;/em&gt;, &lt;em&gt;userdata&lt;/em&gt;, &lt;em&gt;thread&lt;/em&gt;, and &lt;em&gt;table&lt;/em&gt;. The type &lt;em&gt;nil&lt;/em&gt; has one single value, &lt;b&gt;nil&lt;/b&gt;, whose main property is to be different from any other value; it usually represents the absence of a useful value. The type &lt;em&gt;boolean&lt;/em&gt; has two values, &lt;b&gt;false&lt;/b&gt; and &lt;b&gt;true&lt;/b&gt;. Both &lt;b&gt;nil&lt;/b&gt; and &lt;b&gt;false&lt;/b&gt; make a condition false; any other value makes it true. The type &lt;em&gt;number&lt;/em&gt; represents both integer numbers and real (floating-point) numbers. The type &lt;em&gt;string&lt;/em&gt; represents immutable sequences of bytes. Lua is 8-bit clean: strings can contain any 8-bit value, including embedded zeros ('&lt;code&gt;\0&lt;/code&gt;'). Lua is also encoding-agnostic; it makes no assumptions about the contents of a string.</source>
          <target state="translated">Lua中有八种基本类型：&lt;em&gt;nil&lt;/em&gt;，&lt;em&gt;boolean&lt;/em&gt;，&lt;em&gt;number&lt;/em&gt;，&lt;em&gt;string&lt;/em&gt;，&lt;em&gt;function&lt;/em&gt;，&lt;em&gt;userdata&lt;/em&gt;，&lt;em&gt;thread&lt;/em&gt;和&lt;em&gt;table&lt;/em&gt;。类型&lt;em&gt;nil&lt;/em&gt;有一个单一值&lt;b&gt;nil&lt;/b&gt;，其主要属性将不同于任何其他值。它通常表示没有有用的值。&lt;em&gt;布尔&lt;/em&gt;类型具有两个值&lt;b&gt;false&lt;/b&gt;和&lt;b&gt;true&lt;/b&gt;。两个&lt;b&gt;零&lt;/b&gt;和&lt;b&gt;假&lt;/b&gt;赚了条件为假;任何其他值均使其成立。该类型的&lt;em&gt;号码&lt;/em&gt;代表整数和实数（浮点数）。类型&lt;em&gt;字符串&lt;/em&gt;表示字节的不可变序列。Lua是8位纯净的：字符串可以包含任何8位值，包括嵌入的零（' &lt;code&gt;\0&lt;/code&gt; '）。Lua也与编码无关。它不对字符串的内容做任何假设。</target>
        </trans-unit>
        <trans-unit id="e4a1ac0a2e0cbd023852a04862ae5b37cf817438" translate="yes" xml:space="preserve">
          <source>There are two possible attributes: &lt;code&gt;const&lt;/code&gt;, which declares a constant variable, that is, a variable that cannot be assigned to after its initialization; and &lt;code&gt;close&lt;/code&gt;, which declares a to-be-closed variable (see &lt;a href=&quot;#3.3.8&quot;&gt;&amp;sect;3.3.8&lt;/a&gt;). A list of variables can contain at most one to-be-closed variable.</source>
          <target state="translated">有两个可能的属性： &lt;code&gt;const&lt;/code&gt; ，它声明一个常量变量，即在初始化后不能分配给它的变量；和 &lt;code&gt;close&lt;/code&gt; ，它声明一个将要关闭的变量（请参阅第&lt;a href=&quot;#3.3.8&quot;&gt;3.3.8节&lt;/a&gt;）。变量列表最多可以包含一个要关闭的变量。</target>
        </trans-unit>
        <trans-unit id="96a0eb6e93ec0e9480d194fa3833ccbc401284c3" translate="yes" xml:space="preserve">
          <source>There is a system-dependent limit on the number of values that a function may return. This limit is guaranteed to be greater than 1000.</source>
          <target state="translated">一个函数可以返回的值的数量是有系统限制的。这个限制保证大于1000。</target>
        </trans-unit>
        <trans-unit id="7846fd1d69e8fc588a803bcf086d6b71c1b7e6c8" translate="yes" xml:space="preserve">
          <source>There is a system-dependent limit on the number of values that a function may return. This limit is guaranteed to be larger than 1000.</source>
          <target state="translated">一个函数可以返回的值的数量是有系统限制的。这个限制保证大于1000。</target>
        </trans-unit>
        <trans-unit id="190864f70f817fcefb7920da72729737abc80388" translate="yes" xml:space="preserve">
          <source>There is no explicit function to close or to destroy a thread. Threads are subject to garbage collection, like any Lua object.</source>
          <target state="translated">没有显式函数来关闭或销毁线程。线程和任何Lua对象一样,都要进行垃圾收集。</target>
        </trans-unit>
        <trans-unit id="cda37c5365062edc06713b41ab47ba449b3019c1" translate="yes" xml:space="preserve">
          <source>These constants are defined in the header file &lt;code&gt;lua.h&lt;/code&gt;.</source>
          <target state="translated">这些常量在头文件 &lt;code&gt;lua.h&lt;/code&gt; 中定义。</target>
        </trans-unit>
        <trans-unit id="33a5b691e1bbd0d76427c85690ea834884923c9e" translate="yes" xml:space="preserve">
          <source>These operators always result in &lt;b&gt;false&lt;/b&gt; or &lt;b&gt;true&lt;/b&gt;.</source>
          <target state="translated">这些运算符总是导致&lt;b&gt;false&lt;/b&gt;或&lt;b&gt;true&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="23af1fc0e094c2dd4a126a0afba341a0993ddceb" translate="yes" xml:space="preserve">
          <source>These unique identifiers allow a program to check whether different closures share upvalues. Lua closures that share an upvalue (that is, that access a same external local variable) will return identical ids for those upvalue indices.</source>
          <target state="translated">这些唯一的标识符允许程序检查不同的闭包是否共享upvalue。Lua闭包如果共享一个upvalue(即访问同一个外部局部变量),将为这些upvalue指数返回相同的id。</target>
        </trans-unit>
        <trans-unit id="fcf0ac285f24f41a8021faef38d1d581f4af95ef" translate="yes" xml:space="preserve">
          <source>This function allocates a new block of memory with the given size, pushes onto the stack a new full userdata with the block address, and returns this address. The host program can freely use this memory.</source>
          <target state="translated">该函数分配一个新的给定大小的内存块,将一个新的带有块地址的完整用户数据推送到堆栈上,并返回这个地址。主机程序可以自由使用这个内存。</target>
        </trans-unit>
        <trans-unit id="80082966d6e2d690085ef70dbe523603499247be" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;level&lt;/code&gt; of the stack. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no local variable with the given index, and raises an error when called with a &lt;code&gt;level&lt;/code&gt; out of range. (You can call &lt;code&gt;getinfo&lt;/code&gt; to check whether the level is valid.) Otherwise, it returns the name of the local variable.</source>
          <target state="translated">该函数将值的 &lt;code&gt;value&lt;/code&gt; 分配给在堆栈级别 &lt;code&gt;level&lt;/code&gt; 具有函数索引 &lt;code&gt;local&lt;/code&gt; 的局部变量。如果没有给定索引的局部变量，该函数将返回&lt;b&gt;失败&lt;/b&gt;，并在 &lt;code&gt;level&lt;/code&gt; 超出范围的情况下调用时引发错误。（您可以调用 &lt;code&gt;getinfo&lt;/code&gt; 来检查级别是否有效。）否则，它将返回局部变量的名称。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="02ee19d0f7467cfbd14cfa290c226be8222d4802" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;level&lt;/code&gt; of the stack. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no local variable with the given index, and raises an error when called with a &lt;code&gt;level&lt;/code&gt; out of range. (You can call &lt;code&gt;getinfo&lt;/code&gt; to check whether the level is valid.) Otherwise, it returns the name of the local variable.</source>
          <target state="translated">此函数将值的 &lt;code&gt;value&lt;/code&gt; 分配给在堆栈级别 &lt;code&gt;level&lt;/code&gt; 具有函数索引 &lt;code&gt;local&lt;/code&gt; 的局部变量。如果没有给定索引的局部变量，该函数将返回&lt;b&gt;nil&lt;/b&gt;，并且在 &lt;code&gt;level&lt;/code&gt; 超出范围的情况下调用时会引发错误。（您可以调用 &lt;code&gt;getinfo&lt;/code&gt; 来检查级别是否有效。）否则，它将返回局部变量的名称。&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="d4f42b7d060b48926fc5748edd544aaabb74f7f0" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.</source>
          <target state="translated">此函数分配值 &lt;code&gt;value&lt;/code&gt; 给的upvalue与索引 &lt;code&gt;up&lt;/code&gt; 的功能的 &lt;code&gt;f&lt;/code&gt; 。如果给定索引没有升值，该函数将返回&lt;b&gt;失败&lt;/b&gt;。否则，它返回升值的名称。</target>
        </trans-unit>
        <trans-unit id="b7496e2514cb1dfc80c2cf0b9e57db48fa2c53f8" translate="yes" xml:space="preserve">
          <source>This function assigns the value &lt;code&gt;value&lt;/code&gt; to the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue.</source>
          <target state="translated">此函数分配值 &lt;code&gt;value&lt;/code&gt; 给的upvalue与索引 &lt;code&gt;up&lt;/code&gt; 的功能的 &lt;code&gt;f&lt;/code&gt; 。如果给定索引没有升值，则该函数返回&lt;b&gt;nil&lt;/b&gt;。否则，它返回升值的名称。</target>
        </trans-unit>
        <trans-unit id="ca95f2234def804d470e8cb89141fa32f72381d2" translate="yes" xml:space="preserve">
          <source>This function assumes that &lt;code&gt;s&lt;/code&gt; is a valid UTF-8 string.</source>
          <target state="translated">此函数假定 &lt;code&gt;s&lt;/code&gt; 是有效的UTF-8字符串。</target>
        </trans-unit>
        <trans-unit id="9890c3cbbc40d1dddc0de99ae46a48146fcb130a" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="translated">该函数的行为与&lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt;完全相同，但允许被调用的函数屈服（请参见第&lt;a href=&quot;#4.5&quot;&gt;4.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="580c46d5d2b043293bd752a3640317342ee77988" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">此函数的行为与&lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt;完全相同，但允许被调用函数屈服（请参见&lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="228ffaca57d64d62cbfa46f275e2308925e5e66b" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, but allows the called function to yield (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">此函数的行为与&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;完全相同，但允许被调用的函数产生（请参见&lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6950878744f6693dff083a31e116fc5f8c212d8b" translate="yes" xml:space="preserve">
          <source>This function behaves exactly like &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, except that it allows the called function to yield (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="translated">此函数的行为与&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;完全相同，不同之处在于它允许被调用的函数产生（请参见第&lt;a href=&quot;#4.5&quot;&gt;4.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ef5d902b412506777fd97b25d07c93121dc8d6e1" translate="yes" xml:space="preserve">
          <source>This function can raise an error if it is called from a thread with a pending C call with no continuation function (what is called a &lt;em&gt;C-call boundary&lt;/em&gt;), or it is called from a thread that is not running inside a resume (typically the main thread).</source>
          <target state="translated">如果此函数是从没有继续函数的挂起C调用的线程（称为&lt;em&gt;C调用边界&lt;/em&gt;）&lt;em&gt;调用的&lt;/em&gt;，或者是从不在简历中运行的线程调用的，则可能引发错误。主线程）。</target>
        </trans-unit>
        <trans-unit id="1bff58bee943ec12e3d7290610d93d1b1f73d8e7" translate="yes" xml:space="preserve">
          <source>This function can raise an error if it is called from a thread with a pending C call with no continuation function, or it is called from a thread that is not running inside a resume (e.g., the main thread).</source>
          <target state="translated">如果从一个没有延续函数的待定C调用的线程中调用这个函数,或者从一个没有在resume内运行的线程(例如主线程)中调用这个函数,会引发错误。</target>
        </trans-unit>
        <trans-unit id="66854dc63d240dfdfb45adabbcf93e7e8754325d" translate="yes" xml:space="preserve">
          <source>This function creates and pushes on the stack a new full userdata, with &lt;code&gt;nuvalue&lt;/code&gt; associated Lua values, called &lt;code&gt;user values&lt;/code&gt;, plus an associated block of raw memory with &lt;code&gt;size&lt;/code&gt; bytes. (The user values can be set and read with the functions &lt;a href=&quot;#lua_setiuservalue&quot;&gt;&lt;code&gt;lua_setiuservalue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lua_getiuservalue&quot;&gt;&lt;code&gt;lua_getiuservalue&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">此函数创建新的完整 &lt;code&gt;user values&lt;/code&gt; 并将其压入堆栈，该数据具有与 &lt;code&gt;nuvalue&lt;/code&gt; 相关的Lua值（称为用户值）以及与 &lt;code&gt;size&lt;/code&gt; 字节相关的原始内存块。（可以使用&lt;a href=&quot;#lua_setiuservalue&quot;&gt; &lt;code&gt;lua_setiuservalue&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#lua_getiuservalue&quot;&gt; &lt;code&gt;lua_getiuservalue&lt;/code&gt; &lt;/a&gt;函数设置和读取用户值。）</target>
        </trans-unit>
        <trans-unit id="54be94a59f0bc6784fed88d3a32e726d290eea51" translate="yes" xml:space="preserve">
          <source>This function does not pop the Lua function from the stack.</source>
          <target state="translated">这个函数不会从堆栈中弹出Lua函数。</target>
        </trans-unit>
        <trans-unit id="2481d6e1ad7079fac144cbb94c27fa70e98a36a3" translate="yes" xml:space="preserve">
          <source>This function fills parts of a &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; structure with an identification of the &lt;em&gt;activation record&lt;/em&gt; of the function executing at a given level. Level 0 is the current running function, whereas level &lt;em&gt;n+1&lt;/em&gt; is the function that has called level &lt;em&gt;n&lt;/em&gt; (except for tail calls, which do not count in the stack). When called with a level greater than the stack depth, &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; returns 0; otherwise it returns 1.</source>
          <target state="translated">该函数用在给定级别执行的函数的&lt;em&gt;激活记录&lt;/em&gt;的标识来填充&lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt;结构的各个部分。级别0是当前正在运行的函数，而级别&lt;em&gt;n + 1&lt;/em&gt;是已调用级别&lt;em&gt;n&lt;/em&gt;的函数（尾调用除外，该调用不计入堆栈）。当调用的级别大于堆栈深度时，&lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt;返回0；否则，返回0。否则返回1。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b380c64bb33a1e7916dc907712574229b22846ec" translate="yes" xml:space="preserve">
          <source>This function fills parts of a &lt;a href=&quot;#lua_Debug&quot;&gt;&lt;code&gt;lua_Debug&lt;/code&gt;&lt;/a&gt; structure with an identification of the &lt;em&gt;activation record&lt;/em&gt; of the function executing at a given level. Level 0 is the current running function, whereas level &lt;em&gt;n+1&lt;/em&gt; is the function that has called level &lt;em&gt;n&lt;/em&gt; (except for tail calls, which do not count on the stack). When there are no errors, &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; returns 1; when called with a level greater than the stack depth, it returns 0.</source>
          <target state="translated">该函数用在给定级别执行的函数的&lt;em&gt;激活记录&lt;/em&gt;的标识来填充&lt;a href=&quot;#lua_Debug&quot;&gt; &lt;code&gt;lua_Debug&lt;/code&gt; &lt;/a&gt;结构的各个部分。级别0是当前正在运行的函数，而级别&lt;em&gt;n + 1&lt;/em&gt;是已调用级别&lt;em&gt;n&lt;/em&gt;的函数（尾部调用除外，该调用不计入堆栈）。如果没有错误，则&lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; &lt;/a&gt;返回1；否则，返回0。当调用的级别大于堆栈深度时，它将返回0。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="024557e7c0e16ad2ced2b25eb7a968becab0102d" translate="yes" xml:space="preserve">
          <source>This function has the following restrictions:</source>
          <target state="translated">该函数有以下限制。</target>
        </trans-unit>
        <trans-unit id="95f4de101d63040fc5211037c7343d4c56e0ad01" translate="yes" xml:space="preserve">
          <source>This function is a generic interface to the garbage collector. It performs different functions according to its first argument, &lt;code&gt;opt&lt;/code&gt;:</source>
          <target state="translated">此函数是垃圾回收器的通用接口。它根据第一个参数 &lt;code&gt;opt&lt;/code&gt; 执行不同的功能：</target>
        </trans-unit>
        <trans-unit id="d28a53b3b111db987336d2926f880313a09864bb" translate="yes" xml:space="preserve">
          <source>This function is an interface to the underling pseudo-random generator function provided by C.</source>
          <target state="translated">这个函数是C语言提供的下位伪随机发生器函数的接口。</target>
        </trans-unit>
        <trans-unit id="1f6bb805a39a7c15cbab2acf8a9252c04d7c39ee" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, but it has no continuation (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). Therefore, when the thread resumes, it continues the function that called the function calling &lt;code&gt;lua_yield&lt;/code&gt;. To avoid surprises, this function should be called only in a tail call.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt;，但没有延续（请参见&lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;）。因此，当线程恢复时，它将继续执行调用 &lt;code&gt;lua_yield&lt;/code&gt; 函数的函数。为避免意外，仅应在尾部调用中调用此函数。</target>
        </trans-unit>
        <trans-unit id="f98115d2ab8e4d7be0cefa4bae9be552429cd8c3" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, but it has no continuation (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). Therefore, when the thread resumes, it continues the function that called the function calling &lt;code&gt;lua_yield&lt;/code&gt;.</source>
          <target state="translated">此函数等效于&lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt;，但没有延续（请参见&lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;）。因此，当线程恢复时，它将继续执行调用 &lt;code&gt;lua_yield&lt;/code&gt; 函数的函数。</target>
        </trans-unit>
        <trans-unit id="09df5ee7dcda106a1d20f49f414f02662778ab04" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the ISO C function &lt;code&gt;system&lt;/code&gt;. It passes &lt;code&gt;command&lt;/code&gt; to be executed by an operating system shell. Its first result is &lt;b&gt;true&lt;/b&gt; if the command terminated successfully, or &lt;b&gt;fail&lt;/b&gt; otherwise. After this first result the function returns a string plus a number, as follows:</source>
          <target state="translated">此功能等效于ISO C功能 &lt;code&gt;system&lt;/code&gt; 。它传递要由操作系统外壳执行的 &lt;code&gt;command&lt;/code&gt; 。如果命令成功终止，则其第一个结果为&lt;b&gt;true&lt;/b&gt;，否则为&lt;b&gt;失败&lt;/b&gt;。在第一个结果之后，该函数将返回一个字符串和一个数字，如下所示：</target>
        </trans-unit>
        <trans-unit id="670f5f1a9510a05d3452d6c53437d60b035753b4" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the ISO C function &lt;code&gt;system&lt;/code&gt;. It passes &lt;code&gt;command&lt;/code&gt; to be executed by an operating system shell. Its first result is &lt;b&gt;true&lt;/b&gt; if the command terminated successfully, or &lt;b&gt;nil&lt;/b&gt; otherwise. After this first result the function returns a string plus a number, as follows:</source>
          <target state="translated">此功能等效于ISO C功能 &lt;code&gt;system&lt;/code&gt; 。它传递要由操作系统外壳执行的 &lt;code&gt;command&lt;/code&gt; 。如果命令成功终止，则其第一个结果为&lt;b&gt;true&lt;/b&gt;，否则为&lt;b&gt;nil&lt;/b&gt;。在第一个结果之后，该函数将返回一个字符串和一个数字，如下所示：</target>
        </trans-unit>
        <trans-unit id="d3b4b199ecaac9ea3831e4133d9a32cb7ae19470" translate="yes" xml:space="preserve">
          <source>This function is inherently insecure, as it allows Lua to call any function in any readable dynamic library in the system. (Lua calls any function assuming the function has a proper prototype and respects a proper protocol (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;). Therefore, calling an arbitrary function in an arbitrary dynamic library more often than not results in an access violation.)</source>
          <target state="translated">该函数本质上是不安全的，因为它允许Lua调用系统中任何可读动态库中的任何函数。（Lua假定函数具有适当的原型并遵守适当的协议（请参阅&lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt;），因此将调用任何函数。因此，在任意动态库中调用任意函数的情况多半会导致访问冲突。）</target>
        </trans-unit>
        <trans-unit id="e1a39cb0734d0402904008bd0b6e1f1f1778321f" translate="yes" xml:space="preserve">
          <source>This function is not supported by Standard C. As such, it is only available on some platforms (Windows, Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the &lt;code&gt;dlfcn&lt;/code&gt; standard).</source>
          <target state="translated">Standard C不支持此功能。因此，它仅在某些平台（Windows，Linux，Mac OS X，Solaris，BSD以及其他支持 &lt;code&gt;dlfcn&lt;/code&gt; 标准的Unix系统）上可用。</target>
        </trans-unit>
        <trans-unit id="09ff91542609c4270a5672d90a1b6660e19831ef" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt;, except that it sets a new message handler &lt;code&gt;msgh&lt;/code&gt;.</source>
          <target state="translated">该函数类似于&lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt;，不同之处在于它设置了一个新的消息处理程序 &lt;code&gt;msgh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="717f7af51aaada41e5e3c40f203c1a8fa9d3bad9" translate="yes" xml:space="preserve">
          <source>This function is system dependent and is not available on all platforms.</source>
          <target state="translated">该功能取决于系统,并非在所有平台上都可用。</target>
        </trans-unit>
        <trans-unit id="11f290796c947e6dfdea50bcfa8240bdb86eb8a0" translate="yes" xml:space="preserve">
          <source>This function is used to build a prefix for error messages.</source>
          <target state="translated">该函数用于为错误信息建立一个前缀。</target>
        </trans-unit>
        <trans-unit id="ab9f48a6c272547f77904d32d9efdba0ecb10345" translate="yes" xml:space="preserve">
          <source>This function may be not thread safe because of its reliance on C function &lt;code&gt;setlocale&lt;/code&gt;.</source>
          <target state="translated">由于此函数依赖C函数 &lt;code&gt;setlocale&lt;/code&gt; ,因此可能不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="f5e00f4b8570418e20286901c0f8bb0744338ebc" translate="yes" xml:space="preserve">
          <source>This function may raise an error if the given key is neither &lt;b&gt;nil&lt;/b&gt; nor present in the table. See function &lt;a href=&quot;#pdf-next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; for the caveats of modifying the table during its traversal.</source>
          <target state="translated">如果给定键既不为&lt;b&gt;nil，&lt;/b&gt;也不存在于表中，则此函数可能会引发错误。有关在遍历表时修改表的注意事项，请参见&lt;a href=&quot;#pdf-next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="e9bf98dd64c563d3dc312b225a1b47e8d89ef87d" translate="yes" xml:space="preserve">
          <source>This function may raise errors due to memory overflow or an invalid conversion specifier.</source>
          <target state="translated">这个函数可能会因为内存溢出或无效的转换指定器而产生错误。</target>
        </trans-unit>
        <trans-unit id="76e84460922436ebf110cd9c953279251f6cb0bb" translate="yes" xml:space="preserve">
          <source>This function never returns, but it is an idiom to use it in C functions as &lt;code&gt;return luaL_error(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;.</source>
          <target state="translated">此函数从不返回，但是在C函数中将它用作 &lt;code&gt;return luaL_error(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 是一种习惯用法。</target>
        </trans-unit>
        <trans-unit id="7a6a8e72aaf1ce15e733e732a309d591ddf3339d" translate="yes" xml:space="preserve">
          <source>This function never returns.</source>
          <target state="translated">这个函数永远不会返回。</target>
        </trans-unit>
        <trans-unit id="dbd53ac438e83a0043cb356691fb688496f31d3d" translate="yes" xml:space="preserve">
          <source>This function opens a file, in the mode specified in the string &lt;code&gt;mode&lt;/code&gt;. In case of success, it returns a new file handle.</source>
          <target state="translated">此函数以字符串 &lt;code&gt;mode&lt;/code&gt; 指定的模式打开文件。如果成功，它将返回一个新的文件句柄。</target>
        </trans-unit>
        <trans-unit id="48efe0efa8028e0841dad22b3bd2dd2fd225e975" translate="yes" xml:space="preserve">
          <source>This function performs several tasks, according to the value of the parameter &lt;code&gt;what&lt;/code&gt;. For options that need extra arguments, they are listed after the option.</source>
          <target state="translated">该功能根据参数 &lt;code&gt;what&lt;/code&gt; 的值执行多项任务。对于需要额外参数的选项，它们会在选项之后列出。</target>
        </trans-unit>
        <trans-unit id="1586e455af396a0193bb677436a0ad64943d1618" translate="yes" xml:space="preserve">
          <source>This function performs several tasks, according to the value of the parameter &lt;code&gt;what&lt;/code&gt;:</source>
          <target state="translated">此功能根据参数的值执行多个任务， &lt;code&gt;what&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bc205d90b6658beebf2ab75bca0642c69aa0ce84" translate="yes" xml:space="preserve">
          <source>This function pops &lt;code&gt;n&lt;/code&gt; values from the stack &lt;code&gt;from&lt;/code&gt;, and pushes them onto the stack &lt;code&gt;to&lt;/code&gt;.</source>
          <target state="translated">此函数啪啪 &lt;code&gt;n&lt;/code&gt; 值从堆栈 &lt;code&gt;from&lt;/code&gt; ，并推动它们到堆栈 &lt;code&gt;to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4693da6260e34753896c1e887316822f4ced3e1d" translate="yes" xml:space="preserve">
          <source>This function pops both the key and the value from the stack. As in Lua, this function may trigger a metamethod for the &quot;newindex&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">此函数从堆栈中弹出键和值。像在Lua中一样，此函数可能会触发&amp;ldquo; newindex&amp;rdquo;事件的元方法（请参阅第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="02f15be23e4eaf0571f919cc7f7e66b956f4d346" translate="yes" xml:space="preserve">
          <source>This function pops the key from the stack, pushing the resulting value in its place. As in Lua, this function may trigger a metamethod for the &quot;index&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">此函数从堆栈中弹出键，将结果值推入其位置。与Lua中一样，此函数可能会触发&amp;ldquo;索引&amp;rdquo;事件的元方法（请参见&lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="02c44d9ce8f4d61b45f6e95f4c2615a475b30c3d" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. As in Lua, this function may trigger a metamethod for the &quot;newindex&quot; event (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">此函数从堆栈中弹出值。像在Lua中一样，此函数可能会触发&amp;ldquo; newindex&amp;rdquo;事件的元方法（请参阅第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d650072e7d52525aa4e9529e95f455ff101b8ac7" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not invoke &lt;code&gt;__newindex&lt;/code&gt; metamethod.</source>
          <target state="translated">此函数从堆栈中弹出值。该分配是原始的，即它不调用 &lt;code&gt;__newindex&lt;/code&gt; 元方法。</target>
        </trans-unit>
        <trans-unit id="4dc9661dd76f18a4a7b7bac51f4e0d8886007ef1" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not invoke the &lt;code&gt;__newindex&lt;/code&gt; metamethod.</source>
          <target state="translated">此函数从堆栈中弹出值。该分配是原始的，即它不调用 &lt;code&gt;__newindex&lt;/code&gt; 元方法。</target>
        </trans-unit>
        <trans-unit id="819a7807b617b8fa803512c61d1ba2dc4d437101" translate="yes" xml:space="preserve">
          <source>This function pops the value from the stack. The assignment is raw, that is, it does not use the &lt;code&gt;__newindex&lt;/code&gt; metavalue.</source>
          <target state="translated">此函数从堆栈中弹出值。该分配是原始的，也就是说，它不使用 &lt;code&gt;__newindex&lt;/code&gt; 元值。</target>
        </trans-unit>
        <trans-unit id="6ab41c2efc54cdc4ab08b428ef1fab2ac04e1717" translate="yes" xml:space="preserve">
          <source>This function produces the return values for file-related functions in the standard library (&lt;a href=&quot;#pdf-io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-os.rename&quot;&gt;&lt;code&gt;os.rename&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-file:seek&quot;&gt;&lt;code&gt;file:seek&lt;/code&gt;&lt;/a&gt;, etc.).</source>
          <target state="translated">此函数在标准库（&lt;a href=&quot;#pdf-io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-os.rename&quot;&gt; &lt;code&gt;os.rename&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-file:seek&quot;&gt; &lt;code&gt;file:seek&lt;/code&gt; &lt;/a&gt;等）中生成文件相关函数的返回值。</target>
        </trans-unit>
        <trans-unit id="7ba307bd4b8d4a518ec757e560baba91e283126d" translate="yes" xml:space="preserve">
          <source>This function produces the return values for process-related functions in the standard library (&lt;a href=&quot;#pdf-os.execute&quot;&gt;&lt;code&gt;os.execute&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-io.close&quot;&gt;&lt;code&gt;io.close&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此函数在标准库（&lt;a href=&quot;#pdf-os.execute&quot;&gt; &lt;code&gt;os.execute&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-io.close&quot;&gt; &lt;code&gt;io.close&lt;/code&gt; &lt;/a&gt;）中生成与流程相关的函数的返回值。</target>
        </trans-unit>
        <trans-unit id="b6746e2c8158506c924e3d9368f6e2be32b4e0d2" translate="yes" xml:space="preserve">
          <source>This function returns 0 on error (for instance, an invalid option in &lt;code&gt;what&lt;/code&gt;).</source>
          <target state="translated">错误时此函数返回0（例如， &lt;code&gt;what&lt;/code&gt; 中的选项无效）。</target>
        </trans-unit>
        <trans-unit id="007342df8b0ff02345d55706dd45be96b5514f81" translate="yes" xml:space="preserve">
          <source>This function returns 0 to signal an invalid option in &lt;code&gt;what&lt;/code&gt;; even then the valid options are handled correctly.</source>
          <target state="translated">该函数返回0表示 &lt;code&gt;what&lt;/code&gt; 中的选项无效；即使这样，有效的选项也会被正确处理。</target>
        </trans-unit>
        <trans-unit id="9a4eda5d295976dd3059ff0cebee20501ad1d66f" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;table&lt;/code&gt;.</source>
          <target state="translated">此函数返回 &lt;code&gt;table&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dedc3ddfbc8f8f82058b7b55965c12222160cb90" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;f&lt;/code&gt; of the stack. This function accesses not only explicit local variables, but also parameters and temporary values.</source>
          <target state="translated">该函数返回该函数的名称和值，并在堆栈的级别 &lt;code&gt;f&lt;/code&gt; 处以该函数的索引 &lt;code&gt;local&lt;/code&gt; 。该函数不仅访问显式的局部变量，还访问参数和临时值。</target>
        </trans-unit>
        <trans-unit id="cbb6c1599fe3ff6cd07d37a480afe2c16e49c014" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the local variable with index &lt;code&gt;local&lt;/code&gt; of the function at level &lt;code&gt;f&lt;/code&gt; of the stack. This function accesses not only explicit local variables, but also parameters, temporaries, etc.</source>
          <target state="translated">此函数返回的名称和局部变量的索引值 &lt;code&gt;local&lt;/code&gt; 在水平的函数的 &lt;code&gt;f&lt;/code&gt; 堆。此函数不仅访问显式的局部变量，还访问参数，临时变量等。</target>
        </trans-unit>
        <trans-unit id="6f127ef7aa5ca9413741861659f87c5d2122763a" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;fail&lt;/b&gt; if there is no upvalue with the given index.</source>
          <target state="translated">该函数返回的名称和的upvalue的索引值 &lt;code&gt;up&lt;/code&gt; 功能 &lt;code&gt;f&lt;/code&gt; 。如果给定索引没有升值，该函数将返回&lt;b&gt;失败&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="11dccabc4359a103d70b6a183c7d1b9e295f7d04" translate="yes" xml:space="preserve">
          <source>This function returns the name and the value of the upvalue with index &lt;code&gt;up&lt;/code&gt; of the function &lt;code&gt;f&lt;/code&gt;. The function returns &lt;b&gt;nil&lt;/b&gt; if there is no upvalue with the given index.</source>
          <target state="translated">该函数返回的名称和的upvalue的索引值 &lt;code&gt;up&lt;/code&gt; 功能 &lt;code&gt;f&lt;/code&gt; 。如果给定索引没有升值，则该函数返回&lt;b&gt;nil&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="dbabb13e68eb92f970ce1720014ee57a5f7be9a6" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pdf-LUA_ERRFILE&quot;&gt;&lt;code&gt;LUA_ERRFILE&lt;/code&gt;&lt;/a&gt; for file-related errors.</source>
          <target state="translated">对于与文件相关的错误，此函数返回与&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#pdf-LUA_ERRFILE&quot;&gt; &lt;code&gt;LUA_ERRFILE&lt;/code&gt; &lt;/a&gt;相同的结果。</target>
        </trans-unit>
        <trans-unit id="bebb641f92b0e70a08302c805cbf864b58b36eaf" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;, but it has an extra error code &lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt;&lt;code&gt;LUA_ERRFILE&lt;/code&gt;&lt;/a&gt; for file-related errors (e.g., it cannot open or read the file).</source>
          <target state="translated">此函数返回的结果与&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;相同，但是它具有一个额外的错误代码&lt;a id=&quot;pdf-LUA_ERRFILE&quot;&gt; &lt;code&gt;LUA_ERRFILE&lt;/code&gt; ,&lt;/a&gt;用于处理与文件相关的错误（例如，它无法打开或读取文件）。</target>
        </trans-unit>
        <trans-unit id="6596dd0254b38c840e56683db82740f29df06f33" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数返回与&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;相同的结果。</target>
        </trans-unit>
        <trans-unit id="c0db593e94c92390f3357b35159d95eee2be2609" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the chunk name, used for debug information and error messages. The string &lt;code&gt;mode&lt;/code&gt; works as in function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数返回与&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;相同的结果。 &lt;code&gt;name&lt;/code&gt; 是块名称，用于调试信息和错误消息。字符串 &lt;code&gt;mode&lt;/code&gt; 工作方式与&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;函数相同。</target>
        </trans-unit>
        <trans-unit id="fa91cf9c69a1d6d718bdf5a3abdd1697403c8a5e" translate="yes" xml:space="preserve">
          <source>This function returns the same results as &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the chunk name, used for debug information and error messages. The string &lt;code&gt;mode&lt;/code&gt; works as in the function &lt;a href=&quot;#lua_load&quot;&gt;&lt;code&gt;lua_load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数返回与&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;相同的结果。 &lt;code&gt;name&lt;/code&gt; 是块名称，用于调试信息和错误消息。字符串 &lt;code&gt;mode&lt;/code&gt; 工作方式与&lt;a href=&quot;#lua_load&quot;&gt; &lt;code&gt;lua_load&lt;/code&gt; &lt;/a&gt;函数相同。</target>
        </trans-unit>
        <trans-unit id="cf38c50a3f108c7ed76db3fdffae7549d0d9313a" translate="yes" xml:space="preserve">
          <source>This function returns the two seed components that were effectively used, so that setting them again repeats the sequence.</source>
          <target state="translated">该函数返回有效使用的两个种子组件,这样再次设置它们就会重复序列。</target>
        </trans-unit>
        <trans-unit id="fbd05accb35e1396e632daa50237769ee36b8264" translate="yes" xml:space="preserve">
          <source>This function should not be called for an index that is equal to or below an active to-be-closed index.</source>
          <target state="translated">对于等于或低于活动待关闭索引的索引,不应调用此函数。</target>
        </trans-unit>
        <trans-unit id="5412475350d1ee79055711d0c4350d66e69ffd6d" translate="yes" xml:space="preserve">
          <source>This function uses &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; to get its result, so all conversions and caveats of that function apply here.</source>
          <target state="translated">该函数使用&lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt;来获取其结果，因此该函数的所有转换和警告均适用于此。</target>
        </trans-unit>
        <trans-unit id="f440effb67a02807b5514a47b986fa3c896b974d" translate="yes" xml:space="preserve">
          <source>This function uses the &lt;code&gt;xoshiro256**&lt;/code&gt; algorithm to produce pseudo-random 64-bit integers, which are the results of calls with argument 0. Other results (ranges and floats) are unbiased extracted from these integers.</source>
          <target state="translated">此函数使用 &lt;code&gt;xoshiro256**&lt;/code&gt; 算法生成伪随机的64位整数，这些整数是参数为0的调用的结果。其他结果（范围和浮点数）均从这些整数中无偏抽取。</target>
        </trans-unit>
        <trans-unit id="e2d4ea61bcf0f5292e3f253adc7c53a2139d8438" translate="yes" xml:space="preserve">
          <source>This function works like &lt;a href=&quot;#luaL_checkudata&quot;&gt;&lt;code&gt;luaL_checkudata&lt;/code&gt;&lt;/a&gt;, except that, when the test fails, it returns &lt;code&gt;NULL&lt;/code&gt; instead of raising an error.</source>
          <target state="translated">该函数的工作方式与&lt;a href=&quot;#luaL_checkudata&quot;&gt; &lt;code&gt;luaL_checkudata&lt;/code&gt; 相似&lt;/a&gt;，除了测试失败时，它返回 &lt;code&gt;NULL&lt;/code&gt; 而不是引发错误。</target>
        </trans-unit>
        <trans-unit id="6563d8fb9cdba4b8e66ee93d7bd36fb67b77cff7" translate="yes" xml:space="preserve">
          <source>This is a low-level function. It completely bypasses the package and module system. Unlike &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;, it does not perform any path searching and does not automatically adds extensions. &lt;code&gt;libname&lt;/code&gt; must be the complete file name of the C library, including if necessary a path and an extension. &lt;code&gt;funcname&lt;/code&gt; must be the exact name exported by the C library (which may depend on the C compiler and linker used).</source>
          <target state="translated">这是一个低级功能。它完全绕过了封装和模块系统。与&lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;不同，它不执行任何路径搜索，并且不会自动添加扩展名。 &lt;code&gt;libname&lt;/code&gt; 必须是C库的完整文件名，如有必要，还包括路径和扩展名。 &lt;code&gt;funcname&lt;/code&gt; 必须是C库导出的确切名称（这可能取决于所使用的C编译器和链接器）。</target>
        </trans-unit>
        <trans-unit id="fd11429b923b744979c7d1f098bd69f96f85f6c0" translate="yes" xml:space="preserve">
          <source>This is a useful function for mapping strings to C enums. (The usual convention in Lua libraries is to use strings instead of numbers to select options.)</source>
          <target state="translated">这是一个用于将字符串映射到C语言枚举的有用函数。(Lua库中通常的惯例是使用字符串而不是数字来选择选项。)</target>
        </trans-unit>
        <trans-unit id="753037500c4fa6eda5c0c6251d0c5a1a859a582c" translate="yes" xml:space="preserve">
          <source>This is the only function on string buffers that can (and must) be called with an extra element on the stack, which is the value to be added to the buffer.</source>
          <target state="translated">这是唯一一个在字符串缓冲区上可以(也必须)调用的函数,在堆栈上有一个额外的元素,这就是要添加到缓冲区的值。</target>
        </trans-unit>
        <trans-unit id="fc6eb47b441fdf44e1e8bc0429e02c5da92dec89" translate="yes" xml:space="preserve">
          <source>This is the only option that can raise a memory error.</source>
          <target state="translated">这是唯一会引发内存错误的选项。</target>
        </trans-unit>
        <trans-unit id="90d6873741ea710dec0793ac5a59b32c0c418fac" translate="yes" xml:space="preserve">
          <source>This library comprises the operations to manipulate coroutines, which come inside the table &lt;a id=&quot;pdf-coroutine&quot;&gt;&lt;code&gt;coroutine&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt; for a general description of coroutines.</source>
          <target state="translated">该库包含操作协程的操作，这些操作位于表&lt;a id=&quot;pdf-coroutine&quot;&gt; &lt;code&gt;coroutine&lt;/code&gt; &lt;/a&gt;内部。有关协程的一般说明，请参见&lt;a href=&quot;#2.6&quot;&gt;&amp;sect;2.6&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90c1b961ab3b38c58be563362f0802d45e85c135" translate="yes" xml:space="preserve">
          <source>This library is implemented through table &lt;a id=&quot;pdf-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该库通过表&lt;a id=&quot;pdf-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt;实现。</target>
        </trans-unit>
        <trans-unit id="677be47bd4a9ee27a5f7b1353939b6d0981e1e42" translate="yes" xml:space="preserve">
          <source>This library provides basic mathematical functions. It provides all its functions and constants inside the table &lt;a id=&quot;pdf-math&quot;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt;. Functions with the annotation &quot;&lt;code&gt;integer/float&lt;/code&gt;&quot; give integer results for integer arguments and float results for float (or mixed) arguments. Rounding functions (&lt;a href=&quot;#pdf-math.ceil&quot;&gt;&lt;code&gt;math.ceil&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-math.floor&quot;&gt;&lt;code&gt;math.floor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-math.modf&quot;&gt;&lt;code&gt;math.modf&lt;/code&gt;&lt;/a&gt;) return an integer when the result fits in the range of an integer, or a float otherwise.</source>
          <target state="translated">该库提供基本的数学功能。它在表格&lt;a id=&quot;pdf-math&quot;&gt; &lt;code&gt;math&lt;/code&gt; 中&lt;/a&gt;提供了所有函数和常量。带有注解&amp;ldquo; &lt;code&gt;integer/float&lt;/code&gt; &amp;rdquo;的函数为整数参数给出整数结果，为浮点（或混合）参数给出浮点结果。当结果适合整数范围时，舍入函数（&lt;a href=&quot;#pdf-math.ceil&quot;&gt; &lt;code&gt;math.ceil&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-math.floor&quot;&gt; &lt;code&gt;math.floor&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-math.modf&quot;&gt; &lt;code&gt;math.modf&lt;/code&gt; &lt;/a&gt;）返回一个整数，否则返回float。</target>
        </trans-unit>
        <trans-unit id="fda34771150302c5e6235e047b8a7d6f844dd96f" translate="yes" xml:space="preserve">
          <source>This library provides basic mathematical functions. It provides all its functions and constants inside the table &lt;a id=&quot;pdf-math&quot;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt;. Functions with the annotation &quot;&lt;code&gt;integer/float&lt;/code&gt;&quot; give integer results for integer arguments and float results for non-integer arguments. The rounding functions &lt;a href=&quot;#pdf-math.ceil&quot;&gt;&lt;code&gt;math.ceil&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-math.floor&quot;&gt;&lt;code&gt;math.floor&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#pdf-math.modf&quot;&gt;&lt;code&gt;math.modf&lt;/code&gt;&lt;/a&gt; return an integer when the result fits in the range of an integer, or a float otherwise.</source>
          <target state="translated">该库提供基本的数学功能。它在表&lt;a id=&quot;pdf-math&quot;&gt; &lt;code&gt;math&lt;/code&gt; 中&lt;/a&gt;提供了所有函数和常量。带有注解&amp;ldquo; &lt;code&gt;integer/float&lt;/code&gt; &amp;rdquo;的函数为整数参数给出整数结果，为非整数参数给出浮点结果。当结果适合整数范围时，舍入函数&lt;a href=&quot;#pdf-math.ceil&quot;&gt; &lt;code&gt;math.ceil&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-math.floor&quot;&gt; &lt;code&gt;math.floor&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-math.modf&quot;&gt; &lt;code&gt;math.modf&lt;/code&gt; &lt;/a&gt;返回整数，否则返回float。</target>
        </trans-unit>
        <trans-unit id="eff61c8c99df8abb4cc617e0a788ed6e1d7a8ab8" translate="yes" xml:space="preserve">
          <source>This library provides basic support for UTF-8 encoding. It provides all its functions inside the table &lt;a id=&quot;pdf-utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt;. This library does not provide any support for Unicode other than the handling of the encoding. Any operation that needs the meaning of a character, such as character classification, is outside its scope.</source>
          <target state="translated">该库提供对UTF-8编码的基本支持。它在表&lt;a id=&quot;pdf-utf8&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt;内提供了所有功能。除了编码处理之外，该库不提供对Unicode的任何支持。任何需要字符含义的操作（例如字符分类）均超出其范围。</target>
        </trans-unit>
        <trans-unit id="f54156236b7b08469a0920a829130d4325d9534b" translate="yes" xml:space="preserve">
          <source>This library provides generic functions for string manipulation, such as finding and extracting substrings, and pattern matching. When indexing a string in Lua, the first character is at position 1 (not at 0, as in C). Indices are allowed to be negative and are interpreted as indexing backwards, from the end of the string. Thus, the last character is at position -1, and so on.</source>
          <target state="translated">这个库提供了字符串操作的通用函数,如查找和提取子串,以及模式匹配。当在Lua中对一个字符串进行索引时,第一个字符位于1的位置(而不是像C语言中的0)。索引允许为负数,并被解释为从字符串的末端开始向后索引。因此,最后一个字符位于-1位置,以此类推。</target>
        </trans-unit>
        <trans-unit id="eaff80ded470719d876c589d5513c23d7a2d941b" translate="yes" xml:space="preserve">
          <source>This library provides generic functions for table manipulation. It provides all its functions inside the table &lt;a id=&quot;pdf-table&quot;&gt;&lt;code&gt;table&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该库提供用于表操作的通用功能。它在表&lt;a id=&quot;pdf-table&quot;&gt; &lt;code&gt;table&lt;/code&gt; 中&lt;/a&gt;提供了所有功能。</target>
        </trans-unit>
        <trans-unit id="5f4d4c7789cbf6727187aa434640210ed81d6661" translate="yes" xml:space="preserve">
          <source>This library provides the functionality of the debug interface (&lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;) to Lua programs. You should exert care when using this library. Several of its functions violate basic assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside; that userdata metatables cannot be changed by Lua code; that Lua programs do not crash) and therefore can compromise otherwise secure code. Moreover, some functions in this library may be slow.</source>
          <target state="translated">该库为Lua程序提供了调试接口（第&lt;a href=&quot;#4.7&quot;&gt;4.7节&lt;/a&gt;）的功能。使用此库时，应格外小心。它的几个函数违反了有关Lua代码的基本假设（例如，不能从外部访问函数本地变量； Lua代码不能更改用户数据元表； Lua程序不会崩溃），因此可能会破坏安全代码。此外，该库中的某些功能可能很慢。</target>
        </trans-unit>
        <trans-unit id="8d51d524a82a8aae4d9f2e0292c35c2b4f100e81" translate="yes" xml:space="preserve">
          <source>This library provides the functionality of the debug interface (&lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;) to Lua programs. You should exert care when using this library. Several of its functions violate basic assumptions about Lua code (e.g., that variables local to a function cannot be accessed from outside; that userdata metatables cannot be changed by Lua code; that Lua programs do not crash) and therefore can compromise otherwise secure code. Moreover, some functions in this library may be slow.</source>
          <target state="translated">该库为Lua程序提供了调试接口（第&lt;a href=&quot;#4.9&quot;&gt;4.9节&lt;/a&gt;）的功能。使用此库时，应格外小心。它的一些功能违反了有关Lua代码的基本假设（例如，无法从外部访问函数本地变量； Lua代码无法更改userdata元表； Lua程序不会崩溃），因此可能会破坏安全代码。此外，该库中的某些功能可能很慢。</target>
        </trans-unit>
        <trans-unit id="aa99211cd2ffc6b2b1567c3fa58975b02bdbb57d" translate="yes" xml:space="preserve">
          <source>This macro is defined as follows:</source>
          <target state="translated">该宏定义如下:</target>
        </trans-unit>
        <trans-unit id="c062139aee69e54bd4a269563eddaa0f4e8798af" translate="yes" xml:space="preserve">
          <source>This macro is equivalent to &lt;a href=&quot;#lua_pushstring&quot;&gt;&lt;code&gt;lua_pushstring&lt;/code&gt;&lt;/a&gt;, but should be used only when &lt;code&gt;s&lt;/code&gt; is a literal string.</source>
          <target state="translated">该宏等效于&lt;a href=&quot;#lua_pushstring&quot;&gt; &lt;code&gt;lua_pushstring&lt;/code&gt; &lt;/a&gt;，但仅当 &lt;code&gt;s&lt;/code&gt; 是文字字符串时才应使用。</target>
        </trans-unit>
        <trans-unit id="8a5828258eda09312844222f71451e9b5df31690" translate="yes" xml:space="preserve">
          <source>This macro is equivalent to &lt;a href=&quot;#lua_pushstring&quot;&gt;&lt;code&gt;lua_pushstring&lt;/code&gt;&lt;/a&gt;, but should be used only when &lt;code&gt;s&lt;/code&gt; is a literal string. (Lua may optimize this case.)</source>
          <target state="translated">该宏等效于&lt;a href=&quot;#lua_pushstring&quot;&gt; &lt;code&gt;lua_pushstring&lt;/code&gt; &lt;/a&gt;，但仅当 &lt;code&gt;s&lt;/code&gt; 是文字字符串时才应使用。（Lua可能会优化这种情况。）</target>
        </trans-unit>
        <trans-unit id="73fca2eb54a811850b7ad4e17b0d35bfe7cf0032" translate="yes" xml:space="preserve">
          <source>This macro may evaluate its arguments more than once.</source>
          <target state="translated">这个宏可以评价它的参数一次以上。</target>
        </trans-unit>
        <trans-unit id="05f26abbbd5d35b2d22d1c051a71569b0f900ee1" translate="yes" xml:space="preserve">
          <source>This section describes the C API for Lua, that is, the set of C functions available to the host program to communicate with Lua. All API functions and related types and constants are declared in the header file &lt;a id=&quot;pdf-lua.h&quot;&gt;&lt;code&gt;lua.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">本节描述了用于Lua的C API，即，主机程序可用于与Lua通信的C函数集。所有API函数以及相关的类型和常量都在头文件&lt;a id=&quot;pdf-lua.h&quot;&gt; &lt;code&gt;lua.h&lt;/code&gt; &lt;/a&gt;中声明。</target>
        </trans-unit>
        <trans-unit id="f58c3cfe49431540420c4f54cf654f80f9192fd6" translate="yes" xml:space="preserve">
          <source>This section describes the basic concepts of the language.</source>
          <target state="translated">本节介绍语言的基本概念。</target>
        </trans-unit>
        <trans-unit id="8fa659ee1a4beeab1fc33f883314eeb2cadc844d" translate="yes" xml:space="preserve">
          <source>This section describes the lexis, the syntax, and the semantics of Lua. In other words, this section describes which tokens are valid, how they can be combined, and what their combinations mean.</source>
          <target state="translated">本节描述了Lua的词法、语法和语义。换句话说,本节描述了哪些标记是有效的,它们如何组合,以及它们的组合意味着什么。</target>
        </trans-unit>
        <trans-unit id="db29de528ad1c90a96a681f72e450fef6b674bc0" translate="yes" xml:space="preserve">
          <source>This specifier does not support modifiers (flags, width, length).</source>
          <target state="translated">该指定器不支持修饰符(标志、宽度、长度)。</target>
        </trans-unit>
        <trans-unit id="278be3240fe4a7ea3d08f92baa83623d2ac8fe27" translate="yes" xml:space="preserve">
          <source>This userdata must start with the structure &lt;code&gt;luaL_Stream&lt;/code&gt;; it can contain other data after this initial structure. Field &lt;code&gt;f&lt;/code&gt; points to the corresponding C stream (or it can be &lt;code&gt;NULL&lt;/code&gt; to indicate an incompletely created handle). Field &lt;code&gt;closef&lt;/code&gt; points to a Lua function that will be called to close the stream when the handle is closed or collected; this function receives the file handle as its sole argument and must return either &lt;b&gt;true&lt;/b&gt; (in case of success) or &lt;b&gt;nil&lt;/b&gt; plus an error message (in case of error). Once Lua calls this field, it changes the field value to &lt;code&gt;NULL&lt;/code&gt; to signal that the handle is closed.</source>
          <target state="translated">该用户数据必须以 &lt;code&gt;luaL_Stream&lt;/code&gt; 结构开头；在此初始结构之后，它可以包含其他数据。字段 &lt;code&gt;f&lt;/code&gt; 指向相应的C流（或者可以为 &lt;code&gt;NULL&lt;/code&gt; 表示未完全创建的句柄）。字段 &lt;code&gt;closef&lt;/code&gt; 指向一个Lua函数，当关闭或收集手柄时，该函​​数将被调用以关闭流。此函数将文件句柄作为其唯一参数，并且必须返回&lt;b&gt;true&lt;/b&gt;（如果成功）或&lt;b&gt;nil&lt;/b&gt;加错误消息（如果错误）。一旦Lua调用了该字段，它会将字段值更改为 &lt;code&gt;NULL&lt;/code&gt; ,以表示该句柄已关闭。</target>
        </trans-unit>
        <trans-unit id="e34f3769ad0807b3d6dc807de51658a5229c2a2c" translate="yes" xml:space="preserve">
          <source>This userdata must start with the structure &lt;code&gt;luaL_Stream&lt;/code&gt;; it can contain other data after this initial structure. The field &lt;code&gt;f&lt;/code&gt; points to the corresponding C stream (or it can be &lt;code&gt;NULL&lt;/code&gt; to indicate an incompletely created handle). The field &lt;code&gt;closef&lt;/code&gt; points to a Lua function that will be called to close the stream when the handle is closed or collected; this function receives the file handle as its sole argument and must return either a true value, in case of success, or a false value plus an error message, in case of error. Once Lua calls this field, it changes the field value to &lt;code&gt;NULL&lt;/code&gt; to signal that the handle is closed.</source>
          <target state="translated">该用户数据必须以 &lt;code&gt;luaL_Stream&lt;/code&gt; 结构开头；在此初始结构之后，它可以包含其他数据。字段 &lt;code&gt;f&lt;/code&gt; 指向相应的C流（或者它可以为 &lt;code&gt;NULL&lt;/code&gt; 以指示未完全创建的句柄）。字段 &lt;code&gt;closef&lt;/code&gt; 指向一个Lua函数，当关闭或收集手柄时，该函​​数将被调用以关闭流。此函数将文件句柄作为其唯一参数，并且在成功的情况下必须返回true值，在错误的情况下必须返回false值以及错误消息。一旦Lua调用了该字段，它会将字段值更改为 &lt;code&gt;NULL&lt;/code&gt; ,以表示该句柄已关闭。</target>
        </trans-unit>
        <trans-unit id="a38b5444cc9ef2204e61edb4d9f6307dc07f0ac4" translate="yes" xml:space="preserve">
          <source>This variable is only a reference to the real table; assignments to this variable do not change the table used by &lt;a href=&quot;#pdf-require&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">该变量仅是对实际表的引用；对该变量的分配不会更改&lt;a href=&quot;#pdf-require&quot;&gt; &lt;code&gt;require&lt;/code&gt; &lt;/a&gt;使用的表。</target>
        </trans-unit>
        <trans-unit id="53329857ea4576424bb761eab97ba4d7a438b162" translate="yes" xml:space="preserve">
          <source>Threads are subject to garbage collection, like any Lua object.</source>
          <target state="translated">线程和任何Lua对象一样,都要进行垃圾收集。</target>
        </trans-unit>
        <trans-unit id="fd5b59d880561eb52ba3ed52be79a6fc246200cf" translate="yes" xml:space="preserve">
          <source>To allow possible side-effects, function calls can be executed as statements:</source>
          <target state="translated">为了允许可能的副作用,函数调用可以作为语句执行。</target>
        </trans-unit>
        <trans-unit id="e5d4f137bc9e715e9e20a727cc9650777e835e92" translate="yes" xml:space="preserve">
          <source>To allow the use of Lua as a script interpreter in Unix systems, Lua skips the first line of a file chunk if it starts with &lt;code&gt;#&lt;/code&gt;. Therefore, Lua scripts can be made into executable programs by using &lt;code&gt;chmod +x&lt;/code&gt; and the &lt;code&gt;#!&lt;/code&gt; form, as in</source>
          <target state="translated">为了允许将Lua用作Unix系统中的脚本解释器，如果Lua以 &lt;code&gt;#&lt;/code&gt; 开头，则跳过文件块的第一行。因此，可以使用 &lt;code&gt;chmod +x&lt;/code&gt; 和 &lt;code&gt;#!&lt;/code&gt; 将Lua脚本制作为可执行程序。形式，如</target>
        </trans-unit>
        <trans-unit id="888be864c9c88102be3a61e9065fc124fb157083" translate="yes" xml:space="preserve">
          <source>To allow the use of Lua as a script interpreter in Unix systems, the standalone interpreter skips the first line of a chunk if it starts with &lt;code&gt;#&lt;/code&gt;. Therefore, Lua scripts can be made into executable programs by using &lt;code&gt;chmod +x&lt;/code&gt; and the &lt;code&gt;#!&lt;/code&gt; form, as in</source>
          <target state="translated">为了允许将Lua用作Unix系统中的脚本解释器，如果独立解释器以 &lt;code&gt;#&lt;/code&gt; 开头，则跳过该块的第一行。因此，可以使用 &lt;code&gt;chmod +x&lt;/code&gt; 和 &lt;code&gt;#!&lt;/code&gt; 将Lua脚本制作为可执行程序。形式，如</target>
        </trans-unit>
        <trans-unit id="1e9c9099d2aea779a3a3f78d58160c9b66011127" translate="yes" xml:space="preserve">
          <source>To avoid this kind of problem, Lua raises an error whenever it tries to yield across an API call, except for three functions: &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt;. All those functions receive a &lt;em&gt;continuation function&lt;/em&gt; (as a parameter named &lt;code&gt;k&lt;/code&gt;) to continue execution after a yield.</source>
          <target state="translated">为了避免此类问题，Lua每当尝试通过API调用&lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt;时都会引发错误，但以下三个函数除外：lua_yieldk，&lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt;。所有这些函数都接收一个&lt;em&gt;继续函数&lt;/em&gt;（作为名为 &lt;code&gt;k&lt;/code&gt; 的参数）以在yield之后继续执行。</target>
        </trans-unit>
        <trans-unit id="5bb0e844a26e80a97eddacec1b0d3209d0d96606" translate="yes" xml:space="preserve">
          <source>To call a function you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the function are pushed in direct order; that is, the first argument is pushed first. Finally you call &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;nargs&lt;/code&gt; is the number of arguments that you pushed onto the stack. All arguments and the function value are popped from the stack when the function is called. The function results are pushed onto the stack when the function returns. The number of results is adjusted to &lt;code&gt;nresults&lt;/code&gt;, unless &lt;code&gt;nresults&lt;/code&gt; is &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt;&lt;code&gt;LUA_MULTRET&lt;/code&gt;&lt;/a&gt;. In this case, all results from the function are pushed; Lua takes care that the returned values fit into the stack space, but it does not ensure any extra space in the stack. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.</source>
          <target state="translated">要调用一个函数，您必须使用以下协议：首先，要调用的函数被压入堆栈。然后，该函数的参数按直接顺序推入；也就是说，第一个参数先被推入。最后，您调用&lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt;； &lt;code&gt;nargs&lt;/code&gt; 是您压入堆栈的参数数量。调用函数时，将从堆栈中弹出所有参数和函数值。函数返回时，函数结果将被压入堆栈。结果数调整为 &lt;code&gt;nresults&lt;/code&gt; ，除非 &lt;code&gt;nresults&lt;/code&gt; 为&lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt; &lt;code&gt;LUA_MULTRET&lt;/code&gt; &lt;/a&gt;。在这种情况下，该函数的所有结果都会被推送；Lua会确保返回的值适合堆栈空间，但不能确保堆栈中有任何额外的空间。函数结果按直接顺序被推入堆栈（第一个结果首先被推入），因此在调用之后，最后一个结果在堆栈顶部。</target>
        </trans-unit>
        <trans-unit id="6f927865cf7be60df11e5707f3fba807a308ae47" translate="yes" xml:space="preserve">
          <source>To catch errors in Lua, you can do a &lt;em&gt;protected call&lt;/em&gt;, using &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt;). The function &lt;a href=&quot;#pdf-pcall&quot;&gt;&lt;code&gt;pcall&lt;/code&gt;&lt;/a&gt; calls a given function in &lt;em&gt;protected mode&lt;/em&gt;. Any error while running the function stops its execution, and control returns immediately to &lt;code&gt;pcall&lt;/code&gt;, which returns a status code.</source>
          <target state="translated">要捕获Lua中的错误，可以使用&lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt;（或&lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt;）进行&lt;em&gt;受保护的调用&lt;/em&gt;。函数&lt;a href=&quot;#pdf-pcall&quot;&gt; &lt;code&gt;pcall&lt;/code&gt; &lt;/a&gt;在&lt;em&gt;保护模式下&lt;/em&gt;调用给定的函数。运行该函数时发生的任何错误都将停止执行，并且控制权立即返回到 &lt;code&gt;pcall&lt;/code&gt; ，后者将返回状态码。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0ea99929cea20ed156e3c1b46c0e6d4b1e4d677a" translate="yes" xml:space="preserve">
          <source>To change the metatable of other types from Lua code, you must use the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).</source>
          <target state="translated">要从Lua代码更改其他类型的元表，必须使用调试库（第&lt;a href=&quot;#6.10&quot;&gt;6.10节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6417128dbbbaad3ecee352f08e4fffebce841718" translate="yes" xml:space="preserve">
          <source>To do a call you must use the following protocol: first, the function to be called is pushed onto the stack; then, the arguments to the call are pushed in direct order; that is, the first argument is pushed first. Finally you call &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;; &lt;code&gt;nargs&lt;/code&gt; is the number of arguments that you pushed onto the stack. When the function returns, all arguments and the function value are popped and the call results are pushed onto the stack. The number of results is adjusted to &lt;code&gt;nresults&lt;/code&gt;, unless &lt;code&gt;nresults&lt;/code&gt; is &lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt;&lt;code&gt;LUA_MULTRET&lt;/code&gt;&lt;/a&gt;. In this case, all results from the function are pushed; Lua takes care that the returned values fit into the stack space, but it does not ensure any extra space in the stack. The function results are pushed onto the stack in direct order (the first result is pushed first), so that after the call the last result is on the top of the stack.</source>
          <target state="translated">要进行调用，必须使用以下协议：首先，要调用的函数被压入堆栈；然后，调用的参数按直接顺序推入；也就是说，第一个参数先被推入。最后，您调用&lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt;； &lt;code&gt;nargs&lt;/code&gt; 是您压入堆栈的参数数量。函数返回时，将弹出所有参数和函数值，并将调用结果压入堆栈。结果数调整为 &lt;code&gt;nresults&lt;/code&gt; ，除非 &lt;code&gt;nresults&lt;/code&gt; 为&lt;a id=&quot;pdf-LUA_MULTRET&quot;&gt; &lt;code&gt;LUA_MULTRET&lt;/code&gt; &lt;/a&gt;。在这种情况下，该函数的所有结果都会被推送；Lua会确保返回的值适合堆栈空间，但它不能确保堆栈中有任何额外的空间。函数结果按直接顺序被推入堆栈（第一个结果首先被推入），因此在调用之后，最后一个结果在堆栈顶部。</target>
        </trans-unit>
        <trans-unit id="ef1fdaa7f1c7b918f16975f1ca7b0d514c6f0f3a" translate="yes" xml:space="preserve">
          <source>To ensure a required level of randomness to the initial state (or contrarily, to have a deterministic sequence, for instance when debugging a program), you should call &lt;a href=&quot;#pdf-math.randomseed&quot;&gt;&lt;code&gt;math.randomseed&lt;/code&gt;&lt;/a&gt; with explicit arguments.</source>
          <target state="translated">为确保所需的初始状态随机性水平（或者相反，例如在调试程序时具有确定性的顺序），应使用显式参数调用&lt;a href=&quot;#pdf-math.randomseed&quot;&gt; &lt;code&gt;math.randomseed&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e1e6304705c324bc934187373072b763f1a1066" translate="yes" xml:space="preserve">
          <source>To find a loader, &lt;code&gt;require&lt;/code&gt; is guided by the &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt; sequence. By changing this sequence, we can change how &lt;code&gt;require&lt;/code&gt; looks for a module. The following explanation is based on the default configuration for &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要查找加载程序， &lt;code&gt;require&lt;/code&gt; 由&lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt;序列指导。通过更改此顺序，我们可以更改 &lt;code&gt;require&lt;/code&gt; 查找模块的方式。以下说明基于&lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt;的默认配置。</target>
        </trans-unit>
        <trans-unit id="5e712bd9f9ff5cb85660101fcd07ff33cf506329" translate="yes" xml:space="preserve">
          <source>To find a loader, &lt;code&gt;require&lt;/code&gt; is guided by the table &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;. Each item in this table is a search function, that searches for the module in a particular way. By changing this table, we can change how &lt;code&gt;require&lt;/code&gt; looks for a module. The following explanation is based on the default configuration for &lt;a href=&quot;#pdf-package.searchers&quot;&gt;&lt;code&gt;package.searchers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要查找装载程序， &lt;code&gt;require&lt;/code&gt; 是由表&lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt;引导的。该表中的每个项目都是搜索功能，它以特定方式搜索模块。通过更改此表，我们可以更改 &lt;code&gt;require&lt;/code&gt; 查找模块的方式。以下说明基于&lt;a href=&quot;#pdf-package.searchers&quot;&gt; &lt;code&gt;package.searchers&lt;/code&gt; &lt;/a&gt;的默认配置。</target>
        </trans-unit>
        <trans-unit id="d328425732a8a8cf219c051476f3d38be1088896" translate="yes" xml:space="preserve">
          <source>To get information about a function invocation, the parameter &lt;code&gt;ar&lt;/code&gt; must be a valid activation record that was filled by a previous call to &lt;a href=&quot;#lua_getstack&quot;&gt;&lt;code&gt;lua_getstack&lt;/code&gt;&lt;/a&gt; or given as argument to a hook (see &lt;a href=&quot;#lua_Hook&quot;&gt;&lt;code&gt;lua_Hook&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">要获取有关函数调用的信息，参数 &lt;code&gt;ar&lt;/code&gt; 必须是有效的激活记录，该记录由先前对&lt;a href=&quot;#lua_getstack&quot;&gt; &lt;code&gt;lua_getstack&lt;/code&gt; 的&lt;/a&gt;调用填充或作为钩子的参数提供（请参见&lt;a href=&quot;#lua_Hook&quot;&gt; &lt;code&gt;lua_Hook&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="259bf849c0380d37169ac9c2c5ed68eef86ed762" translate="yes" xml:space="preserve">
          <source>To get information about a function you push it onto the stack and start the &lt;code&gt;what&lt;/code&gt; string with the character '&lt;code&gt;&amp;gt;&lt;/code&gt;'. (In that case, &lt;code&gt;lua_getinfo&lt;/code&gt; pops the function from the top of the stack.) For instance, to know in which line a function &lt;code&gt;f&lt;/code&gt; was defined, you can write the following code:</source>
          <target state="translated">要获得有关功能的信息你推入堆栈，开始 &lt;code&gt;what&lt;/code&gt; 字符&amp;ldquo;字符串 &lt;code&gt;&amp;gt;&lt;/code&gt; &amp;rdquo;。（在这种情况下， &lt;code&gt;lua_getinfo&lt;/code&gt; 从堆栈的顶部弹出该函数。）例如，要知道函数 &lt;code&gt;f&lt;/code&gt; 在哪一行定义，可以编写以下代码：</target>
        </trans-unit>
        <trans-unit id="bbdfec85d3ce9d473ff7e0ea2279d69ff617c711" translate="yes" xml:space="preserve">
          <source>To get information about a function, you push it onto the stack and start the &lt;code&gt;what&lt;/code&gt; string with the character '&lt;code&gt;&amp;gt;&lt;/code&gt;'. (In that case, &lt;code&gt;lua_getinfo&lt;/code&gt; pops the function from the top of the stack.) For instance, to know in which line a function &lt;code&gt;f&lt;/code&gt; was defined, you can write the following code:</source>
          <target state="translated">要获得有关功能的信息，你推入堆栈，开始 &lt;code&gt;what&lt;/code&gt; 字符&amp;ldquo;字符串 &lt;code&gt;&amp;gt;&lt;/code&gt; &amp;rdquo;。（在这种情况下， &lt;code&gt;lua_getinfo&lt;/code&gt; 从堆栈顶部弹出该函数。）例如，要知道函数 &lt;code&gt;f&lt;/code&gt; 在哪一行定义，可以编写以下代码：</target>
        </trans-unit>
        <trans-unit id="1c87754131cf9f2c3e4c8c44baabf65a58d386a2" translate="yes" xml:space="preserve">
          <source>To have access to these libraries, the C host program should call the &lt;a href=&quot;#luaL_openlibs&quot;&gt;&lt;code&gt;luaL_openlibs&lt;/code&gt;&lt;/a&gt; function, which opens all standard libraries. Alternatively, the host program can open them individually by using &lt;a href=&quot;#luaL_requiref&quot;&gt;&lt;code&gt;luaL_requiref&lt;/code&gt;&lt;/a&gt; to call &lt;a id=&quot;pdf-luaopen_base&quot;&gt;&lt;code&gt;luaopen_base&lt;/code&gt;&lt;/a&gt; (for the basic library), &lt;a id=&quot;pdf-luaopen_package&quot;&gt;&lt;code&gt;luaopen_package&lt;/code&gt;&lt;/a&gt; (for the package library), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt;&lt;code&gt;luaopen_coroutine&lt;/code&gt;&lt;/a&gt; (for the coroutine library), &lt;a id=&quot;pdf-luaopen_string&quot;&gt;&lt;code&gt;luaopen_string&lt;/code&gt;&lt;/a&gt; (for the string library), &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt;&lt;code&gt;luaopen_utf8&lt;/code&gt;&lt;/a&gt; (for the UTF-8 library), &lt;a id=&quot;pdf-luaopen_table&quot;&gt;&lt;code&gt;luaopen_table&lt;/code&gt;&lt;/a&gt; (for the table library), &lt;a id=&quot;pdf-luaopen_math&quot;&gt;&lt;code&gt;luaopen_math&lt;/code&gt;&lt;/a&gt; (for the mathematical library), &lt;a id=&quot;pdf-luaopen_io&quot;&gt;&lt;code&gt;luaopen_io&lt;/code&gt;&lt;/a&gt; (for the I/O library), &lt;a id=&quot;pdf-luaopen_os&quot;&gt;&lt;code&gt;luaopen_os&lt;/code&gt;&lt;/a&gt; (for the operating system library), and &lt;a id=&quot;pdf-luaopen_debug&quot;&gt;&lt;code&gt;luaopen_debug&lt;/code&gt;&lt;/a&gt; (for the debug library). These functions are declared in &lt;a id=&quot;pdf-lualib.h&quot;&gt;&lt;code&gt;lualib.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要访问这些库，C主机程序应调用&lt;a href=&quot;#luaL_openlibs&quot;&gt; &lt;code&gt;luaL_openlibs&lt;/code&gt; &lt;/a&gt;函数，该函数将打开所有标准库。另外，主机程序可以使用&lt;a href=&quot;#luaL_requiref&quot;&gt; &lt;code&gt;luaL_requiref&lt;/code&gt; &lt;/a&gt;分别调用&lt;a id=&quot;pdf-luaopen_base&quot;&gt; &lt;code&gt;luaopen_base&lt;/code&gt; &lt;/a&gt;（对于基本库），&lt;a id=&quot;pdf-luaopen_package&quot;&gt; &lt;code&gt;luaopen_package&lt;/code&gt; &lt;/a&gt;（对于包库），&lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt; &lt;code&gt;luaopen_coroutine&lt;/code&gt; &lt;/a&gt;（对于coroutine库），&lt;a id=&quot;pdf-luaopen_string&quot;&gt; &lt;code&gt;luaopen_string&lt;/code&gt; &lt;/a&gt;（对于字符串库），&lt;a id=&quot;pdf-luaopen_utf8&quot;&gt; &lt;code&gt;luaopen_utf8&lt;/code&gt; &lt;/a&gt;（对于UTF-8库），&lt;a id=&quot;pdf-luaopen_table&quot;&gt; &lt;code&gt;luaopen_table&lt;/code&gt; &lt;/a&gt;（用于表库），&lt;a id=&quot;pdf-luaopen_math&quot;&gt; &lt;code&gt;luaopen_math&lt;/code&gt; &lt;/a&gt;（用于数学库），&lt;a id=&quot;pdf-luaopen_io&quot;&gt; &lt;code&gt;luaopen_io&lt;/code&gt; &lt;/a&gt;（用于I / O库），&lt;a id=&quot;pdf-luaopen_os&quot;&gt; &lt;code&gt;luaopen_os&lt;/code&gt; &lt;/a&gt;（对于操作系统库）和&lt;a id=&quot;pdf-luaopen_debug&quot;&gt; &lt;code&gt;luaopen_debug&lt;/code&gt; &lt;/a&gt;（对于调试库）。这些函数在&lt;a id=&quot;pdf-lualib.h&quot;&gt; &lt;code&gt;lualib.h&lt;/code&gt; &lt;/a&gt;中声明。</target>
        </trans-unit>
        <trans-unit id="4f65df24a4302e99c5805820ed2c9da17dcc1b4e" translate="yes" xml:space="preserve">
          <source>To have access to these libraries, the C host program should call the &lt;a href=&quot;#luaL_openlibs&quot;&gt;&lt;code&gt;luaL_openlibs&lt;/code&gt;&lt;/a&gt; function, which opens all standard libraries. Alternatively, the host program can open them individually by using &lt;a href=&quot;#luaL_requiref&quot;&gt;&lt;code&gt;luaL_requiref&lt;/code&gt;&lt;/a&gt; to call &lt;a id=&quot;pdf-luaopen_base&quot;&gt;&lt;code&gt;luaopen_base&lt;/code&gt;&lt;/a&gt; (for the basic library), &lt;a id=&quot;pdf-luaopen_package&quot;&gt;&lt;code&gt;luaopen_package&lt;/code&gt;&lt;/a&gt; (for the package library), &lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt;&lt;code&gt;luaopen_coroutine&lt;/code&gt;&lt;/a&gt; (for the coroutine library), &lt;a id=&quot;pdf-luaopen_string&quot;&gt;&lt;code&gt;luaopen_string&lt;/code&gt;&lt;/a&gt; (for the string library), &lt;a id=&quot;pdf-luaopen_utf8&quot;&gt;&lt;code&gt;luaopen_utf8&lt;/code&gt;&lt;/a&gt; (for the UTF8 library), &lt;a id=&quot;pdf-luaopen_table&quot;&gt;&lt;code&gt;luaopen_table&lt;/code&gt;&lt;/a&gt; (for the table library), &lt;a id=&quot;pdf-luaopen_math&quot;&gt;&lt;code&gt;luaopen_math&lt;/code&gt;&lt;/a&gt; (for the mathematical library), &lt;a id=&quot;pdf-luaopen_io&quot;&gt;&lt;code&gt;luaopen_io&lt;/code&gt;&lt;/a&gt; (for the I/O library), &lt;a id=&quot;pdf-luaopen_os&quot;&gt;&lt;code&gt;luaopen_os&lt;/code&gt;&lt;/a&gt; (for the operating system library), and &lt;a id=&quot;pdf-luaopen_debug&quot;&gt;&lt;code&gt;luaopen_debug&lt;/code&gt;&lt;/a&gt; (for the debug library). These functions are declared in &lt;a id=&quot;pdf-lualib.h&quot;&gt;&lt;code&gt;lualib.h&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要访问这些库，C主机程序应调用&lt;a href=&quot;#luaL_openlibs&quot;&gt; &lt;code&gt;luaL_openlibs&lt;/code&gt; &lt;/a&gt;函数，该函数将打开所有标准库。或者，主机程序可以使用&lt;a href=&quot;#luaL_requiref&quot;&gt; &lt;code&gt;luaL_requiref&lt;/code&gt; &lt;/a&gt;分别调用&lt;a id=&quot;pdf-luaopen_base&quot;&gt; &lt;code&gt;luaopen_base&lt;/code&gt; &lt;/a&gt;（对于基本库），&lt;a id=&quot;pdf-luaopen_package&quot;&gt; &lt;code&gt;luaopen_package&lt;/code&gt; &lt;/a&gt;（对于包库），&lt;a id=&quot;pdf-luaopen_coroutine&quot;&gt; &lt;code&gt;luaopen_coroutine&lt;/code&gt; &lt;/a&gt;（对于coroutine库），&lt;a id=&quot;pdf-luaopen_string&quot;&gt; &lt;code&gt;luaopen_string&lt;/code&gt; &lt;/a&gt;（对于字符串库），&lt;a id=&quot;pdf-luaopen_utf8&quot;&gt; &lt;code&gt;luaopen_utf8&lt;/code&gt; &lt;/a&gt;（对于UTF8库），&lt;a id=&quot;pdf-luaopen_table&quot;&gt; &lt;code&gt;luaopen_table&lt;/code&gt; &lt;/a&gt;（用于表库），&lt;a id=&quot;pdf-luaopen_math&quot;&gt; &lt;code&gt;luaopen_math&lt;/code&gt; &lt;/a&gt;（用于数学库），&lt;a id=&quot;pdf-luaopen_io&quot;&gt; &lt;code&gt;luaopen_io&lt;/code&gt; &lt;/a&gt;（用于I / O库），&lt;a id=&quot;pdf-luaopen_os&quot;&gt; &lt;code&gt;luaopen_os&lt;/code&gt; &lt;/a&gt;（对于操作系统库）和&lt;a id=&quot;pdf-luaopen_debug&quot;&gt; &lt;code&gt;luaopen_debug&lt;/code&gt; &lt;/a&gt;（对于调试库）。这些函数在&lt;a id=&quot;pdf-lualib.h&quot;&gt; &lt;code&gt;lualib.h&lt;/code&gt; &lt;/a&gt;中声明。</target>
        </trans-unit>
        <trans-unit id="f7497be5097473a583f39ec52ec425732f31d8c7" translate="yes" xml:space="preserve">
          <source>To resume a coroutine, you remove any results from the last &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;, put on its stack only the values to be passed as results from &lt;code&gt;yield&lt;/code&gt;, and then call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要恢复协程，请从最后一个&lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; 中&lt;/a&gt;删除所有结果，仅将要作为 &lt;code&gt;yield&lt;/code&gt; 的结果传递的值放在其堆栈上，然后调用&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a9f2afcc694b7e6e7b0ece4b95a9b31851f835d" translate="yes" xml:space="preserve">
          <source>To resume a coroutine, you remove the &lt;code&gt;*nresults&lt;/code&gt; yielded values from its stack, push the values to be passed as results from &lt;code&gt;yield&lt;/code&gt;, and then call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要恢复协程，请从堆栈中删除 &lt;code&gt;*nresults&lt;/code&gt; 产生的值，将这些值作为 &lt;code&gt;yield&lt;/code&gt; 的结果传递，然后调用&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f5749af8d5e7fed727ed35d15b38114e430080b8" translate="yes" xml:space="preserve">
          <source>To start a coroutine, you push onto the thread stack the main function plus any arguments; then you call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, with &lt;code&gt;nargs&lt;/code&gt; being the number of arguments. This call returns when the coroutine suspends or finishes its execution. When it returns, the stack contains all values passed to &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;, or all values returned by the body function. &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the coroutine yields, &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; if the coroutine finishes its execution without errors, or an error code in case of errors (see &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">要启动协程，您可以将主函数以及任何参数推入线程堆栈。然后调用&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;，其中 &lt;code&gt;nargs&lt;/code&gt; 是参数的数量。当协程暂停或完成其执行时，此调用返回。返回时，堆栈包含传递给&lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; 的&lt;/a&gt;所有值，或主体函数返回的所有值。&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt;如果协程产率，&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt;如果协程完成它的执行没有错误，或在错误（见的情况下的误差代码&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="76e8f3d7e170acca1d21ee8a1e8c4351dd451abd" translate="yes" xml:space="preserve">
          <source>To start a coroutine, you push the main function plus any arguments onto the empty stack of the thread. then you call &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, with &lt;code&gt;nargs&lt;/code&gt; being the number of arguments. This call returns when the coroutine suspends or finishes its execution. When it returns, &lt;code&gt;*nresults&lt;/code&gt; is updated and the top of the stack contains the &lt;code&gt;*nresults&lt;/code&gt; values passed to &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt; or returned by the body function. &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; if the coroutine yields, &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; if the coroutine finishes its execution without errors, or an error code in case of errors (see &lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt;). In case of errors, the error object is on the top of the stack.</source>
          <target state="translated">要启动协程，您可以将main函数以及所有参数推入线程的空堆栈中。然后调用&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;，其中 &lt;code&gt;nargs&lt;/code&gt; 是参数的数量。当协程暂停或完成其执行时，此调用返回。返回时， &lt;code&gt;*nresults&lt;/code&gt; 会更新，并且堆栈顶部包含 &lt;code&gt;*nresults&lt;/code&gt; 值，&lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt;值传递给lua_yield或由body函数返回。&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;返回&lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt;如果协程产率，&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt;如果协程完成它的执行没有错误，或在错误的情况下的错误代码（参见&lt;a href=&quot;#4.4.1&quot;&gt;&amp;sect;4.4.1&lt;/a&gt;）。如果发生错误，则错误对象位于堆栈的顶部。</target>
        </trans-unit>
        <trans-unit id="2a41adffb8d584e7921f8216490fc0912471c5b7" translate="yes" xml:space="preserve">
          <source>To-be-closed Variables</source>
          <target state="translated">待关闭的变量</target>
        </trans-unit>
        <trans-unit id="2cdc79b068557cc0be76c7d7fde8401dd4f7da9e" translate="yes" xml:space="preserve">
          <source>Tries to convert a Lua float to a Lua integer; the float &lt;code&gt;n&lt;/code&gt; must have an integral value. If that value is within the range of Lua integers, it is converted to an integer and assigned to &lt;code&gt;*p&lt;/code&gt;. The macro results in a boolean indicating whether the conversion was successful. (Note that this range test can be tricky to do correctly without this macro, due to rounding.)</source>
          <target state="translated">尝试将Lua浮点数转换为Lua整数；浮点数 &lt;code&gt;n&lt;/code&gt; 必须具有整数值。如果该值在Lua整数范围内，则将其转换为整数并分配给 &lt;code&gt;*p&lt;/code&gt; 。该宏导致一个布尔值，指示转换是否成功。（请注意，由于四舍五入的缘故，如果没有此宏，此范围测试可能很难正确执行。）</target>
        </trans-unit>
        <trans-unit id="11a3a0ec973c2479f00cc8910cb72beb238ed2cd" translate="yes" xml:space="preserve">
          <source>Type for C functions.</source>
          <target state="translated">C函数的类型。</target>
        </trans-unit>
        <trans-unit id="bbac79126ad582b607fa7de417480b28246073cf" translate="yes" xml:space="preserve">
          <source>Type for a &lt;em&gt;string buffer&lt;/em&gt;.</source>
          <target state="translated">输入&lt;em&gt;字符串缓冲区&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="597df46ee98db369cefa88ec65178daff885f4c9" translate="yes" xml:space="preserve">
          <source>Type for arrays of functions to be registered by &lt;a href=&quot;#luaL_setfuncs&quot;&gt;&lt;code&gt;luaL_setfuncs&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;name&lt;/code&gt; is the function name and &lt;code&gt;func&lt;/code&gt; is a pointer to the function. Any array of &lt;a href=&quot;#luaL_Reg&quot;&gt;&lt;code&gt;luaL_Reg&lt;/code&gt;&lt;/a&gt; must end with a sentinel entry in which both &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;func&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#luaL_setfuncs&quot;&gt; &lt;code&gt;luaL_setfuncs&lt;/code&gt; &lt;/a&gt;要注册的功能数组的类型。 &lt;code&gt;name&lt;/code&gt; 是函数名称， &lt;code&gt;func&lt;/code&gt; 是指向函数的指针。&lt;a href=&quot;#luaL_Reg&quot;&gt; &lt;code&gt;luaL_Reg&lt;/code&gt; 的&lt;/a&gt;任何数组都必须以哨兵条目结尾，其中 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;func&lt;/code&gt; 均为 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7262eb2a012a409a0b60efe4a99f259fc3c90346" translate="yes" xml:space="preserve">
          <source>Type for continuation functions (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;).</source>
          <target state="translated">延续功能的类型（请参见第&lt;a href=&quot;#4.5&quot;&gt;4.5节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="97624a7d15b8942c923346eb9827dfe7da1b1df0" translate="yes" xml:space="preserve">
          <source>Type for continuation functions (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;).</source>
          <target state="translated">延续功能的类型（请参见第&lt;a href=&quot;#4.7&quot;&gt;4.7节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="24445b5aafedd0f5dd84a959ce49844260c89cd8" translate="yes" xml:space="preserve">
          <source>Type for debugging hook functions.</source>
          <target state="translated">调试钩子函数的类型。</target>
        </trans-unit>
        <trans-unit id="bd045f19fb648f6e2a8a5ad73d4fd1e6a85d7f43" translate="yes" xml:space="preserve">
          <source>Typically this function is used only for hashing and debug information.</source>
          <target state="translated">通常这个函数只用于散列和调试信息。</target>
        </trans-unit>
        <trans-unit id="82aace29da601638b56c7fcfaece961d82f801a3" translate="yes" xml:space="preserve">
          <source>Typically, the message handler is used to add more debug information to the error object, such as a stack traceback. Such information cannot be gathered after the return of &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, since by then the stack has unwound.</source>
          <target state="translated">通常，消息处理程序用于将更多调试信息添加到错误对象，例如堆栈回溯。在&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;返回之后，无法收集此类信息，因为那时堆栈已解开。</target>
        </trans-unit>
        <trans-unit id="c9efe5a42434457d2c52ab4c0d1415d4bcf07916" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all I/O functions return &lt;b&gt;fail&lt;/b&gt; on failure, plus an error message as a second result and a system-dependent error code as a third result, and some non-false value on success. On non-POSIX systems, the computation of the error message and error code in case of errors may be not thread safe, because they rely on the global C variable &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">除非另有说明，否则所有I / O函数都会在失败时返回&lt;b&gt;失败&lt;/b&gt;，并在第二个结果中返回一条错误消息，在第三次结果中返回一个与系统相关的错误代码，并在成功时返回一些非false值。在非POSIX系统上，错误消息和错误代码的计算在发生错误的情况下可能不是线程安全的，因为它们依赖于全局C变量 &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31727baa3a70e03cfa1528c55a7acf86c6c0a582" translate="yes" xml:space="preserve">
          <source>Unless otherwise stated, all I/O functions return &lt;b&gt;nil&lt;/b&gt; on failure (plus an error message as a second result and a system-dependent error code as a third result) and some value different from &lt;b&gt;nil&lt;/b&gt; on success. On non-POSIX systems, the computation of the error message and error code in case of errors may be not thread safe, because they rely on the global C variable &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">除非另有说明，否则所有I / O函数在失败时都会返回&lt;b&gt;nil&lt;/b&gt;（加上错误消息作为第二个结果，并返回与系统相关的错误代码作为第三结果），并且某些值在成功时会返回&lt;b&gt;nil&lt;/b&gt;。在非POSIX系统上，错误情况下错误消息和错误代码的计算可能不是线程安全的，因为它们依赖于全局C变量 &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b52e7d27a22d0d612f9608bbf1f1eccee941606" translate="yes" xml:space="preserve">
          <source>Unless stated otherwise, all functions that expect a byte position as a parameter assume that the given position is either the start of a byte sequence or one plus the length of the subject string. As in the string library, negative indices count from the end of the string.</source>
          <target state="translated">除非另有说明,所有期望以字节位置作为参数的函数都假定给定的位置是一个字节序列的开始,或者是一个加上主题字符串的长度。和字符串库中一样,负指数从字符串的末端开始计算。</target>
        </trans-unit>
        <trans-unit id="4b92e3ee7788b339628f8fb046cb8cb890dfc063" translate="yes" xml:space="preserve">
          <source>Unless stated otherwise, any overflow when manipulating integer values &lt;em&gt;wrap around&lt;/em&gt;, according to the usual rules of two-complement arithmetic. (In other words, the actual result is the unique representable integer that is equal modulo &lt;em&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt; to the mathematical result, where &lt;em&gt;n&lt;/em&gt; is the number of bits of the integer type.)</source>
          <target state="translated">除非另有说明，否则根据整数补码的通常规则，在处理整数值时所有溢出都&lt;em&gt;将环绕&lt;/em&gt;。（换句话说，实际结果是唯一可表示的整数，与数学结果的模&lt;em&gt;2 &lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt;模相等，其中&lt;em&gt;n&lt;/em&gt;是整数类型的位数。）</target>
        </trans-unit>
        <trans-unit id="59b21f366bd62c88e740589d6190f38930d6eeac" translate="yes" xml:space="preserve">
          <source>Unlike other push functions, this function checks for the stack space it needs, including the slot for its result.</source>
          <target state="translated">与其他推送函数不同,这个函数检查它所需要的堆栈空间,包括其结果的槽位。</target>
        </trans-unit>
        <trans-unit id="2e42ec0a938ed392af0043f9b91ccccb6b8e5563" translate="yes" xml:space="preserve">
          <source>Upvalues have no particular order, as they are active through the whole function. They are numbered in an arbitrary order.</source>
          <target state="translated">上位值没有特定的顺序,因为它们在整个函数中都是活动的。它们的编号顺序是任意的。</target>
        </trans-unit>
        <trans-unit id="76f521b6a8d60e44bede4ff94d2d23d25dcfafa8" translate="yes" xml:space="preserve">
          <source>Userdata represent C values in Lua. A &lt;em&gt;light userdata&lt;/em&gt; represents a pointer, a &lt;code&gt;void*&lt;/code&gt;. It is a value (like a number): you do not create it, it has no individual metatable, and it is not collected (as it was never created). A light userdata is equal to &quot;any&quot; light userdata with the same C address.</source>
          <target state="translated">用户数据表示Lua中的C值。甲&lt;em&gt;光用户数据&lt;/em&gt;代表一个指针，一个 &lt;code&gt;void*&lt;/code&gt; 。它是一个值（如数字）：您不创建它，它没有单独的元表，也没有收集它（因为它从未创建过）。轻量用户数据等于具有相同C地址的&amp;ldquo;任何&amp;rdquo;轻量用户数据。</target>
        </trans-unit>
        <trans-unit id="e39e23cf8cc12b3b818ae1cbbd67ab727cb6080a" translate="yes" xml:space="preserve">
          <source>Usually, &lt;code&gt;error&lt;/code&gt; adds some information about the error position at the beginning of the message, if the message is a string. The &lt;code&gt;level&lt;/code&gt; argument specifies how to get the error position. With level 1 (the default), the error position is where the &lt;code&gt;error&lt;/code&gt; function was called. Level 2 points the error to where the function that called &lt;code&gt;error&lt;/code&gt; was called; and so on. Passing a level 0 avoids the addition of error position information to the message.</source>
          <target state="translated">通常，如果消息是字符串， &lt;code&gt;error&lt;/code&gt; 会在消息的开头添加一些有关错误位置的信息。该 &lt;code&gt;level&lt;/code&gt; 参数指定如何得到错误的位置。在级别1（默认值）下，错误位置是调用 &lt;code&gt;error&lt;/code&gt; 函数的位置。级别2将错误指向调用 &lt;code&gt;error&lt;/code&gt; 的函数所在的位置。等等。传递级别0可以避免将错误位置信息添加到消息中。</target>
        </trans-unit>
        <trans-unit id="a5ec00a8e6ea1cb6546f41d42ab21ccdd067623e" translate="yes" xml:space="preserve">
          <source>Usually, this function does not return; when the coroutine eventually resumes, it continues executing the continuation function. However, there is one special case, which is when this function is called from inside a line or a count hook (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). In that case, &lt;code&gt;lua_yieldk&lt;/code&gt; should be called with no continuation (probably in the form of &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;) and no results, and the hook should return immediately after the call. Lua will yield and, when the coroutine resumes again, it will continue the normal execution of the (Lua) function that triggered the hook.</source>
          <target state="translated">通常，此函数不返回；当协程最终恢复时，它将继续执行延续功能。但是，有一种特殊情况，即从行或计数挂钩内部调用此函数时（请参见&lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;）。在这种情况下， &lt;code&gt;lua_yieldk&lt;/code&gt; 不应连续调用（可能以&lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt;形式）并且不返回任何结果，并且该钩子应在调用之后立即返回。Lua将屈服，并且当协程再次恢复时，它将继续触发钩子的（Lua）函数的正常执行。</target>
        </trans-unit>
        <trans-unit id="ede0ea911a1e4e16232a1c52be2e25bf93574b23" translate="yes" xml:space="preserve">
          <source>Usually, this function does not return; when the coroutine eventually resumes, it continues executing the continuation function. However, there is one special case, which is when this function is called from inside a line or a count hook (see &lt;a href=&quot;#4.9&quot;&gt;&amp;sect;4.9&lt;/a&gt;). In that case, &lt;code&gt;lua_yieldk&lt;/code&gt; should be called with no continuation (probably in the form of &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;) and no results, and the hook should return immediately after the call. Lua will yield and, when the coroutine resumes again, it will continue the normal execution of the (Lua) function that triggered the hook.</source>
          <target state="translated">通常，此函数不返回；当协程最终恢复时，它将继续执行延续功能。但是，有一种特殊情况，即从行或计数挂钩内部调用此函数的情况（请参阅第&lt;a href=&quot;#4.9&quot;&gt;4.9节&lt;/a&gt;）。在这种情况下， &lt;code&gt;lua_yieldk&lt;/code&gt; 不应连续调用（可能以&lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt;形式）并且不返回任何结果，并且该挂钩应在调用后立即返回。 Lua将屈服，并且当协程再次恢复时，它将继续触发钩子的（Lua）函数的正常执行。</target>
        </trans-unit>
        <trans-unit id="d093e0dbaa7c773904acc28ac0d7a51be7670739" translate="yes" xml:space="preserve">
          <source>Valid and Acceptable Indices</source>
          <target state="translated">有效和可接受的指数</target>
        </trans-unit>
        <trans-unit id="14347ed892514b4d69c3b3bf601cd9c8fb3e904b" translate="yes" xml:space="preserve">
          <source>Values and Types</source>
          <target state="translated">价值和类型</target>
        </trans-unit>
        <trans-unit id="f5b9087c637e2bfd3e2cf26a4d45a4be30f815bf" translate="yes" xml:space="preserve">
          <source>Variable name '&lt;code&gt;?&lt;/code&gt;' (interrogation mark) represents variables with no known names (variables from chunks saved without debug information).</source>
          <target state="translated">变量名' &lt;code&gt;?&lt;/code&gt; '（询问标记）表示没有已知名称的变量（来自块的变量，没有调试信息）。</target>
        </trans-unit>
        <trans-unit id="12bad2c7ac94b1eae85bb4982ce9b8d423815b52" translate="yes" xml:space="preserve">
          <source>Variable names starting with '&lt;code&gt;(&lt;/code&gt;' (open parenthesis) represent variables with no known names (internal variables such as loop control variables, and variables from chunks saved without debug information).</source>
          <target state="translated">以' &lt;code&gt;(&lt;/code&gt; '（开括号）开头的变量名称表示没有已知名称的变量（内部变量（如循环控制变量，以及来自块的变量，没有调试信息）。</target>
        </trans-unit>
        <trans-unit id="91ca405a6bcded978537314760080c405ac3d0b7" translate="yes" xml:space="preserve">
          <source>Variable names starting with '&lt;code&gt;(&lt;/code&gt;' (open parenthesis) represent variables with no known names (variables from chunks saved without debug information).</source>
          <target state="translated">以' &lt;code&gt;(&lt;/code&gt; '（开括号）开头的变量名称表示没有已知名称的变量（来自块的变量，没有调试信息）。</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="be26bb31c1703ed9ce7e9ecf54d6a6a8c765c6e5" translate="yes" xml:space="preserve">
          <source>Variables are places that store values. There are three kinds of variables in Lua: global variables, local variables, and table fields.</source>
          <target state="translated">变量是存储值的地方。Lua中的变量有三种:全局变量、局部变量和表域。</target>
        </trans-unit>
        <trans-unit id="c95e5bb697c2902b5736feab85b400b53ef72faf" translate="yes" xml:space="preserve">
          <source>Visibility Rules</source>
          <target state="translated">可见度规则</target>
        </trans-unit>
        <trans-unit id="e3ca3a5141d9967c701776eca46ec10c9e635787" translate="yes" xml:space="preserve">
          <source>We can specify any byte in a short literal string by its numeric value (including embedded zeros). This can be done with the escape sequence &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;XX&lt;/em&gt; is a sequence of exactly two hexadecimal digits, or with the escape sequence &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;ddd&lt;/em&gt; is a sequence of up to three decimal digits. (Note that if a decimal escape sequence is to be followed by a digit, it must be expressed using exactly three digits.)</source>
          <target state="translated">我们可以通过文字字符串的数字值（包括嵌入的零）来指定任何字节。这可以通过转义序列 &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt; 来完成，其中&lt;em&gt;XX&lt;/em&gt;是正好是两个十六进制数字的序列，或者可以使用转义序列 &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt; ，其中&lt;em&gt;ddd&lt;/em&gt;是最多三个十进制数字的序列。 （请注意，如果十进制转义序列后跟一个数字，则必须使用正好三位数字表示。）</target>
        </trans-unit>
        <trans-unit id="588ae2cdfea2aa5958efa441455bc701b5efa923" translate="yes" xml:space="preserve">
          <source>We can specify any byte in a short literal string, including embedded zeros, by its numeric value. This can be done with the escape sequence &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;XX&lt;/em&gt; is a sequence of exactly two hexadecimal digits, or with the escape sequence &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt;, where &lt;em&gt;ddd&lt;/em&gt; is a sequence of up to three decimal digits. (Note that if a decimal escape sequence is to be followed by a digit, it must be expressed using exactly three digits.)</source>
          <target state="translated">我们可以通过其数字值指定短文字字符串中的任何字节，包括嵌入的零。这可以通过转义序列 &lt;code&gt;\x&lt;em&gt;XX&lt;/em&gt;&lt;/code&gt; 来完成，其中&lt;em&gt;XX&lt;/em&gt;是正好是两个十六进制数字的序列，或者可以使用转义序列 &lt;code&gt;\&lt;em&gt;ddd&lt;/em&gt;&lt;/code&gt; ，其中&lt;em&gt;ddd&lt;/em&gt;是最多三个十进制数字的序列。 （请注意，如果要在十进制转义序列后跟一个数字，则必须使用正好三个数字来表示。）</target>
        </trans-unit>
        <trans-unit id="a75447b7504738d77e48aaf615cad9ff4faa5f14" translate="yes" xml:space="preserve">
          <source>We need to set some terminology to explain continuations. We have a C function called from Lua which we will call the &lt;em&gt;original function&lt;/em&gt;. This original function then calls one of those three functions in the C API, which we will call the &lt;em&gt;callee function&lt;/em&gt;, that then yields the current thread. (This can happen when the callee function is &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, or when the callee function is either &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; and the function called by them yields.)</source>
          <target state="translated">我们需要设置一些术语来解释续集。我们有一个从Lua调用的C函数，我们将调用&lt;em&gt;原始函数&lt;/em&gt;。然后，该原始函数将调用C API中这三个函数之一，我们将调用&lt;em&gt;被调用函数&lt;/em&gt;，然后产生当前线程。（当被调用方函数是&lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt;或被调用方函数是&lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt;并且它们调用的函数产生时，可能会发生这种情况。）</target>
        </trans-unit>
        <trans-unit id="50c12071f88d71d4186a342c705d8f1079d28abd" translate="yes" xml:space="preserve">
          <source>We need to set some terminology to explain continuations. We have a C function called from Lua which we will call the &lt;em&gt;original function&lt;/em&gt;. This original function then calls one of those three functions in the C API, which we will call the &lt;em&gt;callee function&lt;/em&gt;, that then yields the current thread. This can happen when the callee function is &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, or when the callee function is either &lt;a href=&quot;#lua_callk&quot;&gt;&lt;code&gt;lua_callk&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcallk&quot;&gt;&lt;code&gt;lua_pcallk&lt;/code&gt;&lt;/a&gt; and the function called by them yields.</source>
          <target state="translated">我们需要设置一些术语来解释续集。我们有一个从Lua调用的C函数，我们将调用&lt;em&gt;原始函数&lt;/em&gt;。然后，此原始函数将调用C API中的这三个函数之一，我们将调用&lt;em&gt;被调用者函数&lt;/em&gt;，然后产生当前线程。当被调用方函数是&lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt;或被调用方函数是&lt;a href=&quot;#lua_callk&quot;&gt; &lt;code&gt;lua_callk&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#lua_pcallk&quot;&gt; &lt;code&gt;lua_pcallk&lt;/code&gt; &lt;/a&gt;并且它们调用的函数产生时，可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="d41db10b358155f4f013d45b45675b34f33d9ed3" translate="yes" xml:space="preserve">
          <source>Weak Tables</source>
          <target state="translated">弱电表</target>
        </trans-unit>
        <trans-unit id="b484eff0d117b27e8defcec4a0326a877ca574fe" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;n&lt;/code&gt; is zero, this function creates a &lt;em&gt;light C function&lt;/em&gt;, which is just a pointer to the C function. In that case, it never raises a memory error.</source>
          <target state="translated">当 &lt;code&gt;n&lt;/code&gt; 为零时，此函数创建一个&lt;em&gt;light C函数&lt;/em&gt;，它只是C函数的指针。在这种情况下，它永远不会引发内存错误。</target>
        </trans-unit>
        <trans-unit id="341c8ac217813125623e3b1667a920259b68f995" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is not zero, the allocator must behave like &lt;code&gt;realloc&lt;/code&gt;. In particular, the allocator returns &lt;code&gt;NULL&lt;/code&gt; if and only if it cannot fulfill the request.</source>
          <target state="translated">当 &lt;code&gt;nsize&lt;/code&gt; 不为零时，分配器的行为必须类似于 &lt;code&gt;realloc&lt;/code&gt; 。特别是，分配器仅在无法满足请求时才返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="996f3bf8346e25b1239b5ab5057ae46c604d1002" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is not zero, the allocator must behave like &lt;code&gt;realloc&lt;/code&gt;. The allocator returns &lt;code&gt;NULL&lt;/code&gt; if and only if it cannot fulfill the request. Lua assumes that the allocator never fails when &lt;code&gt;osize &amp;gt;= nsize&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;nsize&lt;/code&gt; 不为零时，分配器的行为必须类似于 &lt;code&gt;realloc&lt;/code&gt; 。当且仅当分配器无法满足请求时，分配器才返回 &lt;code&gt;NULL&lt;/code&gt; 。Lua假定当 &lt;code&gt;osize &amp;gt;= nsize&lt;/code&gt; 时，分配器永远不会失败。</target>
        </trans-unit>
        <trans-unit id="be7cbd666142d4c0c3a8b1ac15f72ec90fcd56bb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is zero, the allocator must behave like &lt;code&gt;free&lt;/code&gt; and return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;nsize&lt;/code&gt; 为零时，分配器的行为必须类似于 &lt;code&gt;free&lt;/code&gt; 并返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c59226f69b5bf9ddb3f25a1bd10f5e6547c8ad04" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nsize&lt;/code&gt; is zero, the allocator must behave like &lt;code&gt;free&lt;/code&gt; and then return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;nsize&lt;/code&gt; 为零时，分配器的行为必须类似于 &lt;code&gt;free&lt;/code&gt; ，然后返回 &lt;code&gt;NULL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63de127a2c08c3b5f3fa7d7ca6251d5614a09288" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nup&lt;/code&gt; is not zero, all functions are created sharing &lt;code&gt;nup&lt;/code&gt; upvalues, which must be previously pushed on the stack on top of the library table. These values are popped from the stack after the registration.</source>
          <target state="translated">当 &lt;code&gt;nup&lt;/code&gt; 不为零时，将创建所有共享 &lt;code&gt;nup&lt;/code&gt; 上值的函数，这些值必须事先被推入库表顶部的堆栈中。这些值在注册后从堆栈中弹出。</target>
        </trans-unit>
        <trans-unit id="954632ad2b6013e35487b453af471fab7d911066" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;nup&lt;/code&gt; is not zero, all functions are created with &lt;code&gt;nup&lt;/code&gt; upvalues, initialized with copies of the &lt;code&gt;nup&lt;/code&gt; values previously pushed on the stack on top of the library table. These values are popped from the stack after the registration.</source>
          <target state="translated">当 &lt;code&gt;nup&lt;/code&gt; 不为零时，将使用 &lt;code&gt;nup&lt;/code&gt; upvalue创建所有函数，并使用先前推送到库表顶部堆栈上的 &lt;code&gt;nup&lt;/code&gt; 值的副本进行初始化。这些值在注册后从堆栈中弹出。</target>
        </trans-unit>
        <trans-unit id="335a5475dbcacbd9ecdd1054fd0513668a84ec31" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ptr&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;osize&lt;/code&gt; encodes the kind of object that Lua is allocating. &lt;code&gt;osize&lt;/code&gt; is any of &lt;a href=&quot;#pdf-LUA_TSTRING&quot;&gt;&lt;code&gt;LUA_TSTRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TTABLE&quot;&gt;&lt;code&gt;LUA_TTABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TFUNCTION&quot;&gt;&lt;code&gt;LUA_TFUNCTION&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-LUA_TUSERDATA&quot;&gt;&lt;code&gt;LUA_TUSERDATA&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#pdf-LUA_TTHREAD&quot;&gt;&lt;code&gt;LUA_TTHREAD&lt;/code&gt;&lt;/a&gt; when (and only when) Lua is creating a new object of that type. When &lt;code&gt;osize&lt;/code&gt; is some other value, Lua is allocating memory for something else.</source>
          <target state="translated">当 &lt;code&gt;ptr&lt;/code&gt; 为 &lt;code&gt;NULL&lt;/code&gt; 时， &lt;code&gt;osize&lt;/code&gt; 编码Lua分配的对象的类型。当（且仅当）Lua创建该类型的新对象时， &lt;code&gt;osize&lt;/code&gt; 是&lt;a href=&quot;#pdf-LUA_TSTRING&quot;&gt; &lt;code&gt;LUA_TSTRING&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-LUA_TTABLE&quot;&gt; &lt;code&gt;LUA_TTABLE&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-LUA_TFUNCTION&quot;&gt; &lt;code&gt;LUA_TFUNCTION&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-LUA_TUSERDATA&quot;&gt; &lt;code&gt;LUA_TUSERDATA&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#pdf-LUA_TTHREAD&quot;&gt; &lt;code&gt;LUA_TTHREAD&lt;/code&gt; 中的&lt;/a&gt;任何一个。当 &lt;code&gt;osize&lt;/code&gt; 是其他值时，Lua将为其他内容分配内存。</target>
        </trans-unit>
        <trans-unit id="46d45ecf04d4c4d9ebff91c3f78c309dab0e87ef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ptr&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, &lt;code&gt;osize&lt;/code&gt; is the size of the block pointed by &lt;code&gt;ptr&lt;/code&gt;, that is, the size given when it was allocated or reallocated.</source>
          <target state="translated">当 &lt;code&gt;ptr&lt;/code&gt; 不为 &lt;code&gt;NULL&lt;/code&gt; 时， &lt;code&gt;osize&lt;/code&gt; 是 &lt;code&gt;ptr&lt;/code&gt; 指向的块的大小，即分配或重新分配块时给出的大小。</target>
        </trans-unit>
        <trans-unit id="0344be77d1524703e63d720dcdc36380a6d9b380" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;t&lt;/code&gt; is a sequence, &lt;code&gt;#t&lt;/code&gt; returns its only border, which corresponds to the intuitive notion of the length of the sequence. When &lt;code&gt;t&lt;/code&gt; is not a sequence, &lt;code&gt;#t&lt;/code&gt; can return any of its borders. (The exact one depends on details of the internal representation of the table, which in turn can depend on how the table was populated and the memory addresses of its non-numeric keys.)</source>
          <target state="translated">当 &lt;code&gt;t&lt;/code&gt; 是一个序列， &lt;code&gt;#t&lt;/code&gt; 返回其仅边界，其对应于所述序列的长度的直观概念。当 &lt;code&gt;t&lt;/code&gt; 不是一个序列， &lt;code&gt;#t&lt;/code&gt; 可以返回任何其边界。（确切的一个取决于表的内部表示的详细信息，而表的内部表示又取决于表的填充方式及其非数字键的内存地址。）</target>
        </trans-unit>
        <trans-unit id="3c915266f11381b28c8d7b3533ebdd9fec110c77" translate="yes" xml:space="preserve">
          <source>When Lua loads a chunk, the default value for its &lt;code&gt;_ENV&lt;/code&gt; upvalue is the global environment (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;). Therefore, by default, free names in Lua code refer to entries in the global environment (and, therefore, they are also called &lt;em&gt;global variables&lt;/em&gt;). Moreover, all standard libraries are loaded in the global environment and some functions there operate on that environment. You can use &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#pdf-loadfile&quot;&gt;&lt;code&gt;loadfile&lt;/code&gt;&lt;/a&gt;) to load a chunk with a different environment. (In C, you have to load the chunk and then change the value of its first upvalue.)</source>
          <target state="translated">当Lua加载一个块时，其 &lt;code&gt;_ENV&lt;/code&gt; 上值的默认值是全局环境（请参见&lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt;）。因此，默认情况下，Lua代码中的自由名称引用全局环境中的条目（因此，它们也称为&lt;em&gt;全局变量&lt;/em&gt;）。此外，所有标准库都加载在全局环境中，并且其中的某些功能在该环境中运行。您可以使用&lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt;（或&lt;a href=&quot;#pdf-loadfile&quot;&gt; &lt;code&gt;loadfile&lt;/code&gt; &lt;/a&gt;）在不同的环境下加载块。 （在C语言中，您必须加载块，然后更改其第一个上值的值。）</target>
        </trans-unit>
        <trans-unit id="22c2aab30b39695e8a73be14337c6b9195ec6401" translate="yes" xml:space="preserve">
          <source>When Lua loads a chunk, the default value for its &lt;code&gt;_ENV&lt;/code&gt; variable is the global environment (see &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt;). Therefore, by default, free names in Lua code refer to entries in the global environment and, therefore, they are also called &lt;em&gt;global variables&lt;/em&gt;. Moreover, all standard libraries are loaded in the global environment and some functions there operate on that environment. You can use &lt;a href=&quot;#pdf-load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#pdf-loadfile&quot;&gt;&lt;code&gt;loadfile&lt;/code&gt;&lt;/a&gt;) to load a chunk with a different environment. (In C, you have to load the chunk and then change the value of its first upvalue; see &lt;a href=&quot;#lua_setupvalue&quot;&gt;&lt;code&gt;lua_setupvalue&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">当Lua加载一个块时，其 &lt;code&gt;_ENV&lt;/code&gt; 变量的默认值为全局环境（请参见&lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt;）。因此，默认情况下，Lua代码中的自由名称引用全局环境中的条目，因此，它们也称为&lt;em&gt;全局变量&lt;/em&gt;。此外，所有标准库都加载在全局环境中，并且其中的某些功能在该环境中运行。您可以使用&lt;a href=&quot;#pdf-load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt;（或&lt;a href=&quot;#pdf-loadfile&quot;&gt; &lt;code&gt;loadfile&lt;/code&gt; &lt;/a&gt;）在不同的环境下加载块。 （在C语言中，您必须加载块，然后更改其第一个upvalue的值；请参见&lt;a href=&quot;#lua_setupvalue&quot;&gt; &lt;code&gt;lua_setupvalue&lt;/code&gt; &lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="9bf5cddf64fd956b790dcd47186d571d0648ca7d" translate="yes" xml:space="preserve">
          <source>When a C function calls &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;, the running coroutine suspends its execution, and the call to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt; that started this coroutine returns. The parameter &lt;code&gt;nresults&lt;/code&gt; is the number of values from the stack that will be passed as results to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当C函数调用&lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; 时&lt;/a&gt;，正在运行的协程将暂停其执行，然后返回对启动此协程的&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;的调用。参数 &lt;code&gt;nresults&lt;/code&gt; 是堆栈中作为结果传递给&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;的值的数量。</target>
        </trans-unit>
        <trans-unit id="6f9fd5a034919e5ee7025d158d3271b1427b5c02" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, the so called upvalues; these upvalues are then accessible to the function whenever it is called. This association is called a C closure (see &lt;a href=&quot;#4.2&quot;&gt;&amp;sect;4.2&lt;/a&gt;). To create a C closure, first the initial values for its upvalues must be pushed onto the stack. (When there are multiple upvalues, the first value is pushed first.) Then &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; is called to create and push the C function onto the stack, with the argument &lt;code&gt;n&lt;/code&gt; telling how many values will be associated with the function. &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; also pops these values from the stack.</source>
          <target state="translated">创建C函数时，可以将一些值与之关联，即所谓的upvalues。然后，只要函数被调用，这些上限值就可供函数访问。这种关联称为C闭包（请参见第&lt;a href=&quot;#4.2&quot;&gt;4.2节&lt;/a&gt;）。要创建C闭包，必须首先将其upvalue的初始值压入堆栈。 （当有多个升值时，首先推入第一个值。）然后&lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt;来创建C函数并将其推入堆栈，参数 &lt;code&gt;n&lt;/code&gt; 表示将与该函数关联的值。&lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt;还会从堆栈中弹出这些值。</target>
        </trans-unit>
        <trans-unit id="6587795ac24fa71cf1c2a7e27096b42bc7a40713" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, thus creating a &lt;em&gt;C closure&lt;/em&gt; (see &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt;); these values are called &lt;em&gt;upvalues&lt;/em&gt; and are accessible to the function whenever it is called.</source>
          <target state="translated">创建C函数时，可以将一些值与之关联，从而创建&lt;em&gt;C闭包&lt;/em&gt;（请参见&lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt;）。这些值被称为&lt;em&gt;upvalues&lt;/em&gt;而且每当它被调用的函数访问。</target>
        </trans-unit>
        <trans-unit id="11ab54e362e4ae46fe6b07e57d87eadd11f23cbe" translate="yes" xml:space="preserve">
          <source>When a C function is created, it is possible to associate some values with it, thus creating a C closure (see &lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;); these values are then accessible to the function whenever it is called. To associate values with a C function, first these values must be pushed onto the stack (when there are multiple values, the first value is pushed first). Then &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; is called to create and push the C function onto the stack, with the argument &lt;code&gt;n&lt;/code&gt; telling how many values will be associated with the function. &lt;a href=&quot;#lua_pushcclosure&quot;&gt;&lt;code&gt;lua_pushcclosure&lt;/code&gt;&lt;/a&gt; also pops these values from the stack.</source>
          <target state="translated">创建C函数时，可以将一些值与其关联，从而创建C闭包（请参见&lt;a href=&quot;#4.4&quot;&gt;&amp;sect;4.4&lt;/a&gt;）。这些值可在调用函数时访问。要将值与C函数相关联，必须首先将这些值压入堆栈（当有多个值时，首先压入第一个值）。然后，调用&lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt;来创建C函数并将其推入堆栈，其中参数 &lt;code&gt;n&lt;/code&gt; 表示将与该函数关联多少个值。&lt;a href=&quot;#lua_pushcclosure&quot;&gt; &lt;code&gt;lua_pushcclosure&lt;/code&gt; &lt;/a&gt;还会从堆栈中弹出这些值。</target>
        </trans-unit>
        <trans-unit id="f143d2ac13b52a6742b50e250fa83e180f7c76c7" translate="yes" xml:space="preserve">
          <source>When a Lua function is called, it adjusts its list of arguments to the length of its list of parameters, unless the function is a &lt;em&gt;vararg function&lt;/em&gt;, which is indicated by three dots ('&lt;code&gt;...&lt;/code&gt;') at the end of its parameter list. A vararg function does not adjust its argument list; instead, it collects all extra arguments and supplies them to the function through a &lt;em&gt;vararg expression&lt;/em&gt;, which is also written as three dots. The value of this expression is a list of all actual extra arguments, similar to a function with multiple results. If a vararg expression is used inside another expression or in the middle of a list of expressions, then its return list is adjusted to one element. If the expression is used as the last element of a list of expressions, then no adjustment is made (unless that last expression is enclosed in parentheses).</source>
          <target state="translated">当调用Lua函数时，除非参数是&lt;em&gt;vararg函数&lt;/em&gt;，否则它将参数列表调整为参数列表的长度，该函数由参数列表末尾的三个点（' &lt;code&gt;...&lt;/code&gt; '）表示。 vararg函数不会调整其参数列表。相反，它将收集所有额外的参数，并通过&lt;em&gt;vararg表达式&lt;/em&gt;将其提供给函数&lt;em&gt;&lt;/em&gt;，也被写成三个点。该表达式的值是所有实际额外参数的列表，类似于具有多个结果的函数。如果在另一个表达式内部或表达式列表的中间使用了vararg表达式，则将其返回列表调整为一个元素。如果将表达式用作表达式列表的最后一个元素，则不会进行任何调整（除非最后一个表达式括在括号中）。</target>
        </trans-unit>
        <trans-unit id="e078eea66272045084e3f01aa8c505b53aa0ead0" translate="yes" xml:space="preserve">
          <source>When a function is called, the list of arguments is adjusted to the length of the list of parameters, unless the function is a &lt;em&gt;vararg function&lt;/em&gt;, which is indicated by three dots ('&lt;code&gt;...&lt;/code&gt;') at the end of its parameter list. A vararg function does not adjust its argument list; instead, it collects all extra arguments and supplies them to the function through a &lt;em&gt;vararg expression&lt;/em&gt;, which is also written as three dots. The value of this expression is a list of all actual extra arguments, similar to a function with multiple results. If a vararg expression is used inside another expression or in the middle of a list of expressions, then its return list is adjusted to one element. If the expression is used as the last element of a list of expressions, then no adjustment is made (unless that last expression is enclosed in parentheses).</source>
          <target state="translated">调用函数时，除非函数是&lt;em&gt;vararg函数&lt;/em&gt;，否则将参数列表调整为参数列表的长度，该函数由参数列表末尾的三个点（' &lt;code&gt;...&lt;/code&gt; '）表示。 vararg函数不会调整其参数列表。相反，它将收集所有额外的参数，并通过&lt;em&gt;vararg表达式&lt;/em&gt;将其提供给函数&lt;em&gt;&lt;/em&gt;，也被写成三个点。该表达式的值是所有实际额外参数的列表，类似于具有多个结果的函数。如果在另一个表达式内部或表达式列表中间使用了vararg表达式，则将其返回列表调整为一个元素。如果将表达式用作表达式列表的最后一个元素，则不会进行任何调整（除非最后一个表达式括在括号中）。</target>
        </trans-unit>
        <trans-unit id="a989335dc83d50af6f8884cd0fdec47036abae37" translate="yes" xml:space="preserve">
          <source>When a marked object becomes dead, it is not collected immediately by the garbage collector. Instead, Lua puts it in a list. After the collection, Lua goes through that list. For each object in the list, it checks the object's &lt;code&gt;__gc&lt;/code&gt; metamethod: If it is present, Lua calls it with the object as its single argument.</source>
          <target state="translated">当标记的对象失效时，垃圾收集器不会立即对其进行收集。相反，Lua将其放在列表中。收集之后，Lua将遍历该列表。对于列表中的每个对象，它将检查对象的 &lt;code&gt;__gc&lt;/code&gt; 元方法：如果存在，则Lua将该对象作为其单个参数进行调用。</target>
        </trans-unit>
        <trans-unit id="da6fe573488f94135e6cdc83d520dc4a94e938c8" translate="yes" xml:space="preserve">
          <source>When a marked object becomes garbage, it is not collected immediately by the garbage collector. Instead, Lua puts it in a list. After the collection, Lua goes through that list. For each object in the list, it checks the object's &lt;code&gt;__gc&lt;/code&gt; metamethod: If it is a function, Lua calls it with the object as its single argument; if the metamethod is not a function, Lua simply ignores it.</source>
          <target state="translated">当标记的对象成为垃圾时，垃圾收集器不会立即对其进行收集。相反，Lua将其放在列表中。收集之后，Lua将遍历该列表。对于列表中的每个对象，它检查对象的 &lt;code&gt;__gc&lt;/code&gt; 元方法：如果是函数，则Lua将该对象作为其单个参数调用它；如果元方法不是函数，则Lua会忽略它。</target>
        </trans-unit>
        <trans-unit id="80897f837555b95f2cb104a59226a4a40d8e481f" translate="yes" xml:space="preserve">
          <source>When called with &lt;b&gt;nil&lt;/b&gt; as the first argument, this function only returns the name of the current locale for the given category.</source>
          <target state="translated">以&lt;b&gt;nil&lt;/b&gt;作为第一个参数调用时，此函数仅返回给定类别的当前语言环境的名称。</target>
        </trans-unit>
        <trans-unit id="12503992ba3e7b779eee88f9ab72a6febed44f13" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;base&lt;/code&gt;, then &lt;code&gt;e&lt;/code&gt; must be a string to be interpreted as an integer numeral in that base. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter '&lt;code&gt;A&lt;/code&gt;' (in either upper or lower case) represents 10, '&lt;code&gt;B&lt;/code&gt;' represents 11, and so forth, with '&lt;code&gt;Z&lt;/code&gt;' representing 35. If the string &lt;code&gt;e&lt;/code&gt; is not a valid numeral in the given base, the function returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">当使用 &lt;code&gt;base&lt;/code&gt; 调用时， &lt;code&gt;e&lt;/code&gt; 必须是一个字符串，才能在该base中解释为整数。基数可以是2到36之间（包括2和36）的任何整数。在大于10的基数中，字母&amp;ldquo; &lt;code&gt;A&lt;/code&gt; &amp;rdquo;（大写或小写）表示10，&amp;ldquo; &lt;code&gt;B&lt;/code&gt; &amp;rdquo;表示11，依此类推，&amp;ldquo; &lt;code&gt;Z&lt;/code&gt; &amp;rdquo;表示35。如果字符串 &lt;code&gt;e&lt;/code&gt; 在给定的值中不是有效数字base，该函数返回&lt;b&gt;fail&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="641f9e62059a652c6e39c5a7f8f27534a9246ba4" translate="yes" xml:space="preserve">
          <source>When called with &lt;code&gt;base&lt;/code&gt;, then &lt;code&gt;e&lt;/code&gt; must be a string to be interpreted as an integer numeral in that base. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter '&lt;code&gt;A&lt;/code&gt;' (in either upper or lower case) represents 10, '&lt;code&gt;B&lt;/code&gt;' represents 11, and so forth, with '&lt;code&gt;Z&lt;/code&gt;' representing 35. If the string &lt;code&gt;e&lt;/code&gt; is not a valid numeral in the given base, the function returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">当使用 &lt;code&gt;base&lt;/code&gt; 调用时， &lt;code&gt;e&lt;/code&gt; 必须是一个字符串，才能在该base中解释为整数。基数可以是2到36（含2和36）之间的任何整数。在大于10的基数中，字母&amp;ldquo; &lt;code&gt;A&lt;/code&gt; &amp;rdquo;（大写或小写）表示10，&amp;ldquo; &lt;code&gt;B&lt;/code&gt; &amp;rdquo;表示11，以此类推，&amp;ldquo; &lt;code&gt;Z&lt;/code&gt; &amp;rdquo;表示35。如果字符串 &lt;code&gt;e&lt;/code&gt; 在给定的值中不是有效数字base，该函数返回&lt;b&gt;nil&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="388bcef0db67f7e381df66c3f7ee8cf9b5be28dc" translate="yes" xml:space="preserve">
          <source>When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without arguments, it returns the current default input file.</source>
          <target state="translated">当用文件名调用时,它打开命名的文件(在文本模式下),并将其句柄设置为默认的输入文件。当调用文件句柄时,它只是将这个文件句柄设置为默认输入文件。当调用无参数时,它返回当前的默认输入文件。</target>
        </trans-unit>
        <trans-unit id="ae1235a6e1b0d97767a88001b252dc354fc4428a" translate="yes" xml:space="preserve">
          <source>When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file.</source>
          <target state="translated">当用文件名调用时,它打开命名的文件(在文本模式下),并将其句柄设置为默认的输入文件。当使用文件句柄调用时,它只是简单地将这个文件句柄设置为默认输入文件。当不使用参数调用时,它返回当前的默认输入文件。</target>
        </trans-unit>
        <trans-unit id="861fad074ef63ba8ca7f9ab877254b943a4b7908" translate="yes" xml:space="preserve">
          <source>When called with a table, &lt;code&gt;os.time&lt;/code&gt; also normalizes all the fields documented in the &lt;a href=&quot;#pdf-os.date&quot;&gt;&lt;code&gt;os.date&lt;/code&gt;&lt;/a&gt; function, so that they represent the same time as before the call but with values inside their valid ranges.</source>
          <target state="translated">当使用表进行调用时， &lt;code&gt;os.time&lt;/code&gt; 还将规范&lt;a href=&quot;#pdf-os.date&quot;&gt; &lt;code&gt;os.date&lt;/code&gt; &lt;/a&gt;函数中记录的所有字段，以便它们表示与调用之前相同的时间，但其值在其有效范围内。</target>
        </trans-unit>
        <trans-unit id="36b8d68eea93133c352fa9c0560fcd4d022359aa" translate="yes" xml:space="preserve">
          <source>When called with at least one argument, the integer parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are joined into a 128-bit &lt;em&gt;seed&lt;/em&gt; that is used to reinitialize the pseudo-random generator; equal seeds produce equal sequences of numbers. The default for &lt;code&gt;y&lt;/code&gt; is zero.</source>
          <target state="translated">当使用至少一个参数调用时，整数参数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 被连接到一个128位&lt;em&gt;种子中&lt;/em&gt;，该&lt;em&gt;种子&lt;/em&gt;用于重新初始化伪随机数生成器。相等的种子产生相等的数字序列。 &lt;code&gt;y&lt;/code&gt; 的默认值为零。</target>
        </trans-unit>
        <trans-unit id="cb0d3b8cfb48505757d0b30079cef91155c8b44b" translate="yes" xml:space="preserve">
          <source>When called with no &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;tonumber&lt;/code&gt; tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then &lt;code&gt;tonumber&lt;/code&gt; returns this number; otherwise, it returns &lt;b&gt;fail&lt;/b&gt;.</source>
          <target state="translated">如果没有所谓的 &lt;code&gt;base&lt;/code&gt; ， &lt;code&gt;tonumber&lt;/code&gt; 尝试它的参数转换为数字。如果参数已经是一个数字或可转换为数字的字符串，则 &lt;code&gt;tonumber&lt;/code&gt; 返回此数字；否则，返回true。否则，它返回&lt;b&gt;fail&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="0331839def59d1c279589644566be45521e46878" translate="yes" xml:space="preserve">
          <source>When called with no &lt;code&gt;base&lt;/code&gt;, &lt;code&gt;tonumber&lt;/code&gt; tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then &lt;code&gt;tonumber&lt;/code&gt; returns this number; otherwise, it returns &lt;b&gt;nil&lt;/b&gt;.</source>
          <target state="translated">如果没有所谓的 &lt;code&gt;base&lt;/code&gt; ， &lt;code&gt;tonumber&lt;/code&gt; 尝试它的参数转换为数字。如果参数已经是数字或可转换为数字的字符串，则 &lt;code&gt;tonumber&lt;/code&gt; 返回此数字；否则，返回&lt;b&gt;nil&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="2cf361fe46fad3d672a6b7fc3deab505bdbf7127" translate="yes" xml:space="preserve">
          <source>When called with no arguments, Lua generates a seed with a weak attempt for randomness.</source>
          <target state="translated">当调用无参数时,Lua会生成一个随机性较弱的种子。</target>
        </trans-unit>
        <trans-unit id="e694403948e49c3cdfc8883a69a69e59e1e2c12c" translate="yes" xml:space="preserve">
          <source>When called with option &lt;code&gt;-E&lt;/code&gt;, besides ignoring &lt;code&gt;LUA_INIT&lt;/code&gt;, Lua also ignores the values of &lt;code&gt;LUA_PATH&lt;/code&gt; and &lt;code&gt;LUA_CPATH&lt;/code&gt;, setting the values of &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; with the default paths defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">当使用选项 &lt;code&gt;-E&lt;/code&gt; 调用时，除了忽略 &lt;code&gt;LUA_INIT&lt;/code&gt; 之外，Lua还将忽略 &lt;code&gt;LUA_PATH&lt;/code&gt; 和 &lt;code&gt;LUA_CPATH&lt;/code&gt; 的值，并使用 &lt;code&gt;luaconf.h&lt;/code&gt; 中定义的默认路径设置&lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="595bc8625b546518b3559c5e580a4c82ef8058d6" translate="yes" xml:space="preserve">
          <source>When called with the option &lt;code&gt;-E&lt;/code&gt;, Lua does not consult any environment variables. In particular, the values of &lt;a href=&quot;#pdf-package.path&quot;&gt;&lt;code&gt;package.path&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pdf-package.cpath&quot;&gt;&lt;code&gt;package.cpath&lt;/code&gt;&lt;/a&gt; are set with the default paths defined in &lt;code&gt;luaconf.h&lt;/code&gt;.</source>
          <target state="translated">当使用选项 &lt;code&gt;-E&lt;/code&gt; 调用时，Lua不会查询任何环境变量。特别是，使用 &lt;code&gt;luaconf.h&lt;/code&gt; 中定义的默认路径设置&lt;a href=&quot;#pdf-package.path&quot;&gt; &lt;code&gt;package.path&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#pdf-package.cpath&quot;&gt; &lt;code&gt;package.cpath&lt;/code&gt; &lt;/a&gt;的值。</target>
        </trans-unit>
        <trans-unit id="de667989e59831a06657a1b7bb1953b9b2690bfc" translate="yes" xml:space="preserve">
          <source>When called without a &lt;code&gt;command&lt;/code&gt;, &lt;code&gt;os.execute&lt;/code&gt; returns a boolean that is true if a shell is available.</source>
          <target state="translated">如果在没有 &lt;code&gt;command&lt;/code&gt; 情况下调用 &lt;code&gt;os.execute&lt;/code&gt; ，则返回一个布尔值，如果有可用的shell，则为true。</target>
        </trans-unit>
        <trans-unit id="08516ebb937ecdc973de2d47f44995af938578a2" translate="yes" xml:space="preserve">
          <source>When called without arguments, &lt;a href=&quot;#pdf-debug.sethook&quot;&gt;&lt;code&gt;debug.sethook&lt;/code&gt;&lt;/a&gt; turns off the hook.</source>
          <target state="translated">当不带参数调用时，&lt;a href=&quot;#pdf-debug.sethook&quot;&gt; &lt;code&gt;debug.sethook&lt;/code&gt; &lt;/a&gt;将关闭钩子。</target>
        </trans-unit>
        <trans-unit id="8dfc7d66f66b8d42b0606debc6628a523caba4e4" translate="yes" xml:space="preserve">
          <source>When called without arguments, &lt;code&gt;date&lt;/code&gt; returns a reasonable date and time representation that depends on the host system and on the current locale. (More specifically, &lt;code&gt;os.date()&lt;/code&gt; is equivalent to &lt;code&gt;os.date(&quot;%c&quot;)&lt;/code&gt;.)</source>
          <target state="translated">在不带参数的情况下调用 &lt;code&gt;date&lt;/code&gt; 时,将返回一个合理的日期和时间表示形式，该表示形式取决于主机系统和当前的语言环境。（更具体地说， &lt;code&gt;os.date()&lt;/code&gt; 等效于 &lt;code&gt;os.date(&quot;%c&quot;)&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="c64be510d7a1b577fd35233990dcc39ace49bc5f" translate="yes" xml:space="preserve">
          <source>When called without arguments, returns a pseudo-random float with uniform distribution in the range &lt;em&gt;[0,1)&lt;/em&gt;. When called with two integers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;math.random&lt;/code&gt; returns a pseudo-random integer with uniform distribution in the range &lt;em&gt;[m, n]&lt;/em&gt;. (The value &lt;em&gt;n-m&lt;/em&gt; cannot be negative and must fit in a Lua integer.) The call &lt;code&gt;math.random(n)&lt;/code&gt; is equivalent to &lt;code&gt;math.random(1,n)&lt;/code&gt;.</source>
          <target state="translated">如果不带参数调用，则返回伪随机浮点数，该浮点数的均匀分布范围为&lt;em&gt;[0,1）&lt;/em&gt;。当使用两个整数 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 调用时， &lt;code&gt;math.random&lt;/code&gt; 返回一个伪随机整数，该伪随机整数具有&lt;em&gt;[m，n]&lt;/em&gt;范围内的均匀分布。 （值&lt;em&gt;nm&lt;/em&gt;不能为负，并且必须适合Lua整数。）调用 &lt;code&gt;math.random(n)&lt;/code&gt; 等效于 &lt;code&gt;math.random(1,n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="960c42dc7bcd6f99e9cb92d7e9f07ec281c2bc3b" translate="yes" xml:space="preserve">
          <source>When called without arguments, returns a pseudo-random float with uniform distribution in the range &lt;em&gt;[0,1)&lt;/em&gt;. When called with two integers &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;math.random&lt;/code&gt; returns a pseudo-random integer with uniform distribution in the range &lt;em&gt;[m, n]&lt;/em&gt;. The call &lt;code&gt;math.random(n)&lt;/code&gt;, for a positive &lt;code&gt;n&lt;/code&gt;, is equivalent to &lt;code&gt;math.random(1,n)&lt;/code&gt;. The call &lt;code&gt;math.random(0)&lt;/code&gt; produces an integer with all bits (pseudo)random.</source>
          <target state="translated">如果不带参数调用，则返回伪随机浮点数，该浮点数的均匀分布范围为&lt;em&gt;[0,1）&lt;/em&gt;。当使用两个整数 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 调用时， &lt;code&gt;math.random&lt;/code&gt; 返回一个伪随机整数，该伪随机整数具有&lt;em&gt;[m，n]&lt;/em&gt;范围内的均匀分布。对于正数 &lt;code&gt;n&lt;/code&gt; 的调用 &lt;code&gt;math.random(n)&lt;/code&gt; 等效于 &lt;code&gt;math.random(1,n)&lt;/code&gt; 。调用 &lt;code&gt;math.random(0)&lt;/code&gt; 生成一个具有所有位（伪）随机数的整数。</target>
        </trans-unit>
        <trans-unit id="29766b7237675cb97603d39839cfd67a198b7d0e" translate="yes" xml:space="preserve">
          <source>When called without option &lt;code&gt;-E&lt;/code&gt;, the interpreter checks for an environment variable &lt;a id=&quot;pdf-LUA_INIT_5_3&quot;&gt;&lt;code&gt;LUA_INIT_5_3&lt;/code&gt;&lt;/a&gt; (or &lt;a id=&quot;pdf-LUA_INIT&quot;&gt;&lt;code&gt;LUA_INIT&lt;/code&gt;&lt;/a&gt; if the versioned name is not defined) before running any argument. If the variable content has the format &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt;, then &lt;code&gt;lua&lt;/code&gt; executes the file. Otherwise, &lt;code&gt;lua&lt;/code&gt; executes the string itself.</source>
          <target state="translated">当不带选项称为 &lt;code&gt;-E&lt;/code&gt; ，对于环境变量解释检查&lt;a id=&quot;pdf-LUA_INIT_5_3&quot;&gt; &lt;code&gt;LUA_INIT_5_3&lt;/code&gt; &lt;/a&gt;（或&lt;a id=&quot;pdf-LUA_INIT&quot;&gt; &lt;code&gt;LUA_INIT&lt;/code&gt; &lt;/a&gt;运行任何参数之前，如果版本名称没有定义）。如果变量内容的格式为 &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt; ，则 &lt;code&gt;lua&lt;/code&gt; 执行该文件。否则， &lt;code&gt;lua&lt;/code&gt; 会执行字符串本身。</target>
        </trans-unit>
        <trans-unit id="af35e90ee5c0251ed92b8eb4bb70c55a27767934" translate="yes" xml:space="preserve">
          <source>When called without the option &lt;code&gt;-E&lt;/code&gt;, the interpreter checks for an environment variable &lt;a id=&quot;pdf-LUA_INIT_5_4&quot;&gt;&lt;code&gt;LUA_INIT_5_4&lt;/code&gt;&lt;/a&gt; (or &lt;a id=&quot;pdf-LUA_INIT&quot;&gt;&lt;code&gt;LUA_INIT&lt;/code&gt;&lt;/a&gt; if the versioned name is not defined) before running any argument. If the variable content has the format &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt;, then &lt;code&gt;lua&lt;/code&gt; executes the file. Otherwise, &lt;code&gt;lua&lt;/code&gt; executes the string itself.</source>
          <target state="translated">当不带选项称为 &lt;code&gt;-E&lt;/code&gt; ，对于环境变量解释检查&lt;a id=&quot;pdf-LUA_INIT_5_4&quot;&gt; &lt;code&gt;LUA_INIT_5_4&lt;/code&gt; &lt;/a&gt;（或&lt;a id=&quot;pdf-LUA_INIT&quot;&gt; &lt;code&gt;LUA_INIT&lt;/code&gt; &lt;/a&gt;运行任何参数之前，如果版本名称没有定义）。如果变量内容的格式为 &lt;code&gt;@&lt;em&gt;filename&lt;/em&gt;&lt;/code&gt; ，则 &lt;code&gt;lua&lt;/code&gt; 执行该文件。否则， &lt;code&gt;lua&lt;/code&gt; 会执行字符串本身。</target>
        </trans-unit>
        <trans-unit id="30a01c66de0f50f818dc4c5eb18a31a7ce0c4e4f" translate="yes" xml:space="preserve">
          <source>When closing a file handle created with &lt;a href=&quot;#pdf-io.popen&quot;&gt;&lt;code&gt;io.popen&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pdf-file:close&quot;&gt;&lt;code&gt;file:close&lt;/code&gt;&lt;/a&gt; returns the same values returned by &lt;a href=&quot;#pdf-os.execute&quot;&gt;&lt;code&gt;os.execute&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当关闭与创建的文件句柄&lt;a href=&quot;#pdf-io.popen&quot;&gt; &lt;code&gt;io.popen&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#pdf-file:close&quot;&gt; &lt;code&gt;file:close&lt;/code&gt; &lt;/a&gt;返回相同的值返回由&lt;a href=&quot;#pdf-os.execute&quot;&gt; &lt;code&gt;os.execute&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d7249fe8ac6ec7cee81ebe5d27b0ade52596d313" translate="yes" xml:space="preserve">
          <source>When finalizing an object, Lua does not ignore &lt;code&gt;__gc&lt;/code&gt; metamethods that are not functions. Any value will be called, if present. (Non-callable values will generate a warning, like any other error when calling a finalizer.)</source>
          <target state="translated">完成对象时，Lua不会忽略不是函数的 &lt;code&gt;__gc&lt;/code&gt; 元方法。如果存在，则将调用任何值。（不可调用的值将生成警告，就像调用终结器时发生的任何其他错误一样。）</target>
        </trans-unit>
        <trans-unit id="37e9db54045b382cd01f62245d15a65082274498" translate="yes" xml:space="preserve">
          <source>When finishing normally, the interpreter closes its main Lua state (see &lt;a href=&quot;#lua_close&quot;&gt;&lt;code&gt;lua_close&lt;/code&gt;&lt;/a&gt;). The script can avoid this step by calling &lt;a href=&quot;#pdf-os.exit&quot;&gt;&lt;code&gt;os.exit&lt;/code&gt;&lt;/a&gt; to terminate.</source>
          <target state="translated">正常完成后，解释器将关闭其主要Lua状态（请参见&lt;a href=&quot;#lua_close&quot;&gt; &lt;code&gt;lua_close&lt;/code&gt; &lt;/a&gt;）。该脚本可以通过调用&lt;a href=&quot;#pdf-os.exit&quot;&gt; &lt;code&gt;os.exit&lt;/code&gt; &lt;/a&gt;终止来避免此步骤。</target>
        </trans-unit>
        <trans-unit id="05829140d113fda20398a82789b93e3ec1b75792" translate="yes" xml:space="preserve">
          <source>When possible, you may prefer to use &lt;a href=&quot;#pdf-io.tmpfile&quot;&gt;&lt;code&gt;io.tmpfile&lt;/code&gt;&lt;/a&gt;, which automatically removes the file when the program ends.</source>
          <target state="translated">如果可能，您可能更喜欢使用&lt;a href=&quot;#pdf-io.tmpfile&quot;&gt; &lt;code&gt;io.tmpfile&lt;/code&gt; &lt;/a&gt;，它会在程序结束时自动删除该文件。</target>
        </trans-unit>
        <trans-unit id="8f55b3bc753eda1e33e754171321ae6cdf1d0c2b" translate="yes" xml:space="preserve">
          <source>When the coroutine is resumed again, Lua calls the given continuation function &lt;code&gt;k&lt;/code&gt; to continue the execution of the C function that yielded (see &lt;a href=&quot;#4.5&quot;&gt;&amp;sect;4.5&lt;/a&gt;). This continuation function receives the same stack from the previous function, with the &lt;code&gt;n&lt;/code&gt; results removed and replaced by the arguments passed to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;. Moreover, the continuation function receives the value &lt;code&gt;ctx&lt;/code&gt; that was passed to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当协程再次恢复时，Lua调用给定的延续函数 &lt;code&gt;k&lt;/code&gt; 继续执行产生的C函数（请参阅第&lt;a href=&quot;#4.5&quot;&gt;4.5节&lt;/a&gt;）。此延续函数与上一个函数接收相同的堆栈，其中 &lt;code&gt;n&lt;/code&gt; 个结果已删除，并由传递给&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;的参数替换。此外，延续函数接收传递给&lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt;的值 &lt;code&gt;ctx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0d813e63ce1dec1bf88d125498265fe1c745f04" translate="yes" xml:space="preserve">
          <source>When the coroutine is resumed again, Lua calls the given continuation function &lt;code&gt;k&lt;/code&gt; to continue the execution of the C function that yielded (see &lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;). This continuation function receives the same stack from the previous function, with the &lt;code&gt;n&lt;/code&gt; results removed and replaced by the arguments passed to &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;. Moreover, the continuation function receives the value &lt;code&gt;ctx&lt;/code&gt; that was passed to &lt;a href=&quot;#lua_yieldk&quot;&gt;&lt;code&gt;lua_yieldk&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当协程再次恢复时，Lua调用给定的延续函数 &lt;code&gt;k&lt;/code&gt; 继续执行产生的C函数（请参见&lt;a href=&quot;#4.7&quot;&gt;&amp;sect;4.7&lt;/a&gt;）。此延续函数与上一个函数接收相同的堆栈，其中 &lt;code&gt;n&lt;/code&gt; 个结果已删除，并由传递给&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;的参数替换。此外，延续函数接收传递给&lt;a href=&quot;#lua_yieldk&quot;&gt; &lt;code&gt;lua_yieldk&lt;/code&gt; &lt;/a&gt;的值 &lt;code&gt;ctx&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a75209bbb2c2e6ad290df78bf5d0eed53f0f5ef0" translate="yes" xml:space="preserve">
          <source>When the function is called, the values in these fields do not need to be inside their valid ranges. For instance, if &lt;code&gt;sec&lt;/code&gt; is -10, it means 10 seconds before the time specified by the other fields; if &lt;code&gt;hour&lt;/code&gt; is 1000, it means 1000 hours after the time specified by the other fields.</source>
          <target state="translated">调用该函数时，这些字段中的值不必在其有效范围内。例如，如果 &lt;code&gt;sec&lt;/code&gt; 为-10，则表示比其他字段指定的时间晚10秒；如果 &lt;code&gt;hour&lt;/code&gt; 是1000，则表示比其他字段指定的时间晚1000小时。</target>
        </trans-unit>
        <trans-unit id="4c6a10ad01c056a56db07a26afc7431181db765d" translate="yes" xml:space="preserve">
          <source>When the hook is called, its first parameter is a string describing the event that has triggered its call: &lt;code&gt;&quot;call&quot;&lt;/code&gt; (or &lt;code&gt;&quot;tail call&quot;&lt;/code&gt;), &lt;code&gt;&quot;return&quot;&lt;/code&gt;, &lt;code&gt;&quot;line&quot;&lt;/code&gt;, and &lt;code&gt;&quot;count&quot;&lt;/code&gt;. For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call &lt;code&gt;getinfo&lt;/code&gt; with level 2 to get more information about the running function (level 0 is the &lt;code&gt;getinfo&lt;/code&gt; function, and level 1 is the hook function).</source>
          <target state="translated">当钩子被调用时，它的第一个参数是描述触发其调用的事件的字符串： &lt;code&gt;&quot;call&quot;&lt;/code&gt; （或 &lt;code&gt;&quot;tail call&quot;&lt;/code&gt; ）， &lt;code&gt;&quot;return&quot;&lt;/code&gt; ， &lt;code&gt;&quot;line&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;count&quot;&lt;/code&gt; 。对于线路事件，该钩子还将获取新的线路号作为其第二个参数。在挂钩内，您可以使用级别2 调用 &lt;code&gt;getinfo&lt;/code&gt; 以获得有关正在运行的函数的更多信息（级别0是 &lt;code&gt;getinfo&lt;/code&gt; 函数，级别1是挂钩函数）。</target>
        </trans-unit>
        <trans-unit id="8bbba941f15e3649b6735004f1fa9587fdc162c9" translate="yes" xml:space="preserve">
          <source>When the hook is called, its first parameter is a string describing the event that has triggered its call: &lt;code&gt;&quot;call&quot;&lt;/code&gt;, &lt;code&gt;&quot;tail call&quot;&lt;/code&gt;, &lt;code&gt;&quot;return&quot;&lt;/code&gt;, &lt;code&gt;&quot;line&quot;&lt;/code&gt;, and &lt;code&gt;&quot;count&quot;&lt;/code&gt;. For line events, the hook also gets the new line number as its second parameter. Inside a hook, you can call &lt;code&gt;getinfo&lt;/code&gt; with level 2 to get more information about the running function. (Level 0 is the &lt;code&gt;getinfo&lt;/code&gt; function, and level 1 is the hook function.)</source>
          <target state="translated">当钩子被调用时，它的第一个参数是描述触发其调用的事件的字符串： &lt;code&gt;&quot;call&quot;&lt;/code&gt; ， &lt;code&gt;&quot;tail call&quot;&lt;/code&gt; ， &lt;code&gt;&quot;return&quot;&lt;/code&gt; ， &lt;code&gt;&quot;line&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;count&quot;&lt;/code&gt; 。对于线路事件，该钩子还将获取新的线路号作为其第二个参数。在挂钩内，您可以调用2级的 &lt;code&gt;getinfo&lt;/code&gt; 以获得有关正在运行的函数的更多信息。 （级别0是 &lt;code&gt;getinfo&lt;/code&gt; 函数，级别1是hook函数。）</target>
        </trans-unit>
        <trans-unit id="eaa8e9df04a952020bd076482c3d60135f7f329c" translate="yes" xml:space="preserve">
          <source>When using implicit file handles, all operations are supplied by table &lt;a id=&quot;pdf-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt;. When using explicit file handles, the operation &lt;a href=&quot;#pdf-io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt; returns a file handle and then all operations are supplied as methods of the file handle.</source>
          <target state="translated">使用隐式文件句柄时，所有操作均由表&lt;a id=&quot;pdf-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; 提供&lt;/a&gt;。使用显式文件句柄时，操作&lt;a href=&quot;#pdf-io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; &lt;/a&gt;返回文件句柄，然后所有操作均作为文件句柄的方法提供。</target>
        </trans-unit>
        <trans-unit id="66e7217ccc689c6dec071df236389bbeca36a0c9" translate="yes" xml:space="preserve">
          <source>When you call a Lua function without a fixed number of results (see &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;), Lua ensures that the stack has enough space for all results, but it does not ensure any extra space. So, before pushing anything in the stack after such a call you should use &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当您调用没有固定结果数的Lua函数时（请参见&lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt;），Lua确保堆栈具有足够的空间来容纳所有结果，但不能确保任何额外的空间。因此，在调用之后将任何东西压入堆栈之前，您应该使用&lt;a href=&quot;#lua_checkstack&quot;&gt; &lt;code&gt;lua_checkstack&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e87402f549363e6adea42f0d7521692e33eb5518" translate="yes" xml:space="preserve">
          <source>When you call a Lua function without a fixed number of results (see &lt;a href=&quot;#lua_call&quot;&gt;&lt;code&gt;lua_call&lt;/code&gt;&lt;/a&gt;), Lua ensures that the stack has enough space for all results, but it does not ensure any extra space. So, before pushing anything on the stack after such a call you should use &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当您调用没有固定数量的结果的Lua函数时（请参见&lt;a href=&quot;#lua_call&quot;&gt; &lt;code&gt;lua_call&lt;/code&gt; &lt;/a&gt;），Lua确保堆栈具有足够的空间容纳所有结果，但不能确保任何额外的空间。因此，在调用之后将任何东西压入堆栈之前，您应该使用&lt;a href=&quot;#lua_checkstack&quot;&gt; &lt;code&gt;lua_checkstack&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0fac89278e16d9cfb7afed920548790f04b59edb" translate="yes" xml:space="preserve">
          <source>When you close a state (see &lt;a href=&quot;#lua_close&quot;&gt;&lt;code&gt;lua_close&lt;/code&gt;&lt;/a&gt;), Lua calls the finalizers of all objects marked for finalization, following the reverse order that they were marked. If any finalizer marks objects for collection during that phase, these marks have no effect.</source>
          <target state="translated">当关闭状态时（请参见&lt;a href=&quot;#lua_close&quot;&gt; &lt;code&gt;lua_close&lt;/code&gt; &lt;/a&gt;），Lua会按照标记它们的相反顺序调用标记为终结的所有对象的终结器。如果在该阶段有任何终结器标记要收集的对象，则这些标记无效。</target>
        </trans-unit>
        <trans-unit id="bfa2a1bee37ec1b8b5edb99fbbb2457d178207e5" translate="yes" xml:space="preserve">
          <source>When you create a new Lua state, its registry comes with some predefined values. These predefined values are indexed with integer keys defined as constants in &lt;code&gt;lua.h&lt;/code&gt;. The following constants are defined:</source>
          <target state="translated">创建新的Lua状态时，其注册表会附带一些预定义的值。这些预定义的值用在 &lt;code&gt;lua.h&lt;/code&gt; 中定义为常量的整数键索引。定义了以下常量：</target>
        </trans-unit>
        <trans-unit id="7355d5bd1b6984cb05bdf3acfb6f9c1a447b9f50" translate="yes" xml:space="preserve">
          <source>When you interact with the Lua API, you are responsible for ensuring consistency. In particular, &lt;em&gt;you are responsible for controlling stack overflow&lt;/em&gt;. You can use the function &lt;a href=&quot;#lua_checkstack&quot;&gt;&lt;code&gt;lua_checkstack&lt;/code&gt;&lt;/a&gt; to ensure that the stack has enough space for pushing new elements.</source>
          <target state="translated">与Lua API交互时，您有责任确保一致性。特别是，&lt;em&gt;您负责控制堆栈溢出&lt;/em&gt;。您可以使用函数&lt;a href=&quot;#lua_checkstack&quot;&gt; &lt;code&gt;lua_checkstack&lt;/code&gt; &lt;/a&gt;来确保堆栈具有足够的空间来推送新元素。</target>
        </trans-unit>
        <trans-unit id="f3ce65bde15db7ea0ab6b60f199c33fedc361e77" translate="yes" xml:space="preserve">
          <source>When you load a main chunk, the resulting function will always have exactly one upvalue, the &lt;code&gt;_ENV&lt;/code&gt; variable (see &lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;). However, when you load a binary chunk created from a function (see &lt;a href=&quot;#pdf-string.dump&quot;&gt;&lt;code&gt;string.dump&lt;/code&gt;&lt;/a&gt;), the resulting function can have an arbitrary number of upvalues, and there is no guarantee that its first upvalue will be the &lt;code&gt;_ENV&lt;/code&gt; variable. (A non-main function may not even have an &lt;code&gt;_ENV&lt;/code&gt; upvalue.)</source>
          <target state="translated">加载主块时，结果函数将始终仅具有一个上值，即 &lt;code&gt;_ENV&lt;/code&gt; 变量（请参见&lt;a href=&quot;#2.2&quot;&gt;&amp;sect;2.2&lt;/a&gt;）。但是，当您加载从函数创建的二进制块时（请参见&lt;a href=&quot;#pdf-string.dump&quot;&gt; &lt;code&gt;string.dump&lt;/code&gt; &lt;/a&gt;），结果函数可以具有任意数量的upvalue，并且不能保证其第一个upvalue将是 &lt;code&gt;_ENV&lt;/code&gt; 变量。（非主函数甚至可能没有 &lt;code&gt;_ENV&lt;/code&gt; 升值。）</target>
        </trans-unit>
        <trans-unit id="1e8b32f8352fd78bcc7ec48884a68493230c9360" translate="yes" xml:space="preserve">
          <source>When you run it, it produces the following output:</source>
          <target state="translated">当你运行它时,它会产生以下输出。</target>
        </trans-unit>
        <trans-unit id="a2fe48a4ba1fe6efea7e679ea6354ce71899c865" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, in C) you may give a &lt;em&gt;message handler&lt;/em&gt; to be called in case of errors. This function is called with the original error object and returns a new error object. It is called before the error unwinds the stack, so that it can gather more information about the error, for instance by inspecting the stack and creating a stack traceback. This message handler is still protected by the protected call; so, an error inside the message handler will call the message handler again. If this loop goes on for too long, Lua breaks it and returns an appropriate message. The message handler is called only for regular runtime errors. It is not called for memory-allocation errors nor for errors while running finalizers or other message handlers.</source>
          <target state="translated">当您使用&lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt;（或C中的&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; &lt;/a&gt;）时，您可以提供一个&lt;em&gt;消息处理程序&lt;/em&gt;，以防发生错误。原始错误对象将调用此函数，并返回新的错误对象。在错误展开堆栈之前调用它，以便它可以收集有关错误的更多信息，例如，通过检查堆栈并创建堆栈回溯。此消息处理程序仍受受保护的调用的保护；因此，消息处理程序内部的错误将再次调用消息处理程序。如果此循环持续的时间过长，Lua会将其中断并返回一条适当的消息。仅对于常规运行时错误才调用消息处理程序。不会因内存分配错误或运行终结器或其他消息处理程序时的错误而调用它。</target>
        </trans-unit>
        <trans-unit id="59fc39a27b959170f68fd36bc3ff7103614c868a" translate="yes" xml:space="preserve">
          <source>When you use &lt;a href=&quot;#pdf-xpcall&quot;&gt;&lt;code&gt;xpcall&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#lua_pcall&quot;&gt;&lt;code&gt;lua_pcall&lt;/code&gt;&lt;/a&gt;, you may give a &lt;em&gt;message handler&lt;/em&gt; to be called in case of errors. This function is called with the original error object and returns a new error object. It is called before the error unwinds the stack, so that it can gather more information about the error, for instance by inspecting the stack and creating a stack traceback. This message handler is still protected by the protected call; so, an error inside the message handler will call the message handler again. If this loop goes on for too long, Lua breaks it and returns an appropriate message. (The message handler is called only for regular runtime errors. It is not called for memory-allocation errors nor for errors while running finalizers.)</source>
          <target state="translated">当使用&lt;a href=&quot;#pdf-xpcall&quot;&gt; &lt;code&gt;xpcall&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#lua_pcall&quot;&gt; &lt;code&gt;lua_pcall&lt;/code&gt; 时&lt;/a&gt;，可以提供一个&lt;em&gt;消息处理程序&lt;/em&gt;，以防发生错误。原始错误对象将调用此函数，并返回新的错误对象。在错误展开堆栈之前调用它，以便它可以收集有关错误的更多信息，例如，通过检查堆栈并创建堆栈回溯。此消息处理程序仍受受保护的调用的保护；因此，消息处理程序内部的错误将再次调用消息处理程序。如果此循环持续的时间过长，Lua会将其中断并返回一条适当的消息。 （仅针对常规运行时错误调用消息处理程序。不针对内存分配错误或运行终结器时的错误调用消息处理程序。）</target>
        </trans-unit>
        <trans-unit id="3d4a440a8a54cb67f8b148f43a2a234b9432ff21" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, it ensures that the stack has space for at least &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt;&lt;code&gt;LUA_MINSTACK&lt;/code&gt;&lt;/a&gt; extra elements; that is, you can safely push up to &lt;code&gt;LUA_MINSTACK&lt;/code&gt; values into it. &lt;code&gt;LUA_MINSTACK&lt;/code&gt; is defined as 20, so that usually you do not have to worry about stack space unless your code has loops pushing elements onto the stack.</source>
          <target state="translated">每当Lua调用C时，它都会确保堆栈具有至少可&lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt; &lt;code&gt;LUA_MINSTACK&lt;/code&gt; &lt;/a&gt;额外元素的空间；也就是说，您可以安全地将 &lt;code&gt;LUA_MINSTACK&lt;/code&gt; 值推入其中。 &lt;code&gt;LUA_MINSTACK&lt;/code&gt; 定义为20，因此通常您不必担心堆栈空间，除非您的代码具有将元素推入堆栈的循环。</target>
        </trans-unit>
        <trans-unit id="15a645bbcf65be028c994caf05ae49cc42785d58" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, it ensures that the stack has space for at least &lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt;&lt;code&gt;LUA_MINSTACK&lt;/code&gt;&lt;/a&gt; extra slots. &lt;code&gt;LUA_MINSTACK&lt;/code&gt; is defined as 20, so that usually you do not have to worry about stack space unless your code has loops pushing elements onto the stack.</source>
          <target state="translated">每当Lua调用C时，它都会确保堆栈至少有&lt;a id=&quot;pdf-LUA_MINSTACK&quot;&gt; &lt;code&gt;LUA_MINSTACK&lt;/code&gt; 个&lt;/a&gt;额外插槽的空间。 &lt;code&gt;LUA_MINSTACK&lt;/code&gt; 定义为20，因此通常您不必担心堆栈空间，除非您的代码具有将元素推入堆栈的循环。</target>
        </trans-unit>
        <trans-unit id="bc36795858181bb669bdb65cc9b9976ecc560ce7" translate="yes" xml:space="preserve">
          <source>Whenever Lua calls C, the called function gets a new stack, which is independent of previous stacks and of stacks of C functions that are still active. This stack initially contains any arguments to the C function and it is where the C function can store temporary Lua values and must push its results to be returned to the caller (see &lt;a href=&quot;#lua_CFunction&quot;&gt;&lt;code&gt;lua_CFunction&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">每当Lua调用C时，被调用函数都会获得一个新的堆栈，该堆栈独立于先前的堆栈和仍处于活动状态的C函数的堆栈。该堆栈最初包含C函数的任何参数，并且C函数可以在其中存储临时Lua值，并且必须将其结果压入返回给调用者（请参见&lt;a href=&quot;#lua_CFunction&quot;&gt; &lt;code&gt;lua_CFunction&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="c2b43773a36392d35ca699c4fb17769ecd2dd7c2" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;code&gt;__newindex&lt;/code&gt; metavalue is invoked, Lua does not perform the primitive assignment. If needed, the metamethod itself can call &lt;a href=&quot;#pdf-rawset&quot;&gt;&lt;code&gt;rawset&lt;/code&gt;&lt;/a&gt; to do the assignment.</source>
          <target state="translated">每当调用 &lt;code&gt;__newindex&lt;/code&gt; 元值时，Lua都不执行原始分配。如果需要，元方法本身可以调用&lt;a href=&quot;#pdf-rawset&quot;&gt; &lt;code&gt;rawset&lt;/code&gt; &lt;/a&gt;进行分配。</target>
        </trans-unit>
        <trans-unit id="0194275f7fed5a9af0589750161f145316d9d8f8" translate="yes" xml:space="preserve">
          <source>Whenever a C function is called, its upvalues are located at specific pseudo-indices. These pseudo-indices are produced by the macro &lt;a href=&quot;#lua_upvalueindex&quot;&gt;&lt;code&gt;lua_upvalueindex&lt;/code&gt;&lt;/a&gt;. The first upvalue associated with a function is at index &lt;code&gt;lua_upvalueindex(1)&lt;/code&gt;, and so on. Any access to &lt;code&gt;lua_upvalueindex(&lt;em&gt;n&lt;/em&gt;)&lt;/code&gt;, where &lt;em&gt;n&lt;/em&gt; is greater than the number of upvalues of the current function (but not greater than 256, which is one plus the maximum number of upvalues in a closure), produces an acceptable but invalid index.</source>
          <target state="translated">每当调用C函数时，其上值都位于特定的伪索引处。这些伪索引由宏&lt;a href=&quot;#lua_upvalueindex&quot;&gt; &lt;code&gt;lua_upvalueindex&lt;/code&gt; &lt;/a&gt;产生。与函数关联的第一个升值在索引 &lt;code&gt;lua_upvalueindex(1)&lt;/code&gt; 上，依此类推。对 &lt;code&gt;lua_upvalueindex(&lt;em&gt;n&lt;/em&gt;)&lt;/code&gt; 的任何访问（其中&lt;em&gt;n&lt;/em&gt;大于当前函数的升值数量（但不大于256，这是一个值加上闭包中最大升值的最大数量））都会产生可接受但无效的索引。</target>
        </trans-unit>
        <trans-unit id="7b599885fcde567666ae50c3832fa9901f1faa95" translate="yes" xml:space="preserve">
          <source>Whenever a hook is called, its &lt;code&gt;ar&lt;/code&gt; argument has its field &lt;code&gt;event&lt;/code&gt; set to the specific event that triggered the hook. Lua identifies these events with the following constants: &lt;a id=&quot;pdf-LUA_HOOKCALL&quot;&gt;&lt;code&gt;LUA_HOOKCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKRET&quot;&gt;&lt;code&gt;LUA_HOOKRET&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKTAILCALL&quot;&gt;&lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt;&lt;/a&gt;, &lt;a id=&quot;pdf-LUA_HOOKLINE&quot;&gt;&lt;code&gt;LUA_HOOKLINE&lt;/code&gt;&lt;/a&gt;, and &lt;a id=&quot;pdf-LUA_HOOKCOUNT&quot;&gt;&lt;code&gt;LUA_HOOKCOUNT&lt;/code&gt;&lt;/a&gt;. Moreover, for line events, the field &lt;code&gt;currentline&lt;/code&gt; is also set. To get the value of any other field in &lt;code&gt;ar&lt;/code&gt;, the hook must call &lt;a href=&quot;#lua_getinfo&quot;&gt;&lt;code&gt;lua_getinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每当调用挂钩时，其 &lt;code&gt;ar&lt;/code&gt; 参数会将其字段 &lt;code&gt;event&lt;/code&gt; 设置为触发该挂钩的特定事件。Lua使用以下常量标识这些事件：&lt;a id=&quot;pdf-LUA_HOOKCALL&quot;&gt; &lt;code&gt;LUA_HOOKCALL&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_HOOKRET&quot;&gt; &lt;code&gt;LUA_HOOKRET&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_HOOKTAILCALL&quot;&gt; &lt;code&gt;LUA_HOOKTAILCALL&lt;/code&gt; &lt;/a&gt;，&lt;a id=&quot;pdf-LUA_HOOKLINE&quot;&gt; &lt;code&gt;LUA_HOOKLINE&lt;/code&gt; &lt;/a&gt;和&lt;a id=&quot;pdf-LUA_HOOKCOUNT&quot;&gt; &lt;code&gt;LUA_HOOKCOUNT&lt;/code&gt; &lt;/a&gt;。此外，对于线路事件，还将设置字段 &lt;code&gt;currentline&lt;/code&gt; 。为了获取 &lt;code&gt;ar&lt;/code&gt; 中任何其他字段的值，该挂钩必须调用&lt;a href=&quot;#lua_getinfo&quot;&gt; &lt;code&gt;lua_getinfo&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="77a4ffdfeb7ea6979c398f6e32e8da8ff060ce91" translate="yes" xml:space="preserve">
          <source>Whenever there is a &lt;code&gt;__newindex&lt;/code&gt; metamethod, Lua does not perform the primitive assignment. (If necessary, the metamethod itself can call &lt;a href=&quot;#pdf-rawset&quot;&gt;&lt;code&gt;rawset&lt;/code&gt;&lt;/a&gt; to do the assignment.)</source>
          <target state="translated">每当有 &lt;code&gt;__newindex&lt;/code&gt; 元方法时，Lua都不执行原始分配。（如果需要，元方法本身可以调用&lt;a href=&quot;#pdf-rawset&quot;&gt; &lt;code&gt;rawset&lt;/code&gt; &lt;/a&gt;进行分配。）</target>
        </trans-unit>
        <trans-unit id="380018403674372e84fb15d5ec3167aa3cf9c5cb" translate="yes" xml:space="preserve">
          <source>Whenever there is an error, an &lt;em&gt;error object&lt;/em&gt; (also called an &lt;em&gt;error message&lt;/em&gt;) is propagated with information about the error. Lua itself only generates errors whose error object is a string, but programs may generate errors with any value as the error object. It is up to the Lua program or its host to handle such error objects.</source>
          <target state="translated">只要有错误，就会传播有关&lt;em&gt;错误信息&lt;/em&gt;的&lt;em&gt;错误对象&lt;/em&gt;（也称为&lt;em&gt;错误消息&lt;/em&gt;）。Lua本身只会生成错误对象，该错误的错误对象是字符串，但是程序可能会生成具有任何值的错误作为错误对象。Lua程序或其主机负责处理此类错误对象。</target>
        </trans-unit>
        <trans-unit id="846e0dd3b617fa3bf7db09630f23f0393a92f6a2" translate="yes" xml:space="preserve">
          <source>Whenever there is an error, an &lt;em&gt;error object&lt;/em&gt; is propagated with information about the error. Lua itself only generates errors whose error object is a string, but programs may generate errors with any value as the error object. It is up to the Lua program or its host to handle such error objects. For historical reasons, an error object is often called an &lt;em&gt;error message&lt;/em&gt;, even though it does not have to be a string.</source>
          <target state="translated">只要有错误，就会传播&lt;em&gt;错误对象&lt;/em&gt;以及有关该错误的信息。Lua本身只会生成错误对象，该错误的错误对象是字符串，但是程序可能会生成具有任何值的错误作为错误对象。Lua程序或其主机负责处理此类错误对象。由于历史原因，错误对象通常称为&lt;em&gt;错误消息&lt;/em&gt;，即使它不一定是字符串也是如此。</target>
        </trans-unit>
        <trans-unit id="272f9a8e241eb8a55a33970a98b804e3cbb2993b" translate="yes" xml:space="preserve">
          <source>While Lua is running a hook, it disables other calls to hooks. Therefore, if a hook calls back Lua to execute a function or a chunk, this execution occurs without any calls to hooks.</source>
          <target state="translated">当Lua运行一个钩子时,它禁用其他对钩子的调用。因此,如果一个钩子回调Lua来执行一个函数或一个块,这个执行将在没有任何钩子调用的情况下进行。</target>
        </trans-unit>
        <trans-unit id="c55926fa7030f56d817d54fc38fc120f3c9f44c9" translate="yes" xml:space="preserve">
          <source>While traversing a table, avoid calling &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; directly on a key, unless you know that the key is actually a string. Recall that &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; may change the value at the given index; this confuses the next call to &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在遍历表时，避免直接在键上调用&lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt;，除非您知道该键实际上是一个字符串。回想一下&lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt;可能会更改给定索引处的值；这混淆了对&lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; &lt;/a&gt;的下一次调用。</target>
        </trans-unit>
        <trans-unit id="768488e627b06a1ccd84c86d3762c984059da019" translate="yes" xml:space="preserve">
          <source>While traversing a table, do not call &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; directly on a key, unless you know that the key is actually a string. Recall that &lt;a href=&quot;#lua_tolstring&quot;&gt;&lt;code&gt;lua_tolstring&lt;/code&gt;&lt;/a&gt; may change the value at the given index; this confuses the next call to &lt;a href=&quot;#lua_next&quot;&gt;&lt;code&gt;lua_next&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在遍历表时，请勿直接在键上调用&lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt;，除非您知道键实际上是字符串。回想一下&lt;a href=&quot;#lua_tolstring&quot;&gt; &lt;code&gt;lua_tolstring&lt;/code&gt; &lt;/a&gt;可能会更改给定索引处的值；这混淆了对&lt;a href=&quot;#lua_next&quot;&gt; &lt;code&gt;lua_next&lt;/code&gt; &lt;/a&gt;的下一次调用。</target>
        </trans-unit>
        <trans-unit id="518506b1bd272cc87115a976ea99ba83864b9064" translate="yes" xml:space="preserve">
          <source>With the exception of exponentiation and float division, the arithmetic operators work as follows: If both operands are integers, the operation is performed over integers and the result is an integer. Otherwise, if both operands are numbers or strings that can be converted to numbers (see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt;), then they are converted to floats, the operation is performed following the usual rules for floating-point arithmetic (usually the IEEE 754 standard), and the result is a float.</source>
          <target state="translated">除求幂和浮点除法外，算术运算符的工作方式如下：如果两个操作数均为整数，则对整数进行运算，结果为整数。否则，如果两个操作数都是数字或可以转换为数字的字符串（请参见第&lt;a href=&quot;#3.4.3&quot;&gt;3.4.3节&lt;/a&gt;），然后将它们转换为浮点数，则将按照浮点算术的通常规则（通常是IEEE 754标准）执行操作。 ，结果是一个浮点数。</target>
        </trans-unit>
        <trans-unit id="6d94057967a72a5d81edd6ae24d02d66cf0d57ab" translate="yes" xml:space="preserve">
          <source>With the exception of exponentiation and float division, the arithmetic operators work as follows: If both operands are integers, the operation is performed over integers and the result is an integer. Otherwise, if both operands are numbers, then they are converted to floats, the operation is performed following the machine's rules for floating-point arithmetic (usually the IEEE 754 standard), and the result is a float. (The string library coerces strings to numbers in arithmetic operations; see &lt;a href=&quot;#3.4.3&quot;&gt;&amp;sect;3.4.3&lt;/a&gt; for details.)</source>
          <target state="translated">除求幂和浮点除法外，算术运算符的工作方式如下：如果两个操作数均为整数，则对整数进行运算，结果为整数。否则，如果两个操作数都是数字，则将它们转换为浮点数，然后按照机器的浮点算术规则（通常为IEEE 754标准）执行操作，结果为浮点数。 （字符串库在算术运算&lt;a href=&quot;#3.4.3&quot;&gt;中将&lt;/a&gt;字符串强制转换为数字；有关详细信息，请参见第3.4.3节。）</target>
        </trans-unit>
        <trans-unit id="ef23cb793be6d01c5592ed37d41262accad311cc" translate="yes" xml:space="preserve">
          <source>Writes the value of each of its arguments to &lt;code&gt;file&lt;/code&gt;. The arguments must be strings or numbers.</source>
          <target state="translated">将其每个参数的值写入 &lt;code&gt;file&lt;/code&gt; 。参数必须是字符串或数字。</target>
        </trans-unit>
        <trans-unit id="4b2eb6ac09b984e213b2d26d7367f553447ec91c" translate="yes" xml:space="preserve">
          <source>Yields a coroutine (thread).</source>
          <target state="translated">产生一个coroutine(线程)。</target>
        </trans-unit>
        <trans-unit id="4c14ae77965a71399e48d53e02bcb286bb93f6f2" translate="yes" xml:space="preserve">
          <source>You can also create and manipulate coroutines through the C API: see functions &lt;a href=&quot;#lua_newthread&quot;&gt;&lt;code&gt;lua_newthread&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#lua_resume&quot;&gt;&lt;code&gt;lua_resume&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#lua_yield&quot;&gt;&lt;code&gt;lua_yield&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">您还可以通过C API创建和操作协程：请参见函数&lt;a href=&quot;#lua_newthread&quot;&gt; &lt;code&gt;lua_newthread&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#lua_resume&quot;&gt; &lt;code&gt;lua_resume&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#lua_yield&quot;&gt; &lt;code&gt;lua_yield&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf65c06d67b704766199b9121e3b29a033e4c3cc" translate="yes" xml:space="preserve">
          <source>You can avoid some incompatibilities by compiling Lua with appropriate options (see file &lt;code&gt;luaconf.h&lt;/code&gt;). However, all these compatibility options will be removed in the future. More often than not, compatibility issues arise when these compatibility options are removed. So, whenever you have the chance, you should try to test your code with a version of Lua compiled with all compatibility options turned off. That will ease transitions to newer versions of Lua.</source>
          <target state="translated">您可以通过使用适当的选项编译Lua来避免某些不兼容性（请参见文件 &lt;code&gt;luaconf.h&lt;/code&gt; ）。但是，将来所有这些兼容性选项都将被删除。通常，删除这些兼容性选项时会出现兼容性问题。因此，只要有机会，就应该尝试使用已关闭所有兼容性选项的Lua版本测试代码。这将简化向Lua的较新版本的过渡。</target>
        </trans-unit>
        <trans-unit id="88e17dda44cc7b49c20312b1b3f6c3280740896b" translate="yes" xml:space="preserve">
          <source>You can call functions only in threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;. You can resume threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (to start a new coroutine) or &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; (to resume a coroutine).</source>
          <target state="translated">您只能在状态为&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; 的&lt;/a&gt;线程中调用函数。您可以恢复状态为&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt;（以启动新协程）或&lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt;（以恢复协程）的线程。</target>
        </trans-unit>
        <trans-unit id="30acf487d4f39b1b32392092243899e125648aac" translate="yes" xml:space="preserve">
          <source>You can change the GC mode and parameters by calling &lt;a href=&quot;#lua_gc&quot;&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt; in C or &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt; in Lua. You can also use these functions to control the collector directly (e.g., to stop and restart it).</source>
          <target state="translated">你可以通过调用改变GC模式和参数&lt;a href=&quot;#lua_gc&quot;&gt; &lt;code&gt;lua_gc&lt;/code&gt; &lt;/a&gt;在C或&lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; &lt;/a&gt;在Lua。您还可以使用这些功能直接控制收集器（例如，停止并重新启动收集器）。</target>
        </trans-unit>
        <trans-unit id="b7319a84c3be9c603d878df474f45dfa44f88afd" translate="yes" xml:space="preserve">
          <source>You can change the way that Lua compares tables and userdata by using the &quot;eq&quot; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">您可以使用&amp;ldquo; eq&amp;rdquo;元方法来更改Lua比较表和用户数据的方式（请参见&lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="bfd38a5c874f3757df856f2f0fe3488def075bb2" translate="yes" xml:space="preserve">
          <source>You can change the way that Lua compares tables and userdata by using the &lt;code&gt;__eq&lt;/code&gt; metamethod (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;).</source>
          <target state="translated">您可以使用 &lt;code&gt;__eq&lt;/code&gt; 元方法来更改Lua比较表和用户数据的方式（请参见&lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3102901d0caee19c958fcee9d58ed56ee554d4f9" translate="yes" xml:space="preserve">
          <source>You can change these numbers by calling &lt;a href=&quot;#lua_gc&quot;&gt;&lt;code&gt;lua_gc&lt;/code&gt;&lt;/a&gt; in C or &lt;a href=&quot;#pdf-collectgarbage&quot;&gt;&lt;code&gt;collectgarbage&lt;/code&gt;&lt;/a&gt; in Lua. You can also use these functions to control the collector directly (e.g., stop and restart it).</source>
          <target state="translated">你可以通过调用改变这些数字&lt;a href=&quot;#lua_gc&quot;&gt; &lt;code&gt;lua_gc&lt;/code&gt; &lt;/a&gt;在C或&lt;a href=&quot;#pdf-collectgarbage&quot;&gt; &lt;code&gt;collectgarbage&lt;/code&gt; &lt;/a&gt;在Lua。您也可以使用这些功能直接控制收集器（例如，停止并重新启动收集器）。</target>
        </trans-unit>
        <trans-unit id="1aa1c0455b97a9145781995effbd7a91d175f4dd" translate="yes" xml:space="preserve">
          <source>You can fix these differences by forcing a number to be a float (in Lua 5.2 all numbers were float), in particular writing constants with an ending &lt;code&gt;.0&lt;/code&gt; or using &lt;code&gt;x = x + 0.0&lt;/code&gt; to convert a variable. (This recommendation is only for a quick fix for an occasional incompatibility; it is not a general guideline for good programming. For good programming, use floats where you need floats and integers where you need integers.)</source>
          <target state="translated">您可以通过将数字强制为浮点数来解决这些差异（在Lua 5.2中，所有数字均为浮点数），尤其是编写以 &lt;code&gt;.0&lt;/code&gt; 结尾的常量或使用 &lt;code&gt;x = x + 0.0&lt;/code&gt; 转换变量。（此建议仅用于快速解决偶然的不兼容问题；它不是良好编程的一般准则。对于良好编程，请在需要浮点数的地方使用浮点数，在需要整数的地方使用整数。）</target>
        </trans-unit>
        <trans-unit id="6b9f9c8aada12f19e8959797fbd200469c989aaf" translate="yes" xml:space="preserve">
          <source>You can only call functions in threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt;. You can resume threads with status &lt;a href=&quot;#pdf-LUA_OK&quot;&gt;&lt;code&gt;LUA_OK&lt;/code&gt;&lt;/a&gt; (to start a new coroutine) or &lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt;&lt;code&gt;LUA_YIELD&lt;/code&gt;&lt;/a&gt; (to resume a coroutine).</source>
          <target state="translated">您只能在状态为&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; 的&lt;/a&gt;线程中调用函数。您可以恢复状态为&lt;a href=&quot;#pdf-LUA_OK&quot;&gt; &lt;code&gt;LUA_OK&lt;/code&gt; &lt;/a&gt;（以启动新协程）或&lt;a href=&quot;#pdf-LUA_YIELD&quot;&gt; &lt;code&gt;LUA_YIELD&lt;/code&gt; &lt;/a&gt;（以恢复协程）的线程。</target>
        </trans-unit>
        <trans-unit id="59f7d5bf15872a3901218a87816b69752280c691" translate="yes" xml:space="preserve">
          <source>You can put a closing square bracket in a set by positioning it as the first character in the set. You can put a hyphen in a set by positioning it as the first or the last character in the set. (You can also use an escape for both cases.)</source>
          <target state="translated">您可以将一个方括号作为集合中的第一个字符放入集合中。你可以将连字符作为集合中的第一个或最后一个字符放入集合中。你也可以在这两种情况下使用转义符)。</target>
        </trans-unit>
        <trans-unit id="8061a68da1d074d2f5c5e92636b71ce2c9bfb53d" translate="yes" xml:space="preserve">
          <source>You can put a closing square bracket in a set by positioning it as the first character in the set. You can put an hyphen in a set by positioning it as the first or the last character in the set. (You can also use an escape for both cases.)</source>
          <target state="translated">您可以将一个方括号作为集合中的第一个字符放入集合中。你可以将连字符作为集合中的第一个或最后一个字符放入集合中。你也可以在这两种情况下使用转义符)。</target>
        </trans-unit>
        <trans-unit id="799d3c0c986643b2fb7ee878e60672115c276c33" translate="yes" xml:space="preserve">
          <source>You can query the metatable of any value using the &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt; function. Lua queries metamethods in metatables using a raw access (see &lt;a href=&quot;#pdf-rawget&quot;&gt;&lt;code&gt;rawget&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">您可以使用&lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt;函数查询任何值的元表。Lua使用原始访问来查询元表中的元方法（请参阅&lt;a href=&quot;#pdf-rawget&quot;&gt; &lt;code&gt;rawget&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d2781e61b519fd47b1d4f450639555b1c01907b6" translate="yes" xml:space="preserve">
          <source>You can query the metatable of any value using the &lt;a href=&quot;#pdf-getmetatable&quot;&gt;&lt;code&gt;getmetatable&lt;/code&gt;&lt;/a&gt; function. Lua queries metamethods in metatables using a raw access (see &lt;a href=&quot;#pdf-rawget&quot;&gt;&lt;code&gt;rawget&lt;/code&gt;&lt;/a&gt;). So, to retrieve the metamethod for event &lt;code&gt;ev&lt;/code&gt; in object &lt;code&gt;o&lt;/code&gt;, Lua does the equivalent to the following code:</source>
          <target state="translated">您可以使用&lt;a href=&quot;#pdf-getmetatable&quot;&gt; &lt;code&gt;getmetatable&lt;/code&gt; &lt;/a&gt;函数查询任何值的元表。Lua使用原始访问来查询元表中的元方法（请参阅&lt;a href=&quot;#pdf-rawget&quot;&gt; &lt;code&gt;rawget&lt;/code&gt; &lt;/a&gt;）。因此，要检索对象 &lt;code&gt;o&lt;/code&gt; 中事件 &lt;code&gt;ev&lt;/code&gt; 的元方法，Lua等效于以下代码：</target>
        </trans-unit>
        <trans-unit id="d1dc46c8e9720bcf85f3abea3ac1cb55affdcb0d" translate="yes" xml:space="preserve">
          <source>You can replace the metatable of tables using the &lt;a href=&quot;#pdf-setmetatable&quot;&gt;&lt;code&gt;setmetatable&lt;/code&gt;&lt;/a&gt; function. You cannot change the metatable of other types from Lua code (except by using the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;)); you should use the C API for that.</source>
          <target state="translated">您可以使用&lt;a href=&quot;#pdf-setmetatable&quot;&gt; &lt;code&gt;setmetatable&lt;/code&gt; &lt;/a&gt;函数替换表的元表。您不能从Lua代码更改其他类型的元表（除非使用调试库（第&lt;a href=&quot;#6.10&quot;&gt;6.10节&lt;/a&gt;））；您应该为此使用C API。</target>
        </trans-unit>
        <trans-unit id="71035c95301acc8c192b359af22e6b3657788623" translate="yes" xml:space="preserve">
          <source>You can replace the metatable of tables using the &lt;a href=&quot;#pdf-setmetatable&quot;&gt;&lt;code&gt;setmetatable&lt;/code&gt;&lt;/a&gt; function. You cannot change the metatable of other types from Lua code, except by using the debug library (&lt;a href=&quot;#6.10&quot;&gt;&amp;sect;6.10&lt;/a&gt;).</source>
          <target state="translated">您可以使用&lt;a href=&quot;#pdf-setmetatable&quot;&gt; &lt;code&gt;setmetatable&lt;/code&gt; &lt;/a&gt;函数替换表的元表。您不能通过Lua代码更改其他类型的元表，除非使用调试库（第&lt;a href=&quot;#6.10&quot;&gt;6.10节&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7e58a48a2bbf52e5804761968441fe7ea238d5cc" translate="yes" xml:space="preserve">
          <source>You can set garbage-collector metamethods for tables and, using the C API, for full userdata (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). These metamethods are also called &lt;em&gt;finalizers&lt;/em&gt;. Finalizers allow you to coordinate Lua's garbage collection with external resource management (such as closing files, network or database connections, or freeing your own memory).</source>
          <target state="translated">您可以为表设置垃圾收集器元方法，并使用C API设置完整的用户数据（请参见&lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;）。这些元方法也称为&lt;em&gt;终结器&lt;/em&gt;。使用终结器，您可以将Lua的垃圾回收与外部资源管理（例如，关闭文件，网络或数据库连接或释放自己的内存）进行协调。</target>
        </trans-unit>
        <trans-unit id="bda59ef5aaee54d3f7530ea5520d18e9906d209b" translate="yes" xml:space="preserve">
          <source>You can set garbage-collector metamethods for tables and, using the C API, for full userdata (see &lt;a href=&quot;#2.4&quot;&gt;&amp;sect;2.4&lt;/a&gt;). These metamethods, called &lt;em&gt;finalizers&lt;/em&gt;, are called when the garbage collector detects that the corresponding table or userdata is dead. Finalizers allow you to coordinate Lua's garbage collection with external resource management such as closing files, network or database connections, or freeing your own memory.</source>
          <target state="translated">您可以为表设置垃圾收集器元方法，并使用C API设置完整的用户数据（请参阅第&lt;a href=&quot;#2.4&quot;&gt;2.4节&lt;/a&gt;）。当垃圾收集器检测到相应的表或用户数据已失效时，将调用称为&lt;em&gt;终结器的&lt;/em&gt;这些元方法。终结器使您可以将Lua的垃圾回收与外部资源管理（例如，关闭文件，网络或数据库连接或释放自己的内存）进行协调。</target>
        </trans-unit>
        <trans-unit id="af1a4e1dd00034824534614f2bda7911ae8431cd" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;break&lt;/b&gt; and &lt;b&gt;goto&lt;/b&gt; to exit a &lt;b&gt;for&lt;/b&gt; loop.</source>
          <target state="translated">您可以使用&lt;b&gt;break&lt;/b&gt;和&lt;b&gt;goto&lt;/b&gt;退出&lt;b&gt;for&lt;/b&gt;循环。</target>
        </trans-unit>
        <trans-unit id="b27cc8080576c27c1dd2a0afb3a34a7a52ff85b8" translate="yes" xml:space="preserve">
          <source>You can use &lt;b&gt;break&lt;/b&gt; to exit a &lt;b&gt;for&lt;/b&gt; loop.</source>
          <target state="translated">您可以使用&lt;b&gt;break&lt;/b&gt;退出&lt;b&gt;for&lt;/b&gt;循环。</target>
        </trans-unit>
        <trans-unit id="d52df43ef083f76a03d8e01f3e9a36da3fc66f0d" translate="yes" xml:space="preserve">
          <source>You create a coroutine by calling &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;. Its sole argument is a function that is the main function of the coroutine. The &lt;code&gt;create&lt;/code&gt; function only creates a new coroutine and returns a handle to it (an object of type &lt;em&gt;thread&lt;/em&gt;); it does not start the coroutine.</source>
          <target state="translated">您可以通过调用&lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; 来&lt;/a&gt;创建协程。它唯一的参数是协程的主要功能。在 &lt;code&gt;create&lt;/code&gt; 函数只创建一个新的协程，并返回它的句柄（类型的对象&lt;em&gt;线程&lt;/em&gt;）; 它不会启动协程。</target>
        </trans-unit>
        <trans-unit id="5ef445026cd0a146e81e995bc4681bfd5e57e5c5" translate="yes" xml:space="preserve">
          <source>You do not have to allocate space for the result: the result is a Lua string and Lua takes care of memory allocation (and deallocation, through garbage collection).</source>
          <target state="translated">你不需要为结果分配空间:结果是一个 Lua 字符串,Lua 负责内存分配(以及通过垃圾回收进行去分配)。</target>
        </trans-unit>
        <trans-unit id="76e561e2abeb8c3fca97fd50eca052b57e9c65f8" translate="yes" xml:space="preserve">
          <source>You execute a coroutine by calling &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;. When you first call &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt;, passing as its first argument a thread returned by &lt;a href=&quot;#pdf-coroutine.create&quot;&gt;&lt;code&gt;coroutine.create&lt;/code&gt;&lt;/a&gt;, the coroutine starts its execution by calling its main function. Extra arguments passed to &lt;a href=&quot;#pdf-coroutine.resume&quot;&gt;&lt;code&gt;coroutine.resume&lt;/code&gt;&lt;/a&gt; are passed as arguments to that function. After the coroutine starts running, it runs until it terminates or &lt;em&gt;yields&lt;/em&gt;.</source>
          <target state="translated">您可以通过调用&lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; &lt;/a&gt;执行协程。当你第一次调用&lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 时&lt;/a&gt;，所需传入的第一个参数被返回的线程&lt;a href=&quot;#pdf-coroutine.create&quot;&gt; &lt;code&gt;coroutine.create&lt;/code&gt; 的&lt;/a&gt;，协程调用它的主要功能就开始执行它。传递给&lt;a href=&quot;#pdf-coroutine.resume&quot;&gt; &lt;code&gt;coroutine.resume&lt;/code&gt; 的&lt;/a&gt;额外参数将作为参数传递给该函数。协程开始运行后，它将运行直到终止或&lt;em&gt;屈服&lt;/em&gt;。</target>
        </trans-unit>
        <trans-unit id="9517d537bb2cc69695684dbed19e521703190b55" translate="yes" xml:space="preserve">
          <source>You should not change the value of the control variable during the loop.</source>
          <target state="translated">在循环过程中,你不应该改变控制变量的值。</target>
        </trans-unit>
        <trans-unit id="beb90315d79ba8436d83c1621548dc0828a068ab" translate="yes" xml:space="preserve">
          <source>You should not change the value of the control variable during the loop. If you need its value after the loop, assign it to another variable before exiting the loop.</source>
          <target state="translated">在循环过程中,你不应该改变控制变量的值。如果你在循环后需要它的值,在退出循环前将其赋值给另一个变量。</target>
        </trans-unit>
        <trans-unit id="f53454c1d52c8e8625f900a3b2f28a52f9ab6262" translate="yes" xml:space="preserve">
          <source>_G</source>
          <target state="translated">_G</target>
        </trans-unit>
        <trans-unit id="2f7691c85ede2ffb322e774a60315181bf799f71" translate="yes" xml:space="preserve">
          <source>_VERSION</source>
          <target state="translated">_VERSION</target>
        </trans-unit>
        <trans-unit id="d361be99d87b0fd1757850b39df6dc818e066eec" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;*&lt;/code&gt;', which matches sequences of zero or more characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">单个字符类，后跟' &lt;code&gt;*&lt;/code&gt; '，该字符类与该类中零个或多个字符的序列匹配。这些重复项将始终与最长的序列匹配；</target>
        </trans-unit>
        <trans-unit id="88f22daca599d25013aaf6d4c6cefa12b839e072" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;*&lt;/code&gt;', which matches zero or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">单个字符类，后跟' &lt;code&gt;*&lt;/code&gt; '，该字符类与零个或多个字符重复匹配。这些重复项将始终匹配最长的序列；</target>
        </trans-unit>
        <trans-unit id="9f3711be8dd7bfb74572554b6c7626ae533f6527" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;+&lt;/code&gt;', which matches one or more repetitions of characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">单个字符类，后跟&amp;ldquo; &lt;code&gt;+&lt;/code&gt; &amp;rdquo;，它匹配该类中一个或多个字符的重复。这些重复项将始终匹配最长的序列；</target>
        </trans-unit>
        <trans-unit id="bc94c739274a89a02c004f804c812de321b43960" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;+&lt;/code&gt;', which matches sequences of one or more characters in the class. These repetition items will always match the longest possible sequence;</source>
          <target state="translated">单个字符类，后跟&amp;ldquo; &lt;code&gt;+&lt;/code&gt; &amp;rdquo;，匹配该类中一个或多个字符的序列。这些重复项将始终与最长的序列匹配；</target>
        </trans-unit>
        <trans-unit id="bc742d84c8f95089303b3c1235798dad7894c243" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;-&lt;/code&gt;', which also matches sequences of zero or more characters in the class. Unlike '&lt;code&gt;*&lt;/code&gt;', these repetition items will always match the shortest possible sequence;</source>
          <target state="translated">单个字符类，后跟&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;，它也与该类中零个或多个字符的序列匹配。与&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;不同，这些重复项将始终匹配最短的序列；</target>
        </trans-unit>
        <trans-unit id="7c2c202847f17af45741edd719e4addc76505a81" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;-&lt;/code&gt;', which also matches zero or more repetitions of characters in the class. Unlike '&lt;code&gt;*&lt;/code&gt;', these repetition items will always match the shortest possible sequence;</source>
          <target state="translated">单个字符类，后跟&amp;ldquo; &lt;code&gt;-&lt;/code&gt; &amp;rdquo;，它还与该类中的零个或多个字符重复匹配。与&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo; 不同，这些重复项将始终匹配最短的序列；</target>
        </trans-unit>
        <trans-unit id="237b908d85fd5486211190c63284fa599c924a55" translate="yes" xml:space="preserve">
          <source>a single character class followed by '&lt;code&gt;?&lt;/code&gt;', which matches zero or one occurrence of a character in the class. It always matches one occurrence if possible;</source>
          <target state="translated">单个字符类，后跟' &lt;code&gt;?&lt;/code&gt; '，它与该类中字符的零个或一次匹配。如果可能，它总是匹配一次。</target>
        </trans-unit>
        <trans-unit id="0c5e2141926ba6afbd01b9f0df61d70a7c93f57e" translate="yes" xml:space="preserve">
          <source>a single character class, which matches any single character in the class;</source>
          <target state="translated">一个单字类,它与该类中的任何一个单字相匹配。</target>
        </trans-unit>
        <trans-unit id="63ae10d79f4a0c4781e4e9b2dacd5c9896a57556" translate="yes" xml:space="preserve">
          <source>assert()</source>
          <target state="translated">assert()</target>
        </trans-unit>
        <trans-unit id="d9b7850ae45b39d5960b24328cbe68f8d5986e4d" translate="yes" xml:space="preserve">
          <source>basic UTF-8 support (&lt;a href=&quot;#6.5&quot;&gt;&amp;sect;6.5&lt;/a&gt;);</source>
          <target state="translated">基本的UTF-8支持（第&lt;a href=&quot;#6.5&quot;&gt;6.5节&lt;/a&gt;）；</target>
        </trans-unit>
        <trans-unit id="fefa5c394d291465c545b09029d833606f910bf8" translate="yes" xml:space="preserve">
          <source>basic library (&lt;a href=&quot;#6.1&quot;&gt;&amp;sect;6.1&lt;/a&gt;);</source>
          <target state="translated">基本库（&lt;a href=&quot;#6.1&quot;&gt;第6.1节&lt;/a&gt;）；</target>
        </trans-unit>
        <trans-unit id="74dcaf5215a85f0f3fdfba06d8dc2140d162bce8" translate="yes" xml:space="preserve">
          <source>by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, Waldemar Celes</source>
          <target state="translated">作者:Roberto Ierusalimschy、Luiz Henrique de Figueiredo、Waldemar Celes。</target>
        </trans-unit>
        <trans-unit id="85f91b3e97f2cf4928f588f868b5b56e41f46ac7" translate="yes" xml:space="preserve">
          <source>can be used to call &quot;methods&quot;. A call &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; is syntactic sugar for &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;, except that &lt;code&gt;v&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">可以用来称呼&amp;ldquo;方法&amp;rdquo;。调用 &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 是 &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 的语法糖，只是 &lt;code&gt;v&lt;/code&gt; 仅被评估一次。</target>
        </trans-unit>
        <trans-unit id="6d633e66cce93e82c599b2ed94b6975cd1983c8d" translate="yes" xml:space="preserve">
          <source>can be used to emulate methods. A call &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; is syntactic sugar for &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt;, except that &lt;code&gt;v&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">可以用来模拟方法。调用 &lt;code&gt;v:name(&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 是 &lt;code&gt;v.name(v,&lt;em&gt;args&lt;/em&gt;)&lt;/code&gt; 的语法糖，只是 &lt;code&gt;v&lt;/code&gt; 仅被评估一次。</target>
        </trans-unit>
        <trans-unit id="db3586e1e0bcc962d7bc2f3fead617414fb7e605" translate="yes" xml:space="preserve">
          <source>collectgarbage()</source>
          <target state="translated">collectgarbage()</target>
        </trans-unit>
        <trans-unit id="2d524624e9fa583630d5fa0595340fdebfe37ef7" translate="yes" xml:space="preserve">
          <source>coroutine library (&lt;a href=&quot;#6.2&quot;&gt;&amp;sect;6.2&lt;/a&gt;);</source>
          <target state="translated">协程库（&lt;a href=&quot;#6.2&quot;&gt;&amp;sect;6.2&lt;/a&gt;）;</target>
        </trans-unit>
        <trans-unit id="eae27926b30edc4437a198e2711147c99c5e7fbe" translate="yes" xml:space="preserve">
          <source>coroutine.close()</source>
          <target state="translated">coroutine.close()</target>
        </trans-unit>
        <trans-unit id="20cd53c84ed6149d722a861cd300131fe78d55e2" translate="yes" xml:space="preserve">
          <source>coroutine.create()</source>
          <target state="translated">coroutine.create()</target>
        </trans-unit>
        <trans-unit id="6817fb4ac877543987e9d2cf2bfa960bd73b02b0" translate="yes" xml:space="preserve">
          <source>coroutine.isyieldable()</source>
          <target state="translated">coroutine.isyieldable()</target>
        </trans-unit>
        <trans-unit id="1c13fd77eddf40ec2374814bf03a272d614ac054" translate="yes" xml:space="preserve">
          <source>coroutine.resume()</source>
          <target state="translated">coroutine.resume()</target>
        </trans-unit>
        <trans-unit id="b96ab0d2970d06f0cea57e5eaa71cf5ecdd618a8" translate="yes" xml:space="preserve">
          <source>coroutine.running()</source>
          <target state="translated">coroutine.running()</target>
        </trans-unit>
        <trans-unit id="ba662b8414ef9e3a4eaa77d2c840fa4c12339222" translate="yes" xml:space="preserve">
          <source>coroutine.status()</source>
          <target state="translated">coroutine.status()</target>
        </trans-unit>
        <trans-unit id="bf3b61ea5fdfb1c6f4aa0021505b10377c2744b9" translate="yes" xml:space="preserve">
          <source>coroutine.wrap()</source>
          <target state="translated">coroutine.wrap()</target>
        </trans-unit>
        <trans-unit id="28fa9aab8f13eb98b7d555b1121c4e2f64da5b24" translate="yes" xml:space="preserve">
          <source>coroutine.yield()</source>
          <target state="translated">coroutine.yield()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
