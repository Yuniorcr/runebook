<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rethinkdb">
    <body>
      <group id="rethinkdb">
        <trans-unit id="b64fe618441e29b37149058f1a7d34872564ed83" translate="yes" xml:space="preserve">
          <source>Starting with RethinkDB 1.16, the earlier concept of &amp;ldquo;data centers&amp;rdquo; has been replaced by server tags, described above. Servers in a given data center could all be given a tag such as &lt;code&gt;us_east&lt;/code&gt; or &lt;code&gt;us_west&lt;/code&gt;, and a table can be configured to have replicas associated with specific server tags (e.g., 2 replicas on servers tagged with &lt;code&gt;us_east&lt;/code&gt; and 3 on servers tagged with &lt;code&gt;us_west&lt;/code&gt;).</source>
          <target state="translated">从RethinkDB 1.16开始，较早的&amp;ldquo;数据中心&amp;rdquo;概念已由服务器标签代替，如上所述。在一个给定的数据中心的服务器可以全部给定标签的诸如 &lt;code&gt;us_east&lt;/code&gt; 或 &lt;code&gt;us_west&lt;/code&gt; ，和一个表可以被配置为具有与特定的服务器标签（例如，在服务器2级的副本标记为相关联的复制品 &lt;code&gt;us_east&lt;/code&gt; 和3的服务器上具有标记 &lt;code&gt;us_west&lt;/code&gt; ） 。</target>
        </trans-unit>
        <trans-unit id="2942d3a5f8afc6539a606fe55996f2f85ba8fb2d" translate="yes" xml:space="preserve">
          <source>Starting with RethinkDB 2.0 (&lt;code&gt;V0_4&lt;/code&gt;), the server will process multiple queries in parallel rather than sequentially, and there is no guarantee that a read following a write on the same connection will &amp;ldquo;see&amp;rdquo; the results of the write as long as it&amp;rsquo;s successful. (Previous versions of the server would process multiple queries on the same connection sequentially.)</source>
          <target state="translated">从RethinkDB 2.0（ &lt;code&gt;V0_4&lt;/code&gt; ）开始，服务器将并行而不是顺序地处理多个查询，并且不能保证只要成功，在同一连接上进行写入后的读取将&amp;ldquo;看到&amp;rdquo;写入结果。 （服务器的早期版本将在同一连接上顺序处理多个查询。）</target>
        </trans-unit>
        <trans-unit id="c961f51ddf6e3a1960d4006dbd241d5e425cac28" translate="yes" xml:space="preserve">
          <source>Starting with RethinkDB 2.2, state documents will &lt;em&gt;only&lt;/em&gt; be sent if the &lt;code&gt;includeStates&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;, even on point changefeeds. Initial values will only be sent if &lt;code&gt;includeInitial&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;includeStates&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;includeInitial&lt;/code&gt; is false, the first document on the feed will be &lt;code&gt;{state:'ready'}&lt;/code&gt;.</source>
          <target state="translated">从RethinkDB 2.2开始，&lt;em&gt;仅&lt;/em&gt;在 &lt;code&gt;includeStates&lt;/code&gt; 选项为 &lt;code&gt;true&lt;/code&gt; &lt;em&gt;时才&lt;/em&gt;发送状态文档，即使是在点变更源上也是如此。仅当 &lt;code&gt;includeInitial&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时,才会发送初始值。如果 &lt;code&gt;includeStates&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 且 &lt;code&gt;includeInitial&lt;/code&gt; 为false，则提要中的第一个文档为 &lt;code&gt;{state:'ready'}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1aa3213c8e5b544991124ed5c55d376f49994e0a" translate="yes" xml:space="preserve">
          <source>Starting with version 1.16, RethinkDB maintains special &lt;em&gt;system tables&lt;/em&gt; that contain configuration and status information about servers, databases, individual tables, and issues with the cluster. Querying system tables returns information about the status of the cluster and current objects (such as servers and tables) within the cluster. By inserting or deleting records and updating fields in these tables, the configuration of the objects they represent can be modified.</source>
          <target state="translated">从版本1.16开始，RethinkDB维护特殊的&lt;em&gt;系统表&lt;/em&gt;，这些&lt;em&gt;表&lt;/em&gt;包含有关服务器，数据库，单个表以及群集问题的配置和状态信息。查询系统表将返回有关集群状态以及集群中当前对象（例如服务器和表）的信息。通过插入或删除记录并更新这些表中的字段，可以修改它们表示的对象的配置。</target>
        </trans-unit>
        <trans-unit id="081c1e1e4da3f29bf8bb20597a5735c3791932d3" translate="yes" xml:space="preserve">
          <source>Starting with version 2.3, RethinkDB offers the ability to secure connections between servers, between servers and clients, and to the web UI using &lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLS&lt;/a&gt; encryption (the successor to SSL). Securing RethinkDB in this fashion is similar to securing a web site with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Self-signed_certificate&quot;&gt;self-signed SSL certificate&lt;/a&gt;: create a private key and a certificate, then tell the server to use them.</source>
          <target state="translated">从2.3版开始，RethinkDB可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Transport_Layer_Security&quot;&gt;TLS&lt;/a&gt;加密（SSL的后继产品）来保护服务器之间，服务器与客户端之间以及与Web UI 的连接的安全。以这种方式保护RethinkDB类似于使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Self-signed_certificate&quot;&gt;自签名SSL证书&lt;/a&gt;保护网站：创建私钥和证书，然后告诉服务器使用它们。</target>
        </trans-unit>
        <trans-unit id="a14ca71f5de11ac16b741f2895038968e30fa95f" translate="yes" xml:space="preserve">
          <source>Startup with init.d</source>
          <target state="translated">用init.d启动</target>
        </trans-unit>
        <trans-unit id="ea9b605703b9aa1d999b8932d0180fd06fb42587" translate="yes" xml:space="preserve">
          <source>Startup with launchd (OS X)</source>
          <target state="translated">用 launchd 启动 (OS X)</target>
        </trans-unit>
        <trans-unit id="f4e43708be29e49c1ec1aa4189305be5e1934e28" translate="yes" xml:space="preserve">
          <source>Startup with systemd</source>
          <target state="translated">用systemd启动</target>
        </trans-unit>
        <trans-unit id="2086b21f8f49274138c38d476bee317a84a8aecc" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="translated">Statistics</target>
        </trans-unit>
        <trans-unit id="f1b89f18db10edb807e2bb4dbf71b7f25ac69016" translate="yes" xml:space="preserve">
          <source>Status tables</source>
          <target state="translated">状态表</target>
        </trans-unit>
        <trans-unit id="dc416e1088e4bf094dfc9abe0210e0288f5a169e" translate="yes" xml:space="preserve">
          <source>Step</source>
          <target state="translated">Step</target>
        </trans-unit>
        <trans-unit id="15679a4a26f9a6ba3a691493d6beeae10a421041" translate="yes" xml:space="preserve">
          <source>Stopping a Handler</source>
          <target state="translated">停止处理程序</target>
        </trans-unit>
        <trans-unit id="cbffd52d681c0a57ba768a7b13d045efc1626e9c" translate="yes" xml:space="preserve">
          <source>Stores queries and their results, and displays them from a web interface.</source>
          <target state="translated">存储查询及其结果,并从Web界面显示它们。</target>
        </trans-unit>
        <trans-unit id="051adf2dce81e4edeb3804a2a2cc5362ddbcbd3a" translate="yes" xml:space="preserve">
          <source>Storing and enriching API data</source>
          <target state="translated">存储和丰富API数据</target>
        </trans-unit>
        <trans-unit id="0c202e6f4f3c0ecb61addbe0a44f03640e49acaf" translate="yes" xml:space="preserve">
          <source>Storing binary objects</source>
          <target state="translated">存储二进制对象</target>
        </trans-unit>
        <trans-unit id="f99d2614f3e61769cb31cbb3d64230a0bf9792bd" translate="yes" xml:space="preserve">
          <source>Storing timestamps and JSON date strings as Time data types</source>
          <target state="translated">将时间戳和JSON日期字符串存储为时间数据类型。</target>
        </trans-unit>
        <trans-unit id="421ed75a3333e9d8c5cea75e785430b7939cdab5" translate="yes" xml:space="preserve">
          <source>Storing uploaded files in the database</source>
          <target state="translated">在数据库中存储上传的文件</target>
        </trans-unit>
        <trans-unit id="36dda565904ac283e012045f6d9e7daf872d0a13" translate="yes" xml:space="preserve">
          <source>Storing user avatars</source>
          <target state="translated">存储用户头像</target>
        </trans-unit>
        <trans-unit id="37fcd98b3c8b91061836eba59a7019ed4b18d372" translate="yes" xml:space="preserve">
          <source>Streams and feeds are lazily-computed sequences, and return a &lt;code&gt;ResponseType&lt;/code&gt; of &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; (&lt;code&gt;3&lt;/code&gt;), with currently available data in the &lt;code&gt;r&lt;/code&gt; array. When the driver receives a feed or stream, it should return a cursor (or an object with a cursor-like interface). &lt;em&gt;N.B.:&lt;/em&gt;&lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; and &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; responses should be both be represented as cursors. Depending on the size of the query results and the time it takes to return them, you may receive either one &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; result, or one or more &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; results followed by a final &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; result.</source>
          <target state="translated">流和进料是懒惰地计算的序列，并返回一个 &lt;code&gt;ResponseType&lt;/code&gt; 的 &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; （ &lt;code&gt;3&lt;/code&gt; ），与在当前可用数据 &lt;code&gt;r&lt;/code&gt; 阵列。当驱动程序接收到提要或流时，它应返回一个游标（或具有类似游标的接口的对象）。&lt;em&gt;注意：&lt;/em&gt; &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; 和 &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; 响应都应表示为游标。根据查询结果的大小和返回查询结果所花费的时间，您可能会收到一个 &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; 结果，或者一个或多个 &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; 结果，然后是最终的 &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; 结果。</target>
        </trans-unit>
        <trans-unit id="cb6c4efeac903a0003cef92ddf354bd1374cf2f1" translate="yes" xml:space="preserve">
          <source>Streams use &amp;ldquo;lazy loading,&amp;rdquo; a concept you may have run across in other database interfaces. Instead of returning an entire result set from a query, streams return an &lt;a href=&quot;http://en.wikipedia.org/wiki/Iterator&quot;&gt;iterator&lt;/a&gt; referred to as a &amp;ldquo;cursor,&amp;rdquo; a pointer into the data set.</source>
          <target state="translated">流使用&amp;ldquo;延迟加载&amp;rdquo;，这是您可能在其他数据库界面中遇到过的概念。流不是返回查询的整个结果集，而是返回称为&amp;ldquo;游标&amp;rdquo; 的&lt;a href=&quot;http://en.wikipedia.org/wiki/Iterator&quot;&gt;迭代器&lt;/a&gt;，即指向数据集的指针。</target>
        </trans-unit>
        <trans-unit id="bdd49f40eb94b20bc3d437ca36ad5830377fda8e" translate="yes" xml:space="preserve">
          <source>String Manipulation</source>
          <target state="translated">字符串操作</target>
        </trans-unit>
        <trans-unit id="411f94c6ca34e4478bca225615707da562686a1d" translate="yes" xml:space="preserve">
          <source>String manipulation</source>
          <target state="translated">字符串操作</target>
        </trans-unit>
        <trans-unit id="7c8cf84261f17414d41a19324152deb0638ecb13" translate="yes" xml:space="preserve">
          <source>Subcommands</source>
          <target state="translated">Subcommands</target>
        </trans-unit>
        <trans-unit id="bbd17ca7716d1959474368eb0c63e1ad9ad957be" translate="yes" xml:space="preserve">
          <source>Subqueries</source>
          <target state="translated">Subqueries</target>
        </trans-unit>
        <trans-unit id="98e916c3bddbbc175b04c5eaa8de99d155cbe03c" translate="yes" xml:space="preserve">
          <source>Subqueries can be abstracted in variables, which allows for modular programming in the same way as done by most other modern programming languages.</source>
          <target state="translated">子查询可以在变量中抽象出来,这使得模块化编程与大多数其他现代编程语言的方式相同。</target>
        </trans-unit>
        <trans-unit id="e97aae2f87eb9b6796d483ee8974c03c1e5ba9e2" translate="yes" xml:space="preserve">
          <source>Subscribe to a feed by calling &lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;changes&lt;/a&gt; on a table:</source>
          <target state="translated">通过调用表上的&lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;更改&lt;/a&gt;订阅供稿：</target>
        </trans-unit>
        <trans-unit id="cf8a466677b83f4e1f4df6f8b69bf7ba43beb2b7" translate="yes" xml:space="preserve">
          <source>Subscribe to the &lt;a href=&quot;https://groups.google.com/forum/?fromgroups=#!forum/rethinkdb-dev&quot;&gt;RethinkDB driver developers group&lt;/a&gt;.</source>
          <target state="translated">订阅&lt;a href=&quot;https://groups.google.com/forum/?fromgroups=#!forum/rethinkdb-dev&quot;&gt;RethinkDB驱动程序开发人员组&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="395d7a75e1ae0564bdd8d6d6363f8537be3bc1c5" translate="yes" xml:space="preserve">
          <source>Subscribers create a changefeed on the &lt;code&gt;Exchange&lt;/code&gt;&amp;rsquo;s table, filtering for changes that mention documents matching their topic queries.</source>
          <target state="translated">订阅者会在 &lt;code&gt;Exchange&lt;/code&gt; 的表格上创建更改供稿，过滤出提及与其主题查询匹配的文档的更改。</target>
        </trans-unit>
        <trans-unit id="7b2a790bdd19b116e81ba00ed519edb942e324e3" translate="yes" xml:space="preserve">
          <source>Subscribing to changefeeds</source>
          <target state="translated">订阅changefeeds</target>
        </trans-unit>
        <trans-unit id="6a4dd28a2000f4de189f22a02e6a44d6093e120e" translate="yes" xml:space="preserve">
          <source>Subscribing to hierarchical topics</source>
          <target state="translated">订阅分级主题</target>
        </trans-unit>
        <trans-unit id="a6e859ee0a008ef4fd60b3c46f2e406a1c004727" translate="yes" xml:space="preserve">
          <source>Subscribing to topics using regex</source>
          <target state="translated">使用regex订阅主题</target>
        </trans-unit>
        <trans-unit id="0128e284e80f24203df15083d6d063f8f03c858d" translate="yes" xml:space="preserve">
          <source>Subscribing to topics using tags</source>
          <target state="translated">使用标签订阅主题</target>
        </trans-unit>
        <trans-unit id="9dd600d816401a97bb7171cf8a4a1a7bf7c906c0" translate="yes" xml:space="preserve">
          <source>Subtract two numbers.</source>
          <target state="translated">减去两个数。</target>
        </trans-unit>
        <trans-unit id="4efe5ba11913e60899922a574c9310ce44547cf0" translate="yes" xml:space="preserve">
          <source>Sum two or more numbers, or concatenate two or more strings or arrays.</source>
          <target state="translated">将两个或多个数字相加,或将两个或多个字符串或数组相联。</target>
        </trans-unit>
        <trans-unit id="3c265c2ec47c266f4eddd985a602248cf1492e23" translate="yes" xml:space="preserve">
          <source>Sums all the elements of a sequence. If called with a field name, sums all the values of that field in the sequence, skipping elements of the sequence that lack that field. If called with a function, calls that function on every element of the sequence and sums the results, skipping elements of the sequence where that function returns &lt;code&gt;null&lt;/code&gt; or a non-existence error.</source>
          <target state="translated">对序列的所有元素求和。如果使用字段名调用，则将序列中该字段的所有值求和，并跳过缺少该字段的序列中的元素。如果使用函数调用，则在序列的每个元素上调用该函数并求和结果，并跳过序列中该函数返回 &lt;code&gt;null&lt;/code&gt; 或不存在错误的元素。</target>
        </trans-unit>
        <trans-unit id="d8b6182e4e1fbdaf3ea143a384f18f88f4f511f0" translate="yes" xml:space="preserve">
          <source>Superheroes tutorial</source>
          <target state="translated">超级英雄教程</target>
        </trans-unit>
        <trans-unit id="89bc1824e398cf96683dfbc223ebb34785115277" translate="yes" xml:space="preserve">
          <source>Supported options</source>
          <target state="translated">支持的选项</target>
        </trans-unit>
        <trans-unit id="0e292d899e02633c2e04b35d5deb85171e7578e3" translate="yes" xml:space="preserve">
          <source>Suppose a data set that lists top movies, ranked by user vote. You&amp;rsquo;d like to get the total votes and the average age of the top 25 movies: the &lt;code&gt;avg()&lt;/code&gt; of the &lt;code&gt;year&lt;/code&gt; column and the &lt;code&gt;sum()&lt;/code&gt; of the &lt;code&gt;votes&lt;/code&gt; column, ordered by the &lt;code&gt;rank&lt;/code&gt; column to get the range 1&amp;ndash;25.</source>
          <target state="translated">假设一个数据集列出了按用户投票排名的顶级电影。你想获得的总票数和排名前25位的电影，平均年龄：在 &lt;code&gt;avg()&lt;/code&gt; 中的 &lt;code&gt;year&lt;/code&gt; 列和 &lt;code&gt;sum()&lt;/code&gt; 中的 &lt;code&gt;votes&lt;/code&gt; 列，所订购的 &lt;code&gt;rank&lt;/code&gt; 列得到的范围1-25。</target>
        </trans-unit>
        <trans-unit id="8b899c315ce40799000302d06bdb519d66498dd3" translate="yes" xml:space="preserve">
          <source>Suppose each post has a field &lt;code&gt;tags&lt;/code&gt; that maps to an array of tags. The schema of the table &lt;code&gt;posts&lt;/code&gt; would be something like:</source>
          <target state="translated">假设每个帖子都有一个字段 &lt;code&gt;tags&lt;/code&gt; ，该标签映射到标签数组。表格 &lt;code&gt;posts&lt;/code&gt; 的架构如下所示：</target>
        </trans-unit>
        <trans-unit id="482306a03a24119b4b1e772995e3616816ebe2c3" translate="yes" xml:space="preserve">
          <source>Suppose its output is as follows:</source>
          <target state="translated">假设其输出如下:</target>
        </trans-unit>
        <trans-unit id="305076c03efbc539dfa0aa5fe524a8ad5027bba7" translate="yes" xml:space="preserve">
          <source>Suppose on the blog in the last example, you&amp;rsquo;d like to retrieve the number of posts &lt;em&gt;per category.&lt;/em&gt; A map-reduce query to perform this operation would consist of the following steps:</source>
          <target state="translated">假设在上一个示例的博客中，您想要检索&lt;em&gt;每个类别&lt;/em&gt;的帖子&lt;em&gt;数。&lt;/em&gt;要执行此操作的map-reduce查询将包括以下步骤：</target>
        </trans-unit>
        <trans-unit id="9fc193e9aee3048beb3caf5658d764b058365ee8" translate="yes" xml:space="preserve">
          <source>Suppose that our data model for the employees stores a company name instead of a company id:</source>
          <target state="translated">假设我们的员工数据模型存储的是公司名称而不是公司id。</target>
        </trans-unit>
        <trans-unit id="ba7f91272a3804d75a6598e1f3bad96058fabbf5" translate="yes" xml:space="preserve">
          <source>Suppose that the table &lt;code&gt;games2&lt;/code&gt; has the following data:</source>
          <target state="translated">假设表 &lt;code&gt;games2&lt;/code&gt; 具有以下数据：</target>
        </trans-unit>
        <trans-unit id="d618567de8457f4e1f435d12d614a8fa312d9700" translate="yes" xml:space="preserve">
          <source>Suppose that the table &lt;code&gt;games&lt;/code&gt; has the following data:</source>
          <target state="translated">假设桌面 &lt;code&gt;games&lt;/code&gt; 具有以下数据：</target>
        </trans-unit>
        <trans-unit id="06104ac359e508ccef4ef32dfaf2a4fdca0b82b0" translate="yes" xml:space="preserve">
          <source>Suppose that you want to keep the &lt;code&gt;id&lt;/code&gt; field of the employee, but not the one of the company. You can do it by removing the field &lt;code&gt;right.id&lt;/code&gt;, then calling the &lt;code&gt;zip&lt;/code&gt; command.</source>
          <target state="translated">假设您要保留员工的 &lt;code&gt;id&lt;/code&gt; 字段，而不是公司之一。您可以通过删除 &lt;code&gt;right.id&lt;/code&gt; 字段，然后调用 &lt;code&gt;zip&lt;/code&gt; 命令来实现。</target>
        </trans-unit>
        <trans-unit id="27c97e208254d412ff656573ce4566923a071cae" translate="yes" xml:space="preserve">
          <source>Suppose the players table contains these documents:</source>
          <target state="translated">假设玩家桌上有这些文件。</target>
        </trans-unit>
        <trans-unit id="55d631d358f622eb48a20000ddcdf5a71d5d16d0" translate="yes" xml:space="preserve">
          <source>Suppose the table &lt;code&gt;marks&lt;/code&gt; stores the marks of every students per course:</source>
          <target state="translated">假设表格 &lt;code&gt;marks&lt;/code&gt; 存储每个课程的每个学生的标记：</target>
        </trans-unit>
        <trans-unit id="863abd28999d7a33805cde5f619af1857cb2ffb2" translate="yes" xml:space="preserve">
          <source>Suppose we have a table &lt;code&gt;posts&lt;/code&gt; that links posts to authors via an &lt;code&gt;author_id&lt;/code&gt; field. If we&amp;rsquo;ve created a secondary index on &lt;code&gt;author_id&lt;/code&gt; and want to retrieve all the posts where &lt;code&gt;author_id&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;, we can use the &lt;code&gt;getAll&lt;/code&gt; command to do it as follows:</source>
          <target state="translated">假设我们有一个表格 &lt;code&gt;posts&lt;/code&gt; ，它通过 &lt;code&gt;author_id&lt;/code&gt; 字段将帖子链接到作者。如果我们已经创建了一个二级指标 &lt;code&gt;author_id&lt;/code&gt; 和希望检索所有的帖子，其中 &lt;code&gt;author_id&lt;/code&gt; 是 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ，或 &lt;code&gt;3&lt;/code&gt; ，我们可以使用 &lt;code&gt;getAll&lt;/code&gt; 命令如下做到这一点：</target>
        </trans-unit>
        <trans-unit id="dd69d64d9d90f1021ac7cab49f4dced356698803" translate="yes" xml:space="preserve">
          <source>Suppose we have a table &lt;code&gt;users&lt;/code&gt; with documents of the following form:</source>
          <target state="translated">假设我们有一个表 &lt;code&gt;users&lt;/code&gt; ，其表格式如下：</target>
        </trans-unit>
        <trans-unit id="b1f14a9832b9f642f0b36d37ee55787766eea3b7" translate="yes" xml:space="preserve">
          <source>Suppose we have ten documents in a single category in a sharded table. Four of the documents are on shard 1; six are on shard 2. When the incorrect query is executed, this is its path:</source>
          <target state="translated">假设我们在一个碎片表中的一个类别中有10个文档,其中4个在碎片1上,6个在碎片2上。其中4个文档在1号碎片上;6个文档在2号碎片上。当执行错误的查询时,这就是它的路径。</target>
        </trans-unit>
        <trans-unit id="ecab01432f8dcfd29db07faed3306d03f5f21cc7" translate="yes" xml:space="preserve">
          <source>Suppose we want to rename the field &lt;code&gt;id&lt;/code&gt; to &lt;code&gt;idUser&lt;/code&gt; when retrieving documents from the table &lt;code&gt;users&lt;/code&gt;. In the subquery, we can use &lt;code&gt;merge&lt;/code&gt; to add a new field with the existing field&amp;rsquo;s value, then &lt;code&gt;without&lt;/code&gt; to delete the old field:</source>
          <target state="translated">假设在从表 &lt;code&gt;users&lt;/code&gt; 检索文档时，我们想将字段 &lt;code&gt;id&lt;/code&gt; 重命名为 &lt;code&gt;idUser&lt;/code&gt; 。在子查询中，我们可以使用 &lt;code&gt;merge&lt;/code&gt; 添加具有现有字段值的新字段，然后 &lt;code&gt;without&lt;/code&gt; 删除旧字段：</target>
        </trans-unit>
        <trans-unit id="cd8284b9c5ecd12c0da7cb055be040ad759da9ca" translate="yes" xml:space="preserve">
          <source>Suppose we&amp;rsquo;d like to to retrieve all the posts in the table &lt;code&gt;post&lt;/code&gt; and also return an additional field, &lt;code&gt;comments&lt;/code&gt;, which is an array of all the comments for the relevant post retrieved from the &lt;code&gt;comments&lt;/code&gt; table. We could do this using a subquery:</source>
          <target state="translated">假设我们想检索表中所有的帖子 &lt;code&gt;post&lt;/code&gt; ，也返回一个附加字段， &lt;code&gt;comments&lt;/code&gt; ，这是从检索到的相关帖子所有评论的数组 &lt;code&gt;comments&lt;/code&gt; 表。我们可以使用子查询来做到这一点：</target>
        </trans-unit>
        <trans-unit id="efa9d5fab76e05214df4eea4580738c57dea1f05" translate="yes" xml:space="preserve">
          <source>Suppose we&amp;rsquo;d like to trim down our database and delete every document with less than three posts (sorry Laura and Jean-Luc):</source>
          <target state="translated">假设我们要精简数据库并删除少于三个帖子的每个文档（对不起，Laura和Jean-Luc）：</target>
        </trans-unit>
        <trans-unit id="d9835b16eff20fd64f058bf8e513bffb08e5156e" translate="yes" xml:space="preserve">
          <source>Suppose you are running a blog and would like to retrieve the number of posts. A map-reduce query to perform this operation would consist of the following steps:</source>
          <target state="translated">假设你正在运行一个博客,并希望检索文章的数量。执行此操作的映射还原查询包括以下步骤:</target>
        </trans-unit>
        <trans-unit id="6cc205fe6a19e66a7e73ca9c5922fd6934973caf" translate="yes" xml:space="preserve">
          <source>Suppose you have a chat application with multiple clients posting messages to different chat rooms. You can create feeds that subscribe to messages posted to a specific room:</source>
          <target state="translated">假设您有一个聊天应用程序,有多个客户端向不同的聊天室发布消息。您可以创建feed来订阅发布到特定房间的消息。</target>
        </trans-unit>
        <trans-unit id="4768ff13957450b6b322ffdb25a724ae46b0c89e" translate="yes" xml:space="preserve">
          <source>Suppose you want to retrieve all the posts whose date field is between January 1st, 2012 (included) and January 1st, 2013 (excluded). You could do:</source>
          <target state="translated">假设您想检索日期字段在2012年1月1日(包括)和2013年1月1日(不包括)之间的所有帖子。您可以这样做</target>
        </trans-unit>
        <trans-unit id="9216a7cff4538f532284ba814135bf0e53d98d0a" translate="yes" xml:space="preserve">
          <source>Suppose you wanted to paginate through a set of users, 25 at a time. You could get the first 25 records efficiently just with &lt;code&gt;limit&lt;/code&gt;.</source>
          <target state="translated">假设您想通过一组用户分页，一次25个。您可以有效地获得前25条记录，而且 &lt;code&gt;limit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95b01a971703b06e82b48250dccd360ac1fa7f30" translate="yes" xml:space="preserve">
          <source>Suppose you&amp;rsquo;d like to select all posts where the author&amp;rsquo;s name is &amp;ldquo;Michel&amp;rdquo; and the category is &amp;ldquo;Geek&amp;rdquo;. You can do it as follows:</source>
          <target state="translated">假设您要选择所有作者姓名为&amp;ldquo; Michel&amp;rdquo;且类别为&amp;ldquo; Geek&amp;rdquo;的帖子。您可以按照以下步骤进行操作：</target>
        </trans-unit>
        <trans-unit id="112ab020698e5fc0f4baecd7821a512d8c419a69" translate="yes" xml:space="preserve">
          <source>Swift</source>
          <target state="translated">Swift</target>
        </trans-unit>
        <trans-unit id="c7754a0126d0aaf46fbebc210b5eb50440b996eb" translate="yes" xml:space="preserve">
          <source>System current issues table</source>
          <target state="translated">系统当前问题表</target>
        </trans-unit>
        <trans-unit id="a79086ea99038c78fcb10e82dc0b55ccbabff535" translate="yes" xml:space="preserve">
          <source>System jobs table</source>
          <target state="translated">系统工作表</target>
        </trans-unit>
        <trans-unit id="53fde7d284da785ea8c756a4755a1cf1a647fc31" translate="yes" xml:space="preserve">
          <source>System statistics table</source>
          <target state="translated">系统统计表</target>
        </trans-unit>
        <trans-unit id="a79611699266ef0b5f43b2792f98671886bdc4f7" translate="yes" xml:space="preserve">
          <source>System tables</source>
          <target state="translated">系统表</target>
        </trans-unit>
        <trans-unit id="4722f1e7452b133171f8fe49038f80cb4d543dc4" translate="yes" xml:space="preserve">
          <source>TABLE and DATABASE manipulation</source>
          <target state="translated">TABLE和DATABASE的操作</target>
        </trans-unit>
        <trans-unit id="a8de37891fde68bb5a0ec54a33871e33ff0b04f7" translate="yes" xml:space="preserve">
          <source>TLS options</source>
          <target state="translated">TLS选项</target>
        </trans-unit>
        <trans-unit id="ffc959723a236b0cc6de0f357ad16f5a6da878a5" translate="yes" xml:space="preserve">
          <source>Table availability issues</source>
          <target state="translated">表的可用性问题</target>
        </trans-unit>
        <trans-unit id="d6bb93a216207f4b9e299da1815f37b802ab7b33" translate="yes" xml:space="preserve">
          <source>Table joins in RethinkDB</source>
          <target state="translated">RethinkDB中的表连接</target>
        </trans-unit>
        <trans-unit id="49276d64118baef926d34027bbab4e81079248fe" translate="yes" xml:space="preserve">
          <source>Tables will be available for writing when the command returns.</source>
          <target state="translated">当命令返回时,将有表可写。</target>
        </trans-unit>
        <trans-unit id="1d7222b89a2e8be0d6d59f735ee4900bd39725c7" translate="yes" xml:space="preserve">
          <source>Tables with unevenly distributed primary keys, such as incrementing integers</source>
          <target state="translated">主键分布不均的表,如增量整数表。</target>
        </trans-unit>
        <trans-unit id="3daa2b71e58a54876d28ede052b3a2e246f8ecd2" translate="yes" xml:space="preserve">
          <source>Take the &lt;code&gt;do&lt;/code&gt; command:</source>
          <target state="translated">采取 &lt;code&gt;do&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="38f1d76bf20f6fcdc6d187bbc76cd6436670d3f9" translate="yes" xml:space="preserve">
          <source>Take the function:</source>
          <target state="translated">以功能。</target>
        </trans-unit>
        <trans-unit id="cea65d922ed277d1704ab2878b724b53c61de751" translate="yes" xml:space="preserve">
          <source>Takes a grouped stream or grouped data and turns it into an array of objects representing the groups. Any commands chained after &lt;code&gt;ungroup&lt;/code&gt; will operate on this array, rather than operating on each group individually. This is useful if you want to e.g. order the groups by the value of their reduction.</source>
          <target state="translated">获取分组的流或分组的数据，并将其转换为代表组的对象数组。 &lt;code&gt;ungroup&lt;/code&gt; 后链接的任何命令都将在此阵列上运行，而不是分别对每个组进行操作。如果您要按组的减少值进行排序，这将很有用。</target>
        </trans-unit>
        <trans-unit id="5d5c093f525fdc79a9ecef536f2adf23e1bcd059" translate="yes" xml:space="preserve">
          <source>Takes a stream and partitions it into multiple groups based on the fields or functions provided.</source>
          <target state="translated">根据提供的字段或函数,将一个流划分为多个组。</target>
        </trans-unit>
        <trans-unit id="4be37be90bfccb09eab627d2a5d3f9b1c85287e5" translate="yes" xml:space="preserve">
          <source>Technical details</source>
          <target state="translated">技术细节</target>
        </trans-unit>
        <trans-unit id="b3009d114dbbdc48b07c50727c55f8923baa1735" translate="yes" xml:space="preserve">
          <source>Telling RethinkDB to use your certificate</source>
          <target state="translated">告诉RethinkDB使用你的证书。</target>
        </trans-unit>
        <trans-unit id="e86033a1c268fcd57c5544ec342f884426872fe2" translate="yes" xml:space="preserve">
          <source>Ten-minute guide</source>
          <target state="translated">10分钟指南</target>
        </trans-unit>
        <trans-unit id="62bdf5b0f1b1c7afa76df4a0ec827e816d32887c" translate="yes" xml:space="preserve">
          <source>Ten-minute guide with RethinkDB and JavaScript</source>
          <target state="translated">使用RethinkDB和JavaScript的十分钟指南</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="580faa9f93143659082ee75418784f7ed233bc25" translate="yes" xml:space="preserve">
          <source>Test if a sequence is empty.</source>
          <target state="translated">测试一个序列是否为空。</target>
        </trans-unit>
        <trans-unit id="2b712c0d5fab5555a5ee001f73a9eae6fd7e22ee" translate="yes" xml:space="preserve">
          <source>Test if an object has one or more fields. An object has a field if it has that key and the key has a non-null value. For instance, the object &lt;code&gt;{'a':1,'b':2,'c':null}&lt;/code&gt; has the fields &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">测试对象是否具有一个或多个字段。如果对象具有该键并且该键具有非空值，则该对象具有字段。例如，对象 &lt;code&gt;{'a':1,'b':2,'c':null}&lt;/code&gt; 具有字段 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4c77a6841ba72ffccbbcea87b18fbf2a42ef680" translate="yes" xml:space="preserve">
          <source>Test if two or more values are equal.</source>
          <target state="translated">测试两个或多个值是否相等。</target>
        </trans-unit>
        <trans-unit id="e87a117ac7aa25ab290c4818f470f3ebbcce0e19" translate="yes" xml:space="preserve">
          <source>Test if two or more values are not equal.</source>
          <target state="translated">测试两个或两个以上的值是否不相等。</target>
        </trans-unit>
        <trans-unit id="a5a0b0052fc126b71716d72a6f07f95c3595919b" translate="yes" xml:space="preserve">
          <source>Tests the response time for analytic MapReduce queries involving string operations</source>
          <target state="translated">测试涉及字符串操作的MapReduce分析查询的响应时间。</target>
        </trans-unit>
        <trans-unit id="bcb4d0c346b77ce8d2b0806c1febeba5bff03f3d" translate="yes" xml:space="preserve">
          <source>Tests whether a geometry object is completely contained within another. When applied to a sequence of geometry objects, &lt;code&gt;includes&lt;/code&gt; acts as a &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt;, returning a sequence of objects from the sequence that include the argument.</source>
          <target state="translated">测试几何对象是否完全包含在另一个对象中。当应用于一系列几何对象时， &lt;code&gt;includes&lt;/code&gt; 充当&lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt;，从包含参数的序列中返回一系列对象。</target>
        </trans-unit>
        <trans-unit id="32ad66b24a210fe5fb7c74854564c5c2404f940b" translate="yes" xml:space="preserve">
          <source>Tests whether a geometry object is completely contained within another. When applied to a sequence of geometry objects, &lt;code&gt;includes&lt;/code&gt; acts as a &lt;a href=&quot;filter/index&quot;&gt;filter&lt;/a&gt;, returning a sequence of objects from the sequence that include the argument.</source>
          <target state="translated">测试几何对象是否完全包含在另一个对象中。当应用于一系列几何对象时， &lt;code&gt;includes&lt;/code&gt; 充当&lt;a href=&quot;filter/index&quot;&gt;filter&lt;/a&gt;，从包含参数的序列中返回一系列对象。</target>
        </trans-unit>
        <trans-unit id="76bc89a4bdfcbe6b5eb162678644e978de9e8662" translate="yes" xml:space="preserve">
          <source>Tests whether two geometry objects intersect with one another. When applied to a sequence of geometry objects, &lt;code&gt;intersects&lt;/code&gt; acts as a &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt;, returning a sequence of objects from the sequence that intersect with the argument.</source>
          <target state="translated">测试两个几何对象是否相交。当应用于几何对象序列时， &lt;code&gt;intersects&lt;/code&gt; 充当&lt;a href=&quot;../filter/index&quot;&gt;过滤器&lt;/a&gt;，从与参数相交的序列中返回对象序列。</target>
        </trans-unit>
        <trans-unit id="4f96ec5473cb3c525e604de3ef69ef3872d90917" translate="yes" xml:space="preserve">
          <source>Tests whether two geometry objects intersect with one another. When applied to a sequence of geometry objects, &lt;code&gt;intersects&lt;/code&gt; acts as a &lt;a href=&quot;filter/index&quot;&gt;filter&lt;/a&gt;, returning a sequence of objects from the sequence that intersect with the argument.</source>
          <target state="translated">测试两个几何对象是否相交。当应用于几何对象序列时， &lt;code&gt;intersects&lt;/code&gt; 充当&lt;a href=&quot;filter/index&quot;&gt;过滤器&lt;/a&gt;，从与参数相交的序列中返回对象序列。</target>
        </trans-unit>
        <trans-unit id="8bf2f9529e3017d5406fa32ca8a2854fd68af8da" translate="yes" xml:space="preserve">
          <source>That will preserve &lt;code&gt;city&lt;/code&gt; and other existing fields. But to replace the entire &lt;code&gt;data&lt;/code&gt; document with a new object, use &lt;code&gt;literal&lt;/code&gt;.</source>
          <target state="translated">那将保留 &lt;code&gt;city&lt;/code&gt; 和其他现有领域。但要将整个 &lt;code&gt;data&lt;/code&gt; 文档替换为新对象，请使用 &lt;code&gt;literal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21ae0e5519ad676ec6cffc66040385b181bd25f7" translate="yes" xml:space="preserve">
          <source>The 8-byte unique query token</source>
          <target state="translated">8字节的唯一查询令牌</target>
        </trans-unit>
        <trans-unit id="d60bee9b6432ef97dc1ad43b46670489d6ce7524" translate="yes" xml:space="preserve">
          <source>The 8-byte unique query token the response corresponds to</source>
          <target state="translated">响应所对应的8个字节的唯一查询令牌。</target>
        </trans-unit>
        <trans-unit id="14e7b9dd7173a6825a4fbe67852ce2c6c8b61b25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;changes&lt;/a&gt; command API reference</source>
          <target state="translated">所述&lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;改变&lt;/a&gt;命令API参考</target>
        </trans-unit>
        <trans-unit id="b689a67f47be5478bbcb1a5da019f30befb69c45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../api/javascript/slice/index&quot;&gt;slice&lt;/a&gt; command returns a range from a given start value through but not including a given end value. This makes it easy to use as a &lt;code&gt;skip&lt;/code&gt;/&lt;code&gt;limit&lt;/code&gt; replacement: the start value is the first item to retrieve, and the end value is the first item plus the limit. To retrieve posts 11-20 from the database using &lt;code&gt;slice&lt;/code&gt;:</source>
          <target state="translated">的&lt;a href=&quot;../../../api/javascript/slice/index&quot;&gt;切片&lt;/a&gt;命令从一个给定的初始值通过，但不包括一个给定的最终值返回一个范围。这使得它很容易用作 &lt;code&gt;skip&lt;/code&gt; / &lt;code&gt;limit&lt;/code&gt; 替换：起始值是要检索的第一项，结束值是第一项加上限制。要使用 &lt;code&gt;slice&lt;/code&gt; 从数据库中检索帖子11-20 ：</target>
        </trans-unit>
        <trans-unit id="3fa14532ba532bad5e0a0fe4d1aafde94747bcac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;web UI&lt;/a&gt; (and the &lt;a href=&quot;../info/index&quot;&gt;info&lt;/a&gt; command) can be used to tell you when a table&amp;rsquo;s shards need to be rebalanced.</source>
          <target state="translated">该&lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;网页UI&lt;/a&gt;（和&lt;a href=&quot;../info/index&quot;&gt;信息&lt;/a&gt;命令），可以用来告诉你，当一个表的碎片需要重新平衡。</target>
        </trans-unit>
        <trans-unit id="0b88a496bd9a54b173bbc02e5f424502c1760079" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../docs/data-types/index&quot;&gt;data type&lt;/a&gt; of a primary key is usually a string (like a UUID) or a number, but it can also be a time, binary object, boolean or an array. Data types can be mixed in the primary key field, but all values must be unique. Using an array as a primary key causes the primary key to behave like a compound index; read the documentation on &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index#compound-indexes&quot;&gt;compound secondary indexes&lt;/a&gt; for more information, as it applies to primary keys as well. (Note that the primary index still only covers a single field, while compound secondary indexes can cover multiple fields in a single index.) Primary keys cannot be objects.</source>
          <target state="translated">主键的&lt;a href=&quot;../../../docs/data-types/index&quot;&gt;数据类型&lt;/a&gt;通常是字符串（如UUID）或数字，但也可以是时间，二进制对象，布尔值或数组。可以在主键字段中混合数据类型，但是所有值都必须唯一。使用数组作为主键会导致主键的行为类似于复合索引。请阅读有关&lt;a href=&quot;../../../docs/secondary-indexes/javascript/index#compound-indexes&quot;&gt;复合二级索引&lt;/a&gt;的文档，以了解更多信息，因为它也适用于主键。（请注意，主索引仍然仅覆盖单个字段，而复合二级索引可以覆盖单个索引中的多个字段。）主键不能是对象。</target>
        </trans-unit>
        <trans-unit id="eea447ec8762465807261e23874776e14f996671" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../api/javascript/filter/index&quot;&gt;filter&lt;/a&gt; operation is performed in parallel on each shard of the &lt;code&gt;users&lt;/code&gt; table.</source>
          <target state="translated">该&lt;a href=&quot;../../api/javascript/filter/index&quot;&gt;滤波器&lt;/a&gt;操作是在平行于的每个碎片进行 &lt;code&gt;users&lt;/code&gt; 表。</target>
        </trans-unit>
        <trans-unit id="175363b1926f54cd38dc31893d76c1b6b52b1f68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../cookbook/javascript/index&quot;&gt;cookbook section&lt;/a&gt; for common queries and example snippets.</source>
          <target state="translated">该&lt;a href=&quot;../cookbook/javascript/index&quot;&gt;食谱部分&lt;/a&gt;为常见的查询和示例代码片段。</target>
        </trans-unit>
        <trans-unit id="f2c42c7b4a58d5425ef38d8bc03d53c63ea6af30" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Publish-subscribe&quot;&gt;publish-subscribe pattern&lt;/a&gt; is a powerful way to decouple applications that need to communicate. RethinkDB &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; allow us to implement publish-subscribe with the database acting as a message exchange. We&amp;rsquo;ve built a small example library called &lt;a href=&quot;https://github.com/rethinkdb/example-pubsub/tree/master/javascript&quot;&gt;repubsub&lt;/a&gt; implementing the pattern for use in JavaScript applications.</source>
          <target state="translated">在&lt;a href=&quot;http://en.wikipedia.org/wiki/Publish-subscribe&quot;&gt;发布-订阅模式&lt;/a&gt;是解耦应用程序的强大方式，需要沟通。RethinkDB &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;允许我们使用数据库作为消息交换来实现发布-订阅。我们建立了一个名为&lt;a href=&quot;https://github.com/rethinkdb/example-pubsub/tree/master/javascript&quot;&gt;repubsub&lt;/a&gt;的小型示例库，实现了在JavaScript应用程序中使用的模式。</target>
        </trans-unit>
        <trans-unit id="d91058933c549ee7f1fa7e049d7f4cf89934dd2a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://nobrainer.io/&quot;&gt;NoBrainer documentation&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;http://nobrainer.io/&quot;&gt;NoBrainer文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c7d392cdc77f861f51667a3ca36284f5b8708f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/mfenniak/rethinkdb-net/graphs/contributors&quot;&gt;rethinkdb-net team&lt;/a&gt; (C#/.NET): &lt;a href=&quot;https://github.com/mfenniak/rethinkdb-net&quot;&gt;https://github.com/mfenniak/rethinkdb-net&lt;/a&gt;</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/mfenniak/rethinkdb-net/graphs/contributors&quot;&gt;rethinkdb网团队&lt;/a&gt;（C＃/。NET）：&lt;a href=&quot;https://github.com/mfenniak/rethinkdb-net&quot;&gt;https://github.com/mfenniak/rethinkdb-net&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="444bed1a060381b627b7444756e334ab88f212cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rethinkdb/YCSB/tree/a15e249d6b10147e615ddfaf03672bad35e85e7f&quot;&gt;RethinkDB port of YCSB&lt;/a&gt;</source>
          <target state="translated">该&lt;a href=&quot;https://github.com/rethinkdb/YCSB/tree/a15e249d6b10147e615ddfaf03672bad35e85e7f&quot;&gt;YCSB的RethinkDB端口&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a819fbe9a1937b1797d9c6a1ec035e0b9abad4d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb-example-sinatra-pastie&quot;&gt;Sinatra example application&lt;/a&gt; for a different style of a Ruby web app using RethinkDB.</source>
          <target state="translated">使用RethinkDB的另一种风格的Ruby Web应用&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb-example-sinatra-pastie&quot;&gt;程序&lt;/a&gt;的Sinatra示例应用程序。</target>
        </trans-unit>
        <trans-unit id="551d89155ea50718c64be4d84e790dfe4aa6d142" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://rethinkdb.com/api/python/rebalance&quot;&gt;rebalance&lt;/a&gt; command will rebalance table shards.</source>
          <target state="translated">在&lt;a href=&quot;https://rethinkdb.com/api/python/rebalance&quot;&gt;重新平衡&lt;/a&gt;命令将重新平衡表碎片。</target>
        </trans-unit>
        <trans-unit id="ebcc07dce1d9d2212f7f4ffb39f9574068495311" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;reconfigure&lt;/a&gt; command can change the values for &lt;code&gt;shards&lt;/code&gt; and &lt;code&gt;replicas&lt;/code&gt; for an existing table.</source>
          <target state="translated">所述&lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;重新配置&lt;/a&gt;命令可以更改值 &lt;code&gt;shards&lt;/code&gt; 和 &lt;code&gt;replicas&lt;/code&gt; 对现有的表。</target>
        </trans-unit>
        <trans-unit id="9ce883ec8777da2140767df9008bd415119ca86b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://rethinkdb.com/api/python/table_create&quot;&gt;table_create&lt;/a&gt; (or &lt;a href=&quot;../../api/javascript/table_create/index&quot;&gt;tableCreate&lt;/a&gt;) command can specify initial values for &lt;code&gt;shards&lt;/code&gt; and &lt;code&gt;replicas&lt;/code&gt;.</source>
          <target state="translated">所述&lt;a href=&quot;https://rethinkdb.com/api/python/table_create&quot;&gt;table_create&lt;/a&gt;（或&lt;a href=&quot;../../api/javascript/table_create/index&quot;&gt;tableCreate&lt;/a&gt;）命令可以指定初始值 &lt;code&gt;shards&lt;/code&gt; 和 &lt;code&gt;replicas&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6803c1ac084369b6f0438e238c22cc29c63583d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://rethinkdb.com/api/ruby&quot;&gt;ReQL API docs&lt;/a&gt; for information on RethinkDB commands.</source>
          <target state="translated">有关RethinkDB命令的信息的&lt;a href=&quot;https://rethinkdb.com/api/ruby&quot;&gt;ReQL API文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1bec986688114356ebaf7e0856bb503f1a7aaed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;()&lt;/code&gt; command also accepts integer arguments as array offsets, like the &lt;a href=&quot;../nth/index&quot;&gt;nth&lt;/a&gt; command.</source>
          <target state="translated">在 &lt;code&gt;()&lt;/code&gt; 命令也接受整数参数作为数组偏移，像的&lt;a href=&quot;../nth/index&quot;&gt;第n个&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="0035a462582333656fdc80527201e302fa8b879a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--bind&lt;/code&gt; option controls the default behavior for all RethinkDB ports. If it&amp;rsquo;s specified, the &lt;code&gt;--bind-http&lt;/code&gt;, &lt;code&gt;--bind-cluster&lt;/code&gt; and &lt;code&gt;--bind-driver&lt;/code&gt; options will override that behavior for a specific port. So:</source>
          <target state="translated">该 &lt;code&gt;--bind&lt;/code&gt; 选项控制所有RethinkDB端口的缺省行为。如果已指定，则 &lt;code&gt;--bind-http&lt;/code&gt; ，-- &lt;code&gt;--bind-cluster&lt;/code&gt; 和 &lt;code&gt;--bind-driver&lt;/code&gt; 选项将覆盖特定端口的该行为。所以：</target>
        </trans-unit>
        <trans-unit id="f34a64af8039dab4ccf4ac61fc48463c1783f86e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-r&lt;/code&gt; options are similar to other &lt;code&gt;rethinkdb&lt;/code&gt; options, specifying the cluster host and port (defaulting to &lt;code&gt;localhost:28015&lt;/code&gt;) and either a database or a table to rebuild. The &lt;code&gt;-n&lt;/code&gt; option specifies the number of rebuilds that will be performed concurrently (defaulting to 1).</source>
          <target state="translated">的 &lt;code&gt;-c&lt;/code&gt; 和 &lt;code&gt;-r&lt;/code&gt; 选项类似于其他 &lt;code&gt;rethinkdb&lt;/code&gt; 选项，指定群集主机和端口（默认为 &lt;code&gt;localhost:28015&lt;/code&gt; ）和数据库或一个表来重建。所述 &lt;code&gt;-n&lt;/code&gt; 选项指定将被同时进行重建的数（默认为1）。</target>
        </trans-unit>
        <trans-unit id="1fbb463da8944345c9e3056ecf777aa6bf848ac4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.conf&lt;/code&gt; file includes a number of options exclusively for the init script. The rest of the options are exactly the same as the ones that go on the command line to the RethinkDB server. For more details about these options run &lt;code&gt;rethinkdb help&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;.conf&lt;/code&gt; 文件包括一些专门为init脚本选项。其余选项与RethinkDB服务器的命令行上的选项完全相同。有关这些选项的更多详细信息，请运行 &lt;code&gt;rethinkdb help&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a6abd3a5fbe78c6d61d78af2204c22ef572c884" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; term is equivalent to the &lt;a href=&quot;https://rethinkdb.com/api/python/row&quot;&gt;row&lt;/a&gt; command in the official JavaScript and Python drivers. It&amp;rsquo;s useful for languages where anonymous functions are too verbose.</source>
          <target state="translated">该 &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; 期限相当于&lt;a href=&quot;https://rethinkdb.com/api/python/row&quot;&gt;排&lt;/a&gt;在官方的JavaScript和Python驱动程序命令。这对于匿名函数过于冗长的语言很有用。</target>
        </trans-unit>
        <trans-unit id="a39d2fb859670be092655eed63f6837d95943b3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Response&lt;/code&gt; object will have the following fields:</source>
          <target state="translated">该 &lt;code&gt;Response&lt;/code&gt; 对象将具有以下字段：</target>
        </trans-unit>
        <trans-unit id="7bc2e812e0c496d5d932fcb76cd7cce4a59cbee5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;add&lt;/code&gt; command can be called in either prefix or infix form; both forms are equivalent. Note that ReQL will not perform type coercion. You cannot, for example, &lt;code&gt;add&lt;/code&gt; a string and a number together.</source>
          <target state="translated">所述 &lt;code&gt;add&lt;/code&gt; 命令可以在任一前缀或缀形式被调用; 两种形式是等效的。请注意，ReQL将不执行类型强制。例如，您不能 &lt;code&gt;add&lt;/code&gt; 字符串和数字加在一起。</target>
        </trans-unit>
        <trans-unit id="e770bd3be8c4d7f1305a9eb98af4ed57229b1ce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;and&lt;/code&gt; command can be used as an infix operator after its first argument (&lt;code&gt;r.expr(true).and(false)&lt;/code&gt;) or given all of its arguments as parameters (&lt;code&gt;r.and(true,false)&lt;/code&gt;).</source>
          <target state="translated">的 &lt;code&gt;and&lt;/code&gt; 命令可作为中缀运算符的第一个参数（后 &lt;code&gt;r.expr(true).and(false)&lt;/code&gt; ）或给定它的所有参数作为参数（ &lt;code&gt;r.and(true,false)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ef981f82d6968bc5dd9c7afb548228c07b5c7260" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;authors&lt;/code&gt; table contains a document for each author. Each document contains information about the relevant author and a field &lt;code&gt;posts&lt;/code&gt; with an array of posts for that author. In this case the query to retrieve all authors with their posts is simple:</source>
          <target state="translated">该 &lt;code&gt;authors&lt;/code&gt; 表包含每个作者的文档。每个文档都包含有关相关作者的信息，以及包含该作者的一系列帖子的字段 &lt;code&gt;posts&lt;/code&gt; 。在这种情况下，检索具有其帖子的所有作者的查询很简单：</target>
        </trans-unit>
        <trans-unit id="91ad3b24d7068e67089ba95cdcdfb53d11c31611" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;between&lt;/code&gt; command works with secondary indexes on date fields, but will not work with unindexed date fields. To test whether a date value is between two other dates, use the &lt;a href=&quot;../during/index&quot;&gt;during&lt;/a&gt; command, not &lt;code&gt;between&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;between&lt;/code&gt; 与日期字段辅助索引命令工作，但不会没有索引的日期字段工作。要测试某个日期值是否在其他两个日期之间，请使用&lt;a href=&quot;../during/index&quot;&gt;after&lt;/a&gt;命令，而不要使用 &lt;code&gt;between&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="e6ed8d702f0da3117561443df7630dac12b3151f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind=all&lt;/code&gt; option is a security risk if your machine is open to the internet, and you should take steps to prevent unauthorized access. See the &lt;a href=&quot;../security/index&quot;&gt;security page&lt;/a&gt; for more details.</source>
          <target state="translated">该 &lt;code&gt;bind=all&lt;/code&gt; 选项是一个安全风险，如果您的机器是开放的互联网，你应该采取措施，以防止未经授权的访问。有关更多详细信息，请参见&lt;a href=&quot;../security/index&quot;&gt;安全性页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4e4783dc55f18018622aa7131000c8b4f0bf95e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;branch&lt;/code&gt; command takes 2n+1 arguments: pairs of conditional expressions and commands to be executed if the conditionals return any value but &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; (i.e., &amp;ldquo;truthy&amp;rdquo; values), with a final &amp;ldquo;else&amp;rdquo; command to be evaluated if all of the conditionals are &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;branch&lt;/code&gt; 命令采用2n + 1个参数：如果条件表达式返回任何值，但要执行对条件表达式和命令的 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt; （即，&amp;ldquo;truthy&amp;rdquo;值），用最后的&amp;ldquo;else&amp;rdquo;命令，如果所有的要被评估条件是 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27792a7b391552685c9bade24559d7d53432ae8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;calendar&lt;/code&gt; table inherits &lt;code&gt;read: true&lt;/code&gt; from the database level, but specifies &lt;code&gt;write: false&lt;/code&gt; to make the table ready-only for &lt;code&gt;notesapp&lt;/code&gt;. The &lt;code&gt;supervisor_only&lt;/code&gt; table overrides both read and write access. The &lt;code&gt;notesapp&lt;/code&gt; account has read and write access to all other tables in the &lt;code&gt;field_notes&lt;/code&gt; database, but no ability to create and drop indexes or change any table&amp;rsquo;s cluster configuration.</source>
          <target state="translated">该 &lt;code&gt;calendar&lt;/code&gt; 表秉承 &lt;code&gt;read: true&lt;/code&gt; 从数据库级别，但指定 &lt;code&gt;write: false&lt;/code&gt; 使表准备只为 &lt;code&gt;notesapp&lt;/code&gt; 。该 &lt;code&gt;supervisor_only&lt;/code&gt; 表覆盖读取和写入权限。该 &lt;code&gt;notesapp&lt;/code&gt; 帐户已经阅读并在所有其他表写访问 &lt;code&gt;field_notes&lt;/code&gt; 数据库，但没有创建和删除索引或更改任何表的集群配置的能力。</target>
        </trans-unit>
        <trans-unit id="0e991e5c86a7f1c8aeeaa978efd7dd967c0ddf10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ceil&lt;/code&gt; command can also be chained after an expression.</source>
          <target state="translated">的 &lt;code&gt;ceil&lt;/code&gt; 命令也可以表达后链式连接。</target>
        </trans-unit>
        <trans-unit id="a18180e46d884ec86288be9f1179b764c0543cf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;changes&lt;/code&gt; command returns a cursor (like the &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;filter&lt;/code&gt; commands do). You can iterate through its contents using ReQL. Unlike other cursors, the output of &lt;code&gt;changes&lt;/code&gt; is infinite: the cursor will block until more elements are available. Every time you make a change to the table or document the &lt;code&gt;changes&lt;/code&gt; feed is monitoring, a new object will be returned to the cursor. For example, if you insert a user &lt;code&gt;{id:1,name:Slava,age:31}&lt;/code&gt; into the &lt;code&gt;users&lt;/code&gt; table, RethinkDB will post this document to changefeeds subscribed to &lt;code&gt;users&lt;/code&gt;:</source>
          <target state="translated">的 &lt;code&gt;changes&lt;/code&gt; 命令返回一个光标（如 &lt;code&gt;table&lt;/code&gt; 或 &lt;code&gt;filter&lt;/code&gt; 的命令做）。您可以使用ReQL遍历其内容。与其他游标不同， &lt;code&gt;changes&lt;/code&gt; 的输出是无限的：游标将阻塞直到有更多元素可用。每次您对表进行更改或记录 &lt;code&gt;changes&lt;/code&gt; 供稿正在监视时，都会将一个新对象返回到游标。例如，如果您将用户 &lt;code&gt;{id:1,name:Slava,age:31}&lt;/code&gt; 插入到 &lt;code&gt;users&lt;/code&gt; 表中，则RethinkDB会将此文档发布到订阅给 &lt;code&gt;users&lt;/code&gt; changefeed中：</target>
        </trans-unit>
        <trans-unit id="c71ebc6710e993abe3e242cc002398d0e04115b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chmod&lt;/code&gt; for the two files should be 644 (&lt;code&gt;chmod 644 &amp;lt;file&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">这两个文件的 &lt;code&gt;chmod&lt;/code&gt; 应该为644（ &lt;code&gt;chmod 644 &amp;lt;file&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b1746e0f4ec2b3cbd9ee6e45b008169437cd2080" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; command can optionally take a callback, which will receive an error if one occurs, or return a promise which will be resolved when the connection is closed.</source>
          <target state="translated">在 &lt;code&gt;close&lt;/code&gt; 命令可任选地采取一个回调，其将接收到错误，如果发生一个，或者返回一个承诺当连接被关闭，这将得到解决。</target>
        </trans-unit>
        <trans-unit id="8de72741c99cbbd0f718cde70c80b9b736a0601d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cluster_config&lt;/code&gt; table contains only one row. Documents cannot be inserted into or deleted from this table.</source>
          <target state="translated">该 &lt;code&gt;cluster_config&lt;/code&gt; 表格只包含一行。无法将文档插入此表或从该表中删除。</target>
        </trans-unit>
        <trans-unit id="97a00f39b10088ac3fc7162f96d2aed96ec5e4cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config&lt;/code&gt; command is a shorthand way to access the &lt;code&gt;table_config&lt;/code&gt; or &lt;code&gt;db_config&lt;/code&gt;&lt;a href=&quot;../../../docs/system-tables/index#configuration-tables&quot;&gt;System tables&lt;/a&gt;. It will return the single row from the system that corresponds to the database or table configuration, as if &lt;a href=&quot;../get/index&quot;&gt;get&lt;/a&gt; had been called on the system table with the UUID of the database or table in question.</source>
          <target state="translated">该 &lt;code&gt;config&lt;/code&gt; 命令是一条捷径访问 &lt;code&gt;table_config&lt;/code&gt; 或 &lt;code&gt;db_config&lt;/code&gt; &lt;a href=&quot;../../../docs/system-tables/index#configuration-tables&quot;&gt;系统表&lt;/a&gt;。它将从系统返回与数据库或表配置相对应的单行，就像使用系统数据库或表的UUID在系统表上调用&lt;a href=&quot;../get/index&quot;&gt;get&lt;/a&gt;一样。</target>
        </trans-unit>
        <trans-unit id="f8da9493de79adac421fcb25c1f5650dc9b6547f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; command returns the size of the array.</source>
          <target state="translated">的 &lt;code&gt;count&lt;/code&gt; 命令返回该数组的大小。</target>
        </trans-unit>
        <trans-unit id="d848d8e92a343bd1e1ee7712c5160da92d5ac9ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; field is a Base64-encoded string of the binary object.</source>
          <target state="translated">的 &lt;code&gt;data&lt;/code&gt; 字段是二进制对象的Base64编码的字符串。</target>
        </trans-unit>
        <trans-unit id="ea8d1ca1b2a77edf32c2a4590df21ed431ecff04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;db&lt;/code&gt; command is optional. If it is not present in a query, the query will run against the default database for the connection, specified in the &lt;code&gt;db&lt;/code&gt; argument to &lt;a href=&quot;../connect/index&quot;&gt;connect&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;db&lt;/code&gt; 命令是可选的。如果查询中不存在该查询，则该查询将针对在 &lt;code&gt;db&lt;/code&gt; 参数中指定的&lt;a href=&quot;../connect/index&quot;&gt;connect&lt;/a&gt;的默认数据库运行。</target>
        </trans-unit>
        <trans-unit id="4ad37eacb273de6461d7f78364b2740a5284a171" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;distinct&lt;/code&gt; command can be called on any sequence or table with an index.</source>
          <target state="translated">该 &lt;code&gt;distinct&lt;/code&gt; 指令可以在任何序列或表与索引调用。</target>
        </trans-unit>
        <trans-unit id="cdbdf15e337cc4a8b690ca59921a9c3a8e7640aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;durability&lt;/code&gt; argument on writes is ignored for system tables.</source>
          <target state="translated">系统表将忽略写入时的 &lt;code&gt;durability&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="ea7c8b836aba9d6c0c4b7b00901b656aa824e964" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;durability&lt;/code&gt; setting for a table controls when writes are committed. In &lt;code&gt;hard&lt;/code&gt; durability mode, writes are committed to disk before acknowledgements are sent; in &lt;code&gt;soft&lt;/code&gt; mode, writes are acknowledged immediately upon receipt. The &lt;code&gt;soft&lt;/code&gt; mode is faster but slightly less resilient to failure.</source>
          <target state="translated">表的 &lt;code&gt;durability&lt;/code&gt; 设置控制何时提交写入。在 &lt;code&gt;hard&lt;/code&gt; 持久性模式下，在发送确认之前将写操作提交到磁盘。在 &lt;code&gt;soft&lt;/code&gt; 模式下，接收到写入后立即确认写入。该 &lt;code&gt;soft&lt;/code&gt; 模式是快，但稍显不足的弹性要失败的。</target>
        </trans-unit>
        <trans-unit id="e3a148d5481c3b62ef42c8cb3568f88ca4842c72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;em_run&lt;/code&gt; command returns a &lt;code&gt;QueryHandle&lt;/code&gt; instance. The &lt;code&gt;QueryHandle&lt;/code&gt; will be closed when all results have been received, or when EventMachine stops running. You can explicitly close it with the &lt;code&gt;close&lt;/code&gt; method.</source>
          <target state="translated">该 &lt;code&gt;em_run&lt;/code&gt; 命令返回 &lt;code&gt;QueryHandle&lt;/code&gt; 实例。该 &lt;code&gt;QueryHandle&lt;/code&gt; 当EventMachine的停止运行时，所有的结果已经收到将被关闭，或。您可以使用 &lt;code&gt;close&lt;/code&gt; 方法显式关闭它。</target>
        </trans-unit>
        <trans-unit id="e8854e7d74db852ed391856ffbb13339def8f064" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;emergencyRepair&lt;/code&gt; argument is effectively a different command; when it is specified, no other arguments to &lt;code&gt;reconfigure&lt;/code&gt; are allowed except for &lt;code&gt;dryRun&lt;/code&gt;. When it&amp;rsquo;s executed, each shard of the table is examined and classified into one of three categories:</source>
          <target state="translated">所述 &lt;code&gt;emergencyRepair&lt;/code&gt; 参数实际上是不同的命令; 当指定它时，除 &lt;code&gt;dryRun&lt;/code&gt; 之外，不允许其他 &lt;code&gt;reconfigure&lt;/code&gt; 参数。执行该表时，将检查表的每个分片并将其分为以下三类之一：</target>
        </trans-unit>
        <trans-unit id="ce8009e94a95dd349ffe642ad6a2659550bbd18c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;epoch_time&lt;/code&gt; field is a Unix timestamp, the number of seconds since January 1st, 1970, with millisecond precision. The &lt;code&gt;timezone&lt;/code&gt; field is a string in the format &lt;code&gt;[+-]HH:MM&lt;/code&gt;, indicating the offset from UTC. UTC is &lt;code&gt;+00:00&lt;/code&gt;; PST is &lt;code&gt;-08:00&lt;/code&gt;; and so on.</source>
          <target state="translated">该 &lt;code&gt;epoch_time&lt;/code&gt; 场是一个Unix时间戳，自1970年1月1日的秒数，精确到毫秒。的 &lt;code&gt;timezone&lt;/code&gt; 字段是格式的字符串 &lt;code&gt;[+-]HH:MM&lt;/code&gt; ，表示从UTC偏移。UTC是 &lt;code&gt;+00:00&lt;/code&gt; ; PST是 &lt;code&gt;-08:00&lt;/code&gt; ; 等等。</target>
        </trans-unit>
        <trans-unit id="dd58d2675dc0248d66b49c9c9903627922ec7a35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eq&lt;/code&gt; command returns &lt;code&gt;true&lt;/code&gt; if two values are equal (in this case, the field &lt;code&gt;name&lt;/code&gt; and the string &lt;code&gt;William Adama&lt;/code&gt;).</source>
          <target state="translated">该 &lt;code&gt;eq&lt;/code&gt; 命令返回 &lt;code&gt;true&lt;/code&gt; 如果两个值相等（在这种情况下，字段 &lt;code&gt;name&lt;/code&gt; 和字符串 &lt;code&gt;William Adama&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5aca7815d3874f89ac128aa8778fdf468fd56814" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;floor&lt;/code&gt; command can also be chained after an expression.</source>
          <target state="translated">该 &lt;code&gt;floor&lt;/code&gt; 命令也可以表达后链式连接。</target>
        </trans-unit>
        <trans-unit id="c2c1feeb5fb90500506597611ab61b06ab509f62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;function&lt;/code&gt; field is a binary object containing an opaque representation of the secondary index (including the &lt;code&gt;multi&lt;/code&gt; argument if specified). It can be passed as the second argument to &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt; to create a new index with the same function; see &lt;code&gt;indexCreate&lt;/code&gt; for more information.</source>
          <target state="translated">所述 &lt;code&gt;function&lt;/code&gt; 域是含有二级索引的不透明表示（包括一个二进制对象 &lt;code&gt;multi&lt;/code&gt; ，如果指定的参数）。可以将它作为第二个参数传递给&lt;a href=&quot;../index_create/index&quot;&gt;indexCreate，&lt;/a&gt;以创建具有相同功能的新索引；有关更多信息，请参见 &lt;code&gt;indexCreate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4946559a625e3e8a1a801b2936ef820db204b2d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grant&lt;/code&gt; command returns an object of the following form:</source>
          <target state="translated">的 &lt;code&gt;grant&lt;/code&gt; 命令返回以下形式的一个目的：</target>
        </trans-unit>
        <trans-unit id="0dc08e6a902a4c96c1bd71bf6dc00101fd253b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;granted&lt;/code&gt; field will always be &lt;code&gt;1&lt;/code&gt;, and the &lt;code&gt;permissions_changes&lt;/code&gt; list will have one object, describing the new permissions values and the old values they were changed from (which may be &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">被 &lt;code&gt;granted&lt;/code&gt; 字段将始终为 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;permissions_changes&lt;/code&gt; 列表将具有一个对象，该对象描述新的权限值和更改后的旧值（可能为 &lt;code&gt;null&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="80d81ca6649abafda23e1ea30713e22d76b2657a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gt&lt;/code&gt; command returns &lt;code&gt;true&lt;/code&gt; if a value is greater than the specified value (in this case, if the number of posts is greater than two).</source>
          <target state="translated">的 &lt;code&gt;gt&lt;/code&gt; 命令返回 &lt;code&gt;true&lt;/code&gt; ，如果一个值大于指定值的情况（在这种情况下，如果柱的数目大于二）。</target>
        </trans-unit>
        <trans-unit id="f3b0ff93f0028dedb7d088ecb0bfabd1b04c1ae2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;header&lt;/code&gt; field will be a parsed version of the header with fields lowercased, like so:</source>
          <target state="translated">该 &lt;code&gt;header&lt;/code&gt; 字段将与场头小写，像这样的分析版本：</target>
        </trans-unit>
        <trans-unit id="33748724c059e842b140ab3cebc0157906f31f2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;htpasswd&lt;/code&gt; tool will prompt for your new password.</source>
          <target state="translated">在 &lt;code&gt;htpasswd&lt;/code&gt; 的工具会提示输入您的新密码。</target>
        </trans-unit>
        <trans-unit id="9ab9c4300a5d1a171fddf197c761d335fc5e9a5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;includeStates&lt;/code&gt; optional argument to &lt;code&gt;changes&lt;/code&gt; allows you to receive extra &amp;ldquo;status&amp;rdquo; documents in changefeed streams. These can allow your application to distinguish between initial values returned at the start of a stream and subsequent changes. Read the &lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;changes&lt;/a&gt; API documentation for a full explanation and example.</source>
          <target state="translated">&lt;code&gt;changes&lt;/code&gt; 的 &lt;code&gt;includeStates&lt;/code&gt; 可选参数使您可以在changefeed流中接收额外的&amp;ldquo;状态&amp;rdquo;文档。这些可以使您的应用程序区分流开始时返回的初始值和后续更改。阅读&lt;a href=&quot;../../../api/javascript/changes/index&quot;&gt;更改&lt;/a&gt; API文档以获取完整的说明和示例。</target>
        </trans-unit>
        <trans-unit id="868052f78a577f27a08e87e2dc0bb1b9048f59fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;includeTypes&lt;/code&gt; optional argument adds a third field, &lt;code&gt;type&lt;/code&gt;, to each result sent. The string values for &lt;code&gt;type&lt;/code&gt; are largely self-explanatory:</source>
          <target state="translated">所述 &lt;code&gt;includeTypes&lt;/code&gt; 可选参数增加了一个第三字段， &lt;code&gt;type&lt;/code&gt; ，每个结果发送。 &lt;code&gt;type&lt;/code&gt; 的字符串值在很大程度上是不言自明的：</target>
        </trans-unit>
        <trans-unit id="8d6a2fe819501f70843ca93b461a8f2fab096d7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;includes&lt;/code&gt; command cannot take advantage of a geospatial &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;secondary index&lt;/a&gt;. If you&amp;rsquo;re working with large data sets, consider using an index and &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt; before &lt;code&gt;includes&lt;/code&gt; to narrow down the initial result set.</source>
          <target state="translated">的 &lt;code&gt;includes&lt;/code&gt; 命令不能取地理空间的优点&lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;二级索引&lt;/a&gt;。如果您使用的是大型数据集，请考虑使用索引和 &lt;code&gt;includes&lt;/code&gt; 之前的&lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt;来缩小初始结果集的范围。</target>
        </trans-unit>
        <trans-unit id="8b3a7d962ba66d9269511623889e1a2dd7b32c96" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; argument is mandatory. Optional arguments are:</source>
          <target state="translated">该 &lt;code&gt;index&lt;/code&gt; 的说法是强制性的。可选参数为：</target>
        </trans-unit>
        <trans-unit id="ad770288c26a5de2145131cdaacd5a9d83f4d136" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;index&lt;/code&gt; argument is mandatory. This command returns the same results as &lt;code&gt;table.filter(r.row('index').intersects(geometry))&lt;/code&gt;. The total number of results is limited to the array size limit which defaults to 100,000, but can be changed with the &lt;code&gt;arrayLimit&lt;/code&gt; option to &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt;.</source>
          <target state="translated">该 &lt;code&gt;index&lt;/code&gt; 的说法是强制性的。此命令返回与 &lt;code&gt;table.filter(r.row('index').intersects(geometry))&lt;/code&gt; 相同的结果。结果的总数限制为默认为100,000的数组大小限制，但可以使用 &lt;code&gt;arrayLimit&lt;/code&gt; 选项&lt;a href=&quot;../run/index&quot;&gt;运行&lt;/a&gt;来更改。</target>
        </trans-unit>
        <trans-unit id="cd743e36733d09c9da01000c0b88c5292d0cc3d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indexFunction&lt;/code&gt; can be an anonymous function or a binary representation obtained from the &lt;code&gt;function&lt;/code&gt; field of &lt;a href=&quot;../index_status/index&quot;&gt;indexStatus&lt;/a&gt;. The function must be deterministic, and so cannot use a subquery or the &lt;code&gt;r.js&lt;/code&gt; command.</source>
          <target state="translated">所述 &lt;code&gt;indexFunction&lt;/code&gt; 可以是匿名函数或从所获得的二进制表示 &lt;code&gt;function&lt;/code&gt; 的场&lt;a href=&quot;../index_status/index&quot;&gt;indexStatus&lt;/a&gt;。该函数必须是确定性的，因此不能使用子查询或 &lt;code&gt;r.js&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="b43ceb3b85c6c373b0ae4ee4be93296ef3fea882" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;insert&lt;/code&gt; command accepts a single document or an array of documents if you want to batch inserts. We use an array in this query instead of running three separate &lt;code&gt;insert&lt;/code&gt; commands for each document.</source>
          <target state="translated">如果要批量插入， &lt;code&gt;insert&lt;/code&gt; 命令接受单个文档或文档数组。我们在此查询中使用数组，而不是为每个文档运行三个单独的 &lt;code&gt;insert&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="d6621021a52f95d192cf8605e58bf7280b4c773c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intersects&lt;/code&gt; command cannot take advantage of a geospatial &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;secondary index&lt;/a&gt;. If you&amp;rsquo;re working with large data sets, you should consider using an index and the &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt; command instead of &lt;code&gt;intersects&lt;/code&gt;.</source>
          <target state="translated">所述 &lt;code&gt;intersects&lt;/code&gt; 命令不能取地理空间的优点&lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;二级索引&lt;/a&gt;。如果使用大型数据集，则应考虑使用索引和&lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt;命令而不是 &lt;code&gt;intersects&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4139db0f544e285139cf6c660044e153973d181" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jobs&lt;/code&gt; table provides information about tasks running within the RethinkDB cluster, including queries, disk compaction, and index construction, and allows you to kill query jobs by deleting them from the table. For details, read the &lt;a href=&quot;../system-jobs/index&quot;&gt;System jobs table&lt;/a&gt; documentation.</source>
          <target state="translated">该 &lt;code&gt;jobs&lt;/code&gt; 表提供了有关RethinkDB集群，包括查询，磁盘压缩和索引结构中运行任务的信息，并允许你从表中删除它们杀死查询工作。有关详细信息，请阅读&lt;a href=&quot;../system-jobs/index&quot;&gt;系统作业表&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="02ce76979f5d4e08895a24ed209616d935ad93fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lambda&lt;/code&gt; expression is executed only once on the client. Internally, the driver passes a special object to the &lt;code&gt;lambda&lt;/code&gt; function which allows constructing a representation of the query. This representation is then sent to the server over the network and evaluated on the cluster.</source>
          <target state="translated">将 &lt;code&gt;lambda&lt;/code&gt; 表达在客户端上仅执行一次。在内部，驱动程序将一个特殊对象传递给 &lt;code&gt;lambda&lt;/code&gt; 函数，该函数允许构造查询的表示形式。然后，该表示通过网络发送到服务器，并在群集上进行评估。</target>
        </trans-unit>
        <trans-unit id="8db687d26d281f53ab2937b362050f18086c0100" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;logs&lt;/code&gt; table supports changefeeds. Only messages being &lt;em&gt;written to the logs table&lt;/em&gt; will generate changefeed events.</source>
          <target state="translated">该 &lt;code&gt;logs&lt;/code&gt; 表支持changefeeds。只有&lt;em&gt;写入日志表的&lt;/em&gt;消息才会生成changefeed事件。</target>
        </trans-unit>
        <trans-unit id="747a7670afb696b207114aaef7ea26c0638477d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt; command does not support backreferences.</source>
          <target state="translated">在 &lt;code&gt;match&lt;/code&gt; 的命令不支持反向引用。</target>
        </trans-unit>
        <trans-unit id="7fecdd1e7503897b3b0389a10c6271bc84fd03f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max&lt;/code&gt; command can be called with:</source>
          <target state="translated">该 &lt;code&gt;max&lt;/code&gt; 命令可以调用：</target>
        </trans-unit>
        <trans-unit id="a61970042a7f09b4c61acb3dfc28139c2a94bdaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; command can be called with:</source>
          <target state="translated">该 &lt;code&gt;min&lt;/code&gt; 命令可以调用：</target>
        </trans-unit>
        <trans-unit id="b21b8958d38631f71f563c6d778bb5c3c1ffc323" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multi&lt;/code&gt; field will be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on whether this index was created as a multi index; the &lt;code&gt;geo&lt;/code&gt; field will be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; depending on whether this index was created as a geospatial index. See &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt; for details. The &lt;code&gt;outdated&lt;/code&gt; field will be true if the index is outdated in the current version of RethinkDB and needs to be rebuilt. The &lt;code&gt;progress&lt;/code&gt; field is a float between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, indicating how far along the server is in constructing indexes after the most recent change to the table that would affect them. (&lt;code&gt;0&lt;/code&gt; indicates no such indexes have been constructed; &lt;code&gt;1&lt;/code&gt; indicates all of them have.)</source>
          <target state="translated">在 &lt;code&gt;multi&lt;/code&gt; 场将是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt; 取决于这个指数是否为多指标创建的;在 &lt;code&gt;geo&lt;/code&gt; 领域将是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt; 取决于这个指数是否为地理空间索引创建的。有关详细信息，请参见&lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt;。该 &lt;code&gt;outdated&lt;/code&gt; ，如果该指数在RethinkDB的当前版本已经过时，需要重建领域将是真实的。该 &lt;code&gt;progress&lt;/code&gt; 字段之间的浮动 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; ，表明多远沿着服务器是在最近的变化会影响他们的表后构建索引。 （ &lt;code&gt;0&lt;/code&gt; 表示尚未构建此类索引； &lt;code&gt;1&lt;/code&gt; 表示所有人都有。）</target>
        </trans-unit>
        <trans-unit id="5593aa4baf9fd61785d48ac139c9d79b76a0b29f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; field, if present, will be an array of one or more &lt;code&gt;ResponseNote&lt;/code&gt; values, giving further information about the kind of the stream being returned. These will be numeric values, corresponding to the notes in &lt;code&gt;ql2.proto&lt;/code&gt;.</source>
          <target state="translated">的 &lt;code&gt;n&lt;/code&gt; 字段，如果存在的话，将是一种或多种的阵列 &lt;code&gt;ResponseNote&lt;/code&gt; 值，给出关于所返回的那种流的进一步的信息。这些将是数值，对应于 &lt;code&gt;ql2.proto&lt;/code&gt; 中的注释。</target>
        </trans-unit>
        <trans-unit id="233fb265ce401f5e6ef81eb6bf82b04d5b9bd910" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;or&lt;/code&gt; command can be used as an infix operator after its first argument (&lt;code&gt;r.expr(true).or(false)&lt;/code&gt;) or given all of its arguments as parameters (&lt;code&gt;r.or(true,false)&lt;/code&gt;).</source>
          <target state="translated">的 &lt;code&gt;or&lt;/code&gt; 命令可作为中缀运算符的第一个参数（后 &lt;code&gt;r.expr(true).or(false)&lt;/code&gt; ）或给定它的所有参数作为参数（ &lt;code&gt;r.or(true,false)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="86115daaac62e6d67b2f25326871b6408003fe0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;orderBy&lt;/code&gt; operation is performed on the query server.</source>
          <target state="translated">在 &lt;code&gt;orderBy&lt;/code&gt; 操作查询服务器上执行。</target>
        </trans-unit>
        <trans-unit id="0f69c272f5a8902ee9b15471e9f21b729c73065c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;page&lt;/code&gt; argument takes the type of pagination mechanism used by the API. In this case GitHub uses the standard link header mechanism &lt;code&gt;link-next&lt;/code&gt;, but you can also specify custom pagination schemes for unusual APIs. The &lt;code&gt;page-limit&lt;/code&gt; argument specifies the number of pages you&amp;rsquo;d like to get. See the &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;API reference&lt;/a&gt; for more details.</source>
          <target state="translated">该 &lt;code&gt;page&lt;/code&gt; 参数采用API使用的分页机制的类型。在这种情况下，GitHub使用标准的链接头机制 &lt;code&gt;link-next&lt;/code&gt; ，但是您也可以为不常见的API指定自定义分页方案。该 &lt;code&gt;page-limit&lt;/code&gt; 参数指定你想获得的页数。有关更多详细信息，请参见&lt;a href=&quot;../../api/javascript/http/index&quot;&gt;API参考&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="95bcd53724b946ca9ed7f295c7ce42629507b3c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;page&lt;/code&gt; function may return a string corresponding to the next URL to request, &lt;code&gt;null&lt;/code&gt; indicating that there is no more to get, or an object of the format:</source>
          <target state="translated">该 &lt;code&gt;page&lt;/code&gt; 功能可能会返回对应下一个URL请求字符串， &lt;code&gt;null&lt;/code&gt; 表示没有多拿，或者格式的对象：</target>
        </trans-unit>
        <trans-unit id="8eac2c2eafcc25e69c439c981a9a43c9505640b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;password&lt;/code&gt; field is simply a boolean indicating whether a password is set or not. There is no way to read a password from the database.</source>
          <target state="translated">该 &lt;code&gt;password&lt;/code&gt; 字段是简单地表示口令是否设置的布尔值。无法从数据库读取密码。</target>
        </trans-unit>
        <trans-unit id="9eb572facbb41488fe72b8fa9f65c8b6e60f804a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pluck&lt;/code&gt; command also supports selecting nested fields in a document. For example, suppose we&amp;rsquo;d like to select the fields &lt;code&gt;phone&lt;/code&gt; and &lt;code&gt;email&lt;/code&gt; from the following document:</source>
          <target state="translated">该 &lt;code&gt;pluck&lt;/code&gt; 命令还支持在文档中选择嵌套字段。例如，假设我们要从以下文档中选择 &lt;code&gt;phone&lt;/code&gt; 和 &lt;code&gt;email&lt;/code&gt; 字段：</target>
        </trans-unit>
        <trans-unit id="ded41df3cb008f7a94136d4d3d523c133ad429cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ql2.proto&lt;/code&gt; file is well-commented, showing arguments and output for each command.</source>
          <target state="translated">该 &lt;code&gt;ql2.proto&lt;/code&gt; 文件被良好注释，显示每个命令参数和输出。</target>
        </trans-unit>
        <trans-unit id="1cde22a6f27e7d9521847d08386006eb67987ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r.do()&lt;/code&gt; command is serialized with the &lt;code&gt;FUNCALL&lt;/code&gt; term.</source>
          <target state="translated">所述 &lt;code&gt;r.do()&lt;/code&gt; 命令被序列与 &lt;code&gt;FUNCALL&lt;/code&gt; 术语。</target>
        </trans-unit>
        <trans-unit id="2df58bc197cc0396ab3dc29565ebeae49124d81c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r.http&lt;/code&gt; command will issue a request to &lt;code&gt;www.google.com&lt;/code&gt; directly from the database and return a string with the source of Google&amp;rsquo;s homepage.</source>
          <target state="translated">该 &lt;code&gt;r.http&lt;/code&gt; 命令将发出一个请求 &lt;code&gt;www.google.com&lt;/code&gt; 直接从数据库中，并与谷歌的网页的源返回一个字符串。</target>
        </trans-unit>
        <trans-unit id="36decc9f51cb514925634d8bff79ad911b6257f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;config&lt;/code&gt; permissions can be specified on three scopes, from most granular to least:</source>
          <target state="translated">在 &lt;code&gt;read&lt;/code&gt; ， &lt;code&gt;write&lt;/code&gt; 和 &lt;code&gt;config&lt;/code&gt; 权限，可以在三个领域指定，从最精细到最：</target>
        </trans-unit>
        <trans-unit id="49b42e69bb9c54f130efd1a3ec27a3df710af6ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rebalance&lt;/code&gt; command operates by measuring the distribution of primary keys within a table and picking split points that will give each shard approximately the same number of documents. It won&amp;rsquo;t change the number of shards within a table, or change any other configuration aspect for the table or the database.</source>
          <target state="translated">该 &lt;code&gt;rebalance&lt;/code&gt; 命令通过测量表中主密钥的分配和拾取拆分点，这将使每个碎片近似相同数量的文档进行操作。它不会更改表中的分片数量，也不会更改表或数据库的任何其他配置方面。</target>
        </trans-unit>
        <trans-unit id="554d2dc3c9db959ecfadca51c84bf63b31fddb75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;replace&lt;/code&gt; command can be used to both insert and delete documents. If the &amp;ldquo;replaced&amp;rdquo; document has a primary key that doesn&amp;rsquo;t exist in the table, the document will be inserted; if an existing document is replaced with &lt;code&gt;null&lt;/code&gt;, the document will be deleted. Since &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; operations are performed atomically, this allows atomic inserts and deletes as well.</source>
          <target state="translated">该 &lt;code&gt;replace&lt;/code&gt; 命令可用于既插入和删除文件。如果&amp;ldquo;已替换&amp;rdquo;文档的主键在表中不存在，则将插入该文档；如果将现有文档替换为 &lt;code&gt;null&lt;/code&gt; ，则该文档将被删除。由于 &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;replace&lt;/code&gt; 操作是原子执行的，因此也允许原子插入和删除。</target>
        </trans-unit>
        <trans-unit id="69061fb9a85edfcdb4797cccceab5987fcbbd1bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restore&lt;/code&gt; subcommand has most of the the same options and defaults as the &lt;code&gt;dump&lt;/code&gt; command, although there are a few extra commands for controlling how data is imported.</source>
          <target state="translated">该 &lt;code&gt;restore&lt;/code&gt; 子有大部分相同的选项，默认为 &lt;code&gt;dump&lt;/code&gt; 命令，虽然有用于控制数据如何导入一些额外的命令。</target>
        </trans-unit>
        <trans-unit id="3732c751628619f7fe5223ea3a55cd9b025f5625" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;restore&lt;/code&gt; subcommand will reload a backup an archive into your cluster.</source>
          <target state="translated">在 &lt;code&gt;restore&lt;/code&gt; 子命令将重新加载备份存档到您的集群。</target>
        </trans-unit>
        <trans-unit id="5290e332ab7fca15808af2f086fca3b9fe419cf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rethinkdb&lt;/code&gt; utility includes an &lt;code&gt;import&lt;/code&gt; command to load existing data into RethinkDB databases. It can read JSON files, organized in one of two formats described below, or comma-separated value (CSV) files (including ones with other delimiters such as tab characters). The utility runs under the &lt;code&gt;admin&lt;/code&gt; user account (see &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;Permissions and user accounts&lt;/a&gt;).</source>
          <target state="translated">所述 &lt;code&gt;rethinkdb&lt;/code&gt; 实用程序包括一个 &lt;code&gt;import&lt;/code&gt; 命令现有数据加载到RethinkDB数据库。它可以读取以下述两种格式之一组织的JSON文件，或以逗号分隔的值（CSV）文件（包括带有其他定界符（例如制表符）的CSV文件）。该实用程序在 &lt;code&gt;admin&lt;/code&gt; 用户帐户下运行（请参阅&lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;权限和用户帐户&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="23ff9bbe25c8004989f8850322279724e1a217cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;round&lt;/code&gt; command can also be chained after an expression.</source>
          <target state="translated">该 &lt;code&gt;round&lt;/code&gt; 命令也可以表达后链式连接。</target>
        </trans-unit>
        <trans-unit id="be5dd85bcc132fcce01c6a0bdf9d6ad96e28c77c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rowProcess&lt;/code&gt; callback receives the row as its first argument; it may also take an optional second argument, which is a callback function to be executed after each row has been processed.</source>
          <target state="translated">所述 &lt;code&gt;rowProcess&lt;/code&gt; 回调接收行作为第一个参数; 它也可以使用可选的第二个参数，它是在处理完每一行之后要执行的回调函数。</target>
        </trans-unit>
        <trans-unit id="ab1dfcd0ac2e8005e1671ad7646473bea948e6f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;server&lt;/code&gt; command returns either two or three fields:</source>
          <target state="translated">该 &lt;code&gt;server&lt;/code&gt; 命令返回两个或三个字段：</target>
        </trans-unit>
        <trans-unit id="02c5611afbdf2371b84ac8989750ab9372b63d9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stats&lt;/code&gt; table provides statistics about server read/write throughput, client connections, and memory usage. For details, read the &lt;a href=&quot;../system-stats/index&quot;&gt;System stats table&lt;/a&gt; documentation.</source>
          <target state="translated">在 &lt;code&gt;stats&lt;/code&gt; 表提供了有关服务器的读/写吞吐量，客户端连接，和内存使用情况的统计数据。有关详细信息，请阅读&lt;a href=&quot;../system-stats/index&quot;&gt;系统统计信息表&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="dcbcbb3b476cec86770a7e8508c7d7f14fd0f096" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;table&lt;/code&gt; command returns a cursor; use the &lt;a href=&quot;../../../api/javascript/next/index&quot;&gt;next&lt;/a&gt; or &lt;a href=&quot;../../../api/javascript/each/index&quot;&gt;each&lt;/a&gt; command to iterate through the result set, or &lt;a href=&quot;../../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt; to retrieve the set as an array.</source>
          <target state="translated">该 &lt;code&gt;table&lt;/code&gt; 命令返回一个光标; 使用&lt;a href=&quot;../../../api/javascript/next/index&quot;&gt;下一个&lt;/a&gt;或&lt;a href=&quot;../../../api/javascript/each/index&quot;&gt;每个&lt;/a&gt;命令来遍历结果集，或使用&lt;a href=&quot;../../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt;将其作为数组检索。</target>
        </trans-unit>
        <trans-unit id="8555ee1c59461069384b1231faf6ed2e10256a2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;typeOf&lt;/code&gt; command can be appended to any ReQL command to display what data type that command will returns. For instance (in JavaScript):</source>
          <target state="translated">该 &lt;code&gt;typeOf&lt;/code&gt; 命令可以被附加到任何ReQL命令来显示什么数据键入命令将返回。例如（在JavaScript中）：</target>
        </trans-unit>
        <trans-unit id="e2c3fbf52c0a0225e096a3e3f50430c6f20043c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; command allows changing existing fields in the document, as well as values inside of arrays. Let&amp;rsquo;s suppose Star Trek archaeologists unearthed a new speech by Jean-Luc Picard that we&amp;rsquo;d like to add to his posts:</source>
          <target state="translated">的 &lt;code&gt;update&lt;/code&gt; 命令允许改变阵列内的文档中的现有字段，以及值。假设星际迷航的考古学家发掘了让&amp;middot;卢克&amp;middot;皮卡德（Jean-Luc Picard）的新演讲，我们想在他的帖子中添加以下内容：</target>
        </trans-unit>
        <trans-unit id="f5c71b707545ed0fdcaeabb3a5aac3886c06f220" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; command lets you to overwrite fields, but not delete them. If you want to delete a field, use the &lt;code&gt;replace&lt;/code&gt; command. The &lt;code&gt;replace&lt;/code&gt; command replaces your entire document with the new document you pass as an argument. For example, if you want to delete the field &lt;code&gt;author&lt;/code&gt; of the blog post with the id &lt;code&gt;1&lt;/code&gt;, you would use:</source>
          <target state="translated">使用 &lt;code&gt;update&lt;/code&gt; 命令可以覆盖字段，但不能删除它们。如果要删除字段，请使用 &lt;code&gt;replace&lt;/code&gt; 命令。在 &lt;code&gt;replace&lt;/code&gt; 命令替换您与您作为参数传递新文档整个文档。例如，如果要删除ID为 &lt;code&gt;1&lt;/code&gt; 的博客文章的字段 &lt;code&gt;author&lt;/code&gt; ，则可以使用：</target>
        </trans-unit>
        <trans-unit id="25a4c3fb12182407ba2e67e16e8bc153a3fc6a94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;update&lt;/code&gt; command supports RethinkDB&amp;rsquo;s &lt;a href=&quot;../../../docs/nested-fields/javascript/index&quot;&gt;nested field&lt;/a&gt; syntax to update subdocuments. Consider a user table with contact information in this format:</source>
          <target state="translated">该 &lt;code&gt;update&lt;/code&gt; 命令支持RethinkDB的&lt;a href=&quot;../../../docs/nested-fields/javascript/index&quot;&gt;嵌套场&lt;/a&gt;语法来更新的子文档。考虑具有以下格式的联系信息的用户表：</target>
        </trans-unit>
        <trans-unit id="9709ed7ac5a3ccdb5608327426c040efa46a575b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;users&lt;/code&gt; table contains one document for each user in the system, each with two key/value pairs: a unique &lt;code&gt;id&lt;/code&gt; and a &lt;code&gt;password&lt;/code&gt; field. The &lt;code&gt;id&lt;/code&gt; is the account name. The &lt;code&gt;password&lt;/code&gt; field behaves differently on writes than on reads; you can change an account&amp;rsquo;s password by writing a value to this field (or remove the password by writing &lt;code&gt;false&lt;/code&gt;), but the password cannot be read. Instead, on a read operation &lt;code&gt;password&lt;/code&gt; will be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, indicating whether the account has a password or not.</source>
          <target state="translated">在 &lt;code&gt;users&lt;/code&gt; 表包含系统中的每个用户一个文件，每一个有两个键/值对：一个唯一的 &lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;password&lt;/code&gt; 字段。该 &lt;code&gt;id&lt;/code&gt; 是帐户名称。在 &lt;code&gt;password&lt;/code&gt; 领域表现不同上比读写操作; 您可以通过在此字段中写入值来更改帐户的密码（或通过写入 &lt;code&gt;false&lt;/code&gt; 来删除密码），但是无法读取密码。取而代之的是，在读取操作时， &lt;code&gt;password&lt;/code&gt; 将为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ，指示该帐户是否具有密码。</target>
        </trans-unit>
        <trans-unit id="01c8bf644a4f9030d7ad2577d422c0cd9a38c6cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wait&lt;/code&gt; command takes two optional arguments:</source>
          <target state="translated">在 &lt;code&gt;wait&lt;/code&gt; 命令有两个可选参数：</target>
        </trans-unit>
        <trans-unit id="e2eaaabe02ee4500dead731d18d5ec0e845f4d2e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;map&lt;/strong&gt; step from above.</source>
          <target state="translated">从上面的&lt;strong&gt;地图&lt;/strong&gt;步骤。</target>
        </trans-unit>
        <trans-unit id="2889c83235362d653b025be4c1c424ba1ce7d91e" translate="yes" xml:space="preserve">
          <source>The CSV delimiter defaults to the comma, but this can be overridden with the &lt;code&gt;--delimiter&lt;/code&gt; option. Use &lt;code&gt;--delimiter '\t'&lt;/code&gt; for a tab-delimited file.</source>
          <target state="translated">CSV分隔符默认为逗号，但是可以使用 &lt;code&gt;--delimiter&lt;/code&gt; 选项覆盖。对于制表符分隔的文件，请使用 &lt;code&gt;--delimiter '\t'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c6c8ae6aa468752854d01d185af510f328007df" translate="yes" xml:space="preserve">
          <source>The Data Explorer in the web administration UI is itself a JavaScript REPL, with syntax highlighting and history. (The article on &lt;a href=&quot;../reql-data-exploration/index&quot;&gt;ReQL data exploration&lt;/a&gt; goes into some detail on how to use the Data Explorer.) The advantage of scripting languages with ReQL comes into play when writing administration scripts.</source>
          <target state="translated">Web管理UI中的Data Explorer本身就是JavaScript REPL，具有语法突出显示和历史记录。（有关&lt;a href=&quot;../reql-data-exploration/index&quot;&gt;ReQL数据探索&lt;/a&gt;的文章详细介绍了如何使用Data Explorer。）编写管理脚本时，发挥ReQL脚本语言的优势。</target>
        </trans-unit>
        <trans-unit id="2921a82497eb6c2b10a8bb44faddbdf034525af2" translate="yes" xml:space="preserve">
          <source>The Data Explorer will return information about the inserted rows.</source>
          <target state="translated">数据资源管理器将返回有关插入的行的信息。</target>
        </trans-unit>
        <trans-unit id="17f8232887e712c610ded4c3b1ca09822b2f7852" translate="yes" xml:space="preserve">
          <source>The JSON-encoded &lt;code&gt;Response&lt;/code&gt; object</source>
          <target state="translated">JSON编码的 &lt;code&gt;Response&lt;/code&gt; 对象</target>
        </trans-unit>
        <trans-unit id="ae581c711fdded915ec6331d2e6201dc801ce45f" translate="yes" xml:space="preserve">
          <source>The JSON-encoded response</source>
          <target state="translated">JSON编码的响应</target>
        </trans-unit>
        <trans-unit id="401226b470a193230b4f51fd65ea09e28b5975e5" translate="yes" xml:space="preserve">
          <source>The JavaScript and Python drivers support a convenience command, &lt;code&gt;row()&lt;/code&gt;, which simply returns the currently selected document for use with other ReQL functions in the query. However, &lt;code&gt;row&lt;/code&gt; won&amp;rsquo;t work within nested queries. The solution to this error is to rewrite the &lt;code&gt;row&lt;/code&gt; clause as an anonymous function. So the following:</source>
          <target state="translated">JavaScript和Python驱动程序支持便捷命令 &lt;code&gt;row()&lt;/code&gt; ，该命令仅返回当前选择的文档以与查询中的其他ReQL函数一起使用。但是， &lt;code&gt;row&lt;/code&gt; 不能在嵌套查询中使用。解决此错误的方法是将 &lt;code&gt;row&lt;/code&gt; 子句重写为匿名函数。因此，以下内容：</target>
        </trans-unit>
        <trans-unit id="d93cb88766b967f3d6c02e56c626c06eefa41694" translate="yes" xml:space="preserve">
          <source>The JavaScript driver currently works with Node.js versions 0.10.0 and above. You can check your node version as follows:</source>
          <target state="translated">该JavaScript驱动目前适用于Node.js 0.10.0及以上版本。你可以通过以下方式检查你的node版本。</target>
        </trans-unit>
        <trans-unit id="e74f35f90936d1e818634cc6a9b8cc53ac18e27c" translate="yes" xml:space="preserve">
          <source>The NoBrainer generator automatically includes the &lt;a href=&quot;http://nobrainer.io/docs/timestamps&quot;&gt;TimeStamps&lt;/a&gt; mixin that adds the fields &lt;code&gt;created_on&lt;/code&gt; and &lt;code&gt;updated_on&lt;/code&gt;. You&amp;rsquo;ll also notice this created a simple secondary index on the &lt;code&gt;name&lt;/code&gt; field. In order to add the index to the database, you can use the Rake task:</source>
          <target state="translated">NoBrainer生成器会自动包含&lt;a href=&quot;http://nobrainer.io/docs/timestamps&quot;&gt;TimeStamps&lt;/a&gt;混入，该混入会添加字段 &lt;code&gt;created_on&lt;/code&gt; 和 &lt;code&gt;updated_on&lt;/code&gt; 。您还会注意到，这在 &lt;code&gt;name&lt;/code&gt; 字段上创建了一个简单的二级索引。为了将索引添加到数据库，您可以使用Rake任务：</target>
        </trans-unit>
        <trans-unit id="f78507d39aba2403ee6f13a4ffbdf2b02ac49261" translate="yes" xml:space="preserve">
          <source>The ReQL &lt;a href=&quot;../../api/javascript/grant/index&quot;&gt;grant&lt;/a&gt; command is used to grant and revoke permissions for users. The scope is selected by chaining &lt;code&gt;grant&lt;/code&gt; after &lt;code&gt;db&lt;/code&gt; (for database scope), &lt;code&gt;table&lt;/code&gt; (for table scope), or calling it directly (for global scope).</source>
          <target state="translated">ReQL &lt;a href=&quot;../../api/javascript/grant/index&quot;&gt;grant&lt;/a&gt;命令用于为用户授予和撤消权限。通过在 &lt;code&gt;db&lt;/code&gt; （对于数据库范围）， &lt;code&gt;table&lt;/code&gt; （对于表范围）或直接调用它（对于全局范围）之后链接 &lt;code&gt;grant&lt;/code&gt; 来选择作用域。</target>
        </trans-unit>
        <trans-unit id="3deef836c1824d07b0b55b81f06b31f6cc374b4d" translate="yes" xml:space="preserve">
          <source>The RethinkDB AMI is preconfigured with the following options:</source>
          <target state="translated">RethinkDB AMI预先配置了以下选项。</target>
        </trans-unit>
        <trans-unit id="f68f0cac323d8bd865cffdbd7126de4c860b2528" translate="yes" xml:space="preserve">
          <source>The RethinkDB Python driver integrates with both the &lt;a href=&quot;http://www.tornadoweb.org/&quot;&gt;Tornado web framework&lt;/a&gt; and the &lt;a href=&quot;http://twistedmatrix.com/&quot;&gt;Twisted networking engine&lt;/a&gt;. By using the &lt;a href=&quot;https://rethinkdb.com/api/python/set_loop_type&quot;&gt;set_loop_type&lt;/a&gt; command, you can select either the &lt;code&gt;'tornado'&lt;/code&gt; or &lt;code&gt;'twisted'&lt;/code&gt; event loop model, returning Tornado &lt;code&gt;Future&lt;/code&gt; objects or Twisted &lt;code&gt;Deferred&lt;/code&gt; objects respectively.</source>
          <target state="translated">RethinkDB Python驱动程序与&lt;a href=&quot;http://www.tornadoweb.org/&quot;&gt;Tornado Web框架&lt;/a&gt;和&lt;a href=&quot;http://twistedmatrix.com/&quot;&gt;Twisted网络引擎&lt;/a&gt;集成在一起。通过使用&lt;a href=&quot;https://rethinkdb.com/api/python/set_loop_type&quot;&gt;set_loop_type&lt;/a&gt;命令，您可以选择 &lt;code&gt;'tornado'&lt;/code&gt; 或 &lt;code&gt;'twisted'&lt;/code&gt; 事件循环模型，分别返回&amp;ldquo; Tornado &lt;code&gt;Future&lt;/code&gt; &amp;rdquo;对象或&amp;ldquo; Twisted &lt;code&gt;Deferred&lt;/code&gt; &amp;rdquo;对象。</target>
        </trans-unit>
        <trans-unit id="d1887d58aefbe9cd201c7569b6def6f9b46a2192" translate="yes" xml:space="preserve">
          <source>The RethinkDB Ruby driver adds a new ReQL command, &lt;a href=&quot;https://rethinkdb.com/api/ruby/em_run&quot;&gt;em_run&lt;/a&gt;, designed to work with &lt;a href=&quot;http://rubyeventmachine.com&quot;&gt;EventMachine&lt;/a&gt;. In addition, it provides a superclass, &lt;code&gt;RethinkDB::Handler&lt;/code&gt;, with event-specific methods (e.g., &lt;code&gt;on_open&lt;/code&gt;, &lt;code&gt;on_close&lt;/code&gt;) that may be overridden by a class your application defines and passes to &lt;code&gt;em_run&lt;/code&gt;.</source>
          <target state="translated">RethinkDB Ruby驱动程序添加了一个新的ReQL命令&lt;a href=&quot;https://rethinkdb.com/api/ruby/em_run&quot;&gt;em_run&lt;/a&gt;，旨在与&lt;a href=&quot;http://rubyeventmachine.com&quot;&gt;EventMachine&lt;/a&gt;一起使用。另外，它提供了超类 &lt;code&gt;RethinkDB::Handler&lt;/code&gt; ，它具有事件特定的方法（例如 &lt;code&gt;on_open&lt;/code&gt; ， &lt;code&gt;on_close&lt;/code&gt; ），这些方法可能会被您的应用程序定义的类覆盖并传递给 &lt;code&gt;em_run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb928e983992a16cf85ee7c757c4a76ce7b98a95" translate="yes" xml:space="preserve">
          <source>The RethinkDB command line utility allows you to easily take hot backups on a live cluster with the &lt;code&gt;dump&lt;/code&gt; and &lt;code&gt;restore&lt;/code&gt; subcommands. The utility runs under the &lt;code&gt;admin&lt;/code&gt; user account (see &lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;Permissions and user accounts&lt;/a&gt;).</source>
          <target state="translated">RethinkDB命令行实用程序使您可以使用 &lt;code&gt;dump&lt;/code&gt; 和 &lt;code&gt;restore&lt;/code&gt; 子命令轻松地在活动群集上进行热备份。该实用程序在 &lt;code&gt;admin&lt;/code&gt; 用户帐户下运行（请参阅&lt;a href=&quot;../permissions-and-accounts/index&quot;&gt;权限和用户帐户&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="56cccb51dd81c41e2a73448104ab42e75c1bf07f" translate="yes" xml:space="preserve">
          <source>The Tables</source>
          <target state="translated">表格</target>
        </trans-unit>
        <trans-unit id="b73116bcd937f8234ed2fae850b17a96ef62cc32" translate="yes" xml:space="preserve">
          <source>The above structure is functionally identical to:</source>
          <target state="translated">上述结构在功能上与:</target>
        </trans-unit>
        <trans-unit id="7be08bdb688785dbc0b51a07a4d14e27d4297a6f" translate="yes" xml:space="preserve">
          <source>The admin account</source>
          <target state="translated">管理账户</target>
        </trans-unit>
        <trans-unit id="bd4b50bb6475112f6456711fd2e86904fd04ed69" translate="yes" xml:space="preserve">
          <source>The admin user</source>
          <target state="translated">管理员用户</target>
        </trans-unit>
        <trans-unit id="c49266cd9dfe06ccf934b0d6a03045039f4b9596" translate="yes" xml:space="preserve">
          <source>The asynchronous database API allows you to handle multiple changefeeds simultaneously by running multiple background tasks. As an example, consider this changefeed handler:</source>
          <target state="translated">异步数据库 API 允许您通过运行多个后台任务来同时处理多个 changefeed。作为一个例子,考虑一下这个改变馈送处理程序。</target>
        </trans-unit>
        <trans-unit id="74d2dd939eb0d6439399f983d97cb288040a44ea" translate="yes" xml:space="preserve">
          <source>The asynchronous database API allows you to handle multiple changefeeds simultaneously by scheduling background coroutines. As an example, consider this changefeed handler:</source>
          <target state="translated">异步数据库API允许你通过调度后台的coroutine来同时处理多个changefeed。作为一个例子,考虑一下这个改变馈送处理程序。</target>
        </trans-unit>
        <trans-unit id="519ebcd651eb55bc4130940c4263b3c1d13577fa" translate="yes" xml:space="preserve">
          <source>The automatically chosen cache size ensures a reliable operation in most scenarios, but the cache size can be tuned manually to accommodate increased memory usage by other processes or to maximize query performance. A larger cache improves the database&amp;rsquo;s performance, but you must consider other sources of memory consumption to avoid out of memory conditions.</source>
          <target state="translated">自动选择的缓存大小可确保在大多数情况下可靠的操作，但是可以手动调整缓存大小，以适应其他进程增加的内存使用或最大化查询性能。较大的缓存可以提高数据库的性能，但是必须考虑其他内存消耗源，以避免内存不足的情况。</target>
        </trans-unit>
        <trans-unit id="01e374f6277f44b97e1222377bc67dde6a9c6976" translate="yes" xml:space="preserve">
          <source>The backtrace from the crash, if it&amp;rsquo;s available in the logs.</source>
          <target state="translated">崩溃的回溯（如果在日志中可用）。</target>
        </trans-unit>
        <trans-unit id="713ad2f29426066c8fb98399dc92a553f0434ed4" translate="yes" xml:space="preserve">
          <source>The basic rule is:</source>
          <target state="translated">基本规则是:</target>
        </trans-unit>
        <trans-unit id="a4675c5be848d511ac96d9c2063be8e951d3254f" translate="yes" xml:space="preserve">
          <source>The basic setup is complete&amp;mdash;&lt;strong&gt;you&amp;rsquo;ve now got a working server!&lt;/strong&gt;</source>
          <target state="translated">基本设置已完成- &lt;strong&gt;现在，您已经有了可以使用的服务器！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa6fd40233d0f51b4739f7f3b630ae6b5e237c7d" translate="yes" xml:space="preserve">
          <source>The best way to secure a RethinkDB cluster is to run it on a protected network that doesn&amp;rsquo;t allow access from the outside world. However, this may not always be feasible. For example, cloud deployments often require access from wide area networks.</source>
          <target state="translated">保护RethinkDB群集的最佳方法是在不允许外界访问的受保护网络上运行它。但是，这可能并不总是可行的。例如，云部署通常需要从广域网进行访问。</target>
        </trans-unit>
        <trans-unit id="8a6a0b311a15c9d3de4c39c35a42e039d165be26" translate="yes" xml:space="preserve">
          <source>The body of every &lt;a href=&quot;../filter/index&quot;&gt;filter&lt;/a&gt; is wrapped in an implicit &lt;code&gt;.default(false)&lt;/code&gt;. You can overwrite the value &lt;code&gt;false&lt;/code&gt; with the &lt;code&gt;default&lt;/code&gt; option.</source>
          <target state="translated">每个&lt;a href=&quot;../filter/index&quot;&gt;过滤器&lt;/a&gt;的主体都包装在一个隐式 &lt;code&gt;.default(false)&lt;/code&gt; 中。您可以使用 &lt;code&gt;default&lt;/code&gt; 选项覆盖值 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe5a7c4ac68bb0098f4c7acbfa8d3521ed65b4f3" translate="yes" xml:space="preserve">
          <source>The calls above only return a few dozen stargazers while RethinkDB has thousands. Most APIs paginate large result sets and GitHub is no exception. The &lt;code&gt;r.http&lt;/code&gt; command has built-in support for pagination via the &lt;code&gt;page&lt;/code&gt; and &lt;code&gt;pageLimit&lt;/code&gt; arguments. Let&amp;rsquo;s get ten pages of stargazers from GitHub instead of one:</source>
          <target state="translated">上面的调用只返回几十个观星者，而RethinkDB有数千个。大多数API分页显示大型结果集，而GitHub也不例外。该 &lt;code&gt;r.http&lt;/code&gt; 命令已经内置了对通过支持分页 &lt;code&gt;page&lt;/code&gt; 和 &lt;code&gt;pageLimit&lt;/code&gt; 参数。让我们从GitHub获得十个观星者页面，而不是一个：</target>
        </trans-unit>
        <trans-unit id="c66da8d1fa6ce80f3799528d078f5270ec96090d" translate="yes" xml:space="preserve">
          <source>The center may be specified either by two floating point numbers, the latitude (&amp;minus;90 to 90) and longitude (&amp;minus;180 to 180) of the point on a perfect sphere (see &lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;Geospatial support&lt;/a&gt; for more information on ReQL&amp;rsquo;s coordinate system), or by a point object. The radius is a floating point number whose units are meters by default, although that may be changed with the &lt;code&gt;unit&lt;/code&gt; argument.</source>
          <target state="translated">中心可以由两个浮点数指定，即完美球体上的点的纬度（-90到90）和经度（-180到180）（有关ReQL坐标系的更多信息，请参见&lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;地理空间支持&lt;/a&gt;），或通过点对象。半径是一个浮点数，默认情况下单位为米，尽管可以通过 &lt;code&gt;unit&lt;/code&gt; 参数更改。</target>
        </trans-unit>
        <trans-unit id="e51cfd64d4a242d067b7d8103f85064dab48e6f1" translate="yes" xml:space="preserve">
          <source>The classic chat with Node.js.</source>
          <target state="translated">Node.js的经典聊天方式。</target>
        </trans-unit>
        <trans-unit id="4a08ba537a6bb6b6e0207beb1bd8c225b336d162" translate="yes" xml:space="preserve">
          <source>The client drivers do a lot of work to inspect the code and convert it to an efficient ReQL query that will be executed on the server:</source>
          <target state="translated">客户端驱动程序做了很多工作来检查代码,并将其转换为将在服务器上执行的高效ReQL查询。</target>
        </trans-unit>
        <trans-unit id="fd0e48d480584e226bdbfe1b39b400ad644d5c44" translate="yes" xml:space="preserve">
          <source>The client sends the &amp;ldquo;magic number&amp;rdquo; (&lt;code&gt;0x34c2bdc3&lt;/code&gt;) for the protocol version, as a 32-bit little-endian integer (4 bytes).</source>
          <target state="translated">客户端将协议版本的&amp;ldquo;幻数&amp;rdquo;（ &lt;code&gt;0x34c2bdc3&lt;/code&gt; ）发送为32位的Little-endian整数（4个字节）。</target>
        </trans-unit>
        <trans-unit id="a0cfe67e46bd1330804a94bb469638f0249ededc" translate="yes" xml:space="preserve">
          <source>The client sends the null-terminated JSON &amp;ldquo;client-final-message&amp;rdquo; with the same nonce and the ClientProof computed as specified by the RFC.</source>
          <target state="translated">客户端发送以NULL结尾的JSON&amp;ldquo; client-final-message&amp;rdquo;，带有相同的现时值和由RFC指定的ClientProof。</target>
        </trans-unit>
        <trans-unit id="02a49fdc9855f3f674aee23d74d2e1ea07fdd5ec" translate="yes" xml:space="preserve">
          <source>The client sends the protocol version, authentication method, and authentication as a null-terminated JSON response. RethinkDB currently supports only one authentication method, &lt;code&gt;SCRAM-SHA-256&lt;/code&gt;, as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;IETF RFC 7677&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc5802&quot;&gt;RFC 5802&lt;/a&gt;. The RFC is followed with the exception of error handling (RethinkDB uses its own higher level error reporting rather than the &lt;code&gt;e=&lt;/code&gt; field). RethinkDB does not support channel binding and clients should not request this. The value of &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; is the &amp;ldquo;client-first-message&amp;rdquo; specified in RFC 5802 (the channel binding flag, optional SASL authorization identity, username (&lt;code&gt;n=&lt;/code&gt;), and random nonce (&lt;code&gt;r=&lt;/code&gt;).</source>
          <target state="translated">客户端发送协议版本，身份验证方法和身份验证作为以空值结尾的JSON响应。根据&lt;a href=&quot;https://tools.ietf.org/html/rfc7677&quot;&gt;IETF RFC 7677&lt;/a&gt;和&lt;a href=&quot;https://tools.ietf.org/html/rfc5802&quot;&gt;RFC 5802的&lt;/a&gt;规定，RethinkDB当前仅支持一种身份验证方法 &lt;code&gt;SCRAM-SHA-256&lt;/code&gt; 。遵循RFC的规则是错误处理（RethinkDB使用其自己的更高级别的错误报告而不是 &lt;code&gt;e=&lt;/code&gt; 字段）。 RethinkDB不支持通道绑定，客户端不应请求此功能。 &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; 的值是RFC 5802中指定的&amp;ldquo; client-first-message&amp;rdquo;（客户端优先消息）（通道绑定标志，可选的SASL授权身份，用户名（ &lt;code&gt;n=&lt;/code&gt; ）和随机随机数（ &lt;code&gt;r=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0a84a6d65e8a3295aa13f3589f630b727d114e51" translate="yes" xml:space="preserve">
          <source>The cluster configuration is &lt;em&gt;not&lt;/em&gt; exported in backup. After a full restore, it will need to be manually reconfigured.</source>
          <target state="translated">群集配置&lt;em&gt;不会&lt;/em&gt;导出到备份中。完全还原后，将需要对其进行手动重新配置。</target>
        </trans-unit>
        <trans-unit id="3780ae988b6b36953e49487d4455ef2b6bdb38c3" translate="yes" xml:space="preserve">
          <source>The cluster must have three or more servers</source>
          <target state="translated">集群必须有三个或更多的服务器</target>
        </trans-unit>
        <trans-unit id="632b0a977c5ac1169440868320737c67d0be367c" translate="yes" xml:space="preserve">
          <source>The configuration file&amp;rsquo;s location depends on the startup system your distribution uses. A configuration file may also be specified on the command line with the &lt;code&gt;--config-file&lt;/code&gt; option.</source>
          <target state="translated">配置文件的位置取决于您的发行版使用的启动系统。也可以在命令行上使用 &lt;code&gt;--config-file&lt;/code&gt; 选项指定配置文件。</target>
        </trans-unit>
        <trans-unit id="8d57968bb10f1a8ee059f9f4fabbd5506039b2ce" translate="yes" xml:space="preserve">
          <source>The conflicting field is &lt;code&gt;id&lt;/code&gt;. If you directly use the &lt;code&gt;zip&lt;/code&gt; command, the &lt;code&gt;id&lt;/code&gt; field of the result will be the one from the company. There are three ways to resolve potential field conflicts.</source>
          <target state="translated">冲突字段是 &lt;code&gt;id&lt;/code&gt; 。如果直接使用 &lt;code&gt;zip&lt;/code&gt; 命令，则结果的 &lt;code&gt;id&lt;/code&gt; 字段将是公司的ID字段。有三种解决潜在字段冲突的方法。</target>
        </trans-unit>
        <trans-unit id="41a66fdd8d9de0bac5ea2260645056298020b2b8" translate="yes" xml:space="preserve">
          <source>The contact information is &lt;em&gt;nested,&lt;/em&gt; like paths in a file system.</source>
          <target state="translated">联系人信息是&lt;em&gt;嵌套的，&lt;/em&gt;就像文件系统中的路径一样。</target>
        </trans-unit>
        <trans-unit id="46e1e4bcb0e4603cd6cff58253ffb59a537fc94c" translate="yes" xml:space="preserve">
          <source>The core file, if it was dumped on crash</source>
          <target state="translated">核心文件,如果它在崩溃时被转储的话</target>
        </trans-unit>
        <trans-unit id="ba97166dc1556a5cdbc1fb0a9720d0a77462db53" translate="yes" xml:space="preserve">
          <source>The current issues table is one of the &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; added in version 1.16 of RethinkDB. Querying it returns problems detected within the cluster; in normal, error-free operation, it will remain empty. The table is read-only.</source>
          <target state="translated">当前问题表是RethinkDB 1.16版中添加的&lt;a href=&quot;../system-tables/index&quot;&gt;系统表&lt;/a&gt;之一。查询它会返回在集群中检测到的问题；在正常，无错误的操作中，它将保持为空。该表是只读的。</target>
        </trans-unit>
        <trans-unit id="9e81558969cd0f2524d236b46d01319070689378" translate="yes" xml:space="preserve">
          <source>The data files if RethinkDB cannot restart&amp;sup1;</source>
          <target state="translated">如果RethinkDB无法重启，则为数据文件&amp;sup1;</target>
        </trans-unit>
        <trans-unit id="25aadde4cb61338d8bafe72ae41695aff82a3946" translate="yes" xml:space="preserve">
          <source>The data is often colocated on disk. If you have a dataset that doesn&amp;rsquo;t fit into RAM, data is loaded from disk faster.</source>
          <target state="translated">数据通常位于磁盘上。如果您的数据集不适合RAM，则从磁盘加载数据的速度更快。</target>
        </trans-unit>
        <trans-unit id="432d68834696a4171c465fcdf29cc3b60b18ac02" translate="yes" xml:space="preserve">
          <source>The data is organized into B-Trees, and stored on disk using a log-structured storage engine built specifically for RethinkDB and inspired by the architecture of BTRFS. The storage engine has a number of benefits over other available options, including an incremental, fully concurrent garbage compactor, low CPU overhead and very efficient multicore operation, a number of SSD optimizations, instantaneous recovery after power failure, full data consistency in case of failures, and support for multiversion concurrency control.</source>
          <target state="translated">数据被组织成B树,并使用专门为RethinkDB构建的日志结构化存储引擎存储在磁盘上,其灵感来自于BTRFS的架构。与其他现有方案相比,该存储引擎有很多优点,包括增量式全并发垃圾压缩器、低CPU开销和非常高效的多核操作、大量的SSD优化、断电后瞬间恢复、故障时数据完全一致、支持多版本并发控制。</target>
        </trans-unit>
        <trans-unit id="ca3fd25b569c562f5c89d32cc20220b1580eb52d" translate="yes" xml:space="preserve">
          <source>The data set generated by YCSB consists of 25 million documents, sized at 1 KB each. All data fits into the server cache in this scenario.</source>
          <target state="translated">YCSB生成的数据集由2500万个文档组成,每个文档的大小为1KB。在这种情况下,所有的数据都可以放入服务器缓存中。</target>
        </trans-unit>
        <trans-unit id="d6f5c132a6c8fcdd7afd1c8bae8bfba8ab30a7d1" translate="yes" xml:space="preserve">
          <source>The default security group opens 4 ports:</source>
          <target state="translated">默认安全组开放4个端口。</target>
        </trans-unit>
        <trans-unit id="f19e6a7695718d0586846f66bc593da2a988d29b" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is with the &lt;code&gt;openssl&lt;/code&gt; command line tool. (Under Linux and OS X, this is already installed; for Windows, you may be able to find &lt;a href=&quot;https://wiki.openssl.org/index.php/Binaries&quot;&gt;precompiled binaries&lt;/a&gt; from the list on the OpenSSL wiki.)</source>
          <target state="translated">最简单的方法是使用 &lt;code&gt;openssl&lt;/code&gt; 命令行工具。（在Linux和OS X下，已经安装了此文件；对于Windows，您可以从OpenSSL Wiki上的列表中找到&lt;a href=&quot;https://wiki.openssl.org/index.php/Binaries&quot;&gt;预编译的二进制文件&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="f6f1812991e1cc3c581617dbd4daebc446ccc185" translate="yes" xml:space="preserve">
          <source>The easiest way to rename a database is to use the &lt;a href=&quot;../../../api/javascript/config/index&quot;&gt;config&lt;/a&gt; command to access the &lt;code&gt;db_config&lt;/code&gt;&lt;a href=&quot;../../system-tables/index&quot;&gt;system table&lt;/a&gt;, and then simply use the &lt;code&gt;update&lt;/code&gt; command.</source>
          <target state="translated">重命名数据库的最简单方法是使用&lt;a href=&quot;../../../api/javascript/config/index&quot;&gt;config&lt;/a&gt;命令访问 &lt;code&gt;db_config&lt;/code&gt; &lt;a href=&quot;../../system-tables/index&quot;&gt;系统表&lt;/a&gt;，然后简单地使用 &lt;code&gt;update&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="89bd55fcff5767ef7274bfe1e8ce0c5c79f0d4ff" translate="yes" xml:space="preserve">
          <source>The easiest way to use RethinkDB with EventMachine is simply by passing a block to &lt;code&gt;em_run&lt;/code&gt;. If RethinkDB returns a sequence (including a stream), the block will be called once with each element of the sequence. Otherwise, the block will be called just once with the returned value.</source>
          <target state="translated">将RethinkDB与EventMachine一起使用的最简单方法是将一个块传递给 &lt;code&gt;em_run&lt;/code&gt; 。如果RethinkDB返回一个序列（包括流），则该块将与该序列的每个元素一起调用一次。否则，将仅使用返回值调用该块一次。</target>
        </trans-unit>
        <trans-unit id="e8f5bff35a4c9660e74c3c9c467c02d19d234371" translate="yes" xml:space="preserve">
          <source>The entire query on the exchange is:</source>
          <target state="translated">整个交易所的查询是。</target>
        </trans-unit>
        <trans-unit id="7872f9fb3324da93dd0fa2f2d9cad699581f3968" translate="yes" xml:space="preserve">
          <source>The equivalent query with the &lt;code&gt;each&lt;/code&gt; command would be:</source>
          <target state="translated">&lt;code&gt;each&lt;/code&gt; 命令的等效查询为：</target>
        </trans-unit>
        <trans-unit id="97251998b6e48bd65cb3a5f03d2385e3f4ad6124" translate="yes" xml:space="preserve">
          <source>The essential tradeoff exposed by the CAP theorem is this: in case of network partitioning, does the system maintain availability or data consistency? (Jumping ahead, RethinkDB chooses to maintain data consistency).</source>
          <target state="translated">CAP定理暴露出的本质权衡是:在网络分区的情况下,系统是保持可用性还是数据一致性?(跳转到前面,RethinkDB选择保持数据一致性)。</target>
        </trans-unit>
        <trans-unit id="ffdbbb7e20b2915b198b1869df59132f308dec83" translate="yes" xml:space="preserve">
          <source>The example documentation includes a &lt;a href=&quot;https://github.com/rethinkdb/example-pubsub/blob/master/javascript/demo.js'&quot;&gt;demo script&lt;/a&gt; that shows off the three topic patterns described above. The script implements both a publisher and a subscriber with each pattern type. You can use this script to try out multiple publishers and multiple subscribers to test out how it works.</source>
          <target state="translated">示例文档包括一个&lt;a href=&quot;https://github.com/rethinkdb/example-pubsub/blob/master/javascript/demo.js'&quot;&gt;演示脚本&lt;/a&gt;，展示了上述三个主题模式。该脚本使用每种模式类型实现发布者和订阅者。您可以使用此脚本尝试多个发布者和多个订阅者以测试其工作方式。</target>
        </trans-unit>
        <trans-unit id="9edfaf70b3165d1edeb4b2ca333e0e5c7f12d86f" translate="yes" xml:space="preserve">
          <source>The field &lt;code&gt;left&lt;/code&gt; contains the information from the left table in the query (in this case, the employee)</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; 字段包含查询中左表中的信息（在本例中为雇员）</target>
        </trans-unit>
        <trans-unit id="9c8dc7c54d50cbb27b2e5e50ed222c7c1bcabb6f" translate="yes" xml:space="preserve">
          <source>The field &lt;code&gt;right&lt;/code&gt; contains the information from the right table in the query (in this case, the company)</source>
          <target state="translated">&lt;code&gt;right&lt;/code&gt; 字段包含查询中右侧表中的信息（在本例中为公司）</target>
        </trans-unit>
        <trans-unit id="5ca20f66475f57f24716ce5a447518106f391982" translate="yes" xml:space="preserve">
          <source>The field name can be determined entirely on the server, too. For instance, to update a field whose name is drawn from the value of another field:</source>
          <target state="translated">字段名也可以完全在服务器上确定。例如,如果要更新一个字段,其名称是从另一个字段的值中提取的。</target>
        </trans-unit>
        <trans-unit id="58a69ccf3b964eb9485bcdd26e8c05306cda5c74" translate="yes" xml:space="preserve">
          <source>The file system it&amp;rsquo;s using</source>
          <target state="translated">正在使用的文件系统</target>
        </trans-unit>
        <trans-unit id="26add78546ea5b911c7f22338e8d01f8bc519e6c" translate="yes" xml:space="preserve">
          <source>The file uses a simple format of &lt;code&gt;key=value&lt;/code&gt;, with one key specified per line. A simple configuration file that uses the default ports, assigns a server to a virtual group using server tags and joins an existing cluster might be:</source>
          <target state="translated">该文件使用 &lt;code&gt;key=value&lt;/code&gt; 的简单格式，每行指定一个密钥。使用默认端口，使用服务器标签将服务器分配给虚拟组并加入现有群集的简单配置文件可能是：</target>
        </trans-unit>
        <trans-unit id="967d896d236ec1fb0a5af483a32f7ac64a4a217d" translate="yes" xml:space="preserve">
          <source>The final reduction step is executed to combine the values of the two shards. Instead of computing &lt;code&gt;4 + 6&lt;/code&gt;, the query executes &lt;code&gt;4 + 1&lt;/code&gt;.</source>
          <target state="translated">执行最后的归约步骤以合并两个分片的值。查询执行 &lt;code&gt;4 + 1&lt;/code&gt; ，而不是计算 &lt;code&gt;4 + 6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21c10050daac2ef80e360f5105e9b0c7210bb045" translate="yes" xml:space="preserve">
          <source>The first function increments the accumulator each time it&amp;rsquo;s called, starting at &lt;code&gt;0&lt;/code&gt;; the second function, the emitting function, alternates between returning a single-item list containing the current row or an empty list. The &lt;code&gt;fold&lt;/code&gt; command will return a concatenated list of each emitted value.</source>
          <target state="translated">每次调用累加器时，第一个函数从 &lt;code&gt;0&lt;/code&gt; 开始递增；第二个函数，即发射函数，在返回包含当前行的单项列表或空列表之间交替。的 &lt;code&gt;fold&lt;/code&gt; 命令将返回每个发射值的级联列表。</target>
        </trans-unit>
        <trans-unit id="c8fd60f1adeaf3727bc4bf3fdd3883868eaa6238" translate="yes" xml:space="preserve">
          <source>The first layer implements the distributed infrastructure, placing copies of data on specific servers, routing queries, etc.</source>
          <target state="translated">第一层实现分布式基础设施,将数据的副本放在特定的服务器上,进行路由查询等。</target>
        </trans-unit>
        <trans-unit id="11ba98d6b6cd3aa5da8ea438eaebfebb10f6c61a" translate="yes" xml:space="preserve">
          <source>The first time you call an &lt;code&gt;EventEmitter&lt;/code&gt; method, the cursor or feed will emit data just after the I/O events callbacks and before &lt;code&gt;setTimeout&lt;/code&gt; and &lt;code&gt;setInterval&lt;/code&gt; callbacks.</source>
          <target state="translated">首次调用 &lt;code&gt;EventEmitter&lt;/code&gt; 方法时，游标或源将在I / O事件回调之后， &lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;setInterval&lt;/code&gt; 回调之前发出数据。</target>
        </trans-unit>
        <trans-unit id="9d3e834a06be3d4a966b74e6eddbe6ce25aed60f" translate="yes" xml:space="preserve">
          <source>The first, required function passed to &lt;code&gt;eachAsync&lt;/code&gt; takes either one or two functions as arguments. The first is a callback to process each row as it is emitted; the second is an optional callback which will be executed when all row processing is completed.</source>
          <target state="translated">传递给 &lt;code&gt;eachAsync&lt;/code&gt; 的第一个必需函数采用一个或两个函数作为参数。第一个是回调，用于处理发射的每一行；第二个是可选的回调，将在所有行处理完成后执行。</target>
        </trans-unit>
        <trans-unit id="f77e0ba8b65283ab2e514276f940a158831a2d01" translate="yes" xml:space="preserve">
          <source>The following browsers are supported and known to work with the web UI:</source>
          <target state="translated">以下浏览器支持并可与网页用户界面配合使用。</target>
        </trans-unit>
        <trans-unit id="3df000274781b42d95e5cd8f246c23c4e2ddf8e2" translate="yes" xml:space="preserve">
          <source>The following command will output the contents of &lt;em&gt;all&lt;/em&gt; the configuration/status tables as well as the most recent 50 lines of the &lt;code&gt;logs&lt;/code&gt; table:</source>
          <target state="translated">以下命令将输出&lt;em&gt;所有&lt;/em&gt;配置/状态表的内容以及 &lt;code&gt;logs&lt;/code&gt; 表的最新50行：</target>
        </trans-unit>
        <trans-unit id="e980e576b3cf9e71a983706b28a74a69507c5ca2" translate="yes" xml:space="preserve">
          <source>The following commands can be distributed across shards:</source>
          <target state="translated">以下命令可以分布在不同的碎片上。</target>
        </trans-unit>
        <trans-unit id="23607390bcdf5106a17d091ec59afc6366ef93aa" translate="yes" xml:space="preserve">
          <source>The following fields are always present in this object:</source>
          <target state="translated">该对象中始终存在以下字段:</target>
        </trans-unit>
        <trans-unit id="4fa7d560043390f25c44226fb5ceef0d02b7d4e2" translate="yes" xml:space="preserve">
          <source>The format of the array returned by &lt;code&gt;ungroup&lt;/code&gt; is the same as the default native format of grouped data in the javascript driver and data explorer.</source>
          <target state="translated">&lt;code&gt;ungroup&lt;/code&gt; 返回的数组格式与javascript驱动程序和数据浏览器中分组数据的默认本机格式相同。</target>
        </trans-unit>
        <trans-unit id="6ea8b9bda562c3a2c267fd13344c22561590ebae" translate="yes" xml:space="preserve">
          <source>The full list of &lt;code&gt;QueryType&lt;/code&gt; values is as follows:</source>
          <target state="translated">&lt;code&gt;QueryType&lt;/code&gt; 值的完整列表如下：</target>
        </trans-unit>
        <trans-unit id="475b97f4658238ce4d91f9f9f592b520513498e2" translate="yes" xml:space="preserve">
          <source>The full output from &lt;code&gt;rethinkdb --version&lt;/code&gt;, something like:</source>
          <target state="translated">来自 &lt;code&gt;rethinkdb --version&lt;/code&gt; 的完整输出，类似于：</target>
        </trans-unit>
        <trans-unit id="14769e9184ffc530cac63e2fae1484534e1ee52b" translate="yes" xml:space="preserve">
          <source>The full output from &lt;code&gt;uname -a&lt;/code&gt;, something like:</source>
          <target state="translated">&lt;code&gt;uname -a&lt;/code&gt; 的完整输出，类似于：</target>
        </trans-unit>
        <trans-unit id="69129d2da31b2f07b7562ea61774addc8ca3fc5c" translate="yes" xml:space="preserve">
          <source>The full query execution process is fairly complex and nuanced. For example, some operations cannot be parallelized, some queries cannot be executed lazily (which has implications on runtime and RAM usage), and implementations of some operations could be significantly improved. We will be adding tools to help visualize and understand query execution in a user-friendly way, but at the moment the best way to learn more about it is to ask us or to look at the code.</source>
          <target state="translated">完整的查询执行过程是相当复杂和细微的。例如,一些操作不能并行化,一些查询不能懒惰执行(这对运行时和RAM的使用有影响),一些操作的实现可以大大改进。我们将添加工具,以用户友好的方式帮助可视化和理解查询执行,但目前了解更多信息的最好方法是询问我们或查看代码。</target>
        </trans-unit>
        <trans-unit id="c162ed1ca38301acb854f2294b911ec17da79f31" translate="yes" xml:space="preserve">
          <source>The full syntax for the &lt;code&gt;import&lt;/code&gt; command is as follows:</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 命令的完整语法如下：</target>
        </trans-unit>
        <trans-unit id="deca2cf2857457188d6ef69f7a463144da27b999" translate="yes" xml:space="preserve">
          <source>The function would be serialized as:</source>
          <target state="translated">该函数将被序列化为:</target>
        </trans-unit>
        <trans-unit id="5f7cae79892fe7f333ad65e3b8f50bdbc5bee557" translate="yes" xml:space="preserve">
          <source>The function you give to &lt;code&gt;indexCreate&lt;/code&gt; must be deterministic. In practice this means that that you cannot use a function that contains a sub-query or the &lt;code&gt;r.js&lt;/code&gt; command.</source>
          <target state="translated">您赋予 &lt;code&gt;indexCreate&lt;/code&gt; 的函数必须是确定性的。实际上，这意味着您不能使用包含子查询或 &lt;code&gt;r.js&lt;/code&gt; 命令的函数。</target>
        </trans-unit>
        <trans-unit id="21bb40f02c679aca148c3514604ac102d9df5cab" translate="yes" xml:space="preserve">
          <source>The games table contains these documents:</source>
          <target state="translated">游戏桌上有这些文件。</target>
        </trans-unit>
        <trans-unit id="c9fda65faa054c03a06f17658d0df4a9e5f090ac" translate="yes" xml:space="preserve">
          <source>The geospatial functions are implemented through a set of new geometric object data types:</source>
          <target state="translated">地理空间功能是通过一组新的几何对象数据类型实现的。</target>
        </trans-unit>
        <trans-unit id="66bf76a1e568737c42ee060cb4a10d8649ca86a7" translate="yes" xml:space="preserve">
          <source>The grant command</source>
          <target state="translated">授予命令</target>
        </trans-unit>
        <trans-unit id="c5cc776f379421f9e0176920e32ec32956ce0ba2" translate="yes" xml:space="preserve">
          <source>The index must either be the primary key or have been previously created with &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt;.</source>
          <target state="translated">索引必须是主键，或者以前已使用&lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="2495353fe68162175193be062922febe81792444" translate="yes" xml:space="preserve">
          <source>The index must have been previously created with &lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt;.</source>
          <target state="translated">索引必须先前已使用&lt;a href=&quot;../index_create/index&quot;&gt;indexCreate&lt;/a&gt;创建。</target>
        </trans-unit>
        <trans-unit id="ca41c024d3d03398ad932fa456e6f47678274ff4" translate="yes" xml:space="preserve">
          <source>The init.d script supports starting multiple instances on the same server via multiple &lt;code&gt;.conf&lt;/code&gt; files in &lt;code&gt;/etc/rethinkdb/instances.d&lt;/code&gt;. This may be desirable for isolating databases for separate applications running on the same server, or for testing purposes. (There is no performance gain from running multiple nodes of the same cluster on the same physical machine.)</source>
          <target state="translated">init.d脚本支持通过 &lt;code&gt;/etc/rethinkdb/instances.d&lt;/code&gt; 中的多个 &lt;code&gt;.conf&lt;/code&gt; 文件在同一服务器上启动多个实例。对于隔离同一服务器上运行的单独应用程序的数据库或出于测试目的，这可能是理想的。（在同一台物理计算机上运行同一群集的多个节点不会带来性能提升。）</target>
        </trans-unit>
        <trans-unit id="8ebf19d589643ec5b145f9f4331ef50a76004e07" translate="yes" xml:space="preserve">
          <source>The inner &lt;code&gt;map&lt;/code&gt; function is just being used to iterate through the items in each order. At this point, our query will return a list of objects, each object with three fields: &lt;code&gt;item_id&lt;/code&gt;, &lt;code&gt;quantity&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">内部 &lt;code&gt;map&lt;/code&gt; 函数仅用于迭代每个顺序中的项目。此时，我们的查询将返回一个对象列表，每个对象具有三个字段： &lt;code&gt;item_id&lt;/code&gt; ， &lt;code&gt;quantity&lt;/code&gt; 和 &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d932f3d62c38556feefc878504c15decd242c35" translate="yes" xml:space="preserve">
          <source>The inner &lt;code&gt;sum&lt;/code&gt; adds the scores by match within each document; the outer &lt;code&gt;sum&lt;/code&gt; adds those results together for a total across all the documents.</source>
          <target state="translated">内部 &lt;code&gt;sum&lt;/code&gt; 将每个文档中的匹配项相加；外部 &lt;code&gt;sum&lt;/code&gt; 将这些结果加在一起得出所有文档的总和。</target>
        </trans-unit>
        <trans-unit id="a30db86d4cd4223f11f528b78e8eaa37d415543e" translate="yes" xml:space="preserve">
          <source>The intracluster port will be accessible from within the local network where you run RethinkDB nodes, but will not be accessible from the outside world.</source>
          <target state="translated">集群内端口可以从运行RethinkDB节点的本地网络中访问,但不能从外界访问。</target>
        </trans-unit>
        <trans-unit id="c6e6220488f98ca8b4a9e1814cfe64c223d59c09" translate="yes" xml:space="preserve">
          <source>The jobs table is one of the &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; added in version 1.16 of RethinkDB. It provides information about tasks running within the RethinkDB cluster, including queries, disk compaction, and index construction, and allows you to kill query jobs by deleting them from the table.</source>
          <target state="translated">作业表是RethinkDB 1.16版中添加的&lt;a href=&quot;../system-tables/index&quot;&gt;系统表&lt;/a&gt;之一。它提供有关RethinkDB集群中运行的任务的信息，包括查询，磁盘压缩和索引构造，并允许您通过从表中删除查询作业来终止它们。</target>
        </trans-unit>
        <trans-unit id="41b9718b6370d6926103658ff4576ee577670375" translate="yes" xml:space="preserve">
          <source>The keys in a multi index can be single values, compound values or even arbitrary expressions. (See the section below for more detail on indexes using functions.)</source>
          <target state="translated">多索引中的键可以是单值、复值,甚至是任意表达式。(关于使用函数索引的更多细节,请参见下面的章节)。</target>
        </trans-unit>
        <trans-unit id="82f9d489b67d40b5391cfe80f91d791cb7c19663" translate="yes" xml:space="preserve">
          <source>The language is easy to learn, read, and modify.</source>
          <target state="translated">语言易学、易读、易修改。</target>
        </trans-unit>
        <trans-unit id="9d43b4d8b1ab557e528e7e44276c5ff362b9edeb" translate="yes" xml:space="preserve">
          <source>The last argument to &lt;code&gt;do&lt;/code&gt; (or, in some forms, the only argument) is an expression or an anonymous function which receives values from either the previous arguments or from prefixed commands chained before &lt;code&gt;do&lt;/code&gt;. The &lt;code&gt;do&lt;/code&gt; command is essentially a single-element &lt;a href=&quot;../map/index&quot;&gt;map&lt;/a&gt;, letting you map a function over just one document. This allows you to bind a query result to a local variable within the scope of &lt;code&gt;do&lt;/code&gt;, letting you compute the result just once and reuse it in a complex expression or in a series of ReQL commands.</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; 的最后一个参数（或某些形式的唯一参数）是表达式或匿名函数，该函数从先前的参数或 &lt;code&gt;do&lt;/code&gt; 之前链接的前缀命令中接收值。该 &lt;code&gt;do&lt;/code&gt; 的命令本质上是一个单元素&lt;a href=&quot;../map/index&quot;&gt;的地图&lt;/a&gt;，让你映射功能在仅有的一个文件。这使您可以将查询结果绑定到 &lt;code&gt;do&lt;/code&gt; 范围内的局部变量，从而使您仅计算一次结果，即可在复杂的表达式或一系列ReQL命令中重复使用它。</target>
        </trans-unit>
        <trans-unit id="e1b83f2f20d6e27211b3484dd80a4271132f9fba" translate="yes" xml:space="preserve">
          <source>The length of the response, as a 4-byte little-endian integer</source>
          <target state="translated">响应的长度,是一个4字节的小二进制整数。</target>
        </trans-unit>
        <trans-unit id="9d6f0d5641c4868545fe88e3f18cccf39a6677f5" translate="yes" xml:space="preserve">
          <source>The linearizability guarantee is for &lt;em&gt;atomic operations,&lt;/em&gt; not for &lt;em&gt;queries.&lt;/em&gt; A single RethinkDB query will not necessarily execute as a single atomic operation. It&amp;rsquo;s possible that the query:</source>
          <target state="translated">线性性保证是针对&lt;em&gt;原子操作的，&lt;/em&gt;而不是针对&lt;em&gt;查询的。&lt;/em&gt;单个RethinkDB查询不一定会作为单个原子操作执行。查询可能是：</target>
        </trans-unit>
        <trans-unit id="be6c7b03ecee10bbdd3ecd94feb9326cf807aea0" translate="yes" xml:space="preserve">
          <source>The listener is the other side of the interaction: it connects to RabbitMQ, signs up to be notified of messages it&amp;rsquo;s interested in, and does something when it receives a message.</source>
          <target state="translated">侦听器是交互的另一面：它连接到RabbitMQ，注册以对其感兴趣的消息进行通知，并在接收到消息时执行某些操作。</target>
        </trans-unit>
        <trans-unit id="915fce30152336842eeda671dad0b27dec31599e" translate="yes" xml:space="preserve">
          <source>The log file&amp;rsquo;s location is dependent on your system configuration and how you started RethinkDB.</source>
          <target state="translated">日志文件的位置取决于您的系统配置以及启动RethinkDB的方式。</target>
        </trans-unit>
        <trans-unit id="2e78ae1df38b4c0eccc0c5010b454cb2411fca09" translate="yes" xml:space="preserve">
          <source>The log may give you information as to what caused the crash.</source>
          <target state="translated">日志可能会给你提供关于导致崩溃的信息。</target>
        </trans-unit>
        <trans-unit id="4917584586a9ba5841c6d9996a82f13e2383ec57" translate="yes" xml:space="preserve">
          <source>The message &lt;code&gt;received invalid clustering header&lt;/code&gt; means there is a port mismatch, and something is connecting to the wrong port. For example, it&amp;rsquo;s common to get this message if you accidentally point the browser or connect the client drivers to the intracluster traffic port.</source>
          <target state="translated">消息 &lt;code&gt;received invalid clustering header&lt;/code&gt; 表示端口不匹配，并且某些东西连接到错误的端口。例如，如果您不小心指向浏览器或将客户端驱动程序连接到集群内流量端口，则通常会收到此消息。</target>
        </trans-unit>
        <trans-unit id="e9b96017ac9340db22343a25f56da2ed0e933cf4" translate="yes" xml:space="preserve">
          <source>The metadata in the system tables applies to the RethinkDB cluster as a whole. Each server in a cluster maintains its own copy of the system tables. Whenever a system table on a server changes, the changes are synced across all the servers.</source>
          <target state="translated">系统表中的元数据适用于整个RethinkDB集群。集群中的每一台服务器都会维护自己的系统表副本。每当一台服务器上的系统表发生变化时,这些变化都会在所有服务器上同步。</target>
        </trans-unit>
        <trans-unit id="34aae6139df043314fa6079b6b69c72abcd122fb" translate="yes" xml:space="preserve">
          <source>The most important field of this object is &lt;code&gt;errors&lt;/code&gt;. Generally speaking, if no exceptions are thrown and &lt;code&gt;errors&lt;/code&gt; is 0 then the write did what it was supposed to. (RethinkDB throws an exception when it isn&amp;rsquo;t even able to access the table; it sets the &lt;code&gt;errors&lt;/code&gt; field if it can access the table but an error occurs during the write. This convention exists so that batched writes don&amp;rsquo;t abort halfway through when they encounter an error.)</source>
          <target state="translated">这个对象最重要的领域是 &lt;code&gt;errors&lt;/code&gt; 。一般而言，如果未引发任何异常且 &lt;code&gt;errors&lt;/code&gt; 为0，则写入将执行应有的操作。（RethinkDB甚至无法访问表时，它都会引发异常；如果它可以访问表，但在写入过程中发生错误，则会设置 &lt;code&gt;errors&lt;/code&gt; 字段。此约定存在，因此批量写入不会在中途中断他们遇到错误。）</target>
        </trans-unit>
        <trans-unit id="52054d4689c88c2dd563c71fc3d4622fe9e37e26" translate="yes" xml:space="preserve">
          <source>The most important things for you to provide for us are:</source>
          <target state="translated">你要为我们提供的最重要的东西是。</target>
        </trans-unit>
        <trans-unit id="7d9fb82f35843a166df27094da516f937f5cd76f" translate="yes" xml:space="preserve">
          <source>The next section will explain how to build complex queries. For now, we will just send the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; (&lt;code&gt;r.expr(&quot;foo&quot;)&lt;/code&gt;) to the server.</source>
          <target state="translated">下一节将说明如何构建复杂的查询。现在，我们只将字符串 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; （ &lt;code&gt;r.expr(&quot;foo&quot;)&lt;/code&gt; ）发送到服务器。</target>
        </trans-unit>
        <trans-unit id="850ad84f52970e1d319ea7e6979fbb8fb61b332c" translate="yes" xml:space="preserve">
          <source>The next section will go into more detail, but in our example the &lt;code&gt;QueryType&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; (or &lt;code&gt;START&lt;/code&gt;, as we&amp;rsquo;ll see later), the &lt;code&gt;query&lt;/code&gt; is simply the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; and there are no options.</source>
          <target state="translated">下一部分将进行更详细的介绍，但是在我们的示例中 &lt;code&gt;QueryType&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; （或 &lt;code&gt;START&lt;/code&gt; ，我们将在后面看到）， &lt;code&gt;query&lt;/code&gt; 只是字符串 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; ，没有选项。</target>
        </trans-unit>
        <trans-unit id="1ae3c52cd36f26bb22cf875ccd87448c4be30f8e" translate="yes" xml:space="preserve">
          <source>The number of documents on shard 1 is computed. The query returns the value &lt;code&gt;4&lt;/code&gt; for the shard.</source>
          <target state="translated">计算分片1上的文档数。查询返回分片的值 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b27530ba359fc44b511a6ec9376acbc82fc3b7d1" translate="yes" xml:space="preserve">
          <source>The number of documents on shard 2 is computed. The query returns the value &lt;code&gt;6&lt;/code&gt; for the shard.</source>
          <target state="translated">计算分片2上的文档数。查询返回分片的值 &lt;code&gt;6&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17ded22e16e26949d0a41162bebffb07408ae4b0" translate="yes" xml:space="preserve">
          <source>The opposite of pluck; takes an object or a sequence of objects, and returns them with the specified paths removed.</source>
          <target state="translated">与pluck相反;取一个对象或一个对象序列,并在删除指定路径后返回。</target>
        </trans-unit>
        <trans-unit id="efdd31a108ade64161256b161e030637f32003ab" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;interleave&lt;/code&gt; argument controls how the sequences will be merged:</source>
          <target state="translated">可选的 &lt;code&gt;interleave&lt;/code&gt; 参数控制如何合并序列：</target>
        </trans-unit>
        <trans-unit id="3e541b9a29bd1d84a6fc76c8fea0e5e43910a115" translate="yes" xml:space="preserve">
          <source>The optional arguments are:</source>
          <target state="translated">可选参数是:</target>
        </trans-unit>
        <trans-unit id="7639f7478ac816294a9ebad71d1188e73a7903a1" translate="yes" xml:space="preserve">
          <source>The options can be:</source>
          <target state="translated">选项可以是:</target>
        </trans-unit>
        <trans-unit id="c9c6dbe2e2ebb18556376a0edc038dbb53b9d23d" translate="yes" xml:space="preserve">
          <source>The order in which callbacks are called in the &lt;code&gt;EventMachine.run&lt;/code&gt; block is not guaranteed; in the sample output above, &lt;code&gt;[:array, [1, 2, 3]]&lt;/code&gt; might have printed first.</source>
          <target state="translated">不保证在 &lt;code&gt;EventMachine.run&lt;/code&gt; 块中调用回调的顺序。在上面的示例输出中，可能首先打印了 &lt;code&gt;[:array, [1, 2, 3]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a80bb124c4d721554e30b34eefc7bc2457ea017a" translate="yes" xml:space="preserve">
          <source>The order in which you chain ReQL commands can affect performance. For an example, imagine combining the previous two queries to return an ordered list of names of admin users. The &lt;code&gt;filter&lt;/code&gt; operation can be distributed across shards, but the &lt;code&gt;orderBy&lt;/code&gt; operation cannot. So this query:</source>
          <target state="translated">链接ReQL命令的顺序可能会影响性能。例如，假设结合前两个查询以返回管理员用户名称的有序列表。该 &lt;code&gt;filter&lt;/code&gt; 操作可在碎片分布，但 &lt;code&gt;orderBy&lt;/code&gt; 操作不了。所以这个查询：</target>
        </trans-unit>
        <trans-unit id="e126ffbf5f64034b05b6cc9873b4d6e9ac47fdda" translate="yes" xml:space="preserve">
          <source>The output format of a point changefeed is identical to a table changefeed.</source>
          <target state="translated">点变化进纸的输出格式与表变化进纸相同。</target>
        </trans-unit>
        <trans-unit id="52544879000b4070f7c1ec53be285dedc81e74e4" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;rethinkdb&lt;/code&gt; on startup</source>
          <target state="translated">启动时 &lt;code&gt;rethinkdb&lt;/code&gt; 的输出</target>
        </trans-unit>
        <trans-unit id="db1df362b12f7161c6f9dfe2a13f7a5f148cea5f" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;changes&lt;/code&gt; query adheres to the following protocol:</source>
          <target state="translated">&lt;code&gt;changes&lt;/code&gt; 查询的输出遵循以下协议：</target>
        </trans-unit>
        <trans-unit id="9adcae7e13d1ddedbed6b9d9a4afd7aa5562ddd7" translate="yes" xml:space="preserve">
          <source>The output will be in this format:</source>
          <target state="translated">输出将是这种格式。</target>
        </trans-unit>
        <trans-unit id="4edfaeb420dd2cad843364eade6bfcc6103ac8f2" translate="yes" xml:space="preserve">
          <source>The parameters are represented as values &lt;code&gt;&amp;lt;p1&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;p2&amp;gt;&lt;/code&gt;, etc.; the values are arbitrary, but must be unique per query to avoid collisions. Within the function body the values are referred to with the query term &lt;code&gt;VAR&lt;/code&gt;, defined as &lt;code&gt;10&lt;/code&gt; in &lt;code&gt;ql2.proto&lt;/code&gt;. So the value of parameter &lt;code&gt;1&lt;/code&gt; is retrieved with &lt;code&gt;[10, [1]]&lt;/code&gt;.</source>
          <target state="translated">参数表示为值 &lt;code&gt;&amp;lt;p1&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;p2&amp;gt;&lt;/code&gt; 等；值是任意的，但每个查询必须唯一，以避免冲突。在函数体内，值用查询术语 &lt;code&gt;VAR&lt;/code&gt; 引用，在 &lt;code&gt;ql2.proto&lt;/code&gt; 中定义为 &lt;code&gt;10&lt;/code&gt; 。因此，使用 &lt;code&gt;[10, [1]]&lt;/code&gt; 检索参数 &lt;code&gt;1&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="709d9935fbae98edda7024d5c1ad7e0e1365088d" translate="yes" xml:space="preserve">
          <source>The part of a secondary index key that&amp;rsquo;s used for fast lookups depends on the length of the primary key (which must be 127 bytes or less). The length of this part is 238&amp;minus;&lt;em&gt;PK&lt;/em&gt;, where &lt;em&gt;PK&lt;/em&gt; is the primary key length; if the primary key length is a 36-character GUID, for instance, this means that 202 characters in the secondary index will be significant. If a table has multiple entries where the first 238&amp;minus;&lt;em&gt;PK&lt;/em&gt; characters are identical, lookup performance will be sharply degraded, as RethinkDB will have to perform a linear search to find the correct entries.</source>
          <target state="translated">用于快速查找的辅助索引键的部分取决于主键的长度（必须为127个字节或更小）。这部分的长度为238&amp;minus; &lt;em&gt;PK&lt;/em&gt;，其中&lt;em&gt;PK&lt;/em&gt;为主键长度；例如，如果主键长度是36个字符的GUID，则这意味着辅助索引中的202个字符将是有效的。如果一个表有多个条目，其中前238个&lt;em&gt;PK&lt;/em&gt;字符相同，则查询性能将急剧下降，因为RethinkDB必须执行线性搜索才能找到正确的条目。</target>
        </trans-unit>
        <trans-unit id="a85fd7e773e98525a057dee410b910ff3a9a2c35" translate="yes" xml:space="preserve">
          <source>The predicate &lt;code&gt;{age:30}&lt;/code&gt; selects documents in the &lt;code&gt;users&lt;/code&gt; table with an &lt;code&gt;age&lt;/code&gt; field whose value is &lt;code&gt;30&lt;/code&gt;. Documents with an &lt;code&gt;age&lt;/code&gt; field set to any other value &lt;em&gt;or&lt;/em&gt; with no &lt;code&gt;age&lt;/code&gt; field present are skipped.</source>
          <target state="translated">谓词 &lt;code&gt;{age:30}&lt;/code&gt; 在 &lt;code&gt;users&lt;/code&gt; 表中选择其 &lt;code&gt;age&lt;/code&gt; 字段为 &lt;code&gt;30&lt;/code&gt; 的文档。将 &lt;code&gt;age&lt;/code&gt; 字段设置为任何其他值&lt;em&gt;或&lt;/em&gt;不存在 &lt;code&gt;age&lt;/code&gt; 字段的文档将被跳过。</target>
        </trans-unit>
        <trans-unit id="ab592fecf2d641277abe2dc185bc11bf61ae10da" translate="yes" xml:space="preserve">
          <source>The primary index of a table can be used in any ReQL command that uses a secondary index.</source>
          <target state="translated">表的主索引可以用在任何使用二级索引的ReQL命令中。</target>
        </trans-unit>
        <trans-unit id="169a155070f84ee6fa928b40cd22b933ed483d0c" translate="yes" xml:space="preserve">
          <source>The primary key of each document is used by RethinkDB to place the document into an appropriate shard, and index it within that shard using a B-Tree data structure. Querying documents by primary key is extremely efficient, because the query can immediately be routed to the right shard and the document can be looked up in the B-Tree.</source>
          <target state="translated">每个文档的主键被RethinkDB用来将文档放到一个合适的shard中,并在该shard中使用B-Tree数据结构进行索引。通过主键查询文档是非常高效的,因为查询可以立即被路由到正确的shard,并且可以在B-Tree中查找文档。</target>
        </trans-unit>
        <trans-unit id="8b50e856dfd19b785cfb1ae6817c08f87c06cd84" translate="yes" xml:space="preserve">
          <source>The primary way to administer a RethinkDB AMI is through the web UI. Advanced tasks can be performed with ReQL administration commands, using the Data Explorer interactively or scripting through any RethinkDB driver. Read &lt;a href=&quot;../administration-tools/index&quot;&gt;Administration tools&lt;/a&gt; for more details about scripting administration tasks.</source>
          <target state="translated">管理RethinkDB AMI的主要方法是通过Web UI。可以使用ReQL管理命令，以交互方式使用Data Explorer或通过任何RethinkDB驱动程序编写脚本来执行高级任务。阅读&lt;a href=&quot;../administration-tools/index&quot;&gt;管理工具&lt;/a&gt;以获取有关脚本化管理任务的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="56486ac3e6a0cff408514c32848848251b792543" translate="yes" xml:space="preserve">
          <source>The programmer can also mark a read query to be ok with out-of-date data. In this mode, the query isn&amp;rsquo;t necessarily routed to the shard&amp;rsquo;s primary, but is likely to be routed to its closest replica. Out-of-date queries are likely to have lower latency and have stronger availability guarantees, but don&amp;rsquo;t necessarily return the latest version of the data to the client.</source>
          <target state="translated">程序员还可以将过期的数据标记为可以正常执行的读取查询。在这种模式下，查询不一定会路由到分片的主数据库，而是可能会路由到其最接近的副本。过时的查询可能具有较低的延迟和更强的可用性保证，但不一定会将最新版本的数据返回给客户端。</target>
        </trans-unit>
        <trans-unit id="43f06ecd9db4c427f5c01e559845b1558afef7ab" translate="yes" xml:space="preserve">
          <source>The proxy node can do some query processing itself, reducing CPU load on database servers.</source>
          <target state="translated">代理节点可以自己进行一些查询处理,减少数据库服务器的CPU负载。</target>
        </trans-unit>
        <trans-unit id="03aeb45cfefab1e6845737436e42c4ae921ad3f3" translate="yes" xml:space="preserve">
          <source>The proxy will send queries directly to the correct machines, reducing intracluster traffic.</source>
          <target state="translated">代理会将查询直接发送到正确的机器,减少集群内的流量。</target>
        </trans-unit>
        <trans-unit id="36fbbe7526681119c7192d6053c30c4b1b91f8d9" translate="yes" xml:space="preserve">
          <source>The queries are efficiently transported to the server (via protocol buffers), and evaluated in the cluster.</source>
          <target state="translated">查询被有效地传送到服务器(通过协议缓冲区),并在集群中进行评估。</target>
        </trans-unit>
        <trans-unit id="03c9e234b8601cd8cefabab2a66ae0491cf2637c" translate="yes" xml:space="preserve">
          <source>The queries linking the data between the authors and their posts tend to be more complicated.</source>
          <target state="translated">连接作者及其职位之间数据的查询往往比较复杂。</target>
        </trans-unit>
        <trans-unit id="2f2e5494893b9508bc4d620ee6c352443bb70976" translate="yes" xml:space="preserve">
          <source>The query is sent to a server for execution.</source>
          <target state="translated">该查询被发送到服务器执行。</target>
        </trans-unit>
        <trans-unit id="d418228ef09faaa1d551875cd4899ad068afb495" translate="yes" xml:space="preserve">
          <source>The query types are defined in &lt;code&gt;ql2.proto&lt;/code&gt;. When a query is first sent to the server, it will be sent with a &lt;code&gt;QueryType&lt;/code&gt; of &lt;code&gt;START&lt;/code&gt; (&lt;code&gt;1&lt;/code&gt;). The options (sometimes referred to as &amp;ldquo;global optargs&amp;rdquo;) are options passed to the &lt;code&gt;run&lt;/code&gt; command itself; see the &lt;a href=&quot;https://rethinkdb.com/api/python/run&quot;&gt;run documentation&lt;/a&gt; for a complete list. (Commands sent to the server are snake_case, not camelCase.)</source>
          <target state="translated">查询类型在 &lt;code&gt;ql2.proto&lt;/code&gt; 中定义。当查询首先被发送到服务器，它将与一个发送 &lt;code&gt;QueryType&lt;/code&gt; 的 &lt;code&gt;START&lt;/code&gt; （ &lt;code&gt;1&lt;/code&gt; ）。这些选项（有时称为&amp;ldquo;全局optargs&amp;rdquo;）是传递给 &lt;code&gt;run&lt;/code&gt; 命令本身的选项。请参阅&lt;a href=&quot;https://rethinkdb.com/api/python/run&quot;&gt;运行文档&lt;/a&gt;以获取完整列表。（发送到服务器的命令是snake_case，而不是camelCase。）</target>
        </trans-unit>
        <trans-unit id="c3ed5416cb9cfab926b34e7082c8a35489e21a3b" translate="yes" xml:space="preserve">
          <source>The query would look like this:</source>
          <target state="translated">查询的内容是这样的。</target>
        </trans-unit>
        <trans-unit id="49093f36439602ded586cf0ea033178761fb4a63" translate="yes" xml:space="preserve">
          <source>The reduction function can be called on the results of two previous reductions because the &lt;code&gt;reduce&lt;/code&gt; command is distributed and parallelized across shards and CPU cores. A common mistaken when using the &lt;code&gt;reduce&lt;/code&gt; command is to suppose that the reduction is executed from left to right. Read the &lt;a href=&quot;../../../docs/map-reduce/index&quot;&gt;map-reduce in RethinkDB&lt;/a&gt; article to see an example.</source>
          <target state="translated">由于 &lt;code&gt;reduce&lt;/code&gt; 命令是在分片和CPU内核之间分布和并行化的，因此可以在前两次缩减的结果上调用reduce函数。使用 &lt;code&gt;reduce&lt;/code&gt; 命令时，一个常见的错误是假定从左到右执行还原。阅读&lt;a href=&quot;../../../docs/map-reduce/index&quot;&gt;RethinkDB中&lt;/a&gt;的map-reduce文章以查看示例。</target>
        </trans-unit>
        <trans-unit id="2eaef544cfa01e61b0600b7381d8e28d53266a21" translate="yes" xml:space="preserve">
          <source>The reduction function can be called on:</source>
          <target state="translated">可以调用还原函数上。</target>
        </trans-unit>
        <trans-unit id="118a3751802c0d2d297d092376f59ad08a2671d1" translate="yes" xml:space="preserve">
          <source>The repubsub library has three classes:</source>
          <target state="translated">repubsub图书馆有三类。</target>
        </trans-unit>
        <trans-unit id="4c34de0c47665e2093b16d6e8c6cc2dafe60ac91" translate="yes" xml:space="preserve">
          <source>The result is an array containing one object for each table index:</source>
          <target state="translated">结果是一个数组,包含每个表索引的一个对象。</target>
        </trans-unit>
        <trans-unit id="05697956ca1c2b261267f1b15b9b31d091e913b4" translate="yes" xml:space="preserve">
          <source>The result is an array of the three previously inserted documents, along with the generated &lt;code&gt;id&lt;/code&gt; values.</source>
          <target state="translated">结果是三个先前插入的文档的数组，以及生成的 &lt;code&gt;id&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="96b9393100a8f012abd44d66848a45d8492c36be" translate="yes" xml:space="preserve">
          <source>The result is an array where for each index, there will be an object like this one:</source>
          <target state="translated">结果是一个数组,每个索引都会有一个像这样的对象。</target>
        </trans-unit>
        <trans-unit id="348e1c53bcf414975d4e88512994c35382165db3" translate="yes" xml:space="preserve">
          <source>The result is returned to the client.</source>
          <target state="translated">结果返回给客户。</target>
        </trans-unit>
        <trans-unit id="a4f25bd6541b97b8d992950d6d5f5fc101f8780b" translate="yes" xml:space="preserve">
          <source>The result look like:</source>
          <target state="translated">结果看起来像。</target>
        </trans-unit>
        <trans-unit id="f460bc9b91b03b6b76aa3c9f4052058e662787ad" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;filter&lt;/code&gt; is sent from the shards to the query server and combined.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 的结果从分片发送到查询服务器并合并。</target>
        </trans-unit>
        <trans-unit id="26ef6ad9412c9be209139ccf22acdf6ab7306819" translate="yes" xml:space="preserve">
          <source>The result of this query is a stream of documents that includes every post written by every author in our database:</source>
          <target state="translated">这个查询的结果是一个文件流,包括我们数据库中每个作者写的每一篇文章。</target>
        </trans-unit>
        <trans-unit id="4166859a2337b060599ebba8ff3782b1a2dac997" translate="yes" xml:space="preserve">
          <source>The result set of &lt;code&gt;eqJoin&lt;/code&gt; is a stream or array of objects. Each object in the returned set will be an object of the form &lt;code&gt;{left:&amp;lt;left-document&amp;gt;,right:&amp;lt;right-document&amp;gt;}&lt;/code&gt;, where the values of &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; will be the joined documents. Use the &lt;code&gt;&lt;a href=&quot;../zip/index&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; command to merge the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; fields together.</source>
          <target state="translated">&lt;code&gt;eqJoin&lt;/code&gt; 的结果集是对象的流或数组。返回集中的每个对象将是 &lt;code&gt;{left:&amp;lt;left-document&amp;gt;,right:&amp;lt;right-document&amp;gt;}&lt;/code&gt; 形式的对象，其中 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 的值将是连接的文档。使用 &lt;code&gt;&lt;a href=&quot;../zip/index&quot;&gt;zip&lt;/a&gt;&lt;/code&gt; 命令将合并 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 领域在一起。</target>
        </trans-unit>
        <trans-unit id="bcacb4ffc1428a1e7537a1b530d77ec1be49f08c" translate="yes" xml:space="preserve">
          <source>The result will be</source>
          <target state="translated">结果将是</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">结果将是:</target>
        </trans-unit>
        <trans-unit id="7ee33cf492c99cfb381b58051e0acd3d936534d2" translate="yes" xml:space="preserve">
          <source>The result will have two fields &lt;code&gt;old_val&lt;/code&gt; and &lt;code&gt;new_val&lt;/code&gt;.</source>
          <target state="translated">结果将具有两个字段 &lt;code&gt;old_val&lt;/code&gt; 和 &lt;code&gt;new_val&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2762176fdb80307d4542fb97295cbd05e50ef387" translate="yes" xml:space="preserve">
          <source>The result will now include a &lt;code&gt;changes&lt;/code&gt; field:</source>
          <target state="translated">现在，结果将包含一个 &lt;code&gt;changes&lt;/code&gt; 字段：</target>
        </trans-unit>
        <trans-unit id="580d6c3b8e7791206b60fdc3fbc9d93f7725d9aa" translate="yes" xml:space="preserve">
          <source>The results from &lt;code&gt;eqJoin&lt;/code&gt; are, by default, not ordered. The optional &lt;code&gt;ordered: true&lt;/code&gt; parameter will cause &lt;code&gt;eqJoin&lt;/code&gt; to order the output based on the left side input stream. (If there are multiple matches on the right side for a document on the left side, their order is not guaranteed even if &lt;code&gt;ordered&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.) Requiring ordered results can significantly slow down &lt;code&gt;eqJoin&lt;/code&gt;, and in many circumstances this ordering will not be required. (See the first example, in which ordered results are obtained by using &lt;code&gt;orderBy&lt;/code&gt; after &lt;code&gt;eqJoin&lt;/code&gt;.)</source>
          <target state="translated">默认情况下， &lt;code&gt;eqJoin&lt;/code&gt; 的结果不排序。可选的 &lt;code&gt;ordered: true&lt;/code&gt; 参数将使 &lt;code&gt;eqJoin&lt;/code&gt; 根据左侧输入流对输出进行排序。 （如果左侧的文档在右侧有多个匹配项，即使 &lt;code&gt;ordered&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 也不保证其顺序。）要求排序的结果可能会大大降低 &lt;code&gt;eqJoin&lt;/code&gt; 的速度，在许多情况下，不需要此排序。 （请参阅第一个示例，其中通过在 &lt;code&gt;eqJoin&lt;/code&gt; 之后使用 &lt;code&gt;orderBy&lt;/code&gt; 获得有序结果。）</target>
        </trans-unit>
        <trans-unit id="d9451368182bf51f88eb6d06ba8ad24bd4eea60c" translate="yes" xml:space="preserve">
          <source>The results of which might look something like:</source>
          <target state="translated">其结果可能是这样的:</target>
        </trans-unit>
        <trans-unit id="0fb83e527b8a750c6dbf5105d1252ab390a7c46c" translate="yes" xml:space="preserve">
          <source>The results will be:</source>
          <target state="translated">结果将是:</target>
        </trans-unit>
        <trans-unit id="f8c631d950204e251a618f771c764d482aaa3e66" translate="yes" xml:space="preserve">
          <source>The return value is an object consisting of a single field, &lt;code&gt;ready&lt;/code&gt;. The value is an integer indicating the number of tables waited for. It will always be &lt;code&gt;1&lt;/code&gt; when &lt;code&gt;wait&lt;/code&gt; is called on a table, and the total number of tables when called on a database.</source>
          <target state="translated">返回值是一个由单个字段 &lt;code&gt;ready&lt;/code&gt; 组成的对象。该值是整数，指示等待的表数。在表上调用 &lt;code&gt;wait&lt;/code&gt; 时，它将始终为 &lt;code&gt;1&lt;/code&gt; ;在数据库上调用时，表的总数将始终为1。</target>
        </trans-unit>
        <trans-unit id="36faca8c0d371071eae4e811f7ff0155ed872784" translate="yes" xml:space="preserve">
          <source>The return value is an object providing information about the table&amp;rsquo;s shards, replicas and replica readiness states. For a more complete discussion of the object fields, read about the &lt;code&gt;table_status&lt;/code&gt; table in &lt;a href=&quot;../../../docs/system-tables/index#status-tables&quot;&gt;System tables&lt;/a&gt;.</source>
          <target state="translated">返回值是一个对象，提供有关表的分片，副本和副本就绪状态的信息。对于对象的字段的更完整的讨论，阅读有关 &lt;code&gt;table_status&lt;/code&gt; 表&lt;a href=&quot;../../../docs/system-tables/index#status-tables&quot;&gt;系统表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8664182ddca74a0afbba7d649d8e66f1228d49e5" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;rebalance&lt;/code&gt; is an object with two fields:</source>
          <target state="translated">&lt;code&gt;rebalance&lt;/code&gt; 的返回值是一个具有两个字段的对象：</target>
        </trans-unit>
        <trans-unit id="c84ffcb32dd5cb8354ded3859b763e4a6e87665d" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;reconfigure&lt;/code&gt; in emergency repair mode is the same as before. Examine the &lt;code&gt;config_changes&lt;/code&gt; field to see the old and new configuration settings for the table. As in the normal mode, if you specify &lt;code&gt;emergencyRepair&lt;/code&gt; with &lt;code&gt;dryRun: true&lt;/code&gt;, the table will not actually be reconfigured.</source>
          <target state="translated">紧急修复模式下 &lt;code&gt;reconfigure&lt;/code&gt; 的返回值与以前相同。检查 &lt;code&gt;config_changes&lt;/code&gt; 字段以查看表的旧和新配置设置。在正常模式下，如果你指定 &lt;code&gt;emergencyRepair&lt;/code&gt; 与 &lt;code&gt;dryRun: true&lt;/code&gt; ，该表实际上不会进行重新配置。</target>
        </trans-unit>
        <trans-unit id="e02204eda362a94ed3590b8243708f0a55205484" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;reconfigure&lt;/code&gt; is an object with three fields:</source>
          <target state="translated">&lt;code&gt;reconfigure&lt;/code&gt; 的返回值是具有三个字段的对象：</target>
        </trans-unit>
        <trans-unit id="4a42d23931413086f7413742cda1659b0e61d53c" translate="yes" xml:space="preserve">
          <source>The return value on success will be an object of the format &lt;code&gt;{renamed:1}&lt;/code&gt;, or &lt;code&gt;{renamed:0}&lt;/code&gt; if the old and new names are the same.</source>
          <target state="translated">成功的返回值将是格式的对象 &lt;code&gt;{renamed:1}&lt;/code&gt; 或 &lt;code&gt;{renamed:0}&lt;/code&gt; 如果旧的和新的名称是相同的。</target>
        </trans-unit>
        <trans-unit id="a37da5d84e981e0bb315cf13e3a7994a4aa1e0e0" translate="yes" xml:space="preserve">
          <source>The return value will be an array of two-item objects with the keys &lt;code&gt;dist&lt;/code&gt; and &lt;code&gt;doc&lt;/code&gt;, set to the distance between the specified point and the document (in the units specified with &lt;code&gt;unit&lt;/code&gt;, defaulting to meters) and the document itself, respectively. The array will be sorted by the values of &lt;code&gt;dist&lt;/code&gt;.</source>
          <target state="translated">返回值将是两个项目的数组，其键为 &lt;code&gt;dist&lt;/code&gt; 和 &lt;code&gt;doc&lt;/code&gt; ，分别设置为指定点和文档之间的距离（以unit指定的 &lt;code&gt;unit&lt;/code&gt; ，默认为米）和文档本身之间的距离。该数组将按 &lt;code&gt;dist&lt;/code&gt; 的值排序。</target>
        </trans-unit>
        <trans-unit id="e759e1229ecea9bbd7516da914692287ca680f57" translate="yes" xml:space="preserve">
          <source>The return value, array or stream, will be the same type as the input.</source>
          <target state="translated">返回值,数组或流,将与输入的类型相同。</target>
        </trans-unit>
        <trans-unit id="4fec44479d0d10c75421c13f42fbeec52349083e" translate="yes" xml:space="preserve">
          <source>The returned sequence represents an intersection of the left-hand sequence and the right-hand sequence: each row of the left-hand sequence will be compared with each row of the right-hand sequence to find all pairs of rows which satisfy the predicate. Each matched pair of rows of both sequences are combined into a result row. In most cases, you will want to follow the join with &lt;a href=&quot;../zip/index&quot;&gt;zip&lt;/a&gt; to combine the left and right results.</source>
          <target state="translated">返回的序列表示左手序列和右手序列的交集：将左手序列的每一行与右手序列的每一行进行比较，以找到满足谓词的所有行对。两个序列的每个匹配的行对都组合成一个结果行。在大多数情况下，您将需要使用&lt;a href=&quot;../zip/index&quot;&gt;zip&lt;/a&gt;进行连接以合并左右结果。</target>
        </trans-unit>
        <trans-unit id="ac5cc5666ad8aa8ef95292cf77a92d9802649f93" translate="yes" xml:space="preserve">
          <source>The same is true for &lt;code&gt;single&lt;/code&gt; write mode and &lt;code&gt;soft&lt;/code&gt; durability mode. In normal operation these produce the same results as &lt;code&gt;majority&lt;/code&gt; and &lt;code&gt;hard&lt;/code&gt;, but in the event of a network or server failure, recent write operations that were run using these modes might be lost.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; 写入模式和 &lt;code&gt;soft&lt;/code&gt; 耐用性模式也是如此。在正常操作中，它们产生的结果与 &lt;code&gt;majority&lt;/code&gt; 和 &lt;code&gt;hard&lt;/code&gt; 相同，但是在网络或服务器出现故障的情况下，使用这些模式运行的最近写入操作可能会丢失。</target>
        </trans-unit>
        <trans-unit id="b4c323e945ed7f27785d054b5f8f97e0e237757c" translate="yes" xml:space="preserve">
          <source>The second comment can be deleted by using &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;deleteAt&lt;/code&gt; together.</source>
          <target state="translated">可以同时使用 &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;deleteAt&lt;/code&gt; 来删除第二条注释。</target>
        </trans-unit>
        <trans-unit id="202097410423eb99aa6ecf467119bc01a4f749f3" translate="yes" xml:space="preserve">
          <source>The second layer builds on the first and implements various automation mechanisms (e.g. automatically determining how to split shards, where to place copies of the data, automatically picking optimal primary replicas, etc.) This is the layer that compiles goals specified by the user into blueprints.</source>
          <target state="translated">第二层建立在第一层的基础上,实现各种自动化机制(如自动决定如何拆分碎片,在哪里放置数据的副本,自动挑选最优的主副本等)这一层是将用户指定的目标编译成蓝图。</target>
        </trans-unit>
        <trans-unit id="114be4a5ece50c916bc47741e3a7d572735f0817" translate="yes" xml:space="preserve">
          <source>The server sends a null-terminated JSON response with a &lt;code&gt;&quot;success&quot;&lt;/code&gt; value of either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. On &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; will contain the &amp;ldquo;server-final-message&amp;rdquo; with the ServerSignature value. The client should compute a ServerSignature as specified in the RFC and verify the values are identical.</source>
          <target state="translated">服务器发送一个以null终止的JSON响应，其 &lt;code&gt;&quot;success&quot;&lt;/code&gt; 值为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。如果为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; 将包含带有ServerSignature值的&amp;ldquo; server-final-message&amp;rdquo;。客户端应计算RFC中指定的ServerSignature并验证值是否相同。</target>
        </trans-unit>
        <trans-unit id="edb1a2704ae24a6e1303f7d8a6f62db3e8042205" translate="yes" xml:space="preserve">
          <source>The server sends a null-terminated JSON response with a &lt;code&gt;&quot;success&quot;&lt;/code&gt; value of either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. On &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; will contain the &amp;ldquo;server-first-message&amp;rdquo; containing the iteration count (&lt;code&gt;i=&lt;/code&gt;), salt (&lt;code&gt;s=&lt;/code&gt;) and a concatenation of the client nonce with its own nonce.</source>
          <target state="translated">服务器发送一个以null终止的JSON响应，其 &lt;code&gt;&quot;success&quot;&lt;/code&gt; 值为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。如果为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;&quot;authentication&quot;&lt;/code&gt; 将包含&amp;ldquo;服务器优先消息&amp;rdquo;，其中包含迭代计数（ &lt;code&gt;i=&lt;/code&gt; ），盐（ &lt;code&gt;s=&lt;/code&gt; ）以及客户端随机数与自己的随机数的串联。</target>
        </trans-unit>
        <trans-unit id="f585ded5cf8cfbbeb9c1f07d18ba8a91cefb4bcd" translate="yes" xml:space="preserve">
          <source>The server should return an object with zero errors and three inserted documents. We didn&amp;rsquo;t specify any primary keys (by default, each table uses the &lt;code&gt;id&lt;/code&gt; attribute for primary keys), so RethinkDB generated them for us. The generated keys are returned via the &lt;code&gt;generated_keys&lt;/code&gt; attribute.</source>
          <target state="translated">服务器应返回一个零错误的对象和三个插入的文档。我们没有指定任何主键（默认情况下，每个表都使用 &lt;code&gt;id&lt;/code&gt; 属性作为主键），因此RethinkDB为我们生成了它们。生成的密钥通过 &lt;code&gt;generated_keys&lt;/code&gt; 属性返回。</target>
        </trans-unit>
        <trans-unit id="98b6dd8a48a32954f5cb12942416a3c37cb847e5" translate="yes" xml:space="preserve">
          <source>The server will buffer up to &lt;code&gt;changefeedQueueSize&lt;/code&gt; elements (default 100,000). If the buffer limit is hit, early changes will be discarded, and the client will receive an object of the form &lt;code&gt;{error:&quot;Changefeed cache over array size limit, skipped X elements.&quot;}&lt;/code&gt; where &lt;code&gt;X&lt;/code&gt; is the number of elements skipped.</source>
          <target state="translated">服务器将缓冲最多 &lt;code&gt;changefeedQueueSize&lt;/code&gt; 元素（默认为100,000）。如果达到缓冲区限制，则早期的更改将被丢弃，并且客户端将收到 &lt;code&gt;{error:&quot;Changefeed cache over array size limit, skipped X elements.&quot;}&lt;/code&gt; 形式的对象，其中 &lt;code&gt;X&lt;/code&gt; 是跳过的元素数。</target>
        </trans-unit>
        <trans-unit id="8ecf2cc5495ccd280e597b73766b3eb352486850" translate="yes" xml:space="preserve">
          <source>The server will respond with a &lt;code&gt;null&lt;/code&gt;-terminated ASCII string describing the result of the handshake. If the string is &lt;code&gt;&quot;SUCCESS&quot;&lt;/code&gt;, the client may proceed to stage 2 and begin sending queries. Any other string indicates an error. The server will close the connection, and the driver should report this error to the user.</source>
          <target state="translated">服务器将以 &lt;code&gt;null&lt;/code&gt; 终止的ASCII字符串作为响应，以描述握手结果。如果字符串是 &lt;code&gt;&quot;SUCCESS&quot;&lt;/code&gt; ，则客户端可以进入阶段2并开始发送查询。其他任何字符串均表示错误。服务器将关闭连接，驱动程序应将此错误报告给用户。</target>
        </trans-unit>
        <trans-unit id="01511cc2b5cf35c2db85f41272ca8094df7742c9" translate="yes" xml:space="preserve">
          <source>The short answer is no. The longer answer is that the clustering system is designed with three main principles in mind:</source>
          <target state="translated">简而言之,答案是否定的。长一点的答案是,聚类系统的设计主要有三个原则。</target>
        </trans-unit>
        <trans-unit id="122b514199aca38b1e64f978120a76550d5f8df4" translate="yes" xml:space="preserve">
          <source>The short answer: you can&amp;rsquo;t. Use &lt;code&gt;Time&lt;/code&gt; objects instead.</source>
          <target state="translated">简短的答案：您不能。请改用&amp;ldquo; &lt;code&gt;Time&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="3b9453d9082351eda5683faedd71864622103978" translate="yes" xml:space="preserve">
          <source>The simplest case is publishing a message with a string for a topic. This lends itself to using regexes for filtering.</source>
          <target state="translated">最简单的情况是用一个字符串来发布一个主题的消息。这就适合使用regexes进行过滤。</target>
        </trans-unit>
        <trans-unit id="bb3e9cfc183b68887a93814d02362733592ff536" translate="yes" xml:space="preserve">
          <source>The size of the JSON-encoded response, as a 4-byte little-endian integer</source>
          <target state="translated">JSON编码响应的大小,是一个4字节的小字节整数。</target>
        </trans-unit>
        <trans-unit id="74b63d6fbff9efcdad47927189bdc3fb30c297b0" translate="yes" xml:space="preserve">
          <source>The size of the JSON-serialized, UTF8-encoded query, as a 4-byte little-endian integer</source>
          <target state="translated">JSON序列化的UTF8编码查询的大小,是一个4字节的小字节整数。</target>
        </trans-unit>
        <trans-unit id="57d388ed7a0a12386d59b691694b54aade3412a2" translate="yes" xml:space="preserve">
          <source>The size of the JSON-serialized, UTF8-encoded wrapped query, as a 4-byte little-endian integer</source>
          <target state="translated">JSON序列化的、UTF8编码的封装查询的大小,为4字节的小字节整数。</target>
        </trans-unit>
        <trans-unit id="9317ef5264324276eb78c8a1c900602db1085bdc" translate="yes" xml:space="preserve">
          <source>The slightly longer answer: there&amp;rsquo;s only one native &lt;code&gt;time&lt;/code&gt; data type in RethinkDB. When a language supports more than one kind of date/time object, we think it&amp;rsquo;s better to explicitly support one and only one of them in the client driver to avoid confusion. Otherwise, you might insert a &lt;code&gt;DateTime&lt;/code&gt; object and get a &lt;code&gt;Time&lt;/code&gt; object back.</source>
          <target state="translated">答案稍长一点：RethinkDB中只有一种本机 &lt;code&gt;time&lt;/code&gt; 数据类型。当一种语言支持一种以上的日期/时间对象时，我们认为最好在客户端驱动程序中显式地支持其中一种并且仅支持其中一种以避免混淆。否则，您可能会插入一个 &lt;code&gt;DateTime&lt;/code&gt; 对象并返回一个 &lt;code&gt;Time&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="b7c32a92c25b9cee33b2f71bfb7a043ec405b0db" translate="yes" xml:space="preserve">
          <source>The smallest recommended instance type is &lt;code&gt;t2.small&lt;/code&gt;. However, &lt;code&gt;t2.micro&lt;/code&gt; works for simple tests. Follow these instructions to set up an AMI:</source>
          <target state="translated">推荐的最小实例类型为 &lt;code&gt;t2.small&lt;/code&gt; 。但是， &lt;code&gt;t2.micro&lt;/code&gt; 可用于简单测试。请按照以下说明设置AMI：</target>
        </trans-unit>
        <trans-unit id="fe9f9991bad143f14ee5c65aadc6ca48be3371b7" translate="yes" xml:space="preserve">
          <source>The solution is to add a &lt;code&gt;default&lt;/code&gt; to the &lt;code&gt;row&lt;/code&gt; command that always evaluates to something other than what you&amp;rsquo;re testing for, so it will return &lt;code&gt;false&lt;/code&gt; if the field doesn&amp;rsquo;t exist:</source>
          <target state="translated">解决方案是向 &lt;code&gt;row&lt;/code&gt; 命令添加一个 &lt;code&gt;default&lt;/code&gt; ，该默认值始终会得出除您要测试的值之外的其他值，因此如果该字段不存在，它将返回 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5b36db4e47fc826603ad3fcc1fa591fc90ce4a59" translate="yes" xml:space="preserve">
          <source>The stats table is one of the &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; added in version 1.16 of RethinkDB. It provides statistics about server read/write throughput, client connections, and memory usage.</source>
          <target state="translated">stats表是RethinkDB 1.16版中添加的&lt;a href=&quot;../system-tables/index&quot;&gt;系统表&lt;/a&gt;之一。它提供有关服务器读/写吞吐量，客户端连接和内存使用情况的统计信息。</target>
        </trans-unit>
        <trans-unit id="84f5d2d101fc423bc118fd0bc79f68807e1dd7f3" translate="yes" xml:space="preserve">
          <source>The steps necessary for migrating data to current RethinkDB versions from previous ones depend on which version you&amp;rsquo;re migrating from.</source>
          <target state="translated">将数据从以前的版本迁移到当前RethinkDB版本所需的步骤取决于要从哪个版本迁移。</target>
        </trans-unit>
        <trans-unit id="ac277ab708b96fe6dc91bf3cd9a94437f7706c40" translate="yes" xml:space="preserve">
          <source>The storage engine is used in conjunction with a custom, B-Tree-aware caching engine which allows file sizes many orders of magnitude greater than the amount of available memory. RethinkDB can operate on a terabyte of data with about ten gigabytes of free RAM.</source>
          <target state="translated">存储引擎与一个定制的、B-Tree-aware缓存引擎一起使用,它允许文件大小比可用内存量大许多数量级。RethinkDB可以在一TB的数据上运行,而可用的内存大约为10GB。</target>
        </trans-unit>
        <trans-unit id="d8396b8f23f4763e864595f49d22dca2ab9cdfe5" translate="yes" xml:space="preserve">
          <source>The table created has six fields: an automatically generated primary key (&lt;code&gt;id&lt;/code&gt;), &lt;code&gt;rank&lt;/code&gt; (the IMDb rank, 1&amp;ndash;250), &lt;code&gt;rating&lt;/code&gt; (on a 1&amp;ndash;10 scale), &lt;code&gt;title&lt;/code&gt;, &lt;code&gt;votes&lt;/code&gt;, and &lt;code&gt;year&lt;/code&gt;.</source>
          <target state="translated">创建的表包含六个字段：自动生成的主键（ &lt;code&gt;id&lt;/code&gt; ）， &lt;code&gt;rank&lt;/code&gt; （IMDb等级，1-250）， &lt;code&gt;rating&lt;/code&gt; （以1-10的比例）， &lt;code&gt;title&lt;/code&gt; ， &lt;code&gt;votes&lt;/code&gt; 和 &lt;code&gt;year&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3bee24f1a9444db1641572680398af8a1e9f5a02" translate="yes" xml:space="preserve">
          <source>The table must be configured to have three or more replicas</source>
          <target state="translated">该表必须配置为有三个或更多的副本</target>
        </trans-unit>
        <trans-unit id="4be6c448f38373c6d6cf5f4315ebc31efcf470d8" translate="yes" xml:space="preserve">
          <source>The table stores a maximum of 1000 messages per server. The changefeed will not deliver events for log entries when they are removed.</source>
          <target state="translated">该表每个服务器最多存储 1000 条消息。当日志条目被删除时,changefeed将不会为其提供事件。</target>
        </trans-unit>
        <trans-unit id="67c77aec7a677d740204db26286743a08de27d11" translate="yes" xml:space="preserve">
          <source>The table&amp;rsquo;s primary key is the &lt;code&gt;id&lt;/code&gt; field, and the keys are always arrays. The first element in the array is always a string indicating the object type being queried (i.e., &lt;code&gt;&quot;table&quot;&lt;/code&gt;, &lt;code&gt;&quot;server&quot;&lt;/code&gt;, etc.); for all objects but the cluster (which has only one document in the &lt;code&gt;stats&lt;/code&gt; table), the second element is the UUID of the object being queried.</source>
          <target state="translated">该表的主键是 &lt;code&gt;id&lt;/code&gt; 字段，并且键始终是数组。数组中的第一个元素始终是一个字符串，该字符串指示要查询的对象类型（即 &lt;code&gt;&quot;table&quot;&lt;/code&gt; ， &lt;code&gt;&quot;server&quot;&lt;/code&gt; 等）；对于除群集（ &lt;code&gt;stats&lt;/code&gt; 中只有一个文档）之外的所有对象，第二个元素是要查询的对象的UUID。</target>
        </trans-unit>
        <trans-unit id="4af84b2b5658b67fb03036b287f81c0ea4dc3b25" translate="yes" xml:space="preserve">
          <source>The table&amp;rsquo;s primary key is the &lt;code&gt;id&lt;/code&gt; field, and the keys are always arrays. The first element in the array is always a string indicating the type of job (e.g., &lt;code&gt;&quot;query&quot;&lt;/code&gt;, &lt;code&gt;&quot;disk_compaction&quot;&lt;/code&gt;, etc.); the second element is the UUID of the job. The type of job is also given in the &lt;code&gt;type&lt;/code&gt; field.</source>
          <target state="translated">该表的主键是 &lt;code&gt;id&lt;/code&gt; 字段，并且键始终是数组。数组中的第一个元素始终是指示作业类型的字符串（例如 &lt;code&gt;&quot;query&quot;&lt;/code&gt; ， &lt;code&gt;&quot;disk_compaction&quot;&lt;/code&gt; 等）；第二个元素是作业的UUID。作业的类型也在 &lt;code&gt;type&lt;/code&gt; 字段中给出。</target>
        </trans-unit>
        <trans-unit id="45cd12e06348bca2dd80568fa923b95cdcd2c00d" translate="yes" xml:space="preserve">
          <source>The third layers builds on the previous two and provides the user with command line and web-based tools to control the cluster.</source>
          <target state="translated">第三层在前两层的基础上,为用户提供了命令行和基于Web的工具来控制集群。</target>
        </trans-unit>
        <trans-unit id="f6d1631967f3c75d8b045a65b29120cdf51ee7e5" translate="yes" xml:space="preserve">
          <source>The token is a unique integer per connection. Keeping a counter per connection is a simple way to implement it.</source>
          <target state="translated">token是每个连接的唯一整数。为每个连接保留一个计数器是一种简单的实现方式。</target>
        </trans-unit>
        <trans-unit id="466d055f41cbd22991febcdb9bc74645f65ffa5e" translate="yes" xml:space="preserve">
          <source>The top-level ReQL namespace.</source>
          <target state="translated">顶级的ReQL命名空间。</target>
        </trans-unit>
        <trans-unit id="b41045caf64cf3a3c5b73e63bfcd20c490c63cbe" translate="yes" xml:space="preserve">
          <source>The two most important aspects of the execution engine is that every query is completely parallelized across the cluster, and that queries are evaluated lazily. For instance, if the client requests only one document, RethinkDB will try to do just enough work to return this document, and will not process every shard in its entirety. This allows for large, complicated queries to execute in a very efficient way.</source>
          <target state="translated">执行引擎最重要的两个方面是,每个查询都是在集群中完全并行化的,而且查询的评估是懒惰的。例如,如果客户端只请求一个文档,RethinkDB会尽量只做足够的工作来返回这个文档,而不会完整地处理每个碎片。这样就可以非常高效地执行大型复杂的查询。</target>
        </trans-unit>
        <trans-unit id="cf5d5fdab91cb54e7ea1d05ea3a02e8164908734" translate="yes" xml:space="preserve">
          <source>The type of data &lt;code&gt;binary&lt;/code&gt; accepts depends on the client language. In JavaScript, it expects a &lt;a href=&quot;http://nodejs.org&quot;&gt;Node.js&lt;/a&gt;&lt;code&gt;Buffer&lt;/code&gt;. Using a &lt;code&gt;Buffer&lt;/code&gt; object within a query implies the use of &lt;code&gt;binary&lt;/code&gt; and the ReQL driver will automatically perform the coercion.</source>
          <target state="translated">&lt;code&gt;binary&lt;/code&gt; 接受的数据类型取决于客户端语言。在JavaScript中，它需要一个&lt;a href=&quot;http://nodejs.org&quot;&gt;Node.js &lt;/a&gt; &lt;code&gt;Buffer&lt;/code&gt; 。在查询中使用 &lt;code&gt;Buffer&lt;/code&gt; 对象意味着将使用 &lt;code&gt;binary&lt;/code&gt; ，ReQL驱动程序将自动执行强制转换。</target>
        </trans-unit>
        <trans-unit id="7cf930814fe3eaac8532459ad55f2f6375a3b9e8" translate="yes" xml:space="preserve">
          <source>The type will be returned as a string:</source>
          <target state="translated">类型将以字符串形式返回。</target>
        </trans-unit>
        <trans-unit id="5bbbb2de3860c2f10b7d816ad7baeb36022c1e11" translate="yes" xml:space="preserve">
          <source>The update command will go through every row and issue an API request to the GitHub URL for the given user, grab the relevant data, and update the user information with that data!</source>
          <target state="translated">更新命令会查看每一行,并向给定用户的GitHub URL发出API请求,抓取相关数据,并用这些数据更新用户信息!</target>
        </trans-unit>
        <trans-unit id="d6834cea4439bc5555fa593bfe010a1c4b3e8728" translate="yes" xml:space="preserve">
          <source>The value for &lt;code&gt;iterations&lt;/code&gt; is a tradeoff between performance and security against brute force attacks. If connections are slow, consider lowering the number of iterations. Raising the number of iterations will make it harder to use a brute force attack, but will increase the CPU usage on clients while establishing a connection.</source>
          <target state="translated">&lt;code&gt;iterations&lt;/code&gt; 的价值是在性能和​​安全性之间进行权衡，以抵御暴力攻击。如果连接速度很慢，请考虑减少迭代次数。增加迭代次数将使使用蛮力攻击更加困难，但会在建立连接时增加客户端上的CPU使用率。</target>
        </trans-unit>
        <trans-unit id="c8f4326f44c3a4e70aa078a4d1ef6136197b6c59" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;connection&lt;/code&gt; is now initialized and we can run queries.</source>
          <target state="translated">现在，变量 &lt;code&gt;connection&lt;/code&gt; 已初始化，我们可以运行查询。</target>
        </trans-unit>
        <trans-unit id="ae352b30a0ea50d1839336defec725fd2135db8a" translate="yes" xml:space="preserve">
          <source>The various &lt;code&gt;on_*&lt;/code&gt; methods provide fallbacks for one another:</source>
          <target state="translated">各种 &lt;code&gt;on_*&lt;/code&gt; 方法可互相提供后备：</target>
        </trans-unit>
        <trans-unit id="8a205ac1eb38bfbb096a68973349763844c85250" translate="yes" xml:space="preserve">
          <source>The web UI only affects servers with the &lt;code&gt;default&lt;/code&gt; tag. If you remove the &lt;code&gt;default&lt;/code&gt; tag from a server or start it without that tag, it will not be used for tables configured through the web UI.</source>
          <target state="translated">Web UI仅影响具有 &lt;code&gt;default&lt;/code&gt; 标记的服务器。如果您从服务器上删除 &lt;code&gt;default&lt;/code&gt; 标签或在没有该标签的情况下启动它，那么它将不会用于通过Web UI配置的表。</target>
        </trans-unit>
        <trans-unit id="46633f21ecb5a76f2aebb7bf842e88c3bda5f0fe" translate="yes" xml:space="preserve">
          <source>The web UI requires &lt;code&gt;DataView&lt;/code&gt; and &lt;code&gt;Uint8Array&lt;/code&gt; JavaScript features to be supported by your browser.</source>
          <target state="translated">Web UI要求浏览器支持 &lt;code&gt;DataView&lt;/code&gt; 和 &lt;code&gt;Uint8Array&lt;/code&gt; JavaScript功能。</target>
        </trans-unit>
        <trans-unit id="19c6c96199f3171355430a94a64a0f33d4759d04" translate="yes" xml:space="preserve">
          <source>The web UI supports creation and deletion of simple secondary indexes. In the table list, click on the table &lt;code&gt;users&lt;/code&gt;. You can manipulate indexes through the secondary index panel in the table view.</source>
          <target state="translated">Web UI支持创建和删除简单的二级索引。在表列表中，单击表 &lt;code&gt;users&lt;/code&gt; 。您可以通过表视图中的二级索引面板来操作索引。</target>
        </trans-unit>
        <trans-unit id="835e5ac2124d7adb55a81eefe9733c24756faad2" translate="yes" xml:space="preserve">
          <source>The web administration UI always connects as if it were the &lt;code&gt;admin&lt;/code&gt; user, and skips the authentication process (i.e., the password is not used for this connection). While the web UI cannot be password-protected, you can limit the addresses it will accept connections on using the &lt;code&gt;--bind-http&lt;/code&gt; command line option. For more details on this, review &lt;a href=&quot;../security/index#securing-the-web-interface&quot;&gt;Secure your cluster&lt;/a&gt;.</source>
          <target state="translated">Web管理UI始终像 &lt;code&gt;admin&lt;/code&gt; 用户一样进行连接，并跳过身份验证过程（即，该连接未使用密码）。虽然无法使用密码保护Web UI，但是可以使用 &lt;code&gt;--bind-http&lt;/code&gt; 命令行选项限制它接受连接的地址。有关更多信息，请查看&lt;a href=&quot;../security/index#securing-the-web-interface&quot;&gt;保护您的集群&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c23b44b5fa92781014237ab0b6407a8b0dec1e43" translate="yes" xml:space="preserve">
          <source>The web interface</source>
          <target state="translated">网页界面</target>
        </trans-unit>
        <trans-unit id="e76bb2e6186f4296fdc2ce7806daa233e0129060" translate="yes" xml:space="preserve">
          <source>The wrapped query message (QueryType, serialized query and options)</source>
          <target state="translated">封装的查询信息(QueryType,序列化查询和选项)。</target>
        </trans-unit>
        <trans-unit id="5a9dd02e0e3fec7b03eb0481b5b9083049419d70" translate="yes" xml:space="preserve">
          <source>The wrapped query message sent to the server is an array of three elements:</source>
          <target state="translated">发送给服务器的封装查询消息是一个由三个元素组成的数组。</target>
        </trans-unit>
        <trans-unit id="11526202a4159cbc549e507781f630a99b427910" translate="yes" xml:space="preserve">
          <source>The write acknowledgement setting for a table controls when the cluster acknowledges a write request as fulfilled. There are two possible settings:</source>
          <target state="translated">表的写确认设置控制集群何时确认写请求已完成。有两种可能的设置。</target>
        </trans-unit>
        <trans-unit id="47a108c7b7e30ffc4e3685e98ee4b64f37fa6b38" translate="yes" xml:space="preserve">
          <source>Then as before, we map each post to the number &lt;code&gt;1&lt;/code&gt;. Commands after the &lt;code&gt;group&lt;/code&gt; command will be applied to each grouped set.</source>
          <target state="translated">然后像以前一样，将每个帖子映射到数字 &lt;code&gt;1&lt;/code&gt; 。 &lt;code&gt;group&lt;/code&gt; 命令之后的命令将应用于每个分组集。</target>
        </trans-unit>
        <trans-unit id="373f73812762c7dc46fcca04a15315b885d341a8" translate="yes" xml:space="preserve">
          <source>Then make sure to move or delete the old RethinkDB data directory (&lt;code&gt;rethinkdb_data&lt;/code&gt; by default), since the new version will not be able to read the old file.</source>
          <target state="translated">然后，请确保移动或删除旧的RethinkDB数据目录（默认情况下为 &lt;code&gt;rethinkdb_data&lt;/code&gt; ），因为新版本将无法读取旧文件。</target>
        </trans-unit>
        <trans-unit id="85735e42e3c49d21bec18736a350e53f8ef64177" translate="yes" xml:space="preserve">
          <source>Then open your browser:</source>
          <target state="translated">然后打开浏览器。</target>
        </trans-unit>
        <trans-unit id="20dc328e896c46407854b85c49918fd88856739d" translate="yes" xml:space="preserve">
          <source>Then start RethinkDB on the second machine:</source>
          <target state="translated">然后在第二台机器上启动RethinkDB。</target>
        </trans-unit>
        <trans-unit id="cf05db71c2c2b82022a19f45d7550290ae72ac9b" translate="yes" xml:space="preserve">
          <source>Then you can use that index in the &lt;code&gt;group&lt;/code&gt; function. This query would return the highest-value invoice for each day.</source>
          <target state="translated">然后，您可以在 &lt;code&gt;group&lt;/code&gt; 函数中使用该索引。该查询将返回每天的最高值发票。</target>
        </trans-unit>
        <trans-unit id="777999d7676c59ebd630e109f25af12b28bcb677" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll need to create the RethinkDB data directory.</source>
          <target state="translated">然后，您需要创建RethinkDB数据目录。</target>
        </trans-unit>
        <trans-unit id="61bfdd81f4b7a5981123dcfefee521c9149dc1b8" translate="yes" xml:space="preserve">
          <source>Then, copy the sample configuration file and use the &lt;a href=&quot;../config-file/index&quot;&gt;configuration file&lt;/a&gt; documentation as a guide to customize it. (If you don&amp;rsquo;t have the sample &lt;code&gt;.conf&lt;/code&gt; file, you can download it &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;here&lt;/a&gt;.)</source>
          <target state="translated">然后，复制样本配置文件，并使用&lt;a href=&quot;../config-file/index&quot;&gt;配置文件&lt;/a&gt;文档作为自定义指南。（如果没有示例 &lt;code&gt;.conf&lt;/code&gt; 文件，则可以&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;在此处&lt;/a&gt;下载。）</target>
        </trans-unit>
        <trans-unit id="a3fb4e7ad8aef52a7890cc49ca8ea407afa881ff" translate="yes" xml:space="preserve">
          <source>Then, enable the service:</source>
          <target state="translated">然后,启用服务。</target>
        </trans-unit>
        <trans-unit id="11bdef9943474cec9139375264eb2ce91de1c8ea" translate="yes" xml:space="preserve">
          <source>Then, generate a certificate, &lt;code&gt;cert.pem&lt;/code&gt;, from that key:</source>
          <target state="translated">然后，从该密钥生成证书 &lt;code&gt;cert.pem&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f5ea72c2d37c2b1c37bd8b7ebe6736cad9811c2e" translate="yes" xml:space="preserve">
          <source>Then, import the RethinkDB driver:</source>
          <target state="translated">然后,导入RethinkDB驱动。</target>
        </trans-unit>
        <trans-unit id="ee598540a861f6fcc6ac7ae1337575b517fbede7" translate="yes" xml:space="preserve">
          <source>Then, restart the service:</source>
          <target state="translated">然后,重新启动服务。</target>
        </trans-unit>
        <trans-unit id="e11ea22ba5fd48e949819f8d6852dd06f4fcead4" translate="yes" xml:space="preserve">
          <source>Then, start RethinkDB with its default options.</source>
          <target state="translated">然后,用默认选项启动RethinkDB。</target>
        </trans-unit>
        <trans-unit id="0dc97a274d3921d7624f9e93eda6738f45944317" translate="yes" xml:space="preserve">
          <source>Then, subscribers could listen for messages with any combination of tags:</source>
          <target state="translated">然后,用户可以用任意组合的标签收听消息。</target>
        </trans-unit>
        <trans-unit id="a0ff0e7a5afdd6b7af8306c4a3ef8b9cdf8beb45" translate="yes" xml:space="preserve">
          <source>Then, there are two functions for retrieving files: one to retrieve a directory of a user&amp;rsquo;s uploaded files (&lt;code&gt;getUserFileIDs&lt;/code&gt;) and one to retrieve the actual file itself (&lt;code&gt;getFile&lt;/code&gt;). We don&amp;rsquo;t have to use &lt;code&gt;binary&lt;/code&gt; again here; the ReQL driver will return the proper data type for the &lt;code&gt;file&lt;/code&gt; field in our object.</source>
          <target state="translated">然后，有两种用于检索文件的功能：一种用于检索用户上载文件的目录（ &lt;code&gt;getUserFileIDs&lt;/code&gt; ），另一种用于检索实际文件本身（ &lt;code&gt;getFile&lt;/code&gt; ）。我们不必在这里再次使用 &lt;code&gt;binary&lt;/code&gt; 。ReQL驱动程序将为我们对象中的 &lt;code&gt;file&lt;/code&gt; 字段返回正确的数据类型。</target>
        </trans-unit>
        <trans-unit id="3296464e11028ef43904be0c240bf019c7b106a0" translate="yes" xml:space="preserve">
          <source>Then, to listen to messages, just provide a callback to the &lt;code&gt;.subscribe()&lt;/code&gt; method on the queue:</source>
          <target state="translated">然后，要侦听消息，只需在队列上提供对 &lt;code&gt;.subscribe()&lt;/code&gt; 方法的回调：</target>
        </trans-unit>
        <trans-unit id="c41f2ba74cf07c786c81edddddb4f3b2805474be" translate="yes" xml:space="preserve">
          <source>Then, we add the &lt;code&gt;tableCreate&lt;/code&gt; command to create the actual table.</source>
          <target state="translated">然后，我们添加 &lt;code&gt;tableCreate&lt;/code&gt; 命令来创建实际的表。</target>
        </trans-unit>
        <trans-unit id="fb8c1b60653312846c75686a1276635b4ed825ca" translate="yes" xml:space="preserve">
          <source>There are a couple of things to note about this query:</source>
          <target state="translated">关于这个疑问,有几点需要注意。</target>
        </trans-unit>
        <trans-unit id="a23dd3c8cb9731a3fd1112c01afc115df9338b76" translate="yes" xml:space="preserve">
          <source>There are currently two states:</source>
          <target state="translated">目前有两个州。</target>
        </trans-unit>
        <trans-unit id="50ea354dfdde1a79f1cc524cc5796f0426d4d12f" translate="yes" xml:space="preserve">
          <source>There are different publish-subscribe variations, so here we&amp;rsquo;ll describe the type using a central topic exchange. In this model, publishers connect to the central exchange and broadcast a message with a given topic. When subscribers connect, they notify the exchange about what kinds of messages they&amp;rsquo;re interested in. The exchange is then responsible for filtering messages.</source>
          <target state="translated">有不同的发布-订阅变体，因此在这里我们将使用中心主题交换来描述类型。在此模型中，发布者连接到中央交换机并广播具有给定主题的消息。当订户连接时，他们将他们感兴趣的消息通知交换所。交换所然后负责过滤消息。</target>
        </trans-unit>
        <trans-unit id="5e6a261f4a90188d0d21308eb4518c242c3ee55a" translate="yes" xml:space="preserve">
          <source>There are four different permissions that can be granted to a user:</source>
          <target state="translated">有四种不同的权限可以授予用户。</target>
        </trans-unit>
        <trans-unit id="32c898affbf2b04845b19d3ef8037b56ffc7b0d6" translate="yes" xml:space="preserve">
          <source>There are four different permissions that can be granted to an account:</source>
          <target state="translated">有四种不同的权限可以授予一个账户。</target>
        </trans-unit>
        <trans-unit id="52482533c49305cf3ba538f7607584d817448f16" translate="yes" xml:space="preserve">
          <source>There are four kinds of jobs. The document schema is consistent between them, with job-specific data appearing in the &lt;code&gt;info&lt;/code&gt; field.</source>
          <target state="translated">有四种工作。它们之间的文档架构是一致的，在 &lt;code&gt;info&lt;/code&gt; 字段中显示特定于作业的数据。</target>
        </trans-unit>
        <trans-unit id="886bf75dd348fa061a7ef813ce2b2a8d5e1d33e4" translate="yes" xml:space="preserve">
          <source>There are more options than what we&amp;rsquo;ve covered here. Run &lt;code&gt;rethinkdb help import&lt;/code&gt; for a full list of parameters and examples.</source>
          <target state="translated">除了这里介绍的内容以外，还有更多选择。运行 &lt;code&gt;rethinkdb help import&lt;/code&gt; 获取完整的参数和示例列表。</target>
        </trans-unit>
        <trans-unit id="cb609b83989bc8962ca574f2727ce880206e9583" translate="yes" xml:space="preserve">
          <source>There are multiple subscriptions we could have set up that would receive this news:</source>
          <target state="translated">我们可以设置多个订阅,来接收这个消息。</target>
        </trans-unit>
        <trans-unit id="c38856d11ec968183c07a941fbd374de03ae8440" translate="yes" xml:space="preserve">
          <source>There are multiple ways to paginate results in RethinkDB. The most straightforward way is using &lt;code&gt;skip&lt;/code&gt; and &lt;code&gt;limit&lt;/code&gt; (similar to the way SQL&amp;rsquo;s &lt;code&gt;OFFSET&lt;/code&gt; and &lt;code&gt;LIMIT&lt;/code&gt; work), but that&amp;rsquo;s also the least efficient. It&amp;rsquo;s more efficient to use &lt;code&gt;slice&lt;/code&gt;, and even more efficient to use &lt;code&gt;between&lt;/code&gt; with a secondary index.</source>
          <target state="translated">RethinkDB中有多种分页结果的方法。最直接的方法是使用 &lt;code&gt;skip&lt;/code&gt; 和 &lt;code&gt;limit&lt;/code&gt; （类似于SQL的 &lt;code&gt;OFFSET&lt;/code&gt; 和 &lt;code&gt;LIMIT&lt;/code&gt; 的工作方式），但这也是效率最低的。使用 &lt;code&gt;slice&lt;/code&gt; 会更有效， &lt;code&gt;between&lt;/code&gt; 辅助索引之间使用更加有效。</target>
        </trans-unit>
        <trans-unit id="e3d0701e5c4ffb4f00017a0efde2655267d62238" translate="yes" xml:space="preserve">
          <source>There are only three useful things you can do with a time: modify it, compare it to another time, or retrieve a portion of it.</source>
          <target state="translated">你可以对一个时间做的事情只有三件:修改它,与另一个时间比较,或检索其中的一部分。</target>
        </trans-unit>
        <trans-unit id="20d0f3c1694126ef828f7b9c9046e4cd07be046f" translate="yes" xml:space="preserve">
          <source>There are six optional arguments to &lt;code&gt;changes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;changes&lt;/code&gt; 有六个可选参数。</target>
        </trans-unit>
        <trans-unit id="3dbdf1c4e79d2810c4de37e0b75ee18a93c58c48" translate="yes" xml:space="preserve">
          <source>There are some limitations and caveats on chaining with changefeeds.</source>
          <target state="translated">使用changefeeds进行链式连接有一些限制和注意事项。</target>
        </trans-unit>
        <trans-unit id="9e894103cc8b90a96e8dfc7a000aa22e6638f5e5" translate="yes" xml:space="preserve">
          <source>There are three major sources of memory use in RethinkDB:</source>
          <target state="translated">RethinkDB的内存使用主要有三个来源。</target>
        </trans-unit>
        <trans-unit id="6109eedf0d15d10946505da2e66b0a1f37da67ab" translate="yes" xml:space="preserve">
          <source>There are three primary commands for changing sharding and replication in ReQL. In addition, there are lower-level values that can be changed by manipulating &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt;.</source>
          <target state="translated">在ReQL中，有三个主要命令用于更改分片和复制。另外，还有一些较低级别的值可以通过&lt;a href=&quot;../system-tables/index&quot;&gt;操作系统表&lt;/a&gt;来更改。</target>
        </trans-unit>
        <trans-unit id="75c7501f6c75b26a129e17d9ac77b7c99d5158a9" translate="yes" xml:space="preserve">
          <source>There are two main methods RethinkDB provides for securing the cluster: TLS encryption for connections, and binding the ports the server uses to specific IP addresses to limit outside connections.</source>
          <target state="translated">RethinkDB主要提供了两种方法来保证集群的安全。为连接进行TLS加密,以及将服务器使用的端口绑定到特定的IP地址来限制外部连接。</target>
        </trans-unit>
        <trans-unit id="f665401e538bf2bfb28ca2c473bf66cdb74afaf6" translate="yes" xml:space="preserve">
          <source>There are two optional arguments.</source>
          <target state="translated">有两个可选参数。</target>
        </trans-unit>
        <trans-unit id="0b88a8c857155f74745bbba8371ea96ca0e6acb6" translate="yes" xml:space="preserve">
          <source>There are two ways a write operation can fail. If a write fails &lt;strong&gt;definitively,&lt;/strong&gt; no read will ever see it, even in the weaker read modes. If it fails &lt;strong&gt;indeterminately,&lt;/strong&gt; reads run in &lt;code&gt;single&lt;/code&gt; or &lt;code&gt;outdated&lt;/code&gt; modes might see it, but when the network failure or crash that caused the problem is resolved the write might or might not be rolled back. In general, writes will fail indeterminately if they were running at the exact moment when the network or server issue first happened. Both of these failures will generate errors, and you can examine the error message to see whether the failure was definitive or indeterminate.</source>
          <target state="translated">写入操作可能会以两种方式失败。如果写入操作&lt;strong&gt;最终&lt;/strong&gt;失败，即使在较弱的读取模式下也不会读取。如果&lt;strong&gt;不确定地&lt;/strong&gt;失败&lt;strong&gt;，则&lt;/strong&gt;可能会看到以 &lt;code&gt;single&lt;/code&gt; 或 &lt;code&gt;outdated&lt;/code&gt; 模式运行的读取，但是当导致问题的网络故障或崩溃得以解决后，写入可能会或可能不会回滚。通常，如果写入恰好在首次发生网络或服务器问题的那一刻运行，则写入将不确定地失败。这两种故障都会产生错误，您可以检查错误消息以查看故障是确定的还是不确定的。</target>
        </trans-unit>
        <trans-unit id="500288a5784a07d1f133215bca8ff9857c28adf3" translate="yes" xml:space="preserve">
          <source>There are two ways to model relationships between documents in RethinkDB:</source>
          <target state="translated">在RethinkDB中,文档之间的关系有两种建模方式。</target>
        </trans-unit>
        <trans-unit id="d694c51ef35209adcd08ccf24e3a25d1dad7f109" translate="yes" xml:space="preserve">
          <source>There is little to no chance of security issues that arise from string injection attacks.</source>
          <target state="translated">几乎不存在因字符串注入攻击而产生安全问题的可能性。</target>
        </trans-unit>
        <trans-unit id="40f84b9a87e9e02fe596b7aede64a1239440fef1" translate="yes" xml:space="preserve">
          <source>There is no limitation on the number of posts, so this approach is more suitable for large amounts of data.</source>
          <target state="translated">对帖子的数量没有限制,所以这种方法更适合大量的数据。</target>
        </trans-unit>
        <trans-unit id="95ebbd6e44279cc8790e0813ade721a8b8cfd992" translate="yes" xml:space="preserve">
          <source>There is no new syntax or new commands for complex queries. Once you understand the composition principle you can write new queries without learning anything else.</source>
          <target state="translated">对于复杂的查询,没有新的语法或新的命令。一旦你理解了组成原理,你就可以写出新的查询,而不需要学习其他的东西。</target>
        </trans-unit>
        <trans-unit id="539a61fd005fdf182e291c26a8ea7bd3dde87263" translate="yes" xml:space="preserve">
          <source>There is very comprehensive documentation of &lt;a href=&quot;http://nobrainer.io/docs/querying/&quot;&gt;NoBrainer&amp;rsquo;s query language&lt;/a&gt;, and its capabilities. NoBrainer&amp;rsquo;s language is built on top of ReQL, so if you know how to do something in ReQL, it should be straightforward to translate it.</source>
          <target state="translated">关于&lt;a href=&quot;http://nobrainer.io/docs/querying/&quot;&gt;NoBrainer的查询语言&lt;/a&gt;及其功能，有非常全面的文档。NoBrainer的语言是建立在ReQL之上的，因此，如果您知道如何在ReQL中做某事，翻译它应该很简单。</target>
        </trans-unit>
        <trans-unit id="df2ddd5eb9c85f2c5d0c2cdef8e0ff78782ff6a5" translate="yes" xml:space="preserve">
          <source>There will be one issue per name in conflict.</source>
          <target state="translated">冲突中每个名字将有一个问题。</target>
        </trans-unit>
        <trans-unit id="65f37cec946cc13932c02805b52c0981c77aac29" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a separate article, &lt;a href=&quot;../table-joins/index&quot;&gt;Table joins in RethinkDB&lt;/a&gt;, with much more information about the multiple-table approach, including how to do the ReQL equivalents of inner, outer and cross joins. If you aren&amp;rsquo;t sure which schema to use, ask us on &lt;a href=&quot;http://stackoverflow.com/questions/ask&quot;&gt;Stack Overflow&lt;/a&gt; or join the &lt;code&gt;#rethinkdb&lt;/code&gt; IRC channel on &lt;a href=&quot;http://www.freenode.org/&quot;&gt;Freenode&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../table-joins/index&quot;&gt;在RethinkDB中&lt;/a&gt;有另一篇文章，表联接，有关多表方法的更多信息，包括如何进行内部，外部和交叉联接的ReQL等效。如果不确定使用哪种模式，请在&lt;a href=&quot;http://stackoverflow.com/questions/ask&quot;&gt;Stack Overflow&lt;/a&gt;上询问我们，或在&lt;a href=&quot;http://www.freenode.org/&quot;&gt;Freenode&lt;/a&gt;上加入 &lt;code&gt;#rethinkdb&lt;/code&gt; IRC频道。</target>
        </trans-unit>
        <trans-unit id="255b3e7dcb8b478414bde749509dfb707e256261" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also the &lt;a href=&quot;../../../api/javascript/during/index&quot;&gt;during&lt;/a&gt; command, which can check whether a time is in a particular range of times.</source>
          <target state="translated">另外还有&amp;ldquo; &lt;a href=&quot;../../../api/javascript/during/index&quot;&gt;期间&amp;rdquo;&lt;/a&gt;命令，它可以检查时间是否在特定的时间范围内。</target>
        </trans-unit>
        <trans-unit id="309e4b22505e880972a173dadd6710f8768bb239" translate="yes" xml:space="preserve">
          <source>These can be executed in the Data Explorer to try out RethinkDB&amp;rsquo;s geospatial support.</source>
          <target state="translated">可以在数据资源管理器中执行这些操作，以试用RethinkDB的地理空间支持。</target>
        </trans-unit>
        <trans-unit id="e8c3ca286bcb01488ff4b1b7840f17718d02289a" translate="yes" xml:space="preserve">
          <source>These drivers have been updated to use the JSON driver protocol and at least RethinkDB 2.0 ReQL.</source>
          <target state="translated">这些驱动已经更新为使用JSON驱动协议和至少是RethinkDB 2.0 ReQL。</target>
        </trans-unit>
        <trans-unit id="7390fee221f918304e3f706816a48b3e50189077" translate="yes" xml:space="preserve">
          <source>These drivers may not support all of RethinkDB 2.0's ReQL. However, if you wish to work with one of these languages, they may provide a good starting point.</source>
          <target state="translated">这些驱动程序可能不支持RethinkDB 2.0的所有ReQL。然而,如果你想使用这些语言中的一种,它们可以提供一个良好的起点。</target>
        </trans-unit>
        <trans-unit id="b8830b150e94f8e0e7316103afc9f8c34e10bcc8" translate="yes" xml:space="preserve">
          <source>These entries represent queries issued by a specific client.</source>
          <target state="translated">这些条目代表特定客户发出的查询。</target>
        </trans-unit>
        <trans-unit id="27d43bcbccbfa2aa21ba9dc356bde61777eca619" translate="yes" xml:space="preserve">
          <source>These evaluate to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">这些评估为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7dd8a76f2353c0d03a4bba453817d515bf5b73aa" translate="yes" xml:space="preserve">
          <source>These examples use Python, but there&amp;rsquo;s equivalent functionality in Ruby, and any other scripting language with a RethinkDB driver updated for version 1.16 or later. Read the API documentation for more information on specific commands along with descriptions of their return values.</source>
          <target state="translated">这些示例使用Python，但是在Ruby中具有等效功能，并且其他任何脚本语言都已为1.16版或更高版本更新了RethinkDB驱动程序。阅读API文档，以获取有关特定命令的更多信息以及它们的返回值的描述。</target>
        </trans-unit>
        <trans-unit id="bb99d9acc915cf6020285f96009c8736af483471" translate="yes" xml:space="preserve">
          <source>These may be specified as startup options to &lt;code&gt;rethinkdb&lt;/code&gt; or in the configuration file.</source>
          <target state="translated">这些可以指定为 &lt;code&gt;rethinkdb&lt;/code&gt; 的启动选项，也可以在配置文件中指定。</target>
        </trans-unit>
        <trans-unit id="dd1553d3431a9387915caf2bdf00cc7d8566a157" translate="yes" xml:space="preserve">
          <source>These options can be passed to the &lt;code&gt;rethinkdb&lt;/code&gt; server on the command line on startup. Many of these options can also be set in the configuration file; read &lt;a href=&quot;../config-file/index&quot;&gt;Configuration file options&lt;/a&gt; for a detailed list.</source>
          <target state="translated">这些选项可以在启动时通过命令行传递到 &lt;code&gt;rethinkdb&lt;/code&gt; 服务器。这些选项中的许多选项也可以在配置文件中设置。阅读&lt;a href=&quot;../config-file/index&quot;&gt;配置文件选项&lt;/a&gt;以获取详细列表。</target>
        </trans-unit>
        <trans-unit id="defbae41e4dfdca69a6819f0816da9b76a0d3ef9" translate="yes" xml:space="preserve">
          <source>These tasks cannot be performed through the web interface.</source>
          <target state="translated">这些任务无法通过网络界面执行。</target>
        </trans-unit>
        <trans-unit id="98980261bf21bdc07626834d6ab2bd419f725534" translate="yes" xml:space="preserve">
          <source>These tasks construct secondary indexes in the background. The &lt;code&gt;progress&lt;/code&gt; field is a number between 0 and 1 indicating how far along the index construction task is.</source>
          <target state="translated">这些任务在后台构造二级索引。该 &lt;code&gt;progress&lt;/code&gt; 字段，是指示多远沿指数编制任务是在0和1之间的数字。</target>
        </trans-unit>
        <trans-unit id="fa32730d8deba25793d975fc9ca7bd1549b1e9a2" translate="yes" xml:space="preserve">
          <source>These will be numeric values, corresponding to the types in &lt;code&gt;ql2.proto&lt;/code&gt;.</source>
          <target state="translated">这些将是数值，与 &lt;code&gt;ql2.proto&lt;/code&gt; 中的类型相对应。</target>
        </trans-unit>
        <trans-unit id="86ea5ad3004c53aee816959f875903b54616b1e0" translate="yes" xml:space="preserve">
          <source>They allow clients to receive changes on a table, a single document, or even the results from a specific query as they happen. Nearly any ReQL query can be turned into a changefeed.</source>
          <target state="translated">它们允许客户端在表、单个文档或甚至是特定查询的结果发生变化时接收变化。几乎所有的ReQL查询都可以变成一个变化feed。</target>
        </trans-unit>
        <trans-unit id="a73949fe5d7b6f10bad43de1b54b4ab3f1ca5501" translate="yes" xml:space="preserve">
          <source>Third-party admin tools</source>
          <target state="translated">第三方管理工具</target>
        </trans-unit>
        <trans-unit id="b72113e83e7d2971aadeb613ad353fd5b1504f55" translate="yes" xml:space="preserve">
          <source>Third-party administration tools</source>
          <target state="translated">第三方管理工具</target>
        </trans-unit>
        <trans-unit id="48032cfdd12c4e4801fb63f5130f887114e864cd" translate="yes" xml:space="preserve">
          <source>Third-party deployment tools</source>
          <target state="translated">第三方部署工具</target>
        </trans-unit>
        <trans-unit id="cd38f46529ac3ba0f37dc5014c00e6b8d7818624" translate="yes" xml:space="preserve">
          <source>Third-party libraries</source>
          <target state="translated">第三方图书馆</target>
        </trans-unit>
        <trans-unit id="9fe57a3efac3522bd52f774f6fbbf29694109b1a" translate="yes" xml:space="preserve">
          <source>Thirty-second quickstart</source>
          <target state="translated">三十秒快速启动</target>
        </trans-unit>
        <trans-unit id="6904ea0735b3e37923321c865579d4c8314dc798" translate="yes" xml:space="preserve">
          <source>Thirty-second quickstart with RethinkDB</source>
          <target state="translated">三十秒快速启动RethinkDB。</target>
        </trans-unit>
        <trans-unit id="1a3e4a37762f6f18b5db37b31335d439c9579506" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;user_data&lt;/code&gt; field to contain any legal JSON value, while &lt;code&gt;name&lt;/code&gt; must still be a valid string.</source>
          <target state="translated">这允许 &lt;code&gt;user_data&lt;/code&gt; 字段包含任何合法的JSON值，而 &lt;code&gt;name&lt;/code&gt; 仍必须是有效的字符串。</target>
        </trans-unit>
        <trans-unit id="f21998ea5369dd7c67fc23e4127c7487fa1fb7d8" translate="yes" xml:space="preserve">
          <source>This article will explain how to use repubsub, as well as describe how it&amp;rsquo;s implemented on top of changefeeds. If your application needs asynchronous broadcast notifications, this may be a good fit.</source>
          <target state="translated">本文将说明如何使用repubsub，并说明如何在changefeed上实现它。如果您的应用程序需要异步广播通知，则可能很合适。</target>
        </trans-unit>
        <trans-unit id="4ab295b90534ae1ba62c82bb793079aab7adfbee" translate="yes" xml:space="preserve">
          <source>This asserts that a topic exchange named &amp;ldquo;rethinkdb&amp;rdquo; exists, and that it&amp;rsquo;s set to be non-durable. If the exchange doesn&amp;rsquo;t exist, it&amp;rsquo;ll be created. If it does exist and has different properties, an exception will occur. Being non-durable means it won&amp;rsquo;t persist across RabbitMQ restarts (this is the default).</source>
          <target state="translated">这断言存在一个名为&amp;ldquo; rethinkdb&amp;rdquo;的主题交换，并且将其设置为非持久性。如果交换不存在，它将被创建。如果确实存在并且具有不同的属性，则会发生异常。不持久意味着它不会在RabbitMQ重新启动后持续存在（这是默认设置）。</target>
        </trans-unit>
        <trans-unit id="b512cd11bbaeb824c3cf95df0ce1530e7c842ef2" translate="yes" xml:space="preserve">
          <source>This behavior is similar to any other safe database system. Below is a number of steps you can take to speed up insert performance in RethinkDB. Most of these guidelines will also apply to other database systems.</source>
          <target state="translated">这种行为与其他安全数据库系统类似。下面是你可以采取的一些步骤来加快RethinkDB的插入性能。这些准则中的大部分也将适用于其他数据库系统。</target>
        </trans-unit>
        <trans-unit id="82fcad98e3ebc81b03b92fbcbc2a0eb46d0e10a1" translate="yes" xml:space="preserve">
          <source>This behavior may change in the future. See &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/3992&quot;&gt;Github issue #3992&lt;/a&gt; to track the discussion.</source>
          <target state="translated">这种行为将来可能会改变。请参阅&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/3992&quot;&gt;Github问题＃3992&lt;/a&gt;以跟踪讨论。</target>
        </trans-unit>
        <trans-unit id="7d333bc0db0fbff976dd318e4e97606ee1df8cf3" translate="yes" xml:space="preserve">
          <source>This can also be used to implement a check-and-set register. The following query will atomically check whether the &lt;code&gt;check&lt;/code&gt; field is equal to &lt;code&gt;old_value&lt;/code&gt; and change it to &lt;code&gt;new_value&lt;/code&gt; if so:</source>
          <target state="translated">这也可以用于实现检查设置寄存器。以下查询将自动检查 &lt;code&gt;check&lt;/code&gt; 字段是否等于 &lt;code&gt;old_value&lt;/code&gt; ，如果是，则将其更改为 &lt;code&gt;new_value&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="136a95a3ef0f44b9424d790086bf559ff51f2e02" translate="yes" xml:space="preserve">
          <source>This can be accomplished with &lt;a href=&quot;../has_fields/index&quot;&gt;hasFields&lt;/a&gt; rather than &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">这可以通过&lt;a href=&quot;../has_fields/index&quot;&gt;hasFields&lt;/a&gt;而不是 &lt;code&gt;default&lt;/code&gt; 来完成。</target>
        </trans-unit>
        <trans-unit id="2b17f23ecff1b552fca7bbe53044ccbc70aab57b" translate="yes" xml:space="preserve">
          <source>This can be useful for diagnostic purposes, as well as for filing bug reports. The easiest way to do this is with ReQL administration commands. Any individual table can be examined with &lt;code&gt;r.db('rethinkdb').table(&amp;lt;tablename&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">这对于诊断目的以及提交错误报告很有用。最简单的方法是使用ReQL管理命令。任何单独的表都可以使用 &lt;code&gt;r.db('rethinkdb').table(&amp;lt;tablename&amp;gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25b50bdea1677bf9f3cc6cf1c8fe6526f3ee4558" translate="yes" xml:space="preserve">
          <source>This command will export all your data to a &lt;code&gt;tar.gz&lt;/code&gt; file named &lt;code&gt;rethinkdb_dump_&amp;lt;timestamp&amp;gt;.tar.gz&lt;/code&gt; (this may vary depending on your platform).</source>
          <target state="translated">此命令会将所有数据导出到名为 &lt;code&gt;rethinkdb_dump_&amp;lt;timestamp&amp;gt;.tar.gz&lt;/code&gt; 的 &lt;code&gt;tar.gz&lt;/code&gt; 文件中（具体取决于您的平台）。</target>
        </trans-unit>
        <trans-unit id="de554f35b082125ac3ff33b85f9132341445f97f" translate="yes" xml:space="preserve">
          <source>This document describes how to start RethinkDB from the command line in several configurations, from a single instance on one machine to multiple instances on multiple machines.</source>
          <target state="translated">本文档介绍了如何从命令行启动RethinkDB的几种配置,从一台机器上的单个实例到多台机器上的多个实例。</target>
        </trans-unit>
        <trans-unit id="884a0999d1995cf78ebbbf8b08f0bb1e21cc671c" translate="yes" xml:space="preserve">
          <source>This document explains how to set up RethinkDB to run as a system service on supported operating systems, automatically launching on boot. For general instructions on starting RethinkDB, see &lt;a href=&quot;../start-a-server/index&quot;&gt;Start a RethinkDB server&lt;/a&gt;.</source>
          <target state="translated">本文档说明了如何设置RethinkDB以在受支持的操作系统上作为系统服务运行，并在启动时自动启动。有关启动RethinkDB的一般说明，请参阅&lt;a href=&quot;../start-a-server/index&quot;&gt;启动RethinkDB服务器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5e112ab270acffb2e520b045d4086e0a4758065b" translate="yes" xml:space="preserve">
          <source>This example in the Data Explorer demonstrates sorting mixed types:</source>
          <target state="translated">数据资源管理器中的这个示例演示了混合类型的排序。</target>
        </trans-unit>
        <trans-unit id="f60ec41c0244bc4bf79f1ba740c162008674fd3a" translate="yes" xml:space="preserve">
          <source>This example renames the field &lt;code&gt;id&lt;/code&gt; to &lt;code&gt;userId&lt;/code&gt; when retrieving documents from the table &lt;code&gt;users&lt;/code&gt;.</source>
          <target state="translated">此示例在从表 &lt;code&gt;users&lt;/code&gt; 检索文档时将字段 &lt;code&gt;id&lt;/code&gt; 重命名为 &lt;code&gt;userId&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05d221d0dc27530f067ff5358c8a277dc571c798" translate="yes" xml:space="preserve">
          <source>This grant can only be given on a global level.</source>
          <target state="translated">这笔赠款只能在全球范围内发放。</target>
        </trans-unit>
        <trans-unit id="badcd4b2105b2f046863005ef03daa5e931fc0ec" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;required&lt;/em&gt; if you&amp;rsquo;re upgrading from versions before 1.16; in those cases, you&amp;rsquo;ll need to upgrade to version 2.0.5 first. (You can download 2.0.5 and other older versions at RethinkDB&amp;rsquo;s &lt;a href=&quot;http://download.rethinkdb.com&quot;&gt;download archive&lt;/a&gt;). If you&amp;rsquo;re upgrading from RethinkDB version 1.16 or later, you can move to 2.2 or higher directly.</source>
          <target state="translated">如果要从1.16之前的版本升级，这是&lt;em&gt;必需的&lt;/em&gt;。在这种情况下，您需要先升级到2.0.5版。（您可以从RethinkDB的&lt;a href=&quot;http://download.rethinkdb.com&quot;&gt;下载档案中&lt;/a&gt;下载2.0.5和其他旧版本）。如果要从RethinkDB 1.16或更高版本升级，则可以直接移至2.2或更高版本。</target>
        </trans-unit>
        <trans-unit id="7690a03a80d488dfd784992d260be51267e9cf4b" translate="yes" xml:space="preserve">
          <source>This is a list of commands for updating data in the database.</source>
          <target state="translated">这是更新数据库中数据的命令列表。</target>
        </trans-unit>
        <trans-unit id="4094879dcd891fd3d505701f441b8c1edcdeb065" translate="yes" xml:space="preserve">
          <source>This is a list of queries for creating and dropping tables and databases.</source>
          <target state="translated">这是一个用于创建和删除表和数据库的查询列表。</target>
        </trans-unit>
        <trans-unit id="66b57e4c31062f253f74d06daaee496d81b79de2" translate="yes" xml:space="preserve">
          <source>This is a list of queries for deleting data from the database.</source>
          <target state="translated">这是一个从数据库中删除数据的查询列表。</target>
        </trans-unit>
        <trans-unit id="9db9a6dffeb553d1c76935d872aff66778ce1499" translate="yes" xml:space="preserve">
          <source>This is a list of queries for inserting data into a database.</source>
          <target state="translated">这是一个将数据插入数据库的查询列表。</target>
        </trans-unit>
        <trans-unit id="24cb2d221d2ccf3805e7df7390075b15277b1ff8" translate="yes" xml:space="preserve">
          <source>This is a list of queries for performing data aggregation.</source>
          <target state="translated">这是一个用于执行数据聚合的查询列表。</target>
        </trans-unit>
        <trans-unit id="57255ff40e07d35053520b96ede5ad2090e4b64c" translate="yes" xml:space="preserve">
          <source>This is a list of queries for performing joins between multiple tables.</source>
          <target state="translated">这是在多个表之间执行连接的查询列表。</target>
        </trans-unit>
        <trans-unit id="61a4e6ed605b06ae73e9999bd507404c4f0f7b89" translate="yes" xml:space="preserve">
          <source>This is a list of queries for selecting data out of a database.</source>
          <target state="translated">这是一个从数据库中选择数据的查询列表。</target>
        </trans-unit>
        <trans-unit id="c950bfcba327ffdf5a9d2f1ecf0f9730e6174c18" translate="yes" xml:space="preserve">
          <source>This is a typical document schema for a server connected to the host server&amp;mdash;that is, the server the client&amp;rsquo;s connecting to when they query the &lt;code&gt;server_status&lt;/code&gt; table.</source>
          <target state="translated">这是连接到主机服务器的服务器（即，当客户端查询 &lt;code&gt;server_status&lt;/code&gt; 表时客户端连接的服务器）的典型文档架构。</target>
        </trans-unit>
        <trans-unit id="495c13e74882e8a9b4dbc7d70144d347e8f36bb0" translate="yes" xml:space="preserve">
          <source>This is an ongoing task on each server, compacting RethinkDB&amp;rsquo;s storage space in the background. The &lt;code&gt;duration_sec&lt;/code&gt; field will always be &lt;code&gt;null&lt;/code&gt;, and there is no extra information metadata.</source>
          <target state="translated">这是每台服务器上正在进行的任务，在后台压缩RethinkDB的存储空间。该 &lt;code&gt;duration_sec&lt;/code&gt; 场永远是 &lt;code&gt;null&lt;/code&gt; ，而且没有额外的信息的元数据。</target>
        </trans-unit>
        <trans-unit id="744bd55da05671572fd0681cdeaea849a2d47d17" translate="yes" xml:space="preserve">
          <source>This is an overview of the system. For more details, consult the API documentation for individual geospatial commands.</source>
          <target state="translated">这是对系统的概述。更多细节,请查阅各个地理空间命令的API文档。</target>
        </trans-unit>
        <trans-unit id="9df7168c66a6de94c891ac3113c4fa363d86ea95" translate="yes" xml:space="preserve">
          <source>This is analogous to using &lt;strong&gt;apply&lt;/strong&gt; in JavaScript. (However, note that &lt;code&gt;args&lt;/code&gt; evaluates all its arguments before passing them into the parent term, even if the parent term otherwise allows lazy evaluation.)</source>
          <target state="translated">这是类似于使用&lt;strong&gt;适用&lt;/strong&gt;于JavaScript的。（但是，请注意， &lt;code&gt;args&lt;/code&gt; 在将其所有参数传递给父项之前先对其求值，即使父项否则允许进行惰性求值。）</target>
        </trans-unit>
        <trans-unit id="e6bc537c2149375b9bb8ea0948f4cb1e620a73ea" translate="yes" xml:space="preserve">
          <source>This is based on an example from &lt;a href=&quot;http://docs.mongodb.org/manual/tutorial/map-reduce-examples/&quot;&gt;MongoDB&lt;/a&gt;. Imagine a table of orders, with each document in the table structured like this:</source>
          <target state="translated">这基于&lt;a href=&quot;http://docs.mongodb.org/manual/tutorial/map-reduce-examples/&quot;&gt;MongoDB&lt;/a&gt;的示例。想象一个订单表，该表中的每个文档的结构如下：</target>
        </trans-unit>
        <trans-unit id="55687884bd6d8ee24ca5745c354a05190fdf9d33" translate="yes" xml:space="preserve">
          <source>This is equivalent to calling &lt;code&gt;SELECT name, age FROM users&lt;/code&gt; in SQL.</source>
          <target state="translated">这等效于在SQL中调用 &lt;code&gt;SELECT name, age FROM users&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fda8e7fa70fba551ec9a5ec7d7a2bfb32969507" translate="yes" xml:space="preserve">
          <source>This is equivalent to using the &lt;code&gt;db&lt;/code&gt; command to specify the database:</source>
          <target state="translated">这等效于使用 &lt;code&gt;db&lt;/code&gt; 命令指定数据库：</target>
        </trans-unit>
        <trans-unit id="d3bb2a306948c13f0ac184c0266661dd1de824fb" translate="yes" xml:space="preserve">
          <source>This is the alphabetical order of their type name as returned by the &lt;code&gt;typeOf()&lt;/code&gt; command. (Binary objects, geometry objects and times are &amp;ldquo;pseudotypes,&amp;rdquo; and return &lt;code&gt;PTYPE&amp;lt;BINARY&amp;gt;&lt;/code&gt;, &lt;code&gt;PTYPE&amp;lt;GEOMETRY&amp;gt;&lt;/code&gt; and &lt;code&gt;PTYPE&amp;lt;TIME&amp;gt;&lt;/code&gt;, respectively.)</source>
          <target state="translated">这是由 &lt;code&gt;typeOf()&lt;/code&gt; 命令返回的类型名称的字母顺序。 （二进制对象，几何对象和时间是&amp;ldquo;伪类型&amp;rdquo;，分别返回 &lt;code&gt;PTYPE&amp;lt;BINARY&amp;gt;&lt;/code&gt; ， &lt;code&gt;PTYPE&amp;lt;GEOMETRY&amp;gt;&lt;/code&gt; 和 &lt;code&gt;PTYPE&amp;lt;TIME&amp;gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="e85848e3ad69e8a64cb4101d0c2be64cba8259e9" translate="yes" xml:space="preserve">
          <source>This is the equivalent of the following:</source>
          <target state="translated">这相当于以下内容:</target>
        </trans-unit>
        <trans-unit id="3c3b90ecc4bbe7e0c4ecc1bb9f83e2950a385f51" translate="yes" xml:space="preserve">
          <source>This issue will appear at most once for each server.</source>
          <target state="translated">这个问题在每个服务器上最多出现一次。</target>
        </trans-unit>
        <trans-unit id="77ccacb7783df82d612f51e347348c7a7db7d8ce" translate="yes" xml:space="preserve">
          <source>This issue will appear at most once for each table.</source>
          <target state="translated">这个问题每张表最多出现一次。</target>
        </trans-unit>
        <trans-unit id="747341dedcda6a869995253b4dbc7ba5a4018242" translate="yes" xml:space="preserve">
          <source>This issue will only appear in the &lt;code&gt;current_issues&lt;/code&gt; table once&amp;mdash;check the &lt;code&gt;info&lt;/code&gt; field for the tables and indexes it affects.</source>
          <target state="translated">此问题仅会在 &lt;code&gt;current_issues&lt;/code&gt; 表中出现一次-检查 &lt;code&gt;info&lt;/code&gt; 字段以获取影响的表和索引。</target>
        </trans-unit>
        <trans-unit id="5ebc8aa4d2f21780ed5017f2917975404a143a19" translate="yes" xml:space="preserve">
          <source>This just creates a new &lt;code&gt;Comment&lt;/code&gt; and associates it with the current &lt;code&gt;Article&lt;/code&gt;, rather than using the &lt;code&gt;build&lt;/code&gt; method.</source>
          <target state="translated">这只是创建一个新的 &lt;code&gt;Comment&lt;/code&gt; 并将其与当前 &lt;code&gt;Article&lt;/code&gt; 关联，而不是使用 &lt;code&gt;build&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="0461d690717cd0e6df210318899cac20104d6444" translate="yes" xml:space="preserve">
          <source>This may also be specified in the &lt;a href=&quot;http://rethinkdb.com/docs/cluster-on-startup/&quot;&gt;config file&lt;/a&gt;.</source>
          <target state="translated">这也可以在&lt;a href=&quot;http://rethinkdb.com/docs/cluster-on-startup/&quot;&gt;配置文件中&lt;/a&gt;指定。</target>
        </trans-unit>
        <trans-unit id="2227c47b8b5a4f6a718999ee7cef861b0123236c" translate="yes" xml:space="preserve">
          <source>This may show you messages similar to this:</source>
          <target state="translated">这可能会让你看到类似这样的信息。</target>
        </trans-unit>
        <trans-unit id="26ab6e368431d7927f2a04b793ec9f220536744c" translate="yes" xml:space="preserve">
          <source>This means that every read will see every previous successful write, and no read will ever see a definitively failed write. (See note about definitively failed vs. indeterminate writes below.)</source>
          <target state="translated">这意味着每一次读取都会看到之前的每一次成功写入,而没有一次读取会出现明确失败的写入。(参见下面关于明确失败与不确定写入的说明)。(参见下面关于明确失败与不确定写入的说明)。</target>
        </trans-unit>
        <trans-unit id="6116a33e3ee4eebf769e234ae37a3a28895b7e1c" translate="yes" xml:space="preserve">
          <source>This message indicates there are currently servers that cannot see every server in the cluster. This may cause table availability issues. It can be resolved by restoring full connectivity.</source>
          <target state="translated">此消息表示目前有的服务器无法看到集群中的每个服务器。这可能会导致表的可用性问题。可以通过恢复完全连接来解决。</target>
        </trans-unit>
        <trans-unit id="b6c5c2546366708a269614bdd6393853b3b25fd1" translate="yes" xml:space="preserve">
          <source>This message is a warning that a &lt;a href=&quot;https://en.wikipedia.org/wiki/Paging&quot;&gt;page fault&lt;/a&gt; has occurred on a RethinkDB server and swap space is being used. Under Linux, this message will only appear if a RethinkDB process has started paging memory; under OS X, it will appear when &lt;em&gt;any&lt;/em&gt; process is paging. The Windows version of RethinkDB cannot detect when paging occurs.</source>
          <target state="translated">此消息是警告RethinkDB服务器上发生&lt;a href=&quot;https://en.wikipedia.org/wiki/Paging&quot;&gt;页面错误，&lt;/a&gt;并且正在使用交换空间。在Linux下，仅当RethinkDB进程已开始分页内存时，才会显示此消息；在OS X下，当&lt;em&gt;任何&lt;/em&gt;进程正在分页时，它将出现。Windows版本的RethinkDB无法检测到何时发生分页。</target>
        </trans-unit>
        <trans-unit id="5d4bf8bcc88e1e23ef0b9f22469b4f4fd3e521e9" translate="yes" xml:space="preserve">
          <source>This mode is &lt;strong&gt;not as safe&lt;/strong&gt; as the default hard durability mode. If you&amp;rsquo;re writing using soft durability, a few seconds worth of data might be lost in case of power failure.</source>
          <target state="translated">此模式不如默认的硬耐用性模式&lt;strong&gt;安全&lt;/strong&gt;。如果使用软耐用性进行写入，则在电源故障的情况下可能会丢失几秒钟的数据。</target>
        </trans-unit>
        <trans-unit id="03bae79890f9931111f7596cfde45eef26137817" translate="yes" xml:space="preserve">
          <source>This object is not a connection, but a cursor. To retrieve the results, you can call &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;each&lt;/code&gt; or &lt;code&gt;toArray&lt;/code&gt; on this object.</source>
          <target state="translated">该对象不是连接，而是游标。要检索结果，可以在此对象上 &lt;code&gt;each&lt;/code&gt; 调用 &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;toArray&lt;/code&gt; 或toArray。</target>
        </trans-unit>
        <trans-unit id="3c94199271f50662dc6a036ee949c151bf137f34" translate="yes" xml:space="preserve">
          <source>This opens up the possibility of notifying client applications immediately when a change occurs in a table. For real-time applications, this push behavior is essential.</source>
          <target state="translated">这开辟了当表发生变化时立即通知客户端应用程序的可能性。对于实时应用来说,这种推送行为是必不可少的。</target>
        </trans-unit>
        <trans-unit id="003d171c060f2713ec6326d898756333da62b72f" translate="yes" xml:space="preserve">
          <source>This option creates a random password for that server&amp;rsquo;s &lt;code&gt;admin&lt;/code&gt; account. Once that server is synchronized with the cluster, the random password will be overwritten by the &lt;code&gt;admin&lt;/code&gt; password, preventing the exploit described above.</source>
          <target state="translated">此选项为该服务器的 &lt;code&gt;admin&lt;/code&gt; 帐户创建一个随机密码。该服务器与群集同步后，随机密码将被 &lt;code&gt;admin&lt;/code&gt; 密码覆盖，从而防止上述漏洞利用。</target>
        </trans-unit>
        <trans-unit id="35f047d23d5560efaf4283d83fa25adfdafd890c" translate="yes" xml:space="preserve">
          <source>This particular example simply returns the error message, so it isn&amp;rsquo;t very useful. But it would be possible to change the default value based on the specific error message thrown.</source>
          <target state="translated">这个特定的示例仅返回错误消息，因此它不是很有用。但是可以根据抛出的特定错误消息来更改默认值。</target>
        </trans-unit>
        <trans-unit id="713c8d0837ca1d19105b3bc382212f39c5333371" translate="yes" xml:space="preserve">
          <source>This query can be rewritten with the &lt;code&gt;each&lt;/code&gt; command:</source>
          <target state="translated">可以使用 &lt;code&gt;each&lt;/code&gt; 命令来重写此查询：</target>
        </trans-unit>
        <trans-unit id="bd2d49b6729659af5432ba9236e6221e72845b7c" translate="yes" xml:space="preserve">
          <source>This query joins the &lt;code&gt;company_id&lt;/code&gt; of the employee table with the primary key of the company table. It returns a sequence of documents where each document contains two fields&amp;mdash;the employee information and the company information:</source>
          <target state="translated">该查询将雇员表的 &lt;code&gt;company_id&lt;/code&gt; 与公司表的主键连接在一起。它返回一系列文档，其中每个文档包含两个字段-员工信息和公司信息：</target>
        </trans-unit>
        <trans-unit id="612f4e9545d8bc014df5735c54ea0dbe678cc103" translate="yes" xml:space="preserve">
          <source>This query looks just like any other Python code you would normally write. Note that RethinkDB will execute this query on the server, and it doesn&amp;rsquo;t execute native Python code.</source>
          <target state="translated">该查询看起来与您通常编写的任何其他Python代码一样。请注意，RethinkDB将在服务器上执行此查询，并且不执行本机Python代码。</target>
        </trans-unit>
        <trans-unit id="dd03b43a9a0662e67f4621af412284eaccf6bc7d" translate="yes" xml:space="preserve">
          <source>This query makes a call to GitHub and returns an array of JSON documents. RethinkDB natively operates on JSON, and what&amp;rsquo;s really convenient about &lt;code&gt;r.http&lt;/code&gt; is that its output is no different from any other query. You can use ReQL commands to perform operations on the output of &lt;code&gt;r.http&lt;/code&gt;, just like on a standard RethinkDB table!</source>
          <target state="translated">该查询调用GitHub，并返回JSON文档数组。RethinkDB本机运行在JSON上，而 &lt;code&gt;r.http&lt;/code&gt; 真正的方便之处在于它的输出与任何其他查询没有什么不同。您可以使用ReQL命令在 &lt;code&gt;r.http&lt;/code&gt; 的输出上执行操作，就像在标准RethinkDB表上一样！</target>
        </trans-unit>
        <trans-unit id="c1ed5db3f58d8d8a4a7b6fd0156d19d27037316d" translate="yes" xml:space="preserve">
          <source>This query pulls out &lt;code&gt;new_val&lt;/code&gt; from the changefeed, and passes just the topic field from the new value down to the subscriber&amp;rsquo;s function.</source>
          <target state="translated">该查询从 &lt;code&gt;new_val&lt;/code&gt; 提取new_val，并将主题字段仅从新值传递到订阅者的函数。</target>
        </trans-unit>
        <trans-unit id="0504572bb7932c5f61e74e74594395b17470a17e" translate="yes" xml:space="preserve">
          <source>This query returns a cursor with one document&amp;mdash;the record for William Adama. The &lt;code&gt;filter&lt;/code&gt; command evaluates the provided condition for every row in the table, and returns only the relevant rows. Here&amp;rsquo;s the new commands we used to construct the condition above:</source>
          <target state="translated">该查询返回一个带有一个文档的游标-William Adama的记录。该 &lt;code&gt;filter&lt;/code&gt; 命令将评估表中的每一行所提供的条件，并且仅返回相关的行。这是我们用来构造上述条件的新命令：</target>
        </trans-unit>
        <trans-unit id="d6039c10afb25b25847b1d9787b22376a9ca0b91" translate="yes" xml:space="preserve">
          <source>This range includes all compound keys:</source>
          <target state="translated">这个范围包括所有复合键。</target>
        </trans-unit>
        <trans-unit id="7b1dd23beb1a551a08393d66db64399a66756207" translate="yes" xml:space="preserve">
          <source>This report describes a recent effort that the RethinkDB team took to measure our database product, RethinkDB, under different workloads and in different clustering configurations. We seek to provide a general overview of RethinkDB&amp;rsquo;s performance metrics for a variety of workloads and potential use cases. In this report some of the questions we&amp;rsquo;ll address include:</source>
          <target state="translated">该报告描述了RethinkDB团队最近在不同的工作负载和不同的集群配置下为衡量我们的数据库产品RethinkDB而付出的努力。我们力求提供针对各种工作负载和潜在用例的RethinkDB性能指标的一般概述。在此报告中，我们将解决的一些问题包括：</target>
        </trans-unit>
        <trans-unit id="dbf7d676994679d10fb326236fe98c7d7b06ae4d" translate="yes" xml:space="preserve">
          <source>This table returns information about the status and availability of servers within a RethinkDB cluster. A single document is created for each server that connects to the cluster. If a server loses its connection to the cluster, it will be removed from the &lt;code&gt;server_status&lt;/code&gt; table.</source>
          <target state="translated">该表返回有关RethinkDB集群中服务器的状态和可用性的信息。为连接到群集的每个服务器创建一个文档。如果服务器失去与集群的连接，它将从 &lt;code&gt;server_status&lt;/code&gt; 表中删除。</target>
        </trans-unit>
        <trans-unit id="8b1ac2a2ea0485ae1d2247b1c116a2c2f4acddb6" translate="yes" xml:space="preserve">
          <source>This table shows problems that have been detected within the RethinkDB cluster. For details, read the &lt;a href=&quot;../system-issues/index&quot;&gt;System current issues table&lt;/a&gt; documentation.</source>
          <target state="translated">下表显示了RethinkDB集群中已检测到的问题。有关详细信息，请阅读&amp;ldquo; &lt;a href=&quot;../system-issues/index&quot;&gt;系统当前问题&amp;rdquo;表&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="9a58322ca86137de68e645fd6b69456345f7a1c8" translate="yes" xml:space="preserve">
          <source>This table stores information about table availability. There is one document per table (not counting system tables).</source>
          <target state="translated">此表存储有关表的可用性信息。每个表有一个文件(不包括系统表)。</target>
        </trans-unit>
        <trans-unit id="700035ba5743d362d312992febe3cdb4c2d32eca" translate="yes" xml:space="preserve">
          <source>This table stores the log files of the cluster. One row is added to the table for each log message generated by &lt;em&gt;each&lt;/em&gt; server that&amp;rsquo;s connected to the cluster. A maximum of 1000 entries will be stored for each server.</source>
          <target state="translated">该表存储集群的日志文件。对于连接到群集的&lt;em&gt;每台&lt;/em&gt;服务器生成的&lt;em&gt;每条&lt;/em&gt;日志消息，表中都会添加一行。每个服务器最多可存储1000个条目。</target>
        </trans-unit>
        <trans-unit id="7d26d8d3a47febb845fda047336c8a95a95ed440" translate="yes" xml:space="preserve">
          <source>This table stores the names of servers along with their &lt;em&gt;tags.&lt;/em&gt; Server tags organize servers into logical groups: servers could be tagged by usage (database, application, etc.), or by data center location (&amp;ldquo;us_west,&amp;rdquo; &amp;ldquo;us_east,&amp;rdquo; &amp;ldquo;london,&amp;rdquo; and so on). For more about server tags, read &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt;.</source>
          <target state="translated">该表存储服务器名称及其&lt;em&gt;标记。&lt;/em&gt;服务器标签将服务器组织为逻辑组：服务器可以按用途（数据库，应用程序等）或数据中心位置（&amp;ldquo; us_west&amp;rdquo;，&amp;ldquo; us_east&amp;rdquo;，&amp;ldquo;伦敦&amp;rdquo;等）进行标记。有关服务器标签的更多信息，请阅读分片&lt;a href=&quot;../sharding-and-replication/index&quot;&gt;和复制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b24cf5174181e90b5c8aafe2f4e0730440af51a1" translate="yes" xml:space="preserve">
          <source>This technology has limitations. While most operations allow you to write familiar code, you can&amp;rsquo;t use native language&amp;rsquo;s operations that have side effects (such as &lt;code&gt;print&lt;/code&gt;) or control blocks (such as &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;). Instead, you have to use alternative ReQL commands:</source>
          <target state="translated">此技术有局限性。尽管大多数操作都允许您编写熟悉的代码，但是您不能使用具有副作用（例如 &lt;code&gt;print&lt;/code&gt; ）或控制块（例如 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;for&lt;/code&gt; ）的母语操作。相反，您必须使用其他ReQL命令：</target>
        </trans-unit>
        <trans-unit id="645d6109bf848329c6f455ed5bcf791cd5d05962" translate="yes" xml:space="preserve">
          <source>This will bind the HTTP and driver ports on all available interfaces, while the cluster port will only be bound on the loopback interface and &lt;code&gt;192.168.0.1&lt;/code&gt;.</source>
          <target state="translated">这将在所有可用接口上绑定HTTP和驱动程序端口，而群集端口将仅在回送接口和 &lt;code&gt;192.168.0.1&lt;/code&gt; 上绑定。</target>
        </trans-unit>
        <trans-unit id="7be68a47df33c85c24d05535e067d92117013277" translate="yes" xml:space="preserve">
          <source>This will create the following model for comments:</source>
          <target state="translated">这将为评论创建以下模型。</target>
        </trans-unit>
        <trans-unit id="bd972f0112cecc4dacfc67ccb7c54818c2630b9e" translate="yes" xml:space="preserve">
          <source>This will deserialize the change message, and pretty print it, along with a short description of what kind of change it is.</source>
          <target state="translated">这将反序列化变更消息,并打印出来,同时附上简短的变更描述。</target>
        </trans-unit>
        <trans-unit id="2da799672b875bde58a2e844c9e9c6c18c1febf6" translate="yes" xml:space="preserve">
          <source>This will fail if the &lt;code&gt;notes&lt;/code&gt; field does not exist in the document. To perform this as an &amp;ldquo;upsert&amp;rdquo; (update or insert), use the &lt;a href=&quot;../default/index&quot;&gt;default&lt;/a&gt; command to ensure the field is initialized as an empty list.</source>
          <target state="translated">如果 &lt;code&gt;notes&lt;/code&gt; 字段在文档中不存在，将失败。要将其作为&amp;ldquo; upsert&amp;rdquo;（更新或插入）执行，请使用&lt;a href=&quot;../default/index&quot;&gt;默认&lt;/a&gt;命令以确保将该字段初始化为空列表。</target>
        </trans-unit>
        <trans-unit id="d6dd0bebb08581cc718c11f050b164f60dd94ee5" translate="yes" xml:space="preserve">
          <source>This will override the &lt;code&gt;write: true&lt;/code&gt; permissions granted in the first example, but for this table only. Other tables in the &lt;code&gt;users&lt;/code&gt; database will inherit from the database permissions.</source>
          <target state="translated">这将覆盖第一个示例中授予的 &lt;code&gt;write: true&lt;/code&gt; 权限，但仅适用于此表。 &lt;code&gt;users&lt;/code&gt; 数据库中的其他表将从数据库权限继承。</target>
        </trans-unit>
        <trans-unit id="7a527a2cb141bcf68e0849631dd72491cfe72328" translate="yes" xml:space="preserve">
          <source>This will return a result set such as the following:</source>
          <target state="translated">这将返回一个结果集,如以下。</target>
        </trans-unit>
        <trans-unit id="7974561d2e44ebf7a89c5cbd490575ef1cd12a6b" translate="yes" xml:space="preserve">
          <source>This will return a result similar to:</source>
          <target state="translated">这将返回一个类似的结果。</target>
        </trans-unit>
        <trans-unit id="7b09d7bf2c5573de92a708dc2698ffe91aec72af" translate="yes" xml:space="preserve">
          <source>This workload exclusively performs read operations to retrieve individual documents from the database (YCSB workload C). In this workload, we use the same setup and data set as workload A above. Reads are also performed identically using 8 client servers with 128 concurrent connections per database server in the cluster.</source>
          <target state="translated">该工作负载专门执行读取操作,以从数据库中检索单个文档(YCSB 工作负载 C)。在该工作负载中,我们使用与上述工作负载A相同的设置和数据集。读取也同样使用8个客户端服务器执行,集群中每个数据库服务器有128个并发连接。</target>
        </trans-unit>
        <trans-unit id="15a00ec912a3416fb1d64828fe342fae918688b8" translate="yes" xml:space="preserve">
          <source>This would be serialized as:</source>
          <target state="translated">这将被序列化为:</target>
        </trans-unit>
        <trans-unit id="c0a2cb70deba71b04f648c048262a358d25fe6fc" translate="yes" xml:space="preserve">
          <source>This yields the following model in &lt;code&gt;app/models/article.rb&lt;/code&gt;:</source>
          <target state="translated">这将在 &lt;code&gt;app/models/article.rb&lt;/code&gt; 中产生以下模型：</target>
        </trans-unit>
        <trans-unit id="743fc98678fa343fac71fe0aeddfa10f7343ab41" translate="yes" xml:space="preserve">
          <source>Three or more &lt;a href=&quot;../point/index&quot;&gt;Point&lt;/a&gt; objects specifying the polygon&amp;rsquo;s vertices.</source>
          <target state="translated">三个或更多&lt;a href=&quot;../point/index&quot;&gt;Point&lt;/a&gt;对象，用于指定多边形的顶点。</target>
        </trans-unit>
        <trans-unit id="8060e8f9e58e7d9250d13fd0e26c17e27cbffa62" translate="yes" xml:space="preserve">
          <source>Three or more &lt;a href=&quot;point/index&quot;&gt;Point&lt;/a&gt; objects specifying the polygon&amp;rsquo;s vertices.</source>
          <target state="translated">三个或更多&lt;a href=&quot;point/index&quot;&gt;Point&lt;/a&gt;对象，用于指定多边形的顶点。</target>
        </trans-unit>
        <trans-unit id="c6910e95d75d06c9f63a498f4fb6811b580000e6" translate="yes" xml:space="preserve">
          <source>Three or more two-item arrays, specifying latitude and longitude numbers of the polygon&amp;rsquo;s vertices;</source>
          <target state="translated">三个或更多的两个项目的数组，指定多边形顶点的纬度和经度数；</target>
        </trans-unit>
        <trans-unit id="16a9f47918b7ae16f0a1bea2bdc77c1f72578e59" translate="yes" xml:space="preserve">
          <source>Three settings control consistency and durability in RethinkDB: write acknowledgements and durability per table, and the query read mode.</source>
          <target state="translated">在RethinkDB中,有三个设置控制了一致性和耐久性:每张表的写入确认和耐久性,以及查询读取模式。</target>
        </trans-unit>
        <trans-unit id="9c56bf83063cedaf9e42b20360c4e018d13f5da0" translate="yes" xml:space="preserve">
          <source>Throw a runtime error. If called with no arguments inside the second argument to &lt;code&gt;default&lt;/code&gt;, re-throw the current error.</source>
          <target state="translated">引发运行时错误。如果在 &lt;code&gt;default&lt;/code&gt; 的第二个参数内没有任何参数调用，请重新抛出当前错误。</target>
        </trans-unit>
        <trans-unit id="7f35dd2cbf5aff9146859bee96606edf5a8c2413" translate="yes" xml:space="preserve">
          <source>Thus, &lt;code&gt;on_val&lt;/code&gt; acts a &amp;ldquo;catch-all&amp;rdquo; for any data that is not handled by a more specific method.</source>
          <target state="translated">因此， &lt;code&gt;on_val&lt;/code&gt; 对未由更特定方法处理的任何数据都起到&amp;ldquo; 包罗万象&amp;rdquo;的作用。</target>
        </trans-unit>
        <trans-unit id="5f35a7ab78049f5c0c80564c4ff28263d078b176" translate="yes" xml:space="preserve">
          <source>Thus, this is how our previous query is represented:</source>
          <target state="translated">因此,我们前面的查询就是这样表示的。</target>
        </trans-unit>
        <trans-unit id="51ba744d18b1aed2282b3fb904045b5795d7ea41" translate="yes" xml:space="preserve">
          <source>Times are considered equal when their epoch (UTC) time values are equal, &lt;strong&gt;regardless of what time zone they&amp;rsquo;re in&lt;/strong&gt;. This is true for both comparisons and indexed operations. Times are compared in floating point with millisecond precision.</source>
          <target state="translated">如果各自的时期（UT​​C）时间值相等，则认为时间相等，&lt;strong&gt;无论它们处于哪个时区&lt;/strong&gt;。比较和索引操作都是如此。时间以浮点数与毫秒精度进行比较。</target>
        </trans-unit>
        <trans-unit id="b52eb4d78ab2e73e97cd1b17559ff603ae360f2a" translate="yes" xml:space="preserve">
          <source>Times are only compared with millisecond precision:</source>
          <target state="translated">时间只与毫秒级精度比较。</target>
        </trans-unit>
        <trans-unit id="63dd97c999febb3940f6b2aba7d4800126874dbd" translate="yes" xml:space="preserve">
          <source>Times are stored on the server as seconds since epoch (UTC) with millisecond precision plus a time zone. Currently the only available time zones are minute-precision time offsets from UTC, but we may add support for DST-aware time zones in the future. Time zones are strings as specified by ISO 8601. Note that the JavaScript driver strips time zone information due to limitations with the &lt;code&gt;Date&lt;/code&gt; object, although you can retrieve time zone data via the raw ReQL time object. (See below.)</source>
          <target state="translated">时间以毫秒为单位，以毫秒为单位，自纪元（UTC）开始存储在服务器上，外加一个时区。当前唯一可用的时区是距UTC的分钟精度时差，但是将来我们可能会增加对DST感知时区的支持。时区是ISO 8601指定的字符串。请注意，由于可以通过 &lt;code&gt;Date&lt;/code&gt; 对象进行限制，因此JavaScript驱动程序会剥离时区信息，尽管您可以通过原始ReQL时间对象检索时区数据。（见下文。）</target>
        </trans-unit>
        <trans-unit id="15603cced6ce07ab8236ca3d48ec34b3d1fb78d0" translate="yes" xml:space="preserve">
          <source>Times may be used as the primary key for a table. Two times are considered equal if they have the same number of milliseconds since epoch (UTC), regardless of time zone.</source>
          <target state="translated">时间可以作为一个表的主键。如果两个时间自纪元(UTC)以来的毫秒数相同,则视为相等,而不考虑时区。</target>
        </trans-unit>
        <trans-unit id="9b9188703b28defc378651fb275e83b6e977aec9" translate="yes" xml:space="preserve">
          <source>To add or overwrite a field, you can use the &lt;code&gt;update&lt;/code&gt; command. For instance, if you would like to add the field &lt;code&gt;author&lt;/code&gt; with the value &amp;ldquo;Michel&amp;rdquo; for all of the documents in the table &lt;code&gt;posts&lt;/code&gt;, you would use:</source>
          <target state="translated">要添加或覆盖字段，可以使用 &lt;code&gt;update&lt;/code&gt; 命令。例如，如果您想为表 &lt;code&gt;posts&lt;/code&gt; 中的所有文档添加值为&amp;ldquo; Michel&amp;rdquo; 的字段 &lt;code&gt;author&lt;/code&gt; ，则可以使用：</target>
        </trans-unit>
        <trans-unit id="f483b4eeb3105dade2c40cdd94f2d80f3d322ddf" translate="yes" xml:space="preserve">
          <source>To buffer messages that the subscriber hasn&amp;rsquo;t consumed yet (this buffering is actually done in the database server)</source>
          <target state="translated">缓冲订阅者尚未使用的消息（此缓冲实际上是在数据库服务器中完成的）</target>
        </trans-unit>
        <trans-unit id="cb12f935e01637a6bb4fce40c83665d86ec98cc9" translate="yes" xml:space="preserve">
          <source>To change the password used to access the web UI, log in over SSH and run the following command:</source>
          <target state="translated">要更改用于访问Web用户界面的密码,请通过SSH登录并运行以下命令。</target>
        </trans-unit>
        <trans-unit id="feb7113ba6e90ec2431b889d30d86a37bc3c8f95" translate="yes" xml:space="preserve">
          <source>To change these settings for a table:</source>
          <target state="translated">要改变表格的这些设置。</target>
        </trans-unit>
        <trans-unit id="b482256206d6e96941c63a16517331684e1bb28d" translate="yes" xml:space="preserve">
          <source>To close a cursor and stop receiving data from the stream or feed, send a query with a &lt;code&gt;QueryType&lt;/code&gt; of &lt;code&gt;STOP&lt;/code&gt; on the same connection with the same token.</source>
          <target state="translated">要关闭游标并停止从流或源中接收数据，请在具有相同令牌的相同连接上发送查询 &lt;code&gt;QueryType&lt;/code&gt; 为 &lt;code&gt;STOP&lt;/code&gt; 的查询。</target>
        </trans-unit>
        <trans-unit id="54f3a65cc4d17eb7acb7f0b3fbfc5ccdee0afcbf" translate="yes" xml:space="preserve">
          <source>To configure our river, we need to create a type called &lt;code&gt;rethinkdb&lt;/code&gt; in the &lt;code&gt;_river&lt;/code&gt; index. Then we need to insert a document with the id &lt;code&gt;_meta&lt;/code&gt; into that type. Elasticsearch lets us create the document and the type in one go with a &lt;code&gt;PUT&lt;/code&gt; request:</source>
          <target state="translated">要配置我们的河，我们需要在 &lt;code&gt;_river&lt;/code&gt; 索引中创建一个名为 &lt;code&gt;rethinkdb&lt;/code&gt; 的类型。然后，我们需要将ID为 &lt;code&gt;_meta&lt;/code&gt; 的文档插入该类型。Elasticsearch让我们与 &lt;code&gt;PUT&lt;/code&gt; 请求一起创建文档和类型：</target>
        </trans-unit>
        <trans-unit id="6d4e23954b31922795c6068d267ad1ca0a01598c" translate="yes" xml:space="preserve">
          <source>To connect to your instance over SSH, log in as the user &lt;code&gt;ubuntu&lt;/code&gt;. Use the private key you chose during the installation process and the public hostname of the instance. For example:</source>
          <target state="translated">要通过SSH连接到您的实例，请以 &lt;code&gt;ubuntu&lt;/code&gt; 用户身份登录。使用在安装过程中选择的私钥和实例的公共主机名。例如：</target>
        </trans-unit>
        <trans-unit id="4e84477f8fc3e9974738da45f0d2b5d08603632e" translate="yes" xml:space="preserve">
          <source>To create indexes on fields containing geometry objects, you simply use the standard &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; command, setting the &lt;code&gt;geo&lt;/code&gt; optional argument to &lt;code&gt;true&lt;/code&gt;. In JavaScript, this would be:</source>
          <target state="translated">要在包含几何对象的字段上创建索引，只需使用标准&lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt;命令，将 &lt;code&gt;geo&lt;/code&gt; 可选参数设置为 &lt;code&gt;true&lt;/code&gt; 即可。在JavaScript中，这将是：</target>
        </trans-unit>
        <trans-unit id="e383099f5bc1d4fa7940f0d449f15522b3fe3f50" translate="yes" xml:space="preserve">
          <source>To delete documents, select the documents you&amp;rsquo;d like to delete and use the &lt;code&gt;delete&lt;/code&gt; command. For example, let&amp;rsquo;s delete all posts with the author &amp;ldquo;Michel&amp;rdquo;:</source>
          <target state="translated">要删除文档，请选择要删除的文档，然后使用 &lt;code&gt;delete&lt;/code&gt; 命令。例如，让我们删除所有作者为&amp;ldquo; Michel&amp;rdquo;的帖子：</target>
        </trans-unit>
        <trans-unit id="950e075f5afb40521c4507c103d6c51dff9e0c44" translate="yes" xml:space="preserve">
          <source>To efficiently perform concurrent query execution RethinkDB implements block-level multiversion concurrency control (MVCC). Whenever a write operation occurs while there is an ongoing read, RethinkDB takes a snapshot of the B-Tree for each relevant shard and temporarily maintains different versions of the blocks in order to execute read and write operations concurrently. From the perspective of the applications written on top of RethinkDB, the system is essentially lock-free&amp;mdash; you can run an hour-long analytics query on a live system without blocking any real-time reads or writes.</source>
          <target state="translated">为了有效地执行并发查询执行，RethinkDB实现了块级多版本并发控制（MVCC）。每当正在进行连续读取时发生写入操作时，RethinkDB都会为每个相关分片拍摄B树的快照，并临时维护块的不同版本，以便同时执行读取和写入操作。从在RethinkDB上编写的应用程序的角度来看，该系统基本上是无锁的-您可以在实时系统上运行一个小时的分析查询，而不会阻塞任何实时读取或写入操作。</target>
        </trans-unit>
        <trans-unit id="b5e4b8665d86162d6ee0499ed85653c5815afb9a" translate="yes" xml:space="preserve">
          <source>To export your data, use &lt;code&gt;rethinkdb dump&lt;/code&gt;:</source>
          <target state="translated">要导出数据，请使用 &lt;code&gt;rethinkdb dump&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a5cfc170270329b9655e380eece96e7561697147" translate="yes" xml:space="preserve">
          <source>To filter messages from the &lt;code&gt;Exchange&lt;/code&gt; by their &lt;code&gt;Topic&lt;/code&gt; (again, the server does this filtering)</source>
          <target state="translated">按 &lt;code&gt;Topic&lt;/code&gt; 过滤来自 &lt;code&gt;Exchange&lt;/code&gt; 的邮件（同样，服务器执行此过滤）</target>
        </trans-unit>
        <trans-unit id="b9e67fa6a41c04fe151b7928d066cb31b3fea779" translate="yes" xml:space="preserve">
          <source>To gain more precise control, write a class that inherits from &lt;code&gt;RethinkDB::Handler&lt;/code&gt; and override the event handling methods, then pass an instance of that class to &lt;code&gt;em_run&lt;/code&gt;.</source>
          <target state="translated">为了获得更精确的控制，请编写一个从 &lt;code&gt;RethinkDB::Handler&lt;/code&gt; 继承的类并重写事件处理方法，然后将该类的实例传递给 &lt;code&gt;em_run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecb986ccee4f137068ef2d566f7031789cf5f9b2" translate="yes" xml:space="preserve">
          <source>To get a specific document by ID, use &lt;code&gt;get&lt;/code&gt;:</source>
          <target state="translated">要通过ID获取特定文档，请使用 &lt;code&gt;get&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="32c34afe39f590eccd4f302451652c9d5db80b83" translate="yes" xml:space="preserve">
          <source>To get all documents in a table, simply use the &lt;code&gt;table&lt;/code&gt; command:</source>
          <target state="translated">要获取表中的所有文档，只需使用 &lt;code&gt;table&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="de40767187d55c844372554d913cfb17c30ac121" translate="yes" xml:space="preserve">
          <source>To get the list without duplicates, we can simply leave off &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">要获得没有重复的列表，我们可以简单地忽略 &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88d921b59c0f75df156b7448a630f25ee63f52bf" translate="yes" xml:space="preserve">
          <source>To group servers together in data centers, RethinkDB uses &lt;a href=&quot;#server-tags&quot;&gt;Server tags&lt;/a&gt;. Servers can be &amp;ldquo;tagged&amp;rdquo; with one or more group names on startup:</source>
          <target state="translated">为了将数据中心中的服务器分组在一起，RethinkDB使用&lt;a href=&quot;#server-tags&quot;&gt;服务器标签&lt;/a&gt;。在启动时，可以使用一个或多个组名来&amp;ldquo;标记&amp;rdquo;服务器：</target>
        </trans-unit>
        <trans-unit id="7c8c09feafb751ddc9987a1f0769b5852c6515f6" translate="yes" xml:space="preserve">
          <source>To import repubsub and create a connection to an exchange:</source>
          <target state="translated">导入repubsub并创建一个连接到交易所。</target>
        </trans-unit>
        <trans-unit id="c1f91e358f2a76534d12cdf146988fdd67d454fb" translate="yes" xml:space="preserve">
          <source>To import the file &lt;code&gt;users.json&lt;/code&gt; into the table &lt;code&gt;test.users&lt;/code&gt;, you would use:</source>
          <target state="translated">要将文件 &lt;code&gt;users.json&lt;/code&gt; 导入表 &lt;code&gt;test.users&lt;/code&gt; ，可以使用：</target>
        </trans-unit>
        <trans-unit id="366e39a918bb090b9526809d87179174180378d0" translate="yes" xml:space="preserve">
          <source>To import your data, use &lt;code&gt;rethinkdb restore&lt;/code&gt;:</source>
          <target state="translated">要导入数据，请使用 &lt;code&gt;rethinkdb restore&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="86d61c074af286c312f7bf0ff03e2e2f22db6204" translate="yes" xml:space="preserve">
          <source>To install the river, we&amp;rsquo;ll use the &lt;code&gt;plugin&lt;/code&gt; program that comes with Elasticsearch. On most platforms the program is named &lt;code&gt;plugin&lt;/code&gt;, but it&amp;rsquo;s sometimes called &lt;code&gt;elasticsearch-plugin&lt;/code&gt;:</source>
          <target state="translated">要安装River，我们将使用Elasticsearch随附的 &lt;code&gt;plugin&lt;/code&gt; 程序。在大多数平台上，该程序都称为 &lt;code&gt;plugin&lt;/code&gt; ，但有时也称为 &lt;code&gt;elasticsearch-plugin&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="07ccf555ea9bbb6b48936787543c2086779b895e" translate="yes" xml:space="preserve">
          <source>To learn more, read about &lt;a href=&quot;../data-modeling/index&quot;&gt;data modeling in RethinkDB&lt;/a&gt;. For detailed information, take a look at the API documentation for the join commands:</source>
          <target state="translated">要了解更多信息，请阅读&lt;a href=&quot;../data-modeling/index&quot;&gt;RethinkDB中的数据建模&lt;/a&gt;。有关详细信息，请查看连接命令的API文档：</target>
        </trans-unit>
        <trans-unit id="6400029759c584c7be4cecaa7c0efc09877f5ffb" translate="yes" xml:space="preserve">
          <source>To perform automatic failover for a table, the following requirements must be met:</source>
          <target state="translated">要对表执行自动故障转移,必须满足以下要求。</target>
        </trans-unit>
        <trans-unit id="d9ec4446461d0874e4e3707aaa37881f8f5364dd" translate="yes" xml:space="preserve">
          <source>To perform this, &lt;a href=&quot;../../../api/javascript/map/index&quot;&gt;map&lt;/a&gt; the first 25 movies into a new result set, adding a &lt;code&gt;count&lt;/code&gt; column, then &lt;a href=&quot;../../../api/javascript/reduce/index&quot;&gt;reduce&lt;/a&gt; each row of the mapped result set into a total for each field (&lt;code&gt;votes&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt; and &lt;code&gt;column&lt;/code&gt;). Then use &lt;a href=&quot;../../../api/javascript/do/index&quot;&gt;do&lt;/a&gt; to return a result set with the total votes and the average year, computed by dividing the sum of the years by their count.</source>
          <target state="translated">要执行此操作，请将前25部电影&lt;a href=&quot;../../../api/javascript/map/index&quot;&gt;映射&lt;/a&gt;到新的结果集中，添加一个 &lt;code&gt;count&lt;/code&gt; 列，然后将映射结果集的每一行&lt;a href=&quot;../../../api/javascript/reduce/index&quot;&gt;减少&lt;/a&gt;为每个字段的总和（ &lt;code&gt;votes&lt;/code&gt; ， &lt;code&gt;year&lt;/code&gt; 和 &lt;code&gt;column&lt;/code&gt; ）。然后使用&lt;a href=&quot;../../../api/javascript/do/index&quot;&gt;do&lt;/a&gt;返回具有总投票数和平均年数的结果集，该结果集是通过将年数总和除以年数来计算的。</target>
        </trans-unit>
        <trans-unit id="a0ff8e79026cbc6c21f05b4a17f993ecb68823c4" translate="yes" xml:space="preserve">
          <source>To publish a message to the exchange, create a topic:</source>
          <target state="translated">要向交易所发布消息,请创建一个主题。</target>
        </trans-unit>
        <trans-unit id="b02d7fe7e4c8253f0f26c381301a861cc87b02c6" translate="yes" xml:space="preserve">
          <source>To put these into a new table, wrap that query with &lt;code&gt;insert&lt;/code&gt;. We&amp;rsquo;ll get new IDs generated automatically. This is also an example of using subqueries with ReQL: it&amp;rsquo;s easy to pass the results of one query into another. (One of ReQL&amp;rsquo;s other nice properties, which we&amp;rsquo;ve already seen, is command chaining: the input of one command is often the output of the command before it, similar to Unix piping.)</source>
          <target state="translated">要将它们放入新表中，请使用 &lt;code&gt;insert&lt;/code&gt; 包裹该查询。我们将自动生成新的ID。这也是在ReQL中使用子查询的示例：将一个查询的结果传递到另一个查询很容易。（我们已经看到，ReQL的其他不错的特性之一是命令链接：一个命令的输入通常是它前面的命令的输出，类似于Unix管道。）</target>
        </trans-unit>
        <trans-unit id="aeaa752cf337e6eca87d3929b1caf4bdac7d936a" translate="yes" xml:space="preserve">
          <source>To recap, sending a query to the server takes the following steps:</source>
          <target state="translated">概括地说,向服务器发送查询需要以下步骤。</target>
        </trans-unit>
        <trans-unit id="85f19992e8bf6c08c0bc6c8efb74c60dd624f683" translate="yes" xml:space="preserve">
          <source>To retrieve all documents from the table &lt;code&gt;authors&lt;/code&gt;, we can simply run the query &lt;code&gt;r.table('authors')&lt;/code&gt;:</source>
          <target state="translated">要从表 &lt;code&gt;authors&lt;/code&gt; 检索所有文档，我们可以简单地运行查询 &lt;code&gt;r.table('authors')&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3a5f4a8eb4db8e8ab545aa8109b844e626df95c5" translate="yes" xml:space="preserve">
          <source>To retrieve documents by the value of a specific &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;index&lt;/a&gt;, use &lt;code&gt;getAll&lt;/code&gt;:</source>
          <target state="translated">要通过特定&lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;索引&lt;/a&gt;的值检索文档，请使用 &lt;code&gt;getAll&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fbb0258d07691baeefb2b68816f6b95a63456b10" translate="yes" xml:space="preserve">
          <source>To retrieve documents by the value of a specific field, use &lt;code&gt;filter&lt;/code&gt;:</source>
          <target state="translated">要按特定字段的值检索文档，请使用 &lt;code&gt;filter&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ed3be06592db0d57713ac35e99b8a2f3ebf7ea85" translate="yes" xml:space="preserve">
          <source>To retrieve more data for the cursor, the driver should send a query with a &lt;code&gt;QueryType&lt;/code&gt; of &lt;code&gt;CONTINUE&lt;/code&gt;&lt;em&gt;on the same connection with the same token.&lt;/em&gt; As with other queries, this must be sent with the query token, the size of the query, and the query itself, simply &lt;code&gt;[2]&lt;/code&gt;.</source>
          <target state="translated">要为游标检索更多数据，驱动程序应&lt;em&gt;在具有相同令牌的相同连接上&lt;/em&gt;发送查询 &lt;code&gt;QueryType&lt;/code&gt; 为 &lt;code&gt;CONTINUE&lt;/code&gt; 的查询&lt;em&gt;。&lt;/em&gt;与其他查询一样，此查询必须与查询令牌，查询的大小以及查询本身一起发送，只需 &lt;code&gt;[2]&lt;/code&gt; 即可。</target>
        </trans-unit>
        <trans-unit id="594e344aa121fcd72ce614816e06800232731f0c" translate="yes" xml:space="preserve">
          <source>To return the status on a specific table, you can use the &lt;a href=&quot;https://rethinkdb.com/api/python/status&quot;&gt;status&lt;/a&gt; command.</source>
          <target state="translated">要返回特定表上的状态，可以使用&lt;a href=&quot;https://rethinkdb.com/api/python/status&quot;&gt;status&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="0f2544d8217895f115ddbfac5ce0427076385ac7" translate="yes" xml:space="preserve">
          <source>To run a proxy node, simply use the &lt;code&gt;proxy&lt;/code&gt; command line option on startup.</source>
          <target state="translated">要运行代理节点，只需在启动时使用 &lt;code&gt;proxy&lt;/code&gt; 命令行选项。</target>
        </trans-unit>
        <trans-unit id="7ad487668453bf9cfe5420133fd62d266a6f19fb" translate="yes" xml:space="preserve">
          <source>To secure the cluster port, bind it to a specific IP address using the &lt;code&gt;--bind-cluster&lt;/code&gt;&lt;a href=&quot;../cli-options/index&quot;&gt;command line option&lt;/a&gt; or the corresponding &lt;a href=&quot;../config-file/index&quot;&gt;configuration file option&lt;/a&gt;. Bind it to an IP address that is only accessible from within your local network.</source>
          <target state="translated">要保护群集端口，请使用 &lt;code&gt;--bind-cluster&lt;/code&gt; &lt;a href=&quot;../cli-options/index&quot;&gt;命令行选项&lt;/a&gt;或相应的&lt;a href=&quot;../config-file/index&quot;&gt;配置文件选项&lt;/a&gt;将其绑定到特定的IP地址。将其绑定到只能从本地网络内访问的IP地址。</target>
        </trans-unit>
        <trans-unit id="63abc14b3a39ce86c3ddac5a6216b4527d3e45bd" translate="yes" xml:space="preserve">
          <source>To secure your instance more tightly, we recommend that you perform the following steps:</source>
          <target state="translated">为了更紧密地保护你的实例,我们建议你执行以下步骤。</target>
        </trans-unit>
        <trans-unit id="ad6055491136bc9a98781e119b4821f59b1ddbf8" translate="yes" xml:space="preserve">
          <source>To solve this, specify the canonical address explicitly by using the &lt;code&gt;--canonical-address&lt;/code&gt; argument.</source>
          <target state="translated">要解决此问题，请使用 &lt;code&gt;--canonical-address&lt;/code&gt; 参数显式指定规范地址。</target>
        </trans-unit>
        <trans-unit id="d72bc2454fca47c2c0ab0269659e7cf093c4a3e6" translate="yes" xml:space="preserve">
          <source>To specify the permissions described above for Bob, you would execute the following ReQL commands:</source>
          <target state="translated">要为Bob指定上面描述的权限,你将执行以下ReQL命令。</target>
        </trans-unit>
        <trans-unit id="1cb6d614ff621abfe0d6a335ad8d264a853e0544" translate="yes" xml:space="preserve">
          <source>To start RethinkDB, use &lt;code&gt;launchctl&lt;/code&gt;:</source>
          <target state="translated">要启动RethinkDB，请使用 &lt;code&gt;launchctl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2dad878292712b7f558426d349ed880e4af7a108" translate="yes" xml:space="preserve">
          <source>To start a feed, open a new terminal and open a new RethinkDB connection. Then, run the following query:</source>
          <target state="translated">要开始一个feed,打开一个新的终端并打开一个新的RethinkDB连接。然后,运行以下查询。</target>
        </trans-unit>
        <trans-unit id="9c11c7d34e1946579e4adcbac994f885acb15b11" translate="yes" xml:space="preserve">
          <source>To start the first RethinkDB instance, run this command in your terminal:</source>
          <target state="translated">要启动第一个RethinkDB实例,在你的终端中运行这个命令。</target>
        </trans-unit>
        <trans-unit id="c3e5329f2856e1b30fd4b56a003d3db2b1ded724" translate="yes" xml:space="preserve">
          <source>To summarize all of the above in code:</source>
          <target state="translated">用代码来总结以上所有的内容。</target>
        </trans-unit>
        <trans-unit id="3abbd29486099a34e7f40b5a4cddbe4b9cf10916" translate="yes" xml:space="preserve">
          <source>To understand the number of blocks used by a given data set, we must first distinguish two different modes of how a document can be stored.</source>
          <target state="translated">为了理解给定数据集所使用的块数,我们必须首先区分文档存储方式的两种不同模式。</target>
        </trans-unit>
        <trans-unit id="f0f9dad2d6cdcc7eacf224d626d3f9f091cf0c85" translate="yes" xml:space="preserve">
          <source>To use TLS connections between servers in the cluster:</source>
          <target state="translated">要在集群中的服务器之间使用TLS连接。</target>
        </trans-unit>
        <trans-unit id="b133e48e0d2e81b55fd18918ab28e9f2c17723e7" translate="yes" xml:space="preserve">
          <source>To use TLS connections with client drivers, specify:</source>
          <target state="translated">要使用客户端驱动程序的TLS连接,请指定。</target>
        </trans-unit>
        <trans-unit id="bb0309d21645559c49035d639aedb79fa72fcc44" translate="yes" xml:space="preserve">
          <source>Todo list 1</source>
          <target state="translated">所有清单1</target>
        </trans-unit>
        <trans-unit id="c0d571fb15bd5004e86b86da5d5fd2117fc978b4" translate="yes" xml:space="preserve">
          <source>Todo list 2</source>
          <target state="translated">所有清单2</target>
        </trans-unit>
        <trans-unit id="8ec3b42250ed256519f611273d212bc6a9381982" translate="yes" xml:space="preserve">
          <source>Todo list in Backbone</source>
          <target state="translated">Backbone的待办事项列表</target>
        </trans-unit>
        <trans-unit id="9b709f53299c781ad6cfe792699295be55f8b558" translate="yes" xml:space="preserve">
          <source>Todo list in Ember.js</source>
          <target state="translated">Ember.js中的Todo list</target>
        </trans-unit>
        <trans-unit id="132a9e5e92ca13cc63a8881214eed35704933a05" translate="yes" xml:space="preserve">
          <source>Todo list with Angular and Express</source>
          <target state="translated">使用Angular和Express的Todo list</target>
        </trans-unit>
        <trans-unit id="bea627f8ee28519a09b024254b900d47c7456046" translate="yes" xml:space="preserve">
          <source>Tornado</source>
          <target state="translated">Tornado</target>
        </trans-unit>
        <trans-unit id="bd22935ae208296740b8d45826f737f20bba80b9" translate="yes" xml:space="preserve">
          <source>Transform each element of one or more sequences by applying a mapping function to them. If &lt;code&gt;map&lt;/code&gt; is run with two or more sequences, it will iterate for as many items as there are in the shortest sequence.</source>
          <target state="translated">通过将映射功能应用于一个或多个序列的每个元素，可以对它们进行变换。如果 &lt;code&gt;map&lt;/code&gt; 以两个或多个序列运行，则它将迭代最短序列中的所有项目。</target>
        </trans-unit>
        <trans-unit id="d685ad7c59aeb1945ef867b52857539b62c1b81c" translate="yes" xml:space="preserve">
          <source>Transformations</source>
          <target state="translated">Transformations</target>
        </trans-unit>
        <trans-unit id="e2bc0fa55c343cd8ae1a2849f02567a3cbc8198c" translate="yes" xml:space="preserve">
          <source>Transformations are applied before changes are calculated.</source>
          <target state="translated">在计算变化之前,先进行变换。</target>
        </trans-unit>
        <trans-unit id="636b384f08584381fd6ed01329683547509c1d32" translate="yes" xml:space="preserve">
          <source>Transmitted</source>
          <target state="translated">Transmitted</target>
        </trans-unit>
        <trans-unit id="10756c57fa929e54d2fbfddbd05bebea58ee3730" translate="yes" xml:space="preserve">
          <source>Transmitted bytes</source>
          <target state="translated">发送的字节数</target>
        </trans-unit>
        <trans-unit id="285ec850c11d78bac10f6bfa31b69a37f1b257c9" translate="yes" xml:space="preserve">
          <source>Troubleshooting</source>
          <target state="translated">Troubleshooting</target>
        </trans-unit>
        <trans-unit id="a366c709db27bd15c4dfe9c2cf45f4723cc61549" translate="yes" xml:space="preserve">
          <source>Troubleshooting FAQ</source>
          <target state="translated">疑难解答</target>
        </trans-unit>
        <trans-unit id="37980a44c517087463e129eca0240643f5c25de3" translate="yes" xml:space="preserve">
          <source>Troubleshooting common RethinkDB problems</source>
          <target state="translated">RethinkDB常见故障的排除</target>
        </trans-unit>
        <trans-unit id="9beec1d3517a419360a6ad6fb2b7d53d1d3521a5" translate="yes" xml:space="preserve">
          <source>Trusted Docker build and instructions for deploying a RethinkDB cluster.</source>
          <target state="translated">可信的Docker构建和部署RethinkDB集群的说明。</target>
        </trans-unit>
        <trans-unit id="cbe5413cca0e1a50a658098a3df98dcd9a0f8b94" translate="yes" xml:space="preserve">
          <source>Try out the repubsub demo</source>
          <target state="translated">试试Repubsub的演示</target>
        </trans-unit>
        <trans-unit id="e3ca01cb076f183ec2cf707e0ea65c9829a4435d" translate="yes" xml:space="preserve">
          <source>Trying to access &lt;code&gt;user1&lt;/code&gt; in ReQL will cause a nesting depth error.</source>
          <target state="translated">尝试在ReQL中访问 &lt;code&gt;user1&lt;/code&gt; 将导致嵌套深度错误。</target>
        </trans-unit>
        <trans-unit id="53664f1e2f0e6eb2b0c4bce0be6d2549297e9871" translate="yes" xml:space="preserve">
          <source>Turn a query into a changefeed, an infinite stream of objects representing changes to the query&amp;rsquo;s results as they occur. A changefeed may return changes to a table or an individual document (a &amp;ldquo;point&amp;rdquo; changefeed). Commands such as &lt;code&gt;filter&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt; may be used before the &lt;code&gt;changes&lt;/code&gt; command to transform or filter the output, and many commands that operate on sequences can be chained after &lt;code&gt;changes&lt;/code&gt;.</source>
          <target state="translated">将查询转换为变更提要，即一个无限的对象流，它们表示查询结果发生更改时的变化。变更馈送可以将变更返回到表或单个文档（&amp;ldquo;点&amp;rdquo;变更馈送）。可以在 &lt;code&gt;changes&lt;/code&gt; 命令之前使用诸如 &lt;code&gt;filter&lt;/code&gt; 或 &lt;code&gt;map&lt;/code&gt; 之类的命令来转换或过滤输出，并且可以在 &lt;code&gt;changes&lt;/code&gt; 后链接许多对序列进行操作的命令。</target>
        </trans-unit>
        <trans-unit id="4b79156b13c38a60392112dbdf81a9d0a27fcf63" translate="yes" xml:space="preserve">
          <source>Twisted</source>
          <target state="translated">Twisted</target>
        </trans-unit>
        <trans-unit id="6446b1c8d77fa2cd9100709887d91f9bbff92d94" translate="yes" xml:space="preserve">
          <source>Two (latitude and longitude). Elevation is not supported.</source>
          <target state="translated">两个(经纬度)。不支持高程。</target>
        </trans-unit>
        <trans-unit id="1fa1c3c9ce84fdece536b61347999037fad2354c" translate="yes" xml:space="preserve">
          <source>Two events can be emitted, &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">可以发出两个事件： &lt;code&gt;data&lt;/code&gt; 和 &lt;code&gt;error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6b5482647136d8564d88c44675609c8ed6bdba4" translate="yes" xml:space="preserve">
          <source>Two or more &lt;a href=&quot;../point/index&quot;&gt;Point&lt;/a&gt; objects specifying the line&amp;rsquo;s vertices.</source>
          <target state="translated">两个或多个&lt;a href=&quot;../point/index&quot;&gt;Point&lt;/a&gt;对象，指定线的顶点。</target>
        </trans-unit>
        <trans-unit id="1b1a580c0ac47b78a0704236a77398259abc1c6b" translate="yes" xml:space="preserve">
          <source>Two or more &lt;a href=&quot;point/index&quot;&gt;Point&lt;/a&gt; objects specifying the line&amp;rsquo;s vertices.</source>
          <target state="translated">两个或多个&lt;a href=&quot;point/index&quot;&gt;Point&lt;/a&gt;对象，指定线的顶点。</target>
        </trans-unit>
        <trans-unit id="bbdcc944716c5615a236baa9e2fc33d539a9105d" translate="yes" xml:space="preserve">
          <source>Two or more two-item arrays, specifying latitude and longitude numbers of the line&amp;rsquo;s vertices;</source>
          <target state="translated">两个或多个两个项目的数组，指定线的顶点的纬度和经度数；</target>
        </trans-unit>
        <trans-unit id="4ba1815eb2917359deeac9d397d5812c0b4b098a" translate="yes" xml:space="preserve">
          <source>Two settings for tables, write acknowledgements and write durability, cannot be set through either the web interface or the &lt;code&gt;reconfigure&lt;/code&gt; command. They must be set by modifying the &lt;code&gt;table_config&lt;/code&gt; table for individual tables.</source>
          <target state="translated">不能通过Web界面或 &lt;code&gt;reconfigure&lt;/code&gt; 命令设置表的两个设置，即写确认和写持久性。必须通过修改单个表的 &lt;code&gt;table_config&lt;/code&gt; 表来设置它们。</target>
        </trans-unit>
        <trans-unit id="6c7e8c4768d6d89677c79690c60c193c74ddcb13" translate="yes" xml:space="preserve">
          <source>Typically, this indicates that a JSON object with subdocuments is too deeply nested:</source>
          <target state="translated">通常情况下,这表明带有子文档的JSON对象嵌套太深。</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="364270ef7d2c546a581298054e0fe3b7afbbe2ac" translate="yes" xml:space="preserve">
          <source>US election analysis</source>
          <target state="translated">美国大选分析</target>
        </trans-unit>
        <trans-unit id="a1c366cacdc2e4f2ca5e9f514afccf66ad1dfa3e" translate="yes" xml:space="preserve">
          <source>Ubuntu</source>
          <target state="translated">Ubuntu</target>
        </trans-unit>
        <trans-unit id="a6812ddf0974dcae6abd3a14c32af9a9161c78a9" translate="yes" xml:space="preserve">
          <source>Ubuntu 14.04</source>
          <target state="translated">Ubuntu 14.04</target>
        </trans-unit>
        <trans-unit id="9fa17002e5897edadc0072042bcef127cb475076" translate="yes" xml:space="preserve">
          <source>Ubuntu Server 12.04 LTS</source>
          <target state="translated">Ubuntu服务器12.04 LTS</target>
        </trans-unit>
        <trans-unit id="2fcd95479f339b189b1b91af8268bb81bf5e8c84" translate="yes" xml:space="preserve">
          <source>Under OS X, the system versions of Python and Ruby link to old versions of OpenSSL which do not support RethinkDB&amp;rsquo;s defaults for TLS. To use those drivers under OS X, the server must specify:</source>
          <target state="translated">在OS X下，Python和Ruby的系统版本链接到不支持RethinkDB TLS默认值的OpenSSL的旧版本。要在OS X下使用这些驱动程序，服务器必须指定：</target>
        </trans-unit>
        <trans-unit id="8c637e03237e3de5320d47b31840684831855946" translate="yes" xml:space="preserve">
          <source>Under most circumstances, it is easier to manipulate the &lt;code&gt;permissions&lt;/code&gt; table by using the &lt;a href=&quot;../../api/javascript/grant/index&quot;&gt;grant&lt;/a&gt; command.</source>
          <target state="translated">在大多数情况下，使用&lt;a href=&quot;../../api/javascript/grant/index&quot;&gt;Grant&lt;/a&gt;命令更容易操作 &lt;code&gt;permissions&lt;/code&gt; 表。</target>
        </trans-unit>
        <trans-unit id="0d4479e111cf225a452266879c7640ba144cf369" translate="yes" xml:space="preserve">
          <source>Under normal circumstances the system will prevent name collisions, but a collision could occur due to a race condition&amp;mdash;for instance, two clients trying to create tables with the same name on different servers simultaneously. This is a critical error, as a name collision on a table or database makes it impossible to read or write from that table or from tables in that database.</source>
          <target state="translated">在正常情况下，系统将防止名称冲突，但是由于争用情况而可能发生冲突，例如，两个客户端试图同时在不同的服务器上创建具有相同名称的表。这是一个严重错误，因为表或数据库上的名称冲突使得无法从该表或该数据库中的表进行读取或写入。</target>
        </trans-unit>
        <trans-unit id="44b2aafb6bac3c1c7dac049c5af91f953afa5c68" translate="yes" xml:space="preserve">
          <source>Understanding RethinkDB memory requirements</source>
          <target state="translated">了解RethinkDB的内存需求</target>
        </trans-unit>
        <trans-unit id="e843f3bbb1a4125dd9a299d4d68c73b5d88c19db" translate="yes" xml:space="preserve">
          <source>Understanding how RethinkDB parallelizes queries can improve the performance of your applications&amp;mdash;sometimes significantly.</source>
          <target state="translated">了解RethinkDB如何并行化查询可以有时甚至显着提高应用程序的性能。</target>
        </trans-unit>
        <trans-unit id="ce00816d4a4fa8b4c822b510eb10cc24e4557eab" translate="yes" xml:space="preserve">
          <source>Ungrouping</source>
          <target state="translated">Ungrouping</target>
        </trans-unit>
        <trans-unit id="f6eabc3d4ce5084fa933d9e3e40b1a62a4408c35" translate="yes" xml:space="preserve">
          <source>Ungrouping is useful e.g. for ordering grouped data, or for inserting grouped data into a table.</source>
          <target state="translated">未分组是很有用的,例如对分组的数据进行排序,或将分组的数据插入到表中。</target>
        </trans-unit>
        <trans-unit id="f217805f771e930edb43d7bf7bca94dcb4d337f2" translate="yes" xml:space="preserve">
          <source>Unlike a relational database, RethinkDB doesn&amp;rsquo;t enforce types, so NoBrainer&amp;rsquo;s type annotations on the field are validators that are run just before a document is saved to the database. If you don&amp;rsquo;t want to specify the type for a field, you can use the dummy type &lt;code&gt;object&lt;/code&gt;:</source>
          <target state="translated">与关系数据库不同，RethinkDB不会强制执行类型，因此NoBrainer在字段上的类型注释是在将文档保存到数据库之前运行的验证器。如果您不想指定字段的类型，则可以使用虚拟类型 &lt;code&gt;object&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ac7e8952b13e5acdc4da0cec2cf13463f8f61d32" translate="yes" xml:space="preserve">
          <source>Unlike most NoSQL languages, you can use ReQL to build queries of arbitrary complexity.</source>
          <target state="translated">与大多数NoSQL语言不同,你可以使用ReQL来构建任意复杂度的查询。</target>
        </trans-unit>
        <trans-unit id="c16226abce85df018665b20883ae7e6e4b1e5e95" translate="yes" xml:space="preserve">
          <source>Unlike the script that pushes data into Rabbit, to listen we need to create a &lt;em&gt;queue&lt;/em&gt;. Queues are basically mailboxes. You go to an exchange and sign up a queue for different topics from that exchange:</source>
          <target state="translated">与将数据推送到Rabbit中的脚本不同，要侦听，我们需要创建一个&lt;em&gt;queue&lt;/em&gt;。队列基本上是邮箱。您去交换所并为该交换所中的不同主题注册队列：</target>
        </trans-unit>
        <trans-unit id="fdeb266883f342263bdad04080658322848b0916" translate="yes" xml:space="preserve">
          <source>Update JSON documents in a table. Accepts a JSON document, a ReQL expression, or a combination of the two.</source>
          <target state="translated">更新表中的JSON文档。接受JSON文档、ReQL表达式或两者的组合。</target>
        </trans-unit>
        <trans-unit id="886df39f252cb5160cd6c67abc34816e8e74dfa5" translate="yes" xml:space="preserve">
          <source>Update documents</source>
          <target state="translated">更新文件</target>
        </trans-unit>
        <trans-unit id="889a7dd9a4b654d699b56a7a2065ecff1fbc5e44" translate="yes" xml:space="preserve">
          <source>Update returns an object that contains the following attributes:</source>
          <target state="translated">Update返回一个包含以下属性的对象。</target>
        </trans-unit>
        <trans-unit id="78a05a6a04989744e749ac1bebf7d5f706cbd978" translate="yes" xml:space="preserve">
          <source>Updating nested fields</source>
          <target state="translated">更新嵌套字段</target>
        </trans-unit>
        <trans-unit id="46d2ffec68a2c34115384d62c30e25333d59d0dc" translate="yes" xml:space="preserve">
          <source>Updating the state of a cluster is a surprisingly difficult problem in distributed systems. At any given point different (and potentially) conflicting configurations can be selected on different sides of a netsplit, different configurations can reach different nodes in the cluster at unpredictable times, etc.</source>
          <target state="translated">在分布式系统中,更新集群的状态是一个令人惊讶的难题。在任何一个点上,都可能在网分的不同侧选择不同的(潜在的)冲突配置,不同的配置可能在不可预测的时间到达集群中的不同节点,等等。</target>
        </trans-unit>
        <trans-unit id="80fd74f545706363781bafd9b9b926b0120f411a" translate="yes" xml:space="preserve">
          <source>Upgrade RethinkDB to a new version</source>
          <target state="translated">将RethinkDB升级到新版本</target>
        </trans-unit>
        <trans-unit id="ebbd9e0c3ed2ca872f91fb9e343b590ec4bc9217" translate="yes" xml:space="preserve">
          <source>Upgrading RethinkDB</source>
          <target state="translated">升级RethinkDB</target>
        </trans-unit>
        <trans-unit id="449ffb29ddf3b7b7d07cbf671ea03550c293da3a" translate="yes" xml:space="preserve">
          <source>Upgrading from RethinkDB versions 1.6 or earlier has &lt;em&gt;not&lt;/em&gt; been tested with RethinkDB 2.1 and higher. However, you should be able to use the deprecated &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/02b4f29e1e7f15b3edffcb68bf015578ec5783ab/scripts/migration&quot;&gt;migration script&lt;/a&gt;.</source>
          <target state="translated">从RethinkDB版本1.6或更早版本的升级也&lt;em&gt;未&lt;/em&gt;经过测试与RethinkDB 2.1及更高版本。但是，您应该可以使用不建议使用的&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/02b4f29e1e7f15b3edffcb68bf015578ec5783ab/scripts/migration&quot;&gt;迁移脚本&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23ae55bbf764d16d108fec022f1450aafee2eec8" translate="yes" xml:space="preserve">
          <source>Uppercases a string.</source>
          <target state="translated">大写一个字符串。</target>
        </trans-unit>
        <trans-unit id="659680921b67aa2e7a75e1c65027d91f2d9c5555" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://rethinkdb.com/api/python/index_status/&quot;&gt;index_status&lt;/a&gt; to retrieve a binary representation of the existing secondary index (whether it is simple, compound, multi, or based on an expression)</source>
          <target state="translated">使用&lt;a href=&quot;https://rethinkdb.com/api/python/index_status/&quot;&gt;index_status&lt;/a&gt;检索现有二级索引的二进制表示形式（无论是简单的，复合的，多重的还是基于表达式的）</target>
        </trans-unit>
        <trans-unit id="0a6475c00b0900ae4e541e3bb4fa60e368eea9b9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;default&lt;/code&gt; to ensure that if the &lt;code&gt;count&lt;/code&gt; field doesn&amp;rsquo;t already exist in the document, it&amp;rsquo;s added correctly, rather than letting &lt;code&gt;add&lt;/code&gt; throw an error.</source>
          <target state="translated">使用 &lt;code&gt;default&lt;/code&gt; 可确保如果 &lt;code&gt;count&lt;/code&gt; 字段在文档中尚不存在，则将其正确添加，而不是让 &lt;code&gt;add&lt;/code&gt; 引发错误。</target>
        </trans-unit>
        <trans-unit id="95f978d6b1722fef203b1e9a1db06789e0fa0612" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;polygon2&lt;/code&gt; to &amp;ldquo;punch out&amp;rdquo; a hole in &lt;code&gt;polygon1&lt;/code&gt;. &lt;code&gt;polygon2&lt;/code&gt; must be completely contained within &lt;code&gt;polygon1&lt;/code&gt; and must have no holes itself (it must not be the output of &lt;code&gt;polygonSub&lt;/code&gt; itself).</source>
          <target state="translated">使用 &lt;code&gt;polygon2&lt;/code&gt; 来&amp;ldquo;冲出&amp;rdquo; &lt;code&gt;polygon1&lt;/code&gt; 中的孔。 &lt;code&gt;polygon2&lt;/code&gt; 必须完全包含在 &lt;code&gt;polygon1&lt;/code&gt; 中,并且本身必须没有孔（它不能是 &lt;code&gt;polygonSub&lt;/code&gt; 本身的输出）。</target>
        </trans-unit>
        <trans-unit id="828e6b81f935582a6801e7c26c4473219515b699" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;rethinkdb help &amp;lt;command&amp;gt;&lt;/code&gt; for a list of options. For more details, see &lt;a href=&quot;../backup/index&quot;&gt;Backing up your data&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;rethinkdb help &amp;lt;command&amp;gt;&lt;/code&gt; 获得选项列表。有关更多详细信息，请参阅&lt;a href=&quot;../backup/index&quot;&gt;备份数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a3315d5d9a9dfeca99bc7ea7f478442bf8813cad" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;rethinkdb restore --help&lt;/code&gt; to see the complete list of options for importing your data. Again, for more details, see &lt;a href=&quot;../backup/index&quot;&gt;Backing up your data&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;rethinkdb restore --help&lt;/code&gt; 可以查看用于导入数据的选项的完整列表。同样，有关更多详细信息，请参阅&lt;a href=&quot;../backup/index&quot;&gt;备份数据&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="409daa75fdb8287421baffc1e21a8ba0992f8262" translate="yes" xml:space="preserve">
          <source>Use RethinkDB as session store with Express 4.x framework. Adapted from connect-rethinkdb.</source>
          <target state="translated">使用RethinkDB作为Express 4.x框架的会话存储。改编自connect-rethinkdb。</target>
        </trans-unit>
        <trans-unit id="f97f9ac1ace574e46eab8167a8178383052e916d" translate="yes" xml:space="preserve">
          <source>Use a multi index and a mapping function to speed getAll/contains</source>
          <target state="translated">使用多索引和映射函数来加快getAll/contains的速度。</target>
        </trans-unit>
        <trans-unit id="1a5e2238f6aaa1ef54f93db2748355c0cdf7ae64" translate="yes" xml:space="preserve">
          <source>Use emergency repair mode to reconfigure the table</source>
          <target state="translated">使用紧急修复模式重新配置表格。</target>
        </trans-unit>
        <trans-unit id="fa6c78a4797a701376427269a923c2b9c592d55a" translate="yes" xml:space="preserve">
          <source>Use simple indexes to efficiently retrieve and order documents by the value of a single field.</source>
          <target state="translated">使用简单的索引,通过单个字段的值有效地检索和排序文档。</target>
        </trans-unit>
        <trans-unit id="03df0bd73e277e326500f2baf39c368061042c3e" translate="yes" xml:space="preserve">
          <source>Use the &amp;ldquo;Run&amp;rdquo; button or Shift+Enter to run the query. Now, let&amp;rsquo;s insert some JSON documents into the table:</source>
          <target state="translated">使用&amp;ldquo;运行&amp;rdquo;按钮或Shift + Enter运行查询。现在，让我们将一些JSON文档插入表中：</target>
        </trans-unit>
        <trans-unit id="2876eba68994921e941ce6ae6a34c2ef904b9ec2" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;dump&lt;/code&gt; subcommand from the command line to create an archive of data from the cluster. This creates a &lt;strong&gt;tar.gz&lt;/strong&gt; file consisting of JSON documents and additional table metadata.</source>
          <target state="translated">从命令行使用 &lt;code&gt;dump&lt;/code&gt; 子命令从集群创建数据归档。这将创建一个由JSON文档和其他表元数据组成的&lt;strong&gt;tar.gz&lt;/strong&gt;文件。</target>
        </trans-unit>
        <trans-unit id="eb50f3d35b929185e801b877f1b0751aa34d4633" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;dump&lt;/code&gt; subcommand to create an archive of data from the cluster. This creates a &lt;strong&gt;tar.gz&lt;/strong&gt; file consisting of JSON documents and additional table metadata.</source>
          <target state="translated">使用 &lt;code&gt;dump&lt;/code&gt; 子命令从集群创建数据归档。这将创建一个由JSON文档和其他表元数据组成的&lt;strong&gt;tar.gz&lt;/strong&gt;文件。</target>
        </trans-unit>
        <trans-unit id="8bbfd294af31d640ef3ad7e899852587e4a1d8cb" translate="yes" xml:space="preserve">
          <source>Use the commands &lt;code&gt;toEpochTime&lt;/code&gt; and &lt;code&gt;toISO8601&lt;/code&gt; to convert back.</source>
          <target state="translated">使用命令 &lt;code&gt;toEpochTime&lt;/code&gt; 和 &lt;code&gt;toISO8601&lt;/code&gt; 进行转换。</target>
        </trans-unit>
        <trans-unit id="25c8ead3ef495e865b02517c55d36f6c25cd0800" translate="yes" xml:space="preserve">
          <source>Use the intracluster port (&lt;code&gt;29015&lt;/code&gt; by default) to connect other nodes in the cluster to this node.</source>
          <target state="translated">使用群集内端口（默认为 &lt;code&gt;29015&lt;/code&gt; ）将群集中的其他节点连接到该节点。</target>
        </trans-unit>
        <trans-unit id="868d9b6e254a3d9e47e5e1742d8635d9345c6ee1" translate="yes" xml:space="preserve">
          <source>Used to &amp;lsquo;zip&amp;rsquo; up the result of a join by merging the &amp;lsquo;right&amp;rsquo; fields into &amp;lsquo;left&amp;rsquo; fields of each member of the sequence.</source>
          <target state="translated">通过将序列的每个成员的&amp;ldquo;右&amp;rdquo;字段合并为&amp;ldquo;左&amp;rdquo;字段，用于&amp;ldquo;压缩&amp;rdquo;联接的结果。</target>
        </trans-unit>
        <trans-unit id="272780d74a89aee8464a61459eba3e0fe818429a" translate="yes" xml:space="preserve">
          <source>Useful RethinkDB commands for exploring data</source>
          <target state="translated">有用的RethinkDB探索数据的命令</target>
        </trans-unit>
        <trans-unit id="cc9b2237413a1771afb24378d67abbf13359869d" translate="yes" xml:space="preserve">
          <source>User account tables</source>
          <target state="translated">用户账户表</target>
        </trans-unit>
        <trans-unit id="57f2b181d0a5e79a147ea1cdf41457f58dbbb3c9" translate="yes" xml:space="preserve">
          <source>Users</source>
          <target state="translated">Users</target>
        </trans-unit>
        <trans-unit id="fe239a4bde23258d27dc84379a4d908f81c05df7" translate="yes" xml:space="preserve">
          <source>Users are created by &lt;a href=&quot;../../api/javascript/insert/index&quot;&gt;inserting&lt;/a&gt; documents into the &lt;code&gt;users&lt;/code&gt;&lt;a href=&quot;../system-tables/index&quot;&gt;system table&lt;/a&gt;. Every user has an account name in the &lt;code&gt;id&lt;/code&gt; field, and an optional password.</source>
          <target state="translated">通过&lt;a href=&quot;../../api/javascript/insert/index&quot;&gt;将&lt;/a&gt;文档插入 &lt;code&gt;users&lt;/code&gt; &lt;a href=&quot;../system-tables/index&quot;&gt;系统表中&lt;/a&gt;来创建用户。每个用户在 &lt;code&gt;id&lt;/code&gt; 字段中都有一个帐户名和一个可选密码。</target>
        </trans-unit>
        <trans-unit id="b0856eda2a019e0b5196369667b10a81678fe41e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;update&lt;/code&gt; to modify the &lt;code&gt;data&lt;/code&gt; field will normally merge the nested documents:</source>
          <target state="translated">使用 &lt;code&gt;update&lt;/code&gt; 修改 &lt;code&gt;data&lt;/code&gt; 字段通常会合并嵌套的文档：</target>
        </trans-unit>
        <trans-unit id="cb923ef24fa89505954667a416ebf08a8cef2954" translate="yes" xml:space="preserve">
          <source>Using GeoJSON</source>
          <target state="translated">使用GeoJSON</target>
        </trans-unit>
        <trans-unit id="2ee0b45d99570088519a4ae6ac622316e2428e8c" translate="yes" xml:space="preserve">
          <source>Using JSON data:</source>
          <target state="translated">使用JSON数据。</target>
        </trans-unit>
        <trans-unit id="5193e9d892132533665ae3d20fb4b221c445f6b7" translate="yes" xml:space="preserve">
          <source>Using RethinkDB with Ruby on Rails</source>
          <target state="translated">在Ruby on Rails中使用RethinkDB</target>
        </trans-unit>
        <trans-unit id="809b510f6074ebbf8930f56b4cd49a32dc1aa406" translate="yes" xml:space="preserve">
          <source>Using RethinkDB::Handler</source>
          <target state="translated">使用RethinkDB::Handler</target>
        </trans-unit>
        <trans-unit id="c87acab6bd223d4993d03d1b63847d6484fd3d19" translate="yes" xml:space="preserve">
          <source>Using SSH tunneling</source>
          <target state="translated">使用SSH隧道</target>
        </trans-unit>
        <trans-unit id="f2ecfece0838a81fdbbc9c35122066e4be35b348" translate="yes" xml:space="preserve">
          <source>Using SSL with RethinkDB requires proxy software on the server, such as &lt;a href=&quot;http://nginx.org/&quot;&gt;Nginx&lt;/a&gt;, &lt;a href=&quot;http://www.haproxy.org/&quot;&gt;HAProxy&lt;/a&gt; or an SSL tunnel. RethinkDB will encrypt traffic and verify the CA certification to prevent &lt;a href=&quot;http://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;man-in-the-middle&lt;/a&gt; attacks. Consult your proxy&amp;rsquo;s documentation for more details.</source>
          <target state="translated">将SSL与RethinkDB一起使用需要服务器上的代理软件，例如&lt;a href=&quot;http://nginx.org/&quot;&gt;Nginx&lt;/a&gt;，&lt;a href=&quot;http://www.haproxy.org/&quot;&gt;HAProxy&lt;/a&gt;或SSL隧道。RethinkDB将加密流量并验证CA认证，以防止&lt;a href=&quot;http://en.wikipedia.org/wiki/Man-in-the-middle_attack&quot;&gt;中间人&lt;/a&gt;攻击。有关更多详细信息，请查阅代理的文档。</target>
        </trans-unit>
        <trans-unit id="686d16463ab8470f47e9807e2c221cf7aa81ac78" translate="yes" xml:space="preserve">
          <source>Using TLS</source>
          <target state="translated">使用TLS</target>
        </trans-unit>
        <trans-unit id="1a44d475de27bf8ecc5a4143d17cb29cc4787e26" translate="yes" xml:space="preserve">
          <source>Using a REPL</source>
          <target state="translated">使用REPL</target>
        </trans-unit>
        <trans-unit id="2d512428ae050cca4f30e03acaad3f9aabd9be07" translate="yes" xml:space="preserve">
          <source>Using a RethinkDB configuration file</source>
          <target state="translated">使用RethinkDB配置文件</target>
        </trans-unit>
        <trans-unit id="d81aacd9868a292e3578d159e7ed1f613ef3b61d" translate="yes" xml:space="preserve">
          <source>Using a function, you can also group by date on a ReQL &lt;a href=&quot;../../../docs/dates-and-times/javascript/index&quot;&gt;date field&lt;/a&gt;.</source>
          <target state="translated">使用功能，您还可以在ReQL &lt;a href=&quot;../../../docs/dates-and-times/javascript/index&quot;&gt;日期字段&lt;/a&gt;上按日期分组。</target>
        </trans-unit>
        <trans-unit id="5b9ec5caa02a4c07b8f2e3c0442f8ca0f1179a72" translate="yes" xml:space="preserve">
          <source>Using a similar technique to the last recipe, we can use &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; to maintain a document&amp;rsquo;s &lt;code&gt;updated_at&lt;/code&gt; and &lt;code&gt;created_at&lt;/code&gt; fields by either inserting a new document or updating one depending on whether a document with a specified ID exists.</source>
          <target state="translated">使用与上一食谱类似的技术，我们可以使用 &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;replace&lt;/code&gt; 通过插入新文档或根据是否存在具有指定ID的文档来更新文档来维护文档的 &lt;code&gt;updated_at&lt;/code&gt; 和 &lt;code&gt;created_at&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="6faf0ceb9a6f33df301c462b697d88b9951a190c" translate="yes" xml:space="preserve">
          <source>Using dynamic keys in ReQL commands</source>
          <target state="translated">在ReQL命令中使用动态键</target>
        </trans-unit>
        <trans-unit id="237f42b300a70240761ddbdf32a86cce7ecb363c" translate="yes" xml:space="preserve">
          <source>Using embedded arrays</source>
          <target state="translated">使用嵌入式数组</target>
        </trans-unit>
        <trans-unit id="97a6a1a45f47d0216453781940f9099c52dec943" translate="yes" xml:space="preserve">
          <source>Using form-encoded data:</source>
          <target state="translated">使用表格编码的数据。</target>
        </trans-unit>
        <trans-unit id="67bce4759a1cb93217026e515d5d3cc2b3774b9a" translate="yes" xml:space="preserve">
          <source>Using indexes: &lt;a href=&quot;../../../api/javascript/get_all/index&quot;&gt;getAll&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/between/index&quot;&gt;between&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/eq_join/index&quot;&gt;eqJoin&lt;/a&gt; and &lt;a href=&quot;../../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt;</source>
          <target state="translated">使用索引：&lt;a href=&quot;../../../api/javascript/get_all/index&quot;&gt;GETALL&lt;/a&gt;，&lt;a href=&quot;../../../api/javascript/between/index&quot;&gt;之间&lt;/a&gt;，&lt;a href=&quot;../../../api/javascript/eq_join/index&quot;&gt;eqJoin&lt;/a&gt;和&lt;a href=&quot;../../../api/javascript/order_by/index&quot;&gt;排序依据&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8c903deddf1788950d2da6460df95c1c59112ce" translate="yes" xml:space="preserve">
          <source>Using multi indexes and arbitrary expressions together</source>
          <target state="translated">同时使用多索引和任意表达式。</target>
        </trans-unit>
        <trans-unit id="3d5fe0f0b3e1de4f6909c894b998f50d44a3a243" translate="yes" xml:space="preserve">
          <source>Using one Handler with multiple queries</source>
          <target state="translated">使用一个处理程序进行多个查询</target>
        </trans-unit>
        <trans-unit id="e4d9b622d71e22f8696e9db216e36591b73d21e4" translate="yes" xml:space="preserve">
          <source>Using primary keys</source>
          <target state="translated">使用主键</target>
        </trans-unit>
        <trans-unit id="6b170d9f14648ef984442f6e5e63898213d065c9" translate="yes" xml:space="preserve">
          <source>Using repubsub</source>
          <target state="translated">使用resubsub</target>
        </trans-unit>
        <trans-unit id="1cec89010b614aeb7357b2820307b3ae5393bd2f" translate="yes" xml:space="preserve">
          <source>Using secondary indexes</source>
          <target state="translated">使用二级索引</target>
        </trans-unit>
        <trans-unit id="5eca378782b329a4026fe26cdc21aac26acd3ebe" translate="yes" xml:space="preserve">
          <source>Using secondary indexes in RethinkDB</source>
          <target state="translated">在RethinkDB中使用二级索引</target>
        </trans-unit>
        <trans-unit id="84d838889946a0fac40a5de13ea1a2f43bfbcbdc" translate="yes" xml:space="preserve">
          <source>Using subqueries</source>
          <target state="translated">使用子查询</target>
        </trans-unit>
        <trans-unit id="729c7823bfb90d234bb84656173de344c20bea56" translate="yes" xml:space="preserve">
          <source>Using subqueries to return additional fields</source>
          <target state="translated">使用子查询来返回附加字段</target>
        </trans-unit>
        <trans-unit id="43a6ea12e91af64b785f205dfed680f0218707a4" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;emergency_repair&lt;/code&gt; option on a table will invalidate all the guarantees.</source>
          <target state="translated">在表上使用 &lt;code&gt;emergency_repair&lt;/code&gt; 选项将使所有保证无效。</target>
        </trans-unit>
        <trans-unit id="5722bcd22448ac79f109bb697058f2d47ce09231" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;multi&lt;/code&gt; option we can group data by match A, B or C.</source>
          <target state="translated">使用 &lt;code&gt;multi&lt;/code&gt; 选项，我们可以按匹配项A，B或C对数据进行分组。</target>
        </trans-unit>
        <trans-unit id="705d0b4e12cf0053e511acba4552bde444eb041e" translate="yes" xml:space="preserve">
          <source>Using the RethinkDB authentication system</source>
          <target state="translated">使用RethinkDB认证系统</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="7b90cb504c43b2a2a9b990be53f6df122a25af9b" translate="yes" xml:space="preserve">
          <source>Values and predicates may be mixed freely in the argument list.</source>
          <target state="translated">值和谓词可以在参数列表中自由混合。</target>
        </trans-unit>
        <trans-unit id="926d89b38c0fd681c3af2ba8930446b8e5f7318c" translate="yes" xml:space="preserve">
          <source>Values in CSV imports will always be imported as strings. If you want to convert those fields after import to the &lt;code&gt;number&lt;/code&gt; data type, run an &lt;code&gt;update&lt;/code&gt; query that does the conversion. An example runnable in the Data Explorer:</source>
          <target state="translated">CSV导入中的值将始终作为字符串导入。如果要在导入后将这些字段转换为 &lt;code&gt;number&lt;/code&gt; 数据类型，请运行执行转换的 &lt;code&gt;update&lt;/code&gt; 查询。在数据资源管理器中可运行的示例：</target>
        </trans-unit>
        <trans-unit id="15016d3c7c10ecd1c9597a5f34d435ed31333cb0" translate="yes" xml:space="preserve">
          <source>Venturing into the river</source>
          <target state="translated">冒險進入河中</target>
        </trans-unit>
        <trans-unit id="f0bcbe1a75a85e68f5324b0bd200d85161e476dd" translate="yes" xml:space="preserve">
          <source>Version V1_0</source>
          <target state="translated">V1_0版本</target>
        </trans-unit>
        <trans-unit id="cfc78243db15552d9f29c3a8e82edc038370e606" translate="yes" xml:space="preserve">
          <source>Version migration</source>
          <target state="translated">版本迁移</target>
        </trans-unit>
        <trans-unit id="8dccbe2184e054027478456d942eb37b74c436b7" translate="yes" xml:space="preserve">
          <source>Versions V0_3 and V0_4</source>
          <target state="translated">V0_3和V0_4版本。</target>
        </trans-unit>
        <trans-unit id="0ee85caf439b8d9ca0edb97fdd328b72c5f720aa" translate="yes" xml:space="preserve">
          <source>Versions of RethinkDB prior to 2.3 allowed &lt;code&gt;wait&lt;/code&gt; to be called without a table or database specified. This is no longer valid; &lt;code&gt;wait&lt;/code&gt; requires explicit selection of a database or table.</source>
          <target state="translated">RethinkDB 2.3之前的版本允许在未指定表或数据库的情况下 &lt;code&gt;wait&lt;/code&gt; 调用。这不再有效； &lt;code&gt;wait&lt;/code&gt; 需要显式选择数据库或表。</target>
        </trans-unit>
        <trans-unit id="8348559cdda119c179112149d26acad5abced44c" translate="yes" xml:space="preserve">
          <source>Via a SOCKS proxy</source>
          <target state="translated">通过SOCKS代理</target>
        </trans-unit>
        <trans-unit id="3869ea92f6e4c30ec5a50a43581bcd31fb6f5b45" translate="yes" xml:space="preserve">
          <source>Via a reverse proxy</source>
          <target state="translated">通过反向代理</target>
        </trans-unit>
        <trans-unit id="975a1001ef5a5de638f5bda5e81a0529a895c359" translate="yes" xml:space="preserve">
          <source>Wait for a table or all the tables in a database to be ready. A table may be temporarily unavailable after creation, rebalancing or reconfiguring. The &lt;code&gt;wait&lt;/code&gt; command blocks until the given table (or database) is fully up to date.</source>
          <target state="translated">等待一个表或数据库中的所有表准备就绪。创建，重新平衡或重新配置后，表可能暂时不可用。在 &lt;code&gt;wait&lt;/code&gt; 命令块，直到给定的表（或数据库）是完全处于最新状态。</target>
        </trans-unit>
        <trans-unit id="261d399f3036a71cf61c5c84dd87512ac2888ee9" translate="yes" xml:space="preserve">
          <source>Wait for the instance to initialize.</source>
          <target state="translated">等待实例的初始化。</target>
        </trans-unit>
        <trans-unit id="d0c1959b0ecb2f56be0b9936d450f3112ec53c98" translate="yes" xml:space="preserve">
          <source>Wait for the specified indexes on this table to be ready, or for all indexes on this table to be ready if no indexes are specified.</source>
          <target state="translated">等待本表上指定的索引准备好,如果没有指定索引,则等待本表上所有索引准备好。</target>
        </trans-unit>
        <trans-unit id="72ca0cead14e5f62674072d67d6d08760af08beb" translate="yes" xml:space="preserve">
          <source>We also let you slice the time into the date and the current time of day (a time and a duration, respectively):</source>
          <target state="translated">我们还可以让你把时间切成日期和当前的时间(分别是一个时间和一个持续时间)。</target>
        </trans-unit>
        <trans-unit id="7776b91d96b28a68efde88ac27af064591f79f60" translate="yes" xml:space="preserve">
          <source>We also recently contracted Kyle Kingsbury, known to the Internet as &lt;a href=&quot;https://twitter.com/aphyr&quot;&gt;@aphyr&lt;/a&gt;, as an independent researcher to evaluate RethinkDB. He wrote &lt;a href=&quot;https://aphyr.com/tags/RethinkDB&quot;&gt;a pair of blog posts&lt;/a&gt; on how he tested and confirmed RethinkDB clustering and consistency guarantees.</source>
          <target state="translated">我们最近还签约了Kyle Kingsbury（其在互联网上称为&lt;a href=&quot;https://twitter.com/aphyr&quot;&gt;@aphyr&lt;/a&gt;）作为评估RethinkDB的独立研究人员。他写&lt;a href=&quot;https://aphyr.com/tags/RethinkDB&quot;&gt;了&lt;/a&gt;两篇博客文章，介绍了他如何测试和确认RethinkDB集群和一致性保证。</target>
        </trans-unit>
        <trans-unit id="6d342d6dbf43f23b7c55cc56df79901ba303f19e" translate="yes" xml:space="preserve">
          <source>We always welcome suggestions on how to improve our documentation, or specific ReQL questions.</source>
          <target state="translated">我们始终欢迎对如何改进我们的文档或具体的ReQL问题提出建议。</target>
        </trans-unit>
        <trans-unit id="9f7018091e8774b88423f84671a497d40e60360f" translate="yes" xml:space="preserve">
          <source>We can also efficiently retrieve documents by their primary key using the &lt;code&gt;get&lt;/code&gt; command. We can use one of the ids generated in the previous example:</source>
          <target state="translated">我们还可以使用 &lt;code&gt;get&lt;/code&gt; 命令通过其主键有效地检索文档。我们可以使用上一个示例中生成的ID之一：</target>
        </trans-unit>
        <trans-unit id="64de53529b50a2fdc1bd84d07e544b9a92f93299" translate="yes" xml:space="preserve">
          <source>We can also specify more in-depth validation on fields. We can modify the &lt;code&gt;Article&lt;/code&gt; model in a few ways to ensure the data has the properties we expect:</source>
          <target state="translated">我们还可以在字段上指定更深入的验证。我们可以通过几种方式修改 &lt;code&gt;Article&lt;/code&gt; 模型，以确保数据具有我们期望的属性：</target>
        </trans-unit>
        <trans-unit id="c63294a56bafc0eef492fd77b1e4ed5da84b133b" translate="yes" xml:space="preserve">
          <source>We can chain the &lt;code&gt;zip&lt;/code&gt; command at the end of the query to merge the two fields into a single document. For example, the following query:</source>
          <target state="translated">我们可以在查询末尾链接 &lt;code&gt;zip&lt;/code&gt; 命令，以将两个字段合并到一个文档中。例如，以下查询：</target>
        </trans-unit>
        <trans-unit id="13f934be941448b5e9e200ea54513a21677bf61d" translate="yes" xml:space="preserve">
          <source>We can create a secondary index on the &lt;code&gt;company&lt;/code&gt; field of the &lt;code&gt;companies&lt;/code&gt; table, and perform our query by taking advantage of the secondary index:</source>
          <target state="translated">我们可以在 &lt;code&gt;companies&lt;/code&gt; 表的 &lt;code&gt;company&lt;/code&gt; 字段上创建二级索引，并利用二级索引来执行查询：</target>
        </trans-unit>
        <trans-unit id="421ccb395f490935893503fb8285f8416b351dd1" translate="yes" xml:space="preserve">
          <source>We can join the two tables as follows:</source>
          <target state="translated">我们可以将两张表连接如下。</target>
        </trans-unit>
        <trans-unit id="238cbcbb68c7b2e609fdf95cbb4c9da849d12481" translate="yes" xml:space="preserve">
          <source>We can model the relationship between authors and posts by using embedded arrays as follows. Consider this example document in the table &lt;code&gt;authors&lt;/code&gt;:</source>
          <target state="translated">我们可以通过使用嵌入式数组来建模作者和帖子之间的关系，如下所示。在表格 &lt;code&gt;authors&lt;/code&gt; 考虑以下示例文档：</target>
        </trans-unit>
        <trans-unit id="64689a843a25c01b96b2b56aefbb1e9ab53997e6" translate="yes" xml:space="preserve">
          <source>We can now filter based on these times:</source>
          <target state="translated">我们现在可以根据这些时间进行筛选。</target>
        </trans-unit>
        <trans-unit id="a8b638b442b219f731f46422f2827d1aa6301062" translate="yes" xml:space="preserve">
          <source>We can now sort the stargazers by the number of their followers!</source>
          <target state="translated">现在,我们可以根据追星族的粉丝数量进行分类了!</target>
        </trans-unit>
        <trans-unit id="c67d818e11b259fa9a1add1ae55aba6b19cb3598" translate="yes" xml:space="preserve">
          <source>We can rewrite the previous query with &lt;code&gt;r.branch&lt;/code&gt; too.</source>
          <target state="translated">我们也可以使用 &lt;code&gt;r.branch&lt;/code&gt; 重写先前的查询。</target>
        </trans-unit>
        <trans-unit id="5d13a4948443772b564d9f81fd28607546884e82" translate="yes" xml:space="preserve">
          <source>We can schedule it on the Tornado IO loop with this code:</source>
          <target state="translated">我们可以用这段代码将其调度在Tornado IO循环上。</target>
        </trans-unit>
        <trans-unit id="44a3bc4b8cc860b147fafd28edacfcceffded305" translate="yes" xml:space="preserve">
          <source>We can schedule it on the Twisted &lt;code&gt;reactor&lt;/code&gt; with this code:</source>
          <target state="translated">我们可以使用以下代码在Twisted &lt;code&gt;reactor&lt;/code&gt; 上调度它：</target>
        </trans-unit>
        <trans-unit id="937a9712d9866bbe0eeb7d1ad3b0b2515f02e6ff" translate="yes" xml:space="preserve">
          <source>We can use the following syntax:</source>
          <target state="translated">我们可以使用以下语法。</target>
        </trans-unit>
        <trans-unit id="749984b3d67df427b6d7089de846645a0b19255b" translate="yes" xml:space="preserve">
          <source>We compose the query on the client and call &lt;code&gt;run&lt;/code&gt; only once. Remember to call &lt;code&gt;run&lt;/code&gt; only once on the complex query when you&amp;rsquo;re ready for it to be executed.</source>
          <target state="translated">我们在客户端上组成查询，并且仅调用一次 &lt;code&gt;run&lt;/code&gt; 。记住调用 &lt;code&gt;run&lt;/code&gt; ，当你准备要执行它的复杂查询一次。</target>
        </trans-unit>
        <trans-unit id="7fc2949011d5056e98a8b39f265e81ae5fa84b31" translate="yes" xml:space="preserve">
          <source>We define &lt;code&gt;r.monday...r.sunday&lt;/code&gt; and &lt;code&gt;r.january...r.december&lt;/code&gt; for convenience:</source>
          <target state="translated">为了方便起见，我们定义 &lt;code&gt;r.monday...r.sunday&lt;/code&gt; 和 &lt;code&gt;r.january...r.december&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="745b28655c36626ee40e3202ef17f3821beb6747" translate="yes" xml:space="preserve">
          <source>We felt that performing automatic maintenance operations on the cluster (such as adding shards) is a higher-level component, and that it&amp;rsquo;s crucial to have a really good implementation of the lower-level components done first. As a result, the clustering system is organized into three layers:</source>
          <target state="translated">我们认为，在集群上执行自动维护操作（例如添加分片）是一个较高级别的组件，而对一个较低级别的组件进行真正良好的实现是至关重要的。结果，集群系统分为三层：</target>
        </trans-unit>
        <trans-unit id="05c0c11e81d4866e9926eff039590fc5082fe2af" translate="yes" xml:space="preserve">
          <source>We first tested this workload in the &lt;a href=&quot;https://www.rethinkdb.com/api/javascript/run/&quot;&gt;default configuration for RethinkDB which forbids stale reads&lt;/a&gt;. In this configuration, RethinkDB is able to perform 134.7K QPS on a single server. While the overhead of network communication between the servers becomes visible when increasing the cluster size from one to two servers, adding further servers to the cluster demonstrates the near-linear scalability of RethinkDB, up to over 500K QPS on 16 servers.</source>
          <target state="translated">我们首先在&lt;a href=&quot;https://www.rethinkdb.com/api/javascript/run/&quot;&gt;RethinkDB&lt;/a&gt;的默认配置（禁止陈旧读取）中测试了此工作负载。在此配置中，RethinkDB能够在单个服务器上执行134.7K QPS。当将群集大小从一台服务器增加到两台服务器时，服务器之间的网络通信开销变得可见，但向群集中添加更多服务器则表明RethinkDB具有近乎线性的可扩展性，最多可在16台服务器上提供500K QPS。</target>
        </trans-unit>
        <trans-unit id="b3bfcc94969b31f058be9abcc163977af2f5f363" translate="yes" xml:space="preserve">
          <source>We found that in a mixed read/write workload, RethinkDB with two servers was able to perform nearly 16K queries per second (QPS) and scaled to almost 120K QPS while in a 16-node cluster. Under a read only workload and synchronous read settings, RethinkDB was able to scale from about 150K QPS on a single node up to over 550K QPS on 16 nodes. Under the same workload, in an asynchronous &amp;ldquo;outdated read&amp;rdquo; setting, RethinkDB went from 150K QPS on one server to 1.3M in a 16-node cluster.</source>
          <target state="translated">我们发现，在混合的读/写工作负载中，带有两个服务器的RethinkDB能够每秒执行近16K查询（QPS），并在16节点群集中扩展到近120K QPS。在只读工作负载和同步读取设置下，RethinkDB能够从单个节点上的大约150K QPS扩展到16个节点上的550K QPS以上。在相同的工作负载下，通过异步&amp;ldquo;过期读取&amp;rdquo;设置，RethinkDB从一台服务器上的150K QPS变为16节点群集中的1.3M。</target>
        </trans-unit>
        <trans-unit id="dbff981f6fd069bd5c8d8cf7eb708cfb69dba1bf" translate="yes" xml:space="preserve">
          <source>We pass the &lt;code&gt;lastName&lt;/code&gt; saved from the previous set to &lt;code&gt;between&lt;/code&gt; as the start index. For the end index, we pass &lt;code&gt;null&lt;/code&gt; to return documents from the start index to the table&amp;rsquo;s end. The &lt;code&gt;leftBound&lt;/code&gt; parameter tells &lt;code&gt;between&lt;/code&gt; not to include the first record, since it was already returned as part of the previous page.</source>
          <target state="translated">我们将前一组保存的 &lt;code&gt;lastName&lt;/code&gt; 传递到 &lt;code&gt;between&lt;/code&gt; 作为起始索引。对于结束索引，我们传递 &lt;code&gt;null&lt;/code&gt; 以将文档从开始索引返回到表的末尾。该 &lt;code&gt;leftBound&lt;/code&gt; 参数告诉 &lt;code&gt;between&lt;/code&gt; 不包括第一个记录，因为它已经返回前一页面的一部分。</target>
        </trans-unit>
        <trans-unit id="5e4ab3e8535ad86d1930d6966ac3b697d68d7c2d" translate="yes" xml:space="preserve">
          <source>We run one query at a time. Results show the average over five runs.</source>
          <target state="translated">我们每次运行一个查询。结果显示的是五次运行的平均值。</target>
        </trans-unit>
        <trans-unit id="0cfdf1121b09e1f9602550a8e25484415b81e4d7" translate="yes" xml:space="preserve">
          <source>We run this query five times for every cluster size and then calculate the average runtime. The results table below shows these averages.</source>
          <target state="translated">我们为每个集群大小运行这个查询五次,然后计算平均运行时间。下面的结果表显示了这些平均值。</target>
        </trans-unit>
        <trans-unit id="2f9e5f655eaf28e2126ba52b421344bdf3a5d0a2" translate="yes" xml:space="preserve">
          <source>We should get back an object that looks like this:</source>
          <target state="translated">我们应该得到一个像这样的对象。</target>
        </trans-unit>
        <trans-unit id="196493c218ffa561ad6e0835430dcfa5bcdcb59b" translate="yes" xml:space="preserve">
          <source>We use Github for issue tracking: &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues&quot;&gt;https://github.com/rethinkdb/rethinkdb/issues&lt;/a&gt;. If you want to report a suspected bug in RethinkDB, open an issue there.</source>
          <target state="translated">我们使用Github进行问题跟踪：&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues&quot;&gt;https&lt;/a&gt; : //github.com/rethinkdb/rethinkdb/issues。如果要报告RethinkDB中的可疑错误，请在此处打开一个问题。</target>
        </trans-unit>
        <trans-unit id="2572dfb8bb2188aed94b74fdd625ca4d557e9b76" translate="yes" xml:space="preserve">
          <source>We use the ISO 8601 definition of a week, which starts with Monday, represented as &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">我们使用一周的ISO 8601定义，该定义从星期一开始，表示为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="665c5f87426678ac0c4134325d4f37ee25bde4ef" translate="yes" xml:space="preserve">
          <source>We used a port of YCSB based on our official Java driver and intend to submit a pull request for it in the near future. &lt;a href=&quot;https://github.com/rethinkdb/ycsb&quot;&gt;Our fork is available for review here&lt;/a&gt;.</source>
          <target state="translated">我们使用了基于我们官方Java驱动程序的YCSB端口，并打算在不久的将来对此请求提交拉取请求。&lt;a href=&quot;https://github.com/rethinkdb/ycsb&quot;&gt;我们的货叉可以在这里查看&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18dd2c5b2e52082a2c22b308916628b31080863f" translate="yes" xml:space="preserve">
          <source>We wanted to provide a reasonably comprehensive RethinkDB test that covers a variety of different workloads. We chose to use the YCSB testing framework as a reliable and community-approved means of conducting rigorous testing on our database. We saw that all of the tests resulted in near-linear scalability as we moved from a single RethinkDB instance to a 16 node cluster. Although most of the tests resulted in performance metrics that suggest horizontal scalability, we know that there are plenty of improvements to make as the database evolves.</source>
          <target state="translated">我们希望提供一个合理全面的RethinkDB测试,涵盖各种不同的工作负载。我们选择使用YCSB测试框架,作为对我们的数据库进行严格测试的可靠和社区认可的手段。我们看到,当我们从一个RethinkDB实例转移到一个16节点集群时,所有的测试都导致了近乎线性的可扩展性。虽然大多数测试的结果是性能指标表明水平扩展性,但我们知道随着数据库的发展,还有很多改进的地方。</target>
        </trans-unit>
        <trans-unit id="f96b69538b15b08a373ab863833264fbb5d412fa" translate="yes" xml:space="preserve">
          <source>We were fortunate enough to receive free credits from Rackspace to perform the majority of these tests and are very grateful for their contributions to open source software. All of &lt;a href=&quot;https://www.rackspace.com/cloud/servers/onmetal&quot;&gt;Rackspace&amp;rsquo;s OnMetal offerings can be found here&lt;/a&gt;.</source>
          <target state="translated">我们很幸运地从Rackspace获得了免费的信用，可以执行大多数此类测试，并非常感谢他们对开源软件的贡献。&lt;a href=&quot;https://www.rackspace.com/cloud/servers/onmetal&quot;&gt;可以在此处找到Rackspace的&lt;/a&gt;所有OnMetal产品。</target>
        </trans-unit>
        <trans-unit id="164561a49c5ec1d8b8043aa717cadb49a0004f16" translate="yes" xml:space="preserve">
          <source>We won&amp;rsquo;t need a &lt;strong&gt;group&lt;/strong&gt; step for this example.</source>
          <target state="translated">在此示例中，我们不需要&lt;strong&gt;分组&lt;/strong&gt;。</target>
        </trans-unit>
        <trans-unit id="5adda084a6c0ad257b70d2264a1e0d1c00f337fa" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d love to answer any questions you have about these tests. Come join us at &lt;a href=&quot;http://slack.rethinkdb.com&quot;&gt;http://slack.rethinkdb.com&lt;/a&gt; and feel free to ask more specific questions we don&amp;rsquo;t answer here by pinging @danielmewes or @dalanmiller.</source>
          <target state="translated">我们很乐意回答您对这些测试的任何疑问。快来&lt;a href=&quot;http://slack.rethinkdb.com&quot;&gt;http://slack.rethinkdb.com&lt;/a&gt;加入我们，并通过ping @danielmewes或@dalanmiller随意提出一些我们不在此处回答的更具体的问题。</target>
        </trans-unit>
        <trans-unit id="60cf0d58afd9a9633a947183c3b149f711f93f0f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll attempt to answer these questions by using workloads from the YCSB benchmark suite. You can &lt;a href=&quot;https://labs.yahoo.com/news/yahoo-cloud-serving-benchmark&quot;&gt;learn more about YCSB here&lt;/a&gt;, and &lt;a href=&quot;https://github.com/rethinkdb/ycsb&quot;&gt;review the source code here&lt;/a&gt;. Expanding beyond the YCSB workloads we selected, we created an additional test which investigates scalability for analytic workloads.</source>
          <target state="translated">我们将尝试使用YCSB基准套件中的工作量来回答这些问题。您可以&lt;a href=&quot;https://labs.yahoo.com/news/yahoo-cloud-serving-benchmark&quot;&gt;在此处了解有关YCSB的更多信息&lt;/a&gt;，并在此处&lt;a href=&quot;https://github.com/rethinkdb/ycsb&quot;&gt;查看源代码&lt;/a&gt;。为了扩展到我们选择的YCSB工作负载之外，我们创建了一个额外的测试，用于调查分析工作负载的可伸缩性。</target>
        </trans-unit>
        <trans-unit id="353d7cec36aac636b04e7dd7fdc90d2f15428252" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll go over the other two sources in more detail.</source>
          <target state="translated">我们将更详细地介绍其他两个资源。</target>
        </trans-unit>
        <trans-unit id="85193fc8eeecb00e53dca414ff426e4d326bd9f6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll sign an NDA if necessary, and can set up an FTP server for you to transfer the file to if it&amp;rsquo;s large.</source>
          <target state="translated">如有必要，我们将签署NDA，并且可以设置FTP服务器供您将文件传输到较大的文件。</target>
        </trans-unit>
        <trans-unit id="66df9144e5385962d5f6afd0a4d7f84e1cf0c9a6" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re exploring best practices to determine whether it&amp;rsquo;s possible to build a really good general purpose automation layer that controls the cluster by automatically enforcing user-specified rules (such as resharding the system when the shard balance drops below a certain threshold).</source>
          <target state="translated">我们正在探索最佳实践，以确定是否有可能通过自动执行用户指定的规则（例如，当分片余额降至某个阈值以下时重新分片系统）来构建一个非常好的通用自动化层来控制集群。</target>
        </trans-unit>
        <trans-unit id="a538ffd70620351939ce46ac034c5da4165359af" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re working on an easier syntax for performing multiple aggregations after &lt;code&gt;group&lt;/code&gt; commands. Follow &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/1725&quot;&gt;issue 1725&lt;/a&gt; to track progress on this.</source>
          <target state="translated">我们正在研究一种更简单的语法，用于在 &lt;code&gt;group&lt;/code&gt; 命令之后执行多个聚合。请遵循&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/1725&quot;&gt;问题1725，&lt;/a&gt;以跟踪此进度。</target>
        </trans-unit>
        <trans-unit id="bf8c4b29bb88f8bd8bcd0cf73f362e495df9a83a" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve just inserted two rows into the &lt;code&gt;tv_shows&lt;/code&gt; table. Let&amp;rsquo;s verify the number of rows inserted:</source>
          <target state="translated">我们刚刚在 &lt;code&gt;tv_shows&lt;/code&gt; 表中插入了两行。让我们验证插入的行数：</target>
        </trans-unit>
        <trans-unit id="0701e0f428cf7608aac0acb0258957e688e4a72b" translate="yes" xml:space="preserve">
          <source>Web frontend written in PHP to create/rename/update/delete RethinkDB databases/tables/docs and run ReQL queries in PHP.</source>
          <target state="translated">用PHP编写的Web前端可以创建/重命名/更新/删除RethinkDB数据库/表/文件,并在PHP中运行ReQL查询。</target>
        </trans-unit>
        <trans-unit id="7a6ea1d18d178d755c66b826316925c783a2b7a2" translate="yes" xml:space="preserve">
          <source>Web options</source>
          <target state="translated">网页选项</target>
        </trans-unit>
        <trans-unit id="bc84915ab33bd5e1a1327bf7c2b3bb4fd9f8f422" translate="yes" xml:space="preserve">
          <source>WebGL</source>
          <target state="translated">WebGL</target>
        </trans-unit>
        <trans-unit id="38dbec004299870c0658d95152cb99afac826447" translate="yes" xml:space="preserve">
          <source>Wercker box for RethinkDB, by &lt;a href=&quot;https://github.com/mies&quot;&gt;@mies&lt;/a&gt;.</source>
          <target state="translated">RethinkDB的Wercker框，@ &lt;a href=&quot;https://github.com/mies&quot;&gt;mies&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04042d6ae7f7ec89f3280cedaa0c0eacdb0730a2" translate="yes" xml:space="preserve">
          <source>What CAP theorem tradeoffs are made in RethinkDB?</source>
          <target state="translated">RethinkDB的CAP定理有哪些取舍?</target>
        </trans-unit>
        <trans-unit id="3ef0a4b65de6f3a94060b4fcb91fcc42ad42201d" translate="yes" xml:space="preserve">
          <source>What Elasticsearch does</source>
          <target state="translated">Elasticsearch的功能</target>
        </trans-unit>
        <trans-unit id="c9d3e613df197c31b8cbb198ef82019567e7ac08" translate="yes" xml:space="preserve">
          <source>What are availability and performance impacts of sharding and replication?</source>
          <target state="translated">sharding和复制对可用性和性能有什么影响?</target>
        </trans-unit>
        <trans-unit id="64c26d1ad1ec301943108eaa27899279ef7ac1fd" translate="yes" xml:space="preserve">
          <source>What does &amp;lsquo;received invalid clustering header&amp;rsquo; mean?</source>
          <target state="translated">&amp;ldquo;收到的无效聚类头&amp;rdquo;是什么意思？</target>
        </trans-unit>
        <trans-unit id="2a9c3f058de7e47106c818dfd4d4338f9cdd8f8d" translate="yes" xml:space="preserve">
          <source>What does it mean to be inefficient here? When operating on grouped data rather than a grouped stream, &lt;em&gt;all&lt;/em&gt; of the data has to be available on the node processing the query. This means that the operation will only use one server&amp;rsquo;s resources, and will require memory proportional to the size of the grouped data it&amp;rsquo;s operating on. (In the case of the &lt;a href=&quot;../order_by/index&quot;&gt;orderBy&lt;/a&gt; in the inefficient example, that means memory proportional &lt;strong&gt;to the size of the table&lt;/strong&gt;.) The array limit is also enforced for grouped data, so the &lt;code&gt;orderBy&lt;/code&gt; example would fail for tables with more than 100,000 rows without changing the &lt;code&gt;arrayLimit&lt;/code&gt; option to &lt;code&gt;run&lt;/code&gt;.</source>
          <target state="translated">这里的低效率意味着什么？当对分组数据而不是分组流进行操作时，&lt;em&gt;所有&lt;/em&gt;数据必须在处理查询的节点上可用。这意味着该操作将仅使用一台服务器的资源，并且将需要与其操作的分组数据大小成比例的内存。 （在效率低下的示例中，对于&lt;a href=&quot;../order_by/index&quot;&gt;orderBy而言&lt;/a&gt;，这意味着内存与&lt;strong&gt;表的大小&lt;/strong&gt;成正比。）数组限制也适用于分组数据，因此，对于具有100,000行以上的表而未更改&lt;strong&gt;表的大小，&lt;/strong&gt; &lt;code&gt;orderBy&lt;/code&gt; 示例将失败 &lt;code&gt;arrayLimit&lt;/code&gt; 选项 &lt;code&gt;run&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04e01954d9f8d8e77895e864b870472fafc1d2fc" translate="yes" xml:space="preserve">
          <source>What governs the location of shards and replicas in the cluster?</source>
          <target state="translated">碎片和副本在集群中的位置受什么支配?</target>
        </trans-unit>
        <trans-unit id="aeecbe039cd869cf6b58de21cfda895bec05bbb8" translate="yes" xml:space="preserve">
          <source>What happens when a server becomes unreachable?</source>
          <target state="translated">当服务器变得无法访问时,会发生什么?</target>
        </trans-unit>
        <trans-unit id="84f1d71d28f72c7bce86041433bf5e9d8269c36b" translate="yes" xml:space="preserve">
          <source>What is RethinkDB?</source>
          <target state="translated">什么是RethinkDB?</target>
        </trans-unit>
        <trans-unit id="792fc2e237565f7453ac727b16937607f543048d" translate="yes" xml:space="preserve">
          <source>What sort of performance can I expect from a RethinkDB cluster?</source>
          <target state="translated">我可以从RethinkDB集群中期待什么样的性能?</target>
        </trans-unit>
        <trans-unit id="c273c7432071ee60c46a1ad37f5833a8812489f7" translate="yes" xml:space="preserve">
          <source>What to do after a crash</source>
          <target state="translated">撞车后该怎么办</target>
        </trans-unit>
        <trans-unit id="e860c67987579ed63e69cb49c8bae21cee8ab0f2" translate="yes" xml:space="preserve">
          <source>What you likely want is the result of using &lt;code&gt;zip&lt;/code&gt; with that. For clarity, we&amp;rsquo;ll use &lt;code&gt;without&lt;/code&gt; to drop the &lt;code&gt;id&lt;/code&gt; field from the games table (it conflicts with the &lt;code&gt;id&lt;/code&gt; field for the players and it&amp;rsquo;s redundant anyway), and we&amp;rsquo;ll order it by the games.</source>
          <target state="translated">您可能想要的是使用 &lt;code&gt;zip&lt;/code&gt; 的结果。为了清楚起见，我们将 &lt;code&gt;without&lt;/code&gt; 使用从游戏表中删除 &lt;code&gt;id&lt;/code&gt; 字段的方式（它与玩家的 &lt;code&gt;id&lt;/code&gt; 字段冲突，并且无论如何都是多余的），我们将按游戏顺序对其进行排序。</target>
        </trans-unit>
        <trans-unit id="b2412f7ca4f8b6170188b11c9ed6cd4be9e075b0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;count&lt;/code&gt; is called on a sequence with a predicate value or function, it returns the number of elements in the sequence equal to that value or where the function returns &lt;code&gt;true&lt;/code&gt;. On a &lt;a href=&quot;../binary/index&quot;&gt;binary&lt;/a&gt; object, &lt;code&gt;count&lt;/code&gt; returns the size of the object in bytes; on strings, &lt;code&gt;count&lt;/code&gt; returns the string&amp;rsquo;s length. This is determined by counting the number of Unicode codepoints in the string, counting combining codepoints separately.</source>
          <target state="translated">在具有谓词值或函数的序列上调用 &lt;code&gt;count&lt;/code&gt; 时，它将返回序列中等于该值或函数返回 &lt;code&gt;true&lt;/code&gt; 的元素数。对于&lt;a href=&quot;../binary/index&quot;&gt;二进制&lt;/a&gt;对象， &lt;code&gt;count&lt;/code&gt; 返回以字节为单位的对象大小；在字符串上， &lt;code&gt;count&lt;/code&gt; 返回字符串的长度。这是通过计算字符串中Unicode代码点的数量，并分别计算组合代码点的数量来确定的。</target>
        </trans-unit>
        <trans-unit id="4a943aaea897090869701fc63a61450e4a044356" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;includeTypes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, there will be three fields:</source>
          <target state="translated">当 &lt;code&gt;includeTypes&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，将有三个字段：</target>
        </trans-unit>
        <trans-unit id="db59537e91adcaeb56b2666cc25c2ed2d6fefa3a" translate="yes" xml:space="preserve">
          <source>When a RethinkDB node starts, it will broadcast its &amp;ldquo;canonical&amp;rdquo; IP address, the address other nodes should use to connect to it. By default, the canonical address is the server&amp;rsquo;s primary IP address. However, if this address is an internal IP address that isn&amp;rsquo;t reachable by other nodes (for example, the nodes are on different networks), the nodes will not be able to reach one another. You may receive an error message such as:</source>
          <target state="translated">当RethinkDB节点启动时，它将广播其&amp;ldquo;规范&amp;rdquo; IP地址，其他节点应使用该地址连接到它。默认情况下，规范地址是服务器的主IP地址。但是，如果此地址是其他节点无法访问的内部IP地址（例如，这些节点位于不同的网络上），则这些节点将无法相互访问。您可能会收到以下错误消息：</target>
        </trans-unit>
        <trans-unit id="bbdb94ecb03dbf42358c1312dbd7d67d5be3564f" translate="yes" xml:space="preserve">
          <source>When a document is deleted, &lt;code&gt;new_val&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt;; when a document is inserted, &lt;code&gt;old_val&lt;/code&gt; will be &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">删除文档后， &lt;code&gt;new_val&lt;/code&gt; 将为 &lt;code&gt;null&lt;/code&gt; ；插入文档时， &lt;code&gt;old_val&lt;/code&gt; 将为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="703065bb49bf10d98540e55348b4199e4bf90f6b" translate="yes" xml:space="preserve">
          <source>When a node in the cluster receives a query from the client, it evaluates the query in the following way.</source>
          <target state="translated">当集群中的节点接收到来自客户端的查询时,会以如下方式对查询进行评估。</target>
        </trans-unit>
        <trans-unit id="7895cfeb7489d6ebc6349cdf88d440ab9cae0b6b" translate="yes" xml:space="preserve">
          <source>When a server connects or disconnects, its log entries will be added to or removed from the &lt;code&gt;logs&lt;/code&gt; table. The action of connecting or disconnecting will not generate changefeed events for those log entries.</source>
          <target state="translated">服务器连接或断开连接时，其日志条目将添加到 &lt;code&gt;logs&lt;/code&gt; 表中或从中删除。连接或断开连接的操作不会为这些日志条目生成更改源事件。</target>
        </trans-unit>
        <trans-unit id="734fd0f99a381fd084bb9daae0c46a98286a6f99" translate="yes" xml:space="preserve">
          <source>When a server fails, it may be because of a network availability issue or something more serious, such as system failure. In a multi-server configuration, where tables have multiple replicas distributed among multiple physical machines, RethinkDB will be able to maintain availability automatically in many cases.</source>
          <target state="translated">当一台服务器出现故障时,可能是因为网络可用性问题,也可能是更严重的问题,比如系统故障。在多服务器配置中,表的多个副本分布在多台物理机上,RethinkDB在很多情况下都能自动维护可用性。</target>
        </trans-unit>
        <trans-unit id="ff4dc39866df867c372286f6ac82dbbab1db65cb" translate="yes" xml:space="preserve">
          <source>When applied to a single object, &lt;code&gt;hasFields&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the object has the fields and &lt;code&gt;false&lt;/code&gt; if it does not. When applied to a sequence, it will return a new sequence (an array or stream) containing the elements that have the specified fields.</source>
          <target state="translated">当应用于单个对象时，如果对象具有字段，则 &lt;code&gt;hasFields&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。当应用于序列时，它将返回一个包含具有指定字段的元素的新序列（数组或流）。</target>
        </trans-unit>
        <trans-unit id="b45a355356ae32e6ce951e83aa32fd7dafeeac3c" translate="yes" xml:space="preserve">
          <source>When called with values, returns &lt;code&gt;true&lt;/code&gt; if a sequence contains all the specified values. When called with predicate functions, returns &lt;code&gt;true&lt;/code&gt; if for each predicate there exists at least one element of the stream where that predicate returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">用值调用时，如果序列包含所有指定值，则返回 &lt;code&gt;true&lt;/code&gt; 。当与谓词函数调用，返回 &lt;code&gt;true&lt;/code&gt; ，如果对于每个谓词那里的流，其中该谓词回报中的至少一个元素存在 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f48292c69cb277e3b22337ed22c98c2ced2902a" translate="yes" xml:space="preserve">
          <source>When creating a table you can specify the following options:</source>
          <target state="translated">创建表格时,您可以指定以下选项。</target>
        </trans-unit>
        <trans-unit id="95ca91852d7312c3e3e0989f96be0729d530f742" translate="yes" xml:space="preserve">
          <source>When grouped data are returned to the client, they are transformed into a client-specific native type. (Something similar is done with &lt;a href=&quot;../../../docs/dates-and-times/javascript/index&quot;&gt;times&lt;/a&gt;.) In JavaScript, grouped data are transformed into an &lt;code&gt;Array&lt;/code&gt;. If you instead want to receive the raw pseudotype from the server, you can specify &lt;code&gt;groupFormat: 'raw'&lt;/code&gt; as an optional argument to &lt;code&gt;run&lt;/code&gt;:</source>
          <target state="translated">当分组的数据返回给客户端时，它们将转换为特定于客户端的本机类型。（有些事情是用&lt;a href=&quot;../../../docs/dates-and-times/javascript/index&quot;&gt;时间&lt;/a&gt;来完成的。）在JavaScript中，分组数据被转换为 &lt;code&gt;Array&lt;/code&gt; 。如果您想从服务器接收原始 &lt;code&gt;groupFormat: 'raw'&lt;/code&gt; ，则可以指定groupFormat：'raw'作为 &lt;code&gt;run&lt;/code&gt; 的可选参数：</target>
        </trans-unit>
        <trans-unit id="733c238b3057fb40dff28896edf33c02a6ec4626" translate="yes" xml:space="preserve">
          <source>When new servers (including proxies) join an existing cluster, it will synchronize with all the user account information, including passwords, from that cluster. This includes the &lt;code&gt;admin&lt;/code&gt; account. However, a server with no admin password set cannot join an existing cluster that &lt;em&gt;does&lt;/em&gt; have a password set. Otherwise, it would technically be possible for an attacker to connect to that server as an admin and run arbitrary queries in the time between that server starting and the accounts synchronizing from the rest of the cluster.</source>
          <target state="translated">当新服务器（包括代理）加入现有群集时，它将与该群集中的所有用户帐户信息（包括密码）同步。这包括 &lt;code&gt;admin&lt;/code&gt; 帐户。然而，没有管理员密码集的服务器无法加入现有群集&lt;em&gt;并&lt;/em&gt;设置了口令。否则，从技术上讲，攻击者可能会以管理员身份连接到该服务器并在该服务器启动到与群集其余部分进行同步的帐户之间的时间运行任意查询。</target>
        </trans-unit>
        <trans-unit id="39499a0cd2439f58a90448079631a689bc240bd5" translate="yes" xml:space="preserve">
          <source>When paging occurs on RethinkDB&amp;rsquo;s process, performance will be adversely affected, and the more paging occurs the worse performance will be. You may be able to address it by ensuring other applications are not using physical memory on the server, tuning the paging cache, or adding more RAM to the server.</source>
          <target state="translated">当在RethinkDB的进程上进行页面调度时，性能将受到不利影响，并且发生的页面调度越多，性能将越差。您可以通过确保其他应用程序不使用服务器上的物理内存，调整分页缓存或向服务器添加更多RAM来解决该问题。</target>
        </trans-unit>
        <trans-unit id="e0ee88af11d3830bf42ab1d4973a89c0606e33c7" translate="yes" xml:space="preserve">
          <source>When posting a message to a topic, first repubsub attempts to overwrite a document with the exact same topic. If the exact topic isn&amp;rsquo;t found, it creates a new document with the topic.</source>
          <target state="translated">在将消息发布到主题时，第一次repubsub会尝试使用完全相同的主题覆盖文档。如果找不到确切的主题，它将使用该主题创建一个新文档。</target>
        </trans-unit>
        <trans-unit id="39c16909e8c88df0ea5a422f64978472b8724466" translate="yes" xml:space="preserve">
          <source>When servers are tagged, you can use the tags in the &lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;reconfigure&lt;/a&gt; command. To assign 3 replicas of the &lt;code&gt;users&lt;/code&gt; table to &lt;code&gt;us_west&lt;/code&gt; and 2 to &lt;code&gt;us_east&lt;/code&gt;:</source>
          <target state="translated">在标记服务器后，可以在&lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;reconfigure&lt;/a&gt;命令中使用标记。要将 &lt;code&gt;users&lt;/code&gt; 表的3个副本分配给 &lt;code&gt;us_west&lt;/code&gt; 并将2 个副本分配给 &lt;code&gt;us_east&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="786f7d315c87c4bca4d9c2b6ce53eda3ca9303b5" translate="yes" xml:space="preserve">
          <source>When starting RethinkDB from the command line, the cache size limit is set through the &lt;code&gt;--cache-size &amp;lt;limit in MB&amp;gt;&lt;/code&gt; argument:</source>
          <target state="translated">从命令行启动RethinkDB时，通过 &lt;code&gt;--cache-size &amp;lt;limit in MB&amp;gt;&lt;/code&gt; 参数设置缓存大小限制：</target>
        </trans-unit>
        <trans-unit id="79c7ae19c81131fd14f6580c4d04a2dee10e9f6b" translate="yes" xml:space="preserve">
          <source>When the RethinkDB instance is ready, click on its &lt;strong&gt;Access Software&lt;/strong&gt; link.</source>
          <target state="translated">当RethinkDB实例准备就绪时，单击其&lt;strong&gt;访问软件&lt;/strong&gt;链接。</target>
        </trans-unit>
        <trans-unit id="01a54f9b1d8b2e5e569294b706e164e9b5699c16" translate="yes" xml:space="preserve">
          <source>When the driver finds an anonymous function, it returns a query object like this one:</source>
          <target state="translated">当驱动程序找到匿名函数时,它会返回一个像这样的查询对象。</target>
        </trans-unit>
        <trans-unit id="46d0359667f7a0c929b209d338b0f9a3993f1d7d" translate="yes" xml:space="preserve">
          <source>When the option is available, you should choose the JSON file format. If you&amp;rsquo;re exporting from a SQL database this might not be possible, but you might be able to write a separate script to transform CSV output into JSON, or use the &lt;code&gt;mysql2json&lt;/code&gt; script available as part of &lt;a href=&quot;https://github.com/seamusabshere/mysql2xxxx&quot;&gt;mysql2xxxx&lt;/a&gt;.</source>
          <target state="translated">该选项可用时，您应该选择JSON文件格式。如果你从一个SQL数据库导出这也许是不可能的，但你也许可以写一个单独的脚本以CSV输出转换成JSON，或者使用 &lt;code&gt;mysql2json&lt;/code&gt; 可用脚本的一部分&lt;a href=&quot;https://github.com/seamusabshere/mysql2xxxx&quot;&gt;mysql2xxxx&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d5717a00ca57bc298ae32605ce5314580ad4d3f3" translate="yes" xml:space="preserve">
          <source>When the user creates a table, they have the option of specifying the attribute that will serve as the primary key (if the primary key attribute isn&amp;rsquo;t specified, it defaults to &amp;lsquo;id&amp;rsquo;). When the user inserts a document into the table, if the document contains the primary key attribute, its value is used to index the document. Otherwise, a random unique ID is generated for the index automatically.</source>
          <target state="translated">用户创建表时，可以选择指定将用作主键的属性（如果未指定主键属性，则默认为'id'）。当用户将文档插入表中时，如果文档包含主键属性，则其值将用于为文档建立索引。否则，将自动为索引生成一个随机的唯一ID。</target>
        </trans-unit>
        <trans-unit id="f13c50073789e73f7832addb638ad24cfe0cc700" translate="yes" xml:space="preserve">
          <source>When using the web UI, simply specify the number of shards you want, and based on the data available RethinkDB will determine the best split points to maintain balanced shards. To shard your data:</source>
          <target state="translated">在使用Web用户界面时,只需指定你想要的shard数量,根据可用的数据,RethinkDB将确定最佳的分割点,以保持平衡的shard。要对你的数据进行分片。</target>
        </trans-unit>
        <trans-unit id="085a0570038dfb7cf2cfd3cbed19548b2d1f7c9c" translate="yes" xml:space="preserve">
          <source>When you first start RethinkDB, the server opens a port for the client drivers (&lt;code&gt;28015&lt;/code&gt; by default). Let&amp;rsquo;s open a connection:</source>
          <target state="translated">首次启动RethinkDB时，服务器会打开客户端驱动程序的端口（默认为 &lt;code&gt;28015&lt;/code&gt; ）。让我们打开一个连接：</target>
        </trans-unit>
        <trans-unit id="35057656e095ebe83647859420615be9709172fb" translate="yes" xml:space="preserve">
          <source>When you issue a write query (&lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, or &lt;code&gt;replace&lt;/code&gt;), RethinkDB returns a summary object that looks like this:</source>
          <target state="translated">当您发出写查询（ &lt;code&gt;insert&lt;/code&gt; ， &lt;code&gt;delete&lt;/code&gt; ， &lt;code&gt;update&lt;/code&gt; 或 &lt;code&gt;replace&lt;/code&gt; ）时，RethinkDB返回一个摘要对象，如下所示：</target>
        </trans-unit>
        <trans-unit id="9adc3f762a66ce024127380f3784d16c509e1f05" translate="yes" xml:space="preserve">
          <source>When you parse the response string as JSON, you get the object:</source>
          <target state="translated">当你把响应字符串解析为JSON时,你会得到对象。</target>
        </trans-unit>
        <trans-unit id="715d798b7e9cd5985d005f0aed4eba85867d2b96" translate="yes" xml:space="preserve">
          <source>When you pass functions to ReQL, your language&amp;rsquo;s driver serializes those functions into ReQL lambda functions that are run on the server, not in your client language. (See &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;All about lambda functions in RethinkDB queries&lt;/a&gt; for more details.) A consequence of this is that native language constructs like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt; will not produce the expected result when their conditions involve ReQL commands. While they may not cause errors, they will be executed on the client side before the function is compiled for ReQL, and thus give an incorrect result. Instead, you must use equivalent ReQL control functions such as &lt;a href=&quot;../../api/javascript/branch/index&quot;&gt;branch&lt;/a&gt; and &lt;a href=&quot;../../api/javascript/for_each/index&quot;&gt;forEach&lt;/a&gt;. Here&amp;rsquo;s an example in Python from the &lt;a href=&quot;../introduction-to-reql/index&quot;&gt;Introduction to ReQL&lt;/a&gt; document:</source>
          <target state="translated">当您将函数传递给ReQL时，语言的驱动程序会将这些函数序列化为在服务器上运行的ReQL lambda函数，而不是以您的客户端语言运行。（有关更多详细信息，请参阅&lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;RethinkDB查询中的关于lambda函数的全部&lt;/a&gt;。）其结果是， &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;for&lt;/code&gt; 这样的本地语言结构的条件涉及ReQL命令时，它们将不会产生预期的结果。尽管它们可能不会引起错误，但是它们将在客户端上执行，然后再为ReQL编译函数，从而给出错误的结果。相反，必须使用等效的ReQL控制功能，例如&lt;a href=&quot;../../api/javascript/branch/index&quot;&gt;branch&lt;/a&gt;和&lt;a href=&quot;../../api/javascript/for_each/index&quot;&gt;forEach&lt;/a&gt;。这是&lt;a href=&quot;../introduction-to-reql/index&quot;&gt;ReQL简介&lt;/a&gt;中的Python 示例 文件：</target>
        </trans-unit>
        <trans-unit id="3b0d34296f9afa1b34c187838548381f1a1a9da2" translate="yes" xml:space="preserve">
          <source>When you turn on pagination in &lt;code&gt;r.http&lt;/code&gt;, instead of returning an array of documents, RethinkDB returns a stream which you can access in the driver via the usual cursor API. This is significant because pagination happens lazily &amp;mdash; RethinkDB will request new pages as you iterate through the cursor to minimize the number of API calls.</source>
          <target state="translated">当您在 &lt;code&gt;r.http&lt;/code&gt; 中打开分页时，RethinkDB会返回一个流，您可以通过常规游标API在驱动程序中访问该流，而不是返回文档数组。这很重要，因为分页是懒惰发生的-当您遍历游标时，RethinkDB将请求新页面以最大程度地减少API调用次数。</target>
        </trans-unit>
        <trans-unit id="910523961609d1635340d9fd8646a5044eb8223b" translate="yes" xml:space="preserve">
          <source>When you upgrade a major release (i.e., 2.1 to 2.2), you should rebuild outdated secondary indexes manually. This can be done easily from the command line:</source>
          <target state="translated">当你升级一个主要版本时(例如,2.1到2.2),你应该手动重建过时的二级索引。这可以通过命令行轻松完成。</target>
        </trans-unit>
        <trans-unit id="e01352645abcc16780dde4407c35c5e8f103dc1c" translate="yes" xml:space="preserve">
          <source>Whenever possible, the client drivers use operator overloading to support expressions such as &lt;code&gt;user['age'] &amp;gt; 30&lt;/code&gt;.</source>
          <target state="translated">客户端驱动程序尽可能使用运算符重载来支持诸如 &lt;code&gt;user['age'] &amp;gt; 30&lt;/code&gt; 表达式。</target>
        </trans-unit>
        <trans-unit id="d9a1774318fd30b2eb43097c891e57357be23711" translate="yes" xml:space="preserve">
          <source>Whenever possible, you should use native ReQL commands rather than &lt;code&gt;r.js&lt;/code&gt; for better performance.</source>
          <target state="translated">尽可能使用本地ReQL命令而不是 &lt;code&gt;r.js&lt;/code&gt; 以获得更好的性能。</target>
        </trans-unit>
        <trans-unit id="d1a090ba50026546708baf541642a566aa524853" translate="yes" xml:space="preserve">
          <source>Where &amp;ldquo;newpass&amp;rdquo; is the new password you want to use.</source>
          <target state="translated">其中&amp;ldquo; newpass&amp;rdquo;是您要使用的新密码。</target>
        </trans-unit>
        <trans-unit id="ecf978f6caa66726e06b1ef68ccd9f19f9ba5466" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;eq_join&lt;/code&gt; produces a table-like result (the rough equivalent of SQL&amp;rsquo;s &lt;code&gt;SELECT * FROM companies, employees WHERE companies.id = employees.company_id&lt;/code&gt;), using a subquery produces a nested document, where the employee objects are returned in a list in the &lt;code&gt;employees&lt;/code&gt; field.</source>
          <target state="translated">凡 &lt;code&gt;eq_join&lt;/code&gt; 产生的表样的结果（SQL年代大致相当于 &lt;code&gt;SELECT * FROM companies, employees WHERE companies.id = employees.company_id&lt;/code&gt; ），使用子查询生成一个嵌套的文档，其中雇员对象在返回列表中的 &lt;code&gt;employees&lt;/code&gt; 领域。</target>
        </trans-unit>
        <trans-unit id="963cb49ae920f88d504d16b3b7083da4270506f8" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;t:1&lt;/code&gt; means that the response is a value, and &lt;code&gt;r: [&quot;foo&quot;]&lt;/code&gt; the string &lt;code&gt;&quot;foo&quot;&lt;/code&gt;.</source>
          <target state="translated">其中 &lt;code&gt;t:1&lt;/code&gt; 表示响应是一个值， &lt;code&gt;r: [&quot;foo&quot;]&lt;/code&gt; 字符串 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffd6f0444e5d149aef2022bdf6d34990e15630b1" translate="yes" xml:space="preserve">
          <source>Where&amp;rsquo;s &lt;code&gt;r.binary&lt;/code&gt;? You don&amp;rsquo;t need it in this case, because &lt;code&gt;r.http&lt;/code&gt; will return a binary object with the &lt;code&gt;{resultFormat:'binary'}&lt;/code&gt; option. (If the MIME type on the sending server is set correctly, you can even leave that off, and &lt;code&gt;r.http&lt;/code&gt; will figure out the correct type.)</source>
          <target state="translated">&lt;code&gt;r.binary&lt;/code&gt; 在哪里？在这种情况下，您不需要它，因为 &lt;code&gt;r.http&lt;/code&gt; 将返回带有 &lt;code&gt;{resultFormat:'binary'}&lt;/code&gt; 选项的二进制对象。（如果发送服务器上的MIME类型设置正确，您甚至可以将其保留，然后 &lt;code&gt;r.http&lt;/code&gt; 将找出正确的类型。）</target>
        </trans-unit>
        <trans-unit id="85ff01499d11ce21062a9b96027ab58ee226aad3" translate="yes" xml:space="preserve">
          <source>Where,</source>
          <target state="translated">Where,</target>
        </trans-unit>
        <trans-unit id="74ef3c384631337c470ed9830ea2e775e4e4fa26" translate="yes" xml:space="preserve">
          <source>Whereas &lt;code&gt;concatMap&lt;/code&gt; with the same mapping function would merge those sequences into one:</source>
          <target state="translated">而具有相同映射功能的 &lt;code&gt;concatMap&lt;/code&gt; 会将这些序列合并为一个：</target>
        </trans-unit>
        <trans-unit id="7c3802c9a75c102c56d33838d3085aeced2d4be5" translate="yes" xml:space="preserve">
          <source>Which file systems are supported?</source>
          <target state="translated">支持哪些文件系统?</target>
        </trans-unit>
        <trans-unit id="c2d903bd400a10130121c28b48937e8649984629" translate="yes" xml:space="preserve">
          <source>Which versions of Node.js are supported?</source>
          <target state="translated">支持哪些版本的Node.js?</target>
        </trans-unit>
        <trans-unit id="75c7b24c0d75f53a78e5d965405062d03b3aa767" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;distinct&lt;/code&gt; can be called on a table without an index, the only effect will be to convert the table into a stream; the content of the stream will not be affected.</source>
          <target state="translated">尽管可以在没有索引的表上调用 &lt;code&gt;distinct&lt;/code&gt; ，但唯一的效果就是将表转换为流。流的内容不会受到影响。</target>
        </trans-unit>
        <trans-unit id="eda1f1902e0534da8b4f0914078aa6c1b6b382f8" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;import&lt;/code&gt; has the ability to import a directory full of files, those files are expected to be in the format and directory structure created by the &lt;code&gt;export&lt;/code&gt; command.</source>
          <target state="translated">虽然 &lt;code&gt;import&lt;/code&gt; 可以导入充满文件的目录，但是这些文件应采用 &lt;code&gt;export&lt;/code&gt; 命令创建的格式和目录结构。</target>
        </trans-unit>
        <trans-unit id="e15bffa8e190edcd775e600e8f345fc990c8b319" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;outdated&lt;/code&gt; reads are faster, they are the least consistent. For more information on this option, read &amp;ldquo;Balancing safety and performance&amp;rdquo; in the &lt;a href=&quot;../consistency/index#balancing-safety-and-performance&quot;&gt;Consistency guarantees&lt;/a&gt; documentation.</source>
          <target state="translated">虽然 &lt;code&gt;outdated&lt;/code&gt; 读取速度更快，但它们的一致性最低。有关此选项的更多信息，请阅读&lt;a href=&quot;../consistency/index#balancing-safety-and-performance&quot;&gt;一致性保证&lt;/a&gt;文档中的&amp;ldquo;平衡安全性和性能&amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="cbe5b9c83c28270a91a6119308ebb3167601ae92" translate="yes" xml:space="preserve">
          <source>While RethinkDB doesn&amp;rsquo;t currently have a fully-featured query optimizer, ReQL is designed with one in mind. For example, the server has enough information to reorder the chain for efficiency, or to use alternative implementation plans to improve performance. This feature will be introduced into future versions of RethinkDB.</source>
          <target state="translated">尽管RethinkDB当前没有全功能的查询优化器，但ReQL在设计时就考虑了这一点。例如，服务器具有足够的信息来对链进行重新排序以提高效率，或使用替代实施计划来提高性能。此功能将在以后的RethinkDB版本中引入。</target>
        </trans-unit>
        <trans-unit id="e87f1d7f7e013b05d15b906401df3c72981e5795" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s not strictly necessary to back up your data before upgrading, it&amp;rsquo;s always a good idea. You should make a backup by using the &lt;code&gt;dump&lt;/code&gt; command &lt;em&gt;before&lt;/em&gt; updating RethinkDB to its new version! Databases that have been automatically upgraded are not backward-compatible (that is, a database from version 1.14 cannot be used with version 1.13).</source>
          <target state="translated">尽管不一定要在升级之前备份数据，但这始终是个好主意。&lt;em&gt;在&lt;/em&gt;将RethinkDB更新到新版本&lt;em&gt;之前，&lt;/em&gt;您应该使用 &lt;code&gt;dump&lt;/code&gt; 命令进行备份！自动升级的数据库不向后兼容（即，版本1.14的数据库不能与版本1.13一起使用）。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c508518c472ea549e545c7cc3c1828474cbd1b66" translate="yes" xml:space="preserve">
          <source>While queries are built up on the client, they&amp;rsquo;re only sent to the server once you call the &lt;code&gt;run&lt;/code&gt; command. All processing happens on the server&amp;mdash;the queries don&amp;rsquo;t run on the client, and don&amp;rsquo;t require intermediary network round trips between the client and the server. For example, you can store queries in variables, and send them to the server later:</source>
          <target state="translated">虽然查询是在客户端上建立的，但是只有在您调用 &lt;code&gt;run&lt;/code&gt; 命令后，查询才会发送到服务器。所有处理都在服务器上进行-查询不在客户端上运行，并且不需要客户端和服务器之间的中间网络往返。例如，您可以将查询存储在变量中，然后将其发送到服务器：</target>
        </trans-unit>
        <trans-unit id="0c5b09514d00b6ab4c988fd2046f1b881599653b" translate="yes" xml:space="preserve">
          <source>While running, a server&amp;rsquo;s configuration can be changed by writing to the &lt;code&gt;rethinkdb.server_config&lt;/code&gt;&lt;a href=&quot;../system-tables/index&quot;&gt;system table&lt;/a&gt;.</source>
          <target state="translated">在运行时，可以通过写入 &lt;code&gt;rethinkdb.server_config&lt;/code&gt; &lt;a href=&quot;../system-tables/index&quot;&gt;系统表&lt;/a&gt;来更改服务器的配置。</target>
        </trans-unit>
        <trans-unit id="196bc69045bb039c922d7d34e6348aba06827f91" translate="yes" xml:space="preserve">
          <source>While system tables support changefeeds, they do not support all of the chaining that real tables do. For instance, aggregation (&lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt;) and &lt;code&gt;limit&lt;/code&gt; commands will not work with system tables.</source>
          <target state="translated">尽管系统表支持变更提要，但它们并不支持真实表所支持的所有链接。例如，聚合（ &lt;code&gt;max&lt;/code&gt; 和 &lt;code&gt;min&lt;/code&gt; ）和 &lt;code&gt;limit&lt;/code&gt; 命令不适用于系统表。</target>
        </trans-unit>
        <trans-unit id="5e1db1780061897d624e2492fa72c8d8a9c49dd8" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;{field:value}&lt;/code&gt; style of predicate is useful for exact matches, a more general way to write a predicate is to use the &lt;a href=&quot;../row/index&quot;&gt;row&lt;/a&gt; command with a comparison operator such as &lt;a href=&quot;../eq/index&quot;&gt;eq&lt;/a&gt; or &lt;a href=&quot;../gt/index&quot;&gt;gt&lt;/a&gt;, or to use an anonymous function that returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">虽然谓词的 &lt;code&gt;{field:value}&lt;/code&gt; 样式对于完全匹配很有用，但是写谓词的更通用的方法是将&lt;a href=&quot;../row/index&quot;&gt;row&lt;/a&gt;命令与比较运算符（例如&lt;a href=&quot;../eq/index&quot;&gt;eq&lt;/a&gt;或&lt;a href=&quot;../gt/index&quot;&gt;gt&lt;/a&gt;）一起使用，或者使用返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb232e8e16f07d7f64a5545b6cc6855a0b706386" translate="yes" xml:space="preserve">
          <source>While there &lt;em&gt;is&lt;/em&gt; a [circle] command, it approximates a circle by defining either a line or a polygon. There is no true circular data type.</source>
          <target state="translated">虽然&lt;em&gt;是&lt;/em&gt;一个[圆圈]命令时，它近似于通过定义或者是线或多边形的圆。没有真正的循环数据类型。</target>
        </trans-unit>
        <trans-unit id="8880d3ba6f9209b576363cabe9ca016a317fd7a2" translate="yes" xml:space="preserve">
          <source>While we strive to give you perfect uptime, like other complex applications RethinkDB is not immune to crashing. Here are some tips on how to recover from a crash, how to submit a bug report, and how to maximize availability.</source>
          <target state="translated">虽然我们努力为您提供完美的正常运行时间,但像其他复杂的应用程序一样,RethinkDB也不能避免崩溃。这里有一些关于如何从崩溃中恢复的提示,如何提交错误报告,以及如何最大化可用性。</target>
        </trans-unit>
        <trans-unit id="a9c9f8d79908203bf616bc5ec24c72cd56e7ec7f" translate="yes" xml:space="preserve">
          <source>While you may be able to leave many options at their defaults, you&amp;rsquo;ll definitely need to change the &lt;code&gt;directory=&lt;/code&gt; line in the configuration file to point to your RethinkDB data directory.</source>
          <target state="translated">虽然您可以将许多选项保留为默认值，但绝对需要更改配置文件中的 &lt;code&gt;directory=&lt;/code&gt; 行，以指向您的RethinkDB数据目录。</target>
        </trans-unit>
        <trans-unit id="d70b857aa26bf55f4755a8a354b5a0cf782812e2" translate="yes" xml:space="preserve">
          <source>Whitespace-separated JSON rows.</source>
          <target state="translated">以空格分隔的JSON行。</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="d110c7983aa12b9b68c9e762bd72396013153dbb" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;one&lt;/strong&gt; argument &lt;em&gt;x,&lt;/em&gt; the result will be in the range &lt;code&gt;[0,x)&lt;/code&gt;, and will be integer unless &lt;code&gt;{float:true}&lt;/code&gt; is given as an option. Specifying a floating point number without the &lt;code&gt;float&lt;/code&gt; option will raise an error.</source>
          <target state="translated">使用&lt;strong&gt;一个&lt;/strong&gt;参数&lt;em&gt;x时，&lt;/em&gt;结果将在 &lt;code&gt;[0,x)&lt;/code&gt; 范围内，并且将是整数，除非提供 &lt;code&gt;{float:true}&lt;/code&gt; 作为选项。指定不带 &lt;code&gt;float&lt;/code&gt; 选项的浮点数将引发错误。</target>
        </trans-unit>
        <trans-unit id="b7043f8490538934638889f8014fabd627f4ae9b" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;two&lt;/strong&gt; arguments &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y,&lt;/em&gt; the result will be in the range &lt;code&gt;[x,y)&lt;/code&gt;, and will be integer unless &lt;code&gt;{float:true}&lt;/code&gt; is given as an option. If &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; are equal an error will occur, unless the floating-point option has been specified, in which case &lt;em&gt;x&lt;/em&gt; will be returned. Specifying a floating point number without the &lt;code&gt;float&lt;/code&gt; option will raise an error.</source>
          <target state="translated">有&lt;strong&gt;两个&lt;/strong&gt;参数&lt;em&gt;x&lt;/em&gt;和&lt;em&gt;y，&lt;/em&gt;结果将在 &lt;code&gt;[x,y)&lt;/code&gt; 范围内，并且将是整数，除非提供 &lt;code&gt;{float:true}&lt;/code&gt; 作为选项。如果&lt;em&gt;x&lt;/em&gt;和&lt;em&gt;y&lt;/em&gt;相等，除非指定了浮点选项，否则将发生错误，在这种情况下将返回&lt;em&gt;x&lt;/em&gt;。指定不带 &lt;code&gt;float&lt;/code&gt; 选项的浮点数将引发错误。</target>
        </trans-unit>
        <trans-unit id="ed3cfa588bab7867e4924f429e5db144b0535192" translate="yes" xml:space="preserve">
          <source>With &lt;strong&gt;zero&lt;/strong&gt; arguments, the result will be a floating-point number in the range &lt;code&gt;[0,1)&lt;/code&gt; (from 0 up to but not including 1).</source>
          <target state="translated">如果参数&lt;strong&gt;为零&lt;/strong&gt;，则结果将是 &lt;code&gt;[0,1)&lt;/code&gt; （从0到但不包括1）范围内的浮点数。</target>
        </trans-unit>
        <trans-unit id="3e699cf78c6c70afc59571e065ee6662df7ae4ed" translate="yes" xml:space="preserve">
          <source>With a single server, our query takes 59 seconds to complete. The automatic query parallelization in RethinkDB results in practically linear scalability, as the same query is executed in just above 4 seconds on 16 servers. The graph, shown in the results overview section, demonstrates the inverse execution time (queries per second) of the query.</source>
          <target state="translated">在一台服务器上,我们的查询需要59秒才能完成。RethinkDB中的自动查询并行化导致了实际上的线性可扩展性,因为同样的查询在16台服务器上的执行时间仅在4秒以上。结果概述部分所示的图表展示了查询的逆向执行时间(每秒查询次数)。</target>
        </trans-unit>
        <trans-unit id="d8a5b7f3faeb9e33f62bb627c2b2a563e64920b5" translate="yes" xml:space="preserve">
          <source>With a string, &lt;code&gt;slice&lt;/code&gt; behaves similarly, with the indexes referring to Unicode codepoints. String indexes start at &lt;code&gt;0&lt;/code&gt;. (Note that &lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;combining codepoints&lt;/a&gt; are counted separately.)</source>
          <target state="translated">对于字符串， &lt;code&gt;slice&lt;/code&gt; 的行为类似，而索引引用的是Unicode代码点。字符串索引从 &lt;code&gt;0&lt;/code&gt; 开始。（请注意，&lt;a href=&quot;https://en.wikipedia.org/wiki/Combining_character&quot;&gt;组合代码点&lt;/a&gt;是单独计算的。）</target>
        </trans-unit>
        <trans-unit id="f4fd536709cd6838a47751145de8bc8d075d4ebd" translate="yes" xml:space="preserve">
          <source>With most commands that take a field name string or the &lt;code&gt;() &lt;/code&gt; syntax above, you can also use a JSON-style nested syntax:</source>
          <target state="translated">对于大多数采用字段名称字符串或上述 &lt;code&gt;() &lt;/code&gt; 语法的命令，您还可以使用JSON样式的嵌套语法：</target>
        </trans-unit>
        <trans-unit id="f765a154bf9b7d7db33d2b68b71884f46493323f" translate="yes" xml:space="preserve">
          <source>With no arguments, &lt;code&gt;range&lt;/code&gt; returns an &amp;ldquo;infinite&amp;rdquo; stream from 0 up to and including the maximum integer value;</source>
          <target state="translated">不带参数的 &lt;code&gt;range&lt;/code&gt; 返回从0到最大整数值的&amp;ldquo;无限&amp;rdquo;流；</target>
        </trans-unit>
        <trans-unit id="1be6d08d4038949893064ebde481b01100a94fa1" translate="yes" xml:space="preserve">
          <source>With one argument, &lt;code&gt;range&lt;/code&gt; returns a stream from 0 up to but not including the end value;</source>
          <target state="translated">使用一个参数， &lt;code&gt;range&lt;/code&gt; 返回从0到但不包括最终值的流；否则，返回0。</target>
        </trans-unit>
        <trans-unit id="e28fd958eebbcb33351a1302bb1eea36388fb720" translate="yes" xml:space="preserve">
          <source>With simple and compound indexes, a document will be indexed using at most one index key: a single value for a simple index and a set of values for a compound index. Multiple documents may have the same index key. With a &lt;em&gt;multi index&lt;/em&gt;, a document can be indexed using more than one key in the same index. For instance, a blog post might have multiple tags, and each tag might refer to multiple blog posts.</source>
          <target state="translated">对于简单索引和复合索引，将使用最多一个索引键来为文档建立索引：简单索引的单个值和复合索引的一组值。多个文档可能具有相同的索引键。使用&lt;em&gt;多重索引&lt;/em&gt;，可以使用同一索引中的多个键来为文档建立索引。例如，一个博客文章可能具有多个标签，并且每个标签可能引用多个博客文章。</target>
        </trans-unit>
        <trans-unit id="561955fb8ca5f5782474961bc600ce7a0b051525" translate="yes" xml:space="preserve">
          <source>With system tables only, the &lt;code&gt;table&lt;/code&gt; command takes a new argument, &lt;code&gt;identifier_format&lt;/code&gt;. Legal values are &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;uuid&lt;/code&gt;. When it&amp;rsquo;s set to &lt;code&gt;uuid&lt;/code&gt;, references in system tables to databases or other tables will be UUIDs rather than database/table names. This is useful for writing scripts and administration tasks, as UUIDs remain consistent even if object names change. The default is &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">仅对于系统表， &lt;code&gt;table&lt;/code&gt; 命令采用新的参数 &lt;code&gt;identifier_format&lt;/code&gt; 。合法值是 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;uuid&lt;/code&gt; 。设置为 &lt;code&gt;uuid&lt;/code&gt; 时，系统表中对数据库或其他表的引用将是UUID，而不是数据库/表名。这对于编写脚本和管理任务很有用，因为即使对象名称更改，UUID也会保持一致。默认值为 &lt;code&gt;name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ecebde599b9bd6e7b61ea5841eb82f0b8ce413a" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;multi&lt;/code&gt; flag single documents can be assigned to multiple groups, similar to the behavior of &lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;multi-indexes&lt;/a&gt;. When &lt;code&gt;multi&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and the grouping value is an array, documents will be placed in each group that corresponds to the elements of the array. If the array is empty the row will be ignored.</source>
          <target state="translated">使用 &lt;code&gt;multi&lt;/code&gt; 标记，可以将单个文档分配给多个组，类似于&lt;a href=&quot;../../../docs/secondary-indexes/javascript/index&quot;&gt;多索引&lt;/a&gt;的行为。当 &lt;code&gt;multi&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 并且分组值为数组时，文档将放置在与数组元素相对应的每个组中。如果数组为空，则该行将被忽略。</target>
        </trans-unit>
        <trans-unit id="c1c2a4ec9b5fe6dd2c2a1f09763272a5046fc80b" translate="yes" xml:space="preserve">
          <source>With the appropriate &lt;a href=&quot;../install-drivers/index&quot;&gt;client driver&lt;/a&gt; installed you can use a supported language to perform all administration tasks, either from the language&amp;rsquo;s REPL or as a script. There are ReQL commands for &lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;configuring sharding and replication&lt;/a&gt;, &lt;a href=&quot;https://rethinkdb.com/api/python/rebalance&quot;&gt;rebalancing shards&lt;/a&gt; and more. In addition, you can query &lt;a href=&quot;../system-tables/index&quot;&gt;system tables&lt;/a&gt; to get information about your cluster and to change many of its operational characteristics.</source>
          <target state="translated">安装了适当的&lt;a href=&quot;../install-drivers/index&quot;&gt;客户端驱动&lt;/a&gt;程序后，您可以使用受支持的语言从语言的REPL或作为脚本来执行所有管理任务。有ReQL命令用于&lt;a href=&quot;https://rethinkdb.com/api/python/reconfigure&quot;&gt;配置分片和复制&lt;/a&gt;，&lt;a href=&quot;https://rethinkdb.com/api/python/rebalance&quot;&gt;重新平衡&lt;/a&gt;分片等。此外，您可以查询&lt;a href=&quot;../system-tables/index&quot;&gt;系统表&lt;/a&gt;以获取有关集群的信息并更改其许多运行特性。</target>
        </trans-unit>
        <trans-unit id="88ce626689bbb3d87a8121372f5b3f4b42db58eb" translate="yes" xml:space="preserve">
          <source>With the following settings, RethinkDB guarantees linearizability of individual atomic operations on individual documents:</source>
          <target state="translated">通过以下设置,RethinkDB可以保证对单个文档的单个原子操作的线性化。</target>
        </trans-unit>
        <trans-unit id="f2d4c9e7aabba038136ff518e49156fb80b1960b" translate="yes" xml:space="preserve">
          <source>With this approach you cannot atomically update both the author data and and the posts data.</source>
          <target state="translated">使用这种方法,你不能同时原子化地更新作者数据和和帖子数据。</target>
        </trans-unit>
        <trans-unit id="c9c5da5a74f1e53423101b6b6a642e055eee3483" translate="yes" xml:space="preserve">
          <source>With two arguments, &lt;code&gt;range&lt;/code&gt; returns a stream from the start value up to but not including the end value.</source>
          <target state="translated">使用两个参数， &lt;code&gt;range&lt;/code&gt; 返回从起始值到但不包括结束值的流。</target>
        </trans-unit>
        <trans-unit id="706a9fb9c60fd738be99224175848f1837d058a5" translate="yes" xml:space="preserve">
          <source>With version &lt;code&gt;V1_0&lt;/code&gt; of the protocol, the handshake protocol has changed from previous versions.</source>
          <target state="translated">对于协议的版本 &lt;code&gt;V1_0&lt;/code&gt; ，握手协议已从以前的版本中更改。</target>
        </trans-unit>
        <trans-unit id="03c726aadd8ac092e0447f9f7e0fbd7bbf6e227c" translate="yes" xml:space="preserve">
          <source>Working with streams</source>
          <target state="translated">与溪流一起工作</target>
        </trans-unit>
        <trans-unit id="c081f805ae12217f57b46b44e966da71b81ef959" translate="yes" xml:space="preserve">
          <source>Working with times</source>
          <target state="translated">与时俱进</target>
        </trans-unit>
        <trans-unit id="369a3cda46aff60d2423048907eef67959000caa" translate="yes" xml:space="preserve">
          <source>Workload A</source>
          <target state="translated">工作量A</target>
        </trans-unit>
        <trans-unit id="3ff249cc11740bb6ad8b6e01ed11cfa8c3c78f8f" translate="yes" xml:space="preserve">
          <source>Workload C</source>
          <target state="translated">工作量C</target>
        </trans-unit>
        <trans-unit id="f39dd82bdd5c2b2b0591a73c0a966f99123a4a07" translate="yes" xml:space="preserve">
          <source>Would be sent to the server as</source>
          <target state="translated">将被发送到服务器上,作为</target>
        </trans-unit>
        <trans-unit id="89dc61bcc6d6ce0ce9d24febb8af7ea389f5b539" translate="yes" xml:space="preserve">
          <source>Wrapping queries</source>
          <target state="translated">包裹查询</target>
        </trans-unit>
        <trans-unit id="659ca7d443e63ce2949dec486536ee88fa72c4d0" translate="yes" xml:space="preserve">
          <source>Wrapping the DB query option</source>
          <target state="translated">包裹DB查询选项</target>
        </trans-unit>
        <trans-unit id="dbedb4dc90f07d001648d9502697a610b881d451" translate="yes" xml:space="preserve">
          <source>Write acks and durability</source>
          <target state="translated">写上酸碱度和耐久性</target>
        </trans-unit>
        <trans-unit id="5e6eaa2c1185928e8b28fb617129c097ed9398c9" translate="yes" xml:space="preserve">
          <source>Write atomicity is supported on a per-document basis &amp;ndash; updates to a single JSON document are guaranteed to be atomic. RethinkDB is different from other NoSQL systems in that atomic document updates aren&amp;rsquo;t limited to a small subset of possible operations &amp;ndash; any combination of operations that can be performed on a single document is guaranteed to update the document atomically. For example, the user may wish to update the value of attribute A to a sum of the values of attributes B and C, increment the value of attribute D by a fixed number, and append an element to an array in attribute E. All of these operations can be applied to the document atomically in a single update operation.</source>
          <target state="translated">每个文档均支持写入原子性&amp;ndash;确保对单个JSON文档的更新是原子性的。RethinkDB与其他NoSQL系统的不同之处在于，原子文档更新不仅限于一小部分可能的操作-可以对单个文档执行的任何操作组合都可以保证原子更新文档。例如，用户可能希望将属性A的值更新为属性B和C的值之和，将属性D的值增加一个固定的数字，并将元素添加到属性E中的数组。这些操作可以在单个更新操作中原子地应用于文档。</target>
        </trans-unit>
        <trans-unit id="f62115f9f3535c8b07d79df0f9f18ccafd554421" translate="yes" xml:space="preserve">
          <source>Write operations on system tables are non-atomic. Avoid writing to the same system table row from more than one client at the same time.</source>
          <target state="translated">对系统表的写操作是非原子性的。避免同时从多个客户端对同一系统表行进行写入操作。</target>
        </trans-unit>
        <trans-unit id="778b0b2b0319607e4822502fbb728b660dd8744d" translate="yes" xml:space="preserve">
          <source>Writes are performed with &amp;ldquo;hard&amp;rdquo; durability (wait for data to be on disk on both replicas)</source>
          <target state="translated">以&amp;ldquo;硬&amp;rdquo;持久性执行写入（等待两个副本上的数据都在磁盘上）</target>
        </trans-unit>
        <trans-unit id="9e632869f49afb8aba3986c578bc41023c0edd69" translate="yes" xml:space="preserve">
          <source>Writing Data</source>
          <target state="translated">编写数据</target>
        </trans-unit>
        <trans-unit id="8a414f19d977be639835849a95f5232ef94bac3b" translate="yes" xml:space="preserve">
          <source>Writing RethinkDB drivers</source>
          <target state="translated">编写RethinkDB驱动程序</target>
        </trans-unit>
        <trans-unit id="3f85d90f8a8e1dd726894cac4b4961c2ef2bc396" translate="yes" xml:space="preserve">
          <source>Writing data</source>
          <target state="translated">写数据</target>
        </trans-unit>
        <trans-unit id="0592df9e765a33e009a61a0f043994284838f69d" translate="yes" xml:space="preserve">
          <source>Writing drivers</source>
          <target state="translated">编写驱动程序</target>
        </trans-unit>
        <trans-unit id="c61bb79a2505d2a4aa2a95f6ce80e265d54461a3" translate="yes" xml:space="preserve">
          <source>YCSB comes with a variety of default workloads, but for the purposes of our testing we chose two of them to run against RethinkDB. Out of the YCSB workload options, we chose to run workload A which comprises 50% reads and 50% update operations, and workload C which performs strictly read operations. All documents stored by the YCSB tests contain 10 fields with randomized 100 byte strings as values, with each document totaling about 1 KB in size.</source>
          <target state="translated">YCSB有很多默认的工作负载,但是为了我们的测试目的,我们选择了其中的两个工作负载来运行RethinkDB。在YCSB的工作负载选项中,我们选择运行工作负载A,它包括50%的读取和50%的更新操作,以及工作负载C,它严格执行读取操作。YCSB测试存储的所有文档都包含10个字段,以随机的100字节字符串作为值,每个文档总大小约为1KB。</target>
        </trans-unit>
        <trans-unit id="3eb210c778a79793e9d78d22c3f1ede24830d9f8" translate="yes" xml:space="preserve">
          <source>Yes. Distance calculations are done on a geodesic (either WGS84&amp;rsquo;s reference ellipsoid or a unit sphere).</source>
          <target state="translated">是。距离计算是通过测地线（WGS84的参考椭球或单位球体）完成的。</target>
        </trans-unit>
        <trans-unit id="7c3e24fef8be8e5708c75420ec10f7858a6a4a38" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;../../api/javascript/update/index&quot;&gt;update&lt;/a&gt; the password to a new value, or remove it by setting it to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">您可以将密码&lt;a href=&quot;../../api/javascript/update/index&quot;&gt;更新&lt;/a&gt;为新值，也可以将其设置为 &lt;code&gt;false&lt;/code&gt; 来将其删除。</target>
        </trans-unit>
        <trans-unit id="948b7ad33f6106e0c518960b93f129c834918f85" translate="yes" xml:space="preserve">
          <source>You can accomplish this with &lt;code&gt;object&lt;/code&gt; and a pivot.</source>
          <target state="translated">您可以使用 &lt;code&gt;object&lt;/code&gt; 和轴来完成此操作。</target>
        </trans-unit>
        <trans-unit id="925356081da49bb85c51c3cfc060b861749e8f91" translate="yes" xml:space="preserve">
          <source>You can add or subtract a duration (in seconds):</source>
          <target state="translated">您可以增加或减少一个持续时间(以秒为单位)。</target>
        </trans-unit>
        <trans-unit id="4533fcb6c96cfc2d8d905dbd40d93091a926daf0" translate="yes" xml:space="preserve">
          <source>You can also chain &lt;code&gt;changes&lt;/code&gt; before any command that operates on a sequence of documents, as long as that command doesn&amp;rsquo;t consume the entire sequence. (For instance, &lt;code&gt;count&lt;/code&gt; and &lt;code&gt;orderBy&lt;/code&gt; cannot come after the &lt;code&gt;changes&lt;/code&gt; command.)</source>
          <target state="translated">您也可以在对序列文档进行操作的任何命令之前链接 &lt;code&gt;changes&lt;/code&gt; ，只要该命令不占用整个序列。（例如， &lt;code&gt;count&lt;/code&gt; 和 &lt;code&gt;orderBy&lt;/code&gt; 不能在 &lt;code&gt;changes&lt;/code&gt; 命令之后。）</target>
        </trans-unit>
        <trans-unit id="aa193e7db24ef17527767c2a2fb1bc7e212cf120" translate="yes" xml:space="preserve">
          <source>You can also choose to receive errors in the block by accepting two arguments.</source>
          <target state="translated">你也可以通过接受两个参数来选择在块中接收错误。</target>
        </trans-unit>
        <trans-unit id="7521a0e1d0a48d0648af79a67343e53203f19dc3" translate="yes" xml:space="preserve">
          <source>You can also combine soft durability and &lt;code&gt;noreply&lt;/code&gt; for the highest performance:</source>
          <target state="translated">您还可以将柔软的耐用性与 &lt;code&gt;noreply&lt;/code&gt; 相结合，以实现最高的性能：</target>
        </trans-unit>
        <trans-unit id="f7bee9dd40ed9b84d531cd93a05bc744d1be6b9b" translate="yes" xml:space="preserve">
          <source>You can also filter messages by tags. We could put the tags into a string and build a regex to match messages with the tags we want, but luckily we have the full power of ReQL at our disposal. Instead, we can make the topic an actual JSON array, and use ReQL&amp;rsquo;s &lt;a href=&quot;../../../api/javascript/contains/index&quot;&gt;contains&lt;/a&gt; method to do the filtering.</source>
          <target state="translated">您还可以按标签过滤邮件。我们可以将标签放入字符串中并构建一个正则表达式，以使消息与所需标签匹配，但是幸运的是，我们拥有ReQL的全部功能。相反，我们可以使该主题成为实际的JSON数组，并使用ReQL的&lt;a href=&quot;../../../api/javascript/contains/index&quot;&gt;contains&lt;/a&gt;方法进行过滤。</target>
        </trans-unit>
        <trans-unit id="55f7bbe803221ed2cce75841fcc9fc9bd55f8f78" translate="yes" xml:space="preserve">
          <source>You can also group by a function.</source>
          <target state="translated">你也可以按功能分组。</target>
        </trans-unit>
        <trans-unit id="8f7329e3cb33fdb6c2fd3c98bf353c3c9bcd0191" translate="yes" xml:space="preserve">
          <source>You can also group by more than one field.</source>
          <target state="translated">您也可以按多个字段进行分组。</target>
        </trans-unit>
        <trans-unit id="a60b122be5d58582613cfb6b6776eff696b1b764" translate="yes" xml:space="preserve">
          <source>You can also group on an index (primary key or secondary).</source>
          <target state="translated">您也可以在索引上进行分组(主键或次键)。</target>
        </trans-unit>
        <trans-unit id="6654958bc49bc05258fa3acec5130cab590a8a51" translate="yes" xml:space="preserve">
          <source>You can also manually compare dates:</source>
          <target state="translated">你也可以手动比较日期。</target>
        </trans-unit>
        <trans-unit id="0ec8c02dd35711b36397abb1da1ac1fa12d559ed" translate="yes" xml:space="preserve">
          <source>You can also perform this query using the &lt;a href=&quot;https://rethinkdb.com/api/python/inner_join/&quot;&gt;inner_join&lt;/a&gt; command.</source>
          <target state="translated">您也可以使用&lt;a href=&quot;https://rethinkdb.com/api/python/inner_join/&quot;&gt;inner_join&lt;/a&gt;命令执行此查询。</target>
        </trans-unit>
        <trans-unit id="a74279a58953a26e9ef411c14ba12ac3c17b2d47" translate="yes" xml:space="preserve">
          <source>You can also point the client drivers to &lt;code&gt;localhost:28015&lt;/code&gt; or &lt;code&gt;localhost:28016&lt;/code&gt; to start running queries (it doesn&amp;rsquo;t matter which node you use&amp;mdash;the cluster will automatically route all commands to appropriate nodes).</source>
          <target state="translated">您也可以将客户端驱动程序指向 &lt;code&gt;localhost:28015&lt;/code&gt; 或 &lt;code&gt;localhost:28016&lt;/code&gt; 以开始运行查询（使用哪个节点都无所谓，集群将自动将所有命令路由到适当的节点）。</target>
        </trans-unit>
        <trans-unit id="e44ac32db1d54d18e34eb6ab558c9e482d15daa2" translate="yes" xml:space="preserve">
          <source>You can also select a descending ordering:</source>
          <target state="translated">您也可以选择降序。</target>
        </trans-unit>
        <trans-unit id="b8fc5957165ff64f88a05853da874a06bd5d3701" translate="yes" xml:space="preserve">
          <source>You can also specify explicitly which index and type you want synced documents to go to:</source>
          <target state="translated">您还可以明确指定您希望同步的文档进入哪个索引和类型。</target>
        </trans-unit>
        <trans-unit id="80eac1c2d72fc26d947819c83575a858603c9378" translate="yes" xml:space="preserve">
          <source>You can also transform a time object on the server using either &lt;code&gt;toEpochTime&lt;/code&gt; or &lt;code&gt;toISO8601&lt;/code&gt;.</source>
          <target state="translated">您还可以使用 &lt;code&gt;toEpochTime&lt;/code&gt; 或 &lt;code&gt;toISO8601&lt;/code&gt; 在服务器上转换时间对象。</target>
        </trans-unit>
        <trans-unit id="cac8d8320c3579227fb8c5d1475782eef117e2c2" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;r.now&lt;/code&gt; (which the server interprets as the time the query was received in UTC), or construct a time using &lt;code&gt;r.time&lt;/code&gt;, &lt;code&gt;r.epochTime&lt;/code&gt;, or &lt;code&gt;r.ISO8601&lt;/code&gt;.</source>
          <target state="translated">您也可以使用 &lt;code&gt;r.now&lt;/code&gt; （服务器将其解释为在UTC中收到查询的时间），或使用 &lt;code&gt;r.time&lt;/code&gt; ， &lt;code&gt;r.epochTime&lt;/code&gt; 或 &lt;code&gt;r.ISO8601&lt;/code&gt; 构造时间。</target>
        </trans-unit>
        <trans-unit id="cb2bd319a45cdc6fba892eaab1939a5068f518fa" translate="yes" xml:space="preserve">
          <source>You can also use RethinkDB to query many to many relations. Let&amp;rsquo;s suppose we have a collaborative blogging platform where authors collaborate to create posts (multiple authors can work on any given post, and publish multiple posts).</source>
          <target state="translated">您还可以使用RethinkDB查询多对多关系。假设我们有一个协作博客平台，作者可以在其中协作创建帖子（多个作者可以处理任何给定帖子，并发布多个帖子）。</target>
        </trans-unit>
        <trans-unit id="260bde3e879639056344b2578c9acb496c3e9dfd" translate="yes" xml:space="preserve">
          <source>You can also use more complicated expressions. Let&amp;rsquo;s say you have a table &lt;code&gt;scores&lt;/code&gt; that contains the latest game score for every user of your game. You can create a feed of all games where a user beats their previous score, and get only the new value:</source>
          <target state="translated">您还可以使用更复杂的表达式。假设您有一个表 &lt;code&gt;scores&lt;/code&gt; ，其中包含游戏中每个用户的最新游戏分数。您可以创建用户超过其先前得分的所有游戏的供稿，并仅获取新值：</target>
        </trans-unit>
        <trans-unit id="3d752132db71ae1e37214a4686c56d81c5eaeefd" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;../limit/index&quot;&gt;limit&lt;/a&gt; command with the no-argument variant to achieve the same result in this case:</source>
          <target state="translated">在这种情况下，还可以将&lt;a href=&quot;../limit/index&quot;&gt;limit&lt;/a&gt;命令与no-argument变量一起使用以实现相同的结果：</target>
        </trans-unit>
        <trans-unit id="68b26d9038bb64d58ff064aaaf43b40e2b7dd37d" translate="yes" xml:space="preserve">
          <source>You can also use the prefix notation (passing all arguments to &lt;code&gt;r.and&lt;/code&gt;), if that&amp;rsquo;s what you prefer:</source>
          <target state="translated">如果您愿意，还可以使用前缀表示法（将所有参数传递给 &lt;code&gt;r.and&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="98524810990f6ce3791d22ab50b4d44cc51b4729" translate="yes" xml:space="preserve">
          <source>You can also use this approach with a &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;compound index&lt;/a&gt; on the intervals you want to group:</source>
          <target state="translated">您还可以对要分组的时间间隔使用此方法以及&lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;复合索引&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="2e210d90ddec99211d2b1d62f90c31cc57cbc7fa" translate="yes" xml:space="preserve">
          <source>You can ask questions and get notes on changes introduced in new versions of RethinkDB on the &lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/rethinkdb-dev&quot;&gt;RethinkDB-Dev Google Group&lt;/a&gt;. You can also visit the &lt;a href=&quot;irc://irc.freenode.org/rethinkdb&quot;&gt;RethinkDB IRC Channel&lt;/a&gt;, where core developers and other driver developers frequently hang out. Also, you can ask questions on &lt;a href=&quot;http://stackoverflow.com/&quot;&gt;Stack Overflow&lt;/a&gt; using the tag &amp;ldquo;&lt;a href=&quot;http://stackoverflow.com/questions/tagged/rethinkdb&quot;&gt;rethinkdb&lt;/a&gt;.&amp;rdquo;</source>
          <target state="translated">您可以在&lt;a href=&quot;https://groups.google.com/forum/?fromgroups#!forum/rethinkdb-dev&quot;&gt;RethinkDB-Dev Google网上论坛中&lt;/a&gt;提问并获得有关RethinkDB新版本中引入的更改的注释。您还可以访问&lt;a href=&quot;irc://irc.freenode.org/rethinkdb&quot;&gt;RethinkDB IRC频道&lt;/a&gt;，核心开发人员和其他驱动程序开发人员经常在这里闲逛。另外，您可以使用标签&amp;ldquo; &lt;a href=&quot;http://stackoverflow.com/questions/tagged/rethinkdb&quot;&gt;rethinkdb&lt;/a&gt; &amp;rdquo; 在&lt;a href=&quot;http://stackoverflow.com/&quot;&gt;堆栈溢出&lt;/a&gt;问题上提问。</target>
        </trans-unit>
        <trans-unit id="ab33dc48c02612349a04e9a9040eefd1db934e27" translate="yes" xml:space="preserve">
          <source>You can chain as many ReQL commands as necessary to perform data manipulation tasks. Since ReQL is explicitly designed for JSON querying and modification, it&amp;rsquo;s also an excellent language for operating on web services!</source>
          <target state="translated">您可以根据需要链接任意多个ReQL命令以执行数据操作任务。由于ReQL是专门为JSON查询和修改而设计的，因此它也是在Web服务上运行的极好的语言！</target>
        </trans-unit>
        <trans-unit id="1d30f31519b2594ea55d30183732bc6402bd588e" translate="yes" xml:space="preserve">
          <source>You can combine multiple ReQL queries to build more complex ones.</source>
          <target state="translated">你可以将多个ReQL查询组合起来,建立更复杂的查询。</target>
        </trans-unit>
        <trans-unit id="6cec52bedaeaa6b1b669dabc56c482be17d6581c" translate="yes" xml:space="preserve">
          <source>You can compute the average value of a field with the &lt;code&gt;avg&lt;/code&gt; command.</source>
          <target state="translated">您可以使用 &lt;code&gt;avg&lt;/code&gt; 命令计算字段的平均值。</target>
        </trans-unit>
        <trans-unit id="70626bab7a8c982a8c2b47eb0111e64d0d9ee6a0" translate="yes" xml:space="preserve">
          <source>You can connect to your hosted cluster on Compose in one of two ways: via SSL or via SSH tunneling. With SSL, you can get a direct Admin URL and driver connection URL to your RethinkDB instance. SSL driver connections are only supported with the official RethinkDB drivers and the community-supported Go driver. For more details, read Compose&amp;rsquo;s &lt;a href=&quot;https://www.compose.io/articles/rethinkdb-and-ssl-think-secure/&quot;&gt;RethinkDB and SSL&lt;/a&gt; blog post.</source>
          <target state="translated">您可以通过以下两种方式之一连接到Compose上的托管群集：通过SSL或SSH隧道。使用SSL，您可以直接获得RethinkDB实例的管理URL和驱动程序连接URL。只有正式的RethinkDB驱动程序和社区支持的Go驱动程序才支持SSL驱动程序连接。有关更多详细信息，请阅读Compose的&lt;a href=&quot;https://www.compose.io/articles/rethinkdb-and-ssl-think-secure/&quot;&gt;RethinkDB和SSL&lt;/a&gt;博客文章。</target>
        </trans-unit>
        <trans-unit id="07b08edef601b139269d80f58b49bf6d38d77cbe" translate="yes" xml:space="preserve">
          <source>You can construct queries incrementally by chaining transformations and examining intermediary results.</source>
          <target state="translated">您可以通过链式转换和检查中间结果来构建增量查询。</target>
        </trans-unit>
        <trans-unit id="e0d2d2ae12e1b289f792fb7810556ffc10df36f3" translate="yes" xml:space="preserve">
          <source>You can count the number of documents with a &lt;code&gt;count&lt;/code&gt; command:</source>
          <target state="translated">您可以使用 &lt;code&gt;count&lt;/code&gt; 命令来计算文档数：</target>
        </trans-unit>
        <trans-unit id="6c82b7f4625b4de3a4454fdede8889e7985323d5" translate="yes" xml:space="preserve">
          <source>You can create a multi index on an arbitrary expression in similar fashion, by passing the multi option as the last parameter to &lt;code&gt;indexCreate&lt;/code&gt;.</source>
          <target state="translated">您可以通过将multi选项作为最后一个参数传递给 &lt;code&gt;indexCreate&lt;/code&gt; ，以类似的方式在任意表达式上创建多重索引。</target>
        </trans-unit>
        <trans-unit id="0ff9726784d6a1aff26ac13770f9e52387b5cba0" translate="yes" xml:space="preserve">
          <source>You can create an index on an arbitrary expression by passing an anonymous function to &lt;code&gt;indexCreate&lt;/code&gt;.</source>
          <target state="translated">您可以通过将匿名函数传递给 &lt;code&gt;indexCreate&lt;/code&gt; 来在任意表达式上创建索引。</target>
        </trans-unit>
        <trans-unit id="8c85924dc6701675bf65f65e91338b361c7719c7" translate="yes" xml:space="preserve">
          <source>You can find unofficial community-supported Docker images on our &lt;a href=&quot;../frameworks-and-libraries/index&quot;&gt;Frameworks and Libraries&lt;/a&gt; list under &amp;ldquo;Docker images.&amp;rdquo;</source>
          <target state="translated">您可以在我们的&lt;a href=&quot;../frameworks-and-libraries/index&quot;&gt;框架和库&lt;/a&gt;列表中的&amp;ldquo; Docker映像&amp;rdquo;下找到非官方社区支持的Docker映像。</target>
        </trans-unit>
        <trans-unit id="7128754a7ec44d094fd8436c4f0024fffbe80772" translate="yes" xml:space="preserve">
          <source>You can get the value of a specific field by using the &lt;code&gt;()&lt;/code&gt; operator successively to &amp;ldquo;drill down&amp;rdquo; in the document nesting:</source>
          <target state="translated">您可以通过依次使用 &lt;code&gt;()&lt;/code&gt; 运算符来&amp;ldquo;向下钻取&amp;rdquo;文档嵌套来获取特定字段的值：</target>
        </trans-unit>
        <trans-unit id="3fab9bb039306b94d3dcceac9307f7438d69a0d8" translate="yes" xml:space="preserve">
          <source>You can give the queue a name if you want, but since we passed an empty string to &lt;code&gt;assertQueue&lt;/code&gt; it&amp;rsquo;ll create a randomly generated name for us.</source>
          <target state="translated">您可以根据需要为队列指定一个名称，但是由于我们向 &lt;code&gt;assertQueue&lt;/code&gt; 传递了一个空字符串，它将为我们创建一个随机生成的名称。</target>
        </trans-unit>
        <trans-unit id="95a4afcf8eb4b7e86bde39ff9cd1eee507b21edb" translate="yes" xml:space="preserve">
          <source>You can increase the performance of a query by using the &lt;code&gt;outdated&lt;/code&gt; read mode, which allows the cluster to return values from memory on arbitrarily-selected replicas.</source>
          <target state="translated">您可以通过使用 &lt;code&gt;outdated&lt;/code&gt; 读取模式来提高查询的性能，该模式允许群集从任意选择的副本上的内存中返回值。</target>
        </trans-unit>
        <trans-unit id="144b33ca938be37a7db68bea3a8e00681f057745" translate="yes" xml:space="preserve">
          <source>You can insert data in soft durability mode as follows:</source>
          <target state="translated">在软耐久性模式下,可按以下方式插入数据。</target>
        </trans-unit>
        <trans-unit id="19aa0f58079aaa5fdb28aefcf4d031b7fca0523d" translate="yes" xml:space="preserve">
          <source>You can insert documents by calling the &lt;code&gt;insert&lt;/code&gt; command on the appropriate table:</source>
          <target state="translated">您可以通过在适当的表上调用 &lt;code&gt;insert&lt;/code&gt; 命令来插入文档：</target>
        </trans-unit>
        <trans-unit id="522166a599dd048fb9f36a688c8769900fab5110" translate="yes" xml:space="preserve">
          <source>You can insert multiple documents at once by passing an array of documents to &lt;code&gt;insert&lt;/code&gt; as follows:</source>
          <target state="translated">您可以通过传递要 &lt;code&gt;insert&lt;/code&gt; 的文档数组来一次插入多个文档：</target>
        </trans-unit>
        <trans-unit id="bc5fd63ec4ce45a7100edbaad666967334a1bcbb" translate="yes" xml:space="preserve">
          <source>You can insert times by simply passing a native &lt;code&gt;Date&lt;/code&gt; object.</source>
          <target state="translated">您可以通过简单地传递本地 &lt;code&gt;Date&lt;/code&gt; 对象来插入时间。</target>
        </trans-unit>
        <trans-unit id="751f056e4fe6679c065eb7194734fc44fd1a7b13" translate="yes" xml:space="preserve">
          <source>You can limit the number of documents returned by your queries with the &lt;code&gt;limit&lt;/code&gt; command. Let&amp;rsquo;s retrieve just the first 10 blog posts:</source>
          <target state="translated">您可以使用 &lt;code&gt;limit&lt;/code&gt; 命令限制查询返回的文档数量。让我们只检索前10个博客文章：</target>
        </trans-unit>
        <trans-unit id="76b17d6c854c4f6dab9445bfb353fd30b3552e94" translate="yes" xml:space="preserve">
          <source>You can manually merge the &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; fields without using the &lt;code&gt;zip&lt;/code&gt; command. Suppose you want to keep the name of the employee and the name of his company. You can do:</source>
          <target state="translated">您可以手动合并 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 字段，而使用 &lt;code&gt;zip&lt;/code&gt; 命令。假设您要保留员工的姓名和公司的名称。你可以做：</target>
        </trans-unit>
        <trans-unit id="ef36e76fd44a04fb2dd47cac5bdfd94615eb0032" translate="yes" xml:space="preserve">
          <source>You can now access RethinkDB commands through the &lt;code&gt;r&lt;/code&gt; module.</source>
          <target state="translated">您现在可以通过 &lt;code&gt;r&lt;/code&gt; 模块访问RethinkDB命令。</target>
        </trans-unit>
        <trans-unit id="79a60802ebbd73788c71aa231b342a11949864ed" translate="yes" xml:space="preserve">
          <source>You can now access the web interface using the following URL: &lt;code&gt;http://HOST/rethinkdb_admin&lt;/code&gt;.</source>
          <target state="translated">您现在可以使用以下URL访问Web界面： &lt;code&gt;http://HOST/rethinkdb_admin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32d827dd1b8146523ca253b1fbd010534352b7e6" translate="yes" xml:space="preserve">
          <source>You can now connect to your RethinkDB instance by connecting to the host &lt;code&gt;localhost&lt;/code&gt; and port &lt;code&gt;local_port&lt;/code&gt;:</source>
          <target state="translated">现在，您可以通过连接到主机 &lt;code&gt;localhost&lt;/code&gt; 和端口 &lt;code&gt;local_port&lt;/code&gt; 来连接到RethinkDB实例：</target>
        </trans-unit>
        <trans-unit id="544a44f70a2d29fc913b28c805d563bd24f59665" translate="yes" xml:space="preserve">
          <source>You can now generate models individually or use the scaffolding mechanism. For example, here&amp;rsquo;s a scaffold for an Article resource:</source>
          <target state="translated">现在，您可以单独生成模型，也可以使用脚手架机制。例如，这是&amp;ldquo;文章&amp;rdquo;资源的支架：</target>
        </trans-unit>
        <trans-unit id="1babd33de8299282e70321fd6e6921550e6a311f" translate="yes" xml:space="preserve">
          <source>You can now visit &lt;code&gt;localhost:8080&lt;/code&gt; to see the RethinkDB web admin.</source>
          <target state="translated">您现在可以访问 &lt;code&gt;localhost:8080&lt;/code&gt; 来查看RethinkDB Web管理员。</target>
        </trans-unit>
        <trans-unit id="2136ac157f038f4f09ae39e08df0720968297d60" translate="yes" xml:space="preserve">
          <source>You can only check arity of the methods to a certain extent. If an &lt;code&gt;ARGS&lt;/code&gt; term is one of the argument, only the server can effectively verify that enough arguments are provided (or not too many). The arity errors reported by the server suppose a prefix notation. Things may change if the solution in &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/2463#issuecomment-44584491&quot;&gt;#2463&lt;/a&gt; is implemented.</source>
          <target state="translated">您只能在一定程度上检查方法的适用性。如果 &lt;code&gt;ARGS&lt;/code&gt; 术语是参数之一，则只有服务器才能有效地验证是否提供了足够的参数（或没有太多）。服务器报告的Arity错误假定为前缀符号。如果实施&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/2463#issuecomment-44584491&quot;&gt;＃2463中&lt;/a&gt;的解决方案，情况可能会发生变化。</target>
        </trans-unit>
        <trans-unit id="c9c17135e144b5ea5748af8b5b13a317d020c5cc" translate="yes" xml:space="preserve">
          <source>You can query for specific kinds of issues by filtering on the &lt;code&gt;type&lt;/code&gt; field.</source>
          <target state="translated">您可以通过在 &lt;code&gt;type&lt;/code&gt; 字段上进行过滤来查询特定种类的问题。</target>
        </trans-unit>
        <trans-unit id="9a42ac8551b89b20f2c10b30974b7c931c71637d" translate="yes" xml:space="preserve">
          <source>You can read more about ReQL in the &lt;a href=&quot;../introduction-to-reql/index&quot;&gt;Introduction to ReQL&lt;/a&gt; article, or go into greater depth with the &lt;a href=&quot;../../api/javascript/index&quot;&gt;API documentation&lt;/a&gt;.</source>
          <target state="translated">您可以在ReQL &lt;a href=&quot;../introduction-to-reql/index&quot;&gt;简介&lt;/a&gt;文章中阅读有关ReQL的更多信息，或者使用&lt;a href=&quot;../../api/javascript/index&quot;&gt;API文档进行&lt;/a&gt;更深入的了解。</target>
        </trans-unit>
        <trans-unit id="be9ee9a22a35c38e47001b9b9f655322e519c2c4" translate="yes" xml:space="preserve">
          <source>You can register multiple queries with the same &lt;code&gt;Handler&lt;/code&gt; instance. If you define &lt;code&gt;Handler&lt;/code&gt; methods with an additional argument (two arguments instead of one, or one argument instead of zero), that argument will receive the appropriate &lt;code&gt;QueryHandle&lt;/code&gt; instance.</source>
          <target state="translated">您可以使用同一 &lt;code&gt;Handler&lt;/code&gt; 实例注册多个查询。如果使用附加参数（两个参数而不是一个参数，或一个参数而不是零）定义 &lt;code&gt;Handler&lt;/code&gt; 方法，则该参数将接收适当的 &lt;code&gt;QueryHandle&lt;/code&gt; 实例。</target>
        </trans-unit>
        <trans-unit id="1933909364676c58638278c6dab0bcfb57c730da" translate="yes" xml:space="preserve">
          <source>You can run the &lt;code&gt;tags&lt;/code&gt; and &lt;code&gt;hierarchy&lt;/code&gt; demos the same way.</source>
          <target state="translated">您可以以相同的方式运行 &lt;code&gt;tags&lt;/code&gt; 和 &lt;code&gt;hierarchy&lt;/code&gt; 演示。</target>
        </trans-unit>
        <trans-unit id="4b3967663785629ac46bd8c818c4a0c7fb7bb0b7" translate="yes" xml:space="preserve">
          <source>You can select the database where you&amp;rsquo;d like to create the table with the &lt;code&gt;db&lt;/code&gt; command and use the &lt;code&gt;tableCreate&lt;/code&gt; command as follows:</source>
          <target state="translated">您可以使用 &lt;code&gt;db&lt;/code&gt; 命令选择要在其中创建表的数据库，并使用 &lt;code&gt;tableCreate&lt;/code&gt; 命令，如下所示：</target>
        </trans-unit>
        <trans-unit id="3445238753b67722f154d32ffb435fb68a7c2ce7" translate="yes" xml:space="preserve">
          <source>You can specify associations between models in the generator:</source>
          <target state="translated">您可以在生成器中指定模型之间的关联。</target>
        </trans-unit>
        <trans-unit id="4655d414014487455834f6df43050a9e8837e922" translate="yes" xml:space="preserve">
          <source>You can then retrieve only the domain with the &lt;a href=&quot;../get_field/index&quot;&gt;()&lt;/a&gt; selector and &lt;a href=&quot;../nth/index&quot;&gt;nth&lt;/a&gt;.</source>
          <target state="translated">然后，您可以使用&lt;a href=&quot;../get_field/index&quot;&gt;（）&lt;/a&gt;选择器和&lt;a href=&quot;../nth/index&quot;&gt;nth&lt;/a&gt;仅检索域。</target>
        </trans-unit>
        <trans-unit id="cc57e6e3fb5364b78e07f1d7b90170685584269a" translate="yes" xml:space="preserve">
          <source>You can upgrade your version of Node.js via &lt;code&gt;npm&lt;/code&gt;:</source>
          <target state="translated">您可以通过 &lt;code&gt;npm&lt;/code&gt; 升级Node.js版本：</target>
        </trans-unit>
        <trans-unit id="a96610657bbf110f72a345d4ecbc8d9e3ab92272" translate="yes" xml:space="preserve">
          <source>You can use Ruby&amp;rsquo;s &lt;code&gt;DateTime.to_time&lt;/code&gt; and &lt;code&gt;Time.to_datetime&lt;/code&gt; methods to easily convert between one and the other.</source>
          <target state="translated">您可以使用Ruby的 &lt;code&gt;DateTime.to_time&lt;/code&gt; 和 &lt;code&gt;Time.to_datetime&lt;/code&gt; 方法在彼此之间轻松转换。</target>
        </trans-unit>
        <trans-unit id="4696c1747cc9a947e3f0c3d082249e222fd734da" translate="yes" xml:space="preserve">
          <source>You can use a relational data modeling technique and create two tables to store your data. A typical document in the &lt;code&gt;authors&lt;/code&gt; table would look like this:</source>
          <target state="translated">您可以使用关系数据建模技术并创建两个表来存储数据。 &lt;code&gt;authors&lt;/code&gt; 表中的典型文档如下所示：</target>
        </trans-unit>
        <trans-unit id="65f77048ddce4bc4a4e2b66b3f488074fd0873c3" translate="yes" xml:space="preserve">
          <source>You can use a reverse HTTP proxy to allow access to the web interface from other servers. Most web servers (such as Apache or Nginx) support this feature. In the following example we&amp;rsquo;ll use Apache to set up a reverse proxy.</source>
          <target state="translated">您可以使用反向HTTP代理来允许其他服务器访问Web界面。大多数Web服务器（例如Apache或Nginx）都支持此功能。在以下示例中，我们将使用Apache设置反向代理。</target>
        </trans-unit>
        <trans-unit id="34248ba9eb41ee870921e136f9b749265031e98c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt; command to pass an array of Point objects (or latitude-longitude pairs) to &lt;code&gt;line&lt;/code&gt;.</source>
          <target state="translated">您可以使用&lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt;命令将Point对象（或纬度-经度对）数组传递给 &lt;code&gt;line&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e81a753574cef91d728da364d2a3db98c3d900d4" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt; command to pass an array of Point objects (or latitude-longitude pairs) to &lt;code&gt;polygon&lt;/code&gt;.</source>
          <target state="translated">您可以使用&lt;a href=&quot;../args/index&quot;&gt;args&lt;/a&gt;命令将Point对象（或纬度-经度对）数组传递给 &lt;code&gt;polygon&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1883a6a496342b873c98c19cfd071b52992f989" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;dbCreate&lt;/code&gt; command as follows:</source>
          <target state="translated">您可以使用 &lt;code&gt;dbCreate&lt;/code&gt; 命令，如下所示：</target>
        </trans-unit>
        <trans-unit id="b1a8bb3cc77f7c36ca0ad2e7223d33bcbb516f2c" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;epochTime&lt;/code&gt; and &lt;code&gt;ISO8601&lt;/code&gt; commands to convert Unix timestamps (in seconds) and JSON date-time strings (which are in ISO 8601 format) to the ReQL time type. The ReQL driver will also convert JavaScript Date objects into ReQL time.</source>
          <target state="translated">您可以使用 &lt;code&gt;epochTime&lt;/code&gt; 和 &lt;code&gt;ISO8601&lt;/code&gt; 命令将Unix时间戳（以秒为单位）和JSON日期时间字符串（ISO 8601格式）转换为ReQL时间类型。ReQL驱动程序还将JavaScript日期对象转换为ReQL时间。</target>
        </trans-unit>
        <trans-unit id="f1af73a9bb486d64ee96e9f24cb09d18d079d423" translate="yes" xml:space="preserve">
          <source>You can use the same programming environment and tools you&amp;rsquo;re already used to.</source>
          <target state="translated">您可以使用已经习惯的相同编程环境和工具。</target>
        </trans-unit>
        <trans-unit id="f1ca27ed70bc37c74353361fb557af790a5f1898" translate="yes" xml:space="preserve">
          <source>You cannot apply a &lt;code&gt;filter&lt;/code&gt; after &lt;code&gt;orderBy.limit&lt;/code&gt; in a changefeed.</source>
          <target state="translated">您不能在 &lt;code&gt;orderBy.limit&lt;/code&gt; 中的orderBy.limit 之后应用 &lt;code&gt;filter&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e488f04e53bcbc97716fbfbf8849bce6efacd19" translate="yes" xml:space="preserve">
          <source>You cannot chain multiple &lt;code&gt;getAll&lt;/code&gt; commands. Use a compound index to efficiently retrieve documents by multiple fields.</source>
          <target state="translated">您不能链接多个 &lt;code&gt;getAll&lt;/code&gt; 命令。使用复合索引可以通过多个字段有效地检索文档。</target>
        </trans-unit>
        <trans-unit id="f812c4695332d39c66ee05c0e065ad6439a12fcd" translate="yes" xml:space="preserve">
          <source>You cannot change a username once it&amp;rsquo;s been created. You can, however, &lt;a href=&quot;../../api/javascript/delete/index&quot;&gt;delete&lt;/a&gt; users from the table.</source>
          <target state="translated">创建用户名后，您将无法再对其进行更改。但是，您可以从表中&lt;a href=&quot;../../api/javascript/delete/index&quot;&gt;删除&lt;/a&gt;用户。</target>
        </trans-unit>
        <trans-unit id="0f6e9f3b175f70884052e2fe6138e9def53f0107" translate="yes" xml:space="preserve">
          <source>You cannot use changefeeds after &lt;a href=&quot;../../../api/javascript/concat_map/index&quot;&gt;concatMap&lt;/a&gt; or other transformations whose results cannot be pushed to the shards.</source>
          <target state="translated">您不能在&lt;a href=&quot;../../../api/javascript/concat_map/index&quot;&gt;concatMap&lt;/a&gt;或其他无法将结果推送到分片的转换之后使用changefeed 。</target>
        </trans-unit>
        <trans-unit id="d5ab7b5179be60b7819ad174aebb47f94c0041ef" translate="yes" xml:space="preserve">
          <source>You have to explicitly use the &lt;code&gt;getAll&lt;/code&gt; command to take advantage of secondary indexes.</source>
          <target state="translated">您必须显式使用 &lt;code&gt;getAll&lt;/code&gt; 命令来利用二级索引。</target>
        </trans-unit>
        <trans-unit id="3ccc70d6fea9d281cc273dec1dd133e29a74e62f" translate="yes" xml:space="preserve">
          <source>You may also insert a time by inserting a literal pseudotype object. This is useful if, for instance, you exported a row using &lt;code&gt;{timeFormat:'raw'}&lt;/code&gt; (see &lt;strong&gt;Retrieving Times&lt;/strong&gt; below).</source>
          <target state="translated">您也可以通过插入文字伪类型对象来插入时间。例如，如果您使用 &lt;code&gt;{timeFormat:'raw'}&lt;/code&gt; 导出了一行，这将很有用（请参见下面的&amp;ldquo; &lt;strong&gt;检索时间&amp;rdquo;&lt;/strong&gt;）。</target>
        </trans-unit>
        <trans-unit id="d5c78d1f1e9d17eec8fcc2f3043e460ea50d9a31" translate="yes" xml:space="preserve">
          <source>You may also rebuild indexes manually in ReQL:</source>
          <target state="translated">您也可以在ReQL中手动重建索引。</target>
        </trans-unit>
        <trans-unit id="6b801a804a689f7ce7c3a900f04b102e00c4a77e" translate="yes" xml:space="preserve">
          <source>You may also see &lt;strong&gt;Any&lt;/strong&gt; used for commands that work with any data type.</source>
          <target state="translated">您还可以看到&lt;strong&gt;任何&lt;/strong&gt;用于命令与任何数据类型的工作。</target>
        </trans-unit>
        <trans-unit id="216cd29d79b5e764f267b1fbf7cd40f5945222e2" translate="yes" xml:space="preserve">
          <source>You may also use the special constants &lt;code&gt;r.minval&lt;/code&gt; and &lt;code&gt;r.maxval&lt;/code&gt; for boundaries, which represent &amp;ldquo;less than any index key&amp;rdquo; and &amp;ldquo;more than any index key&amp;rdquo; respectively. For instance, if you use &lt;code&gt;r.minval&lt;/code&gt; as the lower key, then &lt;code&gt;between&lt;/code&gt; will return all documents whose primary keys (or indexes) are less than the specified upper key.</source>
          <target state="translated">您还可以对边界使用特殊常量 &lt;code&gt;r.minval&lt;/code&gt; 和 &lt;code&gt;r.maxval&lt;/code&gt; ，它们分别表示&amp;ldquo;小于任何索引键&amp;rdquo;和&amp;ldquo;大于任何索引键&amp;rdquo;。例如，如果使用 &lt;code&gt;r.minval&lt;/code&gt; 作为下键，则 &lt;code&gt;between&lt;/code&gt; 将返回其主键（或索引）小于指定的上键的所有文档。</target>
        </trans-unit>
        <trans-unit id="7fd36a0d0214d1375b3acce6557fd40919d911a8" translate="yes" xml:space="preserve">
          <source>You may be able to check if the kernel&amp;rsquo;s out-of-memory killer is responsible for the crash by checking the system message buffer:</source>
          <target state="translated">您可以通过检查系统消息缓冲区来检查内核的内存不足杀手是否导致崩溃：</target>
        </trans-unit>
        <trans-unit id="f4ab6a173ae1d00c9f2de8cdd6f47316610bceee" translate="yes" xml:space="preserve">
          <source>You may be interested in retrieving the results in this format:</source>
          <target state="translated">你可能对以这种格式检索结果感兴趣。</target>
        </trans-unit>
        <trans-unit id="9ca4e5872728b2af78f129fbcb8862f39ba1561e" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;branch&lt;/code&gt; infix style on the first test. (See the second example for an illustration.)</source>
          <target state="translated">您可以在第一个测试中调用 &lt;code&gt;branch&lt;/code&gt; 缀样式。（有关示例，请参见第二个示例。）</target>
        </trans-unit>
        <trans-unit id="88fbc6d30374c1685dcaa3058d32036e9d22c0e4" translate="yes" xml:space="preserve">
          <source>You may need to adjust RethinkDB&amp;rsquo;s page cache size, using the &lt;code&gt;--cache-size&lt;/code&gt; argument or configuration file option. Read &amp;ldquo;&lt;a href=&quot;../memory-usage/index&quot;&gt;Understanding RethinkDB memory requirements&lt;/a&gt;&amp;rdquo; for a more detailed explanation of how RethinkDB uses memory and how to tune its performance.</source>
          <target state="translated">您可能需要使用 &lt;code&gt;--cache-size&lt;/code&gt; 参数或配置文件选项来调整RethinkDB的页面缓存大小。阅读&amp;ldquo; &lt;a href=&quot;../memory-usage/index&quot;&gt;了解RethinkDB内存需求&lt;/a&gt; &amp;rdquo;以获取有关RethinkDB如何使用内存以及如何调整其性能的更详细说明。</target>
        </trans-unit>
        <trans-unit id="035b683c2eb870d8c3a4314f01b4185d55a4eaf3" translate="yes" xml:space="preserve">
          <source>You may rebuild indexes with the &lt;code&gt;rethinkdb&lt;/code&gt; command line utility:</source>
          <target state="translated">您可以使用 &lt;code&gt;rethinkdb&lt;/code&gt; 命令行实用程序重建索引：</target>
        </trans-unit>
        <trans-unit id="9d45fcbef747c80cc440d1e1381aa9a9df031a71" translate="yes" xml:space="preserve">
          <source>You may receive a warning message about secondary indexes on startup being &amp;ldquo;outdated&amp;rdquo; when you upgrade RethinkDB versions.</source>
          <target state="translated">当您升级RethinkDB版本时，您可能会收到一条警告消息，提示启动时的二级索引已&amp;ldquo;过时&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="f2609f36c24cc34f3e43480b11002dab3d0ca9d7" translate="yes" xml:space="preserve">
          <source>You may rewrite these with anonymous functions.</source>
          <target state="translated">你可以用匿名函数重写这些。</target>
        </trans-unit>
        <trans-unit id="ca1d5f446a7c535a121af4af891a4d8add811e03" translate="yes" xml:space="preserve">
          <source>You might also want to use the &lt;a href=&quot;../ungroup/index&quot;&gt;ungroup&lt;/a&gt; command (see above), which will turn the grouped data into an array of objects on the server.</source>
          <target state="translated">您可能还希望使用&lt;a href=&quot;../ungroup/index&quot;&gt;ungroup&lt;/a&gt;命令（请参见上文），该命令会将分组的数据转换为服务器上的对象数组。</target>
        </trans-unit>
        <trans-unit id="d436e93d9a8764b9f606ec167d5f673b80bd6458" translate="yes" xml:space="preserve">
          <source>You might have caught that there were 253 documents inserted, not 250. Either we have the top 253 movies, or there are a few duplicate records lurking in there. We can use &lt;code&gt;distinct&lt;/code&gt; to get a count of unique rows, but we need to remove the &lt;code&gt;id&lt;/code&gt; column from the query, since all ID values are unique.</source>
          <target state="translated">您可能已经发现插入了253个文档，而不是250个。或者我们拥有排在前253位的电影，或者其中隐藏着一些重复的记录。我们可以使用 &lt;code&gt;distinct&lt;/code&gt; 获得唯一行的计数，但是由于所有ID值都是唯一的，因此我们需要从查询中删除 &lt;code&gt;id&lt;/code&gt; 列。</target>
        </trans-unit>
        <trans-unit id="c327a4b6eb6a8adef5a599c8b2953dcb153c415f" translate="yes" xml:space="preserve">
          <source>You might want to &amp;ldquo;tag&amp;rdquo; the tables to make it clear which changes belong to which table.</source>
          <target state="translated">您可能需要&amp;ldquo;标记&amp;rdquo;表以明确哪些更改属于哪个表。</target>
        </trans-unit>
        <trans-unit id="c08b665617a6aa1f2e950387a4615085af0f8a22" translate="yes" xml:space="preserve">
          <source>You might want to produce a &amp;ldquo;union&amp;rdquo; changefeed to watch multiple tables or queries on just one feed. Since the &lt;code&gt;union&lt;/code&gt; command works with &lt;code&gt;changes&lt;/code&gt;, ReQL makes this fairly straightforward. To monitor two tables at once:</source>
          <target state="translated">您可能想要生成一个&amp;ldquo;联合&amp;rdquo;变更供稿，以仅在一个供稿上监视多个表或查询。由于 &lt;code&gt;union&lt;/code&gt; 命令可以进行 &lt;code&gt;changes&lt;/code&gt; ，因此ReQL使其变得非常简单。要一次监视两个表：</target>
        </trans-unit>
        <trans-unit id="f40e2c91ca208432ed398a66468fc4cf49d642a7" translate="yes" xml:space="preserve">
          <source>You might want to use &lt;code&gt;filter&lt;/code&gt; to return documents that have one of two (or more) optional fields set, such as the following:</source>
          <target state="translated">您可能想使用 &lt;code&gt;filter&lt;/code&gt; 返回设置了两个（或多个）可选字段之一的文档，例如：</target>
        </trans-unit>
        <trans-unit id="d42e3e3b1bf529384b192a0b26f47fb0a3069032" translate="yes" xml:space="preserve">
          <source>You must export your data &lt;strong&gt;before&lt;/strong&gt; you&amp;rsquo;ve upgraded RethinkDB to a new version! If you&amp;rsquo;ve already updated, you can find binaries for previous versions in the &lt;a href=&quot;http://download.rethinkdb.com&quot;&gt;download archive&lt;/a&gt;.</source>
          <target state="translated">在将RethinkDB升级到新版本&lt;strong&gt;之前&lt;/strong&gt;，必须先导出数据！如果您已经更新，则可以在&lt;a href=&quot;http://download.rethinkdb.com&quot;&gt;下载档案中&lt;/a&gt;找到以前版本的二进制文件。</target>
        </trans-unit>
        <trans-unit id="565592f422a57bd14395f0aa5e9f7a0c35a0c8de" translate="yes" xml:space="preserve">
          <source>You should not release a connection in the pool as soon as you receive a response. Only release the connection when you receive a response of a type other than &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt;.</source>
          <target state="translated">收到响应后，您不应该在池中释放连接。仅当您收到 &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; 以外类型的响应时，才释放连接。</target>
        </trans-unit>
        <trans-unit id="e2a72e6345a75043e81786646c9dbb79a9081cfe" translate="yes" xml:space="preserve">
          <source>You should see a &amp;ldquo;Setting up a RethinkDB AMI&amp;rdquo; web page. Click on the &lt;strong&gt;Continue&lt;/strong&gt; button to proceed.</source>
          <target state="translated">您应该看到&amp;ldquo;设置RethinkDB AMI&amp;rdquo;网页。单击&lt;strong&gt;继续&lt;/strong&gt;按钮继续。</target>
        </trans-unit>
        <trans-unit id="eaf96a569106f7f50b78dc40ac65e2bc7dc0d21b" translate="yes" xml:space="preserve">
          <source>You start using ReQL in your program similarly to how you&amp;rsquo;d use other databases:</source>
          <target state="translated">您开始在程序中使用ReQL的方式与使用其他数据库的方式类似：</target>
        </trans-unit>
        <trans-unit id="404788204c896695d91565b254d02b6bcaa381e7" translate="yes" xml:space="preserve">
          <source>You will need to create new copies of the &lt;code&gt;com.rethinkdb.server.plist&lt;/code&gt; file with different names (e.g., &lt;code&gt;com.rethinkdb.server2.plist&lt;/code&gt;), making the following changes:</source>
          <target state="translated">您将需要使用不同的名称（例如 &lt;code&gt;com.rethinkdb.server2.plist&lt;/code&gt; ）创建 &lt;code&gt;com.rethinkdb.server.plist&lt;/code&gt; 文件的新副本，进行以下更改：</target>
        </trans-unit>
        <trans-unit id="47868cbefdabe5748bbbe9252f2e32d2707b331b" translate="yes" xml:space="preserve">
          <source>You will receive another response of either type &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt;, indicating there is still more data available, or &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; if you have reached the end of the stream. (This will never be returned for a feed.) Note that these &lt;code&gt;ResponseType&lt;/code&gt;s can be returned without data (an empty array as the &lt;code&gt;r&lt;/code&gt; value). A driver can send &lt;code&gt;CONTINUE&lt;/code&gt; to fetch the next batch of a sequence as soon as the response is received.</source>
          <target state="translated">您将收到另一个 &lt;code&gt;SUCCESS_PARTIAL&lt;/code&gt; 类型的响应，表明仍然有更多数据可用；如果您已到达流的末尾，则返回 &lt;code&gt;SUCCESS_SEQUENCE&lt;/code&gt; 。（永远不会为提要返回此结果。）请注意，可以在没有数据的情况下返回这些 &lt;code&gt;ResponseType&lt;/code&gt; （作为 &lt;code&gt;r&lt;/code&gt; 值的空数组）。收到响应后，驱动程序可以发送 &lt;code&gt;CONTINUE&lt;/code&gt; 以获取下一批序列。</target>
        </trans-unit>
        <trans-unit id="86c4cbeddd9897a41e6259d4e6a3d2093444c21d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll need the following modules installed for Apache:</source>
          <target state="translated">您需要为Apache安装以下模块：</target>
        </trans-unit>
        <trans-unit id="82c41a6c59099a5955fcbee15e65b236d0cbb940" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that both times we inserted are returned as native JavaScript &lt;code&gt;Date&lt;/code&gt; objects. (&lt;code&gt;Date&lt;/code&gt; objects don&amp;rsquo;t store time zone information, so both times are UTC, regardless of your server&amp;rsquo;s local time zone.)</source>
          <target state="translated">您会注意到，两次插入均作为本机JavaScript &lt;code&gt;Date&lt;/code&gt; 对象返回。（ &lt;code&gt;Date&lt;/code&gt; 对象不存储时区信息，因此，无论服务器的本地时区如何，这两个时间均为UTC。）</target>
        </trans-unit>
        <trans-unit id="e157eeb5d7999ee35c81400e6f62bfd4665acb70" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re now up and running with RethinkDB and Rails!</source>
          <target state="translated">您现在就可以使用RethinkDB和Rails来运行了！</target>
        </trans-unit>
        <trans-unit id="060231f2ff139d1387dcc212f509aea6e53a8086" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re on your way with Ruby on Rails and RethinkDB! Be sure to check out additional resources for more information.</source>
          <target state="translated">您正在使用Ruby on Rails和RethinkDB！请确保签出其他资源以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="c0f2169a05838f460f5e9de4b3001208843d3087" translate="yes" xml:space="preserve">
          <source>Your application would by default receive the object as it existed in the database after the &lt;em&gt;most recent&lt;/em&gt; change. The previous two updates would be &amp;ldquo;squashed&amp;rdquo; into the third.</source>
          <target state="translated">默认情况下，您的应用程序将在&lt;em&gt;最新&lt;/em&gt;更改后接收数据库中存在的对象。前两次更新将被&amp;ldquo;压缩&amp;rdquo;为第三次。</target>
        </trans-unit>
        <trans-unit id="d66cc44d6602b7bd31c89d7a1be1215e97a7adc8" translate="yes" xml:space="preserve">
          <source>Your cluster configuration (number of servers, basic network topology, etc.)</source>
          <target state="translated">您的集群配置(服务器数量、基本网络拓扑结构等)。</target>
        </trans-unit>
        <trans-unit id="3375d9e34870f4082b05af85d0b6b6b292554300" translate="yes" xml:space="preserve">
          <source>Your driver should assign each query a unique 8-byte token per connection. (The official RethinkDB drivers implement this as an unsigned 8-byte little-endian counter per connection.) The server will send responses to queries using this token as an identifier so the response can be matched to its query. The token can also be used to request more data for the query if all the results were not returned in the first response.</source>
          <target state="translated">你的驱动应该为每个连接的查询分配一个唯一的8字节标记。(官方的RethinkDB驱动将其实现为每个连接的8字节无符号小二进制计数器)。服务器将使用这个标记作为标识符来发送对查询的响应,这样响应就可以和它的查询进行匹配。如果第一次响应没有返回所有的结果,这个标记也可以用来为查询请求更多的数据。</target>
        </trans-unit>
        <trans-unit id="5078ae8174ee0ebcf94480eb09d460024b113428" translate="yes" xml:space="preserve">
          <source>Zipfian key access distribution</source>
          <target state="translated">Zipfian密钥访问分布</target>
        </trans-unit>
        <trans-unit id="a8a0673c8ed7b6be0dbd6e89da9b275e36e95a98" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;field name&lt;/strong&gt;, to return the element of the sequence with the largest value in that field;</source>
          <target state="translated">一个&lt;strong&gt;字段名&lt;/strong&gt;，返回与在该领域最大的价值序列的元素;</target>
        </trans-unit>
        <trans-unit id="03960db85c68eefbc47d4547b8d35cf0176392b6" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;field name&lt;/strong&gt;, to return the element of the sequence with the smallest value in that field;</source>
          <target state="translated">一个&lt;strong&gt;字段名&lt;/strong&gt;，返回与该字段中的最小值的序列的元素;</target>
        </trans-unit>
        <trans-unit id="e6a2eac36c508310920d67198d9c07d0ac4346cb" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;function&lt;/strong&gt;, to apply the function to every element within the sequence and return the element which returns the largest value from the function, ignoring any elements where the function produces a non-existence error.</source>
          <target state="translated">一个&lt;strong&gt;函数&lt;/strong&gt;，对函数应用到每个元件的序列内，并返回其从函数返回最大值，忽略其中函数产生一个不存在的差错的任何元素的元素。</target>
        </trans-unit>
        <trans-unit id="51161408b253db2bc8cd04ca036d0be54cc2469d" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;function&lt;/strong&gt;, to apply the function to every element within the sequence and return the element which returns the smallest value from the function, ignoring any elements where the function produces a non-existence error.</source>
          <target state="translated">一个&lt;strong&gt;function&lt;/strong&gt;，将函数应用于序列中的每个元素，并返回从函数返回最小值的元素，而忽略该函数会产生不存在错误的任何元素。</target>
        </trans-unit>
        <trans-unit id="cd9872fbde97c7cf8b282e7afff9d51a63f70f22" translate="yes" xml:space="preserve">
          <source>a binary object can be coerced to a string and vice-versa</source>
          <target state="translated">二进制对象可以被胁迫成字符串,反之亦然。</target>
        </trans-unit>
        <trans-unit id="45abe18bbf8e0052b4064b1b9c9bd0cfa96182da" translate="yes" xml:space="preserve">
          <source>a sequence, selection or an array of key-value pairs can be coerced to an object</source>
          <target state="translated">一个序列、选择或键值对的数组可以被强制到一个对象上。</target>
        </trans-unit>
        <trans-unit id="ab027b3a4f17d2c5fbc84639e3d462c468056de8" translate="yes" xml:space="preserve">
          <source>a sequence, selection or object can be coerced to an array</source>
          <target state="translated">序列、选择或对象可以被强制到一个数组中。</target>
        </trans-unit>
        <trans-unit id="e325e7bf81dae8d35aeef7c7a58e7bf8c0a14465" translate="yes" xml:space="preserve">
          <source>a stream will be handled by &lt;code&gt;on_stream_val&lt;/code&gt; if defined; otherwise it will be handled by &lt;code&gt;on_val&lt;/code&gt;.</source>
          <target state="translated">如果已定义，流将由 &lt;code&gt;on_stream_val&lt;/code&gt; 处理；否则将由 &lt;code&gt;on_val&lt;/code&gt; 处理。</target>
        </trans-unit>
        <trans-unit id="59462ed31f22981dcea909b3a58fd3f7fee5aeea" translate="yes" xml:space="preserve">
          <source>a string can be coerced to a number</source>
          <target state="translated">字符串可以被胁迫成数</target>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="c63d48ab6a49abed2ff11f28593398d7920e1365" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;index&lt;/strong&gt; (the primary key or a secondary index), to return the element of the sequence with the largest value in that index;</source>
          <target state="translated">一个&lt;strong&gt;索引&lt;/strong&gt;（主钥匙或次索引），以返回与该索引的最大值的序列的元素;</target>
        </trans-unit>
        <trans-unit id="b22fd606be8e50662952de0616e76de5f757397d" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;index&lt;/strong&gt; (the primary key or a secondary index), to return the element of the sequence with the smallest value in that index;</source>
          <target state="translated">一个&lt;strong&gt;索引&lt;/strong&gt;（主钥匙或次索引），以返回与该索引中的最小值的序列的元素;</target>
        </trans-unit>
        <trans-unit id="2f61c5a7a1dd022dd82cf2297401f9e62417803b" translate="yes" xml:space="preserve">
          <source>an array will be handled by &lt;code&gt;on_array&lt;/code&gt; if defined; otherwise it will be handled by &lt;code&gt;on_atom&lt;/code&gt;. If neither of those are defined, the &lt;em&gt;individual elements&lt;/em&gt; of the array will be handled by &lt;code&gt;on_stream_val&lt;/code&gt; or, if that is not defined, &lt;code&gt;on_val&lt;/code&gt;.</source>
          <target state="translated">如果定义了数组，则将由 &lt;code&gt;on_array&lt;/code&gt; 处理；否则将由 &lt;code&gt;on_atom&lt;/code&gt; 处理。如果没有那些被定义，所述&lt;em&gt;单个元件&lt;/em&gt;的阵列的将被处理 &lt;code&gt;on_stream_val&lt;/code&gt; 或，如果没有定义， &lt;code&gt;on_val&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="d09ece47e5e6eac4f0488488b4d27d82317b9e3a" translate="yes" xml:space="preserve">
          <source>and in another window run:</source>
          <target state="translated">并在另一个窗口运行。</target>
        </trans-unit>
        <trans-unit id="2c6be7e76811f8a5e128fffbca0db1459bf763b3" translate="yes" xml:space="preserve">
          <source>any datum (single value) can be coerced to to a string</source>
          <target state="translated">任何一个基准点(单值)都可以被胁迫成一个字符串。</target>
        </trans-unit>
        <trans-unit id="a58020f282bf4efacbf5d09a443a72fc9c66bcab" translate="yes" xml:space="preserve">
          <source>anything else: as &lt;code&gt;text&lt;/code&gt;</source>
          <target state="translated">其他：作为 &lt;code&gt;text&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db43bff34c78044870bc6b1ae2aa16902bb1bb8a" translate="yes" xml:space="preserve">
          <source>append</source>
          <target state="translated">append</target>
        </trans-unit>
        <trans-unit id="3030e728f154bf51419109efb93b6b8aeec9a976" translate="yes" xml:space="preserve">
          <source>args</source>
          <target state="translated">args</target>
        </trans-unit>
        <trans-unit id="fcc9016d1aa6a646348df69e14d31e955d51da60" translate="yes" xml:space="preserve">
          <source>arrays</source>
          <target state="translated">arrays</target>
        </trans-unit>
        <trans-unit id="dfc520a023c642ce8f2688447d7245de35aae993" translate="yes" xml:space="preserve">
          <source>auth key</source>
          <target state="translated">验证码</target>
        </trans-unit>
        <trans-unit id="97e77871b5fcc4941bebceb4338c97c1fd149f8c" translate="yes" xml:space="preserve">
          <source>avg</source>
          <target state="translated">avg</target>
        </trans-unit>
        <trans-unit id="89f7376411836c9118d833584b7127b976b30eca" translate="yes" xml:space="preserve">
          <source>backfill</source>
          <target state="translated">backfill</target>
        </trans-unit>
        <trans-unit id="709634051471385aada32356842983beeff4b065" translate="yes" xml:space="preserve">
          <source>between</source>
          <target state="translated">between</target>
        </trans-unit>
        <trans-unit id="7e57cfe843145135aee1f4d0d63ceb7842093712" translate="yes" xml:space="preserve">
          <source>binary</source>
          <target state="translated">binary</target>
        </trans-unit>
        <trans-unit id="0cf36e054d06cf3e24262b9c117b8c36a2f910c2" translate="yes" xml:space="preserve">
          <source>binary objects</source>
          <target state="translated">二进制对象</target>
        </trans-unit>
        <trans-unit id="80a25bf9e5d787c109376c0b79d204a87d3b2159" translate="yes" xml:space="preserve">
          <source>booleans</source>
          <target state="translated">booleans</target>
        </trans-unit>
        <trans-unit id="8b7003a3cbdca58c13fadc160b3cb2a18890ccd4" translate="yes" xml:space="preserve">
          <source>box-rethinkdb</source>
          <target state="translated">box-rethinkdb</target>
        </trans-unit>
        <trans-unit id="10d735e581f1e2505cd69675691925490e447c44" translate="yes" xml:space="preserve">
          <source>branch</source>
          <target state="translated">branch</target>
        </trans-unit>
        <trans-unit id="613af80c25dfbc9ef75ce605280571b9a518d632" translate="yes" xml:space="preserve">
          <source>ceil</source>
          <target state="translated">ceil</target>
        </trans-unit>
        <trans-unit id="5b21c21f1b4d308af711792b548fc67cbdb3501b" translate="yes" xml:space="preserve">
          <source>changeAt</source>
          <target state="translated">changeAt</target>
        </trans-unit>
        <trans-unit id="49a04ba4469678c38e0f6a327f8702ea61d9e8a4" translate="yes" xml:space="preserve">
          <source>changes</source>
          <target state="translated">changes</target>
        </trans-unit>
        <trans-unit id="00b7b8118efde44c546b69243ec15b21cd64c9d9" translate="yes" xml:space="preserve">
          <source>circle</source>
          <target state="translated">circle</target>
        </trans-unit>
        <trans-unit id="da38860cb875cb64092e402d80d9fe29c4865b18" translate="yes" xml:space="preserve">
          <source>close</source>
          <target state="translated">close</target>
        </trans-unit>
        <trans-unit id="3f058d4502d8d3821d428b7868b825d469c09dfc" translate="yes" xml:space="preserve">
          <source>close (cursor)</source>
          <target state="translated">闭合</target>
        </trans-unit>
        <trans-unit id="da68bf3a55223d19ffeabebe48b0af570d763307" translate="yes" xml:space="preserve">
          <source>cluster</source>
          <target state="translated">cluster</target>
        </trans-unit>
        <trans-unit id="b8359ca5f77b2d89fbef0ec0be2b08810eb6036f" translate="yes" xml:space="preserve">
          <source>cluster_config</source>
          <target state="translated">cluster_config</target>
        </trans-unit>
        <trans-unit id="09c2d2c08b69155cee87c21f7ba3f9df41b4ccbc" translate="yes" xml:space="preserve">
          <source>coerceTo</source>
          <target state="translated">coerceTo</target>
        </trans-unit>
        <trans-unit id="aa60230ab00282b5a1f3f1993b2d1c503e7d15a5" translate="yes" xml:space="preserve">
          <source>column</source>
          <target state="translated">column</target>
        </trans-unit>
        <trans-unit id="f4c35a76ac7be23c2bdef7981de2a3ccdf4c6dbd" translate="yes" xml:space="preserve">
          <source>concatMap</source>
          <target state="translated">concatMap</target>
        </trans-unit>
        <trans-unit id="aadcc2dbb054cb813f3bcabf9f333951aecd357d" translate="yes" xml:space="preserve">
          <source>concat_map</source>
          <target state="translated">concat_map</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="f11a107f38328604e9320754224b60375758bca1" translate="yes" xml:space="preserve">
          <source>connect</source>
          <target state="translated">connect</target>
        </trans-unit>
        <trans-unit id="348eb028ae2fba9221b11f8c2e3cdea9cb2bf40c" translate="yes" xml:space="preserve">
          <source>contact &amp;rarr; phone &amp;rarr; work &amp;rarr; 408-555-1212</source>
          <target state="translated">联系人&amp;rarr;电话&amp;rarr;工作&amp;rarr;408-555-1212</target>
        </trans-unit>
        <trans-unit id="caeb909ae4ff4ee25a0ff0d476946ed256f2aee1" translate="yes" xml:space="preserve">
          <source>contains</source>
          <target state="translated">contains</target>
        </trans-unit>
        <trans-unit id="be25171a40f5008c51632a20d39171138456c900" translate="yes" xml:space="preserve">
          <source>could return &lt;code&gt;false&lt;/code&gt;! Each individual &lt;a href=&quot;../../api/javascript/get/index&quot;&gt;get&lt;/a&gt; operation is atomic, but the query as a whole is not. To read and modify a document in a single atomic operation, use the &lt;a href=&quot;../../api/javascript/update/index&quot;&gt;update&lt;/a&gt; or &lt;a href=&quot;../../api/javascript/replace/index&quot;&gt;replace&lt;/a&gt; commands.</source>
          <target state="translated">可能返回 &lt;code&gt;false&lt;/code&gt; ！每个单独的&lt;a href=&quot;../../api/javascript/get/index&quot;&gt;get&lt;/a&gt;操作都是原子的，但整个查询不是。要在单个原子操作中阅读和修改文档，请使用&lt;a href=&quot;../../api/javascript/update/index&quot;&gt;update&lt;/a&gt;或&lt;a href=&quot;../../api/javascript/replace/index&quot;&gt;replace&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="ee9f38e186ba06f57b7b74d7e626b94e13ce2556" translate="yes" xml:space="preserve">
          <source>count</source>
          <target state="translated">count</target>
        </trans-unit>
        <trans-unit id="825b192e87a09e48fa7650bc8b5c00660b37183c" translate="yes" xml:space="preserve">
          <source>current_issues</source>
          <target state="translated">current_issues</target>
        </trans-unit>
        <trans-unit id="233e3ce74af9b1e2688f1f811ea11b8770173d6e" translate="yes" xml:space="preserve">
          <source>data that is &lt;em&gt;not&lt;/em&gt; a stream will be handled by &lt;code&gt;on_atom&lt;/code&gt; if defined; otherwise it will be handled by &lt;code&gt;on_val&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;非&lt;/em&gt;流数据将由 &lt;code&gt;on_atom&lt;/code&gt; 处理（如果已定义）；否则将由 &lt;code&gt;on_val&lt;/code&gt; 处理。</target>
        </trans-unit>
        <trans-unit id="6d613a1ee01eec4c0f8ca66df0db71dca0c6e1cf" translate="yes" xml:space="preserve">
          <source>database</source>
          <target state="translated">database</target>
        </trans-unit>
        <trans-unit id="03b1cc5f2e973088b9bb7dc062fee46bd8f432e7" translate="yes" xml:space="preserve">
          <source>database (affecting a database and the tables within)</source>
          <target state="translated">资料库</target>
        </trans-unit>
        <trans-unit id="e927d0677c77241b707442314346326278051dd6" translate="yes" xml:space="preserve">
          <source>date</source>
          <target state="translated">date</target>
        </trans-unit>
        <trans-unit id="a2620cbc10f5198dd03e3f5a1569eb5dcf9a6a87" translate="yes" xml:space="preserve">
          <source>day</source>
          <target state="translated">day</target>
        </trans-unit>
        <trans-unit id="d096c011585d07ea34d552634cab76998611ecd3" translate="yes" xml:space="preserve">
          <source>dayOfWeek</source>
          <target state="translated">dayOfWeek</target>
        </trans-unit>
        <trans-unit id="7d0afeccbd861b481e5513e7daf9473833eacec3" translate="yes" xml:space="preserve">
          <source>dayOfYear</source>
          <target state="translated">dayOfYear</target>
        </trans-unit>
        <trans-unit id="0352a8acc949c7df21fec16e566ba9a74e797a97" translate="yes" xml:space="preserve">
          <source>db</source>
          <target state="translated">db</target>
        </trans-unit>
        <trans-unit id="c6b86d9568cd42b1afb45d6533e1f5b6cc2dbfe9" translate="yes" xml:space="preserve">
          <source>dbCreate</source>
          <target state="translated">dbCreate</target>
        </trans-unit>
        <trans-unit id="3632550442fe7f7fb5788d44a3c05e77e638473d" translate="yes" xml:space="preserve">
          <source>dbDrop</source>
          <target state="translated">dbDrop</target>
        </trans-unit>
        <trans-unit id="8f9451107ae4c39ed8e37bcc9cfc7ffc3c891664" translate="yes" xml:space="preserve">
          <source>dbList</source>
          <target state="translated">dbList</target>
        </trans-unit>
        <trans-unit id="b7ff13c07403be6a24a21282f1e7367c3f378d23" translate="yes" xml:space="preserve">
          <source>db_config</source>
          <target state="translated">db_config</target>
        </trans-unit>
        <trans-unit id="7505d64a54e061b7acd54ccd58b49dc43500b635" translate="yes" xml:space="preserve">
          <source>default</source>
          <target state="translated">default</target>
        </trans-unit>
        <trans-unit id="9485989ff514b5106b7738850fd73c23e8c1e3f7" translate="yes" xml:space="preserve">
          <source>delete</source>
          <target state="translated">delete</target>
        </trans-unit>
        <trans-unit id="5a5ecfe6db57773e77aaacb83bd9dda4c230a08f" translate="yes" xml:space="preserve">
          <source>deleteAt</source>
          <target state="translated">deleteAt</target>
        </trans-unit>
        <trans-unit id="48d53c6e22192bbaaff43be3456d5f6f5d82da6f" translate="yes" xml:space="preserve">
          <source>difference</source>
          <target state="translated">difference</target>
        </trans-unit>
        <trans-unit id="8ae18ed496a7c0132f6bdd4064c9122781c753c0" translate="yes" xml:space="preserve">
          <source>disk_compaction</source>
          <target state="translated">disk_compaction</target>
        </trans-unit>
        <trans-unit id="104082c0efcf62ca0e142ebdffe15221e79de79d" translate="yes" xml:space="preserve">
          <source>distance</source>
          <target state="translated">distance</target>
        </trans-unit>
        <trans-unit id="21a08d6787a0d64238e8d57c9b087a45f1a70665" translate="yes" xml:space="preserve">
          <source>distinct</source>
          <target state="translated">distinct</target>
        </trans-unit>
        <trans-unit id="26021f1f4700496d68e21ef6d4a1b6945da4c8eb" translate="yes" xml:space="preserve">
          <source>div</source>
          <target state="translated">div</target>
        </trans-unit>
        <trans-unit id="eadcd9bd2a09c75aef04954e6799e50278ee124a" translate="yes" xml:space="preserve">
          <source>do</source>
          <target state="translated">do</target>
        </trans-unit>
        <trans-unit id="4f8278c89ad16da05fec4fdfc61fe44798b92720" translate="yes" xml:space="preserve">
          <source>document</source>
          <target state="translated">document</target>
        </trans-unit>
        <trans-unit id="e4370fb0ea59e2aeb0cf8fec4afadb0dd1b956c6" translate="yes" xml:space="preserve">
          <source>downcase</source>
          <target state="translated">downcase</target>
        </trans-unit>
        <trans-unit id="ffed391ca2a6c8bb0b20f95bace87ef78d0c9f59" translate="yes" xml:space="preserve">
          <source>during</source>
          <target state="translated">during</target>
        </trans-unit>
        <trans-unit id="b32f279e548b6fceef4343170778273bfe60658c" translate="yes" xml:space="preserve">
          <source>each</source>
          <target state="translated">each</target>
        </trans-unit>
        <trans-unit id="b1dbc1e1373091420361bccbec082ea83c366e5c" translate="yes" xml:space="preserve">
          <source>eachAsync</source>
          <target state="translated">eachAsync</target>
        </trans-unit>
        <trans-unit id="b07623c2ca4a8d4da83b94812562e891cb5c7139" translate="yes" xml:space="preserve">
          <source>epochTime</source>
          <target state="translated">epochTime</target>
        </trans-unit>
        <trans-unit id="a9c619705e8fcaa770885cac1837ae950f5c8ba5" translate="yes" xml:space="preserve">
          <source>eq</source>
          <target state="translated">eq</target>
        </trans-unit>
        <trans-unit id="e6fd069581a9f3fdcf06a7b624e63f0074e8b36f" translate="yes" xml:space="preserve">
          <source>eqJoin</source>
          <target state="translated">eqJoin</target>
        </trans-unit>
        <trans-unit id="f4ee2443ea84bd630ec142e6d14d7252fe5b111a" translate="yes" xml:space="preserve">
          <source>eq_join</source>
          <target state="translated">eq_join</target>
        </trans-unit>
        <trans-unit id="11f9578d05e6f7bb58a3cdd00107e9f4e3882671" translate="yes" xml:space="preserve">
          <source>error</source>
          <target state="translated">error</target>
        </trans-unit>
        <trans-unit id="0fd1860204d6cee43392972817e66792ee702b89" translate="yes" xml:space="preserve">
          <source>expr</source>
          <target state="translated">expr</target>
        </trans-unit>
        <trans-unit id="2da0b68df8841752bb747a76780679bcd87c6215" translate="yes" xml:space="preserve">
          <source>field</source>
          <target state="translated">field</target>
        </trans-unit>
        <trans-unit id="7aec9744ba1554e4d38febae4278e74a5e764414" translate="yes" xml:space="preserve">
          <source>fill</source>
          <target state="translated">fill</target>
        </trans-unit>
        <trans-unit id="4bb4ca75941b7bbc5bc6a12be44b22fc9c8d234e" translate="yes" xml:space="preserve">
          <source>filter</source>
          <target state="translated">filter</target>
        </trans-unit>
        <trans-unit id="3684c9d3c05e7bee19e2728c6a5b2bbccf0cd9c7" translate="yes" xml:space="preserve">
          <source>floor</source>
          <target state="translated">floor</target>
        </trans-unit>
        <trans-unit id="43402b235d9049b59f92a603a9cf29e68b57c71c" translate="yes" xml:space="preserve">
          <source>fluent-plugin-rethinkdb</source>
          <target state="translated">fluent-plugin-rethinkdb</target>
        </trans-unit>
        <trans-unit id="c5b2b01d33b40a69b0f829fd1827cb8201538518" translate="yes" xml:space="preserve">
          <source>fold</source>
          <target state="translated">fold</target>
        </trans-unit>
        <trans-unit id="7baf67ac9de40c6fc6e4dfd610bab1343f7292a2" translate="yes" xml:space="preserve">
          <source>for each element in the sequence, call both the combining function and a separate emitting function. The emitting function takes three parameters: the previous reduction result (the accumulator), the current element, and the output from the combining function (the new value of the accumulator).</source>
          <target state="translated">对于序列中的每个元素,同时调用组合函数和单独的发射函数。发射函数需要三个参数:之前的还原结果(累加器),当前元素,以及组合函数的输出(累加器的新值)。</target>
        </trans-unit>
        <trans-unit id="edc5ee22beb2b82f4da41914d8d41cca9c53020f" translate="yes" xml:space="preserve">
          <source>forEach</source>
          <target state="translated">forEach</target>
        </trans-unit>
        <trans-unit id="96acf00f78ac6bb5cac1dec9c262de290a22dbb2" translate="yes" xml:space="preserve">
          <source>function: the &lt;code&gt;interleave&lt;/code&gt; argument can take a function whose argument is the current row, and whose return value is a string to take as a field name, as with the &lt;code&gt;&quot;field_name&quot;&lt;/code&gt; setting described above.</source>
          <target state="translated">函数： &lt;code&gt;interleave&lt;/code&gt; 参数可以接受一个函数，该函数的参数为​​当前行，其返回值为作为字段名的字符串，与上述 &lt;code&gt;&quot;field_name&quot;&lt;/code&gt; 设置相同。</target>
        </trans-unit>
        <trans-unit id="a9060bd5525711459bfd3fbd9a5d9658cfa6338a" translate="yes" xml:space="preserve">
          <source>ge</source>
          <target state="translated">ge</target>
        </trans-unit>
        <trans-unit id="b582f58d189d192b7d2998328bbf22a0ed59b60d" translate="yes" xml:space="preserve">
          <source>geojson</source>
          <target state="translated">geojson</target>
        </trans-unit>
        <trans-unit id="65e4e3da890302538dd75ff31b491e3c7fef5d76" translate="yes" xml:space="preserve">
          <source>geometry objects</source>
          <target state="translated">几何对象</target>
        </trans-unit>
        <trans-unit id="783923e57ba5e8f1044632c31fd806ee24814bb5" translate="yes" xml:space="preserve">
          <source>get</source>
          <target state="translated">get</target>
        </trans-unit>
        <trans-unit id="159ecaec32b351286f1d86013ef0ed8ee1ad6934" translate="yes" xml:space="preserve">
          <source>getAll</source>
          <target state="translated">getAll</target>
        </trans-unit>
        <trans-unit id="a1f20c8f5186bb9d998515a2d95409450015f95f" translate="yes" xml:space="preserve">
          <source>getField</source>
          <target state="translated">getField</target>
        </trans-unit>
        <trans-unit id="9296baea6e69026f29ae352a59cfa8236933d146" translate="yes" xml:space="preserve">
          <source>getIntersecting</source>
          <target state="translated">getIntersecting</target>
        </trans-unit>
        <trans-unit id="84020c79c2c513336c8ad5755f06c427fc2a4fba" translate="yes" xml:space="preserve">
          <source>getNearest</source>
          <target state="translated">getNearest</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
