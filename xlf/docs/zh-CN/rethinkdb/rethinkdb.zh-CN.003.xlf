<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="rethinkdb">
    <body>
      <group id="rethinkdb">
        <trans-unit id="30cc23fe9eebe4e35d1386f15397f430ca395f5f" translate="yes" xml:space="preserve">
          <source>Here is example data for the &lt;code&gt;posts&lt;/code&gt; table:</source>
          <target state="translated">这是 &lt;code&gt;posts&lt;/code&gt; 表的示例数据：</target>
        </trans-unit>
        <trans-unit id="0db125f41ac677370c65d1ff336c8967617e8c56" translate="yes" xml:space="preserve">
          <source>Here is how we&amp;rsquo;d delete all documents in a table:</source>
          <target state="translated">这是删除表中所有文档的方法：</target>
        </trans-unit>
        <trans-unit id="8c181cff70c9b30163c281e99e0c3fbff9ddc3eb" translate="yes" xml:space="preserve">
          <source>Here we we show how RethinkDB scales up to 16-nodes with these various workloads:</source>
          <target state="translated">在这里,我们展示了RethinkDB如何在这些不同的工作负载下扩展到16个节点。</target>
        </trans-unit>
        <trans-unit id="99390579ff3daa48faeab2ac93996d68119e186c" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;ve told the river to watch two tables in the &lt;code&gt;blog&lt;/code&gt; database: &lt;code&gt;posts&lt;/code&gt; and &lt;code&gt;comments&lt;/code&gt;. The river should also pull in all existing documents from those tables before it starts watching for updates to the tables. By default, the river inserts documents into a type named after its table, and into an index named after its database. So, in the example above, we&amp;rsquo;d get a new index named &amp;ldquo;blog&amp;rdquo; with two types: &amp;ldquo;posts&amp;rdquo; and &amp;ldquo;comments.&amp;rdquo;</source>
          <target state="translated">在这里，我们告诉River观看 &lt;code&gt;blog&lt;/code&gt; 数据库中的两个表格： &lt;code&gt;posts&lt;/code&gt; 和 &lt;code&gt;comments&lt;/code&gt; 。在开始监视表的更新之前，河流还应从这些表中提取所有现有文档。默认情况下，river将文档插入以其表命名的类型和以其数据库命名的索引。因此，在上面的示例中，我们将获得一个名为&amp;ldquo; blog&amp;rdquo;的新索引，它具有两种类型：&amp;ldquo; posts&amp;rdquo;和&amp;ldquo; comments&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="3e7bca2668150cf7af8f28ff5d8fe33087f8aa11" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s another, more fun example: adding &lt;a href=&quot;https://en.gravatar.com/site/implement/images/&quot;&gt;Gravatar&lt;/a&gt; avatars to user accounts. We can use &lt;a href=&quot;../../../api/javascript/http/index&quot;&gt;http&lt;/a&gt; to retrieve them.</source>
          <target state="translated">这是另一个更有趣的示例：将&lt;a href=&quot;https://en.gravatar.com/site/implement/images/&quot;&gt;Gravatar&lt;/a&gt;头像添加到用户帐户。我们可以使用&lt;a href=&quot;../../../api/javascript/http/index&quot;&gt;http&lt;/a&gt;来检索它们。</target>
        </trans-unit>
        <trans-unit id="aabb856537a5cb29782d8f22decbbabaf04fe163" translate="yes" xml:space="preserve">
          <source>Here, we listen for changes on multiple tables at once. We simultaneously write into the tables, and observe our writes appear in the changefeeds. We then cancel the changefeeds after we&amp;rsquo;ve written 10 items into each of the tables.</source>
          <target state="translated">在这里，我们一次监听多个表上的更改。我们同时在表中写入数据，并观察到我们的写入内容出现在changefeed中。然后，在将10个项目写入每个表之后，我们取消更改供稿。</target>
        </trans-unit>
        <trans-unit id="4f01b808b9218e45dc7c69f3aef704c9a0d36876" translate="yes" xml:space="preserve">
          <source>Here, we use the &lt;code&gt;r.table('users').pluck('last_name')&lt;/code&gt; query as the inner query in &lt;code&gt;filter&lt;/code&gt;, combining the two queries to build a more sophisticated one. Even if you have a cluster of servers and both the &lt;code&gt;authors&lt;/code&gt; table and the &lt;code&gt;users&lt;/code&gt; table are sharded, RethinkDB will do the right thing and evaluate relevant parts of the query above on the appropriate shards, combine bits of data as necessary, and return the complete result.</source>
          <target state="translated">在这里，我们使用 &lt;code&gt;r.table('users').pluck('last_name')&lt;/code&gt; 查询作为 &lt;code&gt;filter&lt;/code&gt; 中的内部查询，将这两个查询结合起来以构建更复杂的查询。即使您有服务器集群，并且 &lt;code&gt;authors&lt;/code&gt; 表和 &lt;code&gt;users&lt;/code&gt; 表都已分片，RethinkDB也会做正确的事情，并在适当的分片上评估上面查询的相关部分，根据需要合并部分数据，然后返回完整的数据。结果。</target>
        </trans-unit>
        <trans-unit id="bda1b9ddd2a172cd6fc2bdd66737451d25b6f867" translate="yes" xml:space="preserve">
          <source>Hierarchy</source>
          <target state="translated">Hierarchy</target>
        </trans-unit>
        <trans-unit id="d432b424148d95b2cce165cd6d0f0d72d5ced443" translate="yes" xml:space="preserve">
          <source>Host: &lt;code&gt;localhost&lt;/code&gt;</source>
          <target state="translated">主机： &lt;code&gt;localhost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c68edbcf7ed862ae84ad731d2c9e92a481b3221d" translate="yes" xml:space="preserve">
          <source>How GMR queries are executed</source>
          <target state="translated">如何执行GMR查询</target>
        </trans-unit>
        <trans-unit id="d0436939cd770cb85fe38b78e1ea8d601df6d4a1" translate="yes" xml:space="preserve">
          <source>How are concurrent queries handled?</source>
          <target state="translated">如何处理并发查询?</target>
        </trans-unit>
        <trans-unit id="05958a9e0373acd35417171d14b2cb37c3c7ad19" translate="yes" xml:space="preserve">
          <source>How can I get a dump of the RethinkDB system tables?</source>
          <target state="translated">如何获得RethinkDB系统表的转储?</target>
        </trans-unit>
        <trans-unit id="4f38e71eadb2253b980e162dfd32f94db825a64c" translate="yes" xml:space="preserve">
          <source>How can I order the output of &lt;code&gt;group&lt;/code&gt;?</source>
          <target state="translated">如何订购 &lt;code&gt;group&lt;/code&gt; 的输出？</target>
        </trans-unit>
        <trans-unit id="ff95c867208c070d7e0b98dd60887a84ad884d3d" translate="yes" xml:space="preserve">
          <source>How can I perform a backup of my cluster?</source>
          <target state="translated">如何对我的集群进行备份?</target>
        </trans-unit>
        <trans-unit id="6f4c44d7a176db22669cfb91c2ecc685d03533ba" translate="yes" xml:space="preserve">
          <source>How do I specify an external canonical IP address of a RethinkDB node?</source>
          <target state="translated">如何指定RethinkDB节点的外部规范IP地址?</target>
        </trans-unit>
        <trans-unit id="7584a8c902d164f0d9b0ee384de49f4974a71781" translate="yes" xml:space="preserve">
          <source>How do I store a Ruby DateTime object in RethinkDB?</source>
          <target state="translated">如何在RethinkDB中存储一个Ruby DateTime对象?</target>
        </trans-unit>
        <trans-unit id="84f27fb4447eb1718681a879231d9bf58780f9cf" translate="yes" xml:space="preserve">
          <source>How does RethinkDB execute queries?</source>
          <target state="translated">RethinkDB如何执行查询?</target>
        </trans-unit>
        <trans-unit id="bcc03b75e66a9846786026fdc4f24e9980175519" translate="yes" xml:space="preserve">
          <source>How does RethinkDB handle data corruption?</source>
          <target state="translated">RethinkDB如何处理数据损坏?</target>
        </trans-unit>
        <trans-unit id="554f5b2f1b62f14b6b314e954a24c929e5a7ecb2" translate="yes" xml:space="preserve">
          <source>How does RethinkDB index data?</source>
          <target state="translated">RethinkDB如何索引数据?</target>
        </trans-unit>
        <trans-unit id="f9960fac43b439c45d353e943db31612a90a46d8" translate="yes" xml:space="preserve">
          <source>How does RethinkDB partition data into shards?</source>
          <target state="translated">RethinkDB如何将数据分割成shards?</target>
        </trans-unit>
        <trans-unit id="988f89c80cee59aa20b3943aea8c7d5a89cae618" translate="yes" xml:space="preserve">
          <source>How does multi-datacenter support work?</source>
          <target state="translated">多数据中心支持如何运作?</target>
        </trans-unit>
        <trans-unit id="a46bc328f467283ecd22518500c2976a70cc4b79" translate="yes" xml:space="preserve">
          <source>How does the atomicity model work?</source>
          <target state="translated">原子性模型如何运作?</target>
        </trans-unit>
        <trans-unit id="af951d8e3819cb840390880fdb37b87df5a0958e" translate="yes" xml:space="preserve">
          <source>How is cluster configuration propagated?</source>
          <target state="translated">集群配置如何传播?</target>
        </trans-unit>
        <trans-unit id="4c81c881ea45d72abebac10fe2d8328a713ebfad" translate="yes" xml:space="preserve">
          <source>How is data stored on disk?</source>
          <target state="translated">数据如何存储在磁盘上?</target>
        </trans-unit>
        <trans-unit id="3f5542bbcb5f2574afad2e3107d6f83ea128ae54" translate="yes" xml:space="preserve">
          <source>How much memory it has</source>
          <target state="translated">它有多少内存</target>
        </trans-unit>
        <trans-unit id="a5666083879cda19541342c834b60e45280910b9" translate="yes" xml:space="preserve">
          <source>How the library is implemented</source>
          <target state="translated">库是如何实现的</target>
        </trans-unit>
        <trans-unit id="cb65cc4955150500049d751964b89925511c01ba" translate="yes" xml:space="preserve">
          <source>How to submit a bug report</source>
          <target state="translated">如何提交错误报告</target>
        </trans-unit>
        <trans-unit id="bdb93ab2ccf5f87fe1eb8544b5133c4fc441ae7f" translate="yes" xml:space="preserve">
          <source>How well does RethinkDB scale?</source>
          <target state="translated">RethinkDB的扩展能力如何?</target>
        </trans-unit>
        <trans-unit id="80369d7456c92b2363b49ca4f9bd24c13fd34679" translate="yes" xml:space="preserve">
          <source>However, RethinkDB does come with some restrictions regarding which operations can be performed atomically. Operations that cannot be proven deterministic cannot update the document in an atomic way. Currently, values obtained by executing JavaScript code, random values, and values obtained as a result of a subquery (e.g. incrementing the value of an attribute by the value of an attribute in a different document) cannot be performed atomically. If an update or replace query cannot be executed atomically, by default RethinkDB will throw an error. The user can choose to set the flag on the update operation in the client driver to execute the query in a non-atomic way. Note that non-atomic operations can only be detected when they involve functions (including &lt;code&gt;row()&lt;/code&gt;) being passed to &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;replace&lt;/code&gt;; a non-atomic &lt;code&gt;insert&lt;/code&gt; operation will not throw an error.</source>
          <target state="translated">但是，RethinkDB确实对可以自动执行哪些操作有一些限制。无法证明是确定性的操作无法以原子方式更新文档。当前，不能原子地执行通过执行JavaScript代码而获得的值，随机值以及作为子查询的结果而获得的值（例如，将属性的值增加另一文档中的属性的值）。如果无法自动执行更新或替换查询，则默认情况下，RethinkDB将引发错误。用户可以选择在客户端驱动程序中的更新操作上设置标志，以非原子方式执行查询。请注意，仅当非原子操作涉及传递用于 &lt;code&gt;update&lt;/code&gt; 函数（包括 &lt;code&gt;row()&lt;/code&gt; ）时，才能检测到它们或 &lt;code&gt;replace&lt;/code&gt; ; 非原子 &lt;code&gt;insert&lt;/code&gt; 操作不会引发错误。</target>
        </trans-unit>
        <trans-unit id="3faa40890508b3aedb1fa775f4e3c1c7b7c50083" translate="yes" xml:space="preserve">
          <source>However, an &lt;a href=&quot;../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; query will be executed differently.</source>
          <target state="translated">但是，&lt;a href=&quot;../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt;查询将以不同的方式执行。</target>
        </trans-unit>
        <trans-unit id="40db98da898bb7295f138bdfd36eef49c309e873" translate="yes" xml:space="preserve">
          <source>However, if any document in the &lt;code&gt;posts&lt;/code&gt; table above lacks a &lt;code&gt;category&lt;/code&gt; field, it won&amp;rsquo;t be included in the result set even if it has a &lt;code&gt;genre&lt;/code&gt; field whose value is &lt;code&gt;'mystery'&lt;/code&gt;. The problem isn&amp;rsquo;t the &lt;code&gt;or&lt;/code&gt; command; it&amp;rsquo;s that the invocation of &lt;code&gt;r.row('category')&lt;/code&gt; on a document without that field returns an error, and the rest of the filter predicate isn&amp;rsquo;t evaluated.</source>
          <target state="translated">但是，如果上面的 &lt;code&gt;posts&lt;/code&gt; 表中的任何文档都缺少 &lt;code&gt;category&lt;/code&gt; 字段，则即使该文档的 &lt;code&gt;genre&lt;/code&gt; 字段的值为 &lt;code&gt;'mystery'&lt;/code&gt; ，也不会包含在结果集中。问题不在于 &lt;code&gt;or&lt;/code&gt; 命令。这是因为在没有该字段的文档上调用 &lt;code&gt;r.row('category')&lt;/code&gt; 会返回错误，并且其余过滤谓词不会被评估。</target>
        </trans-unit>
        <trans-unit id="7ab68a405a573ec72447284d7730942d09144c5b" translate="yes" xml:space="preserve">
          <source>However, that won&amp;rsquo;t work! The reason is that the query object doesn&amp;rsquo;t store state. Each of the commands after the first one is simply running on the &lt;em&gt;original&lt;/em&gt; value of &lt;code&gt;query&lt;/code&gt; (in this case, the &lt;code&gt;posts&lt;/code&gt; table). You can solve this by explicitly assigning the output of each new command to the &lt;code&gt;query&lt;/code&gt; variable:</source>
          <target state="translated">但是，那行不通！原因是查询对象不存储状态。第一个命令之后的每个命令都仅在 &lt;code&gt;query&lt;/code&gt; 的&lt;em&gt;原始&lt;/em&gt;值（在本例中为 &lt;code&gt;posts&lt;/code&gt; 表）上运行。您可以通过将每个新命令的输出显式分配给 &lt;code&gt;query&lt;/code&gt; 变量来解决此问题：</target>
        </trans-unit>
        <trans-unit id="9e05c0bf3bf2f972577d556b1734e3c65fb13e2a" translate="yes" xml:space="preserve">
          <source>However, the first form (passing the index as an argument to &lt;code&gt;distinct&lt;/code&gt;) is faster, and won&amp;rsquo;t run into array limit issues since it&amp;rsquo;s returning a stream.</source>
          <target state="translated">但是，第一种形式（将index作为参数传递给 &lt;code&gt;distinct&lt;/code&gt; ）更快，并且由于它返回流，因此不会遇到数组限制问题。</target>
        </trans-unit>
        <trans-unit id="af69c31fd2ccb351c32df056cd24759e925cdadb" translate="yes" xml:space="preserve">
          <source>I get a &amp;ldquo;ReqlResourceLimitError: Array over size limit 100000&amp;rdquo; when trying to order a table</source>
          <target state="translated">尝试订购表时，出现&amp;ldquo; ReqlResourceLimitError：数组大小超过限制100000&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9433ac50f85f3397600f69393461f23a57de0a9b" translate="yes" xml:space="preserve">
          <source>I get back a connection in my callback with the Node driver</source>
          <target state="translated">我在回调中得到一个与Node驱动的连接。</target>
        </trans-unit>
        <trans-unit id="8a7ade210bab251eef67b6b310337a7a911f67f2" translate="yes" xml:space="preserve">
          <source>I get incorrect results when I pass functions with if/for statements to ReQL</source>
          <target state="translated">当我把带有if/for语句的函数传递给ReQL时,我得到了不正确的结果。</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="58ee37c4c15383ecc1c4a02446d911520642fcf8" translate="yes" xml:space="preserve">
          <source>ISO8601</source>
          <target state="translated">ISO8601</target>
        </trans-unit>
        <trans-unit id="a38f684f0bd8e40a0a38584d5636df0f1ce3d901" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt; (the default), documents with missing fields will be skipped.</source>
          <target state="translated">如果将 &lt;code&gt;default&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; （默认值），则会跳过缺少字段的文档。</target>
        </trans-unit>
        <trans-unit id="2000e8612ae4736ab4bd4478f0043d6b2d5b2a47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is set to &lt;code&gt;r.error()&lt;/code&gt;, an &lt;code&gt;ReqlRuntimeError&lt;/code&gt; will be thrown when a document with a missing field is tested.</source>
          <target state="translated">如果将 &lt;code&gt;default&lt;/code&gt; 设置为 &lt;code&gt;r.error()&lt;/code&gt; ，则在测试缺少字段的文档时将引发 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3289e209f880af4ffc396ac28a2cb56909bbe4d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;default&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, documents with missing fields will be returned rather than skipped.</source>
          <target state="translated">如果 &lt;code&gt;default&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ，则将返回而不是跳过缺少字段的文档。</target>
        </trans-unit>
        <trans-unit id="cbad5bbddabc4696c7b0fe7ac59bbdd74a689d0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;endOffset&lt;/code&gt; is past the end of the sequence, all elements from &lt;code&gt;startOffset&lt;/code&gt; to the end of the sequence will be returned. If &lt;code&gt;startOffset&lt;/code&gt; is past the end of the sequence or &lt;code&gt;endOffset&lt;/code&gt; is less than &lt;code&gt;startOffset&lt;/code&gt;, a zero-element sequence will be returned.</source>
          <target state="translated">如果 &lt;code&gt;endOffset&lt;/code&gt; 在序列末尾之后，则将返回从 &lt;code&gt;startOffset&lt;/code&gt; 到序列末尾的所有元素。如果 &lt;code&gt;startOffset&lt;/code&gt; 超出序列的末尾，或者 &lt;code&gt;endOffset&lt;/code&gt; 小于 &lt;code&gt;startOffset&lt;/code&gt; ，则将返回零元素序列。</target>
        </trans-unit>
        <trans-unit id="541d7adb5503b9e9cc1678d403ded0fcc502208e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;endOffset&lt;/code&gt; is specified, it must not be less than &lt;code&gt;offset&lt;/code&gt;. Both &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;endOffset&lt;/code&gt; must be within the array&amp;rsquo;s bounds (i.e., if the array has 10 elements, an &lt;code&gt;offset&lt;/code&gt; or &lt;code&gt;endOffset&lt;/code&gt; of 10 or higher is invalid).</source>
          <target state="translated">如果指定了 &lt;code&gt;endOffset&lt;/code&gt; ，则它不得小于 &lt;code&gt;offset&lt;/code&gt; 。二者 &lt;code&gt;offset&lt;/code&gt; 和 &lt;code&gt;endOffset&lt;/code&gt; 必须是阵列的边界内（即，如果阵列有10个元素，一个 &lt;code&gt;offset&lt;/code&gt; 或 &lt;code&gt;endOffset&lt;/code&gt; 的10或更高是无效的）。</target>
        </trans-unit>
        <trans-unit id="70e3400a53d9912811460dc3089f66e4bd36e1eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_val&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;old_val&lt;/code&gt; contains the document that was deleted.</source>
          <target state="translated">如果 &lt;code&gt;new_val&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则 &lt;code&gt;old_val&lt;/code&gt; 包含已删除的文档。</target>
        </trans-unit>
        <trans-unit id="de0f3c985cff6f8f6df3f791728158af7a1d7010" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_val&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt;, then &lt;code&gt;new_val&lt;/code&gt; contains the newly created document.</source>
          <target state="translated">如果 &lt;code&gt;old_val&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则 &lt;code&gt;new_val&lt;/code&gt; 包含新创建的文档。</target>
        </trans-unit>
        <trans-unit id="6e0dfba5c9ea511ec048c70efd9aa834fdfe8263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reconfigure&lt;/code&gt; is called on a database, all the tables in the database will have their configurations affected. The return value will be an array of the objects described above, one per table.</source>
          <target state="translated">如果在数据库上调用 &lt;code&gt;reconfigure&lt;/code&gt; ,则数据库中的所有表的配置都会受到影响。返回值将是上述对象的数组，每个表一个。</target>
        </trans-unit>
        <trans-unit id="04dafed2e68464eb0c2df7065604fff9f98185a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replicas&lt;/code&gt; is an integer, it specifies the number of replicas per shard. Specifying more replicas than there are servers will return an error.</source>
          <target state="translated">如果 &lt;code&gt;replicas&lt;/code&gt; 是整数，则它指定每个分片的副本数。指定的副本数多于服务器数，将返回错误。</target>
        </trans-unit>
        <trans-unit id="b48d338ec4b0cd8007b610f5216dc2440ba915b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replicas&lt;/code&gt; is an object, it specifies key-value pairs of server tags and the number of replicas to assign to those servers: &lt;code&gt;{tag1: 2, tag2: 4, tag3: 2, ...}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;replicas&lt;/code&gt; 是一个对象，则它指定服务器标签的键值对以及要分配给这些服务器的副本数量： &lt;code&gt;{tag1: 2, tag2: 4, tag3: 2, ...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb2fb50f691e2304ef3477ac0d2d56d8f7c02254" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replicas&lt;/code&gt; is an object, it specifies key-value pairs of server tags and the number of replicas to assign to those servers: &lt;code&gt;{tag1: 2, tag2: 4, tag3: 2, ...}&lt;/code&gt;. For more information about server tags, read &lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;Administration tools&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;replicas&lt;/code&gt; 是一个对象，则它指定服务器标签的键值对以及要分配给这些服务器的副本数量： &lt;code&gt;{tag1: 2, tag2: 4, tag3: 2, ...}&lt;/code&gt; 。有关服务器标签的更多信息，请阅读&lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;管理工具&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3c635da42642bd2920f3672ac40f4da5ab950fc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replicas&lt;/code&gt; is an object, it specifies key-value pairs of server tags and the number of replicas to assign to those servers: &lt;code&gt;{tag1:2,tag2:4,tag3:2,...}&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;replicas&lt;/code&gt; 是一个对象，则它指定服务器标记的键值对以及要分配给这些服务器的副本数量： &lt;code&gt;{tag1:2,tag2:4,tag3:2,...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="14f31dd824a6c11f58e8cb24afb979b65f78e9ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;replicas&lt;/code&gt; is an object, it specifies key-value pairs of server tags and the number of replicas to assign to those servers: &lt;code&gt;{tag1:2,tag2:4,tag3:2,...}&lt;/code&gt;. For more information about server tags, read &lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;Administration tools&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;replicas&lt;/code&gt; 是一个对象，则它指定服务器标记的键值对以及要分配给这些服务器的副本数量： &lt;code&gt;{tag1:2,tag2:4,tag3:2,...}&lt;/code&gt; 。有关服务器标签的更多信息，请阅读&lt;a href=&quot;../../../docs/administration-tools/index&quot;&gt;管理工具&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a60664966184e4fe4a694c068740f17f6a53ba57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;returnChanges&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;&quot;always&quot;&lt;/code&gt;, the &lt;code&gt;changes&lt;/code&gt; array will follow the same order as the inserted documents. Documents in &lt;code&gt;changes&lt;/code&gt; for which an error occurs (such as a key conflict) will have a third field, &lt;code&gt;error&lt;/code&gt;, with an explanation of the error.</source>
          <target state="translated">如果 &lt;code&gt;returnChanges&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;&quot;always&quot;&lt;/code&gt; ，则 &lt;code&gt;changes&lt;/code&gt; 数组将遵循与插入文档相同的顺序。发生错误（例如键冲突）的 &lt;code&gt;changes&lt;/code&gt; 文档将具有第三个字段 &lt;code&gt;error&lt;/code&gt; ，其中包含错误说明。</target>
        </trans-unit>
        <trans-unit id="7dadb3aacb6423eb027f3fe197b6216164febbc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;slice&lt;/code&gt; is used with a &lt;a href=&quot;../binary/index&quot;&gt;binary&lt;/a&gt; object, the indexes refer to byte positions within the object. That is, the range &lt;code&gt;(10,20)&lt;/code&gt; will refer to the 10th byte through the 19th byte.</source>
          <target state="translated">如果 &lt;code&gt;slice&lt;/code&gt; 与&lt;a href=&quot;../binary/index&quot;&gt;二进制&lt;/a&gt;对象一起使用，则索引引用该对象内的字节位置。也就是说，范围 &lt;code&gt;(10,20)&lt;/code&gt; 将指向第10个字节到第19个字节。</target>
        </trans-unit>
        <trans-unit id="2cd3ead652ee8e80ce01547b661f7b2f2a06b0d6" translate="yes" xml:space="preserve">
          <source>If a database with the same name already exists, the command throws &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">如果已经存在同名数据库，则该命令将引发 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f512423d2484874d4ef81262f263f73e18785542" translate="yes" xml:space="preserve">
          <source>If a server has timed out, the returned document will contain no statistics, but &lt;em&gt;will&lt;/em&gt; contain an error field.</source>
          <target state="translated">如果服务器超时，则返回的文档将不包含任何统计信息，但&lt;em&gt;将&lt;/em&gt;包含一个错误字段。</target>
        </trans-unit>
        <trans-unit id="d67164fdd5b2432d26eb520edd2ceaec9fff9d09" translate="yes" xml:space="preserve">
          <source>If a table is unavailable for reads and/or writes but all its servers are still available, no issue will be shown.</source>
          <target state="translated">如果一个表无法进行读取和/或写入,但其所有服务器仍然可用,则不会显示问题。</target>
        </trans-unit>
        <trans-unit id="ec828d6df90fe81b82d20f519d2c700677a81bbc" translate="yes" xml:space="preserve">
          <source>If a table with the same name already exists, the command throws &lt;code&gt;ReqlOpFailedError&lt;/code&gt;.</source>
          <target state="translated">如果已经存在具有相同名称的表，则该命令将引发 &lt;code&gt;ReqlOpFailedError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="762cbf1b1c5f6e0a0ced0867b8bfd90d270b76fb" translate="yes" xml:space="preserve">
          <source>If an error occurs during an asynchronous operation, the &lt;code&gt;yield&lt;/code&gt; statement will throw an exception as normal. This may happen immediately (for example, you might reference a table that doesn&amp;rsquo;t exist), but your application might receive large amounts of data before the error (for example, your network might be disrupted after the connection is established).</source>
          <target state="translated">如果在异步操作期间发生错误， &lt;code&gt;yield&lt;/code&gt; 语句将照常抛出异常。这可能会立即发生（例如，您可能引用一个不存在的表），但是您的应用程序可能会在错误发生之前收到大量数据（例如，建立连接后网络可能会中断）。</target>
        </trans-unit>
        <trans-unit id="bd199cccfdd4faed1362982f6070c2db7adb71fd" translate="yes" xml:space="preserve">
          <source>If an initial result for a document has been sent and a change is made to that document that would move it to the unsent part of the result set (for instance, a changefeed monitors the top 100 posters, the first 50 have been sent, and poster 48 has become poster 52), an &amp;ldquo;uninitial&amp;rdquo; notification will be sent, with an &lt;code&gt;old_val&lt;/code&gt; field but no &lt;code&gt;new_val&lt;/code&gt; field. This is distinct from a delete change event, which would have a &lt;code&gt;new_val&lt;/code&gt; of &lt;code&gt;null&lt;/code&gt;. (In the top 100 posters example, that could indicate the poster has been deleted, or has dropped out of the top 100.)</source>
          <target state="translated">如果已发送文档的初始结果，并且对该文档进行了更改，将其移动到结果集的未发送部分（例如，changefeed监视前100个发布者，则前50个发布者已发送，并且海报48已变成海报52），将发送&amp;ldquo; uninitial&amp;rdquo;通知，其中包含 &lt;code&gt;old_val&lt;/code&gt; 字段，但没有 &lt;code&gt;new_val&lt;/code&gt; 字段。这与delete change事件不同，后者的 &lt;code&gt;new_val&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 。 （在前100个发布者示例中，这可能表明发布者已被删除，或已从前100名中退出。）</target>
        </trans-unit>
        <trans-unit id="26d654a2235b72cf5ee8cfc9300d6051e8b4403b" translate="yes" xml:space="preserve">
          <source>If half or more of the voting replicas for a shard are lost (including the case of a two-server cluster losing one server), the cluster will need to be repaired manually using the &lt;a href=&quot;../../api/javascript/reconfigure/index#emergency-repair-mode&quot;&gt;emergency repair&lt;/a&gt; option of &lt;code&gt;reconfigure&lt;/code&gt;.</source>
          <target state="translated">如果某个分片的一半或更多有表决权的副本丢失（包括两台服务器的群集丢失一台服务器的情况），则需要使用&lt;a href=&quot;../../api/javascript/reconfigure/index#emergency-repair-mode&quot;&gt;紧急修复&lt;/a&gt;选项 &lt;code&gt;reconfigure&lt;/code&gt; 手动修复该群集。</target>
        </trans-unit>
        <trans-unit id="77bbf8bb3d1284cc20e43e13466c1d3fbf32cb64" translate="yes" xml:space="preserve">
          <source>If half or more of the voting replicas of a shard are lost and cannot be reconnected, an &lt;em&gt;emergency repair&lt;/em&gt; will need to be performed. For more information on the emergency repair option, read the documentation for &lt;a href=&quot;../../api/javascript/reconfigure/index&quot;&gt;reconfigure&lt;/a&gt;.</source>
          <target state="translated">如果碎片的一半或更多有表决权的副本丢失并且无法重新连接，则需要执行&lt;em&gt;紧急修复&lt;/em&gt;。有关紧急维修选件的更多信息，请阅读文档以进行&lt;a href=&quot;../../api/javascript/reconfigure/index&quot;&gt;重新配置&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="061df7e7c49aee434f1204c027cba934cda6af25" translate="yes" xml:space="preserve">
          <source>If half or more of the voting replicas of a shard are lost, the only way to recover availability is to run &lt;a href=&quot;../../api/javascript/reconfigure/index&quot;&gt;reconfigure&lt;/a&gt; with the &lt;code&gt;emergency_repair&lt;/code&gt; option. Consult the documentation for &lt;code&gt;reconfigure&lt;/code&gt; for more details.</source>
          <target state="translated">如果碎片的一半或更多投票副本丢失，恢复可用性的唯一方法是使用 &lt;code&gt;emergency_repair&lt;/code&gt; 选项运行&lt;a href=&quot;../../api/javascript/reconfigure/index&quot;&gt;重新配置&lt;/a&gt;。有关更多详细信息，请查阅文档以进行 &lt;code&gt;reconfigure&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efde73ef7877a20ecc7739f334f47a742fb86558" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t appear to be a memory issue and the log provides no clue, you can try asking for support on our official IRC channel, &lt;a href=&quot;http://webchat.freenode.net/?channels=#rethinkdb&quot;&gt;#rethinkdb on freenode&lt;/a&gt; or our &lt;a href=&quot;http://groups.google.com/group/rethinkdb&quot;&gt;Google Group&lt;/a&gt;. If your problem is a crash that we&amp;rsquo;ve seen before&amp;mdash;or our users have&amp;mdash;this may get you a quick answer.</source>
          <target state="translated">如果这似乎不是内存问题，并且日志也不提供任何线索，则可以尝试在我们的官方IRC频道，&lt;a href=&quot;http://webchat.freenode.net/?channels=#rethinkdb&quot;&gt;freenode上的#rethinkdb&lt;/a&gt;或我们的&lt;a href=&quot;http://groups.google.com/group/rethinkdb&quot;&gt;Google Group &lt;/a&gt;上寻求支持。如果您的问题是我们之前或我们的用户遇到的崩溃，那么这可能会为您提供快速解答。</target>
        </trans-unit>
        <trans-unit id="73e399501b70c228221cdf6526c7e0a1cd275818" translate="yes" xml:space="preserve">
          <source>If it doesn&amp;rsquo;t appear to be a memory issue and the log provides no clue, you can try asking for support on our official IRC channel, &lt;a href=&quot;https://webchat.freenode.net/?channels=#rethinkdb&quot;&gt;#rethinkdb on freenode&lt;/a&gt; or our &lt;a href=&quot;https://groups.google.com/group/rethinkdb&quot;&gt;Google Group&lt;/a&gt;. If your problem is a crash that we&amp;rsquo;ve seen before&amp;mdash;or our users have&amp;mdash;this may get you a quick answer.</source>
          <target state="translated">如果这似乎不是内存问题，并且日志也不提供任何线索，则可以尝试在我们的官方IRC频道，&lt;a href=&quot;https://webchat.freenode.net/?channels=#rethinkdb&quot;&gt;freenode上的#rethinkdb&lt;/a&gt;或我们的&lt;a href=&quot;https://groups.google.com/group/rethinkdb&quot;&gt;Google Group&lt;/a&gt;上寻求支持。如果您的问题是我们之前或我们的用户曾经遇到过的崩溃，那么这可能会为您提供快速解答。</target>
        </trans-unit>
        <trans-unit id="5d31a410767f1b496fa91c893eba00137addcbe4" translate="yes" xml:space="preserve">
          <source>If it were a CSV file, you would use:</source>
          <target state="translated">如果它是一个CSV文件,你会使用。</target>
        </trans-unit>
        <trans-unit id="273525957d7122e79508032144daf98b9a7bfb02" translate="yes" xml:space="preserve">
          <source>If no callback is provided, a promise will be returned.</source>
          <target state="translated">如果没有提供回调,将返回一个承诺。</target>
        </trans-unit>
        <trans-unit id="3f18c7407787ae4cadbbed6cf6901d014fa5ee70" translate="yes" xml:space="preserve">
          <source>If no document exists with that primary key, &lt;code&gt;get&lt;/code&gt; will return &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果不存在使用该主键的文档，则 &lt;code&gt;get&lt;/code&gt; 将返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c34094ff9acb919418ed68f9a89587ff4b66f77" translate="yes" xml:space="preserve">
          <source>If no match is found, returns &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">如果没有找到匹配项，则返回 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d365045e1c5dd0e5c7738c8f718e4c906a519cf2" translate="yes" xml:space="preserve">
          <source>If no tags are specified on startup, the server will be started with one tag, &lt;code&gt;default&lt;/code&gt;. Changing the sharding/replica information from the web UI or from ReQL commands that do not specify server tags will affect all servers with the &lt;code&gt;default&lt;/code&gt; tag.</source>
          <target state="translated">如果启动时未指定任何标签，则服务器将使用一个标签（ &lt;code&gt;default&lt;/code&gt; 为）启动。从Web UI或未指定服务器标签的ReQL命令更改分片/副本信息将影响所有具有 &lt;code&gt;default&lt;/code&gt; 标签的服务器。</target>
        </trans-unit>
        <trans-unit id="0aee98830b826882bbc15a192271ab7048ad30ff" translate="yes" xml:space="preserve">
          <source>If one of the objects is a polygon or a line, the point will be projected onto the line or polygon assuming a perfect sphere model before the distance is computed (using the model specified with &lt;code&gt;geoSystem&lt;/code&gt;). As a consequence, if the polygon or line is extremely large compared to Earth&amp;rsquo;s radius and the distance is being computed with the default WGS84 model, the results of &lt;code&gt;distance&lt;/code&gt; should be considered approximate due to the deviation between the ellipsoid and spherical models.</source>
          <target state="translated">如果对象之一是多边形或直线，则在计算距离之前（使用 &lt;code&gt;geoSystem&lt;/code&gt; 指定的模型），将假设一个完美的球体模型将该点投影到直线或多边形上。因此，如果多边形或直线与地球的半径相比非常大，并且使用默认的WGS84模型计算距离，则由于椭圆和球形模型之间存在偏差，因此应将 &lt;code&gt;distance&lt;/code&gt; 的结果视为近似值。</target>
        </trans-unit>
        <trans-unit id="547988c7baa3a8e7481b284ce93792e14a5f411c" translate="yes" xml:space="preserve">
          <source>If only &lt;code&gt;offset&lt;/code&gt; is specified, &lt;code&gt;deleteAt&lt;/code&gt; removes the element at that index. If both &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;endOffset&lt;/code&gt; are specified, &lt;code&gt;deleteAt&lt;/code&gt; removes the range of elements between &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;endOffset&lt;/code&gt;, inclusive of &lt;code&gt;offset&lt;/code&gt; but not inclusive of &lt;code&gt;endOffset&lt;/code&gt;.</source>
          <target state="translated">如果仅指定 &lt;code&gt;offset&lt;/code&gt; ，则 &lt;code&gt;deleteAt&lt;/code&gt; 删除该索引处的元素。如果同时指定了 &lt;code&gt;offset&lt;/code&gt; 和 &lt;code&gt;endOffset&lt;/code&gt; ，则 &lt;code&gt;deleteAt&lt;/code&gt; 会删除 &lt;code&gt;offset&lt;/code&gt; 和 &lt;code&gt;endOffset&lt;/code&gt; 之间的元素范围，包括 &lt;code&gt;offset&lt;/code&gt; 但不包括 &lt;code&gt;endOffset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93cdeb256a2ad46f4019d2d854dd0948d1443b40" translate="yes" xml:space="preserve">
          <source>If provided, the emitting function must return a list.</source>
          <target state="translated">如果提供,发射函数必须返回一个列表。</target>
        </trans-unit>
        <trans-unit id="85371ec3fada1de618df9a12eeb103a9281a5594" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;createIndex&lt;/code&gt; will return an object of the form &lt;code&gt;{&quot;created&quot;: 1}&lt;/code&gt;. If an index by that name already exists on the table, a &lt;code&gt;ReqlRuntimeError&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果成功，则 &lt;code&gt;createIndex&lt;/code&gt; 将返回 &lt;code&gt;{&quot;created&quot;: 1}&lt;/code&gt; 形式的对象。如果该表上已经存在该名称的索引，则将引发 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08bbef08552a1acfb0ef92a1b563805617586812" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;createIndex&lt;/code&gt; will return an object of the form &lt;code&gt;{&quot;created&quot;:1}&lt;/code&gt;. If an index by that name already exists on the table, a &lt;code&gt;ReqlRuntimeError&lt;/code&gt; will be thrown.</source>
          <target state="translated">如果成功，则 &lt;code&gt;createIndex&lt;/code&gt; 将返回 &lt;code&gt;{&quot;created&quot;:1}&lt;/code&gt; 形式的对象。如果该表上已经存在该名称的索引，则将引发 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e63b0f260be9dfbe19de4fd67d55ad17d37f0ceb" translate="yes" xml:space="preserve">
          <source>If successful, &lt;code&gt;setWriteHook&lt;/code&gt; returns an object of the following form:</source>
          <target state="translated">如果成功，则 &lt;code&gt;setWriteHook&lt;/code&gt; 返回以下形式的对象：</target>
        </trans-unit>
        <trans-unit id="e4e76ff0946a766ef5a743092083b843ce45d352" translate="yes" xml:space="preserve">
          <source>If successful, the command returns an object with two fields:</source>
          <target state="translated">如果成功,命令将返回一个有两个字段的对象。</target>
        </trans-unit>
        <trans-unit id="cb6692ae099a8a1eddf760e79c9cc4b51391cd12" translate="yes" xml:space="preserve">
          <source>If successful, the operation returns an object: &lt;code&gt;{synced: 1}&lt;/code&gt;.</source>
          <target state="translated">如果成功，则该操作将返回一个对象： &lt;code&gt;{synced: 1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f099ce09be84c0c1d227ab9e128e80491015c35" translate="yes" xml:space="preserve">
          <source>If successful, the operation returns an object: &lt;code&gt;{synced:1}&lt;/code&gt;.</source>
          <target state="translated">如果成功，该操作将返回一个对象： &lt;code&gt;{synced:1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2923d4d1e36d8e9e18eb7c10ec7984419a44d118" translate="yes" xml:space="preserve">
          <source>If tags aren&amp;rsquo;t specified when a server starts, the server is automatically assigned the &lt;code&gt;default&lt;/code&gt; tag. Documents cannot be inserted into &lt;code&gt;server_config&lt;/code&gt;. A new document gets created when a server connects to the cluster.</source>
          <target state="translated">如果服务器启动时未指定标签，则会自动为服务器分配 &lt;code&gt;default&lt;/code&gt; 标签。无法将文档插入 &lt;code&gt;server_config&lt;/code&gt; 。服务器连接到群集时，将创建一个新文档。</target>
        </trans-unit>
        <trans-unit id="13169b77be457524ff32a677bc03d95492a45d9e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;db&lt;/code&gt; option is passed to the &lt;code&gt;run&lt;/code&gt; command, its value must be a &lt;code&gt;DB&lt;/code&gt; term. The query:</source>
          <target state="translated">如果将 &lt;code&gt;db&lt;/code&gt; 选项传递给 &lt;code&gt;run&lt;/code&gt; 命令，则其值必须是一个 &lt;code&gt;DB&lt;/code&gt; 术语。查询：</target>
        </trans-unit>
        <trans-unit id="8edba50ace18abb1314bf60cd6f3d0fcda04c32c" translate="yes" xml:space="preserve">
          <source>If the argument is a ReQL term (not including a datum), serialize it using the standard term:</source>
          <target state="translated">如果参数是一个ReQL术语(不包括一个基准),则使用标准术语将其序列化。</target>
        </trans-unit>
        <trans-unit id="de24125bbc0cf5f33af7e2d8106c74639325e769" translate="yes" xml:space="preserve">
          <source>If the cluster requires authorization, you can prompt for the &lt;code&gt;admin&lt;/code&gt; user account password with &lt;code&gt;-p&lt;/code&gt;, or supply a &lt;code&gt;--password-file&lt;/code&gt; to read the password from. (The password file is just a plain text file, with the password on the first and only line.)</source>
          <target state="translated">如果集群需要授权，则可以使用 &lt;code&gt;-p&lt;/code&gt; 提示输入 &lt;code&gt;admin&lt;/code&gt; 用户帐户密码，或者提供 &lt;code&gt;--password-file&lt;/code&gt; 来读取密码。（密码文件只是纯文本文件，密码在第一行和唯一一行。）</target>
        </trans-unit>
        <trans-unit id="0acb66e1a94ce282af96b933ae7b825c35ee4474" translate="yes" xml:space="preserve">
          <source>If the connection cannot be established, a &lt;code&gt;ReqlDriverError&lt;/code&gt; will be passed to the callback instead of a connection.</source>
          <target state="translated">如果无法建立连接，则 &lt;code&gt;ReqlDriverError&lt;/code&gt; 将传递给回调而不是连接。</target>
        </trans-unit>
        <trans-unit id="07a6f801dd9460154f182a8f8dd0817d6309de72" translate="yes" xml:space="preserve">
          <source>If the documents in the table &lt;code&gt;marvel&lt;/code&gt; are:</source>
          <target state="translated">如果表中的文档 &lt;code&gt;marvel&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f30a5dfdb2b1fdb4d94c80ce16b870e4ca1e325d" translate="yes" xml:space="preserve">
          <source>If the function passed to &lt;code&gt;indexCreate&lt;/code&gt; returns an error for a given document, that document will not be indexed. No error will be returned for those documents.</source>
          <target state="translated">如果传递给 &lt;code&gt;indexCreate&lt;/code&gt; 的函数针对给定文档返回错误，则该文档将不会被索引。这些文档将不会返回任何错误。</target>
        </trans-unit>
        <trans-unit id="3ebcff7ab038fb5d86072a62ba35507e5a212753" translate="yes" xml:space="preserve">
          <source>If the given database does not exist, the command throws &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">如果给定的数据库不存在，该命令将抛出 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83f8c355202cee0cf037193fa6419e0d1579befc" translate="yes" xml:space="preserve">
          <source>If the given table does not exist in the database, the command throws &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">如果给定的表在数据库中不存在，该命令将抛出 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d33e35064ceaac7c92d0b921dbc25bb696a28689" translate="yes" xml:space="preserve">
          <source>If the language&amp;rsquo;s native binary format is used, use the pseudotype serialization described above.</source>
          <target state="translated">如果使用语言的本机二进制格式，请使用上述伪类型序列化。</target>
        </trans-unit>
        <trans-unit id="794172004aead88e65b683a952a6720840320737" translate="yes" xml:space="preserve">
          <source>If the last point does not specify the same coordinates as the first point, &lt;code&gt;polygon&lt;/code&gt; will close the polygon by connecting them. You cannot directly construct a polygon with holes in it using &lt;code&gt;polygon&lt;/code&gt;, but you can use &lt;a href=&quot;../polygon_sub/index&quot;&gt;polygonSub&lt;/a&gt; to use a second polygon within the interior of the first to define a hole.</source>
          <target state="translated">如果最后的点不指定相同的坐标作为第一点， &lt;code&gt;polygon&lt;/code&gt; 将通过连接他们关闭多边形。您不能使用 &lt;code&gt;polygon&lt;/code&gt; 直接构造其中带有孔的多边形，但是可以使用&lt;a href=&quot;../polygon_sub/index&quot;&gt;polygonSub&lt;/a&gt;在第一个内部使用第二个多边形定义孔。</target>
        </trans-unit>
        <trans-unit id="279227353c7ecc61dd5168899f51f27994a2cf67" translate="yes" xml:space="preserve">
          <source>If the native object is a Node.js &lt;code&gt;Buffer&lt;/code&gt;, then &lt;code&gt;expr&lt;/code&gt; will return a binary object. See &lt;a href=&quot;../binary/index&quot;&gt;binary&lt;/a&gt; for more information.</source>
          <target state="translated">如果本地对象是Node.js &lt;code&gt;Buffer&lt;/code&gt; ，则 &lt;code&gt;expr&lt;/code&gt; 将返回一个二进制对象。有关更多信息，请参见&lt;a href=&quot;../binary/index&quot;&gt;二进制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6cd91c4ca8d0c94417414eca59c8a4a0745ad9b0" translate="yes" xml:space="preserve">
          <source>If the post has more than 100 views, set the &lt;code&gt;type&lt;/code&gt; of a post to &lt;code&gt;hot&lt;/code&gt;, else set it to &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">如果帖子具有超过100个视图，请将帖子的 &lt;code&gt;type&lt;/code&gt; 设置为 &lt;code&gt;hot&lt;/code&gt; ，否则将其设置为 &lt;code&gt;normal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a8b3ab6af7c7c7f01aa89ce524e930adc4773f6" translate="yes" xml:space="preserve">
          <source>If the primary replica for a table fails, as long as more than half of the table&amp;rsquo;s voting replicas and more than half of the voting replicas for each shard remain available, one of the voting replicas will become the new primary replica.</source>
          <target state="translated">如果表的主副本失败，只要该表的投票副本的一半以上和每个分片的投票副本的一半以上仍然可用，其中一个投票副本将成为新的主副本。</target>
        </trans-unit>
        <trans-unit id="5992fd4ae70294816f6f1035fd88f48be1057692" translate="yes" xml:space="preserve">
          <source>If the primary replica for a table fails, as long as more than half of the table&amp;rsquo;s voting replicas and more than half of the voting replicas for each shard remain available, one of those voting replicas will be arbitrarily selected as the new primary. There will be a brief period of unavailability, but no data will be lost. If the primary replica specified in a table&amp;rsquo;s configuration comes back online after a failure, it will return to being the primary.</source>
          <target state="translated">如果表的主副本失败，只要该表的投票副本的一半以上和每个分片的投票副本的一半以上仍然可用，这些投票副本中的一个将被任意选择为新的主副本。会有短暂的不可用时间，但是不会丢失任何数据。如果表配置中指定的主副本在失败后恢复联机，它将恢复为主副本。</target>
        </trans-unit>
        <trans-unit id="18ddd2727a3246ed2f57a5fc71e675c7a4286058" translate="yes" xml:space="preserve">
          <source>If the primary replica is lost but more than half of the voting replicas are still available, an arbitrary voting replica will be elected as primary. The new primary will appear in &lt;code&gt;table_status&lt;/code&gt;, but the &lt;code&gt;primary_replica&lt;/code&gt; field of &lt;code&gt;table_config&lt;/code&gt; will not change. If the old primary ever becomes available again, the system will switch back. When the primary changes there will be a brief period of unavailability.</source>
          <target state="translated">如果主要副本丢失，但仍有一半以上的投票副本可用，则将选择一个任意的投票副本作为主要副本。新的主会出现在 &lt;code&gt;table_status&lt;/code&gt; ，但 &lt;code&gt;primary_replica&lt;/code&gt; 领域 &lt;code&gt;table_config&lt;/code&gt; 不会改变。如果旧的主数据库再次可用，则系统将切换回原来的状态。当主要更改发生时，将有短暂的不可用时间。</target>
        </trans-unit>
        <trans-unit id="6eb19c9d9de161ce9deb372c1a852deaaa59b9d1" translate="yes" xml:space="preserve">
          <source>If the programmer marks a read query to be ok with out-of-date data, RethinkDB will route the query to the closest available replica instead of routing it to the primary. In this case the client will see the data as long as there are replicas of the data on its side of the netsplit. However, in this case the data has the risk of being out of date. This is usually ok for reports, analytics, cached data, or any scenario in general where having the absolute latest information isn&amp;rsquo;t imperative.</source>
          <target state="translated">如果程序员将读取的查询标记为可以处理过期的数据，则RethinkDB会将查询路由到最接近的可用副本，而不是将其路由到主副本。在这种情况下，只要netsplit一侧有数据副本，客户端就会看到数据。但是，在这种情况下，数据可能会过时。通常，对于报告，分析，缓存的数据，或通常不需要绝对最新信息的任何情况，这都是可以的。</target>
        </trans-unit>
        <trans-unit id="e03767ac627ef652aaabb8ba7ea00ea8e5ff0c57" translate="yes" xml:space="preserve">
          <source>If the sequence has less than the requested number of elements (i.e., calling &lt;code&gt;sample(10)&lt;/code&gt; on a sequence with only five elements), &lt;code&gt;sample&lt;/code&gt; will return the entire sequence in a random order.</source>
          <target state="translated">如果序列的元素数量少于请求的数量（即，在仅包含五个元素的序列上调用 &lt;code&gt;sample(10)&lt;/code&gt; ），则 &lt;code&gt;sample&lt;/code&gt; 将以随机顺序返回整个序列。</target>
        </trans-unit>
        <trans-unit id="e80daa38162b2a8e635d7344846e528706031e35" translate="yes" xml:space="preserve">
          <source>If the sequence has only one element, the first element will be returned.</source>
          <target state="translated">如果序列只有一个元素,将返回第一个元素。</target>
        </trans-unit>
        <trans-unit id="e31c2b8b5674abdc6e8ae2e43f28019783df7d9f" translate="yes" xml:space="preserve">
          <source>If the sequence is empty, the server will produce a &lt;code&gt;ReqlRuntimeError&lt;/code&gt; that can be caught with &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果序列为空，则服务器将生成 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; ，可以使用 &lt;code&gt;default&lt;/code&gt; 捕获该错误。</target>
        </trans-unit>
        <trans-unit id="297486ecfa823e3925af80b1b2a0da86d1f441bb" translate="yes" xml:space="preserve">
          <source>If the table becomes unavailable, the changefeed will be disconnected, and a runtime exception will be thrown by the driver.</source>
          <target state="translated">如果表变得不可用,changefeed将被断开,并且驱动程序将抛出一个运行时异常。</target>
        </trans-unit>
        <trans-unit id="e78393bd57dfdd0854c325d0ada127c46c54fc3c" translate="yes" xml:space="preserve">
          <source>If the user is local, the &lt;code&gt;&amp;lt;domain&amp;gt;&lt;/code&gt; is the name of the server; otherwise, it&amp;rsquo;s the name of the Windows Domain or Active Directory the user record is located in.</source>
          <target state="translated">如果用户是本地用户，则 &lt;code&gt;&amp;lt;domain&amp;gt;&lt;/code&gt; 是服务器的名称；否则，它是用户记录所在的Windows域或Active Directory的名称。</target>
        </trans-unit>
        <trans-unit id="b38d841f1274380a6fad3c11a39dc0bd3d4f5892" translate="yes" xml:space="preserve">
          <source>If this is the case, you may be able to avoid crashes by changing RethinkDB&amp;rsquo;s cache size. For information on in-memory caches, how to check their current size, and how to change them, read &lt;a href=&quot;../memory-usage/index&quot;&gt;Understanding RethinkDB memory requirements&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，您可以通过更改RethinkDB的缓存大小来避免崩溃。有关内存中高速缓存，如何检查其当前大小以及如何更改它们的信息，请阅读《&lt;a href=&quot;../memory-usage/index&quot;&gt;了解RethinkDB内存要求》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e26451b295f2c64f69e48115cef996c58d0e87bf" translate="yes" xml:space="preserve">
          <source>If we go back into the &lt;code&gt;Article&lt;/code&gt; model and add the &lt;code&gt;has_many&lt;/code&gt; side of the association, it&amp;rsquo;s important to note that &lt;code&gt;has_many&lt;/code&gt; associations in NoBrainer are read-only. The server doesn&amp;rsquo;t support transactions, so saving the members of the association is up to the developer.</source>
          <target state="translated">如果我们回到 &lt;code&gt;Article&lt;/code&gt; 模型并添加关联的 &lt;code&gt;has_many&lt;/code&gt; 端，则需要注意的是，NoBrainer中的 &lt;code&gt;has_many&lt;/code&gt; 关联是只读的。服务器不支持事务，因此保存关联成员取决于开发人员。</target>
        </trans-unit>
        <trans-unit id="562a74a46cba2abb9d672c91f3be189ffbff89c6" translate="yes" xml:space="preserve">
          <source>If we want to retrieve all users on the Galactica and Pegasus, we can write:</source>
          <target state="translated">如果我们想检索银河号和飞马号上的所有用户,我们可以写。</target>
        </trans-unit>
        <trans-unit id="3091eed1fda89cc9704666214f1d9fddcd96cc63" translate="yes" xml:space="preserve">
          <source>If we want to retrieve all users that have the email address &lt;code&gt;user@email.com&lt;/code&gt;, we can write:</source>
          <target state="translated">如果要检索所有电子邮件地址为 &lt;code&gt;user@email.com&lt;/code&gt; 的用户，则可以编写：</target>
        </trans-unit>
        <trans-unit id="7540c0f9849aa5c72866ece490cc2ace24df9655" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;delete&lt;/code&gt; a row from &lt;code&gt;table_config&lt;/code&gt; the table will be deleted. If you &lt;code&gt;insert&lt;/code&gt; a row, the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;db&lt;/code&gt; fields are required; the other fields are optional, and will be automatically generated or set to their default if they are not specified. Do not include the &lt;code&gt;id&lt;/code&gt; field. The system will auto-generate a UUID.</source>
          <target state="translated">如果您从 &lt;code&gt;table_config&lt;/code&gt; 中 &lt;code&gt;delete&lt;/code&gt; 一行，则该表将被删除。如果您 &lt;code&gt;insert&lt;/code&gt; 一行，则 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;db&lt;/code&gt; 字段是必填字段；其他字段是可选的，如果未指定，将自动生成或设置为默认值。不要包含 &lt;code&gt;id&lt;/code&gt; 字段。系统将自动生成一个UUID。</target>
        </trans-unit>
        <trans-unit id="22ef0a100b781bbe86d9c3b56b60862049f3cd72" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;replace&lt;/code&gt; a row in &lt;code&gt;table_config&lt;/code&gt;, you must include all the fields. It&amp;rsquo;s usually easier to &lt;code&gt;update&lt;/code&gt; specific fields.</source>
          <target state="translated">如果 &lt;code&gt;replace&lt;/code&gt; &lt;code&gt;table_config&lt;/code&gt; 中的一行，则必须包括所有字段。通常更容易 &lt;code&gt;update&lt;/code&gt; 特定字段。</target>
        </trans-unit>
        <trans-unit id="bc00aecc5294d2dc3548435f91ed3d2f89d0baeb" translate="yes" xml:space="preserve">
          <source>If you accept the &lt;code&gt;rowFinished&lt;/code&gt; callback, it &lt;em&gt;must&lt;/em&gt; be called at the end of each row. If you call &lt;code&gt;rowFinished&lt;/code&gt; with any value, iteration will stop, and the value will be wrapped in &lt;code&gt;error.message&lt;/code&gt; for the error handler.</source>
          <target state="translated">如果您接受 &lt;code&gt;rowFinished&lt;/code&gt; 回调，则&lt;em&gt;必须&lt;/em&gt;在每一行的末尾调用它。如果使用任何值调用 &lt;code&gt;rowFinished&lt;/code&gt; ，迭代将停止，并且该值将包装在 &lt;code&gt;error.message&lt;/code&gt; 中以供错误处理程序使用。</target>
        </trans-unit>
        <trans-unit id="2f9276b4d2b3fcbd52dda6edde3718ac5d70084a" translate="yes" xml:space="preserve">
          <source>If you are using configuration files to configure RethinkDB (e.g. &lt;code&gt;/etc/rethinkdb/instances.d/...&lt;/code&gt;), add &lt;code&gt;cache-size=&amp;lt;limit in MB&amp;gt;&lt;/code&gt; to the configuration file to set the size limit manually.</source>
          <target state="translated">如果您正在使用配置文件来配置RethinkDB（例如 &lt;code&gt;/etc/rethinkdb/instances.d/...&lt;/code&gt; ），请在配置文件中添加 &lt;code&gt;cache-size=&amp;lt;limit in MB&amp;gt;&lt;/code&gt; 以手动设置大小限制。</target>
        </trans-unit>
        <trans-unit id="cdcc580c70eb68dd90fba166fa8fe3d003208dd8" translate="yes" xml:space="preserve">
          <source>If you ask for a nested field that doesn&amp;rsquo;t exist, you will get an empty object or array (this is &lt;em&gt;not&lt;/em&gt; the same as a &lt;code&gt;null&lt;/code&gt; value):</source>
          <target state="translated">如果你问的是不存在的嵌套场，你会得到一个空对象或数组（这是&lt;em&gt;不&lt;/em&gt;一样的一个 &lt;code&gt;null&lt;/code&gt; 值）：</target>
        </trans-unit>
        <trans-unit id="771d3ba57f317fd5733896e2943507e103014c06" translate="yes" xml:space="preserve">
          <source>If you call the &lt;code&gt;stop&lt;/code&gt; method on a &lt;code&gt;Handler&lt;/code&gt;, it will stop processing changes and open streams using that handler will be closed. Queries registered with that handler instance will not be interrupted if they are currently processing (e.g., a batch write), but will close rather than executing after the handler has been stopped.</source>
          <target state="translated">如果在 &lt;code&gt;Handler&lt;/code&gt; 上调用 &lt;code&gt;stop&lt;/code&gt; 方法，它将停止处理更改并关闭使用该处理程序的打开流。如果该处理程序实例中正在注册的查询当前正在处理中（例如，批写入），则该查询不会中断，而是会在处理程序停止后关闭而不是执行。</target>
        </trans-unit>
        <trans-unit id="53db7cb1ddeb0a3b73fa5adb4f52c02474678ca5" translate="yes" xml:space="preserve">
          <source>If you change options in the configuration file, the service will be need to be restarted to pick up the changes.</source>
          <target state="translated">如果你改变了配置文件中的选项,将需要重新启动服务以接收这些变化。</target>
        </trans-unit>
        <trans-unit id="2816abb70037d2cb8f468a1edfbf5eabe5da4f44" translate="yes" xml:space="preserve">
          <source>If you compiled from source, get the &lt;code&gt;init.d&lt;/code&gt; script from &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/init/rethinkdb&quot;&gt;here&lt;/a&gt;. Get the sample &lt;code&gt;.conf&lt;/code&gt; file &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">如果从源代码编译，请从&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/init/rethinkdb&quot;&gt;此处&lt;/a&gt;获取 &lt;code&gt;init.d&lt;/code&gt; 脚本。在&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/packaging/assets/config/default.conf.sample&quot;&gt;此处&lt;/a&gt;获取示例 &lt;code&gt;.conf&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="83708fec6ffb6df17569d9d454fa458ff10ae070" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t install using Homebrew, you&amp;rsquo;ll need to create a launchd configuration file, and decide where you want to store your data files. These instructions assume the following locations:</source>
          <target state="translated">如果您未使用Homebrew进行安装，则需要创建一个启动的配置文件，并确定要将数据文件存储在何处。这些说明假定位于以下位置：</target>
        </trans-unit>
        <trans-unit id="eadc4d652313b1fe2d6ed6344fdf54172fc82742" translate="yes" xml:space="preserve">
          <source>If you do &lt;em&gt;not&lt;/em&gt; use &lt;code&gt;rowFinished&lt;/code&gt;, the &lt;code&gt;rowProcess&lt;/code&gt; callback can end iteration early by returning any value &lt;em&gt;other&lt;/em&gt; than a Promise. If it returns a non-Promise value (other than &lt;code&gt;undefined&lt;/code&gt;), then &lt;code&gt;final&lt;/code&gt; will receive an error object. If it returns a Promise, the Promise will be resolved before iteration continues; if the resolved Promise returns a value, iteration will be stopped and an error object will be passed to &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">如果你&lt;em&gt;不&lt;/em&gt;使用 &lt;code&gt;rowFinished&lt;/code&gt; ，该 &lt;code&gt;rowProcess&lt;/code&gt; 回调可以提前通过返回的任意值结束迭代&lt;em&gt;其他&lt;/em&gt;不是承诺。如果它返回一个非Promise值（ &lt;code&gt;undefined&lt;/code&gt; 除外），则 &lt;code&gt;final&lt;/code&gt; 将收到一个错误对象。如果它返回一个Promise，则该Promise将在迭代继续之前得到解决；如果已解析的Promise返回一个值，则迭代将停止，并且错误对象将传递给 &lt;code&gt;final&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfd2e5e2bd99765946497d8434bb3926deedd62f" translate="yes" xml:space="preserve">
          <source>If you do not find one, treat the argument normally.</source>
          <target state="translated">如果没有找到,就正常处理论证。</target>
        </trans-unit>
        <trans-unit id="e45384aab5ceacddb4ba809043d5294d1d019636" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have the Python driver installed, you can install a previous version using &lt;code&gt;pip install rethinkdb==&amp;lt;version&amp;gt;&lt;/code&gt;. (You can use the &lt;a href=&quot;https://pypi.python.org/pypi/rethinkdb&quot;&gt;Python Package Index&lt;/a&gt; to check on current and older versions.)</source>
          <target state="translated">如果未安装Python驱动程序，则可以使用 &lt;code&gt;pip install rethinkdb==&amp;lt;version&amp;gt;&lt;/code&gt; 。（您可以使用&lt;a href=&quot;https://pypi.python.org/pypi/rethinkdb&quot;&gt;Python软件包索引&lt;/a&gt;来检查当前版本和较旧版本。）</target>
        </trans-unit>
        <trans-unit id="b9550f01fd6cb5bf84e8788a9564ba6ce7305a18" translate="yes" xml:space="preserve">
          <source>If you forget the admin password, it can be changed from the Data Explorer using &lt;code&gt;update&lt;/code&gt; as described above.</source>
          <target state="translated">如果您忘记了管理员密码，则可以使用如上所述的 &lt;code&gt;update&lt;/code&gt; 从Data Explorer更改它。</target>
        </trans-unit>
        <trans-unit id="5ef723651e3c827e99014952458339056d2c209e" translate="yes" xml:space="preserve">
          <source>If you forget to specify the &lt;code&gt;nonAtomic&lt;/code&gt; flag, you will get a &lt;code&gt;ReqlRuntimeError&lt;/code&gt;:</source>
          <target state="translated">如果忘记指定 &lt;code&gt;nonAtomic&lt;/code&gt; 标志，则会得到 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5646d27eb019a3807161da40de3568dc2f4e4197" translate="yes" xml:space="preserve">
          <source>If you have a secondary index built on the field &lt;code&gt;age&lt;/code&gt;, you can run a more efficient query:</source>
          <target state="translated">如果您具有基于field &lt;code&gt;age&lt;/code&gt; 的二级索引，则可以运行更高效的查询：</target>
        </trans-unit>
        <trans-unit id="4c572ebf586ce8e501c48a35b2c6aaa65c043299" translate="yes" xml:space="preserve">
          <source>If you have a secondary index built on the field &lt;code&gt;name&lt;/code&gt;, you can run a more efficient query:</source>
          <target state="translated">如果您在字段 &lt;code&gt;name&lt;/code&gt; 上构建了二级索引，则可以运行更高效的查询：</target>
        </trans-unit>
        <trans-unit id="1235d59d708558b9571a719afc8da5ddd845970f" translate="yes" xml:space="preserve">
          <source>If you have a secondary index, you can use the &lt;a href=&quot;../../../api/javascript/between/index&quot;&gt;between&lt;/a&gt; command in conjunction with &lt;a href=&quot;../../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; and &lt;code&gt;limit&lt;/code&gt;. This is the most efficient way to paginate, but requires looking up values in the secondary index field to find the first record of each page.</source>
          <target state="translated">如果您有二级索引，则可以将&lt;a href=&quot;../../../api/javascript/between/index&quot;&gt;between&lt;/a&gt;命令与&lt;a href=&quot;../../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt;和 &lt;code&gt;limit&lt;/code&gt; 结合使用。这是最有效的分页方法，但是需要在二级索引字段中查找值以找到每个页面的第一条记录。</target>
        </trans-unit>
        <trans-unit id="76ce08c2e0f3f14f3e931d8e20da63959f60afbe" translate="yes" xml:space="preserve">
          <source>If you have a time, you can retrieve a particular portion (like the month, or the hours) relative to the current time zone. (See the full list at the &lt;a href=&quot;https://rethinkdb.com/api&quot;&gt;API reference&lt;/a&gt;.)</source>
          <target state="translated">如果您有时间，则可以检索相对于当前时区的特定部分（例如月份或小时）。（请参阅&lt;a href=&quot;https://rethinkdb.com/api&quot;&gt;API参考上&lt;/a&gt;的完整列表。）</target>
        </trans-unit>
        <trans-unit id="bfe387ee6476daedd31f1f133dde57638c19abdf" translate="yes" xml:space="preserve">
          <source>If you have an index (primary key or secondary index) built on the field of the right table, you can perform a more efficient join with &lt;a href=&quot;../../../api/javascript/eq_join/index&quot;&gt;eqJoin&lt;/a&gt;.</source>
          <target state="translated">如果您在右表的字段上建立了索引（主键或辅助索引），则可以使用&lt;a href=&quot;../../../api/javascript/eq_join/index&quot;&gt;eqJoin&lt;/a&gt;执行更有效的联接。</target>
        </trans-unit>
        <trans-unit id="82e4fe23b378dc14cd8cfd0877cfbc4782c6460c" translate="yes" xml:space="preserve">
          <source>If you have changed the intracluster port from 29015, use the new number. For more guidance, see RethinkDB&amp;rsquo;s &lt;a href=&quot;../cluster-on-startup/index&quot;&gt;cluster setup instructions&lt;/a&gt; and Amazon&amp;rsquo;s documentation on &lt;a href=&quot;http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html&quot;&gt;Security Groups for your VPC&lt;/a&gt;.</source>
          <target state="translated">如果您已将群集内端口从29015更改为新端口号。有关更多指导，请参阅RethinkDB的&lt;a href=&quot;../cluster-on-startup/index&quot;&gt;群集设置说明&lt;/a&gt;和有关&lt;a href=&quot;http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html&quot;&gt;VPC的&lt;/a&gt; Amazon有关安全组的文档。</target>
        </trans-unit>
        <trans-unit id="b9fa29a24142f608f007dabd4548011dc3c49e08" translate="yes" xml:space="preserve">
          <source>If you have changed the intracluster port from 29015, use the new number. For more guidance, see RethinkDB&amp;rsquo;s &lt;a href=&quot;../cluster-on-startup/index&quot;&gt;cluster setup instructions&lt;/a&gt; and Amazon&amp;rsquo;s documentation on &lt;a href=&quot;https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html&quot;&gt;Security Groups for your VPC&lt;/a&gt;.</source>
          <target state="translated">如果您已将群集内端口从29015更改为新端口号。有关更多指导，请参阅RethinkDB的&lt;a href=&quot;../cluster-on-startup/index&quot;&gt;群集设置说明&lt;/a&gt;和有关&lt;a href=&quot;https://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/VPC_SecurityGroups.html&quot;&gt;VPC的&lt;/a&gt;Amazon有关安全组的文档。</target>
        </trans-unit>
        <trans-unit id="05a4aedf88c6ef11885acadb36c80628a3555466" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t already added billing information to your Compose account, you&amp;rsquo;ll be prompted to do so before deployment.</source>
          <target state="translated">如果尚未将帐单信息添加到您的Compose帐户，则系统会提示您先进行添加。</target>
        </trans-unit>
        <trans-unit id="3e16ddb9cd8af200dcaf09b797a43f7f78d9b2f8" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t read the &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;article on changefeeds&lt;/a&gt; yet, start there! You can subscribe to notifications on tables and queries with changefeeds alone, without using publish-subscribe. If you&amp;rsquo;d like to see how to implement a message queue with topics using changefeeds, read on!</source>
          <target state="translated">如果您尚未阅读&lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;有关changefeed&lt;/a&gt;的文章，请从此处开始！您可以仅使用变更订阅源订阅表和查询的通知，而无需使用发布-订阅。如果您想了解如何使用Changefeeds实现带有主题的消息队列，请继续阅读！</target>
        </trans-unit>
        <trans-unit id="288b2d3310d3674f40603201b027dd0c6eb8f2a2" translate="yes" xml:space="preserve">
          <source>If you install RethinkDB using &lt;a href=&quot;http://brew.sh&quot;&gt;Homebrew&lt;/a&gt;, a &lt;code&gt;launchd&lt;/code&gt; configuration file will be installed for you in &lt;code&gt;~/Library/LaunchAgents/&lt;/code&gt;, although that file may need to be modified.</source>
          <target state="translated">如果使用&lt;a href=&quot;http://brew.sh&quot;&gt;Homebrew&lt;/a&gt;安装RethinkDB ，则会在 &lt;code&gt;~/Library/LaunchAgents/&lt;/code&gt; 为您安装一个 &lt;code&gt;launchd&lt;/code&gt; 配置文件，尽管该文件可能需要修改。</target>
        </trans-unit>
        <trans-unit id="b83c2d472c66af5b0f347ebd36a95ea49bff6b87" translate="yes" xml:space="preserve">
          <source>If you install RethinkDB using &lt;a href=&quot;https://brew.sh&quot;&gt;Homebrew&lt;/a&gt;, a &lt;code&gt;launchd&lt;/code&gt; configuration file will be installed for you in &lt;code&gt;~/Library/LaunchAgents/&lt;/code&gt;, although that file may need to be modified.</source>
          <target state="translated">如果使用&lt;a href=&quot;https://brew.sh&quot;&gt;Homebrew&lt;/a&gt;安装RethinkDB ，则会在 &lt;code&gt;~/Library/LaunchAgents/&lt;/code&gt; 为您安装 &lt;code&gt;launchd&lt;/code&gt; 配置文件，尽管该文件可能需要修改。</target>
        </trans-unit>
        <trans-unit id="a5552500ec8d4feb23c54bc6392958bb200d8875" translate="yes" xml:space="preserve">
          <source>If you installed RethinkDB through a package manager on a system that does &lt;em&gt;not&lt;/em&gt; use &lt;code&gt;systemd&lt;/code&gt;, then you may have to check where it&amp;rsquo;s configured to log. It&amp;rsquo;s very likely this will be in the &lt;code&gt;/var/log/&lt;/code&gt; directory (i.e., &lt;code&gt;/var/log/rethinkdb&lt;/code&gt;).</source>
          <target state="translated">如果通过&lt;em&gt;不&lt;/em&gt;使用 &lt;code&gt;systemd&lt;/code&gt; 的系统上的程序包管理器安装了RethinkDB ，则可能必须检查将其配置为记录的位置。这很有可能位于 &lt;code&gt;/var/log/&lt;/code&gt; 目录（即 &lt;code&gt;/var/log/rethinkdb&lt;/code&gt; ）中。</target>
        </trans-unit>
        <trans-unit id="647301df2f1301b87e8dd79c6025e36d6587ac71" translate="yes" xml:space="preserve">
          <source>If you need to do this, you can try passing the &lt;code&gt;--no-secondary-indexes&lt;/code&gt; flag to &lt;code&gt;restore&lt;/code&gt; as a workaround. This will usually allow restores to work on older versions, although this is not guaranteed.</source>
          <target state="translated">如果需要执行此操作，可以尝试传递 &lt;code&gt;--no-secondary-indexes&lt;/code&gt; 标志以作为解决方法进行 &lt;code&gt;restore&lt;/code&gt; 。尽管不能保证，但是这通常将允许还原在较旧的版本上进行。</target>
        </trans-unit>
        <trans-unit id="ddf5f2f153ce1b030eca220c0f0c9358b895c3a9" translate="yes" xml:space="preserve">
          <source>If you need to keep both fields, you can rename them with &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;without&lt;/code&gt; before using the &lt;code&gt;zip&lt;/code&gt; command.</source>
          <target state="translated">如果需要保留两个字段，则可以使用 &lt;code&gt;map&lt;/code&gt; 重命名它们，而 &lt;code&gt;without&lt;/code&gt; 使用 &lt;code&gt;zip&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="0c512f640834e077c4381c35c4c5f5238c4d755c" translate="yes" xml:space="preserve">
          <source>If you need to retrieve only a few specific fields from your documents, you can use the &lt;code&gt;pluck&lt;/code&gt; command. For example, here is how you&amp;rsquo;d return only the fields &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;age&lt;/code&gt; from each row in table &lt;code&gt;users&lt;/code&gt;:</source>
          <target state="translated">如果您只需要从文档中检索几个特定字段，则可以使用 &lt;code&gt;pluck&lt;/code&gt; 命令。例如，这是您仅返回表 &lt;code&gt;users&lt;/code&gt; 中每一行的字段 &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;age&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b75a375a87a4428fc1234e32ea18a55d70c1347d" translate="yes" xml:space="preserve">
          <source>If you pass an ISO 8601 string without a time zone, you must specify the time zone with the &lt;code&gt;defaultTimezone&lt;/code&gt; argument.</source>
          <target state="translated">如果传递不带时区的ISO 8601字符串，则必须使用 &lt;code&gt;defaultTimezone&lt;/code&gt; 参数指定时区。</target>
        </trans-unit>
        <trans-unit id="f596ed1d102ee48cfe38f90920a8a73907a2fff7" translate="yes" xml:space="preserve">
          <source>If you provide a &lt;code&gt;final&lt;/code&gt; callback, it will always be executed when row processing is completed (the end of the sequence is hit, iteration is stopped prematurely, or an error occurs). The &lt;code&gt;final&lt;/code&gt; callback will receive an &lt;code&gt;error&lt;/code&gt; object if an error is thrown or &lt;code&gt;rowProcess&lt;/code&gt; returns any value (other than a Promise). If &lt;code&gt;final&lt;/code&gt; returns any value it will be ignored.</source>
          <target state="translated">如果提供 &lt;code&gt;final&lt;/code&gt; 回调，则它将始终在行处理完成时执行（命中序列的末尾，过早停止迭代或发生错误）。如果引发错误或 &lt;code&gt;rowProcess&lt;/code&gt; 返回任何值（Promise除外），则 &lt;code&gt;final&lt;/code&gt; 回调将收到一个 &lt;code&gt;error&lt;/code&gt; 对象。如果 &lt;code&gt;final&lt;/code&gt; 返回任何值，它将被忽略。</target>
        </trans-unit>
        <trans-unit id="e6396deb74891150f578d1c5de136d0b47288655" translate="yes" xml:space="preserve">
          <source>If you read this document back, you&amp;rsquo;ll get this:</source>
          <target state="translated">如果您阅读本文档，将会得到以下信息：</target>
        </trans-unit>
        <trans-unit id="3f68dcdc1d24865c3b47fc643cd2e0f50d3fbb0a" translate="yes" xml:space="preserve">
          <source>If you remove &lt;em&gt;all&lt;/em&gt; of a server&amp;rsquo;s tags and then reconfigure all the cluster&amp;rsquo;s tables, that server will be taken out of service.</source>
          <target state="translated">如果删除服务器的&lt;em&gt;所有&lt;/em&gt;标记，然后重新配置所有集群的表，则该服务器将停止使用。</target>
        </trans-unit>
        <trans-unit id="c6a74de84425f66a0b769b6d4648c4cc1b05afde" translate="yes" xml:space="preserve">
          <source>If you run a query that returns a grouped stream, it will be automatically converted to grouped data before being sent back to you (there is currently no efficient way to stream groups from RethinkDB). This grouped data is subject to the array size limit, by default 100,000 elements (see &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt; for details on how to use the &lt;code&gt;arrayLimit&lt;/code&gt; option to change this).</source>
          <target state="translated">如果您运行返回分组流的查询，它将被自动转换为分组数据，然后再发送回给您（当前没有有效的方法来从RethinkDB流分组）。分组后的数据受阵列大小限制，默认情况下为100,000个元素（有关如何使用 &lt;code&gt;arrayLimit&lt;/code&gt; 选项更改此设置的详细信息，请参阅&lt;a href=&quot;../run/index&quot;&gt;运行&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="86f33fd9951e9ede0d1ce3032f36a0859998d02f" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;true&lt;/code&gt; for both &lt;code&gt;includeStates&lt;/code&gt; and &lt;code&gt;includeInitial&lt;/code&gt;, the changefeed stream will start with a &lt;code&gt;{state: 'initializing'}&lt;/code&gt; status document, followed by initial values. A &lt;code&gt;{state: 'ready'}&lt;/code&gt; status document will be sent when all the initial values have been sent.</source>
          <target state="translated">如果为 &lt;code&gt;includeStates&lt;/code&gt; 和 &lt;code&gt;includeInitial&lt;/code&gt; 都指定 &lt;code&gt;true&lt;/code&gt; ，则changefeed流将以 &lt;code&gt;{state: 'initializing'}&lt;/code&gt; 状态文档开头，后跟初始值。发送所有初始值后，将发送一个 &lt;code&gt;{state: 'ready'}&lt;/code&gt; 状态文档。</target>
        </trans-unit>
        <trans-unit id="e70f8245f1c68cb85f247cf67565bb8eec8be33c" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;true&lt;/code&gt; for both &lt;code&gt;includeStates&lt;/code&gt; and &lt;code&gt;includeInitial&lt;/code&gt;, the changefeed stream will start with a &lt;code&gt;{state:'initializing'}&lt;/code&gt; status document, followed by initial values. A &lt;code&gt;{state:'ready'}&lt;/code&gt; status document will be sent when all the initial values have been sent.</source>
          <target state="translated">如果为 &lt;code&gt;includeStates&lt;/code&gt; 和 &lt;code&gt;includeInitial&lt;/code&gt; 都指定 &lt;code&gt;true&lt;/code&gt; ，则changefeed流将以 &lt;code&gt;{state:'initializing'}&lt;/code&gt; 状态文档开头，后跟初始值。发送所有初始值后，将发送一个 &lt;code&gt;{state:'ready'}&lt;/code&gt; 状态文档。</target>
        </trans-unit>
        <trans-unit id="2cbddffcc9f00819db397afa4df1b08e38d12bf2" translate="yes" xml:space="preserve">
          <source>If you started &lt;code&gt;rethinkdb&lt;/code&gt; on a terminal rather than from a startup script, it will log to the &lt;code&gt;rethinkdb_data&lt;/code&gt; directory. By default it will write to &lt;code&gt;log_file&lt;/code&gt; but this may be overridden with the &lt;code&gt;--log-file&lt;/code&gt; startup option.</source>
          <target state="translated">如果您是在终端而不是从启动脚本启动 &lt;code&gt;rethinkdb&lt;/code&gt; 的，它将记录到 &lt;code&gt;rethinkdb_data&lt;/code&gt; 目录。默认情况下，它将写入 &lt;code&gt;log_file&lt;/code&gt; ,但是可以使用 &lt;code&gt;--log-file&lt;/code&gt; 启动选项覆盖它。</target>
        </trans-unit>
        <trans-unit id="82ace7a41170ad2855ed92f890913f90ce2fe88d" translate="yes" xml:space="preserve">
          <source>If you subtract two times, you get a duration:</source>
          <target state="translated">如果你减去两次,就会得到一个持续时间。</target>
        </trans-unit>
        <trans-unit id="4ed2b0735a26aa75e5a52e94d19026c65a460278" translate="yes" xml:space="preserve">
          <source>If you support &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; in your driver, then every time you parse the argument of a function you should check if the method can take a function. If it can, you should look for an &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; term (i.e., &lt;code&gt;row&lt;/code&gt;). If you find one, wrap the argument in a function that takes one parameter:</source>
          <target state="translated">如果在驱动程序中支持 &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; ，则每次解析函数的参数时，都应检查该方法是否可以使用函数。如果可以，则应查找 &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; 项（即 &lt;code&gt;row&lt;/code&gt; ）。如果找到一个，则将参数包装在带有一个参数的函数中：</target>
        </trans-unit>
        <trans-unit id="7e555f9a01208c3228041f9a60ea0708846725a6" translate="yes" xml:space="preserve">
          <source>If you try to serialize a document containing a ReQL time zone object using Python&amp;rsquo;s &lt;code&gt;json&lt;/code&gt; library, you may receive this error. Solve this by passing the &lt;code&gt;time_format=&quot;raw&quot;&lt;/code&gt; option to &lt;code&gt;run&lt;/code&gt;:</source>
          <target state="translated">如果您尝试使用Python的 &lt;code&gt;json&lt;/code&gt; 库序列化包含ReQL时区对象的文档，则可能会收到此错误。通过传递 &lt;code&gt;time_format=&quot;raw&quot;&lt;/code&gt; 选项 &lt;code&gt;run&lt;/code&gt; 解决此问题：</target>
        </trans-unit>
        <trans-unit id="a69fd118d720c0b3ef04383826f0c9000327522b" translate="yes" xml:space="preserve">
          <source>If you use arrays as indexes (compound indexes), they will be sorted using &lt;a href=&quot;https://en.wikipedia.org/wiki/Lexicographical_order&quot;&gt;lexicographical order&lt;/a&gt;. Take the following range as an example:</source>
          <target state="translated">如果将数组用作索引（复合索引），则将使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Lexicographical_order&quot;&gt;字典顺序&lt;/a&gt;对其进行排序。以以下范围为例：</target>
        </trans-unit>
        <trans-unit id="137368e26abb11bd3729cf72ed538f86d0b76bb7" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;zip&lt;/code&gt; command after &lt;code&gt;join&lt;/code&gt;, the document from the right table will be merged into the left one.</source>
          <target state="translated">如果在 &lt;code&gt;join&lt;/code&gt; 后使用 &lt;code&gt;zip&lt;/code&gt; 命令，则右表中的文档将合并到左表中。</target>
        </trans-unit>
        <trans-unit id="faa0c1937c2c1e18853e93e9c38fa77f7753e71f" translate="yes" xml:space="preserve">
          <source>If you use this option on the server, the client must use a secure connection as well. Pass the certificate information in the &lt;code&gt;ssl&lt;/code&gt; option to the &lt;code&gt;connect&lt;/code&gt; ReQL command; read the API documentation for &lt;a href=&quot;../../api/javascript/connect/index&quot;&gt;connect&lt;/a&gt; for details on your language&amp;rsquo;s specific syntax.</source>
          <target state="translated">如果在服务器上使用此选项，则客户端也必须使用安全连接。将 &lt;code&gt;ssl&lt;/code&gt; 选项中的证书信息传递给 &lt;code&gt;connect&lt;/code&gt; ReQL命令；请阅读API文档进行&lt;a href=&quot;../../api/javascript/connect/index&quot;&gt;连接，&lt;/a&gt;以获取有关您语言特定语法的详细信息。</target>
        </trans-unit>
        <trans-unit id="8933a5a5bc42ce744657eae9a0d136b21cd536e8" translate="yes" xml:space="preserve">
          <source>If you want an exact match for a field that is an object, you will have to use &lt;code&gt;r.literal&lt;/code&gt;.</source>
          <target state="translated">如果要与作为对象的字段完全匹配，则必须使用 &lt;code&gt;r.literal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42f06f6a06529fafebf5726831ab492c1731013d" translate="yes" xml:space="preserve">
          <source>If you want to operate on all the groups rather than operating on each group (e.g. if you want to order the groups by their reduction), you can use &lt;a href=&quot;../ungroup/index&quot;&gt;ungroup&lt;/a&gt; to turn a grouped stream or grouped data into an array of objects representing the groups.</source>
          <target state="translated">如果要对所有组进行操作而不是对每个组进行操作（例如，如果&lt;a href=&quot;../ungroup/index&quot;&gt;要按&lt;/a&gt;组的减少顺序对其进行排序），则可以使用ungroup将已分组的流或已分组的数据转换为表示组的对象数组。</target>
        </trans-unit>
        <trans-unit id="8e46c1955c2c8d4036f94c039e2a8a144057b763" translate="yes" xml:space="preserve">
          <source>If you want to perform a query that returns aggregations on different fields together, this is a canonical use case for &lt;a href=&quot;../../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt;.</source>
          <target state="translated">如果要执行一个查询，以一起返回不同字段上的聚合，则这是&lt;a href=&quot;../../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt;的典型用例。</target>
        </trans-unit>
        <trans-unit id="ffc292f977df5974c81cb7f1681982162644cd6e" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all the posts with the primary keys &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt; you can use the &lt;code&gt;getAll&lt;/code&gt; command:</source>
          <target state="translated">如果你想检索所有的主键的帖子 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ，或 &lt;code&gt;3&lt;/code&gt; ，你可以使用 &lt;code&gt;getAll&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="dbbd54db4f2738a27bb5bf620810ae9c295fee97" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all users whose last name contains &amp;ldquo;ll&amp;rdquo;, you can use &lt;code&gt;r.match&lt;/code&gt; this way:</source>
          <target state="translated">如果要检索姓氏包含&amp;ldquo; ll&amp;rdquo;的所有用户，则可以通过以下方式使用 &lt;code&gt;r.match&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="57d32ed6842f8937bfbfb6135067bdf013914ba5" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all users whose last name ends with an &amp;ldquo;s&amp;rdquo;, you can use &lt;code&gt;r.match&lt;/code&gt; this way:</source>
          <target state="translated">如果要检索所有姓氏以&amp;ldquo; s&amp;rdquo;结尾的用户，则可以通过以下方式使用 &lt;code&gt;r.match&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5955d5b29355702e414b30489a1bf41c4ff4157d" translate="yes" xml:space="preserve">
          <source>If you want to retrieve all users whose last name starts with &amp;ldquo;Ma&amp;rdquo;, you can use &lt;code&gt;r.match&lt;/code&gt; this way:</source>
          <target state="translated">如果要检索所有姓氏以&amp;ldquo; Ma&amp;rdquo;开头的用户，则可以通过以下方式使用 &lt;code&gt;r.match&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="33be99218ff191c90e1b3baa8c8578229b913813" translate="yes" xml:space="preserve">
          <source>If you want to uninstall the RethinkDB service:</source>
          <target state="translated">如果你想卸载RethinkDB服务。</target>
        </trans-unit>
        <trans-unit id="c0bc2c2dcf06bfff997e2c4a74f6f884030f7aba" translate="yes" xml:space="preserve">
          <source>If you want to use a prefix notation, you just need to implement all the commands on a module. If you want to use an infix notation, you should implement all the functions on a class &amp;ldquo;term&amp;rdquo; and some prefix commands on the module.</source>
          <target state="translated">如果要使用前缀表示法，则只需在模块上实现所有命令。如果要使用中缀表示法，则应在&amp;ldquo; term&amp;rdquo;类上实现所有功能，并在模块上实现一些前缀命令。</target>
        </trans-unit>
        <trans-unit id="9be25802011254b9d2a1331968b140867a7a3dff" translate="yes" xml:space="preserve">
          <source>If you wanted to receive &lt;em&gt;all&lt;/em&gt; the changes, including the interim states, you could do so by passing &lt;code&gt;squash: false&lt;/code&gt;. The server will buffer up to 100,000 changes. (This number can be changed with the &lt;code&gt;changefeedQueueSize&lt;/code&gt; optional argument.)</source>
          <target state="translated">如果要接收&lt;em&gt;所有&lt;/em&gt;更改，包括过渡状态，可以通过传递 &lt;code&gt;squash: false&lt;/code&gt; 。服务器将缓冲多达100,000个更改。（可以使用 &lt;code&gt;changefeedQueueSize&lt;/code&gt; 可选参数更改此数字。）</target>
        </trans-unit>
        <trans-unit id="0bfcf6ae6bbb104a8f2d9363a057e7ab252bf34a" translate="yes" xml:space="preserve">
          <source>If you wish other locations, change the text in the file appropriately.</source>
          <target state="translated">如果你想要其他的位置,请适当修改文件中的文字。</target>
        </trans-unit>
        <trans-unit id="683e445d7ef31ffd6276aee46241b7bc6d8c2d1d" translate="yes" xml:space="preserve">
          <source>If you wish to find all points within a certain radius of another point, it&amp;rsquo;s often faster to use &lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt; with &lt;a href=&quot;../circle/index&quot;&gt;circle&lt;/a&gt;, as long as the approximation of a circle that &lt;code&gt;circle&lt;/code&gt; generates is sufficient.</source>
          <target state="translated">如果希望找到另一个点的某个半径范围内的所有点，则将&lt;a href=&quot;../get_intersecting/index&quot;&gt;getIntersecting&lt;/a&gt;与&lt;a href=&quot;../circle/index&quot;&gt;circle&lt;/a&gt;一起使用通常会更快，只要可以逼近 &lt;code&gt;circle&lt;/code&gt; 生成的一个圆形就足够了。</target>
        </trans-unit>
        <trans-unit id="7524784d2e4a2810021fbd5dcbfcfdac73a9720d" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re doing ad-hoc analysis and know your table won&amp;rsquo;t have more then 100,000 elements (or you&amp;rsquo;ve changed the setting of the &lt;code&gt;array_limit&lt;/code&gt; option for &lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt;) you can run &lt;code&gt;orderBy&lt;/code&gt; without an index:</source>
          <target state="translated">如果您正在进行临时分析，并且知道您的表中不会有超过100,000个元素（或者您已将 &lt;code&gt;array_limit&lt;/code&gt; 选项的设置更改为&lt;a href=&quot;../run/index&quot;&gt;run&lt;/a&gt;），则可以运行不带索引的 &lt;code&gt;orderBy&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7e6a5888fe6d36406b5d6e9972fc8df495ab5b94" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re running RethinkDB on Linux and see a &amp;ldquo;Data from a process on this server has been placed into swap memory&amp;rdquo; warning in the &lt;a href=&quot;../system-issues/index#memory-availability-issues&quot;&gt;System issues table&lt;/a&gt; even though your server has RAM available, it&amp;rsquo;s possible you need to adjust the &lt;code&gt;swappiness&lt;/code&gt; kernel parameter. A swappiness setting of 0 prevents swap space from being used unless the server is completely out of physical memory; a setting of 100 uses swap space all the time. To check the swappiness of your kernel:</source>
          <target state="translated">如果您在Linux上运行RethinkDB，并且即使服务器具有RAM，则在&amp;ldquo;&lt;a href=&quot;../system-issues/index#memory-availability-issues&quot;&gt;系统问题&amp;rdquo;表中&lt;/a&gt;看到&amp;ldquo;此服务器上的进程中的数据已放入交换内存&amp;rdquo;警告，则可能需要调整 &lt;code&gt;swappiness&lt;/code&gt; 内核参数。swappiness设置为0会阻止使用交换空间，除非服务器完全没有物理内存。设置为100会一直使用交换空间。要检查内核的可交换性：</target>
        </trans-unit>
        <trans-unit id="6ff79c17332249a5d857f8a257aa944f0b925e14" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re setting up a cluster in a secure environment (for instance, the whole cluster is on a local network behind a firewall), you can simply start the servers in the cluster without an admin password, then update the &lt;code&gt;admin&lt;/code&gt; record in the &lt;code&gt;users&lt;/code&gt; table with a new password. However, if you&amp;rsquo;re joining a new server to a cluster that&amp;rsquo;s already password-protected, the best way to do it is to specify the &lt;code&gt;--initial-password auto&lt;/code&gt; option.</source>
          <target state="translated">如果要在安全的环境中设置群集（例如，整个群集位于防火墙后面的本地网络中），则可以简单地启动群集中的服务器而无需管理员密码，然后在服务器中更新 &lt;code&gt;admin&lt;/code&gt; 记录。 &lt;code&gt;users&lt;/code&gt; 表使用新密码。但是，如果要将新服务器加入到已经受密码保护的群集中，最好的方法是指定 &lt;code&gt;--initial-password auto&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="456807bd4deabd7fb0d4e595a0e89ba5793a3a63" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re trying to run the RethinkDB JavaScript driver on an older version of Node.js, you might get an error similar to this one:</source>
          <target state="translated">如果尝试在较旧版本的Node.js上运行RethinkDB JavaScript驱动程序，则可能会收到与以下错误类似的错误：</target>
        </trans-unit>
        <trans-unit id="0a0ba4242f24cd3660d34b716dd663972fe09358" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt;, the proxy will de-duplicate changefeed messages sent from other cluster nodes, further reducing traffic.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt;，则代理将对从其他群集节点发送的changefeed消息进行重复数据删除，从而进一步减少流量。</target>
        </trans-unit>
        <trans-unit id="3b39a010075ff223dcb6231c15f5807cd083e75c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;, the proxy will de-duplicate changefeed messages sent from other cluster nodes, further reducing traffic.</source>
          <target state="translated">如果您使用的是&lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;，则代理将重复删除从其他群集节点发送的changefeed消息，从而进一步减少流量。</target>
        </trans-unit>
        <trans-unit id="f62e60bf0cc80777903c60849396bf97f6d61d7f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a command that returns a stream and want to retrieve all of its results at once in an array rather than iterating through them with the cursor object, you can coerce it to an array using the &lt;a href=&quot;../../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt; command.</source>
          <target state="translated">如果使用返回流的命令，并且想一次在数组中检索所有结果，而不是使用游标对象遍历它们，则可以使用&lt;a href=&quot;../../../api/javascript/to_array/index&quot;&gt;toArray&lt;/a&gt;命令将其强制为数组。</target>
        </trans-unit>
        <trans-unit id="bacb25a3674084c03c251e600233179fe60bd947" translate="yes" xml:space="preserve">
          <source>If your Linux system uses &lt;code&gt;systemd&lt;/code&gt;, use &lt;code&gt;journalctl&lt;/code&gt; to view the log:</source>
          <target state="translated">如果您的Linux系统使用 &lt;code&gt;systemd&lt;/code&gt; ，请使用 &lt;code&gt;journalctl&lt;/code&gt; 查看日志：</target>
        </trans-unit>
        <trans-unit id="da2db0981a7397bff51112a1fc945fe4ca7b2b8f" translate="yes" xml:space="preserve">
          <source>If your cluster has at least three servers, then in most cases RethinkDB will be able to perform automatic failover and maintain table availability.</source>
          <target state="translated">如果你的集群至少有三台服务器,那么在大多数情况下,RethinkDB将能够执行自动故障转移并维持表的可用性。</target>
        </trans-unit>
        <trans-unit id="b49541bdff3c285637a61fef077a63e1f69a37fc" translate="yes" xml:space="preserve">
          <source>If your driver uses infix notation, you must make sure that the &lt;code&gt;VAR&lt;/code&gt; term implements all the ReQL methods.</source>
          <target state="translated">如果您的驱动程序使用中缀表示法，则必须确保 &lt;code&gt;VAR&lt;/code&gt; 术语实现所有ReQL方法。</target>
        </trans-unit>
        <trans-unit id="350e9574e2ae89a26fa9dc3cc454a0ede0acc59d" translate="yes" xml:space="preserve">
          <source>If your network is open to the internet, you should take additional precautions. See the &lt;a href=&quot;../security/index&quot;&gt;security page&lt;/a&gt; for more details.</source>
          <target state="translated">如果您的网络对Internet开放，则应采取其他预防措施。有关更多详细信息，请参见&lt;a href=&quot;../security/index&quot;&gt;安全性页面&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="366849b7e0bac319320d290f73d9827bd3539c9b" translate="yes" xml:space="preserve">
          <source>If your platform isn&amp;rsquo;t listed here, you may still be able to build from source. You should be able to build RethinkDB on most Linux-based systems&amp;mdash;check out the generic &lt;a href=&quot;https://rethinkdb.com/docs/build&quot;&gt;build instructions&lt;/a&gt;. If you get RethinkDB running on your platform, please &lt;a href=&quot;https://rethinkdb.com/community&quot;&gt;contribute&lt;/a&gt; a package!</source>
          <target state="translated">如果您的平台未在此处列出，则您仍然可以从源代码进行构建。您应该能够在大多数基于Linux的系统上构建RethinkDB，请查阅通用的&lt;a href=&quot;https://rethinkdb.com/docs/build&quot;&gt;构建说明&lt;/a&gt;。如果您的平台上运行的是RethinkDB，请&lt;a href=&quot;https://rethinkdb.com/community&quot;&gt;提供&lt;/a&gt;一个软件包！</target>
        </trans-unit>
        <trans-unit id="23b1ba702365541b74287007a736458d67c4eaea" translate="yes" xml:space="preserve">
          <source>If your program frequently executes a &lt;a href=&quot;../../../api/javascript/get_all/index&quot;&gt;getAll&lt;/a&gt; followed by a &lt;a href=&quot;../../../api/javascript/contains/index&quot;&gt;contains&lt;/a&gt;, that operation can be made more efficient by creating a compound multi index using a mapping function on the field that contains the list.</source>
          <target state="translated">如果您的程序经常执行&lt;a href=&quot;../../../api/javascript/get_all/index&quot;&gt;getAll&lt;/a&gt;后跟一个&lt;a href=&quot;../../../api/javascript/contains/index&quot;&gt;contains&lt;/a&gt;，则可以通过在包含列表的字段上使用映射函数创建复合多重索引来提高该操作的效率。</target>
        </trans-unit>
        <trans-unit id="d0f7491313b584ad1d089f9d22913b45b26e6b14" translate="yes" xml:space="preserve">
          <source>If your timestamps are stored with time zones, this query will work even if you have sales from different offices in different countries (assuming they all work 9-5 local time).</source>
          <target state="translated">如果你的时间戳是按时区存储的,即使你的销售人员来自不同国家的不同办事处,这个查询也会有效(假设他们都是当地时间9-5工作)。</target>
        </trans-unit>
        <trans-unit id="6768eab9c379c5663aede0e10ef2910ddbacc359" translate="yes" xml:space="preserve">
          <source>Ignored host: (remove everything)</source>
          <target state="translated">忽略的主机:(删除所有内容)</target>
        </trans-unit>
        <trans-unit id="00b783520a8a2fbc5645a580ba36a3a286254053" translate="yes" xml:space="preserve">
          <source>Implementation Details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="7830d9e83bdb571cca1e50f542e8516184aeb2bf" translate="yes" xml:space="preserve">
          <source>Implementation considerations</source>
          <target state="translated">执行方面的考虑</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">实施细节</target>
        </trans-unit>
        <trans-unit id="48c76de824c667c812b20e68b2adc022b6cc3927" translate="yes" xml:space="preserve">
          <source>Implementing pagination</source>
          <target state="translated">实施分页</target>
        </trans-unit>
        <trans-unit id="4b9473d2b75bfa42436746f65c8c33b98460fd54" translate="yes" xml:space="preserve">
          <source>Import the data into the new version of RethinkDB</source>
          <target state="translated">将数据导入到新版RethinkDB中。</target>
        </trans-unit>
        <trans-unit id="238711b7dea1818e5597c84c0a73743721ecdeb7" translate="yes" xml:space="preserve">
          <source>Import the driver</source>
          <target state="translated">导入驱动程序</target>
        </trans-unit>
        <trans-unit id="017c247df6b2b83d4d9a69a49f09f95bae03a6a1" translate="yes" xml:space="preserve">
          <source>Importing data</source>
          <target state="translated">导入数据</target>
        </trans-unit>
        <trans-unit id="e2edf793f8ceb332bdd4099e91b0d561315566da" translate="yes" xml:space="preserve">
          <source>Importing from a directory is only supported for directories created by the &lt;code&gt;rethinkdb export&lt;/code&gt; command.</source>
          <target state="translated">仅通过 &lt;code&gt;rethinkdb export&lt;/code&gt; 命令创建的目录支持从目录导入。</target>
        </trans-unit>
        <trans-unit id="9f1cdd2fcf75bc422b05e6de9e62859e98a52259" translate="yes" xml:space="preserve">
          <source>Importing your data</source>
          <target state="translated">导入您的数据</target>
        </trans-unit>
        <trans-unit id="b2365d482c0ea18f41ce8c42a7403d51a41e4cae" translate="yes" xml:space="preserve">
          <source>Improve this doc</source>
          <target state="translated">完善本文档</target>
        </trans-unit>
        <trans-unit id="a2b4972775d63230221d59d42b6e919bd9b4dc33" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;saveFile&lt;/code&gt;, we pass a path to the uploaded file (which may be in a temporary storage directory, even with a temporary name depending on the uploading library we&amp;rsquo;ve used), the name to save the file with, and the id of the user who&amp;rsquo;s uploaded the file. The &lt;a href=&quot;../../../api/javascript/binary/index&quot;&gt;binary&lt;/a&gt; ReQL command is used to store the file&amp;rsquo;s contents as a binary object in the &lt;code&gt;file&lt;/code&gt; field.</source>
          <target state="translated">在 &lt;code&gt;saveFile&lt;/code&gt; 中，我们将路径传递到上载的文件（该文件可能在临时存储目录中，甚至具有临时名称，具体取决于我们使用的上载库），保存文件的名称以及文件的ID。上传文件的用户。的&lt;a href=&quot;../../../api/javascript/binary/index&quot;&gt;二进制&lt;/a&gt; ReQL命令用于该文件的内容存储为在一个二进制对象 &lt;code&gt;file&lt;/code&gt; 字段。</target>
        </trans-unit>
        <trans-unit id="ab75b66b21721ea02b5f1190366112cfa1b49ce9" translate="yes" xml:space="preserve">
          <source>In JavaScript you can use the operator &lt;code&gt;()&lt;/code&gt; to get the value of a field. This operator can be chained to retrieve values from nested fields.</source>
          <target state="translated">在JavaScript中，您可以使用运算符 &lt;code&gt;()&lt;/code&gt; 来获取字段的值。可以将此操作符链接起来，以从嵌套字段中检索值。</target>
        </trans-unit>
        <trans-unit id="4b8d71b1ae4e957e1c701dd6a29e28ae62e6fa5a" translate="yes" xml:space="preserve">
          <source>In ReQL, you can chain commands at the end of other commands using the &lt;code&gt;.&lt;/code&gt; operator:</source>
          <target state="translated">在ReQL中，您可以使用链接其他命令末尾的命令 &lt;code&gt;.&lt;/code&gt; 操作员：</target>
        </trans-unit>
        <trans-unit id="d7e11373b98a35ae62612e925d7efc50e57e385c" translate="yes" xml:space="preserve">
          <source>In RethinkDB, if there is a network partition, the behavior of the system from any given client&amp;rsquo;s perspective depends on which side of the netsplit that client is on. If the client is on the same side of the netsplit as the majority of voting replicas for the shard the client is trying to reach, it will continue operating without any problems. If the client is on the side of the netsplit with half or fewer of the voting replicas for the shard the client is trying to reach, the client&amp;rsquo;s up-to-date queries and write queries will encounter a failure of availability. For example, if the client is running an up-to-date range query that spans multiple shards, the primaries for all shards must be on the same side of the netsplit as the client, or the client will encounter a failure of availability.</source>
          <target state="translated">在RethinkDB中，如果存在网络分区，则从任何给定客户端的角度来看，系统的行为都取决于该客户端位于netsplit的哪一侧。如果客户端与客户端尝试访问的分片的大多数有表决权副本位于网络拆分的同一侧，则它将继续运行而不会出现任何问题。如果客户端位于netsplit的一侧，且客户端尝试访问的分片的投票副本的一半或更少，则客户端的最新查询和写入查询将遇到可用性故障。例如，如果客户端正在运行跨多个分片的最新范围查询，则所有分片的主键必须与客户端在netsplit的同一侧，否则客户端将遇到可用性故障。</target>
        </trans-unit>
        <trans-unit id="53975b0e82ce0d86ca8d9057bdbb663e9bcafe56" translate="yes" xml:space="preserve">
          <source>In RethinkDB, map-reduce queries operate on sequences and are composed of two or three parts:</source>
          <target state="translated">在RethinkDB中,map-reduce查询对序列进行操作,并且由两部分或三部分组成。</target>
        </trans-unit>
        <trans-unit id="e547e43d492374793f980136c4cf014cfc49388d" translate="yes" xml:space="preserve">
          <source>In Ruby, you would use a block:</source>
          <target state="translated">在Ruby中,你会使用一个块。</target>
        </trans-unit>
        <trans-unit id="1f616f120c6b02696c4b0366e3aece768d2e56d2" translate="yes" xml:space="preserve">
          <source>In a many to many relation, we can use multiple &lt;code&gt;eq_join&lt;/code&gt; commands to join the data from all three tables:</source>
          <target state="translated">在多对多关系中，我们可以使用多个 &lt;code&gt;eq_join&lt;/code&gt; 命令来联接来自所有三个表的数据：</target>
        </trans-unit>
        <trans-unit id="b8a1f7a4ae7bafa4f994ca4dcbba5e5033b936cc" translate="yes" xml:space="preserve">
          <source>In a relational database, we&amp;rsquo;d use a &lt;code&gt;JOIN&lt;/code&gt; here; in RethinkDB, we use the &lt;code&gt;eq_join&lt;/code&gt; command. To get all posts along with the author information for William Adama:</source>
          <target state="translated">在关系数据库中，我们将在此处使用 &lt;code&gt;JOIN&lt;/code&gt; ；在RethinkDB中，我们使用 &lt;code&gt;eq_join&lt;/code&gt; 命令。要获取所有帖子以及William Adama的作者信息，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="0017c83cf17c2e2c74f552cbefb9d78035ec322b" translate="yes" xml:space="preserve">
          <source>In addition to commands described here, ReQL supports a number of sophisticated commands that are composable similarly to the commands described here. See the following documentation for more details:</source>
          <target state="translated">除了这里描述的命令外,ReQL还支持一些复杂的命令,这些命令与这里描述的命令类似,是可以合成的。更多的细节请看下面的文档。</target>
        </trans-unit>
        <trans-unit id="69b56eab4e915ecae6acc17c1b920e1f95e8dda6" translate="yes" xml:space="preserve">
          <source>In addition to the simple &lt;code&gt;on_val&lt;/code&gt; method, you can provide methods that specifically apply to arrays, streams and atoms.</source>
          <target state="translated">除了简单的 &lt;code&gt;on_val&lt;/code&gt; 方法，您还可以提供专门适用于数组，流和原子的方法。</target>
        </trans-unit>
        <trans-unit id="e832c720b5396283b4982d091435fc8a17a57bae" translate="yes" xml:space="preserve">
          <source>In addition, RethinkDB&amp;rsquo;s cursors and feeds implement an &lt;a href=&quot;../../api/javascript/ee-cursor/index&quot;&gt;EventEmitter interface&lt;/a&gt; compatible with Node&amp;rsquo;s. This allows your application to set up listeners to receive data from queries as the data becomes available.</source>
          <target state="translated">另外，RethinkDB的游标和提要实现与Node兼容的&lt;a href=&quot;../../api/javascript/ee-cursor/index&quot;&gt;EventEmitter接口&lt;/a&gt;。这使您的应用程序可以设置侦听器，以在数据可用时从查询接收数据。</target>
        </trans-unit>
        <trans-unit id="ac43c6179eddd9e0aa83a1d0f3a033887a74a4d9" translate="yes" xml:space="preserve">
          <source>In addition, like most NoSQL systems, RethinkDB does not support updating multiple documents atomically.</source>
          <target state="translated">此外,和大多数NoSQL系统一样,RethinkDB不支持原子式更新多个文档。</target>
        </trans-unit>
        <trans-unit id="482ca37f4f75fe52405c7f2363070d3ac96941cf" translate="yes" xml:space="preserve">
          <source>In addition, the following two fields are set as circumstances dictate:</source>
          <target state="translated">此外,根据情况需要设置以下两个字段:</target>
        </trans-unit>
        <trans-unit id="dfeb6cb29bcc9b1be788874544634d9e422e0566" translate="yes" xml:space="preserve">
          <source>In addition, there are changefeed-specific methods that may be defined.</source>
          <target state="translated">此外,还可以定义一些特定的变更馈送方法。</target>
        </trans-unit>
        <trans-unit id="7e9c26359d4eb826c3e725e35c3b93e27549d853" translate="yes" xml:space="preserve">
          <source>In addition, there&amp;rsquo;s a &amp;ldquo;pseudotype&amp;rdquo; called &lt;strong&gt;geometry&lt;/strong&gt; which appears in documentation, to indicate that any of the geometric objects can be used with those commands.</source>
          <target state="translated">另外，在文档中出现了一个名为&lt;strong&gt;geometry&lt;/strong&gt;的&amp;ldquo;伪类型&amp;rdquo; ，以指示任何几何对象都可以与这些命令一起使用。</target>
        </trans-unit>
        <trans-unit id="1d97d60a0bcfdd4c2631d5518ed2ed0252cb8e11" translate="yes" xml:space="preserve">
          <source>In an arithmetic shift (also referred to as signed shift), like a logical shift, the bits that slide off the end disappear (except for the last, which goes into the carry flag). But in an arithmetic shift, the spaces are filled in such a way to preserve the sign of the number being slid. For this reason, arithmetic shifts are better suited for signed numbers in two&amp;rsquo;s complement format.</source>
          <target state="translated">在算术移位（也称为有符号移位）中，就像逻辑移位一样，从末尾滑落的位会消失（最后一位除外，该位进入进位标志）。但是，在算术转换中，空格会以保留数字滑动符号的方式填充。因此，算术移位更适合于二进制补码格式的有符号数。</target>
        </trans-unit>
        <trans-unit id="323e806a49b60c04ba3804b1c03762d7b82fb862" translate="yes" xml:space="preserve">
          <source>In both cases, each documents is a JSON object, bracketed with &lt;code&gt;{ }&lt;/code&gt; characters. Only the first format is itself a valid JSON document, but RethinkDB will import documents properly either way.</source>
          <target state="translated">在这两种情况下，每个文档都是一个JSON对象，并用 &lt;code&gt;{ }&lt;/code&gt; 字符括起来。只有第一种格式本身就是有效的JSON文档，但是RethinkDB会以任何一种方式正确导入文档。</target>
        </trans-unit>
        <trans-unit id="98129ae214b9438711e0e318ef2278075825e480" translate="yes" xml:space="preserve">
          <source>In both cases, each documents is a JSON object, bracketed with &lt;code&gt;{}&lt;/code&gt; characters. Only the first format is itself a valid JSON document, but RethinkDB will import documents properly either way.</source>
          <target state="translated">在这两种情况下，每个文档都是一个JSON对象，并用 &lt;code&gt;{}&lt;/code&gt; 个字符括起来。只有第一种格式本身就是有效的JSON文档，但是RethinkDB会以任何一种方式正确导入文档。</target>
        </trans-unit>
        <trans-unit id="22394df195b3edd891870077561851c540a2351b" translate="yes" xml:space="preserve">
          <source>In case you found a vulnerability</source>
          <target state="translated">如果你发现了一个漏洞</target>
        </trans-unit>
        <trans-unit id="3aacc2c5441ad29368ece646c1428ab06b82d543" translate="yes" xml:space="preserve">
          <source>In case you found vulnerability or security issue in one of the drivers or the database, please do not publish it, instead, contact us via e-mail at &lt;a href=&quot;mailto:security@rethinkdb.com&quot;&gt;security@rethinkdb.com&lt;/a&gt;. We will take the necessary steps to fix the issue. We are handling the vulnerabilities privately to keep our users&amp;rsquo; data as safe as we can.</source>
          <target state="translated">如果您在驱动程序或数据库之一中发现漏洞或安全问题，请不要发布它，而是通过电子邮件&lt;a href=&quot;mailto:security@rethinkdb.com&quot;&gt;security@rethinkdb.com&lt;/a&gt;与我们联系。我们将采取必要的步骤解决此问题。我们正在私下处理漏洞，以尽可能确保我们用户数据的安全。</target>
        </trans-unit>
        <trans-unit id="773635fe0eb58ef5487b10a80b4676b6c55ed2df" translate="yes" xml:space="preserve">
          <source>In case you have any further questions regarding vulnerability reporting, feel free to open an &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/new&quot;&gt;issue&lt;/a&gt; on GitHub.</source>
          <target state="translated">如果您对漏洞报告还有其他疑问，请随时在GitHub上打开一个&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/new&quot;&gt;问题&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b0a086d5882f5f0f06698c6203f1af04758586d8" translate="yes" xml:space="preserve">
          <source>In cases where it matters, the system should give administrators fine-tuned control, such as pinning specific primary and secondary replicas to specific servers in the cluster.</source>
          <target state="translated">在重要的情况下,系统应该给管理员提供细微的控制,比如将特定的主复制和辅助复制钉在集群中的特定服务器上。</target>
        </trans-unit>
        <trans-unit id="5b00ccdfaea40371a01b81bb7dc1bad4ad740441" translate="yes" xml:space="preserve">
          <source>In each configuration file, set a different data directory, and include the &lt;code&gt;join&lt;/code&gt; configuration option for each node with the IP address and port of another node in the cluster. If the instances are not running on the same machine, specify &lt;code&gt;bind=all&lt;/code&gt; in the configuration file (or &lt;code&gt;--bind all&lt;/code&gt; on the command line). Take care that each instance on the same machine specifies different values for &lt;code&gt;driver-port&lt;/code&gt;, &lt;code&gt;cluster-port&lt;/code&gt; and &lt;code&gt;http-port&lt;/code&gt;.</source>
          <target state="translated">在每个配置文件中，设置一个不同的数据目录，并为每个节点包括 &lt;code&gt;join&lt;/code&gt; 配置选项，以及群集中另一个节点的IP地址和端口。如果实例不在同一台计算机上运行，​​请在配置文件中指定 &lt;code&gt;bind=all&lt;/code&gt; （或在命令行上 &lt;code&gt;--bind all&lt;/code&gt; ）。请注意，同一台计算机上的每个实例为 &lt;code&gt;driver-port&lt;/code&gt; ， &lt;code&gt;cluster-port&lt;/code&gt; 和 &lt;code&gt;http-port&lt;/code&gt; 指定不同的值。</target>
        </trans-unit>
        <trans-unit id="ab3aa8875b25a2ffc4aedb33806133ea9bef7d9c" translate="yes" xml:space="preserve">
          <source>In general, operations on grouped streams will be efficiently distributed, and operations on grouped data won&amp;rsquo;t be. You can figure out what you&amp;rsquo;re working with by putting &lt;code&gt;typeOf&lt;/code&gt; on the end of your query. Below are efficient and inefficient examples.</source>
          <target state="translated">通常，对分组流的操作将得到有效分配，而对分组数据的操作将不会有效地分布。您可以通过将 &lt;code&gt;typeOf&lt;/code&gt; 放在查询末尾来弄清楚正在使用什么。以下是有效和无效的示例。</target>
        </trans-unit>
        <trans-unit id="f054beb39982d96498daad23e2a815f6da2c843d" translate="yes" xml:space="preserve">
          <source>In general, you&amp;rsquo;ll have to follow these steps:</source>
          <target state="translated">通常，您必须执行以下步骤：</target>
        </trans-unit>
        <trans-unit id="de3c73ba8ae404d459a86a8fedcb02be56388736" translate="yes" xml:space="preserve">
          <source>In its first form, &lt;code&gt;fold&lt;/code&gt; operates like &lt;a href=&quot;../reduce/index&quot;&gt;reduce&lt;/a&gt;, returning a value by applying a combining function to each element in a sequence. The combining function takes two parameters: the previous reduction result (the accumulator) and the current element. However, &lt;code&gt;fold&lt;/code&gt; has the following differences from &lt;code&gt;reduce&lt;/code&gt;:</source>
          <target state="translated">在第一种形式中， &lt;code&gt;fold&lt;/code&gt; 的操作类似于&lt;a href=&quot;../reduce/index&quot;&gt;reduce&lt;/a&gt;，通过将组合函数应用于序列中的每个元素来返回值。合并函数采用两个参数：先前的归约结果（累加器）和当前元素。但是， &lt;code&gt;fold&lt;/code&gt; 与 &lt;code&gt;reduce&lt;/code&gt; 具有以下区别：</target>
        </trans-unit>
        <trans-unit id="3984a5dbbfd384237df25b964a2fe7964065b882" translate="yes" xml:space="preserve">
          <source>In its second form, &lt;code&gt;fold&lt;/code&gt; operates like &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt;, returning a new sequence rather than a single value. When an &lt;code&gt;emit&lt;/code&gt; function is provided, &lt;code&gt;fold&lt;/code&gt; will:</source>
          <target state="translated">在第二种形式中， &lt;code&gt;fold&lt;/code&gt; 的操作类似于&lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt;，返回一个新序列而不是单个值。提供 &lt;code&gt;emit&lt;/code&gt; 功能时， &lt;code&gt;fold&lt;/code&gt; 将：</target>
        </trans-unit>
        <trans-unit id="f1803506720787d5029fd735e7823ff69080cca3" translate="yes" xml:space="preserve">
          <source>In most circumstances, automatic failover can be performed as long as a majority of voting replicas are available. However, one circumstance in which it may not be performed is a non-transitive connectivity failure. Imagine a cluster with three servers: A, B, and C. Under normal network operations, all of the servers can connect to one another. If a network failure occurs such that A can connect to B and B can connect to C, but A cannot connect to C, the network failure is non-transitive. For a more in-depth description, as well as progress on a long-term solution, read &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/4357&quot;&gt;Github issue #4357&lt;/a&gt;.</source>
          <target state="translated">在大多数情况下，只要大多数表决副本可用，就可以执行自动故障转移。但是，一种可能无法执行的情况是非传递性连接失败。想象一个包含三台服务器的群集：A，B和C。在正常的网络操作下，所有服务器都可以相互连接。如果发生网络故障，使得A可以连接到B，而B可以连接到C，但是A无法连接到C，则该网络故障是不可传递的。有关更深入的描述以及长期解决方案的进展，请阅读&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/issues/4357&quot;&gt;Github问题＃4357&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fd2d7923eb0bc8efca1cb651f85d4797323b30ae" translate="yes" xml:space="preserve">
          <source>In normal operation, &lt;code&gt;single&lt;/code&gt; read mode produces the same results as &lt;code&gt;majority&lt;/code&gt; read mode, but it might return outdated results in the event of a network failure or crash. It&amp;rsquo;s also possible that a read run in &lt;code&gt;single&lt;/code&gt; mode could return results from an incomplete write that is later rolled back.</source>
          <target state="translated">在正常操作中， &lt;code&gt;single&lt;/code&gt; 读取模式产生的结果与 &lt;code&gt;majority&lt;/code&gt; 读取模式相同，但是在网络故障或崩溃的情况下，它可能返回过时的结果。 &lt;code&gt;single&lt;/code&gt; 模式下的读取运行也可能返回来自不完整写入的结果，该写入随后被回滚。</target>
        </trans-unit>
        <trans-unit id="ae45c6d0609936a00a819d3d51967b8a8050e205" translate="yes" xml:space="preserve">
          <source>In order to model this data we&amp;rsquo;d create three tables&amp;mdash;&lt;code&gt;authors&lt;/code&gt;, &lt;code&gt;posts&lt;/code&gt; and &lt;code&gt;authors_posts&lt;/code&gt;, similarly to how we&amp;rsquo;d do it in a relational system. Here is example data for the &lt;code&gt;authors&lt;/code&gt; table:</source>
          <target state="translated">为了这个数据模型，我们会创建三个表- &lt;code&gt;authors&lt;/code&gt; ， &lt;code&gt;posts&lt;/code&gt; 和 &lt;code&gt;authors_posts&lt;/code&gt; ，类似于我们怎么会做它关系系统。这是 &lt;code&gt;authors&lt;/code&gt; 表的示例数据：</target>
        </trans-unit>
        <trans-unit id="97a88b12b94723a393b40b35de02068c1acae898" translate="yes" xml:space="preserve">
          <source>In other words, ReQL queries that involve multiple shards will be processed on those shards whenever possible.</source>
          <target state="translated">换句话说,涉及多个碎片的ReQL查询将尽可能在这些碎片上处理。</target>
        </trans-unit>
        <trans-unit id="afd135582e47c109847489d0def7f5b6eefbf292" translate="yes" xml:space="preserve">
          <source>In production, you&amp;rsquo;d likely want to specify options via configuration files rather than command line options; read the &lt;a href=&quot;../config-file/index&quot;&gt;configuration file&lt;/a&gt; documentation for details on the format and available options. Also, you&amp;rsquo;d want your RethinkDB instances to come online at system startup. See &lt;a href=&quot;../start-on-startup/index&quot;&gt;Start RethinkDB at system startup&lt;/a&gt; to learn how to set up RethinkDB with &lt;code&gt;init.d&lt;/code&gt; or &lt;code&gt;systemd&lt;/code&gt;.</source>
          <target state="translated">在生产中，您可能希望通过配置文件而不是命令行选项来指定选项。阅读&lt;a href=&quot;../config-file/index&quot;&gt;配置文件&lt;/a&gt;文档以获取有关格式和可用选项的详细信息。另外，您希望RethinkDB实例在系统启动时联机。请参阅&lt;a href=&quot;../start-on-startup/index&quot;&gt;在系统启动时启动RethinkDB&lt;/a&gt;以了解如何使用 &lt;code&gt;init.d&lt;/code&gt; 或 &lt;code&gt;systemd&lt;/code&gt; 设置RethinkDB 。</target>
        </trans-unit>
        <trans-unit id="e0dc7c6b334bc6af46a97821423466554f645dd8" translate="yes" xml:space="preserve">
          <source>In soft durability mode RethinkDB will acknowledge the write immediately after receiving it, but before the write has been committed to disk.</source>
          <target state="translated">在软耐久性模式下,RethinkDB将在接收到写入后立即确认,但在写入被提交到磁盘之前。</target>
        </trans-unit>
        <trans-unit id="5e7d59ad6bb744097a2528372b93cd92bdc3e075" translate="yes" xml:space="preserve">
          <source>In terms of hardware, we used the &lt;a href=&quot;https://www.rackspace.com/en-us/cloud/servers/onmetal&quot;&gt;OnMetal offerings from Rackspace&lt;/a&gt; to run both RethinkDB server and RethinkDB client nodes. We used different hardware configurations for the server and client nodes as shown below:</source>
          <target state="translated">在硬件方面，我们使用了&lt;a href=&quot;https://www.rackspace.com/en-us/cloud/servers/onmetal&quot;&gt;Rackspace提供&lt;/a&gt;的OnMetal产品来运行RethinkDB服务器和RethinkDB客户端节点。我们为服务器和客户端节点使用了不同的硬件配置，如下所示：</target>
        </trans-unit>
        <trans-unit id="cb384544524d3d59795f35c682141659070ffc05" translate="yes" xml:space="preserve">
          <source>In terms of latency, we found that in a 16-node cluster and forbidding stale reads, the 95th percentile for latency is 3ms. When doing a heavy read workload, a large majority of reads fell between 0ms and 1ms which can be seen in the graph below.</source>
          <target state="translated">在延迟方面,我们发现在一个16节点的集群中,并且禁止陈旧的读取,延迟的第95百分位数是3ms。当做重读工作负载时,绝大部分读数落在0ms到1ms之间,这可以从下图中看到。</target>
        </trans-unit>
        <trans-unit id="c2a92dff43ec5bf76e7d231b5b621039bca24c72" translate="yes" xml:space="preserve">
          <source>In that example, when you&amp;rsquo;re trying to get at just one value, the JSON style doesn&amp;rsquo;t offer much advantage. But you can use it to retrieve &lt;em&gt;multiple&lt;/em&gt; values at the same nesting level. For instance, you can get just Bob&amp;rsquo;s work and cell numbers, but not home:</source>
          <target state="translated">在该示例中，当您尝试仅获得一个值时，JSON样式没有太大优势。但是您可以使用它来检索同一嵌套级别的&lt;em&gt;多个&lt;/em&gt;值。例如，您只能获取Bob的工作和电话号码，而不能获取家庭地址：</target>
        </trans-unit>
        <trans-unit id="aa606add1a5523e36aa8ef8f2ae241c827c85963" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;asynchronous&amp;rdquo; test, reads use the &lt;code&gt;{readMode: &amp;rdquo;outdated&amp;rdquo;}&lt;/code&gt; setting</source>
          <target state="translated">在&amp;ldquo;异步&amp;rdquo;测试中，使用 &lt;code&gt;{readMode: &amp;rdquo;outdated&amp;rdquo;}&lt;/code&gt; 设置进行读取</target>
        </trans-unit>
        <trans-unit id="bf0b85b37e8a9ef902d18f0effb8b8b0a5e0b487" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;asynchronous&amp;rdquo; test, reads use the &lt;code&gt;{readMode:&amp;rdquo;outdated&amp;rdquo;}&lt;/code&gt; setting</source>
          <target state="translated">在&amp;ldquo;异步&amp;rdquo;测试中，使用 &lt;code&gt;{readMode:&amp;rdquo;outdated&amp;rdquo;}&lt;/code&gt; 设置进行读取</target>
        </trans-unit>
        <trans-unit id="d386ba1cc200d80b7866a894432946f810b0b236" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;synchronous&amp;rdquo; test, we use the default &lt;code&gt;{readMode: &amp;rdquo;single&amp;rdquo;}&lt;/code&gt; setting</source>
          <target state="translated">在&amp;ldquo;同步&amp;rdquo;测试中，我们使用默认的 &lt;code&gt;{readMode: &amp;rdquo;single&amp;rdquo;}&lt;/code&gt; 设置</target>
        </trans-unit>
        <trans-unit id="224e33b3ae99c46077d788fc2cbcfc0ec642f4c2" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;synchronous&amp;rdquo; test, we use the default &lt;code&gt;{readMode:&amp;rdquo;single&amp;rdquo;}&lt;/code&gt; setting</source>
          <target state="translated">在&amp;ldquo;同步&amp;rdquo;测试中，我们使用默认的 &lt;code&gt;{readMode:&amp;rdquo;single&amp;rdquo;}&lt;/code&gt; 设置</target>
        </trans-unit>
        <trans-unit id="d0c0068240942eeaad5904125996b7f2b3d6ea1f" translate="yes" xml:space="preserve">
          <source>In the Data Explorer, the following command will output the contents of all the configuration/status tables and the most recent 50 lines of the &lt;code&gt;logs&lt;/code&gt; table:</source>
          <target state="translated">在数据资源管理器中，以下命令将输出所有配置/状态表的内容以及 &lt;code&gt;logs&lt;/code&gt; 表的最新50行：</target>
        </trans-unit>
        <trans-unit id="0f2e3061797f8ffc035d338c6ee005215f806609" translate="yes" xml:space="preserve">
          <source>In the ReQL API documentation and some error messages, you&amp;rsquo;ll come across terms for &amp;ldquo;data types&amp;rdquo; that are actually &lt;em&gt;classes&lt;/em&gt; of other data types.</source>
          <target state="translated">在ReQL API文档和一些错误信息，你会遇到的条款是真正的&amp;ldquo;数据类型&amp;rdquo; &lt;em&gt;类的&lt;/em&gt;其他数据类型。</target>
        </trans-unit>
        <trans-unit id="8918357e3571d7f57170387ccdf371596278a850" translate="yes" xml:space="preserve">
          <source>In the ReQL API documentation you&amp;rsquo;ll also see a &amp;ldquo;pseudotype&amp;rdquo; called &lt;strong&gt;Geometry,&lt;/strong&gt; which is a collective for all of the geometry data types. Those commands will work with points, lines and polygons.</source>
          <target state="translated">在ReQL API文档中，您还将看到一个名为&lt;strong&gt;Geometry&lt;/strong&gt;的&amp;ldquo;伪类型&amp;rdquo; &lt;strong&gt;，&lt;/strong&gt;它是所有几何数据类型的集合。这些命令将与点，线和多边形一起使用。</target>
        </trans-unit>
        <trans-unit id="50f6c67f7c1dbf2748240f51a04ec169aff9a6b9" translate="yes" xml:space="preserve">
          <source>In the case of nested functions, the &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; term is ambiguous, and should not be used. Your driver should either throw an error or let the server return an error.</source>
          <target state="translated">在嵌套函数的情况下， &lt;code&gt;IMPLICIT_VAR&lt;/code&gt; 术语是不明确的，不应使用。您的驱动程序应该抛出错误或让服务器返回错误。</target>
        </trans-unit>
        <trans-unit id="84e483a5ecf212378a48f1669d098b93f94aaf23" translate="yes" xml:space="preserve">
          <source>In the case of the first source, every database process uses memory to store intermediate results and to maintain internal state. The memory used varies significantly depending on the type of queries run and the size of documents stored in the database. As a rough estimate, expect each query and background process to use 1&amp;ndash;20 MB of memory.</source>
          <target state="translated">对于第一个源，每个数据库进程都使用内存来存储中间结果并维护内部状态。根据运行的查询类型和数据库中存储的文档大小，使用的内存差异很大。粗略估计，期望每个查询和后台进程使用1&amp;ndash;20 MB的内存。</target>
        </trans-unit>
        <trans-unit id="7bcb70dff2e48b1f52037256b865f5a9417b2b37" translate="yes" xml:space="preserve">
          <source>In the form above&amp;mdash;with a block that accepts a single argument&amp;mdash;RethinkDB&amp;rsquo;s EventMachine adapter will throw errors back up to your application for you to handle in the same fashion as you would using RethinkDB without EventMachine. If the table &lt;code&gt;test&lt;/code&gt; did not exist in the database above, you would receive the standard &lt;code&gt;ReqlRunTimeError&lt;/code&gt;:</source>
          <target state="translated">在上面的表格中（带有一个接受单个参数的块），RethinkDB的EventMachine适配器会将错误返回给您的应用程序，以便您以与使用不带EventMachine的RethinkDB相同的方式来处理。如果上面的数据库中没有表 &lt;code&gt;test&lt;/code&gt; ，您将收到标准的 &lt;code&gt;ReqlRunTimeError&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9ec0b06d735bfc391094860e46de01fa59f75cec" translate="yes" xml:space="preserve">
          <source>In the results, we&amp;rsquo;ll see how RethinkDB scales to perform 1.3 million individual reads per second. We will also demonstrate how RethinkDB performs well above 100 thousand operations per second in a mixed 50:50 read/write workload - while at the full level of durability and data integrity guarantees. We performed all benchmarks across a range of cluster sizes, scaling up from one to 16 nodes.</source>
          <target state="translated">在结果中，我们将看到RethinkDB如何扩展以执行每秒130万次个人读取。我们还将演示RethinkDB如何在混合的50:50读/写工作负载中每秒执行10万次以上的操作，同时又具有完整的持久性和数据完整性保证。我们在一系列群集大小（从1个节点扩展到16个节点）上执行了所有基准测试。</target>
        </trans-unit>
        <trans-unit id="effef7fb5159ccc0efbb8a008e85c758abcdaa0d" translate="yes" xml:space="preserve">
          <source>In the second example, the two replicas in the &lt;code&gt;us&lt;/code&gt; group may be on any of the four servers in the United States.</source>
          <target state="translated">在第二个示例中， &lt;code&gt;us&lt;/code&gt; 组中的两个副本可以位于美国四台服务器中的任何一台上。</target>
        </trans-unit>
        <trans-unit id="bd1292a9ca18510e97840764bd37257fdac0d158" translate="yes" xml:space="preserve">
          <source>In the subscribing application we need to create a queue to receive and buffer messages. The queue takes a ReQL filtering function as an argument. This is similar to what you would pass to &lt;a href=&quot;../../../api/javascript/filter/index&quot;&gt;filter&lt;/a&gt;. Here we&amp;rsquo;ll subscribe to all messages about superhero fights:</source>
          <target state="translated">在订阅应用程序中，我们需要创建一个队列来接收和缓冲消息。队列采用ReQL过滤功能作为参数。这类似于传递给&lt;a href=&quot;../../../api/javascript/filter/index&quot;&gt;filter的内容&lt;/a&gt;。在这里，我们将订阅有关超级英雄之战的所有消息：</target>
        </trans-unit>
        <trans-unit id="79b11bb5d26c6627628246b9b4da08bc855ecd84" translate="yes" xml:space="preserve">
          <source>In this case, the predicate &lt;code&gt;r.row(&quot;age&quot;).eq(30)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if the field &lt;code&gt;age&lt;/code&gt; is equal to 30. You can write this predicate as an anonymous function instead:</source>
          <target state="translated">在这种情况下，如果字段 &lt;code&gt;age&lt;/code&gt; 等于30 ，则谓词 &lt;code&gt;r.row(&quot;age&quot;).eq(30)&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。您可以将此谓词编写为匿名函数：</target>
        </trans-unit>
        <trans-unit id="25d73c774a9ee763c700413c07c0009819356017" translate="yes" xml:space="preserve">
          <source>In this case, we would only receive notifications of fights involving a superhero. Fights between supervillains would be ignored.</source>
          <target state="translated">在这种情况下,我们只会收到涉及超级英雄的战斗通知。超级英雄之间的战斗将被忽略。</target>
        </trans-unit>
        <trans-unit id="895f4bd40e5222929c7fb08157cbd280981cabbc" translate="yes" xml:space="preserve">
          <source>In this case, we&amp;rsquo;re using a predicate that returns &lt;code&gt;true&lt;/code&gt; only if the length of the array in the field &lt;code&gt;posts&lt;/code&gt; is greater than two. This predicate contains two commands we haven&amp;rsquo;t seen before:</source>
          <target state="translated">在这种情况下，我们使用一个谓词，返回 &lt;code&gt;true&lt;/code&gt; 只有在该领域的数组的长度 &lt;code&gt;posts&lt;/code&gt; 大于二。该谓词包含两个我们之前从未见过的命令：</target>
        </trans-unit>
        <trans-unit id="b372f7d94072c06cbc703d33f6f2f5eb322d59ab" translate="yes" xml:space="preserve">
          <source>In this case, you can do a pivot operation with the &lt;code&gt;group&lt;/code&gt; and &lt;code&gt;coerceTo&lt;/code&gt; commands.</source>
          <target state="translated">在这种情况下，您可以使用 &lt;code&gt;group&lt;/code&gt; 和 &lt;code&gt;coerceTo&lt;/code&gt; 命令进行数据透视操作。</target>
        </trans-unit>
        <trans-unit id="932455af624242d4d4e2291c9afaaa19c3951b01" translate="yes" xml:space="preserve">
          <source>In this example, we count the number of sentences over the whole data set of 25 million documents based on one of the fields. We use the following exact query which utilizes the map and sum (reduce) functions of ReQL:</source>
          <target state="translated">在这个例子中,我们根据其中一个字段来统计整个2500万文档数据集的句子数量。我们使用下面的精确查询,它利用了ReQL的映射和求和(reduce)函数。</target>
        </trans-unit>
        <trans-unit id="5a837ef70a876172728ac7037ebd677f98962f1e" translate="yes" xml:space="preserve">
          <source>In this form, the block will receive &lt;code&gt;nil&lt;/code&gt; as the first argument if there is no error. In the case of an error, the second argument will be &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">以这种形式，如果没有错误，则该块将接收 &lt;code&gt;nil&lt;/code&gt; 作为第一个参数。如果发生错误，第二个参数将为 &lt;code&gt;nil&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="558ef6c0550627ce8d41470ac5b93bdfb82caa5b" translate="yes" xml:space="preserve">
          <source>In this guide we look at what RethinkDB uses memory for, how we can estimate the amount needed, and how to configure the size of RethinkDB&amp;rsquo;s page cache.</source>
          <target state="translated">在本指南中，我们研究了RethinkDB将内存用于什么，如何估计所需的数量以及如何配置RethinkDB的页面缓存的大小。</target>
        </trans-unit>
        <trans-unit id="26ea7c60ff32fa4b3e8fefeb9a9dc71af8af950d" translate="yes" xml:space="preserve">
          <source>In-depth description of the RabbitMQ model</source>
          <target state="translated">RabbitMQ模型的深度描述</target>
        </trans-unit>
        <trans-unit id="e07cfb5357625f4bbae1c6809f007bdeed5bbd4c" translate="yes" xml:space="preserve">
          <source>Include OWASP link, CVE references or links to other public advisories and standards</source>
          <target state="translated">包括OWASP链接、CVE参考资料或其他公共咨询和标准的链接。</target>
        </trans-unit>
        <trans-unit id="6c1c63beb34300ba0d002edb636ab37ff5010363" translate="yes" xml:space="preserve">
          <source>Includes scripts for building an image for Docker with RethinkDB (and other things).</source>
          <target state="translated">包括用RethinkDB为Docker构建镜像的脚本(以及其他东西)。</target>
        </trans-unit>
        <trans-unit id="5714de2ace97726c8558fc98cd998b375aeaa197" translate="yes" xml:space="preserve">
          <source>Including initial values</source>
          <target state="translated">包括初始值</target>
        </trans-unit>
        <trans-unit id="0e1b750635a22beeae4a57fea2a9554b63dc760b" translate="yes" xml:space="preserve">
          <source>Including result types</source>
          <target state="translated">包括结果类型</target>
        </trans-unit>
        <trans-unit id="a4dfbecd4fe9a9b9f9a34ada5173cbb0a60fca4a" translate="yes" xml:space="preserve">
          <source>Including state changes</source>
          <target state="translated">包括国家变化</target>
        </trans-unit>
        <trans-unit id="0777c09113ddc3b67cd50cd499a4890c5b231cf0" translate="yes" xml:space="preserve">
          <source>Including the &lt;code&gt;type&lt;/code&gt; field can simplify code that handles different cases for changefeed results.</source>
          <target state="translated">包含 &lt;code&gt;type&lt;/code&gt; 字段可以简化处理更改提要结果的不同情况的代码。</target>
        </trans-unit>
        <trans-unit id="4527e9704b753e001f3be370d293684ea1fc9ebc" translate="yes" xml:space="preserve">
          <source>Increasing the number of shards on an empty table, then using non-UUID primary keys in that table</source>
          <target state="translated">在空表上增加碎片数量,然后在该表中使用非UUID主键。</target>
        </trans-unit>
        <trans-unit id="ea06f91098e8943020ff7f86773b8606b3f3f7a0" translate="yes" xml:space="preserve">
          <source>Incrementing a field value</source>
          <target state="translated">递增字段值</target>
        </trans-unit>
        <trans-unit id="c95a80f91577f1b4f75e07f8b821d9e8943fe898" translate="yes" xml:space="preserve">
          <source>Indexes (both secondary and primary) are guaranteed to be updated by successful write operations. If an &lt;code&gt;insert&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt; or &lt;code&gt;delete&lt;/code&gt; operation is successful, the change will be correctly reflected in the index. (Read about RethinkDB &lt;a href=&quot;../../consistency/index&quot;&gt;Consistency guarantees&lt;/a&gt; for write operations.)</source>
          <target state="translated">索引（辅助索引和主索引）保证通过成功的写操作进行更新。如果 &lt;code&gt;insert&lt;/code&gt; ， &lt;code&gt;update&lt;/code&gt; 或 &lt;code&gt;delete&lt;/code&gt; 操作成功，则更改将正确反映在索引中。（了解有关写操作的RethinkDB &lt;a href=&quot;../../consistency/index&quot;&gt;一致性保证&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="0391e1ecda549a694d60dcf43663ae1c4ada2850" translate="yes" xml:space="preserve">
          <source>Indexes based on &lt;em&gt;arbitrary expressions&lt;/em&gt;.</source>
          <target state="translated">基于&lt;em&gt;任意表达式的&lt;/em&gt;索引。</target>
        </trans-unit>
        <trans-unit id="5758991da81d866c69900c0ad779d0d61274c0f9" translate="yes" xml:space="preserve">
          <source>Indexes based on &lt;strong&gt;arbitrary expressions&lt;/strong&gt;.</source>
          <target state="translated">基于&lt;strong&gt;任意表达式的&lt;/strong&gt;索引。</target>
        </trans-unit>
        <trans-unit id="cfa5fc5368d198722219726949e2bbad91dda010" translate="yes" xml:space="preserve">
          <source>Indexes built with an older version of RethinkDB need to be rebuilt due to changes in the way ReQL handles indexing. See &amp;ldquo;&lt;a href=&quot;../troubleshooting/index#my-secondary-index-is-outdated&quot;&gt;My secondary index is outdated&lt;/a&gt;&amp;rdquo; for details on how to rebuild indexes.</source>
          <target state="translated">由于ReQL处理索引的方式发生了变化，因此需要重建使用较旧版本的RethinkDB构建的索引。有关如何重建索引的详细信息，请参见&amp;ldquo; &lt;a href=&quot;../troubleshooting/index#my-secondary-index-is-outdated&quot;&gt;我的二级索引已过时&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="a1609b5c345fc2347a59a738ac67f1b56e06b94a" translate="yes" xml:space="preserve">
          <source>Indexes on arbitrary ReQL expressions</source>
          <target state="translated">任意ReQL表达式的索引</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="043018f3a2dce17d498788f43e79b4e219d2416a" translate="yes" xml:space="preserve">
          <source>Information about the cluster and all operations on the cluster should be programmatically accessible.</source>
          <target state="translated">关于群集的信息和对群集的所有操作都应该是可以通过程序访问的。</target>
        </trans-unit>
        <trans-unit id="5abeab7792567877161cdefc7357d62712b8d656" translate="yes" xml:space="preserve">
          <source>Information about the server:</source>
          <target state="translated">关于服务器的信息。</target>
        </trans-unit>
        <trans-unit id="f9ec4176c4501a5a0d6dc615f46d39b3af2491e2" translate="yes" xml:space="preserve">
          <source>Initial state (&lt;code&gt;old_val&lt;/code&gt;)</source>
          <target state="translated">初始状态（ &lt;code&gt;old_val&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="2eea430756a8711c4e7806f52c9877e92ac65847" translate="yes" xml:space="preserve">
          <source>Initial steps</source>
          <target state="translated">初步步骤</target>
        </trans-unit>
        <trans-unit id="80505361d6e27b7e0ae3d35e93853b22f2675393" translate="yes" xml:space="preserve">
          <source>Insert a value in to an array at a given index. Returns the modified array.</source>
          <target state="translated">在给定的数组中插入一个值。返回修改后的数组。</target>
        </trans-unit>
        <trans-unit id="d8eba2c9cbef2976d5ebdfcd90efdd1990cc6029" translate="yes" xml:space="preserve">
          <source>Insert data</source>
          <target state="translated">插入数据</target>
        </trans-unit>
        <trans-unit id="8a47f8d72661f904ca4e211f6a9e1f8c9c152b3a" translate="yes" xml:space="preserve">
          <source>Insert documents into a table. Accepts a single document or an array of documents.</source>
          <target state="translated">在表格中插入文档。接受单个文档或文档数组。</target>
        </trans-unit>
        <trans-unit id="ac0b22d784ef13cc442529b0995c912c4dcd2b31" translate="yes" xml:space="preserve">
          <source>Insert returns an object that contains the following attributes:</source>
          <target state="translated">Insert返回一个包含以下属性的对象。</target>
        </trans-unit>
        <trans-unit id="65a6ea576f847d46029b82648e01c9ba3de063ca" translate="yes" xml:space="preserve">
          <source>Insert several values in to an array at a given index. Returns the modified array.</source>
          <target state="translated">在给定的数组中插入多个值。返回修改后的数组。</target>
        </trans-unit>
        <trans-unit id="e2d0c213ca368674692f81a4b603c53678e69fc3" translate="yes" xml:space="preserve">
          <source>Inserting documents</source>
          <target state="translated">插入文件</target>
        </trans-unit>
        <trans-unit id="29b8d93e8ca73ad1184f047cbc37d36c670720a4" translate="yes" xml:space="preserve">
          <source>Inserting times</source>
          <target state="translated">插入时间</target>
        </trans-unit>
        <trans-unit id="ec5593e73134544c0d12300a4f2f2bdea2b1ab11" translate="yes" xml:space="preserve">
          <source>Instagram PubSubHubbub</source>
          <target state="translated">Instagram PubSubHubbub</target>
        </trans-unit>
        <trans-unit id="3cc343c3aa41172c7a302bc5bb30b454ee61655b" translate="yes" xml:space="preserve">
          <source>Install &lt;a href=&quot;http://rubyonrails.org/download/&quot;&gt;Ruby on Rails&lt;/a&gt;</source>
          <target state="translated">安装&lt;a href=&quot;http://rubyonrails.org/download/&quot;&gt;Ruby on Rails&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eea9f12452b1397d31321dc6aae0063da202053c" translate="yes" xml:space="preserve">
          <source>Install &lt;a href=&quot;http://www.squaremobius.net/amqp.node/&quot;&gt;amqplib&lt;/a&gt;, a RabbitMQ library for NodeJS</source>
          <target state="translated">安装&lt;a href=&quot;http://www.squaremobius.net/amqp.node/&quot;&gt;amqplib&lt;/a&gt;，它是NodeJS的RabbitMQ库</target>
        </trans-unit>
        <trans-unit id="0e26578d0a3c30b7cc1f3e97e04029b42bb08700" translate="yes" xml:space="preserve">
          <source>Install RethinkDB</source>
          <target state="translated">安装RethinkDB</target>
        </trans-unit>
        <trans-unit id="b6d9894293f7a4227b3086a28d9c0d307a5e6bd9" translate="yes" xml:space="preserve">
          <source>Install RethinkDB as a service for your operating system. (This document describes how to do that for both &lt;code&gt;init.d&lt;/code&gt; and &lt;code&gt;systemd&lt;/code&gt;-based Linux distributions, as well as OS X using &lt;code&gt;launchd&lt;/code&gt; and Windows services. Depending on how you&amp;rsquo;ve installed RethinkDB, this may already be done for you.)</source>
          <target state="translated">将RethinkDB安装为操作系统的服务。 （本文档描述了如何针对基于 &lt;code&gt;init.d&lt;/code&gt; 和基于 &lt;code&gt;systemd&lt;/code&gt; 的Linux发行版以及使用已 &lt;code&gt;launchd&lt;/code&gt; 和Windows服务的OS X进行此操作。根据您安装RethinkDB的方式，可能已经为您完成了此操作。）</target>
        </trans-unit>
        <trans-unit id="32dacb2f0cddc3948aa2de26d4c1fa81e213e4a7" translate="yes" xml:space="preserve">
          <source>Install RethinkDB as a service for your operating system. (This document describes how to do that for both &lt;code&gt;init.d&lt;/code&gt; and &lt;code&gt;systemd&lt;/code&gt;-based Linux distributions, as well as OS X using &lt;code&gt;launchd&lt;/code&gt;. Depending on how you&amp;rsquo;ve installed RethinkDB, this may already be done for you.)</source>
          <target state="translated">将RethinkDB安装为操作系统的服务。（本文档介绍了如何针对 &lt;code&gt;init.d&lt;/code&gt; 和基于 &lt;code&gt;systemd&lt;/code&gt; 的Linux发行版以及使用 &lt;code&gt;launchd&lt;/code&gt; 的 OS X进行此操作。根据您安装RethinkDB的方式，可能已经为您完成了此操作。）</target>
        </trans-unit>
        <trans-unit id="2df8530df735797a29fd92fab10ddfe7b16aedf6" translate="yes" xml:space="preserve">
          <source>Install client drivers</source>
          <target state="translated">安装客户端驱动程序</target>
        </trans-unit>
        <trans-unit id="01fd635cf310ad64f3e1b1f64648e6ae28c17133" translate="yes" xml:space="preserve">
          <source>Install the server</source>
          <target state="translated">安装服务器</target>
        </trans-unit>
        <trans-unit id="828b11b9132aed05b6b796b08db5481e6d19dd3e" translate="yes" xml:space="preserve">
          <source>Installing RethinkDB</source>
          <target state="translated">安装RethinkDB</target>
        </trans-unit>
        <trans-unit id="f0813a11b71d8a038d4b80014edfc9b3a6adf95c" translate="yes" xml:space="preserve">
          <source>Installing RethinkDB client drivers</source>
          <target state="translated">安装RethinkDB客户端驱动</target>
        </trans-unit>
        <trans-unit id="25698238529e36c36bbff9a1cf8864afeb7e862b" translate="yes" xml:space="preserve">
          <source>Installing from source</source>
          <target state="translated">从源头安装</target>
        </trans-unit>
        <trans-unit id="66166bdf5a5269039901f352cb2db046575a54fa" translate="yes" xml:space="preserve">
          <source>Installing on other platforms</source>
          <target state="translated">在其他平台上安装</target>
        </trans-unit>
        <trans-unit id="333df51781cc357460f2c635fe316602326864a3" translate="yes" xml:space="preserve">
          <source>Instance administration</source>
          <target state="translated">实例管理</target>
        </trans-unit>
        <trans-unit id="4319f262417314ad390a0bffe2a7838f08952aea" translate="yes" xml:space="preserve">
          <source>Instead of using the &lt;code&gt;default&lt;/code&gt; optional argument to &lt;code&gt;filter&lt;/code&gt;, we have to use default values on the fields within the &lt;code&gt;or&lt;/code&gt; clause. Why? If the field on the left side of the &lt;code&gt;or&lt;/code&gt; clause is missing from a document&amp;mdash;in this case, if the user doesn&amp;rsquo;t have a &lt;code&gt;role&lt;/code&gt; field&amp;mdash;the predicate will generate an error, and will return &lt;code&gt;false&lt;/code&gt; (or the value the &lt;code&gt;default&lt;/code&gt; argument is set to) without evaluating the right side of the &lt;code&gt;or&lt;/code&gt;. By using &lt;code&gt;.default(false)&lt;/code&gt; on the fields, each side of the &lt;code&gt;or&lt;/code&gt; will evaluate to either the field&amp;rsquo;s value or &lt;code&gt;false&lt;/code&gt; if the field doesn&amp;rsquo;t exist.</source>
          <target state="translated">而不是使用 &lt;code&gt;default&lt;/code&gt; 可选参数来 &lt;code&gt;filter&lt;/code&gt; ，我们必须在 &lt;code&gt;or&lt;/code&gt; 子句中的字段上使用默认值。为什么？如果文档中缺少 &lt;code&gt;or&lt;/code&gt; 子句左侧的字段（在这种情况下，如果用户没有 &lt;code&gt;role&lt;/code&gt; 字段），则谓词将生成错误，并返回 &lt;code&gt;false&lt;/code&gt; （或值为 &lt;code&gt;default&lt;/code&gt; 参数）设置为）而不评估 &lt;code&gt;or&lt;/code&gt; 的右侧。通过在字段上使用 &lt;code&gt;.default(false)&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; 每一边都将求值为该字段的值；如果该字段不存在，则求值为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="edcb8acb99853d0a5ef2bb5e68e942595143f90e" translate="yes" xml:space="preserve">
          <source>Integrating Elasticsearch</source>
          <target state="translated">整合Elasticsearch</target>
        </trans-unit>
        <trans-unit id="8dbfed65b5b9df99b02a2d3fc9690365cea617b8" translate="yes" xml:space="preserve">
          <source>Integrating RabbitMQ</source>
          <target state="translated">集成RabbitMQ</target>
        </trans-unit>
        <trans-unit id="081430b73c2092922b1df2dd3a411dc9f24c47e1" translate="yes" xml:space="preserve">
          <source>Integrating RethinkDB with RabbitMQ</source>
          <target state="translated">将RethinkDB与RabbitMQ整合在一起。</target>
        </trans-unit>
        <trans-unit id="a7881cac6e64abca5eafd172df6eb31fe0b84c88" translate="yes" xml:space="preserve">
          <source>Integrations</source>
          <target state="translated">Integrations</target>
        </trans-unit>
        <trans-unit id="796755669082ff5596709d22781a79a1f59e5527" translate="yes" xml:space="preserve">
          <source>Intel Xeon E5-2680 v2 CPU 2.8 GHz (10 cores)</source>
          <target state="translated">Intel Xeon E5-2680 v2 CPU 2.8 GHz (10核心)</target>
        </trans-unit>
        <trans-unit id="873fde3ef086eae1a20c3748b3a65e16d5a254b8" translate="yes" xml:space="preserve">
          <source>Internal metadata</source>
          <target state="translated">内部元数据</target>
        </trans-unit>
        <trans-unit id="cc2de5d3fe42b60664127c2656b7a7a0b43b73c3" translate="yes" xml:space="preserve">
          <source>Internally this approach is more difficult to implement than the more commonly used consistent hashing, but it has significant advantages because it allows for an efficient implementation of range queries.</source>
          <target state="translated">从内部来看,这种方法比比较常用的一致散列法更难实现,但它有显著的优势,因为它可以有效地实现范围查询。</target>
        </trans-unit>
        <trans-unit id="110fc7f6ed7d04de80c4765c8e43e4f598bb28eb" translate="yes" xml:space="preserve">
          <source>Internally, compound indexes and simple indexes are the same type of index in RethinkDB; compound indexes are simply a special case of regular index that returns an array rather than a single value.</source>
          <target state="translated">在RethinkDB内部,复式索引和简单索引是同一种类型的索引,复式索引只是常规索引的一种特殊情况,它返回的是一个数组,而不是单个值。</target>
        </trans-unit>
        <trans-unit id="56880de82bcea48ab8325b91afa2386b2d395979" translate="yes" xml:space="preserve">
          <source>Internally, compound indexes and simple indexes are the same type of index in RethinkDB; compound indexes are simply a special case of regular index that returns an array rather than a single value. Note that this affects sorting: compound index values are sorted lexicographically, with the first (leftmost) elements of the compound value being more significant than the last (rightmost) ones. Therefore, using the &lt;code&gt;full_name&lt;/code&gt; index, the above example &amp;ldquo;all users whose last name is Smith&amp;rdquo; only works for the &lt;code&gt;last_name&lt;/code&gt; field. Searching by &lt;code&gt;first_name&lt;/code&gt; with a query like &lt;code&gt;between([r.minval, &quot;John&quot;], [r.maxval, &quot;John&quot;], {index: &quot;full_name&quot;})&lt;/code&gt; would effectively select &lt;em&gt;every&lt;/em&gt; user in the table, except (theoretically) users that have &lt;code&gt;r.minval&lt;/code&gt; as last name and a first name lexicographically smaller than &amp;ldquo;John&amp;rdquo; (or the reverse for &lt;code&gt;r.maxval&lt;/code&gt;).</source>
          <target state="translated">在内部，复合索引和简单索引是RethinkDB中相同类型的索引。复合索引只是常规索引的一种特殊情况，它返回数组而不是单个值。请注意，这会影响排序：按字典顺序对复合索引值进行排序，复合值的第一个（最左边的）元素比最后一个（最右边的）元素更重要。因此，使用 &lt;code&gt;full_name&lt;/code&gt; 索引，以上示例&amp;ldquo;姓氏为Smith的所有用户&amp;rdquo;仅适用于 &lt;code&gt;last_name&lt;/code&gt; 字段。使用 &lt;code&gt;between([r.minval, &quot;John&quot;], [r.maxval, &quot;John&quot;], {index: &quot;full_name&quot;})&lt;/code&gt; 的查询按 &lt;code&gt;first_name&lt;/code&gt; 进行搜索（[r.minval，&amp;ldquo; John&amp;rdquo;]，[r.maxval，&amp;ldquo; John&amp;rdquo;]，{index：&amp;ldquo; full_name&amp;rdquo;}）会有效地选择&lt;em&gt;每个&lt;/em&gt;表中的用户，（理论上除外）具有 &lt;code&gt;r.minval&lt;/code&gt; 作为姓氏且名字在字典上小于&amp;ldquo; John&amp;rdquo;（或 &lt;code&gt;r.maxval&lt;/code&gt; 则相反）的用户。</target>
        </trans-unit>
        <trans-unit id="016355aa2cdbc678752876dfc6bd8a8f0e33fcf6" translate="yes" xml:space="preserve">
          <source>Internally, queries are represented as trees. A query of:</source>
          <target state="translated">在内部,查询用树来表示。一个查询的:</target>
        </trans-unit>
        <trans-unit id="3c0f8a211170bbe9fd74bfe3fb9d32dca2499482" translate="yes" xml:space="preserve">
          <source>Intersect two arrays returning values that occur in both of them as a set (an array with distinct values).</source>
          <target state="translated">将两个数组相交,将两个数组中出现的值作为一个集合返回(一个具有不同值的数组)。</target>
        </trans-unit>
        <trans-unit id="1df374766527b0942d46def76ff145106af94c20" translate="yes" xml:space="preserve">
          <source>Introduction to Joins</source>
          <target state="translated">加盟介绍</target>
        </trans-unit>
        <trans-unit id="886e399859534e91e45eb866e28bb27d1c8ebef9" translate="yes" xml:space="preserve">
          <source>Introduction to ReQL</source>
          <target state="translated">ReQL简介</target>
        </trans-unit>
        <trans-unit id="c861239c228b921387ace53d3216eff7ae8989a1" translate="yes" xml:space="preserve">
          <source>Introduction to map-reduce</source>
          <target state="translated">地图还原介绍</target>
        </trans-unit>
        <trans-unit id="abbf10e2c10be16cbb5de69a08a9647bc4b8886f" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tableCreate&lt;/code&gt; without specifying a database using &lt;a href=&quot;../db/index&quot;&gt;db&lt;/a&gt; creates a table in the database specified in &lt;a href=&quot;../connect/index&quot;&gt;connect&lt;/a&gt;, or &lt;code&gt;test&lt;/code&gt; if no database was specified.</source>
          <target state="translated">&lt;code&gt;tableCreate&lt;/code&gt; 不使用&lt;a href=&quot;../db/index&quot;&gt;db&lt;/a&gt;来指定数据库的情况下调用tableCreate会在&lt;a href=&quot;../connect/index&quot;&gt;connect中&lt;/a&gt;指定的数据库中创建一个表，或者 &lt;code&gt;test&lt;/code&gt; 是否未指定数据库。</target>
        </trans-unit>
        <trans-unit id="2e984013c5e5d72e6ebe438bef7ce2e2e4fb1ca3" translate="yes" xml:space="preserve">
          <source>Invoking this functionality automatically without the user&amp;rsquo;s request is the next layer in this hierarchy. Currently the user can control the system via the web UI, manually via the command line, or by writing scripts to call the command line tools to perform server automation.</source>
          <target state="translated">无需用户请求即可自动调用此功能是此层次结构中的下一层。当前，用户可以通过Web UI，通过命令行手动或通过编写脚本来调用命令行工具以执行服务器自动化来控制系统。</target>
        </trans-unit>
        <trans-unit id="3648c9e586da9da329d881f9456ad5f94947161e" translate="yes" xml:space="preserve">
          <source>Is RethinkDB immediately or eventually consistent?</source>
          <target state="translated">RethinkDB是立即还是最终一致?</target>
        </trans-unit>
        <trans-unit id="4345620dde11a944cdd9bd27934184533e094c4e" translate="yes" xml:space="preserve">
          <source>Is preferable to this query:</source>
          <target state="translated">是优于这个查询。</target>
        </trans-unit>
        <trans-unit id="2425127c8709646f155c07fc3ff2d5c6988816eb" translate="yes" xml:space="preserve">
          <source>Is the crash reproducible, and if so, under what conditions?</source>
          <target state="translated">碰撞是否可以重现,如果可以,在什么条件下?</target>
        </trans-unit>
        <trans-unit id="6e1cb81d9e26a4f9b860dc2a2fd2ba2b29daee20" translate="yes" xml:space="preserve">
          <source>Issue types</source>
          <target state="translated">问题类型</target>
        </trans-unit>
        <trans-unit id="f03aac29f543ef0de44fcdf77a29c785765deb8a" translate="yes" xml:space="preserve">
          <source>Issues added to the table follow the same structure.</source>
          <target state="translated">添加到表中的问题也遵循同样的结构。</target>
        </trans-unit>
        <trans-unit id="b48c8924e7f87f4c696bb70c6d06139c134e96ed" translate="yes" xml:space="preserve">
          <source>It also returns results ordered from most relevant to least, not worrying about small differences. Say you want to ask the question: &amp;ldquo;What documents best match the phrase &amp;lsquo;Holy guacamole, Batman&amp;rsquo;?&amp;rdquo; If the hoped-for guacamole reference isn&amp;rsquo;t found, a full-text search should reply with documents containing good matches like &amp;ldquo;Holy smokes, Batman!&amp;rdquo; and &amp;ldquo;Holy armadillo, Batman!&amp;rdquo; In short, you should be using a full-text search database like Elasticsearch if you find yourself writing convoluted regular expressions to grep through big text fields.</source>
          <target state="translated">它还返回从最相关到​​最不相关的结果，而不必担心细微的差异。假设您想问一个问题：&amp;ldquo;哪些文件最适合短语'蝙蝠侠圣鳄梨酱？&amp;rdquo;如果找不到所需的鳄梨调味酱参考，则全文搜索应回复包含匹配良好的文档，例如&amp;ldquo;圣烟，蝙蝠侠！&amp;rdquo;和&amp;ldquo;圣犰狳，蝙蝠侠！&amp;rdquo;简而言之，如果您发现自己通过大文本字段向grep中编写了复杂的正则表达式，则应该使用像Elasticsearch这样的全文搜索数据库。</target>
        </trans-unit>
        <trans-unit id="f7f292e66c309fe4cd3fbb49b33a11a9a27f61fc" translate="yes" xml:space="preserve">
          <source>It relies on the underlying storage system to ensure data consistency. RethinkDB does not perform additional checksums on stored data. It is, however, compatible with file systems which do guarantee data integrity, such as ZFS.</source>
          <target state="translated">它依靠底层存储系统来确保数据的一致性。RethinkDB不会对存储的数据进行额外的校验。然而,它与保证数据完整性的文件系统兼容,如ZFS。</target>
        </trans-unit>
        <trans-unit id="0308bae19734e53e8eeb8fc72417975f82b4d057" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a common pattern in some query interfaces to &amp;ldquo;build&amp;rdquo; queries programmatically by instantiating a query object, calling it several times in succession to add query commands, then calling the execution command. This lets you dynamically change the query based on conditions at runtime. You might expect to do this in ReQL like so:</source>
          <target state="translated">在某些查询界面中，这是一种常见的模式，它通过实例化查询对象，依次调用多次以添加查询命令，然后调用执行命令来以编程方式&amp;ldquo;构建&amp;rdquo;查询。这使您可以在运行时根据条件动态更改查询。您可能希望在ReQL中这样做，如下所示：</target>
        </trans-unit>
        <trans-unit id="43d263475c984dca5d502747655b9f006256096e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a common task for web applications to accept file uploads from users; with RethinkDB you can store these files directly in the database.</source>
          <target state="translated">Web应用程序接受用户上传的文件是一项常见的任务。使用RethinkDB，您可以将这些文件直接存储在数据库中。</target>
        </trans-unit>
        <trans-unit id="4df14c095e2e2a042484762e7fae65618dd20e3e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s a natural and convenient way to express queries.</source>
          <target state="translated">这是表达查询的自然而便捷的方法。</target>
        </trans-unit>
        <trans-unit id="cd366d6aeb93bc8ec97f59c94513521c61f160c9" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for this error to be caused by a circular reference, where a document inadvertently contains itself:</source>
          <target state="translated">此错误也可能是由循环引用引起的，其中文档无意间包含了自身：</target>
        </trans-unit>
        <trans-unit id="7e119ec402d3bfe01c9d4e90058826653b70f9ef" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to use RethinkDB with Ruby on Rails. This guide assumes some familiarity with Rails and ActiveRecord. We&amp;rsquo;ll be using &lt;a href=&quot;http://nobrainer.io&quot;&gt;NoBrainer&lt;/a&gt;&amp;mdash;a RethinkDB ORM, which is an almost drop-in replacement for ActiveRecord.</source>
          <target state="translated">将RethinkDB与Ruby on Rails一起使用很容易。本指南假定您对Rails和ActiveRecord有所了解。我们将使用&lt;a href=&quot;http://nobrainer.io&quot;&gt;NoBrainer&lt;/a&gt; &amp;mdash; RethinkDB ORM，它几乎是ActiveRecord的直接替代品。</target>
        </trans-unit>
        <trans-unit id="30747a6d28762ec1343765ae06483c010e675643" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to increment a field value in a document&amp;mdash;for example, a counter&amp;mdash;in one step on the server.</source>
          <target state="translated">在服务器上的一步中，可以增加文档中的字段值（例如，计数器）。</target>
        </trans-unit>
        <trans-unit id="b1c38f29865ef6022444784351ea37ca314feb8c" translate="yes" xml:space="preserve">
          <source>JOINS</source>
          <target state="translated">JOINS</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="be4521311d0f547ae040a777490a7694a57f7b10" translate="yes" xml:space="preserve">
          <source>JSON files are preferred to CSV files, as JSON can represent RethinkDB documents fully. If you&amp;rsquo;re importing from a CSV file, you should include a header row with the field names, or use the &lt;code&gt;--no-header&lt;/code&gt; option with the &lt;code&gt;--custom-header&lt;/code&gt; option to specify the names.</source>
          <target state="translated">JSON文件比CSV文件优先，因为JSON可以完全代表RethinkDB文档。如果要从CSV文件导入，则应在标题行中包含字段名称，或将 &lt;code&gt;--no-header&lt;/code&gt; 选项与 &lt;code&gt;--custom-header&lt;/code&gt; 选项一起使用以指定名称。</target>
        </trans-unit>
        <trans-unit id="e027e57610f85225767aafbbf23fed7457e55828" translate="yes" xml:space="preserve">
          <source>Java</source>
          <target state="translated">Java</target>
        </trans-unit>
        <trans-unit id="ee620923ff5fc510555dc37083a135ee93b5404b" translate="yes" xml:space="preserve">
          <source>JavaScript</source>
          <target state="translated">JavaScript</target>
        </trans-unit>
        <trans-unit id="2150136b161bb7f3850c20f55af98f5e50de8133" translate="yes" xml:space="preserve">
          <source>JavaScript ORM for RethinkDB.</source>
          <target state="translated">RethinkDB的JavaScript ORM。</target>
        </trans-unit>
        <trans-unit id="2a15a5b5017d006df320fa6b8ac5c83f39e3e070" translate="yes" xml:space="preserve">
          <source>JavaScript ReQL command reference</source>
          <target state="translated">JavaScript ReQL命令参考</target>
        </trans-unit>
        <trans-unit id="12bfad731fd2da7fcf4e3ba16201bc4b30c542f9" translate="yes" xml:space="preserve">
          <source>JavaScript driver with Node.js</source>
          <target state="translated">Node.js的JavaScript驱动</target>
        </trans-unit>
        <trans-unit id="c5b67826a8b2b2a28d0ea2896c58630359061683" translate="yes" xml:space="preserve">
          <source>JavaScript has no native iterator, but ReQL implements an &lt;a href=&quot;../../api/javascript/each/index&quot;&gt;each&lt;/a&gt; command similar to &lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;jQuery&lt;/a&gt;&amp;rsquo;s.</source>
          <target state="translated">JavaScript没有本机迭代器，但是ReQL实现了类似于&lt;a href=&quot;http://api.jquery.com/each/&quot;&gt;jQuery&lt;/a&gt;的&lt;a href=&quot;../../api/javascript/each/index&quot;&gt;each&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="bebbf71cbcfcc4a8f36a414029104510399ac461" translate="yes" xml:space="preserve">
          <source>JavaScript has no native iterator, but ReQL implements an &lt;a href=&quot;../../api/javascript/each/index&quot;&gt;each&lt;/a&gt; command similar to &lt;a href=&quot;https://api.jquery.com/each/&quot;&gt;jQuery&lt;/a&gt;&amp;rsquo;s.</source>
          <target state="translated">JavaScript没有本机迭代器，但是ReQL实现了类似于&lt;a href=&quot;https://api.jquery.com/each/&quot;&gt;jQuery&lt;/a&gt;的&lt;a href=&quot;../../api/javascript/each/index&quot;&gt;each&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="437736fdb5bb707abdc048483193c86b9a99983e" translate="yes" xml:space="preserve">
          <source>Jobs</source>
          <target state="translated">Jobs</target>
        </trans-unit>
        <trans-unit id="7bb6a0357b0f1772fd50b7f8539ec577ed6f6748" translate="yes" xml:space="preserve">
          <source>Join tables using a field or function on the left-hand sequence matching primary keys or secondary indexes on the right-hand table. &lt;code&gt;eqJoin&lt;/code&gt; is more efficient than other ReQL join types, and operates much faster. Documents in the result set consist of pairs of left-hand and right-hand documents, matched when the field on the left-hand side exists and is non-null and an entry with that field&amp;rsquo;s value exists in the specified index on the right-hand side.</source>
          <target state="translated">使用左侧序列上的字段或函数连接表，使其与右侧表上的主键或辅助索引匹配。 &lt;code&gt;eqJoin&lt;/code&gt; 比其他ReQL连接类型更高效，并且运行速度更快。结果集中的文档由成对的左手文档和右手文档组成，当左手边的字段存在且为非空并且在右手边的指定索引中存在具有该字段值的条目时，这些匹配手侧。</target>
        </trans-unit>
        <trans-unit id="442e9473c8c4abf9dfcae036af694232b5434ef9" translate="yes" xml:space="preserve">
          <source>Join these tables using &lt;code&gt;gameId&lt;/code&gt; on the player table and &lt;code&gt;id&lt;/code&gt; on the games table:</source>
          <target state="translated">使用玩家表上的 &lt;code&gt;gameId&lt;/code&gt; 和游戏表上的 &lt;code&gt;id&lt;/code&gt; 将这些表连接起来：</target>
        </trans-unit>
        <trans-unit id="3b2597a987d6f7990bcc2736d74772e6aaab9771" translate="yes" xml:space="preserve">
          <source>Joining multiple changefeeds into one</source>
          <target state="translated">将多个换料合并为一个</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="614248f657c4cd869544f362220155e71e70a6d3" translate="yes" xml:space="preserve">
          <source>Jump into the &lt;a href=&quot;../../cookbook/javascript/index&quot;&gt;cookbook&lt;/a&gt; and browse through dozens of examples of common RethinkDB queries.</source>
          <target state="translated">跳入&lt;a href=&quot;../../cookbook/javascript/index&quot;&gt;食谱&lt;/a&gt;并浏览数十个常见的RethinkDB查询示例。</target>
        </trans-unit>
        <trans-unit id="cadea68a130fb4da345a2bd00c5bc5ec1fdab118" translate="yes" xml:space="preserve">
          <source>Jump into the &lt;a href=&quot;../cookbook/javascript/index&quot;&gt;cookbook&lt;/a&gt; and see dozens of examples of common RethinkDB queries.</source>
          <target state="translated">跳入&lt;a href=&quot;../cookbook/javascript/index&quot;&gt;食谱&lt;/a&gt;，查看数十个常见的RethinkDB查询示例。</target>
        </trans-unit>
        <trans-unit id="815740848353ae01fefc9bf1699f34710f065f60" translate="yes" xml:space="preserve">
          <source>Just in case you needed another calculator, ReQL can do that too!</source>
          <target state="translated">如果你需要另一个计算器,ReQL也可以做到这一点。</target>
        </trans-unit>
        <trans-unit id="df1556914f9d65ff6bb135e1e34b460926c8b594" translate="yes" xml:space="preserve">
          <source>Just like other ReQL indexes, you can create an index using an anonymous function rather than a simple field name, as well as create multi indexes by using the &lt;code&gt;multi&lt;/code&gt; flag with &lt;code&gt;geo&lt;/code&gt;. Read the &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; API documentation for more details.</source>
          <target state="translated">与其他ReQL索引一样，您可以使用匿名函数而不是简单的字段名来创建索引，也可以通过将 &lt;code&gt;multi&lt;/code&gt; 标志与 &lt;code&gt;geo&lt;/code&gt; 一起使用来创建多个索引。请阅读&lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt; API文档以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="2d5bfabcb6bca6d271e3af0b81998719a3d8e256" translate="yes" xml:space="preserve">
          <source>Koa</source>
          <target state="translated">Koa</target>
        </trans-unit>
        <trans-unit id="0cd80e0b1a0d9ca537de8880c046d1db4c5bba77" translate="yes" xml:space="preserve">
          <source>Koa middleware that automatically manages connections via a connection pool.</source>
          <target state="translated">Koa中间件通过连接池自动管理连接。</target>
        </trans-unit>
        <trans-unit id="26fad106569fcec275e401a5f8f426bcdc4c1a5d" translate="yes" xml:space="preserve">
          <source>Lambda functions in RethinkDB</source>
          <target state="translated">RethinkDB中的Lambda函数</target>
        </trans-unit>
        <trans-unit id="b3efedc3036d62c6e9695305d32c2033a97f6fed" translate="yes" xml:space="preserve">
          <source>Larger documents of more than 250 bytes are stored in blocks of their own. Documents up to 4 KB use a single block; larger documents are split across multiple blocks as needed.</source>
          <target state="translated">超过250字节的大型文档存储在自己的块中。4 KB以下的文档使用一个块;较大的文档根据需要分成多个块。</target>
        </trans-unit>
        <trans-unit id="5d9c8282669843d174d46b5ef2c7b930b7ff91c0" translate="yes" xml:space="preserve">
          <source>Lastly, we call &lt;code&gt;run(connection, callback)&lt;/code&gt; in order to send the query to the server.</source>
          <target state="translated">最后，我们调用 &lt;code&gt;run(connection, callback)&lt;/code&gt; 以便将查询发送到服务器。</target>
        </trans-unit>
        <trans-unit id="b593864b68f106789807303bd0cf74356e8e4ff9" translate="yes" xml:space="preserve">
          <source>Latency is also an important metric to measure when testing performance. We found that in a 16-node cluster, the 95th percentile for Workload A query latencies is 26ms.</source>
          <target state="translated">在测试性能时,延迟也是一个重要的衡量指标。我们发现,在一个16节点的集群中,工作负载A查询延迟的第95百分位数是26ms。</target>
        </trans-unit>
        <trans-unit id="ec18da38841bcc22e0215d72fe5f8195fe0cb024" translate="yes" xml:space="preserve">
          <source>Launching an instance</source>
          <target state="translated">启动一个实例</target>
        </trans-unit>
        <trans-unit id="cde4c57577148cb7290eeb61254becb94294e003" translate="yes" xml:space="preserve">
          <source>Lazily iterate over a cursor, array, or feed one element at a time. &lt;code&gt;eachAsync&lt;/code&gt; always returns a promise that will be resolved once all rows are returned.</source>
          <target state="translated">懒惰地遍历游标，数组或一次提供一个元素。 &lt;code&gt;eachAsync&lt;/code&gt; 总是返回一个承诺，一旦返回所有行，该承诺将被解决。</target>
        </trans-unit>
        <trans-unit id="7580d3d26925e442143c501474aa5ee2f4ba2239" translate="yes" xml:space="preserve">
          <source>Lazily iterate over the result set one element at a time. The second callback is optional and is called when the iteration stops (when there are no more rows or when the callback returns &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">懒惰地一次遍历结果集一个元素。第二个回调是可选的，并在迭代停止时（没有更多行或回调返回 &lt;code&gt;false&lt;/code&gt; 时）被调用。</target>
        </trans-unit>
        <trans-unit id="882d7824546e260d7aecb582ca23a9e9525d35d8" translate="yes" xml:space="preserve">
          <source>Laziness</source>
          <target state="translated">Laziness</target>
        </trans-unit>
        <trans-unit id="119a27138fe3d276ec8a407746eb7af54a9639ef" translate="yes" xml:space="preserve">
          <source>Leap-seconds aren&amp;rsquo;t well-supported right now: &lt;code&gt;2012-06-30T23:59:60&lt;/code&gt; and &lt;code&gt;2012-07-01T00:00:00&lt;/code&gt; parse to the same time.</source>
          <target state="translated">秒现在没有得到很好的支持： &lt;code&gt;2012-06-30T23:59:60&lt;/code&gt; 和 &lt;code&gt;2012-07-01T00:00:00&lt;/code&gt; 同时解析。</target>
        </trans-unit>
        <trans-unit id="7352c39338b0f7491547ec046eb62e590d5666fa" translate="yes" xml:space="preserve">
          <source>Learn about changefeeds, RethinkDB's realtime push technology, and how it can be used to build and scale realtime apps.</source>
          <target state="translated">了解changefeeds、RethinkDB的实时推送技术,以及如何使用它来构建和扩展实时应用。</target>
        </trans-unit>
        <trans-unit id="053b8690ab05d3886d2e0a4df01379bf8f5f5878" translate="yes" xml:space="preserve">
          <source>Learn how to deploy RethinkDB on cloud services like Compose.io, AWS, and others.</source>
          <target state="translated">了解如何在Compose.io、AWS等云服务上部署RethinkDB。</target>
        </trans-unit>
        <trans-unit id="4008d50d045acf61774875510316c96f31310945" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">了解如何在RethinkDB中使用&lt;a href=&quot;../../map-reduce/index&quot;&gt;map-&lt;/a&gt; reduce。</target>
        </trans-unit>
        <trans-unit id="e7a12b247f8e4dd853fb7027039428b2379a21df" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../../table-joins/index&quot;&gt;table joins&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">了解如何在RethinkDB中使用&lt;a href=&quot;../../table-joins/index&quot;&gt;表联接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38439358cead9a9ddb8011466b2b2f821423863f" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../map-reduce/index&quot;&gt;map-reduce&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">了解如何在RethinkDB中使用&lt;a href=&quot;../map-reduce/index&quot;&gt;map-&lt;/a&gt; reduce。</target>
        </trans-unit>
        <trans-unit id="9211e3e0cf73e7b17435ad61921079b0ccf56943" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;primary and secondary indexes&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">了解如何在RethinkDB中使用&lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;主索引和辅助索引&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46618e390b1b640a19b5fe7e820ff17c339e0144" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;a href=&quot;../table-joins/index&quot;&gt;table joins&lt;/a&gt; in RethinkDB.</source>
          <target state="translated">了解如何在RethinkDB中使用&lt;a href=&quot;../table-joins/index&quot;&gt;表联接&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f065a72b19aac97d11c858d3ee474f834c0ea4e9" translate="yes" xml:space="preserve">
          <source>Learn how to use GeoJSON features to build location-aware apps in RethinkDB.</source>
          <target state="translated">学习如何使用GeoJSON功能在RethinkDB中构建位置感知的应用程序。</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">了解更多</target>
        </trans-unit>
        <trans-unit id="7a058f790976caa297b4022af937873c407c3337" translate="yes" xml:space="preserve">
          <source>Learn more about how RethinkDB can efficiently retrieve documents with &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;secondary indexes&lt;/a&gt;.</source>
          <target state="translated">了解有关RethinkDB如何有效检索具有&lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;二级索引的&lt;/a&gt;文档的更多信息。</target>
        </trans-unit>
        <trans-unit id="89b463fdfab8c2b3e899da5b283265547e388a16" translate="yes" xml:space="preserve">
          <source>Learning the language is no different from learning any other library.</source>
          <target state="translated">学习语文和学习其他图书馆没有什么不同。</target>
        </trans-unit>
        <trans-unit id="3b20a7997c63ce3054fd7d30d35de4678173fe84" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore the advantages and disadvantages of each approach. We&amp;rsquo;ll use a simple blog database that stores information about authors and their posts to demonstrate them.</source>
          <target state="translated">让我们探讨每种方法的优缺点。我们将使用一个简单的博客数据库来存储有关作者及其帖子的信息，以向他们展示。</target>
        </trans-unit>
        <trans-unit id="0a3374d1d23dd959122583511673592b311245c8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s filter based on the nested field &lt;code&gt;email&lt;/code&gt;:</source>
          <target state="translated">让我们根据嵌套字段 &lt;code&gt;email&lt;/code&gt; 进行过滤：</target>
        </trans-unit>
        <trans-unit id="cb7b4f56da03ec0ec2ef157f49777af0230bdeb9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s find the most influential GitHub users who showed interest in RethinkDB. First, let&amp;rsquo;s grab the list of RethinkDB stargazers:</source>
          <target state="translated">让我们找到对RethinkDB感兴趣的最具影响力的GitHub用户。首先，让我们获取RethinkDB观星者的列表：</target>
        </trans-unit>
        <trans-unit id="7c2b1f805ab05c4e6512aa8198d873b9d8e69683" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s follow the processing of a simple query. (This example uses JavaScript, but the commands are virtually identical in other languages.)</source>
          <target state="translated">让我们跟随一个简单查询的处理。（此示例使用JavaScript，但是其他语言中的命令实际上是相同的。）</target>
        </trans-unit>
        <trans-unit id="e6b2a5e6f45fc67a9ecc8d1de778247a2bb0f236" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s insert three new documents into the &lt;code&gt;authors&lt;/code&gt; table:</source>
          <target state="translated">让我们在 &lt;code&gt;authors&lt;/code&gt; 表中插入三个新文档：</target>
        </trans-unit>
        <trans-unit id="b741c7ad37ec13a7b2f8b15575a0343bd5b1de26" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at these concepts in more detail.</source>
          <target state="translated">让我们更详细地了解这些概念。</target>
        </trans-unit>
        <trans-unit id="ef26fdd5241f22380a2542ba5b766049445eb40d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have another table &lt;code&gt;authors&lt;/code&gt;, and we&amp;rsquo;d like to get a list of authors whose last names are also in the &lt;code&gt;users&lt;/code&gt; table we&amp;rsquo;ve seen before. We can do it by combining two queries:</source>
          <target state="translated">假设我们还有另一个表 &lt;code&gt;authors&lt;/code&gt; ，我们希望获得一个作者列表，其姓氏也在我们之前见过的 &lt;code&gt;users&lt;/code&gt; 表中。我们可以通过组合两个查询来做到这一点：</target>
        </trans-unit>
        <trans-unit id="b7ff567a62fcc49849955f0084cafdf6e60d5359" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we want to publish the teaming up between Batman, Superman and the Joker:</source>
          <target state="translated">假设我们要发布蝙蝠侠，超人和小丑之间的团队合作：</target>
        </trans-unit>
        <trans-unit id="4c97142a03d1740d9845e909927ca5b45579f24c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how we can use joins in RethinkDB to query data based on &lt;strong&gt;one to many&lt;/strong&gt;, and &lt;strong&gt;many to many&lt;/strong&gt; relations.</source>
          <target state="translated">让我们看看如何在RethinkDB中使用联接基于&lt;strong&gt;一对多&lt;/strong&gt;和&lt;strong&gt;多对多&lt;/strong&gt;关系查询数据。</target>
        </trans-unit>
        <trans-unit id="b9a6c351ade4cff6a3547f0d48de14100d80140b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a simple example. RethinkDB supports server-side JavaScript evaluation using the embedded V8 engine (sandboxed within outside processes, of course):</source>
          <target state="translated">让我们从一个简单的例子开始。RethinkDB支持使用嵌入式V8引擎（当然，在外部进程中包含沙盒）来进行服务器端JavaScript评估：</target>
        </trans-unit>
        <trans-unit id="49a17718af97d847a464ec714b54c94d0f64ebbe" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s suppose we&amp;rsquo;ve created two tables: &lt;code&gt;employees&lt;/code&gt; and &lt;code&gt;companies&lt;/code&gt;. We&amp;rsquo;ll use these tables to model the notion of people working for organizations (each organization has multiple people working for it, but any given person works at a single organization). Here&amp;rsquo;s an example document in the &lt;code&gt;employees&lt;/code&gt; table:</source>
          <target state="translated">假设我们已经创建了两个表： &lt;code&gt;employees&lt;/code&gt; 和 &lt;code&gt;companies&lt;/code&gt; 。我们将使用这些表来建模为组织工作的人员的概念（每个组织都有多个工作人员，但是任何给定的人都在单个组织中工作）。这是 &lt;code&gt;employees&lt;/code&gt; 表中的示例文档：</target>
        </trans-unit>
        <trans-unit id="b79e2ec29148ce71c9f97e43dc0f1bb9de49bd76" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try something very simple &amp;mdash; accessing a website. Type the following command in the Data Explorer and hit &amp;lsquo;Run&amp;rsquo; (alternatively, you can run it from a RethinkDB driver):</source>
          <target state="translated">让我们尝试一些简单的方法-访问网站。在数据资源管理器中键入以下命令，然后单击&amp;ldquo;运行&amp;rdquo;（或者，您可以从RethinkDB驱动程序运行它）：</target>
        </trans-unit>
        <trans-unit id="d523c71f4437b42b411bb4d2f3290905dc21ba48" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try to retrieve the document where the &lt;code&gt;name&lt;/code&gt; attribute is set to &lt;code&gt;William Adama&lt;/code&gt;. We can use a condition to filter the documents by chaining a &lt;code&gt;filter&lt;/code&gt; command to the end of the query:</source>
          <target state="translated">让我们尝试检索 &lt;code&gt;name&lt;/code&gt; 属性设置为 &lt;code&gt;William Adama&lt;/code&gt; 的文档。我们可以使用条件通过将 &lt;code&gt;filter&lt;/code&gt; 命令链接到查询的末尾来过滤文档：</target>
        </trans-unit>
        <trans-unit id="74167a956b2c180d4d5a4db633dfab9b54f1b3ee" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update all documents in the &lt;code&gt;authors&lt;/code&gt; table and add a &lt;code&gt;type&lt;/code&gt; field to note that every author so far is fictional:</source>
          <target state="translated">让我们更新 &lt;code&gt;authors&lt;/code&gt; 表中的所有文档，并添加一个 &lt;code&gt;type&lt;/code&gt; 字段以指出到目前为止，每个作者都是虚构的：</target>
        </trans-unit>
        <trans-unit id="e46cc597dcd23c00f763aa1f360f40229ca58a86" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update our stargazer data with this additional information:</source>
          <target state="translated">让我们使用以下附加信息更新观星者数据：</target>
        </trans-unit>
        <trans-unit id="5cc9d86c4961df923fc41b3ea88b4072aa84010d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use &lt;code&gt;filter&lt;/code&gt; again to retrieve all authors who have more than two posts:</source>
          <target state="translated">让我们再次使用 &lt;code&gt;filter&lt;/code&gt; 来检索具有两个以上帖子的所有作者：</target>
        </trans-unit>
        <trans-unit id="0bbb0ddb2e3183cfe93ee6ec919cd561d521a487" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a script that listens for changes in the RethinkDB server and pushes them to RabbitMQ.</source>
          <target state="translated">让我们编写一个脚本，侦听RethinkDB服务器中的更改并将其推送到RabbitMQ。</target>
        </trans-unit>
        <trans-unit id="332e9d887845f15f8edb7f47a27c9feaa5e64473" translate="yes" xml:space="preserve">
          <source>Lets you install RethinkDB using Vagrant.</source>
          <target state="translated">让你使用Vagrant安装RethinkDB。</target>
        </trans-unit>
        <trans-unit id="faa75a36abc1bfd1fe97a7d7bec24659e766b29c" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.</source>
          <target state="translated">采用知识共享署名-相同方式共享3.0未移植许可协议进行许可。</target>
        </trans-unit>
        <trans-unit id="e3891b7e1579150dc791a1037b6ef7ffc603c47a" translate="yes" xml:space="preserve">
          <source>Like any ReQL command, &lt;code&gt;changes&lt;/code&gt; integrates with the rest of the query language. You can call &lt;code&gt;changes&lt;/code&gt; after most commands that transform or select data:</source>
          <target state="translated">像任何ReQL命令一样， &lt;code&gt;changes&lt;/code&gt; 与其余查询语言集成在一起。您可以在大多数转换或选择数据的命令之后调用 &lt;code&gt;changes&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="50c623d37beca2feae774d169fbe6b85ee0be7e7" translate="yes" xml:space="preserve">
          <source>Like many traditional database systems, RethinkDB supports &lt;code&gt;JOIN&lt;/code&gt; commands to combine data from multiple tables. In RethinkDB joins are automatically distributed&amp;mdash;a join command is automatically sent to the appropriate nodes across the cluster, the relevant data is combined, and the final result is presented to the user.</source>
          <target state="translated">像许多传统的数据库系统一样，RethinkDB支持 &lt;code&gt;JOIN&lt;/code&gt; 命令来组合来自多个表的数据。在RethinkDB中，联接是自动分布的&amp;mdash;联接命令会自动发送到整个集群中的适当节点，合并相关数据，并将最终结果呈现给用户。</target>
        </trans-unit>
        <trans-unit id="b81e349422612226eccc114d5f889ba875ee59c6" translate="yes" xml:space="preserve">
          <source>Like most database systems, ReQL supports primary and secondary indexes to allow efficient data access. You can also create compound indexes and indexes based on arbitrary ReQL expressions to speed up complex queries.</source>
          <target state="translated">与大多数数据库系统一样,ReQL支持主索引和次索引,以实现高效的数据访问。您还可以创建复合索引和基于任意ReQL表达式的索引,以加快复杂查询的速度。</target>
        </trans-unit>
        <trans-unit id="cbcbaaf781c0838f0b358c0dddcca12bc10e4339" translate="yes" xml:space="preserve">
          <source>Limitations of automatic failover</source>
          <target state="translated">自动故障切换的局限性</target>
        </trans-unit>
        <trans-unit id="8f13609bf219f6ca237069b790c4c9a2ad381552" translate="yes" xml:space="preserve">
          <source>Limiting the number of returned documents</source>
          <target state="translated">限制退回文件的数量</target>
        </trans-unit>
        <trans-unit id="46453bf012aa531ac54613a0f5623dcf3c269fca" translate="yes" xml:space="preserve">
          <source>Linearizability and atomicity guarantees</source>
          <target state="translated">可线性化和原子性保证</target>
        </trans-unit>
        <trans-unit id="8079cd01630a2b6f154b2abd4aca58bf065d2bf7" translate="yes" xml:space="preserve">
          <source>Lines and distances</source>
          <target state="translated">线路和距离</target>
        </trans-unit>
        <trans-unit id="f8a8b40332141131251cba0338928c84cbc899bd" translate="yes" xml:space="preserve">
          <source>Lines and polygons can be specified using either point objects or sequences of two-number arrays:</source>
          <target state="translated">线条和多边形可以使用点对象或两数组的序列来指定。</target>
        </trans-unit>
        <trans-unit id="e2e17174307bd30c9651cd5cd7f2b98cd08f8a35" translate="yes" xml:space="preserve">
          <source>Linking documents in multiple tables</source>
          <target state="translated">在多个表格中链接文件</target>
        </trans-unit>
        <trans-unit id="6ed36fa1183214845ee195f26eeda3f8866b655a" translate="yes" xml:space="preserve">
          <source>Linux Mint</source>
          <target state="translated">Linux Mint</target>
        </trans-unit>
        <trans-unit id="d51bed5d4234a9759d6a8aab8a001767fd630b60" translate="yes" xml:space="preserve">
          <source>Linux and OS X</source>
          <target state="translated">Linux和OS X</target>
        </trans-unit>
        <trans-unit id="a6b55add3271bf52f9229b1f55c71bf39192ee0c" translate="yes" xml:space="preserve">
          <source>List all database names in the system. The result is a list of strings.</source>
          <target state="translated">列出系统中所有的数据库名称。结果是一个字符串的列表。</target>
        </trans-unit>
        <trans-unit id="993b1d68164e0a0c046c84b9ca43c4e5830eec98" translate="yes" xml:space="preserve">
          <source>List all table names in a database. The result is a list of strings.</source>
          <target state="translated">列出数据库中的所有表名。结果是一个字符串的列表。</target>
        </trans-unit>
        <trans-unit id="3bb65a3a68d5a8ad114346be2ad7ccd0b325bc12" translate="yes" xml:space="preserve">
          <source>List all the secondary indexes of this table.</source>
          <target state="translated">列出本表的所有二级索引。</target>
        </trans-unit>
        <trans-unit id="cca8cd4e2bc2f275251b8f0b5ed8434b92cf0173" translate="yes" xml:space="preserve">
          <source>Listen for changes in a RethinkDB table over RabbitMQ.</source>
          <target state="translated">通过 RabbitMQ 侦听 RethinkDB 表中的变化。</target>
        </trans-unit>
        <trans-unit id="eb6fc719e4222cb0e021bed23a373eb005d0e88d" translate="yes" xml:space="preserve">
          <source>Listening to RabbitMQ messages</source>
          <target state="translated">听取RabbitMQ消息</target>
        </trans-unit>
        <trans-unit id="5ec7392e4c45dc057d7ab6c781c38d95f4d3346a" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;python&lt;/code&gt; (or &lt;a href=&quot;http://ipython.org&quot;&gt;ipython&lt;/a&gt;) and set up a connection to your database:</source>
          <target state="translated">加载 &lt;code&gt;python&lt;/code&gt; （或&lt;a href=&quot;http://ipython.org&quot;&gt;ipython&lt;/a&gt;）并建立与数据库的连接：</target>
        </trans-unit>
        <trans-unit id="37819416fc67fd2f5cd366c850cf56b4ff2d213c" translate="yes" xml:space="preserve">
          <source>Log in using the username &lt;code&gt;rethinkdb&lt;/code&gt; and the password you chose in step 7.</source>
          <target state="translated">使用用户名 &lt;code&gt;rethinkdb&lt;/code&gt; 和在步骤7中选择的密码登录。</target>
        </trans-unit>
        <trans-unit id="d2e3210b91ade80c488bbcfd4ac6f12798b16237" translate="yes" xml:space="preserve">
          <source>Log options</source>
          <target state="translated">日志选项</target>
        </trans-unit>
        <trans-unit id="aa42cc5f49c6d291cfc5d71f7d47803ff3f9de31" translate="yes" xml:space="preserve">
          <source>Log write issues</source>
          <target state="translated">日志写入问题</target>
        </trans-unit>
        <trans-unit id="00d45cf43ab6900d309ef4eaaa39f6e115347863" translate="yes" xml:space="preserve">
          <source>Logging tools</source>
          <target state="translated">测井工具</target>
        </trans-unit>
        <trans-unit id="77579f2f6e9a0b7bf5302dfdb7b5e31eec34bd09" translate="yes" xml:space="preserve">
          <source>Longitude (&amp;minus;180 to 180) and latitude (&amp;minus;90 to 90) of vertices are plotted on a perfect sphere. See &lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;Geospatial support&lt;/a&gt; for more information on ReQL&amp;rsquo;s coordinate system.</source>
          <target state="translated">顶点的经度（-180至180）和纬度（-90至90）绘制在理想球体上。有关ReQL坐标系的更多信息，请参见&lt;a href=&quot;../../../docs/geo-support/javascript/index&quot;&gt;地理空间支持&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7f41960132584f9d7bd0c067c3f4dfa28d057b2" translate="yes" xml:space="preserve">
          <source>Look at how many arguments the function takes (&lt;code&gt;num_args&lt;/code&gt;)</source>
          <target state="translated">查看函数需要多少个参数（ &lt;code&gt;num_args&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c92246116a0060ce1970018249864b4c7a3348ef" translate="yes" xml:space="preserve">
          <source>Loop over a sequence, evaluating the given write query for each element.</source>
          <target state="translated">在一个序列上循环,对每个元素评估给定的写查询。</target>
        </trans-unit>
        <trans-unit id="c6ceab055f64bcd972209f1ed242740ed0fe108b" translate="yes" xml:space="preserve">
          <source>Lowercases a string.</source>
          <target state="translated">小写一个字符串。</target>
        </trans-unit>
        <trans-unit id="b0832074630eb731d7fbe8074de48a90cd9bb220" translate="yes" xml:space="preserve">
          <source>Lua</source>
          <target state="translated">Lua</target>
        </trans-unit>
        <trans-unit id="853db5db5e9449857a125fdaf64c49523fbe605b" translate="yes" xml:space="preserve">
          <source>Make also sure you&amp;rsquo;ve &lt;a href=&quot;https://rethinkdb.com/docs/install-drivers/javascript/&quot;&gt;installed the JavaScript driver&lt;/a&gt;.</source>
          <target state="translated">还要确保已&lt;a href=&quot;https://rethinkdb.com/docs/install-drivers/javascript/&quot;&gt;安装JavaScript驱动程序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae4a8e3bb1c5ba5084979d58dccde30ec4b6619e" translate="yes" xml:space="preserve">
          <source>Make sure you&amp;rsquo;ve &lt;a href=&quot;https://rethinkdb.com/install&quot;&gt;installed RethinkDB&lt;/a&gt;&amp;mdash;it should only take a minute!</source>
          <target state="translated">确保已&lt;a href=&quot;https://rethinkdb.com/install&quot;&gt;安装RethinkDB-&lt;/a&gt;仅需一分钟！</target>
        </trans-unit>
        <trans-unit id="ec8db219e768dbf927afc537cce0ed0ac5d426cf" translate="yes" xml:space="preserve">
          <source>Manipulating Databases</source>
          <target state="translated">操作数据库</target>
        </trans-unit>
        <trans-unit id="cd5274de84779cf7e26c8aeb43ee293a6d239ace" translate="yes" xml:space="preserve">
          <source>Manipulating Tables</source>
          <target state="translated">操作表格</target>
        </trans-unit>
        <trans-unit id="0315f3bc6857038096e10b57a0d97ca1a21082ee" translate="yes" xml:space="preserve">
          <source>Manipulating databases</source>
          <target state="translated">操作数据库</target>
        </trans-unit>
        <trans-unit id="85cd44aae68cc1b84cb48c7c2fe761b7d6e991c5" translate="yes" xml:space="preserve">
          <source>Manipulating documents</source>
          <target state="translated">操作文件</target>
        </trans-unit>
        <trans-unit id="379776eeb89cc816e18680ac4dff7a7359381323" translate="yes" xml:space="preserve">
          <source>Manipulating indexes with the web UI</source>
          <target state="translated">用Web用户界面操纵索引</target>
        </trans-unit>
        <trans-unit id="ae4c8c8c4f2c5ea1dc21a8c397caa583dd053f78" translate="yes" xml:space="preserve">
          <source>Manipulating indexes: &lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/index_drop/index&quot;&gt;indexDrop&lt;/a&gt; and &lt;a href=&quot;../../../api/javascript/index_list/index&quot;&gt;indexList&lt;/a&gt;</source>
          <target state="translated">操作索引：&lt;a href=&quot;../../../api/javascript/index_create/index&quot;&gt;indexCreate&lt;/a&gt;，&lt;a href=&quot;../../../api/javascript/index_drop/index&quot;&gt;indexDrop&lt;/a&gt;和&lt;a href=&quot;../../../api/javascript/index_list/index&quot;&gt;indexList&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e391b105e9585f961562e7064cb0aa9414e73a72" translate="yes" xml:space="preserve">
          <source>Manipulating tables</source>
          <target state="translated">操作表格</target>
        </trans-unit>
        <trans-unit id="f17e3cdc08f968d3b1b8c2ec9eb1ceefef64f7ee" translate="yes" xml:space="preserve">
          <source>Manually merge the left and right fields</source>
          <target state="translated">手动合并左边和右边的字段</target>
        </trans-unit>
        <trans-unit id="b9a082aaaec9d03b12fca89934928f413350caae" translate="yes" xml:space="preserve">
          <source>Many people have been reporting that they get back a connection object when they run a query, the object being:</source>
          <target state="translated">很多人都反映,他们在运行查询时,得到一个连接对象,这个对象是。</target>
        </trans-unit>
        <trans-unit id="bf4d9a2e9aca1ebab3357daa2f4482b382a28a79" translate="yes" xml:space="preserve">
          <source>Many to many relations</source>
          <target state="translated">多对多关系</target>
        </trans-unit>
        <trans-unit id="d103bd0ce354a22ec2d971d2a818261309039c72" translate="yes" xml:space="preserve">
          <source>Map-reduce in RethinkDB</source>
          <target state="translated">RethinkDB中的Map-reduce</target>
        </trans-unit>
        <trans-unit id="ec8bb2749b0912c81ba2d5e51014afb3a3980c0f" translate="yes" xml:space="preserve">
          <source>Matches against a regular expression. If there is a match, returns an object with the fields:</source>
          <target state="translated">与正则表达式进行匹配。如果匹配,返回一个包含字段的对象。</target>
        </trans-unit>
        <trans-unit id="aded3de93027fd725e41f6ca4105d385535009bf" translate="yes" xml:space="preserve">
          <source>Math and Logic</source>
          <target state="translated">数学和逻辑</target>
        </trans-unit>
        <trans-unit id="e76587c25d66762a167abd2d402654b3cc867d80" translate="yes" xml:space="preserve">
          <source>Math and logic</source>
          <target state="translated">数学和逻辑</target>
        </trans-unit>
        <trans-unit id="6888270cc5b2dfaf0916f2237e02a11e56088cf7" translate="yes" xml:space="preserve">
          <source>Memory availability issues</source>
          <target state="translated">内存可用性问题</target>
        </trans-unit>
        <trans-unit id="110c6707f36ae400d4ca884b4a45ac2166550586" translate="yes" xml:space="preserve">
          <source>Memory requirements</source>
          <target state="translated">所需内存</target>
        </trans-unit>
        <trans-unit id="5dd7c30db3f640d34b64d0e2719a800c2ccfb0d5" translate="yes" xml:space="preserve">
          <source>Merge two or more objects together to construct a new object with properties from all. When there is a conflict between field names, preference is given to fields in the rightmost object in the argument list. &lt;code&gt;merge&lt;/code&gt; also accepts a subquery function that returns an object, which will be used similarly to a &lt;a href=&quot;../map/index&quot;&gt;map&lt;/a&gt; function.</source>
          <target state="translated">将两个或多个对象合并在一起以构造一个具有所有属性的新对象。当字段名称之间存在冲突时，将优先考虑参数列表中最右边对象中的字段。 &lt;code&gt;merge&lt;/code&gt; 还接受一个返回对象的子查询函数，该对象将与&lt;a href=&quot;../map/index&quot;&gt;映射&lt;/a&gt;函数类似地使用。</target>
        </trans-unit>
        <trans-unit id="04d73701de8502ed6708d400a96b65af03f13dbb" translate="yes" xml:space="preserve">
          <source>Merge two or more objects together to construct a new object with properties from all. When there is a conflict between field names, preference is given to fields in the rightmost object in the argument list. &lt;code&gt;merge&lt;/code&gt; also accepts a subquery function that returns an object, which will be used similarly to a &lt;a href=&quot;map/index&quot;&gt;map&lt;/a&gt; function.</source>
          <target state="translated">将两个或多个对象合并在一起以构造一个具有所有属性的新对象。当字段名称之间存在冲突时，将优先考虑参数列表中最右边对象中的字段。 &lt;code&gt;merge&lt;/code&gt; 还接受一个返回对象的子查询函数，该对象将与&lt;a href=&quot;map/index&quot;&gt;映射&lt;/a&gt;函数类似地使用。</target>
        </trans-unit>
        <trans-unit id="98f6cf8510e0439f12bcf7a86ba1ceba63386fc2" translate="yes" xml:space="preserve">
          <source>Merge two or more sequences.</source>
          <target state="translated">合并两个或多个序列。</target>
        </trans-unit>
        <trans-unit id="1f0a513d0abdd16d2f84502191d76b98a52fb8f7" translate="yes" xml:space="preserve">
          <source>Migrating data from previous versions of RethinkDB</source>
          <target state="translated">从以前版本的RethinkDB中迁移数据。</target>
        </trans-unit>
        <trans-unit id="aa6d9b542df934b1fb7cababc57d99f0c762b82c" translate="yes" xml:space="preserve">
          <source>Migrating old data</source>
          <target state="translated">迁移旧数据</target>
        </trans-unit>
        <trans-unit id="ce5743bd4325e12d91947a3f4a1b808fb776fbbb" translate="yes" xml:space="preserve">
          <source>Migration consists of three simple steps:</source>
          <target state="translated">迁移包括三个简单的步骤:</target>
        </trans-unit>
        <trans-unit id="7fe0b02845ac7e31f8355515cfa9358814ea98d9" translate="yes" xml:space="preserve">
          <source>Mimics the behavior of Python&amp;rsquo;s &lt;code&gt;string.split&lt;/code&gt; in edge cases, except for splitting on the empty string, which instead produces an array of single-character strings.</source>
          <target state="translated">模拟在 &lt;code&gt;string.split&lt;/code&gt; 情况下Python的string.split的行为，除了在空字符串上分割外，它会生成一个单字符字符串数组。</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="1a0e2290409950c22eeaa9cec60aef1b7a34fe19" translate="yes" xml:space="preserve">
          <source>Mixed sequences of data sort in the following order:</source>
          <target state="translated">混合数据序列按以下顺序排序:</target>
        </trans-unit>
        <trans-unit id="050aa84d9f3547048f944db27736fa71c21601f8" translate="yes" xml:space="preserve">
          <source>Modeling relationships</source>
          <target state="translated">建立关系模型</target>
        </trans-unit>
        <trans-unit id="4d7ad1ad621c826e63ea432ff5d8acd0e7e9dbc1" translate="yes" xml:space="preserve">
          <source>Models in depth</source>
          <target state="translated">深度模型</target>
        </trans-unit>
        <trans-unit id="0e0c2052c8a28cb53004104670a5f3189e0ff126" translate="yes" xml:space="preserve">
          <source>Modifying times</source>
          <target state="translated">修改时间</target>
        </trans-unit>
        <trans-unit id="38ed8d7a13fc2d35939d911335ecac667570c279" translate="yes" xml:space="preserve">
          <source>Molly.js</source>
          <target state="translated">Molly.js</target>
        </trans-unit>
        <trans-unit id="4bab2d8fe13fa6ab57f80098b414f0f734c5dd25" translate="yes" xml:space="preserve">
          <source>More</source>
          <target state="translated">More</target>
        </trans-unit>
        <trans-unit id="65607507695dbb68853f7200e33956e39fd6a15d" translate="yes" xml:space="preserve">
          <source>More Examples</source>
          <target state="translated">更多例子</target>
        </trans-unit>
        <trans-unit id="41775da315d57d76ff81ed9611116e4ea3dfd26d" translate="yes" xml:space="preserve">
          <source>More complex predicates</source>
          <target state="translated">更复杂的谓词</target>
        </trans-unit>
        <trans-unit id="7180389997e0b1e0af0e7dc001fd021b621caff0" translate="yes" xml:space="preserve">
          <source>Most APIs support some form of authentication and rate limiting. The &lt;code&gt;r.http&lt;/code&gt; command supports common forms of authentication (see the &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;reference&lt;/a&gt; for more details). For example, here is how you can use GitHub tokens with basic auth:</source>
          <target state="translated">大多数API支持某种形式的身份验证和速率限制。所述 &lt;code&gt;r.http&lt;/code&gt; 命令支持（见认证的常见形式&lt;a href=&quot;../../api/javascript/http/index&quot;&gt;参考&lt;/a&gt;详细介绍）。例如，这是如何在基本身份验证中使用GitHub令牌：</target>
        </trans-unit>
        <trans-unit id="fa60d0629e116eb043cbf63a410f5ce6c0b76c72" translate="yes" xml:space="preserve">
          <source>Most date operations are only defined on years in the range &lt;code&gt;[1400, 10000]&lt;/code&gt; (but note that times in the year &lt;code&gt;10000&lt;/code&gt; cannot be printed as ISO 8601 dates).</source>
          <target state="translated">大多数日期操作仅在 &lt;code&gt;[1400, 10000]&lt;/code&gt; 范围内的年份定义（但请注意，不能将 &lt;code&gt;10000&lt;/code&gt; 年中的时间打印为ISO 8601日期）。</target>
        </trans-unit>
        <trans-unit id="0641f9094acfde9b6cf6cc3b9d52a297e0e65bd8" translate="yes" xml:space="preserve">
          <source>Multi indexes</source>
          <target state="translated">多索引</target>
        </trans-unit>
        <trans-unit id="98a7e7d6cc4d0854490ddbd7601741fd83b90023" translate="yes" xml:space="preserve">
          <source>Multi-datacenter setup</source>
          <target state="translated">多数据中心设置</target>
        </trans-unit>
        <trans-unit id="86753c0740ef8a696a347475bf1ea038b52b180e" translate="yes" xml:space="preserve">
          <source>Multipart responses</source>
          <target state="translated">多部分对策</target>
        </trans-unit>
        <trans-unit id="021a631169c4a417b486aab49a973289a6614f87" translate="yes" xml:space="preserve">
          <source>Multiple RethinkDB instances on a single machine</source>
          <target state="translated">一台机器上有多个RethinkDB实例。</target>
        </trans-unit>
        <trans-unit id="09ad7baebfde68a2882bc6128e8473c249838c72" translate="yes" xml:space="preserve">
          <source>Multiple instances</source>
          <target state="translated">多个实例</target>
        </trans-unit>
        <trans-unit id="cc1d53d7c78cd147a3d1ec6d9077c46bc8013328" translate="yes" xml:space="preserve">
          <source>Multiple servers, databases, or tables in the same database have been assigned the same name. The &lt;code&gt;name&lt;/code&gt; field shows the conflicting name; &lt;code&gt;ids&lt;/code&gt; are the UUIDs of the entities that have that name. In the case of &lt;code&gt;table_name_collision&lt;/code&gt;, &lt;code&gt;db&lt;/code&gt; will be the database that the tables are in. Rename the conflicting entities.</source>
          <target state="translated">已为同一数据库中的多个服务器，数据库或表分配了相同的名称。该 &lt;code&gt;name&lt;/code&gt; 字段显示冲突的名称; &lt;code&gt;ids&lt;/code&gt; 是具有该名称的实体的UUID。对于 &lt;code&gt;table_name_collision&lt;/code&gt; ， &lt;code&gt;db&lt;/code&gt; 将是表所在的数据库。重命名冲突的实体。</target>
        </trans-unit>
        <trans-unit id="8ee266f49fc4bb636b4d04389645377477ea4f26" translate="yes" xml:space="preserve">
          <source>Multiply two numbers, or make a periodic array.</source>
          <target state="translated">将两个数相乘,或者做一个周期性的数组。</target>
        </trans-unit>
        <trans-unit id="1f211804aeeccd93ce4380676a5c34cd70670249" translate="yes" xml:space="preserve">
          <source>My insert queries are slow. How can I speed them up?</source>
          <target state="translated">我的插入查询很慢。我如何加快它们的速度?</target>
        </trans-unit>
        <trans-unit id="4d572e4dbba9de4ec7b823d0ec15cdc5e5e700f7" translate="yes" xml:space="preserve">
          <source>My secondary index is outdated</source>
          <target state="translated">我的二级指数已经过时了</target>
        </trans-unit>
        <trans-unit id="e7942af5c84b130986b851206ecc6f9a347c6d81" translate="yes" xml:space="preserve">
          <source>Name collision issues</source>
          <target state="translated">名称碰撞问题</target>
        </trans-unit>
        <trans-unit id="57d2c00ce45ae19ada8881fa5212e7afd2ff2b8c" translate="yes" xml:space="preserve">
          <source>Native ReQL commands like &lt;code&gt;reconfigure&lt;/code&gt; also control sharding and replication, and if you&amp;rsquo;re not using server tags you can change sharding/replication settings in the web UI. Read &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt; for more details.</source>
          <target state="translated">诸如 &lt;code&gt;reconfigure&lt;/code&gt; 类的本机ReQL命令还控制分片和复制，如果您不使用服务器标签，则可以在Web UI中更改分片/复制设置。阅读分片&lt;a href=&quot;../sharding-and-replication/index&quot;&gt;和复制&lt;/a&gt;以获取更多详细信息。</target>
        </trans-unit>
        <trans-unit id="b732272c643f080018849521bf6a04412a4035e5" translate="yes" xml:space="preserve">
          <source>Native language&amp;rsquo;s operations that have side effects or control blocks cannot be used within a &lt;code&gt;lambda&lt;/code&gt;. Learn more about &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;how this design is implemented&lt;/a&gt; for details.</source>
          <target state="translated">带有副作用或控制块的母语操作不能在 &lt;code&gt;lambda&lt;/code&gt; 中使用。详细了解&lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;如何实现此设计&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="87c96561f54572b1d2129d04e9b42119a72d9901" translate="yes" xml:space="preserve">
          <source>Near to the release of this performance report, we are excited to release RethinkDB 2.3 with plenty of new features. Rigorous performance testing, and properly publishing results is a very time-consuming process, but one we will conduct for future releases on an ongoing basis. We plan to publish our next set of metrics during the lifetime of the RethinkDB 2.3 release. We also would like to test RethinkDB performance when scaled to beyond a 16 node cluster during our next testing cycle. Going forward, we will include a summary of previous reports at the end of each report for comparison.</source>
          <target state="translated">在临近发布这份性能报告的时候,我们很高兴地发布了具有大量新功能的RethinkDB 2.3。严格的性能测试,以及正确的发布结果是一个非常耗时的过程,但我们会在未来的版本中持续进行。我们计划在RethinkDB 2.3版本的生命周期内发布下一组指标。我们还希望在下一个测试周期中测试RethinkDB扩展到16节点集群之外时的性能。今后,我们将在每份报告的末尾加入以前报告的摘要,以便比较。</target>
        </trans-unit>
        <trans-unit id="2f6fba18324193c1ccc35dd945f1c291c471bf6d" translate="yes" xml:space="preserve">
          <source>Negative &lt;code&gt;startOffset&lt;/code&gt; and &lt;code&gt;endOffset&lt;/code&gt; values are allowed with arrays; in that case, the returned range counts back from the array&amp;rsquo;s end. That is, the range &lt;code&gt;(-2)&lt;/code&gt; returns the last two elements, and the range of &lt;code&gt;(2,-1)&lt;/code&gt; returns the second element through the next-to-last element of the range. An error will be raised on a negative &lt;code&gt;startOffset&lt;/code&gt; or &lt;code&gt;endOffset&lt;/code&gt; with non-arrays. (An &lt;code&gt;endOffset&lt;/code&gt; of &amp;minus;1 &lt;em&gt;is&lt;/em&gt; allowed with a stream if &lt;code&gt;rightBound&lt;/code&gt; is closed; this behaves as if no &lt;code&gt;endOffset&lt;/code&gt; was specified.)</source>
          <target state="translated">数组允许使用负的 &lt;code&gt;startOffset&lt;/code&gt; 和 &lt;code&gt;endOffset&lt;/code&gt; 值；在这种情况下，返回的范围从数组的末尾算起。也就是说，范围 &lt;code&gt;(-2)&lt;/code&gt; 返回最后两个元素，范围 &lt;code&gt;(2,-1)&lt;/code&gt; 返回第二个元素，直到范围的倒数第二个元素。错误会在负极被升高 &lt;code&gt;startOffset&lt;/code&gt; 或 &lt;code&gt;endOffset&lt;/code&gt; 与非阵列。（安 &lt;code&gt;endOffset&lt;/code&gt; -1 &lt;em&gt;被&lt;/em&gt;允许与如果流 &lt;code&gt;rightBound&lt;/code&gt; 是封闭的;这表现为好像没有 &lt;code&gt;endOffset&lt;/code&gt; 。指定）</target>
        </trans-unit>
        <trans-unit id="55d06d5784fa220b321b58feb4840aab256fc83a" translate="yes" xml:space="preserve">
          <source>Nested resources in views</source>
          <target state="translated">视图中的嵌套资源</target>
        </trans-unit>
        <trans-unit id="6ddf66c9236295cf80e623178cd3a86d93d90f71" translate="yes" xml:space="preserve">
          <source>Network options</source>
          <target state="translated">网络选项</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">今后的步骤</target>
        </trans-unit>
        <trans-unit id="24f947aa7d57d693ce1d98cdba36427bb9ce7386" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll connect to the RabbitMQ server using amqplib:</source>
          <target state="translated">接下来，我们将使用amqplib连接到RabbitMQ服务器：</target>
        </trans-unit>
        <trans-unit id="8bcd0a2c52378cf0d5699266d7e259ed99978f8c" translate="yes" xml:space="preserve">
          <source>Nim</source>
          <target state="translated">Nim</target>
        </trans-unit>
        <trans-unit id="16acb6d551b744fda3354c17a22ed53ee3c2a38e" translate="yes" xml:space="preserve">
          <source>No proxy for: (remove everything)</source>
          <target state="translated">没有代理。(删除一切)</target>
        </trans-unit>
        <trans-unit id="d4388553ac2433a2d8de402d1a33e87d261b34cb" translate="yes" xml:space="preserve">
          <source>No special procedures or commands are necessary to execute RethinkDB queries asynchronously in JavaScript. Read about using callbacks and promises with RethinkDB in the documentation for the &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;run&lt;/a&gt; command.</source>
          <target state="translated">不需要特殊的过程或命令即可在JavaScript中异步执行RethinkDB查询。在&lt;a href=&quot;../../api/javascript/run/index&quot;&gt;run&lt;/a&gt;命令的文档中了解有关对RethinkDB使用回调和Promise的信息。</target>
        </trans-unit>
        <trans-unit id="7695d8b90da619c62d4210a919c12878e58d47a6" translate="yes" xml:space="preserve">
          <source>No. However, you can export to GeoJSON and process that with other tools.</source>
          <target state="translated">然而,你可以导出为GeoJSON,然后用其他工具处理。</target>
        </trans-unit>
        <trans-unit id="7fc6dfab40c56076b4529c151dc339fe0e28415a" translate="yes" xml:space="preserve">
          <source>NoBrainer adds a light wrapper around ReQL queries. Here are some examples:</source>
          <target state="translated">NoBrainer为ReQL查询添加了一个轻量级的包装器。下面是一些例子。</target>
        </trans-unit>
        <trans-unit id="2334597b85868c5bda45705d9c6dadcdc53b3feb" translate="yes" xml:space="preserve">
          <source>NoBrainer runs the validations only when saving, but not when retrieving a document. This means you can always retrieve your data, but an invalid model won&amp;rsquo;t be saved to the database.</source>
          <target state="translated">NoBrainer仅在保存时运行验证，而在检索文档时不运行验证。这意味着您始终可以检索数据，但是无效的模型不会保存到数据库中。</target>
        </trans-unit>
        <trans-unit id="ff74a5e83610f74cfb3d040f4dd2a594d12dd9d2" translate="yes" xml:space="preserve">
          <source>Node and Socket.io</source>
          <target state="translated">Node和Socket.io</target>
        </trans-unit>
        <trans-unit id="10b3493287f831e81a438811a1ffba01f8cec4b7" translate="yes" xml:space="preserve">
          <source>Node.js</source>
          <target state="translated">Node.js</target>
        </trans-unit>
        <trans-unit id="aa72935495ba47f9868598eb0972bab220cb0b79" translate="yes" xml:space="preserve">
          <source>Node.js Todo list</source>
          <target state="translated">Node.js 全部列表</target>
        </trans-unit>
        <trans-unit id="4839715bc122d856e205f2a6e684ab4b4c9e9787" translate="yes" xml:space="preserve">
          <source>Node.js libraries</source>
          <target state="translated">Node.js库</target>
        </trans-unit>
        <trans-unit id="9e325452c6548fc2449564842660d75ef3b1eb73" translate="yes" xml:space="preserve">
          <source>Nodes</source>
          <target state="translated">Nodes</target>
        </trans-unit>
        <trans-unit id="60e056d9960d2aa21ce42b1232734ba6d3cb45ff" translate="yes" xml:space="preserve">
          <source>Not passing the &lt;code&gt;group_format&lt;/code&gt; flag would return:</source>
          <target state="translated">不通过 &lt;code&gt;group_format&lt;/code&gt; 标志将返回：</target>
        </trans-unit>
        <trans-unit id="a33a695a3e0e45a968fb7f12f79cb0174916eeb2" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; will ignore the &lt;code&gt;read_mode&lt;/code&gt; flag, and will always behave as if it is set to &lt;code&gt;single&lt;/code&gt;.</source>
          <target state="translated">请注意，&lt;a href=&quot;../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;将忽略 &lt;code&gt;read_mode&lt;/code&gt; 标志，并且始终将其设置为 &lt;code&gt;single&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="23aa91cdc70b0f0c42f4dc080acc2e18f209da6b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;branch&lt;/code&gt;, the ReQL conditional command, must be used instead of &lt;code&gt;if&lt;/code&gt;. See the &lt;code&gt;branch&lt;/code&gt;&lt;a href=&quot;../branch/index&quot;&gt;documentation&lt;/a&gt; for more.</source>
          <target state="translated">请注意，必须使用 &lt;code&gt;branch&lt;/code&gt; （ReQL条件命令）代替 &lt;code&gt;if&lt;/code&gt; 。有关更多信息，请参见 &lt;code&gt;branch&lt;/code&gt; &lt;a href=&quot;../branch/index&quot;&gt;文档&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="046b36ef7075cbe7dba601071ec0d34de7ee628d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;getAll&lt;/code&gt; and similar operations do &lt;em&gt;not&lt;/em&gt; execute in an atomic fashion with &lt;code&gt;update&lt;/code&gt;. Read &lt;a href=&quot;../../../docs/consistency/index&quot;&gt;Consistency guarantees&lt;/a&gt; for more details. Also, see the example for conditional updates below for a solution using &lt;code&gt;branch&lt;/code&gt; in an &lt;code&gt;update&lt;/code&gt; clause.</source>
          <target state="translated">请注意， &lt;code&gt;filter&lt;/code&gt; ， &lt;code&gt;getAll&lt;/code&gt; 和类似操作&lt;em&gt;不会&lt;/em&gt;通过 &lt;code&gt;update&lt;/code&gt; 以原子方式执行。阅读&lt;a href=&quot;../../../docs/consistency/index&quot;&gt;一致性保证&lt;/a&gt;以获取更多详细信息。另外，有关在 &lt;code&gt;update&lt;/code&gt; 子句中使用 &lt;code&gt;branch&lt;/code&gt; 的解决方案，请参见下面的条件更新示例。</target>
        </trans-unit>
        <trans-unit id="f3cce3c5063c9b4680ce2db7489bc86d18a9613e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;innerJoin&lt;/code&gt; is slower and much less efficient than using &lt;a href=&quot;../eq_join/index&quot;&gt;eqJoin&lt;/a&gt; or &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt; with &lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt;. You should avoid using &lt;code&gt;innerJoin&lt;/code&gt; in commands when possible.</source>
          <target state="translated">请注意，与将&lt;a href=&quot;../eq_join/index&quot;&gt;eqJoin&lt;/a&gt;或&lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt;与&lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt;一起使用时， &lt;code&gt;innerJoin&lt;/code&gt; 速度较慢且效率低得多。您应该尽可能避免在命令中使用 &lt;code&gt;innerJoin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb9c353d911b32d303fae6ec6ffcae4f1a653918" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;map&lt;/code&gt; can only be applied to sequences, not single values. If you wish to apply a function to a single value/selection (including an array), use the &lt;a href=&quot;../do/index&quot;&gt;do&lt;/a&gt; command.</source>
          <target state="translated">请注意， &lt;code&gt;map&lt;/code&gt; 只能应用于序列，不能应用于单个值。如果希望将函数应用于单个值/选择（包括数组），请使用&lt;a href=&quot;../do/index&quot;&gt;do&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="52edb1931a7678b06f40d0f67216ea63d608c768" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;outerJoin&lt;/code&gt; is slower and much less efficient than using &lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt; with &lt;a href=&quot;../get_all/index&quot;&gt;getAll&lt;/a&gt;. You should avoid using &lt;code&gt;outerJoin&lt;/code&gt; in commands when possible.</source>
          <target state="translated">请注意，与将&lt;a href=&quot;../concat_map/index&quot;&gt;concatMap&lt;/a&gt;与&lt;a href=&quot;../get_all/index&quot;&gt;getAll结合&lt;/a&gt;使用时， &lt;code&gt;outerJoin&lt;/code&gt; 速度较慢且效率低得多。您应尽可能避免在命令中使用 &lt;code&gt;outerJoin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd4b1c6ffc31ec1f99a87680dc2b303487664897" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;row&lt;/code&gt; does not work within subqueries to access nested documents; you should use anonymous functions to access those documents instead. (See the last example.)</source>
          <target state="translated">请注意， &lt;code&gt;row&lt;/code&gt; 子查询中无法访问嵌套文档；您应该改用匿名功能访问这些文档。（请参阅最后一个示例。）</target>
        </trans-unit>
        <trans-unit id="d752e9b9c354ac26c00d43811dff01c2a8679e7b" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;true&lt;/code&gt; in the example above is testing for the existence of &lt;code&gt;championships&lt;/code&gt; as a field, not testing to see if the value of the &lt;code&gt;championships&lt;/code&gt; field is set to &lt;code&gt;true&lt;/code&gt;. There&amp;rsquo;s a more convenient shorthand form available. (See &lt;a href=&quot;../pluck/index&quot;&gt;pluck&lt;/a&gt; for more details on this.)</source>
          <target state="translated">请注意，在上面的示例中， &lt;code&gt;true&lt;/code&gt; 是测试是否存在 &lt;code&gt;championships&lt;/code&gt; 作为字段，而不是测试以查看 &lt;code&gt;championships&lt;/code&gt; 字段的值是否设置为 &lt;code&gt;true&lt;/code&gt; 。有更方便的速记形式。（有关更多详细信息，请参见&lt;a href=&quot;../pluck/index&quot;&gt;pluck&lt;/a&gt;。）</target>
        </trans-unit>
        <trans-unit id="b95d53711950543d65d38ace0235593f05e863af" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;write_acks&lt;/code&gt; and &lt;code&gt;durability&lt;/code&gt; don&amp;rsquo;t actually affect how the write is performed; they only affect when the acknowledgement is sent back to the client.</source>
          <target state="translated">请注意， &lt;code&gt;write_acks&lt;/code&gt; 和 &lt;code&gt;durability&lt;/code&gt; 实际上并不影响写入的执行方式。它们仅影响将确认发送回客户端的时间。</target>
        </trans-unit>
        <trans-unit id="7020586ba6fb68f8b3332682998d8be66b7d38f3" translate="yes" xml:space="preserve">
          <source>Note that a line between the north pole and south pole (from latitude &amp;minus;90 to latitude 90) cannot be calculated, as &lt;em&gt;all&lt;/em&gt; possible paths between them are the &amp;ldquo;shortest&amp;rdquo;; this may trigger an error in ReQL or it may choose an arbitrary (but technically correct) path.</source>
          <target state="translated">请注意，由于南北极之间的&lt;em&gt;所有&lt;/em&gt;可能路径均为&amp;ldquo;最短&amp;rdquo;，因此无法计算南北极之间的线（从-90到90度）。这可能会触发ReQL错误，也可能选择任意（但技术上正确）路径。</target>
        </trans-unit>
        <trans-unit id="869310050eda36904b9b1684e375eea8a27df6a7" translate="yes" xml:space="preserve">
          <source>Note that an index may not be immediately available after creation. If your application needs to use indexes immediately after creation, use the &lt;a href=&quot;../index_wait/index&quot;&gt;indexWait&lt;/a&gt; command to ensure the indexes are ready before use.</source>
          <target state="translated">请注意，索引在创建后可能不会立即可用。如果您的应用程序需要在创建后立即使用索引，请使用&lt;a href=&quot;../index_wait/index&quot;&gt;indexWait&lt;/a&gt;命令以确保索引在使用前已准备就绪。</target>
        </trans-unit>
        <trans-unit id="5633901ed522442fae34a2aee51f02c0e3f374cf" translate="yes" xml:space="preserve">
          <source>Note that both the official JavaScript driver and neumino&amp;rsquo;s &amp;ldquo;rethinkdbdash&amp;rdquo; driver are designed to work with Node.js.</source>
          <target state="translated">请注意，正式的JavaScript驱动程序和neumino的&amp;ldquo; rethinkdbdash&amp;rdquo;驱动程序均旨在与Node.js一起使用。</target>
        </trans-unit>
        <trans-unit id="cc7bb93e73f8b5f0f5aac10c43c2d4956feb9dc0" translate="yes" xml:space="preserve">
          <source>Note that by default, RethinkDB only opens connections bound to &lt;code&gt;localhost&lt;/code&gt; in order to prevent unauthorized clients on the network from connecting to the server. The &lt;code&gt;--bind all&lt;/code&gt; option allows connections from anywhere on the network. It works well if the network is protected.</source>
          <target state="translated">请注意，默认情况下，RethinkDB仅打开绑定到 &lt;code&gt;localhost&lt;/code&gt; 的连接，以防止网络上未经授权的客户端连接到服务器。该 &lt;code&gt;--bind all&lt;/code&gt; 选项允许从网络上任何地方的连接。如果网络受到保护，它将很好地工作。</target>
        </trans-unit>
        <trans-unit id="07fbecac98fcf0f3caf272d28683d05c9f00b5fe" translate="yes" xml:space="preserve">
          <source>Note that if you call &lt;a href=&quot;../../api/javascript/table/index&quot;&gt;table&lt;/a&gt; with &lt;code&gt;identifier_format&lt;/code&gt; set to &lt;code&gt;uuid&lt;/code&gt;, then references to servers, tables and databases in the &lt;code&gt;info&lt;/code&gt; subdocument will be UUIDs rather than names.</source>
          <target state="translated">请注意，如果调用的&lt;a href=&quot;../../api/javascript/table/index&quot;&gt;表&lt;/a&gt;的 &lt;code&gt;identifier_format&lt;/code&gt; 设置为 &lt;code&gt;uuid&lt;/code&gt; ，则 &lt;code&gt;info&lt;/code&gt; 子文档中对服务器，表和数据库的引用将是UUID而不是名称。</target>
        </trans-unit>
        <trans-unit id="6ae89b9920878619801ec2ca89056fee59578b79" translate="yes" xml:space="preserve">
          <source>Note that if you didn&amp;rsquo;t call &lt;code&gt;ungroup&lt;/code&gt;, you would instead select one random game from each player:</source>
          <target state="translated">请注意，如果您未致电 &lt;code&gt;ungroup&lt;/code&gt; ，则应从每个玩家中选择一个随机游戏：</target>
        </trans-unit>
        <trans-unit id="794a796e7f7b74c249460ac6df405541e4ffc7df" translate="yes" xml:space="preserve">
          <source>Note that in the last case, you&amp;rsquo;re required to provide a CA certificate as well. This is a certificate used to sign other certificates. In this case, we&amp;rsquo;re using the same certificate for both, but we could sign our &lt;code&gt;cert.pem&lt;/code&gt; with a different CA certificate and specify both of them. Servers can only connect to the cluster if the certificates specified by their &lt;code&gt;cluster-tls-cert&lt;/code&gt; value are signed by the CA certificate specified by &lt;code&gt;cluster-tls-ca&lt;/code&gt;.</source>
          <target state="translated">请注意，在最后一种情况下，还需要提供CA证书。这是用于签署其他证书的证书。在这种情况下，我们为两者使用相同的证书，但是我们可以使用不同的CA证书对 &lt;code&gt;cert.pem&lt;/code&gt; 进行签名，并同时指定两者。如果服务器的 &lt;code&gt;cluster-tls-cert&lt;/code&gt; 值指定的证书由 &lt;code&gt;cluster-tls-ca&lt;/code&gt; 指定的CA证书签名，则服务器只能连接到群集。</target>
        </trans-unit>
        <trans-unit id="69a530ba90750d307c78bffe12c73f7bc690c170" translate="yes" xml:space="preserve">
          <source>Note that in this case, &lt;a href=&quot;../row/index&quot;&gt;row&lt;/a&gt; may be used as an alternative to writing an anonymous function, as it returns the same value as the function parameter receives:</source>
          <target state="translated">请注意，在这种情况下，&lt;a href=&quot;../row/index&quot;&gt;行&lt;/a&gt;可以代替编写匿名函数，因为它返回的值与函数参数接收的值相同：</target>
        </trans-unit>
        <trans-unit id="d4d62e0a372be981e1086845747762fa68efdd64" translate="yes" xml:space="preserve">
          <source>Note that looping over a cursor must be done with &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;fetch_next&lt;/code&gt;, rather than using a &lt;code&gt;for x in cursor&lt;/code&gt; loop.</source>
          <target state="translated">注意，游标的循环必须使用 &lt;code&gt;while&lt;/code&gt; 和 &lt;code&gt;fetch_next&lt;/code&gt; 来完成，而不是 &lt;code&gt;for x in cursor&lt;/code&gt; 循环中使用for x。</target>
        </trans-unit>
        <trans-unit id="f9631e710ce7fec5bb59199fdbb7bd3ffaa2b587" translate="yes" xml:space="preserve">
          <source>Note that passwords will be sent in plaintext unless you are using TLS encryption. Instead of (or in addition to) TLS, you can bind the driver port and use SSH tunneling, as described below.</source>
          <target state="translated">请注意,除非您使用 TLS 加密,否则密码将以纯文本形式发送。除了TLS之外,您还可以绑定驱动程序端口并使用SSH隧道,如下所述。</target>
        </trans-unit>
        <trans-unit id="caab8be7c7ee8a44aad19ce23e3ceec991876422" translate="yes" xml:space="preserve">
          <source>Note that queries with &lt;code&gt;getAll&lt;/code&gt; or &lt;code&gt;between&lt;/code&gt; may return the same document multiple times unless you use the &lt;a href=&quot;../../../api/javascript/distinct/index&quot;&gt;distinct&lt;/a&gt; command.</source>
          <target state="translated">请注意，使用 &lt;code&gt;getAll&lt;/code&gt; 或 &lt;code&gt;between&lt;/code&gt; 查询可能会多次返回同一文档，除非您使用&lt;a href=&quot;../../../api/javascript/distinct/index&quot;&gt;distinct&lt;/a&gt;命令。</target>
        </trans-unit>
        <trans-unit id="c7c21b67930f527774bfd43705840df0f2b95c65" translate="yes" xml:space="preserve">
          <source>Note that rebuilding indexes is &lt;em&gt;not&lt;/em&gt; required if you&amp;rsquo;re upgrading between minor releases (i.e., 2.2.0 to 2.2.1).</source>
          <target state="translated">需要注意的是重建索引是&lt;em&gt;不是&lt;/em&gt;必需的，如果你次要版本（即2.2.0至2.2.1）之间正在升级。</target>
        </trans-unit>
        <trans-unit id="6f72e66b293b77e8428e776de4027ca58fa284cb" translate="yes" xml:space="preserve">
          <source>Note that server tags cannot be configured through RethinkDB&amp;rsquo;s web administration dashboard. They may be created and assigned through ReQL commands and scripts.</source>
          <target state="translated">请注意，不能通过RethinkDB的Web管理仪表板配置服务器标签。它们可以通过ReQL命令和脚本来创建和分配。</target>
        </trans-unit>
        <trans-unit id="82182344e60cfb2c08352c68670095dcbc4419cc" translate="yes" xml:space="preserve">
          <source>Note that tables are configured on creation and when the &lt;code&gt;reconfigure&lt;/code&gt; command is called, but the configurations are &lt;em&gt;not&lt;/em&gt; stored by the server otherwise. To reconfigure tables consistently&amp;mdash;especially if your configuration uses server tags&amp;mdash;you should save the configuration in a script. Read more about this in &lt;a href=&quot;../administration-tools/index&quot;&gt;Administration tools&lt;/a&gt;.</source>
          <target state="translated">请注意，表是在创建时和调用 &lt;code&gt;reconfigure&lt;/code&gt; 命令时配置的，但是服务器&lt;em&gt;不会&lt;/em&gt;存储配置。要一致地重新配置表（特别是如果您的配置使用服务器标记），则应将配置保存在脚本中。在&lt;a href=&quot;../administration-tools/index&quot;&gt;管理工具中&lt;/a&gt;了解有关此内容的更多信息。</target>
        </trans-unit>
        <trans-unit id="a9aa756264e1ece12b1221ef8bdfe0cf69fa30d7" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;../now/index&quot;&gt;now&lt;/a&gt; command always returns UTC time, so the comparison may fail if &lt;code&gt;user(&quot;birthdate&quot;)&lt;/code&gt; isn&amp;rsquo;t also in UTC. You can use the &lt;a href=&quot;../in_timezone/index&quot;&gt;inTimezone&lt;/a&gt; command to adjust for this:</source>
          <target state="translated">请注意，&lt;a href=&quot;../now/index&quot;&gt;now&lt;/a&gt;命令始终返回UTC时间，因此，如果 &lt;code&gt;user(&quot;birthdate&quot;)&lt;/code&gt; 也不在UTC中，则比较可能会失败。您可以使用&lt;a href=&quot;../in_timezone/index&quot;&gt;inTimezone&lt;/a&gt;命令对此进行调整：</target>
        </trans-unit>
        <trans-unit id="5a7ac990a54eac51a8c5b0af1f5b7cf5ce6153d2" translate="yes" xml:space="preserve">
          <source>Note that the JavaScript driver strips time zone information due to limitations with the &lt;code&gt;Date&lt;/code&gt; object, although you can retrieve time zone data via the raw ReQL time object. (See below.)</source>
          <target state="translated">请注意，尽管可以通过原始ReQL时间对象检索时区数据，但由于 &lt;code&gt;Date&lt;/code&gt; 对象的限制，JavaScript驱动程序会剥离时区信息。（见下文。）</target>
        </trans-unit>
        <trans-unit id="cf5a0befe8f4a2d2c04f639c1bc0ee0b7b9f3d58" translate="yes" xml:space="preserve">
          <source>Note that the left bound (including the implied left bound of 0 in the 0- and 1-argument form) is always closed and the right bound is always open: the start value will always be included in the returned range and the end value will &lt;em&gt;not&lt;/em&gt; be included in the returned range.</source>
          <target state="translated">请注意，左边界（包括在0和1参数形式中的隐含左边界0）始终是关闭的，而右边界始终是开放的：起始值将始终包含在返回范围内，而终止值将始终包含在内&lt;em&gt;不&lt;/em&gt;包含在返回范围内。</target>
        </trans-unit>
        <trans-unit id="8c2fd8bb823ff27914611ee376d7f11e792c0216" translate="yes" xml:space="preserve">
          <source>Note that the sequence being merged&amp;mdash;in this example, the comments&amp;mdash;must be coerced from a selection to an array. Without &lt;code&gt;coerceTo&lt;/code&gt; the operation will throw an error (&amp;ldquo;Expected type DATUM but found SELECTION&amp;rdquo;).</source>
          <target state="translated">请注意，必须将合并的序列（在此示例中为注释）从选择内容强制转换为数组。没有 &lt;code&gt;coerceTo&lt;/code&gt; ,该操作将引发错误（&amp;ldquo;预期类型DATUM，但找到了SELECTION&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="e98abad9a62e2bab40d6be837e719bce034e43c6" translate="yes" xml:space="preserve">
          <source>Note that the values for &lt;code&gt;author_id&lt;/code&gt; correspond to the &lt;code&gt;id&lt;/code&gt; field of the author, which allows us to link the documents.</source>
          <target state="translated">请注意， &lt;code&gt;author_id&lt;/code&gt; 的值对应于作者的 &lt;code&gt;id&lt;/code&gt; 字段，这使我们可以链接文档。</target>
        </trans-unit>
        <trans-unit id="d8ca43a4f1a4253668972ac4f388573e961d6210" translate="yes" xml:space="preserve">
          <source>Note that we first selected every author in the table, and then chained the &lt;code&gt;update&lt;/code&gt; command to the end of the query. We could also update a subset of documents by filtering the table first. Let&amp;rsquo;s update William Adama&amp;rsquo;s record to note that he has the rank of Admiral:</source>
          <target state="translated">请注意，我们首先选择表中的每个作者，然后将 &lt;code&gt;update&lt;/code&gt; 命令链接到查询的末尾。我们还可以通过首先过滤表来更新文档的子集。让我们更新威廉&amp;middot;阿达玛的记录，以指出他拥有海军上将的军衔：</target>
        </trans-unit>
        <trans-unit id="92ed5dd039e24ac49d654376ac966bb44a6b7f52" translate="yes" xml:space="preserve">
          <source>Note that while &lt;code&gt;r.do()&lt;/code&gt; takes the function as its &lt;em&gt;last&lt;/em&gt; argument, &lt;code&gt;FUNCALL&lt;/code&gt; serializes the function as its &lt;em&gt;first&lt;/em&gt; argument.</source>
          <target state="translated">请注意，尽管 &lt;code&gt;r.do()&lt;/code&gt; 将函数作为其&lt;em&gt;最后一个&lt;/em&gt;参数，但 &lt;code&gt;FUNCALL&lt;/code&gt; 会将函数序列化为其&lt;em&gt;第一个&lt;/em&gt;参数。</target>
        </trans-unit>
        <trans-unit id="961048dc5c12584ceafa08e33e5c7ca4211def59" translate="yes" xml:space="preserve">
          <source>Note that you can omit the &lt;code&gt;db&lt;/code&gt; command if you&amp;rsquo;re creating a table in the default database on your connection (set to &lt;code&gt;test&lt;/code&gt; unless specified in &lt;code&gt;connect&lt;/code&gt;).</source>
          <target state="translated">请注意，如果要在连接的默认数据库中创建表（设置为 &lt;code&gt;test&lt;/code&gt; ,除非在 &lt;code&gt;connect&lt;/code&gt; 中指定），则可以省略 &lt;code&gt;db&lt;/code&gt; 命令。</target>
        </trans-unit>
        <trans-unit id="02badbdd66f3ecc05d33efbafafd420cfaa47135" translate="yes" xml:space="preserve">
          <source>Note that you will not be able to read the &lt;code&gt;iterations&lt;/code&gt; value for an account; as it&amp;rsquo;s stored in the password field, it remains read-only.</source>
          <target state="translated">请注意，您将无法读取帐户的 &lt;code&gt;iterations&lt;/code&gt; 值；因为它存储在密码字段中，所以它保持只读状态。</target>
        </trans-unit>
        <trans-unit id="5dbcb1737995d27923331529248e2e3554797023" translate="yes" xml:space="preserve">
          <source>Note that, due to the index being sorted lexicographically (and the fact that &lt;code&gt;between&lt;/code&gt; returns a single contiguous interval of rows), it would be possible to search for posts about &lt;code&gt;&quot;fun&quot;&lt;/code&gt; by any author but then it would not be possible to limit the time range (not without building a different index, of course).</source>
          <target state="translated">请注意，由于索引是按字典顺序排序的（并且 &lt;code&gt;between&lt;/code&gt; 的索引返回一个连续的行间隔），因此任何作者都可以搜索有关 &lt;code&gt;&quot;fun&quot;&lt;/code&gt; 的帖子，但这样就不可能限制时间范围（当然，不是建立不同的索引）。</target>
        </trans-unit>
        <trans-unit id="8cb089f10f83d1ccdecb1a60a861bab8d0ee2602" translate="yes" xml:space="preserve">
          <source>Note the command line parameters we used to start the second node:</source>
          <target state="translated">注意我们用来启动第二个节点的命令行参数。</target>
        </trans-unit>
        <trans-unit id="44da02227d007949366a19f44ea67a15d04cf1dc" translate="yes" xml:space="preserve">
          <source>Note the id of the security group. It will start with &lt;code&gt;sg-&lt;/code&gt;.</source>
          <target state="translated">记下安全组的ID。它将以 &lt;code&gt;sg-&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="4be3a7d8983105ceac2d9d6226a9207c4e4a7f87" translate="yes" xml:space="preserve">
          <source>Note the port numbers you can use to access RethinkDB:</source>
          <target state="translated">注意你可以用来访问RethinkDB的端口号。</target>
        </trans-unit>
        <trans-unit id="520bd0b12df7f31816c20ea08f041b38cd1efc9c" translate="yes" xml:space="preserve">
          <source>Note: Only alphanumeric characters and underscores are valid for the database name.</source>
          <target state="translated">注意:数据库名称只能使用字母数字字符和下划线。</target>
        </trans-unit>
        <trans-unit id="e4f1dfb495411f7c79397bcc72d7fc74a5c0836b" translate="yes" xml:space="preserve">
          <source>Note: The last argument given will always be the &amp;lsquo;open&amp;rsquo; side of the range, but when generating a floating-point number, the &amp;lsquo;open&amp;rsquo; side may be less than the &amp;lsquo;closed&amp;rsquo; side.</source>
          <target state="translated">注意：最后给出的参数将始终是范围的&amp;ldquo;开放&amp;rdquo;侧，但是在生成浮点数时，&amp;ldquo;开放&amp;rdquo;侧可能小于&amp;ldquo;封闭&amp;rdquo;侧。</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="ceb637042a0d9428c0df8add2990697098a05c47" translate="yes" xml:space="preserve">
          <source>Notes on connections</source>
          <target state="translated">关于连接的说明</target>
        </trans-unit>
        <trans-unit id="b4d5a0b9e73af6cd9b264bcafa717aeda3b8bd40" translate="yes" xml:space="preserve">
          <source>Now consider a larger example:</source>
          <target state="translated">现在考虑一个更大的例子。</target>
        </trans-unit>
        <trans-unit id="3a1aea1028da8d2cfbf3ca018738fc4dca263dc7" translate="yes" xml:space="preserve">
          <source>Now create an SSH tunnel on the server that needs to access the remote RethinkDB driver port:</source>
          <target state="translated">现在在需要访问远程RethinkDB驱动端口的服务器上创建一个SSH隧道。</target>
        </trans-unit>
        <trans-unit id="36c86a37d15270331c5ca41f45f937ef93547855" translate="yes" xml:space="preserve">
          <source>Now for something more complicated: calculating the total and average quantities sold per item. For this, we&amp;rsquo;ll use the &lt;a href=&quot;https://rethinkdb.com/api/python/concat_map&quot;&gt;concat_map&lt;/a&gt; function, which combines mapping and concatenation together. In this case, we want to produce a sequence of all the items sold throughout all the orders with their item IDs and quantities. We&amp;rsquo;ll also add a &amp;ldquo;count&amp;rdquo; field set to &lt;code&gt;1&lt;/code&gt;; we&amp;rsquo;ll use this the same way we used the mapping of each post in the blog example.</source>
          <target state="translated">现在进行更复杂的处理：计算每件商品的总销售量和平均数量。为此，我们将使用&lt;a href=&quot;https://rethinkdb.com/api/python/concat_map&quot;&gt;concat_map&lt;/a&gt;函数，该函数将映射和串联结合在一起。在这种情况下，我们要生成所有订单中出售的所有物品的序列及其物品ID和数量。我们还将添加一个设置为 &lt;code&gt;1&lt;/code&gt; 的&amp;ldquo; count&amp;rdquo;字段；我们将以与博客示例中每个帖子的映射相同的方式使用它。</target>
        </trans-unit>
        <trans-unit id="83b7df19c7a7fab5f6f86d5d49556fd86a1c4ed9" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s access a real JSON API. In this example we&amp;rsquo;re going to use GitHub &amp;mdash; a collaborative development platform that hosts thousands of open-source projects. Users on GitHub can indicate interest by starring projects and following other users. GitHub calls users who starred other projects &amp;ldquo;stargazers&amp;rdquo;.</source>
          <target state="translated">现在，让我们访问一个真实的JSON API。在此示例中，我们将使用GitHub &amp;mdash;托管数千个开源项目的协作开发平台。GitHub上的用户可以通过给项目加注星标并关注其他用户来表示兴趣。GitHub将曾在其他项目中加注星标的用户称为&amp;ldquo;注视者&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="7e792f8e7d51655e21b3f588eca27d6ee4ec76c2" translate="yes" xml:space="preserve">
          <source>Now start the second RethinkDB instance on the same machine:</source>
          <target state="translated">现在在同一台机器上启动第二个RethinkDB实例。</target>
        </trans-unit>
        <trans-unit id="c29ee53738e56f268012e978255da2e21fb2123f" translate="yes" xml:space="preserve">
          <source>Now switch back to your first terminal. We&amp;rsquo;ll be updating and deleting some documents in the next two sections. As we run these commands, the feed will push notifications to your program. The code above will print the following messages in the second terminal:</source>
          <target state="translated">现在切换回您的第一个终端。在接下来的两节中，我们将更新和删除一些文档。当我们运行这些命令时，提要会将通知推送到您的程序。上面的代码将在第二个终端中显示以下消息：</target>
        </trans-unit>
        <trans-unit id="a233b26c262807902c4cc9fc0e713ee2a3c939fb" translate="yes" xml:space="preserve">
          <source>Now that we inserted some data, let&amp;rsquo;s see how we can query the database!</source>
          <target state="translated">现在我们已经插入了一些数据，让我们看看如何查询数据库！</target>
        </trans-unit>
        <trans-unit id="8efdd3a96ed18374cd2b44f39375f891439bba62" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve installed the plugin, the next step is to actually configure it to connect to our RethinkDB instance. We can do that by talking to Elasticsearch&amp;rsquo;s REST API. There are three concepts we need to deal with in the API: indexes, types, and documents. A document is the actual data being stored itself and is just JSON. A type contains documents and is similar to a table in RethinkDB. An index contains types and is similar to a database in RethinkDB.</source>
          <target state="translated">现在我们已经安装了插件，下一步是实际配置它以连接到我们的RethinkDB实例。我们可以通过与Elasticsearch的REST API交谈来做到这一点。API中需要处理三个概念：索引，类型和文档。文档是实际存储的实际数据，只是JSON。类型包含文档，类似于RethinkDB中的表。索引包含类型，并且类似于RethinkDB中的数据库。</target>
        </trans-unit>
        <trans-unit id="e816e64d8ebb842e4b0118841e17ba4aab267ea3" translate="yes" xml:space="preserve">
          <source>Now the coroutine will run in the background, printing out changes. When we alter the table, the changes will be noticed.</source>
          <target state="translated">现在,coroutine将在后台运行,打印出变化。当我们改变表格时,就会注意到这些变化。</target>
        </trans-unit>
        <trans-unit id="88579e11bba37adb2b24fcaf9dceaf04746ffa0d" translate="yes" xml:space="preserve">
          <source>Now the task will run in the background, printing out changes. When we alter the table, the changes will be noticed.</source>
          <target state="translated">现在任务将在后台运行,打印出更改。当我们改变表格时,会注意到这些变化。</target>
        </trans-unit>
        <trans-unit id="96aaeca03bd2a83f83cdc2012364ba4295826827" translate="yes" xml:space="preserve">
          <source>Now we can plug our changes directly into Rabbit:</source>
          <target state="translated">现在我们可以把我们的变化直接插入Rabbit中。</target>
        </trans-unit>
        <trans-unit id="7cca3688c70abd6d885cd1f6703f8f921526df1a" translate="yes" xml:space="preserve">
          <source>Now we can publish any arbitrary JSON document to the topic:</source>
          <target state="translated">现在我们可以将任何任意的JSON文档发布到主题中。</target>
        </trans-unit>
        <trans-unit id="2399a2288ab147cdf7e8afafb71d676fc702e4fb" translate="yes" xml:space="preserve">
          <source>Now we need to &amp;ldquo;bind&amp;rdquo; the queue to the topics we&amp;rsquo;re interested in. Other listeners can subscribe to the same topic, and Rabbit will copy the message for every queue. Here, we&amp;rsquo;ll just keep it simple and bind to all events from &amp;ldquo;mytable&amp;rdquo;:</source>
          <target state="translated">现在我们需要将队列&amp;ldquo;绑定&amp;rdquo;到我们感兴趣的主题。其他侦听器可以订阅相同的主题，Rabbit将为每个队列复制消息。在这里，我们将使其保持简单并绑定&amp;ldquo; mytable&amp;rdquo;中的所有事件：</target>
        </trans-unit>
        <trans-unit id="0c8880d6597c3169973e8e1627a2c6d6907027cb" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;d like to sort RethinkDB stargazers by influence. When you request stargazers from GitHub, the GitHub API doesn&amp;rsquo;t include the number of followers for each stargazer, but it does include a field &lt;code&gt;url&lt;/code&gt; specific to each stargazer. If you follow this URL, the GitHub API will return additional information for the user, including the number of their followers.</source>
          <target state="translated">现在，我们想按影响力对RethinkDB观星者进行排序。当您从GitHub请求观星者时，GitHub API不包括每个观星者的关注者数量，但确实包括每个观星者的特定字段 &lt;code&gt;url&lt;/code&gt; 。如果您遵循此URL，则GitHub API将为用户返回其他信息，包括其关注者数量。</target>
        </trans-unit>
        <trans-unit id="1ceb299c25786316a08bb16460c9243fa1eec175" translate="yes" xml:space="preserve">
          <source>Now with a &amp;ldquo;clean&amp;rdquo; data set we can run simple reports right in the Data Explorer. (You might want to switch to Table View for some of these, and you can also add &lt;code&gt;.without('id')&lt;/code&gt; in the command chain to &amp;ldquo;prettify&amp;rdquo; the table display if you wish.)</source>
          <target state="translated">现在有了&amp;ldquo;干净的&amp;rdquo;数据集，我们可以在数据浏览器中直接运行简单的报告。（您可能希望其中的一些切换到&amp;ldquo;表视图&amp;rdquo;，也可以 &lt;code&gt;.without('id')&lt;/code&gt; 在命令链中添加.without（'id'）以&amp;ldquo;整理&amp;rdquo;表显示。）</target>
        </trans-unit>
        <trans-unit id="9caa73cdf116b57684d6c1c8b8b9f44f4d600fcd" translate="yes" xml:space="preserve">
          <source>Now, consider a larger example.</source>
          <target state="translated">现在,考虑一个更大的例子。</target>
        </trans-unit>
        <trans-unit id="afea3b1aecf0d259448b1b35c58dad9976a271d3" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s get those back:</source>
          <target state="translated">现在，让我们把它们取回来：</target>
        </trans-unit>
        <trans-unit id="e6ed379404867578a5a6db513257215a7d553130" translate="yes" xml:space="preserve">
          <source>Now, use one of the following two methods to enable secure access.</source>
          <target state="translated">现在,使用以下两种方法之一来启用安全访问。</target>
        </trans-unit>
        <trans-unit id="fba0bbb4e77831e38e81b55c86757fe6c887f2ef" translate="yes" xml:space="preserve">
          <source>Now, we&amp;rsquo;ll &lt;code&gt;group&lt;/code&gt; by the &lt;code&gt;item_id&lt;/code&gt; field and use a custom &lt;code&gt;reduce&lt;/code&gt; function to sum the quantities and counts.</source>
          <target state="translated">现在，我们将对 &lt;code&gt;item_id&lt;/code&gt; 字段进行 &lt;code&gt;group&lt;/code&gt; ，并使用自定义的 &lt;code&gt;reduce&lt;/code&gt; 函数对数量和计数求和。</target>
        </trans-unit>
        <trans-unit id="c4dffe1e129e38cabba8445af4a117e656e614bc" translate="yes" xml:space="preserve">
          <source>Now, when any heroes are added, modified or deleted from either table, a change notification will be sent out.</source>
          <target state="translated">现在,当任何一个表中的英雄被添加、修改或删除时,都会发出变更通知。</target>
        </trans-unit>
        <trans-unit id="2c148f3b7dd44ba4e2ab9591ded50bd106dde2f1" translate="yes" xml:space="preserve">
          <source>Now, you can use ReQL commands to query system tables and perform reconfiguration commands. To return the server status, you can query the &lt;code&gt;server_status&lt;/code&gt; system table in the special &lt;code&gt;rethinkdb&lt;/code&gt; database.</source>
          <target state="translated">现在，您可以使用ReQL命令查询系统表并执行重新配置命令。要返回服务器状态，可以查询特殊的 &lt;code&gt;rethinkdb&lt;/code&gt; 数据库中的 &lt;code&gt;server_status&lt;/code&gt; 系统表。</target>
        </trans-unit>
        <trans-unit id="85120bce76a23e361fb938c44bc73facc906afcd" translate="yes" xml:space="preserve">
          <source>ORMs</source>
          <target state="translated">ORMs</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="translated">OS X</target>
        </trans-unit>
        <trans-unit id="9cf4af30df052d80876381f9ec0e05811ecd3d08" translate="yes" xml:space="preserve">
          <source>Objective-C</source>
          <target state="translated">Objective-C</target>
        </trans-unit>
        <trans-unit id="3868dbba6ab95babefa387180cf6de66e170f8ea" translate="yes" xml:space="preserve">
          <source>Official RethinkDB client drivers for Python, JavaScript, Java, and Ruby</source>
          <target state="translated">适用于Python、JavaScript、Java和Ruby的官方RethinkDB客户端驱动。</target>
        </trans-unit>
        <trans-unit id="74cdd5cbbd592f9b99c0f8d5979f1463f350d5ff" translate="yes" xml:space="preserve">
          <source>Official drivers</source>
          <target state="translated">官方司机</target>
        </trans-unit>
        <trans-unit id="ebd6ec34f67b785d250d426fa00edef1acad05a5" translate="yes" xml:space="preserve">
          <source>Official packages</source>
          <target state="translated">官方配套</target>
        </trans-unit>
        <trans-unit id="831937a5ef9ec548ca483436b44fdfe4b969dfca" translate="yes" xml:space="preserve">
          <source>Older versions</source>
          <target state="translated">旧版本</target>
        </trans-unit>
        <trans-unit id="d65b6345aa5b8fc44215a53289fccbbb539c6d88" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;false&lt;/code&gt;, the server will send an error and error code as above.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则服务器将发送错误和错误代码，如上。</target>
        </trans-unit>
        <trans-unit id="c1cebe4c7f1c61569d9257cc40cc35bbf81ae6de" translate="yes" xml:space="preserve">
          <source>On &lt;code&gt;false&lt;/code&gt;, the server will send an error and error code.</source>
          <target state="translated">如果为 &lt;code&gt;false&lt;/code&gt; ，则服务器将发送错误和错误代码。</target>
        </trans-unit>
        <trans-unit id="4412954aef37a85b9b6c203be268bc8e49fc7bc0" translate="yes" xml:space="preserve">
          <source>On &lt;strong&gt;failure,&lt;/strong&gt; the server sends a null-terminated error string (&lt;em&gt;not&lt;/em&gt; JSON).</source>
          <target state="translated">上&lt;strong&gt;失败，&lt;/strong&gt;服务器发送一个空终止错误字符串（&lt;em&gt;不&lt;/em&gt; JSON）。</target>
        </trans-unit>
        <trans-unit id="f51347c7500404083d9d35f76646a95435173ff5" translate="yes" xml:space="preserve">
          <source>On &lt;strong&gt;success,&lt;/strong&gt; the server sends a null-terminated JSON response, indicating success, minimum and maximum protocol versions, and the server version.</source>
          <target state="translated">上&lt;strong&gt;的成功，&lt;/strong&gt;该服务器发送一个空终止JSON响应，表示成功，最小和最大协议版本，和服务器版本。</target>
        </trans-unit>
        <trans-unit id="bb940d279b36ee1325e1f1b7715aa2df3888293b" translate="yes" xml:space="preserve">
          <source>On the &lt;a href=&quot;https://aws.amazon.com/marketplace/pp/B013R60Q8Y&quot;&gt;RethinkDB marketplace page&lt;/a&gt;, click the &lt;strong&gt;Continue&lt;/strong&gt; button.</source>
          <target state="translated">在&lt;a href=&quot;https://aws.amazon.com/marketplace/pp/B013R60Q8Y&quot;&gt;RethinkDB市场页面上&lt;/a&gt;，单击&lt;strong&gt;继续&lt;/strong&gt;按钮。</target>
        </trans-unit>
        <trans-unit id="b81c1cb3f1e6975a3ac220d8d48062c1f8158f69" translate="yes" xml:space="preserve">
          <source>Once RethinkDB is running, you can connect to it at &lt;a href=&quot;http://localhost:8080&quot;&gt;http://localhost:8080&lt;/a&gt;, assuming you&amp;rsquo;ve kept the default port (8080) and it&amp;rsquo;s running on your local machine.</source>
          <target state="translated">一旦RethinkDB运行，您就可以在&lt;a href=&quot;http://localhost:8080&quot;&gt;http：// localhost：8080上&lt;/a&gt;连接它，前提是您保留了默认端口（8080）并且它在本地计算机上运行。</target>
        </trans-unit>
        <trans-unit id="7ee24599fbbe748a6207ac5abb75b2f0ce146744" translate="yes" xml:space="preserve">
          <source>Once a server has been given a tag, the tags may be used to assign table replicas to servers with the same tags using the &lt;code&gt;reconfigure&lt;/code&gt; command. Read the section of this document on &lt;a href=&quot;#server-tags&quot;&gt;Server tags&lt;/a&gt; for more details.</source>
          <target state="translated">一旦为服务器提供了标签，就可以使用标签使用 &lt;code&gt;reconfigure&lt;/code&gt; 命令将表副本分配给具有相同标签的服务器。有关更多详细信息，请阅读本文档中有关&lt;a href=&quot;#server-tags&quot;&gt;服务器标签&lt;/a&gt;的部分。</target>
        </trans-unit>
        <trans-unit id="e5540408974abb67910a41cc619a4fa95a13d057" translate="yes" xml:space="preserve">
          <source>Once the &lt;a href=&quot;https://rethinkdb.com/api/python/run&quot;&gt;run&lt;/a&gt; command is processed, the serialized query needs to be wrapped in the message sent to the server. The complete message takes the form:</source>
          <target state="translated">处理完&lt;a href=&quot;https://rethinkdb.com/api/python/run&quot;&gt;运行&lt;/a&gt;命令后，需要将序列化查询包装在发送给服务器的消息中。完整的消息采用以下形式：</target>
        </trans-unit>
        <trans-unit id="53bf8635a8710aec13732e6e69e7bc521527324f" translate="yes" xml:space="preserve">
          <source>Once the query is sent, you can read the response object back from the server. The response object takes the following form:</source>
          <target state="translated">一旦发送了查询,你就可以从服务器上读回响应对象。响应对象的形式如下。</target>
        </trans-unit>
        <trans-unit id="3581112a511227ecab2edb84928b539f7af5864d" translate="yes" xml:space="preserve">
          <source>Once you block the web interface port in the step above, the easiest way to access it is to use ssh to set up a SOCKS proxy. Run the following command on your local server (not the one running RethinkDB):</source>
          <target state="translated">一旦你在上面的步骤中屏蔽了web界面端口,最简单的访问方式就是使用ssh来设置一个SOCKS代理。在你的本地服务器上运行以下命令(不是运行RethinkDB的那个)。</target>
        </trans-unit>
        <trans-unit id="d54a699f360387d75f05e3a07ed4952abe9ff92f" translate="yes" xml:space="preserve">
          <source>Once you have several machines in a RethinkDB cluster, you can improve your cluster&amp;rsquo;s efficiency by running a &lt;em&gt;proxy node&lt;/em&gt; on each application server and having the client application connect to the proxy on &lt;code&gt;localhost&lt;/code&gt;.</source>
          <target state="translated">一旦您在RethinkDB群集中拥有多台计算机，就可以通过在每个应用程序服务器上运行&lt;em&gt;代理节点&lt;/em&gt;并使客户端应用程序连接到 &lt;code&gt;localhost&lt;/code&gt; 上的代理服务器来提高群集的效率。</target>
        </trans-unit>
        <trans-unit id="0dbb1fe10358fc30c28cd5763913addfac15ea73" translate="yes" xml:space="preserve">
          <source>Once you start using the &lt;code&gt;EventEmitter&lt;/code&gt; interface, the other RethinkDB cursor commands like &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;toArray&lt;/code&gt;, and &lt;code&gt;each&lt;/code&gt; will not be available anymore.</source>
          <target state="translated">一旦你开始使用 &lt;code&gt;EventEmitter&lt;/code&gt; 接口，其他RethinkDB光标指令喜欢 &lt;code&gt;next&lt;/code&gt; ， &lt;code&gt;toArray&lt;/code&gt; ，而 &lt;code&gt;each&lt;/code&gt; 将不再提供。</target>
        </trans-unit>
        <trans-unit id="5e0cf5a9798cd7d0b4bee1fb0bc70175a34b8763" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve got the data in your Elasticsearch server, you&amp;rsquo;re ready to go. Here&amp;rsquo;s an example of a simple query using the Elasticsearch REST API:</source>
          <target state="translated">在Elasticsearch服务器中获得数据后，就可以开始使用了。这是使用Elasticsearch REST API进行简单查询的示例：</target>
        </trans-unit>
        <trans-unit id="91405022f24ea795a6deb7e4bd6123de31f00a95" translate="yes" xml:space="preserve">
          <source>One document exists in &lt;code&gt;db_config&lt;/code&gt; for each database in the cluster, with only two fields in the document.</source>
          <target state="translated">&lt;code&gt;db_config&lt;/code&gt; 中针对集群中的每个数据库存在一个文档，该文档中只有两个字段。</target>
        </trans-unit>
        <trans-unit id="1aefbe1f3a3edcbf196b9064f46c2b010b75a91e" translate="yes" xml:space="preserve">
          <source>One error in particular is notable. If you have a coroutine set to consume a changefeed indefinitely, and the connection closes, the coroutine will experience a &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">特别是一个错误。如果您将协程设置为无限期使用changefeed，并且连接关闭，则协程将遇到 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f970864af19d41ebb8dfcca5915e187b5747d24e" translate="yes" xml:space="preserve">
          <source>One error in particular is notable. If you have a task that consumes a changefeed indefinitely, and the connection closes, the task will experience a &lt;code&gt;ReqlRuntimeError&lt;/code&gt;.</source>
          <target state="translated">特别是一个错误。如果您的任务无限期地消耗更改提要，并且连接关闭，则该任务将遇到 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16aa2d8ea363974f203646459194020c667345ca" translate="yes" xml:space="preserve">
          <source>One more way to write the previous query is to set the age to be &lt;code&gt;-1&lt;/code&gt; when the field is missing.</source>
          <target state="translated">编写前一个查询的另一种方法是在缺少该字段时将年龄设置为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3e019a9ff633c6020fe2ace6839ac83a61316c9" translate="yes" xml:space="preserve">
          <source>One to many relations</source>
          <target state="translated">一对多关系</target>
        </trans-unit>
        <trans-unit id="99333c2702163735323c381df7d8fefff652b99b" translate="yes" xml:space="preserve">
          <source>One way to build the index would be:</source>
          <target state="translated">建立指数的一种方法是:</target>
        </trans-unit>
        <trans-unit id="2e0254c28e2b06c621fe3e5af23ceeb7e03e64e7" translate="yes" xml:space="preserve">
          <source>Ongoing</source>
          <target state="translated">Ongoing</target>
        </trans-unit>
        <trans-unit id="066193625de0ad53074bd617e05acb13fb7e193d" translate="yes" xml:space="preserve">
          <source>Only a limited subset of ReQL commands may be chained after &lt;code&gt;binary&lt;/code&gt;:</source>
          <target state="translated">在 &lt;code&gt;binary&lt;/code&gt; 后只能链接有限的ReQL命令子集：</target>
        </trans-unit>
        <trans-unit id="bddea468cb2adb77cc258c3b88f6e01f0752c0bc" translate="yes" xml:space="preserve">
          <source>Only longitude/latitude coordinates are supported. GeoJSON objects that use Cartesian coordinates, specify an altitude, or specify their own coordinate reference system will be rejected.</source>
          <target state="translated">只支持经度/纬度坐标。使用笛卡尔坐标、指定高度或指定自己的坐标参考系的GeoJSON对象将被拒绝。</target>
        </trans-unit>
        <trans-unit id="262b6559e88c687d15b623deba02fac703403295" translate="yes" xml:space="preserve">
          <source>Open a TCP connection to the server on the driver port. The default port is &lt;code&gt;28015&lt;/code&gt;.</source>
          <target state="translated">在驱动程序端口上打开到服务器的TCP连接。默认端口是 &lt;code&gt;28015&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c232e4ef552d94c7bc322934608dfd9c1f3678b" translate="yes" xml:space="preserve">
          <source>Open a connection</source>
          <target state="translated">打开一个连接</target>
        </trans-unit>
        <trans-unit id="65160f68c4c399c8650355e13e625aa1a85b20f6" translate="yes" xml:space="preserve">
          <source>Open the &lt;strong&gt;Security Groups&lt;/strong&gt; section of the administration console.</source>
          <target state="translated">打开管理控制台的&amp;ldquo; &lt;strong&gt;安全组&amp;rdquo;&lt;/strong&gt;部分。</target>
        </trans-unit>
        <trans-unit id="3098205123cfb916f292fb3965082298a4ab6621" translate="yes" xml:space="preserve">
          <source>Open the RethinkDB Data Explorer in the web UI and execute the following command:</source>
          <target state="translated">在Web UI中打开RethinkDB数据浏览器,并执行以下命令。</target>
        </trans-unit>
        <trans-unit id="26e94e9d577c801c827b900c0b793db4e3600d97" translate="yes" xml:space="preserve">
          <source>OpenSSL will ask you to enter information for the certificate. While some of these questions can be left at their default, the &amp;ldquo;Common Name&amp;rdquo; must match the domain name of your server. For local testing purposes you can use &lt;code&gt;localhost&lt;/code&gt;, but not in production.</source>
          <target state="translated">OpenSSL将要求您输入证书信息。虽然其中一些问题可以保留为默认值，但&amp;ldquo;公用名&amp;rdquo;必须与服务器的域名匹配。为了进行本地测试，可以使用 &lt;code&gt;localhost&lt;/code&gt; ，但不能在生产环境中使用。</target>
        </trans-unit>
        <trans-unit id="005f473987f60d5de30a1511d957a61d11d7b074" translate="yes" xml:space="preserve">
          <source>Opera 1.62 or higher</source>
          <target state="translated">Opera 1.62或更高</target>
        </trans-unit>
        <trans-unit id="800944565827543e19a120253438c1772df26425" translate="yes" xml:space="preserve">
          <source>Operations on authors and posts don&amp;rsquo;t require loading the data for every post for a given author into memory.</source>
          <target state="translated">对作者和帖子的操作不需要将给定作者的每个帖子的数据加载到内存中。</target>
        </trans-unit>
        <trans-unit id="67910125278b444143eb3baa7f7a144f98b62c28" translate="yes" xml:space="preserve">
          <source>Optimizing query performance</source>
          <target state="translated">优化查询性能</target>
        </trans-unit>
        <trans-unit id="3c7b449b88c10330229439fe19c9db3e4b06af90" translate="yes" xml:space="preserve">
          <source>Optional arguments available with &lt;code&gt;circle&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;circle&lt;/code&gt; 可用的可选参数为：</target>
        </trans-unit>
        <trans-unit id="e91d767910b702fe59c28c74e7779fc7e01b53ac" translate="yes" xml:space="preserve">
          <source>Optional arguments available with &lt;code&gt;distance&lt;/code&gt; are:</source>
          <target state="translated">&lt;code&gt;distance&lt;/code&gt; 可用的可选参数为：</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="655dae8fdf9f43c66dc061c5ade6f0a366837031" translate="yes" xml:space="preserve">
          <source>Options for imports include:</source>
          <target state="translated">进口的选择包括:</target>
        </trans-unit>
        <trans-unit id="52b7d82bd544399dc5fb544375b8f490d76aeee0" translate="yes" xml:space="preserve">
          <source>Options to &lt;code&gt;dump&lt;/code&gt; let you specify cluster information and limit the archive to specific databases or tables.</source>
          <target state="translated">通过 &lt;code&gt;dump&lt;/code&gt; 选项，您可以指定群集信息并将存档限制为特定的数据库或表。</target>
        </trans-unit>
        <trans-unit id="c82e2b89585dcea4afe8d1cf12f407a6d9a9afae" translate="yes" xml:space="preserve">
          <source>Or create a secondary index on them:</source>
          <target state="translated">或在其上建立二级索引。</target>
        </trans-unit>
        <trans-unit id="76ee0a831a4163c3b30755e038356362dcf59b70" translate="yes" xml:space="preserve">
          <source>Or, Bob&amp;rsquo;s work phone and Skype handle:</source>
          <target state="translated">或者，鲍勃的工作电话和Skype可以处理：</target>
        </trans-unit>
        <trans-unit id="dea3c588ab8bfc482b4550169db7672275347564" translate="yes" xml:space="preserve">
          <source>Or, let&amp;rsquo;s pluck out usernames and IDs, and sort the array in ascending order by user IDs:</source>
          <target state="translated">或者，让我们选择用户名和ID，然后按用户ID升序对数组进行排序：</target>
        </trans-unit>
        <trans-unit id="a8617c20d3ebc00ea8af63ceb4ece5ae885ba2bb" translate="yes" xml:space="preserve">
          <source>Or, let&amp;rsquo;s try to delete a single user:</source>
          <target state="translated">或者，让我们尝试删除一个用户：</target>
        </trans-unit>
        <trans-unit id="517d47ffe448c40f8d65907d0e9bbb885347087a" translate="yes" xml:space="preserve">
          <source>Oracle Java 1.8.0 on the client nodes</source>
          <target state="translated">客户端节点上的Oracle Java 1.8.0。</target>
        </trans-unit>
        <trans-unit id="a67de582176ad1685ed737600c40cb806a9dc02a" translate="yes" xml:space="preserve">
          <source>Order by date and title.</source>
          <target state="translated">按日期和标题排序。</target>
        </trans-unit>
        <trans-unit id="1d3437a75ca6256f37c2450c0c776fb565f1c788" translate="yes" xml:space="preserve">
          <source>Ordering without an index requires the server to load the whole sequence in an array, which is limited by default to 100,000 documents. You can use the &lt;code&gt;arrayLimit&lt;/code&gt; option to &lt;a href=&quot;../../api/javascript/run/index&quot;&gt;run&lt;/a&gt; to temporarily raise this limit. However, a more efficient option is to use an index. See the documentation for &lt;a href=&quot;../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt; for more information.</source>
          <target state="translated">不带索引的订购要求服务器将整个序列加载到数组中，默认情况下，该序列限制为100,000个文档。您可以使用 &lt;code&gt;arrayLimit&lt;/code&gt; 选项&lt;a href=&quot;../../api/javascript/run/index&quot;&gt;运行&lt;/a&gt;以临时提高此限制。但是，更有效的选择是使用索引。有关更多信息，请参阅&lt;a href=&quot;../../api/javascript/order_by/index&quot;&gt;orderBy&lt;/a&gt;的文档。</target>
        </trans-unit>
        <trans-unit id="0635fe7d51a8df49e7a657f79a8f6473abb466ab" translate="yes" xml:space="preserve">
          <source>Organizing by value with &lt;strong&gt;multi&lt;/strong&gt;</source>
          <target state="translated">通过价值进行&lt;strong&gt;多方&lt;/strong&gt;组织&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02920c862ccbff6d9ea90f0249e6739c73f53be8" translate="yes" xml:space="preserve">
          <source>Other architectures</source>
          <target state="translated">其他结构</target>
        </trans-unit>
        <trans-unit id="bc1c9b417f89fe542bb1934f83a9192b283b0bb0" translate="yes" xml:space="preserve">
          <source>Other tables</source>
          <target state="translated">其他表格</target>
        </trans-unit>
        <trans-unit id="2650dbe4bcd4f307dc4c1b316b876d711322bfab" translate="yes" xml:space="preserve">
          <source>Other things that might be helpful to us, if you have them:</source>
          <target state="translated">其他可能对我们有帮助的东西,如果你有的话。</target>
        </trans-unit>
        <trans-unit id="866131f1f2375ca571ce12c268e0c656ecbc12e4" translate="yes" xml:space="preserve">
          <source>Other unusual configuration details</source>
          <target state="translated">其他不寻常的配置细节</target>
        </trans-unit>
        <trans-unit id="3f6f6d94cdfb57598370b4d3559b5ea5baf371fc" translate="yes" xml:space="preserve">
          <source>Otherwise, a document was updated from &lt;code&gt;new_val&lt;/code&gt; to &lt;code&gt;old_val&lt;/code&gt;</source>
          <target state="translated">否则，文档已从 &lt;code&gt;new_val&lt;/code&gt; 更新为 &lt;code&gt;old_val&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="635983c30fa94cc702bf5a3063575de06b27f6c0" translate="yes" xml:space="preserve">
          <source>Our first workload from YCSB is workload A. It performs an equal number of get and update operations.</source>
          <target state="translated">我们来自YCSB的第一个工作负载是工作负载A,它执行同等数量的获取和更新操作。</target>
        </trans-unit>
        <trans-unit id="c3102dfdc420ea7f4b95502211100be74c8d001e" translate="yes" xml:space="preserve">
          <source>Our long-term goal is to port RethinkDB to every widely-used platform. &lt;a href=&quot;https://rethinkdb.com/community/&quot;&gt;Get involved&lt;/a&gt; in the development effort and help port RethinkDB to more platforms.</source>
          <target state="translated">我们的长期目标是将RethinkDB移植到每个广泛使用的平台。&lt;a href=&quot;https://rethinkdb.com/community/&quot;&gt;参与&lt;/a&gt;开发工作，并帮助将RethinkDB移植到更多平台。</target>
        </trans-unit>
        <trans-unit id="9d27e01bc1f16af9ab5b684bbca08e77d04c7441" translate="yes" xml:space="preserve">
          <source>Outdated index issues</source>
          <target state="translated">过时的指数问题</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="7daf403c7589f4927632ed3b6af762a992f09b78" translate="yes" xml:space="preserve">
          <source>PHP</source>
          <target state="translated">PHP</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1ad9f67d0f855f646efb3775c7a4778a3cc5a138" translate="yes" xml:space="preserve">
          <source>Parallelism</source>
          <target state="translated">Parallelism</target>
        </trans-unit>
        <trans-unit id="a3f2f9b464ffd6a075b16b138e68eee36eb4fad2" translate="yes" xml:space="preserve">
          <source>Parse a JSON string on the server.</source>
          <target state="translated">在服务器上解析JSON字符串。</target>
        </trans-unit>
        <trans-unit id="a02cd3149b8489d7554699018bd6802639a0fb15" translate="yes" xml:space="preserve">
          <source>Parsing RethinkDB&amp;rsquo;s response to a write query</source>
          <target state="translated">解析RethinkDB对写查询的响应</target>
        </trans-unit>
        <trans-unit id="d5ed1ca0e30841762087801ad0ea2356bf068bd4" translate="yes" xml:space="preserve">
          <source>Passport</source>
          <target state="translated">Passport</target>
        </trans-unit>
        <trans-unit id="a6ef67119795d1dec2733382dde8851959466fd2" translate="yes" xml:space="preserve">
          <source>Password hashing iterations</source>
          <target state="translated">密码散列迭代</target>
        </trans-unit>
        <trans-unit id="602f708ddfd2f5c04ef6214f07b92793c6440c57" translate="yes" xml:space="preserve">
          <source>Pastie app</source>
          <target state="translated">Pastie应用程序</target>
        </trans-unit>
        <trans-unit id="9ee3e3fb749ad0b1c61fd33d63af73925ef460d8" translate="yes" xml:space="preserve">
          <source>Perform a branching conditional equivalent to &lt;code&gt;if-then-else&lt;/code&gt;.</source>
          <target state="translated">执行等效于 &lt;code&gt;if-then-else&lt;/code&gt; 的分支条件。</target>
        </trans-unit>
        <trans-unit id="efb5dcdc44fc2c6fa0229180b4ba0e6617436df4" translate="yes" xml:space="preserve">
          <source>Perform a handshake</source>
          <target state="translated">进行握手</target>
        </trans-unit>
        <trans-unit id="31d145708b03b1271ba67061462d8bf7d2aa9ca6" translate="yes" xml:space="preserve">
          <source>Performance Details</source>
          <target state="translated">性能细节</target>
        </trans-unit>
        <trans-unit id="d8de1447c9bf3acce93c7e508a1c29a20555687a" translate="yes" xml:space="preserve">
          <source>Performance report</source>
          <target state="translated">执行情况报告</target>
        </trans-unit>
        <trans-unit id="1a7039a0fe11cfbcaf911a9186d34c5c3a09eeb8" translate="yes" xml:space="preserve">
          <source>Performing a conditional insert or replace</source>
          <target state="translated">执行有条件的插入或替换</target>
        </trans-unit>
        <trans-unit id="933b62ca112baccc2befe203fa03de8a89c72068" translate="yes" xml:space="preserve">
          <source>Performing a pivot operation</source>
          <target state="translated">执行枢轴操作</target>
        </trans-unit>
        <trans-unit id="a9d4d7d7d35c4a76ac97d509252cf3e581c5e1dc" translate="yes" xml:space="preserve">
          <source>Performing an unpivot operation</source>
          <target state="translated">执行非枢轴操作</target>
        </trans-unit>
        <trans-unit id="c0bc0b17b999bff2f1cc8b8c30efeb6034e0c0a9" translate="yes" xml:space="preserve">
          <source>Performing multiple aggregations simultaneously</source>
          <target state="translated">同时执行多个聚合</target>
        </trans-unit>
        <trans-unit id="a03eb97735ec7717f1d64f293267ac389abb2754" translate="yes" xml:space="preserve">
          <source>Performs 200 million operations in total</source>
          <target state="translated">共执行2亿次操作</target>
        </trans-unit>
        <trans-unit id="1f85efe74af8d3b3506a24e9543f0465c2109af2" translate="yes" xml:space="preserve">
          <source>Performs 50 million operations in total</source>
          <target state="translated">总共执行5000万次操作</target>
        </trans-unit>
        <trans-unit id="f111d810e7ca920bda8f128569fc002610c45314" translate="yes" xml:space="preserve">
          <source>Perl</source>
          <target state="translated">Perl</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="627aed65a0d9d2626caf51bb839dcee691e75d17" translate="yes" xml:space="preserve">
          <source>Permissions and user accounts</source>
          <target state="translated">权限和用户账户</target>
        </trans-unit>
        <trans-unit id="0ac88ea84587ef82d96b641061e89b7e0e66ff2c" translate="yes" xml:space="preserve">
          <source>Permissions are stored in the &lt;code&gt;permissions&lt;/code&gt; system table. While you can change permissions by modifying documents within that table, it&amp;rsquo;s far more convenient to use the &lt;a href=&quot;#the-grant-command&quot;&gt;grant&lt;/a&gt; command; see below.</source>
          <target state="translated">权限存储在 &lt;code&gt;permissions&lt;/code&gt; 系统表中。虽然可以通过修改该表中的文档来更改权限，但是使用&lt;a href=&quot;#the-grant-command&quot;&gt;grant&lt;/a&gt;命令要方便得多；见下文。</target>
        </trans-unit>
        <trans-unit id="bf871a8778973cc849027508cdc967888db0dc66" translate="yes" xml:space="preserve">
          <source>Permissions may be granted on a global scope, or granted for a specific table or database. The scope is defined by calling &lt;code&gt;grant&lt;/code&gt; on its own (e.g., &lt;code&gt;r.grant()&lt;/code&gt;, on a table (&lt;code&gt;r.table().grant()&lt;/code&gt;), or on a database (&lt;code&gt;r.db().grant()&lt;/code&gt;).</source>
          <target state="translated">权限可以在全局范围内授予，也可以在特定的表或数据库中授予。通过 &lt;code&gt;r.grant()&lt;/code&gt; 调用 &lt;code&gt;grant&lt;/code&gt; （例如，r.grant（），表（ &lt;code&gt;r.table().grant()&lt;/code&gt; ）或数据库（ &lt;code&gt;r.db().grant()&lt;/code&gt; ）来定义范围。</target>
        </trans-unit>
        <trans-unit id="eb767066d9789af7d92101acfb56fb7687bff20c" translate="yes" xml:space="preserve">
          <source>Permissions specified at a lower level will override permissions set at a higher level: a user could be granted read and write access to the &lt;code&gt;field_notes&lt;/code&gt; database, but denied the ability to write to the &lt;code&gt;calendar&lt;/code&gt; table and to either read or write to the &lt;code&gt;supervisor_only&lt;/code&gt; table.</source>
          <target state="translated">在较低级别上指定的权限将覆盖在较高级别上设置的权限：可以授予用户对 &lt;code&gt;field_notes&lt;/code&gt; 数据库的读写访问权限，但拒绝用户写入 &lt;code&gt;calendar&lt;/code&gt; 表以及读取或写入 &lt;code&gt;supervisor_only&lt;/code&gt; 表的功能。</target>
        </trans-unit>
        <trans-unit id="d15069fb8e15cad486a5d82a9690982408a75b0e" translate="yes" xml:space="preserve">
          <source>Permissions that are not defined on a local scope will be inherited from the next largest scope. For example, a write operation on a table will first check if &lt;code&gt;write&lt;/code&gt; permissions are explicitly set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; for that table and account combination; if they are not, the &lt;code&gt;write&lt;/code&gt; permissions for the database will be used if those are explicitly set; and if neither table nor database permissions are set for that account, the global &lt;code&gt;write&lt;/code&gt; permissions for that account will be used.</source>
          <target state="translated">未在本地范围内定义的权限将从下一个最大范围继承。例如，对表的写操作将首先检查该表和帐户组合的 &lt;code&gt;write&lt;/code&gt; 权限是否显式设置为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ；如果没有，则显式设置数据库的 &lt;code&gt;write&lt;/code&gt; 权限；否则，将使用数据库的写权限。如果该帐户没有设置表权限或数据库权限，则将使用该帐户的全局 &lt;code&gt;write&lt;/code&gt; 权限。</target>
        </trans-unit>
        <trans-unit id="b965dd6fc2b3bcbc619861e8015982b2b31bc638" translate="yes" xml:space="preserve">
          <source>Please take into consideration when you generating version 5 UUIDs can&amp;rsquo;t be considered guaranteed unique if they&amp;rsquo;re computing based on user data because they use SHA-1 algorithm.</source>
          <target state="translated">生成版本5的UUID是基于用户数据进行计算时，因为它们使用SHA-1算法，因此，在生成第5版UUID时，不能将其视为保证唯一。</target>
        </trans-unit>
        <trans-unit id="7b2206d37e61c7b1012ffbefa3c983e86a032077" translate="yes" xml:space="preserve">
          <source>Plucks one or more attributes from a sequence of objects, filtering out any objects in the sequence that do not have the specified fields. Functionally, this is identical to &lt;a href=&quot;../has_fields/index&quot;&gt;hasFields&lt;/a&gt; followed by &lt;a href=&quot;../pluck/index&quot;&gt;pluck&lt;/a&gt; on a sequence.</source>
          <target state="translated">从对象序列中抽取一个或多个属性，过滤掉序列中没有指定字段的所有对象。在功能上，这是相同的&lt;a href=&quot;../has_fields/index&quot;&gt;hasFields&lt;/a&gt;随后&lt;a href=&quot;../pluck/index&quot;&gt;拔毛&lt;/a&gt;上的序列。</target>
        </trans-unit>
        <trans-unit id="a7461725c3e122f101426f35a2e66d9ba3287681" translate="yes" xml:space="preserve">
          <source>Plucks one or more attributes from a sequence of objects, filtering out any objects in the sequence that do not have the specified fields. Functionally, this is identical to &lt;a href=&quot;has_fields/index&quot;&gt;hasFields&lt;/a&gt; followed by &lt;a href=&quot;pluck/index&quot;&gt;pluck&lt;/a&gt; on a sequence.</source>
          <target state="translated">从对象序列中抽取一个或多个属性，过滤掉序列中没有指定字段的所有对象。在功能上，这是相同的&lt;a href=&quot;has_fields/index&quot;&gt;hasFields&lt;/a&gt;随后&lt;a href=&quot;pluck/index&quot;&gt;拔毛&lt;/a&gt;上的序列。</target>
        </trans-unit>
        <trans-unit id="4550e37a008aa8641c291ddb18c860428af08805" translate="yes" xml:space="preserve">
          <source>Plucks out one or more attributes from either an object or a sequence of objects (projection).</source>
          <target state="translated">从一个对象或一个对象序列中提取出一个或多个属性(投影)。</target>
        </trans-unit>
        <trans-unit id="59a24e502e21080856136622628d2c36a365ff13" translate="yes" xml:space="preserve">
          <source>Point (single document) changefeeds</source>
          <target state="translated">点(单份文件)的更改输入</target>
        </trans-unit>
        <trans-unit id="d82fa8e3ba9ed2db42802966c34a79c79ec35e10" translate="yes" xml:space="preserve">
          <source>Point your browser to &lt;code&gt;localhost:8080&lt;/code&gt;. You&amp;rsquo;ll see an administrative UI where you can control the cluster (which so far consists of one server), and play with the query language.</source>
          <target state="translated">将浏览器指向 &lt;code&gt;localhost:8080&lt;/code&gt; 。您将看到一个管理UI，您可以在其中控制集群（到目前为止，该集群由一台服务器组成），并使用查询语言进行播放。</target>
        </trans-unit>
        <trans-unit id="d6fedcfcdb0a32752d9ea03a839178f433515d36" translate="yes" xml:space="preserve">
          <source>Point your browser to the HTTP connections port (&lt;code&gt;8080&lt;/code&gt; by default) to access the web interface.</source>
          <target state="translated">将浏览器指向HTTP连接端口（默认为 &lt;code&gt;8080&lt;/code&gt; ）以访问Web界面。</target>
        </trans-unit>
        <trans-unit id="a4a871ea0a8e57174881c9b4bf86e9bb052c9f69" translate="yes" xml:space="preserve">
          <source>Polygons can also have holes in them, created when a polygon entirely enclosed by another one is &amp;ldquo;punched out&amp;rdquo; of the larger one using the &lt;code&gt;polygonSub&lt;/code&gt; command. (This is the only way to create a polygon with a hole in it.)</source>
          <target state="translated">多边形中也可以有孔，这是通过使用 &lt;code&gt;polygonSub&lt;/code&gt; 命令从一个较大的多边形&amp;ldquo;冲出&amp;rdquo;一个完全被另一个多边形包围的多边形而创建的。（这是创建带有孔的多边形的唯一方法。）</target>
        </trans-unit>
        <trans-unit id="606d1d5e59fa1b7b6ee0fae6e5cdc98754db92b8" translate="yes" xml:space="preserve">
          <source>Port 22 is for SSH. The server uses public key authentication.</source>
          <target state="translated">22号端口用于SSH。服务器使用公钥认证。</target>
        </trans-unit>
        <trans-unit id="167dacf7578e199e55dd6313fc9876a5b1867b79" translate="yes" xml:space="preserve">
          <source>Port 28015 is for client driver access. The only form of authentication is a key that is sent in plain text over the network.</source>
          <target state="translated">28015端口用于客户端驱动程序的访问。唯一的认证方式是通过网络发送纯文本的密钥。</target>
        </trans-unit>
        <trans-unit id="6122f7270d7d535ad95a3aec4e825c2e02f9c751" translate="yes" xml:space="preserve">
          <source>Port 443 is for HTTPS. An Nginx server sits between RethinkDB and the world and provides basic HTTP authentication and secure HTTPS connections for the web UI.</source>
          <target state="translated">443端口是用于HTTPS。Nginx服务器位于RethinkDB和世界之间,为Web用户界面提供基本的HTTP认证和安全的HTTPS连接。</target>
        </trans-unit>
        <trans-unit id="f5c666906c3424aaf3e0422d4c7fc73f92951d6e" translate="yes" xml:space="preserve">
          <source>Port 80 is for HTTP. It is used during the setup process but otherwise redirects to HTTPS.</source>
          <target state="translated">80端口是用于HTTP。它在设置过程中使用,但在其他情况下会重定向到HTTPS。</target>
        </trans-unit>
        <trans-unit id="687986e409c97687863566c17cb109678af9b482" translate="yes" xml:space="preserve">
          <source>Port: &lt;code&gt;3000&lt;/code&gt;</source>
          <target state="translated">港口： &lt;code&gt;3000&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5333d3c84dc8377268cd686f0cc959419711b637" translate="yes" xml:space="preserve">
          <source>Predicates to &lt;code&gt;filter&lt;/code&gt; are evaluated on the server, and must use ReQL expressions. You cannot use standard JavaScript comparison operators such as &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;/&lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;/&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">在服务器上评估要 &lt;code&gt;filter&lt;/code&gt; 谓词，并且必须使用ReQL表达式。您不能使用 &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;&amp;lt;&lt;/code&gt; / &lt;code&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 之类的标准JavaScript比较运算符 / &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d574e84514abeecdd6ac66fa898f6addb4221b4" translate="yes" xml:space="preserve">
          <source>Prepend a value to an array.</source>
          <target state="translated">将一个值预置到一个数组中。</target>
        </trans-unit>
        <trans-unit id="7f22ba753489d7e920e259cf09c81b2c3d9c5597" translate="yes" xml:space="preserve">
          <source>Produce a single value from a sequence through repeated application of a reduction function.</source>
          <target state="translated">通过重复应用还原函数从一个序列中产生一个单一的值。</target>
        </trans-unit>
        <trans-unit id="d9f525bfecb73d82d2f90a76e5e52925c8bfb8b8" translate="yes" xml:space="preserve">
          <source>Produces a non-existence error when called on an empty sequence. You can handle this case with &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">在空序列上调用时产生不存在的错误。您可以使用 &lt;code&gt;default&lt;/code&gt; 处理这种情况。</target>
        </trans-unit>
        <trans-unit id="9015371a0d33ee422afb2ea58ff543ac4c16f19b" translate="yes" xml:space="preserve">
          <source>Provide a default value in case of non-existence errors. The &lt;code&gt;default&lt;/code&gt; command evaluates its first argument (the value it&amp;rsquo;s chained to). If that argument returns &lt;code&gt;null&lt;/code&gt; or a non-existence error is thrown in evaluation, then &lt;code&gt;default&lt;/code&gt; returns its second argument. The second argument is usually a default value, but it can be a function that returns a value.</source>
          <target state="translated">如果不存在错误，请提供默认值。该 &lt;code&gt;default&lt;/code&gt; 命令评估其第一个参数（它链接到的值）。如果该参数返回 &lt;code&gt;null&lt;/code&gt; 或在评估中引发不存在的错误，则 &lt;code&gt;default&lt;/code&gt; 返回其第二个参数。第二个参数通常是默认值，但它可以是返回值的函数。</target>
        </trans-unit>
        <trans-unit id="2a2793cd5e2cebdd699874e60337368ad4c7f0e4" translate="yes" xml:space="preserve">
          <source>Proxy nodes</source>
          <target state="translated">代理节点</target>
        </trans-unit>
        <trans-unit id="35cd7f9cdee7e3c5423c4f68b7a5a738e7ee908a" translate="yes" xml:space="preserve">
          <source>Publish-Subscribe</source>
          <target state="translated">Publish-Subscribe</target>
        </trans-unit>
        <trans-unit id="d74d06bbc20ee3a59b09c01526b467c887af9167" translate="yes" xml:space="preserve">
          <source>Publish-Subscribe with RethinkDB</source>
          <target state="translated">用RethinkDB发布-订阅</target>
        </trans-unit>
        <trans-unit id="08ab1df032a5bfbbddcde416cd9683a3da9a8034" translate="yes" xml:space="preserve">
          <source>Publish-subscribe</source>
          <target state="translated">Publish-subscribe</target>
        </trans-unit>
        <trans-unit id="9c416ee884bbd4d8e89a95d4c023e9b2eff57f5f" translate="yes" xml:space="preserve">
          <source>Pushing changes to RabbitMQ</source>
          <target state="translated">推进对RabbitMQ的修改</target>
        </trans-unit>
        <trans-unit id="c148aded3d47eba6bad059e92b2038d207b0a750" translate="yes" xml:space="preserve">
          <source>Putting it all together</source>
          <target state="translated">把它整合在一起</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="49cfc0fae0169e4b63343a3e789527ea52375294" translate="yes" xml:space="preserve">
          <source>Python driver</source>
          <target state="translated">Python驱动程序</target>
        </trans-unit>
        <trans-unit id="d82cabe971317809828edbfbe4a5e9612ec586ff" translate="yes" xml:space="preserve">
          <source>Python libraries</source>
          <target state="translated">Python库</target>
        </trans-unit>
        <trans-unit id="c56ac30b14c8764fec5b5b70036659f9b693a5b5" translate="yes" xml:space="preserve">
          <source>Python with Tornado or Twisted</source>
          <target state="translated">Python与Tornado或Twisted</target>
        </trans-unit>
        <trans-unit id="bacc89e7a944a342361ad407e50c1bdc4adbb60e" translate="yes" xml:space="preserve">
          <source>Queries for accessing authors and posts tend to be simpler.</source>
          <target state="translated">访问作者和帖子的查询往往比较简单。</target>
        </trans-unit>
        <trans-unit id="9a23e1f2ab29b58922510028cdd1e93bcff6daa1" translate="yes" xml:space="preserve">
          <source>Queries in detail</source>
          <target state="translated">详细查询</target>
        </trans-unit>
        <trans-unit id="6ed8d030024e173cbdfaacb35d2c5b9fe1de254d" translate="yes" xml:space="preserve">
          <source>Query (read and/or update) the configurations for individual tables or databases.</source>
          <target state="translated">查询(读取和/或更新)各个表或数据库的配置。</target>
        </trans-unit>
        <trans-unit id="2dd43bff670fb4443641b638e91c3a1e2666b727" translate="yes" xml:space="preserve">
          <source>Query Runtime (seconds)</source>
          <target state="translated">查询运行时间(秒</target>
        </trans-unit>
        <trans-unit id="90479d900b8bfaebff69bef7c1e6f5e4acf525cc" translate="yes" xml:space="preserve">
          <source>Query execution</source>
          <target state="translated">查询执行</target>
        </trans-unit>
        <trans-unit id="89912ace151473384dc0a610242cf6f97eff4e6b" translate="yes" xml:space="preserve">
          <source>Query optimization</source>
          <target state="translated">查询优化</target>
        </trans-unit>
        <trans-unit id="c40c0a7ff9b0eb9e3f2b0a13a19b9c280e41d151" translate="yes" xml:space="preserve">
          <source>Query types: 50% single-document read ops, 50% single-document update ops</source>
          <target state="translated">查询类型。50%的单一文件读取操作,50%的单一文件更新操作。</target>
        </trans-unit>
        <trans-unit id="aaa9e9974cdedcdc0d68a460b12895753d966e0f" translate="yes" xml:space="preserve">
          <source>Query types: Count the total number of sentences over a single field: table.map(r.row(&amp;ldquo;field0&amp;rdquo;).split(&amp;ldquo;.&amp;rdquo;).count()).sum()</source>
          <target state="translated">查询类型：计算单个字段中的句子总数：table.map（r.row（&amp;ldquo; field0&amp;rdquo;）。split（&amp;ldquo;。&amp;rdquo;）。count（））。sum（）</target>
        </trans-unit>
        <trans-unit id="30a91f4f78c1ba3a4e0863c44ed3e1c0761b3e1b" translate="yes" xml:space="preserve">
          <source>Query types: Single-document gets</source>
          <target state="translated">查询类型。单一文件获取</target>
        </trans-unit>
        <trans-unit id="cc6835ce045ca407e1aa42cf034a40b2dc968c7d" translate="yes" xml:space="preserve">
          <source>Querying</source>
          <target state="translated">Querying</target>
        </trans-unit>
        <trans-unit id="2311ef772fd9667ad480d784efeb91fd87562cee" translate="yes" xml:space="preserve">
          <source>Querying the jobs table</source>
          <target state="translated">查询工作表</target>
        </trans-unit>
        <trans-unit id="cfd1d967b9233f2a022120ac5fc5e2af2bff64b0" translate="yes" xml:space="preserve">
          <source>Querying the stats table</source>
          <target state="translated">查询统计表</target>
        </trans-unit>
        <trans-unit id="b4e9d799b4c484b951d3a7526f99384d51e97175" translate="yes" xml:space="preserve">
          <source>Querying this table with no filters produces a list of all current issues within the cluster.</source>
          <target state="translated">在没有过滤器的情况下,查询此表会产生一个集群内所有当前问题的列表。</target>
        </trans-unit>
        <trans-unit id="24cc2440fd1b49aaf1c5a8958c6de61e1529c18a" translate="yes" xml:space="preserve">
          <source>Quick setup</source>
          <target state="translated">快速设置</target>
        </trans-unit>
        <trans-unit id="d07133c8504b6a0e98371a1b9afe2ca2855a7270" translate="yes" xml:space="preserve">
          <source>Quickstart</source>
          <target state="translated">Quickstart</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="bfc29699c72375bf47c9436811bc275479e815df" translate="yes" xml:space="preserve">
          <source>RECV</source>
          <target state="translated">RECV</target>
        </trans-unit>
        <trans-unit id="9e7d6316420463a965783442095454fff2759c0a" translate="yes" xml:space="preserve">
          <source>RabbitMQ is a natural choice for distributing notifications of change events. It&amp;rsquo;s designed to efficiently route messages to many listeners, and there are client libraries for most popular languages. In this tutorial we take advantage of RabbitMQ&amp;rsquo;s &lt;a href=&quot;https://www.rabbitmq.com/tutorials/amqp-concepts.html#topic-exchange&quot;&gt;topic exchanges&lt;/a&gt;. Topic exchanges allow clients to subscribe to the messages they&amp;rsquo;re interested in, and ignore the rest.</source>
          <target state="translated">RabbitMQ是分发变更事件通知的自然选择。它旨在将消息有效地路由到许多侦听器，并且有用于大多数流行语言的客户端库。在本教程中，我们利用RabbitMQ的&lt;a href=&quot;https://www.rabbitmq.com/tutorials/amqp-concepts.html#topic-exchange&quot;&gt;主题交流&lt;/a&gt;。主题交换使客户可以订阅他们感兴趣的消息，而忽略其余消息。</target>
        </trans-unit>
        <trans-unit id="5dd8e5ee1c3e6446669db2bc1a5feb0e30e90272" translate="yes" xml:space="preserve">
          <source>Rackspace OnMetal Compute</source>
          <target state="translated">Rackspace OnMetal Compute</target>
        </trans-unit>
        <trans-unit id="26231667af7cc1c479da94498b920bd20cc4204e" translate="yes" xml:space="preserve">
          <source>Rackspace OnMetal I/O</source>
          <target state="translated">Rackspace OnMetal I/O</target>
        </trans-unit>
        <trans-unit id="56f04e78d5af9bc3df5498e192f568246521ebe8" translate="yes" xml:space="preserve">
          <source>Raspbian</source>
          <target state="translated">Raspbian</target>
        </trans-unit>
        <trans-unit id="cc2546f8cc7b851025e82d9ad64be8681c1defc8" translate="yes" xml:space="preserve">
          <source>ReQL</source>
          <target state="translated">ReQL</target>
        </trans-unit>
        <trans-unit id="4ac00efdbe1ef213d5db65a44a2317ffb880734f" translate="yes" xml:space="preserve">
          <source>ReQL administration commands</source>
          <target state="translated">ReQL管理命令</target>
        </trans-unit>
        <trans-unit id="ed867a0a1051c1e47be81b1dc6bcf49d2a9a6a50" translate="yes" xml:space="preserve">
          <source>ReQL command: () (bracket)</source>
          <target state="translated">ReQL命令。()(括号)</target>
        </trans-unit>
        <trans-unit id="9c77279ce7eb456fb9242d6b0d4944fc101cd9ac" translate="yes" xml:space="preserve">
          <source>ReQL command: EventEmitter (connection)</source>
          <target state="translated">ReQL命令。EventEmitter(连接)</target>
        </trans-unit>
        <trans-unit id="33ff2c1a1ec8fbe986458a9f2936ae04f4bdfb80" translate="yes" xml:space="preserve">
          <source>ReQL command: EventEmitter (cursor)</source>
          <target state="translated">ReQL命令。EventEmitter (cursor)</target>
        </trans-unit>
        <trans-unit id="ecfe4f46eb5536b7c3b6865e0253407db4987f76" translate="yes" xml:space="preserve">
          <source>ReQL command: ISO8601</source>
          <target state="translated">ReQL命令。ISO8601</target>
        </trans-unit>
        <trans-unit id="d77f4ff715692913a39d0f155d76e544abc4994a" translate="yes" xml:space="preserve">
          <source>ReQL command: add</source>
          <target state="translated">ReQL命令:添加</target>
        </trans-unit>
        <trans-unit id="bd75b6bf5a43cdc3fbcc301becfc8a5b38968d20" translate="yes" xml:space="preserve">
          <source>ReQL command: and</source>
          <target state="translated">ReQL命令:和</target>
        </trans-unit>
        <trans-unit id="f2605569a04a0afde3a9470a0eff3c6a2b21a661" translate="yes" xml:space="preserve">
          <source>ReQL command: append</source>
          <target state="translated">ReQL命令:追加</target>
        </trans-unit>
        <trans-unit id="c2634cf1d36dacdd152e506ed1c1009b68f6146a" translate="yes" xml:space="preserve">
          <source>ReQL command: args</source>
          <target state="translated">ReQL命令:args</target>
        </trans-unit>
        <trans-unit id="06786aca8c46cb6acbf99bb208c4f2ecc10b5911" translate="yes" xml:space="preserve">
          <source>ReQL command: avg</source>
          <target state="translated">ReQL命令:avg</target>
        </trans-unit>
        <trans-unit id="11520f025e9654a1117903ab39195c25867c3da1" translate="yes" xml:space="preserve">
          <source>ReQL command: between</source>
          <target state="translated">ReQL命令:在</target>
        </trans-unit>
        <trans-unit id="3655b193f6608706a983a08861b50d6b5e185a06" translate="yes" xml:space="preserve">
          <source>ReQL command: binary</source>
          <target state="translated">ReQL命令:二进制</target>
        </trans-unit>
        <trans-unit id="571dc7d8f2d64865f6200147ca4b9d8cd8606b53" translate="yes" xml:space="preserve">
          <source>ReQL command: bitAnd</source>
          <target state="translated">ReQL命令:bitAnd</target>
        </trans-unit>
        <trans-unit id="9eb7b32c24ff6334c93138e0cee13addf996c896" translate="yes" xml:space="preserve">
          <source>ReQL command: bitNot</source>
          <target state="translated">ReQL命令:bitNot</target>
        </trans-unit>
        <trans-unit id="2e98931c028999e90b8f13abdaf953947e1a45a9" translate="yes" xml:space="preserve">
          <source>ReQL command: bitOr</source>
          <target state="translated">ReQL命令:bitOr</target>
        </trans-unit>
        <trans-unit id="2a8dd27993a3456720a8e10e4af832cddb66be56" translate="yes" xml:space="preserve">
          <source>ReQL command: bitSal</source>
          <target state="translated">ReQL命令:bitSal</target>
        </trans-unit>
        <trans-unit id="3880c7496ccfb622259572fe35ea04fd28ae8c5b" translate="yes" xml:space="preserve">
          <source>ReQL command: bitSar</source>
          <target state="translated">ReQL命令:bitSar</target>
        </trans-unit>
        <trans-unit id="0d527a62dcc74ad7c16de243448a28ff9bb775dd" translate="yes" xml:space="preserve">
          <source>ReQL command: bitXor</source>
          <target state="translated">ReQL命令:bitXor</target>
        </trans-unit>
        <trans-unit id="cc7b8e77c49a6f5233051f7e6eb87cbaa04267df" translate="yes" xml:space="preserve">
          <source>ReQL command: branch</source>
          <target state="translated">ReQL命令:分支</target>
        </trans-unit>
        <trans-unit id="a542671e41bd856caf41efc6940bae16c1a4696d" translate="yes" xml:space="preserve">
          <source>ReQL command: ceil</source>
          <target state="translated">ReQL命令:ceil</target>
        </trans-unit>
        <trans-unit id="527929389823a7da454b535fc44ab98c9b397b0d" translate="yes" xml:space="preserve">
          <source>ReQL command: changeAt</source>
          <target state="translated">ReQL命令:changeAt</target>
        </trans-unit>
        <trans-unit id="25d7b0a2ca00d4a73406eff48faa4fefee9b927e" translate="yes" xml:space="preserve">
          <source>ReQL command: changes</source>
          <target state="translated">ReQL命令:改变</target>
        </trans-unit>
        <trans-unit id="b439af789b774f651c0736c700338a2616f990b1" translate="yes" xml:space="preserve">
          <source>ReQL command: circle</source>
          <target state="translated">ReQL命令:圆圈</target>
        </trans-unit>
        <trans-unit id="6b2fd8a84da14971568a45b72ab9313d35cade87" translate="yes" xml:space="preserve">
          <source>ReQL command: close</source>
          <target state="translated">ReQL命令:关闭</target>
        </trans-unit>
        <trans-unit id="417eab2fa9f97567083539e8c74527f21ccacd8c" translate="yes" xml:space="preserve">
          <source>ReQL command: coerceTo</source>
          <target state="translated">ReQL命令:coerceTo</target>
        </trans-unit>
        <trans-unit id="4184adbeb4e69b759b643238c0d1b15d72ffc48e" translate="yes" xml:space="preserve">
          <source>ReQL command: concatMap</source>
          <target state="translated">ReQL命令:concatMap</target>
        </trans-unit>
        <trans-unit id="2cba949c803d2634ab6f639cf3a79f395d198c8e" translate="yes" xml:space="preserve">
          <source>ReQL command: config</source>
          <target state="translated">ReQL命令:配置</target>
        </trans-unit>
        <trans-unit id="44e902bd9764f683711d0c83dd116fd1ae54a328" translate="yes" xml:space="preserve">
          <source>ReQL command: connect</source>
          <target state="translated">ReQL命令:连接</target>
        </trans-unit>
        <trans-unit id="79ec01842c910c009d437f0b1ec418b2cd2e55ff" translate="yes" xml:space="preserve">
          <source>ReQL command: contains</source>
          <target state="translated">ReQL命令:包含</target>
        </trans-unit>
        <trans-unit id="63144a966ab3eea31f6d0e990c630286409bb445" translate="yes" xml:space="preserve">
          <source>ReQL command: count</source>
          <target state="translated">ReQL命令:计数</target>
        </trans-unit>
        <trans-unit id="ed85af4ffe2d7e416e7f09211f7fde5e62c12bd2" translate="yes" xml:space="preserve">
          <source>ReQL command: date</source>
          <target state="translated">ReQL命令:日期</target>
        </trans-unit>
        <trans-unit id="fe45f01059e3f5e250f4fe61f283fa0b3e071514" translate="yes" xml:space="preserve">
          <source>ReQL command: day</source>
          <target state="translated">ReQL命令:day</target>
        </trans-unit>
        <trans-unit id="1bf352324c27548c918fa1efea8de5b8bd8c7ab1" translate="yes" xml:space="preserve">
          <source>ReQL command: dayOfWeek</source>
          <target state="translated">ReQL命令:dayOfWeek</target>
        </trans-unit>
        <trans-unit id="059e7de04bc86952404125b943c999aa79d78ed3" translate="yes" xml:space="preserve">
          <source>ReQL command: dayOfYear</source>
          <target state="translated">ReQL命令:dayOfYear</target>
        </trans-unit>
        <trans-unit id="8b5d959614c2e1eff9a4980760f966439d124e61" translate="yes" xml:space="preserve">
          <source>ReQL command: db</source>
          <target state="translated">ReQL命令:db</target>
        </trans-unit>
        <trans-unit id="d76075daac756324d6d0ec0a0928aa961d586a1d" translate="yes" xml:space="preserve">
          <source>ReQL command: dbCreate</source>
          <target state="translated">ReQL命令:dbCreate</target>
        </trans-unit>
        <trans-unit id="8e87a1bc1f3bf2ec8d32b7c2cc40f36556358729" translate="yes" xml:space="preserve">
          <source>ReQL command: dbDrop</source>
          <target state="translated">ReQL命令:dbDrop</target>
        </trans-unit>
        <trans-unit id="f2a8b36dca132fdcc0c2871c7a5fbe6092c9db74" translate="yes" xml:space="preserve">
          <source>ReQL command: dbList</source>
          <target state="translated">ReQL命令:dbList</target>
        </trans-unit>
        <trans-unit id="5f2d6e5cf850ea9208748619684b22798f566d95" translate="yes" xml:space="preserve">
          <source>ReQL command: default</source>
          <target state="translated">ReQL命令:默认</target>
        </trans-unit>
        <trans-unit id="152ab9d0af0267e9629d3302fda86cb29bd1679c" translate="yes" xml:space="preserve">
          <source>ReQL command: delete</source>
          <target state="translated">ReQL命令:删除</target>
        </trans-unit>
        <trans-unit id="5793c7294123817b3c67b2446d9ed0fc24099e64" translate="yes" xml:space="preserve">
          <source>ReQL command: deleteAt</source>
          <target state="translated">ReQL命令:deleteAt</target>
        </trans-unit>
        <trans-unit id="ea37eedb2d752c766abd0663d17fa8283bafc07a" translate="yes" xml:space="preserve">
          <source>ReQL command: difference</source>
          <target state="translated">ReQL命令:差异</target>
        </trans-unit>
        <trans-unit id="4a5e04f27c1cb25c8d2eae66f69a116238196fdf" translate="yes" xml:space="preserve">
          <source>ReQL command: distance</source>
          <target state="translated">ReQL命令:距离</target>
        </trans-unit>
        <trans-unit id="f3ba8164cc670369a39c3cd89a607b234d43f1c0" translate="yes" xml:space="preserve">
          <source>ReQL command: distinct</source>
          <target state="translated">ReQL命令:distinct</target>
        </trans-unit>
        <trans-unit id="5476b8fa7162e4450c92f418aa9aa3e48fd06aef" translate="yes" xml:space="preserve">
          <source>ReQL command: div</source>
          <target state="translated">ReQL命令:div</target>
        </trans-unit>
        <trans-unit id="561b5fa4e590d6f2ad1196573954cfb43c646dd8" translate="yes" xml:space="preserve">
          <source>ReQL command: do</source>
          <target state="translated">ReQL命令:做</target>
        </trans-unit>
        <trans-unit id="9aec0c0d4c81051146d47accc16dda35f7a5a0b3" translate="yes" xml:space="preserve">
          <source>ReQL command: downcase</source>
          <target state="translated">ReQL命令:降序</target>
        </trans-unit>
        <trans-unit id="f28b2c93a01839f916ec02c4cfcc9a13721eb722" translate="yes" xml:space="preserve">
          <source>ReQL command: during</source>
          <target state="translated">ReQL命令:在</target>
        </trans-unit>
        <trans-unit id="3d326b5fb9ed975ecff66601d036627598003399" translate="yes" xml:space="preserve">
          <source>ReQL command: each</source>
          <target state="translated">ReQL命令:每个</target>
        </trans-unit>
        <trans-unit id="aabe73e97a51d3c59d01989d6242a260e6d74509" translate="yes" xml:space="preserve">
          <source>ReQL command: eachAsync</source>
          <target state="translated">ReQL命令:eachAsync</target>
        </trans-unit>
        <trans-unit id="425ea449a1d70e01c64dbe6b5b29d2b23e87a858" translate="yes" xml:space="preserve">
          <source>ReQL command: epochTime</source>
          <target state="translated">ReQL命令:epochTime</target>
        </trans-unit>
        <trans-unit id="98c30486e513c1a061f79323971a52b0a723618f" translate="yes" xml:space="preserve">
          <source>ReQL command: eq</source>
          <target state="translated">ReQL命令:eq</target>
        </trans-unit>
        <trans-unit id="3e7a5fb0e8e29eec05542a30ba6b8c444ee3105a" translate="yes" xml:space="preserve">
          <source>ReQL command: eqJoin</source>
          <target state="translated">ReQL命令:eqJoin</target>
        </trans-unit>
        <trans-unit id="6b42cae3456f66df523de497a56b8436bdc4f933" translate="yes" xml:space="preserve">
          <source>ReQL command: error</source>
          <target state="translated">ReQL命令:错误</target>
        </trans-unit>
        <trans-unit id="804a86083314037dd13602582c6f8bbc82d8f39b" translate="yes" xml:space="preserve">
          <source>ReQL command: expr</source>
          <target state="translated">ReQL命令:expr</target>
        </trans-unit>
        <trans-unit id="611e77c0661fdb3292aea37d8df3679b35c7df12" translate="yes" xml:space="preserve">
          <source>ReQL command: fill</source>
          <target state="translated">ReQL命令:填充</target>
        </trans-unit>
        <trans-unit id="9dccb4ccbba48c519594c5157e513ba0d5701de8" translate="yes" xml:space="preserve">
          <source>ReQL command: filter</source>
          <target state="translated">ReQL命令:过滤</target>
        </trans-unit>
        <trans-unit id="9cffb149505c56762d298753a09eb0d2d8a6560b" translate="yes" xml:space="preserve">
          <source>ReQL command: floor</source>
          <target state="translated">ReQL命令:floor</target>
        </trans-unit>
        <trans-unit id="94cbd2adf0a235aac8c2088b4ca0140be21b53f8" translate="yes" xml:space="preserve">
          <source>ReQL command: fold</source>
          <target state="translated">ReQL命令:折叠</target>
        </trans-unit>
        <trans-unit id="897d9459594bc60b50cde84578f8afb019abc97e" translate="yes" xml:space="preserve">
          <source>ReQL command: forEach</source>
          <target state="translated">ReQL命令:forEach</target>
        </trans-unit>
        <trans-unit id="bab464954d3bc8833ad8340a54c35662a312b11d" translate="yes" xml:space="preserve">
          <source>ReQL command: ge</source>
          <target state="translated">ReQL命令:ge</target>
        </trans-unit>
        <trans-unit id="d741c68ddfa631d21e6871f1b46d42614e18a83a" translate="yes" xml:space="preserve">
          <source>ReQL command: geojson</source>
          <target state="translated">ReQL命令:geojson</target>
        </trans-unit>
        <trans-unit id="82ed05550360dd83aa891c363cbc524b4a2f8f7a" translate="yes" xml:space="preserve">
          <source>ReQL command: get</source>
          <target state="translated">ReQL命令:得到</target>
        </trans-unit>
        <trans-unit id="a1f385f0efe0b25f9afac8babc9ac59aefa669e0" translate="yes" xml:space="preserve">
          <source>ReQL command: getAll</source>
          <target state="translated">ReQL命令:getAll</target>
        </trans-unit>
        <trans-unit id="d0a8e46aaab6c31944afe326cfc398bb973a4686" translate="yes" xml:space="preserve">
          <source>ReQL command: getField</source>
          <target state="translated">ReQL命令:getField</target>
        </trans-unit>
        <trans-unit id="db529b687aac749a71e749e57613644679a50870" translate="yes" xml:space="preserve">
          <source>ReQL command: getIntersecting</source>
          <target state="translated">ReQL命令:getIntersecting</target>
        </trans-unit>
        <trans-unit id="2496d8ab318dd96eb24cd47e28fe55900147c8db" translate="yes" xml:space="preserve">
          <source>ReQL command: getNearest</source>
          <target state="translated">ReQL命令:getNearest</target>
        </trans-unit>
        <trans-unit id="fe1ca76d944081b6b32cc89a9d095e2680c9b43d" translate="yes" xml:space="preserve">
          <source>ReQL command: getWriteHook</source>
          <target state="translated">ReQL命令:getWriteHook</target>
        </trans-unit>
        <trans-unit id="aabf73eab95fa6104bd97b42749ee58b48fd0292" translate="yes" xml:space="preserve">
          <source>ReQL command: grant</source>
          <target state="translated">ReQL命令:授予</target>
        </trans-unit>
        <trans-unit id="7b03dc68f7aad27c5aaa10cd5ee0aad622ce5f31" translate="yes" xml:space="preserve">
          <source>ReQL command: group</source>
          <target state="translated">ReQL命令:组</target>
        </trans-unit>
        <trans-unit id="e86480de71bd273e6658917ba3f61bc7e6824443" translate="yes" xml:space="preserve">
          <source>ReQL command: gt</source>
          <target state="translated">ReQL命令:gt</target>
        </trans-unit>
        <trans-unit id="c24bee4561071d0d871cdd0200719bc29b97ebc8" translate="yes" xml:space="preserve">
          <source>ReQL command: hasFields</source>
          <target state="translated">ReQL命令:hasFields</target>
        </trans-unit>
        <trans-unit id="7bd359800f881c05722a02a6b5695da760181882" translate="yes" xml:space="preserve">
          <source>ReQL command: hours</source>
          <target state="translated">ReQL命令:小时</target>
        </trans-unit>
        <trans-unit id="bcc9bf4de764097e98526fcd54cc961135eb7962" translate="yes" xml:space="preserve">
          <source>ReQL command: http</source>
          <target state="translated">ReQL命令:http</target>
        </trans-unit>
        <trans-unit id="7431d9aa2cada8de64c18a070081d24a5b9fbb09" translate="yes" xml:space="preserve">
          <source>ReQL command: inTimezone</source>
          <target state="translated">ReQL命令:inTimezone</target>
        </trans-unit>
        <trans-unit id="cd1c77e55dc7e874dfb9a9c9be6aaccb645f6b7d" translate="yes" xml:space="preserve">
          <source>ReQL command: includes</source>
          <target state="translated">ReQL命令:包括</target>
        </trans-unit>
        <trans-unit id="d6711e810c115ceff2ece5c128308dbb42b5a2cf" translate="yes" xml:space="preserve">
          <source>ReQL command: indexCreate</source>
          <target state="translated">ReQL命令:indexCreate</target>
        </trans-unit>
        <trans-unit id="bfd351f65f12fb8a7fe92627deee9214f561ab3e" translate="yes" xml:space="preserve">
          <source>ReQL command: indexDrop</source>
          <target state="translated">ReQL命令:indexDrop</target>
        </trans-unit>
        <trans-unit id="3652ad2442800cc05c6e2985c0264e2e0382ca27" translate="yes" xml:space="preserve">
          <source>ReQL command: indexList</source>
          <target state="translated">ReQL命令:indexList</target>
        </trans-unit>
        <trans-unit id="f1e54de063dd1435fd13b88690dd9922aa7eeb29" translate="yes" xml:space="preserve">
          <source>ReQL command: indexRename</source>
          <target state="translated">ReQL命令:indexRename</target>
        </trans-unit>
        <trans-unit id="8b48bce424975b58f5a6277f94555aa3e884e76e" translate="yes" xml:space="preserve">
          <source>ReQL command: indexStatus</source>
          <target state="translated">ReQL命令:indexStatus</target>
        </trans-unit>
        <trans-unit id="f625bf613db8f884e43c623097656ac6805cb4d5" translate="yes" xml:space="preserve">
          <source>ReQL command: indexWait</source>
          <target state="translated">ReQL命令:indexWait</target>
        </trans-unit>
        <trans-unit id="daf81e983eb792f0c3e3c85e87f063644fd228a7" translate="yes" xml:space="preserve">
          <source>ReQL command: info</source>
          <target state="translated">ReQL命令:info</target>
        </trans-unit>
        <trans-unit id="f2865b2fe07ec14465b473e3e2191c86471ebc88" translate="yes" xml:space="preserve">
          <source>ReQL command: innerJoin</source>
          <target state="translated">ReQL命令:innerJoin</target>
        </trans-unit>
        <trans-unit id="42c5914444ddf911b418ac8a07bbdfe87434a490" translate="yes" xml:space="preserve">
          <source>ReQL command: insert</source>
          <target state="translated">ReQL命令:插入</target>
        </trans-unit>
        <trans-unit id="5e67c8f25f616daa8641527206d66dbca593343b" translate="yes" xml:space="preserve">
          <source>ReQL command: insertAt</source>
          <target state="translated">ReQL命令:insertAt</target>
        </trans-unit>
        <trans-unit id="e7827d7ac574cac26fe38a431bf6d13d20d79386" translate="yes" xml:space="preserve">
          <source>ReQL command: intersects</source>
          <target state="translated">ReQL命令:intersects</target>
        </trans-unit>
        <trans-unit id="2fc4b91b71a6f3ca54688e50d5dfb5007f51a3a6" translate="yes" xml:space="preserve">
          <source>ReQL command: isEmpty</source>
          <target state="translated">ReQL命令:isEmpty</target>
        </trans-unit>
        <trans-unit id="cc63c3831bbe8fcf8cc6bb4a0bf3937a70c83637" translate="yes" xml:space="preserve">
          <source>ReQL command: js</source>
          <target state="translated">ReQL命令:js</target>
        </trans-unit>
        <trans-unit id="704734e522301a470558a5131f2c6e3b6ef85eb1" translate="yes" xml:space="preserve">
          <source>ReQL command: json</source>
          <target state="translated">ReQL命令:json</target>
        </trans-unit>
        <trans-unit id="ee963dc4f4a09e977f54e79c552d271a5efe1ab5" translate="yes" xml:space="preserve">
          <source>ReQL command: keys</source>
          <target state="translated">ReQL命令:键</target>
        </trans-unit>
        <trans-unit id="464e94774d901f92cc30536abe6dc20f1abb20d5" translate="yes" xml:space="preserve">
          <source>ReQL command: le</source>
          <target state="translated">ReQL命令:le</target>
        </trans-unit>
        <trans-unit id="04153a56a203e790ab924f8607428b4b8d9eb847" translate="yes" xml:space="preserve">
          <source>ReQL command: limit</source>
          <target state="translated">ReQL命令:限制</target>
        </trans-unit>
        <trans-unit id="9f2597983292d8bf2c21e31bbb1694b0f4e60b71" translate="yes" xml:space="preserve">
          <source>ReQL command: line</source>
          <target state="translated">ReQL命令:行</target>
        </trans-unit>
        <trans-unit id="04e551b6caa8c5819ee49593aa863ab30753852a" translate="yes" xml:space="preserve">
          <source>ReQL command: literal</source>
          <target state="translated">ReQL命令:字面意思</target>
        </trans-unit>
        <trans-unit id="dd52f5f092b7e6f28627bef15e94ecf8131e3ef6" translate="yes" xml:space="preserve">
          <source>ReQL command: lt</source>
          <target state="translated">ReQL命令:lt</target>
        </trans-unit>
        <trans-unit id="8cd6432c7520ab24d1a185bc4ab261febc0ac9f9" translate="yes" xml:space="preserve">
          <source>ReQL command: map</source>
          <target state="translated">ReQL命令:map</target>
        </trans-unit>
        <trans-unit id="f29d7e822149fb3bdb52bb327684c64fed039865" translate="yes" xml:space="preserve">
          <source>ReQL command: match</source>
          <target state="translated">ReQL命令:匹配</target>
        </trans-unit>
        <trans-unit id="c75671801e688e758173dd6841f05e272b833433" translate="yes" xml:space="preserve">
          <source>ReQL command: max</source>
          <target state="translated">ReQL命令:最大</target>
        </trans-unit>
        <trans-unit id="99b4fb1fe845d533e11f41a152cc7193a70f0a3c" translate="yes" xml:space="preserve">
          <source>ReQL command: merge</source>
          <target state="translated">ReQL命令:合并</target>
        </trans-unit>
        <trans-unit id="f32d131081cad08c01e30eada59cfa338cb1b409" translate="yes" xml:space="preserve">
          <source>ReQL command: min</source>
          <target state="translated">ReQL命令:min</target>
        </trans-unit>
        <trans-unit id="8c3b86a9d0f6ac29f03bfbb3265cd75620f9d3e0" translate="yes" xml:space="preserve">
          <source>ReQL command: minutes</source>
          <target state="translated">ReQL命令:分钟</target>
        </trans-unit>
        <trans-unit id="5cb8dacfbfe621b76bb3f63fdb19e0e6e6dd08d6" translate="yes" xml:space="preserve">
          <source>ReQL command: mod</source>
          <target state="translated">ReQL命令:mod</target>
        </trans-unit>
        <trans-unit id="759964af86c65918dbeb70bab369aed0f281b7ac" translate="yes" xml:space="preserve">
          <source>ReQL command: month</source>
          <target state="translated">ReQL命令:月</target>
        </trans-unit>
        <trans-unit id="f88a626fbd64a50878cbe7d76d55f2a5c63f80ce" translate="yes" xml:space="preserve">
          <source>ReQL command: mul</source>
          <target state="translated">ReQL命令:mul</target>
        </trans-unit>
        <trans-unit id="de874b4d0dc4ed2dbc0d6880b5cb21a27c76bc32" translate="yes" xml:space="preserve">
          <source>ReQL command: ne</source>
          <target state="translated">ReQL命令:ne</target>
        </trans-unit>
        <trans-unit id="6c6619dceafd328a67bddca06d99d66fe8e0c745" translate="yes" xml:space="preserve">
          <source>ReQL command: next</source>
          <target state="translated">ReQL命令:下一个</target>
        </trans-unit>
        <trans-unit id="2fe619f0be2dfaac8395f90e027e18f66dfb5cde" translate="yes" xml:space="preserve">
          <source>ReQL command: noreplyWait</source>
          <target state="translated">ReQL命令:noreplyWait</target>
        </trans-unit>
        <trans-unit id="b786c5ec3389b7fffd91940e9df8dcfc1bed6413" translate="yes" xml:space="preserve">
          <source>ReQL command: not</source>
          <target state="translated">ReQL命令:不</target>
        </trans-unit>
        <trans-unit id="51bf93483726e0ed581b769efc939be0c439b3f0" translate="yes" xml:space="preserve">
          <source>ReQL command: now</source>
          <target state="translated">ReQL命令:现在</target>
        </trans-unit>
        <trans-unit id="142c81f0e7aad4d403a5e9717af093c3fa309da0" translate="yes" xml:space="preserve">
          <source>ReQL command: nth</source>
          <target state="translated">ReQL命令:第n次</target>
        </trans-unit>
        <trans-unit id="7a52ef447aef8fb68ab5bf4ab1b1be3cb0a8e6fa" translate="yes" xml:space="preserve">
          <source>ReQL command: object</source>
          <target state="translated">ReQL命令:对象</target>
        </trans-unit>
        <trans-unit id="0285d42b6439c5758658f23558fb2a316aa232a9" translate="yes" xml:space="preserve">
          <source>ReQL command: offsetsOf</source>
          <target state="translated">ReQL命令:offsetsOf</target>
        </trans-unit>
        <trans-unit id="37141a239a711e7b56007bb0ff0bef4bc3a55f32" translate="yes" xml:space="preserve">
          <source>ReQL command: or</source>
          <target state="translated">ReQL命令:或</target>
        </trans-unit>
        <trans-unit id="469eeab7689f5192386b409764992410551e27f1" translate="yes" xml:space="preserve">
          <source>ReQL command: orderBy</source>
          <target state="translated">ReQL命令:orderBy</target>
        </trans-unit>
        <trans-unit id="c49f00d76ad001bdc3166004292a3c0a27e75d43" translate="yes" xml:space="preserve">
          <source>ReQL command: outerJoin</source>
          <target state="translated">ReQL命令:outerJoin</target>
        </trans-unit>
        <trans-unit id="cd3e4940e21cee61fccac24d189f22bbfab1ba9f" translate="yes" xml:space="preserve">
          <source>ReQL command: pluck</source>
          <target state="translated">ReQL命令:pluck</target>
        </trans-unit>
        <trans-unit id="0914f786606ccc5c9796e887a77cd485af776083" translate="yes" xml:space="preserve">
          <source>ReQL command: point</source>
          <target state="translated">ReQL命令:点</target>
        </trans-unit>
        <trans-unit id="dce548026c69300e92a29bc23af287b80ded5dd0" translate="yes" xml:space="preserve">
          <source>ReQL command: polygon</source>
          <target state="translated">ReQL命令:多边形</target>
        </trans-unit>
        <trans-unit id="ec7f5406bd2ba258cc0960fe19f501b84159cbf3" translate="yes" xml:space="preserve">
          <source>ReQL command: polygonSub</source>
          <target state="translated">ReQL命令:PolygonSub</target>
        </trans-unit>
        <trans-unit id="25d262b79633d6a23b112ff0642a2bbd27b058de" translate="yes" xml:space="preserve">
          <source>ReQL command: prepend</source>
          <target state="translated">ReQL命令:prepend</target>
        </trans-unit>
        <trans-unit id="32df6b377a42b81280feba4abd45d6fb776b7c5b" translate="yes" xml:space="preserve">
          <source>ReQL command: r</source>
          <target state="translated">ReQL命令:r</target>
        </trans-unit>
        <trans-unit id="163b8f2d543ca883e5f457526db714e8507bc273" translate="yes" xml:space="preserve">
          <source>ReQL command: random</source>
          <target state="translated">ReQL命令:随机</target>
        </trans-unit>
        <trans-unit id="abd0f1d41d793cf5d1fd1be44dad48ed9f52dcb0" translate="yes" xml:space="preserve">
          <source>ReQL command: range</source>
          <target state="translated">ReQL命令:范围</target>
        </trans-unit>
        <trans-unit id="abcfac2a068eb352bf7b1585227c21dd99a9dad2" translate="yes" xml:space="preserve">
          <source>ReQL command: rebalance</source>
          <target state="translated">ReQL命令:重新平衡</target>
        </trans-unit>
        <trans-unit id="ed78391e00455b6f7508ebf957eb0c3519b8cda6" translate="yes" xml:space="preserve">
          <source>ReQL command: reconfigure</source>
          <target state="translated">ReQL命令:重新配置</target>
        </trans-unit>
        <trans-unit id="bb603637d01d111818e3e54d87f6fbe2f0948e04" translate="yes" xml:space="preserve">
          <source>ReQL command: reconnect</source>
          <target state="translated">ReQL命令:重新连接</target>
        </trans-unit>
        <trans-unit id="ca15dd0e4b3cb78958bbc04ff2ebdfc6237c1480" translate="yes" xml:space="preserve">
          <source>ReQL command: reduce</source>
          <target state="translated">ReQL命令:减少</target>
        </trans-unit>
        <trans-unit id="1b669d035898f8b7832c9d6b122df85452bb3621" translate="yes" xml:space="preserve">
          <source>ReQL command: replace</source>
          <target state="translated">ReQL命令:替换</target>
        </trans-unit>
        <trans-unit id="462aad92203d25425961d17c822cf9c057229d02" translate="yes" xml:space="preserve">
          <source>ReQL command: round</source>
          <target state="translated">ReQL命令:round</target>
        </trans-unit>
        <trans-unit id="021b12c6ad75724f11b7b4db3ef364873869fc62" translate="yes" xml:space="preserve">
          <source>ReQL command: row</source>
          <target state="translated">ReQL命令:行</target>
        </trans-unit>
        <trans-unit id="30f7a7cfdc10d2f8f0979e09db335392564ee022" translate="yes" xml:space="preserve">
          <source>ReQL command: run</source>
          <target state="translated">ReQL命令:运行</target>
        </trans-unit>
        <trans-unit id="35baf0bd20ef826e0e6f2d92d0b5ececfd90953e" translate="yes" xml:space="preserve">
          <source>ReQL command: sample</source>
          <target state="translated">ReQL命令:样本</target>
        </trans-unit>
        <trans-unit id="0be3d60445795016ac04b5c046a0a131b0ae6079" translate="yes" xml:space="preserve">
          <source>ReQL command: seconds</source>
          <target state="translated">ReQL命令:秒</target>
        </trans-unit>
        <trans-unit id="f1bb2be8ae02baa7d054dd238fb17ff6adc0e5fc" translate="yes" xml:space="preserve">
          <source>ReQL command: server</source>
          <target state="translated">ReQL命令:服务器</target>
        </trans-unit>
        <trans-unit id="bd21c33c7d7e4a661ae24315ff5adaf657b0d101" translate="yes" xml:space="preserve">
          <source>ReQL command: setDifference</source>
          <target state="translated">ReQL命令:setDifference</target>
        </trans-unit>
        <trans-unit id="ee8b9454ec4e6e9f1927b8de9dc70609dcdeafae" translate="yes" xml:space="preserve">
          <source>ReQL command: setInsert</source>
          <target state="translated">ReQL命令:setInsert</target>
        </trans-unit>
        <trans-unit id="c9a0eb231439f96cafbfefb58f50b26a3a819a2d" translate="yes" xml:space="preserve">
          <source>ReQL command: setIntersection</source>
          <target state="translated">ReQL命令:settingersection</target>
        </trans-unit>
        <trans-unit id="04f4bae437d2c848c78c8d28f84714b52d7f6c3f" translate="yes" xml:space="preserve">
          <source>ReQL command: setUnion</source>
          <target state="translated">ReQL命令:setUnion</target>
        </trans-unit>
        <trans-unit id="98a6520cbec0f57832621c081c07b22454e679e2" translate="yes" xml:space="preserve">
          <source>ReQL command: setWriteHook</source>
          <target state="translated">ReQL命令:setWriteHook</target>
        </trans-unit>
        <trans-unit id="19311ff5522c6db5f5f3d20e812d39f1a5fc5892" translate="yes" xml:space="preserve">
          <source>ReQL command: skip</source>
          <target state="translated">ReQL命令:跳过</target>
        </trans-unit>
        <trans-unit id="76501a2b3ef6222fd67dd4c4fd5d7848613ac2b2" translate="yes" xml:space="preserve">
          <source>ReQL command: slice</source>
          <target state="translated">ReQL命令:切片</target>
        </trans-unit>
        <trans-unit id="5dfe709e1e34e3632317f2600c09e5128cb9ae93" translate="yes" xml:space="preserve">
          <source>ReQL command: spliceAt</source>
          <target state="translated">ReQL命令:spliceAt</target>
        </trans-unit>
        <trans-unit id="c8464e0de44dd2800e23b2097a3059deee41b021" translate="yes" xml:space="preserve">
          <source>ReQL command: split</source>
          <target state="translated">ReQL命令:分割</target>
        </trans-unit>
        <trans-unit id="570b17954ae1d507f16d974d184fbad67acf5855" translate="yes" xml:space="preserve">
          <source>ReQL command: status</source>
          <target state="translated">ReQL命令:状态</target>
        </trans-unit>
        <trans-unit id="13e59b90332b50ab084f0e4a384ba3686605cd3f" translate="yes" xml:space="preserve">
          <source>ReQL command: sub</source>
          <target state="translated">ReQL命令:sub</target>
        </trans-unit>
        <trans-unit id="10e1b3442af15fbd32119e6a98b64febea339584" translate="yes" xml:space="preserve">
          <source>ReQL command: sum</source>
          <target state="translated">ReQL命令:和</target>
        </trans-unit>
        <trans-unit id="da0339a917c31dc275e5131893031fc7f6acce4c" translate="yes" xml:space="preserve">
          <source>ReQL command: sync</source>
          <target state="translated">ReQL命令:同步</target>
        </trans-unit>
        <trans-unit id="8d21f3686cbc79062796b79f01a307a2daa74707" translate="yes" xml:space="preserve">
          <source>ReQL command: table</source>
          <target state="translated">ReQL命令:表</target>
        </trans-unit>
        <trans-unit id="5a75ff2420141b13ad812407726590d8e11bf491" translate="yes" xml:space="preserve">
          <source>ReQL command: tableCreate</source>
          <target state="translated">ReQL命令:tableCreate</target>
        </trans-unit>
        <trans-unit id="6edc96e8bb975009898532d7c3ac0d5c9c3e1171" translate="yes" xml:space="preserve">
          <source>ReQL command: tableDrop</source>
          <target state="translated">ReQL命令:tableDrop</target>
        </trans-unit>
        <trans-unit id="321385e05615dc1e097447354a11170214318796" translate="yes" xml:space="preserve">
          <source>ReQL command: tableList</source>
          <target state="translated">ReQL命令:tableList</target>
        </trans-unit>
        <trans-unit id="0659bee81d319deb7e130473db0dc2263f4622f3" translate="yes" xml:space="preserve">
          <source>ReQL command: time</source>
          <target state="translated">ReQL命令:时间</target>
        </trans-unit>
        <trans-unit id="37216ac18e28d2fe512c09beeb963db758364a4b" translate="yes" xml:space="preserve">
          <source>ReQL command: timeOfDay</source>
          <target state="translated">ReQL命令:timeOfDay</target>
        </trans-unit>
        <trans-unit id="1de03f1799a9257b1e0cb0c6a0e68b6a2125ca72" translate="yes" xml:space="preserve">
          <source>ReQL command: timezone</source>
          <target state="translated">ReQL命令:时区</target>
        </trans-unit>
        <trans-unit id="2af08e633e375c04686b6dd4e002092239a1eed9" translate="yes" xml:space="preserve">
          <source>ReQL command: toArray</source>
          <target state="translated">ReQL命令:toArray</target>
        </trans-unit>
        <trans-unit id="513f46f55a4b510e789657e077cfdb94101a2398" translate="yes" xml:space="preserve">
          <source>ReQL command: toEpochTime</source>
          <target state="translated">ReQL命令:toEpochTime</target>
        </trans-unit>
        <trans-unit id="627570fef15c7acc0c2663e684f59cb33b2b1459" translate="yes" xml:space="preserve">
          <source>ReQL command: toGeojson</source>
          <target state="translated">ReQL命令:toGeojson</target>
        </trans-unit>
        <trans-unit id="56852d9c1a1873fd61c17972ef99801ac2c87ecf" translate="yes" xml:space="preserve">
          <source>ReQL command: toISO8601</source>
          <target state="translated">ReQL命令:toISO8601</target>
        </trans-unit>
        <trans-unit id="f6f174b5765bf64194d9ca622d10e16cd8a46617" translate="yes" xml:space="preserve">
          <source>ReQL command: toJsonString, toJSON</source>
          <target state="translated">ReQL命令:toJsonString,toJSON。</target>
        </trans-unit>
        <trans-unit id="19cdf1a2a2fefcc0935b25802524c2a58527dbbb" translate="yes" xml:space="preserve">
          <source>ReQL command: typeOf</source>
          <target state="translated">ReQL命令:typeOf</target>
        </trans-unit>
        <trans-unit id="8022749a3da3c400ea76655d26b31790850a20bf" translate="yes" xml:space="preserve">
          <source>ReQL command: ungroup</source>
          <target state="translated">ReQL命令:解组</target>
        </trans-unit>
        <trans-unit id="fe481736ff3cb3a807c23188aaf45a55b2d99dc4" translate="yes" xml:space="preserve">
          <source>ReQL command: union</source>
          <target state="translated">ReQL命令:union</target>
        </trans-unit>
        <trans-unit id="6dbff263f97562be4ce701c91fec033e04feaf07" translate="yes" xml:space="preserve">
          <source>ReQL command: upcase</source>
          <target state="translated">ReQL命令:upcase</target>
        </trans-unit>
        <trans-unit id="455ab20ffc94cace160b696dfbeaa15326dd0cf2" translate="yes" xml:space="preserve">
          <source>ReQL command: update</source>
          <target state="translated">ReQL命令:更新</target>
        </trans-unit>
        <trans-unit id="e0651ec1f9bbf8339e03befeb514c75a1ab27c73" translate="yes" xml:space="preserve">
          <source>ReQL command: use</source>
          <target state="translated">ReQL命令:使用</target>
        </trans-unit>
        <trans-unit id="4e9d4a579dc4455f2e6db7cb499db7af40804ded" translate="yes" xml:space="preserve">
          <source>ReQL command: uuid</source>
          <target state="translated">ReQL命令:uuid</target>
        </trans-unit>
        <trans-unit id="325ff960145ced96b81cf4fd70fa7b1153d74132" translate="yes" xml:space="preserve">
          <source>ReQL command: values</source>
          <target state="translated">ReQL命令:值</target>
        </trans-unit>
        <trans-unit id="997a6bf76bb87f3bcdf7d12f2d88b575cc41fefa" translate="yes" xml:space="preserve">
          <source>ReQL command: wait</source>
          <target state="translated">ReQL命令:等待</target>
        </trans-unit>
        <trans-unit id="85a62250b115e6cd99762def1db4a11a411a71e6" translate="yes" xml:space="preserve">
          <source>ReQL command: withFields</source>
          <target state="translated">ReQL命令:withFields</target>
        </trans-unit>
        <trans-unit id="369250ffd90be27fd1fa8cfe5c8ea1f06e5ca8ed" translate="yes" xml:space="preserve">
          <source>ReQL command: without</source>
          <target state="translated">ReQL命令:不含</target>
        </trans-unit>
        <trans-unit id="274b2016fa95fda2a3b60df052ec709fc131c8b3" translate="yes" xml:space="preserve">
          <source>ReQL command: year</source>
          <target state="translated">ReQL命令:年</target>
        </trans-unit>
        <trans-unit id="395a7dc9265d0f496258ee4292950abf3e16e123" translate="yes" xml:space="preserve">
          <source>ReQL command: zip</source>
          <target state="translated">ReQL命令:zip</target>
        </trans-unit>
        <trans-unit id="0745f2086f93ccd2a331d7072137817d3cb55afa" translate="yes" xml:space="preserve">
          <source>ReQL commands</source>
          <target state="translated">ReQL命令</target>
        </trans-unit>
        <trans-unit id="59807be887cb81af9dbfaac16f14ad42e6245fa9" translate="yes" xml:space="preserve">
          <source>ReQL commands are represented as a list of two or three elements.</source>
          <target state="translated">ReQL命令是由两个或三个元素组成的列表来表示的。</target>
        </trans-unit>
        <trans-unit id="94f7952690489bb7dd3edb6940dbc296908f9252" translate="yes" xml:space="preserve">
          <source>ReQL data</source>
          <target state="translated">ReQL数据</target>
        </trans-unit>
        <trans-unit id="09010231d56a5d2fda3a74b70c661c1e81cadefe" translate="yes" xml:space="preserve">
          <source>ReQL data types</source>
          <target state="translated">ReQL数据类型</target>
        </trans-unit>
        <trans-unit id="191a7a574620481e86f08d38eca70528f9f36e03" translate="yes" xml:space="preserve">
          <source>ReQL embeds into your programming language</source>
          <target state="translated">ReQL嵌入到您的编程语言中</target>
        </trans-unit>
        <trans-unit id="125f3b5c55d48af1835dac4b751c29ca63213adc" translate="yes" xml:space="preserve">
          <source>ReQL error types</source>
          <target state="translated">ReQL错误类型</target>
        </trans-unit>
        <trans-unit id="cece285d53709eacd625cbfa5e27ed559a1d29d6" translate="yes" xml:space="preserve">
          <source>ReQL geometry objects are not &lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt; objects, but you can convert back and forth between them with the &lt;a href=&quot;../../../api/javascript/geojson/index&quot;&gt;geojson&lt;/a&gt; and &lt;a href=&quot;../../../api/javascript/to_geojson/index&quot;&gt;toGeojson&lt;/a&gt; commands.</source>
          <target state="translated">ReQL几何对象不是&lt;a href=&quot;http://geojson.org&quot;&gt;GeoJSON&lt;/a&gt;对象，但是您可以使用&lt;a href=&quot;../../../api/javascript/geojson/index&quot;&gt;geojson&lt;/a&gt;和&lt;a href=&quot;../../../api/javascript/to_geojson/index&quot;&gt;toGeojson&lt;/a&gt;命令在它们之间来回转换。</target>
        </trans-unit>
        <trans-unit id="35a42830df2a6efe0b040fe441dccc75dde4e460" translate="yes" xml:space="preserve">
          <source>ReQL has commands for extracting parts of &lt;a href=&quot;../../dates-and-times/javascript/index&quot;&gt;dates and times&lt;/a&gt;, including &lt;a href=&quot;../../../api/javascript/year/index&quot;&gt;year&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/month/index&quot;&gt;month&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/day/index&quot;&gt;day&lt;/a&gt;, &lt;a href=&quot;../../../api/javascript/day_of_week/index&quot;&gt;dayOfWeek&lt;/a&gt; and more. You can use these with &lt;a href=&quot;../../../api/javascript/group/index&quot;&gt;group&lt;/a&gt; to group by various intervals. Suppose you had a table of invoices and wanted to retrieve them in groups ordered by year and month:</source>
          <target state="translated">ReQL具有用于提取&lt;a href=&quot;../../dates-and-times/javascript/index&quot;&gt;日期和时间&lt;/a&gt;部分的命令，包括&lt;a href=&quot;../../../api/javascript/year/index&quot;&gt;年&lt;/a&gt;，&lt;a href=&quot;../../../api/javascript/month/index&quot;&gt;月&lt;/a&gt;，&lt;a href=&quot;../../../api/javascript/day/index&quot;&gt;日&lt;/a&gt;，&lt;a href=&quot;../../../api/javascript/day_of_week/index&quot;&gt;dayOfWeek&lt;/a&gt;等。您可以将它们与&lt;a href=&quot;../../../api/javascript/group/index&quot;&gt;分组&lt;/a&gt;一起按各种间隔分组。假设您有一张发票表，并想按年和月排序的组中检索它们：</target>
        </trans-unit>
        <trans-unit id="da86166d7e392999c718f777993e73c609f2fbc7" translate="yes" xml:space="preserve">
          <source>ReQL is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;domain specific language&lt;/a&gt; expressed in the host language. The three official drivers follow a very similar syntax; you should stick to that model as closely as your chosen language allows. Typically you are free to use either a prefix or infix notation, or mix the two.</source>
          <target state="translated">ReQL是用宿主语言表示的&lt;a href=&quot;http://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;领域特定&lt;/a&gt;语言。这三个官方驱动程序遵循非常相似的语法。您应该在选择的语言允许的范围内尽可能地坚持该模型。通常，您可以自由使用前缀或中缀表示法，也可以将两者混合使用。</target>
        </trans-unit>
        <trans-unit id="d43a43b0bbaf9ebff40c9b56aa0745166d84b3da" translate="yes" xml:space="preserve">
          <source>ReQL is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;domain specific language&lt;/a&gt; expressed in the host language. The three official drivers follow a very similar syntax; you should stick to that model as closely as your chosen language allows. Typically you are free to use either a prefix or infix notation, or mix the two.</source>
          <target state="translated">ReQL是用宿主语言表达的&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;领域特定&lt;/a&gt;语言。这三个官方驱动程序遵循非常相似的语法。您应该在选择的语言允许的范围内尽可能地坚持该模型。通常，您可以自由使用前缀或中缀表示法，也可以将两者混合使用。</target>
        </trans-unit>
        <trans-unit id="03b7a017a84f9b3da4de0039647a3013516208eb" translate="yes" xml:space="preserve">
          <source>ReQL is different from other NoSQL query languages. It&amp;rsquo;s built on three key principles:</source>
          <target state="translated">ReQL与其他NoSQL查询语言不同。它基于三个关键原则：</target>
        </trans-unit>
        <trans-unit id="dab0c7b28a7500cbaccffec7e5e887241992d2da" translate="yes" xml:space="preserve">
          <source>ReQL is efficient</source>
          <target state="translated">ReQL是高效的</target>
        </trans-unit>
        <trans-unit id="6c8ae750e37a742a762efbb4d4a707a2f88e21d9" translate="yes" xml:space="preserve">
          <source>ReQL is the RethinkDB query language. It offers a very powerful and convenient way to manipulate JSON documents. This document is a gentle introduction to ReQL concepts. You don&amp;rsquo;t have to read it to be productive with RethinkDB, but it helps to understand some basics.</source>
          <target state="translated">ReQL是RethinkDB查询语言。它提供了一种非常强大且便捷的方式来处理JSON文档。本文档是ReQL概念的简要介绍。您无需阅读即可有效使用RethinkDB，但是它有助于理解一些基础知识。</target>
        </trans-unit>
        <trans-unit id="62b7b785aa09ec970184f5e88cf1e8539b883367" translate="yes" xml:space="preserve">
          <source>ReQL pseudo types</source>
          <target state="translated">ReQL伪类型</target>
        </trans-unit>
        <trans-unit id="8b783f5ac5ce21c42bde10cc36b31b26d3e95f39" translate="yes" xml:space="preserve">
          <source>ReQL queries are composable</source>
          <target state="translated">ReQL查询是可以合成的</target>
        </trans-unit>
        <trans-unit id="0d649019dd97255601cf647335065eb587632177" translate="yes" xml:space="preserve">
          <source>ReQL queries are executed lazily:</source>
          <target state="translated">ReQL查询的执行速度很慢。</target>
        </trans-unit>
        <trans-unit id="46cc7a8d6eff2c8a22f5442d9d90d27387cddcaa" translate="yes" xml:space="preserve">
          <source>ReQL queries are functional</source>
          <target state="translated">ReQL查询的功能</target>
        </trans-unit>
        <trans-unit id="baf0a6b4a49af458581fecb524a2b910b9bc313c" translate="yes" xml:space="preserve">
          <source>ReQL types and commands are defined in the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/src/rdb_protocol/ql2.proto&quot;&gt;ql2.proto&lt;/a&gt; file.</source>
          <target state="translated">ReQL类型和命令在&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/blob/next/src/rdb_protocol/ql2.proto&quot;&gt;ql2.proto&lt;/a&gt;文件中定义。</target>
        </trans-unit>
        <trans-unit id="2093e96b1a65a9a688a5cc8dffba6429e5a47515" translate="yes" xml:space="preserve">
          <source>ReQL&amp;rsquo;s nesting depth is limited to 20 levels. This can be changed with the undocumented &lt;code&gt;nestingDepth&lt;/code&gt; (or &lt;code&gt;nesting_depth&lt;/code&gt;) option to &lt;code&gt;r.expr()&lt;/code&gt;, but before using that, consider whether the document can be reorganized to avoid the error.</source>
          <target state="translated">ReQL的嵌套深度限制为20个级别。可以使用 &lt;code&gt;nestingDepth&lt;/code&gt; （）的未记录的nestingDepth（或 &lt;code&gt;nesting_depth&lt;/code&gt; ）选项来 &lt;code&gt;r.expr()&lt;/code&gt; ，但是在使用该选项之前，请考虑是否可以重新组织文档以避免错误。</target>
        </trans-unit>
        <trans-unit id="6f2b9560013f6f1bce5d0df1f754255ff37ad07d" translate="yes" xml:space="preserve">
          <source>React.js</source>
          <target state="translated">React.js</target>
        </trans-unit>
        <trans-unit id="48fa53a29856312c157be48d24a169a0a913953d" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;../../../docs/sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt; for a complete discussion of the subject, including advanced topics.</source>
          <target state="translated">阅读分片&lt;a href=&quot;../../../docs/sharding-and-replication/index&quot;&gt;和复制&lt;/a&gt;以完整地讨论该主题，包括高级主题。</target>
        </trans-unit>
        <trans-unit id="b4eef36f30bb0fd18c9978dad0fad8450b46a35e" translate="yes" xml:space="preserve">
          <source>Read Compose&amp;rsquo;s &lt;a href=&quot;https://docs.compose.io/getting-started/rethinkdb-deployments.html&quot;&gt;overview&lt;/a&gt; of RethinkDB support and their &lt;a href=&quot;https://help.compose.io/docs/connecting-to-rethinkdb&quot;&gt;Connecting to RethinkDB&lt;/a&gt; documentation for more information.</source>
          <target state="translated">阅读Compose的RethinkDB支持&lt;a href=&quot;https://docs.compose.io/getting-started/rethinkdb-deployments.html&quot;&gt;概述&lt;/a&gt;及其&amp;ldquo; &lt;a href=&quot;https://help.compose.io/docs/connecting-to-rethinkdb&quot;&gt;连接到RethinkDB&amp;rdquo;&lt;/a&gt;文档以获取更多信息。</target>
        </trans-unit>
        <trans-unit id="646061e2f38829c59bbd2bebc1acc8f7f33e1c4e" translate="yes" xml:space="preserve">
          <source>Read More</source>
          <target state="translated">阅读更多</target>
        </trans-unit>
        <trans-unit id="26899b3ad08bf6f09ed1824ded31e41b43aadfd5" translate="yes" xml:space="preserve">
          <source>Read about &lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;creating secondary indexes in RethinkDB&lt;/a&gt;.</source>
          <target state="translated">阅读有关&lt;a href=&quot;../../secondary-indexes/javascript/index&quot;&gt;在RethinkDB中创建二级索引的信息&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6445979be97a3e933b6bb240cff09a6407b2918" translate="yes" xml:space="preserve">
          <source>Read about &lt;a href=&quot;http://nobrainer.io/docs/validations/&quot;&gt;validation in NoBrainer&lt;/a&gt; for more details.</source>
          <target state="translated">了解有关&lt;a href=&quot;http://nobrainer.io/docs/validations/&quot;&gt;NoBrainer中验证&lt;/a&gt;的更多信息。</target>
        </trans-unit>
        <trans-unit id="f88dbb0d2a98507a39fce321163277b3a73a9734" translate="yes" xml:space="preserve">
          <source>Read about &lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;how this technology is implemented&lt;/a&gt; for more details.</source>
          <target state="translated">阅读有关&lt;a href=&quot;https://rethinkdb.com/blog/lambda-functions/&quot;&gt;如何实现该技术&lt;/a&gt;的更多详细信息。</target>
        </trans-unit>
        <trans-unit id="ad086cf55b834c375e209972840f1342401d8c41" translate="yes" xml:space="preserve">
          <source>Read more</source>
          <target state="translated">阅读更多</target>
        </trans-unit>
        <trans-unit id="a2453263034e6e359ea2f543b4881317b239da0a" translate="yes" xml:space="preserve">
          <source>Read more about this command &amp;rarr;</source>
          <target state="translated">了解有关此命令的更多信息&amp;rarr;</target>
        </trans-unit>
        <trans-unit id="02f254122240b0223890c627f9fb1fededf11d25" translate="yes" xml:space="preserve">
          <source>Read more details about RethinkDB&amp;rsquo;s binary object support: &lt;a href=&quot;../../../docs/storing-binary/javascript/index&quot;&gt;Storing binary objects&lt;/a&gt;.</source>
          <target state="translated">阅读有关RethinkDB二进制对象支持的更多详细信息：&lt;a href=&quot;../../../docs/storing-binary/javascript/index&quot;&gt;存储二进制对象&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90468c1697f8bededde1b19c579430c9cba85e5a" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../../introduction-to-reql/index&quot;&gt;introduction to RQL&lt;/a&gt; to learn about the ReQL concepts in more depth.</source>
          <target state="translated">阅读&lt;a href=&quot;../../introduction-to-reql/index&quot;&gt;RQL简介，&lt;/a&gt;以更深入地了解ReQL概念。</target>
        </trans-unit>
        <trans-unit id="b7305dc3ce2b74ab8470a10b76b25826ab716813" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../../quickstart/index&quot;&gt;thirty-second quickstart&lt;/a&gt;</source>
          <target state="translated">阅读&lt;a href=&quot;../../quickstart/index&quot;&gt;三十秒快速入门&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd50ab4e04e65b18c59e790e54937f033d4e636d" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../../quickstart/index&quot;&gt;thirty-second quickstart&lt;/a&gt;.</source>
          <target state="translated">阅读&lt;a href=&quot;../../quickstart/index&quot;&gt;三十秒快速入门&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3f7216d53c7652972070c1613c1e9033b24a010" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../guide/javascript/index&quot;&gt;ten-minute guide&lt;/a&gt; to get started with using RethinkDB.</source>
          <target state="translated">阅读&lt;a href=&quot;../guide/javascript/index&quot;&gt;十分钟指南&lt;/a&gt;，开始使用RethinkDB。</target>
        </trans-unit>
        <trans-unit id="2d09665db0a53946b8e9d31dc64ad079edc1aaff" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;../quickstart/index&quot;&gt;thirty-second quickstart&lt;/a&gt;</source>
          <target state="translated">阅读&lt;a href=&quot;../quickstart/index&quot;&gt;三十秒快速入门&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a87c2bcd4362cf6fb041820c08ec2389cdff1f01" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/v2.3.x/drivers&quot;&gt;source code for existing drivers&lt;/a&gt;.</source>
          <target state="translated">阅读&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/v2.3.x/drivers&quot;&gt;现有驱动程序&lt;/a&gt;的源代码。</target>
        </trans-unit>
        <trans-unit id="b3140532e83a846933dd1c5054c5e9b1d505bc64" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/v2.4.x/drivers&quot;&gt;source code for existing drivers&lt;/a&gt;.</source>
          <target state="translated">阅读&lt;a href=&quot;https://github.com/rethinkdb/rethinkdb/tree/v2.4.x/drivers&quot;&gt;现有驱动程序&lt;/a&gt;的源代码。</target>
        </trans-unit>
        <trans-unit id="ecd34094f7e876256eb1edd303a58f87ed2f40f7" translate="yes" xml:space="preserve">
          <source>Read the article on &lt;a href=&quot;../../../docs/data-types/index&quot;&gt;ReQL data types&lt;/a&gt; for a more detailed discussion. Note that some possible return values from &lt;code&gt;typeOf&lt;/code&gt; are internal values, such as &lt;code&gt;MAXVAL&lt;/code&gt;, and unlikely to be returned from queries in standard practice.</source>
          <target state="translated">阅读有关&lt;a href=&quot;../../../docs/data-types/index&quot;&gt;ReQL数据类型&lt;/a&gt;的文章，以进行更详细的讨论。请注意， &lt;code&gt;typeOf&lt;/code&gt; 的某些可能的返回值是内部值，例如 &lt;code&gt;MAXVAL&lt;/code&gt; ，并且在标准实践中不太可能从查询中返回。</target>
        </trans-unit>
        <trans-unit id="69a94a798fe63c51a0462527c27fb6ae3d9aa98a" translate="yes" xml:space="preserve">
          <source>Read the article on &lt;a href=&quot;../writing-drivers/index&quot;&gt;writing RethinkDB drivers&lt;/a&gt;.</source>
          <target state="translated">阅读有关&lt;a href=&quot;../writing-drivers/index&quot;&gt;编写RethinkDB驱动程序&lt;/a&gt;的文章。</target>
        </trans-unit>
        <trans-unit id="6ae455b050e5bf042c051a0264064730a12241af" translate="yes" xml:space="preserve">
          <source>Reads and writes are performed by eight client servers, with 128 concurrent connections per database server. This means we have 128 connections with just a single RethinkDB server, and 2048 concurrent connections with a 16-node cluster. We used a replication factor of two per table, meaning each document was replicated to two separate servers.</source>
          <target state="translated">读取和写入由8个客户端服务器完成,每个数据库服务器有128个并发连接。这意味着我们只用一台RethinkDB服务器就有128个连接,用16节点的集群就有2048个并发连接。我们使用了每个表的复制系数为2,也就是说每个文档被复制到两个独立的服务器上。</target>
        </trans-unit>
        <trans-unit id="ee4d904478e46dd47f209480eb0a07339d3b0d44" translate="yes" xml:space="preserve">
          <source>Reads run in &lt;code&gt;&quot;outdated&quot;&lt;/code&gt; mode will return outdated data even during normal operation, but the data will typically be less than a second out of date. In the event of a network or server failure, the data may be much more out of date. The advantage of running reads in &lt;code&gt;&quot;outdated&quot;&lt;/code&gt; mode is that the latency and throughput are often better than in &lt;code&gt;&quot;single&quot;&lt;/code&gt; mode, in addition to the availability differences described in the previous section.</source>
          <target state="translated">即使在正常操作期间，以 &lt;code&gt;&quot;outdated&quot;&lt;/code&gt; 模式运行的读取也将返回过时的数据，但是该数据通常会少于一秒。如果发生网络或服务器故障，数据可能会过时得多。在 &lt;code&gt;&quot;outdated&quot;&lt;/code&gt; 模式下运行读取的好处是，除了上一节中描述的可用性差异之外，延迟和吞吐量通常比 &lt;code&gt;&quot;single&quot;&lt;/code&gt; 模式下更好。</target>
        </trans-unit>
        <trans-unit id="4f4e1fdf56fccb0716e779b51b4fd1b78316b38b" translate="yes" xml:space="preserve">
          <source>Reads run in &lt;code&gt;single&lt;/code&gt; mode may succeed even if the table is not available, but this is not guaranteed. Reads run in &lt;code&gt;outdated&lt;/code&gt; mode will succeed as long as at least one replica for each of the relevant shards is available.</source>
          <target state="translated">即使表不可用，以 &lt;code&gt;single&lt;/code&gt; 模式运行的读取也可能成功，但是不能保证。只要每个相关分片至少有一个副本可用，则以 &lt;code&gt;outdated&lt;/code&gt; 模式运行的读取将成功。</target>
        </trans-unit>
        <trans-unit id="1d0349ac58ea3d38ff5f50980a915c92316eb132" translate="yes" xml:space="preserve">
          <source>Realtime feeds</source>
          <target state="translated">实时馈送</target>
        </trans-unit>
        <trans-unit id="6858c6a7228cbd560d4cfe81ead5db5f9e52f0b8" translate="yes" xml:space="preserve">
          <source>Rebalances the shards of a table. When called on a database, all the tables in that database will be rebalanced.</source>
          <target state="translated">重新平衡一个表的碎片。当调用数据库时,该数据库中的所有表都将被重新平衡。</target>
        </trans-unit>
        <trans-unit id="0fe299ad13ae6716e4c9dd8be790a6a70d91b0f3" translate="yes" xml:space="preserve">
          <source>Rebuild indexes</source>
          <target state="translated">重建索引</target>
        </trans-unit>
        <trans-unit id="36141d622dd1843fafbde3ba5b63d5704d3eaca5" translate="yes" xml:space="preserve">
          <source>Receive responses</source>
          <target state="translated">收到答复</target>
        </trans-unit>
        <trans-unit id="f40f931807d3e751f75ae8f61f51b88d3c55f63e" translate="yes" xml:space="preserve">
          <source>Recently, the team behind BigchainDB &amp;ndash; a scalable blockchain database built on top of RethinkDB &amp;ndash; has benchmarked RethinkDB on a 32-server cluster running on Amazon&amp;rsquo;s EC2. They measured throughput of more than a million writes per second. Their conclusion: &amp;ldquo;There is linear scaling in write performance with the number of nodes.&amp;rdquo; The full report is available at &lt;a href=&quot;https://www.bigchaindb.com/whitepaper/&quot;&gt;https://www.bigchaindb.com/whitepaper/&lt;/a&gt;</source>
          <target state="translated">最近，BigchainDB背后的团队-基于RethinkDB构建的可扩展的区块链数据库-已经在Amazon EC2上运行的32服务器集群上对RethinkDB进行了基准测试。他们测量的吞吐量超过每秒一百万次写入。他们的结论是：&amp;ldquo;写入性能与节点数成线性比例关系。&amp;rdquo; 完整报告可在&lt;a href=&quot;https://www.bigchaindb.com/whitepaper/&quot;&gt;https://www.bigchaindb.com/whitepaper/&lt;/a&gt;获得。</target>
        </trans-unit>
        <trans-unit id="4ed843dc519783f62617c1358f81fae926ee0818" translate="yes" xml:space="preserve">
          <source>Reconfigure a table&amp;rsquo;s sharding and replication.</source>
          <target state="translated">重新配置表的分片和复制。</target>
        </trans-unit>
        <trans-unit id="2ce1c56b1ad89cc7c3d7f1c846b92e4404ee94e6" translate="yes" xml:space="preserve">
          <source>Reconfiguring a table (changing the number of shards, rebalancing, etc.) causes brief losses of availability at various points during the reconfiguration.</source>
          <target state="translated">重新配置一个表(改变碎片数量、重新平衡等)会在重新配置期间的不同点造成短暂的可用性损失。</target>
        </trans-unit>
        <trans-unit id="1a5dd83d686967dbee491e598c66e203e42c8bea" translate="yes" xml:space="preserve">
          <source>Redux</source>
          <target state="translated">Redux</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="d883c0d0e6af1f4f5d9bae45cb31865272b7621e" translate="yes" xml:space="preserve">
          <source>Reference a database.</source>
          <target state="translated">参考一个数据库。</target>
        </trans-unit>
        <trans-unit id="f97b0faeb0aa223b01f7944075457b4fdb5c0b17" translate="yes" xml:space="preserve">
          <source>Related commands</source>
          <target state="translated">相关命令</target>
        </trans-unit>
        <trans-unit id="6fd9fce94e1798f55b5904f5f4b1afc9b73462f0" translate="yes" xml:space="preserve">
          <source>Remove one or more elements from an array at a given index. Returns the modified array. (Note: &lt;code&gt;deleteAt&lt;/code&gt; operates on arrays, not documents; to delete documents, see the &lt;a href=&quot;../delete/index&quot;&gt;delete&lt;/a&gt; command.)</source>
          <target state="translated">从给定索引的数组中删除一个或多个元素。返回修改后的数组。（注意： &lt;code&gt;deleteAt&lt;/code&gt; 对数组而不是文档进行操作；要删除文档，请参见&lt;a href=&quot;../delete/index&quot;&gt;delete&lt;/a&gt;命令。）</target>
        </trans-unit>
        <trans-unit id="28b83b24b89e420600d6b0c7028a8d2290ddf0d9" translate="yes" xml:space="preserve">
          <source>Remove one or more elements from an array at a given index. Returns the modified array. (Note: &lt;code&gt;deleteAt&lt;/code&gt; operates on arrays, not documents; to delete documents, see the &lt;a href=&quot;delete/index&quot;&gt;delete&lt;/a&gt; command.)</source>
          <target state="translated">从给定索引的数组中删除一个或多个元素。返回修改后的数组。（注意： &lt;code&gt;deleteAt&lt;/code&gt; 对数组而不是文档进行操作；要删除文档，请参见&lt;a href=&quot;delete/index&quot;&gt;delete&lt;/a&gt;命令。）</target>
        </trans-unit>
        <trans-unit id="a87b37bc5f692c148c02fe605a7458c77b15a50d" translate="yes" xml:space="preserve">
          <source>Remove the elements of one array from another and return them as a set (an array with distinct values).</source>
          <target state="translated">将一个数组中的元素从另一个数组中移除,并将其作为一个集合(一个具有不同值的数组)返回。</target>
        </trans-unit>
        <trans-unit id="afa632a95dc9c80b866a354f23735d7bcd1157a2" translate="yes" xml:space="preserve">
          <source>Remove the elements of one array from another array.</source>
          <target state="translated">从另一个数组中删除一个数组的元素。</target>
        </trans-unit>
        <trans-unit id="0697a27ec337b72d0e4d72523605d451a59444a0" translate="yes" xml:space="preserve">
          <source>Removes duplicates from elements in a sequence.</source>
          <target state="translated">删除序列中元素的重复。</target>
        </trans-unit>
        <trans-unit id="79a53851e290035c55b906df35b29aaa6f920cf9" translate="yes" xml:space="preserve">
          <source>Removing a field from a document</source>
          <target state="translated">从文档中删除一个字段</target>
        </trans-unit>
        <trans-unit id="67e44982c2b6ecb129404da6bb7b5c7d570feae7" translate="yes" xml:space="preserve">
          <source>Removing duplicate documents</source>
          <target state="translated">删除重复的文件</target>
        </trans-unit>
        <trans-unit id="fd82550f7bdd5147fa9b38ad056203473cb75426" translate="yes" xml:space="preserve">
          <source>Removing the conflicting fields</source>
          <target state="translated">删除冲突的领域</target>
        </trans-unit>
        <trans-unit id="b5140bff21a36c4d10e5e19f157b727b262facdd" translate="yes" xml:space="preserve">
          <source>Rename an existing secondary index on a table. If the optional argument &lt;code&gt;overwrite&lt;/code&gt; is specified as &lt;code&gt;true&lt;/code&gt;, a previously existing index with the new name will be deleted and the index will be renamed. If &lt;code&gt;overwrite&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default) an error will be raised if the new index name already exists.</source>
          <target state="translated">重命名表上的现有二级索引。如果将可选参数 &lt;code&gt;overwrite&lt;/code&gt; 指定为 &lt;code&gt;true&lt;/code&gt; ，则将删除具有新名称的先前存在的索引，并将重命名该索引。如果 &lt;code&gt;overwrite&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; （默认设置），则在新索引名称已经存在的情况下将引发错误。</target>
        </trans-unit>
        <trans-unit id="3b77fd7d07db52ea2672fd8ede11ae8823105710" translate="yes" xml:space="preserve">
          <source>Rename the new index to the old index&amp;rsquo;s name with &lt;a href=&quot;https://rethinkdb.com/api/python/index_rename&quot;&gt;index_rename&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://rethinkdb.com/api/python/index_rename&quot;&gt;index_rename&lt;/a&gt;将新索引重命名为旧索引的名称。</target>
        </trans-unit>
        <trans-unit id="40c174bdf445078528f8a2f96d1df5c325ca2288" translate="yes" xml:space="preserve">
          <source>Renaming a database</source>
          <target state="translated">重命名数据库</target>
        </trans-unit>
        <trans-unit id="284f910642e6a0defb4586578a3c2a7bd1161d13" translate="yes" xml:space="preserve">
          <source>Renaming a field when retrieving documents</source>
          <target state="translated">检索文件时重命名字段</target>
        </trans-unit>
        <trans-unit id="c85b059a75da0fd1dc38ae1c0c348e9320390608" translate="yes" xml:space="preserve">
          <source>Renaming the fields</source>
          <target state="translated">重新命名领域</target>
        </trans-unit>
        <trans-unit id="6aca56afb789aecc38fe4230dec10a4632e60865" translate="yes" xml:space="preserve">
          <source>Replace an object in a field instead of merging it with an existing object in a &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; operation. Using &lt;code&gt;literal&lt;/code&gt; with no arguments in a &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; operation will remove the corresponding field.</source>
          <target state="translated">替换字段中的对象，而不是在 &lt;code&gt;merge&lt;/code&gt; 或 &lt;code&gt;update&lt;/code&gt; 操作中将其与现有对象合并。在 &lt;code&gt;merge&lt;/code&gt; 或 &lt;code&gt;update&lt;/code&gt; 操作中使用不带任何参数的 &lt;code&gt;literal&lt;/code&gt; 将删除相应的字段。</target>
        </trans-unit>
        <trans-unit id="9ab64c46bc6706994c25c2b0a6ee60d324ab8b2d" translate="yes" xml:space="preserve">
          <source>Replace documents in a table. Accepts a JSON document or a ReQL expression, and replaces the original document with the new one. The new document must have the same primary key as the original document.</source>
          <target state="translated">替换表中的文档。接受JSON文档或ReQL表达式,并用新文档替换原始文档。新文档的主键必须与原文档相同。</target>
        </trans-unit>
        <trans-unit id="b6a9ea19f10bfe83981d4540dee88a3df008ec57" translate="yes" xml:space="preserve">
          <source>Replace returns an object that contains the following attributes:</source>
          <target state="translated">Replace返回一个包含以下属性的对象。</target>
        </trans-unit>
        <trans-unit id="2c5d061d62323778048566a495b1df0b38ea2db7" translate="yes" xml:space="preserve">
          <source>Replaces cursors with streams.</source>
          <target state="translated">将光标替换为流。</target>
        </trans-unit>
        <trans-unit id="722a8bb542ea393f48ca936e084109b805daa87a" translate="yes" xml:space="preserve">
          <source>Replication</source>
          <target state="translated">Replication</target>
        </trans-unit>
        <trans-unit id="bfc37608c32958ce7ebb03befffc73e782976778" translate="yes" xml:space="preserve">
          <source>Reporting vulnerabilities</source>
          <target state="translated">报告弱点</target>
        </trans-unit>
        <trans-unit id="8c34185af915f1e0949bfddb344b5dea859540d4" translate="yes" xml:space="preserve">
          <source>Repubsub implements a simple abstraction on top of RethinkDB to enable publish-subscribe. It uses ReQL as the filtering mechanism, so the full power of the language is at your disposal. This gives a lot more flexibility than traditional message queues.</source>
          <target state="translated">Repubsub在RethinkDB之上实现了一个简单的抽象,以实现发布-订阅。它使用ReQL作为过滤机制,所以语言的全部功能都在你的掌握之中。这比传统的消息队列有更多的灵活性。</target>
        </trans-unit>
        <trans-unit id="552a6a287997255111938f1213d6239a6eb625b9" translate="yes" xml:space="preserve">
          <source>Request Options</source>
          <target state="translated">请求选项</target>
        </trans-unit>
        <trans-unit id="cf028cb289e92d72ecac0c14797660b76e05fb6f" translate="yes" xml:space="preserve">
          <source>Resolving field name conflicts</source>
          <target state="translated">解决字段名冲突</target>
        </trans-unit>
        <trans-unit id="5488d03c527f32b4acc287af95407883ab8f73b2" translate="yes" xml:space="preserve">
          <source>Response notes</source>
          <target state="translated">回复说明</target>
        </trans-unit>
        <trans-unit id="edbff191035089d6d00fc87982482ed99855f37e" translate="yes" xml:space="preserve">
          <source>Response types</source>
          <target state="translated">响应类型</target>
        </trans-unit>
        <trans-unit id="ab860e83a8bba4577ed1f5d169b6ff9b4a71a996" translate="yes" xml:space="preserve">
          <source>Responses from the server take the following form:</source>
          <target state="translated">来自服务器的响应采用以下形式。</target>
        </trans-unit>
        <trans-unit id="3cbe6d6b9a8d1596bb5bca12e14d81c9e108a1a3" translate="yes" xml:space="preserve">
          <source>Restore</source>
          <target state="translated">Restore</target>
        </trans-unit>
        <trans-unit id="fa8c448a3304c7e3bba81325d21434fc4e1ab989" translate="yes" xml:space="preserve">
          <source>Restore &lt;code&gt;backup.tar.gz&lt;/code&gt; to the cluster running on &lt;code&gt;fortress&lt;/code&gt; at port &lt;code&gt;39500&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;backup.tar.gz&lt;/code&gt; 还原到 &lt;code&gt;fortress&lt;/code&gt; 在端口 &lt;code&gt;39500&lt;/code&gt; 上运行的群集。</target>
        </trans-unit>
        <trans-unit id="1c5aff5b034a17ad5b0aa80d1b5867fcaeafd472" translate="yes" xml:space="preserve">
          <source>Restore to the default cluster (&lt;code&gt;localhost:28015&lt;/code&gt;).</source>
          <target state="translated">恢复到默认群集（ &lt;code&gt;localhost:28015&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cfb3d23e010f68e0af656c3a161f08787d49d8df" translate="yes" xml:space="preserve">
          <source>Restore to the default cluster, only importing the table &lt;code&gt;users&lt;/code&gt; to the database &lt;code&gt;league&lt;/code&gt; from the archive &lt;code&gt;backup.tar.gz&lt;/code&gt;. Read the &lt;code&gt;admin&lt;/code&gt; user password from the file &lt;code&gt;pw.txt&lt;/code&gt;. (This should be a plain text file with the password on the first and only line.)</source>
          <target state="translated">恢复到默认集群，仅将表 &lt;code&gt;users&lt;/code&gt; 从归档 &lt;code&gt;backup.tar.gz&lt;/code&gt; 导入数据库 &lt;code&gt;league&lt;/code&gt; 。从文件 &lt;code&gt;pw.txt&lt;/code&gt; 中读取 &lt;code&gt;admin&lt;/code&gt; 用户密码。（这应该是纯文本文件，密码在第一行也是唯一的行。）</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="89ddb5cfb70d8bad46dda602a6ccbd88515a58d8" translate="yes" xml:space="preserve">
          <source>RethinkDB</source>
          <target state="translated">RethinkDB</target>
        </trans-unit>
        <trans-unit id="735933ae21af969b090b07b609e7695fc978b7ac" translate="yes" xml:space="preserve">
          <source>RethinkDB 2.1.5 performance &amp;amp; scaling report</source>
          <target state="translated">RethinkDB 2.1.5性能和扩展报告</target>
        </trans-unit>
        <trans-unit id="cb467484ded44adadf6f26ec92b1553d399b7b13" translate="yes" xml:space="preserve">
          <source>RethinkDB Documentation</source>
          <target state="translated">RethinkDB文档</target>
        </trans-unit>
        <trans-unit id="e4d8c0ff3051c40b7a7d2280bdd1fcf8d66cf738" translate="yes" xml:space="preserve">
          <source>RethinkDB achieves a throughput of 14.6K QPS with two servers, and scales near-linearly as servers are added to the cluster.</source>
          <target state="translated">RethinkDB在使用两台服务器的情况下,实现了14.6K QPS的吞吐量,并随着服务器的增加而接近线性扩展。</target>
        </trans-unit>
        <trans-unit id="e345c3b07e0fd9d1adeaa8ca81dd01baad355475" translate="yes" xml:space="preserve">
          <source>RethinkDB allows you to shard and replicate your cluster on a per-table basis. Settings can be controlled easily from the web administration console. In addition, ReQL commands for table configuration allow both scripting capability and more fine-grained control over replication, distributing replicas for individual tables across user-defined groups of servers using server tags.</source>
          <target state="translated">RethinkDB允许你在每个表的基础上对集群进行碎片和复制。设置可以从web管理控制台轻松控制。此外,用于表配置的ReQL命令允许脚本功能和更精细的复制控制,使用服务器标签在用户定义的服务器组之间分配单个表的复制。</target>
        </trans-unit>
        <trans-unit id="eda9071dab24f5356340e451144a72dcc92d3fce" translate="yes" xml:space="preserve">
          <source>RethinkDB and Rails</source>
          <target state="translated">RethinkDB和Rails</target>
        </trans-unit>
        <trans-unit id="26e492bb4ea400bd0d23919baddf67941c58a444" translate="yes" xml:space="preserve">
          <source>RethinkDB automatically rebalances tables when the number of shards are increased, and as long as your documents have evenly distributed primary keys&amp;mdash;such as the default UUIDs&amp;mdash;it is rarely necessary to call &lt;code&gt;rebalance&lt;/code&gt; manually. Cases where &lt;code&gt;rebalance&lt;/code&gt; may need to be called include:</source>
          <target state="translated">当分片数量增加时，只要您的文档具有均匀分布的主键（例如默认的UUID），RethinkDB就会自动重新平衡表，很少需要手动调用 &lt;code&gt;rebalance&lt;/code&gt; 。其中，案件 &lt;code&gt;rebalance&lt;/code&gt; 可能需要被调用包括：</target>
        </trans-unit>
        <trans-unit id="ad70484f409d6361985bb8c8f93c7743544624d3" translate="yes" xml:space="preserve">
          <source>RethinkDB binary installed by the official package in &lt;code&gt;/usr/local/bin/rethinkdb&lt;/code&gt;</source>
          <target state="translated">由官方软件包安装在 &lt;code&gt;/usr/local/bin/rethinkdb&lt;/code&gt; 中的RethinkDB二进制文件</target>
        </trans-unit>
        <trans-unit id="b9fdbdd31616d7b419cfafad99fc5ceb4c45dd50" translate="yes" xml:space="preserve">
          <source>RethinkDB cache size set to 64,000 MB per server, otherwise default parameters</source>
          <target state="translated">每台服务器的RethinkDB缓存大小设置为64,000 MB,否则为默认参数。</target>
        </trans-unit>
        <trans-unit id="6492843a1285914ee9da37e99939a00ce233450b" translate="yes" xml:space="preserve">
          <source>RethinkDB can be easily deployed on &lt;a href=&quot;http://compose.io/&quot;&gt;Compose&lt;/a&gt; and &lt;a href=&quot;http://aws.amazon.com/&quot;&gt;Amazon Web Services&lt;/a&gt;.</source>
          <target state="translated">RethinkDB可以轻松地部署在&lt;a href=&quot;http://compose.io/&quot;&gt;Compose&lt;/a&gt;和&lt;a href=&quot;http://aws.amazon.com/&quot;&gt;Amazon Web Services上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e521fbd07c46ca1b86622fa3f53c672422be77c8" translate="yes" xml:space="preserve">
          <source>RethinkDB can be easily deployed on &lt;a href=&quot;https://compose.io/&quot;&gt;Compose&lt;/a&gt; and &lt;a href=&quot;https://aws.amazon.com/&quot;&gt;Amazon Web Services&lt;/a&gt;.</source>
          <target state="translated">RethinkDB可以轻松地部署在&lt;a href=&quot;https://compose.io/&quot;&gt;Compose&lt;/a&gt;和&lt;a href=&quot;https://aws.amazon.com/&quot;&gt;Amazon Web Services上&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="779613e061fcbb3ecdf1b3f674a77401d73451f7" translate="yes" xml:space="preserve">
          <source>RethinkDB can handle databases much larger than the amount of main memory available on a server. However, some internal metadata is always kept in memory to guarantee fast access times. Every table has an overhead of 8 MB per server.</source>
          <target state="translated">RethinkDB可以处理比服务器上可用的主内存量大得多的数据库。但是,一些内部的元数据总是保存在内存中,以保证快速的访问时间。每个表的开销为每台服务器8MB。</target>
        </trans-unit>
        <trans-unit id="a7a4715c972f6634315cdf77dceadee9d8dd2408" translate="yes" xml:space="preserve">
          <source>RethinkDB changefeeds</source>
          <target state="translated">RethinkDB changefeeds</target>
        </trans-unit>
        <trans-unit id="72830b7dc8ac5c8f7d4784d89a3b380858da88d5" translate="yes" xml:space="preserve">
          <source>RethinkDB changefeeds synced with &lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt; app state</source>
          <target state="translated">RethinkDB changefeeds与&lt;a href=&quot;https://redux.js.org/&quot;&gt;Redux&lt;/a&gt;应用程序状态同步</target>
        </trans-unit>
        <trans-unit id="1982a12bd3c3cd7086173906e98b7aa6c17ed25d" translate="yes" xml:space="preserve">
          <source>RethinkDB client drivers are responsible for serializing queries, sending them to the server using the ReQL wire protocol, and receiving responses from the server and returning them to the calling application. This process takes the following steps:</source>
          <target state="translated">RethinkDB客户端驱动程序负责将查询序列化,使用ReQL线协议将查询发送到服务器,并从服务器接收响应,然后返回给调用应用程序。这个过程有以下几个步骤。</target>
        </trans-unit>
        <trans-unit id="29742e53bf514545423e131a5089ae63314110fd" translate="yes" xml:space="preserve">
          <source>RethinkDB clustering with CoreOS, etcd2 and Docker, by &lt;a href=&quot;https://github.com/pires&quot;&gt;@pires&lt;/a&gt;.</source>
          <target state="translated">使用@pires通过&lt;a href=&quot;https://github.com/pires&quot;&gt;CoreOS&lt;/a&gt;，etcd2和Docker进行RethinkDB集群。</target>
        </trans-unit>
        <trans-unit id="546b0d2304c21245d3bc9748794a02297ae69be4" translate="yes" xml:space="preserve">
          <source>RethinkDB command line options</source>
          <target state="translated">RethinkDB命令行选项</target>
        </trans-unit>
        <trans-unit id="757b43f479974355f39e37a9afd966d958b550a0" translate="yes" xml:space="preserve">
          <source>RethinkDB controls access to clusters through a system based around &lt;strong&gt;users, permissions,&lt;/strong&gt; and &lt;strong&gt;scopes.&lt;/strong&gt; Together, these allow you to specify fine grained control for reading, writing and administrative access down to a per-table level.</source>
          <target state="translated">RethinkDB通过基于&lt;strong&gt;用户，权限&lt;/strong&gt;和&lt;strong&gt;范围&lt;/strong&gt;的系统来控制对集群的访问&lt;strong&gt;。&lt;/strong&gt;在一起，它们使您可以指定细粒度的控制，以逐个表级别进行读取，写入和管理访问。</target>
        </trans-unit>
        <trans-unit id="b5823fa08eb48445af67a4037ecc0701a77215e5" translate="yes" xml:space="preserve">
          <source>RethinkDB data directory will be &lt;code&gt;/Library/RethinkDB/data&lt;/code&gt;</source>
          <target state="translated">RethinkDB数据目录将为 &lt;code&gt;/Library/RethinkDB/data&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="612315f0d5f8087ec3f0b4e7fce019c06049b1a8" translate="yes" xml:space="preserve">
          <source>RethinkDB demonstrates extremely high scalability in this configuration, reaching throughputs of well over a million queries per second. The slightly sub-linear scalability when going from 12 to 16 database servers is caused by the client servers&amp;rsquo; CPUs getting saturated at these throughputs.</source>
          <target state="translated">RethinkDB在此配置中展示了极高的可扩展性，每秒吞吐量超过一百万次。从12台数据库服务器到16台数据库服务器时，亚线性的可伸缩性略微是由于客户端服务器的CPU在这些吞吐量下达到饱和所致。</target>
        </trans-unit>
        <trans-unit id="8672db1bf1765198165013defafd20d8db24f975" translate="yes" xml:space="preserve">
          <source>RethinkDB does not currently have an optimizer. As an example, the following query will not automatically use an index:</source>
          <target state="translated">RethinkDB目前没有优化器。举个例子,下面的查询不会自动使用索引。</target>
        </trans-unit>
        <trans-unit id="672811adc0003c264d287d9d90dddfe5392790ce" translate="yes" xml:space="preserve">
          <source>RethinkDB does not have fully automatic failover (yet), but if a server in a cluster crashes it can be manually removed from the cluster. In most cases, RethinkDB will recover from such a situation automatically. For information on this process, read &lt;a href=&quot;../failover/index&quot;&gt;Failover&lt;/a&gt;.</source>
          <target state="translated">RethinkDB还没有完全自动故障转移（但是），但是如果集群中的服务器崩溃，则可以手动将其从集群中删除。在大多数情况下，RethinkDB将自动从这种情况下恢复。有关此过程的信息，请阅读&lt;a href=&quot;../failover/index&quot;&gt;故障转移&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29225a505de5e9d97ccc052ef35e3e9e191310f6" translate="yes" xml:space="preserve">
          <source>RethinkDB does not support unique secondary indexes even for non-sharded tables.</source>
          <target state="translated">RethinkDB不支持唯一的二级索引,即使是非碎片表。</target>
        </trans-unit>
        <trans-unit id="3a1e6552e69e48ce4c7f868763ae1040ab304a06" translate="yes" xml:space="preserve">
          <source>RethinkDB does take exclusive block-level locks in case multiple writes are performed on documents that are close together in the B-Tree. If the contested block is cached in memory, these locks are extremely short-lived. If the blocks need to be loaded from disk, these locks take longer. Typically this does not present performance problems because the top levels of the B-Tree are all cached along with the frequently used blocks, so in most cases writes can be performed essentially lock-free.</source>
          <target state="translated">RethinkDB确实会在B树中相近的文档上进行多次写入的情况下,采取专属的块级锁。如果有争议的块被缓存在内存中,这些锁的时间极短。如果需要从磁盘中加载块,这些锁需要更长的时间。通常情况下,这不会带来性能问题,因为B-Tree的最高层都和常用的块一起被缓存,所以在大多数情况下,写入可以基本无锁地执行。</target>
        </trans-unit>
        <trans-unit id="40f0f98da3c17608b70462f0c36e09dd4a185e21" translate="yes" xml:space="preserve">
          <source>RethinkDB has access to the query structure, which allows for optimization techniques similar to those available in SQL. This feature will be added to RethinkDB in the future.</source>
          <target state="translated">RethinkDB可以访问查询结构,这就可以实现类似于SQL中的优化技术。这个功能将在未来加入到RethinkDB中。</target>
        </trans-unit>
        <trans-unit id="cf29f8f9f21bf8fba6ea63ced9d6fae553e0b5eb" translate="yes" xml:space="preserve">
          <source>RethinkDB has failed to write to its log file (or to &lt;code&gt;stdout/stderr&lt;/code&gt;). The &lt;code&gt;message&lt;/code&gt; string will be the error that RethinkDB received from the operating system on the failed write; &lt;code&gt;servers&lt;/code&gt; will be a list of servers affected.</source>
          <target state="translated">RethinkDB无法写入其日志文件（或 &lt;code&gt;stdout/stderr&lt;/code&gt; ）。的 &lt;code&gt;message&lt;/code&gt; 字符串将是从上失败的写入操作系统接收RethinkDB误差; &lt;code&gt;servers&lt;/code&gt; 将是受影响的服务器列表。</target>
        </trans-unit>
        <trans-unit id="2bc2af13435e602b512f4af7f70dee3bcd170db5" translate="yes" xml:space="preserve">
          <source>RethinkDB has native support for millisecond-precision times with time zones. Some highlights:</source>
          <target state="translated">RethinkDB原生支持毫秒级精度的时间与时区。一些亮点。</target>
        </trans-unit>
        <trans-unit id="0fae139b6eb1367767e96d5c430169b70f3ebb30" translate="yes" xml:space="preserve">
          <source>RethinkDB has powerful Hadoop-style map-reduce tools, that integrate cleanly into the query language. Learn how they work, and play with a few examples.</source>
          <target state="translated">RethinkDB拥有强大的Hadoop风格的map-reduce工具,这些工具可以干净利落地集成到查询语言中。了解它们是如何工作的,并通过一些例子来玩。</target>
        </trans-unit>
        <trans-unit id="7b596f5ffcda7c2fb3cfedba5e4d1051b8fe7dbe" translate="yes" xml:space="preserve">
          <source>RethinkDB has shortcuts for five common aggregation operations: &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. In practice, you&amp;rsquo;ll often be able to use these with &lt;code&gt;group&lt;/code&gt; in place of writing your own &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; functions.</source>
          <target state="translated">RethinkDB具有五个常用聚合操作的快捷方式： &lt;code&gt;count&lt;/code&gt; ， &lt;code&gt;sum&lt;/code&gt; ， &lt;code&gt;avg&lt;/code&gt; ， &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 。在实践中，您通常可以将它们与 &lt;code&gt;group&lt;/code&gt; 一起使用，以代替编写自己的 &lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;reduce&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="7bba8fb71c9832349f00a9f837897d44f12388f1" translate="yes" xml:space="preserve">
          <source>RethinkDB has shortcuts for five common aggregation operations: &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;avg&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;code&gt;max&lt;/code&gt;. In practice, you&amp;rsquo;ll often be able to use these with &lt;code&gt;group&lt;/code&gt; these rather than writing your own &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; functions.</source>
          <target state="translated">RethinkDB具有五个常用聚合操作的快捷方式： &lt;code&gt;count&lt;/code&gt; ， &lt;code&gt;sum&lt;/code&gt; ， &lt;code&gt;avg&lt;/code&gt; ， &lt;code&gt;min&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 。实际上，您通常可以将它们与这些 &lt;code&gt;group&lt;/code&gt; 在一起使用，而不是编写自己的 &lt;code&gt;map&lt;/code&gt; 和 &lt;code&gt;reduce&lt;/code&gt; 功能。</target>
        </trans-unit>
        <trans-unit id="a07a2f1e204ccef9ce95abeb8228ca595f3024c2" translate="yes" xml:space="preserve">
          <source>RethinkDB has three classes of errors: driver (&lt;code&gt;ReqlDriverError&lt;/code&gt;), query compilation (&lt;code&gt;ReqlCompileError&lt;/code&gt;) and runtime (errors subclassed from &lt;code&gt;ReqlRuntimeError&lt;/code&gt;).</source>
          <target state="translated">RethinkDB具有三类错误：驱动程序（ &lt;code&gt;ReqlDriverError&lt;/code&gt; ），查询编译（ &lt;code&gt;ReqlCompileError&lt;/code&gt; ）和运行时（错误从 &lt;code&gt;ReqlRuntimeError&lt;/code&gt; 子类化）。</target>
        </trans-unit>
        <trans-unit id="7024546f8577c97b82e4aeda6e9841941adc8703" translate="yes" xml:space="preserve">
          <source>RethinkDB in two minutes</source>
          <target state="translated">两分钟内完成RethinkDB</target>
        </trans-unit>
        <trans-unit id="4eeea1cb9e84ccba67aa59483a4f622f2c06144f" translate="yes" xml:space="preserve">
          <source>RethinkDB inverts the traditional database architecture by exposing an exciting new access model &amp;ndash; instead of polling for changes, the developer can tell RethinkDB to continuously push updated query results to applications in realtime.</source>
          <target state="translated">RethinkDB通过公开一个令人兴奋的新访问模型来颠覆传统的数据库体系结构&amp;ndash;开发人员可以告诉RethinkDB不断将更新的查询结果实时推送到应用程序，而不必轮询更改。</target>
        </trans-unit>
        <trans-unit id="f15b38cf885439fce391405265382c8fb3a5eddc" translate="yes" xml:space="preserve">
          <source>RethinkDB is running out of memory</source>
          <target state="translated">RethinkDB内存不足</target>
        </trans-unit>
        <trans-unit id="025c104640a27fcf19c9484f3ab6cf659bfa56be" translate="yes" xml:space="preserve">
          <source>RethinkDB keeps an internal directory tracking the current state of the cluster: how many servers are accessible, what data is currently stored on each server, etc. The data structures that keep track of the directory are automatically updated when the cluster changes. For example, if a server dies due to power failure, the directory is updated to represent this change.</source>
          <target state="translated">RethinkDB会保存一个内部目录,跟踪集群的当前状态:有多少台服务器可以访问,每个服务器上当前存储了哪些数据等。当集群发生变化时,跟踪该目录的数据结构会自动更新。例如,如果一台服务器因断电而死亡,目录就会被更新来代表这一变化。</target>
        </trans-unit>
        <trans-unit id="cf9d083edb8c21c54d52f3036376df035b56b907" translate="yes" xml:space="preserve">
          <source>RethinkDB log will be &lt;code&gt;/var/log/rethinkdb.log&lt;/code&gt;</source>
          <target state="translated">RethinkDB日志将为 &lt;code&gt;/var/log/rethinkdb.log&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12e7e6962d9b0bc38ee3bb81801ab1841743fac0" translate="yes" xml:space="preserve">
          <source>RethinkDB maintains availability if the user increases or decreases the number of replicas in the cluster. In most cases, the replication process should not have a strong performance impact on the real-time system.</source>
          <target state="translated">如果用户增加或减少集群中的复制数量,RethinkDB就会保持可用性。在大多数情况下,复制过程不应该对实时系统产生强烈的性能影响。</target>
        </trans-unit>
        <trans-unit id="623536e8efae22fe8dbe6bff869831b8cb6a7ba8" translate="yes" xml:space="preserve">
          <source>RethinkDB makes building and scaling realtime apps dramatically easier. Get started by installing the server, and jump into our getting started guide to start building your first app in minutes.</source>
          <target state="translated">RethinkDB让构建和扩展实时应用程序变得更加容易。通过安装服务器开始,并跳入我们的入门指南,在几分钟内开始构建你的第一个应用程序。</target>
        </trans-unit>
        <trans-unit id="2e85a94c44575620e7b9601eb22bb2499c37e1fb" translate="yes" xml:space="preserve">
          <source>RethinkDB may or may not maintain availability if the user modifies the number of shards. In many cases availability will be maintained, but currently it cannot be guaranteed. We&amp;rsquo;re exploring different solutions to remove this limitation.</source>
          <target state="translated">如果用户修改了分片的数量，RethinkDB可能会或可能不会保持可用性。在许多情况下，将保持可用性，但是目前无法保证。我们正在探索不同的解决方案以消除此限制。</target>
        </trans-unit>
        <trans-unit id="0d55b0820382b90b873c36c3282a6665c40558fe" translate="yes" xml:space="preserve">
          <source>RethinkDB only allows conversion of GeoJSON objects which have ReQL equivalents: Point, LineString, and Polygon. MultiPoint, MultiLineString, and MultiPolygon are not supported. (You could, however, store multiple points, lines and polygons in an array and use a geospatial multi index with them.)</source>
          <target state="translated">RethinkDB只允许转换有ReQL等价的GeoJSON对象。Point,LineString,and Polygon.不支持MultiPoint、MultiLineString和MultiPolygon。(然而,你可以将多个点、线和多边形存储在一个数组中,并使用一个地理空间的多索引。)</target>
        </trans-unit>
        <trans-unit id="05eba76c1e3bf668992e43cbb82de3b220dab3cc" translate="yes" xml:space="preserve">
          <source>RethinkDB only allows conversion of GeoJSON objects which have ReQL equivalents: Point, LineString, and Polygon; MultiPoint, MultiLineString, and MultiPolygon are not supported. (You could, however, store multiple points, lines and polygons in an array and use a geospatial multi index with them.)</source>
          <target state="translated">RethinkDB只允许转换有ReQL等价的GeoJSON对象。Point,LineString,and Polygon;MultiPoint,MultiLineString,and MultiPolygon are not supported.然而,你可以将多个点、线和多边形存储在一个数组中,并使用地理空间多索引。</target>
        </trans-unit>
        <trans-unit id="ae8f4e6bd74894f0a648d341946431e0292b55f6" translate="yes" xml:space="preserve">
          <source>RethinkDB operates at peak performance when the batch size is around two hundred documents.</source>
          <target state="translated">当批处理量在两百个文档左右时,RethinkDB的性能达到峰值。</target>
        </trans-unit>
        <trans-unit id="08ab91ee1258986387b10e654d9e4c5d42985b98" translate="yes" xml:space="preserve">
          <source>RethinkDB operations are never atomic across multiple keys. For this reason, RethinkDB cannot be considered an ACID database.</source>
          <target state="translated">RethinkDB的操作从来不是跨多个键的原子操作。因此,RethinkDB不能被认为是一个ACID数据库。</target>
        </trans-unit>
        <trans-unit id="8741a43490c434407d3eb5b4660dc5f8849570f6" translate="yes" xml:space="preserve">
          <source>RethinkDB organizes data into blocks. Blocks in RethinkDB are sized in steps of 512 bytes up to a maximum of 4 KB. While the content of a block itself can be cleared from main memory to free space, metadata of approximately 10&amp;ndash;26 bytes per block is always kept in memory. Thus, this memory overhead is directly proportional to the number of blocks that a given data set requires. (This is in addition to the 8 MB overhead mentioned above.)</source>
          <target state="translated">RethinkDB将数据组织成块。RethinkDB中的块大小以512字节为步长，最大为4 KB。虽然可以将块本身的内容从主存储器清除到可用空间，但是每个块大约10-26字节的元数据始终保留在内存中。因此，此内存开销与给定数据集所需的块数成正比。（这是上述8 MB开销的补充。）</target>
        </trans-unit>
        <trans-unit id="b9269f54553fd9442463297c700ee2b8e73e7de2" translate="yes" xml:space="preserve">
          <source>RethinkDB packages automatically install an init script at &lt;code&gt;/etc/init.d/rethinkdb&lt;/code&gt; and add default run-level entries. For RethinkDB to automatically run on system startup, you&amp;rsquo;ll need to add a config file to &lt;code&gt;/etc/rethinkdb/instances.d/&lt;/code&gt;.</source>
          <target state="translated">RethinkDB软件包会自动在 &lt;code&gt;/etc/init.d/rethinkdb&lt;/code&gt; 中安装一个初始化脚本，并添加默认的运行级别条目。为了使RethinkDB在系统启动时自动运行，您需要向 &lt;code&gt;/etc/rethinkdb/instances.d/&lt;/code&gt; 添加一个配置文件。</target>
        </trans-unit>
        <trans-unit id="c7f008700c05c1865d12295437922484ecae3c18" translate="yes" xml:space="preserve">
          <source>RethinkDB provides a web interface which lets you manage your entire server cluster, from controlling sharding and replication to running ReQL queries (in JavaScript), with editing and history support. In addition, you can perform administration tasks using scriptable ReQL commands.</source>
          <target state="translated">RethinkDB提供了一个web界面,让你管理整个服务器集群,从控制sharding和复制到运行ReQL查询(在JavaScript中),并支持编辑和历史记录。此外,你可以使用可脚本的ReQL命令来执行管理任务。</target>
        </trans-unit>
        <trans-unit id="0f7f159d2a79c214cc2f935797ab4190a4a3c1ee" translate="yes" xml:space="preserve">
          <source>RethinkDB provides an &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt; command for accessing external APIs directly from the database. Since many APIs accept and return JSON, RethinkDB is a convenient platform for manipulating and analyzing API data, both interactively and in running applications.</source>
          <target state="translated">RethinkDB提供了一个&lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt;命令，用于直接从数据库访问外部API。由于许多API接受并返回JSON，因此RethinkDB是一个便捷的平台，可用于交互和运行应用程序中的API数据进行操作和分析。</target>
        </trans-unit>
        <trans-unit id="b8d1105c1ecf2daa0d8a73d978e1f6486a4435a7" translate="yes" xml:space="preserve">
          <source>RethinkDB provides an &lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt; command for accessing external APIs directly from the database. Since many APIs accept and return JSON, RethinkDB is a convenient platform for manipulating and analyzing API data, both interactively and in running applications. Make sure that you &lt;strong&gt;never&lt;/strong&gt; use this command for &lt;strong&gt;user provided&lt;/strong&gt; URLs.</source>
          <target state="translated">RethinkDB提供了一个&lt;a href=&quot;../../api/javascript/http/index&quot;&gt;r.http&lt;/a&gt;命令，用于直接从数据库访问外部API。由于许多API都接受并返回JSON，因此RethinkDB是一个便捷的平台，用于以交互方式和在运行的应用程序中操作和分析API数据。确保您&lt;strong&gt;永远不要&lt;/strong&gt;对&lt;strong&gt;用户提供的&lt;/strong&gt;URL使用此命令。</target>
        </trans-unit>
        <trans-unit id="7f522c8137b2011dbb2715593ecd36021f7cbfe7" translate="yes" xml:space="preserve">
          <source>RethinkDB server</source>
          <target state="translated">RethinkDB服务器</target>
        </trans-unit>
        <trans-unit id="b74edfe769c267c7428c9983eb180ae400916f47" translate="yes" xml:space="preserve">
          <source>RethinkDB ships with simple tools to perform a hot backup of a running cluster. See the &lt;a href=&quot;../backup/index&quot;&gt;backup instructions&lt;/a&gt; for more details.</source>
          <target state="translated">RethinkDB附带了简单的工具，可以对正在运行的集群执行热备份。有关更多详细信息，请参见&lt;a href=&quot;../backup/index&quot;&gt;备份说明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ca3a98b62a215786642692f61a3dcc4decf1ecb3" translate="yes" xml:space="preserve">
          <source>RethinkDB supports &lt;a href=&quot;../../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt;, which allow you to subscribe to changes on a table. The database pushes these changes to you as they happen.</source>
          <target state="translated">RethinkDB支持&lt;a href=&quot;../../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt;，它允许您订阅表上的更改。数据库会在发生更改时将这些更改推送给您。</target>
        </trans-unit>
        <trans-unit id="84dcf0975c77e90cf88fc77f75f9af0d1107ebf5" translate="yes" xml:space="preserve">
          <source>RethinkDB supports &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;, which allow you to subscribe to changes on a table. The database pushes these changes to you as they happen.</source>
          <target state="translated">RethinkDB支持&lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;，它允许您订阅表上的更改。数据库会在发生更改时将这些更改推送给您。</target>
        </trans-unit>
        <trans-unit id="f539d29ec109400beb33e87944c1bc419991ee37" translate="yes" xml:space="preserve">
          <source>RethinkDB supports a native binary object type, letting you use ReQL to store binary objects directly in the database. The ReQL driver will transparently translate between the ReQL type and Node.js &lt;a href=&quot;http://nodejs.org/api/buffer.html&quot;&gt;Buffers&lt;/a&gt;.</source>
          <target state="translated">RethinkDB支持本机二进制对象类型，使您可以使用ReQL将二进制对象直接存储在数据库中。ReQL驱动程序将在ReQL类型和Node.js &lt;a href=&quot;http://nodejs.org/api/buffer.html&quot;&gt;Buffers&lt;/a&gt;之间透明地转换。</target>
        </trans-unit>
        <trans-unit id="9a3ee7c067f76cae71e52f28c4124afb7429a365" translate="yes" xml:space="preserve">
          <source>RethinkDB supports a native binary object type, letting you use ReQL to store binary objects directly in the database. The ReQL driver will transparently translate between the ReQL type and Node.js &lt;a href=&quot;https://nodejs.org/api/buffer.html&quot;&gt;Buffers&lt;/a&gt;.</source>
          <target state="translated">RethinkDB支持本机二进制对象类型，使您可以使用ReQL将二进制对象直接存储在数据库中。ReQL驱动程序将在ReQL类型和Node.js &lt;a href=&quot;https://nodejs.org/api/buffer.html&quot;&gt;Buffers&lt;/a&gt;之间透明地转换。</target>
        </trans-unit>
        <trans-unit id="b79de0235d3d7e49d6270396cae554871735eba3" translate="yes" xml:space="preserve">
          <source>RethinkDB supports automatic failover when more than half of the voting replicas for each shard of a table are still available (see the &lt;a href=&quot;../../../docs/failover/index&quot;&gt;Failover&lt;/a&gt; documentation for more details). However, if half or more of the voting replicas for a shard are lost, failover will not happen automatically, leaving two options:</source>
          <target state="translated">当一个表的每个分片仍有一半以上的投票副本可用时，RethinkDB支持自动故障转移（有关更多详细信息，请参阅&lt;a href=&quot;../../../docs/failover/index&quot;&gt;故障转移&lt;/a&gt;文档）。但是，如果分片的一半或更多有表决权的副本丢失了，故障转移将不会自动发生，留下两个选择：</target>
        </trans-unit>
        <trans-unit id="f6ad0355b7469785a915bd6fcb267d42c7a9623f" translate="yes" xml:space="preserve">
          <source>RethinkDB supports both secondary and compound indexes, as well as indexes that compute arbitrary expressions. You can see examples of how to use the secondary index API &lt;a href=&quot;../secondary-indexes/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">RethinkDB支持二级索引和复合索引，以及计算任意表达式的索引。您可以&lt;a href=&quot;../secondary-indexes/index&quot;&gt;在此处&lt;/a&gt;查看有关如何使用二级索引API的示例。</target>
        </trans-unit>
        <trans-unit id="bc0a64248d0d6d9b7730531fe524793090fdf2c0" translate="yes" xml:space="preserve">
          <source>RethinkDB supports both secondary and compound indexes, as well as indexes that compute arbitrary expressions. You can see examples of how to use the secondary index API &lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">RethinkDB支持二级索引和复合索引，以及计算任意表达式的索引。您可以&lt;a href=&quot;../secondary-indexes/javascript/index&quot;&gt;在此处&lt;/a&gt;查看有关如何使用二级索引API的示例。</target>
        </trans-unit>
        <trans-unit id="71d8b68931056a0d66d312a06ccb2e2e6cb5d9a2" translate="yes" xml:space="preserve">
          <source>RethinkDB supports both up-to-date and out-of-date reads. By default, all read queries are executed up-to-date, which means that every read operation for a given shard is routed to the primary replica for that shard and executed in order with other operations on the shard. In this default mode, the client always sees the latest, consistent, artifact-free view of the data.</source>
          <target state="translated">RethinkDB支持最新的和过时的读取。默认情况下,所有的读取查询都会被执行为最新的,这意味着对一个给定的shard的每一个读取操作都会被路由到该shard的主副本,并与shard上的其他操作一起按顺序执行。在这种默认模式下,客户端总是看到最新的、一致的、无伪装的数据视图。</target>
        </trans-unit>
        <trans-unit id="f11243238b91ef1b89680e4c273314a374928ae0" translate="yes" xml:space="preserve">
          <source>RethinkDB supports different types of secondary indexes:</source>
          <target state="translated">RethinkDB支持不同类型的二级索引。</target>
        </trans-unit>
        <trans-unit id="56794295c6dd1026fd6f7ec8b02775e58186eb63" translate="yes" xml:space="preserve">
          <source>RethinkDB supports most commonly used file systems. It optionally supports direct disk I/O for greater efficiency, but this is not enabled by default.</source>
          <target state="translated">RethinkDB支持最常用的文件系统。它可以选择支持直接的磁盘I/O来提高效率,但默认情况下是不启用的。</target>
        </trans-unit>
        <trans-unit id="10e2f3eb29f4d8af581f7118e24c03dfdcd9a5d9" translate="yes" xml:space="preserve">
          <source>RethinkDB supports replication of data: every table in a database can be replicated as many times as you have servers in a cluster. Setting up replication is a simple operation with the web interface or the command line tool. For details, read &lt;a href=&quot;../sharding-and-replication/index&quot;&gt;Sharding and replication&lt;/a&gt;.</source>
          <target state="translated">RethinkDB支持数据复制：数据库中的每个表可以复制的次数与集群中服务器的复制次数相同。设置复制是通过Web界面或命令行工具进行的简单操作。有关详细信息，请阅读分片&lt;a href=&quot;../sharding-and-replication/index&quot;&gt;和复制&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2cb54ac86a86c52460e890916d58c1288376ab8b" translate="yes" xml:space="preserve">
          <source>RethinkDB supports spatial and geographic queries through geometry object support.</source>
          <target state="translated">RethinkDB通过几何对象支持空间和地理查询。</target>
        </trans-unit>
        <trans-unit id="d32fa6ee6031165bb84247418c80028e7ab18532" translate="yes" xml:space="preserve">
          <source>RethinkDB supports the WGS84 World Geodetic System&amp;rsquo;s reference ellipsoid and geographic coordinate system (GCS). It does not directly support any projected coordinate system (PCS), but there are many tools available for performing such projections.</source>
          <target state="translated">RethinkDB支持WGS84世界大地测量系统的参考椭球和地理坐标系（GCS）。它不直接支持任何投影坐标系（PCS），但是有许多工具可用于执行此类投影。</target>
        </trans-unit>
        <trans-unit id="a9c7488acfc62299ace979066c1e3f08638dfc5c" translate="yes" xml:space="preserve">
          <source>RethinkDB uses a range sharding algorithm parameterized on the table&amp;rsquo;s primary key to partition the data. When the user states they want a given table to use a certain number of shards, the system examines the statistics for the table and finds the optimal set of split points to break up the table evenly. All sharding is currently done based on the table&amp;rsquo;s primary key, and cannot be done based on any other attribute (in RethinkDB the primary key and the shard key are effectively the same thing).</source>
          <target state="translated">RethinkDB使用在表的主键上参数化的范围分片算法对数据进行分区。当用户声明他们希望给定的表使用一定数量的分片时，系统将检查表的统计信息，并找到最佳的拆分点集以将表平均分解。当前，所有分片都是基于表的主键完成的，不能基于任何其他属性来完成（在RethinkDB中，主键和分片键实际上是同一件事）。</target>
        </trans-unit>
        <trans-unit id="5f2b0afa489f326033447882c4ce512558bc7c6f" translate="yes" xml:space="preserve">
          <source>RethinkDB uses a safe default configuration for write acknowledgement. Each write is committed to disk before the server acknowledges it to the client. If you&amp;rsquo;re running a single thread that inserts documents into RethinkDB in a loop, each insert must wait for the server acknowledgement before proceeding to the next one. This can significantly slow down the overall throughput.</source>
          <target state="translated">RethinkDB使用安全的默认配置进行写确认。在服务器向客户端确认之前，每次写入都会提交到磁盘。如果您正在运行一个循环将文档插入RethinkDB的线程，则每个插入操作必须等待服务器确认，然后才能进行下一个操作。这会大大降低整体吞吐量。</target>
        </trans-unit>
        <trans-unit id="87d7ed56e064cdc2be5c3c306b0a024e244f7da3" translate="yes" xml:space="preserve">
          <source>RethinkDB uses byte-wise ordering for &lt;code&gt;between&lt;/code&gt; and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint.</source>
          <target state="translated">RethinkDB在 &lt;code&gt;between&lt;/code&gt; 使用字节顺序排序，并且不支持Unicode归类。非ASCII字符将按UTF-8代码点排序。</target>
        </trans-unit>
        <trans-unit id="a2b7492bd98ab8c96ed190967271aac8f2b9a308" translate="yes" xml:space="preserve">
          <source>RethinkDB uses the &lt;a href=&quot;https://en.wikipedia.org/wiki/Raft_(computer_science)&quot;&gt;Raft algorithm&lt;/a&gt; to store and propagate cluster configuration in most cases, although there are some situations it uses semilattices, versioned with internal timestamps. This architecture turns out to have sufficient mathematical properties to address all the issues mentioned above (this result has been known in distributed systems research for quite a while).</source>
          <target state="translated">在大多数情况下，RethinkDB使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Raft_(computer_science)&quot;&gt;Raft算法&lt;/a&gt;存储和传播集群配置，尽管在某些情况下，它使用带有内部时间戳版本的半格。事实证明，此体系结构具有足够的数学属性来解决上述所有问题（此结果在分布式系统研究中已经存在相当长的一段时间了）。</target>
        </trans-unit>
        <trans-unit id="ad9e86f0c36323e6c20f0c976359840d640f76c9" translate="yes" xml:space="preserve">
          <source>RethinkDB uses the same protocol for communication within a datacenter as it does across datacenters. Because the architecture is immediately consistent and does not require quorums on individual document reads and writes, the latency issues commonly associated with cross-datacenter quorums on Dynamo-style systems do not arise in RethinkDB.</source>
          <target state="translated">RethinkDB在数据中心内的通信和跨数据中心的通信使用相同的协议。由于架构是立即一致的,并且不需要对单个文档的读写进行配额,所以在RethinkDB中不会出现通常与Dynamo式系统的跨数据中心配额相关的延迟问题。</target>
        </trans-unit>
        <trans-unit id="3e113a38cea5f70d16b5f974ca8331179248d2d4" translate="yes" xml:space="preserve">
          <source>RethinkDB uses three ports to operate&amp;mdash;the HTTP web UI port, the client drivers port, and the intracluster traffic port. You can connect the browser to the web UI port to administer the cluster right from your browser, and connect the client drivers to the client driver port to run queries from your application. If you&amp;rsquo;re running a cluster, different RethinkDB nodes communicate with each other via the intracluster traffic port.</source>
          <target state="translated">RethinkDB使用三个端口进行操作-HTTP Web UI端口，客户端驱动程序端口和集群内流量端口。您可以将浏览器连接到Web UI端口以直接从浏览器管理群集，并将客户端驱动程序连接到客户端驱动程序端口以从应用程序运行查询。如果您正在运行群集，则不同的RethinkDB节点将通过群集内流量端口相互通信。</target>
        </trans-unit>
        <trans-unit id="82c73af11c06078443ac96c46a3ff491a24f303f" translate="yes" xml:space="preserve">
          <source>RethinkDB version 2.1.5</source>
          <target state="translated">RethinkDB 2.1.5版。</target>
        </trans-unit>
        <trans-unit id="64be170039b96e0579e9278dd905f8db6230488d" translate="yes" xml:space="preserve">
          <source>RethinkDB will accept two formats for JSON files:</source>
          <target state="translated">RethinkDB将接受两种格式的JSON文件。</target>
        </trans-unit>
        <trans-unit id="1b3f223b9bb1750bce96d8634333989e0ebc07d7" translate="yes" xml:space="preserve">
          <source>RethinkDB will automatically load on startup. To disable this behavior, change the &lt;code&gt;RunAtLoad&lt;/code&gt; key to &lt;code&gt;&amp;lt;false/&amp;gt;&lt;/code&gt; in the &lt;code&gt;plist&lt;/code&gt; file.</source>
          <target state="translated">RethinkDB将在启动时自动加载。若要禁用此行为，请在 &lt;code&gt;plist&lt;/code&gt; 文件中将 &lt;code&gt;RunAtLoad&lt;/code&gt; 键更改为 &lt;code&gt;&amp;lt;false/&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="188b67359aa222e3ea9d29fed4e862f6d351f160" translate="yes" xml:space="preserve">
          <source>RethinkDB will generate a primary key and return it in &lt;code&gt;generated_keys&lt;/code&gt;.</source>
          <target state="translated">RethinkDB将生成一个主键，并将其返回到 &lt;code&gt;generated_keys&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="431dcb2d29ab61bb877a049c1843bebcddf81fc6" translate="yes" xml:space="preserve">
          <source>RethinkDB will notify your program of all changes in the &lt;code&gt;authors&lt;/code&gt; table and will include the old value and the new value of each modified document. See the &lt;a href=&quot;../../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt; documentation entry for more details on how to use realtime feeds in RethinkDB.</source>
          <target state="translated">RethinkDB将在 &lt;code&gt;authors&lt;/code&gt; 表中将所有更改通知您的程序，并将包括每个已修改文档的旧值和新值。有关如何在RethinkDB中使用实时提要的更多详细信息，请参见&lt;a href=&quot;../../changefeeds/index&quot;&gt;changefeeds&lt;/a&gt;文档条目。</target>
        </trans-unit>
        <trans-unit id="ac7af94097e441aba69be3324247352a59b9643a" translate="yes" xml:space="preserve">
          <source>RethinkDB will notify your program of all changes in the &lt;code&gt;authors&lt;/code&gt; table and will include the old value and the new value of each modified document. See the &lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt; documentation entry for more details on how to use realtime feeds in RethinkDB.</source>
          <target state="translated">RethinkDB将在 &lt;code&gt;authors&lt;/code&gt; 表中将所有更改通知您的程序，并将包括每个已修改文档的旧值和新值。有关如何在RethinkDB中使用实时提要的更多详细信息，请参见&lt;a href=&quot;../../changefeeds/javascript/index&quot;&gt;changefeeds&lt;/a&gt;文档条目。</target>
        </trans-unit>
        <trans-unit id="f968cad894d6556a053a28efbaa35e8a48e757e7" translate="yes" xml:space="preserve">
          <source>RethinkDB will process this query with the following steps:</source>
          <target state="translated">RethinkDB将通过以下步骤处理这个查询。</target>
        </trans-unit>
        <trans-unit id="64b9b5257d87ef3a851f521694a7f625e0295a7e" translate="yes" xml:space="preserve">
          <source>RethinkDB will seamlessly evaluate the &lt;code&gt;js&lt;/code&gt; command by calling into the V8 engine during the evaluation of the &lt;code&gt;filter&lt;/code&gt; query. You can combine most queries this way into progressively more complex ones.</source>
          <target state="translated">RethinkDB将在评估 &lt;code&gt;filter&lt;/code&gt; 查询期间通过调用V8引擎来无缝评估 &lt;code&gt;js&lt;/code&gt; 命令。您可以通过这种方式将大多数查询组合为越来越复杂的查询。</target>
        </trans-unit>
        <trans-unit id="aaa0bfa56109a4dcf6840553fb0b62be795519d3" translate="yes" xml:space="preserve">
          <source>RethinkDB write operations will only throw exceptions if errors occur before any writes. Other errors will be listed in &lt;code&gt;first_error&lt;/code&gt;, and &lt;code&gt;errors&lt;/code&gt; will be set to a non-zero count. To properly handle errors with this term, code must both handle exceptions and check the &lt;code&gt;errors&lt;/code&gt; return value!</source>
          <target state="translated">RethinkDB写操作仅在任何写操作之前发生错误的情况下才会引发异常。其他错误将列在 &lt;code&gt;first_error&lt;/code&gt; 中，并且 &lt;code&gt;errors&lt;/code&gt; 将被设置为非零计数。为了使用该术语正确处理错误，代码必须同时处理异常并检查 &lt;code&gt;errors&lt;/code&gt; 返回值！</target>
        </trans-unit>
        <trans-unit id="34e087373ce7adace20d25fd88b9372fbefa4968" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s GMR queries are distributed and parallelized across shards and CPU cores whenever possible. While this allows them to execute efficiently, it&amp;rsquo;s important to keep in mind that the &lt;code&gt;reduce&lt;/code&gt; function is &lt;em&gt;not&lt;/em&gt; called on the elements of its input stream from left to right. It&amp;rsquo;s called on either the elements of the stream &lt;em&gt;in any order&lt;/em&gt; or on the output of previous calls to the function.</source>
          <target state="translated">RethinkDB的GMR查询尽可能在分片和CPU内核之间分布和并行化。尽管这可以使它们高效执行，但请务必记住，&lt;em&gt;请勿&lt;/em&gt;从左到右在其输入流的元素上调用 &lt;code&gt;reduce&lt;/code&gt; 函数。在流的元素上&lt;em&gt;以任何顺序&lt;/em&gt;调用它，或者在先前对该函数的调用的输出上调用它。&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b133a4402124e33904942b046a7e475fcf7c87c8" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s UUIDs are standards-compliant. Without the optional argument, a version 4 random UUID will be generated; with that argument, a version 5 UUID will be generated, using a fixed namespace UUID of &lt;code&gt;91461c99-f89d-49d2-af96-d8e2e14e9b58&lt;/code&gt;. For more information, read &lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;Wikipedia&amp;rsquo;s UUID article&lt;/a&gt;.</source>
          <target state="translated">RethinkDB的UUID符合标准。如果没有可选参数，将生成版本4随机UUID。使用该参数，将使用固定名称空间UUID &lt;code&gt;91461c99-f89d-49d2-af96-d8e2e14e9b58&lt;/code&gt; 生成版本5 UUID 。有关更多信息，请阅读&lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;Wikipedia的UUID文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0da7bfd7ba58030ff21673f3096c2d4399c90c10" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s automatic failover has limitations in cases of non-transitive connectivity failure, i.e., server A can contact B and B can contact C, but A cannot contact C. Read the &lt;a href=&quot;../failover/index&quot;&gt;Failover&lt;/a&gt; documentation for more details.</source>
          <target state="translated">在非传递性连接失败的情况下，RethinkDB的自动故障转移有局限性，即服务器A可以联系B，B可以联系C，但是A无法联系C。有关详细信息，请参阅&lt;a href=&quot;../failover/index&quot;&gt;故障转移&lt;/a&gt;文档。</target>
        </trans-unit>
        <trans-unit id="f1fe8ed60518c4cc231f66de64be6b6b14e157f1" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s basic data types include numbers, strings, boolean values, objects, arrays, and the &lt;code&gt;null&lt;/code&gt; value. In addition, it stores RethinkDB-specific data types including tables, streams, selections, binary objects, time objects, geometry data types, and grouped data.</source>
          <target state="translated">RethinkDB的基本数据类型包括数字，字符串，布尔值，对象，数组和 &lt;code&gt;null&lt;/code&gt; 值。此外，它存储RethinkDB特定的数据类型，包括表，流，选择，二进制对象，时间对象，几何数据类型和分组数据。</target>
        </trans-unit>
        <trans-unit id="0ca7a8d234327a4022cad363f1285f21bac0f144" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s default settings prioritize safety over performance, except in one case: &lt;code&gt;read_mode&lt;/code&gt; defaults to &lt;code&gt;single&lt;/code&gt; rather than &lt;code&gt;majority&lt;/code&gt;. The &lt;code&gt;majority&lt;/code&gt; read mode requires sending a query to all of the replicas and waiting for a majority to reply, which significantly degrades performance.</source>
          <target state="translated">RethinkDB的默认设置优先级的安全性能上，除了一种情况： &lt;code&gt;read_mode&lt;/code&gt; 默认为 &lt;code&gt;single&lt;/code&gt; ，而不是 &lt;code&gt;majority&lt;/code&gt; 。在 &lt;code&gt;majority&lt;/code&gt; 读模式需要发送查询到所有的副本，并等待广大回复，这显著降低性能。</target>
        </trans-unit>
        <trans-unit id="bb2f37e7edacabf1482154290f8348ef4776073d" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s defaults tend to prioritize safety over performance. One of those defaults is that queries will be sent to the primary replicas for shards, which will always have current data (although that data may be returned to a query before it&amp;rsquo;s been committed to disk).</source>
          <target state="translated">RethinkDB的默认值倾向于优先考虑安全性而不是性能。这些默认值之一是查询将发送到分片的主副本，分片将始终具有当前数据（尽管数据可能会在提交给磁盘之前返回给查询）。</target>
        </trans-unit>
        <trans-unit id="db4c9426f43aa7a8535f8d64ebcc1ea7e3791bc5" translate="yes" xml:space="preserve">
          <source>RethinkDB&amp;rsquo;s page cache keeps recently used data in memory to minimize disk access. By default, RethinkDB automatically configures the cache size limit according to the formula &lt;code&gt;(available_mem - 1024 MB) / 2&lt;/code&gt;. &lt;code&gt;available_mem&lt;/code&gt; is the amount of available memory at the time RethinkDB starts, including memory that can be freed up by the operating system if needed (such as the operating system&amp;rsquo;s disk cache). If there is less than 1224 MB of memory available on the system, a minimum cache size limit of 100 MB is used. You can find the actual size limit used by an instance of RethinkDB in its log.</source>
          <target state="translated">RethinkDB的页面缓存将最近使用的数据保留在内存中，以最大程度地减少磁盘访问。默认情况下，RethinkDB根据公式 &lt;code&gt;(available_mem - 1024 MB) / 2&lt;/code&gt; 自动配置缓存大小限制。 &lt;code&gt;available_mem&lt;/code&gt; 是RethinkDB启动时的可用内存量，包括可以在需要时由操作系统释放的内存（例如操作系统的磁盘缓存）。如果系统上的可用内存少于1224 MB，则使用100 MB的最小高速缓存大小限制。您可以在其日志中找到RethinkDB实例使用的实际大小限制。</target>
        </trans-unit>
        <trans-unit id="653b9779dde232052144d040476ebeef4a8dcaaa" translate="yes" xml:space="preserve">
          <source>RethinkDB-specific data types</source>
          <target state="translated">RethinkDB特有的数据类型</target>
        </trans-unit>
        <trans-unit id="57354ca1c1a9aab463d86135427b774bc928dbcc" translate="yes" xml:space="preserve">
          <source>Retrieve all results and pass them as an array to the given callback.</source>
          <target state="translated">检索所有结果,并将其作为数组传递给给定的回调。</target>
        </trans-unit>
        <trans-unit id="a0800d22e7dc2655702fc5c45eb8eba5b2a4d42c" translate="yes" xml:space="preserve">
          <source>Retrieve all users named &amp;ldquo;William Adama&amp;rdquo; (first name &amp;ldquo;William&amp;rdquo;, last name &amp;ldquo;Adama&amp;rdquo;), and who do not have a middle name.</source>
          <target state="translated">检索所有名为&amp;ldquo; William Adama&amp;rdquo;（名字&amp;ldquo; William&amp;rdquo;，姓氏&amp;ldquo; Adama&amp;rdquo;）且没有中间名的用户。</target>
        </trans-unit>
        <trans-unit id="cec1adbb3f9ef3982a4b34f750d9645287ab990d" translate="yes" xml:space="preserve">
          <source>Retrieve all users named &amp;ldquo;William Adama&amp;rdquo; (first name &amp;ldquo;William&amp;rdquo;, last name &amp;ldquo;Adama&amp;rdquo;), with any middle name.</source>
          <target state="translated">检索所有名称为&amp;ldquo; William Adama&amp;rdquo;（名字为&amp;ldquo; William&amp;rdquo;，姓氏为&amp;ldquo; Adama&amp;rdquo;）的用户，并使用中间名。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
