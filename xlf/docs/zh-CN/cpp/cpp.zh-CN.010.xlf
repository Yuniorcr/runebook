<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="5de0dced78d11272f963c83043ebca189594c138" translate="yes" xml:space="preserve">
          <source>A member of a class &lt;code&gt;T&lt;/code&gt; cannot use &lt;code&gt;T&lt;/code&gt; as its name if the member is a static data member, a member function, a member type, a member template , an enumerator of an unscoped enumeration, a member of a member anonymous union. However, a non-static data member may use the name &lt;code&gt;T&lt;/code&gt; as long as there are no user-declared constructors.</source>
          <target state="translated">如果类 &lt;code&gt;T&lt;/code&gt; 的成员是静态数据成员，成员函数，成员类型，成员模板，无作用域枚举的枚举器，成员匿名联合的成员，则不能使用 &lt;code&gt;T&lt;/code&gt; 作为其名称。但是，只要没有用户声明的构造函数，非静态数据成员就可以使用名称 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4ca9ae096395091286ce2f97b84c334ccf6644c" translate="yes" xml:space="preserve">
          <source>A member or a member template of a class template may be explicitly specialized for a given implicit instantiation of the class template, even if the member or member template is defined in the class template definition.</source>
          <target state="translated">一个类模板的成员或成员模板可以为给定的类模板的隐式实例显式专门化,即使该成员或成员模板是在类模板定义中定义的。</target>
        </trans-unit>
        <trans-unit id="3cc4194447e3feb7759961528ba2acc170fa12c7" translate="yes" xml:space="preserve">
          <source>A modifiable lvalue may be used as the left-hand operand of the built-in assignment and compound assignment operators.</source>
          <target state="translated">一个可修改的l值可以作为内置赋值和复合赋值运算符的左手操作数。</target>
        </trans-unit>
        <trans-unit id="8c00f6a72efb6556fa9292b04ea6629a5f0cab13" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_day&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/1&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;month_day&lt;/code&gt; 的更方便方法是使用 &lt;code&gt;operator/&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e596eb0f0194c2c2e4167ab358138e5b60c14287" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_day_last&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;month_day_last&lt;/code&gt; 的更便捷方法是使用 &lt;code&gt;operator/&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a8c5116dd01717b8a1f75b9620c596b6f5367a7" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_weekday&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[2]&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;month_weekday&lt;/code&gt; 的一种更方便的方法是使用 &lt;code&gt;operator/&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[2]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4752a9f37cdb6658a9a8728cdd2291f0b5ec64d6" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_weekday_last&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;month_weekday_last&lt;/code&gt; 的一种更方便的方法是使用 &lt;code&gt;operator/&lt;/code&gt; ，例如 &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7327a074e15b5c31502879c12e39a884355916ba" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;weekday_indexed&lt;/code&gt; is with &lt;code&gt;weekday&lt;/code&gt;'s &lt;code&gt;operator[]&lt;/code&gt;, i.e., &lt;code&gt;wd[index]&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;weekday_indexed&lt;/code&gt; 的一种更方便的方法是使用 &lt;code&gt;weekday&lt;/code&gt; 的 &lt;code&gt;operator[]&lt;/code&gt; （即 &lt;code&gt;wd[index]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c209a7c3ca3ab0475649b12caaff743d2fbd1dd1" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;weekday_last&lt;/code&gt; is with &lt;code&gt;weekday&lt;/code&gt;'s &lt;code&gt;operator[]&lt;/code&gt;, i.e., &lt;code&gt;wd[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;weekday_last&lt;/code&gt; 的一种更方便的方法是使用 &lt;code&gt;weekday&lt;/code&gt; 的 &lt;code&gt;operator[]&lt;/code&gt; ，即 &lt;code&gt;wd[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="653ca78a80e72fd3496d4da44b432d7ef45908d8" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;year_month&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;2007y/&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">构造 &lt;code&gt;year_month&lt;/code&gt; 的一种更方便的方法是使用 &lt;code&gt;operator/&lt;/code&gt; ，例如 &lt;code&gt;2007y/&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;&lt;/code&gt; chrono :: April。</target>
        </trans-unit>
        <trans-unit id="6f1d73be6c54e98a146e6c453de6dea68f79b357" translate="yes" xml:space="preserve">
          <source>A move assignment operator of class &lt;code&gt;T&lt;/code&gt; is a non-template &lt;a href=&quot;member_functions&quot;&gt;non-static member function&lt;/a&gt; with the name &lt;code&gt;operator=&lt;/code&gt; that takes exactly one parameter of type &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt;, or &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">类 &lt;code&gt;T&lt;/code&gt; 的移动赋值运算符是名称为 &lt;code&gt;operator=&lt;/code&gt; 的非模板&lt;a href=&quot;member_functions&quot;&gt;非静态成员函数&lt;/a&gt;，该函数正好采用类型 &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; ， &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt; ， &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt; 一个参数。</target>
        </trans-unit>
        <trans-unit id="7677c3fc7a7f1b5d05a4ba8d65de62c8c77ad6c9" translate="yes" xml:space="preserve">
          <source>A move constructor of class &lt;code&gt;T&lt;/code&gt; is a non-template &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; whose first parameter is &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt;, or &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt;, and either there are no other parameters, or the rest of the parameters all have default values.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 类的move构造函数是一个非模板&lt;a href=&quot;constructor&quot;&gt;构造函数，&lt;/a&gt;其第一个参数为 &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; ， &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt; ， &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt; ，或者没有其他参数，或者其余参数都具有默认值。</target>
        </trans-unit>
        <trans-unit id="16af80cf4cdc5acb425ed5fb5f2a532dceaaf925" translate="yes" xml:space="preserve">
          <source>A multibyte character string is layout-compatible with null-terminated byte string (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; member functions, &lt;code&gt;&lt;a href=&quot;../locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;, or the following locale-dependent conversion functions:</source>
          <target state="translated">多字节字符串在布局上与空终止字节字符串（NTBS）兼容，也就是说，除了计算字符数外，还可以使用相同的功能进行存储，复制和检查。如果正确的语言环境生效，则I / O函数还将处理多字节字符串。可以使用 &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 成员函数 &lt;code&gt;&lt;a href=&quot;../locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; 或以下依赖于语言环境的转换函数，在宽字符串之间来回转换多字节字符串：</target>
        </trans-unit>
        <trans-unit id="d98fb2bdc836fccaa6d115487be59107743d4bcc" translate="yes" xml:space="preserve">
          <source>A name declared non-deprecated may be redeclared deprecated. A name declared deprecated cannot be un-deprecated by redeclaring it without this attribute.</source>
          <target state="translated">被宣布为非reciprecated的名称可以被重新宣布为deprecated。被宣布为弃用的名称不能通过重新宣布而不使用该属性来解除弃用。</target>
        </trans-unit>
        <trans-unit id="9645e04714e8aeab4e16fb75044a74252ed38005" translate="yes" xml:space="preserve">
          <source>A name first declared in a friend declaration within class or class template X becomes a member of the innermost enclosing namespace of X, but is not visible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at the namespace scope is provided - see &lt;a href=&quot;namespace#Namespaces&quot;&gt;namespaces&lt;/a&gt; for details.</source>
          <target state="translated">首先在类或类模板X的朋友声明中声明的名称成为X的最内层封闭名称空间的成员，但对于查找（对于考虑X的依赖于参数的查找除外）不可见，除非在名称空间范围内的匹配声明为提供- 有关详细信息，请参见&lt;a href=&quot;namespace#Namespaces&quot;&gt;名称空间&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3933fe1919f27704fb38fb769004562260d8099c" translate="yes" xml:space="preserve">
          <source>A name is classified as a member of the current instantiation if it is.</source>
          <target state="translated">一个名称如果是以下情况,则被归类为当前实例的成员:</target>
        </trans-unit>
        <trans-unit id="9ddc18654271b83daffe509c6b14c3572df5edd8" translate="yes" xml:space="preserve">
          <source>A name that denotes object, reference, function, type, template, namespace, or value, may have</source>
          <target state="translated">表示对象、引用、函数、类型、模板、命名空间或值的名称,可以有</target>
        </trans-unit>
        <trans-unit id="853d1578fabbd2c82d82a0fe09f5702733aba960" translate="yes" xml:space="preserve">
          <source>A name that is accessible through multiple paths in the inheritance graph has the access of the path with the most access:</source>
          <target state="translated">通过继承图中的多条路径可以访问的名称,具有访问最多的路径的访问权。</target>
        </trans-unit>
        <trans-unit id="6e45514825dadadd15b3e67c603ee32f7155b58a" translate="yes" xml:space="preserve">
          <source>A name that is private according to unqualified &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, may be accessible through qualified name lookup:</source>
          <target state="translated">根据非限定&lt;a href=&quot;lookup&quot;&gt;名称查找&lt;/a&gt;，私有名称可以通过限定名称查找来访问：</target>
        </trans-unit>
        <trans-unit id="39b86d73926de6a377e6b550b9b013a7e40df60f" translate="yes" xml:space="preserve">
          <source>A namespace member that was declared within a namespace body may be defined or redeclared outside of it using explicit qualification.</source>
          <target state="translated">在命名空间体中声明的命名空间成员可以在命名空间体之外使用显式限定进行定义或重新声明。</target>
        </trans-unit>
        <trans-unit id="039345001a9866dd339fc34b017f987d45772976" translate="yes" xml:space="preserve">
          <source>A narrow character string is created as if by a call to &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(spec, v)&lt;/code&gt; in the &quot;C&quot; locale, where &lt;code&gt;spec&lt;/code&gt; is the chosen conversion specifier.</source>
          <target state="translated">如同在&amp;ldquo; C&amp;rdquo;语言环境中通过调用 &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(spec, v)&lt;/code&gt; 来创建窄字符串一样，其中 &lt;code&gt;spec&lt;/code&gt; 是所选的转换说明符。</target>
        </trans-unit>
        <trans-unit id="105e80128937d46ea748308c3640f225aa1f1163" translate="yes" xml:space="preserve">
          <source>A negative value of &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; causes &lt;code&gt;mktime&lt;/code&gt; to attempt to determine if Daylight Saving Time was in effect.</source>
          <target state="translated">的负值 &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; 使 &lt;code&gt;mktime&lt;/code&gt; 试图确定是否夏令时是效果。</target>
        </trans-unit>
        <trans-unit id="93b6295b9130f095206e2ffbf6e1a198ffb81cdb" translate="yes" xml:space="preserve">
          <source>A nested requirement has the form.</source>
          <target state="translated">嵌套要求的形式是:</target>
        </trans-unit>
        <trans-unit id="aab04a416d50d68103518e61edffcc3d876b52d0" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; object, constructed from correctly copied allocators.</source>
          <target state="translated">从正确复制的分配器构造的新 &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="b3fea0735582c1d92ba9ca4265c504066694d506" translate="yes" xml:space="preserve">
          <source>A newly constructed object of type &lt;code&gt;pos_type&lt;/code&gt; which stores the resulting file position, or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">一个新建的 &lt;code&gt;pos_type&lt;/code&gt; 类型的对象，用于存储生成的文件位置，或者在失败时存储 &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7812e17881f85045a11332d843939ff143d1510b" translate="yes" xml:space="preserve">
          <source>A newly opened stream has no orientation. The first call to &lt;code&gt;std::fwide&lt;/code&gt; or to any I/O function establishes the orientation: wide I/O function makes the stream wide-oriented, narrow I/O function makes the stream narrow-oriented. Once set, orientation can only be changed with &lt;code&gt;&lt;a href=&quot;c/freopen&quot;&gt;std::freopen&lt;/a&gt;&lt;/code&gt;. Narrow I/O functions cannot be called on a wide-oriented stream, wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;std::wcrtomb&lt;/a&gt;&lt;/code&gt;. Unlike the multibyte character strings that are valid in a program, multibyte characters in the file may contain embedded nulls and do not have to begin or end in the initial shift state.</source>
          <target state="translated">新打开的流没有方向。对 &lt;code&gt;std::fwide&lt;/code&gt; 或任何I / O函数的第一次调用将确定方向：Wide I / O函数使流面向宽方向，窄I / O函数使流面向窄方向。设置后，只能使用 &lt;code&gt;&lt;a href=&quot;c/freopen&quot;&gt;std::freopen&lt;/a&gt;&lt;/code&gt; 更改方向。不能在面向宽流的流上调用窄I / O函数，不能在面向窄流的流上调用宽I / O函数。宽I / O函数就像调用 &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;std::wcrtomb&lt;/a&gt;&lt;/code&gt; 一样，在宽字节和多字节字符之间进行转换。与程序中有效的多字节字符串不同，文件中的多字节字符可以包含嵌入的null，而不必在初始移位状态下开始或结束。</target>
        </trans-unit>
        <trans-unit id="869a3424851c79242efec3e07d77e356612111d6" translate="yes" xml:space="preserve">
          <source>A noexcept-specification of a function is considered to be</source>
          <target state="translated">一个函数的noexcept指定被认为是</target>
        </trans-unit>
        <trans-unit id="6aee1e7c886fbccbfdc8526a802aa2e4e5e0f970" translate="yes" xml:space="preserve">
          <source>A non-class non-array prvalue cannot be &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;. (Note: a function call or cast expression may result in a prvalue of non-class cv-qualified type, but the cv-qualifier is immediately stripped out.)</source>
          <target state="translated">非类非数组prvalue不能通过&lt;a href=&quot;cv&quot;&gt;cv限定&lt;/a&gt;。（注意：函数调用或强制转换表达式可能会导致非类cv限定类型的prvalue，但是cv限定符会立即被剥离。）</target>
        </trans-unit>
        <trans-unit id="9c16e8da66b88facf18bcff094f8898640478943" translate="yes" xml:space="preserve">
          <source>A non-const rvalue of type &lt;code&gt;X::node_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X::node_type&lt;/code&gt; 类型的非常量右值</target>
        </trans-unit>
        <trans-unit id="cbfbc01b79d14846f146d50d1446c4035f6cd1b8" translate="yes" xml:space="preserve">
          <source>A non-explicit constructor that accepts an argument of type (possibly const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;, which stores that offset and and value-initializes the state object. This constructor must also accept the special value &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;(-1)&lt;/code&gt;: the &lt;code&gt;std::fpos&lt;/code&gt; constructed in this manner is returned by some stream operations to indicate errors.</source>
          <target state="translated">一个非显式的构造函数，它接受类型为 &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; 的类型（可能为const）的参数，该参数存储该偏移量并通过值初始化状态对象。此构造函数还必须接受特殊值 &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;(-1)&lt;/code&gt; ：一些流操作将以这种方式构造的 &lt;code&gt;std::fpos&lt;/code&gt; 返回以指示错误。</target>
        </trans-unit>
        <trans-unit id="7c5f2f406d4c6d5a6be68be9a352e598e29e63cd" translate="yes" xml:space="preserve">
          <source>A non-member function definition may appear at namespace scope only (there are no nested functions). A &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; definition may also appear in the body of a &lt;a href=&quot;class&quot;&gt;class definition&lt;/a&gt;. They have the following syntax:</source>
          <target state="translated">非成员函数定义只能出现在名称空间范围内（没有嵌套函数）。甲&lt;a href=&quot;member_functions&quot;&gt;成员函数&lt;/a&gt;定义也可能出现在身体&lt;a href=&quot;class&quot;&gt;的类定义&lt;/a&gt;。它们具有以下语法：</target>
        </trans-unit>
        <trans-unit id="a8537e5e8c50ad3a4da6590cf63b9c692c279951" translate="yes" xml:space="preserve">
          <source>A non-placement allocation or deallocation function for a class is odr-used by the definition of a constructor of that class.</source>
          <target state="translated">一个类的非placement分配或deallocation函数是由该类的构造函数定义 odr-使用的。</target>
        </trans-unit>
        <trans-unit id="54709ac99fdc50ecc6383b09c5e6260c6f17f5a9" translate="yes" xml:space="preserve">
          <source>A non-placement deallocation function for a class is odr-used by the definition of the destructor of that class, or by being selected by the lookup at the point of definition of a virtual destructor</source>
          <target state="translated">一个类的非位置分配函数是由该类的destructor定义的odr-使用的,或者是由虚拟destructor定义点的查找选择的。</target>
        </trans-unit>
        <trans-unit id="57427d16d98090f308df82f3319c4bb23d4b400e" translate="yes" xml:space="preserve">
          <source>A non-static member function can be declared with a const, volatile, or const volatile qualifier (this qualifier appears after the parameter list in the &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;). Differently cv-qualified functions have different types and so may overload each other.</source>
          <target state="translated">可以使用const，volatile或const volatile限定符声明非静态成员函数（此限定符出现在&lt;a href=&quot;function&quot;&gt;函数声明中&lt;/a&gt;的参数列表之后）。具有不同cv资格的函数具有不同的类型，因此可能会彼此过载。</target>
        </trans-unit>
        <trans-unit id="6269d14f99ea7d83ea3dec1f28326b8c6d5c5ecd" translate="yes" xml:space="preserve">
          <source>A non-static member function can be declared with no ref-qualifier, with an lvalue ref-qualifier (the token &lt;code&gt;&amp;amp;&lt;/code&gt; after the parameter list) or the rvalue ref-qualifier (the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; after the parameter list). During &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, non-static cv-qualified member function of class X is treated as follows:</source>
          <target state="translated">可以在没有ref限定符的情况下声明非静态成员函数，而不能使用左值ref限定符（参数列表后面的标记 &lt;code&gt;&amp;amp;&lt;/code&gt; ）或右值ref限定符（参数列表后面的标记 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ）。在&lt;a href=&quot;overload_resolution&quot;&gt;重载解析&lt;/a&gt;期间，将按以下方式处理类X的非静态cv限定成员函数：</target>
        </trans-unit>
        <trans-unit id="c58ef98b1f97443f7f30d89e9dea4b508149bdcf" translate="yes" xml:space="preserve">
          <source>A non-static member function is a function that is declared in a &lt;a href=&quot;class&quot;&gt;member specification&lt;/a&gt; of a class without a &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; or &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; specifier.</source>
          <target state="translated">非静态成员函数是在类的&lt;a href=&quot;class&quot;&gt;成员规范&lt;/a&gt;中声明的没有&lt;a href=&quot;static&quot;&gt;静态&lt;/a&gt;或&lt;a href=&quot;friend&quot;&gt;朋友&lt;/a&gt;说明符的函数。</target>
        </trans-unit>
        <trans-unit id="327b4ee07e641d05a96006e2735a0db3601ea014" translate="yes" xml:space="preserve">
          <source>A non-static member function may be declared</source>
          <target state="translated">可以声明一个非静态成员函数</target>
        </trans-unit>
        <trans-unit id="8309388308c23f79d7667a2481e8485faf7c4b76" translate="yes" xml:space="preserve">
          <source>A non-static member function of class X may be called.</source>
          <target state="translated">可以调用类X的一个非静态成员函数。</target>
        </trans-unit>
        <trans-unit id="3dd8b8cff9d7f40f60c773d5633d2a93e250abe4" translate="yes" xml:space="preserve">
          <source>A non-template function is always distinct from a template specialization with the same type. Specializations of different function templates are always distinct from each other even if they have the same type. Two function templates with the same return type and the same parameter list are distinct and can be distinguished with explicit template argument list.</source>
          <target state="translated">一个非模板函数总是不同于具有相同类型的模板特化。不同函数模板的特化总是相互区别的,即使它们具有相同的类型。两个具有相同返回类型和相同参数列表的函数模板是不同的,可以用显式模板参数列表来区分。</target>
        </trans-unit>
        <trans-unit id="ec8d1e0238ca169189cb132939968a32e225940d" translate="yes" xml:space="preserve">
          <source>A non-template member function and a template member function with the same name may be declared. In case of conflict (when some template specialization matches the non-template function signature exactly), use of that name and type refers to the non-template member unless an explicit template argument list is supplied.</source>
          <target state="translated">可以声明一个非模板成员函数和一个同名的模板成员函数。在冲突的情况下(当某些模板特殊化与非模板函数签名完全匹配时),除非提供明确的模板参数列表,否则使用该名称和类型是指非模板成员。</target>
        </trans-unit>
        <trans-unit id="1d14804af608dab04a2318dab2393b02651d54c9" translate="yes" xml:space="preserve">
          <source>A notable implementation where &lt;code&gt;std::random_device&lt;/code&gt; is deterministic is MinGW (&lt;a href=&quot;https://sourceforge.net/p/mingw-w64/bugs/338/&quot;&gt;bug 338&lt;/a&gt;), although replacement implementations exist, such as &lt;a href=&quot;https://github.com/euloanty/mingw-std-random_device&quot;&gt;mingw-std-random_device&lt;/a&gt;.</source>
          <target state="translated">尽管存在替代实现，例如&lt;a href=&quot;https://github.com/euloanty/mingw-std-random_device&quot;&gt;mingw-std-random_device&lt;/a&gt;，但 &lt;code&gt;std::random_device&lt;/code&gt; 是确定性的一个显着实现是MinGW（&lt;a href=&quot;https://sourceforge.net/p/mingw-w64/bugs/338/&quot;&gt;错误338&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="d97541bdffeb4e63b35a3a02617d21fc06220467" translate="yes" xml:space="preserve">
          <source>A null pointer constant may be &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to any pointer type; such conversion results in the null pointer value of that type. If a null pointer constant has integer type, it may be converted to a prvalue of type &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">空指针常量可以&lt;a href=&quot;../language/implicit_cast&quot;&gt;隐式转换&lt;/a&gt;为任何指针类型。这样的转换将导致该类型的空指针值。如果空指针常量具有整数类型，则可以将其转换为 &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 类型的prvalue 。</target>
        </trans-unit>
        <trans-unit id="f1572c78e938eb0e97af4e78573d5ecf38073eb0" translate="yes" xml:space="preserve">
          <source>A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array &lt;code&gt;{'\x63', '\x61', '\x74', '\0'}&lt;/code&gt; is an NTBS holding the string &lt;code&gt;&quot;cat&quot;&lt;/code&gt; in ASCII encoding.</source>
          <target state="translated">空终止字节字符串（NTBS）是一个非零字节序列，后跟一个值为零的字节（终止空字符）。字节字符串中的每个字节编码某个字符集的一个字符。例如，字符数组 &lt;code&gt;{'\x63', '\x61', '\x74', '\0'}&lt;/code&gt; 是一个NTBS，它以ASCII编码保存字符串 &lt;code&gt;&quot;cat&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b3fe15454343ce4cbfa8b2d64edd72623154c83" translate="yes" xml:space="preserve">
          <source>A null-terminated multibyte string (NTMBS), or &quot;multibyte string&quot;, is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).</source>
          <target state="translated">空尾多字节字符串(NTMBS),或 &quot;多字节字符串&quot;,是一个非零字节的序列,后面是一个值为零的字节(终止的空字符)。</target>
        </trans-unit>
        <trans-unit id="d3f369b83e123d7a5137bbdf57df583877994fe3" translate="yes" xml:space="preserve">
          <source>A null-terminated wide string is a sequence of valid wide characters, ending with a null character.</source>
          <target state="translated">空头结束的宽字符串是一个有效的宽字符序列,以空字符结束。</target>
        </trans-unit>
        <trans-unit id="f262d7c58008e0145d059876c3647b11a00b98dc" translate="yes" xml:space="preserve">
          <source>A numeric array containing elements with values obtained by applying corresponding operator to the values in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">一个数字数组，其中包含具有通过将相应的运算符应用于 &lt;code&gt;*this&lt;/code&gt; 中的值而获得的值的元素。</target>
        </trans-unit>
        <trans-unit id="477cf9e2034b21d56b53532edeb5fa0ff54341d3" translate="yes" xml:space="preserve">
          <source>A numeric array containing the results of computation of inverse tangent.</source>
          <target state="translated">一个包含反切计算结果的数字数组。</target>
        </trans-unit>
        <trans-unit id="d991ad4854aaf7bce85259a803aef1efb1b7db52" translate="yes" xml:space="preserve">
          <source>A numeric array containing the results of exponentiation.</source>
          <target state="translated">一个包含指数结果的数字数组。</target>
        </trans-unit>
        <trans-unit id="2b3cfb0c9df6711008dfe1dd42137fa47903d378" translate="yes" xml:space="preserve">
          <source>A numeric array of &lt;code&gt;bool&lt;/code&gt; containing comparison results of corresponding elements.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 的数字数组，其中包含相应元素的比较结果。</target>
        </trans-unit>
        <trans-unit id="bd2bad531f6152b88c43bb2fbb72d8dcd8b7df39" translate="yes" xml:space="preserve">
          <source>A numeric value &lt;code&gt;n&lt;/code&gt; can be converted to a byte value using &lt;code&gt;std::byte{n}&lt;/code&gt;, due to C++17 relaxed enum class initialization rules.</source>
          <target state="translated">由于C ++ 17宽松的枚举类初始化规则，可以使用 &lt;code&gt;std::byte{n}&lt;/code&gt; 将数值 &lt;code&gt;n&lt;/code&gt; 转换为字节值。</target>
        </trans-unit>
        <trans-unit id="c9a28ea00b0028d881fe812f3c217cb4fc954bd0" translate="yes" xml:space="preserve">
          <source>A pack expansion may appear inside the parentheses of a &lt;a href=&quot;direct_initialization&quot;&gt;direct initializer&lt;/a&gt;, a &lt;a href=&quot;explicit_cast&quot;&gt;function-style cast&lt;/a&gt;, and other contexts (&lt;a href=&quot;constructor&quot;&gt;member initializer&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, etc) in which case the rules are identical to the rules for a function call expression above.</source>
          <target state="translated">包扩展可能会出现在&lt;a href=&quot;direct_initialization&quot;&gt;直接初始值设定项&lt;/a&gt;，&lt;a href=&quot;explicit_cast&quot;&gt;函数样式强制转换&lt;/a&gt;和其他上下文（&lt;a href=&quot;constructor&quot;&gt;成员初始值设定项&lt;/a&gt;，&lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;等）的括号内，在这种情况下，规则与上述函数调用表达式的规则相同。</target>
        </trans-unit>
        <trans-unit id="2677c415425384fd8d2e20b4d33138e46186a2e0" translate="yes" xml:space="preserve">
          <source>A pack expansion may appear inside the parentheses of a function call operator, in which case the largest expression or braced-init-list to the left of the ellipsis is the pattern that is expanded.</source>
          <target state="translated">包扩展可能出现在函数调用操作符的括号内,在这种情况下,省略号左侧最大的表达式或括号内的列表就是被扩展的模式。</target>
        </trans-unit>
        <trans-unit id="e1ace690cd25f5f4ab9e5665bb9125a09841bb96" translate="yes" xml:space="preserve">
          <source>A pack expansion may designate the list of base classes in a &lt;a href=&quot;class&quot;&gt;class declaration&lt;/a&gt;. Typically, this also means that the constructor needs to use a pack expansion in the &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; to call the constructors of these bases:</source>
          <target state="translated">包扩展可以在&lt;a href=&quot;class&quot;&gt;类声明中&lt;/a&gt;指定基类列表。通常，这还意味着构造函数需要在&lt;a href=&quot;constructor&quot;&gt;成员初始化程序列表中&lt;/a&gt;使用包扩展来调用以下基础的构造函数：</target>
        </trans-unit>
        <trans-unit id="d479119249c5408ac797bae6fd07fa8962b62780" translate="yes" xml:space="preserve">
          <source>A pair of iterators to the first and one past last positions in [first, last) where a subsequence that compares equal to [pat_first, pat_last) as defined by &lt;code&gt;pred&lt;/code&gt; is located, or a pair of copies of &lt;code&gt;last&lt;/code&gt; otherwise.</source>
          <target state="translated">一对迭代器，它们位于[first，last）的第一个和一个过去的最后一个位置，在该处有一个 &lt;code&gt;pred&lt;/code&gt; 定义的等于[pat_first，pat_last）的子序列，否则为一对 &lt;code&gt;last&lt;/code&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="92fbc534b58c32d1abb15ac3dd6e84d9ec347ad8" translate="yes" xml:space="preserve">
          <source>A pair whose first element is an iterator to the element past the last element moved in the source range, and whose second element is an iterator to the element past the last element moved in the destination range.</source>
          <target state="translated">一个对,它的第一个元素是迭代到在源范围内最后移动的元素,第二个元素是迭代到在目的范围内最后移动的元素。</target>
        </trans-unit>
        <trans-unit id="2e2beaabd453f4099778dc9501c74c786e364ee1" translate="yes" xml:space="preserve">
          <source>A parameter declaration in a function declaration that isn't a definition</source>
          <target state="translated">在函数声明中的参数声明,不是一个定义</target>
        </trans-unit>
        <trans-unit id="0076d34b706ead6a1662fb14d4690ea4e30b8030" translate="yes" xml:space="preserve">
          <source>A parameter pack may appear in the capture clause of a &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; expression.</source>
          <target state="translated">参数包可能出现在&lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt;表达式的capture子句中。</target>
        </trans-unit>
        <trans-unit id="9b45675f6742158d4e1ce1e4e41d58001eb61fb1" translate="yes" xml:space="preserve">
          <source>A path can be</source>
          <target state="translated">一个路径可以是</target>
        </trans-unit>
        <trans-unit id="8d3919f5b58d9be3b1d118858e1954d6017bb744" translate="yes" xml:space="preserve">
          <source>A path of execution is deemed to include a label if and only if it contains a jump to that label:</source>
          <target state="translated">如果且仅当一个执行路径包含一个跳转到该标签时,该路径才会被视为包含一个标签。</target>
        </trans-unit>
        <trans-unit id="cc3d18d57e43e7c1a9f4ffb652c5171bd83b4d2f" translate="yes" xml:space="preserve">
          <source>A pattern consisting of a sign with no digits following it is treated as pattern that did not match anything.</source>
          <target state="translated">由后面没有数字的符号组成的模式,将被视为不匹配的模式。</target>
        </trans-unit>
        <trans-unit id="8746ca0afe0288d6db6ce87470f68b70a4fdf43e" translate="yes" xml:space="preserve">
          <source>A pattern followed by an ellipsis, in which the name of at least one parameter pack appears at least once, is</source>
          <target state="translated">一个带省略号的模式,其中至少有一个参数包的名称至少出现一次,就是</target>
        </trans-unit>
        <trans-unit id="9ca2d1d59088c7c3b22db69dff86c0c2b3191b10" translate="yes" xml:space="preserve">
          <source>A placeholder type specifier may appear in the following contexts:</source>
          <target state="translated">占位符类型指定器可以出现在以下情况下。</target>
        </trans-unit>
        <trans-unit id="cbee5c61daad736bbf4e77a8621940e9b34e3473" translate="yes" xml:space="preserve">
          <source>A plain integer is accepted if its meaning is unambiguous from the types of other operands: &lt;code&gt;2005y/4/5&lt;/code&gt; is allowed, but &lt;code&gt;5/April/2005&lt;/code&gt; is not.</source>
          <target state="translated">如果纯整数的含义与其他操作数的类型没有 &lt;code&gt;2005y/4/5&lt;/code&gt; 接受该纯整数：允许使用2005y / 4/5，但不允许使用 &lt;code&gt;5/April/2005&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fec8de0bf924bd134d73493ee3f200fd0ba8a2d5" translate="yes" xml:space="preserve">
          <source>A pointer declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">指针声明是其&lt;a href=&quot;declarations&quot;&gt;声明符&lt;/a&gt;具有形式的任何简单声明。</target>
        </trans-unit>
        <trans-unit id="e616d2d8a65fe8ffec77841c511375e1b8f9b0c3" translate="yes" xml:space="preserve">
          <source>A pointer or a reference to the current element.</source>
          <target state="translated">指向当前元素的指针或引用。</target>
        </trans-unit>
        <trans-unit id="76ac2aea4079c4a955b7660eae02edd433a9fd7c" translate="yes" xml:space="preserve">
          <source>A pointer or reference to the current match.</source>
          <target state="translated">指向当前匹配的指针或引用。</target>
        </trans-unit>
        <trans-unit id="ab95db86866612e103ecab472411fe9d5d6b7a23" translate="yes" xml:space="preserve">
          <source>A pointer that points to an object</source>
          <target state="translated">指向一个对象的指针</target>
        </trans-unit>
        <trans-unit id="4c96343afd2f0777da9cdc63088d337b0fc36123" translate="yes" xml:space="preserve">
          <source>A pointer to (possibly &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;-qualified) &lt;code&gt;void&lt;/code&gt; cannot be dereferenced. Pointers to other incomplete types can be dereferenced, but the resulting lvalue can only be used in contexts that allow an lvalue of incomplete type, e.g. when initializing a reference.</source>
          <target state="translated">指向（可能是&lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;限定的） &lt;code&gt;void&lt;/code&gt; 的指针不能被取消引用。可以取消对其他不完整类型的指针的引用，但是所得的左值只能在允许不完整类型的左值的上下文中使用，例如，在初始化引用时。</target>
        </trans-unit>
        <trans-unit id="d01181d4498df4cf0f8003b09ba8e09b3c553181" translate="yes" xml:space="preserve">
          <source>A pointer to &lt;code&gt;void&lt;/code&gt; cannot be deleted because it is not a pointer to a complete object type.</source>
          <target state="translated">指向 &lt;code&gt;void&lt;/code&gt; 的指针不能删除，因为它不是指向完整对象类型的指针。</target>
        </trans-unit>
        <trans-unit id="9f73f5e3d4de4e157b8dccf9da808fedaf2b59de" translate="yes" xml:space="preserve">
          <source>A pointer to a standard-layout class may be converted (with reinterpret_cast) to a pointer to its first non-static data member and vice versa.</source>
          <target state="translated">一个指向标准布局类的指针可以被转换(使用reinterpret_cast)为指向它的第一个非静态数据成员的指针,反之亦然。</target>
        </trans-unit>
        <trans-unit id="705e66bb80cbfe8e2e8b61352ddc175ed95890e9" translate="yes" xml:space="preserve">
          <source>A pointer to allocated storage of at least &lt;code&gt;bytes&lt;/code&gt; bytes in size, aligned to the specified &lt;code&gt;alignment&lt;/code&gt; if such alignment is supported, and to &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; otherwise.</source>
          <target state="translated">指向已分配存储空间的指针，该指针的大小至少为 &lt;code&gt;bytes&lt;/code&gt; 字节，如果支持这种对齐方式，则对齐到指定的 &lt;code&gt;alignment&lt;/code&gt; 否则，指向 &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9e5f21a34ce522aab5ca357e2281d794f6f56ab" translate="yes" xml:space="preserve">
          <source>A pointer to an element of an array satisfies all requirements of LegacyContiguousIterator.</source>
          <target state="translated">一个指向数组元素的指针满足LegacyContiguousIterator的所有要求。</target>
        </trans-unit>
        <trans-unit id="2dabfa7c1aee6ff19a8d014db29f4e03389ef1ab" translate="yes" xml:space="preserve">
          <source>A pointer to an element of an array satisfies all requirements of LegacyRandomAccessIterator.</source>
          <target state="translated">指向数组元素的指针满足LegacyRandomAccessIterator的所有要求。</target>
        </trans-unit>
        <trans-unit id="bf53771350311775a7859918261dd7a4cabe6a6f" translate="yes" xml:space="preserve">
          <source>A pointer to an object of standard-layout class type can be &lt;a href=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; to pointer to its first non-static non-bitfield data member (if it has non-static data members) or otherwise any of its base class subobjects (if it has any), and vice versa. In other words, padding is not allowed before the first data member of a standard-layout type. Note that &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;strict aliasing&lt;/a&gt; rules still apply to the result of such cast.</source>
          <target state="translated">可以将指向标准布局类类型的对象的指针&lt;a href=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt;指向为其第一个非静态非位域数据成员（如果它具有非静态数据成员）或其他任何基类子对象（如果它具有任何对象）的指针。 ），反之亦然。换句话说，在标准布局类型的第一个数据成员之前不允许填充。请注意，&lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;严格的别名&lt;/a&gt;规则仍适用于此类转换的结果。</target>
        </trans-unit>
        <trans-unit id="c433adb64c0845bb1339f1da97f3f437a44c4418" translate="yes" xml:space="preserve">
          <source>A pointer to function can be initialized with an address of a non-member function or a static member function. Because of the &lt;a href=&quot;implicit_cast&quot;&gt;function-to-pointer&lt;/a&gt; implicit conversion, the address-of operator is optional:</source>
          <target state="translated">可以使用非成员函数或静态成员函数的地址来初始化指向函数的指针。由于&lt;a href=&quot;implicit_cast&quot;&gt;函数到指针的&lt;/a&gt;隐式转换，address-of运算符是可选的：</target>
        </trans-unit>
        <trans-unit id="fee552ad23a470ee0488c57dc099836dec669c19" translate="yes" xml:space="preserve">
          <source>A pointer to function can be used as the left-hand operand of the &lt;a href=&quot;operator_other&quot;&gt;function call operator&lt;/a&gt;, this invokes the pointed-to function:</source>
          <target state="translated">指向函数的指针可用作&lt;a href=&quot;operator_other&quot;&gt;函数调用操作符&lt;/a&gt;的左侧操作数，这将调用指向的函数：</target>
        </trans-unit>
        <trans-unit id="099c10c4969aca0ed60f063fd0510673f35f2754" translate="yes" xml:space="preserve">
          <source>A pointer to function may be initialized from an overload set which may include functions, function template specializations, and function templates, if only one overload matches the type of the pointer (see &lt;a href=&quot;overloaded_address&quot;&gt;address of an overloaded function&lt;/a&gt; for more detail):</source>
          <target state="translated">如果只有一个重载与指针的类型相匹配，则可以从重载集合初始化指向函数的指针，该重载集合可以包括函数，函数模板专门化和功能模板（有关更多详细信息，请参见&lt;a href=&quot;overloaded_address&quot;&gt;重载函数的地址&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="8f1bfae7aedabc69e7b7058df026de700a35db9f" translate="yes" xml:space="preserve">
          <source>A pointer to non-array object is treated as a pointer to the first element of an array with size 1.</source>
          <target state="translated">非数组对象的指针被视为指向大小为1的数组第一个元素的指针。</target>
        </trans-unit>
        <trans-unit id="cb38a2b02a68bb7fc07ad522e4391fd787512883" translate="yes" xml:space="preserve">
          <source>A pointer to non-static member function &lt;code&gt;f&lt;/code&gt; which is a member of class &lt;code&gt;C&lt;/code&gt; can be initialized with the expression &lt;code&gt;&amp;amp;C::f&lt;/code&gt; exactly. Expressions such as &lt;code&gt;&amp;amp;(C::f)&lt;/code&gt; or &lt;code&gt;&amp;amp;f&lt;/code&gt; inside C's member function do not form pointers to member functions.</source>
          <target state="translated">可以使用表达式 &lt;code&gt;&amp;amp;C::f&lt;/code&gt; 完全初始化指向类 &lt;code&gt;C&lt;/code&gt; 成员的非静态成员函数 &lt;code&gt;f&lt;/code&gt; 的指针。表达式如 &lt;code&gt;&amp;amp;(C::f)&lt;/code&gt; 或 &lt;code&gt;&amp;amp;f&lt;/code&gt; C'S成员函数的内部不形成指针的成员函数。</target>
        </trans-unit>
        <trans-unit id="53cf9e67e880a7f25905f2424504dd5b25bc02f1" translate="yes" xml:space="preserve">
          <source>A pointer to non-static member object &lt;code&gt;m&lt;/code&gt; which is a member of class &lt;code&gt;C&lt;/code&gt; can be initialized with the expression &lt;code&gt;&amp;amp;C::m&lt;/code&gt; exactly. Expressions such as &lt;code&gt;&amp;amp;(C::m)&lt;/code&gt; or &lt;code&gt;&amp;amp;m&lt;/code&gt; inside C's member function do not form pointers to members.</source>
          <target state="translated">可以使用表达式 &lt;code&gt;&amp;amp;C::m&lt;/code&gt; 完全初始化指向类 &lt;code&gt;C&lt;/code&gt; 成员的非静态成员对象 &lt;code&gt;m&lt;/code&gt; 的指针。表达式如 &lt;code&gt;&amp;amp;(C::m)&lt;/code&gt; 或 &lt;code&gt;&amp;amp;m&lt;/code&gt; C'S成员函数的内部不形成成员指针。</target>
        </trans-unit>
        <trans-unit id="4605388fefbc6745ad5fb4ab3501853f9b2e59ca" translate="yes" xml:space="preserve">
          <source>A pointer to object can be initialized with the return value of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; applied to any expression of object type, including another pointer type:</source>
          <target state="translated">可以使用应用于对象类型的任何表达式（包括另一种指针类型）的&lt;a href=&quot;operator_member_access&quot;&gt;address-of运算符&lt;/a&gt;的返回值来初始化指向对象的指针：</target>
        </trans-unit>
        <trans-unit id="cb0b45c2fb8692553e4131bcd61d0db96c449b86" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the local time zone of the computer.</source>
          <target state="translated">指向此数据库中 &lt;code&gt;std::chrono::time_zone&lt;/code&gt; 指针，该指针代表计算机的本地时区。</target>
        </trans-unit>
        <trans-unit id="109ab033a06ddd191eedf4e6243ebdbfa781c50d" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the time zone designated by &lt;code&gt;tz_name&lt;/code&gt;.</source>
          <target state="translated">指向此数据库中 &lt;code&gt;std::chrono::time_zone&lt;/code&gt; 指针，该指针代表 &lt;code&gt;tz_name&lt;/code&gt; 指定的时区。</target>
        </trans-unit>
        <trans-unit id="7186294424331f7f2da77bb5b939c2393a738e08" translate="yes" xml:space="preserve">
          <source>A pointer to the allocated and constructed object.</source>
          <target state="translated">指向分配和构造对象的指针。</target>
        </trans-unit>
        <trans-unit id="90fab4aff09dede56fdb6d84059c3624b3b99e4c" translate="yes" xml:space="preserve">
          <source>A pointer to the allocated storage.</source>
          <target state="translated">指向分配的存储空间的指针。</target>
        </trans-unit>
        <trans-unit id="84ca1216b138fa1171353f37562e84b5694e8e55" translate="yes" xml:space="preserve">
          <source>A pointer to the beginning of the sequence.</source>
          <target state="translated">指针指向序列的开始。</target>
        </trans-unit>
        <trans-unit id="34743a200c5640f215061cfae8958c69a6b3ced4" translate="yes" xml:space="preserve">
          <source>A pointer to the block of memory containing the elements of the container.</source>
          <target state="translated">指向包含容器元素的内存块的指针。</target>
        </trans-unit>
        <trans-unit id="a8d3f2979c65ac771376f7686ffa1017464bd622" translate="yes" xml:space="preserve">
          <source>A pointer to the first character in the range specified by &lt;code&gt;[p, p + count)&lt;/code&gt; that compares equal to &lt;code&gt;ch&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if not found.</source>
          <target state="translated">指向由 &lt;code&gt;[p, p + count)&lt;/code&gt; 指定的范围内的第一个字符的指针，该字符等于 &lt;code&gt;ch&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 如果找不到则为。</target>
        </trans-unit>
        <trans-unit id="85748d7d2f8b08c1130cce69c2693bdbf36686d5" translate="yes" xml:space="preserve">
          <source>A pointer to the first element in the classification table (which an array of size &lt;code&gt;std::ctype&amp;lt;char&amp;gt;::table_size&lt;/code&gt;).</source>
          <target state="translated">指向分类表中第一个元素的指针（分类表的大小为 &lt;code&gt;std::ctype&amp;lt;char&amp;gt;::table_size&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6d6f48b5d05090c0288e98d43d8a863e8b2c04b8" translate="yes" xml:space="preserve">
          <source>A pointer to the owned deleter or &lt;code&gt;nullptr&lt;/code&gt;. The returned pointer is valid at least as long as there remains at least one &lt;code&gt;shared_ptr&lt;/code&gt; instance that owns it.</source>
          <target state="translated">指向拥有的删除器或 &lt;code&gt;nullptr&lt;/code&gt; 的指针。返回的指针至少在至少一个拥有它的 &lt;code&gt;shared_ptr&lt;/code&gt; 实例时才有效。</target>
        </trans-unit>
        <trans-unit id="b50fe0059480635f66a814d6c4000336f99ae375" translate="yes" xml:space="preserve">
          <source>A pointer to the stored function if &lt;code&gt;target_type() == typeid(T)&lt;/code&gt;, otherwise a null pointer.</source>
          <target state="translated">如果 &lt;code&gt;target_type() == typeid(T)&lt;/code&gt; ，则指向存储函数的指针，否则为空指针。</target>
        </trans-unit>
        <trans-unit id="fe7ecdbac553ec91128d6f72f68f35f00624e049" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying character array.</source>
          <target state="translated">指向底层字符数组的指针。</target>
        </trans-unit>
        <trans-unit id="890ea029c831a738d852daab1692736f467e7a47" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying character storage.</source>
          <target state="translated">一个指向底层字符存储的指针。</target>
        </trans-unit>
        <trans-unit id="7a202c804155efff22e9a4e471438c6dbf2d98d3" translate="yes" xml:space="preserve">
          <source>A possible implementation of this class is.</source>
          <target state="translated">这个类的一个可能的实现是:</target>
        </trans-unit>
        <trans-unit id="bc77f50c4833701227ea3422c38b612aa4fdfe9d" translate="yes" xml:space="preserve">
          <source>A possible use for &lt;code&gt;std::condition_variable_any&lt;/code&gt; with custom &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; types is to provide convenient interruptible waits: the custom lock operation would both lock the associated mutex as expected, and also perform the necessary setup to notify this condition variable when the interrupting signal is received.&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;condition_variable_any#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">具有自定义&lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt;类型的 &lt;code&gt;std::condition_variable_any&lt;/code&gt; 可能用途是提供方便的可中断等待：自定义锁定操作将按预期锁定相关的互斥锁，并在接收到中断信号时执行必要的设置以通知此条件变量。&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;condition_variable_any#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0c4ca9f04ce9075912ba0b19bfb872f73c52baa7" translate="yes" xml:space="preserve">
          <source>A possibly const value of type &lt;code&gt;X::key_compare&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;X::key_compare&lt;/code&gt; 可能是const值</target>
        </trans-unit>
        <trans-unit id="7916eb952414b9a1c31b5a2dafada3b876f5ad6e" translate="yes" xml:space="preserve">
          <source>A precondition of this function is that &lt;code&gt;[first, n_first)&lt;/code&gt; and &lt;code&gt;[n_first, last)&lt;/code&gt; are valid ranges.</source>
          <target state="translated">此功能的前提条件是 &lt;code&gt;[first, n_first)&lt;/code&gt; 和 &lt;code&gt;[n_first, last)&lt;/code&gt; 是有效范围。</target>
        </trans-unit>
        <trans-unit id="b6b696e16fd55d74c0cbd8840d4be4cbde76e009" translate="yes" xml:space="preserve">
          <source>A primitive static vector class, demonstrating creation, access, and destruction of objects in aligned storage.</source>
          <target state="translated">一个原始的静态向量类,展示了对齐存储中对象的创建、访问和销毁。</target>
        </trans-unit>
        <trans-unit id="9f03356025d9d886dc6751b026e010eaa4c75c65" translate="yes" xml:space="preserve">
          <source>A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.</source>
          <target state="translated">优先级队列是一个容器适配器,它以牺牲对数插入和提取为代价,提供最大(默认)元素的恒时查找。</target>
        </trans-unit>
        <trans-unit id="aa89f91f3d3f3e8b505f31100bf86fa2ca7b655c" translate="yes" xml:space="preserve">
          <source>A private member of a class can only be accessed by the members and friends of that class, regardless of whether the members are on the same or different instances:</source>
          <target state="translated">一个类的私有成员只能被该类的成员和朋友访问,无论成员是在同一个实例还是不同的实例上。</target>
        </trans-unit>
        <trans-unit id="da9d03016a24905e53207d2ba428a1b8e9a9aaf7" translate="yes" xml:space="preserve">
          <source>A program is not required to call the destructor of an object to end its lifetime if the object is &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;trivially-destructible&lt;/a&gt; or if the program does not rely on the side effects of the destructor. However, if a program ends the lifetime of an non-trivial object explicitly, it must ensure that a new object of the same type is constructed in-place (e.g. via placement new) before the destructor may be called implicitly, i.e. due to scope exit or exception for automatic objects, due to thread exit for thread-local objects, or due to program exit for static objects; otherwise the behavior is undefined.</source>
          <target state="translated">如果对象是&lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;可微毁灭的，&lt;/a&gt;或者程序不依赖于析构函数的副作用，则不需要程序调用该对象的析构函数来终止其生存期。但是，如果程序显式结束了一个非平凡对象的生存期，则它必须确保在隐式调用析构函数之前（即由于范围而定）就地构造了相同类型的新对象（例如，通过new放置）。由于线程本地对象的线程退出，或由于静态对象的程序退出，自动对象的退出或异常；否则，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="03089f15ead7ca5ed65d816afebaddda671b3974" translate="yes" xml:space="preserve">
          <source>A program may be translated with one of three</source>
          <target state="translated">一个程序可以通过以下三种方式之一进行翻译</target>
        </trans-unit>
        <trans-unit id="66c3ecf22ff81745bed14260f746ab81e7c0d0a2" translate="yes" xml:space="preserve">
          <source>A program may be translated with one of two</source>
          <target state="translated">一个程序可以通过以下两种方式之一进行翻译</target>
        </trans-unit>
        <trans-unit id="5a764d00cd6118dc37146370c6388538e41d1085" translate="yes" xml:space="preserve">
          <source>A program may not specialize &lt;code&gt;basic_common_reference&lt;/code&gt; on the third or fourth parameters, nor may it specialize &lt;code&gt;common_reference&lt;/code&gt; itself. A program that adds specializations in violation of these rules has undefined behavior.</source>
          <target state="translated">程序可能并不是专门 &lt;code&gt;basic_common_reference&lt;/code&gt; 上的第三或第四参数，也不得专门 &lt;code&gt;common_reference&lt;/code&gt; 本身。违反这些规则添加专业化的程序具有未定义的行为。</target>
        </trans-unit>
        <trans-unit id="17328f55bfa3f5f5c88fbe4c9f98cf4b5f272bc0" translate="yes" xml:space="preserve">
          <source>A program may specialize &lt;code&gt;basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;&lt;/code&gt; on the first two parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; are both true and at least one of them depends on a program-defined type.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;T，&lt;a href=&quot;decay&quot;&gt;std :: decay_t&lt;/a&gt; &amp;lt;T &amp;gt;&amp;gt;和 &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;U，&lt;a href=&quot;decay&quot;&gt;std :: decay_t&lt;/a&gt;，则程序可以在前两个参数 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 上专门设置 &lt;code&gt;basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;&lt;/code&gt; &amp;lt;U &amp;gt;&amp;gt;均为true，并且其中至少一个取决于程序定义的类型。</target>
        </trans-unit>
        <trans-unit id="8e61a356e3234eed06fa2f0f5dee899601ee82c6" translate="yes" xml:space="preserve">
          <source>A program may specialize &lt;code&gt;clock_time_conversion&lt;/code&gt; if at least one of the template parameters is a user-defined clock type.</source>
          <target state="translated">如果模板参数中的至少一个是用户定义的时钟类型，则程序可以专用于 &lt;code&gt;clock_time_conversion&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97b63352c2d736a021395385f10f9bb467d6e3fd" translate="yes" xml:space="preserve">
          <source>A program shall contain a global function named &lt;code&gt;main&lt;/code&gt;, which is the designated start of the program. It shall have one of the following forms:</source>
          <target state="translated">程序应包含一个名为 &lt;code&gt;main&lt;/code&gt; 的全局函数，这是程序的指定开始。它应具有以下形式之一：</target>
        </trans-unit>
        <trans-unit id="5437280a6191901c16079ac8f80aff7f070d8c2f" translate="yes" xml:space="preserve">
          <source>A program that adds &lt;code&gt;common_type&lt;/code&gt; specializations in violation of these rules has undefined behavior.</source>
          <target state="translated">违反这些规则的情况下添加 &lt;code&gt;common_type&lt;/code&gt; 专业化的程序具有未定义的行为。</target>
        </trans-unit>
        <trans-unit id="7fee44e17e3a13581354a330d85e96728e00f4bd" translate="yes" xml:space="preserve">
          <source>A protected member of a class &lt;code&gt;Base&lt;/code&gt; can only be accessed.</source>
          <target state="translated">只能访问 &lt;code&gt;Base&lt;/code&gt; 类的受保护成员。</target>
        </trans-unit>
        <trans-unit id="87b080a926e158a236034e081054063e31488155" translate="yes" xml:space="preserve">
          <source>A prvalue cannot be &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;: the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of the object it identifies is always the type of the expression.</source>
          <target state="translated">一个prvalue不能是&lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;多态的&lt;/a&gt;：它所标识的对象的&lt;a href=&quot;type-id#Dynamic_type&quot;&gt;动态类型&lt;/a&gt;始终是表达式的类型。</target>
        </trans-unit>
        <trans-unit id="948c7440ba50ed3eb424033ba764365ffa6afd0f" translate="yes" xml:space="preserve">
          <source>A prvalue cannot have &lt;a href=&quot;abstract_class&quot;&gt;abstract class type&lt;/a&gt; or an array thereof.</source>
          <target state="translated">prvalue不能具有&lt;a href=&quot;abstract_class&quot;&gt;抽象类类型&lt;/a&gt;或其数组。</target>
        </trans-unit>
        <trans-unit id="9922e8eeb154c6c0744ee9e4ba026d8fb5b557df" translate="yes" xml:space="preserve">
          <source>A prvalue cannot have &lt;a href=&quot;type-id#Incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (except for type void, see below, or when used in &lt;a href=&quot;decltype&quot;&gt;decltype specifier&lt;/a&gt;)</source>
          <target state="translated">一个prvalue不能有&lt;a href=&quot;type-id#Incomplete_type&quot;&gt;不完整的类型&lt;/a&gt;（void 类型除外，请参阅下文，或在&lt;a href=&quot;decltype&quot;&gt;decltype说明符中使用时&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="89adcc7246c411786e22055f1d4bc6dc797ab523" translate="yes" xml:space="preserve">
          <source>A prvalue of integer or unscoped enumeration type can be converted to a prvalue of any floating-point type. If the value cannot be represented correctly, it is implementation defined whether the closest higher or the closest lower representable value will be selected, although if IEEE arithmetic is supported, rounding defaults &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;to nearest&lt;/a&gt;. If the value cannot fit into the destination type, the behavior is undefined. If the source type is &lt;code&gt;bool&lt;/code&gt;, the value &lt;code&gt;false&lt;/code&gt; is converted to zero, and the value &lt;code&gt;true&lt;/code&gt; is converted to one.</source>
          <target state="translated">整数或无作用域枚举类型的prvalue可以转换为任何浮点类型的prvalue。如果无法正确表示该值，则由实现方式定义是选择最接近的较高值还是最接近的较低可表示值，尽管如果支持IEEE算术，则四舍五入默认&lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;为Nearest&lt;/a&gt;。如果该值不能适合目标类型，则行为未定义。如果源类型为 &lt;code&gt;bool&lt;/code&gt; ，则值 &lt;code&gt;false&lt;/code&gt; 转换为零，值 &lt;code&gt;true&lt;/code&gt; 转换为1。</target>
        </trans-unit>
        <trans-unit id="1cc331b941fd7c1d4179b58d5442419123db000e" translate="yes" xml:space="preserve">
          <source>A prvalue of type pointer to member of cv-qualified type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;X&lt;/code&gt; can be converted to a prvalue pointer to member of more cv-qualified type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">类型的指针，以CV-限定类型的部件A prvalue &lt;code&gt;T&lt;/code&gt; 类 &lt;code&gt;X&lt;/code&gt; 可以转换为一个prvalue指针更CV-限定类型的构件 &lt;code&gt;T&lt;/code&gt; 类 &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3def19238902e53ffc0e7c4199b58d0948a3fce" translate="yes" xml:space="preserve">
          <source>A prvalue of type pointer to non-throwing member function can be converted to a prvalue pointer to potentially-throwing member function.</source>
          <target state="translated">一个指向非抛出成员函数类型指针的prvalue可以转换为指向潜在抛出成员函数的prvalue指针。</target>
        </trans-unit>
        <trans-unit id="e4ca3c60807a21440fb680870f4faa7d3f0b6ab5" translate="yes" xml:space="preserve">
          <source>A prvalue pointer to a (optionally cv-qualified) derived class type can be converted to a prvalue pointer to its (identically cv-qualified) base class. If the base class is inaccessible or ambiguous, the conversion is ill-formed (won't compile). The result of the conversion is a pointer to the base class subobject within the pointed-to object. The null pointer value is converted to the null pointer value of the destination type.</source>
          <target state="translated">一个指向(可选择cv限定的)派生类类型的prvalue指针可以被转换为指向它的(相同cv限定的)基类的prvalue指针。如果基类不可访问或含糊不清,则转换是不正规的(不会编译)。转换的结果是指向指向对象内的基类子对象的指针。空指针值被转换为目的类型的空指针值。</target>
        </trans-unit>
        <trans-unit id="b68c522f33b2f282c51184b2111938ab2a45c6a2" translate="yes" xml:space="preserve">
          <source>A pseudo-random number in [&lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt;].</source>
          <target state="translated">[ &lt;code&gt;min()&lt;/code&gt; ， &lt;code&gt;max()&lt;/code&gt; ]中的伪随机数。</target>
        </trans-unit>
        <trans-unit id="518c2995944086d5bc64a89e68ef8ff2eda028d4" translate="yes" xml:space="preserve">
          <source>A public member of a class is accessible everywhere.</source>
          <target state="translated">一个类的公共成员是可以到处访问的。</target>
        </trans-unit>
        <trans-unit id="a237039e9334b0659fe3de5e7abb2fcf04116a22" translate="yes" xml:space="preserve">
          <source>A pure virtual function is a &lt;a href=&quot;virtual&quot;&gt;virtual function&lt;/a&gt; whose &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; has the following syntax:</source>
          <target state="translated">纯虚函数是其&lt;a href=&quot;function&quot;&gt;声明符&lt;/a&gt;具有以下语法的&lt;a href=&quot;virtual&quot;&gt;虚函数&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="d2a131b189a54243081396040bed210dca58fe18" translate="yes" xml:space="preserve">
          <source>A qualified name that appears in</source>
          <target state="translated">中出现的限定名称。</target>
        </trans-unit>
        <trans-unit id="f00c1c26af032f164f98a00ceb65858c99c608e2" translate="yes" xml:space="preserve">
          <source>A qualified name that is used as a &lt;a href=&quot;declarations#Specifiers&quot;&gt;declaration specifier&lt;/a&gt; in the (top-level) decl-specifier-seq of:</source>
          <target state="translated">在（顶级）decl-specifier-seq中用作&lt;a href=&quot;declarations#Specifiers&quot;&gt;声明说明符&lt;/a&gt;的限定名称：</target>
        </trans-unit>
        <trans-unit id="234e75018942daa7d9ddc6b7ab239081b75bbb61" translate="yes" xml:space="preserve">
          <source>A random number distribution post-processes the output of a URBG in such a way that resulting output is distributed according to a defined statistical probability density function.</source>
          <target state="translated">随机数分布对URBG的输出进行后处理,使输出结果按照定义的统计概率密度函数分布。</target>
        </trans-unit>
        <trans-unit id="63c005a6e5fbfc7dc8af621e2d17685667135352" translate="yes" xml:space="preserve">
          <source>A random number engine is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.</source>
          <target state="translated">随机数引擎是一个返回无符号整数值的函数对象,使可能结果范围内的每个值都具有(理想的)相等的概率。</target>
        </trans-unit>
        <trans-unit id="218114a7bf5a72fb79f4bcfba1ca863f66fc080d" translate="yes" xml:space="preserve">
          <source>A random number generator may satisfy &lt;code&gt;Invocable&lt;/code&gt; but cannot satisfy &lt;code&gt;RegularInvocable&lt;/code&gt; (&lt;a href=&quot;https://xkcd.com/221/&quot;&gt;comical&lt;/a&gt;&lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;ones&lt;/a&gt; excluded).</source>
          <target state="translated">随机数发生器可满足 &lt;code&gt;Invocable&lt;/code&gt; 的，但不能满足 &lt;code&gt;RegularInvocable&lt;/code&gt; （&lt;a href=&quot;https://xkcd.com/221/&quot;&gt;滑稽&lt;/a&gt;&lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;那些&lt;/a&gt;除外）。</target>
        </trans-unit>
        <trans-unit id="c8740cda35197e3b7986bfb9d3958a23da53121b" translate="yes" xml:space="preserve">
          <source>A random number uniformly distributed in [&lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt;].</source>
          <target state="translated">均匀分布在[ &lt;code&gt;min()&lt;/code&gt; ， &lt;code&gt;max()&lt;/code&gt; ]中的随机数。</target>
        </trans-unit>
        <trans-unit id="c6c8fb5e09b78d7ba8993d92c01b80b6ecf577e7" translate="yes" xml:space="preserve">
          <source>A range adaptor that returns a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of its &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">一个范围适配器，它返回一个包含其&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;参数的所有元素的&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b161bf3c0670ce52a5c8049eec7a861c20295c5" translate="yes" xml:space="preserve">
          <source>A raw pointer of the type &lt;code&gt;element_type*&lt;/code&gt; that references the same memory location as the argument &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;element_type*&lt;/code&gt; 原始指针引用与参数 &lt;code&gt;p&lt;/code&gt; 相同的内存位置。</target>
        </trans-unit>
        <trans-unit id="a987fe5116d16dac6c986d15e44866f1f2950023" translate="yes" xml:space="preserve">
          <source>A read-modify-write operation with this memory order is both an</source>
          <target state="translated">这种内存顺序的读改写操作既是一个</target>
        </trans-unit>
        <trans-unit id="e3862e525cd9728a75bb86198e817c0be834e74b" translate="yes" xml:space="preserve">
          <source>A reference is required to be initialized to refer to a valid object or function: see &lt;a href=&quot;reference_initialization&quot;&gt;reference initialization&lt;/a&gt;.</source>
          <target state="translated">需要将引用初始化为引用有效的对象或函数：请参见&lt;a href=&quot;reference_initialization&quot;&gt;参考初始化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8168313a358c53144732f59b7b55f79bc0d83aa" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;OuterAlloc&lt;/code&gt;.</source>
          <target state="translated">对 &lt;code&gt;OuterAlloc&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="804797fdb54fd58e448bcbbb5edeb1965dd46ac6" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;T&lt;/code&gt; can be initialized with an object of type &lt;code&gt;T&lt;/code&gt;, a function of type &lt;code&gt;T&lt;/code&gt;, or an object implicitly convertible to &lt;code&gt;T&lt;/code&gt;. Once initialized, a reference cannot be changed to refer to another object.</source>
          <target state="translated">所述的参考 &lt;code&gt;T&lt;/code&gt; 可以与类型的对象进行初始化 &lt;code&gt;T&lt;/code&gt; ，类型的函数 &lt;code&gt;T&lt;/code&gt; 或对象隐式转换为 &lt;code&gt;T&lt;/code&gt; 。一旦初始化，引用就不能更改为引用另一个对象。</target>
        </trans-unit>
        <trans-unit id="96effaa229108956b87eaa0ef7506c4b68779cfb" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Ith&lt;/code&gt; element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">甲参照 &lt;code&gt;Ith&lt;/code&gt; 的元件 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fed9a57692255e9193120495f8b304740d5643ee" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Ith&lt;/code&gt; element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">对 &lt;code&gt;s&lt;/code&gt; 的 &lt;code&gt;Ith&lt;/code&gt; 元素的引用。</target>
        </trans-unit>
        <trans-unit id="8587a8972573baad1abe654df486c02df1c78add" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;idx&lt;/code&gt;-th element of the array, i.e., &lt;code&gt;get()[idx]&lt;/code&gt;</source>
          <target state="translated">对数组第 &lt;code&gt;idx&lt;/code&gt; 个元素的引用，即 &lt;code&gt;get()[idx]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36d8ef7aa332a08ad1749e9a36b2ab00fe12b221" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;idx&lt;/code&gt;-th element of the sequence, i.e., &lt;code&gt;data()[idx]&lt;/code&gt;</source>
          <target state="translated">对序列的第 &lt;code&gt;idx&lt;/code&gt; 个元素的引用，即 &lt;code&gt;data()[idx]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af1efc2484e454ad9728eae87f942a799f403462" translate="yes" xml:space="preserve">
          <source>A reference to the back element.</source>
          <target state="translated">指的是后面的元素。</target>
        </trans-unit>
        <trans-unit id="932b2a1f1d48ceff1483626d393c48deb6ec133d" translate="yes" xml:space="preserve">
          <source>A reference to the contained value.</source>
          <target state="translated">对所含数值的引用;</target>
        </trans-unit>
        <trans-unit id="8de78a95776c196427cb50ef2308786df9feaa77" translate="yes" xml:space="preserve">
          <source>A reference to the element at relative location, that is, &lt;code&gt;base()[-n-1]&lt;/code&gt;.</source>
          <target state="translated">对相对位置的元素的引用，即 &lt;code&gt;base()[-n-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed2f64858c4b136043374a81f773f2bb47825288" translate="yes" xml:space="preserve">
          <source>A reference to the element.</source>
          <target state="translated">对该要素的引用;</target>
        </trans-unit>
        <trans-unit id="1b47ff083eea09f7ebfc57e29aa6a19dcffb7f4b" translate="yes" xml:space="preserve">
          <source>A reference to the first element.</source>
          <target state="translated">对第一个要素的提及;</target>
        </trans-unit>
        <trans-unit id="a0df3de2b33596434eabf885b30512aa4bd9a7f7" translate="yes" xml:space="preserve">
          <source>A reference to the inner allocator, which is itself a &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt;.</source>
          <target state="translated">对内部分配器的引用，该内部分配器本身是 &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d12739b00cf675a6ba691cc42cc3b54b7c86c25" translate="yes" xml:space="preserve">
          <source>A reference to the inserted element.</source>
          <target state="translated">对插入的元素的引用。</target>
        </trans-unit>
        <trans-unit id="9b728bf8ae3f8f1afb3d2c134ee7f6175d648f5b" translate="yes" xml:space="preserve">
          <source>A reference to the new contained object.</source>
          <target state="translated">对新包含对象的引用。</target>
        </trans-unit>
        <trans-unit id="695dad725bff816bf70ec1a1e915658d83c47722" translate="yes" xml:space="preserve">
          <source>A reference to the new contained value.</source>
          <target state="translated">对新的包含值的引用。</target>
        </trans-unit>
        <trans-unit id="1f840389ee6e69a00e4361ae4f5b87b0602e4e15" translate="yes" xml:space="preserve">
          <source>A reference to the selected element of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">对 &lt;code&gt;t&lt;/code&gt; 的选定元素的引用。</target>
        </trans-unit>
        <trans-unit id="215a738f7f92427350a124e8545beaf159690b56" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;../../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;../../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 派生的对未指定运行时类型的静态对象的引用。</target>
        </trans-unit>
        <trans-unit id="2dce474f5e611fdd344ca6f78607a960539b8d24" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 派生的对未指定运行时类型的静态对象的引用。</target>
        </trans-unit>
        <trans-unit id="52beb0ba5b037a0cd1d9ec162abace30f7074fd0" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 派生的对未指定运行时类型的静态对象的引用。</target>
        </trans-unit>
        <trans-unit id="b9ad010ef7d281736e175c6e04e6e45d80ea96e8" translate="yes" xml:space="preserve">
          <source>A reference to the stream, i.e., &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">对流的引用，即 &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b519975029bcddb7935a1938c71b85de5a9aa395" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;day&lt;/code&gt; after modification.</source>
          <target state="translated">修改后引用到这 &lt;code&gt;day&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd1b8fb4c67bb93024d4c080ffbd107e8a00646c" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;month&lt;/code&gt; after modification.</source>
          <target state="translated">修改后引用 &lt;code&gt;month&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="77d42f71b8ba36af0d80129ce3320e59f448b88f" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;weekday&lt;/code&gt; after modification.</source>
          <target state="translated">修改后对本 &lt;code&gt;weekday&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="30e2b7de4724355804f01b061a5218dcca673f33" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;year&lt;/code&gt; after modification.</source>
          <target state="translated">修改后参考 &lt;code&gt;year&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c42d3cc108e10a5c0d961e89275a7b7e304370ef" translate="yes" xml:space="preserve">
          <source>A reference to this duration after modification.</source>
          <target state="translated">修改后的这个期限的参考。</target>
        </trans-unit>
        <trans-unit id="477f7a0da5713d89a4c5a2b12679f4b4532b6576" translate="yes" xml:space="preserve">
          <source>A reference variable declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">引用变量声明是其&lt;a href=&quot;declarations&quot;&gt;声明符&lt;/a&gt;具有以下形式的任何简单声明。</target>
        </trans-unit>
        <trans-unit id="071394746753f76fda55bbb1f2d7273768e4c96d" translate="yes" xml:space="preserve">
          <source>A release fence F in thread A synchronizes-with atomic &lt;a href=&quot;memory_order&quot;&gt;acquire operation&lt;/a&gt; Y in thread B, if.</source>
          <target state="translated">如果线程A中的释放防护F与线程B中的原子&lt;a href=&quot;memory_order&quot;&gt;获取操作&lt;/a&gt; Y 同步。</target>
        </trans-unit>
        <trans-unit id="6aafba41a946d2b0a19753067d04e0ec8318ec66" translate="yes" xml:space="preserve">
          <source>A release fence FA in thread A synchronizes-with an acquire fence FB in thread B, if.</source>
          <target state="translated">线程A中的释放栅栏FA与线程B中的获取栅栏FB同步,如果:</target>
        </trans-unit>
        <trans-unit id="00a2a5eb93eeb9be0332c1c8673603beb7ab0223" translate="yes" xml:space="preserve">
          <source>A safely-derived copy of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 的安全派生副本。</target>
        </trans-unit>
        <trans-unit id="34d713d3ce9641e15f0083875fa82da7295cd6d0" translate="yes" xml:space="preserve">
          <source>A searcher suitable for use with the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&quot;&gt;Boyer-Moore-Horspool string searching algorithm&lt;/a&gt;.</source>
          <target state="translated">一个适合与 &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; 的&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt;重载一起使用的搜索器，该搜索器实现了&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&quot;&gt;Boyer-Moore-Horspool字符串搜索算法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4aca9528474448c3c240ea5a50dac0f70fee741" translate="yes" xml:space="preserve">
          <source>A searcher suitable for use with the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore string searching algorithm&lt;/a&gt;.</source>
          <target state="translated">一个适合与 &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; 的&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt;重载一起使用的搜索器，它实现了&lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore字符串搜索算法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c73f721b6023bb7d94aabb383e7afe39aad3eff" translate="yes" xml:space="preserve">
          <source>A separate stored pointer is necessary to ensure that converting a &lt;code&gt;shared_ptr&lt;/code&gt; to &lt;code&gt;weak_ptr&lt;/code&gt; and then back works correctly, even for aliased &lt;code&gt;shared_ptr&lt;/code&gt;s. It is not possible to access the stored pointer in a &lt;code&gt;weak_ptr&lt;/code&gt; without locking it into a &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">需要单独存储的指针，以确保将 &lt;code&gt;shared_ptr&lt;/code&gt; 转换为 &lt;code&gt;weak_ptr&lt;/code&gt; ，然后再正确转换，即使对于别名为 &lt;code&gt;shared_ptr&lt;/code&gt; 的情况也是如此。如果不将其锁定在 &lt;code&gt;shared_ptr&lt;/code&gt; 中，就不可能访问 &lt;code&gt;weak_ptr&lt;/code&gt; 中存储的指针。</target>
        </trans-unit>
        <trans-unit id="25e507c2060a3cafdcda35e0bc4aa2552b49e574" translate="yes" xml:space="preserve">
          <source>A sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range &lt;code&gt;[F1, F2)&lt;/code&gt; otherwise</source>
          <target state="translated">代表归类元素的字符序列，该序列元素由迭代器范围 &lt;code&gt;[F1, F2)&lt;/code&gt; 指定的字符序列组成，否则</target>
        </trans-unit>
        <trans-unit id="3a4ef167623ed9faf9a94eff09dae4f596aaaa70" translate="yes" xml:space="preserve">
          <source>A simple declaration is a statement that introduces, creates, and optionally initializes one or several identifiers, typically variables.</source>
          <target state="translated">一个简单的声明是一个声明,它介绍,创建,并有选择地初始化一个或几个标识符,通常是变量。</target>
        </trans-unit>
        <trans-unit id="555b8933650b3bb84b4b7b35f14e9c321630ac4d" translate="yes" xml:space="preserve">
          <source>A simple requirement is an arbitrary expression statement. It asserts that the expression is valid. The expression is an unevaluated operand; only language correctness is checked.</source>
          <target state="translated">一个简单的要求是一个任意的表达式声明。它断言该表达式是有效的。表达式是一个未经评估的操作数;只检查语言的正确性。</target>
        </trans-unit>
        <trans-unit id="3a6977f0304e9c21ebecd390f1670f86c4119c3c" translate="yes" xml:space="preserve">
          <source>A simple-template-id that names a class template specialization names a class.</source>
          <target state="translated">一个简单的模板id,命名一个类模板专业化命名一个类。</target>
        </trans-unit>
        <trans-unit id="8fa198408b5d0cb7b3044995aa1b61b2fdf97bfa" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;link&quot;&gt;std::chrono::link&lt;/a&gt;&amp;gt;&lt;/code&gt; containing description of alternative names of time zones (links)</source>
          <target state="translated">排序的 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;link&quot;&gt;std::chrono::link&lt;/a&gt;&amp;gt;&lt;/code&gt; 包含时区替代名称的描述（链接）</target>
        </trans-unit>
        <trans-unit id="457d45e0af075f01765307d373a69c2a8d94815f" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;&amp;gt;&lt;/code&gt; containing description of time zones</source>
          <target state="translated">排序的 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;&amp;gt;&lt;/code&gt; 包含时区描述</target>
        </trans-unit>
        <trans-unit id="967914ef26dbd68948b66b13d60e30b85ed85a3c" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;std::chrono::leaps&amp;gt;&lt;/code&gt; containing description of leap seconds</source>
          <target state="translated">排序的 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;std::chrono::leaps&amp;gt;&lt;/code&gt; 包含leap秒的描述</target>
        </trans-unit>
        <trans-unit id="eee524fe2ac982c4dd9f9a32a0c582f50eef3782" translate="yes" xml:space="preserve">
          <source>A span &lt;code&gt;r&lt;/code&gt; that is a view over the first &lt;code&gt;Count&lt;/code&gt; elements of &lt;code&gt;*this&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">跨度 &lt;code&gt;r&lt;/code&gt; 是 &lt;code&gt;*this&lt;/code&gt; 的前 &lt;code&gt;Count&lt;/code&gt; 个元素的视图，因此 &lt;code&gt;r.data() == this-&amp;gt;data() &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65c54f136c4760893800380e5b0c393d21d23647" translate="yes" xml:space="preserve">
          <source>A span &lt;code&gt;r&lt;/code&gt; that is a view over the last &lt;code&gt;Count&lt;/code&gt; elements of &lt;code&gt;*this&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + (this-&amp;gt;size() - Count) &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">跨度 &lt;code&gt;r&lt;/code&gt; 是 &lt;code&gt;*this&lt;/code&gt; 的最后 &lt;code&gt;Count&lt;/code&gt; 个元素的视图，因此 &lt;code&gt;r.data() == this-&amp;gt;data() + (this-&amp;gt;size() - Count) &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5074592fbba4772cb532096c90f531b3f380c17b" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">的专业化 &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ee495551d56b04a23dc52fb815bb43b2e18e8c4" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;conjunction&lt;/code&gt; does not necessarily inherit from either &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;: it simply inherits from the first &lt;code&gt;B&lt;/code&gt; whose &lt;code&gt;::value&lt;/code&gt;, explicitly converted to bool, is false, or from the very last &lt;code&gt;B&lt;/code&gt; when all of them convert to true. For example, &lt;code&gt;std::conjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">的专业化 &lt;code&gt;conjunction&lt;/code&gt; 不一定无论从继承 &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; ：它只是从第一继承 &lt;code&gt;B&lt;/code&gt; 其 &lt;code&gt;::value&lt;/code&gt; ，显式转换为布尔，是假的，或者从最后 &lt;code&gt;B&lt;/code&gt; 当所有的人转换为true。例如， &lt;code&gt;std::conjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; 是 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9e9b49b2bead30b9efc6f23cbdc32fd0fd8ce60" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;disjunction&lt;/code&gt; does not necessarily inherit from of either &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;: it simply inherits from the first &lt;code&gt;B&lt;/code&gt; whose &lt;code&gt;::value&lt;/code&gt;, explicitly converted to &lt;code&gt;bool&lt;/code&gt;, is true, or from the very last B when all of them convert to false. For example, &lt;code&gt;std::disjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; &lt;code&gt;disjunction&lt;/code&gt; 的特殊化不一定继承自std :: true_type或 &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; ：它仅继承自第一个 &lt;code&gt;B&lt;/code&gt; ,后者的 &lt;code&gt;::value&lt;/code&gt; 显式转换为 &lt;code&gt;bool&lt;/code&gt; ，是true，或者继承自最后一个B他们转换为假。例如， &lt;code&gt;std::disjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; 是 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f9e5d495b1b862008c29e72aac873442799f4b0" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::greater&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::greater&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::greater&lt;/code&gt; 对任何指针类型的特殊化都会产生严格的总顺序，即使内置的 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 不会。严格的总顺序在该指针类型的 &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;std::greater&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; 专长之间是一致的，并且还与相应的内置运算符强加的部分顺序一致（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="4d8a4b2d55428dedbd5dbf627f7b5d8550161022" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::greater_equal&lt;/code&gt; 对任何指针类型的特殊化都会产生严格的总顺序，即使内置 &lt;code&gt;operator&amp;gt;=&lt;/code&gt; 也不如此。严格的总顺序在该指针类型的 &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;std::greater_equal&lt;/code&gt; 专长之间是一致的，并且还与相应的内置运算符强加的部分顺序一致（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="475b3cfac8883fd0a588f09dae13ae24eea6b2df" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::less&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;std::less&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::less&lt;/code&gt; 对于任何指针类型的特殊化都会产生严格的总顺序，即使内置 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 不会。严格的总顺序在该指针类型的 &lt;code&gt;std::less&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; 专长之间是一致的，并且还与相应的内置运算符强加的部分顺序一致（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5040d1c9db6502c777c18889e5250a72b8267c2f" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::less_equal&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">的专业化 &lt;code&gt;std::less_equal&lt;/code&gt; 为任何指针类型产生一个严格全序，即使内置的 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 没有。严格的总顺序在该指针类型的 &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;std::less_equal&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; 专长之间是一致的，并且还与相应的内置运算符强加的部分顺序一致（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="92e25a120740f5ad5adbba2aabed8d933eb3d5e4" translate="yes" xml:space="preserve">
          <source>A spinlock mutex can be implemented in userspace using an atomic exchange operation, similar to &lt;code&gt;&lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;std::atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">可以使用原子交换操作在用户空间中实现自旋锁互斥锁，类似于 &lt;code&gt;&lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;std::atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9515057fe6328dc05919c4cf02d9006061787a0c" translate="yes" xml:space="preserve">
          <source>A spinlock mutex can be implemented in userspace using an atomic_flag.</source>
          <target state="translated">自旋锁mutex可以在用户空间中使用atomic_flag实现。</target>
        </trans-unit>
        <trans-unit id="901d05a2e6ec5ffbcf6b01e787bf262ebced94a5" translate="yes" xml:space="preserve">
          <source>A standard conversion sequence consists of the following, in this order:</source>
          <target state="translated">一个标准的转换序列按以下顺序组成:</target>
        </trans-unit>
        <trans-unit id="d4c338c0450a24104d97679430b5532160d82771" translate="yes" xml:space="preserve">
          <source>A static assert declaration may appear at namespace and block scope (as a &lt;a href=&quot;declarations&quot;&gt;block declaration&lt;/a&gt;) and inside a class body (as a &lt;a href=&quot;class&quot;&gt;member declaration&lt;/a&gt;).</source>
          <target state="translated">静态断言声明可以出现在名称空间和块作用域（作为&lt;a href=&quot;declarations&quot;&gt;块声明&lt;/a&gt;）以及类体内（作为&lt;a href=&quot;class&quot;&gt;成员声明&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f33f270773f2dc3de0fd0352e32cf33418d9b8c0" translate="yes" xml:space="preserve">
          <source>A static data member may be declared &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;. An inline static data member can be defined in the class definition and may specify an initializer. It does not need an out-of-class definition:</source>
          <target state="translated">可以将静态数据成员声明为&lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt;。内联静态数据成员可以在类定义中定义，并且可以指定初始化程序。它不需要类外定义：</target>
        </trans-unit>
        <trans-unit id="5da97780b140e6a47935295d4e1ee4870bfe1e89" translate="yes" xml:space="preserve">
          <source>A static member variable (but not a namespace-scope variable) declared &lt;code&gt;constexpr&lt;/code&gt; is implicitly an inline variable.</source>
          <target state="translated">声明为 &lt;code&gt;constexpr&lt;/code&gt; 的静态成员变量（但不是名称空间范围的变量）隐式为内联变量。</target>
        </trans-unit>
        <trans-unit id="4b6d0fdd7d7607c01a896d9094690fc14c51a0b3" translate="yes" xml:space="preserve">
          <source>A steady clock is used to measure the duration. This function may block for longer than &lt;code&gt;timeout_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">稳定时钟用于测量持续时间。由于调度或资源争用延迟，此功能可能阻塞的时间超过 &lt;code&gt;timeout_duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78127daba885f04d8c232a3a0e396aee55e69e02" translate="yes" xml:space="preserve">
          <source>A store operation with this memory order performs the</source>
          <target state="translated">用这个存储顺序进行存储操作,会执行</target>
        </trans-unit>
        <trans-unit id="c6bc48899775e9a6c5f0a1a15785f5ee33b9cf7b" translate="yes" xml:space="preserve">
          <source>A string describing the given error condition.</source>
          <target state="translated">描述给定错误条件的字符串。</target>
        </trans-unit>
        <trans-unit id="46b19b69118bd315cdfc683d15a6fa75436b64bc" translate="yes" xml:space="preserve">
          <source>A string literal is not necessarily a C string: if a string literal has embedded null characters, it represents an array which contains more than one string.</source>
          <target state="translated">字符串不一定是 C 字符串:如果一个字符串字符串有嵌入的空字符,它代表一个包含多个字符串的数组。</target>
        </trans-unit>
        <trans-unit id="1550cc2a5436eb99f071dfa4dcf0dd47ccf4c825" translate="yes" xml:space="preserve">
          <source>A string view representing the entire contents of the string.</source>
          <target state="translated">字符串视图,表示字符串的全部内容。</target>
        </trans-unit>
        <trans-unit id="32570ac03b4c2c47cffb2bbc021cc0ca86dcc629" translate="yes" xml:space="preserve">
          <source>A structured binding declaration first introduces a uniquely-named variable (here denoted by &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;) to hold the value of the initializer, as follows:</source>
          <target state="translated">结构化绑定声明首先引入一个唯一命名的变量（在此由 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 表示）来保存初始化程序的值，如下所示：</target>
        </trans-unit>
        <trans-unit id="144f71d00798ee052aabd4ddb5c24678262a6ae1" translate="yes" xml:space="preserve">
          <source>A structured binding declaration introduces all identifiers in the identifier-list as names in the surrounding scope and binds them to subobjects or elements of the object denoted by expression. The bindings so introduced are called</source>
          <target state="translated">结构化绑定声明将标识符列表中的所有标识符作为名称引入到周围的作用域中,并将它们绑定到表达式所表示的对象的子对象或元素上。这样引入的绑定被称为</target>
        </trans-unit>
        <trans-unit id="835974f7bef28e4dff1c1ff405518b0bb98087eb" translate="yes" xml:space="preserve">
          <source>A structured binding declaration then performs the binding in one of three possible ways, depending on &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;:</source>
          <target state="translated">然后，根据 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; ，结构化绑定声明以三种可能的方式之一执行绑定：</target>
        </trans-unit>
        <trans-unit id="5ebdd31b80b554a53c87eaf8af1247d0cf95b1cf" translate="yes" xml:space="preserve">
          <source>A subobject is</source>
          <target state="translated">一个子对象是</target>
        </trans-unit>
        <trans-unit id="7a0f0cf82fd7a9695235dbab61201c1151c693d9" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;operator()&lt;/code&gt; synchronizes with a call to any member function of a &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; that share their shared state with &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">成功调用 &lt;code&gt;operator()&lt;/code&gt; 会与对与 &lt;code&gt;*this&lt;/code&gt; 共享其共享状态的 &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; 任何成员函数的调用同步。</target>
        </trans-unit>
        <trans-unit id="5e5e13088bac64880bbd1d92f74dea1c546eae32" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;std::feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成功调用 &lt;code&gt;ungetc&lt;/code&gt; 会清除文件状态标志 &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;std::feof&lt;/a&gt;&lt;/code&gt; 的结尾。</target>
        </trans-unit>
        <trans-unit id="2f18b9828e8cbe5f820c7f00f14018c93e63c261" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</source>
          <target state="translated">在二进制流上成功调用 &lt;code&gt;ungetc&lt;/code&gt; 会使流位置指示符减一（如果流位置指示符为零，则行为不确定）。</target>
        </trans-unit>
        <trans-unit id="ca4337b8d12737a6a022afbf7eb03368caa77b5b" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">在文本流上成功调用 &lt;code&gt;ungetc&lt;/code&gt; 会以未指定的方式修改流位置指示符，但可以保证在通过读取操作检索到所有推回字符后，流位置指示符等于其在 &lt;code&gt;ungetc&lt;/code&gt; 之前的值。</target>
        </trans-unit>
        <trans-unit id="a28d7859e6f4fcb6db1df05cff06566fff5a4e72" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; clears the end of file status flag &lt;code&gt;feof&lt;/code&gt;.</source>
          <target state="translated">成功调用 &lt;code&gt;ungetwc&lt;/code&gt; 会清除文件状态标志 &lt;code&gt;feof&lt;/code&gt; 的结尾。</target>
        </trans-unit>
        <trans-unit id="96bde972d314cd8969488c09d04edcb68d3e8cec" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">在流（无论是文本还是二进制）上对 &lt;code&gt;ungetwc&lt;/code&gt; 的成功调用将以未指定的方式修改流位置指示符，但保证在通过读取操作检索到所有推回的宽字符之后，流位置指示符等于其在 &lt;code&gt;ungetwc&lt;/code&gt; 之前的值。</target>
        </trans-unit>
        <trans-unit id="4438ef6f7a0682bb256998449673a26881f7a072" translate="yes" xml:space="preserve">
          <source>A template argument for a template template parameter must be an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; which names a class template or a template alias.</source>
          <target state="translated">模板模板参数的模板参数必须是一个&lt;a href=&quot;name#In_expressions&quot;&gt;ID表达式&lt;/a&gt;，用于命名类模板或模板别名。</target>
        </trans-unit>
        <trans-unit id="0cbe97ed8a5079b18bed67f0b987c6e75304c3a6" translate="yes" xml:space="preserve">
          <source>A template argument for a type template parameter must be a &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;, which may name an incomplete type:</source>
          <target state="translated">类型模板参数的模板参数必须是&lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;，它可以命名不完整的类型：</target>
        </trans-unit>
        <trans-unit id="b77575f13c55d5afb76807a44c03b42f3be5cca3" translate="yes" xml:space="preserve">
          <source>A template defined in the &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; header may be instantiated with an incomplete type unless otherwise specified, notwithstanding the general prohibition against instantiating standard library templates with incomplete types.</source>
          <target state="translated">除非另有说明，否则 &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; 标头中定义的模板可以用不完整的类型实例化，尽管一般禁止使用不完整的类型实例化标准库模板。</target>
        </trans-unit>
        <trans-unit id="3db9cfde6b359f0a7eac7446ebfcb7cabe3498b5" translate="yes" xml:space="preserve">
          <source>A template friend declaration can name a member of a class template A, which can be either a member function or a member type (the type must use &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated-type-specifier&lt;/a&gt;). Such declaration is only well-formed if the last component in its nested-name-specifier (the name to the left of the last &lt;code&gt;::&lt;/code&gt;) is a simple-template-id (template name followed by argument list in angle brackets) that names the class template. The template parameters of such template friend declaration must be deducible from the simple-template-id.</source>
          <target state="translated">模板好友声明可以命名类模板A的成员，该类可以是成员函数或成员类型（该类型必须使用&lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated-type-specifier&lt;/a&gt;）。仅当嵌套名称说明符中的最后一个组件（最后一个 &lt;code&gt;::&lt;/code&gt; 的左侧的名称）是一个简单模板ID（模板名称，后跟尖括号中的参数列表）时，该声明的格式才正确类模板。此类模板朋友声明的模板参数必须可以从simple-template-id推导出。</target>
        </trans-unit>
        <trans-unit id="b8cbfd05ed876a96f58d914b20aab64f29b86a74" translate="yes" xml:space="preserve">
          <source>A template is a C++ entity that defines one of the following:</source>
          <target state="translated">模板是一个C++实体,它定义了以下内容之一。</target>
        </trans-unit>
        <trans-unit id="59d81713cfdc4799ddf46175f8d61401bcd90683" translate="yes" xml:space="preserve">
          <source>A template parameter of the form &lt;code&gt;class Foo&lt;/code&gt; is not an unnamed non-type template parameter of type &lt;code&gt;Foo&lt;/code&gt;, even if otherwise &lt;code&gt;class Foo&lt;/code&gt; is an &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; and &lt;code&gt;class Foo x;&lt;/code&gt; declares &lt;code&gt;x&lt;/code&gt; to be of type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">形式为 &lt;code&gt;class Foo&lt;/code&gt; 模板参数不是类型为 &lt;code&gt;Foo&lt;/code&gt; 的未命名非类型模板参数，即使其他情况下， &lt;code&gt;class Foo&lt;/code&gt; 是&lt;a href=&quot;elaborated_type_specifier&quot;&gt;复杂的类型说明符，&lt;/a&gt;而 &lt;code&gt;class Foo x;&lt;/code&gt; 声明 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;Foo&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d85241f2bc54602e57c2582a6ecab6b9f660f5f6" translate="yes" xml:space="preserve">
          <source>A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A function parameter pack is a function parameter that accepts zero or more function arguments.</source>
          <target state="translated">模板参数包是一个模板参数,它接受零或多个模板参数(非类型、类型或模板)。函数参数包是一个函数参数,它接受零个或多个函数参数。</target>
        </trans-unit>
        <trans-unit id="eb2fa05aae2cb5737143f68053260c6a62f41e74" translate="yes" xml:space="preserve">
          <source>A template parameter pack that is explicitly specified may be extended by template argument deduction if there are additional arguments:</source>
          <target state="translated">明确指定的模板参数包,如果有额外的参数,可以通过模板参数推导进行扩展。</target>
        </trans-unit>
        <trans-unit id="f41dfabc2328a29181220b5113304c48aad61703" translate="yes" xml:space="preserve">
          <source>A template specialization that was declared but not defined can be used just like any other &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (e.g. pointers and references to it may be used).</source>
          <target state="translated">已声明但未定义的模板特殊化可以像其他任何&lt;a href=&quot;incomplete_type&quot;&gt;不完整类型&lt;/a&gt;一样使用（例如，可以使用指针和对其的引用）。</target>
        </trans-unit>
        <trans-unit id="344b2caa5e5fe345b5eddc1d5d915de3d6be2db2" translate="yes" xml:space="preserve">
          <source>A template with at least one parameter pack is called a</source>
          <target state="translated">具有至少一个参数包的模板称为</target>
        </trans-unit>
        <trans-unit id="673816c6497404faf247ef589f1b122b3a14f807" translate="yes" xml:space="preserve">
          <source>A template-id is only valid if.</source>
          <target state="translated">只有在以下情况下,模板标识才有效:</target>
        </trans-unit>
        <trans-unit id="10655830c19a77e3e63f7c59d226efb3c807b9e8" translate="yes" xml:space="preserve">
          <source>A template-id that names an alias template specialization names a type.</source>
          <target state="translated">一个命名别名模板专业化的template-id命名一个类型。</target>
        </trans-unit>
        <trans-unit id="df2b079308f3eca647407b9397b352dc670c7a81" translate="yes" xml:space="preserve">
          <source>A template-id that names an function template specialization names a function.</source>
          <target state="translated">一个模板-id,它命名了一个函数模板专门化命名一个函数。</target>
        </trans-unit>
        <trans-unit id="3c85feec0c63ebeca50f678f352ffcc3928d1b88" translate="yes" xml:space="preserve">
          <source>A templated entity (or, in some sources, &quot;temploid&quot;) is any entity that is defined (or, for a lambda-expression, created) within a template definition. All of the following are templated entities:</source>
          <target state="translated">模板化实体(或者,在某些资料中,&quot;temploid&quot;)是在模板定义中定义(或者,对于一个lambda表达式,创建)的任何实体。以下所有的实体都是模板化实体。</target>
        </trans-unit>
        <trans-unit id="97a674e12e96df448607046bf1ea74819514e29d" translate="yes" xml:space="preserve">
          <source>A temporary object of type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">类型 &lt;code&gt;T&lt;/code&gt; 的临时对象是&lt;a href=&quot;../language/value_initialization&quot;&gt;值初始化&lt;/a&gt;或&lt;a href=&quot;../language/aggregate_initialization&quot;&gt;集合初始化的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="33f18c53306de042e4c98fc4f2ec71d92fc7452f" translate="yes" xml:space="preserve">
          <source>A test for self-reset, i.e. whether &lt;code&gt;ptr&lt;/code&gt; points to an object already managed by &lt;code&gt;*this&lt;/code&gt;, is not performed, except where provided as a compiler extension or as a debugging assert. Note that code such as &lt;code&gt;p.reset(p.release())&lt;/code&gt; does not involve self-reset, only code like &lt;code&gt;p.reset(p.get())&lt;/code&gt; does.</source>
          <target state="translated">除非执行编译器扩展或调试断言，否则不执行自复位测试，即 &lt;code&gt;ptr&lt;/code&gt; 是否指向已由 &lt;code&gt;*this&lt;/code&gt; 管理的对象。请注意，诸如 &lt;code&gt;p.reset(p.release())&lt;/code&gt; 之类的代码不涉及自复位，只有诸如 &lt;code&gt;p.reset(p.get())&lt;/code&gt; 之类的代码才涉及自复位。</target>
        </trans-unit>
        <trans-unit id="69a493f42c2d5d0a3d7b1e06a1285a10bdbe7061" translate="yes" xml:space="preserve">
          <source>A thread is said to</source>
          <target state="translated">一条线可以说是</target>
        </trans-unit>
        <trans-unit id="ba9c13c0f9167e54bcbaf88e115f4167e83660c0" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;lock&lt;/code&gt; on a recursive mutex repeatedly. Ownership will only be released after the thread makes a matching number of calls to &lt;code&gt;unlock&lt;/code&gt;.</source>
          <target state="translated">一个线程可以调用 &lt;code&gt;lock&lt;/code&gt; 反复上递归互斥。只有在线程发出匹配数量的 &lt;code&gt;unlock&lt;/code&gt; 请求后，才释放所有权。</target>
        </trans-unit>
        <trans-unit id="7f432eae50bd789012a099dcf2a13f431564693f" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock&lt;/code&gt; increment the ownsership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">线程可能 &lt;code&gt;try_lock&lt;/code&gt; 在递归互斥体上反复调用try_lock。成功调用 &lt;code&gt;try_lock&lt;/code&gt; 会增加拥有者计数：互斥锁仅在线程发出与 &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; 匹配的调用数之后才释放。</target>
        </trans-unit>
        <trans-unit id="37671f46b069e4bce5a6c704520d4965568d9f60" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock_for&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock_for&lt;/code&gt; increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">线程可能 &lt;code&gt;try_lock_for&lt;/code&gt; 在递归互斥体上反复调用try_lock_for。成功调用 &lt;code&gt;try_lock_for&lt;/code&gt; 会增加所有权计数：互斥锁仅在线程发出与之匹配的调用次数后才 &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="892016f3791df53a75393a4054de36f6670ede74" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock_until&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock_until&lt;/code&gt; increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">线程可能 &lt;code&gt;try_lock_until&lt;/code&gt; 在递归互斥体上反复调用try_lock_until。成功调用 &lt;code&gt;try_lock_until&lt;/code&gt; 会增加所有权计数：互斥锁仅在线程发出与之匹配的调用次数后才会 &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b4560e93294ed5a9703378d1e170be75de3f418" translate="yes" xml:space="preserve">
          <source>A thread object does not have an associated thread (and is safe to destroy) after.</source>
          <target state="translated">一个线程对象没有相关联的线程(并且可以安全销毁)后。</target>
        </trans-unit>
        <trans-unit id="bac126fd4b2160e8de884ee506093cb6e1453d7a" translate="yes" xml:space="preserve">
          <source>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by &lt;code&gt;&lt;a href=&quot;../thread/thread/thread&quot;&gt;std::thread::thread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, or other means.</source>
          <target state="translated">执行线程是程序中的控制流，该控制流始于通过 &lt;code&gt;&lt;a href=&quot;../thread/thread/thread&quot;&gt;std::thread::thread&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../thread/async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; 或其他方式调用顶级函数。</target>
        </trans-unit>
        <trans-unit id="13fb085a74dd9fd867bcbeeeed6c63aa5ff60cd7" translate="yes" xml:space="preserve">
          <source>A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</source>
          <target state="translated">一个已经完成执行代码,但尚未加入的线程仍然被认为是一个活动的执行线程,因此可以加入。</target>
        </trans-unit>
        <trans-unit id="d83b1a24d6c356fdf4f8f81bf30022c94f556e0c" translate="yes" xml:space="preserve">
          <source>A time point is a duration of time that has passed since the epoch of a specific clock.</source>
          <target state="translated">时间点是指从一个特定时钟的纪元开始,已经过去的时间长度。</target>
        </trans-unit>
        <trans-unit id="842ecf6d69cdbeaddd28ab48c6e44b247497210b" translate="yes" xml:space="preserve">
          <source>A time point representing the current time.</source>
          <target state="translated">一个代表当前时间的时间点。</target>
        </trans-unit>
        <trans-unit id="482e88b6e7ea3206c3e62b40431b9801a98e659f" translate="yes" xml:space="preserve">
          <source>A trailing template-argument can be left unspecified in an explicit instantiation of a function template specialization or of a member function template specialization if it can be &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from the function parameter.</source>
          <target state="translated">如果可以从功能参数中&lt;a href=&quot;template_argument_deduction&quot;&gt;推断出&lt;/a&gt;模板模板参数，则可以在函数模板专用化或成员函数模板专用化的显式实例中保留未指定的尾随模板参数。</target>
        </trans-unit>
        <trans-unit id="1744e51348fac7204c6560fe5f680fd02436a4e6" translate="yes" xml:space="preserve">
          <source>A translation unit that includes a standard library header may not &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;#undef&lt;/code&gt; names declared in any standard library header.</source>
          <target state="translated">包含标准库头的翻译单元不得在任何标准库头中声明的 &lt;code&gt;#define&lt;/code&gt; 或 &lt;code&gt;#undef&lt;/code&gt; 名称。</target>
        </trans-unit>
        <trans-unit id="e8a16a40cb320ca82f7aab312a29ceda1b14f739" translate="yes" xml:space="preserve">
          <source>A translation unit that uses any part of the standard library may not &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;#undef&lt;/code&gt; names lexically identical to:</source>
          <target state="translated">使用标准库的任何部分的翻译单元可能无法 &lt;code&gt;#define&lt;/code&gt; 或 &lt;code&gt;#undef&lt;/code&gt; 名称在词汇上与以下内容相同：</target>
        </trans-unit>
        <trans-unit id="d317f7a0ab3e788267489e0fc1532ddec6c12c38" translate="yes" xml:space="preserve">
          <source>A trivial copy assignment operator makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially copy-assignable.</source>
          <target state="translated">一个简单的副本分配运算符可以像 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; 一样复制对象表示形式。与C语言兼容的所有数据类型（POD类型）都是可复制分配的。</target>
        </trans-unit>
        <trans-unit id="dd6abf8a66d91871c0f211e838354255f118cc43" translate="yes" xml:space="preserve">
          <source>A trivial copy constructor for a non-union class effectively copies every scalar subobject (including, recursively, subobject of subobjects and so forth) of the argument and performs no other action. However, padding bytes need not be copied, and even the object representations of the copied subobjects need not be the same as long as their values are identical.</source>
          <target state="translated">一个非union类的琐碎复制构造函数,有效地复制了参数的每一个标量子对象(包括,递归地,子对象的子对象等等),而不执行其他操作。但是,填充字节不需要被复制,甚至被复制的子对象的对象表示也不需要相同,只要它们的值是相同的。</target>
        </trans-unit>
        <trans-unit id="53f265b51a6ad6bc29b0d13aa314fdd06dcfce6a" translate="yes" xml:space="preserve">
          <source>A trivial default constructor is a constructor that performs no action. All data types compatible with the C language (POD types) are trivially default-constructible. Unlike &lt;a href=&quot;http://en.cppreference.com/w/c/language/object.html#Effective_type&quot;&gt;in C&lt;/a&gt;, however, objects with trivial default constructors cannot be created by simply reinterpreting suitably aligned storage, such as memory allocated with &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;: placement-new is required to formally &lt;a href=&quot;objects&quot;&gt;introduce a new object&lt;/a&gt; and avoid potential undefined behavior.</source>
          <target state="translated">普通的默认构造函数是不执行任何操作的构造函数。与C语言兼容的所有数据类型（POD类型）都是默认可构造的。但是，与&lt;a href=&quot;http://en.cppreference.com/w/c/language/object.html#Effective_type&quot;&gt;C语言&lt;/a&gt;不同，不能通过简单地重新解释适当对齐的存储来创建具有琐碎默认构造函数的对象，例如，用 &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; 分配的内存：正式&lt;a href=&quot;objects&quot;&gt;引入新对象&lt;/a&gt;并避免潜在的未定义行为时，需要placement-new 。</target>
        </trans-unit>
        <trans-unit id="033337ca5c4ad7c5b77be1ecaa5de6acda3c11c8" translate="yes" xml:space="preserve">
          <source>A trivial destructor is a destructor that performs no action. Objects with trivial destructors don't require a delete-expression and may be disposed of by simply deallocating their storage. All data types compatible with the C language (POD types) are trivially destructible.</source>
          <target state="translated">trivial destructor是一个不执行任何操作的destructor。具有三重破坏器的对象不需要delete-expression,可以通过简单的deallocating它们的存储来处理。所有与C语言兼容的数据类型(POD类型)都是可微不足道地反破坏的。</target>
        </trans-unit>
        <trans-unit id="d79042321968ff405b9eb41b02f03841f248eb8b" translate="yes" xml:space="preserve">
          <source>A trivial move assignment operator performs the same action as the trivial copy assignment operator, that is, makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially move-assignable.</source>
          <target state="translated">琐碎的移动赋值运算符执行与琐碎的副本赋值运算符相同的操作，即，像通过 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; 一样复制对象表示形式。与C语言兼容的所有数据类型（POD类型）都是可移动分配的。</target>
        </trans-unit>
        <trans-unit id="0ceb73134e634232cb9fed5b06967cd8af551fd6" translate="yes" xml:space="preserve">
          <source>A trivial move constructor is a constructor that performs the same action as the trivial copy constructor, that is, makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially movable.</source>
          <target state="translated">简单的移动构造函数是执行与简单的副本构造函数相同的操作的构造函数，即，像通过 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; 一样复制对象表示形式。与C语言兼容的所有数据类型（POD类型）都可以轻松移动。</target>
        </trans-unit>
        <trans-unit id="4362f0ff877083bd05b03790df742e70f948b72d" translate="yes" xml:space="preserve">
          <source>A try-block is a &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, and as such, can appear anywhere a statement can appear (that is, as one of the statements in a compound statement, including the function body compound statement). See &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for the try blocks around function bodies. The following description applies to both try-blocks and &lt;a href=&quot;function-try-block&quot;&gt;function-try-blocks&lt;/a&gt;.</source>
          <target state="translated">try块是一个&lt;a href=&quot;statements&quot;&gt;语句&lt;/a&gt;，因此可以出现在语句可以出现的任何位置（即，作为复合语句中的语句之一，包括函数体复合语句）。有关&lt;a href=&quot;function-try-block&quot;&gt;功能&lt;/a&gt;体周围的try块，请参见function-try-block。以下描述适用于try块和&lt;a href=&quot;function-try-block&quot;&gt;function-try块&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19834a31076ba08c517eaff630de5e748d366c53" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;E&lt;/code&gt; satisfying &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; will additionally satisfy RandomNumberEngine if, given.</source>
          <target state="translated">如果给定，则满足&lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;的类型 &lt;code&gt;E&lt;/code&gt; 将另外满足RandomNumberEngine。</target>
        </trans-unit>
        <trans-unit id="ca6cf0688a958e8a7bf6dc59cfc4cfb1df147a82" translate="yes" xml:space="preserve">
          <source>A type T is ValueSwappable if.</source>
          <target state="translated">一个类型T是ValueSwappable,如果:</target>
        </trans-unit>
        <trans-unit id="a7bc09bb961fc3d44a04b48c1111a1a318bd62fe" translate="yes" xml:space="preserve">
          <source>A type has</source>
          <target state="translated">一种类型有</target>
        </trans-unit>
        <trans-unit id="1816dc600e8b7d025987ab256efe8b9a53ee4eb9" translate="yes" xml:space="preserve">
          <source>A type requirement is the keyword &lt;code&gt;typename&lt;/code&gt; followed by a type name, optionally qualified. The requirement is that the named type is valid: this can be used to verify that a certain named nested type exists, or that a class template specialization names a type, or that an alias template specialization names a type. A type requirement naming a class template specialization does not require the type to be complete.</source>
          <target state="translated">类型要求是关键字 &lt;code&gt;typename&lt;/code&gt; ,后跟类型名称（可以选择限定）。要求是命名类型是有效的：可用于验证某个命名嵌套类型是否存在，或者类模板专门化命名类型，或者别名模板专门化命名类型。命名类模板专业化的类型要求不要求类型完整。</target>
        </trans-unit>
        <trans-unit id="15ef01c2ad4973128037ff3072f4151a78c62933" translate="yes" xml:space="preserve">
          <source>A type that can hold all valid values of &lt;code&gt;X::char_type&lt;/code&gt; plus &lt;code&gt;X::eof()&lt;/code&gt;</source>
          <target state="translated">可以容纳 &lt;code&gt;X::char_type&lt;/code&gt; 加上 &lt;code&gt;X::eof()&lt;/code&gt; 所有有效值的类型</target>
        </trans-unit>
        <trans-unit id="03ac68cf57c6c426934400170b4271e37c362fbe" translate="yes" xml:space="preserve">
          <source>A typical cause of failure for &lt;code&gt;std::puts&lt;/code&gt; is running out of space on the file system, when &lt;code&gt;stdout&lt;/code&gt; is redirected to a file.</source>
          <target state="translated">将 &lt;code&gt;stdout&lt;/code&gt; 重定向到文件时， &lt;code&gt;std::puts&lt;/code&gt; 失败的典型原因是文件系统上的空间不足。</target>
        </trans-unit>
        <trans-unit id="ae95c3cb82eea0b19d5fa37c3903de19a5db5a6a" translate="yes" xml:space="preserve">
          <source>A typical example of such situation is the naive implementation of &lt;code&gt;&lt;a href=&quot;../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; (derived from the empty base &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt;), which holds the underlying iterator (also derived from &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt;) as its first non-static data member.</source>
          <target state="translated">这种情况的一个典型示例是 &lt;code&gt;&lt;a href=&quot;../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; 的幼稚实现（从空的基本 &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt; 派生），它将基础迭代器（也从 &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt; 派生）作为其第一个非静态数据成员。</target>
        </trans-unit>
        <trans-unit id="0734374c55a399a52d1410a4e6f7c1c0d057f16d" translate="yes" xml:space="preserve">
          <source>A typical generator's yield_value would store (copy/move or just store the address of, since the argument's lifetime crosses the suspension point inside the co_await) its argument into the generator object and return &lt;code&gt;std::suspend_always&lt;/code&gt;, transferring control to the caller/resumer.</source>
          <target state="translated">典型的生成器的yield_value会将其自变量存储（复制/移动或仅存储其地址，因为自变量的生命周期跨越co_await内部的悬浮点）并将其自变量返回到生成器对象并返回 &lt;code&gt;std::suspend_always&lt;/code&gt; ，将控制权转移给调用者/恢复者。</target>
        </trans-unit>
        <trans-unit id="51f160ce423fd83704df3a5cb0174dbe3220c314" translate="yes" xml:space="preserve">
          <source>A typical implementation holds one integer data member (the value) and a pointer to an &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个典型的实现包含一个整数数据成员（值）和一个指向 &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 的指针。</target>
        </trans-unit>
        <trans-unit id="1aa218a5c2f20a77c0b0ce98af0029f85ebd7ae1" translate="yes" xml:space="preserve">
          <source>A typical implementation holds only two members: a pointer to &lt;code&gt;T&lt;/code&gt; and a size.</source>
          <target state="translated">典型的实现仅包含两个成员：指向 &lt;code&gt;T&lt;/code&gt; 的指针和一个size。</target>
        </trans-unit>
        <trans-unit id="b1049a0bd6d2b817dcdf4dbacf6924d39c59809b" translate="yes" xml:space="preserve">
          <source>A typical implementation holds only two members: a pointer to constant &lt;code&gt;CharT&lt;/code&gt; and a size.</source>
          <target state="translated">典型的实现仅包含两个成员：指向恒定 &lt;code&gt;CharT&lt;/code&gt; 的指针和大小。</target>
        </trans-unit>
        <trans-unit id="2c4f9d8e2fe4e7c12c1285e532e5570e4bb48e5d" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_fstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_fstream&lt;/code&gt; 典型实现仅包含一个非派生数据成员： &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="b8130838cccfdb668dc1da70d0ff806b7225abc0" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_ifstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_ifstream&lt;/code&gt; 典型实现仅包含一个非派生数据成员： &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="7183d62923a8e947e2f0e103df21cd2904d87891" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_ofstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_ofstream&lt;/code&gt; 典型实现仅包含一个非派生的数据成员： &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="217f99906b2120be1fba7713f69e991a00815576" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::istream_iterator&lt;/code&gt; holds two data members: a pointer to the associated &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; object and the most recently read value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::istream_iterator&lt;/code&gt; 典型实现包含两个数据成员：指向关联的 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 对象的指针和类型 &lt;code&gt;T&lt;/code&gt; 的最近读取值。</target>
        </trans-unit>
        <trans-unit id="ad3a71fd17c76f0ee62dee1d66ae5633a375fd68" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::regex_iterator&lt;/code&gt; holds the begin and the end iterators for the underlying sequence (two instances of BidirIt), a pointer to the regular expression (&lt;code&gt;const regex_type*&lt;/code&gt;), the match flags (&lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::match_flag_type&lt;/a&gt;&lt;/code&gt;), and the current match (&lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::regex_iterator&lt;/code&gt; 典型实现包含基础序列（BidirIt的两个实例）的开始和结束迭代器，正则表达式的指针（ &lt;code&gt;const regex_type*&lt;/code&gt; ），匹配标志（ &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::match_flag_type&lt;/a&gt;&lt;/code&gt; ） ，以及当前匹配项（ &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="5594f6466e9c627a309f191d1d21416131d6dcaa" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::regex_token_iterator&lt;/code&gt; holds the underlying &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt;, a container (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;) of the requested submatch indexes, the internal counter equal to the index of the submatch, a pointer to &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;, pointing at the current submatch of the current match, and a &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; object containing the last non-matched character sequence (used in tokenizer mode).</source>
          <target state="translated">&lt;code&gt;std::regex_token_iterator&lt;/code&gt; 典型实现包含底层 &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; ，该容器是请求的子匹配索引的容器（例如 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; ），内部计数器等于子匹配的索引，是指向 &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; 的指针： ：sub_match，指向当前匹配项的当前子匹配项，以及一个 &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; 对象，该对象包含最后一个不匹配的字符序列（在令牌生成器模式下使用）。</target>
        </trans-unit>
        <trans-unit id="ec993624f290f31f38642161da480cca7738a5b4" translate="yes" xml:space="preserve">
          <source>A uniform random bit generator is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.</source>
          <target state="translated">统一随机比特生成器是一个函数对象,返回无符号整数值,使每个值在可能的结果范围内具有(理想的)相等的概率。</target>
        </trans-unit>
        <trans-unit id="5b1045e71b04fce292271774a5a72bec6686a37d" translate="yes" xml:space="preserve">
          <source>A union can have member functions (including constructors and destructors), but not virtual functions.</source>
          <target state="translated">一个联盟可以有成员函数(包括构造函数和析构函数),但不能有虚拟函数。</target>
        </trans-unit>
        <trans-unit id="a2abfe76729a7513736cb7faa5d5ce5576166784" translate="yes" xml:space="preserve">
          <source>A union cannot have base classes and cannot be used as a base class.</source>
          <target state="translated">工会不能有基类,不能作为基类使用。</target>
        </trans-unit>
        <trans-unit id="d044e7ff18d6370026b7cb48f5515536c724fbdc" translate="yes" xml:space="preserve">
          <source>A union cannot have non-static data members of reference types.</source>
          <target state="translated">一个联合体不能有引用类型的非静态数据成员。</target>
        </trans-unit>
        <trans-unit id="8c914c20794cb64933a85898ab023cc57498cff6" translate="yes" xml:space="preserve">
          <source>A union is a special class type that can hold only one of its non-static &lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt; at a time.</source>
          <target state="translated">联合是一种特殊的类类型，一次只能容纳其非静态&lt;a href=&quot;data_members&quot;&gt;数据成员之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b72fa34edde9b7a760e2ca9a63cea91e1b555145" translate="yes" xml:space="preserve">
          <source>A universal character name in a narrow string literal or a 16-bit string literal may map to more than one character, e.g. &lt;code&gt;\U0001f34c&lt;/code&gt; is 4 &lt;code&gt;char&lt;/code&gt; code units in UTF-8 (&lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt;) and 2 &lt;code&gt;char16_t&lt;/code&gt; code units in UTF-16 (&lt;code&gt;\uD83C\uDF4C&lt;/code&gt;).</source>
          <target state="translated">窄字符串文字或16位字符串文字中的通用字符名称可以映射到多个字符，例如 &lt;code&gt;\U0001f34c&lt;/code&gt; 是UTF-8中的4个 &lt;code&gt;char&lt;/code&gt; 代码单位（ &lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt; ）和2个 &lt;code&gt;char16_t&lt;/code&gt; 代码单位为UTF-16（ &lt;code&gt;\uD83C\uDF4C&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="416c36a6fa82a246cd095bd156c7aaf5425291a8" translate="yes" xml:space="preserve">
          <source>A useful guideline is that the destructor of any base class must be &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual&quot;&gt;public and virtual or protected and non-virtual&lt;/a&gt;.</source>
          <target state="translated">一个有用的准则是，任何基类的析构函数都必须是&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual&quot;&gt;public和virtual或protected和non-virtual&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83e4b1da3b5d3236546ebba09aeb934da81e6f4f" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt; can be a template.</source>
          <target state="translated">用户定义的&lt;a href=&quot;cast_operator&quot;&gt;转换功能&lt;/a&gt;可以是模板。</target>
        </trans-unit>
        <trans-unit id="5d638bfd657359641307f2e7271f6931cb2015b9" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;code&gt;std::unexpected_handler&lt;/code&gt; is expected to either terminate the program or throw an exception. If it throws an exception, one of the following three situations may be encountered:</source>
          <target state="translated">用户定义的 &lt;code&gt;std::unexpected_handler&lt;/code&gt; 应该终止程序或引发异常。如果引发异常，则可能会遇到以下三种情况之一：</target>
        </trans-unit>
        <trans-unit id="73f25ff036d8280e869a001e21e48bbeb542c334" translate="yes" xml:space="preserve">
          <source>A user-defined conversion consists of zero or one non-explicit single-argument constructor or non-explicit &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt; call.</source>
          <target state="translated">用户定义的转换由零个或一个非显式单参数构造函数或非显式&lt;a href=&quot;cast_operator&quot;&gt;转换函数&lt;/a&gt;调用组成。</target>
        </trans-unit>
        <trans-unit id="d0e1aabd13d35e1072413a4e56940753290b1935" translate="yes" xml:space="preserve">
          <source>A user-defined conversion function template cannot have a deduced return type.</source>
          <target state="translated">用户定义的转换函数模板不能有推导返回类型。</target>
        </trans-unit>
        <trans-unit id="1e6c06935ba93da6b0506db32bcdb2cfcdba4051" translate="yes" xml:space="preserve">
          <source>A user-defined literal is an expression of any of the following forms.</source>
          <target state="translated">用户定义的文字是以下任何一种形式的表达式。</target>
        </trans-unit>
        <trans-unit id="3054b1de584f16f3593abd57817b8a39cfd5c191" translate="yes" xml:space="preserve">
          <source>A user-provided &lt;code&gt;Compare&lt;/code&gt; can be supplied to change the ordering, e.g. using &lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt; would cause the smallest element to appear as the &lt;code&gt;&lt;a href=&quot;priority_queue/top&quot;&gt;top()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以提供用户提供的 &lt;code&gt;Compare&lt;/code&gt; 来更改顺序，例如，使用 &lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt; 会使最小的元素显示为 &lt;code&gt;&lt;a href=&quot;priority_queue/top&quot;&gt;top()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="640dc08af4538f2be62eb03eb3dd195df49a90d2" translate="yes" xml:space="preserve">
          <source>A using-declaration also can't be used to introduce the name of a dependent member template as a</source>
          <target state="translated">使用声明也不能用来引入依赖成员模板的名称作为</target>
        </trans-unit>
        <trans-unit id="4bae902040c5ab2ebd693033e3fed94dda49e2af" translate="yes" xml:space="preserve">
          <source>A using-declaration cannot name a member template specialization (&lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; is not permitted by the grammar):</source>
          <target state="translated">using声明不能命名成员模板专业化（语法不允许使用&lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="ef90b2e3eff9b374774e4a806f69699ec8e2d794" translate="yes" xml:space="preserve">
          <source>A using-declaration cannot refer to a namespace, to a scoped enumerator, to a destructor of a base class or to a specialization of a member template for a user-defined conversion function.</source>
          <target state="translated">一个使用声明不能引用一个命名空间,不能引用一个作用域枚举器,不能引用一个基类的析构器,也不能引用一个用户定义的转换函数的成员模板的特殊化。</target>
        </trans-unit>
        <trans-unit id="b03fbcaa0bf1071b311fbaae0c5ce6b26d0a8ede" translate="yes" xml:space="preserve">
          <source>A using-declaration with more than one using-declarator is equivalent to a corresponding sequence of using-declarations with one using-declarator.</source>
          <target state="translated">一个有多个使用声明者的使用声明相当于一个有一个使用声明者的使用声明的对应序列。</target>
        </trans-unit>
        <trans-unit id="20d0f9a0bea74c92ad5ff18da1b24cd553bbba2b" translate="yes" xml:space="preserve">
          <source>A valarray with the same size as the parameter.</source>
          <target state="translated">一个与参数大小相同的数值组。</target>
        </trans-unit>
        <trans-unit id="9b0aa598587fc3cc855c9c9ccc2c85d04dd3b0d5" translate="yes" xml:space="preserve">
          <source>A valid const iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">一个有效的常量迭代到 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14a30aab0776a047f20feb27371310d867438a4f" translate="yes" xml:space="preserve">
          <source>A valid dereferenceable const iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">有效可提领常量迭代到 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c5ba5e3ccd5588e225779b9a36ab64c069c240a" translate="yes" xml:space="preserve">
          <source>A valid dereferenceable iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">有效可提领迭代器 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28223fe6cd5ada49f5862218ac60de143b2567db" translate="yes" xml:space="preserve">
          <source>A value equal to 0 if the path is lexicographically equal to the given path.</source>
          <target state="translated">如果路径在词法上等于给定的路径,数值等于0。</target>
        </trans-unit>
        <trans-unit id="a50061555eec54932403da5e038843403742ee9c" translate="yes" xml:space="preserve">
          <source>A value equivalent to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">等于 &lt;code&gt;c&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="de1ab572a1a705bc1af0966dac1fe26f7ab37241" translate="yes" xml:space="preserve">
          <source>A value greater than 0 if the path is lexicographically greater than the given path.</source>
          <target state="translated">如果路径在词法上大于给定的路径,数值大于0。</target>
        </trans-unit>
        <trans-unit id="59605f92ecf81d222cf73bc53f88e408d0be42bc" translate="yes" xml:space="preserve">
          <source>A value less than 0 if the path is lexicographically less than the given path.</source>
          <target state="translated">如果路径在词法上小于给定的路径,数值小于0。</target>
        </trans-unit>
        <trans-unit id="772e15e1bdd5eccbbc37f434f301068fa5b598a7" translate="yes" xml:space="preserve">
          <source>A value less than zero if this sub_match is</source>
          <target state="translated">小于零的值,如果这个sub_match为</target>
        </trans-unit>
        <trans-unit id="32241575a78d789ffd0a6260e7ef09d51214c2a4" translate="yes" xml:space="preserve">
          <source>A value not equivalent to any valid value of type &lt;code&gt;char_type&lt;/code&gt;.</source>
          <target state="translated">一个不等于 &lt;code&gt;char_type&lt;/code&gt; 类型的有效值的值。</target>
        </trans-unit>
        <trans-unit id="6b19e1b2f4ff9e9aafad05b04d18d7cec329645b" translate="yes" xml:space="preserve">
          <source>A value of a floating-point type can also be converted to any complete enumeration type.</source>
          <target state="translated">浮点类型的值也可以转换为任何完整的枚举类型。</target>
        </trans-unit>
        <trans-unit id="63a22bbd341be0d94948a8da39b757c96e4a822a" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;future&quot;&lt;/code&gt;.</source>
          <target state="translated">一个类型为 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 值，该值保存与错误类别 &lt;code&gt;&quot;future&quot;&lt;/code&gt; 相关的 &lt;code&gt;e&lt;/code&gt; 中的错误代码号。</target>
        </trans-unit>
        <trans-unit id="8d689f1f7f9107c84de7e9e6a91164c4d8d448b7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 值，该值保存 &lt;code&gt;e&lt;/code&gt; 中与错误类别 &lt;code&gt;&quot;iostream&quot;&lt;/code&gt; 相关联的错误代码编号。</target>
        </trans-unit>
        <trans-unit id="d85edc98c1d148807f1167309444da367dce2885" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;future&quot;&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 值，该值保存 &lt;code&gt;e&lt;/code&gt; 中与错误类别 &lt;code&gt;&quot;future&quot;&lt;/code&gt; 相关联的错误代码号。</target>
        </trans-unit>
        <trans-unit id="db29599a3ec1300b12f7cddbf4961efd2a438f2c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 值，该值保存与错误类别 &lt;code&gt;&quot;iostream&quot;&lt;/code&gt; 关联的 &lt;code&gt;e&lt;/code&gt; 中的错误代码号。</target>
        </trans-unit>
        <trans-unit id="d4716864d7aecb12710c82c5051f8f56cfc5d9f6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::result&lt;/a&gt;&lt;/code&gt;, indicating the success status as follows:</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::result&lt;/a&gt;&lt;/code&gt; ，指示成功状态，如下所示：</target>
        </trans-unit>
        <trans-unit id="32fad6cd0042895426d631ee6330654d50fdd26f" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; identifying the thread associated with &lt;code&gt;*this&lt;/code&gt;. If there is no thread associated, default constructed &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; 值，用于标识与 &lt;code&gt;*this&lt;/code&gt; 关联的线程。如果没有关联的线程，则返回默认构造的 &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4007ab79efb7d58184f823559bcab8f2c0fe4508" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;X::key_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X::key_type&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="072712158f85df6191a61fbd61f9b1af57edb2a6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;X::value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9fa2a7989928288a59b9d1061cab281384dc7d7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;dateorder&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;dateorder&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="e52779b1e6c9706944a08739b4d2e94ab73e1ebe" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt; representing &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt; 值，表示 &lt;code&gt;t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="372178480f2f29b6cd4a1502b1b12fa8b61b4a68" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::partial_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">如上所述，类型为 &lt;code&gt;std::partial_ordering&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="f50da534940de9fa538b0344ec2f07e991732fc7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::strong_equality&lt;/code&gt;, as described above.</source>
          <target state="translated">&lt;code&gt;std::strong_equality&lt;/code&gt; ，类型为std :: strong_equality的值。</target>
        </trans-unit>
        <trans-unit id="1240d3098b2313d3e38b4e6524a3981c2caf173b" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::strong_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">&lt;code&gt;std::strong_ordering&lt;/code&gt; ，类型为std :: strong_ordering的值。</target>
        </trans-unit>
        <trans-unit id="d920da1ed499cf59fb8f2ff084478f87888ebedf" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::weak_equality&lt;/code&gt;, as described above.</source>
          <target state="translated">&lt;code&gt;std::weak_equality&lt;/code&gt; ，类型为std :: weak_equality的值。</target>
        </trans-unit>
        <trans-unit id="84362b6647406e2ba1f03eb0961d6929e28947bb" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::weak_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">&lt;code&gt;std::weak_ordering&lt;/code&gt; ，类型为std :: weak_ordering的值。</target>
        </trans-unit>
        <trans-unit id="d92cb041f91a75157fbd95d555f69774c1ab1976" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;void (*)(int)&lt;/code&gt;. When returned by &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt;, indicates that an error has occurred.</source>
          <target state="translated">类型 &lt;code&gt;void (*)(int)&lt;/code&gt; 。当归还时 &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; ，表明发生了错误。</target>
        </trans-unit>
        <trans-unit id="03d7158f8947427f81b002e1dd1993eed28a9ff7" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;!c(ku, r)&lt;/code&gt;</source>
          <target state="translated">使得 &lt;code&gt;a&lt;/code&gt; 相对于 &lt;code&gt;!c(ku, r)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="450945ae5d73489824ccfb0cd773638c26cd3654" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;c(r, ke)&lt;/code&gt; and &lt;code&gt;!c(ke, r)&lt;/code&gt;, with &lt;code&gt;c(r, ke)&lt;/code&gt; implying &lt;code&gt;!c(ke, r)&lt;/code&gt;</source>
          <target state="translated">使得 &lt;code&gt;a&lt;/code&gt; 相对于 &lt;code&gt;c(r, ke)&lt;/code&gt; 和 &lt;code&gt;!c(ke, r)&lt;/code&gt; 划分的值，其中 &lt;code&gt;c(r, ke)&lt;/code&gt; 表示 &lt;code&gt;!c(ke, r)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66162c2a5d40aef1c22e1f7994ce56c76783a955" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;c(r,kl)&lt;/code&gt;, with &lt;code&gt;r&lt;/code&gt; the key value of &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">使得A值 &lt;code&gt;a&lt;/code&gt; 相对于分配到 &lt;code&gt;c(r,kl)&lt;/code&gt; ，具有 &lt;code&gt;r&lt;/code&gt; 的密钥值 &lt;code&gt;e&lt;/code&gt; 和 &lt;code&gt;e&lt;/code&gt; 在 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0a71e388e98e2de2ca1e6729afcd2caf02f4c95" translate="yes" xml:space="preserve">
          <source>A value that is identical for all &lt;code&gt;type_info&lt;/code&gt; objects referring to the same type.</source>
          <target state="translated">所有 &lt;code&gt;type_info&lt;/code&gt; 的值都相同引用相同类型的对象，该值都相同。</target>
        </trans-unit>
        <trans-unit id="79bfc8c0189d75c8cec44ecc8d6396e58c45af93" translate="yes" xml:space="preserve">
          <source>A variable template declaration may appear at class scope, in which case it declares a static data member template. See &lt;a href=&quot;variable_template&quot;&gt;variable templates&lt;/a&gt; for details.</source>
          <target state="translated">变量模板声明可能会出现在类范围内，在这种情况下，它将声明一个静态数据成员模板。有关详细信息，请参见&lt;a href=&quot;variable_template&quot;&gt;变量模板&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a00357cf9d6e102b6c1e5ad12063c42c54ad2ce7" translate="yes" xml:space="preserve">
          <source>A variable template defines a family of variables or static data members.</source>
          <target state="translated">变量模板定义了一个变量家族或静态数据成员。</target>
        </trans-unit>
        <trans-unit id="aff896d1642161992d5991ac4ba8de8003708a52" translate="yes" xml:space="preserve">
          <source>A variable template may be introduced by a template declaration at namespace scope, where declaration declares a variable.</source>
          <target state="translated">变量模板可以通过命名空间范围的模板声明引入,其中声明声明一个变量。</target>
        </trans-unit>
        <trans-unit id="09fc623a5cbacf9a90a9e712a74ec555cda701fd" translate="yes" xml:space="preserve">
          <source>A variadic class template can be instantiated with any number of template arguments:</source>
          <target state="translated">一个变量类模板可以用任意数量的模板参数来实例化。</target>
        </trans-unit>
        <trans-unit id="1fb3820743def9d88fa6123aad6fc9bce3f38a75" translate="yes" xml:space="preserve">
          <source>A variadic function template can be called with any number of function arguments (the template arguments are deduced through &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;):</source>
          <target state="translated">可变参数函数模板可以使用任意数量的函数参数调用（模板参数可通过&lt;a href=&quot;template_argument_deduction&quot;&gt;模板参数deduction推导&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="bb6e304c2616213d182d17fab4792e56d3349945" translate="yes" xml:space="preserve">
          <source>A variant is not permitted to hold references, arrays, or the type &lt;code&gt;void&lt;/code&gt;. Empty variants are also ill-formed (&lt;code&gt;std::variant&amp;lt;&lt;a href=&quot;variant/monostate&quot;&gt;std::monostate&lt;/a&gt;&amp;gt;&lt;/code&gt; can be used instead).</source>
          <target state="translated">不允许变体保存引用，数组或类型 &lt;code&gt;void&lt;/code&gt; 。空变量也格式不正确（可以使用 &lt;code&gt;std::variant&amp;lt;&lt;a href=&quot;variant/monostate&quot;&gt;std::monostate&lt;/a&gt;&amp;gt;&lt;/code&gt; 代替）。</target>
        </trans-unit>
        <trans-unit id="ce4af0ae9360b0d87edd912329cc74243aa60def" translate="yes" xml:space="preserve">
          <source>A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type.</source>
          <target state="translated">一个变体允许持有同一类型一次以上,并持有同一类型的不同的cv限定版本。</target>
        </trans-unit>
        <trans-unit id="ea9112a4205a8e149b6d870c2538c2387fcc45a2" translate="yes" xml:space="preserve">
          <source>A variant may become valueless in the following situations:</source>
          <target state="translated">在下列情况下,一个变体可能变得毫无价值:</target>
        </trans-unit>
        <trans-unit id="360ab0f56da776d903fad4cd3c7802b6cff86bff" translate="yes" xml:space="preserve">
          <source>A variant that is valueless by exception is treated as being in an invalid state: &lt;a href=&quot;index&quot;&gt;index&lt;/a&gt; returns &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;, &lt;a href=&quot;get&quot;&gt;get&lt;/a&gt; and &lt;a href=&quot;visit&quot;&gt;visit&lt;/a&gt; throw &lt;a href=&quot;bad_variant_access&quot;&gt;bad_variant_access&lt;/a&gt;.</source>
          <target state="translated">异常无价值的变体被视为处于无效状态：&lt;a href=&quot;index&quot;&gt;索引&lt;/a&gt;返回&lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;，&lt;a href=&quot;get&quot;&gt;获取&lt;/a&gt;并&lt;a href=&quot;visit&quot;&gt;访问&lt;/a&gt;抛出&lt;a href=&quot;bad_variant_access&quot;&gt;bad_variant_access&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d13acd0a8aed6cefb7c9972fe8dbd4991eb6d5ec" translate="yes" xml:space="preserve">
          <source>A vector of strings can be sorted according to a non-default locale by using the locale object as comparator:</source>
          <target state="translated">通过使用locale对象作为比较器,可以根据非默认的locale对字符串向量进行排序。</target>
        </trans-unit>
        <trans-unit id="c3e281fb8afe5cc3b522bbdd748cec3c0126f3da" translate="yes" xml:space="preserve">
          <source>A very common implementation-defined form of main() has a third argument (in addition to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;), of type &lt;code&gt;char*[]&lt;/code&gt;, pointing at &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the execution environment variables&lt;/a&gt;.</source>
          <target state="translated">main（）的一种非常常见的实现定义形式，具有第三个参数（除了 &lt;code&gt;argc&lt;/code&gt; 和 &lt;code&gt;argv&lt;/code&gt; ），类型为 &lt;code&gt;char*[]&lt;/code&gt; ，它指向指向&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;执行环境变量的指针数组&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ec66bbac0bdedd0761cb72a1751288a98eb028c" translate="yes" xml:space="preserve">
          <source>A very common implementation-defined form of main() has a third argument (in addition to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;), of type &lt;code&gt;char*[]&lt;/code&gt;, pointing at &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the execution environment variables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cef77f8c0ffb4916f8bc0498dc7440820ca8d36" translate="yes" xml:space="preserve">
          <source>A zero-initialized pointer is the null pointer value of its type, even if the value of the null pointer is not integral zero.</source>
          <target state="translated">零初始化指针是其类型的空指针值,即使空指针的值不是积分零。</target>
        </trans-unit>
        <trans-unit id="7be129f416228534857a690cd4c38374c5515373" translate="yes" xml:space="preserve">
          <source>A, and B</source>
          <target state="translated">A和B</target>
        </trans-unit>
        <trans-unit id="a5e35ae614f82259bcebce61eb00073751f2e388" translate="yes" xml:space="preserve">
          <source>A, and B is a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation, then X precedes B in S d) if a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence X</source>
          <target state="translated">A，并且B是 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 操作，则X在S d中先于B，如果 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 栅栏X</target>
        </trans-unit>
        <trans-unit id="48a01a12d57f9009c8dea86e8610f3bdea642dd4" translate="yes" xml:space="preserve">
          <source>A. Williams (2012), &quot;C++ concurrency in action&quot; 9.2.4 Interrupting a wait on std::condition_variable_any</source>
          <target state="translated">A.Williams(2012),&quot;C++并发在行动&quot; 9.2.4中断对std::condition_variable_any的等待。</target>
        </trans-unit>
        <trans-unit id="6b4fe715ea89fb871c5a975d173f10a5adf57e7c" translate="yes" xml:space="preserve">
          <source>A1, A2, A3,... is a possibly empty list of arbitrary expressions, except the comma operator is not allowed at the top level to avoid ambiguity.</source>
          <target state="translated">A1,A2,A3,......是一个可能为空的任意表达式列表,只是为了避免歧义,在顶层不允许使用逗号操作。</target>
        </trans-unit>
        <trans-unit id="de2c49eaafb50b14e68d760cacef2f0ba0ba8f45" translate="yes" xml:space="preserve">
          <source>ADL</source>
          <target state="translated">ADL</target>
        </trans-unit>
        <trans-unit id="cd5086cb4e7d0efbc40ccb220af4c1d024f33775" translate="yes" xml:space="preserve">
          <source>ADL can find a &lt;a href=&quot;friend&quot;&gt;friend function&lt;/a&gt; (typically, an overloaded operator) that is defined entirely within a class or class template, even if it was never declared at namespace level.</source>
          <target state="translated">ADL可以找到&lt;a href=&quot;friend&quot;&gt;朋友功能&lt;/a&gt;完全在类或类模板中定义（通常是重载的运算符），即使从未在命名空间级别上声明它。</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="daf2a98f5077d337e35a18a770cad80d218e9ca5" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE NOON WITH JEEM WITH YEH FINAL FORM</source>
          <target state="translated">阿拉伯之光正午与JEEM与YEH的最终形式。</target>
        </trans-unit>
        <trans-unit id="5f8c72f94f6217e6dad861d24c88516ef9cd816b" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE SALLA USED AS KORANIC STOP SIGN ISOLATED FORM -</source>
          <target state="translated">用作朝鲜语停止标志的阿拉伯字母SALLA ISOLATED FORM--------。</target>
        </trans-unit>
        <trans-unit id="af1d8ae2aa108f95b9b57f28478231da2a606638" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE TEH WITH JEEM WITH MEEM INITIAL FORM -</source>
          <target state="translated">阿拉伯文字母 &quot;TEH WITH JEEM WITH MEEM &quot;初始形式----阿拉伯文字母 &quot;TEH WITH JEEM WITH MEEM</target>
        </trans-unit>
        <trans-unit id="187459c12cbce645deb52d74f3d6152a7a9a17fc" translate="yes" xml:space="preserve">
          <source>ASCII Chart</source>
          <target state="translated">ASCII图表</target>
        </trans-unit>
        <trans-unit id="6b85275355e86325dde0c35693852c2d7820c750" translate="yes" xml:space="preserve">
          <source>ASCII chart</source>
          <target state="translated">ASCII图</target>
        </trans-unit>
        <trans-unit id="6ff2c765d8c7f7f1624b70244d10913facb7ae0b" translate="yes" xml:space="preserve">
          <source>ASCII values</source>
          <target state="translated">ASCII值</target>
        </trans-unit>
        <trans-unit id="63e21a0c9c10fbf518b0166eb437a67f1ed962cd" translate="yes" xml:space="preserve">
          <source>ATOMIC_FLAG_INIT</source>
          <target state="translated">ATOMIC_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="0b0620452fea1cd6ef04952a1260146f273e310f" translate="yes" xml:space="preserve">
          <source>ATOMIC_VAR_INIT</source>
          <target state="translated">ATOMIC_VAR_INIT</target>
        </trans-unit>
        <trans-unit id="435b6099910c97d9bc8e078e332560e92819291f" translate="yes" xml:space="preserve">
          <source>Abandons the shared state and destroys the stored task object.</source>
          <target state="translated">放弃共享状态并销毁存储的任务对象。</target>
        </trans-unit>
        <trans-unit id="36e1c539cc780bc605cb01b3fddc5d8db9c3b6ab" translate="yes" xml:space="preserve">
          <source>Abandons the shared state:</source>
          <target state="translated">放弃共享状态。</target>
        </trans-unit>
        <trans-unit id="e7becc73c7eaff031859fb120395433f96283795" translate="yes" xml:space="preserve">
          <source>Abbreviated function template</source>
          <target state="translated">缩略函数模板</target>
        </trans-unit>
        <trans-unit id="019202b59ca73881cfaab35533cb5a7033c39a80" translate="yes" xml:space="preserve">
          <source>Abbreviated function templates can be specialized like all function templates.</source>
          <target state="translated">缩略函数模板可以像所有函数模板一样进行专门化。</target>
        </trans-unit>
        <trans-unit id="fd2f1ad3f3e244485410235abcc0dcd9d528402f" translate="yes" xml:space="preserve">
          <source>Absolute value of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 的绝对值。</target>
        </trans-unit>
        <trans-unit id="1b11f0b716439740a7eef7b0954e8e03f2442de7" translate="yes" xml:space="preserve">
          <source>Abstract classes are used to represent general concepts (for example, Shape, Animal), which can be used as base classes for concrete classes (for example, Circle, Dog).</source>
          <target state="translated">抽象类用来表示一般的概念(例如,形状、动物),可以作为具体类(例如,圆、狗)的基类。</target>
        </trans-unit>
        <trans-unit id="496f013275ea0cccdde9e4ce5e27272837e636f5" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be used as parameter types, as function return types, or as the type of an explicit conversion (note this is checked at the point of definition and function call, since at the point of function declaration parameter and return type may be incomplete).</source>
          <target state="translated">抽象类型不能作为参数类型,不能作为函数返回类型,也不能作为显式转换的类型(注意这一点要在定义和函数调用时进行检查,因为在函数声明时参数和返回类型可能是不完整的)。</target>
        </trans-unit>
        <trans-unit id="8fda6cf2aae5ca82e8dc635a5cfbd7ff01d1ac31" translate="yes" xml:space="preserve">
          <source>Abstraction</source>
          <target state="translated">Abstraction</target>
        </trans-unit>
        <trans-unit id="fe89f3fca6949588976c79493bd13c9b36f00658" translate="yes" xml:space="preserve">
          <source>Access checking for the names used in &lt;a href=&quot;default_arguments&quot;&gt;default function arguments&lt;/a&gt; as well as in the default &lt;a href=&quot;template_parameters#Default_template_arguments&quot;&gt;template parameters&lt;/a&gt; is performed at the point of declaration, not at the point of use.</source>
          <target state="translated">对&lt;a href=&quot;default_arguments&quot;&gt;默认函数参数&lt;/a&gt;以及默认&lt;a href=&quot;template_parameters#Default_template_arguments&quot;&gt;模板参数中&lt;/a&gt;使用的名称的访问检查是在声明时执行的，而不是在使用时执行的。</target>
        </trans-unit>
        <trans-unit id="9de67dfb6d06413cdc219824a0f3f88445b9f32c" translate="yes" xml:space="preserve">
          <source>Access out of bounds</source>
          <target state="translated">出界访问</target>
        </trans-unit>
        <trans-unit id="64d102e911590ffe48aba24684384d363cf0b36b" translate="yes" xml:space="preserve">
          <source>Access outside of lifetime</source>
          <target state="translated">生命期外的访问</target>
        </trans-unit>
        <trans-unit id="ff2202db9230ee307101c952851e1360ff1ce903" translate="yes" xml:space="preserve">
          <source>Access overhead: In pImpl, each call to a private member function indirects through a pointer. Each access to a public member made by a private member indirects through another pointer. Both indirections cross translation unit boundaries and so can only be optimized out by link-time optimization. Note that OO factory requires indirection across translation units to access both public data and implementation detail, and offers even fewer opportunities for the link time optimizer due to virtual dispatch.</source>
          <target state="translated">访问开销。在pImpl中,对私有成员函数的每一次调用都要通过一个指针间接进行。私有成员对公共成员的每一次访问都会通过另一个指针间接进行。这两种间接都跨越了翻译单元的边界,所以只能通过链接时间优化来优化掉。需要注意的是,OO工厂需要跨翻译单元间接访问公共数据和实现细节,由于虚拟调度,为链路时间优化器提供的机会更少。</target>
        </trans-unit>
        <trans-unit id="41dcddad26f26d0b23476e3af19f8e0cff1f9f7e" translate="yes" xml:space="preserve">
          <source>Access permissions model &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX permission bits&lt;/a&gt;, and any individual file permissions (as reported by &lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;) are a combination of some of the following bits:</source>
          <target state="translated">访问权限模型&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX权限位&lt;/a&gt;和任何单个文件权限（如&lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;所报告）是以下一些位的组合：</target>
        </trans-unit>
        <trans-unit id="ff48fcdd36448626dfca91c0959a95a136068169" translate="yes" xml:space="preserve">
          <source>Access permissions model &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX permission bits&lt;/a&gt;, and any individual file permissions (as reported by &lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;) are a combination of some of the following bits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29695d27ada4464e68e5f7e3d3cd693fa6cadcf" translate="yes" xml:space="preserve">
          <source>Access rules for the names of &lt;a href=&quot;virtual&quot;&gt;virtual functions&lt;/a&gt; are checked at the call point using the type of the expression used to denote the object for which the member function is called. The access of the final overrider is ignored.</source>
          <target state="translated">&lt;a href=&quot;virtual&quot;&gt;虚拟函数&lt;/a&gt;名称的访问规则在调用点使用用于表示为其调用成员函数的对象的表达式类型，检查。最终替代程序的访问将被忽略。</target>
        </trans-unit>
        <trans-unit id="172f15fcb1759434b4e5cac298998c9f90e5367d" translate="yes" xml:space="preserve">
          <source>Access specifiers</source>
          <target state="translated">访问指定人</target>
        </trans-unit>
        <trans-unit id="fd9b61139d61fe4a3ad562d5c3fb1467d5f0fb25" translate="yes" xml:space="preserve">
          <source>Access specifiers give the author of the class the ability to decide which class members are accessible to the users of the class (that is, the</source>
          <target state="translated">访问指定符给类的作者提供了决定哪些类成员可以被类的用户访问的能力(也就是</target>
        </trans-unit>
        <trans-unit id="b5f1627a2f9ef35b0cad78d685d46c26ac79a8ba" translate="yes" xml:space="preserve">
          <source>Access to a non-static data member or a call to a non-static member function.</source>
          <target state="translated">访问一个非静态数据成员或调用一个非静态成员函数。</target>
        </trans-unit>
        <trans-unit id="1632238dd01e0d2949d4e0ad89257742628b773a" translate="yes" xml:space="preserve">
          <source>Access to pointer passed to realloc</source>
          <target state="translated">访问传递给realloc的指针。</target>
        </trans-unit>
        <trans-unit id="27559787dd122b923d06b7298557d1cd2c568a23" translate="yes" xml:space="preserve">
          <source>Access to the &lt;code&gt;p&lt;/code&gt;'s deleter. If the shared pointer &lt;code&gt;p&lt;/code&gt; owns a deleter of type cv-unqualified &lt;code&gt;Deleter&lt;/code&gt; (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer.</source>
          <target state="translated">访问 &lt;code&gt;p&lt;/code&gt; 的删除器。如果共享指针 &lt;code&gt;p&lt;/code&gt; 拥有类型为cv-unqualified &lt;code&gt;Deleter&lt;/code&gt; 的删除器（例如，如果它是使用将删除器作为参数的构造函数之一创建的），则将指针返回该删除器。否则，返回空指针。</target>
        </trans-unit>
        <trans-unit id="5c1d13d1c544b3feecb6e442b5b9a73c51c6b267" translate="yes" xml:space="preserve">
          <source>Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a &lt;code&gt;shared_future&lt;/code&gt; object.</source>
          <target state="translated">如果每个线程都通过其自己的 &lt;code&gt;shared_future&lt;/code&gt; 对象副本进行访问，则从多个线程访问相同的共享状态是安全的。</target>
        </trans-unit>
        <trans-unit id="f563d2f693e12ab63ee51309db6c0dd439835d3c" translate="yes" xml:space="preserve">
          <source>Accesses a member of its operand.</source>
          <target state="translated">访问操作数的一个成员。</target>
        </trans-unit>
        <trans-unit id="a42b2fe3c4d5fcc9a9d311beb7c3efb130c09b8a" translate="yes" xml:space="preserve">
          <source>Accesses the bit at position &lt;code&gt;pos&lt;/code&gt;. The first version returns the value of the bit, the second version returns an object of type &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; that allows modification of the value.</source>
          <target state="translated">访问位置 &lt;code&gt;pos&lt;/code&gt; 处的位。第一个版本返回bit的值，第二个版本返回 &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; 类型的对象，该对象允许修改值。</target>
        </trans-unit>
        <trans-unit id="d60917183a0203e125a2a367082f7e505a1b54cc" translate="yes" xml:space="preserve">
          <source>Accesses the contained value.</source>
          <target state="translated">访问包含的值。</target>
        </trans-unit>
        <trans-unit id="5ffc054a82694395488926c5d88d20377f2fee4f" translate="yes" xml:space="preserve">
          <source>Accesses the file permissions information.</source>
          <target state="translated">访问文件权限信息。</target>
        </trans-unit>
        <trans-unit id="0faa3d14d648895a9103231a47e67306cf3658f8" translate="yes" xml:space="preserve">
          <source>Accesses the file type information.</source>
          <target state="translated">访问文件类型信息。</target>
        </trans-unit>
        <trans-unit id="9ab9ff8b7be4b7d40eb92e8afba99b14b56097f9" translate="yes" xml:space="preserve">
          <source>Accesses the imaginary part of the complex number.</source>
          <target state="translated">访问复数的虚部。</target>
        </trans-unit>
        <trans-unit id="6c9900004652bab063edd448abb4e13e10ff694e" translate="yes" xml:space="preserve">
          <source>Accesses the index stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">访问存储在 &lt;code&gt;*this&lt;/code&gt; 中的索引。</target>
        </trans-unit>
        <trans-unit id="f3c82d4ce7723e142d0946770db58f80f216a936" translate="yes" xml:space="preserve">
          <source>Accesses the name and target of this &lt;code&gt;link&lt;/code&gt; object.</source>
          <target state="translated">访问此 &lt;code&gt;link&lt;/code&gt; 对象的名称和目标。</target>
        </trans-unit>
        <trans-unit id="ad5cf92f478d0439f59cdb4880f47ebacaf46e23" translate="yes" xml:space="preserve">
          <source>Accesses the native handle of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">访问 &lt;code&gt;*this&lt;/code&gt; 的本机句柄。</target>
        </trans-unit>
        <trans-unit id="9d7d833d3713305bce90c91948acf875f0c20ba4" translate="yes" xml:space="preserve">
          <source>Accesses the native path name as a character string.</source>
          <target state="translated">以字符串形式访问本地路径名。</target>
        </trans-unit>
        <trans-unit id="3ae496a866ebcdc4db51cd8794d1e50d8d500069" translate="yes" xml:space="preserve">
          <source>Accesses the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">访问指向的&lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9823697b16ef01bf1ebfdd504cd02cc048fbff41" translate="yes" xml:space="preserve">
          <source>Accesses the real part of the complex number.</source>
          <target state="translated">访问复数的实部。</target>
        </trans-unit>
        <trans-unit id="bbd2d3ce5c26cd90201155a08a10040ce8faa66b" translate="yes" xml:space="preserve">
          <source>Accessibility applies to all names with no regard to their origin, so a name introduced by a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;using_declaration&quot;&gt;using declarations&lt;/a&gt; is checked, not the name it refers to.</source>
          <target state="translated">可访问性适用于所有名称，而与它们的来源无关，因此将检查由&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;引入或&lt;a href=&quot;using_declaration&quot;&gt;使用声明&lt;/a&gt;的名称，而不是其引用的名称。</target>
        </trans-unit>
        <trans-unit id="db5f1eeeca9d3c68907d330e642c8ec9d5a0116f" translate="yes" xml:space="preserve">
          <source>Accessing an object using an expression of a type other than the type with which it was created is undefined behavior in many cases, see &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;reinterpret_cast&lt;/a&gt; for the list of exceptions and examples.</source>
          <target state="translated">在许多情况下，使用除创建对象类型之外的其他类型的表达式访问对象是未定义的行为，有关异常和示例的列表，请参见&lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;reinterpret_cast&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43edbdec6f4616d56db2ed67623f9b6b877668ea" translate="yes" xml:space="preserve">
          <source>Accessing the variable during initialization from another thread, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; operation).</source>
          <target state="translated">在初始化期间从另一个线程访问该变量，即使通过原子操作也是如此（如果使用 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; 操作将地址立即传递给另一个线程，则可能会发生这种情况）。</target>
        </trans-unit>
        <trans-unit id="bd21f9aade4e041d6127535e2103b7265328e814" translate="yes" xml:space="preserve">
          <source>Acquire operation</source>
          <target state="translated">购置业务</target>
        </trans-unit>
        <trans-unit id="336eaf1465ee3c86483dca958f5b3f81e8c35309" translate="yes" xml:space="preserve">
          <source>Acquires ownership of the given mutex &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">获取给定互斥锁 &lt;code&gt;m&lt;/code&gt; 的所有权。</target>
        </trans-unit>
        <trans-unit id="a0bfcec1da334e9014a69ecff78b70a46245c533" translate="yes" xml:space="preserve">
          <source>Acquires ownership of the given mutexes &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">获取给定互斥锁 &lt;code&gt;m&lt;/code&gt; 的所有权。</target>
        </trans-unit>
        <trans-unit id="c865fe856f24b54f5a468d814de44d24b3ad8da2" translate="yes" xml:space="preserve">
          <source>Acquires shared ownership of the mutex. If another thread is holding the mutex in exclusive ownership, a call to &lt;code&gt;lock_shared&lt;/code&gt; will block execution until shared ownership can be acquired.</source>
          <target state="translated">获取互斥量的共享所有权。如果另一个线程以互斥所有权持有该互斥锁，则对 &lt;code&gt;lock_shared&lt;/code&gt; 的调用将阻止执行，直到可以获取共享所有权为止。</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="894e0d0ca601136dd7488a48cc4e246850d2e574" translate="yes" xml:space="preserve">
          <source>Action if file</source>
          <target state="translated">行动,如果文件</target>
        </trans-unit>
        <trans-unit id="5405a9d57e6b63ab5821d9588dde26920a308e00" translate="yes" xml:space="preserve">
          <source>Action if file already exists</source>
          <target state="translated">如果文件已经存在,则采取行动</target>
        </trans-unit>
        <trans-unit id="c3c1db410576ecf3d85988b0535501a3dc1d020f" translate="yes" xml:space="preserve">
          <source>Action if file does not exist</source>
          <target state="translated">文件不存在时的行动</target>
        </trans-unit>
        <trans-unit id="a7817b78f6b68e579f4e4537bfed1875e7ae184f" translate="yes" xml:space="preserve">
          <source>Actual implementations vary:</source>
          <target state="translated">实际执行情况各不相同。</target>
        </trans-unit>
        <trans-unit id="3ca7e3d2e4ac34bc514652447560887a72b3f649" translate="yes" xml:space="preserve">
          <source>Adaptors</source>
          <target state="translated">Adaptors</target>
        </trans-unit>
        <trans-unit id="fb414d455da6b9468629ebcfdfce20d9ea740f72" translate="yes" xml:space="preserve">
          <source>Adding constexpr modifiers to &lt;code&gt;&lt;a href=&quot;iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;iterator/move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;iterator#Container_access&quot;&gt;range access&lt;/a&gt;</source>
          <target state="translated">将constexpr修饰符添加到 &lt;code&gt;&lt;a href=&quot;iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;iterator/move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; 和&lt;a href=&quot;iterator#Container_access&quot;&gt;范围访问&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9c64c7ebe5a611a1f12ffc12fb7a8366d9e1fdc" translate="yes" xml:space="preserve">
          <source>Adding heterogeneous comparison lookup to associative containers</source>
          <target state="translated">在关联容器中增加异构比较查找功能</target>
        </trans-unit>
        <trans-unit id="ad005a38d417aa5d21ad05bcc3397517559e1e10" translate="yes" xml:space="preserve">
          <source>Adding heterogeneous comparison lookup to unordered associative containers</source>
          <target state="translated">在无序关联容器中增加异构比较查找功能</target>
        </trans-unit>
        <trans-unit id="a6dea03cb51c5650f791a12987ca0df26adb5602" translate="yes" xml:space="preserve">
          <source>Adding pre-calculated hash value lookup to unordered associative containers</source>
          <target state="translated">在无序关联容器中添加预计算的哈希值查找。</target>
        </trans-unit>
        <trans-unit id="87ed11c26edf58b14803d392bf82cd48a91e96b8" translate="yes" xml:space="preserve">
          <source>Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.</source>
          <target state="translated">在列表中或在多个列表中添加、删除和移动元素不会使迭代器或引用无效。只有当相应的元素被删除时,迭代器才会失效。</target>
        </trans-unit>
        <trans-unit id="98f2660c67411bcd6814bc7ce1f2e850dfc897be" translate="yes" xml:space="preserve">
          <source>Adding, removing and moving the elements within the list, or across several lists, does not invalidate the iterators currently referring to other elements in the list. However, an iterator or reference referring to an element is invalidated when the corresponding element is removed (via &lt;code&gt;&lt;a href=&quot;forward_list/erase_after&quot;&gt;erase_after&lt;/a&gt;&lt;/code&gt;) from the list.</source>
          <target state="translated">添加，删除和移动列表中或多个列表中的元素不会使当前引用列表中其他元素的迭代器无效。但是，当从列表中删除相应元素（通过 &lt;code&gt;&lt;a href=&quot;forward_list/erase_after&quot;&gt;erase_after&lt;/a&gt;&lt;/code&gt; ）时，引用该元素的迭代器或引用无效。</target>
        </trans-unit>
        <trans-unit id="48911a7386b2baa20a76ef9e342562ca04e9c341" translate="yes" xml:space="preserve">
          <source>Addition and subtraction</source>
          <target state="translated">加法和减法</target>
        </trans-unit>
        <trans-unit id="5c20b1f1d3dccc5fc33df625c9821015eb0d18af" translate="yes" xml:space="preserve">
          <source>Additional basic types and macros</source>
          <target state="translated">其他基本类型和宏</target>
        </trans-unit>
        <trans-unit id="dc459b3781fd1c39294a64216e4b94c9615d87b0" translate="yes" xml:space="preserve">
          <source>Additional behavior may be defined by the implementations for file systems which append additional elements (such as alternate data streams or partitioned dataset names) to extensions.</source>
          <target state="translated">其他行为可由文件系统的实施例定义,这些实施例将附加附加元素(如备用数据流或分区数据集名称)到扩展名。</target>
        </trans-unit>
        <trans-unit id="a9a945aa19333f0b54ff5676b6d9de2643f1b76b" translate="yes" xml:space="preserve">
          <source>Additional classifications such as &lt;code&gt;&quot;jdigit&quot;&lt;/code&gt; or &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; may be provided by system-supplied locales (in which case they are also accessible through &lt;code&gt;&lt;a href=&quot;../../string/wide/wctype&quot;&gt;std::wctype&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">系统提供的语言环境可以提供其他分类，例如 &lt;code&gt;&quot;jdigit&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; （在这种情况下，也可以通过 &lt;code&gt;&lt;a href=&quot;../../string/wide/wctype&quot;&gt;std::wctype&lt;/a&gt;&lt;/code&gt; 访问它们）。</target>
        </trans-unit>
        <trans-unit id="ed64694f365b81d351dbd520c43964630a71e79f" translate="yes" xml:space="preserve">
          <source>Additional concepts can be found in &lt;a href=&quot;algorithm/ranges#Algorithm_concepts_and_utilities&quot;&gt;the algorithms library&lt;/a&gt; and &lt;a href=&quot;ranges#Range_concepts&quot;&gt;the ranges library&lt;/a&gt;.</source>
          <target state="translated">其他概念可以在&lt;a href=&quot;algorithm/ranges#Algorithm_concepts_and_utilities&quot;&gt;算法库&lt;/a&gt;和&lt;a href=&quot;ranges#Range_concepts&quot;&gt;范围库中找到&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="655988b4d376c12072cf6c9cdb9826fe22ae3e28" translate="yes" xml:space="preserve">
          <source>Additional execution policies may be provided by a standard library implementation (possible future additions may include &lt;code&gt;std::parallel::cuda&lt;/code&gt; and &lt;code&gt;std::parallel::opencl&lt;/code&gt;).</source>
          <target state="translated">标准库实现可以提供其他执行策略（可能的将来添加可能包括 &lt;code&gt;std::parallel::cuda&lt;/code&gt; 和 &lt;code&gt;std::parallel::opencl&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0b037de42fdfdd2746ba0eff4076bb78f7f07fda" translate="yes" xml:space="preserve">
          <source>Additional implementation-defined preparation may take place, which may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">可能会进行其他实现定义的准备工作，这可能会调用 &lt;code&gt;setstate(failbit)&lt;/code&gt; （可能会引发 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="96549f1325a6bd11423df1587b53f51b1bda1aee" translate="yes" xml:space="preserve">
          <source>Additional macro constants, with names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by at least one uppercase letter, may be defined in &lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt;. For example, the POSIX specification requires LC_MESSAGES (which controls &lt;code&gt;&lt;a href=&quot;../io/c/perror&quot;&gt;std::perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt;), ISO/IEC 30112:2014 (&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt;) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE).</source>
          <target state="translated">可以在 &lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt; 中定义其他宏常量，其名称以 &lt;code&gt;LC_&lt;/code&gt; 开头，后跟至少一个大写字母。例如，POSIX规范要求LC_MESSAGES（控制 &lt;code&gt;&lt;a href=&quot;../io/c/perror&quot;&gt;std::perror&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt; ），ISO / IEC 30112：2014（&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014草案&lt;/a&gt;）还定义了LC_IDENTIFICATION，LC_XLITERATE，LC_NAME，LC_ADDRESS，LC_TELEPHONE，LC_PAPER，LC_MEASUREMENT和LC_KEYBOARD ，由GNU C库支持（LC_XLITERATE除外）。</target>
        </trans-unit>
        <trans-unit id="99f91b99c0d1f5963361dc127f6dbe9e38bb8903" translate="yes" xml:space="preserve">
          <source>Additional macros that begin with &lt;code&gt;FE_&lt;/code&gt; followed by uppercase letters, and have the type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, may be supported by an implementation.</source>
          <target state="translated">一个实现可能会支持以 &lt;code&gt;FE_&lt;/code&gt; 开头，后跟大写字母，类型为 &lt;code&gt;const std::fenv_t*&lt;/code&gt; 其他宏。</target>
        </trans-unit>
        <trans-unit id="ef3d826dd03b81e684d86b842e89e92269929ee7" translate="yes" xml:space="preserve">
          <source>Additional numeric formats may be accepted by the currently installed C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当前安装的C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt; 可能接受其他数字格式。</target>
        </trans-unit>
        <trans-unit id="0a5c5be417cfb6cd7d9118d383daf9f4ffd160e0" translate="yes" xml:space="preserve">
          <source>Additional overloads are provided for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and all integer types, which are treated as complex numbers with zero imaginary component.</source>
          <target state="translated">为 &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; ， &lt;code&gt;long double&lt;/code&gt; 和所有整数类型提供了额外的重载，这些重载被视为虚数为零的复数。</target>
        </trans-unit>
        <trans-unit id="e8146529cfa6fa203e23e61b37cbdf2d37d4634b" translate="yes" xml:space="preserve">
          <source>Additional rounding modes may be supported by an implementation.</source>
          <target state="translated">实施例可以支持其他的四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="c51476def7086889d71b363945c5ad2e8649c02e" translate="yes" xml:space="preserve">
          <source>Additional signal names &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;are specified by POSIX&lt;/a&gt;.</source>
          <target state="translated">附加信号名称&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;由POSIX指定&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b8e3f88a4fb1a893c72eb1c76430bba45d521493" translate="yes" xml:space="preserve">
          <source>Additional signal names &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;are specified by POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1faa5440a863d95ba8c415f20385dfa4af6d4b" translate="yes" xml:space="preserve">
          <source>Additional support</source>
          <target state="translated">额外支持</target>
        </trans-unit>
        <trans-unit id="04f95216581ee9c47e04240f25828352cba16ddc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_&amp;shy;concept&lt;/code&gt; may be used to indicate conformance to the iterator concepts.</source>
          <target state="translated">此外， &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_&amp;shy;concept&lt;/code&gt; 可以被用于指示是否符合迭代器概念。</target>
        </trans-unit>
        <trans-unit id="f2e0dd9b924004af0072e53510ae5406eb8b489b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator!=&lt;/code&gt; are provided, either as members or as non-members, as required by &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">此外，根据&lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator的&lt;/a&gt;要求，提供 &lt;code&gt;operator==&lt;/code&gt; 和 &lt;code&gt;operator!=&lt;/code&gt; 作为成员或作为非成员提供。</target>
        </trans-unit>
        <trans-unit id="ce53b9c5df0fcfe1d1195f17fc25165a98c09650" translate="yes" xml:space="preserve">
          <source>Additionally, O(N) calls to the constructor of &lt;code&gt;value_type&lt;/code&gt;, where N is &lt;code&gt;cont.size()&lt;/code&gt;.</source>
          <target state="translated">另外，O（N）调用 &lt;code&gt;value_type&lt;/code&gt; 的构造函数，其中N是 &lt;code&gt;cont.size()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7bee97038914dbaf49097462be0b6fa3a27587e0" translate="yes" xml:space="preserve">
          <source>Additionally, a specialization exists for every cv-qualified version of each arithmetic type, identical to the unqualified specialization, e.g. &lt;code&gt;std::numeric_limits&amp;lt;const int&amp;gt;&lt;/code&gt;, &lt;code&gt;std::numeric_limits&amp;lt;volatile int&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::numeric_limits&amp;lt;const volatile int&amp;gt;&lt;/code&gt; are provided and are equivalent to &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">另外，每种算术类型的每个cv限定版本都存在一种特殊化，与非限定特殊化相同，例如 &lt;code&gt;std::numeric_limits&amp;lt;const int&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::numeric_limits&amp;lt;volatile int&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::numeric_limits&amp;lt;const volatile int&amp;gt;&lt;/code&gt; 提供&amp;gt;并等效于 &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="234e939fc46f7fc9566afc50a39f23e96624b23f" translate="yes" xml:space="preserve">
          <source>Additionally, an object &lt;code&gt;m&lt;/code&gt; of SharedMutex type supports another mode of ownership: shared. Multiple threads (or, more generally, execution agents) can simultaneously own this mutex in shared mode, but no thread may obtain shared ownership if there is a thread that owns it in exclusive mode and no thread may obtain exclusive ownership if there is a thread that owns it in shared mode. If more than implementation-defined number of threads (no less than 10000) hold a shared lock, another attempt to acquire the mutex in shared mode blocks until the number of shared owners drops down below that threshold.</source>
          <target state="translated">此外，SharedMutex类型的对象 &lt;code&gt;m&lt;/code&gt; 支持另一种所有权模式：共享。多个线程（或更一般地说，执行代理）可以在共享模式下同时拥有此互斥锁，但是如果有一个线程在互斥模式下拥有该互斥锁，则任何线程都无法获得共享所有权；如果有线程，则没有线程可以获取互斥所有权。在共享模式下拥有它。如果持有共享锁的线程数量超过实现定义的数量（不少于10000个），则将尝试以共享模式块获取互斥锁，直到共享所有者的数量降至该阈值以下。</target>
        </trans-unit>
        <trans-unit id="4c21e2edf0f81a97ef8a624494e0c5a7e8d14423" translate="yes" xml:space="preserve">
          <source>Additionally, an object &lt;code&gt;m&lt;/code&gt; of SharedTimedMutex type supports timed shared operations:</source>
          <target state="translated">此外，SharedTimedMutex类型的对象 &lt;code&gt;m&lt;/code&gt; 支持定时共享操作：</target>
        </trans-unit>
        <trans-unit id="6981bc51ea468df1e5cb432a395ddfc2e5d78804" translate="yes" xml:space="preserve">
          <source>Additionally, for an object &lt;code&gt;m&lt;/code&gt; of TimedMutex type:</source>
          <target state="translated">此外，对于TimedMutex类型的对象 &lt;code&gt;m&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ceefa22c95a1f23f16745529c429d1edf71f2d45" translate="yes" xml:space="preserve">
          <source>Additionally, for every sequence container, the constructor template that takes two input iterators and the member function template overloads of &lt;code&gt;insert()&lt;/code&gt;, &lt;code&gt;append()&lt;/code&gt;, &lt;code&gt;assign()&lt;/code&gt;, &lt;code&gt;replace()&lt;/code&gt; that take two input iterators do not participate in overload resolution if the corresponding template argument does not satisfy &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">此外，对于每个序列容器，采用两个输入迭代器的构造函数模板以及采用两个输入迭代器的 &lt;code&gt;insert()&lt;/code&gt; ， &lt;code&gt;append()&lt;/code&gt; ， &lt;code&gt;assign()&lt;/code&gt; ， &lt;code&gt;replace()&lt;/code&gt; 的成员函数模板重载，如果不接受重载解析，则相应的模板参数不满足&lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80407204b5613c93f4ff9eeeca0d87435272db5c" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;floatfield != (ios_base::fixed | ios_base::scientific)&lt;/code&gt;, then(since C++11) precision modifier is added, set to &lt;code&gt;str.precision()&lt;/code&gt;</source>
          <target state="translated">此外，如果 &lt;code&gt;floatfield != (ios_base::fixed | ios_base::scientific)&lt;/code&gt; ，则添加（自C ++ 11起）precision修饰符，并将其设置为 &lt;code&gt;str.precision()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92ec030910d3cd27bfd60a9308eb60d240987aa3" translate="yes" xml:space="preserve">
          <source>Additionally, in order for the type &lt;code&gt;A&lt;/code&gt; to satisfy Allocator.</source>
          <target state="translated">另外，为了使类型 &lt;code&gt;A&lt;/code&gt; 满足分配器。</target>
        </trans-unit>
        <trans-unit id="e4c633a25d8deae1fd83be48e6f21fc0579f3bfe" translate="yes" xml:space="preserve">
          <source>Additionally, the following constants of this type are defined, which do not represent permissions:</source>
          <target state="translated">此外,还定义了以下这种类型的常量,它们不代表权限。</target>
        </trans-unit>
        <trans-unit id="e3b85cc6377c854375953c6897c361f957b07ce5" translate="yes" xml:space="preserve">
          <source>Additionally, the resulting &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Floating&lt;/i&gt;&amp;gt;&lt;/code&gt; specialization has standard layout, a trivial default constructor, and a trivial destructor.</source>
          <target state="translated">此外，生成的 &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Floating&lt;/i&gt;&amp;gt;&lt;/code&gt; 特殊化具有标准布局，简单的默认构造函数和简单的析构函数。</target>
        </trans-unit>
        <trans-unit id="e8aaea245aabbd553929a2dc8693fcb475a09d9c" translate="yes" xml:space="preserve">
          <source>Additionally, the resulting &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Integral&lt;/i&gt;&amp;gt;&lt;/code&gt; specialization has standard layout, a trivial default constructor, and a trivial destructor. Signed integer arithmetic is defined to use two's complement; there are no undefined results.</source>
          <target state="translated">另外，生成的 &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Integral&lt;/i&gt;&amp;gt;&lt;/code&gt; 专业化具有标准布局，简单的默认构造函数和简单的析构函数。有符号整数算术被定义为使用二进制补码。没有未定义的结果。</target>
        </trans-unit>
        <trans-unit id="ac1d2a76e849b1b5833ee66f2036219c73ed4239" translate="yes" xml:space="preserve">
          <source>Additionally:</source>
          <target state="translated">Additionally:</target>
        </trans-unit>
        <trans-unit id="76be74594d0a3f6f1c23004ef8fbefa453574daa" translate="yes" xml:space="preserve">
          <source>Additive operators</source>
          <target state="translated">加法运算符</target>
        </trans-unit>
        <trans-unit id="ce6e9db4782a94f83450a756f42238c060b97d77" translate="yes" xml:space="preserve">
          <source>Address constant expression</source>
          <target state="translated">地址常数表达式</target>
        </trans-unit>
        <trans-unit id="38ee922cd750ff4631c23d9b88d00633994c2466" translate="yes" xml:space="preserve">
          <source>Address family not supported</source>
          <target state="translated">不支持地址家庭</target>
        </trans-unit>
        <trans-unit id="9e53f7cf7661710ec98f0a6e7a65398f5e81f0be" translate="yes" xml:space="preserve">
          <source>Address in use</source>
          <target state="translated">使用中的地址</target>
        </trans-unit>
        <trans-unit id="a645d07371a2ce45ebb0b375f8787a4fc425584d" translate="yes" xml:space="preserve">
          <source>Address not available</source>
          <target state="translated">地址不详</target>
        </trans-unit>
        <trans-unit id="f282d429f8e10c6e8f6cc685119b79f7b98f8d4a" translate="yes" xml:space="preserve">
          <source>Address of an lvalue may be taken: &lt;code&gt;&amp;amp;++i&lt;/code&gt;&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; and &lt;code&gt;&amp;amp;&lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; are valid expressions.</source>
          <target state="translated">可以使用左值的地址： &lt;code&gt;&amp;amp;++i&lt;/code&gt; &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;和 &lt;code&gt;&amp;amp;&lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; 是有效的表达式。</target>
        </trans-unit>
        <trans-unit id="1a289481f4bde8e8211ad9ffe17faa98c7f5cb4e" translate="yes" xml:space="preserve">
          <source>Address of an overload set</source>
          <target state="translated">过载集的地址</target>
        </trans-unit>
        <trans-unit id="b68e9b443504394c722ff5e4129a8d602ab42051" translate="yes" xml:space="preserve">
          <source>Address of an overloaded function</source>
          <target state="translated">重载函数的地址</target>
        </trans-unit>
        <trans-unit id="50d8d3dd04846c597735fdea066d1202471e00ac" translate="yes" xml:space="preserve">
          <source>Address of an rvalue may not be taken: &lt;code&gt;&amp;amp;int()&lt;/code&gt;, &lt;code&gt;&amp;amp;i++&lt;/code&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;, &lt;code&gt;&amp;amp;42&lt;/code&gt;, and &lt;code&gt;&amp;amp;std::move(x)&lt;/code&gt; are invalid.</source>
          <target state="translated">不能使用右值的地址： &lt;code&gt;&amp;amp;int()&lt;/code&gt; ， &lt;code&gt;&amp;amp;i++&lt;/code&gt; &lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;， &lt;code&gt;&amp;amp;42&lt;/code&gt; 和 &lt;code&gt;&amp;amp;std::move(x)&lt;/code&gt; 无效。</target>
        </trans-unit>
        <trans-unit id="9377e4719dc070a5dfa0119a44583c6b5ae07578" translate="yes" xml:space="preserve">
          <source>Address-of</source>
          <target state="translated">Address-of</target>
        </trans-unit>
        <trans-unit id="d8e9fb4e567ee2aa8c62d2ac99954b60bc22db70" translate="yes" xml:space="preserve">
          <source>Addressing tuples by type</source>
          <target state="translated">按类型寻址元组</target>
        </trans-unit>
        <trans-unit id="b0ef7d67a5935e3fe8af11cd7847c8809d95a854" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the day value.</source>
          <target state="translated">从日值中加或减1。</target>
        </trans-unit>
        <trans-unit id="e43efbbed96f261cc9549f2681044676631d009f" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the month value, reducing the result modulo 12 to an integer in the range [1, 12].</source>
          <target state="translated">从月值中加减1,将结果以12为模数还原为[1,12]范围内的整数。</target>
        </trans-unit>
        <trans-unit id="fa3ef2c3e28e35bbf2cbd5aafea835fc3ea7a3ef" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">从工作日的值中加减1,将结果以7为模数缩小到[0,6]范围内的整数。</target>
        </trans-unit>
        <trans-unit id="640e675cb46fdd695967fccbbef63e0607e284a0" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the year value.</source>
          <target state="translated">从年值中加或减1。</target>
        </trans-unit>
        <trans-unit id="4153c4972fd500059ef400485fdf85b87aceaa00" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;d.count()&lt;/code&gt; days from the day value.</source>
          <target state="translated">从日期值中添加或减去 &lt;code&gt;d.count()&lt;/code&gt; 天。</target>
        </trans-unit>
        <trans-unit id="678a7c04a10343a84658ffb12634bd9ee9456301" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;d.count()&lt;/code&gt; from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">从工作日值中添加或减去 &lt;code&gt;d.count()&lt;/code&gt; ，将结果取模7为范围为[ 0，6 ]的整数。</target>
        </trans-unit>
        <trans-unit id="3230fc75b04ac3e6ea29e55230fe30dd1c203bfe" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;m.count()&lt;/code&gt; from the month value, reducing the result modulo 12 to an integer in the range [1, 12].</source>
          <target state="translated">从月份值中添加或减去 &lt;code&gt;m.count()&lt;/code&gt; ，将结果取模12为范围为[ 1，12 ]的整数。</target>
        </trans-unit>
        <trans-unit id="25e4a09fe7696cac408ac8a894a8ff1b27aa44b2" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;y.count()&lt;/code&gt; years from the year value.</source>
          <target state="translated">从年份值中添加或减去 &lt;code&gt;y.count()&lt;/code&gt; 年。</target>
        </trans-unit>
        <trans-unit id="458e4498a6e12a40a95f335b3f81898cfd748b12" translate="yes" xml:space="preserve">
          <source>Adjacent &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are concatenated.</source>
          <target state="translated">相邻的&lt;a href=&quot;string_literal&quot;&gt;字符串文字&lt;/a&gt;是串联在一起的。</target>
        </trans-unit>
        <trans-unit id="9932bec15aa8c818ed7b8796dbd6ed7ef02aab26" translate="yes" xml:space="preserve">
          <source>Adopt the Parallelism TS for C++17</source>
          <target state="translated">通过C++17的并行性技术文件。</target>
        </trans-unit>
        <trans-unit id="03e5621c572270086c95471651dc888f07bc2da9" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;e&lt;/code&gt;'s state as if by &lt;code&gt;z&lt;/code&gt; consecutive calls to &lt;code&gt;e()&lt;/code&gt;.</source>
          <target state="translated">进展 &lt;code&gt;e&lt;/code&gt; 的状态仿佛 &lt;code&gt;z&lt;/code&gt; 连续调用 &lt;code&gt;e()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="135dd9fae6bf561e041334e7723bb57b90c62cf2" translate="yes" xml:space="preserve">
          <source>Advances the input sequence by one character and reads one character.</source>
          <target state="translated">将输入序列提前一个字符并读取一个字符。</target>
        </trans-unit>
        <trans-unit id="50499158101997cf6bc049268a358d31d71424e8" translate="yes" xml:space="preserve">
          <source>Advances the internal state by &lt;code&gt;z&lt;/code&gt; times. Equivalent to calling &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;z&lt;/code&gt; times and discarding the result.</source>
          <target state="translated">将内部状态前进 &lt;code&gt;z&lt;/code&gt; 倍。等效于 &lt;code&gt;z&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt; 并丢弃结果。</target>
        </trans-unit>
        <trans-unit id="efa9b27cb8a086b18bbe299b9e1c46a036172d58" translate="yes" xml:space="preserve">
          <source>Advances the internal state by &lt;code&gt;z&lt;/code&gt; times. Equivalent to calling &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;z&lt;/code&gt; times and discarding the result. The state of the underlying engine may be advanced by more than &lt;code&gt;z&lt;/code&gt; times.</source>
          <target state="translated">将内部状态前进 &lt;code&gt;z&lt;/code&gt; 倍。等效于 &lt;code&gt;z&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt; 并丢弃结果。基础引擎的状态可能会提前 &lt;code&gt;z&lt;/code&gt; 倍以上。</target>
        </trans-unit>
        <trans-unit id="b9ef5cc9bbd2286407c3e7b628e2c0232b990d29" translate="yes" xml:space="preserve">
          <source>Advances the iterator by calling &lt;code&gt;sbuf_-&amp;gt;sbumpc()&lt;/code&gt; where &lt;code&gt;sbuf_&lt;/code&gt; is the stored pointer to the stream buffer.</source>
          <target state="translated">通过调用 &lt;code&gt;sbuf_-&amp;gt;sbumpc()&lt;/code&gt; &lt;code&gt;sbuf_&lt;/code&gt; 迭代器，其中sbuf_是指向流缓冲区的存储指针。</target>
        </trans-unit>
        <trans-unit id="141cb43c20eeabe7572fd03d0044e60b4fa23f86" translate="yes" xml:space="preserve">
          <source>Advances the iterator on the next match.</source>
          <target state="translated">将迭代器推进到下一个匹配点。</target>
        </trans-unit>
        <trans-unit id="041d757eb7a9bbdbe12db3d41c780db95f87a90c" translate="yes" xml:space="preserve">
          <source>Advances the iterator on the next sub match.</source>
          <target state="translated">将迭代器推进到下一个子匹配上。</target>
        </trans-unit>
        <trans-unit id="6539ad1eea9dd55e8e95ccfb1b1a314e60e23185" translate="yes" xml:space="preserve">
          <source>Advances the iterator to the next entry. Invalidates all copies of the previous value of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">将迭代器前进到下一个条目。使 &lt;code&gt;*this&lt;/code&gt; 先前值的所有副本无效。</target>
        </trans-unit>
        <trans-unit id="78b5c8f29ae07de10df28f52834a61b1bdbbd82b" translate="yes" xml:space="preserve">
          <source>Advances the iterator.</source>
          <target state="translated">推进迭代器。</target>
        </trans-unit>
        <trans-unit id="207287a093e89e5bc03f0303474f506b39d8c2b3" translate="yes" xml:space="preserve">
          <source>After &lt;b&gt;erasure&lt;/b&gt;, are...</source>
          <target state="translated">&lt;b&gt;删除&lt;/b&gt;之后，...</target>
        </trans-unit>
        <trans-unit id="4f0adbf879d7bad6224d512c2918e8643c30107f" translate="yes" xml:space="preserve">
          <source>After &lt;b&gt;insertion&lt;/b&gt;, are...</source>
          <target state="translated">后&lt;b&gt;插入&lt;/b&gt;，是...</target>
        </trans-unit>
        <trans-unit id="88341f67098f03a0da3cea31a839663a0bc13b2c" translate="yes" xml:space="preserve">
          <source>After a</source>
          <target state="translated">在一次</target>
        </trans-unit>
        <trans-unit id="a061077fb09465352c22016448276d1996de8a86" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt;, dynamic streams become frozen automatically. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;ostrstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 之后，动态流将自动冻结。在退出创建该 &lt;code&gt;ostrstream&lt;/code&gt; 对象的作用域之前，需要调用 &lt;code&gt;freeze(false)&lt;/code&gt; 。否则析构函数将泄漏内存。此外，冻结流的其他输出一旦到达分配的缓冲区的末尾，就可能被截断。</target>
        </trans-unit>
        <trans-unit id="a539ff8b097686cd8f474897e86e0367fc84dba2" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt;, dynamic streams become frozen automatically. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;strstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer.</source>
          <target state="translated">调用 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 之后，动态流将自动冻结。在退出创建此 &lt;code&gt;strstream&lt;/code&gt; 对象的作用域之前，需要调用 &lt;code&gt;freeze(false)&lt;/code&gt; 。否则析构函数将泄漏内存。此外，冻结流的其他输出一旦到达分配的缓冲区的末尾，就可能被截断。</target>
        </trans-unit>
        <trans-unit id="5eb647e196d16c21c41ab1c8527d9b7e8b2a6ba0" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;str()&lt;/code&gt;, dynamic streams become frozen. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;ostrstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer, which may leave the buffer not null-terminated.</source>
          <target state="translated">调用 &lt;code&gt;str()&lt;/code&gt; 之后，动态流将冻结。在退出创建该 &lt;code&gt;ostrstream&lt;/code&gt; 对象的作用域之前，需要调用 &lt;code&gt;freeze(false)&lt;/code&gt; 。否则析构函数将泄漏内存。同样，一旦冻结流到达分配的缓冲区的末尾，它的其他输出可能会被截断，这可能会使缓冲区不为空终止。</target>
        </trans-unit>
        <trans-unit id="44cdb0260695b6e760f2d33d6208f4bfff7fe216" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;str()&lt;/code&gt;, dynamic streams become frozen. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;strstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer, which may leave the buffer not null-terminated.</source>
          <target state="translated">调用 &lt;code&gt;str()&lt;/code&gt; 之后，动态流将冻结。在退出创建此 &lt;code&gt;strstream&lt;/code&gt; 对象的作用域之前，需要调用 &lt;code&gt;freeze(false)&lt;/code&gt; 。否则析构函数将泄漏内存。同样，一旦冻结流到达分配的缓冲区的末尾，它的其他输出可能会被截断，这可能会使缓冲区不为空终止。</target>
        </trans-unit>
        <trans-unit id="b9daa7be1c203f1734014387e6ddd71754a92603" translate="yes" xml:space="preserve">
          <source>After a call to one of these functions, &lt;code&gt;ok()&lt;/code&gt; is always true if no overflow occurred during the operation.</source>
          <target state="translated">调用这些函数之一后，如果在操作过程中未发生溢出，则 &lt;code&gt;ok()&lt;/code&gt; 始终为true。</target>
        </trans-unit>
        <trans-unit id="85753ca571347a3ec5bab8ac7f1155da1ea5f3fa" translate="yes" xml:space="preserve">
          <source>After a call to one of these functions, &lt;code&gt;ok()&lt;/code&gt; is always true.</source>
          <target state="translated">调用这些函数之一后， &lt;code&gt;ok()&lt;/code&gt; 始终为true。</target>
        </trans-unit>
        <trans-unit id="b0d14c1273920c43e0727fafe465d22e6d51d0cb" translate="yes" xml:space="preserve">
          <source>After all macro expansion and evaluation of &lt;code&gt;defined&lt;/code&gt;and &lt;code&gt;__has_include&lt;/code&gt;(since C++17) expressions, any identifier which is not a &lt;a href=&quot;../language/bool_literal&quot;&gt;boolean literal&lt;/a&gt; is replaced with the number &lt;code&gt;​0​&lt;/code&gt; (this includes identifiers that are lexically keywords, but not alternative tokens like &lt;code&gt;and&lt;/code&gt;).</source>
          <target state="translated">所有宏扩展和评估之后 &lt;code&gt;defined&lt;/code&gt; 和 &lt;code&gt;__has_include&lt;/code&gt; （因为C ++ 17）表达式，任何标识符这不是一个&lt;a href=&quot;../language/bool_literal&quot;&gt;布尔值&lt;/a&gt;被替换为数字 &lt;code&gt;​0​&lt;/code&gt; （这包括词法关键字标识符，但不是替代令牌像 &lt;code&gt;and&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b09013ce3cd67396c7277e3bcafa2ffe1562348b" translate="yes" xml:space="preserve">
          <source>After all static initialization is completed, dynamic initialization of non-local variables occurs in the following situations:</source>
          <target state="translated">在所有静态初始化完成后,非本地变量的动态初始化发生在以下情况。</target>
        </trans-unit>
        <trans-unit id="35dd559617a4f18a5460a7d2ed6280a6a78170b4" translate="yes" xml:space="preserve">
          <source>After any call to &lt;code&gt;str()&lt;/code&gt; on a stream with a dynamic buffer, a call to &lt;code&gt;freeze(false)&lt;/code&gt; is required to allow the &lt;code&gt;strstreambuf&lt;/code&gt; destructor to deallocate the buffer when necessary.</source>
          <target state="translated">在具有动态缓冲区的流上对 &lt;code&gt;str()&lt;/code&gt; 的任何调用之后，都需要对 &lt;code&gt;strstreambuf&lt;/code&gt; &lt;code&gt;freeze(false)&lt;/code&gt; 进行调用，以允许strstreambuf析构函数在必要时释放缓冲区。</target>
        </trans-unit>
        <trans-unit id="1bff9fbc15a1512d56427c0bac69b8131756695d" translate="yes" xml:space="preserve">
          <source>After any call to &lt;code&gt;str()&lt;/code&gt;, a call to &lt;code&gt;freeze(false)&lt;/code&gt; is required to allow the destructor to deallocate the buffer as necessary.</source>
          <target state="translated">在对 &lt;code&gt;str()&lt;/code&gt; 的任何调用之后，都需要对Frozen（ &lt;code&gt;freeze(false)&lt;/code&gt; 的调用，以允许析构函数根据需要释放缓冲区。</target>
        </trans-unit>
        <trans-unit id="a783411c667be5aeca25a2e7d260e7d91749c14d" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;detach&lt;/code&gt;&lt;code&gt;*this&lt;/code&gt; no longer owns any thread.</source>
          <target state="translated">调用 &lt;code&gt;detach&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; 不再拥有任何线程。</target>
        </trans-unit>
        <trans-unit id="d81c3a85f42719a311033e306e37b8e8b9fb3c51" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;share&lt;/code&gt; on a &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 上调用 &lt;code&gt;share&lt;/code&gt; 之后，&lt;a href=&quot;valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8a56377919a429bed8801b85b079d1d09d9b97f" translate="yes" xml:space="preserve">
          <source>After calling the rvalue overloads (2,4,6,8), &lt;code&gt;r&lt;/code&gt; is empty and &lt;code&gt;r.get() == nullptr&lt;/code&gt;, except that &lt;code&gt;r&lt;/code&gt; is not modified for &lt;code&gt;dynamic_pointer_cast&lt;/code&gt;(4) if the &lt;code&gt;dynamic_cast&lt;/code&gt; fails.</source>
          <target state="translated">调用右值重载（2,4,6,8）之后， &lt;code&gt;r&lt;/code&gt; 为空，并且 &lt;code&gt;r.get() == nullptr&lt;/code&gt; ，不同之处在于，如果 &lt;code&gt;dynamic_cast&lt;/code&gt; 失败，则不会为 &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; （4）修改 &lt;code&gt;r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a43ab890db9a9d7fd099d5804cec46453734ffa7" translate="yes" xml:space="preserve">
          <source>After considering every P and A in both directions, if, for each type that was considered,</source>
          <target state="translated">在考虑每一个P和A两个方向后,如果,对于每一个被考虑的类型。</target>
        </trans-unit>
        <trans-unit id="cde16484b3a6dce1a5a73f1d71d4d5f94eda1f7f" translate="yes" xml:space="preserve">
          <source>After container move assignment (overload (2)), unless elementwise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">容器移动分配后（过载（2）），除非的elementwise移动分配由不相容分配器，参考文献，指针，和迭代器（除结束迭代除外）被迫 &lt;code&gt;other&lt;/code&gt; 仍然有效，但指的是现在在元件 &lt;code&gt;*this&lt;/code&gt; 。当前标准通过&amp;sect;23.2.1[container.requirements.general] / 12中的一揽子声明来提供此保证，并且正在通过&lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;考虑更直接的保证。</target>
        </trans-unit>
        <trans-unit id="1efd3ba5fab7d922cddedab135cbf68623f0fbb3" translate="yes" xml:space="preserve">
          <source>After container move construction (overload (4)), references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">容器移动施工后（过载（4）），参考文献，指针，和迭代器（除结束迭代除外） &lt;code&gt;other&lt;/code&gt; 仍然有效，但指的是现在在元件 &lt;code&gt;*this&lt;/code&gt; 。当前标准通过&amp;sect;23.2.1[container.requirements.general] / 12中的一揽子声明来提供此保证，并且正在通过&lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;考虑更直接的保证。</target>
        </trans-unit>
        <trans-unit id="eaca101a515420f6158015d9049a7c61e1020372" translate="yes" xml:space="preserve">
          <source>After container move construction (overload (6)), references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">容器移动施工后（过载（6）），参考文献，指针，和迭代器（除结束迭代除外） &lt;code&gt;other&lt;/code&gt; 仍然有效，但指的是现在在元件 &lt;code&gt;*this&lt;/code&gt; 。当前标准通过&amp;sect;23.2.1[container.requirements.general] / 12中的一揽子声明来提供此保证，并且正在通过&lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;考虑更直接的保证。</target>
        </trans-unit>
        <trans-unit id="1fb3e0e585b7b35a447a3da6d3ae0da5248da92b" translate="yes" xml:space="preserve">
          <source>After encountering the &lt;code&gt;#error&lt;/code&gt; directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops).</source>
          <target state="translated">遇到 &lt;code&gt;#error&lt;/code&gt; 指令后，实现将显示诊断消息error_message并使程序格式错误（编译停止）。</target>
        </trans-unit>
        <trans-unit id="1d2d75b0b4cf172aa9246ff178f69aced36a5e9c" translate="yes" xml:space="preserve">
          <source>After evaluating &lt;code&gt;lhs = rhs&lt;/code&gt;:</source>
          <target state="translated">评估 &lt;code&gt;lhs = rhs&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="45a5bba2318081758d338e6bc0ad55114ce64350" translate="yes" xml:space="preserve">
          <source>After one of the two templates was transformed as described above, &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; is executed using the transformed template as the argument template and the original template type of the other template as the parameter template. The process is then repeated using the second template (after transformations) as the argument and the first template in its original form as the parameter.</source>
          <target state="translated">在如上所述对两个模板之一进行转换之后，使用转换后的模板作为参数模板并使用另一个模板的原始模板类型作为参数模板来执行&lt;a href=&quot;template_argument_deduction&quot;&gt;模板参数推导&lt;/a&gt;。然后使用第二个模板（转换后）作为参数，并使用原始形式的第一个模板作为参数，重复此过程。</target>
        </trans-unit>
        <trans-unit id="37697aac1a5eff809b30503e048e426d91ee09c0" translate="yes" xml:space="preserve">
          <source>After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.</source>
          <target state="translated">在寻求到宽流中的非结束位置后,下一次对任何输出函数的调用可能会使文件的剩余部分未被定义,例如通过输出不同长度的多字节序列。</target>
        </trans-unit>
        <trans-unit id="6723da668a7284d1e0d9c856af9a4e60e17d6599" translate="yes" xml:space="preserve">
          <source>After substitution, all function parameters of array and function type are adjusted to pointers and all top-level cv-qualifiers are dropped from function parameters (as in a regular &lt;a href=&quot;function#Function_declaration&quot;&gt;function declaration&lt;/a&gt;).</source>
          <target state="translated">替换后，将数组和函数类型的所有函数参数调整为指针，并从函数参数中删除所有顶级cv限定符（如在常规&lt;a href=&quot;function#Function_declaration&quot;&gt;函数声明中一样&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="799039415462a10354f545fe871b500eacc988ea" translate="yes" xml:space="preserve">
          <source>After that, whether or not an exception was thrown by any destructor, the delete expression invokes the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt;: either &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; (for the first version of the expression) or &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; (for the second version of the expression), unless the matching new-expression was combined with another new-expression(since C++14).</source>
          <target state="translated">之后，无论是否有析构函数抛出异常，delete表达式都会调用&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;释放函数&lt;/a&gt;： &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; （对于表达式的第一版）或 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; （对于表达式的第二版），除非匹配的new-expression与另一个new-expression（自C ++ 14开始）组合在一起。</target>
        </trans-unit>
        <trans-unit id="e0b82e4b58314156b84c6c073fedd13df3c06173" translate="yes" xml:space="preserve">
          <source>After the associated set of classes and namespaces is determined, all declarations found in classes of this set are discarded for the purpose of further ADL processing, except namespace-scoped friend functions and function templates, as stated in point 2 below .</source>
          <target state="translated">在确定了相关的类和命名空间集合后,除了命名空间范围内的友函数和函数模板外,为了进一步的ADL处理,在这个集合的类中发现的所有声明都被丢弃,如下文第2点所述。</target>
        </trans-unit>
        <trans-unit id="a30be8c196cfecdbad0fc0881a76a52f9af12d23" translate="yes" xml:space="preserve">
          <source>After the call &lt;code&gt;getloc() == loc&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;getloc() == loc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b157835cfa6ec4fc0f1fce8dc684fe4a88600d3" translate="yes" xml:space="preserve">
          <source>After the call, the value of &lt;code&gt;t&lt;/code&gt; is the value held by &lt;code&gt;u&lt;/code&gt; before the call, and the value of &lt;code&gt;u&lt;/code&gt; is the value held by &lt;code&gt;t&lt;/code&gt; before the call.</source>
          <target state="translated">通话结束后，价值 &lt;code&gt;t&lt;/code&gt; 是保存的值 &lt;code&gt;u&lt;/code&gt; 呼叫之前，和价值 &lt;code&gt;u&lt;/code&gt; 是保存的值 &lt;code&gt;t&lt;/code&gt; 的调用之前。</target>
        </trans-unit>
        <trans-unit id="4cd3511e0d8d14569c23c73c7b91dc33ab8e711e" translate="yes" xml:space="preserve">
          <source>After the definition &lt;code&gt;T u = rv;&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt; is equal to &lt;code&gt;u2&lt;/code&gt;;</source>
          <target state="translated">在定义之后， &lt;code&gt;T u = rv;&lt;/code&gt; ， &lt;code&gt;u&lt;/code&gt; 等于 &lt;code&gt;u2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3d30d64981287500c819b1f90ccbf12490e9f92c" translate="yes" xml:space="preserve">
          <source>After the definition &lt;code&gt;T u = v;&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt; is equal to &lt;code&gt;v&lt;/code&gt;;</source>
          <target state="translated">在定义之后， &lt;code&gt;T u = v;&lt;/code&gt; ， &lt;code&gt;u&lt;/code&gt; 等于 &lt;code&gt;v&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0c6c90fd32023a18a6a7da6b1f777294338454a9" translate="yes" xml:space="preserve">
          <source>After the destruction, the smart pointers that shared ownership with &lt;code&gt;*this&lt;/code&gt;, if any, will report a &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count()&lt;/a&gt;&lt;/code&gt; that is one less than its previous value.</source>
          <target state="translated">销毁后，与 &lt;code&gt;*this&lt;/code&gt; 共享所有权的智能指针（如果有的话）将报告一个 &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count()&lt;/a&gt;&lt;/code&gt; ，该值比其先前值小一。</target>
        </trans-unit>
        <trans-unit id="d2d0310f3096791666afb21ddf68713192d5f5d5" translate="yes" xml:space="preserve">
          <source>After the error condition is reported by a function, additional guarantees may be provided with regards to the state of the program. The following four levels of exception guarantee are generally recognized&lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;exceptions#cite_note-4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;exceptions#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-6&quot;&gt;&lt;a href=&quot;exceptions#cite_note-6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt;, which are strict supersets of each other:</source>
          <target state="translated">通过功能报告错误情况后，可以提供有关程序状态的其他保证。通常公认以下四个级别的异常保证&lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;exceptions#cite_note-4&quot;&gt;[4] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;exceptions#cite_note-5&quot;&gt;[5] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-6&quot;&gt;&lt;a href=&quot;exceptions#cite_note-6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt;，它们是彼此的严格超集：</target>
        </trans-unit>
        <trans-unit id="5b29961c177bd98d620f93782ce1efd7215c74a8" translate="yes" xml:space="preserve">
          <source>After the standard library deallocation function returns, all pointers referring to any part of the deallocated storage become invalid.</source>
          <target state="translated">在标准库deallocation函数返回后,所有指向deallocated存储的任何部分的指针都变得无效。</target>
        </trans-unit>
        <trans-unit id="d0f96cdce258dfc61390cebc0e99878ba570d5a1" translate="yes" xml:space="preserve">
          <source>After these adjustments, deduction of &lt;code&gt;P&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; is done following &lt;a href=&quot;template_argument_deduction#Deduction_from_a_type&quot;&gt;template argument deduction from a type&lt;/a&gt;.</source>
          <target state="translated">经过上述调整后，扣除 &lt;code&gt;P&lt;/code&gt; 从 &lt;code&gt;A&lt;/code&gt; 下面做&lt;a href=&quot;template_argument_deduction#Deduction_from_a_type&quot;&gt;从类型模板参数推导&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2d3d82b04f2207d9d6bcf7a9bbc105dd774ee13b" translate="yes" xml:space="preserve">
          <source>After these transformations, the deduction processes as described below (cf. section &quot;Deduction from type&quot;) and attempts to find such template arguments that would make the deduced &lt;code&gt;A&lt;/code&gt; (that is, &lt;code&gt;P&lt;/code&gt; after adjustments listed above and the substitution of the deduced template parameters) identical to the</source>
          <target state="translated">经过这些转换后，推导过程如下所述（请参见&amp;ldquo;从类型推导&amp;rdquo;部分），并尝试找到将使推导的 &lt;code&gt;A&lt;/code&gt; （即上面列出的调整后的 &lt;code&gt;P&lt;/code&gt; 和推导的模板参数的替换）成为可能的模板参数。 ）与</target>
        </trans-unit>
        <trans-unit id="cbfa05ba4a64164c2c06108c94e66a0d15618966" translate="yes" xml:space="preserve">
          <source>After this call, &lt;code&gt;other&lt;/code&gt; has no associated mutex.</source>
          <target state="translated">在此调用之后， &lt;code&gt;other&lt;/code&gt; 没有关联的互斥体。</target>
        </trans-unit>
        <trans-unit id="09e6d08a70617f303ffde1bea6a795b13dc7771a" translate="yes" xml:space="preserve">
          <source>After this call, &lt;code&gt;this-&amp;gt;get_id()&lt;/code&gt; is equal to the value of &lt;code&gt;other.get_id()&lt;/code&gt; prior to the call, and &lt;code&gt;other&lt;/code&gt; no longer represents a thread of execution.</source>
          <target state="translated">在此调用之后， &lt;code&gt;this-&amp;gt;get_id()&lt;/code&gt; 等于调用之前的 &lt;code&gt;other.get_id()&lt;/code&gt; 的值，而 &lt;code&gt;other&lt;/code&gt; 不再代表执行线程。</target>
        </trans-unit>
        <trans-unit id="8c87604fd723b0f75058b0139b052da68fd8a53e" translate="yes" xml:space="preserve">
          <source>After this function completes, &lt;a href=&quot;has_path&quot;&gt;&lt;code&gt;has_filename&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">此函数完成后，&lt;a href=&quot;has_path&quot;&gt; &lt;code&gt;has_filename&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af11ceb4dfc69bc2e19a600385c6a2e921b44982" translate="yes" xml:space="preserve">
          <source>After this operation &lt;code&gt;r&lt;/code&gt; is not required to be dereferenceable and any copies of the previous value of &lt;code&gt;r&lt;/code&gt; are no longer required to be dereferenceable or incrementable.</source>
          <target state="translated">在此之后操作 &lt;code&gt;r&lt;/code&gt; 不需要被提领和以前的值的任何副本 &lt;code&gt;r&lt;/code&gt; 不再要求是提领或递增的。</target>
        </trans-unit>
        <trans-unit id="d6b3e4110c978c6c966e175d0fb21c24d0cb55b2" translate="yes" xml:space="preserve">
          <source>After this operation &lt;code&gt;r&lt;/code&gt; is not required to be incrementable and any copies of the previous value of &lt;code&gt;r&lt;/code&gt; are no longer required to be dereferenceable or incrementable.</source>
          <target state="translated">在此操作之后， &lt;code&gt;r&lt;/code&gt; 不需要是可递增的，并且 &lt;code&gt;r&lt;/code&gt; 的先前值的任何副本都不再是可解除引用或可递增的。</target>
        </trans-unit>
        <trans-unit id="5cb3c3ab15a7948ac9776fc01389be53890f7bf1" translate="yes" xml:space="preserve">
          <source>After this statement the control is transferred to the statement immediately following the enclosing loop or switch. As with any block exit, all automatic storage objects declared in enclosing compound statement or in the condition of a loop/switch are destroyed, in reverse order of construction, before the execution of the first line following the enclosing loop.</source>
          <target state="translated">在这个语句之后,控制权被转移到紧接着包围循环或开关的语句中。与任何块退出一样,所有在封闭式复合语句中声明的自动存储对象或在循环/开关的条件中声明的自动存储对象都会在封闭式循环之后的第一行执行之前,按照结构的相反顺序被销毁。</target>
        </trans-unit>
        <trans-unit id="fd175daec3ba5a5ff832d7613dfb6df9054a3994" translate="yes" xml:space="preserve">
          <source>After this, digit grouping is checked. if the position of any of the thousands separators discarded in Stage 2 does not match the grouping provided by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">此后，将检查数字分组。如果在阶段2中丢弃的数千个分隔符中任何一个的位置与 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 提供的分组不匹配： ：failbit被分配给 &lt;code&gt;err&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d93b73971332d0c3efd8634484908552ab34c9a" translate="yes" xml:space="preserve">
          <source>Afterwards, &lt;code&gt;p&lt;/code&gt; is equivalent to &lt;code&gt;nullptr&lt;/code&gt;</source>
          <target state="translated">之后， &lt;code&gt;p&lt;/code&gt; 等于 &lt;code&gt;nullptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="795da143b5dbe81dcf8c6232ccf436d09b14c393" translate="yes" xml:space="preserve">
          <source>Aggregate initialization</source>
          <target state="translated">总量初始化</target>
        </trans-unit>
        <trans-unit id="32f6926454c3165c26d9dc05c16b8b6e9f95c8bb" translate="yes" xml:space="preserve">
          <source>Aggregate initialization initializes</source>
          <target state="translated">聚合初始化初始化</target>
        </trans-unit>
        <trans-unit id="ce0cf7c09d177b646d6d216478f49a68396c308c" translate="yes" xml:space="preserve">
          <source>Aggregates copy/move initialize directly from single-element braced-init-lists of the same type, but non-aggregates consider initializer_list constructors first:</source>
          <target state="translated">聚合体直接从同类型的单元素括号-init-list中复制/移动初始化,但非聚合体首先考虑初始化器_list构造器。</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="e8a0f2b8083d5e86992465667615250c3f737a35" translate="yes" xml:space="preserve">
          <source>Algorithm concepts and utilities</source>
          <target state="translated">算法概念和工具</target>
        </trans-unit>
        <trans-unit id="b03f71c0b2a6d1e175830b00066b005660a7079a" translate="yes" xml:space="preserve">
          <source>Algorithm utilities</source>
          <target state="translated">算法工具</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="6886e87f506cf00f362a34227ad744fd6fcd6652" translate="yes" xml:space="preserve">
          <source>Algorithms library</source>
          <target state="translated">算法库</target>
        </trans-unit>
        <trans-unit id="b1d4c8b0854335cb6dc181f5d361a3a9a6c77f1d" translate="yes" xml:space="preserve">
          <source>Algorithms that operate on ranges</source>
          <target state="translated">对范围进行操作的算法</target>
        </trans-unit>
        <trans-unit id="8d55ef673ad6d9815c8fe83971681410e8111110" translate="yes" xml:space="preserve">
          <source>Alias declarations are &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt; with the following syntax:</source>
          <target state="translated">别名声明是具有以下语法的&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="ac7adb6d456a732926b16ac92fea1efb425fa68c" translate="yes" xml:space="preserve">
          <source>Alias template is a name that refers to a family of types.</source>
          <target state="translated">别名模板是指一个类型系列的名称。</target>
        </trans-unit>
        <trans-unit id="536ee4b3a1593a51e4e7a02e531109ebfa1e7aa5" translate="yes" xml:space="preserve">
          <source>Alias templates</source>
          <target state="translated">模板别名</target>
        </trans-unit>
        <trans-unit id="81fdfe39ee9314fa8adbdd24c8cefa9e67062042" translate="yes" xml:space="preserve">
          <source>Alias templates are never deduced by &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; when deducing a template template parameter.  It is not possible to &lt;a href=&quot;partial_specialization&quot;&gt;partially&lt;/a&gt; or &lt;a href=&quot;template_specialization&quot;&gt;explicitly specialize&lt;/a&gt; an alias template.</source>
          <target state="translated">推导&lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;模板模板参数&lt;/a&gt;时，绝不会通过模板参数推导来推导别名模板。无法&lt;a href=&quot;partial_specialization&quot;&gt;部分&lt;/a&gt;或&lt;a href=&quot;template_specialization&quot;&gt;显式地专门化&lt;/a&gt;别名模板。</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="a2aba61989bb9dc7a1e9fe034611bf7295de52c9" translate="yes" xml:space="preserve">
          <source>Alignment (as obtained by &lt;code&gt;alignof&lt;/code&gt;) has the type &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, but placement forms of allocation and deallocation functions that take &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; as an additional parameter are already in use, so this type is used instead.</source>
          <target state="translated">对齐方式（由 &lt;code&gt;alignof&lt;/code&gt; 获得）的类型为 &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ，但是已经使用了以 &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 作为附加参数的分配和释放函数的放置形式，因此将使用此类型。</target>
        </trans-unit>
        <trans-unit id="1284e78e088763e07d38bdc498c7ac19fcd9faaa" translate="yes" xml:space="preserve">
          <source>Alignment specifier</source>
          <target state="translated">校准指定器</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c533be78046b2b7438a7f5af4856db7635ad0dde" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../container&quot;&gt;standard library containers&lt;/a&gt; require that their element type satisfies Erasable.</source>
          <target state="translated">所有&lt;a href=&quot;../container&quot;&gt;标准库容器&lt;/a&gt;都要求其元素类型满足&amp;ldquo;可擦除&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ad583fce81393d0c4c343ed80041c1cf855fb389" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../language/pointer#Pointers_to_functions&quot;&gt;pointers to functions&lt;/a&gt; satisfy this requirement.</source>
          <target state="translated">所有&lt;a href=&quot;../language/pointer#Pointers_to_functions&quot;&gt;指向函数的指针都&lt;/a&gt;满足此要求。</target>
        </trans-unit>
        <trans-unit id="85e52ab157feeaab3392116ff6342f562d88a7b4" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;objects&quot;&gt;objects&lt;/a&gt; in a program have one of the following storage durations:</source>
          <target state="translated">程序中的所有&lt;a href=&quot;objects&quot;&gt;对象&lt;/a&gt;均具有以下存储时间之一：</target>
        </trans-unit>
        <trans-unit id="2be019deb6ca8794e180ab1025f12fa6403846db" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngines&lt;/a&gt; satisfy this requirement.</source>
          <target state="translated">所有&lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngines都&lt;/a&gt;满足此要求。</target>
        </trans-unit>
        <trans-unit id="5586b0fcd654b42e2d7df9c2c898d38125873577" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;const&lt;/code&gt; member functions can be called concurrently by different threads on the same container. In addition, the member functions &lt;code&gt;begin()&lt;/code&gt;, &lt;code&gt;end()&lt;/code&gt;, &lt;code&gt;rbegin()&lt;/code&gt;, &lt;code&gt;rend()&lt;/code&gt;, &lt;code&gt;front()&lt;/code&gt;, &lt;code&gt;back()&lt;/code&gt;, &lt;code&gt;data()&lt;/code&gt;, &lt;code&gt;find()&lt;/code&gt;, &lt;code&gt;lower_bound()&lt;/code&gt;, &lt;code&gt;upper_bound()&lt;/code&gt;, &lt;code&gt;equal_range()&lt;/code&gt;, &lt;code&gt;at()&lt;/code&gt;, and, except in associative containers, &lt;code&gt;operator[]&lt;/code&gt;, behave as &lt;code&gt;const&lt;/code&gt; for the purposes of thread safety (that is, they can also be called concurrently by different threads on the same container). More generally, the C++ standard library functions do not modify objects unless those objects are accessible, directly or indirectly, via the function's non-const arguments, including the this pointer.</source>
          <target state="translated">所有 &lt;code&gt;const&lt;/code&gt; 成员函数都可以由同一容器上的不同线程并发调用。此外，成员函数 &lt;code&gt;begin()&lt;/code&gt; ， &lt;code&gt;end()&lt;/code&gt; ， &lt;code&gt;rbegin()&lt;/code&gt; ， &lt;code&gt;rend()&lt;/code&gt; ， &lt;code&gt;front()&lt;/code&gt; ， &lt;code&gt;back()&lt;/code&gt; ， &lt;code&gt;data()&lt;/code&gt; ， &lt;code&gt;find()&lt;/code&gt; ， &lt;code&gt;lower_bound()&lt;/code&gt; ， &lt;code&gt;upper_bound()&lt;/code&gt; ， &lt;code&gt;equal_range()&lt;/code&gt; ， &lt;code&gt;at()&lt;/code&gt; ，并且（在关联容器中除外） &lt;code&gt;operator[]&lt;/code&gt; 行为与 &lt;code&gt;const&lt;/code&gt; 相同为了线程安全的目的（也就是说，它们也可以由同一容器上的不同线程并发调用）。更一般而言，C ++标准库函数不会修改对象，除非可以通过函数的非常量参数（包括this指针）直接或间接访问这些对象。</target>
        </trans-unit>
        <trans-unit id="4ce574fe03a26ad67fb18ae15f6d204f756c8e28" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;const&lt;/code&gt; member functions of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; are provided.</source>
          <target state="translated">提供了 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 所有 &lt;code&gt;const&lt;/code&gt; 成员函数。</target>
        </trans-unit>
        <trans-unit id="e4c5afaf4fff1d58306c2cfe530397e8446742a3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;emit()&lt;/code&gt; calls transferring characters to the same wrapped stream buffer object appear to execute in a total order, where each &lt;code&gt;emit()&lt;/code&gt; call &lt;a href=&quot;../../atomic/memory_order&quot;&gt;synchronizes-with&lt;/a&gt; subsequent &lt;code&gt;emit()&lt;/code&gt; calls in that total order, even if these calls are made through difference instances of &lt;code&gt;std::basic_syncbuf&lt;/code&gt;/&lt;code&gt;std::basic_osyncstream&lt;/code&gt;. In practice, this means that emit() takes a lock uniquely associated with the wrapped stream object: for example, it could be held in a static hash map where the address of the wrapped stream is used as the key.</source>
          <target state="translated">所有 &lt;code&gt;emit()&lt;/code&gt; 调用传输字符到同一包装流缓存对象显示在一个总次序，其中，每个执行 &lt;code&gt;emit()&lt;/code&gt; 呼叫&lt;a href=&quot;../../atomic/memory_order&quot;&gt;进行同步-与&lt;/a&gt;后续 &lt;code&gt;emit()&lt;/code&gt; 在总订单呼叫，即便这些呼叫通过差实例制成的 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; / &lt;code&gt;std::basic_osyncstream&lt;/code&gt; 。实际上，这意味着emit（）会获得一个与包装的流对象唯一关联的锁：例如，它可以保存在静态哈希映射中，其中包装的流的地址用作键。</target>
        </trans-unit>
        <trans-unit id="08e7989631f4fa0b7b123c5eceab25241a651d43" translate="yes" xml:space="preserve">
          <source>All Function objects defined in &lt;a href=&quot;../header/functional&quot;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;../header/functional&quot;&gt; &lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt; 中&lt;/a&gt;定义的所有Function对象</target>
        </trans-unit>
        <trans-unit id="267678e718109eec99ac63d1e0c78b1e78e6bc72" translate="yes" xml:space="preserve">
          <source>All arithmetic operators compute the result of specific arithmetic operation and returns its result. The arguments are not modified.</source>
          <target state="translated">所有算术运算符计算特定算术运算的结果,并返回其结果。参数不会被修改。</target>
        </trans-unit>
        <trans-unit id="2196ca16119493aee11e0e86a9a7193062fd552b" translate="yes" xml:space="preserve">
          <source>All atomic types except for &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be</source>
          <target state="translated">除 &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 之外的所有原子类型都可以使用互斥锁或其他锁定操作来实现，而不是使用无锁原子CPU指令来实现。原子类型也被允许</target>
        </trans-unit>
        <trans-unit id="acf874c1ced8a0f3cff5567518c467d553d7b81d" translate="yes" xml:space="preserve">
          <source>All atomic types except for &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be</source>
          <target state="translated">除 &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 之外的所有原子类型都可以使用互斥锁或其他锁定操作来实现，而不是使用无锁原子CPU指令来实现。原子类型也被允许</target>
        </trans-unit>
        <trans-unit id="1c6a82095fc35876e8565ece289c3317d10e940b" translate="yes" xml:space="preserve">
          <source>All built-in assignment operators return &lt;code&gt;*this&lt;/code&gt;, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;*this&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">所有内置的赋值运算符都返回 &lt;code&gt;*this&lt;/code&gt; ，并且大多数&lt;a href=&quot;operators&quot;&gt;用户定义的重载&lt;/a&gt;也返回 &lt;code&gt;*this&lt;/code&gt; ,以便用户定义的运算符可以与内置的相同的方式使用。但是，在用户定义的运算符重载中，任何类型都可以用作返回类型（包括 &lt;code&gt;void&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1e3f7702614f1e201b0d2d7ca9cab6129fd842e0" translate="yes" xml:space="preserve">
          <source>All built-in operators return &lt;code&gt;bool&lt;/code&gt;, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;bool&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">所有内置运算符都返回 &lt;code&gt;bool&lt;/code&gt; ，并且大多数&lt;a href=&quot;operators&quot;&gt;用户定义的重载&lt;/a&gt;也返回 &lt;code&gt;bool&lt;/code&gt; ,以便可以以与内置程序相同的方式使用用户定义的运算符。但是，在用户定义的运算符重载中，任何类型都可以用作返回类型（包括 &lt;code&gt;void&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ad44cda1026b661b30b82e23a1cc8e4adc8dad82" translate="yes" xml:space="preserve">
          <source>All built-in operators return values, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return values so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;). In particular, stream insertion and stream extraction overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; return &lt;code&gt;T&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">所有内置运算符都返回值，并且大多数&lt;a href=&quot;operators&quot;&gt;用户定义的重载&lt;/a&gt;也返回值，以便用户定义运算符可以以与内置函数相同的方式使用。但是，在用户定义的运算符重载中，任何类型都可以用作返回类型（包括 &lt;code&gt;void&lt;/code&gt; ）。特别是， &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 流插入和流提取过载返回 &lt;code&gt;T&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c15cf3f5d785f05b074208b892da42654f696fb" translate="yes" xml:space="preserve">
          <source>All comments are removed from the program at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 3&lt;/a&gt; by replacing each comment with a single whitespace character.</source>
          <target state="translated">通过将每个注释替换为单个空格字符，可以在&lt;a href=&quot;language/translation_phases&quot;&gt;翻译阶段3&lt;/a&gt;将所有注释从程序中删除。</target>
        </trans-unit>
        <trans-unit id="bf78ad8fede01661fec9052125328b1508f2f4d8" translate="yes" xml:space="preserve">
          <source>All comparison operators are short-circuited; they do not access tuple elements beyond what is necessary to determine the result of the comparison.</source>
          <target state="translated">所有的比较运算符都是短路的;它们不会访问超出确定比较结果所必需的元组元素。</target>
        </trans-unit>
        <trans-unit id="d086b64161b8d9aca02f8348f6309d2102ee1278" translate="yes" xml:space="preserve">
          <source>All comparisons are done via the &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; member function (which itself is defined in terms of &lt;code&gt;Traits::compare()&lt;/code&gt;):</source>
          <target state="translated">所有比较都是通过 &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; 成员函数（它本身是根据 &lt;code&gt;Traits::compare()&lt;/code&gt; ）完成的：</target>
        </trans-unit>
        <trans-unit id="b8289f337cbc9bd64fef53be2978b84bf37ef44f" translate="yes" xml:space="preserve">
          <source>All constants, except for &lt;code&gt;match_default&lt;/code&gt; and &lt;code&gt;format_default&lt;/code&gt;, are bitmask elements. The &lt;code&gt;match_default&lt;/code&gt; and &lt;code&gt;format_default&lt;/code&gt; constants are empty bitmasks.</source>
          <target state="translated">除 &lt;code&gt;match_default&lt;/code&gt; 和 &lt;code&gt;format_default&lt;/code&gt; 之外的所有常量都是位掩码元素。该 &lt;code&gt;match_default&lt;/code&gt; 和 &lt;code&gt;format_default&lt;/code&gt; 常数是空的位掩码。</target>
        </trans-unit>
        <trans-unit id="dc168f2bceb154961bb7ed9909031e74d78d43a5" translate="yes" xml:space="preserve">
          <source>All constructors that take &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; against a single argument of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">检查所有将 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 作为唯一参数，或将第一个参数（如果其余参数具有默认值）作为第一个参数的构造函数，并通过&lt;a href=&quot;overload_resolution&quot;&gt;重载解析将其&lt;/a&gt;与 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 类型的单个参数进行匹配</target>
        </trans-unit>
        <trans-unit id="2bcfde28187d671e9cbf776fb85caf9d73bb4df9" translate="yes" xml:space="preserve">
          <source>All container functions can be called concurrently by different threads on different containers. More generally, the C++ standard library functions do not read objects accessible by other threads unless those objects are directly or indirectly accessible via the function arguments, including the this pointer.</source>
          <target state="translated">所有的容器函数都可以被不同的线程在不同的容器上并发调用。更一般地说,C++标准库函数不读取其他线程可访问的对象,除非这些对象是通过函数参数直接或间接访问的,包括this指针。</target>
        </trans-unit>
        <trans-unit id="36bd3ae32477cc666c63b1b73c2d5eb0bca71c31" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../../string/byte/isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">除 &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 之外的所有转换说明符均消耗和丢弃所有前导空白字符（由调用&lt;a href=&quot;../../string/byte/isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt;来确定）在尝试解析输入之前）。这些消耗的字符不计入指定的最大字段宽度。</target>
        </trans-unit>
        <trans-unit id="a2b014357acb5001a9291cf56269f10b96493516" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../../string/wide/iswspace&quot;&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">除 &lt;code&gt;[&lt;/code&gt; ， &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 之外的所有转换说明符均消耗和丢弃所有前导空白字符（由调用&lt;a href=&quot;../../string/wide/iswspace&quot;&gt; &lt;code&gt;iswspace&lt;/code&gt; &lt;/a&gt;来确定）在尝试解析输入之前）。这些消耗的字符不计入指定的最大字段宽度。</target>
        </trans-unit>
        <trans-unit id="cbea028682ce84815358b5aa6eda3b614cfe993e" translate="yes" xml:space="preserve">
          <source>All custom allocators also must be stateless.</source>
          <target state="translated">所有的自定义分配器也必须是无状态的。</target>
        </trans-unit>
        <trans-unit id="e99bcc0ededa138f077034c407c38f0bfa9cb54b" translate="yes" xml:space="preserve">
          <source>All deallocation functions are &lt;code&gt;noexcept(true)&lt;/code&gt; unless specified otherwise in the declaration.</source>
          <target state="translated">所有释放函数均为 &lt;code&gt;noexcept(true)&lt;/code&gt; 除非声明中另有指定，否则。</target>
        </trans-unit>
        <trans-unit id="7590e38178794abe168d1f61e5e605ebedab40ca" translate="yes" xml:space="preserve">
          <source>All direct base classes have trivial destructors</source>
          <target state="translated">所有的直接基类都有琐碎的析构器。</target>
        </trans-unit>
        <trans-unit id="d1644548c66e07081be823b1a24493d9cfc6d493" translate="yes" xml:space="preserve">
          <source>All error codes are distinct and non-zero.</source>
          <target state="translated">所有的错误代码都是独特的、非零的。</target>
        </trans-unit>
        <trans-unit id="4eb9393603f7bb0528b986591eb39bc9de40a1c4" translate="yes" xml:space="preserve">
          <source>All evaluations of &lt;code&gt;h(k)&lt;/code&gt;executed within a given execution of a program(since C++14) yield the same result for the same value of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">在给定的程序执行中执行的所有 &lt;code&gt;h(k)&lt;/code&gt; 评估（自C ++ 14起）对于相同的 &lt;code&gt;k&lt;/code&gt; 值产生相同的结果。</target>
        </trans-unit>
        <trans-unit id="615556c95cd2277e3f2551bbe6ac5d7b7503c6b8" translate="yes" xml:space="preserve">
          <source>All exceptions generated by the standard library inherit from &lt;code&gt;std::exception&lt;/code&gt;.</source>
          <target state="translated">标准库生成的所有异常都继承自 &lt;code&gt;std::exception&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47496370c3026a6d2335b4c07d2899c2bfd0a9f8" translate="yes" xml:space="preserve">
          <source>All existing elements of &lt;code&gt;a&lt;/code&gt; are either move assigned to or destroyed; &lt;code&gt;a&lt;/code&gt; is equal to the value that &lt;code&gt;rv&lt;/code&gt; had before the assignment</source>
          <target state="translated">的所有现有的元件 &lt;code&gt;a&lt;/code&gt; 被上移分配到或销毁; &lt;code&gt;a&lt;/code&gt; 等于 &lt;code&gt;rv&lt;/code&gt; 在赋值之前的值</target>
        </trans-unit>
        <trans-unit id="9b1c1c57702fcbfb1474e82ce403b1688060d643" translate="yes" xml:space="preserve">
          <source>All explicit and partial specializations of &lt;code&gt;hash&lt;/code&gt; provided by the standard library are &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; and &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;. User-provided specializations of &lt;code&gt;hash&lt;/code&gt; also must meet those requirements.</source>
          <target state="translated">所有显性和部分特例 &lt;code&gt;hash&lt;/code&gt; 标准库提供了&lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;缺省构造&lt;/a&gt;，&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;，&lt;a href=&quot;../named_req/swappable&quot;&gt;可交换&lt;/a&gt;和&lt;a href=&quot;../named_req/destructible&quot;&gt;可破坏&lt;/a&gt;。用户提供的 &lt;code&gt;hash&lt;/code&gt; 专业化也必须满足这些要求。</target>
        </trans-unit>
        <trans-unit id="d3caef46757d5c781ce31db0ab1b1d011a7c9448" translate="yes" xml:space="preserve">
          <source>All functions accepting an argument of type &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; except &lt;a href=&quot;begin2&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;end2&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt;(since C++11) should also accept the replacement type.</source>
          <target state="translated">所有接受 &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; 类型的参数的函数，除了&lt;a href=&quot;begin2&quot;&gt; &lt;code&gt;begin()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;end2&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt;（自C ++ 11起）也应接受替换类型。</target>
        </trans-unit>
        <trans-unit id="0179673daad25aa9537982f33e1688378d0b8b34" translate="yes" xml:space="preserve">
          <source>All functions accepting two arguments of type &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; should accept every combination of &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; and the replacement type.</source>
          <target state="translated">接受两个类型为 &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的所有函数都应接受 &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; 和替换类型的每种组合。</target>
        </trans-unit>
        <trans-unit id="c84866185eebd1e3d3c0bd203de655735b81b728" translate="yes" xml:space="preserve">
          <source>All functions from &lt;a href=&quot;../../types#Type_traits&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../../types#Type_traits&quot;&gt;&amp;lt;type_traits&amp;gt;中的&lt;/a&gt;所有功能</target>
        </trans-unit>
        <trans-unit id="eacdccc0ff89286560bd5447dd6d3e5754738868" translate="yes" xml:space="preserve">
          <source>All implicitly-captured variables must be declared within the</source>
          <target state="translated">所有隐式捕获的变量都必须在</target>
        </trans-unit>
        <trans-unit id="ee4038fb61cddc0d5aee00559af689e67143f4cb" translate="yes" xml:space="preserve">
          <source>All implicitly-declared member functions (and inheriting constructors) have exception specifications, selected as follows:</source>
          <target state="translated">所有隐式声明的成员函数(和继承构造函数)都有异常规范,选择如下。</target>
        </trans-unit>
        <trans-unit id="73a8920376f49ed06b9320f4b183b14d1b56c59a" translate="yes" xml:space="preserve">
          <source>All instances of &lt;code&gt;std::monostate&lt;/code&gt; compare equal.</source>
          <target state="translated">&lt;code&gt;std::monostate&lt;/code&gt; 所有实例都相等。</target>
        </trans-unit>
        <trans-unit id="6f36973910215a95c48be1c361c474c6abda5dfd" translate="yes" xml:space="preserve">
          <source>All iterators and references are invalidated, unless the erased elements are at the end or the beginning of the container, in which case only the iterators and references to the erased elements are invalidated.</source>
          <target state="translated">所有的迭代器和引用都是无效的,除非被擦除的元素在容器的结尾或开头,在这种情况下,只有被擦除元素的迭代器和引用是无效的。</target>
        </trans-unit>
        <trans-unit id="3ff58822fed4cebf575b53176b537d16617bfe40" translate="yes" xml:space="preserve">
          <source>All iterators and references are invalidated. Past-the-end iterator is also invalidated.</source>
          <target state="translated">所有的迭代器和引用都是无效的。过去结束的迭代器也无效。</target>
        </trans-unit>
        <trans-unit id="b6bfeb63a7689b81c8714600b9a0261d56188882" translate="yes" xml:space="preserve">
          <source>All iterators and references remain valid. It is unspecified whether an iterator holding the past-the-end value in this container will refer to this or the other container after the operation.</source>
          <target state="translated">所有的迭代器和引用仍然有效。没有说明在这个容器中持有过去结束值的迭代器在操作后是引用这个容器还是另一个容器。</target>
        </trans-unit>
        <trans-unit id="c94adb4871f7b21a7fe1f80a6cb316845a106fd2" translate="yes" xml:space="preserve">
          <source>All iterators and references remain valid. The past-the-end iterator is invalidated.</source>
          <target state="translated">所有迭代器和引用仍然有效。过去结束的迭代器无效。</target>
        </trans-unit>
        <trans-unit id="ca555a6b3c340c88a2973a4408368f43f4dc4831" translate="yes" xml:space="preserve">
          <source>All iterators, including the past-the-end iterator, are invalidated. No references are invalidated.</source>
          <target state="translated">所有的迭代器,包括过去的结束迭代器,都是无效的。没有引用无效。</target>
        </trans-unit>
        <trans-unit id="cf1ebdb0694902a0ff8fae76c426f9dc6a20dead" translate="yes" xml:space="preserve">
          <source>All iterators, including the past-the-end iterator, are invalidated. References are invalidated too, unless &lt;code&gt;pos == begin()&lt;/code&gt; or &lt;code&gt;pos == end()&lt;/code&gt;, in which case they are not invalidated.</source>
          <target state="translated">所有迭代器（包括过去的迭代器）均无效。引用也将无效，除非 &lt;code&gt;pos == begin()&lt;/code&gt; 或 &lt;code&gt;pos == end()&lt;/code&gt; ，在这种情况下，引用不会无效。</target>
        </trans-unit>
        <trans-unit id="40ad628bf4f34bdc58de5f589d209eea4731620e" translate="yes" xml:space="preserve">
          <source>All iterators, pointers and references to the elements of the container are invalidated.</source>
          <target state="translated">所有对容器元素的迭代器、指针和引用都无效。</target>
        </trans-unit>
        <trans-unit id="94cae0bd78bc02d0cb18bf7254756a408b83ca8f" translate="yes" xml:space="preserve">
          <source>All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated.</source>
          <target state="translated">所有迭代器、指针和对容器元素的引用都无效。过去结束的迭代器也无效。</target>
        </trans-unit>
        <trans-unit id="1aa2eedbbbd254c0a4f9a58cb63ee4b66a5cdbf4" translate="yes" xml:space="preserve">
          <source>All lock and unlock operations on a single mutex occur in a single total order</source>
          <target state="translated">单个mutex上的所有锁定和解锁操作都以单一的总顺序进行。</target>
        </trans-unit>
        <trans-unit id="178cdfec76dc5f4d6166a9e91517e1f3fec12bff" translate="yes" xml:space="preserve">
          <source>All lock and unlock operations on a single mutex occur in a single total order that can be viewed as &lt;a href=&quot;../atomic/memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of an atomic variable: the order is specific to this individual mutex.</source>
          <target state="translated">单个互斥锁上的所有锁定和解锁操作均以单个总顺序发生，可以视为原子变量的&lt;a href=&quot;../atomic/memory_order#Modification_order&quot;&gt;修改顺序&lt;/a&gt;：该顺序特定于此单个互斥量。</target>
        </trans-unit>
        <trans-unit id="34930fdb8cc73ddd310f600e059433705d8a684e" translate="yes" xml:space="preserve">
          <source>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of &lt;code&gt;shared_ptr&lt;/code&gt; without additional synchronization even if these instances are copies and share ownership of the same object. If multiple threads of execution access the same &lt;code&gt;shared_ptr&lt;/code&gt; without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur; the &lt;a href=&quot;shared_ptr/atomic&quot;&gt;shared_ptr overloads of atomic functions&lt;/a&gt; can be used to prevent the data race.</source>
          <target state="translated">多个线程可以在 &lt;code&gt;shared_ptr&lt;/code&gt; 的不同实例上调用所有成员函数（包括副本构造函数和副本分配），而无需额外同步，即使这些实例是副本并共享同一对象的所有权。如果多个执行线程在不同步的情况下访问同一个 &lt;code&gt;shared_ptr&lt;/code&gt; ，并且这些访问中的任何一个都使用了 &lt;code&gt;shared_ptr&lt;/code&gt; 的非常量成员函数，则将发生数据争用；否则，将导致数据争用。&lt;a href=&quot;shared_ptr/atomic&quot;&gt;原子函数&lt;/a&gt;的shared_ptr重载可用于防止数据争用。</target>
        </trans-unit>
        <trans-unit id="35b76e83898bb18b9a2f37898e8607d37cde7935" translate="yes" xml:space="preserve">
          <source>All member functions of all standard library specializations of this template are &lt;code&gt;noexcept&lt;/code&gt; except for the member functions of &lt;a href=&quot;optional/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;variant/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::variant&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../memory/unique_ptr/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">除&lt;a href=&quot;optional/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;variant/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::variant&amp;gt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../memory/unique_ptr/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt; &lt;/a&gt;的成员函数外，此模板的所有标准库专业化的所有成员函数 &lt;code&gt;noexcept&lt;/code&gt; 例外。unique_ptr&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8504e2abc83d5c2fab9fb5538bf231a69f226b05" translate="yes" xml:space="preserve">
          <source>All members are defined at once in the class definition, they cannot be added to an already-defined class (unlike the members of namespaces).</source>
          <target state="translated">所有的成员都是在类定义中一次性定义的,它们不能被添加到已经定义好的类中(与命名空间的成员不同)。</target>
        </trans-unit>
        <trans-unit id="5302fa5db09bb78acbca4f2b6c8fda7d03161a35" translate="yes" xml:space="preserve">
          <source>All members of a class (bodies of &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;, initializers of member objects, and the entire &lt;a href=&quot;nested_classes&quot;&gt;nested class definitions&lt;/a&gt;) have access to all names the class can access. A local class within a member function has access to all names the member function can access.</source>
          <target state="translated">类的所有成员（&lt;a href=&quot;member_functions&quot;&gt;成员函数的&lt;/a&gt;主体，成员对象的初始化程序以及整个&lt;a href=&quot;nested_classes&quot;&gt;嵌套的类定义&lt;/a&gt;）都可以访问该类可以访问的所有名称。成员函数中的本地类可以访问该成员函数可以访问的所有名称。</target>
        </trans-unit>
        <trans-unit id="59ab18ea391c2d9b328f2f7d982b4ad982485409" translate="yes" xml:space="preserve">
          <source>All modifications to any particular atomic variable occur in a total order that is specific to this one atomic variable.</source>
          <target state="translated">对任何一个特定原子变量的所有修改,都是以这一个原子变量特有的总顺序发生的。</target>
        </trans-unit>
        <trans-unit id="d28efff2a0fb864afdef01249aa565cd9c9d0c3a" translate="yes" xml:space="preserve">
          <source>All names introduced by the declarations that appear within namespace-body (including nested namespace definitions) become members of the namespace identifier, whether this namespace definition is the original namespace definition (which introduced identifier), or an extension namespace definition (which &quot;reopened&quot; the already defined namespace).</source>
          <target state="translated">所有出现在namespace-body中的声明所引入的名称(包括嵌套的名称空间定义)都会成为名称空间标识符的成员,无论这个名称空间定义是原始的名称空间定义(引入标识符),还是扩展的名称空间定义(&quot;重新打开 &quot;已经定义的名称空间)。</target>
        </trans-unit>
        <trans-unit id="b08c863ba714f38d0d860de01117473b44bbbe86" translate="yes" xml:space="preserve">
          <source>All non-local variables with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; are initialized as part of program startup, before the execution of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt; begins (unless deferred, see below). All variables with thread-local storage duration are initialized as part of thread launch, sequenced-before the execution of the thread function begins. For both of these classes of variables, initialization occurs in two distinct stages:</source>
          <target state="translated">在&lt;a href=&quot;main_function&quot;&gt;主函数&lt;/a&gt;开始执行之前，所有具有静态&lt;a href=&quot;storage_duration&quot;&gt;存储持续时间的&lt;/a&gt;非局部变量都将在程序启动时进行初始化（除非推迟，请参见下文）。在线程函数开始执行之前，所有具有线程本地存储持续时间的变量都将作为线程启动的一部分进行序列化初始化。对于这两种变量，初始化都在两个不同的阶段进行：</target>
        </trans-unit>
        <trans-unit id="55481c71bd011e1fe7bc3e43733da57362a61783" translate="yes" xml:space="preserve">
          <source>All non-specialized &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; functions are also provided by this specialization, and no additional member functions.</source>
          <target state="translated">该专业化还提供所有非专业化的 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 函数，并且没有其他成员函数。</target>
        </trans-unit>
        <trans-unit id="0557b920b1069437438d197127c5136f3ee6adf1" translate="yes" xml:space="preserve">
          <source>All non-static data members and base classes are themselves standard layout types</source>
          <target state="translated">所有非静态数据成员和基类本身就是标准的布局类型。</target>
        </trans-unit>
        <trans-unit id="e4dcf520b0bb3c172727a71b79681a5d16c241c8" translate="yes" xml:space="preserve">
          <source>All non-static data members have the same &lt;a href=&quot;../language/access&quot;&gt;access control&lt;/a&gt;</source>
          <target state="translated">所有非静态数据成员具有相同的&lt;a href=&quot;../language/access&quot;&gt;访问控制&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="624a5b6de90948456f868c89c51c9329989f3cb3" translate="yes" xml:space="preserve">
          <source>All non-static data members of class type (or array of class type) have trivial destructors</source>
          <target state="translated">类类型(或类类型的数组)的所有非静态数据成员都有琐碎的析构器。</target>
        </trans-unit>
        <trans-unit id="f485616a097e8c940e99a2d2edb5c6f19158253d" translate="yes" xml:space="preserve">
          <source>All of the elements before this new &lt;code&gt;nth&lt;/code&gt; element are less than or equal to the elements after the new &lt;code&gt;nth&lt;/code&gt; element.</source>
          <target state="translated">这个新的 &lt;code&gt;nth&lt;/code&gt; 元素之前的所有元素都小于或等于新的 &lt;code&gt;nth&lt;/code&gt; 元素之后的元素。</target>
        </trans-unit>
        <trans-unit id="d5ea57823ac6ced06c326c70fd59fde6fcce0fad" translate="yes" xml:space="preserve">
          <source>All of the iterator categories (except &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;) can be organized into a hierarchy, where more powerful iterator categories (e.g. &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;) support the operations of less powerful categories (e.g. &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;). If an iterator falls into one of these categories and also satisfies the requirements of &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, then it is called a</source>
          <target state="translated">可以将所有迭代器类别（&lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;和&lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;除外）组织成一个层次结构，其中功能更强大的迭代器类别（例如&lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;）支持功能更弱的类别（例如&lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;）的操作。如果迭代器属于这些类别之一，并且还满足&lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;的要求，则称为</target>
        </trans-unit>
        <trans-unit id="f4c48696f28287567f830764d3d2f6d6181a4365" translate="yes" xml:space="preserve">
          <source>All other constructors take an allocator parameter.</source>
          <target state="translated">其他所有的构造函数都取一个分配器参数。</target>
        </trans-unit>
        <trans-unit id="9051dde370d80e8aba9af3637e2fe2a4c637ddb2" translate="yes" xml:space="preserve">
          <source>All pointers are considered valid and may be dereferenced or deallocated</source>
          <target state="translated">所有的指针都被认为是有效的,并可能被取消引用或重新分配。</target>
        </trans-unit>
        <trans-unit id="06db46d40762e7a049233b69f344ddc40172814b" translate="yes" xml:space="preserve">
          <source>All pointers are considered valid and may be dereferenced or deallocated. A reachability-based leak detector may be active</source>
          <target state="translated">所有的指针都被认为是有效的,并可能被取消引用或重新定位。基于可到达性的泄漏检测器可能会被激活。</target>
        </trans-unit>
        <trans-unit id="bdcfa55217ac64f8db8a5cf75b2b3e2a7b2b589f" translate="yes" xml:space="preserve">
          <source>All pointers, references, and iterators are invalidated.</source>
          <target state="translated">所有指针、引用和迭代器都无效。</target>
        </trans-unit>
        <trans-unit id="cae4dbc2c6705f38175037741cbe2272cd9f0a9e" translate="yes" xml:space="preserve">
          <source>All private data members and all private non-virtual member functions are placed in the implementation class. All public, protected, and virtual members remain in the interface class (see &lt;a href=&quot;http://herbsutter.com/gotw/_100/&quot;&gt;GOTW #100&lt;/a&gt; for the discussion of the alternatives).</source>
          <target state="translated">所有私有数据成员和所有私有非虚拟成员函数都放在实现类中。所有公共成员，受保护成员和虚拟成员都保留在接口类中（有关替代方法的讨论，请参阅&lt;a href=&quot;http://herbsutter.com/gotw/_100/&quot;&gt;GOTW＃100&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6ad08b1a1866207c625f156796d23145d807041c" translate="yes" xml:space="preserve">
          <source>All read only operations</source>
          <target state="translated">所有只读操作</target>
        </trans-unit>
        <trans-unit id="51f454bbf261c865ca3eafaca5186949d522a16c" translate="yes" xml:space="preserve">
          <source>All read only operations, &lt;code&gt;&lt;a href=&quot;unordered_map/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">所有只读操作， &lt;code&gt;&lt;a href=&quot;unordered_map/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d0ff23cc747ee3f2c2cacda30dad2daf43fc67d" translate="yes" xml:space="preserve">
          <source>All read only operations, &lt;code&gt;&lt;a href=&quot;vector/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">所有只读操作， &lt;code&gt;&lt;a href=&quot;vector/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41a67df5b26d67f230c41a225f6f4807b01737d6" translate="yes" xml:space="preserve">
          <source>All references, pointers, and iterators are invalidated, including the end iterator. &lt;code&gt;a.empty() == true&lt;/code&gt;.</source>
          <target state="translated">所有引用，指针和迭代器都无效，包括结束迭代器。 &lt;code&gt;a.empty() == true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efe67501a1ba3ff0b54181ac0c20ec517abdc3e4" translate="yes" xml:space="preserve">
          <source>All requirements on the iterator types of a &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; applies to the &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; types of &lt;code&gt;basic_string_view&lt;/code&gt; as well.</source>
          <target state="translated">对&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;的迭代器类型的所有要求也适用于 &lt;code&gt;basic_string_view&lt;/code&gt; 的 &lt;code&gt;iterator&lt;/code&gt; 和 &lt;code&gt;const_iterator&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="2f7b5a1e5c99b2a9bb4697e1dc9787334111a47c" translate="yes" xml:space="preserve">
          <source>All requirements on the iterator types of a &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; applies to the &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; types of &lt;code&gt;span&lt;/code&gt; as well.</source>
          <target state="translated">对&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;的迭代器类型的所有要求也适用于 &lt;code&gt;span&lt;/code&gt; 的 &lt;code&gt;iterator&lt;/code&gt; 和 &lt;code&gt;const_iterator&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="38eb211404e95dd1fe2352aec53428f8cadc5999" translate="yes" xml:space="preserve">
          <source>All resources owned by &lt;code&gt;u&lt;/code&gt; are reclaimed, no exceptions are thrown.</source>
          <target state="translated">&lt;code&gt;u&lt;/code&gt; 拥有的所有资源都将被回收，不会引发任何异常。</target>
        </trans-unit>
        <trans-unit id="67f929817d9ab7c1515c103b3dec94699f49b916" translate="yes" xml:space="preserve">
          <source>All restrictions on regular declarations of the same names, hiding, and overloading rules apply to using-declarations:</source>
          <target state="translated">所有对同名常规声明的限制、隐藏和重载规则都适用于使用-声明。</target>
        </trans-unit>
        <trans-unit id="be8b6e7136fa8d596cfda90d7fa7d28938ef27cd" translate="yes" xml:space="preserve">
          <source>All six relational operators are automatically generated by the compiler if the three-way comparison operator &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; is defined, and that operator, in turn, is generated by the compiler if it is defined as defaulted:</source>
          <target state="translated">如果定义了三向比较运算符operator &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; ，那么所有六个关系运算符将由编译器自动生成，而如果将其定义为默认值，则由编译器生成该运算符：</target>
        </trans-unit>
        <trans-unit id="0d9fb7dc61944bda88f1835dd4562a6f28a100a2" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;fpos&lt;/code&gt; meet the &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;, and &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; requirements.</source>
          <target state="translated">&lt;code&gt;fpos&lt;/code&gt; 的所有专业化都满足&lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;，&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;，&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;，&lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;和&lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable的&lt;/a&gt;要求。</target>
        </trans-unit>
        <trans-unit id="672a39cb4d9a7dc48c3d594e3812033e46d14edc" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;polymorphic_allocator&lt;/code&gt; meet the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;Allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;polymorphic_allocator&lt;/code&gt; 的所有专业都满足&lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;Allocator完整性要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="211f03dbec01e5b6570f235c7176b37d2a2a79b5" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;shared_ptr&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, and &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; and are &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually convertible&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shared_ptr&lt;/code&gt; 的所有专业都满足&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;，&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;和&lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;的要求，并且可以在&lt;a href=&quot;../language/implicit_cast&quot;&gt;上下文中转换&lt;/a&gt;为 &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1031f9406b312c985a6ae796719a2a8d26efc31e" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;std::tuple_size&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">&lt;code&gt;std::tuple_size&lt;/code&gt; 所有专业化都满足&lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt;与</target>
        </trans-unit>
        <trans-unit id="743934d87daadcc6d9d31370a3db4d5504aa0fb9" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;std::variant_size&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">&lt;code&gt;std::variant_size&lt;/code&gt; 所有专业化都满足&lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt;与</target>
        </trans-unit>
        <trans-unit id="63c53895a6870cc913e144b2578bac2d714b260c" translate="yes" xml:space="preserve">
          <source>All standard containers (&lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;, etc.) value-initialize their elements when constructed with a single &lt;code&gt;size_type&lt;/code&gt; argument or when grown by a call to &lt;code&gt;resize()&lt;/code&gt;.</source>
          <target state="translated">所有标准容器（ &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 等）在使用单个 &lt;code&gt;size_type&lt;/code&gt; 参数构造或通过调用 &lt;code&gt;resize()&lt;/code&gt; 进行生长时，都会对它们的元素进行值初始化。</target>
        </trans-unit>
        <trans-unit id="358e40d1bfabb9461fdcb4d0a347855e7c412649" translate="yes" xml:space="preserve">
          <source>All standard library containers except &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; are AllocatorAwareContainers:</source>
          <target state="translated">除 &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; 外的所有标准库容器都是AllocatorAwareContainers：</target>
        </trans-unit>
        <trans-unit id="ffcd9ca742b4542ddb772e7d60b22b2039e3de22" translate="yes" xml:space="preserve">
          <source>All temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created, and if multiple temporary objects were created, they are destroyed in the order opposite to the order of creation. This is true even if that evaluation ends in throwing an exception.</source>
          <target state="translated">所有的临时对象都会在评估(词法上)包含创建点的全表达式的最后一步被销毁,如果创建了多个临时对象,则会按照与创建顺序相反的顺序销毁。即使该评估以抛出异常而告终,也是如此。</target>
        </trans-unit>
        <trans-unit id="32f475507fbff7c599c3fd139abea98403ae6343" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions do not invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">所有这些函数至少调用一次 &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; ，返回后 &lt;code&gt;arg&lt;/code&gt; 的值不确定。这些函数不会调用 &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; ，并且必须由调用方完成。</target>
        </trans-unit>
        <trans-unit id="176f5f0946a06ebe297b8c8ddf38982989abc5aa" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">所有这些函数至少调用一次 &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; ，返回后 &lt;code&gt;arg&lt;/code&gt; 的值不确定。这些函数不会调用 &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; ，并且必须由调用方完成。</target>
        </trans-unit>
        <trans-unit id="fe267d2b83e7299286bdf1b9c5aac0a7f499c7ed" translate="yes" xml:space="preserve">
          <source>All these functions invoke undefined behavior if &lt;code&gt;p&lt;/code&gt; is a null pointer.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是空指针，则所有这些函数都将调用未定义的行为。</target>
        </trans-unit>
        <trans-unit id="b0490d0cb63a327b1645f25c31bcc6482c7608ed" translate="yes" xml:space="preserve">
          <source>All these macro constants (except &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.</source>
          <target state="translated">所有这些宏常量（ &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; 除外）都扩展为具有2的幂的整数常量表达式，它们可唯一标识所有受支持的浮点异常。仅在支持的情况下定义每个宏。</target>
        </trans-unit>
        <trans-unit id="18f14072e9d32bbf324c49cf31c0caf2c548ae29" translate="yes" xml:space="preserve">
          <source>All three overloads effectively return &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).ends_with(x);&lt;/code&gt;</source>
          <target state="translated">这三个重载都有效地返回 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).ends_with(x);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ae0f95f4fd5fb1e59f705f02f6b13547bc8d638" translate="yes" xml:space="preserve">
          <source>All three overloads effectively return &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).starts_with(x);&lt;/code&gt;</source>
          <target state="translated">这三个重载都有效地返回 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).starts_with(x);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41dbcf1025fbada0bb806a90ae80be55d2ccdbc3" translate="yes" xml:space="preserve">
          <source>All uniform random bit generators meet the &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; requirements. C++20 also defines a &lt;a href=&quot;random/uniformrandombitgenerator&quot;&gt;&lt;code&gt;UniformRandomBitGenerator&lt;/code&gt;&lt;/a&gt; concept.</source>
          <target state="translated">所有统一的随机位生成器均满足&lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator的&lt;/a&gt;要求。C ++ 20还定义了&lt;a href=&quot;random/uniformrandombitgenerator&quot;&gt; &lt;code&gt;UniformRandomBitGenerator&lt;/code&gt; &lt;/a&gt;概念。</target>
        </trans-unit>
        <trans-unit id="8d23b28c0c5980cc7718a01e280ed03d0685c95f" translate="yes" xml:space="preserve">
          <source>All users have read, write, and execute/search permissions</source>
          <target state="translated">所有用户都有读、写、执行/搜索的权限。</target>
        </trans-unit>
        <trans-unit id="a57778f1822ccdd378e7db95391c602549921f33" translate="yes" xml:space="preserve">
          <source>All valid permission bits.</source>
          <target state="translated">所有有效的权限位。</target>
        </trans-unit>
        <trans-unit id="49247714c9e6a1264921f2f7061610f5ebfc233f" translate="yes" xml:space="preserve">
          <source>All values are required to be unique except that the values of &lt;code&gt;EOPNOTSUPP&lt;/code&gt; and &lt;code&gt;ENOTSUP&lt;/code&gt; may be identical and the values of &lt;code&gt;EAGAIN&lt;/code&gt; and &lt;code&gt;EWOULDBLOCK&lt;/code&gt; may be identical.</source>
          <target state="translated">除了 &lt;code&gt;EOPNOTSUPP&lt;/code&gt; 和 &lt;code&gt;ENOTSUP&lt;/code&gt; 的值可以相同并且 &lt;code&gt;EAGAIN&lt;/code&gt; 和 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; 的值可以相同之外，所有值都必须唯一。</target>
        </trans-unit>
        <trans-unit id="9c56cddca11b01528f10a9f07f26dc5bec9d8e2f" translate="yes" xml:space="preserve">
          <source>All versions behave as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunctions&lt;/a&gt;. After constructing and checking the sentry object, these functions perform the following:</source>
          <target state="translated">所有版本均表现为&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunctions&lt;/a&gt;。在构造并检查了哨兵对象之后，这些功能将执行以下操作：</target>
        </trans-unit>
        <trans-unit id="fe817f9833c1ccda48652b1e96a5f243b7b8c465" translate="yes" xml:space="preserve">
          <source>All versions set the value of &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; to the number of characters extracted.</source>
          <target state="translated">所有版本都将 &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; 的值设置为提取的字符数。</target>
        </trans-unit>
        <trans-unit id="7c49bcb1867689918b55a1779cbc5e6907f7117d" translate="yes" xml:space="preserve">
          <source>All virtual base subobjects are initialized before any non-virtual base subobject, so only the most derived class calls the constructors of the virtual bases in its &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt;:</source>
          <target state="translated">所有虚拟基础子对象都在任何非虚拟基础子对象之前初始化，因此，只有最派生的类在其&lt;a href=&quot;constructor&quot;&gt;成员初始化器列表中&lt;/a&gt;调用虚拟基础的构造函数：</target>
        </trans-unit>
        <trans-unit id="7b8e5641e2d8cbf1a2bdfdaf4f5a52ae7c538b20" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage whose alignment is specified by &lt;code&gt;alignment&lt;/code&gt;. The &lt;code&gt;size&lt;/code&gt; parameter must be an integral multiple of &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">分配未对齐存储的 &lt;code&gt;size&lt;/code&gt; 字节，未对齐存储的对齐方式由 &lt;code&gt;alignment&lt;/code&gt; 指定。的 &lt;code&gt;size&lt;/code&gt; 参数必须是的整数倍 &lt;code&gt;alignment&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3713458c26ce42a8beb1ed61bfb66555a6fd00bb" translate="yes" xml:space="preserve">
          <source>Allocate memory</source>
          <target state="translated">分配内存</target>
        </trans-unit>
        <trans-unit id="c69536036834933fadf93bcfad2311dd91d4b772" translate="yes" xml:space="preserve">
          <source>Allocate raw aligned memory from the underlying resource</source>
          <target state="translated">从底层资源中分配原始对齐的内存。</target>
        </trans-unit>
        <trans-unit id="8c90ccd007d394557e735c7fe5d3753ec43eedf6" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n * sizeof(T)&lt;/code&gt; bytes of uninitialized storage by calling &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;)&lt;/code&gt;or &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt;(since C++17), but it is unspecified when and how this function is called. The pointer &lt;code&gt;hint&lt;/code&gt; may be used to provide locality of reference: the allocator, if supported by the implementation, will attempt to allocate the new memory block as close as possible to &lt;code&gt;hint&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;（&lt;a href=&quot;../../types/size_t&quot;&gt;std :: size_t&lt;/a&gt;）或 &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;（&lt;a href=&quot;../../types/size_t&quot;&gt;std :: size_t&lt;/a&gt;，&lt;a href=&quot;../new/align_val_t&quot;&gt;std :: align_val_t&lt;/a&gt;）（从C ++ 17开始）分配 &lt;code&gt;n * sizeof(T)&lt;/code&gt; 字节的未初始化存储，但是它是未指定何时以及如何调用此函数。指针 &lt;code&gt;hint&lt;/code&gt; 可用于提供引用的位置：分配器（如果实现支持）将尝试分配新的内存块，使其尽可能接近 &lt;code&gt;hint&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4fd50aabe78c29ec16f5fd9d57b662c1d7d801a" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;nbytes&lt;/code&gt; bytes of storage at specified alignment &lt;code&gt;alignment&lt;/code&gt; using the underlying memory resource. Equivalent to &lt;code&gt;return resource()-&amp;gt;allocate(nbytes, alignment);&lt;/code&gt;</source>
          <target state="translated">使用基础内存资源以指定的对齐 &lt;code&gt;alignment&lt;/code&gt; 分配 &lt;code&gt;nbytes&lt;/code&gt; 字节的存储空间。等效于 &lt;code&gt;return resource()-&amp;gt;allocate(nbytes, alignment);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="575bf26e9df794dbd1383b334ef663788e920b7e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">分配未初始化存储的 &lt;code&gt;size&lt;/code&gt; 字节。</target>
        </trans-unit>
        <trans-unit id="deda37c663ffd540f8cba4cf2e2cde12e85c7e4b" translate="yes" xml:space="preserve">
          <source>Allocates and constructs an object</source>
          <target state="translated">分配和构造一个对象</target>
        </trans-unit>
        <trans-unit id="37d6f4ac7e329233b5c6cfd53ae16c6539bab6fd" translate="yes" xml:space="preserve">
          <source>Allocates and constructs an object of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">分配并构造类型为 &lt;code&gt;U&lt;/code&gt; 的对象。</target>
        </trans-unit>
        <trans-unit id="eec2cf410629d96a9a943a9c58f28ac54a41b535" translate="yes" xml:space="preserve">
          <source>Allocates memory for an array of &lt;code&gt;num&lt;/code&gt; objects of size &lt;code&gt;size&lt;/code&gt; and initializes it to all bits zero.</source>
          <target state="translated">用于阵列中分配内存 &lt;code&gt;num&lt;/code&gt; 尺寸的对象 &lt;code&gt;size&lt;/code&gt; 和初始化它的所有位零。</target>
        </trans-unit>
        <trans-unit id="9d033c92aaed0cd6d702cbb7cedf1b4eeff6647d" translate="yes" xml:space="preserve">
          <source>Allocates raw memory suitable for an object or an array</source>
          <target state="translated">分配适合对象或数组的原始内存。</target>
        </trans-unit>
        <trans-unit id="cf91bb95384027fe5328e00c00aaeaa013321358" translate="yes" xml:space="preserve">
          <source>Allocates requested number of bytes. These allocation functions are called by &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate memory in which new object would then be initialized. They may also be called using regular function call syntax.</source>
          <target state="translated">分配请求的字节数。这些分配函数由&lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt;调用，以分配随后将在其中初始化新对象的内存。也可以使用常规函数调用语法来调用它们。</target>
        </trans-unit>
        <trans-unit id="d2fc2b0dfd842a7e3a00d1f42dd3c72c9a40aeb4" translate="yes" xml:space="preserve">
          <source>Allocates storage for &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt; using the underlying memory resource. Equivalent to &lt;code&gt;return static_cast&amp;lt;T*&amp;gt;(resource()-&amp;gt;allocate(n * sizeof(T), alignof(T)));&lt;/code&gt;.</source>
          <target state="translated">使用基础内存资源为 &lt;code&gt;T&lt;/code&gt; 类型的 &lt;code&gt;n&lt;/code&gt; 个对象分配存储。等效于 &lt;code&gt;return static_cast&amp;lt;T*&amp;gt;(resource()-&amp;gt;allocate(n * sizeof(T), alignof(T)));&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef1e5d4c9fecdb8c77f2367b414e8a2ebe079e5f" translate="yes" xml:space="preserve">
          <source>Allocates storage for &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;U&lt;/code&gt; using the underlying memory resource.</source>
          <target state="translated">使用基础内存资源为 &lt;code&gt;U&lt;/code&gt; 类型的 &lt;code&gt;n&lt;/code&gt; 个对象分配存储。</target>
        </trans-unit>
        <trans-unit id="c8d51dfb7cc15d733b905081816cec434af6b924" translate="yes" xml:space="preserve">
          <source>Allocates storage with a size of at least &lt;code&gt;bytes&lt;/code&gt; bytes, aligned to the specified &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">分配大小至少为 &lt;code&gt;bytes&lt;/code&gt; 个字节的存储，并与指定的 &lt;code&gt;alignment&lt;/code&gt; 对齐。</target>
        </trans-unit>
        <trans-unit id="1719b83d89f242ab75b869949fb55eef6c5d0e25" translate="yes" xml:space="preserve">
          <source>Allocates storage with a size of at least &lt;code&gt;bytes&lt;/code&gt; bytes. The returned storage is aligned to the specified &lt;code&gt;alignment&lt;/code&gt; if such alignment is supported, and to &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; otherwise.</source>
          <target state="translated">分配存储空间，其大小至少为 &lt;code&gt;bytes&lt;/code&gt; 个字节。如果支持这种对齐 &lt;code&gt;alignment&lt;/code&gt; 则将返回的存储对齐到指定的对齐方式，否则将对齐 &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5fa0c7f2ed7e5ab17575514af95c1b4726f6491b" translate="yes" xml:space="preserve">
          <source>Allocates storage.</source>
          <target state="translated">分配存储。</target>
        </trans-unit>
        <trans-unit id="a4cd37a2b2f79389364650460bd02f87e623f6b0" translate="yes" xml:space="preserve">
          <source>Allocates uninitialized contiguous storage, which should be sufficient to store up to &lt;code&gt;count&lt;/code&gt; adjacent objects of type &lt;code&gt;T&lt;/code&gt;. The request is non-binding and the implementation may allocate less or more than necessary to store &lt;code&gt;count&lt;/code&gt; adjacent objects.</source>
          <target state="translated">分配未初始化的连续存储，这应该足以存储最多 &lt;code&gt;count&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; 的相邻对象。该请求是非绑定的，并且实现可能分配比存储 &lt;code&gt;count&lt;/code&gt; 相邻对象所需的少或多的分配。</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="7e5a93aa2050aa67c4b2a8fa0227ec2d570a5f78" translate="yes" xml:space="preserve">
          <source>Allocation functions</source>
          <target state="translated">分配职能</target>
        </trans-unit>
        <trans-unit id="bcdc03b4788456846d38f2b2c7a10637d4ba865e" translate="yes" xml:space="preserve">
          <source>Allocations requests that exceed the largest block size are served from the</source>
          <target state="translated">超过最大区块大小的分配请求将从</target>
        </trans-unit>
        <trans-unit id="cbf9e75065cafb419b19fb5a13dddefb2735eaa6" translate="yes" xml:space="preserve">
          <source>Allocator</source>
          <target state="translated">Allocator</target>
        </trans-unit>
        <trans-unit id="c26087d42681b7f6e496369e9c820f3e757778ab" translate="yes" xml:space="preserve">
          <source>Allocator completeness requirements</source>
          <target state="translated">分配器完整性要求</target>
        </trans-unit>
        <trans-unit id="006db541d4a947093a399166c59d14c227c66a14" translate="yes" xml:space="preserve">
          <source>Allocator for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 分配器</target>
        </trans-unit>
        <trans-unit id="a14116cd7defc5cfe1008ae088831e83125981b1" translate="yes" xml:space="preserve">
          <source>Allocator of a type convertible to &lt;code&gt;A&lt;/code&gt;</source>
          <target state="translated">可转换为 &lt;code&gt;A&lt;/code&gt; 的类型的分配器</target>
        </trans-unit>
        <trans-unit id="71d3d89dd86b8060b5c2c3dff2ad831f3f7d33f4" translate="yes" xml:space="preserve">
          <source>Allocator type</source>
          <target state="translated">分配器类型</target>
        </trans-unit>
        <trans-unit id="c5e06a85490c85e6350aa5bd28390e1ead65f231" translate="yes" xml:space="preserve">
          <source>Allocator-aware containers always call &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::construct(m, p, args)&lt;/code&gt; to construct an object of type &lt;code&gt;A&lt;/code&gt; at &lt;code&gt;p&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt;, with &lt;code&gt;m == get_allocator()&lt;/code&gt;. The default &lt;code&gt;construct&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;::new((void*)p) T(args)&lt;/code&gt;, but specialized allocators may choose a different definition.</source>
          <target state="translated">分配器感知容器随时调用 &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::construct(m, p, args)&lt;/code&gt; 来构造类型的对象 &lt;code&gt;A&lt;/code&gt; 在 &lt;code&gt;p&lt;/code&gt; 使用 &lt;code&gt;args&lt;/code&gt; ，与 &lt;code&gt;m == get_allocator()&lt;/code&gt; 。默认的 &lt;code&gt;construct&lt;/code&gt; 中 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 电话 &lt;code&gt;::new((void*)p) T(args)&lt;/code&gt; ，但专业分配器可以选择不同的定义。</target>
        </trans-unit>
        <trans-unit id="34acd9339509e4e1e31704ab4c073ecbdafd1f25" translate="yes" xml:space="preserve">
          <source>AllocatorAwareContainer</source>
          <target state="translated">AllocatorAwareContainer</target>
        </trans-unit>
        <trans-unit id="5ceb7c7c9f3657e9513254564292abfe012cfefb" translate="yes" xml:space="preserve">
          <source>Allocators</source>
          <target state="translated">Allocators</target>
        </trans-unit>
        <trans-unit id="629f37bb798c36a67317aa9ec0378bd852ec9f11" translate="yes" xml:space="preserve">
          <source>Allocators are class templates encapsulating memory allocation strategy. This allows generic containers to decouple memory management from the data itself.</source>
          <target state="translated">Allocators是封装内存分配策略的类模板。这使得通用容器可以将内存管理与数据本身解耦。</target>
        </trans-unit>
        <trans-unit id="095c1a8ff16049f04c3471ba9a37d8292cb9648d" translate="yes" xml:space="preserve">
          <source>Allow constant evaluation for all &lt;a href=&quot;language/template_parameters#Template_non-type_arguments&quot;&gt;non-type template arguments&lt;/a&gt;</source>
          <target state="translated">允许对所有&lt;a href=&quot;language/template_parameters#Template_non-type_arguments&quot;&gt;非类型模板参数&lt;/a&gt;进行常量求值</target>
        </trans-unit>
        <trans-unit id="8672315bab526e017a0da6b4db8394d5643bd21c" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize for the case where paths of execution including that statement are more or less likely than any alternative path of execution that does not include such a statement.</source>
          <target state="translated">允许编译器针对包含该语句的执行路径比不包含该语句的任何其他执行路径更有可能或更不可能的情况进行优化。</target>
        </trans-unit>
        <trans-unit id="03388373add47a2fa22bbeb6dede9123b781ba3f" translate="yes" xml:space="preserve">
          <source>Allows a function to accept any number of arguments.</source>
          <target state="translated">允许函数接受任意数量的参数。</target>
        </trans-unit>
        <trans-unit id="411787b050d38051721728f3a87d5174918b5c69" translate="yes" xml:space="preserve">
          <source>Allows a function to be called without providing one or more trailing arguments.</source>
          <target state="translated">允许在调用函数时不提供一个或多个尾部参数。</target>
        </trans-unit>
        <trans-unit id="459d9517d5603efba94121b4d2acec3f8491a657" translate="yes" xml:space="preserve">
          <source>Allows any and all code transformations that do not change the observable behavior of the program.</source>
          <target state="translated">允许任何和所有不改变程序可观察行为的代码转换。</target>
        </trans-unit>
        <trans-unit id="f7fd47c92a72794dea3d8bd7149aab52470581d7" translate="yes" xml:space="preserve">
          <source>Allows customizing class and variable(since C++14) templates for a given category of template arguments.</source>
          <target state="translated">允许自定义给定类别的模板参数的类和变量(自C++14起)模板。</target>
        </trans-unit>
        <trans-unit id="36e28bc484be80710ded433fdd6ceb2b32b730fd" translate="yes" xml:space="preserve">
          <source>Allows customizing the template code for a given set of template arguments.</source>
          <target state="translated">允许为给定的模板参数集定制模板代码。</target>
        </trans-unit>
        <trans-unit id="a8bf676764b0183a61de1aa7f44f4c55b945bd3c" translate="yes" xml:space="preserve">
          <source>Allows insertion and extraction of quoted strings, such as the ones found in CSV or XML.</source>
          <target state="translated">允许插入和提取引号字符串,如CSV或XML中的字符串。</target>
        </trans-unit>
        <trans-unit id="1433f306e640197740511f48680f25d7413dc2e9" translate="yes" xml:space="preserve">
          <source>Allows integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix.</source>
          <target state="translated">通过定义一个用户定义的后缀,允许整数、浮点、字符和字符串读写器产生用户定义类型的对象。</target>
        </trans-unit>
        <trans-unit id="714a3428d46162788e491e8dc3208e88274f1f2f" translate="yes" xml:space="preserve">
          <source>Allows the size of an empty base subobject to be zero.</source>
          <target state="translated">允许空基础子对象的大小为零。</target>
        </trans-unit>
        <trans-unit id="ccb54e9be1a4c6bc9837fefd7cc02f1997a12f3c" translate="yes" xml:space="preserve">
          <source>Allows values of integer type to be used in expressions directly.</source>
          <target state="translated">允许在表达式中直接使用整数类型的值。</target>
        </trans-unit>
        <trans-unit id="9a0c4d0005f924626f07462db95d58f6067b54a8" translate="yes" xml:space="preserve">
          <source>Also because braced-init-list has no type, &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;special rules for overload resolution&lt;/a&gt; apply when it is used as an argument to an overloaded function call.</source>
          <target state="translated">同样，因为braced-init-list没有类型，所以当将&lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;重载&lt;/a&gt;初始化列表用作重载函数调用的参数时，将应用特殊的规则来解决重载。</target>
        </trans-unit>
        <trans-unit id="3b587e48dc1be81684dc5d496c6af85f6a461578" translate="yes" xml:space="preserve">
          <source>Also provided are the C-style date and time functions, such as &lt;code&gt;&lt;a href=&quot;chrono/c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/c/difftime&quot;&gt;std::difftime&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;chrono/c/clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">还提供了C风格的日期和时间函数，例如 &lt;code&gt;&lt;a href=&quot;chrono/c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;chrono/c/difftime&quot;&gt;std::difftime&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;chrono/c/clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="729da59cb6e707c89f461faec986a483c428299a" translate="yes" xml:space="preserve">
          <source>Also, all &lt;a href=&quot;language/name&quot;&gt;identifiers&lt;/a&gt; that contain a double underscore __ in any position and each identifier that begins with an underscore followed by an uppercase letter is always reserved and all identifiers that begin with an underscore are reserved for use as names in the global namespace. See &lt;a href=&quot;language/name&quot;&gt;identifiers&lt;/a&gt; for more details.</source>
          <target state="translated">此外，所有&lt;a href=&quot;language/name&quot;&gt;标识符&lt;/a&gt;包含在任意位置的双下划线__以下划线开始，每一个以下划线后跟一个大写字母总是留给开始标识符和所有标识符被保留用作全局命名空间的名称。有关更多详细信息，请参见&lt;a href=&quot;language/name&quot;&gt;标识符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8790a9cbd433decb4fdf7491221b8bbc56822f99" translate="yes" xml:space="preserve">
          <source>Also, on some platforms, bit fields are packed left-to-right, on others right-to-left</source>
          <target state="translated">另外,在一些平台上,位字段从左到右打包,在另一些平台上从右到左打包。</target>
        </trans-unit>
        <trans-unit id="5b07b0bdeb35442e306edb6a6d7347901e47e660" translate="yes" xml:space="preserve">
          <source>Also, the standard library functions called with xvalue arguments may assume the argument is the only reference to the object; if it was constructed from an lvalue with &lt;code&gt;std::move&lt;/code&gt;, no aliasing checks are made. In particular, this means that standard library move assignment operators do not have to perform self-assignment checks:</source>
          <target state="translated">同样，用xvalue参数调用的标准库函数可能会假定该参数是对该对象的唯一引用。如果它是由带有 &lt;code&gt;std::move&lt;/code&gt; 的左值构造的，则不进行任何别名检查。特别是，这意味着标准库移动分配操作员不必执行自我分配检查：</target>
        </trans-unit>
        <trans-unit id="9465911da185e318d4f902c965db53e7bdd827fb" translate="yes" xml:space="preserve">
          <source>Also, unlike the formatted output functions, this function does not set the &lt;code&gt;failbit&lt;/code&gt; on failure.</source>
          <target state="translated">此外，不同于格式化输出函数，此函数不设置 &lt;code&gt;failbit&lt;/code&gt; 失败。</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="2e4d959d6a71905b14d43661b5387037b9b586bd" translate="yes" xml:space="preserve">
          <source>Alternative operator representations</source>
          <target state="translated">备用运算符表示法</target>
        </trans-unit>
        <trans-unit id="c8b93e0cfffeb74171554b62200f1f073639dd68" translate="yes" xml:space="preserve">
          <source>Alternative operator syntax</source>
          <target state="translated">其他运算符语法</target>
        </trans-unit>
        <trans-unit id="e32467443dfa96c0777ac9526ba4d4884bea25fb" translate="yes" xml:space="preserve">
          <source>Alternative tokens</source>
          <target state="translated">替代代币</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="f33a42489881f94fe215353e72be54816924c644" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;&lt;/code&gt; may sometimes be used to detect stack unwinding in progress, it is generally considered bad practice to allow any destructor to terminate by throwing an exception. This functionality is nevertheless used by some libraries, such as &lt;a href=&quot;https://github.com/SOCI/soci&quot;&gt;SOCI&lt;/a&gt; and &lt;a href=&quot;http://galeracluster.com/downloads/&quot;&gt;Galera 3&lt;/a&gt;, which rely on the ability of the destructors of nameless temporaries to throw exceptions at the end of the full expression that constructs the temporary.</source>
          <target state="translated">尽管有时可以使用 &lt;code&gt;&lt;a href=&quot;../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;&lt;/code&gt; 来检测进行中的堆栈展开，但通常认为将任何析构函数通过引发异常终止的做法视为错误做法。但是，某些库（例如&lt;a href=&quot;https://github.com/SOCI/soci&quot;&gt;SOCI&lt;/a&gt;和&lt;a href=&quot;http://galeracluster.com/downloads/&quot;&gt;Galera 3&lt;/a&gt;）仍使用此功能，它们依赖无名临时表的析构函数的能力在构造临时表的完整表达式的末尾抛出异常。</target>
        </trans-unit>
        <trans-unit id="ea2b684e4b095592200988c7ab99debb5b70a888" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::pow&lt;/code&gt; cannot be used to obtain a root of a negative number, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;std::cbrt&lt;/a&gt;&lt;/code&gt; is provided for the common case where &lt;code&gt;exp&lt;/code&gt; is 1/3.</source>
          <target state="translated">尽管无法使用 &lt;code&gt;std::pow&lt;/code&gt; 获得负数的根，但是对于 &lt;code&gt;exp&lt;/code&gt; 为1/3 的常见情况，提供了 &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;std::cbrt&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0bbe9c54239a7325e443792536d8b4342054835" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::scalbn&lt;/code&gt; and &lt;code&gt;std::scalbln&lt;/code&gt; are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="translated">尽管 &lt;code&gt;std::scalbn&lt;/code&gt; 和 &lt;code&gt;std::scalbln&lt;/code&gt; 被指定为有效地执行操作，但在许多实现上，它们的效率不如使用算术运算符乘或除以2的幂。</target>
        </trans-unit>
        <trans-unit id="3d1825778acdae18596af041fff74b7b10c86289" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; with the default deleter may be constructed with &lt;a href=&quot;../../language/incomplete_type&quot;&gt;incomplete type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;, the type &lt;code&gt;T&lt;/code&gt; must be complete at the point of code where the destructor is called.</source>
          <target state="translated">尽管带有默认删除器的 &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 可能使用&lt;a href=&quot;../../language/incomplete_type&quot;&gt;不完整的类型&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 构造，但类型 &lt;code&gt;T&lt;/code&gt; 必须在调用析构函数的代码点处是完整的。</target>
        </trans-unit>
        <trans-unit id="439c84aa6d4f184555f03b26b3fb02df31f3c81c" translate="yes" xml:space="preserve">
          <source>Although a function call can be resolved through ADL even if ordinary lookup finds nothing, a function call to a &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; with explicitly-specified template arguments requires that there is a declaration of the template found by ordinary lookup (otherwise, it is a syntax error to encounter an unknown name followed by a less-than character).</source>
          <target state="translated">尽管即使普通查找没有发现任何函数调用也可以通过ADL进行解析，但是使用显式指定的模板参数对&lt;a href=&quot;function_template&quot;&gt;函数模板&lt;/a&gt;进行函数调用需要声明通过普通查找找到的模板（否则，这是语法错误遇到一个不知名的名称，后跟一个小于号）。</target>
        </trans-unit>
        <trans-unit id="f1ebb0e824901f4ec3f02ea57f64d9e4828306f2" translate="yes" xml:space="preserve">
          <source>Although a zero-initialized &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; always represents the initial conversion state, there may be other values of &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; that also represent the initial conversion state.</source>
          <target state="translated">尽管零初始化的 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 始终代表初始转换状态，但可能还有其他 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 值也代表初始转换状态。</target>
        </trans-unit>
        <trans-unit id="f708528328b72807fc0654354970ef41ee70cd4b" translate="yes" xml:space="preserve">
          <source>Although arrays cannot be returned from functions by value and cannot be targets of most cast expressions, array &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt; may be formed by using a type alias to construct an array temporary using &lt;a href=&quot;explicit_cast&quot;&gt;brace-initialized functional cast&lt;/a&gt;.</source>
          <target state="translated">尽管不能从函数中按值返回数组，并且不能将其作为大多数&lt;a href=&quot;value_category&quot;&gt;强制转换&lt;/a&gt;表达式的目标，但是可以通过使用类型别名使用花&lt;a href=&quot;explicit_cast&quot;&gt;括号初始化的函数&lt;/a&gt;强制转换来构造数组临时值，从而形成数组prvalue。</target>
        </trans-unit>
        <trans-unit id="1fd9b3c6d07c5655b399e6be4424fee0edae9357" translate="yes" xml:space="preserve">
          <source>Although canonical form of pre-increment/pre-decrement returns a reference, as with any operator overload, the return type is user-defined; for example the overloads of these operators for &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; return by value.</source>
          <target state="translated">尽管规范形式的预增/预减返回一个引用，但与任何运算符重载一样，返回类型是用户定义的；例如，按值返回 &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 的这些运算符的重载。</target>
        </trans-unit>
        <trans-unit id="2de2491baa0eb4945c698a40f7cf02c5b5ff7ca9" translate="yes" xml:space="preserve">
          <source>Although decl-specifier-seq implies there can exist &lt;a href=&quot;declarations#Specifiers&quot;&gt;specifiers&lt;/a&gt; other than type specifiers, the only other specifier allowed is &lt;code&gt;register&lt;/code&gt;as well as &lt;code&gt;auto&lt;/code&gt;(until C++11), and it has no effect.</source>
          <target state="translated">尽管decl-specifier-seq暗示除了类型说明&lt;a href=&quot;declarations#Specifiers&quot;&gt;符&lt;/a&gt;之外还可以存在其他说明符，但允许的唯一其他说明符是 &lt;code&gt;register&lt;/code&gt; 和 &lt;code&gt;auto&lt;/code&gt; （直到C ++ 11），并且没有任何作用。</target>
        </trans-unit>
        <trans-unit id="14b7b14235553f3b91083c0b71081ba75f07e98f" translate="yes" xml:space="preserve">
          <source>Although no class is its own base, &lt;code&gt;std::is_base_of&amp;lt;T, T&amp;gt;::value&lt;/code&gt; is true because the intent of the trait is to model the &quot;is-a&quot; relationship, and T is a T. Despite that, &lt;code&gt;std::is_base_of&amp;lt;int, int&amp;gt;::value&lt;/code&gt; is false because only classes participate in the relationship that this trait models.</source>
          <target state="translated">尽管没有类是其自身的基础，但 &lt;code&gt;std::is_base_of&amp;lt;T, T&amp;gt;::value&lt;/code&gt; 为true，因为特征的目的是为&amp;ldquo; is-a&amp;rdquo;关系建模，而T为T。尽管如此， &lt;code&gt;std::is_base_of&amp;lt;int, int&amp;gt;::value&lt;/code&gt; 为false，因为只有类才参与此特征模型的关系。</target>
        </trans-unit>
        <trans-unit id="119fa9e7db8c27df8ae932b0248b04e4bfefb226" translate="yes" xml:space="preserve">
          <source>Although not defined, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt; POSIX time&lt;/a&gt;.</source>
          <target state="translated">尽管未定义，但几乎始终是一个整数值，该值包含自1970年1月1日UTC的00:00开始的秒数（不计算leap秒），对应于&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;POSIX time&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac8975eb41b5df62d74c9b6ae1a1689383a4d797" translate="yes" xml:space="preserve">
          <source>Although references, once initialized, always refer to valid objects or functions, it is possible to create a program where the &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of the referred-to object ends, but the reference remains accessible (</source>
          <target state="translated">尽管引用一经初始化，便始终引用有效的对象或函数，但可以创建一个程序，在该程序中，引用对象的&lt;a href=&quot;lifetime&quot;&gt;生命周期&lt;/a&gt;结束，但是引用仍可访问（</target>
        </trans-unit>
        <trans-unit id="6c367e67cfae5a3c20e167ab56108c7704f6c4ad" translate="yes" xml:space="preserve">
          <source>Although synchronized blocks execute as-if under a global lock, the implementations are expected to examine the code within each block and use optimistic concurrency (backed up by hardware transactional memory where available) for transaction-safe code and minimal locking for non-transaction safe code. When a synchronized block makes a call to a non-inlined function, the compiler may have to drop out of speculative execution and hold a lock around the entire call unless the function is declared &lt;code&gt;transaction_safe&lt;/code&gt; (see below) or the attribute &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; (see below) is used.</source>
          <target state="translated">尽管同步块在全局锁下按条件执行，但仍希望实现检查每个块内的代码，并使用乐观并发（由可用的硬件事务存储器备份）获得事务安全代码，并为非事务安全使用最小限度的锁定码。当同步块对非内联函数进行调用时，编译器可能必须退出推测性执行，并在整个调用周围保持锁定，除非将该函数声明为 &lt;code&gt;transaction_safe&lt;/code&gt; （请参见下文）或属性 &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; （请参见下文）。</target>
        </trans-unit>
        <trans-unit id="dad5173c2001f38e75509fd69dc64ba3e87866b3" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic cosine&quot; (used by POSIX) or &quot;area hyperbolic cosine&quot;.</source>
          <target state="translated">虽然C标准(C++对这个函数的引用)将这个函数命名为 &quot;弧形双曲余弦&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形的面积。正确的名称是 &quot;反双曲余弦&quot;(POSIX使用)或 &quot;面积双曲余弦&quot;。</target>
        </trans-unit>
        <trans-unit id="a1733c8cc2a0d050132b6b9364d6944323c32b74" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic sine&quot; (used by POSIX) or &quot;area hyperbolic sine&quot;.</source>
          <target state="translated">虽然C标准(C++对这个函数的引用)将这个函数命名为 &quot;弧形双曲正弦&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形的面积。正确的名称是 &quot;反双曲正弦&quot;(POSIX使用)或 &quot;面积双曲正弦&quot;。</target>
        </trans-unit>
        <trans-unit id="4277fd8c5f429dde16accb19c538a3e9d0e882ce" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic tangent&quot; (used by POSIX) or &quot;area hyperbolic tangent&quot;.</source>
          <target state="translated">虽然C标准(C++对这个函数的引用)将这个函数命名为 &quot;弧双曲正切&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形。正确的名称是 &quot;反双曲正切&quot;(POSIX使用)或 &quot;面积双曲正切&quot;。</target>
        </trans-unit>
        <trans-unit id="91479e7f0ee3ff1337daf6434e5f71cdfdc3c6a6" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic cosine&quot;, and, less common, &quot;complex area hyperbolic cosine&quot;.</source>
          <target state="translated">虽然C++标准将这个函数命名为 &quot;复圆弧双曲余弦&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形的面积。正确的名称是 &quot;复反双曲余弦&quot;,不常用的是 &quot;复面积双曲余弦&quot;。</target>
        </trans-unit>
        <trans-unit id="6a7e68fe75439346aeaad1f6906c84e17daadb3b" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic sine&quot;, and, less common, &quot;complex area hyperbolic sine&quot;.</source>
          <target state="translated">虽然C++标准将这个函数命名为 &quot;复圆弧双曲正弦&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形的面积。正确的名称是 &quot;复反双曲正弦&quot;,不常用的是 &quot;复面积双曲正弦&quot;。</target>
        </trans-unit>
        <trans-unit id="8d2c788effcf0da46c782a95d9a9fd3b66474139" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic tangent&quot;, and, less common, &quot;complex area hyperbolic tangent&quot;.</source>
          <target state="translated">虽然C++标准将这个函数命名为 &quot;复圆弧双曲正切&quot;,但双曲函数的反函数是面积函数。它们的参数是双曲扇形的面积,而不是弧形的面积。正确的名称是 &quot;复反双曲正切&quot;,不常用的是 &quot;复面积双曲正切&quot;。</target>
        </trans-unit>
        <trans-unit id="fd70e10e04c4727c7eb398861b7b422e51e53f42" translate="yes" xml:space="preserve">
          <source>Although the C++11 standard still says &quot;On most machines, this is true for signed integers.&quot;, it is a defect and has been corrected. The exact wording changed from C++03 to C++11 in such a way that the &lt;code&gt;true&lt;/code&gt; value is no longer compatible with &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;undefined behavior on signed integer overflow&lt;/a&gt;. Because of that, the implementations that rely on signed overflow being undefined (for optimization opportunities) now set &lt;code&gt;is_modulo&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for signed integers. See for example &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt;.</source>
          <target state="translated">尽管C ++ 11标准仍然说&amp;ldquo;在大多数计算机上，这对于带符号整数是正确的。&amp;rdquo;，但这是一个缺陷，并且已得到纠正。确切的措辞从C ++ 03更改为C ++ 11，以使 &lt;code&gt;true&lt;/code&gt; 值不再与有&lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;符号整数溢出时的未定义行为&lt;/a&gt;兼容。因此，依赖于未定义的有符号溢出的实现（用于优化机会）现在将有符号整数的 &lt;code&gt;is_modulo&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 。参见例如&lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73c3fb8cae35d1afdb844e48a3d68c51dd534493" translate="yes" xml:space="preserve">
          <source>Although the C++11 standard still says &quot;On most machines, this is true for signed integers.&quot;, it is a defect and has been corrected. The exact wording changed from C++03 to C++11 in such a way that the &lt;code&gt;true&lt;/code&gt; value is no longer compatible with &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;undefined behavior on signed integer overflow&lt;/a&gt;. Because of that, the implementations that rely on signed overflow being undefined (for optimization opportunities) now set &lt;code&gt;is_modulo&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for signed integers. See for example &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661de5137e7e9dcc1cb0c7e5d23a45a40d059e70" translate="yes" xml:space="preserve">
          <source>Although the definition uses &lt;code&gt;-1&lt;/code&gt;, &lt;a href=&quot;../basic_string&quot;&gt;&lt;code&gt;size_type&lt;/code&gt;&lt;/a&gt; is an unsigned integer type, and the value of &lt;code&gt;npos&lt;/code&gt; is the largest positive value it can hold, due to &lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;signed-to-unsigned implicit conversion&lt;/a&gt;. This is a portable way to specify the largest value of any unsigned type.</source>
          <target state="translated">尽管定义使用 &lt;code&gt;-1&lt;/code&gt; ，但&lt;a href=&quot;../basic_string&quot;&gt; &lt;code&gt;size_type&lt;/code&gt; &lt;/a&gt;是无符号整数类型，由于有&lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;符号到无符号的隐式转换&lt;/a&gt;， &lt;code&gt;npos&lt;/code&gt; 的值是它可以容纳的最大正值。这是一种可移植的方法，可以指定任何无符号类型的最大值。</target>
        </trans-unit>
        <trans-unit id="1abd2f0bb23531226358684e90cc6818e8f8598e" translate="yes" xml:space="preserve">
          <source>Although the expression &lt;code&gt;++c.begin()&lt;/code&gt; often compiles, it is not guaranteed to do so: &lt;code&gt;c.begin()&lt;/code&gt; is an rvalue expression, and there is no &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; requirement that specifies that increment of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers, &lt;code&gt;++c.begin()&lt;/code&gt; does not compile, while &lt;code&gt;std::next(c.begin())&lt;/code&gt; does.</source>
          <target state="translated">尽管 &lt;code&gt;++c.begin()&lt;/code&gt; 表达式经常会编译，但不能保证这样做： &lt;code&gt;c.begin()&lt;/code&gt; 是一个右值表达式，并且没有&lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;要求可以确保保证右值的增量能正常工作。特别是，当迭代器实现为指针时， &lt;code&gt;++c.begin()&lt;/code&gt; 不会编译，而 &lt;code&gt;std::next(c.begin())&lt;/code&gt; 会编译。</target>
        </trans-unit>
        <trans-unit id="55ffdbc2010bd6fba5315668a01fc1d2cb4bf01d" translate="yes" xml:space="preserve">
          <source>Although the expression &lt;code&gt;--c.end()&lt;/code&gt; often compiles, it is not guaranteed to do so: &lt;code&gt;c.end()&lt;/code&gt; is an rvalue expression, and there is no iterator requirement that specifies that decrement of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers, &lt;code&gt;--c.end()&lt;/code&gt; does not compile, while &lt;code&gt;std::prev(c.end())&lt;/code&gt; does.</source>
          <target state="translated">尽管表达式 &lt;code&gt;--c.end()&lt;/code&gt; 通常会编译，但不能保证这样做： &lt;code&gt;c.end()&lt;/code&gt; 是一个右值表达式，并且没有迭代器要求指定保证右值的递减可以正常工作。特别是，当迭代器实现为指针时，-- &lt;code&gt;--c.end()&lt;/code&gt; 不会编译，而 &lt;code&gt;std::prev(c.end())&lt;/code&gt; 会编译。</target>
        </trans-unit>
        <trans-unit id="562d3af0d04be2de0b30b637809f27a622e04faf" translate="yes" xml:space="preserve">
          <source>Although the header &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; is based on the C standard library header &lt;code&gt;errno.h&lt;/code&gt;, the majority of the macros defined by &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; were adopted by C++ from the POSIX standard, rather than the C standard library.</source>
          <target state="translated">尽管标头 &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; 基于C标准库标头 &lt;code&gt;errno.h&lt;/code&gt; ，但 &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; 定义的大多数宏都是POSIX标准的C ++所采用的，而不是C标准库。</target>
        </trans-unit>
        <trans-unit id="3db5014665fd46dd8e252214316aa47507ad7ef2" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;std::tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;std::tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="translated">尽管很难猜出 &lt;code&gt;std::tmpnam&lt;/code&gt; 生成的名称，但是在 &lt;code&gt;std::tmpnam&lt;/code&gt; 返回到程序尝试使用返回的名称来创建一个名称之间，可能有另一个进程创建了具有该名称的文件。文件。标准函数 &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; 和POSIX函数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt;不存在此问题（仅使用标准C库创建唯一目录仍需要使用 &lt;code&gt;tmpnam&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9d5994bfdfeb1041b6398f05b2f8f3e33b52a975" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;std::tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;std::tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f3db27755b0d585a653f2d5f3657aa1f21c81b" translate="yes" xml:space="preserve">
          <source>Although the results of comparing pointers of random origin (e.g. not all pointing to members of the same array) is unspecified, many implementations provide &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total ordering&lt;/a&gt; of pointers, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管未指定比较随机来源的指针（例如，并非所有指针均指向同一数组的成员）的结果，但是许多实现都提供了&lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;严格&lt;/a&gt;的指针总顺序，例如，如果它们被实现为连续虚拟地址空间内的地址。不需要的那些实现（例如，并非指针的所有位都是存储器地址的一部分，必须将其忽略以进行比较，或者需要额外的计算，否则指针和整数不是一对一的关系）。 &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; 专业化，用于具有该保证的指针。这样就可以将随机起源的所有指针用作标准关联容器（例如 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8a747e33a10c6fa21c941b73f1438fc704b6283" translate="yes" xml:space="preserve">
          <source>Although the return type is &lt;code&gt;char*&lt;/code&gt;, modifying the pointed-to characters is undefined behavior.</source>
          <target state="translated">尽管返回类型为 &lt;code&gt;char*&lt;/code&gt; ，但修改指向的字符是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="1a131648c16bdab1f4ad67b397e73af609dc5ab0" translate="yes" xml:space="preserve">
          <source>Although the return type is not allowed in the declaration of a user-defined conversion function, the decl-specifier-seq of &lt;a href=&quot;declarations#Specifiers&quot;&gt;the declaration grammar&lt;/a&gt; may be present and may include any specifier other than type-specifier or the keyword static, In particular, besides &lt;code&gt;explicit&lt;/code&gt;, the specifiers &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt;, &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;, and &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; are also allowed (note that &lt;code&gt;friend&lt;/code&gt; requires a qualified name: &lt;code&gt;friend A::operator B();&lt;/code&gt;).</source>
          <target state="translated">尽管在用户定义的转换函数的声明中不允许使用返回类型，&lt;a href=&quot;declarations#Specifiers&quot;&gt;但是声明语法&lt;/a&gt;的decl-specifier-seq 可能存在，并且可以包括除type-specifier或关键字static外的任何指定符，尤其是 &lt;code&gt;explicit&lt;/code&gt; ，也允许使用&lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;，&lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt;，&lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;和&lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;等说明 &lt;code&gt;friend A::operator B();&lt;/code&gt; （请注意， &lt;code&gt;friend&lt;/code&gt; 需要使用限定名称：friend A :: operator B（）;）。</target>
        </trans-unit>
        <trans-unit id="d77898594331af7d94d8805113c2ae7cc96df8a5" translate="yes" xml:space="preserve">
          <source>Although the standard requires that this facet works with UCS2 when the size of &lt;code&gt;Elem&lt;/code&gt; is 16 bits, some implementations use UTF-16 instead, making this a non-converting locale. The term &quot;UCS2&quot; was deprecated and removed from the Unicode standard.</source>
          <target state="translated">尽管标准要求当 &lt;code&gt;Elem&lt;/code&gt; 的大小为16位时，此构面可与UCS2配合使用，但某些实现使用UTF-16代替，从而使其成为非转换语言环境。术语&amp;ldquo; UCS2&amp;rdquo;已弃用，并从Unicode标准中删除。</target>
        </trans-unit>
        <trans-unit id="3eafdced96881df5338499ac356a8e8f50b8bc53" translate="yes" xml:space="preserve">
          <source>Although the standard requires that this facet works with UCS2 when the size of &lt;code&gt;Elem&lt;/code&gt; is 16 bits, some implementations use UTF-16 instead. The term &quot;UCS2&quot; was deprecated and removed from the Unicode standard.</source>
          <target state="translated">尽管该标准要求当 &lt;code&gt;Elem&lt;/code&gt; 的大小为16位时，此构面可以与UCS2一起使用，但是某些实现使用UTF-16代替。术语&amp;ldquo; UCS2&amp;rdquo;已弃用，并从Unicode标准中删除。</target>
        </trans-unit>
        <trans-unit id="a91bcce893b5de905ecbd22a99a03889cdcc2544" translate="yes" xml:space="preserve">
          <source>Always</source>
          <target state="translated">Always</target>
        </trans-unit>
        <trans-unit id="fe09758345685e241df672635cfac946bfc561d8" translate="yes" xml:space="preserve">
          <source>Always-throwing functions</source>
          <target state="translated">常投功能</target>
        </trans-unit>
        <trans-unit id="4df6b8083eb91bc6a923cb0c4bf5c1ae0e994985" translate="yes" xml:space="preserve">
          <source>Ambiguous and nonexistent local times can occur as a result of time zone transitions (such as daylight saving time). For example, &quot;2016-03-13 02:30:00&quot; does not exist in the &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; time zone, while &quot;2016-11-06 01:30:00&quot; in that time zone can correspond to two UTC time points: 2016-11-06 05:30:00 UTC and 2016-11-06 06:30:00 UTC.</source>
          <target state="translated">时区转换（例如夏时制）可能会导致当地时间不明确和不存在。例如，&amp;ldquo; &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; 时区中不存在&amp;ldquo; 2016-03-13 02:30:00&amp;rdquo; ，而该时区中的&amp;ldquo; 2016-11-06 01:30:00&amp;rdquo;可以对应于两个UTC时间点：世界标准时间2016-11-06 05:30:00和世界标准时间2016-11-06 06:30:00。</target>
        </trans-unit>
        <trans-unit id="c067979f83933e6c4d89a2c1e0fb562a0f280310" translate="yes" xml:space="preserve">
          <source>Ambiguous conversion sequences are ranked as user-defined conversion sequences because multiple conversion sequences for an argument can exist only if they involve different user-defined conversions:</source>
          <target state="translated">模糊的转换序列被列为用户定义的转换序列,因为只有当一个参数涉及不同的用户定义的转换时,才会存在多个转换序列。</target>
        </trans-unit>
        <trans-unit id="5aa47b263945205f7df82cf554dee097502b0d78" translate="yes" xml:space="preserve">
          <source>Amortized constant number of invocations of &lt;code&gt;g.operator()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;g.operator()&lt;/code&gt; 常数调用。</target>
        </trans-unit>
        <trans-unit id="128bb665ca4a35fff2ef43cce127f6f8f60033b5" translate="yes" xml:space="preserve">
          <source>Amortized constant number of invocations of &lt;code&gt;g&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 的摊销常数调​​用</target>
        </trans-unit>
        <trans-unit id="1cbb525f8d6525a8ab447903dfd14ddbdc0818e6" translate="yes" xml:space="preserve">
          <source>Amortized constant on average, worst case linear in the size of the container.</source>
          <target state="translated">平均摊销常数,最坏的情况下,集装箱的大小是线性的。</target>
        </trans-unit>
        <trans-unit id="50471dc8ecc10f0a607efbdd965811e70e031a13" translate="yes" xml:space="preserve">
          <source>Amortized constant.</source>
          <target state="translated">摊销常数。</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="45ea68905c72735578b243d8c992010c73dd2b71" translate="yes" xml:space="preserve">
          <source>An 8-bit binary type can represent any two-digit decimal number exactly, but 3-digit decimal numbers 256..999 cannot be represented. The value of &lt;code&gt;digits10&lt;/code&gt; for an 8-bit type is 2 (&lt;code&gt;8 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 2.41).</source>
          <target state="translated">8位二进制类型可以精确地表示任何两位十进制数字，但是不能表示3位十进制数字256..999。8位类型的 &lt;code&gt;digits10&lt;/code&gt; 的值为2（ &lt;code&gt;8 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; 为2.41）。</target>
        </trans-unit>
        <trans-unit id="b70a29f58335fff2ae0f72bb6d64b3b5da9003ef" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../language/type-id&quot;&gt;arithmetic type&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;../language/type-id&quot;&gt;算术类型&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="807382b205cd61b4e07e059d92477e9e7b450d4d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation&lt;/a&gt; or deallocation function for a class is odr-used by a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt; appearing in a potentially-evaluated expression</source>
          <target state="translated">类的&lt;a href=&quot;../memory/new/operator_new&quot;&gt;分配&lt;/a&gt;或释放函数由出现在潜在评估表达式中的&lt;a href=&quot;new&quot;&gt;新表达式&lt;/a&gt;所使用</target>
        </trans-unit>
        <trans-unit id="8d5b39fd5f28e44fd4cbe7c1a6e4527324fdb198" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;asm&quot;&gt;asm declaration&lt;/a&gt; does not define any entities, but it is classified as a definition.</source>
          <target state="translated">一个&lt;a href=&quot;asm&quot;&gt;asm声明&lt;/a&gt;没有定义任何实体，但它被归类为一个定义。</target>
        </trans-unit>
        <trans-unit id="d3db36c93422d5b474b182b8149fdd0c74f76e94" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; sequence attr may appear just before the label (in which case it applies to the label), or just before any statement itself, in which case it applies to the entire statement. A statement may carry multiple labels. Labels (and only labels) have &lt;a href=&quot;scope#Function_scope&quot;&gt;function scope&lt;/a&gt;. Labels are ignored by &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified lookup&lt;/a&gt;: a label can have the same name as any other entity in the program.</source>
          <target state="translated">一个&lt;a href=&quot;attributes&quot;&gt;属性&lt;/a&gt;序列ATTR可能出现只需将标签（在这种情况下，它适用于标签）之前，或只是任何语句本身，在这种情况下，它适用于整个语句之前。一条语句可以带有多个标签。标签（并且只有标签）具有&lt;a href=&quot;scope#Function_scope&quot;&gt;作用域&lt;/a&gt;。标签将被&lt;a href=&quot;unqualified_lookup&quot;&gt;不合格的查找&lt;/a&gt;忽略：标签可以与程序中的任何其他实体具有相同的名称。</target>
        </trans-unit>
        <trans-unit id="67d8f4f0c409d53bf6fc239c4572103225de8737" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;class_template#Class_template_instantiation&quot;&gt;explicit instantiation declaration&lt;/a&gt; (an &quot;extern template&quot;)</source>
          <target state="translated">一个&lt;a href=&quot;class_template#Class_template_instantiation&quot;&gt;显式实例声明&lt;/a&gt;（一个&amp;ldquo;外部模板&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="e8d07ab60f03237d43aaac774ff0a48905536383" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;declarations&quot;&gt;attribute declaration&lt;/a&gt; (does not define any entities)</source>
          <target state="translated">一个&lt;a href=&quot;declarations&quot;&gt;属性声明&lt;/a&gt;（没有定义任何实体）</target>
        </trans-unit>
        <trans-unit id="8250bcb5d0e5dcdf0fb994dd06a03c09d7251e75" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;declarations&quot;&gt;empty declaration&lt;/a&gt; (does not define any entities)</source>
          <target state="translated">一个&lt;a href=&quot;declarations&quot;&gt;空的声明&lt;/a&gt;（没有定义任何实体）</target>
        </trans-unit>
        <trans-unit id="1cae5b3ce33128b19eacc0658479be44746e7c43" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;enum&quot;&gt;opaque declaration&lt;/a&gt; of an enumeration</source>
          <target state="translated">枚举的&lt;a href=&quot;enum&quot;&gt;不透明声明&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97e3c29d16d88a0e096a7e69f7173bded9fa122e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; whose category and types are the same as &lt;code&gt;X::const_iterator&lt;/code&gt;</source>
          <target state="translated">一个&lt;a href=&quot;iterator&quot;&gt;LegacyIterator，&lt;/a&gt;其类别和类型与 &lt;code&gt;X::const_iterator&lt;/code&gt; 相同</target>
        </trans-unit>
        <trans-unit id="cf13631c6d364b349a268bbd81c204b7997b1947" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; whose category and types are the same as &lt;code&gt;X::iterator&lt;/code&gt;</source>
          <target state="translated">一个&lt;a href=&quot;iterator&quot;&gt;LegacyIterator，&lt;/a&gt;其类别和类型与 &lt;code&gt;X::iterator&lt;/code&gt; 相同</target>
        </trans-unit>
        <trans-unit id="c036f0c614197c69e50ff0747f60db77d1ca80a7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;name&quot;&gt;identifier&lt;/a&gt; that names a non-type template parameter of class type &lt;code&gt;T&lt;/code&gt; denotes a static storage duration object of type &lt;code&gt;const T&lt;/code&gt;, called a</source>
          <target state="translated">命名为类类型 &lt;code&gt;T&lt;/code&gt; 的非类型模板参数的&lt;a href=&quot;name&quot;&gt;标识符&lt;/a&gt;表示类型为 &lt;code&gt;const T&lt;/code&gt; 的静态存储持续时间对象，称为a</target>
        </trans-unit>
        <trans-unit id="c6fbfbd5514da52daf4588bb104a4a85d038970e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;name#In_expressions&quot;&gt;identifier expression&lt;/a&gt; that denotes an immediate function may only appear within a subexpression of an immediate invocation or within an immediate function context. A pointer or reference to an immediate function can be taken but cannot escape constant expression evaluation:</source>
          <target state="translated">表示立即函数的&lt;a href=&quot;name#In_expressions&quot;&gt;标识符表达式&lt;/a&gt;只能出现在立即调用的子表达式中或在立即函数上下文中。可以使用指向立即函数的指针或引用，但不能转义常量表达式求值：</target>
        </trans-unit>
        <trans-unit id="4835e23540157d178506c76dbed3585b131cd6c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; whose declaration is not a definition.</source>
          <target state="translated">一种&lt;a href=&quot;template_specialization&quot;&gt;显式专业化，&lt;/a&gt;其声明不是定义。</target>
        </trans-unit>
        <trans-unit id="0476037f5a01ed84f4c68efe6578d34ee836c695" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;type_alias&quot;&gt;alias-declaration&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;type_alias&quot;&gt;别名声明&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec273bcf1f66db0db9b6197343f94ba32b5eec31" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; of function type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to a &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;pointer to that function&lt;/a&gt;. This does not apply to non-static member functions because lvalues that refer to non-static member functions do not exist.</source>
          <target state="translated">函数类型 &lt;code&gt;T&lt;/code&gt; 的&lt;a href=&quot;value_category#lvalue&quot;&gt;左值&lt;/a&gt;可以隐式转换为&lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;指向该函数&lt;/a&gt;的&lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue &lt;/a&gt;指针。这不适用于非静态成员函数，因为引用非静态成员函数的左值不存在。</target>
        </trans-unit>
        <trans-unit id="7ba6cc034ab70817b81a34ed74af74dd8855a970" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; or &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; of type &quot;array of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;T&lt;/code&gt;&quot; or &quot;array of unknown bound of &lt;code&gt;T&lt;/code&gt;&quot; can be implicitly converted to a &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt; of type &quot;pointer to &lt;code&gt;T&lt;/code&gt;&quot;. If the array is a prvalue, &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; occurs.(since C++17) The resulting pointer refers to the first element of the array (see &lt;a href=&quot;array#Array-to-pointer_decay&quot;&gt;array to pointer decay&lt;/a&gt; for details).</source>
          <target state="translated">一个&lt;a href=&quot;value_category#lvalue&quot;&gt;左值&lt;/a&gt;或&lt;a href=&quot;value_category#rvalue&quot;&gt;右值&lt;/a&gt;类型&amp;ldquo;阵列的 &lt;code&gt;N&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; &amp;rdquo;或&amp;ldquo;结合的未知的阵列 &lt;code&gt;T&lt;/code&gt; &amp;rdquo;可被隐式转换为&lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt;类型&amp;ldquo;指针的 &lt;code&gt;T&lt;/code&gt; &amp;rdquo;。如果数组是prvalue，则会发生&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;临时实现&lt;/a&gt;。（自C ++ 17起）结果指针指向数组的第一个元素（有关详细信息，请参见&lt;a href=&quot;array#Array-to-pointer_decay&quot;&gt;指向指针衰减的数组&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3b75a307aa52c5825d1730c4cdd4f9a558685208" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; object containing the given values.</source>
          <target state="translated">一个包含给定值的 &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="d6c35561be6c0db7de52088fd8b63305b7a7d8f9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; holding a pointer to the beginning of the allocated storage and the number of objects that fit in the storage that was actually allocated.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 持有一个指针，指向已分配存储区的开始以及实际分配的存储区中适合的对象数。</target>
        </trans-unit>
        <trans-unit id="64c0acf093e82ca7c2d56259ef132c09f1d727d8" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;AllocatorAwareContainer&lt;/strong&gt; is a &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt; that holds an instance of an &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; and uses that instance in all its member functions to allocate and deallocate memory and to construct and destroy objects in that memory (such objects may be container elements, nodes, or, for unordered containers, bucket arrays).</source>
          <target state="translated">一个&lt;strong&gt;AllocatorAwareContainer&lt;/strong&gt;是一个&lt;a href=&quot;container&quot;&gt;容器&lt;/a&gt;，其保持的一个实例&lt;a href=&quot;allocator&quot;&gt;分配器&lt;/a&gt;的用途该实例中所有的成员函数来分配和释放存储器和构造和在该存储器破坏对象（例如对象可以是容器中的元素，节点，或者，对于无序的容器和，存储桶数组）。</target>
        </trans-unit>
        <trans-unit id="eaa15e16e5ec0c95afc353328fbb4fb678121869" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;AssociativeContainer&lt;/strong&gt; is an ordered &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt; that provides fast lookup of objects based on keys.</source>
          <target state="translated">一个&lt;strong&gt;AssociativeContainer&lt;/strong&gt;是一个有序的&lt;a href=&quot;container&quot;&gt;容器&lt;/a&gt;，它提供基于键的对象的快速查找。</target>
        </trans-unit>
        <trans-unit id="b5c5d4aca5ec3c0868d0e700b371604b1ec448c3" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;LegacyInputIterator&lt;/strong&gt; is an &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; that can read from the pointed-to element. LegacyInputIterators only guarantee validity for single pass algorithms: once an LegacyInputIterator &lt;code&gt;i&lt;/code&gt; has been incremented, all copies of its previous value may be invalidated.</source>
          <target state="translated">一个&lt;strong&gt;LegacyInputIterator&lt;/strong&gt;是&lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;可以从被指向的元件读取。LegacyInputIterators仅保证单遍算法的有效性：LegacyInputIterator &lt;code&gt;i&lt;/code&gt; 递增后，其先前值的所有副本都可能失效。</target>
        </trans-unit>
        <trans-unit id="a021125aae1a0c5f6666fbd70ad3091d5eaf4be5" translate="yes" xml:space="preserve">
          <source>An UnformattedInputFunction is a stream input function that performs the following:</source>
          <target state="translated">UnformattedInputFunction是一个流输入函数,它可以执行以下操作。</target>
        </trans-unit>
        <trans-unit id="ce56470376a6a1e9f7a374ada94b689a0ac77bd6" translate="yes" xml:space="preserve">
          <source>An abstract class is a class that either defines or inherits at least one function for which &lt;a href=&quot;virtual&quot;&gt;the final overrider&lt;/a&gt; is pure virtual.</source>
          <target state="translated">抽象类是定义或继承至少一个函数的类，对于该函数，&lt;a href=&quot;virtual&quot;&gt;最终替代程序&lt;/a&gt;是纯虚拟的。</target>
        </trans-unit>
        <trans-unit id="908b2d8b11e075496d08f7d7d4b01d8354d7a3e1" translate="yes" xml:space="preserve">
          <source>An additional class template &lt;code&gt;auto_ptr_ref&lt;/code&gt; is referred to throughout the documentation. It is an implementation-defined type that holds a reference to &lt;code&gt;auto_ptr&lt;/code&gt;. The implementation is allowed to provide the template with a different name or implement the functions returning it or accepting it as parameter in other ways.</source>
          <target state="translated">整个文档中都引用了附加的类模板 &lt;code&gt;auto_ptr_ref&lt;/code&gt; 。它是实现定义的类型，具有对 &lt;code&gt;auto_ptr&lt;/code&gt; 的引用。允许实现为模板提供不同的名称，或者以其他方式实现返回模板或将其接受为参数的函数。</target>
        </trans-unit>
        <trans-unit id="492bf377c49f20efce1a6cebadb795c9f43e068d" translate="yes" xml:space="preserve">
          <source>An additional rule is applied to the deduction in this case: when comparing function parameters &lt;code&gt;P&lt;/code&gt;i and &lt;code&gt;A&lt;/code&gt;i, if any &lt;code&gt;P&lt;/code&gt;i is an rvalue reference to cv-unqualified template parameter (a &quot;forwarding reference&quot;) and the corresponding &lt;code&gt;A&lt;/code&gt;i is an lvalue reference, then &lt;code&gt;P&lt;/code&gt;i is adjusted to the template parameter type (T&amp;amp;&amp;amp; becomes T).</source>
          <target state="translated">在这种情况下，对推论应用了一条附加规则：在比较函数参数 &lt;code&gt;P&lt;/code&gt; i和 &lt;code&gt;A&lt;/code&gt; i时，如果任何 &lt;code&gt;P&lt;/code&gt; i是对cv不合格模板参数的右值引用（&amp;ldquo;转发引用&amp;rdquo;），而对应的 &lt;code&gt;A&lt;/code&gt; i是左值参考，然后将 &lt;code&gt;P&lt;/code&gt; i调整为模板参数类型（T &amp;amp;&amp;amp;变为T）。</target>
        </trans-unit>
        <trans-unit id="39f1e2f1f4a1f2712c275be633629814179e5046" translate="yes" xml:space="preserve">
          <source>An aggregate class or array may include non-aggregate public bases(since C++17), members, or elements, which are initialized as described above (e.g. copy-initialization from the corresponding initializer clause).</source>
          <target state="translated">聚合类或数组可以包括非聚合的公共基础(自C++17起)、成员或元素,它们的初始化如上所述(例如从相应的初始化子句复制初始化)。</target>
        </trans-unit>
        <trans-unit id="b197d6cc29c7895c847275964c7060dca3357d57" translate="yes" xml:space="preserve">
          <source>An aggregate is one of the following types:</source>
          <target state="translated">合计是下列类型之一:</target>
        </trans-unit>
        <trans-unit id="12db35057383aa0593fc91fb24bea2072f9fc5b7" translate="yes" xml:space="preserve">
          <source>An algorithm to &quot;clamp&quot; a value between a pair of boundary values (&lt;code&gt;&lt;a href=&quot;algorithm/clamp&quot;&gt;std::clamp&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">一种将值&amp;ldquo;钳位&amp;rdquo;在一对边界值（ &lt;code&gt;&lt;a href=&quot;algorithm/clamp&quot;&gt;std::clamp&lt;/a&gt;&lt;/code&gt; ）之间的算法</target>
        </trans-unit>
        <trans-unit id="6a4c8075a51ee48f2fc8e9678f381d4c2cc5cd9e" translate="yes" xml:space="preserve">
          <source>An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;. The behavior is undefined if &lt;code&gt;Allocator::value_type&lt;/code&gt; is not the same as &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">一个分配器，用于获取/释放内存以及构造/销毁该内存中的元素。类型必须符合&lt;a href=&quot;../named_req/allocator&quot;&gt;分配器&lt;/a&gt;的要求。如果 &lt;code&gt;Allocator::value_type&lt;/code&gt; 与 &lt;code&gt;T&lt;/code&gt; 不同，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="2b7e6c1744a360683380fca88796315c08727ff6" translate="yes" xml:space="preserve">
          <source>An allocator type &lt;code&gt;X&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt; additionally satisfies the</source>
          <target state="translated">类型 &lt;code&gt;T&lt;/code&gt; 的分配器类型 &lt;code&gt;X&lt;/code&gt; 还满足</target>
        </trans-unit>
        <trans-unit id="8d97370574b17753b94ede73aa5e362da9eb3aac" translate="yes" xml:space="preserve">
          <source>An arithmetic type or a class emulating an arithmetic type</source>
          <target state="translated">一个算术类型或一个模拟算术类型的类。</target>
        </trans-unit>
        <trans-unit id="c52cf5a897774b32a3cc4643437d36a5b1792813" translate="yes" xml:space="preserve">
          <source>An array can also be used as a tuple of &lt;code&gt;N&lt;/code&gt; elements of the same type.</source>
          <target state="translated">数组也可以用作相同类型的 &lt;code&gt;N&lt;/code&gt; 个元素的元组。</target>
        </trans-unit>
        <trans-unit id="5ac3648865a50f77bee68245b1bc8d2b8af79b49" translate="yes" xml:space="preserve">
          <source>An array declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">数组声明是其&lt;a href=&quot;declarations&quot;&gt;声明符&lt;/a&gt;具有以下形式的任何简单声明。</target>
        </trans-unit>
        <trans-unit id="f97a7d14a3134d2ce52774abf33446e4a447d088" translate="yes" xml:space="preserve">
          <source>An assignment operator in a class &lt;code&gt;T&lt;/code&gt; that is a member or base of another class &lt;code&gt;U&lt;/code&gt; is odr-used by an implicitly-defined copy-assignment or move-assignment functions of &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">在一类赋值运算符 &lt;code&gt;T&lt;/code&gt; 这是一个部件或另一个类的碱 &lt;code&gt;U&lt;/code&gt; 是ODR-使用的隐式定义的复制分配或移入分配功能 &lt;code&gt;U&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bc87d164b8e7f6ecde4c668667f3c0239908e17" translate="yes" xml:space="preserve">
          <source>An associative container &lt;code&gt;X&lt;/code&gt; that is either &lt;code&gt;std::map&lt;/code&gt; and &lt;code&gt;std::multimap&lt;/code&gt; additionally supports the expression X::mapped_type, which has a return type of T, with the requirement that &lt;code&gt;T&lt;/code&gt; be &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and compile time complexity.</source>
          <target state="translated">的关联容器 &lt;code&gt;X&lt;/code&gt; 是任一 &lt;code&gt;std::map&lt;/code&gt; 和 &lt;code&gt;std::multimap&lt;/code&gt; 附加地支持该表达X :: mapped_type，其具有T的返回类型，与所述要求，即 &lt;code&gt;T&lt;/code&gt; 是&lt;a href=&quot;destructible&quot;&gt;可破坏&lt;/a&gt;，和编译时间复杂度。</target>
        </trans-unit>
        <trans-unit id="864fa04b4ed98eae74afcfaa9ef56bb780bc69ce" translate="yes" xml:space="preserve">
          <source>An asynchronous operation (created via &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;) can provide a &lt;code&gt;std::future&lt;/code&gt; object to the creator of that asynchronous operation.</source>
          <target state="translated">异步操作（通过 &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; ）可以为该异步操作的创建者提供 &lt;code&gt;std::future&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="9e8f8230bc284edbfa18713cf06662ed31c603fb" translate="yes" xml:space="preserve">
          <source>An atomic &lt;a href=&quot;memory_order&quot;&gt;release operation&lt;/a&gt; X in thread A synchronizes-with an acquire fence F in thread B, if.</source>
          <target state="translated">如果线程A中的原子&lt;a href=&quot;memory_order&quot;&gt;释放操作&lt;/a&gt; X与线程B中的获取围栏F同步。</target>
        </trans-unit>
        <trans-unit id="928fdce82eda51be195710313098b2223ec96c39" translate="yes" xml:space="preserve">
          <source>An atomic constraint consists of an expression &lt;code&gt;E&lt;/code&gt; and a mapping from the template parameters that appear within &lt;code&gt;E&lt;/code&gt; to template arguments involving the template parameters of the constrained entity, called its</source>
          <target state="translated">原子约束由一个表达式 &lt;code&gt;E&lt;/code&gt; 和一个从 &lt;code&gt;E&lt;/code&gt; 内出现的模板参数到涉及受约束实体的模板参数的模板参数（称为其约束）的映射组成。</target>
        </trans-unit>
        <trans-unit id="5a79829f8c7b85fe4e4638dfbea954acbd0eda02" translate="yes" xml:space="preserve">
          <source>An atomic operation A on some atomic object M is</source>
          <target state="translated">对某个原子对象M的原子操作A是</target>
        </trans-unit>
        <trans-unit id="5a5310902368573c36e555b627b994b235e68248" translate="yes" xml:space="preserve">
          <source>An attribute can be used almost everywhere in the C++ program, and can be applied to almost everything: to types, to variables, to functions, to names, to code blocks, to entire translation units, although each particular attribute is only valid where it is permitted by the implementation: &lt;code&gt;[[expect_true]]&lt;/code&gt; could be an attribute that can only be used with an &lt;code&gt;if&lt;/code&gt;, and not with a class declaration. &lt;code&gt;[[omp::parallel()]]&lt;/code&gt; could be an attribute that applies to a code block or to a &lt;code&gt;for&lt;/code&gt; loop, but not to the type &lt;code&gt;int&lt;/code&gt;, etc. (note these two attributes are fictional examples, see below for the standard and some non-standard attributes).</source>
          <target state="translated">属性几乎可以在C ++程序中的任何地方使用，并且可以应用于几乎所有事物：类型，变量，函数，名称，代码块，整个翻译单元，尽管每个特定属性仅在其有效的地方有效实现允许： &lt;code&gt;[[expect_true]]&lt;/code&gt; 是只能与 &lt;code&gt;if&lt;/code&gt; 一起使用的属性，而不能与类声明一起使用。 &lt;code&gt;[[omp::parallel()]]&lt;/code&gt; 可以是适用于代码块或 &lt;code&gt;for&lt;/code&gt; 循环的属性，但不适用于 &lt;code&gt;int&lt;/code&gt; 类型等。（请注意，这两个属性都是虚构的示例，有关以下内容，请参见标准和一些非标准属性）。</target>
        </trans-unit>
        <trans-unit id="3b30276e5eb22d8f2d82beaa0982183267864ede" translate="yes" xml:space="preserve">
          <source>An ellipsis &lt;code&gt;...&lt;/code&gt; may appear at the end of the parameter list; this declares a &lt;a href=&quot;variadic_arguments&quot;&gt;variadic function&lt;/a&gt;:</source>
          <target state="translated">参数列表的末尾可能会出现省略号 &lt;code&gt;...&lt;/code&gt; 。这声明了一个&lt;a href=&quot;variadic_arguments&quot;&gt;可变参数函数&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="7b28c53044424dbd671a0a292fff9b11ed2f240c" translate="yes" xml:space="preserve">
          <source>An empty path can be obtained by calling &lt;a href=&quot;clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; and by default-constructing a &lt;code&gt;path&lt;/code&gt;. It can also be returned by a path decomposition function (such as &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension&lt;/code&gt;&lt;/a&gt;) if the corresponding component is not present in the path.</source>
          <target state="translated">可以通过调用&lt;a href=&quot;clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt;并默认构造一个 &lt;code&gt;path&lt;/code&gt; 来获得空路径。如果路径中不存在相应的组件，它也可以由路径分解函数（例如&lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension&lt;/code&gt; &lt;/a&gt;）返回。</target>
        </trans-unit>
        <trans-unit id="2ecc5a9f5ce0682a542e5d3a7d4ffa7f954c9836" translate="yes" xml:space="preserve">
          <source>An empty path is classified as a relative path.</source>
          <target state="translated">空路径被归为相对路径。</target>
        </trans-unit>
        <trans-unit id="96c80c138bff7aa336c0c80903e065616c06546c" translate="yes" xml:space="preserve">
          <source>An empty range is lexicographically</source>
          <target state="translated">一个空的范围在词法上是</target>
        </trans-unit>
        <trans-unit id="c5d73f72c6721b75502428576903171289a2fc14" translate="yes" xml:space="preserve">
          <source>An empty shared_ptr (where &lt;code&gt;use_count() == 0&lt;/code&gt;) may store a non-null pointer accessible by &lt;code&gt;get()&lt;/code&gt;, e.g. if it were created using the aliasing constructor.</source>
          <target state="translated">空的shared_ptr（其中 &lt;code&gt;use_count() == 0&lt;/code&gt; ）可以存储可由 &lt;code&gt;get()&lt;/code&gt; 访问的非null指针，例如，如果它是使用别名构造函数创建的。</target>
        </trans-unit>
        <trans-unit id="bf3e0e6688aa2181023a253a9e87db009478a78e" translate="yes" xml:space="preserve">
          <source>An empty string if the character sequence is not a valid collating element</source>
          <target state="translated">如果字符序列不是一个有效的整理元素,则为空字符串。</target>
        </trans-unit>
        <trans-unit id="3d82664471aad182109ca58741b1d45d1271d6cf" translate="yes" xml:space="preserve">
          <source>An enumeration is defined by</source>
          <target state="translated">一个枚举的定义是</target>
        </trans-unit>
        <trans-unit id="afe5baa45aa238529a9d9f5521326fb55bc4227f" translate="yes" xml:space="preserve">
          <source>An equivalent effect may be achieved with the facilities provided by &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; 提供的功能可以达到同等效果。</target>
        </trans-unit>
        <trans-unit id="26b27f109fdc73d104fb47c91bb0233ff5e7c5ad" translate="yes" xml:space="preserve">
          <source>An example of a custom operator&amp;lt;=&amp;gt; that returns &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt; is an operator that compares every member of a class, except in order that is different from the default (here: last name first).</source>
          <target state="translated">返回&lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt; &lt;code&gt;std::strong_ordering&lt;/code&gt; &lt;/a&gt;的自定义运算符&amp;lt;=&amp;gt;的示例是一个运算符，它比较类的每个成员，但顺序不同于默认值（此处为姓氏）。</target>
        </trans-unit>
        <trans-unit id="e794383d64707bd6aee1a7ffa3033ac34c3317b6" translate="yes" xml:space="preserve">
          <source>An example of a custom operator&amp;lt;=&amp;gt; that returns &lt;a href=&quot;../utility/compare/weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt; is an operator that compares string members of a class in case-insensitive manner: this is different from the default comparison (so a custom operator is required) and it's possible to distinguish two strings that compare equal under this comparison.</source>
          <target state="translated">返回&lt;a href=&quot;../utility/compare/weak_ordering&quot;&gt; &lt;code&gt;std::weak_ordering&lt;/code&gt; &lt;/a&gt;的自定义运算符&amp;lt;=&amp;gt;的示例是一个以不区分大小写的方式比较类的字符串成员的运算符：这与默认比较不同（因此需要自定义运算符），并且可能区分在此比较下比较相等的两个字符串。</target>
        </trans-unit>
        <trans-unit id="bc3fdebc617a723576859b7b78597b5a6e61e62e" translate="yes" xml:space="preserve">
          <source>An example of a type that implements LegacyOutputIterator is &lt;a href=&quot;../iterator/ostream_iterator&quot;&gt;std::ostream_iterator&lt;/a&gt;.</source>
          <target state="translated">实现LegacyOutputIterator的类型的示例是&lt;a href=&quot;../iterator/ostream_iterator&quot;&gt;std :: ostream_iterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="831c258222c425472a6e48db4facf3170a3cef28" translate="yes" xml:space="preserve">
          <source>An example of an inheritance hierarchy with virtual base classes is the iostreams hierarchy of the standard library: &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; using virtual inheritance. &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; is derived from both &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;, so every instance of &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; contains a &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; subobject, a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; subobject, and just one &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; subobject (and, consequently, one &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">具有虚拟基类的继承层次结构的一个示例是标准库的iostreams层次结构： &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; 是使用虚拟继承从 &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; 派生的。 &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; 是从 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; 派生的，因此 &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; 每个实例都包含一个 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; 子对象，一个 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; 子对象和一个 &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; 子对象（因此，一个 &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="41464d61485a2aac603dadcdf39c0ce3781751e5" translate="yes" xml:space="preserve">
          <source>An example of when such declaration is used is the implementation of &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使用此类声明的一个示例是 &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="bdba113faa387d1ab71c87afef4ec469f4cc925c" translate="yes" xml:space="preserve">
          <source>An example where int-returning &lt;code&gt;uncaught_exceptions&lt;/code&gt; is used is the &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; library: the expression &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; first creates a guard object and records the number of uncaught exceptions in its constructor. The output is performed by the guard object's destructor unless foo() throws (in which case the number of uncaught exceptions in the destructor is greater than what the constructor observed).</source>
          <target state="translated">&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt;库是使用int返回 &lt;code&gt;uncaught_exceptions&lt;/code&gt; 的示例：表达式 &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; 首先创建一个保护对象，并在其构造函数中记录未捕获的异常数。输出由保护对象的析构函数执行，除非foo（）抛出（在这种情况下，析构函数中未捕获的异常数大于构造函数观察到的数量）。</target>
        </trans-unit>
        <trans-unit id="3c376fdb08a2c546d5e0e5f8f44feb92df5bc392" translate="yes" xml:space="preserve">
          <source>An example where int-returning &lt;code&gt;uncaught_exceptions&lt;/code&gt; is used is the &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; library: the expression &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; first creates a guard object and records the number of uncaught exceptions in its constructor. The output is performed by the guard object's destructor unless foo() throws (in which case the number of uncaught exceptions in the destructor is greater than what the constructor observed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b085b3ecbb54c70910e25f3896da20b2a187a73" translate="yes" xml:space="preserve">
          <source>An exception can be thrown by a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;, &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation function&lt;/a&gt;, and any of the standard library functions that are specified to throw exceptions to signal certain error conditions (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string/substr&quot;&gt;std::string::substr&lt;/a&gt;&lt;/code&gt;, etc).</source>
          <target state="translated">可以通过&lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;，&lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;，&lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;，&lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;，&lt;a href=&quot;../memory/new/operator_new&quot;&gt;分配函数&lt;/a&gt;以及指定用于抛出异常以表示某些错误情况的任何标准库函数（例如 &lt;code&gt;&lt;a href=&quot;../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; 抛出异常。 &lt;code&gt;&lt;a href=&quot;../string/basic_string/substr&quot;&gt;std::string::substr&lt;/a&gt;&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="734db5e27654b7a1a090879aa79155ed3b4b2a8b" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;*this&lt;/code&gt; has no shared state or &lt;code&gt;get_future&lt;/code&gt; has already been called. To get multiple &quot;pop&quot; ends of the promise-future communication channel, use &lt;code&gt;&lt;a href=&quot;../future/share&quot;&gt;std::future::share&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 没有共享状态或已经调用 &lt;code&gt;get_future&lt;/code&gt; ,则抛出异常。要获得promise-future交流渠道的多个&amp;ldquo; pop&amp;rdquo;端，请使用 &lt;code&gt;&lt;a href=&quot;../future/share&quot;&gt;std::future::share&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44db7b4c1aff9b2986166f1068a5b7109c799860" translate="yes" xml:space="preserve">
          <source>An exception is thrown if there is no shared state or the shared state already stores a value or exception.</source>
          <target state="translated">如果没有共享状态或共享状态已经存储了一个值或异常,就会抛出异常。</target>
        </trans-unit>
        <trans-unit id="400934141b26ebdcfa01b232809e28da4e1614d3" translate="yes" xml:space="preserve">
          <source>An exception of this type is thrown when a &lt;a href=&quot;../language/dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt; to a reference type fails the run-time check (e.g. because the types are not related by inheritance), and also from &lt;code&gt;&lt;a href=&quot;../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&lt;/code&gt; if the requested facet does not exist in the locale.</source>
          <target state="translated">当对引用类型的&lt;a href=&quot;../language/dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt;无法通过运行时检查时（例如，由于类型与继承无关），并且如果在语言环境中不存在所请求的方面，则也会从 &lt;code&gt;&lt;a href=&quot;../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&lt;/code&gt; 引发此类型的异常。</target>
        </trans-unit>
        <trans-unit id="3e10eeb3d50b8941ecde1bf2d5b08ad5eba672d1" translate="yes" xml:space="preserve">
          <source>An exception of this type is thrown when a &lt;a href=&quot;../language/typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt; operator is applied to a dereferenced null pointer value of a polymorphic type.</source>
          <target state="translated">当将&lt;a href=&quot;../language/typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt;运算符应用于多态类型的已取消引用的空指针值时，抛出此类型的异常。</target>
        </trans-unit>
        <trans-unit id="392a7913172c4bf28f4342b2ce3e240403f2f75f" translate="yes" xml:space="preserve">
          <source>An explanatory message for the stored error code and error category.</source>
          <target state="translated">存储的错误代码和错误类别的解释信息。</target>
        </trans-unit>
        <trans-unit id="d5eabc2515cac7175770538d9fd2aca675f84744" translate="yes" xml:space="preserve">
          <source>An explicit instantiation declaration (an extern template) prevents implicit instantiations: the code that would otherwise cause an implicit instantiation has to use the explicit instantiation definition provided somewhere else in the program.</source>
          <target state="translated">显式实例化声明(外部模板)可以防止隐式实例化:否则会引起隐式实例化的代码必须使用程序中其他地方提供的显式实例化定义。</target>
        </trans-unit>
        <trans-unit id="33cd7a0177e9f7ec5c231dde735e35e1a0d3fb00" translate="yes" xml:space="preserve">
          <source>An explicit instantiation declaration (an extern template) skips implicit instantiation step: the code that would otherwise cause an implicit instantiation instead uses the explicit instantiation definition provided elsewhere (resulting in link errors if no such instantiation exists). This can be used to reduce compilation times by explicitly declaring a template instantiation in all but one of the source files using it, and explicitly defining it in the remaining file.</source>
          <target state="translated">显式实例化声明(外部模板)跳过了隐式实例化步骤:否则会导致隐式实例化的代码会使用其他地方提供的显式实例化定义(如果不存在这样的实例化,会导致链接错误)。这可以通过在所有使用模板的源文件中明确声明模板实例化,而在其余文件中明确定义模板实例化来减少编译时间。</target>
        </trans-unit>
        <trans-unit id="133c2fb50577da662edeff998e62d6b70b901935" translate="yes" xml:space="preserve">
          <source>An explicit instantiation definition forces instantiation of the class, struct, or union they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the entire program.</source>
          <target state="translated">显式实例化定义会强制实例化它们所引用的类、结构或联合体。它可以出现在程序中模板定义之后的任何地方,对于一个给定的参数列表,在整个程序中只允许出现一次。</target>
        </trans-unit>
        <trans-unit id="c3fb00f7b63425b442d1cc0c31f1edb4322117c1" translate="yes" xml:space="preserve">
          <source>An explicit instantiation definition forces instantiation of the function or member function they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the program.</source>
          <target state="translated">明确的实例化定义会强制实例化它们所引用的函数或成员函数。它可以出现在程序中模板定义之后的任何地方,对于一个给定的参数列表,只允许在程序中出现一次。</target>
        </trans-unit>
        <trans-unit id="c9c128e72c9b832e8384315ba572027dc359efd3" translate="yes" xml:space="preserve">
          <source>An explicit specialization cannot be a &lt;a href=&quot;friend&quot;&gt;friend declaration&lt;/a&gt;.</source>
          <target state="translated">明确的专业化不能成为&lt;a href=&quot;friend&quot;&gt;朋友声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a4ebeb793310cf18619b24eeafbc2e6fd5d0c1f" translate="yes" xml:space="preserve">
          <source>An explicit specialization of a function template is inline only if it is declared with the &lt;a href=&quot;inline&quot;&gt;inline specifier&lt;/a&gt; (or defined as deleted), it doesn't matter if the primary template is inline.</source>
          <target state="translated">仅当使用&lt;a href=&quot;inline&quot;&gt;内联说明符&lt;/a&gt;声明（或定义为删除）函数模板的显式特化才是内联的，而主模板是否为内联则无关紧要。</target>
        </trans-unit>
        <trans-unit id="ad7859780f7fda205f962953901c88030d43e65f" translate="yes" xml:space="preserve">
          <source>An explicit specialization of a static data member of a template is a definition if the declaration includes an initializer; otherwise, it is a declaration. These definitions must use braces for default initialization:</source>
          <target state="translated">如果声明中包含初始化器,那么模板的静态数据成员的显式特化就是一个定义;否则就是一个声明。这些定义必须使用大括号进行默认初始化。</target>
        </trans-unit>
        <trans-unit id="f5646484a04d1f69f62bdf5309c5a9d249438cc5" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="translated">表达式 &lt;code&gt;e&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="11f8c98f192821781cccabf62455469b73d17864" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">表达式 &lt;code&gt;e&lt;/code&gt; 据说是</target>
        </trans-unit>
        <trans-unit id="34f74cee143d788f51fcc25acc797aea92c197b8" translate="yes" xml:space="preserve">
          <source>An expression followed by a semicolon is a statement.</source>
          <target state="translated">分号后的表达式是一个语句。</target>
        </trans-unit>
        <trans-unit id="f703e5af31c537ec73c27f6089a222ac20a91c8b" translate="yes" xml:space="preserve">
          <source>An expression is</source>
          <target state="translated">一个表达式是</target>
        </trans-unit>
        <trans-unit id="c5756e59953f27f7802c2879dfb5bf8b2ef537aa" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of</source>
          <target state="translated">表达式是一系列的</target>
        </trans-unit>
        <trans-unit id="8582e3c88de4617441467faab5ff600afdf1bfb6" translate="yes" xml:space="preserve">
          <source>An expression statement without an expression is called a</source>
          <target state="translated">没有表达式的表达式语句称为</target>
        </trans-unit>
        <trans-unit id="ba931ef941c10e68e24584826bf3e7b5e908486f" translate="yes" xml:space="preserve">
          <source>An expression that designates a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; (e.g. &lt;code&gt;a.m&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is an lvalue of type &lt;code&gt;struct A { int m: 3; }&lt;/code&gt;) is an lvalue expression: it may be used as the left-hand operand of the assignment operator, but its address cannot be taken and a non-const lvalue reference cannot be bound to it. A const lvalue reference can be initialized from a bit-field lvalue, but a temporary copy of the bit-field will be made: it won't bind to the bit field directly.</source>
          <target state="translated">指定&lt;a href=&quot;bit_field&quot;&gt;位字段&lt;/a&gt;的表达式（例如 &lt;code&gt;a.m&lt;/code&gt; ，其中 &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;struct A { int m: 3; }&lt;/code&gt; 类型的左值）是左值表达式：它可以用作赋值运算符的左侧操作数，但是无法获取地址，并且不能将非常量左值引用绑定到该地址。可以从位域左值初始化const左值引用，但是将创建该位域的临时副本：它不会直接绑定到位域。</target>
        </trans-unit>
        <trans-unit id="95fcc97496d0a23551b56ed465f2ec32a136ce51" translate="yes" xml:space="preserve">
          <source>An identifier can be used &lt;a href=&quot;declarations&quot;&gt;to name&lt;/a&gt; objects, references, functions, enumerators, types, class members, namespaces, templates, template specializations, parameter packs, goto labels, and other entities, with the following exceptions:</source>
          <target state="translated">标识符可用于&lt;a href=&quot;declarations&quot;&gt;命名&lt;/a&gt;对象，引用，函数，枚举器，类型，类成员，名称空间，模板，模板专业化，参数包，goto标签和其他实体，但以下情况除外：</target>
        </trans-unit>
        <trans-unit id="f6eb1c54d1e440abd120bdddffed4feee0d07b20" translate="yes" xml:space="preserve">
          <source>An identifier that names a variable, a function, specialization of a &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;,(since C++20) or an enumerator can be used as an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt;. The result of an expression consisting of just the identifier is the entity named by the identifier. The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the expression is</source>
          <target state="translated">命名变量，函数，&lt;a href=&quot;constraints&quot;&gt;概念的&lt;/a&gt;专业化（自C ++ 20起）或枚举器的标识符可以用作&lt;a href=&quot;expressions&quot;&gt;表达式&lt;/a&gt;。仅由标识符组成的表达式的结果是由标识符命名的实体。表达式的&lt;a href=&quot;value_category&quot;&gt;值类别&lt;/a&gt;为</target>
        </trans-unit>
        <trans-unit id="2bea22f245aad6a1bbd96dbe721e6bfbb9cba55e" translate="yes" xml:space="preserve">
          <source>An immediate function is a constexpr function, and must satisfy the requirements applicable to &lt;a href=&quot;constexpr&quot;&gt;constexpr functions or constexpr constructors&lt;/a&gt;, as the case may be.</source>
          <target state="translated">即时函数是constexpr函数，视情况而定，必须满足适用于&lt;a href=&quot;constexpr&quot;&gt;constexpr函数或constexpr构造函数&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="252a155693a85c4513362e41870c607628599139" translate="yes" xml:space="preserve">
          <source>An implementation cannot declare additional non-static data members that would occupy storage disjoint from the real and imaginary components, and must ensure that the class template specialization does not contain any padding. The implementation must also ensure that optimizations to array access account for the possibility that a pointer to &lt;code&gt;value_type&lt;/code&gt; may be aliasing a &lt;code&gt;std::complex&lt;/code&gt; specialization or array thereof.</source>
          <target state="translated">实现不能声明将占用与实部和虚部不相交的存储的其他非静态数据成员，并且必须确保类模板专门化不包含任何填充。该实现还必须确保对数组访问的优化考虑了指向 &lt;code&gt;value_type&lt;/code&gt; 的指针可能使 &lt;code&gt;std::complex&lt;/code&gt; 或其数组成为别名的可能性。</target>
        </trans-unit>
        <trans-unit id="b36215737bc9acc94a1181b9b9fc0edbe7c6e8eb" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; for a user-defined type.</source>
          <target state="translated">用户定义类型的 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="5f56c2af44fa6aea68d66ab4f981e253c1870786" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for a user-defined type.</source>
          <target state="translated">用户定义类型的 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 的实现。</target>
        </trans-unit>
        <trans-unit id="8e1b5b99aec49dc279b82a189df1e4e71765f759" translate="yes" xml:space="preserve">
          <source>An implementation of the spherical harmonic function is &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;available in boost.math&lt;/a&gt;, and it reduces to this function when called with the parameter phi set to zero.</source>
          <target state="translated">&lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;boost.math中提供&lt;/a&gt;了球谐函数的实现，当将参数phi设置为零时，它将简化为该函数。</target>
        </trans-unit>
        <trans-unit id="6ef6f4ff8cf4b3091eca3ca55f5f34c2dba25629" translate="yes" xml:space="preserve">
          <source>An implementation of the spherical harmonic function is &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;available in boost.math&lt;/a&gt;, and it reduces to this function when called with the parameter phi set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f3d51d05cc3d2c938b7773b2a75528f0f533a8" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e8a80dd8b49b57fd0af28cb5b6f9eab92b003670" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="463a45be898237901d9e95795630e24b7725815f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a328d339a02fcd8f09757618757e341adcf6caf4" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="05afb78eee87d60d6affed2bb5d378e94152fda4" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="14e04477fae2c219d4ca4910e671ec277e96650f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23aab2406e44d22254e76892b9bb67f949035f8f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6d6d6fb65c08ea8df15db6341e3a63d4c3b1cb08" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a8f1f0a1677f6760e20f47ca31a1260d73446bbf" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="172a3359b3bc94067fe1ce4e3994c6fccab63962" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c3f9ea786832c07ac6ee8f2a1cf1bab37d07067f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="023d43dc101a8f0e0055a1bbe7ca05f32647f8f2" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1416c6c581d2a16bec76ecd9c479fdd72d0c8646" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7a97e935596f5c5ad772a94c524a08ecf79d480" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt; as &lt;code&gt;boost::math::legendre_p&lt;/code&gt;, except that the boost.math definition includes the Condon-Shortley phase term.</source>
          <target state="translated">该函数的实现&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;在boost.math中&lt;/a&gt;也可以作为 &lt;code&gt;boost::math::legendre_p&lt;/code&gt; ，除了boost.math定义包括Condon-Shortley相项。</target>
        </trans-unit>
        <trans-unit id="1b94dc33e3c2677817a24c87c5ae3eefdf3888b7" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">该函数的实现也&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;可以在boost.math中获得&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4376b52a3b698d01342890c645e63be771774af" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60467ab6c0631a5664cf0494d5a0ca49e6e52f1" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52edf4f2bf1751043ad31c41a6c11b35f270bfcb" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7b5eda0bb25aa403ce524620df1896aebc5bcd" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aeeb2ecef2e098cd110869669dbedfb641d1e82" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4bbb817d2363546432c72ec47562034e62b930c" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5bcaa2e77d6da4f3fa4ce84e311bb065df9b7be" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583558c1ff06b0561d4406d21632ee55c2b6f356" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c47a9490a77b892440d4dd4af49e877b2a9df1a" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659dcb29046fa05710b38a8fb1931ec898ae5519" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8d66df175707d6c72a60a41c20ae8c99e0d86e" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39da4171238400ac3f8feb8e52e5f753d1bd1fb7" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbdbc8151f3002ecfb8833c5c5c3125beb8e1447" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e14b6f00e0b4e1eb1ae3b23159f9339d5a211c3" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt; as &lt;code&gt;boost::math::legendre_p&lt;/code&gt;, except that the boost.math definition includes the Condon-Shortley phase term.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde4c238b03e2f7efad8438d5c040e7628566cfd" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6484905546dbda0376c3234e4af32b4774ac948c" translate="yes" xml:space="preserve">
          <source>An incompletely-defined object type can be completed:</source>
          <target state="translated">可以完成一个不完全定义的对象类型。</target>
        </trans-unit>
        <trans-unit id="034496cba173d751719f86a31427ebfaf5a3c429" translate="yes" xml:space="preserve">
          <source>An inline namespace is a namespace that uses the optional keyword &lt;code&gt;inline&lt;/code&gt; in its</source>
          <target state="translated">内联名称空间是在其名称中使用可选关键字 &lt;code&gt;inline&lt;/code&gt; 的名称空间。</target>
        </trans-unit>
        <trans-unit id="14113ff7972f0e79ae2bcb3f11df635a03888186" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; holding a reference to the copy of &lt;code&gt;e&lt;/code&gt;, or to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 实例，该实例持有对 &lt;code&gt;e&lt;/code&gt; 的副本的引用，或者对 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 实例或 &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 实例的引用（请参见 &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ba236b1f1a8d82abf0083dac8c36782f2303388c" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; holding a reference to the exception object, or a copy of the exception object, or to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 实例，该实例持有对异常对象或异常对象副本的引用，或者对 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 实例或 &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 实例的引用。</target>
        </trans-unit>
        <trans-unit id="4fbb0b241c865dd210a0103cf5d2af8c3a3e8a71" translate="yes" xml:space="preserve">
          <source>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.</source>
          <target state="translated">大于零的整数,如果这次调用后的流是面向宽的,小于零,如果这次调用后的流是面向字节的,零,如果流没有面向。</target>
        </trans-unit>
        <trans-unit id="27a4b795995133a65c00f00e3a5c86747c696bf8" translate="yes" xml:space="preserve">
          <source>An integer literal is a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt; of the form.</source>
          <target state="translated">整数文字是形式的&lt;a href=&quot;expressions#Primary_expressions&quot;&gt;主要表达&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22296b3029f90df1ec990b3a781242c55d5beaa6" translate="yes" xml:space="preserve">
          <source>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.</source>
          <target state="translated">一个整数类型,它可以作为一个原子实体被访问,即使是在信号进行异步中断的情况下。</target>
        </trans-unit>
        <trans-unit id="5018516b14deb056aa79dc2efd7d50ff7637de58" translate="yes" xml:space="preserve">
          <source>An invalid (in the current C locale) multibyte character was encountered.</source>
          <target state="translated">遇到无效的(在当前C语言环境下)多字节字符。</target>
        </trans-unit>
        <trans-unit id="6a1cb2e740b1d006f9942d3f948b281b6ec84075" translate="yes" xml:space="preserve">
          <source>An invalid multibyte character (according to the current C locale) was encountered. &lt;code&gt;src&lt;/code&gt; is set to point at the beginning of the first unconverted multibyte character.</source>
          <target state="translated">遇到无效的多字节字符（根据当前C语言环境）。 &lt;code&gt;src&lt;/code&gt; 设置为指向第一个未转换的多字节字符的开头。</target>
        </trans-unit>
        <trans-unit id="e0fbbc7a96cda105d7e43e6ea9e384c88eb8bd01" translate="yes" xml:space="preserve">
          <source>An invalid simple-template-id is a compile-time error, unless it names a function template specialization (in which case &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; may apply).</source>
          <target state="translated">无效的simple-template-id是编译时错误，除非它为函数模板专门化命名（在这种情况下，可以使用&lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="738a0c3fdce4b2a8db1475951201c5a23036b195" translate="yes" xml:space="preserve">
          <source>An invariant of &lt;code&gt;zoned_time&lt;/code&gt; is that it always refers to a valid time zone and represents an existing and unambiguous time point in that time zone. Consistent with this invariant, &lt;code&gt;zoned_time&lt;/code&gt; has no move constructor or move assignment operator; attempts to move a &lt;code&gt;zoned_time&lt;/code&gt; will perform a copy.</source>
          <target state="translated">&lt;code&gt;zoned_time&lt;/code&gt; 的不变性是，它始终引用有效时区，并表示该时区中存在的明确时间点。与该不变量一致， &lt;code&gt;zoned_time&lt;/code&gt; 没有移动构造函数或移动赋值运算符。尝试移动 &lt;code&gt;zoned_time&lt;/code&gt; 将执行复制。</target>
        </trans-unit>
        <trans-unit id="ff8ec771a3e408dd089882b2303398b60f16d16a" translate="yes" xml:space="preserve">
          <source>An invocation of an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; is always evaluated, even in an unevaluated operand.</source>
          <target state="translated">即使使用未评估的操作数，也始终评估对&lt;a href=&quot;consteval&quot;&gt;立即函数&lt;/a&gt;的调用。</target>
        </trans-unit>
        <trans-unit id="30e4b56dc9d38cfe9d66956b6e4aed328bf1c204" translate="yes" xml:space="preserve">
          <source>An invocation of an immediate function whose innermost non-block scope is not a &lt;a href=&quot;scope#Function_parameter_scope&quot;&gt;function parameter scope&lt;/a&gt; of an immediate function must produce a constant expression; such an invocation (known as an</source>
          <target state="translated">调用最内部非块作用域不是立即函数的&lt;a href=&quot;scope#Function_parameter_scope&quot;&gt;函数参数作用域&lt;/a&gt;的立即函数必须产生一个常量表达式。这样的调用（称为</target>
        </trans-unit>
        <trans-unit id="4706ad1f00d621a48d2e07b2a350e165dc71b6e6" translate="yes" xml:space="preserve">
          <source>An iterator pointing at the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">指向与 &lt;code&gt;*this&lt;/code&gt; 相同对象的迭代器。</target>
        </trans-unit>
        <trans-unit id="7ef94e98b9aecdcf5a48dda0b6d175cdca4869ff" translate="yes" xml:space="preserve">
          <source>An iterator pointing immediately after the last character produced.</source>
          <target state="translated">一个迭代器,指向最后一个产生的字符之后。</target>
        </trans-unit>
        <trans-unit id="a6f7df894c8448a1c11979a004ebd6ace3d75b98" translate="yes" xml:space="preserve">
          <source>An iterator pointing immediately after the last character recognized as a valid part of the monetary string input.</source>
          <target state="translated">一个迭代器,紧接着指向货币字符串输入的最后一个字符的有效部分。</target>
        </trans-unit>
        <trans-unit id="2ae3748a0356e1b6e535e66f5c4ffa0cfaff3539" translate="yes" xml:space="preserve">
          <source>An iterator pointing to the element following the erased element, or &lt;code&gt;end()&lt;/code&gt; if no such element exists.</source>
          <target state="translated">指向已删除元素之后的元素的迭代器；如果不存在此类元素，则指向 &lt;code&gt;end()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e831682f27c4215fd3d51adc3ab282760afa70fa" translate="yes" xml:space="preserve">
          <source>An iterator referring to the first &lt;code&gt;std::chrono::tzdb&lt;/code&gt; in the container.</source>
          <target state="translated">引用容器中第一个 &lt;code&gt;std::chrono::tzdb&lt;/code&gt; 的迭代器。</target>
        </trans-unit>
        <trans-unit id="7a63b694e4a7d314c8d05c5417ebc4bb1f31eb30" translate="yes" xml:space="preserve">
          <source>An iterator to the beginning of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 或 &lt;code&gt;array&lt;/code&gt; 开头的迭代器。</target>
        </trans-unit>
        <trans-unit id="02479c246c44225a9035a0d45997e83cce8420db" translate="yes" xml:space="preserve">
          <source>An iterator to the end of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;. Note that the end of a container or array is defined as the element following the last valid element.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 或 &lt;code&gt;array&lt;/code&gt; 末尾的迭代器。请注意，容器或数组的末尾定义为最后一个有效元素之后的元素。</target>
        </trans-unit>
        <trans-unit id="a11a64a7066be12c5192b1c7d9f47275f39b47d8" translate="yes" xml:space="preserve">
          <source>An iterator to the reverse-beginning of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 或 &lt;code&gt;array&lt;/code&gt; 的反向开头的迭代器。</target>
        </trans-unit>
        <trans-unit id="e7197d58fc54a43b495f2accaea0f6922ad829bd" translate="yes" xml:space="preserve">
          <source>An iterator to the reverse-end of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">到 &lt;code&gt;c&lt;/code&gt; 或 &lt;code&gt;array&lt;/code&gt; 的后端的迭代器。</target>
        </trans-unit>
        <trans-unit id="625c5f2464c30593f74840f1bd907c2068776afc" translate="yes" xml:space="preserve">
          <source>An iterator type whose category, value, difference, pointer and</source>
          <target state="translated">一个迭代器类型,其类别、值、差值、指针和</target>
        </trans-unit>
        <trans-unit id="19a75628cf6442d77f6648e9556c5bb263d28280" translate="yes" xml:space="preserve">
          <source>An lvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize an lvalue reference&lt;/a&gt;; this associates a new name with the object identified by the expression.</source>
          <target state="translated">左值可用于&lt;a href=&quot;reference_initialization&quot;&gt;初始化左值引用&lt;/a&gt;；这会将新名称与表达式标识的对象相关联。</target>
        </trans-unit>
        <trans-unit id="ca62ca28732e81cc9d1b6aa1ed666a055a48eb41" translate="yes" xml:space="preserve">
          <source>An object can contain other objects, which are called</source>
          <target state="translated">一个对象可以包含其他对象,这些对象被称为</target>
        </trans-unit>
        <trans-unit id="83df7119bca64cfa6a0dedb8658d0ab00a4eaf95" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;basic_istream::sentry&lt;/code&gt; is constructed in local scope at the beginning of each member function of &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; that performs input (both formatted and unformatted). Its constructor prepares the input stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, skips leading whitespace unless &lt;code&gt;noskipws&lt;/code&gt; flag is set, and performs other implementation-defined tasks if necessary. All cleanup, if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during input.</source>
          <target state="translated">&lt;code&gt;basic_istream::sentry&lt;/code&gt; 类的对象在执行输入（格式化和未格式化）的 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 每个成员函数的开头在本地范围内构造。它的构造函数准备输入流：检查流是否已处于故障状态，刷新tie（）的输出流，除非设置了 &lt;code&gt;noskipws&lt;/code&gt; 标志，否则跳过前导空格，并在必要时执行其他实现定义的任务。如有必要，所有清除操作都在析构函数中执行，因此可以保证如果在输入过程中引发异常，则会进行清除。</target>
        </trans-unit>
        <trans-unit id="823634b581a9cede4fd0ccc574bd7fa0bc24d634" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;basic_ostream::sentry&lt;/code&gt; is constructed in local scope at the beginning of each member function of &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; that performs output (both formatted and unformatted). Its constructor prepares the output stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, and performs other implementation-defined tasks if necessary. Implementation-defined cleanup, as well as flushing of the output stream if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during output.</source>
          <target state="translated">在本地范围内，在执行输出（格式化和未格式化）的 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 的每个成员函数的开头，构造了 &lt;code&gt;basic_ostream::sentry&lt;/code&gt; 类的对象。它的构造函数准备输出流：检查流是否已经处于故障状态，刷新tie（）的输出流，并在必要时执行其他实现定义的任务。在析构函数中执行实现定义的清除，并在需要时清除输出流，因此可以保证在输出过程中引发异常时进行清除。</target>
        </trans-unit>
        <trans-unit id="0455f9161322806dadb1a5a0172793f044ae30ea" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;std::locale&lt;/code&gt; is an immutable indexed set of immutable facets. Each stream object of the C++ input/output library is associated with an &lt;code&gt;std::locale&lt;/code&gt; object and uses its facets for parsing and formatting of all data. In addition, a locale object is associated with each &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object. Locale objects can also be used as predicates that perform string collation with the standard containers and algorithms and can be accessed directly to obtain or modify the facets they hold.</source>
          <target state="translated">类 &lt;code&gt;std::locale&lt;/code&gt; 的对象是不可变面的不可变索引集。C ++输入/输出库的每个流对象都与 &lt;code&gt;std::locale&lt;/code&gt; 对象相关联，并使用其构面来解析和格式化所有数据。另外，一个语言环境对象与每个 &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 对象相关联。语言环境对象还可用作与标准容器和算法执行字符串校对的谓词，并且可以直接访问以获取或修改它们所拥有的方面。</target>
        </trans-unit>
        <trans-unit id="d66af98d41f06cecefd4af58c7d9c0ca924bcff6" translate="yes" xml:space="preserve">
          <source>An object of the type must be contextually convertible to bool. The effect of this conversion returns false if the value is equivalent to its null value and true otherwise.</source>
          <target state="translated">该类型的对象必须是上下文可转换为bool的。如果该值等同于null值,则该转换效果返回false,否则返回true。</target>
        </trans-unit>
        <trans-unit id="7bacce28d1059e82c9739033111e220b4d8671d7" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0e2760523dc7073d44af20a277e7f5a90698df4" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;&amp;lt;value_type&amp;gt;</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; &amp;lt;value_type&amp;gt;的对象</target>
        </trans-unit>
        <trans-unit id="7bd18a30dbdab573b7c39639752708407fb37b52" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;To&lt;/code&gt; whose value representation is as described above.</source>
          <target state="translated">类型 &lt;code&gt;To&lt;/code&gt; 的对象，其值表示如上所述。</target>
        </trans-unit>
        <trans-unit id="e81f259c6d82e8e50d80fae74008b6a20cb6f607" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;X::value_compare&lt;/code&gt; constructed out of the comparison object is returned.</source>
          <target state="translated">返回由比较对象构造的 &lt;code&gt;X::value_compare&lt;/code&gt; 类型的对象。</target>
        </trans-unit>
        <trans-unit id="7cce6a193570a048de83246c7b511f63641f001b" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; is a lightweight proxy object that provides access to an array of objects of type &lt;code&gt;const T&lt;/code&gt;.</source>
          <target state="translated">类型为 &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; 对象是轻量级代理对象，可用于访问类型为 &lt;code&gt;const T&lt;/code&gt; 的对象数组。</target>
        </trans-unit>
        <trans-unit id="9033aa603f097747fd262291447f23ece9703946" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;std::once_flag&lt;/code&gt; that is passed to multiple calls to &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; allows those calls to coordinate with each other such that only one of the calls will actually run to completion.</source>
          <target state="translated">类型为 &lt;code&gt;std::once_flag&lt;/code&gt; 的对象将传递给对 &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; 多个调用，从而允许这些调用相互协调，从而只有一个调用实际上可以完成。</target>
        </trans-unit>
        <trans-unit id="3bdae20fade93232b05ba74a9d73283a7dcdf8dd" translate="yes" xml:space="preserve">
          <source>An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; when unpacking a &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, as a placeholder for the arguments that are not used.</source>
          <target state="translated">未指定类型的对象，因此可以为其分配任何值而没有任何效果。拟与 &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; 时，将 &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 拆包，作为未使用参数的占位符。</target>
        </trans-unit>
        <trans-unit id="26b9967510dc89a341fa42ca83cfa44ef6ebf576" translate="yes" xml:space="preserve">
          <source>An object that is not a subobject of another object is called</source>
          <target state="translated">一个不是另一个对象的子对象的对象被称为</target>
        </trans-unit>
        <trans-unit id="858015fdff20dfb1bcca98de775349cd0072b086" translate="yes" xml:space="preserve">
          <source>An object, in C++, is a</source>
          <target state="translated">在C++中,一个对象是一个</target>
        </trans-unit>
        <trans-unit id="2f63388a843dce76eb6b22f8810249f3b38a691e" translate="yes" xml:space="preserve">
          <source>An optional object &lt;code&gt;op&lt;/code&gt; may be turned into an empty optional with both &lt;code&gt;op = {};&lt;/code&gt; and &lt;code&gt;op = nullopt;&lt;/code&gt;. The first expression constructs an empty &lt;code&gt;optional&lt;/code&gt; object with &lt;code&gt;{}&lt;/code&gt; and assigns it to &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;op = {};&lt;/code&gt; 都可以将可选对象 &lt;code&gt;op&lt;/code&gt; 变成空的可选对象。和 &lt;code&gt;op = nullopt;&lt;/code&gt; 。第一个表达式使用 &lt;code&gt;{}&lt;/code&gt; 构造一个空的 &lt;code&gt;optional&lt;/code&gt; 对象，并将其分配给 &lt;code&gt;op&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6a5327aa18d2bb8b350958dde2d290354f8030" translate="yes" xml:space="preserve">
          <source>An out-of-class definition of a member function template must be</source>
          <target state="translated">成员函数模板的类外定义必须是</target>
        </trans-unit>
        <trans-unit id="7a79aaf703db97b5a7b0d58031c37912c2d8149a" translate="yes" xml:space="preserve">
          <source>An output iterator that writes successive elements into an output stream, separating adjacent elements with a delimiter</source>
          <target state="translated">一个输出迭代器,将连续的元素写入一个输出流中,用定界符分隔相邻的元素。</target>
        </trans-unit>
        <trans-unit id="7c1bcb6f6b9e1950eeb340e7b5a97c8ee444cb42" translate="yes" xml:space="preserve">
          <source>An output iterator to element past the last element copied.</source>
          <target state="translated">迭代器输出到最后一个被复制的元素。</target>
        </trans-unit>
        <trans-unit id="dc7304d0df5442d14acbaafb1a4c43fd8d0d9ec3" translate="yes" xml:space="preserve">
          <source>An overload &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if the declaration &lt;code&gt;T_i x[] = { &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t) };&lt;/code&gt; is valid for some invented variable &lt;code&gt;x&lt;/code&gt;;</source>
          <target state="translated">仅当声明 &lt;code&gt;T_i x[] = { &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t) };&lt;/code&gt; &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;T&amp;gt;（t）}时才考虑重载 &lt;code&gt;F(T_i)&lt;/code&gt; ；对于某些发明变量 &lt;code&gt;x&lt;/code&gt; 有效；</target>
        </trans-unit>
        <trans-unit id="31a89ff54bf0a65e07ec5e6290a30f27bf9c83bf" translate="yes" xml:space="preserve">
          <source>An rvalue can't be used as the left-hand operand of the built-in assignment or compound assignment operators.</source>
          <target state="translated">r值不能作为内置赋值或复合赋值运算符的左手操作数。</target>
        </trans-unit>
        <trans-unit id="df8a77695e43a01d35ff3833e595deae1c70885b" translate="yes" xml:space="preserve">
          <source>An rvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize a const lvalue reference&lt;/a&gt;, in which case the lifetime of the object identified by the rvalue is &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extended&lt;/a&gt; until the scope of the reference ends.</source>
          <target state="translated">右值可用于&lt;a href=&quot;reference_initialization&quot;&gt;初始化const左值引用&lt;/a&gt;，在这种情况下，由右值标识的对象的生存期将&lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;延长，&lt;/a&gt;直到引用范围终止。</target>
        </trans-unit>
        <trans-unit id="0e072674017d2ac839c66e65b949d44d2466050e" translate="yes" xml:space="preserve">
          <source>An rvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize an rvalue reference&lt;/a&gt;, in which case the lifetime of the object identified by the rvalue is &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extended&lt;/a&gt; until the scope of the reference ends.</source>
          <target state="translated">右值可用于&lt;a href=&quot;reference_initialization&quot;&gt;初始化右值引用&lt;/a&gt;，在这种情况下，由右值标识的对象的生存期将&lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;延长，&lt;/a&gt;直到引用范围终止。</target>
        </trans-unit>
        <trans-unit id="9223b2493a48ecf49ed1c32238f5defa3e17a1e2" translate="yes" xml:space="preserve">
          <source>An rvalue reference to a cv-unqualified template parameter is not a &lt;a href=&quot;template_argument_deduction&quot;&gt;forwarding reference&lt;/a&gt; if that parameter is a class template parameter:</source>
          <target state="translated">如果cv-unqualified模板参数的右值引用是类模板参数，则它不是&lt;a href=&quot;template_argument_deduction&quot;&gt;转发引用&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="06c47888799c4beade0a1c880e7969d048a047e7" translate="yes" xml:space="preserve">
          <source>An rvalue reference to the element at relative location, that is, &lt;code&gt;std::move(base()[n])&lt;/code&gt;.</source>
          <target state="translated">对元素在相对位置的右值引用，即 &lt;code&gt;std::move(base()[n])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4431ce6b5c54a2464689bcd2649d6be6a6d6edb5" translate="yes" xml:space="preserve">
          <source>Analyzes the character sequence &lt;code&gt;[first,last)&lt;/code&gt; for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">分析下面描述的模式的字符序列 &lt;code&gt;[first,last)&lt;/code&gt; 。如果没有字符匹配的模式，或者如果通过解析匹配的字符而获得的值是不是在该类型表示的 &lt;code&gt;value&lt;/code&gt; ， &lt;code&gt;value&lt;/code&gt; 是未经修饰的，否则的图案匹配的字符被解释为一个算术值，其被存储在文本表示 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ffd735c77a58f5bee4802f3701c7f6fda3f232e" translate="yes" xml:space="preserve">
          <source>And after evaluation, the value of &lt;code&gt;*p&lt;/code&gt; is equivalent to the value formerly held by &lt;code&gt;rv&lt;/code&gt; (&lt;code&gt;rv&lt;/code&gt; remains valid, but is in an unspecified state.).</source>
          <target state="translated">经过评估， &lt;code&gt;*p&lt;/code&gt; 的值等于 &lt;code&gt;rv&lt;/code&gt; 先前保留的值（ &lt;code&gt;rv&lt;/code&gt; 保持有效，但处于未指定状态）。</target>
        </trans-unit>
        <trans-unit id="a5b3b63e68ab039e5e9a76fb79b51bc5995bb988" translate="yes" xml:space="preserve">
          <source>And after evaluation, the value of &lt;code&gt;*p&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;. The value of &lt;code&gt;v&lt;/code&gt; is unchanged.</source>
          <target state="translated">经过评估， &lt;code&gt;*p&lt;/code&gt; 的值等于 &lt;code&gt;v&lt;/code&gt; 的值。 &lt;code&gt;v&lt;/code&gt; 的值不变。</target>
        </trans-unit>
        <trans-unit id="56b1a77f4fe21b0570e2813c8d454db94a7cb374" translate="yes" xml:space="preserve">
          <source>And if any &lt;a href=&quot;reference_initialization&quot;&gt;reference binding&lt;/a&gt; takes place, it is direct binding (not one that constructs a temporary object)</source>
          <target state="translated">而且，如果发生任何&lt;a href=&quot;reference_initialization&quot;&gt;引用绑定&lt;/a&gt;，则它是直接绑定（不是构造临时对象的绑定）</target>
        </trans-unit>
        <trans-unit id="c4c1b28f8418245c8009d38e2fd06aa2b822e70b" translate="yes" xml:space="preserve">
          <source>And, for every.</source>
          <target state="translated">而且,对于每。</target>
        </trans-unit>
        <trans-unit id="c8cb4cc17edf8c49a6c05da36754f248647a5429" translate="yes" xml:space="preserve">
          <source>And, given.</source>
          <target state="translated">而且,鉴于。</target>
        </trans-unit>
        <trans-unit id="78f82f2df8d5e45692f017f6cf128f97529f9a02" translate="yes" xml:space="preserve">
          <source>Anonymous unions</source>
          <target state="translated">匿名工会</target>
        </trans-unit>
        <trans-unit id="f39f69aff078c2dee33a0b3c3af4837d3936bb7c" translate="yes" xml:space="preserve">
          <source>Anonymous unions have further restrictions: they cannot have member functions, cannot have static data members, and all their data members must be public. The only declarations allowed are non-static data members  and &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; declarations(since C++14).</source>
          <target state="translated">匿名联合具有进一步的限制：它们不能具有成员函数，不能具有静态数据成员，并且其所有数据成员必须是公共的。允许的唯一声明是非静态数据成员和&lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt;声明（自C ++ 14起）。</target>
        </trans-unit>
        <trans-unit id="79c7bbc8f686393ed4d5a563735506c51a1b8513" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;std::weak_ptr&lt;/code&gt; is to break reference cycles formed by objects managed by &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle can be made weak.</source>
          <target state="translated">&lt;code&gt;std::weak_ptr&lt;/code&gt; 另一个用途是打破由 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 管理的对象形成的参考周期。如果这样的循环是孤立的（即该循环中没有外部共享指针），则shared_ptr参考计数不能达到零，并且内存泄漏。为了防止这种情况，可以使循环中的指针之一变弱。</target>
        </trans-unit>
        <trans-unit id="899d67ebfae429b08b8eebcf8e8c9e086747304a" translate="yes" xml:space="preserve">
          <source>Another way to test if a floating-point value is NaN is to compare it with itself: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</source>
          <target state="translated">测试浮点值是否为NaN的另一种方法是将其与自身进行比较： &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f898bf7d5a8e88530be0282c53c70a4902e14d0" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;declarations&quot;&gt;simple declarations&lt;/a&gt; are allowed, except.</source>
          <target state="translated">允许使用任何&lt;a href=&quot;declarations&quot;&gt;简单的声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7e1bdbe6a7f8ce733280e2254188bf3b1de8cb1" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;function&quot;&gt;function declarations&lt;/a&gt; are allowed, with additional syntax elements that are only available for non-static member functions: &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; and &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; specifiers, &lt;a href=&quot;abstract_class&quot;&gt;pure-specifiers&lt;/a&gt;, cv-qualifiers, ref-qualifiers, and &lt;a href=&quot;constructor&quot;&gt;member initialization lists&lt;/a&gt;.</source>
          <target state="translated">允许任何&lt;a href=&quot;function&quot;&gt;函数声明&lt;/a&gt;，以及仅适用于非静态成员函数的其他语法元素：&lt;a href=&quot;final&quot;&gt;最终&lt;/a&gt;和&lt;a href=&quot;override&quot;&gt;重写&lt;/a&gt;说明符，&lt;a href=&quot;abstract_class&quot;&gt;纯说明符&lt;/a&gt;，cv限定符，引用限定符和&lt;a href=&quot;constructor&quot;&gt;成员初始化列表&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8b49f8c4e0a542030094cffe671da5baa163695a" translate="yes" xml:space="preserve">
          <source>Any additional integral types needed by the typedefs in the header &lt;a href=&quot;../header/cstdint&quot;&gt;&lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">标头&lt;a href=&quot;../header/cstdint&quot;&gt; &lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt; 中&lt;/a&gt; typedef所需的任何其他整数类型。</target>
        </trans-unit>
        <trans-unit id="f08aea9a890f019823885a1075301ba39bc58d28" translate="yes" xml:space="preserve">
          <source>Any capture may appear only once:</source>
          <target state="translated">任何捕捉只能出现一次。</target>
        </trans-unit>
        <trans-unit id="a6942cddecd7def2bc3a413a01b71ac46c41eb7d" translate="yes" xml:space="preserve">
          <source>Any character in the buffer which has been initialized, regardless of whether it originated from the string passed in the constructor or was appended by &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, is considered to be part of the input sequence.</source>
          <target state="translated">缓冲区中任何已初始化的字符，无论它是源自构造函数中传递的字符串还是由 &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 附加，都被视为输入序列的一部分。</target>
        </trans-unit>
        <trans-unit id="6e77be05deb9b5ecac58519844a0e640e7f8ea02" translate="yes" xml:space="preserve">
          <source>Any character sequence, except that it must not contain the closing sequence &lt;code&gt;)&lt;/code&gt;delimiter&lt;code&gt;&quot;&lt;/code&gt;</source>
          <target state="translated">任何字符序列，除了不能包含结束序列 &lt;code&gt;)&lt;/code&gt; 分隔符 &lt;code&gt;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8037bc5cabc21aa1e4b299af2223a57b399d0e7" translate="yes" xml:space="preserve">
          <source>Any class type (whether declared with class-key&lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt;) may be declared as</source>
          <target state="translated">任何类类型（无论是使用class-key &lt;code&gt;class&lt;/code&gt; 还是 &lt;code&gt;struct&lt;/code&gt; 声明）都可以声明为</target>
        </trans-unit>
        <trans-unit id="3f8220613774bb0009e4140293deea0ebc75659a" translate="yes" xml:space="preserve">
          <source>Any declaration with an &lt;code&gt;extern&lt;/code&gt;&lt;a href=&quot;storage_duration&quot;&gt;storage class specifier&lt;/a&gt; or with a &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; specifier (such as &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;) without an initializer</source>
          <target state="translated">具有 &lt;code&gt;extern&lt;/code&gt; &lt;a href=&quot;storage_duration&quot;&gt;存储类说明符&lt;/a&gt;或具有&lt;a href=&quot;language_linkage&quot;&gt;语言链接&lt;/a&gt;说明符（例如 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; ）而没有初始化程序的任何声明</target>
        </trans-unit>
        <trans-unit id="7246de96efdd56306a5b292694e0b51ddecb8395" translate="yes" xml:space="preserve">
          <source>Any entity captured by a lambda (implicitly or explicitly) is odr-used by the lambda-expression (therefore, implicit capture by a nested lambda triggers implicit capture in the enclosing lambda).</source>
          <target state="translated">任何被lambda捕获的实体(隐式或显式)都会被lambda表达式odr使用(因此,一个嵌套lambda的隐式捕获会触发包围lambda的隐式捕获)。</target>
        </trans-unit>
        <trans-unit id="2989809a7b8d0c13f3bc5dcda54fae5845e8e939" translate="yes" xml:space="preserve">
          <source>Any exception thrown by &lt;code&gt;Clock&lt;/code&gt; or &lt;code&gt;Duration&lt;/code&gt; (clocks and durations provided by the standard library never throw).</source>
          <target state="translated">&lt;code&gt;Clock&lt;/code&gt; 或 &lt;code&gt;Duration&lt;/code&gt; 抛出的任何异常（标准库提供的Clock和Duration均不会抛出）。</target>
        </trans-unit>
        <trans-unit id="0155546b454eb352e396af9a9583e45239059529" translate="yes" xml:space="preserve">
          <source>Any exception thrown by clock, time point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).</source>
          <target state="translated">在执行过程中由时钟、时间点或持续时间抛出的任何异常(标准库提供的时钟、时间点和持续时间从不抛出)。</target>
        </trans-unit>
        <trans-unit id="c2829040c4ec83947a1f6cbfdec13c1bbc1b434c" translate="yes" xml:space="preserve">
          <source>Any exception thrown by clock, time_point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).</source>
          <target state="translated">在执行过程中,由时钟、时间点或持续时间抛出的任何异常(标准库提供的时钟、时间点和持续时间从不抛出)。</target>
        </trans-unit>
        <trans-unit id="c01d2aae1c56f6c1e27461994e6f980f695234ee" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the selected constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, &lt;code&gt;*this&lt;/code&gt; does not contain a value after this call (the previously contained value, if any, had been destroyed).</source>
          <target state="translated">所选 &lt;code&gt;T&lt;/code&gt; 的构造方法引发的任何异常。如果抛出异常，则 &lt;code&gt;*this&lt;/code&gt; 在此调用之后不包含任何值（先前包含的值（如有）已被破坏）。</target>
        </trans-unit>
        <trans-unit id="9f5d991a2059cb95872e45c2fc73f5d2c5d644d5" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the selected constructor of the return value &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">选定的返回值 &lt;code&gt;T&lt;/code&gt; 的构造方法引发的任何异常。</target>
        </trans-unit>
        <trans-unit id="8272c2eb0b4b3a47c1fd6266b118d8e0b7dc16c2" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the swap of the &lt;code&gt;Compare&lt;/code&gt; objects.</source>
          <target state="translated">由 &lt;code&gt;Compare&lt;/code&gt; 对象的交换引发的任何异常。</target>
        </trans-unit>
        <trans-unit id="067dbafb29590e30db3698223b8289c3ba3a81cd" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the swap of the &lt;code&gt;Hash&lt;/code&gt; or &lt;code&gt;KeyEqual&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;Hash&lt;/code&gt; 或 &lt;code&gt;KeyEqual&lt;/code&gt; 对象的交换引发的任何异常。</target>
        </trans-unit>
        <trans-unit id="3ee3642fda89a9c4f4d022a23e66f5f0e3c59796" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt; 抛出的任何异常</target>
        </trans-unit>
        <trans-unit id="b6634d37c80775a0920996e88d7df6e338b295bf" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt; 抛出的任何异常</target>
        </trans-unit>
        <trans-unit id="a87dda0d2400f372bf7fe2820ca303981427bec3" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; (&lt;a href=&quot;../../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; types do not throw in &lt;code&gt;try_lock&lt;/code&gt;, but a custom &lt;a href=&quot;../../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; might)</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; 引发的任何异常（&lt;a href=&quot;../../named_req/mutex&quot;&gt;Mutex&lt;/a&gt;类型不会在 &lt;code&gt;try_lock&lt;/code&gt; 中引发，但自定义&lt;a href=&quot;../../named_req/lockable&quot;&gt;Lockable&lt;/a&gt;可能会）</target>
        </trans-unit>
        <trans-unit id="655f412d1dcbf9a4b5e59996ea72d45e509cebc3" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt; 抛出的任何异常</target>
        </trans-unit>
        <trans-unit id="7e00b1d47fa13181989c95392d4568f3ce99f9b2" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt; 抛出的任何异常</target>
        </trans-unit>
        <trans-unit id="fbacb0aafa934213b8105430ca644b8c44fceb18" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt; 抛出的任何异常</target>
        </trans-unit>
        <trans-unit id="29577e958473f7848749dbde1c0fe41d4d28de86" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_time)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_time)&lt;/code&gt; 抛出的任何异常</target>
        </trans-unit>
        <trans-unit id="3c13a79f4c3e26012d9358714b624c43671f4909" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_until(timeout_time)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;try_lock_until(timeout_time)&lt;/code&gt; 抛出的任何异常</target>
        </trans-unit>
        <trans-unit id="50c476323ba0569c33a9d73cfd698b2849a0d7de" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;unlock()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;unlock()&lt;/code&gt; 抛出的任何异常</target>
        </trans-unit>
        <trans-unit id="dde4d98fe163593f45905da9796164d4135b2aa5" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt; 引发的任何异常</target>
        </trans-unit>
        <trans-unit id="46aca186f0d5118e57ea1ec2d858f1e279a474ac" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by the copy constructors of &lt;code&gt;BinaryPredicate&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BinaryPredicate&lt;/code&gt; 或 &lt;code&gt;ForwardIt&lt;/code&gt; 的副本构造函数引发的任何异常。</target>
        </trans-unit>
        <trans-unit id="4d35da87105417bd2f8dd9b5f22cbdf22b00eefe" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by.</source>
          <target state="translated">抛出的任何例外情况。</target>
        </trans-unit>
        <trans-unit id="ae8214fbedcd7b7b2c7806d56b17165dfe143da7" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown from iterator operations or the element swap.</source>
          <target state="translated">从迭代器操作或元素交换中抛出的任何异常。</target>
        </trans-unit>
        <trans-unit id="39254fcd3fdb015be0ee13d463da04333fcb57d3" translate="yes" xml:space="preserve">
          <source>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator. Parentheses preserve value, type, and value category.</source>
          <target state="translated">括号中的任何表达式也被归为主表达式:这保证了括号的优先级高于任何运算符。小括号保留了值、类型和值类别。</target>
        </trans-unit>
        <trans-unit id="60455d87fc053fc9392b56ddecf2d39bad868244" translate="yes" xml:space="preserve">
          <source>Any instance of &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; at any given point in time either</source>
          <target state="translated">在任何给定时间点的 &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; 任何实例</target>
        </trans-unit>
        <trans-unit id="d6460fec33d2d5219b69f7a6eebb68fbfc2a92cb" translate="yes" xml:space="preserve">
          <source>Any lvalue or rvalue of this type can be swapped with any lvalue or rvalue of some other type, using unqualified function call &lt;code&gt;swap()&lt;/code&gt; in the context where both &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; and the user-defined &lt;code&gt;swap()&lt;/code&gt;s are visible.</source>
          <target state="translated">可以在可见 &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 和用户定义的 &lt;code&gt;swap()&lt;/code&gt; 的上下文中使用不合格的函数调用 &lt;code&gt;swap()&lt;/code&gt; 来将这种类型的任何左值或右值与某种其他类型的左值或右值交换。</target>
        </trans-unit>
        <trans-unit id="6091484d7bf355dd0cb949cd776657171718f832" translate="yes" xml:space="preserve">
          <source>Any member that could not be determined is set to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt;</source>
          <target state="translated">任何无法确定的成员都设置为 &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74a03ddfcb26a95ca3f318466c08e7e95a815c27" translate="yes" xml:space="preserve">
          <source>Any number of access specifiers may appear within a class, in any order. Member access specifiers may affect class layout: the addresses of non-static &lt;a href=&quot;data_members#Layout&quot;&gt;data members&lt;/a&gt; are only guaranteed to increase in order of declaration for the members with the same access. For &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;, all non-static data members must have the same access.</source>
          <target state="translated">一个类中可以按任何顺序出现任意数量的访问说明符。成员访问说明符可能会影响类的布局：非静态&lt;a href=&quot;data_members#Layout&quot;&gt;数据成员&lt;/a&gt;的地址仅保证按具有相同访问权限的成员的声明顺序增加。对于&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;，所有非静态数据成员必须具有相同的访问权限。</target>
        </trans-unit>
        <trans-unit id="a64cd75ae326e1b045aa2b1398be8083184efecf" translate="yes" xml:space="preserve">
          <source>Any of the following can be fully specialized:</source>
          <target state="translated">以下任何一项都可以完全专业化。</target>
        </trans-unit>
        <trans-unit id="437e7790370da61d174fe4d318acf7c074ede85b" translate="yes" xml:space="preserve">
          <source>Any of the following contexts requires class &lt;code&gt;T&lt;/code&gt; to be complete:</source>
          <target state="translated">以下任何上下文均要求类 &lt;code&gt;T&lt;/code&gt; 是完整的：</target>
        </trans-unit>
        <trans-unit id="104d110bb41e8701d9fe7c539eb86ce87b612d21" translate="yes" xml:space="preserve">
          <source>Any of the following names declared at namespace scope have external linkage unless the namespace is unnamed or is contained within an unnamed namespace(since C++11):</source>
          <target state="translated">在命名空间作用域中声明的以下任何名称都有外部链接,除非该命名空间未命名或包含在未命名的命名空间中(自C++11起)。</target>
        </trans-unit>
        <trans-unit id="5407990c5239cdd7bd6ef99bf9f9a20fd8e6527f" translate="yes" xml:space="preserve">
          <source>Any of the following names first declared at block scope have external linkage:</source>
          <target state="translated">在块作用域首先声明的以下任何名称都有外部链接。</target>
        </trans-unit>
        <trans-unit id="3238703010dee73fdace47f181589c27f2e4d0de" translate="yes" xml:space="preserve">
          <source>Any of the six two-way relational operators can be explicitly defaulted. A defaulted relational operator must have the return type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">六个双向关系运算符中的任何一个都可以显式默认。默认的关系运算符必须具有返回类型 &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="904ac65505544c6e1c0c9dffcf96e6454f73cb6f" translate="yes" xml:space="preserve">
          <source>Any other combination of encoding prefixes may or may not be supported by the implementation. The result of such a concatenation is implementation-defined.</source>
          <target state="translated">编码前缀的任何其他组合可能会或可能不会被实现所支持。这种组合的结果由实施者确定。</target>
        </trans-unit>
        <trans-unit id="0401aa15a157b543ba80abd41cb54281ed03d456" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#include&lt;/code&gt;and &lt;code&gt;__has_include&lt;/code&gt;(since C++17) as long as they expand to a sequence of characters surrounded by &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt;&lt;code&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">任何预处理标记（宏常量或表达式）都可以作为 &lt;code&gt;#include&lt;/code&gt; 和 &lt;code&gt;__has_include&lt;/code&gt; （自C ++ 17起）的参数，只要它们扩展为由 &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&quot;&lt;/code&gt; &lt;code&gt;&quot;&lt;/code&gt; 包围的字符序列即可。</target>
        </trans-unit>
        <trans-unit id="52919eaf1eb62c0854fdd694ccfd8a6c2a0705b3" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#line&lt;/code&gt; as long as they expand to a valid decimal integer optionally following a valid character string.</source>
          <target state="translated">任何预处理标记（宏常量或表达式）都可以用作 &lt;code&gt;#line&lt;/code&gt; 的参数，只要它们扩展为有效的十进制整数（可以选择在有效字符串之后）即可。</target>
        </trans-unit>
        <trans-unit id="8a80f56d370810d05ed5b7f500aef83276b2b56b" translate="yes" xml:space="preserve">
          <source>Any random number engine is also a &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;, and therefore may be plugged into any &lt;a href=&quot;../numeric/random&quot;&gt;random number distribution&lt;/a&gt; in order to obtain a random number (formally, a random variate).</source>
          <target state="translated">任何随机数引擎也是&lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;，因此可以将其插入任何&lt;a href=&quot;../numeric/random&quot;&gt;随机数分布&lt;/a&gt;中以获得随机数（形式上是随机变量）。</target>
        </trans-unit>
        <trans-unit id="25328abef95d7bd06cd8ccb115014d680f4af1fb" translate="yes" xml:space="preserve">
          <source>Any reads or writes to a bitset that happen via a &lt;code&gt;std::bitset::reference&lt;/code&gt; potentially read or write to the entire underlying bitset.</source>
          <target state="translated">通过 &lt;code&gt;std::bitset::reference&lt;/code&gt; 任何对位集的读取或写入都可能对整个基础位集进行读取或写入。</target>
        </trans-unit>
        <trans-unit id="ce62d6fd6228c7ed0a629a27ad487d906ba0cf6e" translate="yes" xml:space="preserve">
          <source>Any reads or writes to a vector that happen via a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; potentially read or write to the entire underlying vector.</source>
          <target state="translated">任何通过 &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; 进行的矢量读取或写入都可能会读取或写入整个基础矢量。</target>
        </trans-unit>
        <trans-unit id="79d69f3522c40f28b11ac3de0d09461ee1623eb9" translate="yes" xml:space="preserve">
          <source>Any return value from the function is ignored. If the function throws an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. In order to pass return values or exceptions back to the calling thread, &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">该函数的所有返回值都将被忽略。如果函数抛出异常，则调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。为了将返回值或异常传递回调用线程，可以使用 &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65591f30b00907d381312a521d81c7b5924c3ee3" translate="yes" xml:space="preserve">
          <source>Any shared state is released. &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; after a call to this method.</source>
          <target state="translated">任何共享状态都被释放。调用此方法后， &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="594a9e7004e035507b2faafb30d5238be37f382a" translate="yes" xml:space="preserve">
          <source>Any statement can be</source>
          <target state="translated">任何声明都可以是</target>
        </trans-unit>
        <trans-unit id="569389483a39353b7174754570a587d2d30d7a93" translate="yes" xml:space="preserve">
          <source>Any thread can potentially access any object in the program (objects with automatic and thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; may still be accessed by another thread through a pointer or by reference).</source>
          <target state="translated">任何线程都可以潜在地访问程序中的任何对象（具有自动和线程本地&lt;a href=&quot;storage_duration&quot;&gt;存储持续时间的&lt;/a&gt;对象仍然可以由另一个线程通过指针或引用来访问）。</target>
        </trans-unit>
        <trans-unit id="c56361a71bf85ab91f9c4ec67339965aa7d1d832" translate="yes" xml:space="preserve">
          <source>Any thread that intends to wait on &lt;code&gt;std::condition_variable&lt;/code&gt; has to.</source>
          <target state="translated">任何打算在 &lt;code&gt;std::condition_variable&lt;/code&gt; 上等待的线程都必须这样做。</target>
        </trans-unit>
        <trans-unit id="a27b17e4a874eb86d62efa02b876f52b84cb2492" translate="yes" xml:space="preserve">
          <source>Any two objects with overlapping &lt;a href=&quot;lifetime&quot;&gt;lifetimes&lt;/a&gt; (that are not &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;) are guaranteed to have different addresses unless one of them is a subobject of another or provides storage for another, or if they are subobjects of different type within the same complete object, and one of them is a subobject of zero size.</source>
          <target state="translated">&lt;a href=&quot;lifetime&quot;&gt;生命周期&lt;/a&gt;重叠的任何两个对象（不是&lt;a href=&quot;bit_field&quot;&gt;位字段&lt;/a&gt;）都保证具有不同的地址，除非其中一个是另一个的子对象或为另一个提供存储，或者它们是同一完整对象中不同类型的子对象，并且一个其中的一个是大小为零的子对象。</target>
        </trans-unit>
        <trans-unit id="747805bfa6e2b47c753f371046684998f5739c7b" translate="yes" xml:space="preserve">
          <source>Any use of a pointer that became invalid in this manner, even copying the pointer value into another variable, is undefined behavior.</source>
          <target state="translated">任何以这种方式变得无效的指针的使用,甚至将指针值复制到另一个变量中,都是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="edb0075febb6c810a733225d843cfc260a841379" translate="yes" xml:space="preserve">
          <source>Any valid character except the double-quote &lt;code&gt;&quot;&lt;/code&gt;, backslash &lt;code&gt;\&lt;/code&gt;, or new-line character</source>
          <target state="translated">除双引号 &lt;code&gt;&quot;&lt;/code&gt; ，反斜杠 &lt;code&gt;\&lt;/code&gt; 或换行符外的任何有效字符</target>
        </trans-unit>
        <trans-unit id="1b24babb1df893acf8a8a6efb01913ddf0bd9397" translate="yes" xml:space="preserve">
          <source>Appear in any type specifier, including decl-specifier-seq of &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt;, to specify constness or volatility of the object being declared or of the type being named.</source>
          <target state="translated">出现在任何类型说明符中，包括&lt;a href=&quot;declarations&quot;&gt;声明语法的&lt;/a&gt; decl-specifier-seq ，以指定要声明的对象或命名类型的常量性或易变性。</target>
        </trans-unit>
        <trans-unit id="b3cea74b8699d0d5592fcdb76824dfd00b7a1900" translate="yes" xml:space="preserve">
          <source>Appears in a function declaration, enumeration declaration, or class declaration.</source>
          <target state="translated">出现在函数声明、枚举声明或类声明中。</target>
        </trans-unit>
        <trans-unit id="1f41b36bd2867522723d540cbaf10ea09210fdf2" translate="yes" xml:space="preserve">
          <source>Append to a file</source>
          <target state="translated">添加到文件中</target>
        </trans-unit>
        <trans-unit id="185b3e5c1287dbe88e91911ebf09f0289a09ed1c" translate="yes" xml:space="preserve">
          <source>Append to file</source>
          <target state="translated">附加到文件中</target>
        </trans-unit>
        <trans-unit id="7727ad0dfc1361a3b9a9f16594166faee13a49d3" translate="yes" xml:space="preserve">
          <source>Appends a &lt;code&gt;T&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;</source>
          <target state="translated">附加一个用 &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; &amp;lt;Args&amp;gt;（args）构造的 &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa8f7a6232502ff61b9f355b8192a149bda0bdd" translate="yes" xml:space="preserve">
          <source>Appends a byte string pointed to by &lt;code&gt;src&lt;/code&gt; to a byte string pointed to by &lt;code&gt;dest&lt;/code&gt;. At most &lt;code&gt;count&lt;/code&gt; characters are copied. The resulting byte string is null-terminated.</source>
          <target state="translated">将 &lt;code&gt;src&lt;/code&gt; 指向的字节字符串追加到 &lt;code&gt;dest&lt;/code&gt; 指向的字节字符串。在大多数 &lt;code&gt;count&lt;/code&gt; 字符复制。产生的字节字符串以空值结尾。</target>
        </trans-unit>
        <trans-unit id="c89f8ba239ec205d14a709567d6066df8a0d1451" translate="yes" xml:space="preserve">
          <source>Appends a copy of &lt;code&gt;rv&lt;/code&gt;, possibly using move semantics</source>
          <target state="translated">附加 &lt;code&gt;rv&lt;/code&gt; 的副本，可能使用move语义</target>
        </trans-unit>
        <trans-unit id="93a15a35c8298c01ed0b17fc08d04c4607bfeb7b" translate="yes" xml:space="preserve">
          <source>Appends a copy of &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">附加 &lt;code&gt;t&lt;/code&gt; 的副本</target>
        </trans-unit>
        <trans-unit id="0749406f25dc8bfe01326e6508ea40f8ccdfe8f5" translate="yes" xml:space="preserve">
          <source>Appends a copy of the character string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;. The character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting byte string is null-terminated.</source>
          <target state="translated">将 &lt;code&gt;src&lt;/code&gt; 指向的字符串的副本追加到 &lt;code&gt;dest&lt;/code&gt; 指向的字符串的末尾。字符 &lt;code&gt;src[0]&lt;/code&gt; 替换 &lt;code&gt;dest&lt;/code&gt; 末尾的空终止符。产生的字节字符串以空值结尾。</target>
        </trans-unit>
        <trans-unit id="0f3b244f19389096a59b50d552c3a3947e4ec319" translate="yes" xml:space="preserve">
          <source>Appends a copy of the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting wide string is null-terminated.</source>
          <target state="translated">将 &lt;code&gt;src&lt;/code&gt; 指向的宽字符串的副本追加到 &lt;code&gt;dest&lt;/code&gt; 指向的宽字符串的末尾。宽字符 &lt;code&gt;src[0]&lt;/code&gt; 替换 &lt;code&gt;dest&lt;/code&gt; 末尾的空终止符。产生的宽字符串以null终止。</target>
        </trans-unit>
        <trans-unit id="ee76f2e6383e182374a1ac158b3fb988871f2017" translate="yes" xml:space="preserve">
          <source>Appends a new element to the end of the container. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">将新元素附加到容器的末尾。该元素是通过 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; ，通常使用placement-new在容器提供的位置就地构造该元素。参数 &lt;code&gt;args...&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 转发给构造函数。</target>
        </trans-unit>
        <trans-unit id="3769354c56bdf441401d30ffbfd485d11afed226" translate="yes" xml:space="preserve">
          <source>Appends additional characters to the string.</source>
          <target state="translated">在字符串中添加额外的字符。</target>
        </trans-unit>
        <trans-unit id="9435c7778f8168db6ddee793e51647858e33337b" translate="yes" xml:space="preserve">
          <source>Appends at most &lt;code&gt;count&lt;/code&gt; wide characters from the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;, stopping if the null terminator is copied. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is &lt;code&gt;count+1&lt;/code&gt;).</source>
          <target state="translated">从 &lt;code&gt;src&lt;/code&gt; 指向的宽字符串到 &lt;code&gt;dest&lt;/code&gt; 指向的字符串的末尾最多添加 &lt;code&gt;count&lt;/code&gt; 个宽字符，如果复制了空终止符，则停止。宽字符 &lt;code&gt;src[0]&lt;/code&gt; 替换 &lt;code&gt;dest&lt;/code&gt; 末尾的空终止符。空终止符总是附加在末尾（因此该函数可以写入的最大宽字符 &lt;code&gt;count+1&lt;/code&gt; 为count + 1）。</target>
        </trans-unit>
        <trans-unit id="616d6d1b2db8c5cbc5b78e6729f280f6ef9cde21" translate="yes" xml:space="preserve">
          <source>Appends the character &lt;code&gt;c&lt;/code&gt; to the output character sequence.</source>
          <target state="translated">将字符 &lt;code&gt;c&lt;/code&gt; 附加到输出字符序列。</target>
        </trans-unit>
        <trans-unit id="97e86c02631fb97ad63c305dc2c6744a765ce0c5" translate="yes" xml:space="preserve">
          <source>Appends the character &lt;code&gt;c&lt;/code&gt; to the put area of the buffer, reallocating if possible.</source>
          <target state="translated">将字符 &lt;code&gt;c&lt;/code&gt; 追加到缓冲区的放置区域，并在可能的情况下重新分配。</target>
        </trans-unit>
        <trans-unit id="532328072ae734b050324e7bd55974ecc3a7470f" translate="yes" xml:space="preserve">
          <source>Appends the given character &lt;code&gt;ch&lt;/code&gt; to the end of the string.</source>
          <target state="translated">将给定字符 &lt;code&gt;ch&lt;/code&gt; 追加到字符串的末尾。</target>
        </trans-unit>
        <trans-unit id="cfc483d3db69eff6dcd82b004d3786722b9a1849" translate="yes" xml:space="preserve">
          <source>Appends the given element &lt;code&gt;value&lt;/code&gt; to the end of the container.</source>
          <target state="translated">将给定的元素 &lt;code&gt;value&lt;/code&gt; 附加到容器的末尾。</target>
        </trans-unit>
        <trans-unit id="d2c0fb94e5cddaf445eca7c3640f9ada9fb6e2a7" translate="yes" xml:space="preserve">
          <source>Applied to</source>
          <target state="translated">适用于</target>
        </trans-unit>
        <trans-unit id="cbd47fe22d148dd069a031976318ab7fb6d631c4" translate="yes" xml:space="preserve">
          <source>Applies compound assignment operators to each element in the numeric array.</source>
          <target state="translated">将复合赋值运算符应用于数字数组中的每个元素。</target>
        </trans-unit>
        <trans-unit id="bc6e0092dfd47ac0f36260b8d91a3704f6cc8726" translate="yes" xml:space="preserve">
          <source>Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type &lt;code&gt;T&lt;/code&gt;, removes cv-qualifiers, and defines the resulting type as the member typedef &lt;code&gt;type&lt;/code&gt;. Formally:</source>
          <target state="translated">将左值到右值，数组到指针和函数到指针的隐式转换应用于类型 &lt;code&gt;T&lt;/code&gt; ，删除cv限定符，并将结果类型定义为成员typedef &lt;code&gt;type&lt;/code&gt; 。正式地：</target>
        </trans-unit>
        <trans-unit id="71f4ff319120444a2809431ede654e171b067641" translate="yes" xml:space="preserve">
          <source>Applies the corresponding operation to the referred elements and the elements of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">将相应的操作应用于所引用的元素和 &lt;code&gt;other&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="27d8e4e4d1d2e00786c12ccc2c42604642524bdd" translate="yes" xml:space="preserve">
          <source>Applies the unary operators to the year value.</source>
          <target state="translated">将单数运算符应用于年值。</target>
        </trans-unit>
        <trans-unit id="a0cc3e98fe133b6a125be7a1095a1e4722d59951" translate="yes" xml:space="preserve">
          <source>Applies the visitor &lt;code&gt;vis&lt;/code&gt; to the variants &lt;code&gt;vars&lt;/code&gt;.</source>
          <target state="translated">适用访问者 &lt;code&gt;vis&lt;/code&gt; 的变种 &lt;code&gt;vars&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="767013b70c83389088a9d12acdf6717a821be569" translate="yes" xml:space="preserve">
          <source>Applies to the name being declared in a function declaration, which must be the first declaration of the function.</source>
          <target state="translated">适用于在函数声明中声明的名称,它必须是函数的第一个声明。</target>
        </trans-unit>
        <trans-unit id="0463466b4fbb2abaeda54896e7f772d38769d910" translate="yes" xml:space="preserve">
          <source>Applies to the name being declared in the declaration of a non-static data member that's not a bit field.</source>
          <target state="translated">适用于非静态数据成员声明中被声明的名称,该名称不是位字段。</target>
        </trans-unit>
        <trans-unit id="c80f073f7430ca362ef718e10efb9033f924c369" translate="yes" xml:space="preserve">
          <source>Applies unary operators to each element in the numeric array.</source>
          <target state="translated">对数字数组中的每个元素进行单调运算。</target>
        </trans-unit>
        <trans-unit id="4b03880d31fcc803c8ff4f90e7d09f01a683bd9e" translate="yes" xml:space="preserve">
          <source>Apply binary operators to each element of two valarrays, or a valarray and a value.</source>
          <target state="translated">将二进制运算符应用于两个值的每个元素,或一个值和一个值。</target>
        </trans-unit>
        <trans-unit id="68fcd04d7e11c3d0bcd63b86035531ef6f69e2ba" translate="yes" xml:space="preserve">
          <source>Applying &lt;a href=&quot;cv&quot;&gt;cv-qualifiers&lt;/a&gt; to an array type (through typedef or template type manipulation) applies the qualifiers to the element type, but any array type whose elements are of cv-qualified type is considered to have the same cv-qualification.</source>
          <target state="translated">将&lt;a href=&quot;cv&quot;&gt;cv限定符&lt;/a&gt;应用于数组类型（通过typedef或模板类型操纵）将限定符应用于元素类型，但是任何元素属于cv限定类型的数组类型都被视为具有相同的cv限定。</target>
        </trans-unit>
        <trans-unit id="4da3e84107ea6402ad05595526acce55c364845f" translate="yes" xml:space="preserve">
          <source>Approximate</source>
          <target state="translated">Approximate</target>
        </trans-unit>
        <trans-unit id="09d845a999b4fbc8adffb5aaf317f7912e88b018" translate="yes" xml:space="preserve">
          <source>Approximately (last-first)log(middle-first) applications of &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cmp&lt;/code&gt; 的大约（倒数第一）log（中间第一）应用程序。</target>
        </trans-unit>
        <trans-unit id="784f9dcf68eaea0702498dee303485e97ffb2719" translate="yes" xml:space="preserve">
          <source>Approximately &lt;code&gt;N log N&lt;/code&gt; comparisons, where N is the number of elements in the list.</source>
          <target state="translated">大约 &lt;code&gt;N log N&lt;/code&gt; 个比较，其中N是列表中元素的数量。</target>
        </trans-unit>
        <trans-unit id="263ef14d73529c347640508e4c1ee9f8d38a5463" translate="yes" xml:space="preserve">
          <source>Arbitrary variable name</source>
          <target state="translated">任意变量名称</target>
        </trans-unit>
        <trans-unit id="e35b07545cf742633f94fa34acab673ea47df2c2" translate="yes" xml:space="preserve">
          <source>Args&lt;code&gt;...&lt;/code&gt;args(optional)</source>
          <target state="translated">Args&lt;code&gt;...&lt;/code&gt;args(optional)</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="b8bc95515466bfd1d5820bfea495f62a49211b2b" translate="yes" xml:space="preserve">
          <source>Argument list too long</source>
          <target state="translated">争论列表太长</target>
        </trans-unit>
        <trans-unit id="def2bf62b424e602e225d5df7086bbc94649ceb1" translate="yes" xml:space="preserve">
          <source>Argument type</source>
          <target state="translated">参数类型</target>
        </trans-unit>
        <trans-unit id="2b55cecef5202fd86c073a0e44fac351439665bc" translate="yes" xml:space="preserve">
          <source>Argument-Dependent Lookup</source>
          <target state="translated">依赖于参数的查询</target>
        </trans-unit>
        <trans-unit id="81b2c9c824baa8fa05c1678ad66e87db4cff58c7" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup</source>
          <target state="translated">依赖于参数的查询</target>
        </trans-unit>
        <trans-unit id="ae0999c00edb7da81dc23e3610fb98d912a734a5" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup makes it possible to use operators defined in a different namespace. Example:</source>
          <target state="translated">依赖于参数的查找可以使用在不同命名空间中定义的操作符。例子:</target>
        </trans-unit>
        <trans-unit id="48fb1df93f3daa01db173d8e4c1d5be0610f1c51" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup, also known as ADL, or Koenig lookup, is the set of rules for looking up the unqualified function names in &lt;a href=&quot;operator_other&quot;&gt;function-call expressions&lt;/a&gt;, including implicit function calls to &lt;a href=&quot;operators&quot;&gt;overloaded operators&lt;/a&gt;. These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces considered by the usual &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt;.</source>
          <target state="translated">依赖于参数的查找（也称为ADL或Koenig查找）是用于在&lt;a href=&quot;operator_other&quot;&gt;函数调用表达式中&lt;/a&gt;查找不合格函数名称的规则集，包括对&lt;a href=&quot;operators&quot;&gt;重载运算符的&lt;/a&gt;隐式函数调用。除了通常的&lt;a href=&quot;lookup&quot;&gt;非限定名称查找所&lt;/a&gt;考虑的范围和名称空间之外，还在其参数的名称空间中查找这些函数名称。</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="6e926e8a15212af2e7d9e38d85b6ff5994219acc" translate="yes" xml:space="preserve">
          <source>Arithmetic comparison operators</source>
          <target state="translated">算术比较运算符</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">算术运算</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">算术运算符</target>
        </trans-unit>
        <trans-unit id="ebc8c7691d9a7980369acc634bd9267bcb2e5a9e" translate="yes" xml:space="preserve">
          <source>Arithmetic operators are overloaded for many standard library types.</source>
          <target state="translated">许多标准库类型的算术运算符都会被重载。</target>
        </trans-unit>
        <trans-unit id="aa83af8c4fc56c37be9ed278bb37886d698b573b" translate="yes" xml:space="preserve">
          <source>Arithmetic type capable of representing the process running time of implementation-defined range and precision.</source>
          <target state="translated">算术类型,能够表示执行定义范围和精度的过程运行时间。</target>
        </trans-unit>
        <trans-unit id="8067dbf084d6b81e05c895b3fb91dd4530c4b57b" translate="yes" xml:space="preserve">
          <source>Arithmetic type capable of representing times.</source>
          <target state="translated">能够表示次数的算术类型。</target>
        </trans-unit>
        <trans-unit id="3a96c27ea8acc41f84ccf2e2e957611cc9d4cd07" translate="yes" xml:space="preserve">
          <source>Arithmetic types</source>
          <target state="translated">算术类型</target>
        </trans-unit>
        <trans-unit id="d06d9a0dfd0ee03ff5118df0f82845bdc8d2b4bc" translate="yes" xml:space="preserve">
          <source>Arithmetic types are the built-in types for which the &lt;a href=&quot;../language/operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; (+, -, *, /) are defined (possibly in combination with the usual arithmetic conversions).</source>
          <target state="translated">算术类型是为其定义&lt;a href=&quot;../language/operator_arithmetic&quot;&gt;算术运算符&lt;/a&gt;（+，-，*，/）的内置类型（可能与常规算术转换结合使用）。</target>
        </trans-unit>
        <trans-unit id="7a080955122add0c1c12baf72d49c4257bf60020" translate="yes" xml:space="preserve">
          <source>Array &lt;a href=&quot;value_category&quot;&gt;xvalues&lt;/a&gt; may be formed directly by accessing an array member of a class rvalue or by using &lt;code&gt;std::move&lt;/code&gt; or another cast or function call that returns an rvalue reference.</source>
          <target state="translated">可以通过访问类rvalue的数组成员或使用 &lt;code&gt;std::move&lt;/code&gt; 或另一个返回右值引用的&lt;a href=&quot;value_category&quot;&gt;强制转换&lt;/a&gt;或函数调用直接形成数组xvalue。</target>
        </trans-unit>
        <trans-unit id="ee291b10c5dda44d0a9e99115603b2cd5af533b7" translate="yes" xml:space="preserve">
          <source>Array I/O implementations</source>
          <target state="translated">阵列I/O实现</target>
        </trans-unit>
        <trans-unit id="1fac704c74c4d1cd597a85741e932ee6a1399565" translate="yes" xml:space="preserve">
          <source>Array allocation may supply unspecified overhead, which may vary from one call to new to the next. The pointer returned by the new-expression will be offset by that value from the pointer returned by the allocation function. Many implementations use the array overhead to store the number of objects in the array which is used by the &lt;a href=&quot;delete&quot;&gt;&lt;code&gt;delete[]&lt;/code&gt;&lt;/a&gt; expression to call the correct number of destructors. In addition, if the new-expression is used to allocate an array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, or &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt;, it may request additional memory from the allocation function if necessary to guarantee correct alignment of objects of all types no larger than the requested array size, if one is later placed into the allocated array.</source>
          <target state="translated">数组分配可能会提供未指定的开销，从一次调用到新调用再到下一次调用，开销可能会有所不同。 new-expression返回的指针将从分配函数返回的指针偏移该值。许多实现使用数组开销来存储数组中对象的数量，由&lt;a href=&quot;delete&quot;&gt; &lt;code&gt;delete[]&lt;/code&gt; &lt;/a&gt;表达式使用该对象来调用正确数量的析构函数。另外，如果new-expression用于分配 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;unsigned char&lt;/code&gt; 或&lt;a href=&quot;../types/byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt;数组，则有必要在必要时从分配函数中请求其他内存，以确保所有类型不大于the的对象正确对齐。请求的数组大小，如果稍后将其放入分配的数组中。</target>
        </trans-unit>
        <trans-unit id="19dbfbf61f5e11cabe0b3e7c939480487b44e48e" translate="yes" xml:space="preserve">
          <source>Array and function types may be written in a template declaration, but they are automatically replaced by pointer to object and pointer to function as appropriate.</source>
          <target state="translated">数组和函数类型可以写在模板声明中,但它们会自动被适当的对象指针和函数指针所取代。</target>
        </trans-unit>
        <trans-unit id="3fb125cc9e54d7ed417b90f1b586cad673b24cc3" translate="yes" xml:space="preserve">
          <source>Array declaration</source>
          <target state="translated">阵列声明</target>
        </trans-unit>
        <trans-unit id="fa11a0bed9bf8be4aa754cdcc96dcd83617299af" translate="yes" xml:space="preserve">
          <source>Array rvalues</source>
          <target state="translated">阵列r值</target>
        </trans-unit>
        <trans-unit id="2e4177a778e8e0d4d36e9396b01d0e6f4341b30c" translate="yes" xml:space="preserve">
          <source>Array subscript operator</source>
          <target state="translated">阵列下标运算符</target>
        </trans-unit>
        <trans-unit id="66b8cc3bf902fd9199bad14788d8e22184391a03" translate="yes" xml:space="preserve">
          <source>Array to pointer conversion</source>
          <target state="translated">阵列到指针的转换</target>
        </trans-unit>
        <trans-unit id="c0025fd7b0d4a983ce2fa2e1c1b60d86f77fcd32" translate="yes" xml:space="preserve">
          <source>Array version, &lt;code&gt;unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;</source>
          <target state="translated">数组版本， &lt;code&gt;unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d338acd11db4278249951233a983d4b787dc89b" translate="yes" xml:space="preserve">
          <source>Array-oriented access</source>
          <target state="translated">面向阵列的访问</target>
        </trans-unit>
        <trans-unit id="78c423e7d10bf3348df8d43bf148cb5827744e5a" translate="yes" xml:space="preserve">
          <source>Array-to-pointer and function-to-pointer conversions are never applied to the value calculated by a discarded-value expression. The lvalue-to-rvalue conversion is applied if and only if the expression is a &lt;a href=&quot;cv&quot;&gt;volatile-qualified&lt;/a&gt; glvalue and has one of the following forms (built-in meaning required, possibly parenthesized).</source>
          <target state="translated">数组到指针和函数到指针的转换永远不会应用于由舍弃值表达式计算的值。当且仅当表达式是具有&lt;a href=&quot;cv&quot;&gt;volatile限定的&lt;/a&gt; glvalue且具有以下形式之一（要求内置的含义，可能带有括号）时，才应用从左值到右值的转换。</target>
        </trans-unit>
        <trans-unit id="e8874168e3c1df960a01e93b0e01fe86fb6ae2dc" translate="yes" xml:space="preserve">
          <source>Array-to-pointer decay</source>
          <target state="translated">阵列到指针的衰减</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="1376db7bd12df19420984d74ce62a991f95e82b5" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed from any &lt;a href=&quot;types&quot;&gt;fundamental type&lt;/a&gt; (except &lt;code&gt;void&lt;/code&gt;), &lt;a href=&quot;pointer&quot;&gt;pointers&lt;/a&gt;, &lt;a href=&quot;pointer&quot;&gt;pointers to members&lt;/a&gt;, &lt;a href=&quot;classes&quot;&gt;classes&lt;/a&gt;, &lt;a href=&quot;enum&quot;&gt;enumerations&lt;/a&gt;, or from other arrays (in which case the array is said to be multi-dimensional).</source>
          <target state="translated">数组可以从任何&lt;a href=&quot;types&quot;&gt;基本类型&lt;/a&gt;（ &lt;code&gt;void&lt;/code&gt; 除外），&lt;a href=&quot;pointer&quot;&gt;指针&lt;/a&gt;，&lt;a href=&quot;pointer&quot;&gt;指向成员的指针&lt;/a&gt;，&lt;a href=&quot;classes&quot;&gt;类&lt;/a&gt;，&lt;a href=&quot;enum&quot;&gt;枚举&lt;/a&gt;或从其他数组（在这种情况下，该数组被称为多维）构造而成。</target>
        </trans-unit>
        <trans-unit id="fb1e79ec0101099cc8a59bf9fd30eb4aa15f99db" translate="yes" xml:space="preserve">
          <source>Arrays of character types (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;) can be initialized from an appropriate &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;, optionally enclosed in braces. Successive characters of the string literal (which includes the implicit terminating null character) initialize the elements of the array. If the size of the array is specified and it is larger than the number of characters in the string literal, the remaining characters are zero-initialized.</source>
          <target state="translated">字符类型数组（ &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;signed char&lt;/code&gt; ， &lt;code&gt;unsigned char&lt;/code&gt; ， &lt;code&gt;char8_t&lt;/code&gt; ， &lt;code&gt;char16_t&lt;/code&gt; ， &lt;code&gt;char32_t&lt;/code&gt; ， &lt;code&gt;wchar_t&lt;/code&gt; ）可以从适当的&lt;a href=&quot;string_literal&quot;&gt;字符串文字中&lt;/a&gt;初始化，还可以将其括在花括号中。字符串文字的连续字符（包括隐式终止null字符）将初始化数组的元素。如果指定了数组的大小并且它大于字符串文字中的字符数，则剩余的字符将被零初始化。</target>
        </trans-unit>
        <trans-unit id="1dad2511cb3cf432d9a23097f1bff2b6f8637192" translate="yes" xml:space="preserve">
          <source>Arrays of unknown bound</source>
          <target state="translated">未知边界的数组</target>
        </trans-unit>
        <trans-unit id="5cf5ca03aab0034cdf7ff385d06729a538f15f36" translate="yes" xml:space="preserve">
          <source>As a rule, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during &lt;a href=&quot;array/swap&quot;&gt;swap&lt;/a&gt;, the iterator will continue to point to the same array element, and will thus change its value.</source>
          <target state="translated">通常，数组的迭代器在数组的整个生命周期内都不会失效。但是，应该注意的是，在&lt;a href=&quot;array/swap&quot;&gt;swap&lt;/a&gt;期间，迭代器将继续指向同一数组元素，因此将更改其值。</target>
        </trans-unit>
        <trans-unit id="614cc5be51bd0fccb31d1106fa599930fafe0ca5" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; is treated as a uses-allocator type even though &lt;code&gt;std::uses_allocator&lt;/code&gt; is false for pairs (unlike e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;): see pair-specific overloads of &lt;code&gt;std::polymoprhic_allocator::construct&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;std::scoped_allocator_adaptor::construct&lt;/a&gt;&lt;/code&gt;(until C++20)&lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt;(since C++20)</source>
          <target state="translated">作为一种特殊的情况下， &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 被视为一个用途分配器型即使 &lt;code&gt;std::uses_allocator&lt;/code&gt; 是假用于对（不像例如 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; ）：看到的一对特定的过载 &lt;code&gt;std::polymoprhic_allocator::construct&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;std::scoped_allocator_adaptor::construct&lt;/a&gt;&lt;/code&gt; （直到C ++ 20） &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; （C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="363835804f732ae2a7518afa5d70079b8f827fb9" translate="yes" xml:space="preserve">
          <source>As a special case, objects can be created in arrays of &lt;code&gt;unsigned char&lt;/code&gt; or &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt; (in which case it is said that the array</source>
          <target state="translated">作为一种特殊情况，可以在 &lt;code&gt;unsigned char&lt;/code&gt; 或&lt;a href=&quot;../types/byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt;数组中创建对象（在这种情况下，据说该数组</target>
        </trans-unit>
        <trans-unit id="f52724b9ca0301f1d8b93282821a00b036f2d526" translate="yes" xml:space="preserve">
          <source>As above, with &lt;code&gt;eq=key_equal()&lt;/code&gt;</source>
          <target state="translated">如上所述，使用 &lt;code&gt;eq=key_equal()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8531b085109b3b3d1377cabf79180d8d388c7ee8" translate="yes" xml:space="preserve">
          <source>As above, with &lt;code&gt;hf=hasher()&lt;/code&gt;</source>
          <target state="translated">如上，使用 &lt;code&gt;hf=hasher()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bda77b28e4ca321fc30d59f16b97fba79dbe7581" translate="yes" xml:space="preserve">
          <source>As above, with an unspecified number of buckets</source>
          <target state="translated">同上,但桶数不详</target>
        </trans-unit>
        <trans-unit id="cb4232ed7041310ecc9217dc4e9b0dad693d0afb" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void*)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="translated">作为&amp;ldquo;实现支持&amp;rdquo;需求的一个示例，POSIX函数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt;接受由2 &lt;code&gt;aligned_alloc&lt;/code&gt; &lt;code&gt;sizeof(void*)&lt;/code&gt; 的倍数的任何 &lt;code&gt;alignment&lt;/code&gt; ，并且基于POSIX的aligned_alloc实现继承了此需求。</target>
        </trans-unit>
        <trans-unit id="0a94bbdb2793055475b5f04a01eddcc7f88ab6b4" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void*)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dabb20bee356347a72de2e02dded113dd51368a" translate="yes" xml:space="preserve">
          <source>As any other function, a destructor may terminate by throwing an &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;(this usually requires it to be explicitly declared &lt;code&gt;noexcept(false)&lt;/code&gt;)(since C++11), however if this destructor happens to be called during &lt;a href=&quot;throw&quot;&gt;stack unwinding&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">与其他任何函数一样，析构函数可以通过引发&lt;a href=&quot;exceptions&quot;&gt;异常&lt;/a&gt;来终止（这通常要求将其明确声明为 &lt;code&gt;noexcept(false)&lt;/code&gt; ）（自C ++ 11起），但是，如果此析构函数恰巧在&lt;a href=&quot;throw&quot;&gt;堆栈展开&lt;/a&gt;时被调用，则 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 而是调用终止。</target>
        </trans-unit>
        <trans-unit id="7a66bb24008dddd2f1f26becdeebf04e56826247" translate="yes" xml:space="preserve">
          <source>As defined above.</source>
          <target state="translated">如上定义。</target>
        </trans-unit>
        <trans-unit id="a534c811c2d3571f2ae27f157ef19b52a844ad05" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;) to an object whose member will be accessed.</source>
          <target state="translated">如&lt;a href=&quot;../../named_req/callable&quot;&gt;Callable中所述&lt;/a&gt;，当调用指向非静态成员函数的指针或指向非静态数据成员的指针时，第一个参数必须是引用或指针（可能包括智能指针，如 &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; ）到将要访问其成员的对象。</target>
        </trans-unit>
        <trans-unit id="9ee2578ea146050c5227b8b046d49c6f68518e95" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;, the C++ program may provide global and class-specific replacements for these functions. If the new-expression begins with the optional &lt;code&gt;::&lt;/code&gt; operator, as in &lt;code&gt;::new T&lt;/code&gt; or &lt;code&gt;::new T[n]&lt;/code&gt;, class-specific replacements will be ignored (the function is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; in global &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;). Otherwise, if &lt;code&gt;T&lt;/code&gt; is a class type, lookup begins in the class scope of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如&lt;a href=&quot;../memory/new/operator_new&quot;&gt;分配函数&lt;/a&gt;中所述，C ++程序可以为这些函数提供全局和特定于类的替换。如果new-expression以可选的 &lt;code&gt;::&lt;/code&gt; 运算符开头，如 &lt;code&gt;::new T&lt;/code&gt; 或 &lt;code&gt;::new T[n]&lt;/code&gt; ，则将忽略类特定的替换（该函数在全局&lt;a href=&quot;scope&quot;&gt;范围内&lt;/a&gt;&lt;a href=&quot;lookup&quot;&gt;查找&lt;/a&gt;）。否则，如果 &lt;code&gt;T&lt;/code&gt; 是类类型，则查找从 &lt;code&gt;T&lt;/code&gt; 的类范围开始。</target>
        </trans-unit>
        <trans-unit id="03fe97a528d16f7fe7e71f5717247af8db4822bd" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;explicit_cast&quot;&gt;functional cast&lt;/a&gt;, the syntax &lt;code&gt;T()&lt;/code&gt;(1) is prohibited for arrays, while &lt;code&gt;T{}&lt;/code&gt;(5) is allowed.</source>
          <target state="translated">如&lt;a href=&quot;explicit_cast&quot;&gt;功能转换中&lt;/a&gt;所述，数组禁止使用语法 &lt;code&gt;T()&lt;/code&gt; （1），而允许使用 &lt;code&gt;T{}&lt;/code&gt; （5）。</target>
        </trans-unit>
        <trans-unit id="f2a24edd45dbf727b01f52b1b2fe43e48097af38" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;non-local initialization&lt;/a&gt;, static and thread-local variables that aren't constant-initialized(since C++14) are zero-initialized before any other initialization takes place. If the definition of a non-class non-local variable has no initializer, then default initialization does nothing, leaving the result of the earlier zero-initialization unmodified.</source>
          <target state="translated">如&lt;a href=&quot;initialization#Non-local_variables&quot;&gt;非局部初始化中所述&lt;/a&gt;，未进行常量初始化的静态和线程局部变量（自C ++ 14起）在进行任何其他初始化之前先进行零初始化。如果非类非局部变量的定义没有初始化程序，则默认初始化不执行任何操作，而更早的零初始化的结果将保持不变。</target>
        </trans-unit>
        <trans-unit id="08d19aea73540a5ba0404cba80c23af9e3c2ceba" translate="yes" xml:space="preserve">
          <source>As described in &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;) to an object whose member will be accessed.</source>
          <target state="translated">如 &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; ，当调用指向非静态成员函数的指针或指向非静态数据成员的指针时，第一个参数必须是引用或指针（可能包括智能指针，如 &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; ）到将要访问其成员的对象。</target>
        </trans-unit>
        <trans-unit id="2b2d6cdbd1b2496e6a2f40aed0a78a511c900aab" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt;, the lookup of a dependent name used in a template is postponed until the template arguments are known, at which time.</source>
          <target state="translated">如在&lt;a href=&quot;lookup&quot;&gt;lookup中&lt;/a&gt;讨论的那样，在模板中使用的从属名称的查找被推迟到知道模板参数为止。</target>
        </trans-unit>
        <trans-unit id="58e3f3f862eff79aa619bdf804e54d8152b28137" translate="yes" xml:space="preserve">
          <source>As formulated in C++11, the behavior of &lt;code&gt;std::result_of&lt;/code&gt; is undefined when &lt;code&gt;INVOKE(std::declval&amp;lt;F&amp;gt;(), std::declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; is ill-formed (e.g. when F is not a callable type at all). C++14 changes that to a &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; (when F is not callable, &lt;code&gt;std::result_of&amp;lt;F(ArgTypes...)&amp;gt;&lt;/code&gt; simply doesn't have the &lt;code&gt;type&lt;/code&gt; member).</source>
          <target state="translated">如在C ++ 11配制的行为 &lt;code&gt;std::result_of&lt;/code&gt; 未定义时 &lt;code&gt;INVOKE(std::declval&amp;lt;F&amp;gt;(), std::declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; 是形成不良的（例如，当F根本不是可调用类型）。C ++ 14将其更改为&lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt;（当无法调用F时， &lt;code&gt;std::result_of&amp;lt;F(ArgTypes...)&amp;gt;&lt;/code&gt; 根本没有 &lt;code&gt;type&lt;/code&gt; 成员）。</target>
        </trans-unit>
        <trans-unit id="937a4526e972e8900a66eaf74bf3283dd336852b" translate="yes" xml:space="preserve">
          <source>As free (namespace) function</source>
          <target state="translated">作为free(命名空间)函数</target>
        </trans-unit>
        <trans-unit id="ebe6ab533cbf3972cb8d127e93ba520450789106" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, if statement is a single statement (not a compound statement), the scope of variables declared in it is limited to the loop body as if it was a compound statement.</source>
          <target state="translated">与&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;循环一样，if语句是单个语句（而不是复合语句），在其中声明的变量的范围仅限于循环体，就好像它是复合语句一样。</target>
        </trans-unit>
        <trans-unit id="c00d6a8291143d3954d0476db09f338bbdf6a6a6" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;code&gt;typename&lt;/code&gt;, the &lt;code&gt;template&lt;/code&gt; prefix is allowed even if the name is not dependent or the use does not appear in the scope of a template(since C++11).</source>
          <target state="translated">与 &lt;code&gt;typename&lt;/code&gt; 一样，即使名称不相关或使用未出现在模板范围内（自C ++ 11起），也允许 &lt;code&gt;template&lt;/code&gt; 前缀。</target>
        </trans-unit>
        <trans-unit id="f30e97ae154b85ba90b59b0fc7f3cc9421ecbfce" translate="yes" xml:space="preserve">
          <source>As long as the computation doesn't overflow, (1-3) always return a valid &lt;code&gt;weekday&lt;/code&gt; even if &lt;code&gt;wd.ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">只要计算不会溢出，即使 &lt;code&gt;wd.ok()&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，（1-3）始终返回有效的 &lt;code&gt;weekday&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2ffc3f13ddf954cdee7f939204ad75111f3eb7d" translate="yes" xml:space="preserve">
          <source>As long as the computation doesn't overflow, (1-3) always return a valid month even if &lt;code&gt;m.ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">只要计算不会溢出，即使 &lt;code&gt;m.ok()&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，（1-3）总是返回有效的月份。</target>
        </trans-unit>
        <trans-unit id="974f4de3b83d59e1f68e4272f20e899a5d37454c" translate="yes" xml:space="preserve">
          <source>As member function</source>
          <target state="translated">作为成员函数</target>
        </trans-unit>
        <trans-unit id="713b3ed5226e8894aaa4433505d652a47c900087" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;declarations#Declarators&quot;&gt;Declarations&lt;/a&gt;, the declarator can be followed by a</source>
          <target state="translated">如&lt;a href=&quot;declarations#Declarators&quot;&gt;声明&lt;/a&gt;中所述，声明符后可以跟一个</target>
        </trans-unit>
        <trans-unit id="49e91975e9ca17802a309ea7799083868c1165b1" translate="yes" xml:space="preserve">
          <source>As non-member function</source>
          <target state="translated">作为非成员职能</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
