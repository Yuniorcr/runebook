<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="8967e7083aa7ece41be13822051695a635bff07e" translate="yes" xml:space="preserve">
          <source>If &amp;nu;&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="translated">如果&amp;nu;&amp;gt; = 128，则行为是实现定义的</target>
        </trans-unit>
        <trans-unit id="c861ca152a1a5790f61fc9a7ad6bc1a92ae258c8" translate="yes" xml:space="preserve">
          <source>If (and only if) reallocation takes place, all pointers, references, and iterators are invalidated.</source>
          <target state="translated">如果(也只有当)重分配发生时,所有指针、引用和迭代器都无效。</target>
        </trans-unit>
        <trans-unit id="98c199ab16ab809f486bbb3423d179f029c19b26" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;ON&lt;/code&gt;, all floating-point arithmetic operators obey the current floating-point &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;rounding direction&lt;/a&gt; and report floating-point arithmetic errors as specified in &lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt;&lt;code&gt;math_errhandling&lt;/code&gt;&lt;/a&gt; unless part of a &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;static initializer&lt;/a&gt; (in which case floating-point exceptions are not raised and the rounding mode is to nearest).</source>
          <target state="translated">如果支持&lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FENV_ACCESS&lt;/code&gt; &lt;/a&gt;并将其设置为 &lt;code&gt;ON&lt;/code&gt; ，&lt;a href=&quot;../numeric/math/math_errhandling&quot;&gt; &lt;code&gt;math_errhandling&lt;/code&gt; &lt;/a&gt;除非&lt;a href=&quot;initialization#Non-local_variables&quot;&gt;静态初始化程序的&lt;/a&gt;一部分（在这种情况下为浮点数），否则所有浮点算术运算符都遵循当前的浮点&lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;舍入方向&lt;/a&gt;并报告math_errhandling中指定的浮点算术错误。不会引发异常，并且舍入模式是最接近的）。</target>
        </trans-unit>
        <trans-unit id="7bb02eee6cd1dc516434df27056595be6a6b00a7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; of an object of class type requires that a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is called to convert the initializer expression of type cv &lt;code&gt;S&lt;/code&gt; to the type cv &lt;code&gt;T&lt;/code&gt; of the object being initialized, the following functions are candidate functions:</source>
          <target state="translated">如果类类型的对象的&lt;a href=&quot;copy_initialization&quot;&gt;复制初始化&lt;/a&gt;要求调用&lt;a href=&quot;cast_operator&quot;&gt;用户定义的转换函数&lt;/a&gt;，以将cv &lt;code&gt;S&lt;/code&gt; 类型的初始化表达式转换为要初始化的对象的cv &lt;code&gt;T&lt;/code&gt; 类型，则以下函数为候选函数：</target>
        </trans-unit>
        <trans-unit id="cc788d4e3b334778f8f385fbf8f9f00b88dbcecf" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; is used to exit a try-block and if any of the destructors of block-scoped automatic variables that are executed by the &lt;code&gt;goto&lt;/code&gt; throw exceptions, those exceptions are caught by the try blocks in which the variables are defined:</source>
          <target state="translated">如果使用&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;退出try块，并且如果 &lt;code&gt;goto&lt;/code&gt; 执行的任何块作用域自动变量的析构函数都抛出异常，则这些异常将被在其中定义了变量的try块捕获：</target>
        </trans-unit>
        <trans-unit id="ad02ee6de1557c2cab77c2034cb247d4122fb981" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; is true, does nothing. Otherwise, destroys the currently contained value.</source>
          <target state="translated">如果&lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;为true，则不执行任何操作。否则，销毁当前包含的值。</target>
        </trans-unit>
        <trans-unit id="22e67fa78b1a05182b627ae99ffd3c2b45940a22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!m.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated month name for the month represented by &lt;code&gt;m&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;!m.ok()&lt;/code&gt; 等效于 &lt;code&gt;os &amp;lt;&amp;lt; unsigned(m) &amp;lt;&amp;lt; &quot; is not a valid month&quot;;&lt;/code&gt; 。否则，形成 &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 包括用于通过所表示的月份的缩写月份名称的 &lt;code&gt;m&lt;/code&gt; ，使用具有相关联的语言环境来确定 &lt;code&gt;os&lt;/code&gt; ，并插入 &lt;code&gt;s&lt;/code&gt; 到 &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1a70707db6a348980443d56c9ab0c52464c252f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;!uppercase&lt;/code&gt; ，将使用转换说明符 &lt;code&gt;%g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f6dfc884c101654edafd48a800532bba66066cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;!wd.ok()&lt;/code&gt;, equivalent to &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt;. Otherwise, forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the abbreviated weekday name for the weekday represented by &lt;code&gt;wd&lt;/code&gt;, determined using the locale associated with &lt;code&gt;os&lt;/code&gt;, and inserts &lt;code&gt;s&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;!wd.ok()&lt;/code&gt; 等效于 &lt;code&gt;os &amp;lt;&amp;lt; unsigned(wd) &amp;lt;&amp;lt; &quot; is not a valid weekday&quot;;&lt;/code&gt; 。否则，形成 &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 由缩写星期名称为平日由下式表示 &lt;code&gt;wd&lt;/code&gt; ，使用具有相关联的语言环境来确定 &lt;code&gt;os&lt;/code&gt; ，并插入 &lt;code&gt;s&lt;/code&gt; 到 &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc136d5ecc5ffd29fb88143ae3ce7ad3bfccb312" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;tuple&lt;/code&gt; is trivial.</source>
          <target state="translated">如果 &lt;code&gt;(&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;Types&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;tuple&lt;/code&gt; 的析构函数是微不足道的。</target>
        </trans-unit>
        <trans-unit id="da8cff62887e613aba67b865a9e6d73a9a0208c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, calls &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt;. If that function returns &lt;code&gt;-1&lt;/code&gt;, sets &lt;code&gt;badbit&lt;/code&gt; in &lt;code&gt;os.rdstate()&lt;/code&gt; without propagating an exception.</source>
          <target state="translated">如果 &lt;code&gt;(os.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;) &amp;amp;&amp;amp; !&lt;a href=&quot;../../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;() &amp;amp;&amp;amp; os.good())&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，调用 &lt;code&gt;os.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; 。如果该函数返回 &lt;code&gt;-1&lt;/code&gt; ， &lt;code&gt;badbit&lt;/code&gt; 在 &lt;code&gt;os.rdstate()&lt;/code&gt; 中设置badbit而不传播异常。</target>
        </trans-unit>
        <trans-unit id="cd5e11e3cc0c402b0e9be870090813113d4c62f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt;, then an implementation-defined value is substituted instead of &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt;, possibly different for different values of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;(unsigned char)c &amp;gt;= &lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; ，则将实现定义的值替换为 &lt;code&gt;table()[(unsigned char)c]&lt;/code&gt; ，对于不同的 &lt;code&gt;c&lt;/code&gt; 值可能会有所不同。</target>
        </trans-unit>
        <trans-unit id="92961dd363bdfb6c745602ae238d61a26e00ce3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; refer to the same object, then &lt;code&gt;a&lt;/code&gt; == &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;*a&lt;/code&gt; 和 &lt;code&gt;*b&lt;/code&gt; 引用相同的对象，则 &lt;code&gt;a&lt;/code&gt; == &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d8fc3988020f52aa4cd322d347c93e64ecb80c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, and &lt;code&gt;r&lt;/code&gt; is not the same as &lt;code&gt;*this&lt;/code&gt;, the object is destroyed through the owned deleter.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 已经拥有一个对象，并且它是拥有它的最后一个 &lt;code&gt;shared_ptr&lt;/code&gt; ，并且 &lt;code&gt;r&lt;/code&gt; 与 &lt;code&gt;*this&lt;/code&gt; 不同，则该对象将通过拥有的删除器销毁。</target>
        </trans-unit>
        <trans-unit id="d91b74584f1eaef50da01b154cf35ae1c060bd65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; already owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 已经拥有一个对象，并且它是拥有它的最后一个 &lt;code&gt;shared_ptr&lt;/code&gt; ，则该对象将通过拥有的删除器销毁。</target>
        </trans-unit>
        <trans-unit id="9547dd884045b3da73d2308453755944edbbda07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; both have dynamic type &lt;code&gt;std::exception&lt;/code&gt; then &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 都具有动态类型 &lt;code&gt;std::exception&lt;/code&gt; 则 &lt;code&gt;&lt;a href=&quot;../../string/byte/strcmp&quot;&gt;std::strcmp&lt;/a&gt;(what(), other.what()) == 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9d03bcb4418c0282af6a72fecf7a440fdb5debe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, but &lt;code&gt;other&lt;/code&gt; does not, then the contained value is destroyed by calling its destructor. &lt;code&gt;*this&lt;/code&gt; does not contain a value after the call.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 包含一个值，而 &lt;code&gt;other&lt;/code&gt; 不包含，则通过调用其析构函数销毁所包含的值。 &lt;code&gt;*this&lt;/code&gt; 呼叫后不包含任何值。</target>
        </trans-unit>
        <trans-unit id="a7a277ddff2e8e400ab7cc6265a8854405fc6aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, destroy that value as if by &lt;code&gt;value().T::~T()&lt;/code&gt;. Otherwise, there are no effects.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 包含一个值，则用 &lt;code&gt;value().T::~T()&lt;/code&gt; 销毁该值。否则，没有效果。</target>
        </trans-unit>
        <trans-unit id="3f2f61fd72ae5e884e1a574bf73169287b72c489" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; contains a value, returns a reference to the contained value.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 包含一个值，则返回对该包含值的引用。</target>
        </trans-unit>
        <trans-unit id="c59d16b11cfaa885be1c6ecd9266546a41ca8652" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 有一个关联的互斥锁（（ &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; 返回一个非空指针）并获得了它的所有权（ &lt;code&gt;owns()&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ），则通过调用 &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; 来解锁该互斥锁。</target>
        </trans-unit>
        <trans-unit id="0082e088403160e49ff73354c8b162b48a36a42a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; has an associated thread (&lt;code&gt;joinable() == true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; is called.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 具有关联的线程（ &lt;code&gt;joinable() == true&lt;/code&gt; ），则调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9144affce378c4381a07accbbe9c5b400c516453" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is a suffix iterator, sets &lt;code&gt;*this&lt;/code&gt; to an end-of-sequence iterator.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 是后缀迭代器，则将 &lt;code&gt;*this&lt;/code&gt; 设置为序列结束迭代器。</target>
        </trans-unit>
        <trans-unit id="d1c58d5d72435da6477abb6fcff62548ec0974a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; is the last object referring to the shared state, destroys the shared state. Otherwise does nothing.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 是引用共享状态的最后一个对象，则破坏共享状态。否则什么都不做。</target>
        </trans-unit>
        <trans-unit id="43f3508ad52f8c72c8bffdd8e6f95fe0b279e431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; owns an object and it is the last &lt;code&gt;shared_ptr&lt;/code&gt; owning it, the object is destroyed through the owned deleter.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 拥有一个对象，并且它是拥有它的最后一个 &lt;code&gt;shared_ptr&lt;/code&gt; ，则该对象将通过拥有的删除器销毁。</target>
        </trans-unit>
        <trans-unit id="0047e92ce8b32348ae1bf76f7759ee5ab1deddb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;*this&lt;/code&gt; still has an associated running thread (i.e. &lt;code&gt;joinable() == true&lt;/code&gt;), call &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt;. Otherwise, assigns the state of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; and sets &lt;code&gt;other&lt;/code&gt; to a default constructed state.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 仍具有关联的运行线程（即 &lt;code&gt;joinable() == true&lt;/code&gt; ），请调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;()&lt;/code&gt; 。否则，将 &lt;code&gt;other&lt;/code&gt; 的状态分配给 &lt;code&gt;*this&lt;/code&gt; ，并将 &lt;code&gt;other&lt;/code&gt; 设置为默认的构造状态。</target>
        </trans-unit>
        <trans-unit id="1c3de47b3604829aa8d6c1f140e9684e3f5dc92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--a == --b&lt;/code&gt; then &lt;code&gt;a == b&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;--a == --b&lt;/code&gt; 则 &lt;code&gt;a == b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90fa435f3b59c79cbaeb4963bb4835737f7d7a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;::&lt;/code&gt; is followed by the character &lt;code&gt;~&lt;/code&gt; that is in turn followed by an identifier (that is, it specifies a destructor or pseudo-destructor), that identifier is looked up in the same scope as the name on the left hand side of &lt;code&gt;::&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;::&lt;/code&gt; 后面紧跟一个字符 &lt;code&gt;~&lt;/code&gt; ，然后再加上一个标识符（即，它指定一个析构函数或伪析构函数），则将在与该标识符左侧相同的范围内查找该标识符 &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2a97dc8c387c983d7ce89c28639a1a4934e5f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; is true, the call to &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; may be skipped.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/always_noconv&quot;&gt;std::codecvt::always_noconv&lt;/a&gt;&lt;/code&gt; 为true，则可能会跳过对 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="383dd33e0c7222077e9f39a66a18786b4b4abb6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then the allocator is unchanged. Otherwise, after move-assignment, &lt;code&gt;get_allocator()&lt;/code&gt; equals &lt;code&gt;other.get_allocator()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则分配器不变。否则，在移动分配之后， &lt;code&gt;get_allocator()&lt;/code&gt; 等于 &lt;code&gt;other.get_allocator()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="effa1c8a8ecca962a3e2c90eb4b0b4cd886ee427" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is true, then the allocators are exchanged using an unqualified call to non-member &lt;code&gt;swap&lt;/code&gt;. Otherwise, they are not swapped (and if &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;, the behavior is undefined).</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; 为true，则使用对非成员 &lt;code&gt;swap&lt;/code&gt; 的无条件调用来交换分配器。否则，它们将不会交换（如果 &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; ，则行为未定义）。</target>
        </trans-unit>
        <trans-unit id="895e0eca3c2f91f7c107010968f8c4eae623b669" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; is 2 (or a power of 2), the returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 为2（或2的幂），则返回的值是精确值，&lt;a href=&quot;../fenv/fe_round&quot;&gt;当前舍入模式将&lt;/a&gt;被忽略</target>
        </trans-unit>
        <trans-unit id="1790032c97cf911e15ed06b1a6725dd974239d4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;, otherwise equivalent to &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;SIZE_MAX&lt;/a&gt; / sizeof(U) &amp;lt; n&lt;/code&gt; ，则抛出 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; ，否则等效于 &lt;code&gt;return static_cast&amp;lt;U*&amp;gt;(allocate_bytes(n * sizeof(U), alignof(U)) );&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5ebe4fc1a8abdaf844d29a3d314c89acaad005a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.get().*f&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; 等效于 &lt;code&gt;t1.get().*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="982ec353c22eb69baf317b330efaf0a7a5e7cce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; 等于 &lt;code&gt;(t1.get().*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="975228dc0d0d9d407e294a92674384d84c5af876" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; 等于 &lt;code&gt;t1.*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebb6d3a6dda70443130e44d3d8eef15c8850d72d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; 等于 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46e80aaa2cfeed3cb98adbf86549699888d28e48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then this destructor is a trivial destructor.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则此析构函数为琐碎的析构函数。</target>
        </trans-unit>
        <trans-unit id="50c9fd79a84089afcea1735d81a6458257a8ebf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; is not the appropriate buffer size, &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; can be used to change it.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;&lt;/code&gt; 不是适当的缓冲区大小，则可以使用 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; 进行更改。</target>
        </trans-unit>
        <trans-unit id="3ea3c7ca7ae345831d1c696b26e5dd6650ec9617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; has lower precision, it is implementation-defined whether the value is rounded or truncated.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; 精度较低，则该值是四舍五入还是由实现定义。</target>
        </trans-unit>
        <trans-unit id="4b20a41ac6a8f6f3b703c2287f3854ec31392c44" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../concepts/derivedfrom&quot;&gt;DerivedFrom&lt;/a&gt;&amp;lt;T, view_base&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3253a1bdeb3cf6df583da218fc710e43b8aa013f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;gptr()&lt;/code&gt; (the next pointer in the get area). If &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; is set in &lt;code&gt;which&lt;/code&gt;, attempts to reposition &lt;code&gt;pptr()&lt;/code&gt; (the next pointer in the put area). If neither bit is set in &lt;code&gt;which&lt;/code&gt;, the operation fails.</source>
          <target state="translated">如果在 &lt;code&gt;which&lt;/code&gt; 设置了 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; ，则尝试重新定位 &lt;code&gt;gptr()&lt;/code&gt; （获取区域中的下一个指针）。如果在 &lt;code&gt;which&lt;/code&gt; 设置了 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; ，则尝试重新 &lt;code&gt;pptr()&lt;/code&gt; （放置区域中的下一个指针）。如果没有位被置 &lt;code&gt;which&lt;/code&gt; ，操作失败。</target>
        </trans-unit>
        <trans-unit id="1cfad288bd7fbccd70e8241c69a8d092c6bd2656" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or a similar allocator is used, a class does not have to implement a &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructor&lt;/a&gt; to satisfy this type requirement: a &lt;a href=&quot;../language/copy_constructor&quot;&gt;copy constructor&lt;/a&gt; that takes a &lt;code&gt;const T&amp;amp;&lt;/code&gt; argument can bind rvalue expressions. If a MoveInsertable class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="translated">如果使用 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 或类似的分配器，则类不必实现&lt;a href=&quot;../language/move_constructor&quot;&gt;move构造函数&lt;/a&gt;即可满足此类型要求：采用 &lt;code&gt;const T&amp;amp;&lt;/code&gt; 参数的&lt;a href=&quot;../language/copy_constructor&quot;&gt;副本构造&lt;/a&gt;函数可以绑定右值表达式。如果MoveInsertable类实现了move构造函数，则它还可以实现&lt;a href=&quot;../utility/move&quot;&gt;move语义&lt;/a&gt;，以利用未指定构造后 &lt;code&gt;rv&lt;/code&gt; 的值这一事实。</target>
        </trans-unit>
        <trans-unit id="3e00f15acad4e10cd2ecd0299fd4d8b97a99bb7d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; is a non-final non-union class type that is neither &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; nor derived from &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt;, throws an exception of an unspecified type that is publicly derived from both &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; and from &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, and constructed from &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt;. The default constructor of the &lt;code&gt;nested_exception&lt;/code&gt; base class calls &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;, capturing the currently handled exception object, if any, in a &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; 是既不是 &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; 也不是从 &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; 派生的非最终非联盟类类型，则抛出一个未指定类型的异常，该异常是从两个 &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; 公开派生的:: nested_exception和 &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; ，并从 &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t)&lt;/code&gt; 构造。 &lt;code&gt;nested_exception&lt;/code&gt; 基类的默认构造函数调用 &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; ，以将当前处理的异常对象（如果有）捕获到 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ce6265115b5fdfcaa76a7165b74faf9d8dacb2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;t1.*f&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; 等于 &lt;code&gt;t1.*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f34e8cfb2a1707ab37515e5a9bdd7f9c647abe3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../types/is_base_of&quot;&gt;std::is_base_of&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype(t1)&amp;gt;&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; 等于 &lt;code&gt;(t1.*f)(t2, ..., tN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bcb63cc68623b4a13fa5b83d65086795b276b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the destructor of &lt;code&gt;pair&lt;/code&gt; is trivial.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T1&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T2&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;pair&lt;/code&gt; 的析构函数是微不足道的。</target>
        </trans-unit>
        <trans-unit id="e1f522d5a7a2b7024a237d287703f33d30c5ccd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; is a pointer to a character type (e.g., when &lt;code&gt;Y&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;char[]&lt;/code&gt; or &lt;code&gt;CharT&lt;/code&gt;), this may end up calling the &lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt;overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for null-terminated character strings&lt;/a&gt; (causing undefined behavior if the pointer does not in fact point to such a string), rather than &lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;the overload for printing the value of the pointer itself&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;Y, D&amp;gt;::pointer&lt;/code&gt; 是指向字符类型的指针（例如，当 &lt;code&gt;Y&lt;/code&gt; 为 &lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;char[]&lt;/code&gt; 或 &lt;code&gt;CharT&lt;/code&gt; 时），这可能最终会调用&lt;a href=&quot;../../io/basic_ostream/operator_ltlt2&quot;&gt; &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;的重载以空值终止字符串（如果指针实际上没有指向这样的字符串，则导致未定义的行为），而不是&lt;a href=&quot;../../io/basic_ostream/operator_ltlt&quot;&gt;打印指针本身的值的重载&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f98e0f7ef82d28588de46aaf4b7958b9880eea5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer is a non-null pointer that should not be dereferenced.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则该指针是非空指针，不应取消引用。</target>
        </trans-unit>
        <trans-unit id="7608858d123991a3d0370b23e31edd9570a303db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, the pointer points to a single null character.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;empty()&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则指针指向单个空字符。</target>
        </trans-unit>
        <trans-unit id="5881678af232e47a5ff281e340e3ff360633c7fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果从未为该对象调用过 &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; ，则将返回调用时的全局语言环境。否则，返回传递给上次对 &lt;code&gt;&lt;a href=&quot;imbue&quot;&gt;imbue()&lt;/a&gt;&lt;/code&gt; 的调用的语言环境。</target>
        </trans-unit>
        <trans-unit id="8a3196e43b35b6c3a7ee5a0b4c3620496db3d617" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; is a null pointer (i.e. there is no associated stream buffer), then &lt;code&gt;state | badbit&lt;/code&gt; is assigned. May throw an exception.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; 是空指针（即没有关联的流缓冲区），则 &lt;code&gt;state | badbit&lt;/code&gt; 已分配。可能会引发异常。</target>
        </trans-unit>
        <trans-unit id="115f73826b05df3cd915bd8b19cd251d9d51edc4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic ostrstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">如果在动态ostrstream上调用了 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 而在此之后未调用&lt;a href=&quot;freeze&quot;&gt;freeze（false）&lt;/a&gt;，则此析构函数将泄漏内存。</target>
        </trans-unit>
        <trans-unit id="bbdbfef825b7d3601eff06aaad9cae9874a72eb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">如果在动态strstream上调用了 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 而在此之后未调用&lt;a href=&quot;freeze&quot;&gt;freeze（false）&lt;/a&gt;，则此析构函数将泄漏内存。</target>
        </trans-unit>
        <trans-unit id="478414339a40be92fc6757b885d21490b9c2c06c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; was called on a dynamic strstream and &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; was not called after that, this destructor leaks memory.</source>
          <target state="translated">如果在动态strstream上调用了 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 而在此之后未调用 &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze(false)&lt;/a&gt;&lt;/code&gt; ，则此析构函数将泄漏内存。</target>
        </trans-unit>
        <trans-unit id="28514525eb04de0df8ae0bd7f4815fcf5c0b385a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; is false and &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is true, returns &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;T, Alloc&amp;gt;&lt;/code&gt; 为false并且 &lt;code&gt;&lt;a href=&quot;../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, Args...&amp;gt;&lt;/code&gt; 为true，则返回 &lt;code&gt;&lt;a href=&quot;../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eaf847410a4fe8abec9f71211445a94385c0d80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and the copy operation must not throw exceptions</source>
          <target state="translated">如果 &lt;code&gt;A::propagate_on_container_copy_assignment::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 必须满足&lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;，并且复制操作不得引发异常</target>
        </trans-unit>
        <trans-unit id="53014a7b4b50d8ae84406194de8be90fc34e0d34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; must satisfy &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and the move operation must not throw exceptions.</source>
          <target state="translated">如果 &lt;code&gt;A::propagate_on_container_move_assignment::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 必须满足&lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;，并且移动操作不得抛出异常。</target>
        </trans-unit>
        <trans-unit id="39a1f82ebac72503acedbfb5e0cc69d3fea6e2da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lvalues of &lt;code&gt;A&lt;/code&gt; must be &lt;a href=&quot;swappable&quot;&gt;Swappable&lt;/a&gt; and the swap operation must not throw exceptions</source>
          <target state="translated">如果 &lt;code&gt;A::propagate_on_container_swap::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 的左值必须&lt;a href=&quot;swappable&quot;&gt;可交换&lt;/a&gt;，并且交换操作不得引发异常</target>
        </trans-unit>
        <trans-unit id="930ae60370eac3920b61ed4930312cdb72190d0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt;. This effectively requires &lt;code&gt;T&lt;/code&gt; to be move constructible.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; ，那么它将调用new-placement，如 &lt;code&gt;::new((void*)p) T(rv)&lt;/code&gt; 。这实际上要求 &lt;code&gt;T&lt;/code&gt; 可以移动构造。</target>
        </trans-unit>
        <trans-unit id="a6edb79bda8a280ffb6fcbbc9ba3defcf2428641" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, then this will call placement-new, as by &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; ，则这将调用new-placed，如 &lt;code&gt;::new((void*)p) T(v)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb858ecd848dc52275e556ff876a7f61bbd34174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是引用类型，则将其替换为所引用的类型</target>
        </trans-unit>
        <trans-unit id="b3c213b81227b94ede964107b48a991995b38510" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, &lt;code&gt;A&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是CV-合格， &lt;code&gt;A&lt;/code&gt; 被替换的本身CV-不合格版本</target>
        </trans-unit>
        <trans-unit id="5d95d66680ab1fe42693574faecc757445aabf8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is cv-qualified, the top-level cv-qualifiers are ignored. If &lt;code&gt;A&lt;/code&gt; is a reference type, the referred type is used by deduction.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 通过cv限定，则顶级cv限定符将被忽略。如果 &lt;code&gt;A&lt;/code&gt; 是引用类型，则通过推导使用引用的类型。</target>
        </trans-unit>
        <trans-unit id="dbb888d618ec657b4fdce4930acdf4d77c7df288" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was lvalue reference and &lt;code&gt;P&lt;/code&gt; was rvalue reference, A is considered to be more specialized than P</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是左值参考，而 &lt;code&gt;P&lt;/code&gt; 是右值参考，则认为A比P更专业。</target>
        </trans-unit>
        <trans-unit id="a0457548dadf8dfad5e452b8705d672e063c513a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; was more cv-qualified than &lt;code&gt;P&lt;/code&gt;, A is considered to be more specialized than P</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 比 &lt;code&gt;P&lt;/code&gt; 更具有简历资格，则认为A比P更专业</target>
        </trans-unit>
        <trans-unit id="164bc5f2461c5b557de9ec3b7a0a95d7ca7b6398" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;B&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;std::enable_if&lt;/code&gt; has a public member typedef &lt;code&gt;type&lt;/code&gt;, equal to &lt;code&gt;T&lt;/code&gt;; otherwise, there is no member typedef.</source>
          <target state="translated">如果 &lt;code&gt;B&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;std::enable_if&lt;/code&gt; 具有公共成员typedef &lt;code&gt;type&lt;/code&gt; ，等于 &lt;code&gt;T&lt;/code&gt; ；否则，没有成员typedef。</target>
        </trans-unit>
        <trans-unit id="84997cfae0e3bc373338233f13fc51673ecc94bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is defined, for each constructor (or constructor template) &lt;code&gt;Ci&lt;/code&gt; declared in the named primary template (if it is defined), a fictional function template &lt;code&gt;Fi&lt;/code&gt;, is constructed, such that</source>
          <target state="translated">如果定义了 &lt;code&gt;C&lt;/code&gt; ，则对于在命名的主模板（如果已定义）中声明的每个构造函数（或构造函数模板） &lt;code&gt;Ci&lt;/code&gt; ，将构造一个虚构的函数模板 &lt;code&gt;Fi&lt;/code&gt; ，使得</target>
        </trans-unit>
        <trans-unit id="cc1e774dd0f46e4682b7e19d8770ddcc69c901f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;C&lt;/code&gt; is not defined or does not declare any constructors, an additional fictional function template is added, derived as above from a hypothetical constructor &lt;code&gt;C()&lt;/code&gt;</source>
          <target state="translated">如果未定义 &lt;code&gt;C&lt;/code&gt; 或未声明任何构造函数，则添加一个附加的虚构函数模板，该模板如上从假设的构造函数 &lt;code&gt;C()&lt;/code&gt; 派生</target>
        </trans-unit>
        <trans-unit id="61f6db7fe67ce601045229a53fee7ef72360c40c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Count&lt;/code&gt; is not &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;Count&lt;/code&gt;;</source>
          <target state="translated">如果 &lt;code&gt;Count&lt;/code&gt; 不是 &lt;code&gt;std::dynamic_extent&lt;/code&gt; ，则 &lt;code&gt;Count&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="e1dc222d7a60755a2201700bb9fa727680a8b6d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type and the second overload is chosen, the program is ill-formed.</source>
          <target state="translated">如果 &lt;code&gt;D&lt;/code&gt; 是引用类型，并且选择了第二个重载，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="f9c0db03f2072cdef42cb4c9c11cc3231d111137" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;D&lt;/code&gt; is a reference type, the second overload is defined as deleted. These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. The program is ill-formed if either of these two constructors is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;D&lt;/code&gt; 是引用类型，则第二个重载定义为已删除。仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;D, decltype(d)&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，这些重载才参与重载解析。如果通过&lt;a href=&quot;../../language/deduction_guide&quot;&gt;类模板参数deduction&lt;/a&gt;选择了这两个构造函数中的任何一个，则该程序格式不正确。</target>
        </trans-unit>
        <trans-unit id="d6d1f97a0f5c5a0f55060c5fcf0db428c8650e18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, equivalent to &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt;. Otherwise, equivalent to &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;Deleter&lt;/code&gt; 是引用类型，则等效于 &lt;code&gt;shared_ptr(r.release(), &lt;a href=&quot;../../utility/functional/ref&quot;&gt;std::ref&lt;/a&gt;(r.get_deleter())&lt;/code&gt; ；否则，等效于 &lt;code&gt;shared_ptr(r.release(), r.get_deleter())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e307062451ff2a7a85e243f182577d712be79ad5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is a reference type, requires that &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; is nothrow-&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Deleter&lt;/code&gt; 是引用类型，则要求 &lt;code&gt;std::remove_reference&amp;lt;Deleter&amp;gt;::type&lt;/code&gt; 不行&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;-CopyAssignable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="765f5fc1e61e543452d73e1fb0814a6856e4589a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Deleter&lt;/code&gt; is not a reference type, requires that it is nothrow-&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Deleter&lt;/code&gt; 不是引用类型，则要求它不是nothrow- &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1aa2f10aa226cd93b28fcf97d03c1ee958d0bbf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, such pointer may be used to make &lt;a href=&quot;virtual&quot;&gt;virtual function calls&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Derived&lt;/code&gt; 是&lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;多态的&lt;/a&gt;，则可以使用此类指针进行&lt;a href=&quot;virtual&quot;&gt;虚拟函数调用&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3aeb6cf5a7fd827d219cf1ec41be16033ed0d80b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Derived&lt;/code&gt; is derived from &lt;code&gt;Base&lt;/code&gt; or if both are the same non-union class (in both cases ignoring cv-qualification), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Derived&lt;/code&gt; 是从 &lt;code&gt;Base&lt;/code&gt; 派生的，或者两者都是同一个非工会类（在两种情况下都忽略cv限定），则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ebd268ac27013dab52c304d8fe0d856e345f4dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E2&lt;/code&gt; is not a mutable member, the &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt; of the result is the union of the cv-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;, otherwise (if &lt;code&gt;E2&lt;/code&gt; is a mutable member), it is the union of the volatile-qualifications of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;;</source>
          <target state="translated">如果 &lt;code&gt;E2&lt;/code&gt; 不是一个可变构件，所述&lt;a href=&quot;cv&quot;&gt;CV-资格&lt;/a&gt;结果是的CV-资格的结合 &lt;code&gt;E1&lt;/code&gt; 和 &lt;code&gt;E2&lt;/code&gt; ，否则（如果 &lt;code&gt;E2&lt;/code&gt; 是一个可变部件），它是挥发性-资格的结合 &lt;code&gt;E1&lt;/code&gt; 和 &lt;code&gt;E2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="1cf4d112436b803bd3d27d42c800897ab593f0ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; has class type cv &lt;code&gt;T&lt;/code&gt;, then.</source>
          <target state="translated">如果 &lt;code&gt;E&lt;/code&gt; 在&lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;函数调用表达式&lt;/a&gt; &lt;code&gt;E(args)&lt;/code&gt; 具有类类型CV &lt;code&gt;T&lt;/code&gt; ，然后。</target>
        </trans-unit>
        <trans-unit id="1b8acc70084ea7a5796bb6ffccc7d45f74616a97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;&lt;code&gt;E(args)&lt;/code&gt; names a set of overloaded functions and/or function templates (but not callable objects), the following rules are followed:</source>
          <target state="translated">如果 &lt;code&gt;E&lt;/code&gt; 在&lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;函数调用表达式&lt;/a&gt; &lt;code&gt;E(args)&lt;/code&gt; 的名称的一组过载功能和/或功能的模板（但不是可调用的对象）时，遵循以下规则：</target>
        </trans-unit>
        <trans-unit id="8b40eb284409f27422ea732b684b0f26cb4eef16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; is not a polymorphic class type, or if &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; is an inaccessible or ambiguous base class of &lt;code&gt;E&lt;/code&gt;, there is no effect.</source>
          <target state="translated">如果 &lt;code&gt;E&lt;/code&gt; 不是多态类类型，或者 &lt;code&gt;&lt;a href=&quot;nested_exception&quot;&gt;std::nested_exception&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;E&lt;/code&gt; 不可访问或模棱两可的基类，则无效。</target>
        </trans-unit>
        <trans-unit id="cfb9795d2d85864a23dfb415d8a0b25b1a06bb2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;E&lt;/code&gt; specifies a member function, it may be virtual, in which case the final overrider of that function will be called, using dynamic dispatch at runtime.</source>
          <target state="translated">如果 &lt;code&gt;E&lt;/code&gt; 指定一个成员函数，则它可以是虚拟的，在这种情况下，将在运行时使用动态分配来调用该函数的最终替代程序。</target>
        </trans-unit>
        <trans-unit id="7460d26bd30ccf50bedaefeb690ddad0b62aa2b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; exists and names a type, then &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; must be valid and name a type, and &lt;code&gt;Pred&lt;/code&gt; must be either &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; (the program is ill-formed otherwise).</source>
          <target state="translated">如果存在 &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; 并命名为类型，则 &lt;code&gt;Hash::transparent_key_equal::is_transparent&lt;/code&gt; 必须有效并命名为类型，并且 &lt;code&gt;Pred&lt;/code&gt; 必须为 &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../utility/functional/equal_to&quot;&gt;std::equal_to&lt;/a&gt;&amp;lt;Key&amp;gt;&lt;/code&gt; （程序出错） -否则形成）。</target>
        </trans-unit>
        <trans-unit id="e746872b3f4a32e36e22866e57c3635973587c0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is an integral type, equivalent to &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 是整数类型，则等效于 &lt;code&gt;basic_string(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="236dbe55a4e3dcd17001ed4b1e01a9528c512d6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; is not &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; by (possibly repeatedly) incrementing &lt;code&gt;first&lt;/code&gt;. If &lt;code&gt;InputIt&lt;/code&gt; is &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, the behavior is undefined if &lt;code&gt;last&lt;/code&gt; is not reachable from &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;first&lt;/code&gt; is not reachable from &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 不是&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;，如果这种行为是未定义 &lt;code&gt;last&lt;/code&gt; 是不是从到达 &lt;code&gt;first&lt;/code&gt; 通过（可能重复）递增 &lt;code&gt;first&lt;/code&gt; 。如果 &lt;code&gt;InputIt&lt;/code&gt; 是&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;，如果这种行为是未定义 &lt;code&gt;last&lt;/code&gt; 是不是从到达 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;first&lt;/code&gt; 是不可到达的 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7c4d085e7ff79e59c030b2b8c81a1702c66b3ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, this function rereads the input in order to detect duplicates.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;，则此函数重新读取输入以检测重复项。</target>
        </trans-unit>
        <trans-unit id="c3749207d2ce68de1c41a9f49f0c2035e0f8ee1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have &lt;code&gt;pointer&lt;/code&gt;, but has all other four member types, then the member types are declared as follows:</source>
          <target state="translated">如果 &lt;code&gt;Iter&lt;/code&gt; 没有 &lt;code&gt;pointer&lt;/code&gt; ，但具有所有其他四种成员类型，则成员类型声明如下：</target>
        </trans-unit>
        <trans-unit id="2654ba55a6d218cab7ca7778bb155b247c0f52ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Iter&lt;/code&gt; does not have all five member types &lt;code&gt;difference_type&lt;/code&gt;, &lt;code&gt;value_type&lt;/code&gt;, &lt;code&gt;pointer&lt;/code&gt;, &lt;code&gt;reference&lt;/code&gt;, and &lt;code&gt;iterator_category&lt;/code&gt;, then this template has no members by any of those names (&lt;code&gt;std::iterator_traits&lt;/code&gt; is SFINAE-friendly).</source>
          <target state="translated">如果 &lt;code&gt;Iter&lt;/code&gt; 项目没有全部五个成员类型 &lt;code&gt;difference_type&lt;/code&gt; ， &lt;code&gt;value_type&lt;/code&gt; ， &lt;code&gt;pointer&lt;/code&gt; ， &lt;code&gt;reference&lt;/code&gt; ，和 &lt;code&gt;iterator_category&lt;/code&gt; ，那么这个模板有任何这些名称没有成员（ &lt;code&gt;std::iterator_traits&lt;/code&gt; 是SFINAE友好）。</target>
        </trans-unit>
        <trans-unit id="f45e1c1900c90ccc18a25b3d04a0c5ca7a8286f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, the extent of the returned span &lt;code&gt;S&lt;/code&gt; is also &lt;code&gt;std::dynamic_extent&lt;/code&gt;; otherwise it is &lt;code&gt;sizeof(T) * N&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;N&lt;/code&gt; 为 &lt;code&gt;std::dynamic_extent&lt;/code&gt; ，则返回范围 &lt;code&gt;S&lt;/code&gt; 的范围也为 &lt;code&gt;std::dynamic_extent&lt;/code&gt; ；否则它是 &lt;code&gt;sizeof(T) * N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="347ac408b6a94a1c447cd287529327ba6fa3d9ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is defined as a macro name at the point in the source code where &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; is included, then &lt;code&gt;assert&lt;/code&gt; does nothing.</source>
          <target state="translated">如果在源代码中包含 &lt;code&gt;&amp;lt;cassert&amp;gt;&lt;/code&gt; 的位置将 &lt;code&gt;NDEBUG&lt;/code&gt; 定义为宏名，则 &lt;code&gt;assert&lt;/code&gt; 不会执行任何操作。</target>
        </trans-unit>
        <trans-unit id="f059b210d4e1ce59a4454923ec15e6398050571e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NDEBUG&lt;/code&gt; is not defined, then &lt;code&gt;assert&lt;/code&gt; checks if its argument (which must have scalar type) compares equal to zero. If it does, &lt;code&gt;assert&lt;/code&gt; outputs implementation-specific diagnostic information on the standard error output and calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;. The diagnostic information is required to include the text of &lt;code&gt;expression&lt;/code&gt;, as well as the values of the standard macros &lt;code&gt;__FILE__&lt;/code&gt;, &lt;code&gt;__LINE__&lt;/code&gt;, and the standard variable &lt;code&gt;__func__&lt;/code&gt;(since C++11).</source>
          <target state="translated">如果未定义 &lt;code&gt;NDEBUG&lt;/code&gt; ，则 &lt;code&gt;assert&lt;/code&gt; 会检查其参数（必须具有标量类型）是否等于零。如果是这样，则 &lt;code&gt;assert&lt;/code&gt; 在标准错误输出上输出特定于实现的诊断信息，并调用 &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; 。诊断信息需要包括的文本 &lt;code&gt;expression&lt;/code&gt; ，以及标准的宏的值 &lt;code&gt;__FILE__&lt;/code&gt; ， &lt;code&gt;__LINE__&lt;/code&gt; ，并且标准可变 &lt;code&gt;__func__&lt;/code&gt; （因为C ++ 11）。</target>
        </trans-unit>
        <trans-unit id="bf81f02b0ae53877b2da220b99b70dbdc5bf8ca4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a function parameter list &lt;code&gt;(T)&lt;/code&gt;, then each parameter &lt;code&gt;P&lt;/code&gt;i from that list is compared with the corresponding argument &lt;code&gt;A&lt;/code&gt;i from &lt;code&gt;A&lt;/code&gt;'s function parameter list. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its declarator is compared with each remaining &lt;code&gt;A&lt;/code&gt;i in the parameter type list of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;P&lt;/code&gt; 具有包含功能参数列表 &lt;code&gt;(T)&lt;/code&gt; 的形式之一，则将该列表中的每个参数 &lt;code&gt;P&lt;/code&gt; i与 &lt;code&gt;A&lt;/code&gt; 的功能参数列表中的对应参数 &lt;code&gt;A&lt;/code&gt; i 进行比较。如果最后一个 &lt;code&gt;P&lt;/code&gt; i是一个包扩展，则将其声明符与 &lt;code&gt;A&lt;/code&gt; 的参数类型列表中的每个其余A i进行 &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="03e7b27c0c840fc6ec6677dbe04f78b9c1de1735" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; has one of the forms that include a template parameter list &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt;, then each element &lt;code&gt;P&lt;/code&gt;i of that template argument list is matched against the corresponding template argument &lt;code&gt;A&lt;/code&gt;i of its &lt;code&gt;A&lt;/code&gt;. If the last &lt;code&gt;P&lt;/code&gt;i is a pack expansion, then its pattern is compared against each remaining argument in the template argument list of &lt;code&gt;A&lt;/code&gt;. A trailing parameter pack that is not otherwise deduced, is deduced to an empty parameter pack.</source>
          <target state="translated">如果 &lt;code&gt;P&lt;/code&gt; 具有包括模板参数列表 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;I&amp;gt;&lt;/code&gt; 的形式之一，则该模板参数列表的每个元素 &lt;code&gt;P&lt;/code&gt; i 与其 &lt;code&gt;A&lt;/code&gt; 的对应模板参数 &lt;code&gt;A&lt;/code&gt; i 匹配。如果最后一个 &lt;code&gt;P&lt;/code&gt; i是压缩扩展，则将其模式与 &lt;code&gt;A&lt;/code&gt; 的模板参数列表中的每个其余参数进行比较。否则未推断出的尾随参数包被推断为空参数包。</target>
        </trans-unit>
        <trans-unit id="0f363934a6c954657e01cc4569036680c0791d2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a function type, pointer to function type, or pointer to member function type and if &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;overloaded_address&quot;&gt;set of overloaded functions&lt;/a&gt; not containing function templates, template argument deduction is attempted with each overload. If only one succeeds, that successful deduction is used. If none or more than one succeeds, the template parameter is non-deduced context (see below):</source>
          <target state="translated">如果 &lt;code&gt;P&lt;/code&gt; 是函数类型，指向函数类型的指针或指向成员函数类型的指针，并且如果 &lt;code&gt;A&lt;/code&gt; 是一&lt;a href=&quot;overloaded_address&quot;&gt;组&lt;/a&gt;不包含函数模板的重载函数，则每次重载都会尝试推导模板参数。如果只有一个成功，则使用该成功的推论。如果没有一个或多个成功，则模板参数为非推导上下文（请参见下文）：</target>
        </trans-unit>
        <trans-unit id="798c24b5923fa6b7a5b42f42e0bab257c03db984" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is a reference type, it is replaced by the type referred to</source>
          <target state="translated">如果 &lt;code&gt;P&lt;/code&gt; 是引用类型，则将其替换为所引用的类型</target>
        </trans-unit>
        <trans-unit id="000d2698f624166e9817ec6b2bf3be4c6abd2d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;P&lt;/code&gt; is cv-qualified, &lt;code&gt;P&lt;/code&gt; is replaced with cv-unqualified version of itself</source>
          <target state="translated">如果 &lt;code&gt;P&lt;/code&gt; 是CV-合格， &lt;code&gt;P&lt;/code&gt; 替换的本身CV-不合格版本</target>
        </trans-unit>
        <trans-unit id="aaad64c2f2873b4fe56c05d24d46c262bd388e7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;State&lt;/code&gt; is trivially copy constructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy constructor. If &lt;code&gt;State&lt;/code&gt; is trivially copy assignable, &lt;code&gt;fpos&lt;/code&gt; has a trivial copy assignment operator. If &lt;code&gt;State&lt;/code&gt; is trivially destructible, &lt;code&gt;fpos&lt;/code&gt; has a trivial destructor.</source>
          <target state="translated">如果 &lt;code&gt;State&lt;/code&gt; 是平凡的副本可构造的，则 &lt;code&gt;fpos&lt;/code&gt; 具有平凡的副本构造函数。如果 &lt;code&gt;State&lt;/code&gt; 是普通副本分配运算符，则 &lt;code&gt;fpos&lt;/code&gt; 具有普通副本分配运算符。如果 &lt;code&gt;State&lt;/code&gt; 是微不足道的，则 &lt;code&gt;fpos&lt;/code&gt; 具有微不足道的析构函数。</target>
        </trans-unit>
        <trans-unit id="8dfc67b9e7a073b3ee7a9cff59bc3b6f0015ab5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both reference types, and the</source>
          <target state="translated">如果 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 都是引用类型，并且</target>
        </trans-unit>
        <trans-unit id="b4afe72a5e507713bb840e388d5e58f8a34204b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are both rvalue reference types: if the simple common reference type of &lt;code&gt;T1 &amp;amp;&lt;/code&gt; and &lt;code&gt;T2 &amp;amp;&lt;/code&gt; (determined according to the previous bullet) exists, then let &lt;code&gt;C&lt;/code&gt; denote that type's corresponding rvalue reference type. If &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then the simple common reference type of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 都是右值引用类型：如果存在 &lt;code&gt;T1 &amp;amp;&lt;/code&gt; 和 &lt;code&gt;T2 &amp;amp;&lt;/code&gt; 的简单公共引用类型（根据上一个项目符号确定），则让 &lt;code&gt;C&lt;/code&gt; 表示该类型对应的右值引用类型。如果 &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T1, C&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;T2, C&amp;gt;&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; ，那么简单的公共参考的类型 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 是 &lt;code&gt;C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acc4957d82e8a29ddb9310686f84a5c8e80923c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T1&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; is &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; (i.e., both are lvalue reference types): their simple common reference type is &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt;, where</source>
          <target state="translated">如果 &lt;code&gt;T1&lt;/code&gt; 是 &lt;code&gt;&lt;i&gt;cv1&lt;/i&gt; X &amp;amp;&lt;/code&gt; 并且 &lt;code&gt;T2&lt;/code&gt; 是 &lt;code&gt;&lt;i&gt;cv2&lt;/i&gt; Y &amp;amp;&lt;/code&gt; （即，都是左值引用类型）：它们的简单公共引用类型是 &lt;code&gt;decltype(false? &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 X &amp;amp;&amp;gt;() : &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;cv12 Y &amp;amp;&amp;gt;())&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="08dbf99d80fdb16cd55d43187dd92a8a606edf58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; (the template parameter of &lt;code&gt;shared_ptr&lt;/code&gt;) is an array type &lt;code&gt;U[N]&lt;/code&gt;, &lt;code&gt;idx&lt;/code&gt; must be less than &lt;code&gt;N&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; （ &lt;code&gt;shared_ptr&lt;/code&gt; 的模板参数）是数组类型 &lt;code&gt;U[N]&lt;/code&gt; ，则 &lt;code&gt;idx&lt;/code&gt; 必须小于 &lt;code&gt;N&lt;/code&gt; ，否则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="76e47a93376f512128c0f4db3b70d51d91d300a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; name the same type (including const/volatile qualifications), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; 命名为同一类型（包括const / volatile限定符），则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38278b1e8c4f34f7f9afed63ddee71b7095445d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; has a member typedef &lt;code&gt;allocator_type&lt;/code&gt; which is convertible from &lt;code&gt;Alloc&lt;/code&gt;or is an alias of &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt;(library fundamentals TS), the member constant &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 具有的typedef一个构件 &lt;code&gt;allocator_type&lt;/code&gt; 其转换从 &lt;code&gt;Alloc&lt;/code&gt; 或是一个别名 &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/erased_type&quot;&gt;std::experimental::erased_type&lt;/a&gt;&lt;/code&gt; （库基本面TS），该构件恒定 &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="81aa069be603406651761b390a77246a11143050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, a function type, or an array of unknown bound, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，函数类型或未知范围的数组，则 &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf221325f890a6ce6f02bee9daee7fe55c23f701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; and if any two objects of type &lt;code&gt;T&lt;/code&gt; with the same value have the same &lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;且如果 &lt;code&gt;T&lt;/code&gt; 类型的两个具有相同值的&lt;a href=&quot;../language/objects&quot;&gt;对象&lt;/a&gt;具有相同的对象表示形式，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd6768a7a8e61b9b33b46e7ee729a0e3a0f70982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; (that is, a scalar type, a trivially copyable class with a &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, or array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 为&lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt;（即标量类型，具有&lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;琐碎的默认构造函数&lt;/a&gt;的琐碎可复制的类或此类类型/类的数组，可能是cv限定的），则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1568f85d20b8988df4e7cc3a1520f513dcc3a32c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/derived_class&quot;&gt;derived class&lt;/a&gt; of some base &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;implicitly convertible&lt;/a&gt; to &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt;. The default deleter of the resulting &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; will use &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for &lt;code&gt;B&lt;/code&gt;, leading to &lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;undefined behavior&lt;/a&gt; unless the destructor of &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;. Note that &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; behaves differently: &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; will use the &lt;a href=&quot;new/operator_delete&quot;&gt;operator delete&lt;/a&gt; for the type &lt;code&gt;T&lt;/code&gt; and the owned object will be deleted correctly even if the destructor of &lt;code&gt;B&lt;/code&gt; is not &lt;a href=&quot;../language/virtual&quot;&gt;virtual&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个&lt;a href=&quot;../language/derived_class&quot;&gt;派生类&lt;/a&gt;的一些碱的 &lt;code&gt;B&lt;/code&gt; ，然后 &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 是&lt;a href=&quot;unique_ptr/unique_ptr&quot;&gt;隐式转换&lt;/a&gt;到 &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; 。所得的默认删除器 &lt;code&gt;std::unique_ptr&amp;lt;B&amp;gt;&lt;/code&gt; 将使用&lt;a href=&quot;new/operator_delete&quot;&gt;操作符删除&lt;/a&gt;为 &lt;code&gt;B&lt;/code&gt; ，导致&lt;a href=&quot;../language/destructor#Virtual_destructors&quot;&gt;未定义的行为&lt;/a&gt;除非的析构函数 &lt;code&gt;B&lt;/code&gt; 是&lt;a href=&quot;../language/virtual&quot;&gt;虚拟&lt;/a&gt;。请注意 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 行为有所不同： &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; 将对类型 &lt;code&gt;T&lt;/code&gt; 使用&lt;a href=&quot;new/operator_delete&quot;&gt;运算符delete&lt;/a&gt;并且即使 &lt;code&gt;B&lt;/code&gt; 的析构器不是&lt;a href=&quot;../language/virtual&quot;&gt;虚拟&lt;/a&gt;的，拥有的对象也将被正确删除。</target>
        </trans-unit>
        <trans-unit id="14d30fb0aa28f637b9fb71d066b29a527b12f2ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;polymorphic class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个&lt;a href=&quot;../language/objects#Polymorphic_objects&quot;&gt;多态类&lt;/a&gt;（即声明或继承至少一个虚函数的非联合类），则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9f4f4e6212d0ba8a754d82884bd2c1bd59ed77a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/type-id&quot;&gt;scalar type&lt;/a&gt; (that is a possibly cv-qualified &lt;a href=&quot;is_arithmetic&quot;&gt;arithmetic&lt;/a&gt;, pointer, &lt;a href=&quot;is_member_pointer&quot;&gt;pointer to member&lt;/a&gt;, &lt;a href=&quot;../language/enum&quot;&gt;enumeration&lt;/a&gt;, or &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是&lt;a href=&quot;../language/type-id&quot;&gt;标量类型&lt;/a&gt;（可能是cv限定的&lt;a href=&quot;is_arithmetic&quot;&gt;算术&lt;/a&gt;，指针，&lt;a href=&quot;is_member_pointer&quot;&gt;指向member的指针&lt;/a&gt;，&lt;a href=&quot;../language/enum&quot;&gt;枚举&lt;/a&gt;或 &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 类型），则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26b317cff4e6b234d366569c6bab42c37da84e1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt; (&quot;plain old data type&quot;), that is, both trivial and standard-layout, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是&lt;a href=&quot;../named_req/podtype&quot;&gt;PODType&lt;/a&gt;（&amp;ldquo;普通旧数据类型&amp;rdquo;），即琐碎的和标准布局的，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aabad78089db78755c758b0100bec563037cafec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;类型，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa4f125d6fcfcc5603d821627566fc4b66114754" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type and the cv-unqualified version of the type of other is &lt;code&gt;T&lt;/code&gt; or a class derived from &lt;code&gt;T&lt;/code&gt;, the &lt;a href=&quot;converting_constructor&quot;&gt;non-explicit constructors&lt;/a&gt; of &lt;code&gt;T&lt;/code&gt; are examined and the best match is selected by overload resolution. The constructor is then called to initialize the object.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个类类型和其他类型的CV-不合格版本 &lt;code&gt;T&lt;/code&gt; 或从派生的类 &lt;code&gt;T&lt;/code&gt; ，所述&lt;a href=&quot;converting_constructor&quot;&gt;非显式构造&lt;/a&gt;的 &lt;code&gt;T&lt;/code&gt; 进行检查和最佳匹配是由过载分辨率来选择。然后调用构造函数以初始化对象。</target>
        </trans-unit>
        <trans-unit id="da7735d51b45c0cf73d900692c844b55829fb21a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type that has no default constructor but has a constructor taking &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; is performed.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 的是，没有默认构造函数，但有一个构造服用类类型 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; ，&lt;a href=&quot;list_initialization&quot;&gt;列表初始化&lt;/a&gt;执行。</target>
        </trans-unit>
        <trans-unit id="bd5fd7b67551be2174ad147f6096e9f4d8ec3b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type,</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个类类型，</target>
        </trans-unit>
        <trans-unit id="ec4bcfea7a6b88492eb03ffb2367361b716260ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 为类类型，则 &lt;code&gt;T&lt;/code&gt; 为完整类型。否则，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="896d68960185cda4dfdf0280d92d7ef716c2b80f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class type, and the cv-unqualified version of the type of other is not &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, or if &lt;code&gt;T&lt;/code&gt; is non-class type, but the type of other is a class type, &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequences&lt;/a&gt; that can convert from the type of other to &lt;code&gt;T&lt;/code&gt; (or to a type derived from T if T is a class type and a conversion function is available) are examined and the best one is selected through overload resolution. The result of the conversion, which is a prvalue temporary(until C++17)prvalue expression(since C++17) if a &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; was used, is then used to &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialize&lt;/a&gt; the object. The last step is usually &lt;a href=&quot;copy_elision&quot;&gt;optimized out&lt;/a&gt; and the result of the conversion is constructed directly in the memory allocated for the target object, but the appropriate constructor (move or copy) is required to be accessible even though it's not used.(until C++17)</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是类类型，并且other类型的cv不合格版本不是 &lt;code&gt;T&lt;/code&gt; 或不是从 &lt;code&gt;T&lt;/code&gt; 派生的，或者 &lt;code&gt;T&lt;/code&gt; 是非类类型，但是other的类型是类类型，则&lt;a href=&quot;implicit_cast&quot;&gt;用户定义的转换序列&lt;/a&gt;可以将其他类型转换为 &lt;code&gt;T&lt;/code&gt; （如果T是类类型并且可以使用转换函数，则可以转换为从T派生的类型），然后通过重载分辨率选择最佳的。然后，如果使用&lt;a href=&quot;converting_constructor&quot;&gt;转换构造函数&lt;/a&gt;，则转换结果是prvalue临时（直到C ++ 17）到prvalue表达式（从C ++ 17开始），然后用于&lt;a href=&quot;direct_initialization&quot;&gt;直接初始化&lt;/a&gt;对象。最后一步通常是&lt;a href=&quot;copy_elision&quot;&gt;进行了优化，&lt;/a&gt;转换结果直接在为目标对象分配的内存中构造，但是即使不使用它，也必须可以访问适当的构造函数（移动或复制）。（直到C ++ 17）</target>
        </trans-unit>
        <trans-unit id="d1e8a1503abd79c3951a5fdc99d54970e61781da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a class, it</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个类，它</target>
        </trans-unit>
        <trans-unit id="ed233d36e232baacab8bc15f22e8a539e4afdd7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a complete enumeration type, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names the underlying type of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是完整的枚举类型，则提供成员typedef &lt;code&gt;type&lt;/code&gt; ，该类型为 &lt;code&gt;T&lt;/code&gt; 的基础类型。</target>
        </trans-unit>
        <trans-unit id="8db0456a21c631678465dcec0933012e0ff80219" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a compound type (that is, array, function, object pointer, function pointer, member object pointer, member function pointer, reference, class, union, or enumeration, including any cv-qualified variants), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是复合类型（即数组，函数，对象指针，函数指针，成员对象指针，成员函数指针，引用，类，联合或枚举，包括任何cv限定的变体），则提供成员常 &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef33179463348172c7683162235f438e5b4d890a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type (that is, &lt;code&gt;const&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个常量限定类型（即， &lt;code&gt;const&lt;/code&gt; ，或 &lt;code&gt;const volatile&lt;/code&gt; ），提供了构件恒定 &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6bd5fbe7c6f6fa50f124d44f0d758532e44d5237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a const-qualified type, it must be a class type with a user-provided default constructor.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是const限定类型，则它必须是具有用户提供的默认构造函数的类类型。</target>
        </trans-unit>
        <trans-unit id="91f7440ceeb8c74be7fd249bfe485e7779ba5401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a cv-qualified type, its cv-unqualified version is used for the purpose of default-initialization.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是cv限定类型，则其cv不限定版本用于默认初始化。</target>
        </trans-unit>
        <trans-unit id="e52096d9a275548201e72366e41ec09c171ba7e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a final class (that is, a class declared with the &lt;a href=&quot;../language/final&quot;&gt;final specifier&lt;/a&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是最终类（即用&lt;a href=&quot;../language/final&quot;&gt;最终说明符&lt;/a&gt;声明的类），则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0409542043a949225bfecbaf84bae28f3b1b559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a fundamental type (that is, arithmetic type, &lt;code&gt;void&lt;/code&gt;, or &lt;code&gt;nullptr_t&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是基本类型（即算术类型， &lt;code&gt;void&lt;/code&gt; 或 &lt;code&gt;nullptr_t&lt;/code&gt; ），则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="945c7b712dc29eea2b59cbb88e5b35a7559eb2f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a literal type, then this destructor is a trivial destructor.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 为文字类型，则此析构函数为琐碎的析构函数。</target>
        </trans-unit>
        <trans-unit id="64ca21f761a5e7e05def717cd2e2b74081f4cf00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a multidimensional array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是某种类型的多维数组 &lt;code&gt;X&lt;/code&gt; ，提供的typedef构件 &lt;code&gt;type&lt;/code&gt; 等于 &lt;code&gt;X&lt;/code&gt; ，否则 &lt;code&gt;type&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b1b0a24554bc1d76e3a383da4b1a44ea0d8546a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-class type, the value contained in the object is produced as the prvalue result. For a class type, this conversion.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是非类类型，则对象中包含的值将作为prvalue结果生成。对于类类型，此转换。</target>
        </trans-unit>
        <trans-unit id="69946f1172c363138f6dfe6642850f73c0486b56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a non-union class type, &lt;code&gt;T&lt;/code&gt; shall be a complete type; otherwise, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 为非工会类类型，则 &lt;code&gt;T&lt;/code&gt; 为完整类型。否则，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="81c8d7a5988a6dccdd619ff7a279df533a7a5150" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type (lvalue reference or rvalue reference), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是引用类型（左值引用或右值引用），则提供成员常 &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8dafe7774d902eba322cf87364d4aea07d531abd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type then &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; is always &lt;code&gt;false&lt;/code&gt;. The proper way to check a potentially-reference type for const-ness is to remove the reference: &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是引用类型，则 &lt;code&gt;is_const&amp;lt;T&amp;gt;::value&lt;/code&gt; 始终为 &lt;code&gt;false&lt;/code&gt; 。检查潜在引用类型是否具有 &lt;code&gt;is_const&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;gt;&lt;/code&gt; 的正确方法是删除引用：is_const &amp;lt;typename remove_reference &amp;lt;T&amp;gt; :: type&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="6ea9b4eb9eb04de1f92850f45ff1fddbdaee120f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a reference type, then provides the member typedef &lt;code&gt;type&lt;/code&gt; which is a pointer to the referred type.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是引用类型，则提供成员typedef &lt;code&gt;type&lt;/code&gt; ，该类型是指向引用类型的指针。</target>
        </trans-unit>
        <trans-unit id="2563eff1fa56e4b4ac0532f78126ffeeed82a1f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a scalar type, the object's initial value is the integral constant zero &lt;a href=&quot;explicit_cast&quot;&gt;explicitly converted&lt;/a&gt; to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 为标量类型，则对象的初始值为&lt;a href=&quot;explicit_cast&quot;&gt;明确转换&lt;/a&gt;为 &lt;code&gt;T&lt;/code&gt; 的积分常数零。</target>
        </trans-unit>
        <trans-unit id="87c045c1fc56928cd55cfd53cf91e06e54ae07d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a standard layout type (that is, a scalar type, a standard-layout class, or an array of such type/class, possibly cv-qualified), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是标准布局类型（即标量类型，标准布局类或此类类型/类的数组，可能是cv限定的），则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b944fcc6217049e07d88eb139271e7fb7cc4f093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a type with a virtual destructor, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是具有虚拟析构函数的类型，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4437c61374698795bc2e7b0a725c5aea0e02d36" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union type, the first non-static named data member is zero-initialized and all padding is initialized to zero bits.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是联合类型，则第一个非静态命名数据成员将初始化为零，并且所有填充都将初始化为零位。</target>
        </trans-unit>
        <trans-unit id="c4e59ca1d67fedc2671ca4bc2d55bea20110e0a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a volatile-qualified type (that is, &lt;code&gt;volatile&lt;/code&gt;, or &lt;code&gt;const volatile&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是易失性限定类型（即， &lt;code&gt;volatile&lt;/code&gt; ，或 &lt;code&gt;const volatile&lt;/code&gt; ），提供了构件恒定 &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="902b6c9678e19fc91eed33a7ee6f68dcf0f1506d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/abstract_class&quot;&gt;abstract class&lt;/a&gt; (that is, a non-union class that declares or inherits at least one pure virtual function), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个&lt;a href=&quot;../language/abstract_class&quot;&gt;抽象类&lt;/a&gt;（即声明或继承至少一个纯虚函数的非联合类），则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec8806b61c0e95ac652393c60f0f6708ecf1e2f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/type-id&quot;&gt;object type&lt;/a&gt; (that is any possibly cv-qualified type other than function, reference, or &lt;code&gt;void&lt;/code&gt; types), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个&lt;a href=&quot;../language/type-id&quot;&gt;对象类型&lt;/a&gt;（即比函数，参考，或其他任何可能的CV限定类型 &lt;code&gt;void&lt;/code&gt; 类型），提供了构件恒定 &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0fb50089c183d77cfb88879ad7a640e825184ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;, &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt; is performed.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是&lt;a href=&quot;aggregate_initialization&quot;&gt;聚合类型&lt;/a&gt;，则执行&lt;a href=&quot;aggregate_initialization&quot;&gt;聚合初始化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aa61f0f59c6b53db0c1c4a6741114952582e2eaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an aggregate type and the initializer list has a single element of the same or derived type (possibly cv-qualified), the object is initialized from that element (by &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; for copy-list-initialization, or by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; for direct-list-initialization).</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是聚合类型，并且初始化列表具有单个相同或派生类型的元素（可能是cv限定的），则从该元素初始化对象（通过&lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;进行copy-list-initialization或通过&lt;a href=&quot;direct_initialization&quot;&gt;direct-初始化&lt;/a&gt;直接列表初始化）。</target>
        </trans-unit>
        <trans-unit id="689228bd3413da8a5503b4c482886c287f618b2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type (that is, an integral type or a floating-point type) or a &lt;code&gt;cv-qualified&lt;/code&gt; version thereof, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是算术类型（即整数类型或浮点类型）或其 &lt;code&gt;cv-qualified&lt;/code&gt; 版本，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbccf0b2c1488a744757cc2db3268bc8b20be41f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the floating-point types and the signed integer types, and in &lt;code&gt;false&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是算术式，提供了构件恒定 &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt; ，如果 &lt;code&gt;T(-1) &amp;lt; T(0)&lt;/code&gt; ：此结果在 &lt;code&gt;true&lt;/code&gt; 的浮点类型和签名的整数类型，并且在 &lt;code&gt;false&lt;/code&gt; 的无符号整数类型和 &lt;code&gt;bool&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="fcba9f80c891b0c1e133e1cb6925e4162b876bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an arithmetic type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt;: this results in &lt;code&gt;true&lt;/code&gt; for the unsigned integer types and the type &lt;code&gt;bool&lt;/code&gt; and in &lt;code&gt;false&lt;/code&gt; for the signed integer types and the floating-point types.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是算术式，提供了构件恒定 &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt; ，如果 &lt;code&gt;T(0) &amp;lt; T(-1)&lt;/code&gt; ：此结果在 &lt;code&gt;true&lt;/code&gt; 的无符号整数类型和类型 &lt;code&gt;bool&lt;/code&gt; 和在 &lt;code&gt;false&lt;/code&gt; 的整数类型签署和浮动点类型。</target>
        </trans-unit>
        <trans-unit id="c1fc66fc47bed74ebe67e8cc80e0ae9110815b91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array of some type &lt;code&gt;X&lt;/code&gt;, provides the member typedef &lt;code&gt;type&lt;/code&gt; equal to &lt;code&gt;X&lt;/code&gt;, otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;. Note that if T is a multidimensional array, only the first dimension is removed.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是某种类型的阵列 &lt;code&gt;X&lt;/code&gt; ，提供的typedef构件 &lt;code&gt;type&lt;/code&gt; 等于 &lt;code&gt;X&lt;/code&gt; ，否则 &lt;code&gt;type&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 。请注意，如果T是多维数组，则仅移除第一维。</target>
        </trans-unit>
        <trans-unit id="79fca8c3f06baf2e5727ef4a8e28e151e6f0be48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[N]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[N]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an array type &lt;code&gt;U[]&lt;/code&gt;, these constructors do not participate in overload resolution if &lt;code&gt;Y(*)[]&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;. Otherwise, these constructors do not participate in overload resolution if &lt;code&gt;Y*&lt;/code&gt; is not convertible to &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是数组类型 &lt;code&gt;U[N]&lt;/code&gt; ，则当 &lt;code&gt;Y(*)[N]&lt;/code&gt; 无法转换为 &lt;code&gt;T*&lt;/code&gt; ，这些构造方法将不参与重载解析。如果 &lt;code&gt;T&lt;/code&gt; 是数组类型 &lt;code&gt;U[]&lt;/code&gt; ，则当 &lt;code&gt;Y(*)[]&lt;/code&gt; 无法转换为 &lt;code&gt;T*&lt;/code&gt; ，这些构造方法将不参与重载解析。否则，如果 &lt;code&gt;Y*&lt;/code&gt; 不可转换为 &lt;code&gt;T*&lt;/code&gt; ，则这些构造函数将不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="0b5f23983416e1c75433eb3c8db868b92738cbbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type,</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是数组类型</target>
        </trans-unit>
        <trans-unit id="40f6a482e9f6bb37f7f795348ce26482a687ee2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of dimensions of the array. For any other type, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是数组类型，则提供等于数组维数的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 均为0。</target>
        </trans-unit>
        <trans-unit id="50b11c4cc0a3bc2aa8bbbd2ffae9d6dac98f5145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an array type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to the number of elements along the &lt;code&gt;N&lt;/code&gt;th dimension of the array, if &lt;code&gt;N&lt;/code&gt; is in &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt;. For any other type, or if &lt;code&gt;T&lt;/code&gt; is array of unknown bound along its first dimension and &lt;code&gt;N&lt;/code&gt; is 0, &lt;code&gt;value&lt;/code&gt; is 0.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 为数组类型，则提供成员常 &lt;code&gt;value&lt;/code&gt; ，该值等于沿着数组第 &lt;code&gt;N&lt;/code&gt; 个维度的元素数，如果 &lt;code&gt;N&lt;/code&gt; 在 &lt;code&gt;[0, std::rank&amp;lt;T&amp;gt;::value)&lt;/code&gt; 。对于任何其他类型，或者如果 &lt;code&gt;T&lt;/code&gt; 是沿其第一维的未知范围的数组并且 &lt;code&gt;N&lt;/code&gt; 为0，则 &lt;code&gt;value&lt;/code&gt; 0。</target>
        </trans-unit>
        <trans-unit id="d418fb8b71e5b3d9f326ce97a54075d08f82dec3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an empty type (that is, a non-union class type with no non-static data members other than bit-fields of size 0, no virtual functions, no virtual base classes, and no non-empty base classes), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个空类型（即，一个非联合类类型，除了大小为0的位字段外，没有非静态数据成员，没有虚拟函数，没有虚拟基类，也没有非空基类），提供构件恒定 &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="615ee340215311c44d8a0200015cab668b08669e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error code enumeration, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是错误代码枚举，则此模板将提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f00d4c8f60284c8e8a5d4214a2b023ed99513026" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an error condition enum, this template provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个错误条件枚举，则此模板提供的成员常 &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64661dfb24aa2b41c7a58f86cc3e8e06dff1cc46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the signed integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是整数（布尔型除外）或枚举类型，则为成员typedef &lt;code&gt;type&lt;/code&gt; （与 &lt;code&gt;T&lt;/code&gt; 对应的有符号整数类型）提供相同的cv限定词。</target>
        </trans-unit>
        <trans-unit id="f9f1f9d4a2f0ac4a591a53f86518618b379c091c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integral (except bool) or enumeration type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the unsigned integer type corresponding to &lt;code&gt;T&lt;/code&gt;, with the same cv-qualifiers. The unsigned integer type corresponding to an enumeration type is the unsigned integer type with the smallest &lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;rank&lt;/a&gt; having the same &lt;code&gt;sizeof&lt;/code&gt; as the enumeration.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是整数（布尔型除外）或枚举类型，则为成员typedef &lt;code&gt;type&lt;/code&gt; （与 &lt;code&gt;T&lt;/code&gt; 对应的无符号整数类型）提供相同的cv限定词。对应于枚举类型的无符号整数类型是具有与枚举相同的 &lt;code&gt;sizeof&lt;/code&gt; 的最小&lt;a href=&quot;../language/implicit_cast#Integral_promotion&quot;&gt;秩&lt;/a&gt;的无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="c91459dde93fa1a39419b8fda3571b1d3f2524ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an non-union class type, all base classes and non-static data members are zero-initialized, and all padding is initialized to zero bits. The constructors, if any, are ignored.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是非联合类类型，则所有基类和非静态数据成员都将初始化为零，并且所有填充都将初始化为零位。构造函数（如果有）将被忽略。</target>
        </trans-unit>
        <trans-unit id="c1d5d737127c3f29b041ec54c37e9b91100e0f8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an object type, then, for the type &lt;code&gt;U&lt;/code&gt; equal &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt;, if the expression &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; is well-formed in unevaluated context, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; equals &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是对象类型，则对于类型 &lt;code&gt;U&lt;/code&gt; ,等于 &lt;code&gt;&lt;a href=&quot;remove_all_extents&quot;&gt;std::remove_all_extents&lt;/a&gt;&amp;lt;T&amp;gt;::type&lt;/code&gt; ，如果表达式 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;amp;&amp;gt;().~U()&lt;/code&gt; 在未求值的上下文中格式正确， &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;true&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 等于 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c22afe114b35ac81cf800a1156d7baffcb6d3c14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is array type, each element is zero-initialized</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是数组类型，则每个元素都将初始化为零</target>
        </trans-unit>
        <trans-unit id="dea68d51090e5d0f319644a92de20fb3d9b95d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the program that specializes &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; is ill-formed.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 不是&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;，专门程序 &lt;code&gt;std::tx_exception&amp;lt;T&amp;gt;&lt;/code&gt; 是形成不良的。</target>
        </trans-unit>
        <trans-unit id="73b3d58d3922df960693448a6c809c6309de2344" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not a standard placeholder type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 不是标准的占位符类型，则此模板源自 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,0&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ee1c8ebae98c21b02f68dd05886f8fe92f20e99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is not const-qualified, then &lt;code&gt;rv&lt;/code&gt;'s resulting state (after the definition/expression is evaluated in either bullets above) is valid but unspecified; otherwise, it is unchanged.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 不是const限定的，则 &lt;code&gt;rv&lt;/code&gt; 的结果状态（在以上任一项目符号中定义/表达式求值之后）有效，但未指定；否则，它保持不变。</target>
        </trans-unit>
        <trans-unit id="615bba93f7cf789b20b52441a5845c09300784e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is pointer to non-static member object or a pointer to non-static member function, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是指向非静态成员对象的指针或指向非静态成员函数的指针，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5ac84ccbccc9198a7ab09ce3b026f6c47e5ff46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is reference type, nothing is done.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是引用类型，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="2f854a51cba2ddf3f5cc88ad123c5f24a105a0f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type of a standard placeholder (_1, _2, _3, ...), then this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是标准占位符的类型（_1，_2，_3，...），则此模板派生自 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,1&amp;gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,2&amp;gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int,3&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f81cf7e82856e3e7cad5504cd15ee27f838ea825" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is the type produced by a call to &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;. For any other type, this template is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是通过调用 &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 产生的类型，则此模板是从 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 。对于其他任何类型，此模板均源自 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51e3546d16456aa08a11e4cc71a3bbf5dec35bfe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is trivially-destructible, then this destructor is also trivial, so &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; is also trivially-destructible.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是琐碎可分解的，则此析构函数也是琐碎的，因此 &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; 也是琐碎的。</target>
        </trans-unit>
        <trans-unit id="d31c04866aa7a4ef595b5ddda4f6ba3e2b023b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; models &lt;a href=&quot;../concepts/defaultconstructible&quot;&gt;&lt;code&gt;DefaultConstructible&lt;/code&gt;&lt;/a&gt;, the default constructor of &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; constructs a semiregular wrapper containing a value-initialized &lt;code&gt;T&lt;/code&gt; and is equivalent to:</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 模型为&lt;a href=&quot;../concepts/defaultconstructible&quot;&gt; &lt;code&gt;DefaultConstructible&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;&lt;i&gt;semiregular&lt;/i&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 的默认构造函数将构造一个半正则包装器，该包装器包含一个值初始化的 &lt;code&gt;T&lt;/code&gt; ，并且等效于：</target>
        </trans-unit>
        <trans-unit id="02a86ca705d443044b0fbfb7fbc9ab041d9a2f6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; names the type &quot;array of &lt;code&gt;U&lt;/code&gt;&quot; or &quot;reference to array of &lt;code&gt;U&lt;/code&gt;&quot;, the member typedef &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;U*&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 将类型命名为&amp;ldquo; &lt;code&gt;U&lt;/code&gt; 的数组&amp;rdquo;或&amp;ldquo;对 &lt;code&gt;U&lt;/code&gt; 的引用&amp;rdquo;，则成员typedef &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;U*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c2891f9d56d7ae3301606af512c7f8ffc24cd7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 满足&lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType的&lt;/a&gt;所有要求，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ac1553fe834dd9a1efb1dfce83c0e4902b9cd37a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; satisfies the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 满足&lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt;要求，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c87275ecad38359126e4f40cf9ccd9918c5e81e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 的move构造函数不是 &lt;code&gt;noexcept&lt;/code&gt; ,并且T不可将&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;插入 &lt;code&gt;*this&lt;/code&gt; ，则vector将使用抛出的move构造函数。如果抛出，则放弃担保，并且影响未指定。</target>
        </trans-unit>
        <trans-unit id="407149e5ef249263ab827511e7e341fc16d6fcf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T_i&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; is also &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T_i&lt;/code&gt; 是 &lt;code&gt;bool&lt;/code&gt; （可能是cv限定），则仅在 &lt;code&gt;std:remove_cvref_t&amp;lt;T&amp;gt;&lt;/code&gt; 也是 &lt;code&gt;bool&lt;/code&gt; 时才考虑 &lt;code&gt;F(T_i)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4907a3ab559108aaf0ecc4b4c630266b6c2f7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;V&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed. If &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; is not representable in &lt;code&gt;std::intmax_t&lt;/code&gt;, the program is ill-formed unless the implementation yields correct values for &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;std::intmax_t&lt;/code&gt; 不能表示 &lt;code&gt;U&lt;/code&gt; 或 &lt;code&gt;V&lt;/code&gt; ，则程序格式错误。如果 &lt;code&gt;Num&lt;/code&gt; 或 &lt;code&gt;Denom&lt;/code&gt; 在 &lt;code&gt;std::intmax_t&lt;/code&gt; 不可表示，则程序格式错误，除非实现产生 &lt;code&gt;U&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 的正确值。</target>
        </trans-unit>
        <trans-unit id="1339288b4eceede884dbe475de639d7a8e96920b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="translated">如果 &lt;code&gt;X&lt;/code&gt; 不支持分配器，则将该术语定义为好像 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; ，除了不需要创建分配器对象，并且不实例化 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 用户定义特殊化。</target>
        </trans-unit>
        <trans-unit id="e215c6bfa230a8fadbd8fa567ff0d1dcc73d9d4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; is not allocator-aware, the term is defined as if &lt;code&gt;A&lt;/code&gt; were &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt;, except that no allocator object needs to be created, and user-defined specializations of &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; are not instantiated.</source>
          <target state="translated">如果 &lt;code&gt;X&lt;/code&gt; 不支持分配器，则将该术语定义为好像 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;std::allocator&amp;lt;T&amp;gt;&lt;/code&gt; ，只是不需要创建分配器对象，并且不会实例化 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 用户定义特殊化。</target>
        </trans-unit>
        <trans-unit id="708924c7b6f5980aac166862125db725c9025582" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty or if no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;[s_first, s_last)&lt;/code&gt; 为空，或者没有找到这样的序列，则返回 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4de674a59bdc38a4524989e3aa936059b297e948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[s_first, s_last)&lt;/code&gt; is empty, &lt;code&gt;first&lt;/code&gt; is returned. (since C++11)</source>
          <target state="translated">如果 &lt;code&gt;[s_first, s_last)&lt;/code&gt; 为空，则返回 &lt;code&gt;first&lt;/code&gt; 。（自C ++ 11起）</target>
        </trans-unit>
        <trans-unit id="ac8a7837d00559195769abe3422b2d4b64b0803f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; and &lt;code&gt;b &amp;lt; c&lt;/code&gt; then &lt;code&gt;a &amp;lt; c&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 和 &lt;code&gt;b &amp;lt; c&lt;/code&gt; 则 &lt;code&gt;a &amp;lt; c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0fbd3756fc442152ea5c157999e136ae32a5c4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a &amp;lt; b&lt;/code&gt; then &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 那么 &lt;code&gt;!(b &amp;lt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca13a23e17308315822746f838d58d67fdc10969" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt; and &lt;code&gt;b == c&lt;/code&gt;, then &lt;code&gt;a == c&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;a == b&lt;/code&gt; 和 &lt;code&gt;b == c&lt;/code&gt; ，则 &lt;code&gt;a == c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57b477a3ad052ca87058c8d285998bd3826578b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="translated">如果 &lt;code&gt;a == b&lt;/code&gt; ，则后续对不接受 &lt;code&gt;param_type&lt;/code&gt; 对象的&lt;a href=&quot;operator()&quot;&gt; &lt;code&gt;operator()&lt;/code&gt; &lt;/a&gt;重载的调用将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="058ec9eda946d2f87a4c67ddd844abb0705335fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a == b&lt;/code&gt;, then &lt;code&gt;b == a&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;a == b&lt;/code&gt; ，则 &lt;code&gt;b == a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e95c4991d153eb49fcdeb67a49f232435c188d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; compare equal (&lt;code&gt;a == b&lt;/code&gt; is contextually convertible to &lt;code&gt;true&lt;/code&gt;) then either they are both non-dereferenceable or &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; are references bound to the same object</source>
          <target state="translated">如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 比较相等（ &lt;code&gt;a == b&lt;/code&gt; 在上下文中可转换为 &lt;code&gt;true&lt;/code&gt; ），则它们都是不可取消引用的，或者 &lt;code&gt;*a&lt;/code&gt; 和 &lt;code&gt;*b&lt;/code&gt; 是绑定到同一对象的引用</target>
        </trans-unit>
        <trans-unit id="b0965a7f22c182c2dc94b342ec734afedbfb197f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and Stage 1 representation began with 0x or 0X, will pad after the x or X</source>
          <target state="translated">如果 &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; 并且阶段1表示形式以0x或0X开头，则将在x或X之后填充</target>
        </trans-unit>
        <trans-unit id="55fb07ae63090e46c1b31757c60deb3993a02ead" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; and a sign character occurs in the representation, will pad after the sign</source>
          <target state="translated">如果 &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::internal&lt;/a&gt;&lt;/code&gt; 并且表示中出现符号字符，则将在符号后填充</target>
        </trans-unit>
        <trans-unit id="df7f9cf85073b22f00c706bbf069fde1413ff653" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, will pad after</source>
          <target state="translated">如果 &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; ，将在之后填充</target>
        </trans-unit>
        <trans-unit id="efe26e828a675b79b7ef6061fde6939469a2c778" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt;, will pad before</source>
          <target state="translated">如果 &lt;code&gt;adjustfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::right&lt;/a&gt;&lt;/code&gt; ，则将在</target>
        </trans-unit>
        <trans-unit id="6ee5eea45cb84fb94f59a5848a1a90638eee5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alignof(T)&lt;/code&gt; is not a valid expression, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;alignof(T)&lt;/code&gt; 不是有效的表达式，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="39035be25eaa7a5daa7ee9badf8db195c8f6f1c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为&amp;plusmn;&amp;infin;，则返回+&amp;infin;</target>
        </trans-unit>
        <trans-unit id="dc64028dd5e1343ad289a2a638ecad4eabe7dfc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为&amp;plusmn;&amp;infin;，则引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 并返回实现定义的值</target>
        </trans-unit>
        <trans-unit id="212c6a1d0fbeb2a948b299caf94641bec455cf7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned unmodified</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为&amp;plusmn;&amp;infin;，则返回原样</target>
        </trans-unit>
        <trans-unit id="3af634b2f314cdb14e21e2e232aa0d848e98f5e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为&amp;plusmn;&amp;infin;，则将其返回，并将未指定的值存储在 &lt;code&gt;*exp&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="2926296a9d3ae122af29b30e2bff2458387535b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为&amp;plusmn;&amp;infin;，则返回，不修改</target>
        </trans-unit>
        <trans-unit id="dcb585953813ddfd53495aac0adc0c6028656a9c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;&amp;infin;, or NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为&amp;plusmn;0，&amp;plusmn;&amp;infin;或NaN， &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 引发FE_INVALID。</target>
        </trans-unit>
        <trans-unit id="97a7ce4796bb66aaa2d696b735ad8ca62a0d506b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为&amp;plusmn;0，则返回-&amp;infin;并引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c925fdb14d37c5af0412f43389d6420fcbebc31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为&amp;plusmn;0，则返回原样</target>
        </trans-unit>
        <trans-unit id="b763f3ae25fa4af1639d7559710e6c7dfb77bb58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified, and &lt;code&gt;0&lt;/code&gt; is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为&amp;plusmn;0，则返回它，不对其进行修改，并将 &lt;code&gt;0&lt;/code&gt; 存储在 &lt;code&gt;*exp&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="5f109ac78880a8e0fd5ca3edc07d2d1bf947af61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为NaN，则引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 并返回实现定义的值</target>
        </trans-unit>
        <trans-unit id="40f86add69087dfb700cacff3b1846927488c73a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为NaN，则返回NaN</target>
        </trans-unit>
        <trans-unit id="5f68328ad47978170da252aebc348fd2a3ba01b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned, and an unspecified value is stored in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为NaN，则返回NaN，并且未指定的值存储在 &lt;code&gt;*exp&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="1b0e2c569c27377f09ed2aa7f3f01ddd8ab82ed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is NaN, NaN is returned.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为NaN，则返回NaN。</target>
        </trans-unit>
        <trans-unit id="b47b8c75e53c96b45595a288fa682cfb71c94c2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a NaN, &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 是NaN，则返回 &lt;code&gt;FP_ILOGBNAN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="103047025bbc6992cc2c0159391152d1cac0b073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::lgamma(arg)&lt;/code&gt; is the logarithm of the factorial of &lt;code&gt;arg-1&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 是自然数，则 &lt;code&gt;std::lgamma(arg)&lt;/code&gt; 是 &lt;code&gt;arg-1&lt;/code&gt; 的阶乘的对数。</target>
        </trans-unit>
        <trans-unit id="b0d43e3c2f39b7c1f66e9428682a4d9539c507a8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is a natural number, &lt;code&gt;std::tgamma(arg)&lt;/code&gt; is the factorial of &lt;code&gt;arg-1&lt;/code&gt;. Many implementations calculate the exact integer-domain factorial if the argument is a sufficiently small integer.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 是自然数，则 &lt;code&gt;std::tgamma(arg)&lt;/code&gt; 是 &lt;code&gt;arg-1&lt;/code&gt; 的阶乘。如果参数是足够小的整数，则许多实现都可以计算出精确的整数域阶乘。</target>
        </trans-unit>
        <trans-unit id="2b3d194b382b4cec828f1996e8820c92fc1bc82f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is infinite, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 是无限的，则返回 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e168df92098d4104c20f40ff2c56e9cb3e43970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not a floating-point number, the behavior is unspecified.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 不是浮点数，则行为未指定。</target>
        </trans-unit>
        <trans-unit id="2804f0355d48777b9700b17ec3da3dcca55d9469" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is not zero, infinite, or NaN, the value returned is exactly equivalent to &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 不为零，无限或NaN，则返回的值完全等于 &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;logb&quot;&gt;std::logb&lt;/a&gt;(arg))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="210d2992bbf2bb7d542ddc01b1a18747c781302a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error may occur.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为零或小于零的整数，则可能发生极点错误。</target>
        </trans-unit>
        <trans-unit id="05dafa4d596b7b6f157f2afaee02072f8d977259" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero or is an integer less than zero, a pole error or a domain error may occur.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为零或小于零的整数，则可能发生极点错误或域错误。</target>
        </trans-unit>
        <trans-unit id="c39db051a1df2187c97bcf9b3a8feca13bc7aae3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, &lt;code&gt;FP_ILOGB0&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为零，则返回 &lt;code&gt;FP_ILOGB0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4481c06a081e138b96375d6a39a2024c3db3720a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arg&lt;/code&gt; is zero, returns zero and stores zero in &lt;code&gt;*exp&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 为零，则返回零，并将零存储在 &lt;code&gt;*exp&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="277ca8d97ddf64738fdbd1aa4e973cb1bc8ff33f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is true, the returned bitmask is suitable for matching characters without regard to their case.</source>
          <target state="translated">如果 &lt;code&gt;b&lt;/code&gt; 为true，则返回的位掩码适合于匹配字符，而不考虑它们的大小写。</target>
        </trans-unit>
        <trans-unit id="bc2ce27f23e51347316eec1df499f96102e63b30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;TIME_UTC&lt;/code&gt;, then.</source>
          <target state="translated">如果 &lt;code&gt;base&lt;/code&gt; 为 &lt;code&gt;TIME_UTC&lt;/code&gt; ，则为。</target>
        </trans-unit>
        <trans-unit id="39772be1360347ea75162c3cf41cc79a0690aefc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exp&lt;/code&gt; is finite and non-integer, a domain error occurs and a range error may occur.</source>
          <target state="translated">如果 &lt;code&gt;base&lt;/code&gt; 为有限且为负，而 &lt;code&gt;exp&lt;/code&gt; 为有限且非整数，则将发生域错误，并且可能会发生范围错误。</target>
        </trans-unit>
        <trans-unit id="fcb4bb9772be34cee0a2ea72f8a48a52aed0d515" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is negative, a domain error or a pole error may occur.</source>
          <target state="translated">如果 &lt;code&gt;base&lt;/code&gt; 为零且 &lt;code&gt;exp&lt;/code&gt; 为负，则可能会发生域错误或极点错误。</target>
        </trans-unit>
        <trans-unit id="8cefb315066ca34b099a440410777215c4c88531" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;base&lt;/code&gt; is zero and &lt;code&gt;exp&lt;/code&gt; is zero, a domain error may occur.</source>
          <target state="translated">如果 &lt;code&gt;base&lt;/code&gt; 为零且 &lt;code&gt;exp&lt;/code&gt; 为零，则可能会发生域错误。</target>
        </trans-unit>
        <trans-unit id="735a9c2b9ccda41b360b2ccc955e4ce336eebbf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == 0&lt;/code&gt;, will use conversion specifier &lt;code&gt;%i&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;basefield == 0&lt;/code&gt; ，将使用转换说明符 &lt;code&gt;%i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="72b1b1221364073e1a83ddb04c69595be539a496" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%x&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;basefield == hex &amp;amp;&amp;amp; !uppercase&lt;/code&gt; ，将使用转换说明符 &lt;code&gt;%x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4a2fc2012f6b4718df5c8bbc44f6bc3ac7c622d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == hex&lt;/code&gt;, will use conversion specifier &lt;code&gt;%X&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;basefield == hex&lt;/code&gt; ，将使用转换说明符 &lt;code&gt;%X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abc0fd7910d8386906f231979d946d3d6fcf720b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;basefield == oct&lt;/code&gt;, will use conversion specifier &lt;code&gt;%o&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;basefield == oct&lt;/code&gt; ，将使用转换说明符 &lt;code&gt;%o&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dafca5cc04b66da6cecdcb0541cbba62d4fe3fca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;begin == end&lt;/code&gt;, do nothing. Otherwise,</source>
          <target state="translated">如果 &lt;code&gt;begin == end&lt;/code&gt; ，则不执行任何操作。除此以外，</target>
        </trans-unit>
        <trans-unit id="bc82eb0dcae0fc58deeb2027018fdeadab408395" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; and &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">如果 &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; 和 &lt;code&gt;bool(b &amp;lt; c)&lt;/code&gt; 都为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;bool(a &amp;lt; c)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="0c3b57cf400e324fc93a37880e317b6a3f4e7284" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha != 0&lt;/code&gt; obtains &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; if &lt;code&gt;v == true&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; if &lt;code&gt;v == false&lt;/code&gt;, and outputs each successive character &lt;code&gt;c&lt;/code&gt; of that string to &lt;code&gt;out&lt;/code&gt; with &lt;code&gt;*out++ = c&lt;/code&gt;. No further processing is done in this case, the function returns &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;boolalpha != 0&lt;/code&gt; 获得 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).truename()&lt;/code&gt; 如果 &lt;code&gt;v == true&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).falsename()&lt;/code&gt; 如果 &lt;code&gt;v == false&lt;/code&gt; ，并使用 &lt;code&gt;*out++ = c&lt;/code&gt; 将该字符串的每个连续字符 &lt;code&gt;c&lt;/code&gt; 输出到 &lt;code&gt;out&lt;/code&gt; 。在这种情况下，不做进一步处理，该函数返回 &lt;code&gt;out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="209116e8fd40fdecd41f59a58ba5cba05cc96e2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;boolalpha == 0&lt;/code&gt;, then converts &lt;code&gt;v&lt;/code&gt; to type &lt;code&gt;int&lt;/code&gt; and performs integer output.</source>
          <target state="translated">如果 &lt;code&gt;boolalpha == 0&lt;/code&gt; ，则将 &lt;code&gt;v&lt;/code&gt; 转换为 &lt;code&gt;int&lt;/code&gt; 类型并执行整数输出。</target>
        </trans-unit>
        <trans-unit id="701f5d02367a24c659b0e907a89da5f3ee588ad7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is a null pointer, resizes the internal buffer to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 是空指针，则将内部缓冲区的 &lt;code&gt;size&lt;/code&gt; 调整为size。</target>
        </trans-unit>
        <trans-unit id="bb7a30a4993475e7a73929ac360a9b27b0b3f966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not a null pointer, instructs the stream to use the user-provided buffer of size &lt;code&gt;size&lt;/code&gt; beginning at &lt;code&gt;buffer&lt;/code&gt;. The stream must be closed (with &lt;code&gt;fclose&lt;/code&gt;) before the &lt;a href=&quot;../../language/lifetime&quot;&gt;lifetime&lt;/a&gt; of the array pointed to by &lt;code&gt;buffer&lt;/code&gt; ends. The contents of the array after a successful call to &lt;code&gt;setvbuf&lt;/code&gt; are indeterminate and any attempt to use it is undefined behavior.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 不是null指针，则指示流使用用户提供的 &lt;code&gt;size&lt;/code&gt; 从 &lt;code&gt;buffer&lt;/code&gt; 开始的大小的缓冲区。必须在 &lt;code&gt;buffer&lt;/code&gt; 结束指向的数组&lt;a href=&quot;../../language/lifetime&quot;&gt;生存&lt;/a&gt;期之前关闭流（使用 &lt;code&gt;fclose&lt;/code&gt; ）。成功调用 &lt;code&gt;setvbuf&lt;/code&gt; 之后，数组的内容是不确定的，任何使用它的尝试都是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="a4aa2a51ab02bfef78d16d2394217fe58c759175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is not null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 不为null，则等效于 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, buffer, &lt;a href=&quot;../c&quot;&gt;_IOFBF&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;BUFSIZ&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fda3355283db2eca141b2739a1e7b6dba9c66231" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is null, equivalent to &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt;, which turns off buffering.</source>
          <target state="translated">如果 &lt;code&gt;buffer&lt;/code&gt; 为null，则等效于 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;(stream, &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &lt;a href=&quot;../c&quot;&gt;_IONBF&lt;/a&gt;, 0)&lt;/code&gt; ，这将关闭缓冲。</target>
        </trans-unit>
        <trans-unit id="4dd6d32ffac07b48320fad08007c3cbc378f1ccf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c16&lt;/code&gt; is not the final code unit in a 16-bit representation of a wide character, it does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">如果 &lt;code&gt;c16&lt;/code&gt; 不是宽字符的16位表示形式中的最终代码单元，则它不会写入 &lt;code&gt;s&lt;/code&gt; 指向的数组，仅 &lt;code&gt;*ps&lt;/code&gt; 被更新。</target>
        </trans-unit>
        <trans-unit id="43266a7e25edde20659efab6eb44b99980e95ed3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is invalid (does not contribute to a sequence of &lt;code&gt;char8_t&lt;/code&gt; corresponding to a valid multibyte character), the value of the macro &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; is stored in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;(size_t)(-1)&lt;/code&gt; is returned, and the conversion state is unspecified.</source>
          <target state="translated">如果 &lt;code&gt;c8&lt;/code&gt; 无效（不有助于对应于有效多字节字符的 &lt;code&gt;char8_t&lt;/code&gt; 序列），则宏 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; 的值存储在 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 中，返回 &lt;code&gt;(size_t)(-1)&lt;/code&gt; ，并且转换状态不确定。</target>
        </trans-unit>
        <trans-unit id="120e5087c8f2519bdf8d8babc3ba6bf88d5575b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is not the final UTF-8 code unit in a representation of a code point, the function does not write to the array pointed to by &lt;code&gt;s&lt;/code&gt;, only &lt;code&gt;*ps&lt;/code&gt; is updated.</source>
          <target state="translated">如果 &lt;code&gt;c8&lt;/code&gt; 不是代码点表示形式中的最终UTF-8代码单元，则该函数不会写入 &lt;code&gt;s&lt;/code&gt; 所指向的数组，仅更新 &lt;code&gt;*ps&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e2b9d98d74c329c422daa370d8349ea12b339fed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c8&lt;/code&gt; is the null character &lt;code&gt;u8'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">如果 &lt;code&gt;c8&lt;/code&gt; 是空字符 &lt;code&gt;u8'\0'&lt;/code&gt; ，则存储一个空字节，其后是恢复初始移位状态所需的任何移位序列，并且转换状态参数 &lt;code&gt;*ps&lt;/code&gt; 被更新以表示初始移位状态。</target>
        </trans-unit>
        <trans-unit id="9b496091b9a18ce0c88a971b0705f925544a2dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is the end-of-file indicator (&lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt;), then there is no character to append. The function does nothing and returns an unspecified value other than &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;c&lt;/code&gt; 是文件结尾指示符（ &lt;code&gt;traits::eq_int_type(c,traits::eof()) == true&lt;/code&gt; ），则没有附加字符。该函数不执行任何操作，并且返回除 &lt;code&gt;traits::eof()&lt;/code&gt; 之外的未指定值。</target>
        </trans-unit>
        <trans-unit id="d45180121f410762cee0225f3231172974d6d196" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, returns some value other than &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;. Otherwise, returns &lt;code&gt;(unsigned char)(c)&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">如果 &lt;code&gt;c==&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; ，则返回 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 以外的其他值。否则，成功则返回 &lt;code&gt;(unsigned char)(c)&lt;/code&gt; ，失败则返回 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b94f81efb67c916047d31de0fff924013dd49d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, pushes the character &lt;code&gt;ch&lt;/code&gt; (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that character. The external device associated with the stream is not modified.</source>
          <target state="translated">如果 &lt;code&gt;ch&lt;/code&gt; 不等于 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; ，则将字符 &lt;code&gt;ch&lt;/code&gt; （重新解释为 &lt;code&gt;unsigned char&lt;/code&gt; ）推入与流 &lt;code&gt;stream&lt;/code&gt; 关联的输入缓冲区中，其方式是，从 &lt;code&gt;stream&lt;/code&gt; 进行后续读取操作将检索该字符。与流关联的外部设备未修改。</target>
        </trans-unit>
        <trans-unit id="d30189f2e98ef3c7b1c57bfc6a779e2cf97492e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; does not equal &lt;code&gt;WEOF&lt;/code&gt;, pushes the wide character &lt;code&gt;ch&lt;/code&gt; into the input buffer associated with the stream &lt;code&gt;stream&lt;/code&gt; in such a manner than subsequent read operation from &lt;code&gt;stream&lt;/code&gt; will retrieve that wide character. The external device associated with the stream is not modified.</source>
          <target state="translated">如果 &lt;code&gt;ch&lt;/code&gt; 不等于 &lt;code&gt;WEOF&lt;/code&gt; ，则以这样一种方式将宽字符 &lt;code&gt;ch&lt;/code&gt; 推入与流 &lt;code&gt;stream&lt;/code&gt; 关联的输入缓冲区中，其方式是，随后从 &lt;code&gt;stream&lt;/code&gt; 进行的读取操作将检索该宽字符。与流关联的外部设备未修改。</target>
        </trans-unit>
        <trans-unit id="f9dcd2adfbf165acf0dba129b8151a07f338a6fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">如果 &lt;code&gt;ch&lt;/code&gt; 等于 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; ，则操作失败，并且流不受影响。</target>
        </trans-unit>
        <trans-unit id="6a114914a7e8a31a9eee7e4f7ac5bc1b503807f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch&lt;/code&gt; equals &lt;code&gt;WEOF&lt;/code&gt;, the operation fails and the stream is not affected.</source>
          <target state="translated">如果 &lt;code&gt;ch&lt;/code&gt; 等于 &lt;code&gt;WEOF&lt;/code&gt; ，则操作失败，并且流不受影响。</target>
        </trans-unit>
        <trans-unit id="eb3d10516cbec80af986272f9e48f6efa09dd2d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;command&lt;/code&gt; is a null pointer, checks if the host environment has a command processor and returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">如果 &lt;code&gt;command&lt;/code&gt; 是空指针，则检查主机环境是否具有命令处理器，并且仅当命令处理器存在时才返回非零值。</target>
        </trans-unit>
        <trans-unit id="85aea9f0ae028fe2640a672d5e277a7841d76dc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp(a,b)==true&lt;/code&gt; then &lt;code&gt;comp(b,a)==false&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;comp(a,b)==true&lt;/code&gt; ,则 &lt;code&gt;comp(b,a)==false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f7a074b5aca822ff123427c78123491180762d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;comp&lt;/code&gt; indicates two elements as equivalent, their order is unspecified.</source>
          <target state="translated">如果 &lt;code&gt;comp&lt;/code&gt; 表示两个元素相等，则它们的顺序不确定。</target>
        </trans-unit>
        <trans-unit id="0175bc0a73471ec1cd27562640c1d6735174424d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::directories_only&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing</source>
          <target state="translated">如果在 &lt;code&gt;options&lt;/code&gt; 中存在 &lt;code&gt;copy_options::directories_only&lt;/code&gt; 执行任何操作</target>
        </trans-unit>
        <trans-unit id="815d288d8f8c46dcfd1ed95e2c2d74b9bc1cb888" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; is present in &lt;code&gt;options&lt;/code&gt;, does nothing.</source>
          <target state="translated">如果 &lt;code&gt;copy_options::skip_symlink&lt;/code&gt; 存在于 &lt;code&gt;options&lt;/code&gt; ，什么也不做。</target>
        </trans-unit>
        <trans-unit id="18daaf9d57908b8b11d5a5ce74779de8f547638e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt;, then &lt;code&gt;dest&lt;/code&gt; is allowed to be a null pointer.</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 为 &lt;code&gt;​0​&lt;/code&gt; ，则 &lt;code&gt;dest&lt;/code&gt; 允许为空指针。</target>
        </trans-unit>
        <trans-unit id="6e56b4ab0e5150566fb64d55ba8a1e8a4d01e821" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting character array is not null-terminated.</source>
          <target state="translated">如果在复制整个字符串 &lt;code&gt;src&lt;/code&gt; 之前已达到 &lt;code&gt;count&lt;/code&gt; ，则所得的字符数组不会以null终止。</target>
        </trans-unit>
        <trans-unit id="3896321b9a85e601977b36e1c20e47272d800cfd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is reached before the entire string &lt;code&gt;src&lt;/code&gt; was copied, the resulting wide character array is not null-terminated.</source>
          <target state="translated">如果在复制整个字符串 &lt;code&gt;src&lt;/code&gt; 之前已达到 &lt;code&gt;count&lt;/code&gt; ，则所得的宽字符数组不会以null终止。</target>
        </trans-unit>
        <trans-unit id="06245894aa3eefe9ed953846b24765091a53209d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero or negative, &lt;code&gt;first&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 为零或负数，则返回 &lt;code&gt;first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f336d1b1de719a5985455a6d30969f36f1d4096" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, strings are considered equal.</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 为零，则字符串视为相等。</target>
        </trans-unit>
        <trans-unit id="3f2e6aaeeb8e09e4e7d2914ab4ee68da289d48f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function does nothing.</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 为零，则该函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="7ad8eda07b3297819cd8064cc3589079cc052fd8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;count&lt;/code&gt; is zero, the function returns a null pointer.</source>
          <target state="translated">如果 &lt;code&gt;count&lt;/code&gt; 为零，则该函数返回空指针。</target>
        </trans-unit>
        <trans-unit id="57a3e0d836eef087c17311ab2dbe908db83c04f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d_&lt;/code&gt; is a member variable holding the duration (i.e., time since epoch) of this &lt;code&gt;time_point&lt;/code&gt; object,</source>
          <target state="translated">如果 &lt;code&gt;d_&lt;/code&gt; 是保存此 &lt;code&gt;time_point&lt;/code&gt; 对象的持续时间（即从纪元开始的时间）的成员变量，</target>
        </trans-unit>
        <trans-unit id="3bbc1c66920a4038f904392405e8bb0f323da835" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;del&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it is assumed that the array was allocated with &lt;code&gt;new[]&lt;/code&gt;, and the destructor of this facet will call &lt;code&gt;delete[] tbl&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;del&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则假定为数组分配了 &lt;code&gt;new[]&lt;/code&gt; ，并且此构面的析构函数将调用 &lt;code&gt;delete[] tbl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f2fea471de8b3d0628642cbd7cd79e507ef237c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dir&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; or the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;​0​&lt;/code&gt;, and the most resent operation done on this filebuf object was output (that is, either the put buffer is not empty, or the most recently called function was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;), then calls &lt;code&gt;std::codecvt::unshift&lt;/code&gt; to determine the unshift sequence necessary, and writes that sequence to the file by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;dir&lt;/code&gt; 没有 &lt;code&gt;&lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::basic_ios::cur&lt;/a&gt;&lt;/code&gt; 或抵消 &lt;code&gt;off&lt;/code&gt; 不是 &lt;code&gt;​0​&lt;/code&gt; ，这filebuf对象上做了最反感的操作是输出（即，无论是放置缓冲区不是空的，或者最近调用函数是 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; ），然后调用 &lt;code&gt;std::codecvt::unshift&lt;/code&gt; 确定必要的取消移位序列，并通过调用 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 将序列写入文件。</target>
        </trans-unit>
        <trans-unit id="57e5dcca2d6fb73331af4ef11d3a2dcb0d17f4d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a class member access expression (&lt;code&gt;e1.e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt;), the potential results of the object expression e1 is included in the set.</source>
          <target state="translated">如果 &lt;code&gt;e&lt;/code&gt; 是类成员访问表达式（ &lt;code&gt;e1.e2&lt;/code&gt; 或 &lt;code&gt;e1-&amp;gt;e2&lt;/code&gt; ），则对象表达式e1的潜在结果包含在集合中。</target>
        </trans-unit>
        <trans-unit id="a611f1da12dbf6983879f4306f9df44390150021" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a comma expression (&lt;code&gt;e1,e2&lt;/code&gt;), the potential results of &lt;code&gt;e2&lt;/code&gt; are in the set of potential results</source>
          <target state="translated">如果 &lt;code&gt;e&lt;/code&gt; 是逗号表达式（ &lt;code&gt;e1,e2&lt;/code&gt; ），的潜在结果 &lt;code&gt;e2&lt;/code&gt; 是在该组的潜在结果</target>
        </trans-unit>
        <trans-unit id="b272bd28e80dd2ac2a3667aaa761508a1896965d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a glvalue conditional expression (&lt;code&gt;e1?e2:e3&lt;/code&gt;, where e2 and e3 are glvalues), the union of the potential results of &lt;code&gt;e2&lt;/code&gt; and &lt;code&gt;e3&lt;/code&gt; are both included in the set.</source>
          <target state="translated">如果 &lt;code&gt;e&lt;/code&gt; 是glvalue条件表达式（ &lt;code&gt;e1?e2:e3&lt;/code&gt; ，其中e2和e3是glvalues），则 &lt;code&gt;e2&lt;/code&gt; 和 &lt;code&gt;e3&lt;/code&gt; 的潜在结果的并集都包括在集合中。</target>
        </trans-unit>
        <trans-unit id="2d9fdf08ba2dfa789e82b39c3610d8ef047043a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is a pointer-to-member access expression (&lt;code&gt;e1.*e2&lt;/code&gt; or &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt;) whose second operand is a constant expression, the potential results of the object expression e1 are included in the set</source>
          <target state="translated">如果 &lt;code&gt;e&lt;/code&gt; 是第二个操作数是常量表达式的成员访问指针的表达式（ &lt;code&gt;e1.*e2&lt;/code&gt; 或 &lt;code&gt;e1-&amp;gt;*e2&lt;/code&gt; ），则对象表达式e1的潜在结果包含在集合中</target>
        </trans-unit>
        <trans-unit id="136ae657a0856415b88b024f787e7474c99acad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt;, the expression &lt;code&gt;e&lt;/code&gt; is its only potential result</source>
          <target state="translated">如果 &lt;code&gt;e&lt;/code&gt; 是&lt;a href=&quot;expressions&quot;&gt;id表达式&lt;/a&gt;，则表达式 &lt;code&gt;e&lt;/code&gt; 是其唯一可能的结果</target>
        </trans-unit>
        <trans-unit id="6a6dd1d96309aaabbc396100ce7a188d685eba16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an array subscript expression (&lt;code&gt;e1[e2]&lt;/code&gt;) where one of the operands is an array, the potential results of that operand is included in the set</source>
          <target state="translated">如果 &lt;code&gt;e&lt;/code&gt; 是其中一个操作数是数组的数组下标表达式（ &lt;code&gt;e1[e2]&lt;/code&gt; ），则该操作数的潜在结果包含在集合中</target>
        </trans-unit>
        <trans-unit id="a6876c60a5df4d3a02319ae4acfd99744e4aad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an expression in parentheses (&lt;code&gt;(e1)&lt;/code&gt;), the potential results of &lt;code&gt;e1&lt;/code&gt; are included in the set</source>
          <target state="translated">如果 &lt;code&gt;e&lt;/code&gt; 是在括号中的表达式（ &lt;code&gt;(e1)&lt;/code&gt; ），的潜在结果 &lt;code&gt;e1&lt;/code&gt; 被包括在该组</target>
        </trans-unit>
        <trans-unit id="af0a58bc0809e3f4c48c7935533640bb84b6d5da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eofbit&lt;/code&gt; is set on the stream prior to the call, the construction of the sentry object will set &lt;code&gt;failbit&lt;/code&gt;.</source>
          <target state="translated">如果在调用之前在流上设置了 &lt;code&gt;eofbit&lt;/code&gt; ，则岗哨对象的构造将设置 &lt;code&gt;failbit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce0473bb777b78c63cd5012d3ff7b7e662f591ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt; and &lt;code&gt;equiv(b,c)==true&lt;/code&gt;, then &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;equiv(a,b)==true&lt;/code&gt; 和 &lt;code&gt;equiv(b,c)==true&lt;/code&gt; ，则 &lt;code&gt;equiv(a,c)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ba38a247100280f8e41691728cc66000be9e271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;equiv(a,b)==true&lt;/code&gt;, then &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;equiv(a,b)==true&lt;/code&gt; ，则 &lt;code&gt;equiv(b,a)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="007bad278d6b4bc6d719829636a93a4a9c5a31b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt;, an implementation-defined status indicating successful termination is returned to the host environment. If &lt;code&gt;exit_code&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt;, an implementation-defined status, indicating</source>
          <target state="translated">如果 &lt;code&gt;exit_code&lt;/code&gt; 为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_SUCCESS&lt;/a&gt;&lt;/code&gt; ，则表示成功终止的实现定义状态将返回到主机环境。如果 &lt;code&gt;exit_code&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;exit_status&quot;&gt;EXIT_FAILURE&lt;/a&gt;&lt;/code&gt; ，则是实现定义的状态，指示</target>
        </trans-unit>
        <trans-unit id="f710623c293fe447df3d92556a487868ef46a327" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exp&lt;/code&gt; is 0, then &lt;code&gt;x&lt;/code&gt; is returned, unmodified</source>
          <target state="translated">如果 &lt;code&gt;exp&lt;/code&gt; 为0，则返回 &lt;code&gt;x&lt;/code&gt; ，且未修改</target>
        </trans-unit>
        <trans-unit id="fb1e695a18ffeb815e38e42b92e43f2bd57d73e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; is a &lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;pointer to member function&lt;/a&gt; of class &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">如果 &lt;code&gt;f&lt;/code&gt; 是&lt;a href=&quot;../../language/pointer#Pointers_to_member_functions&quot;&gt;指向&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 类的成员函数的指针：</target>
        </trans-unit>
        <trans-unit id="4837b4b3957d1d06787bdcfc0793edea20847145" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fail()==true&lt;/code&gt;, returns &lt;code&gt;pos_type(-1)&lt;/code&gt;. Otherwise, returns &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;fail()==true&lt;/code&gt; ，则返回 &lt;code&gt;pos_type(-1)&lt;/code&gt; 。否则，返回 &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0463e8b7f222245f189b3d034b86d7447da42d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;failed()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;, inserts the character &lt;code&gt;c&lt;/code&gt; into the associated stream buffer by calling &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt;, where &lt;code&gt;pbuf&lt;/code&gt; is the private member of type &lt;code&gt;streambuf_type*&lt;/code&gt;. Otherwise, does nothing.</source>
          <target state="translated">如果 &lt;code&gt;failed()&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; ，则通过调用 &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; 将字符 &lt;code&gt;c&lt;/code&gt; 插入关联的流缓冲区，其中 &lt;code&gt;pbuf&lt;/code&gt; 是 &lt;code&gt;streambuf_type*&lt;/code&gt; 类型的私有成员。否则，什么都不做。</target>
        </trans-unit>
        <trans-unit id="5400983ef77493ea136e60df816cfe45d2e66859" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt; or &lt;code&gt;first1 == last1&lt;/code&gt;, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="translated">如果 &lt;code&gt;first == last&lt;/code&gt; 或 &lt;code&gt;first1 == last1&lt;/code&gt; ，则返回未经修改的 &lt;code&gt;init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e003924877b9a466eeb7d707612a5f3ab0c7f79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;first == last&lt;/code&gt;, this function has no effect and will merely return &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;first == last&lt;/code&gt; ，则此函数无效，仅返回 &lt;code&gt;d_first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3800b7d6b3d5edad60afa41413956ee387d068de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt;, only the first match is replaced.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 包含 &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_first_only&lt;/a&gt;&lt;/code&gt; ，则仅替换第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="8971b9fbad479977ae5fffcd5b1ef85254f363f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt;, the non-matched subsequences are not copied into &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;flags&lt;/code&gt; 包含 &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::format_no_copy&lt;/a&gt;&lt;/code&gt; ，则不匹配的子序列不会复制到 &lt;code&gt;out&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="afcd9815060753d019811a5dfbfcd47253700f41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%a&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;) &amp;amp;&amp;amp; !uppercase&lt;/code&gt; ，将使用转换说明符 &lt;code&gt;%a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a696cef7fabb97b740bacedd6f505fc04deb3ca2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;, will use conversion specifier &lt;code&gt;%A&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt; ，将使用转换说明符 &lt;code&gt;%A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7df1b6bc3f01af8b0302af4f0306bba39947fde8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%f&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;&lt;/code&gt; ，将使用转换说明符 &lt;code&gt;%f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea893d1e69d7bcb42e6183b8b13629895919af1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt;, will use conversion specifier &lt;code&gt;%e&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt; &amp;amp;&amp;amp; !uppercase&lt;/code&gt; ，将使用转换说明符 &lt;code&gt;%e&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="479647145b4986f0d7bf8bafb84a155b21c78b60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt;, will use conversion specifier &lt;code&gt;%E&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;floatfield == &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;&lt;/code&gt; ，将使用转换说明符 &lt;code&gt;%E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="305a95ccb899fefeb95b7edf07cbcae48fc8c6b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; are the same file as determined by &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="translated">如果 &lt;code&gt;from&lt;/code&gt; 和 &lt;code&gt;to&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;equivalent&quot;&gt;std::filesystem::equivalent&lt;/a&gt;&lt;/code&gt; 确定的文件相同，则报告错误</target>
        </trans-unit>
        <trans-unit id="5981efb911c3a456cb02b7dc34b28f6d5a818dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; does not exist, reports an error.</source>
          <target state="translated">如果 &lt;code&gt;from&lt;/code&gt; 不存在，则报告错误。</target>
        </trans-unit>
        <trans-unit id="433f5d85237ac4e480b0d07ce3da6cac640403a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a directory, but &lt;code&gt;to&lt;/code&gt; is a regular file, reports an error</source>
          <target state="translated">如果 &lt;code&gt;from&lt;/code&gt; 是目录，但是 &lt;code&gt;to&lt;/code&gt; 是常规文件，则报告错误</target>
        </trans-unit>
        <trans-unit id="77fcdb49cb08776e21d9d86e94d339ee3a5b233d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from&lt;/code&gt; is a symbolic link, then</source>
          <target state="translated">如果 &lt;code&gt;from&lt;/code&gt; 是符号链接，则</target>
        </trans-unit>
        <trans-unit id="d60be77b3f79d2ace2289a720e9b7a98142b9a06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">如果 &lt;code&gt;from_stream&lt;/code&gt; 无法解析格式字符串所指定的所有内容，或者解析的信息不足以指定完整的结果，或者如果解析揭示了矛盾的信息，则 &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9f4f8c173e4f387e8d6984eea14c0c97052549e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from_stream&lt;/code&gt; fails to parse everything specified by the format string, or if insufficient information is parsed to specify a complete result, or if parsing discloses contradictory information, &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called.</source>
          <target state="translated">如果 &lt;code&gt;from_stream&lt;/code&gt; 无法解析格式字符串所指定的所有内容，或者解析的信息不足以指定完整的结果，或者如果解析揭示了矛盾的信息，则 &lt;code&gt;is.setstate(&lt;a href=&quot;../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0b2248b896ee027fabe63c433625c357d75a244" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;g&lt;/code&gt; is volatile-qualified (i.e., its cv-qualifiers are either &lt;code&gt;volatile&lt;/code&gt; or &lt;code&gt;const volatile&lt;/code&gt;), the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;g&lt;/code&gt; 是volatile限定的（即，它的cv限定词是 &lt;code&gt;volatile&lt;/code&gt; 或 &lt;code&gt;const volatile&lt;/code&gt; ），则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="ec3b72193abe9aedc79922cd71ce4f681ce5bb3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;get() == nullptr&lt;/code&gt; there are no effects. Otherwise, the owned object is destroyed via &lt;a href=&quot;get_deleter&quot;&gt;&lt;code&gt;get_deleter()&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;get&quot;&gt;&lt;code&gt;(get())&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;get() == nullptr&lt;/code&gt; ，则没有效果。否则，将通过&lt;a href=&quot;get_deleter&quot;&gt; &lt;code&gt;get_deleter()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;get&quot;&gt; &lt;code&gt;(get())&lt;/code&gt; &lt;/a&gt;销毁拥有的对象。</target>
        </trans-unit>
        <trans-unit id="8cfb0ef527264e13542d3e75250bf692fe5adcb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;good() == true&lt;/code&gt;, returns the next character as obtained by &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;good() == true&lt;/code&gt; ，则返回 &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt; 获得的下一个字符。</target>
        </trans-unit>
        <trans-unit id="d798bdc7a53000bbd5ee8924ceef0cc19c68c7ef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;has_relative_path()&lt;/code&gt; returns false, the result is a copy of &lt;code&gt;*this&lt;/code&gt; Otherwise, the result is a path whose generic format pathname is the longest prefix of the generic format pathname of &lt;code&gt;*this&lt;/code&gt; that produces one fewer element in its iteration.</source>
          <target state="translated">如果 &lt;code&gt;has_relative_path()&lt;/code&gt; 返回false，结果是副本 &lt;code&gt;*this&lt;/code&gt; 否则，结果是，其一般格式是路径的通用格式路径名的最长前缀的路径 &lt;code&gt;*this&lt;/code&gt; 产生于它的迭代少一个元素。</target>
        </trans-unit>
        <trans-unit id="3dea94fff00231911d476ee1bc47f5dd6bbd2db9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i == j&lt;/code&gt; and &lt;code&gt;(i, j)&lt;/code&gt; is in the domain of &lt;code&gt;==&lt;/code&gt; then this is equivalent to &lt;code&gt;*j&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;i == j&lt;/code&gt; 且 &lt;code&gt;(i, j)&lt;/code&gt; 在 &lt;code&gt;==&lt;/code&gt; 的域中，则等价于 &lt;code&gt;*j&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13008673cd8597a506cf3daa8b3ec63d08a1c87c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;imbue()&lt;/code&gt; has been never called for this object, then the global locale at the time of the call is returned. Otherwise, the locale passed to the last call to &lt;code&gt;imbue()&lt;/code&gt; is returned.</source>
          <target state="translated">如果从未为该对象调用过 &lt;code&gt;imbue()&lt;/code&gt; ，则将返回调用时的全局语言环境。否则，返回传递给上次对 &lt;code&gt;imbue()&lt;/code&gt; 的调用的语言环境。</target>
        </trans-unit>
        <trans-unit id="9f7a6d2892cb99819b50181c82d0ac33627baaf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;in==end&lt;/code&gt;, Stage 2 is terminated immediately, no further characters are extracted</source>
          <target state="translated">如果 &lt;code&gt;in==end&lt;/code&gt; ，阶段2立即终止，则不会提取其他字符</target>
        </trans-unit>
        <trans-unit id="f94d93ea046597d6595e925ae9e6a64c0253802b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;index() == 0&lt;/code&gt;, returns a &lt;code&gt;sys_days&lt;/code&gt; that represents the date 7 days prior to the first &lt;code&gt;weekday()&lt;/code&gt; of the year and month.</source>
          <target state="translated">如果 &lt;code&gt;index() == 0&lt;/code&gt; ，则返回一个 &lt;code&gt;sys_days&lt;/code&gt; ，它表示年份和月份中第一个Weekday &lt;code&gt;weekday()&lt;/code&gt; 之前7天的日期。</target>
        </trans-unit>
        <trans-unit id="b47ea618b12678469ff2fd08038755240643eae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, calls &lt;code&gt;is.setstate(failbit)&lt;/code&gt;(since c++11) and returns. Otherwise, if &lt;code&gt;is.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. This call can be suppressed if the put area of &lt;code&gt;is.tie()&lt;/code&gt; is empty. The implementation may defer the call to &lt;code&gt;flush&lt;/code&gt; until a call of &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; occurs. If no such call occurs before the sentry object is destroyed, it may be eliminated entirely.</source>
          <target state="translated">如果 &lt;code&gt;is.good()&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则调用 &lt;code&gt;is.setstate(failbit)&lt;/code&gt; （自c ++ 11起）并返回。否则，如果 &lt;code&gt;is.tie()&lt;/code&gt; 不是空指针，则调用 &lt;code&gt;is.tie()-&amp;gt;flush()&lt;/code&gt; 将输出序列与外部流同步。如果 &lt;code&gt;is.tie()&lt;/code&gt; 的放置区域为空，则可以禁止此调用。该实现可以推迟对 &lt;code&gt;flush&lt;/code&gt; 的调用，直到发生 &lt;code&gt;is.rdbuf()-&amp;gt;underflow()&lt;/code&gt; 调用为止。如果在销毁哨兵对象之前没有发生此类调用，则可以将其完全消除。</target>
        </trans-unit>
        <trans-unit id="bbdd95c99548814da982d8d20409a38ef7943968" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;isfinite(t) &amp;amp;&amp;amp; a == b&lt;/code&gt; ，则结果等于 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a92eff5b31f025e8461e121aee4c206aa32fb17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt;, the result is not &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;isfinite(t) || (!isnan(t) &amp;amp;&amp;amp; b-a&amp;nbsp;!= 0)&lt;/code&gt; ，结果不是 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c5e504a6bd1ecb25be6b144ecd53c96279275a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;islower&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="translated">如果 &lt;code&gt;islower&lt;/code&gt; 返回一个非零值，则可以确保 &lt;code&gt;iscntrl&lt;/code&gt; ， &lt;code&gt;isdigit&lt;/code&gt; ， &lt;code&gt;ispunct&lt;/code&gt; 和 &lt;code&gt;isspace&lt;/code&gt; 对于同一C语言环境中的同一字符返回零。</target>
        </trans-unit>
        <trans-unit id="eeb4299451f00a6bbc3cc54d9636ef15cfbc4d81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isupper&lt;/code&gt; returns a nonzero value, it is guaranteed that &lt;code&gt;iscntrl&lt;/code&gt;, &lt;code&gt;isdigit&lt;/code&gt;, &lt;code&gt;ispunct&lt;/code&gt;, and &lt;code&gt;isspace&lt;/code&gt; return zero for the same character in the same C locale.</source>
          <target state="translated">如果 &lt;code&gt;isupper&lt;/code&gt; 返回一个非零值，则可以确保 &lt;code&gt;iscntrl&lt;/code&gt; ， &lt;code&gt;isdigit&lt;/code&gt; ， &lt;code&gt;ispunct&lt;/code&gt; 和 &lt;code&gt;isspace&lt;/code&gt; 对于同一C语言环境中的同一字符返回零。</target>
        </trans-unit>
        <trans-unit id="1cf4537f9c301149e8cc2a31615b3d035dfb3d45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;lock&lt;/code&gt; 是由已经拥有一个线程调用 &lt;code&gt;mutex&lt;/code&gt; 在任何模式（共享或独占），则该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="1025c2a2787ed452c780e1dcd1489b21d28b0a1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined: for example, the program</source>
          <target state="translated">如果已经拥有 &lt;code&gt;mutex&lt;/code&gt; 的线程调用了 &lt;code&gt;lock&lt;/code&gt; ，则行为是不确定的：例如，程序</target>
        </trans-unit>
        <trans-unit id="9a44d1e0b185f370bee6a94519b229c4dac6e172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lock_shared&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (exclusive or shared), the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;lock_shared&lt;/code&gt; 由已经以任何方式（独占或共享）拥有 &lt;code&gt;mutex&lt;/code&gt; 的线程调用，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="4b1ebf8b0f2f951edb330b8fa8ae0d36a2cd369c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; is a &lt;a href=&quot;../language/static&quot;&gt;static member&lt;/a&gt; or a &lt;a href=&quot;../language/member_functions&quot;&gt;member function&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;member&lt;/code&gt; 是&lt;a href=&quot;../language/static&quot;&gt;静态成员&lt;/a&gt;或&lt;a href=&quot;../language/member_functions&quot;&gt;成员函数&lt;/a&gt;，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="d629e4399641b9530158823e61e45ef4cbd7a6cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mode &amp;gt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; wide-oriented. If &lt;code&gt;mode &amp;lt; 0&lt;/code&gt;, attempts to make &lt;code&gt;stream&lt;/code&gt; byte-oriented. If &lt;code&gt;mode==0&lt;/code&gt;, only queries the current orientation of the stream.</source>
          <target state="translated">如果 &lt;code&gt;mode &amp;gt; 0&lt;/code&gt; ，则尝试使 &lt;code&gt;stream&lt;/code&gt; 面向广泛。如果 &lt;code&gt;mode &amp;lt; 0&lt;/code&gt; ，则尝试使 &lt;code&gt;stream&lt;/code&gt; 面向字节。如果 &lt;code&gt;mode==0&lt;/code&gt; ，则仅查询流的当前方向。</target>
        </trans-unit>
        <trans-unit id="c3e26d9cac416d20dc7c2b6fc8e45df72eb4d94c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;money_base::space&lt;/code&gt; or &lt;code&gt;money_base::none&lt;/code&gt; is the last element in the &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, the parser does not attempt to consume any whitespace after the other components of the monetary value were parsed. Otherwise, one or more whitespace characters are consumed where &lt;code&gt;money_base::space&lt;/code&gt; appears.</source>
          <target state="translated">如果 &lt;code&gt;money_base::space&lt;/code&gt; 或 &lt;code&gt;money_base::none&lt;/code&gt; 在最后一个元素 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; ，该解析器不尝试消耗任何空白的货币价值的其他组件进行解析后。否则，将在出现 &lt;code&gt;money_base::space&lt;/code&gt; 地方消耗一个或多个空格字符。</target>
        </trans-unit>
        <trans-unit id="e2acebccacc05bdce0834871463fa8d41cad28a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.grouping()&lt;/code&gt; does not permit thousands separators, the first separator encountered is treated as a parsing error, otherwise they are treated as optional.</source>
          <target state="translated">如果 &lt;code&gt;mp.grouping()&lt;/code&gt; 不允许使用数千个分隔符，则遇到的第一个分隔符将被视为解析错误，否则将其视为可选错误。</target>
        </trans-unit>
        <trans-unit id="3018443da1f5de49f03fa88048943ced63037aee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mp.positive_sign()&lt;/code&gt; (in case positive format pattern is used) or &lt;code&gt;mp.negative_sign()&lt;/code&gt; (in case negative format pattern is used) returns a string with more than one character, the first character returned is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern, and the rest of the characters are placed after all other characters, for example, formatting pattern &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; with units &lt;code&gt;123&lt;/code&gt; and negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt; may result in &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; would generate &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;mp.positive_sign()&lt;/code&gt; （如果使用正数格式模式）或 &lt;code&gt;mp.negative_sign()&lt;/code&gt; （如果使用负数格式模式）返回包含多个字符的字符串，则返回的第一个字符位于输出序列中在格式设置模式中出现 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;sign&lt;/a&gt;&lt;/code&gt; ，其余字符放在所有其他字符之后，例如，格式模式 &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; （单位为 &lt;code&gt;123&lt;/code&gt; ，negative_sign为 &lt;code&gt;&quot;-&quot;&lt;/code&gt; 可能会导致 &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; ，而 &lt;code&gt;&quot;()&quot;&lt;/code&gt; negative_sign 将生成 &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="790ce4186370cb3fc98f05fbcd1efa576fc74ae4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, a string representing</source>
          <target state="translated">如果 &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; ，则字符串表示</target>
        </trans-unit>
        <trans-unit id="c48b8077ed302c34e54734ee208fe448aa9fce59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the length of</source>
          <target state="translated">如果 &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; ，则长度为</target>
        </trans-unit>
        <trans-unit id="f48f02b957cf489ffd4062413d130c7d61ac4261" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt;, the position of the first character of the</source>
          <target state="translated">如果 &lt;code&gt;n &amp;gt; 0 &amp;amp;&amp;amp; n &amp;lt; size()&lt;/code&gt; ，则第一个字符的位置</target>
        </trans-unit>
        <trans-unit id="d0a03be819895b29571bce6f30049ce00d836d67" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n &amp;gt; 0&lt;/code&gt; and &lt;code&gt;n &amp;lt; size()&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence that was matched by the</source>
          <target state="translated">如果 &lt;code&gt;n &amp;gt; 0&lt;/code&gt; 且 &lt;code&gt;n &amp;lt; size()&lt;/code&gt; ，则返回对 &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; 的引用，该引用表示目标序列与</target>
        </trans-unit>
        <trans-unit id="c9ebc82c0ecb8a48088d0a25037fb0de7b63320a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, a string representing entire matched expression is returned.</source>
          <target state="translated">如果 &lt;code&gt;n == 0&lt;/code&gt; ，则返回表示整个匹配表达式的字符串。</target>
        </trans-unit>
        <trans-unit id="793a6257509b6fed6781f48113e3c6c7ee94fe8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, returns a reference to the &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; representing the part of the target sequence matched by the entire matched regular expression.</source>
          <target state="translated">如果 &lt;code&gt;n == 0&lt;/code&gt; ，则返回对 &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; 的引用，该引用表示目标序列中与整个匹配的正则表达式匹配的部分。</target>
        </trans-unit>
        <trans-unit id="465490bd86a1fdb5bc7e8b3d057830ae9c3992ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the counted range is valid and empty. Otherwise, the counted range is only valid if n is positive, i is dereferenceable, and &lt;code&gt;[++i, --n)&lt;/code&gt; is a valid counted range.</source>
          <target state="translated">如果 &lt;code&gt;n == 0&lt;/code&gt; ，则计数范围有效且为空。否则，仅当n为正，i是可引用的，并且 &lt;code&gt;[++i, --n)&lt;/code&gt; 是有效的计数范围时，计数范围才有效。</target>
        </trans-unit>
        <trans-unit id="101f7c47a2904602ca47dee8ebc924745b56a92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the length of the entire matched expression is returned.</source>
          <target state="translated">如果 &lt;code&gt;n == 0&lt;/code&gt; ，则返回整个匹配表达式的长度。</target>
        </trans-unit>
        <trans-unit id="25afe120462723241b3dc46cef36ad98b886885e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n == 0&lt;/code&gt;, the position of the first character of the entire matched expression is returned.</source>
          <target state="translated">如果 &lt;code&gt;n == 0&lt;/code&gt; ，则返回整个匹配表达式的第一个字符的位置。</target>
        </trans-unit>
        <trans-unit id="2c59d6a4ff2080c941bbe2819b072e112c520e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal than 128, the behavior is implementation-defined</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 大于或等于128，则行为是实现定义的</target>
        </trans-unit>
        <trans-unit id="227f98cc1496f2fc8d051b223cb2a826b5a37aeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 大于或等于128，则行为是实现定义的。</target>
        </trans-unit>
        <trans-unit id="b0eb7273803ff8b80903c2e9df0d1f3a2350edf8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is greater than the number of elements in the sequence, selects &lt;code&gt;last-first&lt;/code&gt; elements.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 大于序列中的元素数，则选择 &lt;code&gt;last-first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="184888f0f32fc840aab5148b93e76a03075f7c34" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is negative, the iterator is decremented. In this case, &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 为负，则迭代器递减。在这种情况下， &lt;code&gt;InputIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;，否则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="4dfef1823205b211d7bbfb1b78e819c624879b9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; or &lt;code&gt;m&lt;/code&gt; is greater or equal to 128, the behavior is implementation-defined.</source>
          <target state="translated">如果 &lt;code&gt;n&lt;/code&gt; 或 &lt;code&gt;m&lt;/code&gt; 大于或等于128，则行为是实现定义的。</target>
        </trans-unit>
        <trans-unit id="aad53311f76060eab43c7615e438c48408515bf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators, including the past-the-end iterator, and all references to the elements are invalidated. Otherwise, no iterators or references are invalidated.</source>
          <target state="translated">如果 &lt;code&gt;new_cap&lt;/code&gt; 大于Capacity &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; ，则所有迭代器（包括过去的迭代器）以及对元素的所有引用都将无效。否则，没有迭代器或引用无效。</target>
        </trans-unit>
        <trans-unit id="255c1e92345c2e7929c0df945bb3108b691340d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, and &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; is made equal or greater than &lt;code&gt;new_cap&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;new_cap&lt;/code&gt; 大于当前的Capacity &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; ，则分配新的存储，并且让 &lt;code&gt;new_cap&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 等于或大于new_cap。</target>
        </trans-unit>
        <trans-unit id="9b2651e65eddca052bf67c187fdb378c5807dec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than or equal to the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, there is no effect.</source>
          <target state="translated">如果 &lt;code&gt;new_cap&lt;/code&gt; 小于或等于当前Capacity &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; ，则没有任何效果。</target>
        </trans-unit>
        <trans-unit id="4474adc2275755af141c407f92c0e2fd9a1bdda5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink request.</source>
          <target state="translated">如果 &lt;code&gt;new_cap&lt;/code&gt; 小于当前的Capacity &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; ，则这是一个非绑定的收缩请求。</target>
        </trans-unit>
        <trans-unit id="a7e10ae2e285048c1842329a710bd58e4af2b39c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_cap&lt;/code&gt; is less than the current &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;, this is a non-binding shrink-to-fit request equivalent to &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="translated">如果 &lt;code&gt;new_cap&lt;/code&gt; 小于当前的 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ，则这是一个等同于 &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; 的非绑定收缩适应请求（自C ++ 11起）。</target>
        </trans-unit>
        <trans-unit id="bf95be7cd7ebf5692c3135c92a75c10543f6e749" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_filename&lt;/code&gt; exists, the behavior is implementation-defined.</source>
          <target state="translated">如果 &lt;code&gt;new_filename&lt;/code&gt; 存在，则行为是实现定义的。</target>
        </trans-unit>
        <trans-unit id="80cb878f6f5866322edb61fa31de1ba01506d28f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_size&lt;/code&gt; is zero, the behavior is implementation defined: null pointer may be returned (in which case the old memory block may or may not be freed) or some non-null pointer may be returned that may not be used to access storage.</source>
          <target state="translated">如果 &lt;code&gt;new_size&lt;/code&gt; 为零，则行为是由实现定义的：可能会返回空指针（在这种情况下，可能会释放旧内存块，也可能不会释放旧指针），或者可能会返回一些非空指针，这些指针可能不会用于访问存储。</target>
        </trans-unit>
        <trans-unit id="2de361cc207e32639639c741794ee2fcb6aa4087" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;noskipws&lt;/code&gt; is zero and &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; is nonzero, the function extracts and discards all whitespace characters until the next available character is not a whitespace character (as determined by the currently imbued locale in &lt;code&gt;is&lt;/code&gt;). If &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; returns &lt;code&gt;traits::eof()&lt;/code&gt;, the function calls &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;noskipws&lt;/code&gt; 为零，并且 &lt;code&gt;is.flags() &amp;amp; ios_base::skipws&lt;/code&gt; 为非零，则函数提取并丢弃所有空白字符，直到下一个可用字符不是空白字符为止（由当前插入的语言环境 &lt;code&gt;is&lt;/code&gt; 决定）。如果 &lt;code&gt;is.rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; 或 &lt;code&gt;is.rdbuf()-&amp;gt;sgetc()&lt;/code&gt; 返回 &lt;code&gt;traits::eof()&lt;/code&gt; ，则该函数调用 &lt;code&gt;setstate(failbit | eofbit)&lt;/code&gt; （可能会引发 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9c309a7e2f969d9c1fa291f40fe3ab598e47bd4e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; was not default-constructed, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;obj&lt;/code&gt; 不是默认构造的，则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="4e236834fc06642f73e875ff2b0ea5467f35c428" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a directory, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="translated">如果 &lt;code&gt;old_p&lt;/code&gt; 是目录，则 &lt;code&gt;new_p&lt;/code&gt; 必须是以下之一：</target>
        </trans-unit>
        <trans-unit id="769c85f3779db98891c17618ad67c5dc15d9f91f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;old_p&lt;/code&gt; is a non-directory file, then &lt;code&gt;new_p&lt;/code&gt; must be one of:</source>
          <target state="translated">如果 &lt;code&gt;old_p&lt;/code&gt; 是非目录文件，则 &lt;code&gt;new_p&lt;/code&gt; 必须是以下之一：</target>
        </trans-unit>
        <trans-unit id="73715913e7ab67a68239322dafae4a19098bf520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;openmode&lt;/code&gt; is not one of the modes listed, the &lt;code&gt;open()&lt;/code&gt; fails.</source>
          <target state="translated">如果 &lt;code&gt;openmode&lt;/code&gt; 不是列出的模式之一，则 &lt;code&gt;open()&lt;/code&gt; 失败。</target>
        </trans-unit>
        <trans-unit id="6e9a3e1afd67e93539e35474985138b3c3deb24f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::add&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is set in &lt;code&gt;prms&lt;/code&gt;, but not in the file's current permissions is added to the file's permissions)</source>
          <target state="translated">如果 &lt;code&gt;opts&lt;/code&gt; 是 &lt;code&gt;perm_options::add&lt;/code&gt; ，则文件权限将完全设置为 &lt;code&gt;status(p).permissions() | (prms &amp;amp; perms::mask)&lt;/code&gt; （意味着，在 &lt;code&gt;prms&lt;/code&gt; 中设置的任何有效位，但未在文件的当前权限中设置的任何有效位都将添加到文件的权限中）</target>
        </trans-unit>
        <trans-unit id="38f8c3a3043f7271f4f818139555edb242b7d47e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::remove&lt;/code&gt;, the file permissions are set to exactly &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; (meaning, any valid bit that is clear in &lt;code&gt;prms&lt;/code&gt;, but set in the file's current permissions is cleared in the file's permissions)</source>
          <target state="translated">如果 &lt;code&gt;opts&lt;/code&gt; 是 &lt;code&gt;perm_options::remove&lt;/code&gt; ，则文件权限将完全设置为 &lt;code&gt;status(p).permissions() &amp;amp; ~(prms &amp;amp; perms::mask)&lt;/code&gt; （意味着，任何有效位都可以在 &lt;code&gt;prms&lt;/code&gt; 中清除，但是在文件的当前权限已在文件的权限中清除）</target>
        </trans-unit>
        <trans-unit id="743b1ea9d394f52e11e3859206c7efdd472d283a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opts&lt;/code&gt; is &lt;code&gt;perm_options::replace&lt;/code&gt;, file permissions are set to exactly &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; (meaning, every valid bit of &lt;code&gt;prms&lt;/code&gt; is applied)</source>
          <target state="translated">如果 &lt;code&gt;opts&lt;/code&gt; 是 &lt;code&gt;perm_options::replace&lt;/code&gt; ，则文件权限将完全设置为 &lt;code&gt;prms &amp;amp; &lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::mask&lt;/a&gt;&lt;/code&gt; （这意味着将应用 &lt;code&gt;prms&lt;/code&gt; 的每个有效位）</target>
        </trans-unit>
        <trans-unit id="4fef9d0f0afa6e8487fa35a14b4387e28190db47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.good()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, returns. Otherwise, if &lt;code&gt;os.tie()&lt;/code&gt; is not a null pointer, calls &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; to synchronize the output sequence with external streams. During preparation, the constructor may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;os.good()&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则返回。否则，如果 &lt;code&gt;os.tie()&lt;/code&gt; 不是空指针，则调用 &lt;code&gt;os.tie()-&amp;gt;flush()&lt;/code&gt; 以将输出序列与外部流同步。在准备期间，构造函数可以调用 &lt;code&gt;setstate(failbit)&lt;/code&gt; （这可能引发 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="009d318ae78f457dac42968d4c493d6541c60df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, toggles whether it emits (i.e., transmits data to the underlying stream buffer) when flushed:</source>
          <target state="translated">如果 &lt;code&gt;os.rdbuf()&lt;/code&gt; 实际上指向 &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt; &lt;code&gt;buf&lt;/code&gt; ，则在刷新时切换是否发出（即，将数据传输到底层流缓冲区）：</target>
        </trans-unit>
        <trans-unit id="86470d4ce8b2df93a46fea671370851ae460db55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(2) or &lt;code&gt;std::move(*other)&lt;/code&gt;(3). Note that a moved-from optional still</source>
          <target state="translated">如果 &lt;code&gt;other&lt;/code&gt; 包含一个值，则取决于 &lt;code&gt;*this&lt;/code&gt; 是否包含一个值，所包含的值可以&lt;a href=&quot;../../language/direct_initialization&quot;&gt;直接初始化，&lt;/a&gt;也可以从 &lt;code&gt;*other&lt;/code&gt; （2）或 &lt;code&gt;std::move(*other)&lt;/code&gt; （3）赋值。请注意，移动自可选静止</target>
        </trans-unit>
        <trans-unit id="36484744e817604683f9351055f9e29eff44cf5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; contains a value, then depending on whether &lt;code&gt;*this&lt;/code&gt; contains a value, the contained value is either &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or assigned from &lt;code&gt;*other&lt;/code&gt;(5) or &lt;code&gt;std::move(*other)&lt;/code&gt;(6). Note that a moved-from optional still</source>
          <target state="translated">如果 &lt;code&gt;other&lt;/code&gt; 包含一个值，则取决于 &lt;code&gt;*this&lt;/code&gt; 是否包含一个值，所包含的值可以&lt;a href=&quot;../../language/direct_initialization&quot;&gt;直接初始化，&lt;/a&gt;也可以从 &lt;code&gt;*other&lt;/code&gt; （5）或 &lt;code&gt;std::move(*other)&lt;/code&gt; （6）赋值。请注意，移动自可选静止</target>
        </trans-unit>
        <trans-unit id="c8399508478e3a1e9b6988b20831b2cf1587c5e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;, has no effects. Otherwise, copies the state of the stream &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. This is done in the following sequence:</source>
          <target state="translated">如果 &lt;code&gt;other&lt;/code&gt; 指向与 &lt;code&gt;*this&lt;/code&gt; 相同的对象，则无效。否则，将流 &lt;code&gt;other&lt;/code&gt; 状态复制到 &lt;code&gt;*this&lt;/code&gt; 。按以下顺序进行：</target>
        </trans-unit>
        <trans-unit id="cde0508aa3c91b841b5bb98037ec418d76d0f467" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out_stream&lt;/code&gt; is a pointer to the associated &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;delim&lt;/code&gt; is the delimiter specified at the construction of this object, then the effect is equivalent to.</source>
          <target state="translated">如果 &lt;code&gt;out_stream&lt;/code&gt; 是指向关联的 &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 的指针，而 &lt;code&gt;delim&lt;/code&gt; 是在构造此对象时指定的定界符，则效果等效。</target>
        </trans-unit>
        <trans-unit id="9a4113e2f36160ea8f8bfa69f1009dc12f90fc93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 1&lt;/code&gt;, subsequent calls to the &lt;a href=&quot;operator()&quot;&gt;&lt;code&gt;operator()&lt;/code&gt;&lt;/a&gt; overload that does not accept a &lt;code&gt;param_type&lt;/code&gt; object will cause undefined behavior.</source>
          <target state="translated">如果 &lt;code&gt;p == 1&lt;/code&gt; ，则随后对不接受 &lt;code&gt;param_type&lt;/code&gt; 对象的&lt;a href=&quot;operator()&quot;&gt; &lt;code&gt;operator()&lt;/code&gt; &lt;/a&gt;重载的调用将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="39fcfc6551db4ea098125222aa584e4d80195a5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, reports an error.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 不存在，则报告错误。</target>
        </trans-unit>
        <trans-unit id="c7e10031a884549bafa7d7b0cdef0c9d208f99c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; does not exist, returns &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 不存在，则返回 &lt;code&gt;file_status(file_type::not_found)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35e83165c214a9475effb2ede4b6d71c2ec296a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; exists but file attributes cannot be determined, e.g. due to lack of permissions, returns &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 存在，但是由于缺乏权限而无法确定文件属性，则返回 &lt;code&gt;file_status(file_type::unknown)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="284cbde49fd69756d49af77ea69cb915f6cc4f80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; has an implementation-defined file type, returns &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is the implementation-defined &lt;a href=&quot;file_type&quot;&gt;&lt;code&gt;file_type&lt;/code&gt;&lt;/a&gt; constant for that type.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 具有实现定义的文件类型，则返回 &lt;code&gt;file_status(file_type::A, prms)&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 是该类型的实现定义的&lt;a href=&quot;file_type&quot;&gt; &lt;code&gt;file_type&lt;/code&gt; &lt;/a&gt;常量。</target>
        </trans-unit>
        <trans-unit id="84ba1d9110ba0eaab227ddc535151c53fd9656e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a block special file (as if by POSIX &lt;code&gt;S_ISBLK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是块特殊文件（就像通过POSIX &lt;code&gt;S_ISBLK&lt;/code&gt; 一样），则返回 &lt;code&gt;file_status(file_type::block, prms)&lt;/code&gt; file_type :: block，prms）</target>
        </trans-unit>
        <trans-unit id="a8d7bbe00812399696fe7cc6d0e4fb887d95e2e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a character special file (as if by POSIX &lt;code&gt;S_ISCHR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是字符特殊文件（就像通过POSIX &lt;code&gt;S_ISCHR&lt;/code&gt; 一样），则返回 &lt;code&gt;file_status(file_type::character, prms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5948ebb49968bd5b647e0007b11f05d39ecbae58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a directory (as if by POSIX &lt;code&gt;S_ISDIR&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是目录（就像通过POSIX &lt;code&gt;S_ISDIR&lt;/code&gt; 一样），则返回 &lt;code&gt;file_status(file_type::directory, prms)&lt;/code&gt; file_type :: directory，prms）</target>
        </trans-unit>
        <trans-unit id="7098ea96e1e6fe0bd037998b47dc31e8e17fec8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a fifo or pipe file (as if by POSIX &lt;code&gt;S_ISFIFO&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是fifo或管道文件（就像通过POSIX &lt;code&gt;S_ISFIFO&lt;/code&gt; 一样），则返回 &lt;code&gt;file_status(file_type::fifo, prms)&lt;/code&gt; file_type :: fifo，prms）</target>
        </trans-unit>
        <trans-unit id="6b2d16f4bd782dbe9f713f31636dbe449e4151e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a regular file (as if by POSIX &lt;code&gt;S_ISREG&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是常规文件（就像通过POSIX &lt;code&gt;S_ISREG&lt;/code&gt; 一样），则返回 &lt;code&gt;file_status(file_type::regular, prms)&lt;/code&gt; file_type :: regular，prms）。</target>
        </trans-unit>
        <trans-unit id="dd7f50e30d338262c2966fea6e46450e597e3af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a socket (as if by POSIX &lt;code&gt;S_ISSOCK&lt;/code&gt;), returns &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是套接字（就像通过POSIX &lt;code&gt;S_ISSOCK&lt;/code&gt; 一样），则返回 &lt;code&gt;file_status(file_type::socket, prms)&lt;/code&gt; file_type :: socket，prms）</target>
        </trans-unit>
        <trans-unit id="249fe3aff7a5aaa72c5e17941aa8c099b4d5e055" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is a symlink, returns &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 是符号链接，则返回 &lt;code&gt;file_status(file_type::symlink)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a1524ab079a206332a561da96374e5f2392e60c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;parm_n&lt;/code&gt; is declared with reference type or with a type not compatible with the type that results from &lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;default argument promotions&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;parm_n&lt;/code&gt; 声明为引用类型，或者声明的类型与&lt;a href=&quot;../../language/variadic_arguments#Default_conversions&quot;&gt;默认参数&lt;/a&gt;Promotions产生的类型不兼容，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="e24b13015ddf20bc0adacae9ec44ca2ad7e04f7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt; and native encoding is UTF-8, constructs a path directly as if by &lt;code&gt;path(source)&lt;/code&gt; or &lt;code&gt;path(first, last)&lt;/code&gt;. Note: this is the typical situation of a POSIX system that uses Unicode, such as Linux.</source>
          <target state="translated">如果 &lt;code&gt;path::value_type&lt;/code&gt; 为 &lt;code&gt;char&lt;/code&gt; 且本机编码为UTF-8，则直接按 &lt;code&gt;path(source)&lt;/code&gt; 或 &lt;code&gt;path(first, last)&lt;/code&gt; 构造路径。注意：这是使用Unicode的POSIX系统（例如Linux）的典型情况。</target>
        </trans-unit>
        <trans-unit id="f1467bab99e474a5aa0ae0855c89eab043a29738" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path::value_type&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt;, conversion, if any, is system-dependent. This is the case on typical POSIX systems (such as Linux), where native encoding is UTF-8 and &lt;code&gt;string()&lt;/code&gt; performs no conversion.</source>
          <target state="translated">如果 &lt;code&gt;path::value_type&lt;/code&gt; 为 &lt;code&gt;char&lt;/code&gt; ，则转换（如果有）取决于系统。在典型的POSIX系统（例如Linux）上就是这种情况，其中本机编码为UTF-8， &lt;code&gt;string()&lt;/code&gt; 不执行任何转换。</target>
        </trans-unit>
        <trans-unit id="ecd5f9bafd39fb01f214968395060cedf4c94446" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;placement_params&lt;/code&gt; are provided, they are passed to the allocation function as additional arguments. Such allocation functions are known as &quot;placement new&quot;, after the standard allocation function &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt;, which simply returns its second argument unchanged. This is used to construct objects in allocated storage:</source>
          <target state="translated">如果提供了 &lt;code&gt;placement_params&lt;/code&gt; ，它们将作为附加参数传递到分配函数。在标准分配函数 &lt;code&gt;void* &lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, void*)&lt;/code&gt; ，此类分配函数称为&amp;ldquo; placement new&amp;rdquo;（新放置），该函数简单地返回其第二个参数不变。这用于在分配的存储中构造对象：</target>
        </trans-unit>
        <trans-unit id="73eb91c9e150b84ef667442582643acf6c0ee10d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; size()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; ，则抛出 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5825465b5dfa7d68d014c8c650a4880927e452b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt;, this constructor throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt;. If any characters examined in &lt;code&gt;str&lt;/code&gt; are not &lt;code&gt;zero&lt;/code&gt; or &lt;code&gt;one&lt;/code&gt;, it throws &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pos &amp;gt; str.size()&lt;/code&gt; ，则此构造方法将抛出 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 。如果在 &lt;code&gt;str&lt;/code&gt; 中检查的任何字符都不 &lt;code&gt;zero&lt;/code&gt; 或 &lt;code&gt;one&lt;/code&gt; ，则抛出 &lt;code&gt;&lt;a href=&quot;../../error/invalid_argument/invalid_argument&quot;&gt;std::invalid_argument&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9cdf4cfe8233d41239dac602c3524239510fa6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos == size()&lt;/code&gt;, a reference to the character with value &lt;code&gt;CharT()&lt;/code&gt; (the null character) is returned.</source>
          <target state="translated">如果 &lt;code&gt;pos == size()&lt;/code&gt; ，则返回对值为 &lt;code&gt;CharT()&lt;/code&gt; 的字符(空字符）的引用。</target>
        </trans-unit>
        <trans-unit id="45d948614cf70d9e5ba39df1cc54e194a17a73da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt; - internal to the conversion functions - will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="translated">如果 &lt;code&gt;pos&lt;/code&gt; 不是空指针，则转换函数内部的指针 &lt;code&gt;ptr&lt;/code&gt; 将在 &lt;code&gt;str.c_str()&lt;/code&gt; 中接收第一个未转换字符的地址，并将计算该字符的索引并将其存储在 &lt;code&gt;*pos&lt;/code&gt; 中，给出转换处理的字符数。</target>
        </trans-unit>
        <trans-unit id="f6fea302ec518c538cb888ab49b9e51eb713903c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not a null pointer, then a pointer &lt;code&gt;ptr&lt;/code&gt;, internal to the conversion functions, will receive the address of the first unconverted character in &lt;code&gt;str.c_str()&lt;/code&gt;, and the index of that character will be calculated and stored in &lt;code&gt;*pos&lt;/code&gt;, giving the number of characters that were processed by the conversion.</source>
          <target state="translated">如果 &lt;code&gt;pos&lt;/code&gt; 不是空指针，则转换函数内部的指针 &lt;code&gt;ptr&lt;/code&gt; 将在 &lt;code&gt;str.c_str()&lt;/code&gt; 中接收第一个未转换字符的地址，并将计算该字符的索引并将其存储在 &lt;code&gt;*pos&lt;/code&gt; 中，给出转换处理的字符数。</target>
        </trans-unit>
        <trans-unit id="079f39fe95713c066d5cd5476974d3a17ef66bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; is not within the range of the container, an exception of type &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">如果 &lt;code&gt;pos&lt;/code&gt; 不在容器的范围内，则抛出 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 类型的异常。</target>
        </trans-unit>
        <trans-unit id="beb7dae20fb8d8052f57f043526ceb062d467b3e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ps&lt;/code&gt; is not a null pointer, the &lt;code&gt;mbsinit&lt;/code&gt; function determines whether the pointed-to &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; object describes the initial conversion state.</source>
          <target state="translated">如果 &lt;code&gt;ps&lt;/code&gt; 不是空指针，则 &lt;code&gt;mbsinit&lt;/code&gt; 函数将确定所指向的 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 对象是否描述了初始转换状态。</target>
        </trans-unit>
        <trans-unit id="101e3c4415b14d26fb3724226aa4e6d4501f3aea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the behavior is the same as calling &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;(&lt;code&gt;new_size&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;ptr&lt;/code&gt; 是空指针，则其行为与调用 &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;new_size&lt;/code&gt; ）相同。</target>
        </trans-unit>
        <trans-unit id="75ce63992e734876e2a939cc380b004ef361f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the function does nothing.</source>
          <target state="translated">如果 &lt;code&gt;ptr&lt;/code&gt; 是空指针，则该函数不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="f2dc2865c464168b736d26e4f6c5e34da572e57e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is empty, so is the new &lt;code&gt;shared_ptr&lt;/code&gt; (but its stored pointer is not necessarily null). Otherwise, the new &lt;code&gt;shared_ptr&lt;/code&gt; will share ownership with the initial value of &lt;code&gt;r&lt;/code&gt;, except that it is empty if the &lt;code&gt;dynamic_cast&lt;/code&gt; performed by &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; returns a null pointer.</source>
          <target state="translated">如果 &lt;code&gt;r&lt;/code&gt; 为空，则新的 &lt;code&gt;shared_ptr&lt;/code&gt; 也为空（但其存储的指针不一定为null）。否则，新的 &lt;code&gt;shared_ptr&lt;/code&gt; 将与 &lt;code&gt;r&lt;/code&gt; 的初始值共享所有权，但如果由 &lt;code&gt;dynamic_cast&lt;/code&gt; 执行的 &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; 返回空指针则为空。</target>
        </trans-unit>
        <trans-unit id="b29c481ab6a6599cf423510b090aefb5d2a5a864" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is not null, sets the default memory resource pointer to &lt;code&gt;r&lt;/code&gt;; otherwise, sets the default memory resource pointer to &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;r&lt;/code&gt; 不为null，则将默认内存资源指针设置为 &lt;code&gt;r&lt;/code&gt; ; 否则，将默认内存资源指针设置为 &lt;code&gt;&lt;a href=&quot;new_delete_resource&quot;&gt;std::pmr::new_delete_resource&lt;/a&gt;()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="775fd3976f21369f6410f6f3d50cc92d417bb684" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rand()&lt;/code&gt; is used before any calls to &lt;code&gt;srand()&lt;/code&gt;, &lt;code&gt;rand()&lt;/code&gt; behaves as if it was seeded with &lt;code&gt;srand(1)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;rand()&lt;/code&gt; 的任何调用之前使用 &lt;code&gt;srand()&lt;/code&gt; 函数， &lt;code&gt;rand()&lt;/code&gt; 的行为就好像是用播种 &lt;code&gt;srand(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e1109753adbdfe03f2bb121a57562bbd3b95645" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt;, extracts &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; characters and stores them into successive locations of the characater array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;rdbuf()-&amp;gt;in_avail() &amp;gt; 0&lt;/code&gt; ，则提取 &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(rdbuf()-&amp;gt;in_avail(), count)&lt;/code&gt; 字符并将其存储到characater数组的连续位置，该数组的第一个元素由 &lt;code&gt;s&lt;/code&gt; 指向。</target>
        </trans-unit>
        <trans-unit id="8cb1ced447e9513c6cc2a7656394e6e283081981" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt;, calls &lt;code&gt;setstate(eofbit)&lt;/code&gt; and extracts no characters.</source>
          <target state="translated">如果 &lt;code&gt;rdbuf()-&amp;gt;in_avail() == -1&lt;/code&gt; ，则调用 &lt;code&gt;setstate(eofbit)&lt;/code&gt; 且不提取任何字符。</target>
        </trans-unit>
        <trans-unit id="1d663866c5ef6d453a0e6e1c3a442d54a0a631ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt;, extracts no characters.</source>
          <target state="translated">如果 &lt;code&gt;rdbuf()-&amp;gt;in_avail() == 0&lt;/code&gt; ，则不提取任何字符。</target>
        </trans-unit>
        <trans-unit id="0bb9782f82ff3d24467c86f4716084ada4ca990f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; 返回 &lt;code&gt;Traits::eof()&lt;/code&gt; ，则调用 &lt;code&gt;setstate(badbit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f7f0c931fb16fc794bc074b32fcde3eb8dce586" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rdbuf()&lt;/code&gt; is null or if &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; returns &lt;code&gt;Traits::eof()&lt;/code&gt;, calls &lt;code&gt;setstate(badbit)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;rdbuf()&lt;/code&gt; 为null或 &lt;code&gt;rdbuf-&amp;gt;sputbackc(ch)&lt;/code&gt; 返回 &lt;code&gt;Traits::eof()&lt;/code&gt; ，则调用 &lt;code&gt;setstate(badbit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c685f865d646b3c4c7e1a09a3ab4541aca64af5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object,</source>
          <target state="translated">如果 &lt;code&gt;rep_&lt;/code&gt; 是一个成员变量，它保存了持续时间对象中的滴答声数量，</target>
        </trans-unit>
        <trans-unit id="dd202d89b0c5b4958bcc3baf6d4f8cc9e4180f5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is a member variable holding the number of ticks in a duration object, and &lt;code&gt;D&lt;/code&gt; is the return type,</source>
          <target state="translated">如果 &lt;code&gt;rep_&lt;/code&gt; 是一个成员变量，它保存持续时间对象中的滴答声数量，而 &lt;code&gt;D&lt;/code&gt; 是返回类型，</target>
        </trans-unit>
        <trans-unit id="d39a4ad84577a00c15233086e6e7ac8affa4a963" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep_&lt;/code&gt; is the member variable holding the number of ticks in this duration object,</source>
          <target state="translated">如果 &lt;code&gt;rep_&lt;/code&gt; 是保存此持续时间对象中滴答声数量的成员变量，</target>
        </trans-unit>
        <trans-unit id="f2eadcb39ee434e29ef05bd72b2b26a315c2acf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, the filebuf becomes</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 为空指针且 &lt;code&gt;n&lt;/code&gt; 为零，则filebuf变为</target>
        </trans-unit>
        <trans-unit id="9b53eb098a63b3e541f5d769951b6fce364d2e5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer and &lt;code&gt;n&lt;/code&gt; is zero, this function has no effect.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 为空指针且 &lt;code&gt;n&lt;/code&gt; 为零，则此函数无效。</target>
        </trans-unit>
        <trans-unit id="1972341d22f77196bc1af118f58697bce937d0f6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets its internal conversion state to represent the initial shift state and returns &lt;code&gt;​0​&lt;/code&gt; if the current multibyte encoding is not state-dependent (does not use shift sequences) or a non-zero value if the current multibyte encoding is state-dependent (uses shift sequences).</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是一个空指针，复位其内部转换状态来表示初始移位状态，并返回 &lt;code&gt;​0​&lt;/code&gt; ，如果当前多字节编码不是状态依赖性（不使用移位序列），或者如果当前的多字节非零值编码取决于状态（使用移位序列）。</target>
        </trans-unit>
        <trans-unit id="c39632bb99f5cb18b879a3b49462f93b75999d15" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, resets the global conversion state and determines whether shift sequences are used.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 为空指针，则重置全局转换状态并确定是否使用移位序列。</target>
        </trans-unit>
        <trans-unit id="6138f983954415f7151da4086aa9c700eb8d9987" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是空指针，则对于某些内部缓冲区 &lt;code&gt;buf&lt;/code&gt; ，该调用等效于 &lt;code&gt;std::c16rtomb(buf, u'\0', ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b425a38a00e233a7e79446325b7bf9c1fc117a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是空指针，则对于某些内部缓冲区 &lt;code&gt;buf&lt;/code&gt; ，调用等效于 &lt;code&gt;std::c32rtomb(buf, U'\0', ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed35e82d64bb46cbad184112b5af458797318975" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是空指针，则对于某些内部缓冲区 &lt;code&gt;buf&lt;/code&gt; ，该调用等效于 &lt;code&gt;std::c8rtomb(buf, u8'\0', ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12e013f90ae32cdb16251d5b6510a8d8d5565aed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the call is equivalent to &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; for some internal buffer &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是空指针，则对于某些内部缓冲区 &lt;code&gt;buf&lt;/code&gt; ，该调用等效于 &lt;code&gt;std::wcrtomb(buf, L'\0', ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0c98fdcb47a8abb41d844fc8c53f32413a8247d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc16&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是空指针，则忽略 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;pc16&lt;/code&gt; 的值，并且该调用等效于 &lt;code&gt;std::mbrtoc16(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f441bdad904ce2a3ae27b238bbd76507e2b519da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc32&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是空指针，则忽略 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;pc32&lt;/code&gt; 的值，并且调用等效于 &lt;code&gt;std::mbrtoc32(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="92f917820ffd997e9b4bad50e8a1e2f43abff234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pc8&lt;/code&gt; are ignored and the call is equivalent to &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是空指针，则 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;pc8&lt;/code&gt; 的值将被忽略，并且调用等效于 &lt;code&gt;std::mbrtoc8(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="002e16b0a8a0300cebc1bd2022bc72e0016d413f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is a null pointer, the values of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;pwc&lt;/code&gt; are ignored and call is equivalent to &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是空指针，则忽略 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;pwc&lt;/code&gt; 的值，并且call等效于 &lt;code&gt;std::mbrtowc(&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;, &quot;&quot;, 1, ps)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="387220b12d5b9da678e75cc38f39c0d62fd87341" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c16&lt;/code&gt; is the last 16-bit code unit in a valid variable-length encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不是空指针，并且 &lt;code&gt;c16&lt;/code&gt; 是代码点的有效变长编码中的最后16位代码单元，则该函数确定存储该代码点的多字节字符表示形式所需的字节数（包括任何转换序列，并考虑当前的多字节转换状态 &lt;code&gt;*ps&lt;/code&gt; ，并将多字节字符表示形式存储在字符数组中，该数组的第一个元素由 &lt;code&gt;s&lt;/code&gt; 指向，并根据需要更新 &lt;code&gt;*ps&lt;/code&gt; 。在大多数 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 字节可以通过该功能进行写操作。</target>
        </trans-unit>
        <trans-unit id="8e98391f16286d01eda72c77dda336407bf1f401" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer and &lt;code&gt;c8&lt;/code&gt; is the last code unit in a valid UTF-8 encoding of a code point, the function determines the number of bytes necessary to store the multibyte character representation of that code point (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不是空指针，并且 &lt;code&gt;c8&lt;/code&gt; 是代码点的有效UTF-8编码中的最后一个代码单元，则该函数确定存储该代码点的多字节字符表示形式所需的字节数（包括任何移位序列，并考虑当前的多字节转换状态 &lt;code&gt;*ps&lt;/code&gt; ，并将多字节字符表示形式存储在第一个元素由 &lt;code&gt;s&lt;/code&gt; 指向的字符数组中，并根据需要更新 &lt;code&gt;*ps&lt;/code&gt; 。在大多数 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 字节可以通过该功能进行写操作。</target>
        </trans-unit>
        <trans-unit id="efeff6f4bae9dbe7dacca63bdafb8df5873ba5a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to UTF-8 and stores the first UTf-8 code unit in &lt;code&gt;*pc8&lt;/code&gt; (if &lt;code&gt;pc8&lt;/code&gt; is not null).</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是不是一个空指针，至多检查 &lt;code&gt;n&lt;/code&gt; 字节的多字节字符的字符串的，开头的指向的字节通过 &lt;code&gt;s&lt;/code&gt; 来确定要完成的下一个多字节字符（包括任何移位序列）的字节数。如果函数确定 &lt;code&gt;s&lt;/code&gt; 中的下一个多字节字符完整且有效，请将其转换为UTF-8并将第一个UTf-8代码单元存储在 &lt;code&gt;*pc8&lt;/code&gt; 中（如果 &lt;code&gt;pc8&lt;/code&gt; 不为null）。</target>
        </trans-unit>
        <trans-unit id="66571e29e3face4617295ef95324bcdf8412d045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 16-bit character and stores it in &lt;code&gt;*pc16&lt;/code&gt; (if &lt;code&gt;pc16&lt;/code&gt; is not null).</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是不是一个空指针，至多检查 &lt;code&gt;n&lt;/code&gt; 字节的多字节字符的字符串的，开头的指向的字节通过 &lt;code&gt;s&lt;/code&gt; 来确定要完成的下一个多字节字符（包括任何移位序列）的字节数。如果函数确定 &lt;code&gt;s&lt;/code&gt; 中的下一个多字节字符完整且有效，则将其转换为相应的16位字符并将其存储在 &lt;code&gt;*pc16&lt;/code&gt; 中（如果 &lt;code&gt;pc16&lt;/code&gt; 不为null）。</target>
        </trans-unit>
        <trans-unit id="e34686814ade46fa92cd32a9d644e0c7a90c8094" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding 32-bit character and stores it in &lt;code&gt;*pc32&lt;/code&gt; (if &lt;code&gt;pc32&lt;/code&gt; is not null).</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是不是一个空指针，至多检查 &lt;code&gt;n&lt;/code&gt; 字节的多字节字符的字符串的，开头的指向的字节通过 &lt;code&gt;s&lt;/code&gt; 来确定要完成的下一个多字节字符（包括任何移位序列）的字节数。如果函数确定 &lt;code&gt;s&lt;/code&gt; 中的下一个多字节字符完整且有效，则将其转换为相应的32位字符并将其存储在 &lt;code&gt;*pc32&lt;/code&gt; 中（如果 &lt;code&gt;pc32&lt;/code&gt; 不为null）。</target>
        </trans-unit>
        <trans-unit id="2038e0d252e5f18478ed819b27d31e3681ca48d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, inspects at most &lt;code&gt;n&lt;/code&gt; bytes of the multibyte character string, beginning with the byte pointed to by &lt;code&gt;s&lt;/code&gt; to determine the number of bytes necessary to complete the next multibyte character (including any shift sequences). If the function determines that the next multibyte character in &lt;code&gt;s&lt;/code&gt; is complete and valid, converts it to the corresponding wide character and stores it in &lt;code&gt;*pwc&lt;/code&gt; (if &lt;code&gt;pwc&lt;/code&gt; is not null).</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是不是一个空指针，至多检查 &lt;code&gt;n&lt;/code&gt; 字节的多字节字符的字符串的，开头的指向的字节通过 &lt;code&gt;s&lt;/code&gt; 来确定要完成的下一个多字节字符（包括任何移位序列）的字节数。如果函数确定 &lt;code&gt;s&lt;/code&gt; 中的下一个多字节字符完整且有效，请将其转换为相应的宽字符并将其存储在 &lt;code&gt;*pwc&lt;/code&gt; 中（如果 &lt;code&gt;pwc&lt;/code&gt; 不为null）。</target>
        </trans-unit>
        <trans-unit id="6f4c68687ec93f7e26b9a23cfefd0d3cb05dc64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte character or &lt;code&gt;-1&lt;/code&gt; if the first bytes pointed to by &lt;code&gt;s&lt;/code&gt; do not form a valid multibyte character or &lt;code&gt;​0​&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; is pointing at the null charcter &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是不是一个空指针，返回被包含在多字节字符或字节数 &lt;code&gt;-1&lt;/code&gt; 如果第一字节指向 &lt;code&gt;s&lt;/code&gt; 不形成一个有效的多字节字符或 &lt;code&gt;​0​&lt;/code&gt; ，如果 &lt;code&gt;s&lt;/code&gt; 在空字符内指向 &lt;code&gt;'\0'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f76e4a5183e8ca08cf45c471464ea38bd49564a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, returns the number of bytes that are contained in the multibyte representation of &lt;code&gt;wc&lt;/code&gt; or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;wc&lt;/code&gt; is not a valid character.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 是不是一个空指针，返回被包含在多字节表示字节数 &lt;code&gt;wc&lt;/code&gt; 或 &lt;code&gt;-1&lt;/code&gt; 如果 &lt;code&gt;wc&lt;/code&gt; 是不是一个有效的字符。</target>
        </trans-unit>
        <trans-unit id="6d6df3a6410ecce9d2acc8ffd84bf56f540ac991" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;c32&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不是空指针，则该函数确定存储 &lt;code&gt;c32&lt;/code&gt; 的多字节字符表示形式所需的字节数（包括任何移位序列，并考虑当前的多字节转换状态 &lt;code&gt;*ps&lt;/code&gt; ），并将多字节字符表示形式存储在 &lt;code&gt;s&lt;/code&gt; 指向第一个元素的字符数组，必要时更新 &lt;code&gt;*ps&lt;/code&gt; 。在大多数 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 字节可以通过该功能进行写操作。</target>
        </trans-unit>
        <trans-unit id="a9d1c6974b8b676a8501a6cacc05cdd5f413866d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; is not a null pointer, the function determines the number of bytes necessary to store the multibyte character representation of &lt;code&gt;wc&lt;/code&gt; (including any shift sequences, and taking into account the current multibyte conversion state &lt;code&gt;*ps&lt;/code&gt;), and stores the multibyte character representation in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, updating &lt;code&gt;*ps&lt;/code&gt; as necessary. At most &lt;code&gt;MB_CUR_MAX&lt;/code&gt; bytes can be written by this function.</source>
          <target state="translated">如果 &lt;code&gt;s&lt;/code&gt; 不是空指针，则该函数确定存储 &lt;code&gt;wc&lt;/code&gt; 的多字节字符表示形式所需的字节数（包括任何移位序列，并考虑当前的多字节转换状态 &lt;code&gt;*ps&lt;/code&gt; ），并将多字节字符表示形式存储在 &lt;code&gt;s&lt;/code&gt; 指向第一个元素的字符数组，必要时更新 &lt;code&gt;*ps&lt;/code&gt; 。在大多数 &lt;code&gt;MB_CUR_MAX&lt;/code&gt; 字节可以通过该功能进行写操作。</target>
        </trans-unit>
        <trans-unit id="7823afdead8eb41af529747e83ce1e0afbe2e6fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setjmp&lt;/code&gt; appears in any other context, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;setjmp&lt;/code&gt; 出现在任何其他上下文中，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="4c03a05548ddb96f3438cfeabf552db044243a9a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;showbase&lt;/code&gt; flag is set in &lt;code&gt;str.flags()&lt;/code&gt;, the currency symbol or currency string is required, if it is not set, the currency symbol is optional.</source>
          <target state="translated">如果在 &lt;code&gt;str.flags()&lt;/code&gt; 中设置了 &lt;code&gt;showbase&lt;/code&gt; 标志，则需要货币符号或货币字符串，如果未设置，则货币符号是可选的。</target>
        </trans-unit>
        <trans-unit id="8969128c7f7485e9cafa97fcadad06ea89f50051" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size()&lt;/code&gt; is 0, &lt;code&gt;data()&lt;/code&gt; may or may not return a null pointer.</source>
          <target state="translated">如果 &lt;code&gt;size()&lt;/code&gt; 为0，则 &lt;code&gt;data()&lt;/code&gt; 可能会或可能不会返回空指针。</target>
        </trans-unit>
        <trans-unit id="5a6ee964cf02ec47b4f466324fac4fa5368b4c54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage).</source>
          <target state="translated">如果 &lt;code&gt;size&lt;/code&gt; 为零，则行为是实现定义的（可能会返回空指针，或者可能会返回一些可能不用于访问存储的非空指针）。</target>
        </trans-unit>
        <trans-unit id="4de52063dd761a69f5fec3a1f793d8ab34506b00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果 &lt;code&gt;size&lt;/code&gt; 为零，则行为是实现定义的（可能返回null指针，或者可能返回某些非null指针，这些指针可能不用于访问存储，而必须传递给 &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fece348a8ee3d70f7e3352f3e69bf03a082365cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fread&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">如果 &lt;code&gt;size&lt;/code&gt; 或 &lt;code&gt;count&lt;/code&gt; 为零，则 &lt;code&gt;fread&lt;/code&gt; 返回零，并且不执行其他任何操作。</target>
        </trans-unit>
        <trans-unit id="a444353fd5b9d3848488fa96c9629f1e576c66a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;count&lt;/code&gt; is zero, &lt;code&gt;fwrite&lt;/code&gt; returns zero and performs no other action.</source>
          <target state="translated">如果 &lt;code&gt;size&lt;/code&gt; 或 &lt;code&gt;count&lt;/code&gt; 为零，则 &lt;code&gt;fwrite&lt;/code&gt; 返回零，并且不执行其他任何操作。</target>
        </trans-unit>
        <trans-unit id="62c0f8b2707422825d3dfec002ee726a9c2cbd66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt;, that is, no inner allocators were declared, returns &lt;code&gt;*this&lt;/code&gt;. Otherwise returns a reference to &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt;, that is, a scoped allocator composed of all inner allocators of &lt;code&gt;*this&lt;/code&gt;, with the first inner allocator becoming the outer allocator.</source>
          <target state="translated">如果 &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt; ，即未声明内部分配器，则返回 &lt;code&gt;*this&lt;/code&gt; 。否则，返回对 &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; 的引用，即由 &lt;code&gt;*this&lt;/code&gt; 的所有内部分配器组成的作用域分配器，第一个内部分配器成为外部分配器。</target>
        </trans-unit>
        <trans-unit id="791ac1fc4772ec7b51395220b898af37695b4777" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;sizeof...(T)&lt;/code&gt; 大于2（即 &lt;code&gt;T...&lt;/code&gt; 由类型 &lt;code&gt;T1, T2, R...&lt;/code&gt; ），则如果存在 &lt;code&gt;std::common_reference_t&amp;lt;T1, T2&amp;gt;&lt;/code&gt; ，则成员 &lt;code&gt;type&lt;/code&gt; 表示 &lt;code&gt;std::common_reference_t&amp;lt;std::common_reference_t&amp;lt;T1, T2&amp;gt;, R...&amp;gt;&lt;/code&gt; 如果存在）。在所有其他情况下，没有成员 &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ecc26feb6c4b2ae80a7529b5d61cf9ff7a5b097b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is greater than two (i.e., &lt;code&gt;T...&lt;/code&gt; consists of the types &lt;code&gt;T1, T2, R...&lt;/code&gt;), then if &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; exists, the member &lt;code&gt;type&lt;/code&gt; denotes &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; if such a type exists. In all other cases, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;sizeof...(T)&lt;/code&gt; 大于2（即 &lt;code&gt;T...&lt;/code&gt; 由类型 &lt;code&gt;T1, T2, R...&lt;/code&gt; ），则如果存在 &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; ，则成员 &lt;code&gt;type&lt;/code&gt; 表示 &lt;code&gt;std::common_type&amp;lt;std::common_type&amp;lt;T1, T2&amp;gt;::type, R...&amp;gt;::type&lt;/code&gt; 如果存在）。在所有其他情况下，没有成员 &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78448ef5ca9bbafc2986882ac92ff12c158a9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;T0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;sizeof...(T)&lt;/code&gt; 为1（即 &lt;code&gt;T...&lt;/code&gt; 仅包含一种类型 &lt;code&gt;T0&lt;/code&gt; ），则成员 &lt;code&gt;type&lt;/code&gt; 名称与 &lt;code&gt;T0&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b493ffdbed7ccd8ccc482ba14060e9c250b436b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is one (i.e., &lt;code&gt;T...&lt;/code&gt; contains only one type &lt;code&gt;T0&lt;/code&gt;), the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; if it exists; otherwise there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;sizeof...(T)&lt;/code&gt; 为1（即 &lt;code&gt;T...&lt;/code&gt; 仅包含一种类型 &lt;code&gt;T0&lt;/code&gt; ），则成员 &lt;code&gt;type&lt;/code&gt; 名称与 &lt;code&gt;std::common_type&amp;lt;T0, T0&amp;gt;::type&lt;/code&gt; 如果存在）；否则没有成员 &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05312f022c61c0809a5b4f6761df43d1433c8e8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains exactly two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;),</source>
          <target state="translated">如果 &lt;code&gt;sizeof...(T)&lt;/code&gt; 为2（即 &lt;code&gt;T...&lt;/code&gt; 恰好包含两种类型 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; ），</target>
        </trans-unit>
        <trans-unit id="a9203e749bb438b9fb18b3027d7cd1938fde1b9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is two (i.e., &lt;code&gt;T...&lt;/code&gt; contains two types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt;):</source>
          <target state="translated">如果 &lt;code&gt;sizeof...(T)&lt;/code&gt; 为2（即 &lt;code&gt;T...&lt;/code&gt; 包含两种类型 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="003d0981a91b043f4c661755c19594dc3f2d5e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(T)&lt;/code&gt; is zero, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;sizeof...(T)&lt;/code&gt; 为零，则没有成员 &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6e9a3b7bb26a60d38196ba47db1b4041c4e0a434" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; or if any of the types in &lt;code&gt;Types&lt;/code&gt; is not a complete object type, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;sizeof...(Types) == 0&lt;/code&gt; 或Types中的任何 &lt;code&gt;Types&lt;/code&gt; 都不是完整的对象类型，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="4072b39e3de9b56d51b28e74e4a293634d9f7558" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp&lt;/code&gt; was not obtained by calling &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;seekpos()&lt;/code&gt; on the same file, the behavior is undefined.</source>
          <target state="translated">如果未通过在同一文件上调用 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;seekpos()&lt;/code&gt; 获得 &lt;code&gt;sp&lt;/code&gt; ，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="546524cf93679255723e493223804c25db718c37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">如果 &lt;code&gt;std::abs&lt;/code&gt; 被调用类型的参数 &lt;code&gt;X&lt;/code&gt; ，使得 &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 不能被转换为 &lt;code&gt;int&lt;/code&gt; 由&lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;整数提升&lt;/a&gt;，是形成不良的节目。</target>
        </trans-unit>
        <trans-unit id="feba3c26477487c1b1931e01bd15bdc0fb928819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_and&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="translated">如果 &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; 没有 &lt;code&gt;fetch_and&lt;/code&gt; 成员（仅为&lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;整型&lt;/a&gt;提供此成员），则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="88a445f32dd035df709cb7b01fefe9115a63d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; has no &lt;code&gt;fetch_xor&lt;/code&gt; member (this member is only provided for &lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;integral types&lt;/a&gt;), the program is ill-formed.</source>
          <target state="translated">如果 &lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; 没有 &lt;code&gt;fetch_xor&lt;/code&gt; 成员（仅为&lt;a href=&quot;atomic#Specializations_for_integral_types&quot;&gt;整数类型&lt;/a&gt;提供此成员），则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="def722711403d134b11c7d54af7e5b4d9abce392" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::consume_header&lt;/code&gt; is not selected when reading a file beginning with byte order mark, the Unicode character U+FEFF (Zero width non-breaking space) will be read as the first character of the string content.</source>
          <target state="translated">如果在读取以字节顺序标记开头的文件时未选择 &lt;code&gt;std::consume_header&lt;/code&gt; ，则Unicode字符U + FEFF（零宽度不间断空格）将被读取为字符串内容的第一个字符。</target>
        </trans-unit>
        <trans-unit id="d3cb249ea0f28d0b2a75ca2a7f403cf2a7474c16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; is a reference, this is the rvalue reference version of the same type. Otherwise (such as if the wrapped iterator returns by value), this is &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; unchanged</source>
          <target state="translated">如果 &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; 是引用，则这是相同类型的右值引用版本。否则（例如，包装的迭代器按值返回），这是 &lt;code&gt;std::iterator_traits&amp;lt;Iter&amp;gt;::reference&lt;/code&gt; 不变</target>
        </trans-unit>
        <trans-unit id="949f1f6e0f15336724ef8f4cda94b4e5b055d867" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;std::wcstok&lt;/code&gt; for this particular wide string. The function searches for the first wide character which is</source>
          <target state="translated">如果 &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ，则此调用被视为对此特定宽字符串的 &lt;code&gt;std::wcstok&lt;/code&gt; 的第一个调用。该函数搜索第一个宽字符，即</target>
        </trans-unit>
        <trans-unit id="919d8cd3a8b53f2e18bf07280d97eede84dc299d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as the first call to &lt;code&gt;strtok&lt;/code&gt; for this particular string. The function searches for the first character which is</source>
          <target state="translated">如果 &lt;code&gt;str != &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ，则此调用被视为对该特定字符串的 &lt;code&gt;strtok&lt;/code&gt; 的第一个调用。该函数搜索第一个字符</target>
        </trans-unit>
        <trans-unit id="98634ae53f4036b3363ce6cbf8811e0fd64f6b0f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;std::wcstok&lt;/code&gt;: the function continues from where it left in previous invocation with the same &lt;code&gt;*ptr&lt;/code&gt;. The behavior is the same as if the pointer to the wide character that follows the last detected token is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ，则该调用被视为对 &lt;code&gt;std::wcstok&lt;/code&gt; 的后续调用：该函数从上次调用时以相同的 &lt;code&gt;*ptr&lt;/code&gt; 离开的位置继续。行为与将最后检测到的标记之后的宽字符指针作为 &lt;code&gt;str&lt;/code&gt; 传递的方式相同。</target>
        </trans-unit>
        <trans-unit id="66ec70311bf6aedd6bdb60bbe9f819c870804830" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, the call is treated as a subsequent calls to &lt;code&gt;strtok&lt;/code&gt;: the function continues from where it left in previous invocation. The behavior is the same as if the previously stored pointer is passed as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;str == &lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ，则该调用被视为对 &lt;code&gt;strtok&lt;/code&gt; 的后续调用：该函数从上次调用时从其继续的位置继续。行为与先前存储的指针作为 &lt;code&gt;str&lt;/code&gt; 传递的行为相同。</target>
        </trans-unit>
        <trans-unit id="0f00ca1c926f1dd5787b11275ecdbddb1666242a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; equals &lt;code&gt;str.internal&lt;/code&gt;, the fill characters are inserted where &lt;code&gt;none&lt;/code&gt; or &lt;code&gt;space&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">如果 &lt;code&gt;str.flags() &amp;amp; str.adjustfield&lt;/code&gt; 等于 &lt;code&gt;str.internal&lt;/code&gt; ，填充字符插入其中 &lt;code&gt;none&lt;/code&gt; 或 &lt;code&gt;space&lt;/code&gt; 出现在格式化图案。</target>
        </trans-unit>
        <trans-unit id="1fa5ee33bcecc47b8c59730282fe17b184cd0916" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; is non-zero (the &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; manipulator was used), then the currency symbol or string is generated by calling &lt;code&gt;mp.curr_symbol()&lt;/code&gt; and placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">如果 &lt;code&gt;str.flags() &amp;amp; str.showbase&lt;/code&gt; 不为零（使用了 &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; 操作器），则通过调用 &lt;code&gt;mp.curr_symbol()&lt;/code&gt; 生成货币符号或字符串，并将其放置在输出序列中该 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;symbol&lt;/a&gt;&lt;/code&gt; 出现在格式化模式。</target>
        </trans-unit>
        <trans-unit id="1f05ec444fc20459f458416318c1d398ea88ac26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;str.width()&lt;/code&gt; is non-zero (e.g. &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; was just used) and the number of CharT's after Stage 2 is less than &lt;code&gt;str.width()&lt;/code&gt;, then copies of the &lt;code&gt;fill&lt;/code&gt; character are inserted at the position indicated by padding to bring the length of the sequence to &lt;code&gt;str.width()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;str.width()&lt;/code&gt; 不为零（例如，刚刚使用了 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; ）并且阶段2之后的CharT的数量小于 &lt;code&gt;str.width()&lt;/code&gt; ，则将 &lt;code&gt;fill&lt;/code&gt; 字符的副本插入到由指示的位置填充以使序列的长度达到 &lt;code&gt;str.width()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4dee41190e5faa1ca923bd889668d6289ee307f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stream&lt;/code&gt; is a null pointer, all open output streams are flushed, including the ones manipulated within library packages or otherwise not directly accessible to the program.</source>
          <target state="translated">如果 &lt;code&gt;stream&lt;/code&gt; 是空指针，则将刷新所有打开的输出流，包括在库包中操作的流，否则该程序将无法直接访问这些流。</target>
        </trans-unit>
        <trans-unit id="86e307545d5f002abef118325d5d3eb89a16b86d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt;, the result is finite.</source>
          <target state="translated">如果 &lt;code&gt;t &amp;gt;= 0 &amp;amp;&amp;amp; t &amp;lt;= 1&lt;/code&gt; ，则结果是有限的。</target>
        </trans-unit>
        <trans-unit id="a189eebdd38827d96375b30f0eca568ef1adf1d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 0&lt;/code&gt;, the result is equal to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;t == 0&lt;/code&gt; ，则结果等于 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcbb6f49ce7e941481d92cd71eec73b19dcdaf2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t == 1&lt;/code&gt;, the result is equal to &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;t == 1&lt;/code&gt; ，则结果等于 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35800f7e22639b64ad669cbfd0243c9e80c3180f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; is equivalent to &lt;code&gt;(*t1).*f&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;t1&lt;/code&gt; 不满足先前的条件，则 &lt;code&gt;INVOKE(f, t1)&lt;/code&gt; 等于 &lt;code&gt;(*t1).*f&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f9a950127cdac35950e54e7e7f5e552a16d7cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t1&lt;/code&gt; does not satisfy the previous items, then &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; is equivalent to &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;t1&lt;/code&gt; 不满足前面的项目，则 &lt;code&gt;INVOKE(f, t1, t2, ..., tN)&lt;/code&gt; 等于 &lt;code&gt;((*t1).*f)(t2, ..., tN)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="996fc7fea5a596a0a7f8caf3724383378f3397b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;rv&lt;/code&gt; do not refer to the same object , the value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the assignment.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;rv&lt;/code&gt; 引用的对象不同，则 &lt;code&gt;t&lt;/code&gt; 的值等于赋值之前的 &lt;code&gt;rv&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="70f1cc8280f18381cdb55a983658d6c5ccf12f01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t&lt;/code&gt; represents a time point during a leap second insertion, the last representable value of &lt;code&gt;sys_time&lt;/code&gt; prior to the insertion of the leap second is returned. In all other cases, &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;t&lt;/code&gt; 表示a秒插入期间的时间点，则返回the秒插入之前的 &lt;code&gt;sys_time&lt;/code&gt; 的最后可表示值。在所有其他情况下， &lt;code&gt;utc_clock::from_sys(utc_clock::to_sys(t)) == t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94842a48923ccea749a7b322cc54918cec93ee9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tbl&lt;/code&gt; is null, &lt;code&gt;classic_table()&lt;/code&gt; is used by all classification member functions. Otherwise, &lt;code&gt;tbl&lt;/code&gt; must be a pointer to the first element of an array of masks, at least &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; in size, and that array is used by all of this facet's classification member functions.</source>
          <target state="translated">如果 &lt;code&gt;tbl&lt;/code&gt; 为null，则所有分类成员函数都将使用 &lt;code&gt;classic_table()&lt;/code&gt; 。否则， &lt;code&gt;tbl&lt;/code&gt; 必须是指向掩码数组的第一个元素的指针，其大小至少为 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;::table_size&lt;/code&gt; ，并且该构面的所有分类成员函数都使用该数组。</target>
        </trans-unit>
        <trans-unit id="60c9f234140c969280e37d90ead363e725f41fef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt;, may throw any exception thrown by &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; with i being index().</source>
          <target state="translated">如果 &lt;code&gt;this-&amp;gt;index() == rhs.index()&lt;/code&gt; ，可能会抛出 &lt;code&gt;swap(std::get&amp;lt;i&amp;gt;(*this), std::get&amp;lt;i&amp;gt;(rhs))&lt;/code&gt; 抛出的任何异常，且i为索引（）。</target>
        </trans-unit>
        <trans-unit id="b62e0ed67d83925a4f019bee274f6aaf3d721d41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;time_point&lt;/code&gt; has lower precision, it is implementation defined whether the value is rounded or truncated.</source>
          <target state="translated">如果 &lt;code&gt;time_point&lt;/code&gt; 的精度较低，则由实现定义该值是四舍五入还是截断。</target>
        </trans-unit>
        <trans-unit id="f39154959538bec12350c40feb86c48847d93013" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;timeout_duration&lt;/code&gt; 小于或等于 &lt;code&gt;timeout_duration.zero()&lt;/code&gt; ，则该函数的行为类似于 &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08ae6a5e709170320f3bb275e55a3ea39cb81509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_duration&lt;/code&gt; is less or equal &lt;code&gt;timeout_duration.zero()&lt;/code&gt;, the function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;timeout_duration&lt;/code&gt; 小于或等于 &lt;code&gt;timeout_duration.zero()&lt;/code&gt; ，则该函数的行为类似于 &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94988ecccf327007cfe6e9600377b3a54d244a96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;timeout_time&lt;/code&gt; 已经过去，则此函数的行为类似于 &lt;code&gt;&lt;a href=&quot;try_lock&quot;&gt;try_lock()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="91299d6184527b913bd3a4c6c83fcc921365520d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout_time&lt;/code&gt; has already passed, this function behaves like &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;timeout_time&lt;/code&gt; 已经过去，则此函数的行为类似于 &lt;code&gt;&lt;a href=&quot;try_lock_shared&quot;&gt;try_lock_shared()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="985b3af9a0f9c066a712acb80e6a80e55df51846" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;to&lt;/code&gt; does not exist, first executes &lt;code&gt;create_directory(to, from)&lt;/code&gt; (creates the new directory with a copy of the old directory's attributes)</source>
          <target state="translated">如果 &lt;code&gt;to&lt;/code&gt; 不存在，则首先执行 &lt;code&gt;create_directory(to, from)&lt;/code&gt; （使用旧目录属性的副本创建新目录）</target>
        </trans-unit>
        <trans-unit id="869575bcc3b25a2f60e9720ddcdac4374d7f2bc5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time between two UTC &lt;code&gt;time_point&lt;/code&gt;s, those two &lt;code&gt;time_point&lt;/code&gt;s will be the same, and that &lt;code&gt;time_point&lt;/code&gt; will be returned.</source>
          <target state="translated">如果 &lt;code&gt;tp&lt;/code&gt; 表示两个UTC &lt;code&gt;time_point&lt;/code&gt; 之间不存在的时间，则这两个 &lt;code&gt;time_point&lt;/code&gt; 将相同，并将返回该 &lt;code&gt;time_point&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b14c2985a9828fa673de15ad4b5432c7eec337ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">如果 &lt;code&gt;try_lock()&lt;/code&gt; 成功，则对同一对象进行先前的 &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="f68c72d2cc410f03ed4771fd243cfec6c94f974e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;try_lock&lt;/code&gt; 由已经以任何方式（共享方式或互斥方式）拥有 &lt;code&gt;mutex&lt;/code&gt; 的线程调用，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="2bcbd407f9c0eff5a0a0eb82929bbebd2a38ec19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;try_lock&lt;/code&gt; 由已经拥有 &lt;code&gt;mutex&lt;/code&gt; 的线程调用，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="332a65a0871564214a2da39082b39ae682472b5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">如果 &lt;code&gt;try_lock_for(duration)&lt;/code&gt; 成功，则对同一对象执行先前的 &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="57e45d172606dd71b8ad2f147535c7a9c26b7b2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;try_lock_for&lt;/code&gt; 由已在任何模式（共享或独占）下拥有 &lt;code&gt;mutex&lt;/code&gt; 的线程调用，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="e2913e9dfd8101ebfeeca847b3fbb13f36f0e999" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;try_lock_for&lt;/code&gt; 由已拥有 &lt;code&gt;mutex&lt;/code&gt; 的线程调用，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="3e3938b542994009b61584f5206da7eb84b567ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared()&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">如果 &lt;code&gt;try_lock_shared()&lt;/code&gt; 成功，则对同一对象执行先前的 &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="88e17bb477f3b0dc9840117e325cc5419c64d635" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">如果 &lt;code&gt;try_lock_shared_for(duration)&lt;/code&gt; 成功，则对同一对象执行先前的 &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="3cb436a54d222a2207a53f9e58e0c49e9a0e682d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_for&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;try_lock_shared_for&lt;/code&gt; 由已经以任何模式（共享或互斥）拥有 &lt;code&gt;mutex&lt;/code&gt; 的线程调用，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="2b4a06da759220650268238bcf1faa9bc1408f74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">如果 &lt;code&gt;try_lock_shared_until(time_point)&lt;/code&gt; 成功，则对同一对象执行先前的 &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="2b919196e38c014769e5a77c9fece0fc9c129522" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_shared_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;try_lock_shared_until&lt;/code&gt; 由已在任何模式（共享或独占）下拥有 &lt;code&gt;mutex&lt;/code&gt; 的线程调用，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="bd2e7ac4f22bfd95548a0a07a00613e5cf96f270" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until(time_point)&lt;/code&gt; succeeds, prior &lt;code&gt;unlock()&lt;/code&gt; operations on the same object</source>
          <target state="translated">如果 &lt;code&gt;try_lock_until(time_point)&lt;/code&gt; 成功，则对同一对象进行先前的 &lt;code&gt;unlock()&lt;/code&gt; 操作</target>
        </trans-unit>
        <trans-unit id="ee385f3e6edb77e1716bf26ec86831203e82ffc6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt; in any mode (shared or exclusive), the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;try_lock_until&lt;/code&gt; 由已经以任何方式（共享方式或互斥方式）拥有 &lt;code&gt;mutex&lt;/code&gt; 的线程调用，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="a43b3e939093abea19b584b116c2b4c2095ef181" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;try_lock_until&lt;/code&gt; is called by a thread that already owns the &lt;code&gt;mutex&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;try_lock_until&lt;/code&gt; 由已拥有 &lt;code&gt;mutex&lt;/code&gt; 的线程调用，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="5c29403a2f55f94d0b6bdf83a06a0e7ac5dae5f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is an array type, all dimensions other than the first must be specified as positive &lt;a href=&quot;constant_expression&quot;&gt;integral constant expression&lt;/a&gt;(until C++14)&lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;(since C++14), but the first dimension may be any expression convertible to &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;. This is the only way to directly create an array with size defined at runtime, such arrays are often referred to as</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 是数组类型，则必须将除第一个维度外的所有维指定为正&lt;a href=&quot;constant_expression&quot;&gt;整数常量表达式&lt;/a&gt;（直到C ++ 14），&lt;a href=&quot;constant_expression&quot;&gt;并将其转换&lt;/a&gt;为类型为 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 常量表达式（自C ++ 14起），但第一个维度可以是可转换为 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 任何表达式。这是直接创建在运行时定义大小的数组的唯一方法，此类数组通常称为</target>
        </trans-unit>
        <trans-unit id="987dae04e3210104881f78fd36a73b5af3bafb97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not a &lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;standard layout type&lt;/a&gt;, the behavior is undefined(until C++17)use of the &lt;code&gt;offsetof&lt;/code&gt; macro is conditionally-supported(since C++17).</source>
          <target state="translated">如果 &lt;code&gt;type&lt;/code&gt; 不是&lt;a href=&quot;../language/data_members#Standard_layout&quot;&gt;标准布局类型&lt;/a&gt;，则行为是不确定的（直到C ++ 17），有条件地支持使用 &lt;code&gt;offsetof&lt;/code&gt; 宏（自C ++ 17起）。</target>
        </trans-unit>
        <trans-unit id="8b86993c41ea614db0c1542ae39296df1802bd91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeid&lt;/code&gt; is used on an object under construction or destruction (in a destructor or in a constructor, including constructor's &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt; or &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;), then the &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object referred to by this &lt;code&gt;typeid&lt;/code&gt; represents the class that is being constructed or destroyed even if it is not the most-derived class.</source>
          <target state="translated">如果将 &lt;code&gt;typeid&lt;/code&gt; 用于正在构造或销毁的对象（在析构函数或构造函数中，包括构造函数的&lt;a href=&quot;constructor&quot;&gt;初始化程序列表&lt;/a&gt;或&lt;a href=&quot;data_members#Member_initialization&quot;&gt;默认成员初始化程序&lt;/a&gt;），则此 &lt;code&gt;typeid&lt;/code&gt; 引用的 &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 对象表示正在构造或即使不是最派生的类也被销毁。</target>
        </trans-unit>
        <trans-unit id="2c8bc9e007e9eab3e896a3aaff472ee164636be8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetc&lt;/code&gt; were performed, read operations retrieve the pushed-back characters in reverse order of &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">如果在未进行中间读取或重新定位的情况下多次调用 &lt;code&gt;ungetc&lt;/code&gt; ，则它可能会失败（换言之，可以保证大小为1的推回缓冲区，但任何较大的缓冲区都是实现定义的）。如果执行了多个成功的 &lt;code&gt;ungetc&lt;/code&gt; ，则读取操作将以 &lt;code&gt;ungetc&lt;/code&gt; 的相反顺序检索回退的字符。</target>
        </trans-unit>
        <trans-unit id="b93c880a13d41dd5f02146648e0bcdb941ad4432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ungetwc&lt;/code&gt; is called more than once without an intervening read or repositioning, it may fail (in other words, a pushback buffer of size 1 is guaranteed, but any larger buffer is implementation-defined). If multiple successful &lt;code&gt;ungetwc&lt;/code&gt; were performed, read operations retrieve the pushed-back wide characters in reverse order of &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">如果在不进行中间读取或重新定位的情况下 &lt;code&gt;ungetwc&lt;/code&gt; 调用ungetwc，则它可能会失败（换言之，可以保证大小为1的推回缓冲区，但任何较大的缓冲区都是实现定义的）。如果执行了多个成功的 &lt;code&gt;ungetwc&lt;/code&gt; ，则读取操作 &lt;code&gt;ungetwc&lt;/code&gt; 相反顺序检索回退的宽字符。</target>
        </trans-unit>
        <trans-unit id="1e79c0c8a7bbdaf2db59b21cc3df9306376d12ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;using: namespace&lt;/code&gt; appears in the beginning of an attribute list, no other attributes in the attribute list can specify a namespace: the namespace specified in a using applies to them all:</source>
          <target state="translated">如果 &lt;code&gt;using: namespace&lt;/code&gt; 出现在属性列表的开头，则该属性列表中的其他属性都不能指定名称空间：using中指定的名称空间将全部应用于它们：</target>
        </trans-unit>
        <trans-unit id="08c3c3c90c1cbb009889979159acc6ccce066254" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">如果 &lt;code&gt;v.index() != w.index()&lt;/code&gt; ，则返回 &lt;code&gt;false&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="73386b30a8cd9063a65cadd69c4f27f4b4729d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.index() != w.index()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">如果 &lt;code&gt;v.index() != w.index()&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="60664f03dd91064cc8bcd5281122b9be42c2ecf1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">如果 &lt;code&gt;v.valueless_by_exception()&lt;/code&gt; ，则返回 &lt;code&gt;false&lt;/code&gt; ；否则返回false。</target>
        </trans-unit>
        <trans-unit id="056416cb18ca600a6a47288399d10085b1d96979" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">如果 &lt;code&gt;v.valueless_by_exception()&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="c3e0828292e64efc70577bb97a628f74f2c468ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; compares equivalent to either bound, returns a reference to &lt;code&gt;v&lt;/code&gt;, not the bound.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 比较等于任一边界，则返回对 &lt;code&gt;v&lt;/code&gt; 的引用，而不是边界。</target>
        </trans-unit>
        <trans-unit id="75a090849c6c030efd853b2c4e1bec200144bf8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;va_arg&lt;/code&gt; is called when there are no more arguments in &lt;code&gt;ap&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">如果在 &lt;code&gt;ap&lt;/code&gt; 中没有更多参数时调用 &lt;code&gt;va_arg&lt;/code&gt; ，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="adb7aa1f42112a75264739ee28d6e8827e04fc33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;;</source>
          <target state="translated">如果 &lt;code&gt;w.valueless_by_exception()&lt;/code&gt; ，则返回 &lt;code&gt;false&lt;/code&gt; ；否则返回false。</target>
        </trans-unit>
        <trans-unit id="1ec2d68dd14c2554d3c630fe1822a69b8ee574f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;w.valueless_by_exception()&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">如果 &lt;code&gt;w.valueless_by_exception()&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="4a2e019de572732991114a4b9ac83594fefd4e00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wc&lt;/code&gt; is the null character, the null byte is written to &lt;code&gt;s&lt;/code&gt;, preceded by any shift sequences necessary to restore the initial shift state.</source>
          <target state="translated">如果 &lt;code&gt;wc&lt;/code&gt; 是空字符，则将空字节写入 &lt;code&gt;s&lt;/code&gt; ，之后是恢复初始移位状态所需的任何移位序列。</target>
        </trans-unit>
        <trans-unit id="2df38e58a0b81e321cbdefacc5fbfee02970c44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading (that is, if &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt;), then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="translated">如果 &lt;code&gt;which&lt;/code&gt; 包含 &lt;code&gt;ios_base::in&lt;/code&gt; 并且此缓冲区处于打开状态以供读取（即 &lt;code&gt;((which &amp;amp; ios_base::in) == ios_base::in&lt;/code&gt; ）），则将读取指针 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; 放置在如下所述获取区域</target>
        </trans-unit>
        <trans-unit id="076480d9e864ea3eea8105519a4f861e38abff0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::in&lt;/code&gt; and this buffer is open for reading, then repositions the read pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; inside the get area as described below</source>
          <target state="translated">如果 &lt;code&gt;which&lt;/code&gt; 包含 &lt;code&gt;ios_base::in&lt;/code&gt; 且此缓冲区已打开以供读取， &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::basic_streambuf::gptr&lt;/a&gt;&lt;/code&gt; 如下所述将读取指针std :: basic_streambuf :: gptr重新放置在get区域内</target>
        </trans-unit>
        <trans-unit id="412981fa397417a50c5b81ce7315076f976f90c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing (that is, &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt;), then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="translated">如果 &lt;code&gt;which&lt;/code&gt; 包含 &lt;code&gt;ios_base::out&lt;/code&gt; 且此缓冲区处于打开状态以供写入（即 &lt;code&gt;(which &amp;amp; ios_base::out) == ios_base::out&lt;/code&gt; ），则在放置区域内重新放置写指针 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; 如下所述</target>
        </trans-unit>
        <trans-unit id="ebb77a9083ead2007e8eed624a96ab97b1b10e5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes &lt;code&gt;ios_base::out&lt;/code&gt; and this buffer is open for writing, then repositions the write pointer &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; inside the put area as described below</source>
          <target state="translated">如果 &lt;code&gt;which&lt;/code&gt; 包含 &lt;code&gt;ios_base::out&lt;/code&gt; 且此缓冲区已打开以进行写入， &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::basic_streambuf::pptr&lt;/a&gt;&lt;/code&gt; 如下所述将放置位置内的写入指针std :: basic_streambuf :: pptr重新放置</target>
        </trans-unit>
        <trans-unit id="32ac61f3d8f163e81b3115553fcd68a7ebccec80" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing (&lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt;), and &lt;code&gt;dir&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="translated">如果 &lt;code&gt;which&lt;/code&gt; 包含 &lt;code&gt;ios_base::in&lt;/code&gt; 和 &lt;code&gt;ios_base::out&lt;/code&gt; 且缓冲区已打开以进行读取和写入（ &lt;code&gt;(which &amp;amp; (ios_base::in|ios_base::out)) ==(ios_base::in|ios_base::out)&lt;/code&gt; ），并且 &lt;code&gt;dir&lt;/code&gt; 是 &lt;code&gt;ios_base::beg&lt;/code&gt; 或 &lt;code&gt;ios_base::end&lt;/code&gt; ，然后按如下所述重新放置读写指针。</target>
        </trans-unit>
        <trans-unit id="d56bcb44c21f33d202f66d86615b3fd4c47e7a59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;which&lt;/code&gt; includes both &lt;code&gt;ios_base::in&lt;/code&gt; and &lt;code&gt;ios_base::out&lt;/code&gt; and the buffer is open for both reading and writing, and &lt;code&gt;when&lt;/code&gt; is either &lt;code&gt;ios_base::beg&lt;/code&gt; or &lt;code&gt;ios_base::end&lt;/code&gt;, then repositions both read and write pointers as described below.</source>
          <target state="translated">如果 &lt;code&gt;which&lt;/code&gt; 包括 &lt;code&gt;ios_base::in&lt;/code&gt; 和 &lt;code&gt;ios_base::out&lt;/code&gt; 和缓冲器是开放的读取和写入，并且 &lt;code&gt;when&lt;/code&gt; 是任何 &lt;code&gt;ios_base::beg&lt;/code&gt; 或 &lt;code&gt;ios_base::end&lt;/code&gt; ，然后重新定位读取和写入指针，如下所述。</target>
        </trans-unit>
        <trans-unit id="9292e4a3413eb133a7f76bc6e4fe74a238c5b8bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, domain error</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 均为零，则域错误</target>
        </trans-unit>
        <trans-unit id="8a5e321969b66fbefa9cdd24eacf386b98fffc2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero, range error does not occur either</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 均为零，则也不会发生范围误差</target>
        </trans-unit>
        <trans-unit id="1a0e37c7feac7db699e4130a50b199ceedd910f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;y&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 就是&amp;plusmn;&amp;infin;和 &lt;code&gt;y&lt;/code&gt; 不NaN时，返回NaN且 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="8abb2fb48327f23dca2adde7572dddc2e811ad8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, &amp;plusmn;0 is returned, and &amp;plusmn;&amp;infin; is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为&amp;plusmn;&amp;infin;，则返回&amp;plusmn;0，并将&amp;plusmn;&amp;infin;存储在 &lt;code&gt;*iptr&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="3b9e315fe80911902dd03d84688ec8a34941e551" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;&amp;infin;, it is returned, unmodified</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为&amp;plusmn;&amp;infin;，则返回原样</target>
        </trans-unit>
        <trans-unit id="0d517d0ca1b88b420f9a711836c289f554f6f27a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;y&lt;/code&gt; is not zero, &amp;plusmn;0 is returned</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为&amp;plusmn;0且 &lt;code&gt;y&lt;/code&gt; 不为零，则返回&amp;plusmn;0</target>
        </trans-unit>
        <trans-unit id="dcd1a0509c1e6bf68cbedd9162ffec0cc1242173" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, &amp;plusmn;0 is returned, and &amp;plusmn;0 is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为&amp;plusmn;0，则返回&amp;plusmn;0，并将&amp;plusmn;0存储在 &lt;code&gt;*iptr&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="7cb707c1e458814fee624b6c9deb60721133b5b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为&amp;plusmn;0，则返回原样</target>
        </trans-unit>
        <trans-unit id="f41dcbd3d46c8769c4b2fb80c374a0e5c0d62c23" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is negative, &lt;code&gt;-&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 且 &lt;code&gt;y&lt;/code&gt; 为负，则返回 &lt;code&gt;-&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6968a9e1c046845040fc68d63a376b5e6b8b85a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is positive, &lt;code&gt;+&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 且 &lt;code&gt;y&lt;/code&gt; 为正，则返回 &lt;code&gt;+&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="742021246f19681537f6e140bb629b64b21e4348" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-0&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;+&amp;infin;&lt;/code&gt; 并且 &lt;code&gt;y&lt;/code&gt; 为有限且为负，则返回 &lt;code&gt;-0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="854f55847c1c8f45111c844b75fe0c4c049cc744" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+0&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;+&amp;infin;&lt;/code&gt; 并且 &lt;code&gt;y&lt;/code&gt; 为有限且为正，则返回 &lt;code&gt;+0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70312266975b00e8f11c41c1477d3626e83ccaa9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and negative, &lt;code&gt;-&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;-&amp;infin;&lt;/code&gt; 并且 &lt;code&gt;y&lt;/code&gt; 为有限且为负，则返回 &lt;code&gt;-&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adfdc77216731e53faa0611a28dda473ddae36f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is finite and positive, &lt;code&gt;+&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;-&amp;infin;&lt;/code&gt; 并且 &lt;code&gt;y&lt;/code&gt; 为有限且为正，则返回 &lt;code&gt;+&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c80b06556a1152fcb8c22f136b6473885d57b346" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为NaN，则返回NaN</target>
        </trans-unit>
        <trans-unit id="226af42b45e3a0a3b2917fd765deb1015d6b2d9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, NaN is returned, and NaN is stored in &lt;code&gt;*iptr&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为NaN，则返回NaN，并将NaN存储在 &lt;code&gt;*iptr&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="86712aaf103771c2d7819baa87af27b031d94ae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is NaN, then NaN with the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为NaN，则返回带有 &lt;code&gt;y&lt;/code&gt; 符号的NaN 。</target>
        </trans-unit>
        <trans-unit id="b0446e18a46c6733752844d64ec7ed2bde15bde6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is negative, a domain error may occur</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为负，则可能会发生域错误</target>
        </trans-unit>
        <trans-unit id="0d4fee627ff864097e3bcf0e10e6f4e13892a483" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is zero, returns zero.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不为零，则计算两个不大于 &lt;code&gt;x&lt;/code&gt; 的最大整数幂。如果 &lt;code&gt;x&lt;/code&gt; 为零，则返回零。</target>
        </trans-unit>
        <trans-unit id="2a471c8ab6033df659f209b9c95baa221163a386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not zero, calculates the number of bits needed to store the value &lt;code&gt;x&lt;/code&gt;, that is, \(1 + \lfloor log_2(x) \rfloor\)1 + floor(log</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不为零，则计算存储值 &lt;code&gt;x&lt;/code&gt; 所需的位数，即\（1 + \ lfloor log_2（x）\ rfloor \）1 + floor（log</target>
        </trans-unit>
        <trans-unit id="e48634bd82e2df6f62aec245642cb59777238384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;&amp;infin; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 是&amp;plusmn;&amp;infin;并且 &lt;code&gt;x&lt;/code&gt; 是有限的，则返回 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2ddc1042c63e353212b7799d89a1b092aed734a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &amp;plusmn;0 and &lt;code&gt;x&lt;/code&gt; is not NaN, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为&amp;plusmn;0和 &lt;code&gt;x&lt;/code&gt; 不NaN时，返回NaN且 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="1c4d4232381ec31f82701b3b12b902639c119342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is -0, the result is only negative if the implementation supports the signed zero consistently in arithmetic operations.</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为-0，则仅当实现在算术运算中始终支持带符号的零时，结果才为负。</target>
        </trans-unit>
        <trans-unit id="bb77d357b03480982a5cb3af7fe4d1a54b4629b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;+&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为 &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; 并且 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;+&amp;infin;&lt;/code&gt; ，则返回 &lt;code&gt;&amp;plusmn;&amp;pi;/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c32d4c116dec5e5a3f5f016622351bfcdbb1d9a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;-&amp;infin;&lt;/code&gt;, &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为 &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; 并且 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;-&amp;infin;&lt;/code&gt; ，则返回 &lt;code&gt;&amp;plusmn;3&amp;pi;/4&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2d2be60f0f9dee6ef4e60532e876177666a7509" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is finite, &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 是 &lt;code&gt;&amp;plusmn;&amp;infin;&lt;/code&gt; 并且 &lt;code&gt;x&lt;/code&gt; 是有限的，则返回 &lt;code&gt;&amp;plusmn;&amp;pi;/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04ca9c751f9bab309085f696c5ce7e061eb53bf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is negative or &lt;code&gt;-0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 且 &lt;code&gt;x&lt;/code&gt; 为负或 &lt;code&gt;-0&lt;/code&gt; ，则返回 &lt;code&gt;&amp;plusmn;&amp;pi;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c2e024aa12ac316eec5865ba0f65ada4018df50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is &lt;code&gt;&amp;plusmn;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; is positive or &lt;code&gt;+0&lt;/code&gt;, &lt;code&gt;&amp;plusmn;0&lt;/code&gt; is returned</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为 &lt;code&gt;&amp;plusmn;0&lt;/code&gt; 且 &lt;code&gt;x&lt;/code&gt; 为正或 &lt;code&gt;+0&lt;/code&gt; ，则返回 &lt;code&gt;&amp;plusmn;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db8ff25a6b35fd58c6e2ad1d8257aa1fdbbc1afa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, but the domain error does not occur, zero is returned.</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为零，但没有发生域错误，则返回零。</target>
        </trans-unit>
        <trans-unit id="934c80b3e977f6c9efabb47ff6836e6a1d4145a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, pole error does not occur</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为零，则不会发生极点错误</target>
        </trans-unit>
        <trans-unit id="d5af0b5b04311e67b5c965ddebdd4dcbe743ea19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is zero, the value stored in &lt;code&gt;*quo&lt;/code&gt; is unspecified.</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 为零，则未指定存储在 &lt;code&gt;*quo&lt;/code&gt; 中的值。</target>
        </trans-unit>
        <trans-unit id="687d9b31d16e817da643762a7f7e3d0c38df64e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt;, returns the earlier &lt;code&gt;sys_time&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;z == std::chrono::choose::earliest&lt;/code&gt; ，则返回较早的 &lt;code&gt;sys_time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="966a406501614a5b1c8f3e06813bd52dd307c0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt;, returns the later &lt;code&gt;sys_time&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z == std::chrono::choose::latest&lt;/code&gt; ，则返回更高的 &lt;code&gt;sys_time&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7157b6daee7178a7db7bf2b7f98b21bf5509b46f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="647d48a9a025440a82db0559ba003eb986c87f48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(NaN,&amp;plusmn;&amp;infin;)&lt;/code&gt; （虚部的符号未指定）</target>
        </trans-unit>
        <trans-unit id="5a29bd926acd8a4ed08d36ea492ffa17b0f65b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;pi;/2,-0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d01365aea17ec2d928785c236cc8a0625a50a091" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aca45f2c4af7ce54c221c839224dcc7526370cce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(+0,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b21cb1c0525d180376e59f65f141faac479dcda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(&amp;plusmn;0,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2af12e24fdf73967ee7ab61f7c4d443b37739feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;pi;/2,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b917afe8309bdfdc0889e4ce326dd3daf35a1e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc20a1d28cbfd032ecdaa31a57f9d5ee6abc083b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; （未指定实部的符号）和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="349b76e235126b678fc00eb96b36b916c8c7d87d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised (the sign of the real part is unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; （实部的符号未指定）</target>
        </trans-unit>
        <trans-unit id="6a80692535fb97c3bb378cc0e2235f9e6f89868d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(+&amp;infin;,&amp;pi;/4)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="992a6280563e8dfa9fd680864cf94914e2af8168" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="02e1613ba0e3f7e9f51fc7723495ad1862a78f76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; （虚部的符号未指定）</target>
        </trans-unit>
        <trans-unit id="dc7e1f5800458c8b0514039db23f6f89349f39ac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4153d9975c2c48f8bb5202575acc2cae61f572c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; （实部的符号未指定）</target>
        </trans-unit>
        <trans-unit id="eedb8eec778280d3bcff49c582c5fed9ffc52c94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7210962b1c353ac908b8a5cf3e83977c0e1052f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(+0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9373e34e81874d8368cad6f4032f12ba748b7b06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(1,&amp;plusmn;0)&lt;/code&gt; （虚部的符号未指定）</target>
        </trans-unit>
        <trans-unit id="856848cafe4c0e36a1ad5ce519dc2788d0c24266" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （对于任何有限的非零y），则结果为 &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38ca6940a23e8be06d24918b22d707bed394bbfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （对于任何有限的非零y），则结果为 &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60544872fb73c896e74dc8e5fa99009db9780c61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （对于任何有限的正y），则结果为 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff767095e325e1b139eddcef254efda6cab9a363" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （对于任何有限的正y），则结果为 &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8364d367783724c998297e19343a0b6ad6b6639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （对于任何有限的正y），则结果为 &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22be3e2e16abf84434eed428b48e35f8cb791fa2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （对于任何正有限y），则结果为 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d272464f92e06bbc97dc2b60b9f4b305f104403b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （对于任何正有限y），则结果为 &lt;code&gt;(+0,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="306394ed21756723034bdce29c6c92e8e8f975e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; （对于任何正有限y），则结果为 &lt;code&gt;+&amp;infin;cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0345ff8887f149be457a2b367cd95f127874bb66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; for finite positive y</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+&amp;infin;,y)&lt;/code&gt; ，则对于有限正y而言，结果为 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c635e396c397df4cdf68d1595b6463d80b6d5785" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; (the sign of the real part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt; （未指定实部的符号）和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="7380faae64287df92ea78c0159ffc49274893e26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; （虚部的符号未指定）和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="36abdae4241c852caca11998cf42433abb16ad9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(+0,+0)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+0,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(+0,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2cc8f6469e515605e9eee8a893ab1a721067296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+0,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(-&amp;infin;,+0)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 引发</target>
        </trans-unit>
        <trans-unit id="7ad221569da1d5607bc6299fce77cb0f1118a11f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,+0)&lt;/code&gt;, the result is &lt;code&gt;(1,+0)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+0,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(1,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01db2d5ca8d8ffef07cf540c0e3df9bf5160209e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+0,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;plusmn;0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89130d186050c98271f4a5474781aa4fa940206d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(+0,NaN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+0,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(+0,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6a317cdc33ca73c93da608e61b3b7948bfa218f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+0,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+0,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; （虚部的符号未指定）</target>
        </trans-unit>
        <trans-unit id="57dcd4bc678fdc22d1a23e97a110d173535b6bb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(+1,+0)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(+1,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(+&amp;infin;,+0)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 引发</target>
        </trans-unit>
        <trans-unit id="874f1995c8e575acb11421be6dbde7ae2969a42f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; （未指定符号）</target>
        </trans-unit>
        <trans-unit id="6c365d4aa356678ae4b570fb49e375a4b4ceb0dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(+&amp;infin;,3&amp;pi;/4)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="253435ca3d0567f0dfee4d306973a5da37660409" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-&amp;infin;,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(3&amp;pi;/4,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="579af3f5ca612edf51749805e68c03351cf80f69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; (signs are unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;plusmn;0,&amp;plusmn;0)&lt;/code&gt; （未指定符号）</target>
        </trans-unit>
        <trans-unit id="e78b08f96f6d2562376b89afa7f88fc21913df8a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; (sign of imaginary part unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-&amp;infin;,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(NaN,&amp;infin;)&lt;/code&gt; （虚部的符号未指定）</target>
        </trans-unit>
        <trans-unit id="65dfdfd349a76964ed4ba8c2ee003dcba4c70340" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite positive y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; （对于任何有限的正y），则结果为 &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec76329fb7fb62b9dc71b27cfd5913208f8099b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;+0cis(y)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; （对于任何有限的y），则结果为 &lt;code&gt;+0cis(y)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75ba7cf268eccbdbd782004a0e2520694fb11834" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; （对于任何正有限y），则结果为 &lt;code&gt;(&amp;pi;,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3891fa076b6dcc15dfa77f17c6418c9b728c5090" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; (for any positive finite y), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; （对于任何正有限y），则结果为 &lt;code&gt;(+&amp;infin;,&amp;pi;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56a1f4835fd2810bef4e8bc0c75c1db28c6329f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt;, the result is &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt; for finite positive y</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-&amp;infin;,y)&lt;/code&gt; ，则有限正y 的结果为 &lt;code&gt;(+0,+&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e60ca2bf087c1d87278fedd358c4673cece7420" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(-0,+0)&lt;/code&gt;, the result is &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(-0,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(-&amp;infin;,&amp;pi;)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 引发</target>
        </trans-unit>
        <trans-unit id="89a4a107a9008e545e92be5b1df1c9b5efa21860" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;plusmn;&amp;infin;,NaN)&lt;/code&gt; （实部的符号未指定）</target>
        </trans-unit>
        <trans-unit id="c1290368fb01d308fdca78b212732f24bae238f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; (the sign of the real part is unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(&amp;plusmn;0,&amp;pi;/2)&lt;/code&gt; （实部的符号未指定）</target>
        </trans-unit>
        <trans-unit id="02167beb857a58577bc43d28d09747ed8b716cf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(+&amp;infin;,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f227ab1339277464e7e7720ba15b77847f3dc1c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(NaN,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03b1fb212963f9bff1e0e7f5ce1396cadd18c663" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; (the sign of the imaginary part is unspecified)</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(NaN,&amp;plusmn;0)&lt;/code&gt; （虚部的符号未指定）</target>
        </trans-unit>
        <trans-unit id="a0cec12a18e653673a21b6afcf4d2893eaec9952" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+0)&lt;/code&gt;, the result is &lt;code&gt;(NaN,+0)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,+0)&lt;/code&gt; ，则结果为 &lt;code&gt;(NaN,+0)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48695bc07467a1b54d439f25c1947991dce4e386" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,+y)&lt;/code&gt; (for any finite non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,+y)&lt;/code&gt; （对于任何有限的非零y），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 并且可能引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d365d3a5d388624d62c5ea98bf5be25d94d436" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43432f0ad9333692ce4de812743b6a8a23d990f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,y)&lt;/code&gt; （对于任何有限的非零y），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 可能引发</target>
        </trans-unit>
        <trans-unit id="a74898800da79711b4ca4b837358da0c34309906" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,y)&lt;/code&gt; （对于任何有限的y），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 并且可能引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3986c3fa864e6dfc01234c2970facb3af69b5d42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any finite y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,y)&lt;/code&gt; （对于任何有限的y），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 可能引发。</target>
        </trans-unit>
        <trans-unit id="18e3df5ba9c4d12bc748141c867a2ba815fd8273" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any non-zero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,y)&lt;/code&gt; （对于任何非零y），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 可能引发</target>
        </trans-unit>
        <trans-unit id="3b8c5fbb845c531633355abb0a0435a2ec8eaaf0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt; (for any nonzero y), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,y)&lt;/code&gt; （对于任何非零y），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 可能引发</target>
        </trans-unit>
        <trans-unit id="29a55443041f03e5d510319aa0568a45742e55ea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(NaN,y)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(NaN,y)&lt;/code&gt; ，则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 并且可能引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df2ad89444d23b170108bda8da8ca9ee00ba6c6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 是 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （对于任何有限的非零x）时，将结果 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="e455efcd2e392de8d756291014af13967751bf1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite positive x), the result is &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （对于任何有限的正x），结果为 &lt;code&gt;(+0,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a071dd3e0155d43198db5c9184d3f7c8860d00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （对于任意有限x），则结果为 &lt;code&gt;(&amp;pi;/2,-&amp;infin;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85ebcf7fb682a9f3ba15fca2bb16f8628b521d02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （对于任意有限x），则结果为 &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a6ecedf7500b1db3b4febd7f8959d0c1390edf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （对于任意有限的x），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 并 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7886e26ae70e5250a1e0be3778e2c07bd58265c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （对于任何正有限x），结果为 &lt;code&gt;(+&amp;infin;,&amp;pi;/2)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa903ae726de223dfc94489d7c3a22ae1b23a345" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 是 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （对于任何正有限x）时，将结果 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="22db9353e8948056621c723acfc1f37d717bc4e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 是 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; （对于任何&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;tanh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;有限x）时，将结果 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="0dc41eed06a38a2687f77d174ad8f99a0594fb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt;, the result is &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; even if x is NaN</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,+&amp;infin;)&lt;/code&gt; ，则结果为 &lt;code&gt;(+&amp;infin;,+&amp;infin;)&lt;/code&gt; 即使x是NaN</target>
        </trans-unit>
        <trans-unit id="e9108ce5453cd6b3af30a85d4f435185194ec60d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite non-zero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,NaN)&lt;/code&gt; （对于任何有限的非零x），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 并且可能引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b6b50afd0ebe3c85bd3492ea56b4593b842689c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite nonzero x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,NaN)&lt;/code&gt; （对于任何有限的非零x），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 并且可能引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="204a160d7ec82f80677f4376caef794a23c51075" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,NaN)&lt;/code&gt; （对于任意有限的x），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 并且可能引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b650f50d0ed443a6d100ac136e84b4b3bd34bc7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,NaN)&lt;/code&gt; （对于任何有限的x），结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 并且可能会引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d3a8274e24f46eb6d9b27c393f4df139396e5ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any nonzero finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,NaN)&lt;/code&gt; （对于任何非零有限x），则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 可能引发FE_INVALID。</target>
        </trans-unit>
        <trans-unit id="d9b70aa5296158a2ccd9b37fee97192ed5754e1d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any positive finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,NaN)&lt;/code&gt; （对于任何正有限x），结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 并且可能引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de160560a0670a88a8b2426dbe34cfbd96bd8f64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised.</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,NaN)&lt;/code&gt; （对于任何&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;acosh#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;有限x），结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 可能引发FE_INVALID。</target>
        </trans-unit>
        <trans-unit id="bd01cea44335f9b94fea310daa7ab95e4c6b7953" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt; (for any&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; finite x), the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,NaN)&lt;/code&gt; （对于任何&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;tanh#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;有限x），结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; 并且可能引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d668d6a37cc758c14994156de53988e57bc6b406" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;(x,NaN)&lt;/code&gt;, the result is &lt;code&gt;(NaN,NaN)&lt;/code&gt; (unless x is &amp;plusmn;&amp;infin;) and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果 &lt;code&gt;z&lt;/code&gt; 为 &lt;code&gt;(x,NaN)&lt;/code&gt; ，则结果为 &lt;code&gt;(NaN,NaN)&lt;/code&gt; （除非x为&amp;plusmn;&amp;infin;）， &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 可能引发FE_INVALID</target>
        </trans-unit>
        <trans-unit id="074f956a744f2e0d54cbe071efce74d2c8aa0db4" translate="yes" xml:space="preserve">
          <source>If A was transformed from a function parameter pack, deduction fails.(until C++14) it is compared with each remaining parameter type of the parameter template.(since C++14).</source>
          <target state="translated">如果A是由函数参数包转化而来的,则推导失败.(在C++14之前)它与参数模板的每个剩余参数类型进行比较.(C++14以来)。</target>
        </trans-unit>
        <trans-unit id="e0371b0116f4a5b56551a65f008047322bafb01e" translate="yes" xml:space="preserve">
          <source>If C is not an initializer-list constructor and the initializer list has a single element of possibly cv-qualified X, the implicit conversion sequence has Exact Match rank. If the initializer list has a single element of possibly cv-qualified type derived from X, the implicit conversion sequence has Conversion rank. (note the difference from aggregates: aggregates initialize directly from single-element init lists before considering &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, non-aggregates consider initializer_list constructors before any other constructors)</source>
          <target state="translated">如果C不是初始值设定项列表构造函数，并且初始值设定项列表具有可能是cv限定的X的单个元素，则隐式转换序列的精确匹配等级。如果初始值设定项列表具有从X派生的具有cv限定类型的单个元素，则隐式转换序列具有&amp;ldquo;转换&amp;rdquo;等级。（请注意与聚合的区别：聚合在考虑&lt;a href=&quot;aggregate_initialization&quot;&gt;聚合初始化&lt;/a&gt;之前直接从单元素初始化列表初始化，非聚合在任何其他构造函数之前考虑initializer_list构造函数）</target>
        </trans-unit>
        <trans-unit id="d49d7071128c9d18da1c8f640ffd938c2f5bb26f" translate="yes" xml:space="preserve">
          <source>If P is a function parameter pack, the type A of each remaining parameter type of the argument template is compared with the type P of the declarator-id of the function parameter pack. Each comparison deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack.</source>
          <target state="translated">如果P是一个函数参数包,则将参数模板的每个剩余参数类型A与函数参数包的声明者-id的类型P进行比较。每一次比较都会推导出由函数参数包扩展的模板参数包中后续位置的模板参数。</target>
        </trans-unit>
        <trans-unit id="67a08e610ae0b43d5b7d5de3fee248ad08df296b" translate="yes" xml:space="preserve">
          <source>If Stage 2 was terminated by the test &lt;code&gt;in==end&lt;/code&gt;, &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed to set the eof bit.</source>
          <target state="translated">如果第2阶段是由测试端的 &lt;code&gt;in==end&lt;/code&gt; ， &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; 被执行以设定的EOF位。</target>
        </trans-unit>
        <trans-unit id="a0a49b47583d28360f42a9c412de856cbcf247f7" translate="yes" xml:space="preserve">
          <source>If Statements with Initializer</source>
          <target state="translated">带初始化器的If语句</target>
        </trans-unit>
        <trans-unit id="95e34bcbaa3c6e3efcc81854651af3ec74c54e09" translate="yes" xml:space="preserve">
          <source>If UTF-8 code unit produced is &lt;code&gt;u8'\0'&lt;/code&gt;, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">如果生成的UTF-8代码单元为 &lt;code&gt;u8'\0'&lt;/code&gt; ，则转换状态 &lt;code&gt;*ps&lt;/code&gt; 表示初始移位状态。</target>
        </trans-unit>
        <trans-unit id="5031b0f6e6a8ffbd0c86254f140591158ac1c1ed" translate="yes" xml:space="preserve">
          <source>If UTF-8 encoding of the multibyte character in &lt;code&gt;*s&lt;/code&gt; consists of more than one UTF-8 code unit, then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc8&lt;/code&gt; will write out the additional UTF-8 code units, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;*s&lt;/code&gt; 中多字节字符的UTF-8编码包含多个UTF-8代码单元，则在第一次调用此函数后，将更新 &lt;code&gt;*ps&lt;/code&gt; ，以使下一次对 &lt;code&gt;mbrtoc8&lt;/code&gt; 的调用将写出其他UTF-8代码单元，而不考虑 &lt;code&gt;*s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57e85fdf8664c8892feaa0067e2ab68c323b2c7e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; declaration specifies a default, it must be a friend function definition, and no other declarations of this function are allowed in the translation unit.</source>
          <target state="translated">如果&lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;声明指定默认值，则它必须是friend函数定义，并且在转换单元中不允许该函数的其他声明。</target>
        </trans-unit>
        <trans-unit id="af125d901495baa7e68ae6bf7e676c729a2e9e7d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lambda&quot;&gt;lambda-expression&lt;/a&gt; appears in a default argument, it cannot explicitly or implicitly capture anything.</source>
          <target state="translated">如果&lt;a href=&quot;lambda&quot;&gt;lambda表达式&lt;/a&gt;出现在默认参数中，则它不能显式或隐式捕获任何内容。</target>
        </trans-unit>
        <trans-unit id="a76f53af271b5a909124051c648419560af0ae0d" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; appears as the last &lt;code&gt;P&lt;/code&gt;, then the type &lt;code&gt;P&lt;/code&gt; is matched against the type &lt;code&gt;A&lt;/code&gt; of each remaining argument of the call. Each match deduces the template arguments for the next position in the pack expansion:</source>
          <target state="translated">如果&lt;a href=&quot;parameter_pack&quot;&gt;参数包&lt;/a&gt;显示为最后一个 &lt;code&gt;P&lt;/code&gt; ，则将类型 &lt;code&gt;P&lt;/code&gt; 与调用的每个其余自变量的类型 &lt;code&gt;A&lt;/code&gt; 匹配。每次匹配都会推导出包扩展中下一个位置的模板参数：</target>
        </trans-unit>
        <trans-unit id="b41eca314d823a30b3d9356e848b0ef641d30e0a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;choose&lt;/code&gt; is not passed and an ambiguous or nonexistent local time is encountered, a &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; or &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; exception (as applicable) will be thrown.</source>
          <target state="translated">如果未通过 &lt;code&gt;choose&lt;/code&gt; 并且遇到了模棱两可或不存在的本地时间，则将引发 &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; 或 &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; 异常（如果适用）。</target>
        </trans-unit>
        <trans-unit id="b0232a855656fad38033f04cd7d4e9aba797f804" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;va_list&lt;/code&gt; instance is created, passed to another function, and used via &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; in that function, then any subsequent use in the calling function should be preceded by a call to &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果创建了 &lt;code&gt;va_list&lt;/code&gt; 实例，将其传递给另一个函数，并在该函数中通过 &lt;code&gt;&lt;a href=&quot;va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; 使用，则在调用函数中进行的任何后续使用都应在对 &lt;code&gt;&lt;a href=&quot;va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; 的调用之前。</target>
        </trans-unit>
        <trans-unit id="80b021b3e6bb48d6dea03f2d437af9bc0159b35f" translate="yes" xml:space="preserve">
          <source>If a MoveAssignable class implements a move assignment operator, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after assignment is unspecified.</source>
          <target state="translated">如果MoveAssignable类实现了移动分配运算符，则它也可以实现&lt;a href=&quot;../utility/move&quot;&gt;移动语义&lt;/a&gt;，以利用赋值后 &lt;code&gt;rv&lt;/code&gt; 的值未指定的事实。</target>
        </trans-unit>
        <trans-unit id="50fd9c6db39f2b44036e6dd5cc6b5f20e25a53df" translate="yes" xml:space="preserve">
          <source>If a MoveConstructible class implements a move constructor, it may also implement &lt;a href=&quot;../utility/move&quot;&gt;move semantics&lt;/a&gt; to take advantage of the fact that the value of &lt;code&gt;rv&lt;/code&gt; after construction is unspecified.</source>
          <target state="translated">如果MoveConstructible类实现了move构造函数，则它还可以实现&lt;a href=&quot;../utility/move&quot;&gt;move语义&lt;/a&gt;，以利用未指定构造后 &lt;code&gt;rv&lt;/code&gt; 的值这一事实。</target>
        </trans-unit>
        <trans-unit id="db6d3d9d7cd4ba49aa12646a4de72f6a71fe9090" translate="yes" xml:space="preserve">
          <source>If a UTF-8 string literal and a wide string literal are side by side, the program is ill-formed.</source>
          <target state="translated">如果一个UTF-8的字符串文字和一个宽字符串文字并列,程序就会出现错误。</target>
        </trans-unit>
        <trans-unit id="2e7730383bc958aa60b61242e15f22a8a4d39ba2" translate="yes" xml:space="preserve">
          <source>If a call had been made to &lt;a href=&quot;sync&quot;&gt;&lt;code&gt;sync&lt;/code&gt;&lt;/a&gt; since the last call to &lt;code&gt;emit()&lt;/code&gt;, then also flushes the wrapped stream by calling &lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt;&lt;code&gt;pubsync()&lt;/code&gt;&lt;/a&gt; on it.</source>
          <target state="translated">如果自上次调用 &lt;code&gt;emit()&lt;/code&gt; 之后已经进行了&lt;a href=&quot;sync&quot;&gt; &lt;code&gt;sync&lt;/code&gt; &lt;/a&gt;调用，则还可以通过对其调用&lt;a href=&quot;../basic_streambuf/pubsync&quot;&gt; &lt;code&gt;pubsync()&lt;/code&gt; &lt;/a&gt;来刷新包装的流。</target>
        </trans-unit>
        <trans-unit id="0ea2bfcf7eb556e144def8831349ca368e38aca7" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;sprintf&lt;/code&gt; or &lt;code&gt;snprintf&lt;/code&gt; causes copying to take place between objects that overlap, the behavior is undefined (e.g. &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt;).</source>
          <target state="translated">如果调用 &lt;code&gt;sprintf&lt;/code&gt; 或 &lt;code&gt;snprintf&lt;/code&gt; 导致在重叠的对象之间进行复制，则该行为是不确定的（例如 &lt;code&gt;sprintf(buf, &quot;%s text&quot;, buf);&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c3aa22cbaf61ec140e43d901a3568b282d2888df" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; fails, no further call to &lt;code&gt;try_lock&lt;/code&gt; is performed, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects and a &lt;code&gt;0&lt;/code&gt;-based index of the object that failed to lock is returned.</source>
          <target state="translated">如果对 &lt;code&gt;try_lock&lt;/code&gt; 的调用失败，则不执行对 &lt;code&gt;try_lock&lt;/code&gt; 的进一步调用，对任何锁定的对象调用 &lt;code&gt;unlock&lt;/code&gt; ，并返回未能锁定的对象的从 &lt;code&gt;0&lt;/code&gt; 开始的索引。</target>
        </trans-unit>
        <trans-unit id="42b5fe2f519d0b2189f00f6cdee376383897d0d8" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;try_lock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">如果对 &lt;code&gt;try_lock&lt;/code&gt; 的调用导致异常，则在重新抛出之前，将对所有锁定的对象调用 &lt;code&gt;unlock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="409e5d2187197971805f527baaf18e9e29ae37c9" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">如果对 &lt;code&gt;wrapper()&lt;/code&gt; 的调用传递了const左值 &lt;code&gt;std::string&lt;/code&gt; ，则 &lt;code&gt;T&lt;/code&gt; 被推导为 &lt;code&gt;const std::string&amp;amp;&lt;/code&gt; ，而 &lt;code&gt;std::forward&lt;/code&gt; 确保将const左值引用传递给 &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60d636afcff594f21611dd719c9b59be1be77be5" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes a non-const lvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, and &lt;code&gt;std::forward&lt;/code&gt; ensures that a non-const lvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">如果对 &lt;code&gt;wrapper()&lt;/code&gt; 的调用传递了非常量左值 &lt;code&gt;std::string&lt;/code&gt; ，则将 &lt;code&gt;T&lt;/code&gt; 推导为 &lt;code&gt;std::string&amp;amp;&lt;/code&gt; ，并且 &lt;code&gt;std::forward&lt;/code&gt; 确保将非常量左值引用传递给 &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="531e469ff5d08b04534632e848505259a8c9345f" translate="yes" xml:space="preserve">
          <source>If a call to &lt;code&gt;wrapper()&lt;/code&gt; passes an rvalue &lt;code&gt;std::string&lt;/code&gt;, then &lt;code&gt;T&lt;/code&gt; is deduced to &lt;code&gt;std::string&lt;/code&gt; (not &lt;code&gt;std::string&amp;amp;&lt;/code&gt;, &lt;code&gt;const std::string&amp;amp;&lt;/code&gt;, or &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;), and &lt;code&gt;std::forward&lt;/code&gt; ensures that an rvalue reference is passed to &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">如果对 &lt;code&gt;wrapper()&lt;/code&gt; 的调用传递了一个右值 &lt;code&gt;std::string&lt;/code&gt; ，则 &lt;code&gt;T&lt;/code&gt; 被推导为 &lt;code&gt;std::string&lt;/code&gt; （不是 &lt;code&gt;std::string&amp;amp;&lt;/code&gt; ， &lt;code&gt;const std::string&amp;amp;&lt;/code&gt; 或 &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; ），并且 &lt;code&gt;std::forward&lt;/code&gt; 确保将右值引用传递给 &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3db6809411e108c8a32250227388ae4694cdc2d7" translate="yes" xml:space="preserve">
          <source>If a capacity change takes place, all iterators and references, including the past-the-end iterator, are invalidated.</source>
          <target state="translated">如果发生容量变化,所有的迭代器和引用,包括过去的结束迭代器,都会失效。</target>
        </trans-unit>
        <trans-unit id="91f5ccbd4323fb5f3ed4c55a818cff6f60b92726" translate="yes" xml:space="preserve">
          <source>If a capture list has a capture-default and does not explicitly capture the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;) or an automatic variable, it captures it</source>
          <target state="translated">如果捕获列表具有捕获缺省值，并且未显式捕获封闭对象（如 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;*this&lt;/code&gt; ）或自动变量，则它将捕获它</target>
        </trans-unit>
        <trans-unit id="7dd621d8a6ec99fac9a316fb824dc230d2630614" translate="yes" xml:space="preserve">
          <source>If a catch-clause for a derived class is placed after the catch-clause for a base class, the derived catch-clause will never be executed.</source>
          <target state="translated">如果派生类的 catch-clause 放在基类的 catch-clause 之后,派生类的 catch-clause 将永远不会被执行。</target>
        </trans-unit>
        <trans-unit id="20b89c206d6d992d89351af992dfddfea294ca6c" translate="yes" xml:space="preserve">
          <source>If a class has a public virtual destructor, it can be derived from, and the derived object can be safely deleted through a pointer to the base object (&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW #18&lt;/a&gt;).</source>
          <target state="translated">如果类具有公共虚拟析构函数，则可以从其派生该类，并且可以通过指向基础对象的指针（&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;GotW＃18&lt;/a&gt;）安全删除该派生对象。</target>
        </trans-unit>
        <trans-unit id="d189c715668bfca07f195aaf55d2d525ebbeda96" translate="yes" xml:space="preserve">
          <source>If a class requires a user-defined &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, a user-defined &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, or a user-defined &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, it almost certainly requires all three.</source>
          <target state="translated">如果一个类需要一个用户定义的&lt;a href=&quot;destructor&quot;&gt;析构函数&lt;/a&gt;，一个用户定义的&lt;a href=&quot;copy_constructor&quot;&gt;副本构造函数&lt;/a&gt;或一个用户定义的&lt;a href=&quot;as_operator&quot;&gt;副本赋值运算符&lt;/a&gt;，则几乎可以肯定需要全部三个。</target>
        </trans-unit>
        <trans-unit id="d0521b23151547cdfdf59688f7fc84d8f6a00c6f" translate="yes" xml:space="preserve">
          <source>If a class template has been declared, but not defined, at the point of instantiation, the instantiation yields an incomplete class type:</source>
          <target state="translated">如果一个类模板在实例化时已经被声明,但没有被定义,则实例化会产生一个不完整的类类型。</target>
        </trans-unit>
        <trans-unit id="5de1ec538e9a507f38c522094bdfc9ac9990681e" translate="yes" xml:space="preserve">
          <source>If a const non-inline(since C++17) static data member or a constexpr static data member(since C++11) is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, a definition at namespace scope is still required, but it cannot have an initializer. This definition is deprecated for &lt;code&gt;constexpr&lt;/code&gt; data members(since C++17).</source>
          <target state="translated">如果一个const非内联（因为C ++ 17）静态数据成员或constexpr静态数据成员（因为C ++ 11）是&lt;a href=&quot;definition#ODR-use&quot;&gt;ODR使用的&lt;/a&gt;，仍然需要在命名空间范围的定义，但它不能有初始值设定。对于 &lt;code&gt;constexpr&lt;/code&gt; 数据成员，不赞成使用此定义（自C ++ 17开始）。</target>
        </trans-unit>
        <trans-unit id="23a184ea03d379e5295d8a06a9fb5d4d84026185" translate="yes" xml:space="preserve">
          <source>If a constexpr if statement appears inside a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, and if condition is not &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt; after instantiation, the discarded statement is not instantiated when the enclosing template is instantiated .</source>
          <target state="translated">如果constexpr if语句出现在&lt;a href=&quot;templates#Templated_entity&quot;&gt;模板实体内&lt;/a&gt;，并且条件在实例化后不&lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;依赖&lt;/a&gt;于值，则在实例化封闭模板时不会实例化丢弃的语句。</target>
        </trans-unit>
        <trans-unit id="d387511a4c202656145b74050dd24c2d4377d5ea" translate="yes" xml:space="preserve">
          <source>If a constructor template or conversion function template has an &lt;a href=&quot;explicit&quot;&gt;conditional explicit specifier&lt;/a&gt; which happens to be &lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;value-dependent&lt;/a&gt;, after deduction, if the context requires a candidate that is not explicit and the generated specialization is explicit, it is removed from the candidate set.</source>
          <target state="translated">如果构造函数模板或转换函数模板具有&lt;a href=&quot;explicit&quot;&gt;条件显式指定符&lt;/a&gt;，该条件恰好与&lt;a href=&quot;dependent_name#Value-dependent_expressions&quot;&gt;值相关&lt;/a&gt;，则在推论之后，如果上下文要求的候选对象不是显式的，并且生成的专业化是显式的，则将其从候选集中删除。</target>
        </trans-unit>
        <trans-unit id="e7cac551c36c79f3db2d3cd4de291ee906f04949" translate="yes" xml:space="preserve">
          <source>If a contract condition of a virtual function &lt;code&gt;f&lt;/code&gt; odr-uses &lt;code&gt;*this&lt;/code&gt;, the class of which &lt;code&gt;f&lt;/code&gt; is a direct member must be an unambiguous and accessible base class of any class in which &lt;code&gt;f&lt;/code&gt; is overridden.</source>
          <target state="translated">如果虚拟函数 &lt;code&gt;f&lt;/code&gt; 的合同条件使用 &lt;code&gt;*this&lt;/code&gt; ，则 &lt;code&gt;f&lt;/code&gt; 是直接成员的类必须是 &lt;code&gt;f&lt;/code&gt; 被覆盖的任何类的明确且可访问的基类。</target>
        </trans-unit>
        <trans-unit id="a62eb301fbc04938195faede31c45cafa349ad46" translate="yes" xml:space="preserve">
          <source>If a conversion specification is invalid, the behavior is undefined.</source>
          <target state="translated">如果转换规范无效,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="5705ed552a56d6bfbeab747c83e7be8483a52343" translate="yes" xml:space="preserve">
          <source>If a data race occurs, the behavior of the program is undefined.</source>
          <target state="translated">如果发生数据竞赛,程序的行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="882bf051762ba2c1ce6191c7588fe5e3cee6567e" translate="yes" xml:space="preserve">
          <source>If a declaration introduces a variable with automatic storage duration, it is initialized when its declaration statement is executed. All automatic variables declared in a block are destroyed on exit from the block (regardless how the block is exited: via &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;, &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;, or by reaching its end), in order opposite to their order of initialization.</source>
          <target state="translated">如果声明引入了具有自动存储持续时间的变量，则在执行其声明语句时将对其进行初始化。块中声明的所有自动变量在从块退出时都会被销毁（无论如何退出该块：通过&lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;，&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;或到达其结尾），其顺序与初始化顺序相反。</target>
        </trans-unit>
        <trans-unit id="43c8efd199427ba6a640175787f51c9fb916e92f" translate="yes" xml:space="preserve">
          <source>If a delegating constructor exits with an exception after the non-delegating constructor successfully completed, the destructor for this object is called.</source>
          <target state="translated">如果一个委托构造函数在非委托构造函数成功完成后以异常退出,则会调用这个对象的析构器。</target>
        </trans-unit>
        <trans-unit id="1ac2fdfac54931742b99e44e4aa9aeaa05c1d2d6" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding and the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="translated">如果析构函数在堆栈展开期间重置终止处理程序，并且随后展开导致 &lt;code&gt;terminate&lt;/code&gt; 被调用，则将在throw表达式末尾安装的处理程序被调用。（注意：是否重新抛出是否应用了新的处理程序，这是模棱两可的）。</target>
        </trans-unit>
        <trans-unit id="753c6e50ab4e318d953d5637b772a0f352fda59e" translate="yes" xml:space="preserve">
          <source>If a destructor reset the terminate handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;terminate&lt;/code&gt; being called.</source>
          <target state="translated">如果析构函数在堆栈展开过程中重置了终止处理程序，则无法确定调用哪个处理程序（如果随后展开导致 &lt;code&gt;terminate&lt;/code&gt; 被调用）。</target>
        </trans-unit>
        <trans-unit id="482827679143ed383496ea91dbd86707c7632c8b" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding and the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called, the handler that was installed at the end of the throw expression is the one that will be called. (note: it was ambiguous whether re-throwing applied the new handlers).</source>
          <target state="translated">如果析构函数在堆栈展开期间重置了意外的处理程序，并且随后展开导致导致 &lt;code&gt;unexpected&lt;/code&gt; 的调用，则将在throw表达式末尾安装的处理程序被调用。（注意：是否重新抛出是否应用了新的处理程序，这是模棱两可的）。</target>
        </trans-unit>
        <trans-unit id="f833e8b1ca41ece97da3b5dfb8d80f4a17d92a84" translate="yes" xml:space="preserve">
          <source>If a destructor reset the unexpected handler during stack unwinding, it is unspecified which handler is called if the unwinding later led to &lt;code&gt;unexpected&lt;/code&gt; being called.</source>
          <target state="translated">如果析构函数在堆栈展开过程中重置了意外的处理程序，则无法确定调用哪个处理程序（如果后来展开导致导致 &lt;code&gt;unexpected&lt;/code&gt; 的调用）。</target>
        </trans-unit>
        <trans-unit id="3b53fae349713df5efc757fb7b33531c67e72c29" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value (NaN where supported) is returned.</source>
          <target state="translated">如果发生域错误,则返回一个执行定义的值(支持NaN的地方)。</target>
        </trans-unit>
        <trans-unit id="daaa304029da34d0537dff7e88f32d7146eac438" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned (NaN where supported).</source>
          <target state="translated">如果发生域错误,则返回一个执行定义的值(支持NaN的地方)。</target>
        </trans-unit>
        <trans-unit id="8a2b2a5d22410f7c139500bf2d1ad8bd3daffb21" translate="yes" xml:space="preserve">
          <source>If a domain error occurs, an implementation-defined value is returned.</source>
          <target state="translated">如果发生域错误,将返回一个执行定义的值。</target>
        </trans-unit>
        <trans-unit id="fc6ec94615e1c6cf0e59aab22eb031064112889e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="translated">如果在目录迭代器创建后,文件或目录被删除或添加到目录树中,则未说明是否会通过迭代器观察到该变化。</target>
        </trans-unit>
        <trans-unit id="3724f8b6f7d15be8a8f1594573af0e22249ce20e" translate="yes" xml:space="preserve">
          <source>If a file or a directory is deleted or added to the directory tree after the recursive directory iterator has been created, it is unspecified whether the change would be observed through the iterator.</source>
          <target state="translated">如果在递归目录迭代器创建后,文件或目录被删除或添加到目录树中,则未说明是否会通过迭代器观察到该变化。</target>
        </trans-unit>
        <trans-unit id="39efafdede79fd69777a0e208a3fd4446a9e9cf1" translate="yes" xml:space="preserve">
          <source>If a friend declaration is the first declaration of the function in a translation unit and has a contract condition, that declaration must be a definition and must be the only declaration of the function in the translation unit:</source>
          <target state="translated">如果一个朋友声明是翻译单元中函数的第一个声明,并且有一个合同条件,那么该声明必须是一个定义,并且必须是翻译单元中函数的唯一声明。</target>
        </trans-unit>
        <trans-unit id="9348fef8e416c767f68b83ba99d0f25cfef8feda" translate="yes" xml:space="preserve">
          <source>If a function declared nodiscard or a function returning an enumeration or class declared nodiscard by value is called from a &lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;discarded-value expression&lt;/a&gt; other than a cast to void, the compiler is encouraged to issue a warning.</source>
          <target state="translated">如果从除值强制转换为void之外的&lt;a href=&quot;../expressions#Discarded-value_expressions&quot;&gt;舍弃值表达式中&lt;/a&gt;调用了声明为nodiscard的函数或通过值返回枚举或声明为nodiscard的类的函数，则鼓励编译器发出警告。</target>
        </trans-unit>
        <trans-unit id="0e42988e69c29f9c1e608a2f0ffd727f5c2644ec" translate="yes" xml:space="preserve">
          <source>If a function exits via an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">如果函数通过异常退出，则调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad964142a18dcc049d042a23d7d71322620a52d8" translate="yes" xml:space="preserve">
          <source>If a function has more than one final overrider, the program is ill-formed:</source>
          <target state="translated">如果一个函数有一个以上的最终覆盖器,那么这个程序就是不正规的。</target>
        </trans-unit>
        <trans-unit id="bafd7cb9d12f56ccf89ae9b7b4d93ed2022e34a5" translate="yes" xml:space="preserve">
          <source>If a function is declared &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in one translation unit and the same function is declared without &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">如果一个函数被声明 &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; 在一个转换单元和相同的功能，而不声明 &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; 在另一个翻译单元，是形成不良的程序; 无需诊断。</target>
        </trans-unit>
        <trans-unit id="e3f9e3de669a5122870e6bc1eb5118c628c85194" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;final&lt;/code&gt;, and another function attempts to override it, the program is ill-formed:</source>
          <target state="translated">如果用说明符 &lt;code&gt;final&lt;/code&gt; 声明了一个函数，而另一个函数试图覆盖该函数，则该程序格式错误：</target>
        </trans-unit>
        <trans-unit id="3888ddb42cb2148d436948685603df58149529f7" translate="yes" xml:space="preserve">
          <source>If a function is declared with the specifier &lt;code&gt;override&lt;/code&gt;, but does not override a virtual function, the program is ill-formed:</source>
          <target state="translated">如果使用说明符 &lt;code&gt;override&lt;/code&gt; 声明了一个函数，但没有覆盖虚函数，则该程序的格式不正确：</target>
        </trans-unit>
        <trans-unit id="2f9f7412482ccba02363ec8e1d82ccc1ed257746" translate="yes" xml:space="preserve">
          <source>If a function is declared with type &lt;code&gt;T&lt;/code&gt; listed in its exception specification, the function may throw exceptions of that type or a type derived from it.</source>
          <target state="translated">如果使用异常说明中列出的类型 &lt;code&gt;T&lt;/code&gt; 声明函数，则该函数可能会抛出该类型或从其派生的类型的异常。</target>
        </trans-unit>
        <trans-unit id="0815633756bffaa6b84ff1cbf11092af43ee34c1" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a class type, &lt;code&gt;class&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">如果作用域中存在的函数或变量的名称与类类型的名称相同，则可以在 &lt;code&gt;class&lt;/code&gt; 名之前添加类以消除歧义，从而产生&lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;详细的类型说明符&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43617584a5c434806ea859f8354d597162e188ea" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a non-union class type, &lt;code&gt;struct&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">如果作用域中存在的函数或变量的名称与非工会类类型的名称相同，则可以在名称前加上 &lt;code&gt;struct&lt;/code&gt; 来消除歧义，从而产生&lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;详细的类型说明符&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33c372b62b38e3e28c4c2d8049dc573ffb3184eb" translate="yes" xml:space="preserve">
          <source>If a function or a variable exists in scope with the name identical to the name of a union type, &lt;code&gt;union&lt;/code&gt; can be prepended to the name for disambiguation, resulting in an &lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;</source>
          <target state="translated">如果一个函数或变量与名称相同的联合类型的名称存在范围， &lt;code&gt;union&lt;/code&gt; 可以附加在该名称用于消除歧义，导致&lt;a href=&quot;../language/elaborated_type_specifier&quot;&gt;精细的类型说明符&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3caf3302d65692054c0bd57d280ffa6d4243e44a" translate="yes" xml:space="preserve">
          <source>If a function overrides more than one function, all of the overridden functions must have the same list of contract conditions; no diagnostic is required if corresponding conditions will always evaluate to the same value.</source>
          <target state="translated">如果一个函数覆盖了一个以上的函数,所有被覆盖的函数必须具有相同的合同条件列表;如果相应的条件总是会计算出相同的值,则不需要诊断。</target>
        </trans-unit>
        <trans-unit id="135a8489da58532d74209fec452fabacfcbf21c6" translate="yes" xml:space="preserve">
          <source>If a function template, variable template, member function template, or member function or static data member of a class template is explicitly instantiated with an explicit instantiation definition, the template definition must be present in the same translation unit.</source>
          <target state="translated">如果类模板中的函数模板、变量模板、成员函数模板或成员函数或静态数据成员被显式实例化定义,则模板定义必须存在于同一翻译单元中。</target>
        </trans-unit>
        <trans-unit id="f8f1e8e53e9248772a5ae660d45da68b260826d4" translate="yes" xml:space="preserve">
          <source>If a function that is not transaction-safe is called through a reference or pointer to a transaction-safe function, the behavior is undefined.</source>
          <target state="translated">如果一个非事务安全的函数是通过对事务安全函数的引用或指针调用的,那么行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="0bde24db3435358d326a5b26dc4f5fb9a3ee4c50" translate="yes" xml:space="preserve">
          <source>If a function uses return type deduction, it cannot be redeclared using the type that it deduces to, or another kind of return type deduction even if it deduces to the same type.</source>
          <target state="translated">如果一个函数使用了返回类型推导,就不能使用它推导到的类型重新声明,即使推导到同一类型,也不能使用其他类型的返回类型推导。</target>
        </trans-unit>
        <trans-unit id="26770c3740e0e9cd92c88700d97b6e2c4081721f" translate="yes" xml:space="preserve">
          <source>If a function was introduced by a using-declaration, declaring a function with the same name and parameter list is ill-formed (unless the declaration is for the same function). If a function template was introduced by a using-declaration, declaring a function template with the same name, parameter type list, return type, and template parameter list is ill-formed. Two using-declarations can introduce functions with the same name and parameter list, but if a call to that function is attempted, the program is ill-formed.</source>
          <target state="translated">如果一个函数是由使用声明引入的,那么声明一个名称和参数列表相同的函数是错误的(除非声明的是同一个函数)。如果一个函数模板是由一个使用声明引入的,那么声明一个具有相同名称、参数类型列表、返回类型和模板参数列表的函数模板是错误的。两个使用-声明可以引入具有相同名称和参数列表的函数,但如果试图调用该函数,则程序是错误的。</target>
        </trans-unit>
        <trans-unit id="e751efac5a78fb2353ecab041674493ffe914d58" translate="yes" xml:space="preserve">
          <source>If a function-local (block-scope) static object was destroyed and then that function is called from the destructor of another static object and the control flow passes through the definition of that object (or if it is used indirectly, via pointer or reference), the behavior is undefined.</source>
          <target state="translated">如果一个函数局部(块范围)静态对象被破坏,然后该函数从另一个静态对象的破坏者中被调用,并且控制流经过该对象的定义(或者如果它被间接使用,通过指针或引用),那么该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="a5179d5f0b6b560d982bb76be1dd9a627d77214d" translate="yes" xml:space="preserve">
          <source>If a get area exists (e.g. the file was opened for reading), the effect is implementation-defined. Typical implementation may empty out the get area and move the current file position back by the corresponding number of bytes.</source>
          <target state="translated">如果存在一个get区域(例如,文件被打开读取),效果由实现定义。典型的实现可能会清空获取区域,并将当前文件位置向后移动相应的字节数。</target>
        </trans-unit>
        <trans-unit id="5b16daea89246b1eee5a59e08c141c8e46338b5b" translate="yes" xml:space="preserve">
          <source>If a lambda captures the enclosing object (as &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;*this&lt;/code&gt;), either the nearest enclosing function must be a non-static member function or the lambda must be in a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;:</source>
          <target state="translated">如果lambda捕获了封闭对象（如 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;*this&lt;/code&gt; ），则最接近的封闭函数必须是非静态成员函数，或者lambda必须位于&lt;a href=&quot;data_members#Member_initialization&quot;&gt;默认成员初始化器中&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="cfdecd26d4d9885f6eeae96917954311b903b67d" translate="yes" xml:space="preserve">
          <source>If a lambda expression (or an instantiation of a generic lambda's function call operator) ODR-uses &lt;code&gt;this&lt;/code&gt; or any variable with automatic storage duration, it must be captured by the lambda expression.</source>
          <target state="translated">如果lambda表达式（或通用lambda函数调用运算符的实例化）ODR使用 &lt;code&gt;this&lt;/code&gt; 变量或任何具有自动存储持续时间的变量，则必须由lambda表达式捕获。</target>
        </trans-unit>
        <trans-unit id="c9245324f25aa6ef3f3a921517ba752285940aaf" translate="yes" xml:space="preserve">
          <source>If a lambda odr-uses a reference that is captured by reference, it is using the object referred-to by the original reference, not the captured reference itself:</source>
          <target state="translated">如果一个lambda odr-使用一个通过引用捕获的引用,它使用的是原始引用所引用的对象,而不是捕获的引用本身。</target>
        </trans-unit>
        <trans-unit id="1da4cd3d4148fc5555feb74d4e942788fe474123" translate="yes" xml:space="preserve">
          <source>If a lambda-expression appears in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt;, it cannot explicitly or implicitly capture anything.</source>
          <target state="translated">如果lambda-expression出现在&lt;a href=&quot;default_arguments&quot;&gt;默认参数中&lt;/a&gt;，则不能显式或隐式捕获任何内容。</target>
        </trans-unit>
        <trans-unit id="e34c58387ec074a0a7abef6761392718c559bb60" translate="yes" xml:space="preserve">
          <source>If a member has a default member initializer and also appears in the member initialization list in a constructor, the default member initializer is ignored.</source>
          <target state="translated">如果一个成员有一个默认的成员初始化器,并且也出现在构造函数的成员初始化列表中,那么默认的成员初始化器将被忽略。</target>
        </trans-unit>
        <trans-unit id="f6c0536efbdc9b49435039f82fb9fa51a3523c3e" translate="yes" xml:space="preserve">
          <source>If a name is used in a class body before it is declared, and another declaration for that name is in scope, the program is &lt;a href=&quot;ub&quot;&gt;ill-formed, no diagnostic required&lt;/a&gt;.</source>
          <target state="translated">如果在声明之前在类主体中使用了名称，并且该名称的另一个声明在范围内，则程序&lt;a href=&quot;ub&quot;&gt;格式错误，无需诊断&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="73b765e29ed3c027cc3bcfba763673a78b12e25b" translate="yes" xml:space="preserve">
          <source>If a narrowing conversion is required, other than from an integral type to a floating point type, the program is ill-formed.</source>
          <target state="translated">如果需要进行窄化转换,而不是从积分类型转换为浮点类型,那么程序是不合格的。</target>
        </trans-unit>
        <trans-unit id="a10165cb0c4c283cd3dc5405e46c820a8e3f7689" translate="yes" xml:space="preserve">
          <source>If a nested lambda &lt;code&gt;m2&lt;/code&gt; captures something that is also captured by the immediately enclosing lambda &lt;code&gt;m1&lt;/code&gt;, then &lt;code&gt;m2&lt;/code&gt;'s capture is transformed as follows:</source>
          <target state="translated">如果嵌套的lambda &lt;code&gt;m2&lt;/code&gt; 捕获了立即由紧随其后的lambda &lt;code&gt;m1&lt;/code&gt; 捕获的某些内容，则 &lt;code&gt;m2&lt;/code&gt; 的捕获将按以下方式转换：</target>
        </trans-unit>
        <trans-unit id="35c0cb6d4e19455e10fc3b8d1fea7080305eff39" translate="yes" xml:space="preserve">
          <source>If a new object is created at the address that was occupied by another object, then all pointers, references, and the name of the original object will automatically refer to the new object and, once the lifetime of the new object begins, can be used to manipulate the new object, but only if the following conditions are satisfied:</source>
          <target state="translated">如果在被另一个对象占用的地址上创建了一个新的对象,那么原对象的所有指针、引用和名称都将自动引用新对象,一旦新对象的生命期开始,就可以用来操作新对象,但必须满足以下条件。</target>
        </trans-unit>
        <trans-unit id="040c4b92d07b4519ff12ccd42bcfa061a377c5b4" translate="yes" xml:space="preserve">
          <source>If a non-reference entity is captured by reference, implicitly or explicitly, and the function call operator of the closure object is invoked after the entity's lifetime has ended, undefined behavior occurs. The C++ closures do not extend the lifetimes of the captured references.</source>
          <target state="translated">如果通过引用隐式或显式捕获一个非引用实体,并且在实体的寿命结束后调用闭包对象的函数调用操作符,就会发生未定义的行为。C++闭包不会延长捕获的引用的寿命。</target>
        </trans-unit>
        <trans-unit id="4ceaa0be0f1cb1c411ff6ee0a8d7f52ed257f167" translate="yes" xml:space="preserve">
          <source>If a non-static data member has an &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt; and also appears in a member initializer list, then member initializer list is executed and the default member initializer is ignored:</source>
          <target state="translated">如果非静态数据成员具有&lt;a href=&quot;data_members#Member_initialization&quot;&gt;默认成员初始化程序，&lt;/a&gt;并且也出现在成员初始化程序列表中，那么将执行成员初始化程序列表，并且默认成员初始化程序将被忽略：</target>
        </trans-unit>
        <trans-unit id="0aab394949317f4e8f5352a010f660fb204a47ce" translate="yes" xml:space="preserve">
          <source>If a non-type template parameter is used in the parameter list, and the corresponding template argument is deduced, the type of the deduced template argument ( as specified in its enclosing template parameter list, meaning references are preserved) must match the type of the non-type template parameter exactly, except that cv-qualifiers are dropped, and except where the template argument is deduced from an array bound&amp;mdash;in that case any integral type is allowed, even bool though it would always become true:</source>
          <target state="translated">如果在参数列表中使用了非类型模板参数，并且推导了相应的模板参数，则推导的模板参数的类型（如其随附的模板参数列表中指定的那样，意味着保留引用）必须与完全非类型的模板参数，除了删除cv限定符，以及从数组绑定推导出template参数的情况外，在这种情况下，允许任何整数类型，即使bool始终会变为true：</target>
        </trans-unit>
        <trans-unit id="6a9d189d5910a05ceacbf1d41469dc00391c4252" translate="yes" xml:space="preserve">
          <source>If a pack expansion is nested within another pack expansion, the parameter packs that appear inside the innermost pack expansion are expanded by it, and there must be another pack mentioned in the enclosing pack expansion, but not in the innermost one:</source>
          <target state="translated">如果一个包的扩展被嵌套在另一个包的扩展中,那么出现在最里面的包扩展中的参数包就会被它扩展,而且必须有另一个包在包围的包扩展中提到,但在最里面的包中没有。</target>
        </trans-unit>
        <trans-unit id="0444eb973f9088dccc9bd6e7338a1a6d154f5d7f" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, many implementations of this function leave &lt;code&gt;*t&lt;/code&gt; completely untouched.</source>
          <target state="translated">如果遇到解析错误，则此功能的许多实现都将 &lt;code&gt;*t&lt;/code&gt; 完全保留下来。</target>
        </trans-unit>
        <trans-unit id="7dfecd9ffd391c85c521dbadb0fe904c065d326a" translate="yes" xml:space="preserve">
          <source>If a parsing error is encountered, most implementations of this function leave &lt;code&gt;*t&lt;/code&gt; unmodified.</source>
          <target state="translated">如果遇到解析错误，该函数的大多数实现将 &lt;code&gt;*t&lt;/code&gt; 保留不变。</target>
        </trans-unit>
        <trans-unit id="dcfd421c1a105975620bdb3e159a6ef656b96d8e" translate="yes" xml:space="preserve">
          <source>If a partial specialization of the member template is explicitly specialized for a given (implicit) specialization of the enclosing class template, the primary member template and its other partial specializations are still considered for this specialization of the enclosing class template.</source>
          <target state="translated">如果成员模板的局部特化是针对包围类模板的给定(隐含)特化而显式特化的,则主成员模板及其其他局部特化仍考虑包围类模板的这种特化。</target>
        </trans-unit>
        <trans-unit id="5e69c709c0eda47248b870b79a0045971cbc9fb3" translate="yes" xml:space="preserve">
          <source>If a pointer &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">如果指针 &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95fa4aab00b2248a193df0012ce51bbbfdcb0a2a" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the correct sign).</source>
          <target state="translated">如果发生极点错误，则返回 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; ， &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 或 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; （带有正确的符号）。</target>
        </trans-unit>
        <trans-unit id="88c1375fb3e07154fab82fd39487a150f20a7acc" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">如果发生极点错误，则返回 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; ， &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 或 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83547df0814e730591b9f631b39a107992bddaca" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">如果发生极点错误，则返回 &lt;code&gt;+HUGE_VAL&lt;/code&gt; ， &lt;code&gt;+HUGE_VALF&lt;/code&gt; 或 &lt;code&gt;+HUGE_VALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55c8a2c8fff5d682aefd99723282ecf86b260cc3" translate="yes" xml:space="preserve">
          <source>If a pole error occurs, &lt;code&gt;-HUGE_VAL&lt;/code&gt;, &lt;code&gt;-HUGE_VALF&lt;/code&gt;, or &lt;code&gt;-HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">如果发生极点错误，则返回 &lt;code&gt;-HUGE_VAL&lt;/code&gt; ， &lt;code&gt;-HUGE_VALF&lt;/code&gt; 或 &lt;code&gt;-HUGE_VALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1aad32c287435bd724b2b2cd991a06c95727932d" translate="yes" xml:space="preserve">
          <source>If a pole error or a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">如果由于溢出而发生极点误差或范围误差，则返回 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; ， &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 或 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd506f2079e184fcad156bfb8a88cdf9abf44715" translate="yes" xml:space="preserve">
          <source>If a postcondition &lt;a href=&quot;../definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; a parameter in its predicate and the function body modifies the value of that parameter directly or indirectly, the behavior is undefined.</source>
          <target state="translated">如果后置条件&lt;a href=&quot;../definition#ODR-use&quot;&gt;odr-&lt;/a&gt;在其谓词中使用参数，并且函数主体直接或间接修改该参数的值，则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="d235423e2c4c1707a767d1a11cf327433b3567be" translate="yes" xml:space="preserve">
          <source>If a postcondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the function definition.</source>
          <target state="translated">如果违反了后置条件，则 &lt;code&gt;std::contract_violation&lt;/code&gt; 参数中反映的源位置是函数定义的源位置。</target>
        </trans-unit>
        <trans-unit id="8288ef9f3911668bdd42ba2bba9a0191080ea46e" translate="yes" xml:space="preserve">
          <source>If a precondition is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is implementation-defined.</source>
          <target state="translated">如果违反了前提条件，则 &lt;code&gt;std::contract_violation&lt;/code&gt; 参数中反映的源位置是实现定义的。</target>
        </trans-unit>
        <trans-unit id="ef5fcd9d7689008da5f0e4bea11cd119b6efa160" translate="yes" xml:space="preserve">
          <source>If a primary template is a member of another class template, its partial specializations are members of the enclosing class template. If the enclosing template is instantiated, the declaration of each member partial specialization is instantiated as well (the same way declarations, but not definitions, of all other members of a template are instantiated).</source>
          <target state="translated">如果一个主模板是另一个类模板的成员,那么它的部分特化就是包围类模板的成员。如果包围类模板被实例化,那么每个成员的部分特化的声明也会被实例化(与模板的所有其他成员的声明,而不是定义被实例化的方式相同)。</target>
        </trans-unit>
        <trans-unit id="18b3bedb6ae9572a6c3106b7d4be5f3ebdfc4df2" translate="yes" xml:space="preserve">
          <source>If a program contains declarations of function templates that are</source>
          <target state="translated">如果一个程序包含的函数模板的声明是</target>
        </trans-unit>
        <trans-unit id="87ffbc04e56c0394a3ecec919c439f807e6404bc" translate="yes" xml:space="preserve">
          <source>If a put area exist (e.g. file was opened for writing), first calls &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; to write all pending output to the file, including any unshift sequences.</source>
          <target state="translated">如果存在放置区域（例如，已打开文件进行写入），则首先调用 &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; 将所有待处理的输出写入文件，包括所有取消移位的序列。</target>
        </trans-unit>
        <trans-unit id="919f0fed96116787f70c42581aa4648db9ff5450" translate="yes" xml:space="preserve">
          <source>If a put area exists (e.g. the file was opened for writing), calls &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; to write all pending output to the file, then flushes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果存在放置区域（例如，已打开文件进行写入），则调用 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 将所有待处理的输出写入文件，然后像调用 &lt;code&gt;&lt;a href=&quot;../c/fflush&quot;&gt;std::fflush&lt;/a&gt;&lt;/code&gt; 一样刷新文件。</target>
        </trans-unit>
        <trans-unit id="776889337c5b506a958bcb11170f9049bdd28571" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), and the character &lt;code&gt;c&lt;/code&gt; is equal to the character one position to the left of &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; (as determined by &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt;, then simply decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果在get区域中有一个回退位置可用（ &lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt; ），并且字符 &lt;code&gt;c&lt;/code&gt; 等于 &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; 左侧的字符位置（由 &lt;code&gt;Traits::eq(c, gptr()[-1])&lt;/code&gt; ，然后简单地递减下一个指针（ &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9cb9d7c878f7f8a77860594336867a6041aa5088" translate="yes" xml:space="preserve">
          <source>If a putback position is available in the get area (&lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt;), then decrements the next pointer (&lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt;) and returns the character it now points to.</source>
          <target state="translated">如果在get区域中有一个回退位置（ &lt;code&gt;gptr() &amp;gt; eback()&lt;/code&gt; ），则递减下一个指针（ &lt;code&gt;&lt;a href=&quot;gptr&quot;&gt;gptr()&lt;/a&gt;&lt;/code&gt; ）并返回它现在指向的字符。</target>
        </trans-unit>
        <trans-unit id="79ac53d959c455debaf74453ed6b72c19ac11dfa" translate="yes" xml:space="preserve">
          <source>If a putback position is not available, then calls &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; to back up the input sequence if possible.</source>
          <target state="translated">如果没有 &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; 位置，则在可能的情况下调用pbackfail（）备份输入序列。</target>
        </trans-unit>
        <trans-unit id="5c9db649e4e6e4c38883de06799ee045378481d1" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned (with the same sign as &lt;code&gt;from&lt;/code&gt;).</source>
          <target state="translated">如果范围误差由于发生溢出， &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; ， &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; ，或 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 被返回（与相同的符号 &lt;code&gt;from&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9842b2827c672e6e4b846cc1f4ef41186aaaf5f3" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt;, &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt;, or &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">如果发生由于溢出引起的范围错误，则返回 &lt;code&gt;&amp;plusmn;HUGE_VAL&lt;/code&gt; ， &lt;code&gt;&amp;plusmn;HUGE_VALF&lt;/code&gt; 或 &lt;code&gt;&amp;plusmn;HUGE_VALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9e1bf2f0df7137552a9579d23123773adeb14193" translate="yes" xml:space="preserve">
          <source>If a range error due to overflow occurs, &lt;code&gt;+HUGE_VAL&lt;/code&gt;, &lt;code&gt;+HUGE_VALF&lt;/code&gt;, or &lt;code&gt;+HUGE_VALL&lt;/code&gt; is returned.</source>
          <target state="translated">如果发生由于溢出引起的范围错误，则返回 &lt;code&gt;+HUGE_VAL&lt;/code&gt; ， &lt;code&gt;+HUGE_VALF&lt;/code&gt; 或 &lt;code&gt;+HUGE_VALL&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55d9e5e2db658de793b6612e1c8dc0adb82837dc" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct result (after rounding) is returned.</source>
          <target state="translated">如果由于下溢而发生范围错误,则返回正确的结果(四舍五入后)。</target>
        </trans-unit>
        <trans-unit id="144f2afda2da10823b65a9e4c24a0b3bb37c9913" translate="yes" xml:space="preserve">
          <source>If a range error due to underflow occurs, the correct value (after rounding) is returned.</source>
          <target state="translated">如果发生因下溢而导致的范围错误,则返回正确的值(四舍五入后)。</target>
        </trans-unit>
        <trans-unit id="949156f77460641cf432a3cc1721f1ed036f3731" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding) is returned.</source>
          <target state="translated">如果由于下溢而发生范围错误,则返回正确的结果(四舍五入后)。</target>
        </trans-unit>
        <trans-unit id="48f1515a1657338dc5a4774929668cb3a0851098" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result (after rounding), that is.</source>
          <target state="translated">如果由于下溢而出现范围错误,则正确的结果(四舍五入后),即。</target>
        </trans-unit>
        <trans-unit id="bea570ee8fcad0dd93ebf596f86eddc89718e8ce" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned if subnormals are supported.</source>
          <target state="translated">如果由于下溢而发生范围错误,如果支持子规范,则返回正确的结果。</target>
        </trans-unit>
        <trans-unit id="4771fa50f8d7229b07b35621538a1aac36cd67a9" translate="yes" xml:space="preserve">
          <source>If a range error occurs due to underflow, the correct result is returned.</source>
          <target state="translated">如果由于下溢而发生范围错误,则返回正确的结果。</target>
        </trans-unit>
        <trans-unit id="ccb8e801dc7894cca248dbed67f56627d7cf0cc4" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;)for the stream is set.</source>
          <target state="translated">如果发生读取或写入错误，则会设置流的错误指示符（ &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e789f3da6463649b436aef5182ff1d2b5da92664" translate="yes" xml:space="preserve">
          <source>If a read or write error occurs, the error indicator for the stream (&lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt;) is set and the file position is unaffected.</source>
          <target state="translated">如果发生读取或写入错误，将设置流的错误指示符（ &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; ），并且文件位置不受影响。</target>
        </trans-unit>
        <trans-unit id="86b3ac21433e164a790502ba1ef0db8db078e961" translate="yes" xml:space="preserve">
          <source>If a requires-expression contains invalid types or expressions in its requirements, and it does not appear within the declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt;, then the program is ill-formed.</source>
          <target state="translated">如果require-expression在其需求中包含无效的类型或表达式，并且未出现在&lt;a href=&quot;templates#Templated_entity&quot;&gt;模板实体&lt;/a&gt;的声明中，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="4b01d79ca1850a7a1aa26257022da9a9b9591827" translate="yes" xml:space="preserve">
          <source>If a rewritten candidate is selected by overload resolution for an operator &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;x @ y&lt;/code&gt; is interpreted as the rewritten expression: &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; if the selected candidate is a synthesized candidate with reversed order of parameters, or &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; otherwise, using the selected rewritten &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; candidate.</source>
          <target state="translated">如果通过重载决议为运算符 &lt;code&gt;@&lt;/code&gt; 选择了重写的候选项，则 &lt;code&gt;x @ y&lt;/code&gt; 解释为重写的表达式： &lt;code&gt;0 @ (y &amp;lt;=&amp;gt; x)&lt;/code&gt; 如果所选的候选是参数顺序相反的合成候选，或者 &lt;code&gt;(x &amp;lt;=&amp;gt; y) @ 0&lt;/code&gt; 否则，使用选定的重写 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 候选。</target>
        </trans-unit>
        <trans-unit id="d146da8681a775135daad12f043cc5018dc0ef5e" translate="yes" xml:space="preserve">
          <source>If a signal handler is executed as a result of a call to &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronously), then the execution of the handler is</source>
          <target state="translated">如果信号处理程序是由于对 &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; 的调用（同步）而执行的，则该处理程序的执行为</target>
        </trans-unit>
        <trans-unit id="3f5eeae6c512283e05fb7f521150bb498afe542b" translate="yes" xml:space="preserve">
          <source>If a standard-layout &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; holds two (or more) standard-layout classes as members, and these classes have a common initial sequence of data members, it is well-defined to examine any member of that common initial sequence regardless of which member of the union is active.</source>
          <target state="translated">如果标准布局&lt;a href=&quot;union&quot;&gt;联合&lt;/a&gt;拥有两个（或多个）标准布局类作为成员，并且这些类具有公共的数据成员初始序列，则定义良好的定义是检查该公共初始序列的任何成员，而不管其中的哪个成员工会很活跃。</target>
        </trans-unit>
        <trans-unit id="e3cc007cd990ced3f77a08ffa3521f8f43ea784b" translate="yes" xml:space="preserve">
          <source>If a standard-layout union holds two or more standard-layout structs, it is permitted to inspect the common initial part of them.</source>
          <target state="translated">如果一个标准布局联盟拥有两个或两个以上的标准布局结构,则允许检查它们的共同初始部分。</target>
        </trans-unit>
        <trans-unit id="9c11517af35c72db9ca494141a4ef3243dbf8700" translate="yes" xml:space="preserve">
          <source>If a static data member is declared &lt;code&gt;constexpr&lt;/code&gt;, it is implicitly &lt;code&gt;inline&lt;/code&gt; and does not need to be redeclared at namespace scope. This redeclaration without an initializer (formerly required as shown above) is still permitted, but is deprecated.</source>
          <target state="translated">如果将静态数据成员声明为 &lt;code&gt;constexpr&lt;/code&gt; ，则它是隐式 &lt;code&gt;inline&lt;/code&gt; ，不需要在命名空间范围内重新声明。没有初始化程序的重新声明（以前是必需的，如上所示）仍然是允许的，但已弃用。</target>
        </trans-unit>
        <trans-unit id="58d434e5ce1cbd3b6a5b0e91079e4162ccbc510a" translate="yes" xml:space="preserve">
          <source>If a static data member of &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; is declared &lt;code&gt;constexpr&lt;/code&gt;, it must be initialized with an initializer in which every expression is a constant expression, right inside the class definition:</source>
          <target state="translated">如果将&lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;的静态数据成员声明为 &lt;code&gt;constexpr&lt;/code&gt; ，则必须使用初始化器初始化该初始化器，在该初始化器中，每个表达式都是一个常量表达式，就在类定义内：</target>
        </trans-unit>
        <trans-unit id="6d5250822667240cedf5abd394540f13a00c0bf0" translate="yes" xml:space="preserve">
          <source>If a static data member of integral or enumeration type is declared &lt;code&gt;const&lt;/code&gt; (and not &lt;code&gt;volatile&lt;/code&gt;), it can be initialized with an &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt; in which every expression is a &lt;a href=&quot;constexpr&quot;&gt;constant expression&lt;/a&gt;, right inside the class definition:</source>
          <target state="translated">如果将整型或枚举类型的静态数据成员声明为 &lt;code&gt;const&lt;/code&gt; （而不是 &lt;code&gt;volatile&lt;/code&gt; ），则可以使用初始化器将其&lt;a href=&quot;initialization&quot;&gt;初始化，&lt;/a&gt;在该初始化器中，每个表达式都是一个&lt;a href=&quot;constexpr&quot;&gt;常量表达式&lt;/a&gt;，就在类定义内：</target>
        </trans-unit>
        <trans-unit id="12dd0f953c32785837578e88c1ac2b71b7c9df42" translate="yes" xml:space="preserve">
          <source>If a substitution failure would occur in a requires-expression for every possible template argument, the program is ill-formed, no diagnostic required:</source>
          <target state="translated">如果在一个 requires-表达式中,每一个可能的模板参数都会出现替换失败,那么程序就是不合格的,不需要诊断。</target>
        </trans-unit>
        <trans-unit id="85a2d46acfcfae4cb4dbacf839e2b8264a66b2a5" translate="yes" xml:space="preserve">
          <source>If a textual representation is written using &lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; and that representation is restored into the same or a different object &lt;code&gt;y&lt;/code&gt; of the same type using &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt;, then &lt;code&gt;x==y&lt;/code&gt;.</source>
          <target state="translated">如果使用 &lt;code&gt;os &amp;lt;&amp;lt; x&lt;/code&gt; 编写文本表示形式，并且使用 &lt;code&gt;is &amp;gt;&amp;gt; y&lt;/code&gt; 将该表示形式恢复到相同或不同类型的对象 &lt;code&gt;y&lt;/code&gt; 中，则 &lt;code&gt;x==y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="137821a74c9d0d2d1139c4f208ae9d5537a8856a" translate="yes" xml:space="preserve">
          <source>If a thread offers</source>
          <target state="translated">如果一条线提供</target>
        </trans-unit>
        <trans-unit id="e2107d4d6cd0905d309a488e5a792dc268bd6478" translate="yes" xml:space="preserve">
          <source>If a token matches a user-defined literal syntax and a regular literal syntax, it is assumed to be a regular literal (that is, it's impossible to overload &lt;code&gt;LL&lt;/code&gt; in &lt;code&gt;123LL&lt;/code&gt;).</source>
          <target state="translated">如果令牌匹配用户定义的文本语法和常规文字语法，它被假定为是一个普通文字（即，这是不可能的过载 &lt;code&gt;LL&lt;/code&gt; 在 &lt;code&gt;123LL&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e7ee443e3c5d2843d1d2376575bce346735adf6d" translate="yes" xml:space="preserve">
          <source>If a type contains both a &lt;code&gt;value_type&lt;/code&gt; member and a &lt;code&gt;element_type&lt;/code&gt; member, then the specializations (5) and (6) are ambiguous.</source>
          <target state="translated">如果类型同时包含 &lt;code&gt;value_type&lt;/code&gt; 成员和 &lt;code&gt;element_type&lt;/code&gt; 成员，则专业化（5）和（6）会模棱两可。</target>
        </trans-unit>
        <trans-unit id="0fdf3b97165e0c642a71a4a01aa77341934eb9b1" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, the default constructor of the union is deleted by default unless a &lt;a href=&quot;union#Union-like_classes&quot;&gt;variant member&lt;/a&gt; of the union has a default member initializer .</source>
          <target state="translated">如果联合包含具有非平凡&lt;a href=&quot;default_constructor&quot;&gt;默认构造函数&lt;/a&gt;的非静态数据成员，则默认情况下将删除联合的默认构造函数，除非联合的&lt;a href=&quot;union#Union-like_classes&quot;&gt;变体成员&lt;/a&gt;具有默认成员初始值设定项。</target>
        </trans-unit>
        <trans-unit id="ed781d9376b4a389124dc536ac979cb50e822257" translate="yes" xml:space="preserve">
          <source>If a union contains a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_constructor&quot;&gt;move&lt;/a&gt; constructor, &lt;a href=&quot;as_operator&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_operator&quot;&gt;move&lt;/a&gt; assignment, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;), that function is deleted by default in the union and needs to be defined explicitly by the programmer.</source>
          <target state="translated">如果联合包含具有非平凡特殊成员函数（&lt;a href=&quot;copy_constructor&quot;&gt;复制&lt;/a&gt; / &lt;a href=&quot;move_constructor&quot;&gt;移动&lt;/a&gt;构造函数，&lt;a href=&quot;as_operator&quot;&gt;复制&lt;/a&gt; / &lt;a href=&quot;move_operator&quot;&gt;移动&lt;/a&gt;分配或&lt;a href=&quot;destructor&quot;&gt;析构函数&lt;/a&gt;）的非静态数据成员，则该函数默认在联合中被删除，并且需要由联合显式定义。程序员。</target>
        </trans-unit>
        <trans-unit id="099b8ae16a17dd76f9cadbb47f54a708a0db6c1f" translate="yes" xml:space="preserve">
          <source>If a universal character name does not correspond to a code point in ISO/IEC 10646 (the range 0x0-0x10FFFF, inclusive) or if a universal-character-name corresponds to a surrogate code point (the range 0xD800-0xDFFF, inclusive), the program is ill-formed.</source>
          <target state="translated">如果通用字符名不对应ISO/IEC 10646中的码点(范围0x0-0x10FFFF,含),或者通用字符名对应代用码点(范围0xD800-0xDFFF,含),则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="05d3d79510e285cdbcce2e730e70fb609e1930e6" translate="yes" xml:space="preserve">
          <source>If a user-defined &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is provided, the &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is called again on the value that it returns, recursively, until an &lt;code&gt;operator-&amp;gt;&lt;/code&gt; is reached that returns a plain pointer. After that, built-in semantics are applied to that pointer.</source>
          <target state="translated">如果用户定义的 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 设置，该 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 再次调用上的值，它返回，递归，直至一个 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 达到该返回一个普通的指针。之后，将内置语义应用于该指针。</target>
        </trans-unit>
        <trans-unit id="4afbc606ff35300da34cbcea95316abaecaec363" translate="yes" xml:space="preserve">
          <source>If a using-declaration brings the base class assignment operator into derived class, whose signature happens to match the derived class's copy-assignment or move-assignment operator, that operator is hidden by the implicitly-declared copy/move assignment operator of the derived class. Same applies to a using-declaration that inherits a base class constructor that happens to match the derived class copy/move constructor(since C++11).</source>
          <target state="translated">如果一个使用声明将基类赋值操作符带入派生类,而基类赋值操作符的签名恰好与派生类的复制赋值或移动赋值操作符相匹配,那么这个操作符就会被派生类隐式声明的复制/移动赋值操作符所隐藏。同样的道理也适用于继承基类构造函数的使用声明,而这个基类构造函数恰好与派生类的复制/移动构造函数相匹配(自C++11起)。</target>
        </trans-unit>
        <trans-unit id="f5b571b0ea54c128d0c23143cfd6e47087b60bac" translate="yes" xml:space="preserve">
          <source>If a valid hex digit follows a hex escape in a string literal, it would fail to compile as an invalid escape sequence. String concatenation can be used as a workaround:</source>
          <target state="translated">如果一个有效的十六进制数字跟在一个字符串文字中的十六进制转义之后,它将作为一个无效的转义序列而无法编译。字符串连接可以作为一种变通方法。</target>
        </trans-unit>
        <trans-unit id="e40960cc6f868e411ccb39ae2869971ab6ec8fa0" translate="yes" xml:space="preserve">
          <source>If a violation handler exits by throwing an exception and a contract is violated on a call to a function with a non-throwing exception specification, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called:</source>
          <target state="translated">如果违反处理程序因引发异常而退出，并且在调用具有非引发异常规范的函数时违反了合同，则将调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="89d508127947fb06fdf07d63dd69506781a83552" translate="yes" xml:space="preserve">
          <source>If a virtual function is non-throwing, all declarations, including the definition, of every overrider must be non-throwing as well, unless the overrider is defined as deleted:</source>
          <target state="translated">如果一个虚拟函数是非抛出的,那么包括定义在内的每个覆盖者的所有声明也必须是非抛出的,除非覆盖者被定义为删除。</target>
        </trans-unit>
        <trans-unit id="a4f25c0ec9b3244cc6b75eca052c2b903d4a3faa" translate="yes" xml:space="preserve">
          <source>If a width specifier is used, matches exactly</source>
          <target state="translated">如果使用了宽度指定器,则与之完全匹配。</target>
        </trans-unit>
        <trans-unit id="ee230d51493f44d873329313db640aba06300254" translate="yes" xml:space="preserve">
          <source>If access-specifier is omitted, it defaults to &lt;code&gt;public&lt;/code&gt; for classes declared with class-key &lt;code&gt;struct&lt;/code&gt; and to &lt;code&gt;private&lt;/code&gt; for classes declared with class-key &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">如果省略访问说明符，则默认为 &lt;code&gt;public&lt;/code&gt; 的类的类的关键字声明 &lt;code&gt;struct&lt;/code&gt; 和 &lt;code&gt;private&lt;/code&gt; 的类的类的关键字声明 &lt;code&gt;class&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bb883e9abe3625b7a86952913a7a8fb72c62f08" translate="yes" xml:space="preserve">
          <source>If after preparation is completed, &lt;code&gt;is.good() == true&lt;/code&gt;, then any subsequent calls to &lt;code&gt;operator bool&lt;/code&gt; will return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果准备完成后 &lt;code&gt;is.good() == true&lt;/code&gt; ，则对 &lt;code&gt;operator bool&lt;/code&gt; 任何后续调用都将返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9cb4a02d9dcd9af6fe36d5a1c910eb0e957522e" translate="yes" xml:space="preserve">
          <source>If all scalar types are big-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::big&lt;/code&gt;</source>
          <target state="translated">如果所有标量类型均为big-endian，则 &lt;code&gt;std::endian::native&lt;/code&gt; 等于 &lt;code&gt;std::endian::big&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d891a5fe804d25c6beb79958744a0d7c5ceede89" translate="yes" xml:space="preserve">
          <source>If all scalar types are little-endian, &lt;code&gt;std::endian::native&lt;/code&gt; equals &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="translated">如果所有标量类型均为little-endian，则 &lt;code&gt;std::endian::native&lt;/code&gt; 等于 &lt;code&gt;std::endian::little&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d243121b5c4fac9f94b27743279405785142b5" translate="yes" xml:space="preserve">
          <source>If all scalar types have sizeof equal to 1, endianness does not matter and all three values, &lt;code&gt;std::endian::little&lt;/code&gt;, &lt;code&gt;std::endian::big&lt;/code&gt;, and &lt;code&gt;std::endian::native&lt;/code&gt; are the same</source>
          <target state="translated">如果所有标量类型的大小都等于1，则字节序无关紧要，并且所有三个值 &lt;code&gt;std::endian::little&lt;/code&gt; ， &lt;code&gt;std::endian::big&lt;/code&gt; 和 &lt;code&gt;std::endian::native&lt;/code&gt; 都相同</target>
        </trans-unit>
        <trans-unit id="fee72b37f3cceab886b744b0079670d877f9da6f" translate="yes" xml:space="preserve">
          <source>If all these requirements are satisfied, the program behaves as if there is only one definition in the entire program. Otherwise, the behavior is undefined.</source>
          <target state="translated">如果所有这些要求都得到满足,程序的行为就像整个程序中只有一个定义一样。否则,行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="36968e9ab5f085f057a3410989745d6fedfc4429" translate="yes" xml:space="preserve">
          <source>If all variable arguments share a common type, a &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; provides a convenient mechanism (albeit with a different syntax) for accessing variable arguments. In this case however the arguments cannot be modified since &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; can only provide a const pointer to its elements.</source>
          <target state="translated">如果所有变量参数都具有相同的类型，则 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 可提供一种方便的机制（尽管语法不同）来访问变量参数。但是在这种情况下，由于 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 只能提供指向其元素的const指针，因此无法修改参数。</target>
        </trans-unit>
        <trans-unit id="3d9bddcd412f103377a475053cbfe6abb6de8ca4" translate="yes" xml:space="preserve">
          <source>If allocation fails, calls &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; which may throw &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果分配失败，请调用 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&amp;lt;&amp;gt;::setstate(badbit)&lt;/code&gt; ，这可能会引发 &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d22bb8db5e7c03b3a89c230b5d801c2d5d1be4c" translate="yes" xml:space="preserve">
          <source>If allocation fails, the coroutine throws &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;, unless the Promise type defines the member function &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt;. If that member function is defined, allocation uses the &lt;code&gt;nothrow&lt;/code&gt; form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; and on allocation failure, the coroutine immediately returns the object obtained from &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; to the caller.</source>
          <target state="translated">如果分配失败，协程将抛出 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; ，除非Promise类型定义了成员函数 &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; 。如果定义了该成员函数，则分配使用 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;nothrow&lt;/code&gt; 形式并且在分配失败时，协程立即将从 &lt;code&gt;Promise::get_return_object_on_allocation_failure()&lt;/code&gt; 获得的对象返回给调用者。</target>
        </trans-unit>
        <trans-unit id="10b291b7c1e1eda28b0d49719b46140dae50f0df" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type.</source>
          <target state="translated">如果分配成功,返回分配的内存块中对任何对象类型都适当对齐的最低(第一个)字节的指针。</target>
        </trans-unit>
        <trans-unit id="c9ec1b427a47550a259fb9e7cce19a17de85fede" translate="yes" xml:space="preserve">
          <source>If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any scalar type.</source>
          <target state="translated">如果分配成功,返回分配的内存块中对任何标量类型适当对齐的最低(第一个)字节的指针。</target>
        </trans-unit>
        <trans-unit id="02152ab02c6a07719ce83211d89650966926f11f" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; function is declared in different translation units, the accumulated sets of default arguments must be the same at the end of each translation unit.</source>
          <target state="translated">如果 &lt;a href=&quot;inline&quot;&gt;内联&lt;/a&gt;函数在不同的翻译单元中声明，则默认参数的累积集合在每个翻译单元的末尾必须相同。</target>
        </trans-unit>
        <trans-unit id="1551cfc134da3f21c2cecb1326986402690023a3" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b6cc884811a5bc876e80b90a3283051d48412ce" translate="yes" xml:space="preserve">
          <source>If an adaptor takes multiple arguments, these forms are equivalent:</source>
          <target state="translated">如果一个适配体需要多个参数,这些形式是等价的。</target>
        </trans-unit>
        <trans-unit id="e01b1c25d1638defb1bea8fb709196bd2ebf642e" translate="yes" xml:space="preserve">
          <source>If an argument can be interpreted as both a &lt;a href=&quot;type-id&quot;&gt;type-id&lt;/a&gt; and an expression, it is always interpreted as a type-id, even if the corresponding template parameter is non-type:</source>
          <target state="translated">如果一个参数可以解释为两个 &lt;a href=&quot;type-id&quot;&gt;类型标识&lt;/a&gt;又可以是表达式，那么即使相应的模板参数是非类型的，也总是将其解释为类型标识：</target>
        </trans-unit>
        <trans-unit id="c31ea93038a8a30a4e1fc8e381029269be15af66" translate="yes" xml:space="preserve">
          <source>If an array is so large (greater than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; elements, but less than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; bytes), that the difference between two pointers may not be representable as &lt;code&gt;std::ptrdiff_t&lt;/code&gt;, the result of subtracting two such pointers is undefined.</source>
          <target state="translated">如果数组太大（大于 &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; 元素，但小于 &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;SIZE_MAX&lt;/a&gt;&lt;/code&gt; 字节），则两个指针之间的差可能无法表示为 &lt;code&gt;std::ptrdiff_t&lt;/code&gt; ，减去两个这样的指针的结果是不确定的。</target>
        </trans-unit>
        <trans-unit id="799e3725591131ec4c78246e418ad8132ce4bd81" translate="yes" xml:space="preserve">
          <source>If an assertion is violated, the source location reflected in the &lt;code&gt;std::contract_violation&lt;/code&gt; argument is the source location of the statement to which the assertion is applied.</source>
          <target state="translated">如果违反了断言，则源位置将反映在 &lt;code&gt;std::contract_violation&lt;/code&gt; 参数中的源位置是该断言所应用到的语句的源位置。</target>
        </trans-unit>
        <trans-unit id="940fbe62d35554fccc76640b50d6adbc0079900c" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_acquire&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that</source>
          <target state="translated">如果线程A中的原子存储被标记为 &lt;code&gt;memory_order_release&lt;/code&gt; ,并且线程B中来自同一变量的原子加载被标记为 &lt;code&gt;memory_order_acquire&lt;/code&gt; ，则所有内存写入（非原子和宽松原子）都将</target>
        </trans-unit>
        <trans-unit id="cf29cb2a4f015597bd5e89b82f0e88a7976c2e6a" translate="yes" xml:space="preserve">
          <source>If an atomic store in thread A is tagged &lt;code&gt;memory_order_release&lt;/code&gt; and an atomic load in thread B from the same variable is tagged &lt;code&gt;memory_order_consume&lt;/code&gt;, all memory writes (non-atomic and relaxed atomic) that are</source>
          <target state="translated">如果线程A中的原子存储被标记为 &lt;code&gt;memory_order_release&lt;/code&gt; ,并且线程B中来自同一变量的原子加载被标记为 &lt;code&gt;memory_order_consume&lt;/code&gt; ，则所有的内存写入（非原子和宽松原子）</target>
        </trans-unit>
        <trans-unit id="fb35a531d8dbb01db97b20b4045440d69aef50c3" translate="yes" xml:space="preserve">
          <source>If an entity is declared, but not defined in some inner namespace, and then declared through using-declaration in the outer namespace, and then a definition appears in the outer namespace with the same unqualified name, that definition is a member of the outer namespace and conflicts with the using-declration:</source>
          <target state="translated">如果一个实体被声明,但在某个内部命名空间中没有被定义,然后在外部命名空间中通过使用声明被声明,然后在外部命名空间中出现了一个同样的非限定名的定义,那么这个定义就是外部命名空间的成员,与使用声明发生冲突。</target>
        </trans-unit>
        <trans-unit id="cc997e2af47722454e317470db77023efe2a1536" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate.</source>
          <target state="translated">如果发生错误,流的文件位置指示器的结果值是不确定的。</target>
        </trans-unit>
        <trans-unit id="6911b84a61e5b6d4a44d583d9d016bd32e93add2" translate="yes" xml:space="preserve">
          <source>If an error occurs, the resulting value of the file position indicator for the stream is indeterminate. If a partial element is read, its value is indeterminate.</source>
          <target state="translated">如果发生错误,流的文件位置指示器的结果值是不确定的。如果读取了部分元素,其值是不确定的。</target>
        </trans-unit>
        <trans-unit id="a220d01f6d39ee26bbdcd1467c8f79348871f6b1" translate="yes" xml:space="preserve">
          <source>If an error occurs, the value of any cached attributes is unspecified.</source>
          <target state="translated">如果发生错误,任何缓存属性的值都是未指定的。</target>
        </trans-unit>
        <trans-unit id="9cb826938ccf3fe4b9ff8ed25a48550d29964cf5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (e.g. by the constructor), the container is left unmodified, as if this function was never called (strong exception guarantee).</source>
          <target state="translated">如果抛出了异常(例如由构造函数抛出的异常),容器将不被修改,就像这个函数从未被调用过一样(强异常保证)。</target>
        </trans-unit>
        <trans-unit id="e6b48d12afec14d3a79a0c500c4659180b4eec6c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown (which can be due to &lt;code&gt;Allocator::allocate()&lt;/code&gt; or element copy/move constructor/assignment), this function has no effect (strong exception guarantee).</source>
          <target state="translated">如果引发异常（可能是由于 &lt;code&gt;Allocator::allocate()&lt;/code&gt; 或元素复制/移动构造函数/赋值），则此函数无效（强烈保证异常）。</target>
        </trans-unit>
        <trans-unit id="6b0edabc7639167b7745ce3af46fe3ed92a198db" translate="yes" xml:space="preserve">
          <source>If an exception is thrown and not caught, including exceptions that escape the initial function of &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, the main function, and the constructor or destructor of any static or thread-local objects, then &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. It is implementation-defined whether any stack unwinding takes place for uncaught exceptions.</source>
          <target state="translated">如果引发了异常并且未捕获到异常，包括对 &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 的初始函数，主函数以及任何静态或线程本地对象的构造函数或析构函数进行转义的异常，则 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 调用。由实现定义，是否针对未捕获的异常发生任何堆栈展开。</target>
        </trans-unit>
        <trans-unit id="6c48ec192ada9dad6ea416b0b9a80403d55d5ef7" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, the insertion has no effect.</source>
          <target state="translated">如果任何操作引发了异常,那么插入就没有效果。</target>
        </trans-unit>
        <trans-unit id="74d7d81ca3798adddb2a94c8e751e9f52b51c3b5" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect (strong exception guarantee).</source>
          <target state="translated">如果任何操作抛出了异常,这个函数就没有效果(强异常保证)。</target>
        </trans-unit>
        <trans-unit id="5161835af8a659e8b34603c4018519221f368f0d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown by any operation, this function has no effect.</source>
          <target state="translated">如果任何操作引发了异常,这个函数就没有效果。</target>
        </trans-unit>
        <trans-unit id="7330a7b17e421be1c44660348af259ca51b2771d" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during &lt;code&gt;insert_after&lt;/code&gt; there are no effects (strong exception guarantee).</source>
          <target state="translated">如果在期间抛出异常 &lt;code&gt;insert_after&lt;/code&gt; 之后则没有效果（强烈的异常保证）。</target>
        </trans-unit>
        <trans-unit id="edd7ac01fb9845bcf837eeafecc9a3bfcff9c06c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in &lt;code&gt;[first, last)&lt;/code&gt; are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">如果初始化期间引发异常，则某些对象 &lt;code&gt;[first, last)&lt;/code&gt; 中的有效但未指定的状态，并且已经构造的对象将以未指定的顺序销毁。</target>
        </trans-unit>
        <trans-unit id="ec0adbbf8914c8a6c4eec4111473b5a13e8599b3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, some objects in the source range are left in a valid but unspecified state, and the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">如果在初始化过程中抛出了一个异常,那么源范围内的一些对象就会被留在一个有效但未指定的状态下,而已经构造的对象则会以一个未指定的顺序被销毁。</target>
        </trans-unit>
        <trans-unit id="e9fecf24ed4ce20def8a83e7f8d57995cf139492" translate="yes" xml:space="preserve">
          <source>If an exception is thrown during the initialization, the objects already constructed are destroyed in an unspecified order.</source>
          <target state="translated">如果在初始化过程中抛出了一个异常,那么已经构造的对象就会以一个未指定的顺序被销毁。</target>
        </trans-unit>
        <trans-unit id="e35211af8694cccb5bdef2a4d7dc7571b7be0615" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="translated">如果因为任何原因抛出异常,这个函数没有任何效果(强异常保证)。</target>
        </trans-unit>
        <trans-unit id="7307b2f5ebe1d631c57170aa7d478af487897112" translate="yes" xml:space="preserve">
          <source>If an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="translated">如果因为任何原因抛出异常,这个函数没有任何效果(强异常保证)。(自C++11起)。</target>
        </trans-unit>
        <trans-unit id="e6bb71e623e7422ccad975c487b4cc2c5f5da503" translate="yes" xml:space="preserve">
          <source>If an exception is thrown from a constructor or (rare) from a destructor of an object (regardless of the object's storage duration), destructors are called for all fully-constructed non-static non-variant (until C++14)members and base classes, in reverse order of completion of their constructors.  Variant members of union-like classes are only destroyed in the case of unwinding from constructor, and if the active member changed between initialization and destruction, the behavior is undefined.(since C++14).</source>
          <target state="translated">如果从对象的构造函数或(罕见的)从对象的破坏函数中抛出异常(不管对象的存储持续时间如何),所有完全构造的非静态非变体(直到C++14)成员和基类的破坏函数都会被调用,顺序与它们的构造函数完成的顺序相反。Union-like类的变体成员只有在从构造函数中解开的情况下才会被销毁,如果活动成员在初始化和销毁之间发生了变化,则行为是未定义的(自C++14起)。</target>
        </trans-unit>
        <trans-unit id="2ad1992b7bb0d63f90a28d4087b380a5f34ae1b1" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by T's move constructor, there are no effects.</source>
          <target state="translated">如果T的move构造函数以外的异常被抛出,则没有影响。</target>
        </trans-unit>
        <trans-unit id="0aa3f34d072cd60cd1c35878bea5fd44d2e91e5c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the either end, there are no effects (strong exception guarantee).</source>
          <target state="translated">如果复制构造函数，移动构造函数，赋值运算符或移动值类型的赋值运算符引发了异常，或者在 &lt;code&gt;emplace&lt;/code&gt; 期间引发了异常在两端插入单个元素时效果（强烈的例外保证）。</target>
        </trans-unit>
        <trans-unit id="e8ab6bfb09942462906da02ee59e1dffd07b24d4" translate="yes" xml:space="preserve">
          <source>If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of the value type, or if an exception is thrown while &lt;code&gt;emplace&lt;/code&gt; is used to insert a single element at the end and the value type is either &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or nothrow move constructible, there are no effects (strong exception guarantee).</source>
          <target state="translated">如果通过复制构造函数，移动构造函数，赋值运算符或移动赋值运算符抛出了异常，则抛出异常，或者在使用 &lt;code&gt;emplace&lt;/code&gt; 末尾插入单个元素且值类型为时抛出异常要么&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt; CopyInsertable&lt;/a&gt;或抛出异常举动构造的，有没有效果（强异常保证）。</target>
        </trans-unit>
        <trans-unit id="2b1a5d269dbdbb9335cbe2fc340876502acdd2c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at either end, this function has no effect (strong exception guarantee).</source>
          <target state="translated">如果在两端插入单个元素时产生异常,这个函数没有任何效果(强异常保证)。</target>
        </trans-unit>
        <trans-unit id="bb38c7fc8ae93e70dfd12f9e670486bb28d436c3" translate="yes" xml:space="preserve">
          <source>If an exception is thrown when inserting a single element at the end, and T is &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, there are no effects (strong exception guarantee).</source>
          <target state="translated">如果在末尾插入单个元素时抛出异常，并且T为&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;或 &lt;code&gt;std::is_nothrow_move_constructible&amp;lt;T&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则没有效果（强烈的异常保证）。</target>
        </trans-unit>
        <trans-unit id="5998c425618742c5b2fb20a25e64116eb53b0228" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the order of elements in &lt;code&gt;*this&lt;/code&gt; is unspecified.</source>
          <target state="translated">如果引发异常，则 &lt;code&gt;*this&lt;/code&gt; 中的元素顺序不确定。</target>
        </trans-unit>
        <trans-unit id="b5d6cabb3aae2ee52d65a4c1ac74ad65e7757f3c" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, the shared lock is not acquired.</source>
          <target state="translated">如果抛出异常,则不会获得共享锁。</target>
        </trans-unit>
        <trans-unit id="5440918eea68b650c34253d04fa176ac527a4e96" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, there are no effects (strong exception guarantee).</source>
          <target state="translated">如果抛出异常,则没有影响(强异常保证)。</target>
        </trans-unit>
        <trans-unit id="34d24286b06e2a97113c97c53555bf7644c31051" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (&lt;a href=&quot;../../language/exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;).</source>
          <target state="translated">如果抛出异常，则此功能无效（&lt;a href=&quot;../../language/exceptions&quot;&gt;强异常保证&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2bd98e6e41884aadeeb627570c45089a1aee3259" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee), except if the exception comes from the comparison function.</source>
          <target state="translated">如果抛出一个异常,这个函数没有任何效果(强异常保证),除非异常来自比较函数。</target>
        </trans-unit>
        <trans-unit id="c56964bda95bd497a307eee33dbbbedb399c8d42" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee).</source>
          <target state="translated">如果抛出一个异常,这个函数没有任何效果(强异常保证)。</target>
        </trans-unit>
        <trans-unit id="b1f960da1aad3dc9c4054b8661e9f9da8db12dca" translate="yes" xml:space="preserve">
          <source>If an exception is thrown, this function has no effect (strong exception guarantee). If &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">如果引发异常，则此功能无效（强烈的异常保证）。如果 &lt;code&gt;T&lt;/code&gt; 的move构造函数不是 &lt;code&gt;noexcept&lt;/code&gt; ，并且不是&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;到 &lt;code&gt;*this&lt;/code&gt; ，则vector将使用抛出的move构造函数。如果抛出，则放弃担保，并且影响未指定。</target>
        </trans-unit>
        <trans-unit id="3e81fff806c92690d8247fab353f430b076a5ddb" translate="yes" xml:space="preserve">
          <source>If an exception was stored in the shared state referenced by the future (e.g. via a call to &lt;a href=&quot;../promise/set_exception&quot;&gt;&lt;code&gt;std::promise::set_exception()&lt;/code&gt;&lt;/a&gt;) then that exception will be thrown.</source>
          <target state="translated">如果异常存储在将来引用的共享状态中（例如，通过调用&lt;a href=&quot;../promise/set_exception&quot;&gt; &lt;code&gt;std::promise::set_exception()&lt;/code&gt; &lt;/a&gt;），则将抛出该异常。</target>
        </trans-unit>
        <trans-unit id="d0137b7a583c99b14138ba2d912173e858c09f48" translate="yes" xml:space="preserve">
          <source>If an implicitly-declared destructor is not deleted, it is implicitly defined (that is, a function body is generated and compiled) by the compiler when it is &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. This implicitly-defined destructor has an empty body.</source>
          <target state="translated">如果未删除隐式声明的析构函数，则编译器在&lt;a href=&quot;definition#ODR-use&quot;&gt;使用odr&lt;/a&gt;时会隐式定义（即生成并编译函数体）。此隐式定义的析构函数具有空主体。</target>
        </trans-unit>
        <trans-unit id="5a6f2dbbaa4e8bf97f99dfa70fb418fa8a9f940e" translate="yes" xml:space="preserve">
          <source>If an inline function is declared in different translation units, the accumulated sets of &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; must be the same at the end of each translation unit.</source>
          <target state="translated">如果以不同的翻译单元声明内联函数，则每个翻译单元末尾的累积&lt;a href=&quot;default_arguments&quot;&gt;默认参数&lt;/a&gt;集必须相同。</target>
        </trans-unit>
        <trans-unit id="b7990c568402acf3a5d1219a03555ac57df4d740" translate="yes" xml:space="preserve">
          <source>If an inline function or variable(since C++17) with external linkage is defined differently in different translation units, the behavior is undefined.</source>
          <target state="translated">如果一个具有外部链接的内联函数或变量(自C++17起)在不同的翻译单元中定义不同,则该行为未被定义。</target>
        </trans-unit>
        <trans-unit id="eb3fc767b94cfd5625015f9349fa6a8307905fac" translate="yes" xml:space="preserve">
          <source>If an insertion is performed, the mapped value is &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; (default-constructed for class types, zero-initialized otherwise) and a reference to it is returned.</source>
          <target state="translated">如果执行插入，则将对映射的值进行&lt;a href=&quot;../../language/value_initialization&quot;&gt;值初始化&lt;/a&gt;（对于类类型，默认为默认构造，否则为零初始化），并返回对其的引用。</target>
        </trans-unit>
        <trans-unit id="18180e9058d1e19c0f11fd992aa464bc733a35a8" translate="yes" xml:space="preserve">
          <source>If an insertion occurs and results in a rehashing of the container, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="translated">如果发生插入并导致容器的重新哈希，则所有迭代器均无效。否则，迭代器不会受到影响。引用没有无效。仅当新的元素数量大于 &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; 时,才会进行重新哈希处理。</target>
        </trans-unit>
        <trans-unit id="0a574aa99696eb2cfb80cca007e805d644a25910" translate="yes" xml:space="preserve">
          <source>If an instantiation of a template above depends, directly or indirectly, on an incomplete type, and that instantiation could yield a different result if that type were hypothetically completed, the behavior is undefined.</source>
          <target state="translated">如果上述模板的实例化直接或间接地依赖于一个不完整的类型,并且如果该类型被假设地完成,该实例化可能产生不同的结果,那么该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="a64bffb3522d60e8b666b70574ce5d49611f5000" translate="yes" xml:space="preserve">
          <source>If an internal operation throws an exception, it is caught and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; is set. If &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; is set for &lt;code&gt;badbit&lt;/code&gt;, the exception is rethrown.</source>
          <target state="translated">如果内部操作引发异常，则会捕获该异常并设置 &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;badbit&lt;/a&gt;&lt;/code&gt; 。如果为 &lt;code&gt;badbit&lt;/code&gt; 设置了 &lt;code&gt;&lt;a href=&quot;../basic_ios/exceptions&quot;&gt;exceptions()&lt;/a&gt;&lt;/code&gt; ,则重新抛出该异常。</target>
        </trans-unit>
        <trans-unit id="5a642538c4470f54f4f527d91f99d4f6fe81ff66" translate="yes" xml:space="preserve">
          <source>If an operation on traits emits an exception, the behavior is undefined.</source>
          <target state="translated">如果对特征的操作发出异常,那么行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="6e13b70715d8672a431c8a76c567c768c6ee6a7b" translate="yes" xml:space="preserve">
          <source>If an overriding function specifies &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;, it must specify the same list contract conditions as the functions it overrides; no diagnostic is required if corresponding conditions will always evaluate to the same value. Otherwise, it is considered to have the list of contract conditions from one of its overriden functions; the names in the contract conditions are bound and the semantic constraints are checked at the point where the contract conditions appear.</source>
          <target state="translated">如果覆盖功能指定了&lt;a href=&quot;attributes/contract&quot;&gt;合同条件&lt;/a&gt;，则它必须指定与其覆盖的功能相同的列表合同条件。如果相应的条件总能得出相同的值，则无需诊断。否则，它被视为具有其替代功能之一的合同条件清单；约束合同条件中的名称，并在合同条件出现时检查语义约束。</target>
        </trans-unit>
        <trans-unit id="ea6490ada6b718e0dd1982f5bd44675af661c0e9" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; references the control block created by &lt;code&gt;std::make_shared&lt;/code&gt; after the lifetime of all shared owners ended, the memory occupied by &lt;code&gt;T&lt;/code&gt; persists until all weak owners get destroyed as well, which may be undesirable if &lt;code&gt;sizeof(T)&lt;/code&gt; is large.</source>
          <target state="translated">如果所有共享所有者的生存期结束后，如果任何 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 引用了 &lt;code&gt;std::make_shared&lt;/code&gt; 创建的控制块，则 &lt;code&gt;T&lt;/code&gt; 占用的内存将持续存在，直到所有弱所有者也被销毁为止，如果 &lt;code&gt;sizeof(T)&lt;/code&gt; 为大。</target>
        </trans-unit>
        <trans-unit id="be9fa8a822bab5c2b3736388d805151fa47e91f3" translate="yes" xml:space="preserve">
          <source>If any Ti is not a comparison category type (&lt;a href=&quot;weak_equality&quot;&gt;&lt;code&gt;std::weak_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;partial_ordering&quot;&gt;&lt;code&gt;std::partial_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt;), U is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">如果任何Ti不是比较类别类型（&lt;a href=&quot;weak_equality&quot;&gt; &lt;code&gt;std::weak_equality&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;strong_equality&quot;&gt; &lt;code&gt;std::strong_equality&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;partial_ordering&quot;&gt; &lt;code&gt;std::partial_ordering&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;weak_ordering&quot;&gt; &lt;code&gt;std::weak_ordering&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;strong_ordering&quot;&gt; &lt;code&gt;std::strong_ordering&lt;/code&gt; &lt;/a&gt;），则U为 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa759a7594dd95d5f9753141e5b119ba2c2846a0" translate="yes" xml:space="preserve">
          <source>If any argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="translated">如果任何参数是NaN,则返回NaN,并且不报告域名错误。</target>
        </trans-unit>
        <trans-unit id="7e09a18bf23aa9504f4b8622f9df9a40a3b55dc8" translate="yes" xml:space="preserve">
          <source>If any candidate function is a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; (static or non-static), but not a constructor, it is treated as if it has an extra parameter (</source>
          <target state="translated">如果任何候选函数是&lt;a href=&quot;member_functions&quot;&gt;成员函数&lt;/a&gt;（静态或非静态），但不是构造函数，则将其视为具有附加参数（</target>
        </trans-unit>
        <trans-unit id="a6bcd0ea08bf821e3fbe550757f07bf7cf22d254" translate="yes" xml:space="preserve">
          <source>If any candidate is a function template, its specializations are generated using &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;, and such specializations are treated just like non-template functions except where specified otherwise in the tie-breaker rules. If a name refers to one or more function templates and also to a set of overloaded non-template functions, those functions and the specializations generated from the templates are all candidates.</source>
          <target state="translated">如果有任何候选者是函数模板，则使用&lt;a href=&quot;template_argument_deduction&quot;&gt;模板参数推导&lt;/a&gt;来生成其专业化，并且与非模板函数一样，将这些专业化视为非模板函数，除非在平局规则中另有规定。如果名称指的是一个或多个功能模板，也指一组重载的非模板功能，则这些功能以及从模板生成的专业化特性都是候选对象。</target>
        </trans-unit>
        <trans-unit id="126493e0cbb7819d68c915080c830634b2cac172" translate="yes" xml:space="preserve">
          <source>If any function that is called directly by the stack unwinding mechanism, after initialization of the exception object and before the start of the exception handler, exits with an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. Such functions include &lt;a href=&quot;destructor&quot;&gt;destructors&lt;/a&gt; of objects with automatic storage duration whose scopes are exited, and the copy constructor of the exception object that is called (&lt;a href=&quot;copy_elision&quot;&gt;if not elided&lt;/a&gt;) to initialize catch-by-value arguments.</source>
          <target state="translated">如果任何由堆栈展开机制直接调用的函数，在初始化异常对象之后，在异常处理程序启动之前退出，并带有异常，则将调用 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。这样的函数包括具有自动存储持续时间的对象的&lt;a href=&quot;destructor&quot;&gt;析构函数&lt;/a&gt;，其作用域已退出，并且异常对象的副本构造函数被调用（&lt;a href=&quot;copy_elision&quot;&gt;如果没有消除&lt;/a&gt;），以初始化按值捕获参数。</target>
        </trans-unit>
        <trans-unit id="15dfee2b548c068d0cb9438923992bb46bcca31a" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces directly contains an inline namespace, that inline namespace is added to the set.</source>
          <target state="translated">如果关联的类和名字空间集合中的任何名字空间直接包含一个内联名字空间,则该内联名字空间被添加到集合中。</target>
        </trans-unit>
        <trans-unit id="96b81c5fbadca60870db38fc2f9a183bb9b6fdca" translate="yes" xml:space="preserve">
          <source>If any namespace in the associated set of classes and namespaces is an &lt;a href=&quot;namespace&quot;&gt;inline namespace&lt;/a&gt;, its enclosing namespace is also added to the set.</source>
          <target state="translated">如果关联的类和名称空间集中的任何名称空间是&lt;a href=&quot;namespace&quot;&gt;内联名称空间&lt;/a&gt;，则其封闭的名称空间也将添加到该集中。</target>
        </trans-unit>
        <trans-unit id="77bf32371c11f8b0a2f664f75979c288885d06cb" translate="yes" xml:space="preserve">
          <source>If any of the function calls made, including the call to &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, fails, returns a null pointer. If any of the function calls made throws an exception, the exception is caught and rethrown after calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;. If the file is already closed, returns a null pointer right away.</source>
          <target state="translated">如果进行的任何函数调用（包括对 &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; 的调用）均失败，则返回空指针。如果进行的任何函数调用均引发异常，则在调用 &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; 之后捕获并重新抛出该异常。如果文件已经关闭，则立即返回空指针。</target>
        </trans-unit>
        <trans-unit id="96b62f2f876cd9ccd1e029ff20920e414e1372bd" translate="yes" xml:space="preserve">
          <source>If any of the function parameters uses a</source>
          <target state="translated">如果函数参数中的任何一个使用</target>
        </trans-unit>
        <trans-unit id="2b9407b136cda4e52a8bcbbff35df15df1b4ed8a" translate="yes" xml:space="preserve">
          <source>If any of the operands is a pointer, the following rules apply:</source>
          <target state="translated">如果操作数中的任何一个是指针,则适用以下规则。</target>
        </trans-unit>
        <trans-unit id="6bea11d594aa54f1709b6bc92b826adf56fa3383" translate="yes" xml:space="preserve">
          <source>If any of the private members needs to access a public or protected member, a reference or pointer to the interface may be passed to the private function as a parameter. Alternatively, the back-reference may be maintained as part of the implementation class.</source>
          <target state="translated">如果任何一个私有成员需要访问公共成员或保护成员,可以将接口的引用或指针作为参数传递给私有函数。另外,反向引用也可以作为实现类的一部分来维护。</target>
        </trans-unit>
        <trans-unit id="f4cf008505537dd2a8c50313e658cc2022e63eda" translate="yes" xml:space="preserve">
          <source>If any of these situations occur in a translation unit, the definition of the type must appear in the same translation unit. Otherwise, it is not required.</source>
          <target state="translated">如果这些情况中的任何一种发生在一个翻译单元中,类型的定义必须出现在同一个翻译单元中。否则,就不需要。</target>
        </trans-unit>
        <trans-unit id="205c5da68a3eed873a307fa520147b2a4368cf96" translate="yes" xml:space="preserve">
          <source>If any template definition has a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt; in which the qualifier refers to the</source>
          <target state="translated">如果任何模板定义具有&lt;a href=&quot;qualified_lookup&quot;&gt;限定名称&lt;/a&gt;，则限定词在其中引用</target>
        </trans-unit>
        <trans-unit id="a99969c90cd633e5812cf58136c1c690e70c4d05" translate="yes" xml:space="preserve">
          <source>If any template definition has a member acess expression where the object expression is the</source>
          <target state="translated">如果任何模板定义有一个成员访问表达式,其中对象表达式为</target>
        </trans-unit>
        <trans-unit id="32c3e54b2ab54a4690246c40558fdcba870991e2" translate="yes" xml:space="preserve">
          <source>If any threads are waiting on &lt;code&gt;*this&lt;/code&gt;, calling &lt;code&gt;notify_one&lt;/code&gt; unblocks one of the waiting threads.</source>
          <target state="translated">如果任何线程正在 &lt;code&gt;*this&lt;/code&gt; 上等待，则调用 &lt;code&gt;notify_one&lt;/code&gt; 会解除阻止其中一个正在等待的线程。</target>
        </trans-unit>
        <trans-unit id="7d2a968ab7f2dd81e4eead9cc317c64526456d40" translate="yes" xml:space="preserve">
          <source>If applying &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; to at least one of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; produces a different type, the member &lt;code&gt;type&lt;/code&gt; names the same type as &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt;, if it exists; if not, there is no member &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">如果将 &lt;code&gt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; 应用于 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 中的至少一个会产生不同的类型，则成员 &lt;code&gt;type&lt;/code&gt; 名称与 &lt;code&gt;std::common_type&amp;lt;&lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T1&amp;gt;::type, &lt;a href=&quot;decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;T2&amp;gt;::type&amp;gt;::type&lt;/code&gt; （如果存在）；如果不是，则没有成员 &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08759afad939001ce25641ffda80dd6d474e5c10" translate="yes" xml:space="preserve">
          <source>If arg is NaN, NaN is returned</source>
          <target state="translated">如果arg是NaN,则返回NaN。</target>
        </trans-unit>
        <trans-unit id="a3fffd54a9398802b03cfe88989a4c46d2ce5774" translate="yes" xml:space="preserve">
          <source>If at least one of the arguments to an operator in an expression has a class type or an enumeration type, both &lt;a href=&quot;expressions#Operators&quot;&gt;builtin operators&lt;/a&gt; and &lt;a href=&quot;operators&quot;&gt;user-defined operator overloads&lt;/a&gt; participate in overload resolution, with the set of candidate functions selected as follows:</source>
          <target state="translated">如果表达式中运算符的至少一个参数具有类类型或枚举类型，则&lt;a href=&quot;expressions#Operators&quot;&gt;内置运算符&lt;/a&gt;和&lt;a href=&quot;operators&quot;&gt;用户定义的运算符重载都将&lt;/a&gt;参与重载解析，并选择候选函数集，如下所示：</target>
        </trans-unit>
        <trans-unit id="cfa2de104dcda4911fda849d8572dfd8b37d2933" translate="yes" xml:space="preserve">
          <source>If at least one of the deallocation functions is a destroying delete, all non-destroying deletes are ignored.</source>
          <target state="translated">如果至少有一个deallocation函数是破坏性删除,那么所有非破坏性删除将被忽略。</target>
        </trans-unit>
        <trans-unit id="edc900123598455f7b2624a5d0192ef2c77c276f" translate="yes" xml:space="preserve">
          <source>If at least one of the operands is a pointer or pointer-to-member, array-to-pointer conversions, derived-to-base pointer conversions, function pointer conversions, and qualification conversions are applied as necessary to convert both operands to the same pointer type.</source>
          <target state="translated">如果操作数中至少有一个是指针或指针到成员,则根据需要应用数组到指针的转换、派生到基指针的转换、函数指针的转换和限定转换,以将两个操作数转换为相同的指针类型。</target>
        </trans-unit>
        <trans-unit id="8702bce6fb50aa6cb7bc28c668acc4a3e2449f0f" translate="yes" xml:space="preserve">
          <source>If bool_constexpr returns &lt;code&gt;true&lt;/code&gt;, this declaration has no effect. Otherwise a compile-time error is issued, and the text of message, if any, is included in the diagnostic message.</source>
          <target state="translated">如果bool_constexpr返回 &lt;code&gt;true&lt;/code&gt; ，则此声明无效。否则，将发出编译时错误，并且诊断消息中将包含消息文本（如果有）。</target>
        </trans-unit>
        <trans-unit id="72593242b61b146efa6a985e10a179d983cf718b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contain values, the contained values are exchanged by calling &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; lvalues must satisfy &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 都包含值，则通过 &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(**this, *other)&lt;/code&gt; 进行调用来交换所包含的值；swap（** this，* other）。 &lt;code&gt;T&lt;/code&gt; 值必须满足&lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9149200a2a016ffa0cff6b7a2b77a8a41a09bef3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not contain a value, the function has no effect.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 不都包含值，则该功能无效。</target>
        </trans-unit>
        <trans-unit id="51fcf538b4bb73b4d1fbe54dfcf29fa14c9c5798" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Base&lt;/code&gt; and &lt;code&gt;Derived&lt;/code&gt; are non-union class types, and they are not the same type (ignoring cv-qualification), &lt;code&gt;Derived&lt;/code&gt; shall be a &lt;a href=&quot;../language/incomplete_type&quot;&gt;complete type&lt;/a&gt;; otherwise the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;Base&lt;/code&gt; 和 &lt;code&gt;Derived&lt;/code&gt; 都是非联合类类型，并且它们不是同一类型（忽略cv-qualification），则 &lt;code&gt;Derived&lt;/code&gt; 应该是&lt;a href=&quot;../language/incomplete_type&quot;&gt;完整类型&lt;/a&gt;；否则，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="031007df7a4bbbcc69dda82c9142cab39525a5c6" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are reference types before, determine which is more cv-qualified (in all other cases, cv-qualificiations are ignored for partial ordering purposes)</source>
          <target state="translated">如果 &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 之前都是引用类型，请确定哪个更具有cv限定（在所有其他情况下，出于部分订购目的，将忽略cv限定）</target>
        </trans-unit>
        <trans-unit id="0fbe1e336c3df9cfce302d24095585fa919b438e" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are zero, returns zero. Otherwise, returns the greatest common divisor of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 均为零，则返回零。否则，返回 &lt;code&gt;|m|&lt;/code&gt; 最大公约数。和 &lt;code&gt;|n|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5805a8f51641bf5a39fc87b226394ea5441b146" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; represent valid dates (&lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt;), the result of the lexicographical comparison is consistent with the calendar order.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都表示有效日期（ &lt;code&gt;x.ok() &amp;amp;&amp;amp; y.ok() == true&lt;/code&gt; ），则字典比较的结果与日历顺序一致。</target>
        </trans-unit>
        <trans-unit id="942dbb8422270823dbf96e8d6ddba2211d8b9ddc" translate="yes" xml:space="preserve">
          <source>If both conversion functions and converting constructors can be used to perform some user-defined conversion, the conversion functions and constructors are both considered by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; in &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; and &lt;a href=&quot;reference_initialization&quot;&gt;reference-initialization&lt;/a&gt; contexts, but only the constructors are considered in &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; contexts.</source>
          <target state="translated">如果两个转换函数和转换构造函数可以被用于执行一些用户定义的转换，转换功能和构造都通过考虑&lt;a href=&quot;overload_resolution&quot;&gt;重载方案&lt;/a&gt;中&lt;a href=&quot;copy_initialization&quot;&gt;复制初始化&lt;/a&gt;和&lt;a href=&quot;reference_initialization&quot;&gt;参考初始化&lt;/a&gt;上下文，但只有构造函数中考虑&lt;a href=&quot;direct_initialization&quot;&gt;直接初始化&lt;/a&gt;上下文。</target>
        </trans-unit>
        <trans-unit id="a385931d531ce68f4e5f9578700e55c228573984" translate="yes" xml:space="preserve">
          <source>If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;rvalue&lt;/i&gt;&lt;/a&gt; (either a &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;prvalue&lt;/i&gt;&lt;/a&gt; such as a nameless temporary or an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;xvalue&lt;/i&gt;&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt;), and selects the copy assignment if the argument is an &lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;lvalue&lt;/i&gt;&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.</source>
          <target state="translated">如果同时提供了复制和移动赋值运算符，则当参数为&lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;右值&lt;/i&gt;&lt;/a&gt;（&lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;prvalue（&lt;/i&gt;&lt;/a&gt;例如，无名的临时值或&lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;xvalue，&lt;/i&gt;&lt;/a&gt;例如 &lt;code&gt;std::move&lt;/code&gt; 的结果））时，重载解析将选择移动赋值，并选择复制赋值如果参数是&lt;a href=&quot;value_category&quot;&gt;&lt;i&gt;左值&lt;/i&gt;&lt;/a&gt;（命名对象或返回左值引用的函数/运算符）。如果仅提供副本分配，则所有参数类别都会选择它（只要它按值接受参数或作为const的引用，因为rvalues可以绑定到const引用），这会使副本分配成为移动时移动分配的后备对象不可用。</target>
        </trans-unit>
        <trans-unit id="0bcac6e95caaa2cc81cc604fdcf629399d168aad" translate="yes" xml:space="preserve">
          <source>If both copy and move constructors are provided and no other constructors are viable, overload resolution selects the move constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;rvalue&lt;/a&gt; of the same type (an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; such as the result of &lt;code&gt;std::move&lt;/code&gt; or a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; such as a nameless temporary(until C++17)), and selects the copy constructor if the argument is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; (named object or a function/operator returning lvalue reference). If only the copy constructor is provided, all argument categories select it (as long as it takes a reference to const, since rvalues can bind to const references), which makes copying the fallback for moving, when moving is unavailable.</source>
          <target state="translated">如果同时提供了copy和move构造函数，并且没有其他可行的构造函数，则当参数是相同类型的&lt;a href=&quot;value_category&quot;&gt;右值&lt;/a&gt;（如 &lt;code&gt;std::move&lt;/code&gt; 的结果的&lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt;或无名的&lt;a href=&quot;value_category&quot;&gt;prvalue）时&lt;/a&gt;，重载分辨率将选择move构造器。临时（直到C ++ 17），如果参数是&lt;a href=&quot;value_category&quot;&gt;左值&lt;/a&gt;（命名对象或返回左值引用的函数/运算符），则选择复制构造函数。如果仅提供了复制构造函数，则所有参数类别都会选择它（只要它引用了const，因为rvalues可以绑定到const引用），这使得在移动不可用时复制回退以进行移动。</target>
        </trans-unit>
        <trans-unit id="60aa98cd9f6dc6c43b3235a9ef70bcb42b49d023" translate="yes" xml:space="preserve">
          <source>If both expression are well-formed, the conversion is ambiguous, and the program is ill-formed.</source>
          <target state="translated">如果两个表达式都很好,那么转换就会有歧义,程序就会有歧义。</target>
        </trans-unit>
        <trans-unit id="6e8d82bcd24247033be13b857c411fcd62b8ed61" translate="yes" xml:space="preserve">
          <source>If both of the operands are arrays, three-way comparison is ill-formed except when comparing class members of array type.</source>
          <target state="translated">如果操作数都是数组,除了比较数组类型的类成员时,三向比较是不规范的。</target>
        </trans-unit>
        <trans-unit id="c64fda57212a716e4316cdd7fb2f466fbf4fcafb" translate="yes" xml:space="preserve">
          <source>If both operands are signed or both are unsigned, the operand with lesser</source>
          <target state="translated">如果两个操作数都是有符号的或都是无符号的,则操作数较少的操作数。</target>
        </trans-unit>
        <trans-unit id="63fa8968e2f3efc134b4cba9025b815ed6390596" translate="yes" xml:space="preserve">
          <source>If both operands have arithmetic types, or if one operand has unscoped enumeration type and the other has integral type, the usual arithmetic conversions are applied to the operands, and then.</source>
          <target state="translated">如果两个操作数都具有算术类型,或者一个操作数具有无范围的枚举类型,另一个操作数具有积分类型,则对操作数进行通常的算术转换,然后。</target>
        </trans-unit>
        <trans-unit id="3cb97740b2dc89bf4961cce43d6e24c2e65d1e8e" translate="yes" xml:space="preserve">
          <source>If both operands have the same enumeration type E, the operator yields the result of converting the operands to the underlying type of E and applying &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; to the converted operands.</source>
          <target state="translated">如果两个操作数具有相同的枚举类型E，则运算符将产生以下结果：将操作数转换为E的基础类型，并将 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 应用于转换后的操作数。</target>
        </trans-unit>
        <trans-unit id="70c8bba595d6b98224b1253c961bdde354216878" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; flags are set in &lt;code&gt;policy&lt;/code&gt;, it is up to the implementation whether to perform asynchronous execution or lazy evaluation.</source>
          <target state="translated">如果在 &lt;code&gt;policy&lt;/code&gt; 中同时设置了 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; 标志，则执行异步执行还是懒惰求值取决于实现。</target>
        </trans-unit>
        <trans-unit id="65568841562f35d225fc26d418379905f6cfe94d" translate="yes" xml:space="preserve">
          <source>If both the converted value and the precision are &lt;code&gt;​0​&lt;/code&gt; the conversion results in no characters.</source>
          <target state="translated">如果两个转换值和精度是 &lt;code&gt;​0​&lt;/code&gt; 在没有字符转换结果。</target>
        </trans-unit>
        <trans-unit id="575a8782581ff485f4e8203e4d066fcc1e4f258b" translate="yes" xml:space="preserve">
          <source>If both the remainder and the quotient can be represented as objects of the corresponding type (int, long, long long, std::imaxdiv_t, respectively), returns both as an object of type &lt;code&gt;std::div_t&lt;/code&gt;, &lt;code&gt;std::ldiv_t&lt;/code&gt;, &lt;code&gt;std::lldiv_t&lt;/code&gt;, &lt;code&gt;std::imaxdiv_t&lt;/code&gt; defined as follows:</source>
          <target state="translated">如果余数和商均可以表示为相应类型的对象（分别为int，long，long long，std :: imaxdiv_t），则将它们都返回为 &lt;code&gt;std::div_t&lt;/code&gt; ， &lt;code&gt;std::ldiv_t&lt;/code&gt; 和 &lt;code&gt;std::lldiv_t&lt;/code&gt; 类型的对象:: lldiv_t， &lt;code&gt;std::imaxdiv_t&lt;/code&gt; 定义如下：</target>
        </trans-unit>
        <trans-unit id="fa4b3adcc137d0171dfddcda07618256693fd4ac" translate="yes" xml:space="preserve">
          <source>If c16 is the null wide character &lt;code&gt;u'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">如果c16是空宽字符 &lt;code&gt;u'\0'&lt;/code&gt; ，则存储一个空字节，其后是恢复初始移位状态所需的任何移位序列，并且转换状态参数 &lt;code&gt;*ps&lt;/code&gt; 被更新以表示初始移位状态。</target>
        </trans-unit>
        <trans-unit id="0f25466cdf38f545ddf52bc150f2465947dd2dd7" translate="yes" xml:space="preserve">
          <source>If c32 is the null wide character &lt;code&gt;U'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">如果c32是零位宽字符 &lt;code&gt;U'\0'&lt;/code&gt; ，则存储一个空字节，其后是恢复初始移位状态所需的任何移位序列，并且转换状态参数 &lt;code&gt;*ps&lt;/code&gt; 被更新以表示初始移位状态。</target>
        </trans-unit>
        <trans-unit id="2180c8a148a56a1d4c18f8160ac19934198a22be" translate="yes" xml:space="preserve">
          <source>If called during exception handling (typically, in a &lt;code&gt;catch&lt;/code&gt; clause), captures the current exception object and creates an &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; that holds either a copy or a reference to that exception object (depending on the implementation). The referenced object remains valid at least as long as there is an &lt;code&gt;exception_ptr&lt;/code&gt; object that refers to it.</source>
          <target state="translated">如果在异常处理期间（通常在 &lt;code&gt;catch&lt;/code&gt; 子句中）调用，则捕获当前异常对象并创建一个 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; ，该对象保存对该异常对象的副本或引用（取决于实现）。所引用的对象至少在存在一个引用它的 &lt;code&gt;exception_ptr&lt;/code&gt; 对象时才保持有效。</target>
        </trans-unit>
        <trans-unit id="f5efa0791c0ccd4598c1223b0ede652827016b2d" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator delete&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void&lt;/code&gt;, the first argument &lt;code&gt;void*&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates. The specialization of the template operator delete is chosen with &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;.</source>
          <target state="translated">如果类级 &lt;code&gt;operator delete&lt;/code&gt; 是模板函数，则它的返回类型必须为 &lt;code&gt;void&lt;/code&gt; ，第一个参数为 &lt;code&gt;void*&lt;/code&gt; ，并且必须具有两个或多个参数。换句话说，只有放置表单可以是模板。通过&lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;模板参数推导&lt;/a&gt;选择模板运算符删除的专业化。</target>
        </trans-unit>
        <trans-unit id="07af41f04d885dcdd7da101bd31c36d13b61ce99" translate="yes" xml:space="preserve">
          <source>If class-level &lt;code&gt;operator new&lt;/code&gt; is a template function, it must have the return type of &lt;code&gt;void*&lt;/code&gt;, the first argument &lt;code&gt;std::size_t&lt;/code&gt;, and it must have two or more parameters. In other words, only placement forms can be templates.</source>
          <target state="translated">如果类级 &lt;code&gt;operator new&lt;/code&gt; 是模板函数，则它的返回类型必须为 &lt;code&gt;void*&lt;/code&gt; ，第一个参数为 &lt;code&gt;std::size_t&lt;/code&gt; ，并且必须具有两个或多个参数。换句话说，只有放置表单可以是模板。</target>
        </trans-unit>
        <trans-unit id="ceee4451276b8b4bcab8ca22c22b303c8fd7055d" translate="yes" xml:space="preserve">
          <source>If concurrent calls to call_once pass different functions &lt;code&gt;f&lt;/code&gt;, it is unspecified which &lt;code&gt;f&lt;/code&gt; will be called. The selected function runs in the same thread as the &lt;code&gt;call_once&lt;/code&gt; invocation it was passed to.</source>
          <target state="translated">如果对call_once的并发调用传递了不同的函数 &lt;code&gt;f&lt;/code&gt; ，则未指定将调用哪个 &lt;code&gt;f&lt;/code&gt; 。所选函数与传递给其的 &lt;code&gt;call_once&lt;/code&gt; 调用在同一线程中运行。</target>
        </trans-unit>
        <trans-unit id="e0b50d3647e11790677fe9a4c279326685cf8395" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that doesn't match any of the &lt;code&gt;case:&lt;/code&gt; labels, and the &lt;code&gt;default:&lt;/code&gt; label is present, control is transferred to the statement labeled with the &lt;code&gt;default:&lt;/code&gt; label.</source>
          <target state="translated">如果condition计算得出的值与任何 &lt;code&gt;case:&lt;/code&gt; 标签都不匹配，并且存在 &lt;code&gt;default:&lt;/code&gt; 标签，则控制权将转移到标有 &lt;code&gt;default:&lt;/code&gt; 标签的语句。</target>
        </trans-unit>
        <trans-unit id="c5d36a23ea15e574cf486f3e1d5ad8940a574a30" translate="yes" xml:space="preserve">
          <source>If condition evaluates to the value that is equal to the value of one of constant_expressions, then control is transferred to the statement that is labeled with that constant_expression.</source>
          <target state="translated">如果condition的值等于constant_expressions之一的值,那么控制权就会转移到标有该constant_expression的语句上。</target>
        </trans-unit>
        <trans-unit id="5aa862d229a90e1dcafc139a33ba48261cc1ac13" translate="yes" xml:space="preserve">
          <source>If condition is a declaration such as &lt;code&gt;T t = x&lt;/code&gt;, the declared variable is only in scope in the body of the loop, and is destroyed and recreated on every iteration, in other words, such while loop is equivalent to.</source>
          <target state="translated">如果condition是诸如 &lt;code&gt;T t = x&lt;/code&gt; 的声明，则声明的变量仅在循环体内，并且在每次迭代时都将销毁并重新创建，换句话说，while循环等效。</target>
        </trans-unit>
        <trans-unit id="cc5437232ebb64eb1e0a00ed4f6909a6272177e2" translate="yes" xml:space="preserve">
          <source>If control reaches the end of a function with the return type &lt;code&gt;void&lt;/code&gt; (possibly cv-qualified), end of a constructor, end of a destructor, or the end of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for a function with the return type (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt; without encountering a return statement, &lt;code&gt;return;&lt;/code&gt; is executed.</source>
          <target state="translated">如果控制到达与返回类型的函数的结束 &lt;code&gt;void&lt;/code&gt; （可能CV-合格），构造的端部，析构函数的结束，或者一个的端部&lt;a href=&quot;function-try-block&quot;&gt;功能的try块&lt;/a&gt;用于与返回类型的功能（可能CV -qualified） &lt;code&gt;void&lt;/code&gt; 而不会遇到return语句， &lt;code&gt;return;&lt;/code&gt; 被执行。</target>
        </trans-unit>
        <trans-unit id="62b123ef59b7917fbc8133c9aaa1f1f874506d99" translate="yes" xml:space="preserve">
          <source>If control reaches the end of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt;, &lt;code&gt;return 0;&lt;/code&gt; is executed.</source>
          <target state="translated">如果控制到达&lt;a href=&quot;main_function&quot;&gt;主函数&lt;/a&gt;的结尾，则 &lt;code&gt;return 0;&lt;/code&gt; 否则，返回0。被执行。</target>
        </trans-unit>
        <trans-unit id="49147bdd2f3429795748cce29beffb564badb873" translate="yes" xml:space="preserve">
          <source>If cv appears after &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of declarator and applies to the pointer that's being declared.</source>
          <target state="translated">如果cv出现在指针声明中的 &lt;code&gt;*&lt;/code&gt; 之后，则它是声明符的一部分，并应用于要声明的指针。</target>
        </trans-unit>
        <trans-unit id="4d8f20c7d00a034ba772281f4476c576329d5b6f" translate="yes" xml:space="preserve">
          <source>If cv appears before &lt;code&gt;*&lt;/code&gt; in the pointer declaration, it is part of decl-specifier-seq and applies to the the pointed-to object.</source>
          <target state="translated">如果cv 在指针声明中的 &lt;code&gt;*&lt;/code&gt; 之前出现，则它是decl-specifier-seq的一部分，并应用于指向的对象。</target>
        </trans-unit>
        <trans-unit id="dbec49aac99d6e7dc2b90341eae53b09e233425a" translate="yes" xml:space="preserve">
          <source>If declarations &lt;code&gt;D1&lt;/code&gt; and &lt;code&gt;D2&lt;/code&gt; are constrained and D1's associated constraints subsume D2's associated constraints (or if D2 is unconstrained), then D1 is said to be</source>
          <target state="translated">如果声明 &lt;code&gt;D1&lt;/code&gt; 和 &lt;code&gt;D2&lt;/code&gt; 受约束，并且D1的关联约束包含D2的关联约束（或者如果D2是不受约束的），则称D1为</target>
        </trans-unit>
        <trans-unit id="2411be601f654a07bbdca0b7276e84a7d05756e0" translate="yes" xml:space="preserve">
          <source>If deduction fails , or if deduction succeeds, but the specialization it produces would be invalid (for example, an overloaded operator whose parameters are neither class nor enumeration types),(since C++14) the specialization is not included in the overload set, similar to &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;.</source>
          <target state="translated">如果推导失败，或者推导成功，但是推导成功，则它的专业化将是无效的（例如，参数既不是类也不是枚举类型的重载运算符）（自C ++ 14起），该专业化不包含在重载集中与&lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;类似。</target>
        </trans-unit>
        <trans-unit id="5007ba94c2b890c9a53ac3f2ede0070a7fe62fea" translate="yes" xml:space="preserve">
          <source>If deduction succeeds in both directions, and the original &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; were reference types, then additional tests are made:</source>
          <target state="translated">如果两个方向的推算都成功，并且原始的 &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 是参考类型，则进行其他测试：</target>
        </trans-unit>
        <trans-unit id="c96fa04a65c71e2fd19130c8575defd3c41edbfb" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;M&lt;/code&gt; or &lt;code&gt;N&lt;/code&gt; is not an integer type, or if either is (possibly cv-qualified) &lt;code&gt;bool&lt;/code&gt;, the program is ill-formed.</source>
          <target state="translated">如果 &lt;code&gt;M&lt;/code&gt; 或 &lt;code&gt;N&lt;/code&gt; 不是整数类型，或者任何一个（可能是cv限定） &lt;code&gt;bool&lt;/code&gt; ，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="c79ea3237a0ed39b951058e0ae87cf69e04e9f5e" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;dest&lt;/code&gt; or &lt;code&gt;src&lt;/code&gt; is a null pointer, the behavior is undefined, even if &lt;code&gt;count&lt;/code&gt; is zero.</source>
          <target state="translated">如果 &lt;code&gt;dest&lt;/code&gt; 或 &lt;code&gt;src&lt;/code&gt; 是空指针，则即使 &lt;code&gt;count&lt;/code&gt; 为零，行为也未定义。</target>
        </trans-unit>
        <trans-unit id="1250474b9c6ad69852373ae63ef180eb204a2f48" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; has an implementation-defined &lt;a href=&quot;file_type&quot;&gt;file type&lt;/a&gt;, the effects of this function are implementation-defined.</source>
          <target state="translated">如果 &lt;code&gt;from&lt;/code&gt; 或 &lt;code&gt;to&lt;/code&gt; 具有实现定义的&lt;a href=&quot;file_type&quot;&gt;文件类型&lt;/a&gt;，则此函数的作用是实现定义的。</target>
        </trans-unit>
        <trans-unit id="4165a5260d21b11f33113753f30c5f524bccf1ba" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;from&lt;/code&gt; or &lt;code&gt;to&lt;/code&gt; is not a regular file, a directory, or a symlink, as determined by &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt;, reports an error</source>
          <target state="translated">如果 &lt;code&gt;from&lt;/code&gt; 或 &lt;code&gt;to&lt;/code&gt; 不是由 &lt;code&gt;&lt;a href=&quot;is_other&quot;&gt;std::filesystem::is_other&lt;/a&gt;&lt;/code&gt; 确定的常规文件，目录或符号链接，则报告错误</target>
        </trans-unit>
        <trans-unit id="6f243ca5c29fe6335eb0defcad2154158bb206f7" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;m&lt;/code&gt; or &lt;code&gt;n&lt;/code&gt; is zero, returns zero. Otherwise, returns the least common multiple of &lt;code&gt;|m|&lt;/code&gt; and &lt;code&gt;|n|&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;m&lt;/code&gt; 或 &lt;code&gt;n&lt;/code&gt; 为零，则返回零。否则，返回 &lt;code&gt;|m|&lt;/code&gt; 最小公倍数。和 &lt;code&gt;|n|&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1dab1eb6195d1939bf5f575a24a97060849eb62a" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;p1&lt;/code&gt; or &lt;code&gt;p2&lt;/code&gt; does not exist, an error is reported.</source>
          <target state="translated">如果 &lt;code&gt;p1&lt;/code&gt; 或 &lt;code&gt;p2&lt;/code&gt; 不存在，则报告错误。</target>
        </trans-unit>
        <trans-unit id="192b44dddfe8a0edbf403637b9dc082e8fcbccab" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; is NaN or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为NaN或 &lt;code&gt;y&lt;/code&gt; 为NaN，则返回NaN</target>
        </trans-unit>
        <trans-unit id="5798cb4e0bd7a6d21c2a60a89c9c101a7f709c34" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is NaN, NaN is returned</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 为NaN，则返回NaN</target>
        </trans-unit>
        <trans-unit id="777b045843b0ca1ef95a9acf19549cb4d27be21b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;|m|&lt;/code&gt; or &lt;code&gt;|n|&lt;/code&gt; is not representable as a value of type &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;|m|&lt;/code&gt; 或 &lt;code&gt;|n|&lt;/code&gt; 不能表示为 &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type_t&lt;/a&gt;&amp;lt;M, N&amp;gt;&lt;/code&gt; 类型的值，因此行为未定义。</target>
        </trans-unit>
        <trans-unit id="b1b8d9bd67fa1ccf8414b0062f383f3be7b83851" translate="yes" xml:space="preserve">
          <source>If either argument is NaN, NaN is returned</source>
          <target state="translated">如果其中一个参数是NaN,则返回NaN。</target>
        </trans-unit>
        <trans-unit id="503d04bbbfdfac42a885dc014eabc01dd48a5379" translate="yes" xml:space="preserve">
          <source>If either function is declared despite being unspecified, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal. This makes it possible to instantiate &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果尽管未指定任何函数都声明了该函数，则除了函数的声明（尽管不一定是定义）被保证是合法的之外，还不确定其返回类型是什么。这样就可以实例化 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;void&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dea65a53043b826e1ccaac4bd2898d99fa59f1dd" translate="yes" xml:space="preserve">
          <source>If either operand has scoped enumeration type, no conversion is performed: the other operand and the return type must have the same type</source>
          <target state="translated">如果任何一个操作数具有作用域枚举类型,则不进行转换:另一个操作数和返回类型必须具有相同的类型。</target>
        </trans-unit>
        <trans-unit id="4facc3a3dde5ddbefb08336856d6b20eb05ed6dc" translate="yes" xml:space="preserve">
          <source>If either the remainder or the quotient cannot be represented, the behavior is undefined.</source>
          <target state="translated">如果不能表示余数或商,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="529682e54cfd3160519cd2474a27a6556b3a893e" translate="yes" xml:space="preserve">
          <source>If erasing at begin - only erased elements</source>
          <target state="translated">如果在开始时擦除--只擦除被擦除的元素。</target>
        </trans-unit>
        <trans-unit id="de5cb8f72cd15ee74ae08d973ff1870dcb3c7c8e" translate="yes" xml:space="preserve">
          <source>If erasing at end - only erased elements and the past-the-end iterator</source>
          <target state="translated">如果在结束时擦除--只有被擦除的元素和过去的迭代器。</target>
        </trans-unit>
        <trans-unit id="9de48b7003a6c58f9874d3ee61667a92104df825" translate="yes" xml:space="preserve">
          <source>If errors prevent even knowing whether &lt;code&gt;p&lt;/code&gt; exists, the non-throwing overload sets &lt;code&gt;ec&lt;/code&gt; and returns &lt;code&gt;file_status(file_type::none)&lt;/code&gt;, and the throwing overload throws &lt;code&gt;filesystem_error&lt;/code&gt;</source>
          <target state="translated">如果错误阻止甚至不知道 &lt;code&gt;p&lt;/code&gt; 是否存在，则非抛出重载将设置 &lt;code&gt;ec&lt;/code&gt; 并返回 &lt;code&gt;file_status(file_type::none)&lt;/code&gt; ，并且抛出重载将引发 &lt;code&gt;filesystem_error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d96531c98aaf0d81f4a8e0e1ddfb0d8bc73bc9f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="translated">如果援引为算法的一部分功能的执行引发异常，并 &lt;code&gt;ExecutionPolicy&lt;/code&gt; 是一个&lt;a href=&quot;../algorithm/execution_policy_tag_t&quot;&gt;标准的政策&lt;/a&gt;， &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 被调用。对于任何其他 &lt;code&gt;ExecutionPolicy&lt;/code&gt; ，行为是实现定义的。</target>
        </trans-unit>
        <trans-unit id="2f4657ab0e97f8d71eba8e43d00ec9ecedaa739f" translate="yes" xml:space="preserve">
          <source>If execution of a function invoked as part of the algorithm throws an exception and &lt;code&gt;ExecutionPolicy&lt;/code&gt; is one of the &lt;a href=&quot;execution_policy_tag_t&quot;&gt;standard policies&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For any other &lt;code&gt;ExecutionPolicy&lt;/code&gt;, the behavior is implementation-defined.</source>
          <target state="translated">如果援引为算法的一部分功能的执行引发异常，并 &lt;code&gt;ExecutionPolicy&lt;/code&gt; 是一个&lt;a href=&quot;execution_policy_tag_t&quot;&gt;标准的政策&lt;/a&gt;， &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 被调用。对于任何其他 &lt;code&gt;ExecutionPolicy&lt;/code&gt; ，行为是实现定义的。</target>
        </trans-unit>
        <trans-unit id="9a2f05c159a24f9f71a90bb51a81dc74cfece89a" translate="yes" xml:space="preserve">
          <source>If expr is omitted in the declaration of an array, the type declared is &quot;array of unknown bound of T&quot;, which is a kind of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, except when used in a declaration with an &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initializer&lt;/a&gt;:</source>
          <target state="translated">如果在数组的声明中省略了expr，则声明的类型为&amp;ldquo; T的未知边界数组&amp;rdquo;，这是一种&lt;a href=&quot;incomplete_type&quot;&gt;不完整的类型&lt;/a&gt;，除非在带有&lt;a href=&quot;aggregate_initialization&quot;&gt;聚合初始化程序&lt;/a&gt;的声明中使用：</target>
        </trans-unit>
        <trans-unit id="d71ce2b38f67adf9252fa0e30106230c2ec3b97c" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function is not called.</source>
          <target state="translated">如果表达式评估为空指针值,则不调用析构函数,也不调用deallocation函数。</target>
        </trans-unit>
        <trans-unit id="6030f7d71e85a510bb8fdfa1c9d0573272b5c6c2" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a null pointer value, no destructors are called, and the deallocation function may or may not be called (it's implementation-defined), but the default deallocation functions are guaranteed to do nothing when handed a null pointer.</source>
          <target state="translated">如果表达式评估为空指针值,不会调用任何析构函数,deallocation函数可能会被调用,也可能不会被调用(这是实现定义的),但默认的deallocation函数被保证在交给一个空指针时什么都不做。</target>
        </trans-unit>
        <trans-unit id="5c393875f487dbcd2dff5fb7351c909c9b7c6ee3" translate="yes" xml:space="preserve">
          <source>If expression evaluates to a pointer to a base class subobject of the object that was allocated with &lt;a href=&quot;new&quot;&gt;new&lt;/a&gt;, the destructor of the base class must be virtual, otherwise the behavior is undefined.</source>
          <target state="translated">如果expression的计算结果是指向分配有&lt;a href=&quot;new&quot;&gt;new&lt;/a&gt;的对象的基类子对象的指针，则该基类的析构函数必须是虚的，否则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="1c30833ec734b1a7a3060b4576f5f2e61609aa23" translate="yes" xml:space="preserve">
          <source>If expression has array type &lt;code&gt;A&lt;/code&gt; and no ref-operator is present, then &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; has type</source>
          <target state="translated">如果表达式的数组类型为 &lt;code&gt;A&lt;/code&gt; ,并且不存在ref-operator，则 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 的类型为</target>
        </trans-unit>
        <trans-unit id="e6b3ab3f640c9298f96902e88e604333b949d1d4" translate="yes" xml:space="preserve">
          <source>If expression is a function call which returns a prvalue of class type or is a &lt;a href=&quot;operator_other&quot;&gt;comma expression&lt;/a&gt; whose right operand is such a function call, a temporary object is not introduced for that prvalue.</source>
          <target state="translated">如果expression是返回类类型的prvalue的函数调用，或者是右运算数就是这种函数调用的&lt;a href=&quot;operator_other&quot;&gt;逗号表达式&lt;/a&gt;，则不会为该prvalue引入临时对象。</target>
        </trans-unit>
        <trans-unit id="fcbd7c68e8be5419186b82db2695d726340da722" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue other than a (possibly parenthesized) &lt;a href=&quot;consteval&quot;&gt;immediate invocation&lt;/a&gt;(since C++20), a temporary object is not &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from that prvalue.</source>
          <target state="translated">如果表达比（可能括号）以外的prvalue &lt;a href=&quot;consteval&quot;&gt;直接调用&lt;/a&gt;（因为C ++ 20），一个临时对象不&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;物化&lt;/a&gt;从prvalue。</target>
        </trans-unit>
        <trans-unit id="5eb42168b532c7b11548b11828f78705b38da223" translate="yes" xml:space="preserve">
          <source>If expression is a prvalue, the result object is initialized directly by that expression. This does not involve a copy or move constructor when the types match (see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="translated">如果expression是prvalue，则结果对象直接由该表达式初始化。当类型匹配时，这不涉及复制或移动构造函数（请参见&lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4e15b97975662cad27203429fdb2250f97231751" translate="yes" xml:space="preserve">
          <source>If expression is an lvalue expression that is the (possibly parenthesized) name of an automatic storage duration object declared in the body or as a parameter of the innermost enclosing function or lambda expression, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; to select the constructor to use for initialization of the returned value or, for &lt;code&gt;co_return&lt;/code&gt;, to select the overload of &lt;code&gt;promise.return_value()&lt;/code&gt;(since C++20) is performed</source>
          <target state="translated">如果expression是左值表达式，该左值表达式是在主体中声明的自动存储期限对象的名称（可能带有括号），或者是最里面的封闭函数或lambda表达式的参数，则&lt;a href=&quot;overload_resolution&quot;&gt;重载分辨率&lt;/a&gt;以选择构造函数以用于初始化返回值，或者对于 &lt;code&gt;co_return&lt;/code&gt; ，选择promise的重载 &lt;code&gt;promise.return_value()&lt;/code&gt; 执行return_value （）（从C ++ 20开始）</target>
        </trans-unit>
        <trans-unit id="adc41fc0a93030206f4cdfeba4b6fcb313c8da70" translate="yes" xml:space="preserve">
          <source>If expression is not a null pointer and the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt; is not a destroying delete(since C++20), the &lt;code&gt;delete&lt;/code&gt; expression invokes the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; (if any) for the object that's being destroyed, or for every element of the array being destroyed (proceeding from the last element to the first element of the array).</source>
          <target state="translated">如果expression不是null指针，并且&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;释放函数&lt;/a&gt;也不是销毁delete（自C ++ 20起），则 &lt;code&gt;delete&lt;/code&gt; 表达式将为要销毁的对象或销毁数组的每个元素调用&lt;a href=&quot;destructor&quot;&gt;析构函数&lt;/a&gt;（如果有）。 （从数组的最后一个元素到第一个元素）。</target>
        </trans-unit>
        <trans-unit id="d68091a3a051bfac77278071ebbbc0e0bd6aacd1" translate="yes" xml:space="preserve">
          <source>If extraction fails (e.g. if a letter was entered where a digit is expected), &lt;code&gt;value&lt;/code&gt; is left unmodified and &lt;code&gt;failbit&lt;/code&gt; is set.</source>
          <target state="translated">如果提取失败（例如，如果在预期的数字中输入了字母），则 &lt;code&gt;value&lt;/code&gt; 将保持 &lt;code&gt;failbit&lt;/code&gt; 并设置故障位。</target>
        </trans-unit>
        <trans-unit id="88e6442a7bfe1de939efde09d5178c75fe73775c" translate="yes" xml:space="preserve">
          <source>If extraction fails, zero is written to &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt; is set. If extraction results in the value too large or too small to fit in &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; is written and &lt;code&gt;failbit&lt;/code&gt; flag is set.</source>
          <target state="translated">如果提取失败，则将零写入 &lt;code&gt;value&lt;/code&gt; 并设置故障 &lt;code&gt;failbit&lt;/code&gt; 。如果提取导致该值太大或太小而无法适合该 &lt;code&gt;value&lt;/code&gt; ，则将 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; 写入并设置 &lt;code&gt;failbit&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="9f80eb0726a214c94ee0e311172def7a79d33bde" translate="yes" xml:space="preserve">
          <source>If feature testing is supported, the features described here are indicated by the macro constant &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; with a value equal or greater &lt;code&gt;201505&lt;/code&gt;.</source>
          <target state="translated">如果支持功能测试，则此处描述的功能由值等于或大于 &lt;code&gt;201505&lt;/code&gt; 的宏常量 &lt;code&gt;__cpp_transactional_memory&lt;/code&gt; 指示。</target>
        </trans-unit>
        <trans-unit id="7451ef31b492ad560a6bc540d182167c27d069c5" translate="yes" xml:space="preserve">
          <source>If for some &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;X​::​eq_int_type(e, X​::​to_int_type(c))&lt;/code&gt; is true, &lt;code&gt;c&lt;/code&gt;</source>
          <target state="translated">如果对于某些 &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;X​::​eq_int_type(e, X​::​to_int_type(c))&lt;/code&gt; 为true，则 &lt;code&gt;c&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3824d6a7dbddfd44d6a10b166cb4fa4fdc9aa537" translate="yes" xml:space="preserve">
          <source>If forward declaration appears in local scope, it</source>
          <target state="translated">如果转发声明出现在局部范围内,它</target>
        </trans-unit>
        <trans-unit id="64e89aa46e58a2c727a5922e705eb374f16e676e" translate="yes" xml:space="preserve">
          <source>If implemented, returns the number of characters left to read from the file.</source>
          <target state="translated">如果实现,返回从文件中读取的剩余字符数。</target>
        </trans-unit>
        <trans-unit id="1dbd63790122a2d4ba6e64de77bc6208558b4f4f" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the if statement is equivalent to.</source>
          <target state="translated">如果使用init-statement,if语句相当于。</target>
        </trans-unit>
        <trans-unit id="3828f6a7891b0f54ec954884dcea4fe13ee69fe4" translate="yes" xml:space="preserve">
          <source>If init-statement is used, the switch statement is equivalent to.</source>
          <target state="translated">如果使用init-statement,switch语句相当于。</target>
        </trans-unit>
        <trans-unit id="c47d0b28593af3bb521e18dc6a2d3803710c1f80" translate="yes" xml:space="preserve">
          <source>If initialization terminates by throwing an exception (e.g. from the constructor), if new-expression allocated any storage, it calls the appropriate &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt;: &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; for non-array &lt;code&gt;type&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; for array &lt;code&gt;type&lt;/code&gt;. The deallocation function is looked up in global scope if the new-expression used the &lt;code&gt;::new&lt;/code&gt; syntax, otherwise it is looked up in the scope of &lt;code&gt;T&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a class type. If the failed allocation function was usual (non-placement), lookup for the deallocation function follows the rules described in &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. For a failed placement new, all parameter types, except the first, of the matching deallocation function must be identical to the parameters of the placement new. The call to the deallocation function is made the value obtained earlier from the allocation function passed as the first argument, alignment passed as the optional alignment argument(since C++17), and &lt;code&gt;placement_params&lt;/code&gt;, if any, passed as the additional placement arguments. If no deallocation function is found, memory is not deallocated.</source>
          <target state="translated">如果通过（从构造例如）抛出异常初始化终止时，如果新分配的表达的任何存储，它调用适当的&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;释放函数&lt;/a&gt;： &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; 了非阵列 &lt;code&gt;type&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; 数组 &lt;code&gt;type&lt;/code&gt; 。解除分配功能被查找在全球范围内，如果新的表达式中使用的 &lt;code&gt;::new&lt;/code&gt; 语法，否则是在范围抬头 &lt;code&gt;T&lt;/code&gt; ，如果 &lt;code&gt;T&lt;/code&gt; 是一个类类型。如果失败的分配函数是正常的（非放置），则对释放函数的查找遵循&lt;a href=&quot;delete&quot;&gt;delete-expression中&lt;/a&gt;描述的规则。对于新放置的失败，匹配的解除分配函数的所有参数类型（除第一个之外）必须与新放置的参数相同。到解除分配函数的调用时（因为C ++ 17）从前面作为第一个参数传递的分配函数，对准作为任选对准参数传递而得到的值，和 &lt;code&gt;placement_params&lt;/code&gt; ，如果有的话，作为附加放置参数传递。如果找不到释放函数，则不会释放内存。</target>
        </trans-unit>
        <trans-unit id="25af59fbe30345e9f2749bc57dd4353c2aaf12fb" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">如果initializer是一个用大括号括起来的参数列表，则该数组将被&lt;a href=&quot;aggregate_initialization&quot;&gt;汇总初始化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03cdfead59246b594ac83a38977a55a017d25ad2" translate="yes" xml:space="preserve">
          <source>If initializer is a brace-enclosed list of arguments, the object is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;.</source>
          <target state="translated">如果initializer是一个用大括号括起来的参数列表，则该对象将被&lt;a href=&quot;list_initialization&quot;&gt;列表初始化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb798be20c8b8f83663a5d3251bd571437d043f9" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the array is &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">如果initializer是带括号的参数列表，则该数组为&lt;a href=&quot;aggregate_initialization&quot;&gt;gregation-initialized&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f352a230f880eaabfec8de9e04e32d41381d1c34" translate="yes" xml:space="preserve">
          <source>If initializer is a parenthesized list of arguments, the object is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt;.</source>
          <target state="translated">如果initializer是带括号的参数列表，则该对象为&lt;a href=&quot;direct_initialization&quot;&gt;Direct-initialized&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6b9b4663cfe2da6404a6f0c08f1da0645b33d77" translate="yes" xml:space="preserve">
          <source>If initializer is absent, each element is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">如果没有初始化程序，则每个元素都将&lt;a href=&quot;default_initialization&quot;&gt;默认初始化&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05b0a18ac26e055f0b1b9a9cd56c953cc13ad39f" translate="yes" xml:space="preserve">
          <source>If initializer is absent, the object is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;.</source>
          <target state="translated">如果没有初始化程序，则该对象为&lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a4a45120f7db08d564e532f628e9ea01317f74f2" translate="yes" xml:space="preserve">
          <source>If initializer is an empty pair of parentheses, each element is &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">如果initializer是一对空括号，则每个元素都将被&lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19ed0a48a00d9537e7ba64e93a84031252754715" translate="yes" xml:space="preserve">
          <source>If it finds abbreviated name, followed by the characters that are valid for the full name, it continues reading until it consumes all the characters for the full name or finds a character that isn't expected, in which case parsing fails even if the first few characters were a valid abbreviation.</source>
          <target state="translated">如果它发现了缩写的名称,后面的字符是全名的有效字符,它就会继续读取,直到消耗掉全名的所有字符,或者发现了一个没有预期的字符,在这种情况下,即使前几个字符是有效的缩写,解析也会失败。</target>
        </trans-unit>
        <trans-unit id="c6aab4ab699238bc505d419c37703aa0ef2626a9" translate="yes" xml:space="preserve">
          <source>If it is a non-const xvalue, the object to which it refers is in a valid but unspecified state;</source>
          <target state="translated">如果它是非const xvalue,那么它所指向的对象就处于有效但未指定的状态。</target>
        </trans-unit>
        <trans-unit id="a83e8b41c48694346f5c6e5d8a58bf3d4cd145d7" translate="yes" xml:space="preserve">
          <source>If l&amp;ge;128, the behavior is implementation-defined</source>
          <target state="translated">如果l&amp;ge;128，则行为是实现定义的</target>
        </trans-unit>
        <trans-unit id="095b63a0e4834384f4f2cd6f96c502aa1765c012" translate="yes" xml:space="preserve">
          <source>If lineno is 0 or greater than 32767(until C++11)2147483647(since C++11), the behavior is undefined.</source>
          <target state="translated">如果lineno为0或大于32767(直到C++11)2147483647(自C++11起),则行为未定义。</target>
        </trans-unit>
        <trans-unit id="0ce137b58879463fa5db786928dc6b5433066a3e" translate="yes" xml:space="preserve">
          <source>If lookup finds more than one deallocation function, the function to be called is selected as follows (see &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; for a more detailed description of these functions and their effects):</source>
          <target state="translated">如果查找找到多个释放函数，则按以下方式选择要调用的函数（有关这些函数及其作用的更详细说明，请参见&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;释放函数&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="16f6bcbb6edddebfaed64c4a8ff01d6fc6f7b460" translate="yes" xml:space="preserve">
          <source>If members of a union are classes with user-defined constructors and destructors, to switch the active member, explicit destructor and placement new are generally needed:</source>
          <target state="translated">如果一个联盟的成员是有用户定义的构造函数和析构函数的类,要切换活动成员,一般需要显式析构函数和放置new。</target>
        </trans-unit>
        <trans-unit id="9aaa368e593ef656dfef2f87849d89081dbdfcf4" translate="yes" xml:space="preserve">
          <source>If more than one match is possible, then any match is an acceptable result</source>
          <target state="translated">如果一个以上的匹配是可能的,那么任何匹配都是可接受的结果。</target>
        </trans-unit>
        <trans-unit id="02b8b892d773253c24c7deaa868506ebc598bb0d" translate="yes" xml:space="preserve">
          <source>If more than one preferred functions are found, only preferred functions are considered in the next step.</source>
          <target state="translated">如果找到一个以上的优选函数,下一步只考虑优选函数。</target>
        </trans-unit>
        <trans-unit id="cbd23d50b99e7b96b25fd8ee6be5397b6972349c" translate="yes" xml:space="preserve">
          <source>If more than the implementation-defined maximum number of shared owners already locked the mutex in shared mode, &lt;code&gt;lock_shared&lt;/code&gt; blocks execution until the number of shared owners is reduced. The maximum number of owners is guaranteed to be at least 10000.</source>
          <target state="translated">如果已在共享模式下锁定互斥锁的共享所有者超过实现定义的最大数量，则 &lt;code&gt;lock_shared&lt;/code&gt; 会阻止执行，直到减少共享所有者的数量为止。所有者的最大数量保证至少为10000。</target>
        </trans-unit>
        <trans-unit id="f645135ade1dcc39a052821b217283911b76e60d" translate="yes" xml:space="preserve">
          <source>If multiple constructors are viable but none is better than the others, the implicit conversion sequence is the ambiguous conversion sequence.</source>
          <target state="translated">如果多个构造体可行,但没有一个构造体比其他构造体好,那么隐含的转换序列就是模糊的转换序列。</target>
        </trans-unit>
        <trans-unit id="bbd656e7e48d690ef7ac59721f80eafd7184c36a" translate="yes" xml:space="preserve">
          <source>If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果多个线程尝试同时初始化同一静态局部变量，则初始化仅发生一次（可以使用 &lt;code&gt;&lt;a href=&quot;../thread/call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; 获得任意函数相似的行为）。</target>
        </trans-unit>
        <trans-unit id="71891f311caa8357864e30afc2d3a7d5ac7da117" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; (or, deprecated as of C++20, through the &lt;a href=&quot;atomic&quot;&gt;standalone functions&lt;/a&gt; for atomic access to std::shared_ptr).</source>
          <target state="translated">如果多个执行线程在不同步的情况下访问同一个 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 对象，并且其中任何访问使用了 &lt;code&gt;shared_ptr&lt;/code&gt; 的非常量成员函数，那么除非所有此类访问都是通过 &lt;code&gt;std::atomic&amp;lt;std::shared_ptr&amp;gt;&amp;gt;&lt;/code&gt; （或自C ++ 20起不推荐使用，通过用于原子访问std :: shared_ptr 的&lt;a href=&quot;atomic&quot;&gt;独立函数&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="882b5e537cc3e18e7bf36e2a307bc0559f800747" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through these functions, which are overloads of the corresponding atomic access functions (&lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt;, etc.).</source>
          <target state="translated">如果多个执行线程在不同步的情况下访问同一个 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 对象，并且其中任何访问使用了 &lt;code&gt;shared_ptr&lt;/code&gt; 的非常量成员函数，则将发生数据争用，除非所有此类访问都是通过这些函数执行的，这是相应的原子访问函数（ &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_load&quot;&gt;std::atomic_load&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_store&quot;&gt;std::atomic_store&lt;/a&gt;&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="bd64a01ec402003b9db85651e928cb1f1bbc53d5" translate="yes" xml:space="preserve">
          <source>If multiple threads of execution access the same &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; object without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;weak_ptr&lt;/code&gt; then a data race will occur unless all such access is performed through an instance of &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果多个执行线程在不同步的情况下访问同一个 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 对象，并且其中任何访问使用了non_const成员函数 &lt;code&gt;weak_ptr&lt;/code&gt; ,那么除非所有此类访问都是通过 &lt;code&gt;std::atomic&amp;lt;std::weak_ptr&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40f81f722965ce77fe317399aac97f912e696cd4" translate="yes" xml:space="preserve">
          <source>If n&amp;gt;=128, the behavior is implementation-defined</source>
          <target state="translated">如果n&amp;gt; = 128，则行为是实现定义的</target>
        </trans-unit>
        <trans-unit id="42e3ee0efc70684fde11275bda977b0d1b55fd68" translate="yes" xml:space="preserve">
          <source>If necessary, obtains the status of &lt;code&gt;to&lt;/code&gt;, by no more than a single call to</source>
          <target state="translated">如果必要的话，获得的状态 &lt;code&gt;to&lt;/code&gt; ，不超过一个单一的通话</target>
        </trans-unit>
        <trans-unit id="b0434e8f18603c02eef4062d15cac7f0e1d6bd92" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;*this&lt;/code&gt; nor &lt;code&gt;other&lt;/code&gt; contain a value, the function has no effect.</source>
          <target state="translated">如果 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 都不包含值，则该函数无效。</target>
        </trans-unit>
        <trans-unit id="1e8a7e77e5b17bbba28f9f5bde7a2ff9ba1ac92c" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; nor &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt;, nor any implementation-defined policy flag is set in &lt;code&gt;policy&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; 均未设置，也未在 &lt;code&gt;policy&lt;/code&gt; 中设置任何实现定义的策略标志，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="403cdbe454265b3fef8904df0622a89b983cd05c" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted copy assignment operator and a defaulted move assignment operator. Otherwise, it has a deleted copy assignment operator (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="translated">如果没有指定捕获,那么闭包类型有一个默认的复制分配操作符和一个默认的移动分配操作符,否则,它有一个删除的复制分配操作符(包括有捕获默认的情况,即使它没有实际捕获任何东西)。否则,它有一个被删除的复制分配操作符(这包括有捕获-默认的情况,即使它实际上没有捕获任何东西)。</target>
        </trans-unit>
        <trans-unit id="1b35fa3984aaeb3db9a1c2d09a20b6a3e68e64ef" translate="yes" xml:space="preserve">
          <source>If no captures are specified, the closure type has a defaulted default constructor. Otherwise, it has no default constructor (this includes the case when there is a capture-default, even if it does not actually capture anything).</source>
          <target state="translated">如果没有指定捕获,那么闭包类型就有一个默认的缺省构造函数,否则,它就没有缺省构造函数(包括有捕获缺省的情况,即使它没有实际捕获任何东西)。否则,它就没有默认的构造函数(这包括有capture-default的情况,即使它实际上没有捕获任何东西)。</target>
        </trans-unit>
        <trans-unit id="cd433247692a3d2cd8a72c9ba4974a4b61306058" translate="yes" xml:space="preserve">
          <source>If no characters are extracted then &lt;code&gt;std::ios::failbit&lt;/code&gt; is set on &lt;code&gt;is&lt;/code&gt;, which may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果没有提取到字符，那么 &lt;code&gt;std::ios::failbit&lt;/code&gt; 被设置 &lt;code&gt;is&lt;/code&gt; ，这可能会引发 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69c02d0301239909ac59a990ef2ea5d140fa29fd" translate="yes" xml:space="preserve">
          <source>If no characters are extracted, &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; is called.</source>
          <target state="translated">如果未提取任何字符，则调用 &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ba27093f4416e619f89024b343671475c2b0970" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="translated">如果未提取任何字符，则调用 &lt;code&gt;setstate(failbit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="536ea244a0d993a0064e14e4551396fff4cc9231" translate="yes" xml:space="preserve">
          <source>If no characters were extracted, calls &lt;code&gt;setstate(failbit)&lt;/code&gt;. In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, a null character (&lt;code&gt;CharT()&lt;/code&gt; is stored in the next successive location of the array.</source>
          <target state="translated">如果未提取任何字符，则调用 &lt;code&gt;setstate(failbit)&lt;/code&gt; 。无论如何，如果 &lt;code&gt;count&amp;gt;0&lt;/code&gt; ，则将空字符（ &lt;code&gt;CharT()&lt;/code&gt; 存储在数组的下一个连续位置中。</target>
        </trans-unit>
        <trans-unit id="878b0f05459600af7530cf7141a045ee2d7f3e8f" translate="yes" xml:space="preserve">
          <source>If no characters were inserted, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;. If an exception was thrown while extracting, sets &lt;code&gt;failbit&lt;/code&gt; and, if &lt;code&gt;failbit&lt;/code&gt; is set in &lt;code&gt;exceptions()&lt;/code&gt;, rethrows the exception.</source>
          <target state="translated">如果未插入任何字符，则执行 &lt;code&gt;setstate(failbit)&lt;/code&gt; 。如果一个异常被提取时抛出，套 &lt;code&gt;failbit&lt;/code&gt; ，如果 &lt;code&gt;failbit&lt;/code&gt; 被设置 &lt;code&gt;exceptions()&lt;/code&gt; ，重新抛出异常。</target>
        </trans-unit>
        <trans-unit id="edd868dcc474e443c25a49132bd6419f1abf7cca" translate="yes" xml:space="preserve">
          <source>If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">如果不能进行转换， &lt;code&gt;​0​&lt;/code&gt; 被返回。</target>
        </trans-unit>
        <trans-unit id="530f889d2ad8b60ee918f8e2702b7883b29fb175" translate="yes" xml:space="preserve">
          <source>If no errors occur earg</source>
          <target state="translated">如果没有发生错误,则可</target>
        </trans-unit>
        <trans-unit id="a4b69264dcfdc184105c0c5fcdc54a8a79767399" translate="yes" xml:space="preserve">
          <source>If no errors occur ln(1+arg) is returned.</source>
          <target state="translated">如果没有错误发生,则返回ln(1+arg)。</target>
        </trans-unit>
        <trans-unit id="f3037fe820d838daa891fb3539a8329f215061a7" translate="yes" xml:space="preserve">
          <source>If no errors occur,</source>
          <target state="translated">如果没有发生错误。</target>
        </trans-unit>
        <trans-unit id="47e97b549aae51b3c35168920f72ade75b7949f9" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;base&lt;/code&gt; raised to the power of &lt;code&gt;exp&lt;/code&gt; (or &lt;code&gt;iexp&lt;/code&gt;) (baseexp</source>
          <target state="translated">如果没有错误发生，则将 &lt;code&gt;base&lt;/code&gt; 提高到 &lt;code&gt;exp&lt;/code&gt; （或 &lt;code&gt;iexp&lt;/code&gt; ）（baseexp</target>
        </trans-unit>
        <trans-unit id="ef48764b6bc2b922ac28634b1b57e0a32884367d" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by 2 to the power of &lt;code&gt;exp&lt;/code&gt; (x&amp;times;2exp</source>
          <target state="translated">如果没有错误发生，则将 &lt;code&gt;x&lt;/code&gt; 乘以2乘以 &lt;code&gt;exp&lt;/code&gt; 的幂（x&amp;times;2exp</target>
        </trans-unit>
        <trans-unit id="be1997f1a364feb4c59b1137ec5be5c5163c893c" translate="yes" xml:space="preserve">
          <source>If no errors occur, &lt;code&gt;x&lt;/code&gt; multiplied by &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; to the power of &lt;code&gt;arg&lt;/code&gt; (x&amp;times;FLT_RADIXexp</source>
          <target state="translated">如果没有错误发生，则将 &lt;code&gt;x&lt;/code&gt; 乘以 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;FLT_RADIX&lt;/a&gt;&lt;/code&gt; 等于 &lt;code&gt;arg&lt;/code&gt; 的幂（x&amp;times;FLT_RADIXexp</target>
        </trans-unit>
        <trans-unit id="43e9fba55e5f456a3880c2a5f09b14d52ee81371" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range [0 ; &amp;infin;) along the real axis and in the range [&amp;minus;</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复数反余弦，范围为[0; &amp;infin;）沿实轴且在[&amp;minus;</target>
        </trans-unit>
        <trans-unit id="3ba083c7eab3d055b75951c25f225f73acff4188" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复数反正弦值，其范围在沿虚轴无界的条带范围内，且在[-&amp;pi;/ 2; +&amp;pi;/ 2]沿实轴。</target>
        </trans-unit>
        <trans-unit id="e58f6c458633d11255df6ec72e17d6e0e307082c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复数反正切值，该值在沿着虚轴无界的条带范围内以及[-&amp;pi;/ 2; +&amp;pi;/ 2]沿实轴。</target>
        </trans-unit>
        <trans-unit id="50a8713f4c4c617bedaa7a390ea195b3329dac1c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的双曲余弦值。</target>
        </trans-unit>
        <trans-unit id="a8e6619163d1ca9fedc0a2bfd79d4c047fbeb277" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的双曲正弦值。</target>
        </trans-unit>
        <trans-unit id="0204a9004641a330efb33cc1c10a2eb5fe8c95c2" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复双曲正切值。</target>
        </trans-unit>
        <trans-unit id="b37be6aaeb963e74d379aaa690fc0222ec1a8842" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the absolute value (also known as norm, modulus, or magnitude) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的绝对值（也称为范数，模量或大小）。</target>
        </trans-unit>
        <trans-unit id="f7f248bc9527b22f78b886ecb63cf4c8a2bd9c60" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the fractional part of &lt;code&gt;x&lt;/code&gt; with the same sign as &lt;code&gt;x&lt;/code&gt;. The integral part is put into the value pointed to by &lt;code&gt;iptr&lt;/code&gt;.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;x&lt;/code&gt; 的小数部分，其符号与 &lt;code&gt;x&lt;/code&gt; 相同。整数部分放入 &lt;code&gt;iptr&lt;/code&gt; 指向的值中。</target>
        </trans-unit>
        <trans-unit id="dcbbfc79f2b5b688deb79fcd4d7c358c461e6459" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the phase angle of &lt;code&gt;z&lt;/code&gt; in the interval [&amp;minus;&amp;pi;; &amp;pi;].</source>
          <target state="translated">如果没有出现错误，则返回的相位角 &lt;code&gt;z&lt;/code&gt; 在间隔[-&amp;pi;; &amp;pi;]。</target>
        </trans-unit>
        <trans-unit id="af3231d18a9dbafc82193c163f7f7ec4e37b28f7" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the square root of &lt;code&gt;z&lt;/code&gt;, in the range of the right half-plane, including the imaginary axis ([0; +&amp;infin;) along the real axis and (&amp;minus;&amp;infin;; +&amp;infin;) along the imaginary axis.).</source>
          <target state="translated">如果没有错误发生，则在右半平面的范围内返回 &lt;code&gt;z&lt;/code&gt; 的平方根，包括沿实轴的虚轴（[0; +&amp;infin;）和沿虚轴的（-&amp;infin;; +&amp;infin;）。 ）。</target>
        </trans-unit>
        <trans-unit id="c2564a63d94a5759bfc1f7f8a35fbdfcf9b9d071" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical Bessel function of the first kind of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is j</source>
          <target state="translated">如果没有错误发生，则返回第一种 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的球贝塞尔函数的值，即j</target>
        </trans-unit>
        <trans-unit id="4739e7b0751e1897ecdce821941cd1dfb83af3ac" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical Bessel function of the second kind (spherical Neumann function) of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is n</source>
          <target state="translated">如果没有错误，则返回 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的第二种球形贝塞尔函数（球形诺伊曼函数）的值，即n</target>
        </trans-unit>
        <trans-unit id="63cd03ce841bb8c36f4907b2d91c123b017f259e" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical associated Legendre function (that is, spherical harmonic with ϕ = 0) of &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;&amp;theta;&lt;/code&gt;, where the spherical harmonic function is defined as Ym</source>
          <target state="translated">如果没有错误发生，则返回与球相关的Legendre函数（即Legend = 0 的球谐函数）的 &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;&amp;theta;&lt;/code&gt; 的值，其中球谐函数定义为Ym</target>
        </trans-unit>
        <trans-unit id="ee22b5df48ca25af069416a0b6aead9e8cfe0766" translate="yes" xml:space="preserve">
          <source>If no errors occur, square root of &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg), is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;arg&lt;/code&gt; （&amp;radic;arg）的平方根。</target>
        </trans-unit>
        <trans-unit id="d6cd26c82284031b354355d1565d22e205fe8e3d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc cosine of &lt;code&gt;arg&lt;/code&gt; (arccos(arg)) in the range [0 , &amp;pi;], is returned.</source>
          <target state="translated">如果没有错误发生，则返回范围为[0，&amp;pi;] 的 &lt;code&gt;arg&lt;/code&gt; 的反余弦（arccos（arg））。</target>
        </trans-unit>
        <trans-unit id="039d32b1f2e5bfee4ca5736c63a4206e5274388e" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc sine of &lt;code&gt;arg&lt;/code&gt; (arcsin(arg)) in the range [-</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; （arcsin（arg））的反正弦在[-</target>
        </trans-unit>
        <trans-unit id="b32613c8b978beac62c696ce2bd93a54bd237edb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;arg&lt;/code&gt; (arctan(arg)) in the range [-</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; （arctan（arg））的反正切在[-</target>
        </trans-unit>
        <trans-unit id="c938da3a42fe0590b15c6f8539ff408d3a3b97dd" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (arctan(</source>
          <target state="translated">如果没有错误，则 &lt;code&gt;y/x&lt;/code&gt; 的反正切（arctan（</target>
        </trans-unit>
        <trans-unit id="9d5986c54dce11e1cd1599414757016de12c5f01" translate="yes" xml:space="preserve">
          <source>If no errors occur, the base-</source>
          <target state="translated">如果没有发生错误,则基线</target>
        </trans-unit>
        <trans-unit id="be331ea28ae7c2d7b9acf97860d316fce4b87723" translate="yes" xml:space="preserve">
          <source>If no errors occur, the common (base-</source>
          <target state="translated">如果没有发生错误,则常见的(基站)。</target>
        </trans-unit>
        <trans-unit id="135f7aa5f1c2d4f79725bd744a0dd782f41f3bfa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip of nonnegative values along the real axis and in the interval [&amp;minus;i&amp;pi;; +i&amp;pi;] along the imaginary axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复弧双曲余弦值，该值在沿实轴的非负值的半条带范围内，且在[-i&amp;pi;; +i&amp;pi;]沿虚轴。</target>
        </trans-unit>
        <trans-unit id="05909577ff3329b64c179e57f5f18c51d7427016" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复弧双曲正弦值，该值在沿实轴数学上无界的条带范围内，且在[-i&amp;pi;/ 2; +i&amp;pi;/ 2]沿虚轴。</target>
        </trans-unit>
        <trans-unit id="5e1faa126d0291e9222a13afce04bd8eb0c0cbd7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复弧双曲正切值，该值在沿实轴数学上无界的半条带范围内，且在[-i&amp;pi;/ 2; +i&amp;pi;/ 2]沿虚轴。</target>
        </trans-unit>
        <trans-unit id="b951e541cea44c28eafdd9c54b7c32c1392530f6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的余弦。</target>
        </trans-unit>
        <trans-unit id="e0170daad51b40b50ab797fcf5f22cc95ede3feb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex natural logarithm of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip in the interval [&amp;minus;i&amp;pi;, +i&amp;pi;] along the imaginary axis and mathematically unbounded along the real axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复数自然对数，该数在带的范围内，沿着虚轴在[-i&amp;pi;，+i&amp;pi;]区间内，并且在数学上沿实轴无界。</target>
        </trans-unit>
        <trans-unit id="e80a11cce80b4f8332e379e29bcd184e31b6ff47" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex power xy</source>
          <target state="translated">如果没有发生错误,则复数幂 xy</target>
        </trans-unit>
        <trans-unit id="c05f2e2cc1ed459bdf96a06ef8dbc33e20915e79" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复正弦。</target>
        </trans-unit>
        <trans-unit id="8f171b9589d9359bfb44bdfa881b4ee93ea77d0c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复数切线。</target>
        </trans-unit>
        <trans-unit id="35bd7abdcb7f0220128fd880299baf801952dc19" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cosine of &lt;code&gt;arg&lt;/code&gt; (cos(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; 的余弦（cos（arg））在[-1; +1]，返回。</target>
        </trans-unit>
        <trans-unit id="ff16f514ad4d462d31d6524ed4ea84f4f6bcb390" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cubic root of &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg), is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;arg&lt;/code&gt; （3&amp;radic;arg）的立方根。</target>
        </trans-unit>
        <trans-unit id="1e33cd84b874596d38519b6f05a2e60c9accef6b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the floating point value with the magnitude of &lt;code&gt;x&lt;/code&gt; and the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回具有 &lt;code&gt;x&lt;/code&gt; 的大小和 &lt;code&gt;y&lt;/code&gt; 的符号的浮点值。</target>
        </trans-unit>
        <trans-unit id="29635dc5075be505f22d8b338419ce3b116238e5" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh(arg), or</source>
          <target state="translated">如果没有发生错误，的双曲余弦 &lt;code&gt;arg&lt;/code&gt; （COSH（ARG），或</target>
        </trans-unit>
        <trans-unit id="084419061d5d22eb194084f72eb3bc99faee2d80" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh(arg), or</source>
          <target state="translated">如果没有发生错误，的双曲正弦 &lt;code&gt;arg&lt;/code&gt; （双曲正弦（ARG），或</target>
        </trans-unit>
        <trans-unit id="fde1a5cab1da9385208df6463481d983b8d198b8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh(arg), or</source>
          <target state="translated">如果没有错误发生， &lt;code&gt;arg&lt;/code&gt; （tanh（arg），或</target>
        </trans-unit>
        <trans-unit id="3870fee396c73bbc1aab8cee4f9a85c1179be025" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh-1</source>
          <target state="translated">如果没有错误发生，则为 &lt;code&gt;arg&lt;/code&gt; 的反双曲余弦（cosh-1</target>
        </trans-unit>
        <trans-unit id="c5db26fbae61f4e34cf5287ffaa5a9d47e53259d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh-1</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; 的反双曲正弦（sinh-1</target>
        </trans-unit>
        <trans-unit id="f93099d7063e1d7a83038ac66c3c5233ba5f6ece" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh-1</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; （tanh-1）的反双曲正切值</target>
        </trans-unit>
        <trans-unit id="d4744dace8417a9d2afa9a3795c780e70495855c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the largest integer value not greater than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lfloor;arg&amp;rfloor;, is returned.</source>
          <target state="translated">如果没有错误发生，则返回不大于 &lt;code&gt;arg&lt;/code&gt; 的最大整数值arg。</target>
        </trans-unit>
        <trans-unit id="3007ffc0d3f619ed4878713babc6bf385e75ed5b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the natural (base-</source>
          <target state="translated">如果没有发生错误,则自然(基数)。</target>
        </trans-unit>
        <trans-unit id="c09a1dd12c5becd1a78d62ef2eba3711b8030fb7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value not greater in magnitude than &lt;code&gt;arg&lt;/code&gt; (in other words, &lt;code&gt;arg&lt;/code&gt; rounded towards zero) is returned.</source>
          <target state="translated">如果没有错误发生，则返回幅度不大于 &lt;code&gt;arg&lt;/code&gt; 的最接近的整数值（换句话说， &lt;code&gt;arg&lt;/code&gt; 朝零舍入）。</target>
        </trans-unit>
        <trans-unit id="f769b27b09219929833064428bef0734a24648aa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">如果没有错误发生，则根据&lt;a href=&quot;../fenv/fe_round&quot;&gt;当前的舍入模式&lt;/a&gt;，返回最接近 &lt;code&gt;arg&lt;/code&gt; 的整数值。</target>
        </trans-unit>
        <trans-unit id="a0256d4c5a80036d6bc9fdb716345ed55c66ea11" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, rounding halfway cases away from zero, is returned.</source>
          <target state="translated">如果没有错误发生，则返回最接近 &lt;code&gt;arg&lt;/code&gt; 的整数值（舍入为零的一半）。</target>
        </trans-unit>
        <trans-unit id="2dcc36013b109d5eaf27751a51321acffdd6a03d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the next representable value of &lt;code&gt;from&lt;/code&gt; in the direction of &lt;code&gt;to&lt;/code&gt;. is returned. If &lt;code&gt;from&lt;/code&gt; equals &lt;code&gt;to&lt;/code&gt;, then &lt;code&gt;to&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有发生错误，下一个可表示值 &lt;code&gt;from&lt;/code&gt; 在方向 &lt;code&gt;to&lt;/code&gt; 。返回。如果 &lt;code&gt;from&lt;/code&gt; 等于 &lt;code&gt;to&lt;/code&gt; ，则返回 &lt;code&gt;to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a7b391baa86594c7d0448266a28acb2668a4e8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the sine of &lt;code&gt;arg&lt;/code&gt; (sin(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; 的正弦（sin（arg））在[-1; +1]，返回。</target>
        </trans-unit>
        <trans-unit id="3fa7223cf61583336068c9d91991b4f9bedf8c7c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the smallest integer value not less than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lceil;arg&amp;rceil;, is returned.</source>
          <target state="translated">如果没有错误发生，则返回不小于 &lt;code&gt;arg&lt;/code&gt; 的最小整数值arg。</target>
        </trans-unit>
        <trans-unit id="941693082c1c679c39e6797e593c1a748bca9744" translate="yes" xml:space="preserve">
          <source>If no errors occur, the tangent of &lt;code&gt;arg&lt;/code&gt; (tan(arg)) is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;arg&lt;/code&gt; （tan（arg））的切线。</target>
        </trans-unit>
        <trans-unit id="8e15bc85bb52009c88f5c69e56b9a2471d950454" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed floating-point value.</source>
          <target state="translated">如果没有错误发生，则将 &lt;code&gt;arg&lt;/code&gt; 的无偏指数作为带符号浮点值返回。</target>
        </trans-unit>
        <trans-unit id="026d1df8b0b132c32fe387fe762cb8d1ea884358" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed int value.</source>
          <target state="translated">如果没有错误发生， &lt;code&gt;arg&lt;/code&gt; 有符号的int值形式返回arg的无偏指数。</target>
        </trans-unit>
        <trans-unit id="52dc1f3518fb2bced2d18acc2522443fc278caf6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is \(\mathsf{\Gamma}(arg) = \int_0^\infty t^{arg-1} e^{-t} \mathsf{d}t\)&amp;int;&amp;infin;</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; 的伽马函数值即\（\ mathsf {\ Gamma}（arg）= \ int_0 ^ \ infty t ^ {arg-1} e ^ {-t} \ mathsf {d } t \）&amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="17f4ff9a3637589c23bfc0b873e96c8630ea5296" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the logarithm of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is log</source>
          <target state="translated">如果没有错误发生，则为 &lt;code&gt;arg&lt;/code&gt; 的伽马函数的对数值，即log</target>
        </trans-unit>
        <trans-unit id="753b72c485945c6afd5db2fbcdff840651420e76" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the Riemann zeta function of &lt;code&gt;arg&lt;/code&gt;, &amp;zeta;(arg), defined for the entire real axis:</source>
          <target state="translated">如果没有错误发生，则为整个实轴定义的 &lt;code&gt;arg&lt;/code&gt; 的黎曼zeta函数的值&amp;zeta;（arg）：</target>
        </trans-unit>
        <trans-unit id="6801efcde3e466144a59b2e13c721de60eb9a8db" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the associated Laguerre polynomial of &lt;code&gt;x&lt;/code&gt;, that is \((-1)^m \: \frac{ \mathsf{d} ^ m}{ \mathsf{d}x ^ m} \, \mathsf{L}_{n+m}(x)\)(-1)m</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;x&lt;/code&gt; 的关联Laguerre多项式的值即\（（-1）^ m \：\ frac {\ mathsf {d} ^ m} {\ mathsf {d} x ^ m} \，\ mathsf {L} _ {n + m}（x）\）（-1）m</target>
        </trans-unit>
        <trans-unit id="b70f9e16b11c8009277ec11b877f36771c9cba33" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the associated Legendre polynomial \(\mathsf{P}_n^m\)Pm</source>
          <target state="translated">如果没有发生错误,则相关的Legendre多项式的值 ⑴(mathsf{P}_n^m/)Pm。</target>
        </trans-unit>
        <trans-unit id="238d4638a6406e5670a8756021c43a9a89528ae6" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the beta function of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, that is &amp;int;1</source>
          <target state="translated">如果没有错误，则 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的beta函数的值为&amp;int;1</target>
        </trans-unit>
        <trans-unit id="7f29a8300bf4d8be194d411485092bca1cff89a5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complementary error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">如果没有错误发生，则为 &lt;code&gt;arg&lt;/code&gt; 的互补错误函数的值，即</target>
        </trans-unit>
        <trans-unit id="df9c117eae172dac4ec6d5b52cce8a077d21f8a8" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the first kind of &lt;code&gt;k&lt;/code&gt;, that is &lt;code&gt;ellint_1(k,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">如果没有错误发生，则返回第一种 &lt;code&gt;k&lt;/code&gt; 的完整椭圆积分的值，即 &lt;code&gt;ellint_1(k,&amp;pi;/2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cbeea440564c0733c80ec0f91528453bf57997d" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the second kind of &lt;code&gt;k&lt;/code&gt;, that is &lt;code&gt;ellint_2(k,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">如果没有错误发生，则返回第二种 &lt;code&gt;k&lt;/code&gt; 的完整椭圆积分的值，即 &lt;code&gt;ellint_2(k,&amp;pi;/2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66c1ee451279e40e8fca9ad9ed4b42f5978e872c" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the third kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;nu;&lt;/code&gt;, that is &lt;code&gt;std::ellint_3(k,&amp;nu;,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">如果没有错误发生，则返回第三种 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;&amp;nu;&lt;/code&gt; 的完全椭圆积分的值，即 &lt;code&gt;std::ellint_3(k,&amp;nu;,&amp;pi;/2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a66e2b26fcc8bbc9cd86fdf7747135c750049f9c" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the cylindrical Bessel function of the first kind of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is J</source>
          <target state="translated">如果没有错误发生，则第一类 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的圆柱贝塞尔函数的值即J</target>
        </trans-unit>
        <trans-unit id="543182535183bd8bc0773d95ac751d4302a6fe06" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the cylindrical Neumann function (Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, is returned, that is N</source>
          <target state="translated">如果没有错误发生，则返回圆柱型Neumann函数（第二种贝塞尔函数）的 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的值，即N</target>
        </trans-unit>
        <trans-unit id="0658bf24f8b1dde223e35183fc409335d58b1a45" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">如果没有错误发生，则为 &lt;code&gt;arg&lt;/code&gt; 的错误函数的值，即</target>
        </trans-unit>
        <trans-unit id="9df1996268d06781fa476369becefdaadd629195" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the exponential integral of &lt;code&gt;arg&lt;/code&gt;, that is -&amp;int;&amp;infin;</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; 的指数积分的值即-&amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="12d4162f2889063b6a7da39429e27d5af98a2241" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the first kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">如果没有错误发生，则第一种 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;&amp;phi;&lt;/code&gt; 的不完整椭圆积分的值即&amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="f2687108220b1e44fef928c06fa5038f1e9ca385" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the second kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">如果没有错误发生，则第二种 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;&amp;phi;&lt;/code&gt; 的不完整椭圆积分的值即&amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="7ebd0beae76ba7f9e7e5a8530d1366439fe50ddc" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the third kind of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;&amp;nu;&lt;/code&gt;, and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">如果没有错误发生，则第三种 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;&amp;phi;&lt;/code&gt; 的不完整椭圆积分的值，即&amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="47bf302c79b395741bf53556a6be82fa3fd028e9" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the irregular modified cylindrical Bessel function (modified Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, is returned, that is K</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的不规则修正圆柱Bessel函数（第二种修正Bessel函数）的值，即K</target>
        </trans-unit>
        <trans-unit id="aea1c8d887f4647bdb33eced1d1223c98eae241d" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the nonassociated Laguerre polynomial of &lt;code&gt;x&lt;/code&gt;, that is</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;x&lt;/code&gt; 的非关联Laguerre多项式的值，即</target>
        </trans-unit>
        <trans-unit id="6f5b17abebff553421278dbae1b01fcc098edc8f" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the order-&lt;code&gt;n&lt;/code&gt; unassociated Legendre polynomial of &lt;code&gt;x&lt;/code&gt;, that is \(\mathsf{P}_n(x) = \frac{1}{2^n n!} \frac{\mathsf{d}^n}{\mathsf{d}x^n} (x^2-1)^n \)</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 次未关联勒让德多项式的值，即\（\ mathsf {P} _n（x）= \ frac {1} {2 ^ nn！} \ frac {\ mathsf {d} ^ n} {\ mathsf {d} x ^ n}（x ^ 2-1）^ n \）</target>
        </trans-unit>
        <trans-unit id="5fe63011566ab90404ecbc2fc30a86fbf404e9b5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the order-&lt;code&gt;n&lt;/code&gt;Hermite polynomial of &lt;code&gt;x&lt;/code&gt;, that is (-1)n</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;x&lt;/code&gt; 的 Hermite多项式的值 &lt;code&gt;n&lt;/code&gt; ，即（-1）n</target>
        </trans-unit>
        <trans-unit id="521caff23698b2c47666d0e91701aa665925f3de" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the regular modified cylindrical Bessel function of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is I</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的正则修正圆柱贝塞尔函数的值即I</target>
        </trans-unit>
        <trans-unit id="031ce73d89df4a56cec229b26ace78aed68d756e" translate="yes" xml:space="preserve">
          <source>If no exception was thrown during input, sets the number of extracted characters (gcount) in the input stream.</source>
          <target state="translated">如果在输入过程中没有发生异常,则设置输入流中提取的字符数(gcount)。</target>
        </trans-unit>
        <trans-unit id="4c799e4f486ea142e7186bf650ea8a5b122a9d32" translate="yes" xml:space="preserve">
          <source>If no exception was thrown, returns &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">如果未引发异常，则返回 &lt;code&gt;*this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d67368bbb57de9e88e241a4a9a8276ff5bf9165e" translate="yes" xml:space="preserve">
          <source>If no exception was thrown, returns the value specified by the function.</source>
          <target state="translated">如果没有发生异常,返回函数指定的值。</target>
        </trans-unit>
        <trans-unit id="1f75f70449c5d517f16e8db38a32eb7a472a99d1" translate="yes" xml:space="preserve">
          <source>If no initializer is provided, the rules of &lt;a href=&quot;default_initialization&quot;&gt;default initialization&lt;/a&gt; apply.</source>
          <target state="translated">如果未提供初始化程序，则适用&lt;a href=&quot;default_initialization&quot;&gt;默认初始化&lt;/a&gt;规则。</target>
        </trans-unit>
        <trans-unit id="51774f7adc99f180db60612981a5526941d80108" translate="yes" xml:space="preserve">
          <source>If no matches are found after all catch-clauses were examined, the exception propagation continues to the containing try-block, as described in &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;. If there are no containing try-blocks left, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is executed (in this case, it is implementation-defined whether any stack unwinding occurs at all: throwing an uncaught exception is permitted to terminate the program without invoking any destructors).</source>
          <target state="translated">如果在检查了所有捕获子句之后未找到匹配项，则异常传播将继续进行到包含try块，如&lt;a href=&quot;throw&quot;&gt;throw-expression中所述&lt;/a&gt;。如果没有剩余的try块，则执行 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; （在这种情况下，由实现定义，是否发生任何堆栈展开：允许抛出未捕获的异常来终止程序而无需调用任何析构函数）。</target>
        </trans-unit>
        <trans-unit id="85ed69b90bb670ce03358daa2e3280ab8a0acaef" translate="yes" xml:space="preserve">
          <source>If no memory could be allocated, or allocated storage is not enough to store a single element of type &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;first&lt;/code&gt; element of the result is a null pointer and the &lt;code&gt;second&lt;/code&gt; element is zero.</source>
          <target state="translated">如果无法分配内存，或者分配的存储空间不足以存储类型 &lt;code&gt;T&lt;/code&gt; 的单个元素，则结果的 &lt;code&gt;first&lt;/code&gt; 元素为空指针， &lt;code&gt;second&lt;/code&gt; 元素为零。</target>
        </trans-unit>
        <trans-unit id="9d359f89a70fe560ca132223fbd242fa45ae36ac" translate="yes" xml:space="preserve">
          <source>If no mismatches are found when the comparison reaches &lt;code&gt;last1&lt;/code&gt; or &lt;code&gt;last2&lt;/code&gt;, whichever happens first, the pair holds the end iterator and the corresponding iterator from the other range.</source>
          <target state="translated">如果在比较达到 &lt;code&gt;last1&lt;/code&gt; 或 &lt;code&gt;last2&lt;/code&gt; 时（以较早发生者为准）未找到不匹配项，则该对将保留结束迭代器和另一个范围中的相应迭代器。</target>
        </trans-unit>
        <trans-unit id="5a80ff055cfd93f4382626d501c63e2d0233080f" translate="yes" xml:space="preserve">
          <source>If no mismatches are found when the comparison reaches &lt;code&gt;last1&lt;/code&gt;, the pair holds &lt;code&gt;last1&lt;/code&gt; and the corresponding iterator from the second range. The behavior is undefined if the second range is shorter than the first range.</source>
          <target state="translated">如果在比较达到 &lt;code&gt;last1&lt;/code&gt; 时未找到不匹配项，则该对将保留 &lt;code&gt;last1&lt;/code&gt; 和第二个范围中的相应迭代器。如果第二个范围比第一个范围短，则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="781fedf1bc7025a615d3c4ed7f1b4d2a7b74af04" translate="yes" xml:space="preserve">
          <source>If no preferred functions are found, the non-preferred ones are considered in the next step.</source>
          <target state="translated">如果没有找到首选函数,则在下一步考虑非首选函数。</target>
        </trans-unit>
        <trans-unit id="212c7248247dc34425f2118c2a6054de49eb5fd9" translate="yes" xml:space="preserve">
          <source>If no such character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and the future calls to &lt;code&gt;strtok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">如果找不到这样的字符，则 &lt;code&gt;str&lt;/code&gt; 只有一个令牌，将来对 &lt;code&gt;strtok&lt;/code&gt; 的调用将返回空指针</target>
        </trans-unit>
        <trans-unit id="e0e3f85b21f0603ccfad7c7630e2e6165f6efad1" translate="yes" xml:space="preserve">
          <source>If no such character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">如果找不到这样的字符，则 &lt;code&gt;str&lt;/code&gt; 中根本没有令牌，并且该函数返回空指针。</target>
        </trans-unit>
        <trans-unit id="32d0b18e53a062a7ffa1ce497fbf816f66e2daa5" translate="yes" xml:space="preserve">
          <source>If no such elements are found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到此类元素，则返回 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ef5b0f78fdffa741da1e2a6130af0d51d257860" translate="yes" xml:space="preserve">
          <source>If no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到这样的序列，则返回 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95318ca2ad225ff32e9ddd27aadd58f11c7c9bf8" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;std::wcstok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">如果找不到这样的宽字符，则 &lt;code&gt;str&lt;/code&gt; 只有一个令牌，将来对 &lt;code&gt;std::wcstok&lt;/code&gt; 调用将返回空指针</target>
        </trans-unit>
        <trans-unit id="d9fb4aef6036de9d69cd4d033e352d979c405074" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">如果找不到这样的宽字符，则 &lt;code&gt;str&lt;/code&gt; 中根本没有令牌，并且该函数返回空指针。</target>
        </trans-unit>
        <trans-unit id="40ac478406fa04d277853c0748ded82cd0ccce6d" translate="yes" xml:space="preserve">
          <source>If no user-declared constructors of any kind are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a default constructor as an &lt;code&gt;inline public&lt;/code&gt; member of its class.</source>
          <target state="translated">如果没有为类类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供任何用户声明的构造函数，则编译器将始终将默认构造函数声明为其类的 &lt;code&gt;inline public&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="7ad4343e0140e81303cc7ccdcdc20abcd1b3af02" translate="yes" xml:space="preserve">
          <source>If no user-declared destructor is provided for a &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a destructor as an &lt;code&gt;inline public&lt;/code&gt; member of its class.</source>
          <target state="translated">如果没有为&lt;a href=&quot;class&quot;&gt;类类型&lt;/a&gt;（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供用户声明的析构函数，则编译器将始终将析构函数声明为其类的 &lt;code&gt;inline public&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="bb4a43dac5ef9eabbbba755dc09ed6605a9c36f6" translate="yes" xml:space="preserve">
          <source>If no user-defined constructors are present and the implicitly-declared default constructor is not trivial, the user may still inhibit the automatic generation of an implicitly-defined default constructor by the compiler with the keyword &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">如果不存在用户定义的构造函数，并且隐式声明的默认构造函数并不简单，则用户仍可以禁止编译器使用关键字 &lt;code&gt;delete&lt;/code&gt; 来自动生成隐式定义的默认构造函数。</target>
        </trans-unit>
        <trans-unit id="94c428bc493bfd4bf3cb4c40be6d006d6ae9320b" translate="yes" xml:space="preserve">
          <source>If no user-defined copy assignment operators are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare one as an inline public member of the class. This implicitly-declared copy assignment operator has the form &lt;code&gt;T&amp;amp; T::operator=(const T&amp;amp;)&lt;/code&gt; if all of the following is true:</source>
          <target state="translated">如果没有为类类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供用户定义的副本分配运算符，则编译器将始终将其中一个声明为该类的内联公共成员。如果满足以下所有条件，则此隐式声明的副本分配运算符的形式为 &lt;code&gt;T&amp;amp; T::operator=(const T&amp;amp;)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="851c19dced47a32ee3f0fdfb9f639786302ce9fb" translate="yes" xml:space="preserve">
          <source>If no user-defined copy constructors are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a copy constructor as a non-&lt;a href=&quot;explicit&quot;&gt;explicit&lt;/a&gt;&lt;code&gt;inline public&lt;/code&gt; member of its class. This implicitly-declared copy constructor has the form &lt;code&gt;T::T(const T&amp;amp;)&lt;/code&gt; if all of the following are true:</source>
          <target state="translated">如果没有为类类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供用户定义的副本构造函数，则编译器将始终将副本构造函数声明为其类的非&lt;a href=&quot;explicit&quot;&gt;显式&lt;/a&gt; &lt;code&gt;inline public&lt;/code&gt; 成员。如果满足以下所有条件，则此隐式声明的副本构造函数的形式为 &lt;code&gt;T::T(const T&amp;amp;)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b4fd8cb3d9cb59c45a27ed26df217a6fe2527317" translate="yes" xml:space="preserve">
          <source>If no user-defined move assignment operators are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), and all of the following is true:</source>
          <target state="translated">如果没有为类类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供用户定义的移动分配运算符，并且以下所有条件均成立：</target>
        </trans-unit>
        <trans-unit id="d13ec6ee9e77a6e3545912f76a282bde870c425b" translate="yes" xml:space="preserve">
          <source>If no user-defined move constructors are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), and all of the following is true:</source>
          <target state="translated">如果没有为类类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供用户定义的move构造函数，则以下所有条件均成立：</target>
        </trans-unit>
        <trans-unit id="12fccd1db64bc403607d3dd62463e20e8242d5d4" translate="yes" xml:space="preserve">
          <source>If non-default allocators are intended to be supported for the allocation of the implementation object, any of the usual allocator awareness patterns may be utilized, including allocator template parameter defaulting to &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; and constructor argument of type &lt;a href=&quot;../memory/memory_resource&quot;&gt;&lt;code&gt;std::pmr::memory_resource*&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果打算为实现对象的分配支持非默认分配器，则可以使用任何通常的分配器感知模式，包括默认为 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 分配器模板参数和类型为&lt;a href=&quot;../memory/memory_resource&quot;&gt; &lt;code&gt;std::pmr::memory_resource*&lt;/code&gt; &lt;/a&gt;构造函数参数。memory_resource *。</target>
        </trans-unit>
        <trans-unit id="9e7a52425c4552c258484ec30442892b69acfcad" translate="yes" xml:space="preserve">
          <source>If not empty, destroys the contained object.</source>
          <target state="translated">如果不为空,则销毁包含的对象。</target>
        </trans-unit>
        <trans-unit id="46f7a7c5951af943707abba8135020cebc9f7870" translate="yes" xml:space="preserve">
          <source>If object is a non-bit-field rvalue or a function lvalue, and its type is either &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, equally or less cv-qualified, then the reference is bound to the value of the initializer expression or to its base subobject (after &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializing a temporary&lt;/a&gt; if necessary)(since C++17).</source>
          <target state="translated">如果object是非位字段右值或函数左值，并且其类型是 &lt;code&gt;T&lt;/code&gt; 或从 &lt;code&gt;T&lt;/code&gt; 派生（等于或小于cv限定），则该引用将绑定到初始化程序表达式的值或其基本子对象（在必要时&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;实现临时文件&lt;/a&gt;）（自C ++ 17起）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
