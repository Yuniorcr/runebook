<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="fc058be4fe81eec42326824dea95a8995ba79311" translate="yes" xml:space="preserve">
          <source>The formal parameter of the catch clause (type-specifier-seq and declarator or type-specifier-seq and abstract-declarator) determines which types of exceptions cause this catch clause to be entered. It cannot be an &lt;a href=&quot;reference&quot;&gt;rvalue reference type&lt;/a&gt;, &lt;a href=&quot;abstract_class&quot;&gt;abstract class&lt;/a&gt;, &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, or pointer to incomplete type (except that pointers to (possibly &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;-qualified) &lt;code&gt;void&lt;/code&gt; are allowed). If the type of the formal parameter is array type or function type, it is treated as the corresponding pointer type (similar to a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;).</source>
          <target state="translated">catch子句的形式参数（type-specifier-seq和declarator或type-specifier-seq和abstract-declarator）确定哪些异常类型导致输入此catch子句。它不能是&lt;a href=&quot;reference&quot;&gt;右值引用类型&lt;/a&gt;，&lt;a href=&quot;abstract_class&quot;&gt;抽象类&lt;/a&gt;，&lt;a href=&quot;incomplete_type&quot;&gt;不完整类型&lt;/a&gt;或指向不完整类型的指针（除非允许使用指向（可能是&lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;限定的） &lt;code&gt;void&lt;/code&gt; 的指针）。如果形式参数的类型是数组类型或函数类型，则将其视为相应的指针类型（类似于&lt;a href=&quot;function&quot;&gt;函数声明&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="8c84fba53b093effe5342ab55502a277a5ffaba5" translate="yes" xml:space="preserve">
          <source>The format of &lt;code&gt;filename&lt;/code&gt; is implementation-defined, and does not necessarily refer to a file (e.g. it may be the console or another device accessible through filesystem API). On platforms that support them, &lt;code&gt;filename&lt;/code&gt; may include absolute or relative filesystem path.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; 的格式是实现定义的，不一定引用文件（例如，它可以是控制台或可通过文件系统API访问的其他设备）。在支持它们的平台上， &lt;code&gt;filename&lt;/code&gt; 可能包含绝对或相对文件系统路径。</target>
        </trans-unit>
        <trans-unit id="19e13fb520e9b9f29460d58a00f41c09337dc08f" translate="yes" xml:space="preserve">
          <source>The format of floating-point values is as follows:</source>
          <target state="translated">浮点值的格式如下。</target>
        </trans-unit>
        <trans-unit id="a0add987dacb96215da068df8fc467e3a8d4b58c" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtof&quot;&gt;&lt;code&gt;strtof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数字的格式与&lt;a href=&quot;../../string/byte/strtof&quot;&gt; &lt;code&gt;strtof()&lt;/code&gt; &lt;/a&gt;期望的格式相同。</target>
        </trans-unit>
        <trans-unit id="c7a581065d0c8c103e51ec546cb2d29946e0e282" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数的格式是如预期由相同的&lt;a href=&quot;../../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt;具有值 &lt;code&gt;10&lt;/code&gt; 的 &lt;code&gt;base&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="de50d9c89fd0c551d172e90d35e19763d28aebed" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtol&quot;&gt;&lt;code&gt;strtol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">数的格式是如预期由相同的&lt;a href=&quot;../../string/byte/strtol&quot;&gt; &lt;code&gt;strtol()&lt;/code&gt; &lt;/a&gt;具有值 &lt;code&gt;​0​&lt;/code&gt; 的 &lt;code&gt;base&lt;/code&gt; 参数（基部由解析的第一字符确定）。</target>
        </trans-unit>
        <trans-unit id="f009580f6110aee4f2a9398c68d1bf94787198b5" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数的格式是如预期由相同的&lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt;具有值 &lt;code&gt;10&lt;/code&gt; 的 &lt;code&gt;base&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="48ec45a6a03f7559d556421a2a44ac148d321b20" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数的格式是如预期由相同的&lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt;具有值 &lt;code&gt;16&lt;/code&gt; 的 &lt;code&gt;base&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="bb05ad1877111e85c5dfa1d9f5bf199cff8a0c43" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/byte/strtoul&quot;&gt;&lt;code&gt;strtoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数的格式是如预期由相同的&lt;a href=&quot;../../string/byte/strtoul&quot;&gt; &lt;code&gt;strtoul()&lt;/code&gt; &lt;/a&gt;具有值 &lt;code&gt;8&lt;/code&gt; 为 &lt;code&gt;base&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="f5976eb1d0b6e29b5c32d55d187559f6ff886126" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstof&quot;&gt;&lt;code&gt;wcstof()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">数字的格式与&lt;a href=&quot;../../string/wide/wcstof&quot;&gt; &lt;code&gt;wcstof()&lt;/code&gt; &lt;/a&gt;期望的格式相同。</target>
        </trans-unit>
        <trans-unit id="fecd04092122729704233da78da7584029c1baf0" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数的格式是如预期由相同的&lt;a href=&quot;../../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt;具有值 &lt;code&gt;10&lt;/code&gt; 的 &lt;code&gt;base&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="5bb104d61d7e8e7ed04a16c3daae6cd68cca3601" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstol&quot;&gt;&lt;code&gt;wcstol()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;​0​&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument (base is determined by the first characters parsed).</source>
          <target state="translated">数的格式是如预期由相同的&lt;a href=&quot;../../string/wide/wcstol&quot;&gt; &lt;code&gt;wcstol()&lt;/code&gt; &lt;/a&gt;具有值 &lt;code&gt;​0​&lt;/code&gt; 的 &lt;code&gt;base&lt;/code&gt; 参数（基部由解析的第一字符确定）。</target>
        </trans-unit>
        <trans-unit id="90f5746e8bc2a7796c8836cbdbee3ca457ca3f47" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;10&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数的格式是如预期由相同的&lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt;具有值 &lt;code&gt;10&lt;/code&gt; 的 &lt;code&gt;base&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="c174dea8f8ac6d3123fee439903c3ea47dd4f027" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;16&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数的格式是如预期由相同的&lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt;具有值 &lt;code&gt;16&lt;/code&gt; 的 &lt;code&gt;base&lt;/code&gt; 参数。</target>
        </trans-unit>
        <trans-unit id="f5eb1aae953e6c6c5362653e5973307871541db0" translate="yes" xml:space="preserve">
          <source>The format of the number is the same as expected by &lt;a href=&quot;../../string/wide/wcstoul&quot;&gt;&lt;code&gt;wcstoul()&lt;/code&gt;&lt;/a&gt; with the value &lt;code&gt;8&lt;/code&gt; for the &lt;code&gt;base&lt;/code&gt; argument.</source>
          <target state="translated">数的格式是如预期由相同的&lt;a href=&quot;../../string/wide/wcstoul&quot;&gt; &lt;code&gt;wcstoul()&lt;/code&gt; &lt;/a&gt;具有值 &lt;code&gt;8&lt;/code&gt; 为 &lt;code&gt;base&lt;/code&gt; 的参数。</target>
        </trans-unit>
        <trans-unit id="3d9e18bdb76f0cfc72cfc7220ca845cba830ae2b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary multibyte characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="translated">格式字符串由普通的多字节字符（ &lt;code&gt;%&lt;/code&gt; 除外）组成，这些字符未更改地复制到输出流中，并包含转换说明。每个转换规范具有以下格式：</target>
        </trans-unit>
        <trans-unit id="978f5198d804b9a4148d59f23d49bd19f235af7b" translate="yes" xml:space="preserve">
          <source>The format string consists of ordinary wide characters (except &lt;code&gt;%&lt;/code&gt;), which are copied unchanged into the output stream, and conversion specifications. Each conversion specification has the following format:</source>
          <target state="translated">格式字符串由普通的宽字符（ &lt;code&gt;%&lt;/code&gt; 除外）组成，这些宽字符会原样复制到输出流和转换规范中。每个转换规范具有以下格式：</target>
        </trans-unit>
        <trans-unit id="77ae2a1ebbf9dfc51f6f5d5f89c9ab7a18fe650c" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). All ordinary characters, including the terminating null character, are copied to the output string without modification. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The following format specifiers are available:</source>
          <target state="translated">格式字符串由零个或多个转换说明符和普通字符（ &lt;code&gt;%&lt;/code&gt; 除外）组成。所有普通字符（包括结尾的空字符）都将被复制到输出字符串，而无需进行任何修改。每个转换规范都以 &lt;code&gt;%&lt;/code&gt; 字符开头，可以选择后面跟随 &lt;code&gt;E&lt;/code&gt; 或 &lt;code&gt;O&lt;/code&gt; 修饰符（如果不受语言环境支持，则忽略），后跟确定该规范行为的字符。可以使用以下格式说明符：</target>
        </trans-unit>
        <trans-unit id="f2ac326d01048c042fad765ae54487eb3b38a164" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters. All ordinary characters, excluding the terminating null character, are written into the output stream without modification. Each unmodified conversion specifier begins with a &lt;code&gt;%&lt;/code&gt; character followed by a character that determines the behavior of the specifier. Some conversion specifiers have a modified form in which an &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier character is inserted after the &lt;code&gt;%&lt;/code&gt; character. Each conversion specifier is replaced by appropriate characters in the output as described below.</source>
          <target state="translated">格式字符串由零个或多个转换说明符和普通字符组成。除终止空字符外，所有普通字符均无需修改即可写入输出流。每个未修改的转换说明符均以 &lt;code&gt;%&lt;/code&gt; 字符开头，后跟一个确定说明符行为的字符。某些转换说明符具有修改的形式，其中在 &lt;code&gt;%&lt;/code&gt; 字符后插入了 &lt;code&gt;E&lt;/code&gt; 或 &lt;code&gt;O&lt;/code&gt; 修改符。如下所述，每个转换说明符将在输出中被适当的字符替换。</target>
        </trans-unit>
        <trans-unit id="3945cb192e1c3a5530627de4981979e1dedb2322" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers and ordinary characters. Each ordinary character, excluding whitespace characters and the terminating null character, matches one identical character from the input stream, or causes the function to fail if the next character on the stream does not compare equal.</source>
          <target state="translated">格式字符串由零个或多个转换指定符和普通字符组成。每个普通字符,不包括空格字符和终止符空字符,从输入流中匹配一个相同的字符,或者如果流中的下一个字符不比较相等,则导致函数失败。</target>
        </trans-unit>
        <trans-unit id="ae378d353693d1c7d74c4fd94775d83dcaefd506" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers, whitespace characters, and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). Each ordinary character is expected to match one character in the input stream in case-insensitive comparison. Each whitespace character matches arbitrary whitespace in the input string. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The format specifiers match the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime()&lt;/a&gt;:</source>
          <target state="translated">格式字符串由零个或多个转换说明符，空格字符和普通字符（ &lt;code&gt;%&lt;/code&gt; 除外）组成。在不区分大小写的比较中，期望每个普通字符与输入流中的一个字符匹配。每个空格字符都与输入字符串中的任意空格匹配。每个转换规范都以 &lt;code&gt;%&lt;/code&gt; 字符开头，可以选择后面跟随 &lt;code&gt;E&lt;/code&gt; 或 &lt;code&gt;O&lt;/code&gt; 修饰符（如果不受语言环境支持，则忽略），后跟确定该规范行为的字符。格式说明符与POSIX函数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime（）&lt;/a&gt;匹配：</target>
        </trans-unit>
        <trans-unit id="27b600c5cf47587815343dd3f9cb052e7b9ecfa5" translate="yes" xml:space="preserve">
          <source>The format string consists of zero or more conversion specifiers, whitespace characters, and ordinary characters (except &lt;code&gt;%&lt;/code&gt;). Each ordinary character is expected to match one character in the input stream in case-insensitive comparison. Each whitespace character matches arbitrary whitespace in the input string. Each conversion specification begins with &lt;code&gt;%&lt;/code&gt; character, optionally followed by &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;O&lt;/code&gt; modifier (ignored if unsupported by the locale), followed by the character that determines the behavior of the specifier. The format specifiers match the POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/strptime.html&quot;&gt;strptime()&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d35574333561b6d7197206a894209f7b4dca21b" translate="yes" xml:space="preserve">
          <source>The format string consists of.</source>
          <target state="translated">该格式字符串包括:</target>
        </trans-unit>
        <trans-unit id="f557203d9607d6c00cf9156c3eb7b68888a42acd" translate="yes" xml:space="preserve">
          <source>The formatting &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; used by this function is always &lt;code&gt;mp.neg_format()&lt;/code&gt;.</source>
          <target state="translated">此函数使用的格式化 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; 始终是 &lt;code&gt;mp.neg_format()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36de08c85d1411e27803f51f67e99c60bb0859a9" translate="yes" xml:space="preserve">
          <source>The friend declaration appears in a &lt;a href=&quot;class&quot;&gt;class body&lt;/a&gt; and grants a function or another class access to private and protected members of the class where the friend declaration appears.</source>
          <target state="translated">朋友声明出现在&lt;a href=&quot;class&quot;&gt;类主体中，&lt;/a&gt;并向出现朋友声明的类的私有和受保护成员授予函数或其他类访问权限。</target>
        </trans-unit>
        <trans-unit id="f1e777bed230647173e4ad51c340e8839794d4c2" translate="yes" xml:space="preserve">
          <source>The full contents of a floating-point exception flag is not necessarily a boolean value indicating whether the exception is raised or cleared. For example, it may be a struct which includes the boolean status and the address of the code that triggered the exception. These functions obtain all such content and obtain/store it in &lt;code&gt;flagp&lt;/code&gt; in implementation-defined format.</source>
          <target state="translated">浮点异常标志的全部内容不一定是指示该异常是引发还是清除的布尔值。例如，它可能是一个结构，其中包含布尔状态和触发异常的代码的地址。这些功能获取所有此类内容，并以实现定义的格式将其获取/存储为 &lt;code&gt;flagp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f3faeb997d1ed337e80e4abb047a6ba3e3e7ebc" translate="yes" xml:space="preserve">
          <source>The full path the directory entry refers to.</source>
          <target state="translated">目录条目所指的完整路径。</target>
        </trans-unit>
        <trans-unit id="3d6b6fb5d314fe36dd9f31283cfc562903b69b1f" translate="yes" xml:space="preserve">
          <source>The function (or member) name specified by &lt;code&gt;E&lt;/code&gt; can be overloaded, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; rules used to decide which overload is to be called.</source>
          <target state="translated">可以重载由 &lt;code&gt;E&lt;/code&gt; 指定的函数（或成员）名称，&lt;a href=&quot;overload_resolution&quot;&gt;重载解析&lt;/a&gt;规则用于确定要调用的重载。</target>
        </trans-unit>
        <trans-unit id="e82b0b07e6f429ee9f9368f05dad9fa0ba43d37a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;TC::now()&lt;/code&gt; does not throw exceptions.</source>
          <target state="translated">函数 &lt;code&gt;TC::now()&lt;/code&gt; 不会引发异常。</target>
        </trans-unit>
        <trans-unit id="0e4cb90e10ef6ef7003e78c1e00b67a01ecdf0f5" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;canonical()&lt;/code&gt; is modeled after the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;realpath&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;canonical()&lt;/code&gt; 函数是在POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;realpath&lt;/a&gt;之后建模的。</target>
        </trans-unit>
        <trans-unit id="a8f8abebb05723f10583ccaaf0c51e54fca3aa87" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;canonical()&lt;/code&gt; is modeled after the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html&quot;&gt;realpath&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83d5158312c85ad69a25e7f6c7b3eb92ed2aac66" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;std::frexp&lt;/code&gt;, together with its dual, &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;std::ldexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">函数 &lt;code&gt;std::frexp&lt;/code&gt; 及其对偶 &lt;code&gt;&lt;a href=&quot;ldexp&quot;&gt;std::ldexp&lt;/a&gt;&lt;/code&gt; 可以用于操作浮点数的表示，而无需直接进行位操作。</target>
        </trans-unit>
        <trans-unit id="7a6d7907ee719b354792f98bec95c1316c2a0690" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;std::ldexp&lt;/code&gt; (&quot;load exponent&quot;), together with its dual, &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt;, can be used to manipulate the representation of a floating-point number without direct bit manipulations.</source>
          <target state="translated">函数 &lt;code&gt;std::ldexp&lt;/code&gt; （&amp;ldquo; load exponent&amp;rdquo;）及其对偶 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; 可以用于操作浮点数的表示，而无需直接进行位操作。</target>
        </trans-unit>
        <trans-unit id="57c5dfaac85f79a223adb7359ed5cef42e000f8a" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;weakly_canonical()&lt;/code&gt; was introduced to simplify operational semantics of &lt;a href=&quot;relative&quot;&gt;&lt;code&gt;relative()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">引入了 &lt;code&gt;weakly_canonical()&lt;/code&gt; 函数以简化&lt;a href=&quot;relative&quot;&gt; &lt;code&gt;relative()&lt;/code&gt; 的&lt;/a&gt;操作语义。</target>
        </trans-unit>
        <trans-unit id="65499eb81228ba91e476f471dc5abca02679437e" translate="yes" xml:space="preserve">
          <source>The function accepts (and does nothing with) the null pointer to reduce the amount of special-casing. Whether allocation succeeds or not, the pointer returned by an allocation function can be passed to &lt;code&gt;std::free&lt;/code&gt;.</source>
          <target state="translated">该函数接受空指针（不执行任何操作）以减少特殊情况。无论分配成功与否，分配函数返回的指针都可以传递给 &lt;code&gt;std::free&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2446536a1064ed7b3941beeb277b791515eaa68b" translate="yes" xml:space="preserve">
          <source>The function body is a &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; (sequence of zero or more statements surrounded by a pair of curly braces), which is executed when the function call is made.</source>
          <target state="translated">函数主体是一个&lt;a href=&quot;statements#Compound_statements&quot;&gt;复合语句&lt;/a&gt;（由一对花括号包围的零个或多个语句的序列），在执行函数调用时执行。</target>
        </trans-unit>
        <trans-unit id="c3d08aba422a7497ce575560818de2b5e3664ee2" translate="yes" xml:space="preserve">
          <source>The function call expressions have the form.</source>
          <target state="translated">函数调用表达式的形式。</target>
        </trans-unit>
        <trans-unit id="ef5f5323e424bfd7a1f80cd467bc80719cc4bc17" translate="yes" xml:space="preserve">
          <source>The function called by a user-defined literal is known as</source>
          <target state="translated">用户定义的文字所调用的函数称为</target>
        </trans-unit>
        <trans-unit id="21d35ce53dec97b605e35fbf4bfeaf3e6b25267e" translate="yes" xml:space="preserve">
          <source>The function calls &lt;code&gt;&lt;a href=&quot;sbumpc&quot;&gt;sbumpc()&lt;/a&gt;&lt;/code&gt; to advance the input sequence. If that function returns &lt;code&gt;Traits::eof()&lt;/code&gt; meaning that input sequence has been exhausted and &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; could not retrieve more data, &lt;code&gt;Traits::eof()&lt;/code&gt; is returned. Otherwise &lt;code&gt;&lt;a href=&quot;sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; is called in order to read the character.</source>
          <target state="translated">该函数调用 &lt;code&gt;&lt;a href=&quot;sbumpc&quot;&gt;sbumpc()&lt;/a&gt;&lt;/code&gt; 来推进输入序列。如果该函数返回 &lt;code&gt;Traits::eof()&lt;/code&gt; 表示输入序列已用尽，并且 &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; 无法检索更多数据，则返回 &lt;code&gt;Traits::eof()&lt;/code&gt; 。否则，将调用 &lt;code&gt;&lt;a href=&quot;sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; 以便读取字符。</target>
        </trans-unit>
        <trans-unit id="e8f1319f9d6ef5782692a77b9fd4057196ea681b" translate="yes" xml:space="preserve">
          <source>The function can be implemented with the return type different from &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. In this case, the replacement type has the following properties:</source>
          <target state="translated">该函数可以使用与 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 不同的返回类型来实现。在这种情况下，替换类型具有以下属性：</target>
        </trans-unit>
        <trans-unit id="c822a40a4534bfa3e5439e5ab35928c6a3a344b3" translate="yes" xml:space="preserve">
          <source>The function can be used only if &lt;code&gt;operator&amp;lt;&lt;/code&gt; is defined for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">仅当类型 &lt;code&gt;T&lt;/code&gt; 定义了 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 才能使用该函数。</target>
        </trans-unit>
        <trans-unit id="882d329b93dcad39ff502adfce6844369dd33e8b" translate="yes" xml:space="preserve">
          <source>The function can be used only if &lt;code&gt;operator+=&lt;/code&gt; is defined for type &lt;code&gt;T&lt;/code&gt;. If the &lt;code&gt;std::valarray&lt;/code&gt; is empty, the behavior is undefined. The order in which the elements are processed by this function is unspecified.</source>
          <target state="translated">仅当类型 &lt;code&gt;T&lt;/code&gt; 定义了 &lt;code&gt;operator+=&lt;/code&gt; 时,才能使用该函数。如果 &lt;code&gt;std::valarray&lt;/code&gt; 为空，则行为未定义。未指定此功能处理元素的顺序。</target>
        </trans-unit>
        <trans-unit id="91f7fe88eabe258e81ae01d0f690791e30dabd0d" translate="yes" xml:space="preserve">
          <source>The function does not participate in overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;ToDuration&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; chrono :: duration的实例，否则该函数不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="b0d7738f85da6ab4917bf056d0bb5e776378bfa8" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;Rep&amp;gt;::is_signed&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;Rep&amp;gt;::is_signed&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,否则该函数不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="3f53989ed7fe6b85b91be67846d454e5a5091efc" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;ToDuration&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; chrono :: duration和 &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 的实例，否则该函数不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="2bf9d721422f351f851c897408c2ce6f0621c92c" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an instance of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;ToDuration&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; chrono :: duration的实例，否则该函数不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="38127f74fcf3c7345c5f5fdb8dc95f19e70fd613" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an specialization of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;ToDuration&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; chrono :: duration和 &lt;code&gt;&lt;a href=&quot;../treat_as_floating_point&quot;&gt;std::chrono::treat_as_floating_point&lt;/a&gt;&amp;lt;typename ToDuration::rep&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 的特化,否则该函数不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="4dd86d349303d51526c774f537efd9b40b552f98" translate="yes" xml:space="preserve">
          <source>The function does not participate in the overload resolution unless &lt;code&gt;ToDuration&lt;/code&gt; is an specialization of &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;ToDuration&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; chrono :: duration的特殊化，否则该函数不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="126f425397cb45dc94e0836b07e8eefad9995278" translate="yes" xml:space="preserve">
          <source>The function does not support localization, and the newline character cannot be removed.</source>
          <target state="translated">该函数不支持本地化,不能删除换行符。</target>
        </trans-unit>
        <trans-unit id="072cec0bee6f6155df5b228611698b2538fe2d6d" translate="yes" xml:space="preserve">
          <source>The function does not support localization.</source>
          <target state="translated">该功能不支持本地化。</target>
        </trans-unit>
        <trans-unit id="b9ca2d431e6b4c994632d537c675b64adb91091c" translate="yes" xml:space="preserve">
          <source>The function drops any effects from previous calls to &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">该函数会删除先前对 &lt;code&gt;ungetc&lt;/code&gt; 的调用的所有影响。</target>
        </trans-unit>
        <trans-unit id="23ccd8cd43cb3d597e337e15d54fe5c87828b3ec" translate="yes" xml:space="preserve">
          <source>The function has mathematical poles at &amp;pi;(1/2 + n); however no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">该函数在&amp;pi;（1/2 + n）处具有数学极点；但是，没有通用的浮点表示能够精确地表示&amp;pi;/ 2，因此不存在发生极点误差的参数值。</target>
        </trans-unit>
        <trans-unit id="af880fe541df16b2fd4a74d41e9903882d62887d" translate="yes" xml:space="preserve">
          <source>The function is continuous onto the branch cut taking into account the sign of imaginary part</source>
          <target state="translated">考虑到虚部的符号,函数在支切上是连续的。</target>
        </trans-unit>
        <trans-unit id="064517df7162e7c80b05f70d0c1d72dcf596b5e9" translate="yes" xml:space="preserve">
          <source>The function is equivalent to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt;, except that end-of-file and error indicators are cleared.</source>
          <target state="translated">该功能等效于 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;(stream, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;);&lt;/code&gt; ，但清除了文件结束和错误指示符。</target>
        </trans-unit>
        <trans-unit id="75e35cecac837fab428a324853818b53ded0ac11" translate="yes" xml:space="preserve">
          <source>The function is named after the integer function ⍳ from the programming language APL. It was one of the &lt;a href=&quot;http://www.sgi.com/tech/stl/iota.html&quot;&gt;STL components&lt;/a&gt; that were not included in C++98, but eventually made it into the standard library in C++11.</source>
          <target state="translated">该函数以编程语言APL中的整数函数named命名。它是C ++ 98中未包含的&lt;a href=&quot;http://www.sgi.com/tech/stl/iota.html&quot;&gt;STL组件&lt;/a&gt;之一，但最终使其成为C ++ 11中的标准库。</target>
        </trans-unit>
        <trans-unit id="fe1dff5e844a0cf75859a0d38601b66527b350d8" translate="yes" xml:space="preserve">
          <source>The function is named after the integer function ⍳ from the programming language APL. It was one of the &lt;a href=&quot;https://www.sgi.com/tech/stl/iota.html&quot;&gt;STL components&lt;/a&gt; that were not included in C++98, but eventually made it into the standard library in C++11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9eb4c7699e43ce8f08f56257eff79ffdcf27b49" translate="yes" xml:space="preserve">
          <source>The function is not required to be defined for |x|&amp;gt;1</source>
          <target state="translated">| x |&amp;gt; 1不需要定义该函数</target>
        </trans-unit>
        <trans-unit id="b0d406efcda5923258fa6e7ba435edf7afdbb66b" translate="yes" xml:space="preserve">
          <source>The function is only required to be defined where both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are greater than zero, and is allowed to report a domain error otherwise.</source>
          <target state="translated">仅在 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 都大于零的情况下才需要定义该函数，否则将允许报告域错误。</target>
        </trans-unit>
        <trans-unit id="6034c35371ebcc562e4d00c27057a576e4fdd7db" translate="yes" xml:space="preserve">
          <source>The function may update &lt;code&gt;gptr&lt;/code&gt;, &lt;code&gt;egptr&lt;/code&gt; and &lt;code&gt;eback&lt;/code&gt; pointers to define the location of newly loaded data (if any). On failure, the function ensures that either &lt;code&gt;gptr() == nullptr&lt;/code&gt; or &lt;code&gt;gptr() == egptr&lt;/code&gt;.</source>
          <target state="translated">该函数可以更新 &lt;code&gt;gptr&lt;/code&gt; ， &lt;code&gt;egptr&lt;/code&gt; 和 &lt;code&gt;eback&lt;/code&gt; 指针以定义新加载的数据（如果有）的位置。失败时，该函数可确保 &lt;code&gt;gptr() == nullptr&lt;/code&gt; 或 &lt;code&gt;gptr() == egptr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e7a7a46183956d552300dee684d15128ebe48ebf" translate="yes" xml:space="preserve">
          <source>The function may update &lt;code&gt;pptr&lt;/code&gt;, &lt;code&gt;epptr&lt;/code&gt; and &lt;code&gt;pbase&lt;/code&gt; pointers to define the location to write more data. On failure, the function ensures that either &lt;code&gt;pptr() == nullptr&lt;/code&gt; or &lt;code&gt;pptr() == epptr&lt;/code&gt;.</source>
          <target state="translated">该功能可以更新 &lt;code&gt;pptr&lt;/code&gt; ， &lt;code&gt;epptr&lt;/code&gt; 和 &lt;code&gt;pbase&lt;/code&gt; 指针来定义位置写入更多的数据。失败时，该函数确保 &lt;code&gt;pptr() == nullptr&lt;/code&gt; 或 &lt;code&gt;pptr() == epptr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15af0ce237ff3b3144c6a868b8ee125006a14e71" translate="yes" xml:space="preserve">
          <source>The function modifies static storage and is not thread-safe.</source>
          <target state="translated">该函数修改静态存储,并且不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="ab3db171e79e2989a832c6ee9c99d6df12884a1d" translate="yes" xml:space="preserve">
          <source>The function modifies the pointer only if it would be possible to fit the wanted number of bytes aligned by the given alignment into the buffer. If the buffer is too small, the function does nothing and returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">该函数仅在可能将通过给定对齐方式对齐的所需字节数适合到缓冲区中时修改指针。如果缓冲区太小，则该函数不执行任何操作并返回 &lt;code&gt;nullptr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc27df1dece75c7950d8306c4124d7ab25b1a17f" translate="yes" xml:space="preserve">
          <source>The function must not modify the objects passed to it and must return consistent results when called for the same objects, regardless of their positions in the array.</source>
          <target state="translated">该函数不得修改传递给它的对象,并且当调用相同的对象时,无论它们在数组中的位置如何,都必须返回一致的结果。</target>
        </trans-unit>
        <trans-unit id="6f186c1fa81fe391780ded04d401cc94118bdba5" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;complementary span&quot;</source>
          <target state="translated">该函数名称代表 &quot;互补跨度&quot;</target>
        </trans-unit>
        <trans-unit id="db20681f76479d1a2df4829db6ccf4a0a080e0ef" translate="yes" xml:space="preserve">
          <source>The function name stands for &quot;new scalb&quot;, where &lt;code&gt;scalb&lt;/code&gt; was an older non-standard function whose second argument had floating-point type.</source>
          <target state="translated">函数名称代表&amp;ldquo; new scalb&amp;rdquo;，其中 &lt;code&gt;scalb&lt;/code&gt; 是较旧的非标准函数，其第二个参数为浮点类型。</target>
        </trans-unit>
        <trans-unit id="c9dcfedf49fa204154f0431b2673a0daebcd06a5" translate="yes" xml:space="preserve">
          <source>The function object &lt;code&gt;pred&lt;/code&gt; shall not apply any non-constant function through the dereferenced iterator. This function object may be a pointer to function or an object of a type with an appropriate function call operator.</source>
          <target state="translated">函数对象 &lt;code&gt;pred&lt;/code&gt; 不应通过取消引用的迭代器应用任何非恒定函数。该函数对象可以是指向函数的指针或具有适当函数调用运算符的类型的对象。</target>
        </trans-unit>
        <trans-unit id="fec4de0270a6f3097d68f50b43e7edfb64e10dc9" translate="yes" xml:space="preserve">
          <source>The function parameters that do not participate in template argument deduction (e.g. if the corresponding template arguments are explicitly specified) are subject to implicit conversions to the type of the corresponding function parameter (as in the usual &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;).</source>
          <target state="translated">不参与模板自变量推导的函数参数（例如，如果显式指定了相应的模板自变量）将进行隐式转换为相应函数参数的类型（如通常的&lt;a href=&quot;overload_resolution&quot;&gt;重载解析一样&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="7eeb93d2b7dca68685dc425373a6764fb01e3729" translate="yes" xml:space="preserve">
          <source>The function provides no means to prevent buffer overflow of the destination array, given sufficiently long input string. &lt;code&gt;std::gets&lt;/code&gt; was deprecated in C++11 and removed from C++14.</source>
          <target state="translated">给定足够长的输入字符串，该函数没有提供任何方法来防止目标数组的缓冲区溢出。 &lt;code&gt;std::gets&lt;/code&gt; 在C ++ 11中已弃用，并从C ++ 14中删除。</target>
        </trans-unit>
        <trans-unit id="fa9dad8347dfb2e0d670a4af83e853b0527c897a" translate="yes" xml:space="preserve">
          <source>The function template &lt;code&gt;bind&lt;/code&gt; generates a forwarding call wrapper for &lt;code&gt;f&lt;/code&gt;. Calling this wrapper is equivalent to invoking &lt;code&gt;f&lt;/code&gt; with some of its arguments bound to &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">函数模板 &lt;code&gt;bind&lt;/code&gt; 为 &lt;code&gt;f&lt;/code&gt; 生成转发调用包装。调用此包装程序等效于将 &lt;code&gt;f&lt;/code&gt; 的某些参数绑定到 &lt;code&gt;args&lt;/code&gt; 来调用f。</target>
        </trans-unit>
        <trans-unit id="1b74686fedbb22b834206589460eadd916d0aa6c" translate="yes" xml:space="preserve">
          <source>The function template &lt;code&gt;bind_front&lt;/code&gt; generates a forwarding call wrapper for &lt;code&gt;f&lt;/code&gt;. Calling this wrapper is equivalent to invoking &lt;code&gt;f&lt;/code&gt; with its first &lt;code&gt;sizeof...(Args)&lt;/code&gt; parameters bound to &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">函数模板 &lt;code&gt;bind_front&lt;/code&gt; 为 &lt;code&gt;f&lt;/code&gt; 生成转发调用包装。调用此包装程序等效于将 &lt;code&gt;f&lt;/code&gt; 的第一个 &lt;code&gt;sizeof...(Args)&lt;/code&gt; 参数绑定到 &lt;code&gt;args&lt;/code&gt; 来调用f。</target>
        </trans-unit>
        <trans-unit id="a42b57be9690e30b4d127d5c56b2e136867973a2" translate="yes" xml:space="preserve">
          <source>The function templates #1 and #3 have different signatures and are distinct templates. Nonetheless, #2 and #4, despite being instantiations of different function templates, have the same mangled name &lt;a href=&quot;https://github.com/itanium-cxx-abi/cxx-abi/issues/20&quot;&gt;in the Itanium C++ ABI&lt;/a&gt; (&lt;code&gt;_Z4funcI1XLi0EEvv&lt;/code&gt;), meaning that the linker will erroneously consider them to be the same entity.</source>
          <target state="translated">功能模板＃1和＃3具有不同的签名，并且是不同的模板。尽管如此，＃2和＃4尽管是不同功能模板的实例，但&lt;a href=&quot;https://github.com/itanium-cxx-abi/cxx-abi/issues/20&quot;&gt;在Itanium C ++ ABI中&lt;/a&gt;具有相同的名称（ &lt;code&gt;_Z4funcI1XLi0EEvv&lt;/code&gt; ），这意味着链接器会错误地将它们视为同一实体。</target>
        </trans-unit>
        <trans-unit id="1661ab084a02d0a0b4022e49867df5380e8a9ad8" translate="yes" xml:space="preserve">
          <source>The function templates are then ranked as if for &lt;a href=&quot;function_template#Function_template_overloading&quot;&gt;function template overloading&lt;/a&gt;.</source>
          <target state="translated">然后对功能模板进行排名，就好像&lt;a href=&quot;function_template#Function_template_overloading&quot;&gt;功能模板重载一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c3559ff21a7ec0a87fd87249ee0c6ee1ced4a14" translate="yes" xml:space="preserve">
          <source>The function then returns the pointer to the beginning of the token</source>
          <target state="translated">然后函数返回指向token开头的指针。</target>
        </trans-unit>
        <trans-unit id="4126da2324b4eb270d68c514e43af8301f52dd63" translate="yes" xml:space="preserve">
          <source>The function to calculate the result has not been started yet</source>
          <target state="translated">计算结果的函数尚未启动。</target>
        </trans-unit>
        <trans-unit id="eb957ebe7149eefbfbfc9fa1905a6cdb297d02f9" translate="yes" xml:space="preserve">
          <source>The function type of the function template is &lt;code&gt;P&lt;/code&gt;. The &lt;a href=&quot;overloaded_address&quot;&gt;target type&lt;/a&gt; is the type of &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">函数模板的功能类型为 &lt;code&gt;P&lt;/code&gt; 。的&lt;a href=&quot;overloaded_address&quot;&gt;目标类型&lt;/a&gt;是类型 &lt;code&gt;A&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d62041d0f93824e7e4927764fa5aa1df2523bc0c" translate="yes" xml:space="preserve">
          <source>The function-call operator is always &lt;code&gt;constexpr&lt;/code&gt; if it satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr function&lt;/a&gt;. It is also constexpr if the keyword constexpr was used in the lambda declaration.</source>
          <target state="translated">该函数调用运营商始终是 &lt;code&gt;constexpr&lt;/code&gt; 如果它满足一个要求&lt;a href=&quot;constexpr&quot;&gt;constexpr功能&lt;/a&gt;。如果在lambda声明中使用了关键字constexpr，它也是constexpr。</target>
        </trans-unit>
        <trans-unit id="90237372df253176f7201dadf305ca2efdb82ba0" translate="yes" xml:space="preserve">
          <source>The function-call operator is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the keyword &lt;code&gt;consteval&lt;/code&gt; was used in the lambda expression.</source>
          <target state="translated">如果在lambda表达式中使用关键字 &lt;code&gt;consteval&lt;/code&gt; ,则函数调用运算符为&lt;a href=&quot;consteval&quot;&gt;立即函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="18222cb267ac69f3312ca400b95bb5960956fbce" translate="yes" xml:space="preserve">
          <source>The function-call operators of T are obtained by ordinary &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt; of the name &lt;code&gt;operator()&lt;/code&gt; in the context of the expression &lt;code&gt;(E).operator()&lt;/code&gt;, and every declaration found is added to the set of candidate functions.</source>
          <target state="translated">T的函数调用运算符是通过在表达式 &lt;code&gt;(E).operator()&lt;/code&gt; 的上下文中对名称 &lt;code&gt;operator()&lt;/code&gt; 的常规&lt;a href=&quot;lookup&quot;&gt;查找&lt;/a&gt;而获得的，并将找到的每个声明添加到候选函数集。</target>
        </trans-unit>
        <trans-unit id="5f03f8854c3dadb42ebc1a2f13e6f98271799bab" translate="yes" xml:space="preserve">
          <source>The function-like entities described on this page are</source>
          <target state="translated">本页描述的类功能实体是</target>
        </trans-unit>
        <trans-unit id="c90c3720bc6cd842ff45d50c455cbeb05ef64826" translate="yes" xml:space="preserve">
          <source>The function-try-block is one of the alternative syntax forms for function-body, which is a part of &lt;a href=&quot;function&quot;&gt;function definition&lt;/a&gt;.</source>
          <target state="translated">function-try-block是function-body的替代语法形式之一，它是&lt;a href=&quot;function&quot;&gt;function定义&lt;/a&gt;的一部分。</target>
        </trans-unit>
        <trans-unit id="7d70566d5bc405ba10ba5bb68262596374bff760" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;std::expm1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;std::log1p&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">函数 &lt;code&gt;&lt;a href=&quot;expm1&quot;&gt;std::expm1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;std::log1p&lt;/code&gt; 可用于财务计算，例如，在计算较小的每日利率时：（1 + x）n</target>
        </trans-unit>
        <trans-unit id="ce063565abd09222888790e9a9d67e9d39a935ae" translate="yes" xml:space="preserve">
          <source>The functions &lt;code&gt;std::expm1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;std::log1p&lt;/a&gt;&lt;/code&gt; are useful for financial calculations, for example, when calculating small daily interest rates: (1+x)n</source>
          <target state="translated">函数 &lt;code&gt;std::expm1&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;log1p&quot;&gt;std::log1p&lt;/a&gt;&lt;/code&gt; 可用于财务计算，例如，在计算较小的每日利率时：（1 + x）n</target>
        </trans-unit>
        <trans-unit id="7d057934f5d91a8d0d5efe334eb2fd28c09a314a" translate="yes" xml:space="preserve">
          <source>The functions may be called concurrently with the destruction of the objects with static storage duration and with each other, maintaining the guarantee that if registration of A was sequenced-before the registration of B, then the call to B is sequenced-before the call to A, same applies to the sequencing between static object constructors and calls to &lt;code&gt;atexit&lt;/code&gt;: see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可以在销毁具有静态存储持续时间的对象的同时以及彼此销毁这些函数，并保持这样的保证：如果在A的注册之前对A的注册进行了排序，则在对B的调用之​​前对B的调用进行了排序。 A，同样适用于静态对象构造函数与对 &lt;code&gt;atexit&lt;/code&gt; 的调用之间的排序：请参见 &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3db16cc57db5dbc928e64b1b6ac3975c579a8b6a" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">该函数将 &lt;code&gt;endptr&lt;/code&gt; 指向的指针设置为指向最后解释的字符之后的字符。如果 &lt;code&gt;endptr&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="79e95f56658767e1e470d9215d4b6600bf8174e3" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;endptr&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;endptr&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">该函数将 &lt;code&gt;endptr&lt;/code&gt; 指向的指针设置为指向最后解释的字符之后的宽字符。如果 &lt;code&gt;endptr&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="69ad6824d6f8c048fddeb1809adb4e0dadf9dc71" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">该函数将 &lt;code&gt;str_end&lt;/code&gt; 指向的指针设置为指向最后解释的字符之后的字符。如果 &lt;code&gt;str_end&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="9c7ec7a3aab98e1d97256af5eb3cd5dd8ac9ef4b" translate="yes" xml:space="preserve">
          <source>The functions sets the pointer pointed to by &lt;code&gt;str_end&lt;/code&gt; to point to the wide character past the last character interpreted. If &lt;code&gt;str_end&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, it is ignored.</source>
          <target state="translated">该函数将 &lt;code&gt;str_end&lt;/code&gt; 指向的指针设置为指向最后解释的字符之后的宽字符。如果 &lt;code&gt;str_end&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ，则将其忽略。</target>
        </trans-unit>
        <trans-unit id="f29db516e7cae858024d84b5b0bd244f31b9db50" translate="yes" xml:space="preserve">
          <source>The functions that accept rvalue reference parameters (including &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt;, &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt;, and regular member functions such as &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt;) are selected, by &lt;a href=&quot;../language/overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, when called with &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; arguments (either &lt;a href=&quot;../language/value_category&quot;&gt;prvalues&lt;/a&gt; such as a temporary objects or &lt;a href=&quot;../language/value_category&quot;&gt;xvalues&lt;/a&gt; such as the one produced by &lt;code&gt;std::move&lt;/code&gt;). If the argument identifies a resource-owning object, these overloads have the option, but aren't required, to</source>
          <target state="translated">当使用&lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt;参数（两个&lt;a href=&quot;../language/value_category&quot;&gt;prvalues，&lt;/a&gt;例如临时对象）调用时，通过&lt;a href=&quot;../language/overload_resolution&quot;&gt;重载解析&lt;/a&gt;来选择接受rvalue参考参数的函数（包括&lt;a href=&quot;../language/move_constructor&quot;&gt;move构造函数&lt;/a&gt;，&lt;a href=&quot;../language/move_operator&quot;&gt;move赋值运算符&lt;/a&gt;和常规成员函数，例如 &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt; ）。或&lt;a href=&quot;../language/value_category&quot;&gt;xvalue，&lt;/a&gt;例如 &lt;code&gt;std::move&lt;/code&gt; 产生的值）。如果自变量标识资源拥有对象，则这些重载可以选择（但不是必需）以：</target>
        </trans-unit>
        <trans-unit id="e09608bd7873c020fdfa17e45a1cb9324cfb8735" translate="yes" xml:space="preserve">
          <source>The functions underflow() and overflow()/sync() perform the actual I/O between the file and the get and put areas of the buffer. When &lt;code&gt;CharT&lt;/code&gt; is not &lt;code&gt;char&lt;/code&gt;, most implementations store multibyte characters in the file and a &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet is used to perform wide/multibyte character conversion.</source>
          <target state="translated">函数underflow（）和overflow（）/ sync（）在文件与缓冲区的获取和放置区域之间执行实际的I / O。当 &lt;code&gt;CharT&lt;/code&gt; 不是 &lt;code&gt;char&lt;/code&gt; 时，大多数实现将多字节字符存储在文件中，并且 &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 构面用于执行宽/多字节字符转换。</target>
        </trans-unit>
        <trans-unit id="bffe0d58cdd89a2176e51e07265897958db537f6" translate="yes" xml:space="preserve">
          <source>The functions will be called during the destruction of the static objects, in reverse order: if A was registered before B, then the call to B is made before the call to A. Same applies to the ordering between static object constructors and the calls to &lt;code&gt;atexit&lt;/code&gt;: see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些函数将在销毁静态对象的过程中以相反的顺序被调用：如果A在B之前注册，则对B的调用在对A的调用之前进行。这同样适用于静态对象构造函数与对B的调用之​​间的排序。 &lt;code&gt;atexit&lt;/code&gt; ：请参阅 &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aed96e855f7e3173d3f85e69b959cd5f429e28d2" translate="yes" xml:space="preserve">
          <source>The generated random number.</source>
          <target state="translated">生成的随机数。</target>
        </trans-unit>
        <trans-unit id="7e36dee47d5123274fbbdd384f8394bc9448d978" translate="yes" xml:space="preserve">
          <source>The generation of the implicitly-defined copy assignment operator is deprecated(since C++11) if &lt;code&gt;T&lt;/code&gt; has a user-declared destructor or user-declared copy constructor.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 具有用户声明的析构函数或用户声明的副本构造函数，则不建议使用隐式定义的副本分配运算符的生成（自C ++ 11起）。</target>
        </trans-unit>
        <trans-unit id="9e1eed93866aa0d0e35d2a62d35e689f1a41f754" translate="yes" xml:space="preserve">
          <source>The generation of the implicitly-defined copy constructor is deprecated if &lt;code&gt;T&lt;/code&gt; has a user-defined destructor or user-defined copy assignment operator.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 具有用户定义的析构函数或用户定义的副本分配运算符，则不建议使用隐式定义的副本构造函数的生成。</target>
        </trans-unit>
        <trans-unit id="4f4aa88d036bf2efbab8a357c041b989e684ecb4" translate="yes" xml:space="preserve">
          <source>The generic template and two template specializations each contain a single version of &lt;code&gt;get&lt;/code&gt;. The three versions of &lt;code&gt;get&lt;/code&gt; differ only in the return type.</source>
          <target state="translated">通用模板和两个模板专门化每个都包含 &lt;code&gt;get&lt;/code&gt; 的单个版本。 &lt;code&gt;get&lt;/code&gt; 的三个版本仅在返回类型上有所不同。</target>
        </trans-unit>
        <trans-unit id="7aac1cf4d4dcf6d2df58133c2a7081efc8452b18" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cerr&lt;/code&gt; and &lt;code&gt;std::wcerr&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::wstreambuf&lt;/a&gt;&lt;/code&gt;, respectively), associated with the standard C error output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">全局对象 &lt;code&gt;std::cerr&lt;/code&gt; 和 &lt;code&gt;std::wcerr&lt;/code&gt; 控制输出到实现定义类型的流缓冲区（分别从 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::wstreambuf&lt;/a&gt;&lt;/code&gt; ），该缓冲区与标准C错误输出流 &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="4cdce0c44ee46c553e1a9e5502ff67dca5ca8589" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cin&lt;/code&gt; and &lt;code&gt;std::wcin&lt;/code&gt; control input from a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C input stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">全局对象 &lt;code&gt;std::cin&lt;/code&gt; 和 &lt;code&gt;std::wcin&lt;/code&gt; 控制来自实现定义类型的流缓冲区（从 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 派生）的输入，该缓冲区与标准C输入流 &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 关联。</target>
        </trans-unit>
        <trans-unit id="461aa84897b843038a6471036df9b6bfd2e5db28" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::clog&lt;/code&gt; and &lt;code&gt;std::wclog&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;, but, unlike &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt;, these streams are not automatically flushed and not automatically tie()'d with cout.</source>
          <target state="translated">全局对象 &lt;code&gt;std::clog&lt;/code&gt; 和 &lt;code&gt;std::wclog&lt;/code&gt; 控制输出到实现定义类型的流缓冲区（源自 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; ），与标准C输出流 &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 关联，但是与 &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; ，这些流不会自动刷新，也不会自动与cout tie（）绑定。</target>
        </trans-unit>
        <trans-unit id="f5f98bba6559b17ed7e6d131e3611a81638ab812" translate="yes" xml:space="preserve">
          <source>The global objects &lt;code&gt;std::cout&lt;/code&gt; and &lt;code&gt;std::wcout&lt;/code&gt; control output to a stream buffer of implementation-defined type (derived from &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;), associated with the standard C output stream &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">全局对象 &lt;code&gt;std::cout&lt;/code&gt; 和 &lt;code&gt;std::wcout&lt;/code&gt; 控制输出到与标准C输出流 &lt;code&gt;&lt;a href=&quot;c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 关联的实现定义类型的流缓冲区（源自 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="70f50373a3f6e5f0380c536e396a13926eb96f45" translate="yes" xml:space="preserve">
          <source>The goto statement transfers control to the location specified by &lt;a href=&quot;statements#Labels&quot;&gt;label&lt;/a&gt;. The goto statement must be in the same function as the label it is referring, it may appear before or after the label.</source>
          <target state="translated">goto语句将控制权转移到&lt;a href=&quot;statements#Labels&quot;&gt;label所&lt;/a&gt;指定的位置。goto语句必须与它所引用的标签具有相同的功能，它可以出现在标签之前或之后。</target>
        </trans-unit>
        <trans-unit id="9203ba2e1b9acd8459fc296135b185d6bdec6014" translate="yes" xml:space="preserve">
          <source>The groups are stored as binary values: three-digit group is &lt;code&gt;'\3'&lt;/code&gt;, and 51-digit group is &lt;code&gt;'3'&lt;/code&gt;. The character at index zero of the returned string holds the number of digits in the rightmost group. The character at index 1 holds the number of digits in the second group from the right, etc. The grouping indicated by the last character in the returned string is reused to group all remaining digits in the (left part of) the number.</source>
          <target state="translated">这些组存储为二进制值：三位数字组为 &lt;code&gt;'\3'&lt;/code&gt; ，而51位数字组为 &lt;code&gt;'3'&lt;/code&gt; 。返回字符串的索引零处的字符包含最右边组中的位数。索引1处的字符保存着从右数第二个组中的位数，以此类推。返回字符串中最后一个字符所表示的分组被重新使用，以将数字中剩余的所有剩余位数分组。</target>
        </trans-unit>
        <trans-unit id="377e30e67488234928e5265aef21fdf60f228f58" translate="yes" xml:space="preserve">
          <source>The guarantee that &lt;code&gt;std::from_chars&lt;/code&gt; can recover every floating-point value formatted by &lt;a href=&quot;to_chars&quot;&gt;&lt;code&gt;std::to_chars&lt;/code&gt;&lt;/a&gt; exactly is only provided if both functions are from the same implementation.</source>
          <target state="translated">该担保 &lt;code&gt;std::from_chars&lt;/code&gt; 可以恢复格式化通过每个浮点值&lt;a href=&quot;to_chars&quot;&gt; &lt;code&gt;std::to_chars&lt;/code&gt; &lt;/a&gt;准确，如果两个功能都来自相同的实现只提供。</target>
        </trans-unit>
        <trans-unit id="6a78268c72fa332949b19e97ea94c6bd065b9550" translate="yes" xml:space="preserve">
          <source>The guarantee that &lt;code&gt;std::from_chars&lt;/code&gt; can recover every floating-point value formatted by &lt;code&gt;to_chars&lt;/code&gt; exactly is only provided if both functions are from the same implementation.</source>
          <target state="translated">该保证 &lt;code&gt;std::from_chars&lt;/code&gt; 可以恢复格式化通过每个浮点值 &lt;code&gt;to_chars&lt;/code&gt; 准确，如果两个功能都来自相同的实现只提供。</target>
        </trans-unit>
        <trans-unit id="bb6a61b9c44ca51fc2d67b8e734fd60e0f744ad5" translate="yes" xml:space="preserve">
          <source>The hash code of the associated &lt;code&gt;type_info&lt;/code&gt; object.</source>
          <target state="translated">关联的 &lt;code&gt;type_info&lt;/code&gt; 对象的哈希码。</target>
        </trans-unit>
        <trans-unit id="b862a5e504b0376ea8c84c346ba305c970071424" translate="yes" xml:space="preserve">
          <source>The hash function.</source>
          <target state="translated">哈希函数。</target>
        </trans-unit>
        <trans-unit id="3937832fedbe42cd580633aa32952bacd6b0b437" translate="yes" xml:space="preserve">
          <source>The hash value that respects collation order.</source>
          <target state="translated">尊重整理顺序的哈希值。</target>
        </trans-unit>
        <trans-unit id="e822b844b21e9499cc3d98cbf3f05f1abdf07e6d" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;../header/iterator&quot;&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;&lt;/a&gt; provides a set of concepts and related utility templates designed to ease constraining common algorithm operations.</source>
          <target state="translated">标头&lt;a href=&quot;../header/iterator&quot;&gt; &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; &lt;/a&gt;提供了一组概念和相关实用程序模板，旨在简化约束常见算法的操作。</target>
        </trans-unit>
        <trans-unit id="32774d695cdea646f90e7d021305a854ad71bc9b" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;../header/typeinfo&quot;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt; must be included before using &lt;code&gt;typeid&lt;/code&gt; (if the header is not included, every use of the keyword &lt;code&gt;typeid&lt;/code&gt; makes the program ill-formed.).</source>
          <target state="translated">在使用 &lt;code&gt;typeid&lt;/code&gt; 之前，必须包含标头&lt;a href=&quot;../header/typeinfo&quot;&gt;&amp;lt;typeinfo&amp;gt;&lt;/a&gt;（如果不包含标头，则每次使用关键字 &lt;code&gt;typeid&lt;/code&gt; 都会使程序格式错误。）。</target>
        </trans-unit>
        <trans-unit id="39e45883b37cb57381dea376201d7779a8f05664" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/bit&quot;&gt;&lt;code&gt;&amp;lt;bit&amp;gt;&lt;/code&gt;&lt;/a&gt; provides several function templates to access, manipulate, and process individual bits and bit sequences.</source>
          <target state="translated">头文件&lt;a href=&quot;header/bit&quot;&gt; &lt;code&gt;&amp;lt;bit&amp;gt;&lt;/code&gt; &lt;/a&gt;提供了几个功能模板来访问，操纵和处理各个位和位序列。</target>
        </trans-unit>
        <trans-unit id="c204ad70977b9fc2b727eaecd4f753ba2d1dc617" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cfenv&quot;&gt;&lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt;&lt;/a&gt; defines &lt;a href=&quot;numeric/fenv&quot;&gt;flags and functions related to exceptional floating-point state&lt;/a&gt;, such as overflow and division by zero.</source>
          <target state="translated">标头&lt;a href=&quot;header/cfenv&quot;&gt; &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; &lt;/a&gt;定义&lt;a href=&quot;numeric/fenv&quot;&gt;与异常浮点状态有关的标志和功能&lt;/a&gt;，例如溢出和被零除。</target>
        </trans-unit>
        <trans-unit id="0cbc07e97f0d93b88b9c5ece9e00510e37bf2c6a" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cmath&quot;&gt;&lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;&lt;/a&gt; also provides several mathematical special functions such as &lt;code&gt;&lt;a href=&quot;numeric/special_math/beta&quot;&gt;std::beta&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/special_math/hermite&quot;&gt;std::hermite&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/special_math/cyl_bessel_i&quot;&gt;std::cyl_bessel_i&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标头&lt;a href=&quot;header/cmath&quot;&gt; &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; &lt;/a&gt;还提供了几个数学特殊功能，例如 &lt;code&gt;&lt;a href=&quot;numeric/special_math/beta&quot;&gt;std::beta&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;numeric/special_math/hermite&quot;&gt;std::hermite&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;numeric/special_math/cyl_bessel_i&quot;&gt;std::cyl_bessel_i&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f4dd67444c139abdd3f7b0de3e2b42f5e337403" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/cmath&quot;&gt;&lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt;&lt;/a&gt; provides &lt;a href=&quot;numeric/math&quot;&gt;standard C library mathematical functions&lt;/a&gt; such as &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;std::fabs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标头&lt;a href=&quot;header/cmath&quot;&gt; &lt;code&gt;&amp;lt;cmath&amp;gt;&lt;/code&gt; &lt;/a&gt;提供&lt;a href=&quot;numeric/math&quot;&gt;标准的C库数学函数，&lt;/a&gt;例如 &lt;code&gt;&lt;a href=&quot;numeric/math/fabs&quot;&gt;std::fabs&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;numeric/math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;numeric/math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="743b06117d162324a98c31415f3c294f57b66ed9" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/iterator&quot;&gt;&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;&lt;/a&gt; provides a set of concepts and related utilities designed to ease constraining common algorithm operations.</source>
          <target state="translated">标头&lt;a href=&quot;header/iterator&quot;&gt; &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; &lt;/a&gt;提供了一组概念和相关实用程序，旨在减轻对常见算法操作的约束。</target>
        </trans-unit>
        <trans-unit id="508d20b6cea54c392d295d11726346c65aa4b0b3" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/numeric&quot;&gt;&lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt;&lt;/a&gt; provides numeric algorithms below:</source>
          <target state="translated">标头&lt;a href=&quot;header/numeric&quot;&gt; &lt;code&gt;&amp;lt;numeric&amp;gt;&lt;/code&gt; &lt;/a&gt;提供以下数字算法：</target>
        </trans-unit>
        <trans-unit id="ba440bf8e1f8c37da5221f67c871d6fb13769ff0" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/random&quot;&gt;&lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt;&lt;/a&gt; defines &lt;a href=&quot;numeric/random&quot;&gt;pseudo-random number generators and numerical distributions&lt;/a&gt;. The header &lt;a href=&quot;header/cstdlib&quot;&gt;&lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt;&lt;/a&gt; also includes C-style random number generation via &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;std::srand&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标头&lt;a href=&quot;header/random&quot;&gt; &lt;code&gt;&amp;lt;random&amp;gt;&lt;/code&gt; &lt;/a&gt;定义&lt;a href=&quot;numeric/random&quot;&gt;伪随机数生成器和数值分布&lt;/a&gt;。标头&lt;a href=&quot;header/cstdlib&quot;&gt; &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; &lt;/a&gt;还包括通过 &lt;code&gt;&lt;a href=&quot;numeric/random/srand&quot;&gt;std::srand&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; 生成C样式的随机数。</target>
        </trans-unit>
        <trans-unit id="dd8e217a3115bdf6060d0de317017567a06a41d7" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/ratio&quot;&gt;&lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt;&lt;/a&gt; provides &lt;a href=&quot;numeric/ratio&quot;&gt;types and functions for manipulating and storing compile-time ratios&lt;/a&gt;.</source>
          <target state="translated">头文件&lt;a href=&quot;header/ratio&quot;&gt; &lt;code&gt;&amp;lt;ratio&amp;gt;&lt;/code&gt; &lt;/a&gt;提供&lt;a href=&quot;numeric/ratio&quot;&gt;用于操纵和存储编译时比率的类型和函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="218920ec6c8d077db4c2f0630d45c58c68f68e0c" translate="yes" xml:space="preserve">
          <source>The header &lt;a href=&quot;header/version&quot;&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/a&gt; supplies implementation-dependent information about the C++ standard library (such as the version number and release date. It also defines the &lt;a href=&quot;utility/feature_test&quot;&gt;library feature-test macros&lt;/a&gt;.</source>
          <target state="translated">标头&lt;a href=&quot;header/version&quot;&gt; &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; &lt;/a&gt;提供有关C ++标准库的与实现有关的信息（例如版本号和发行日期。它还定义了&lt;a href=&quot;utility/feature_test&quot;&gt;库功能测试宏）&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf5126087a87a6889e7920c9e1157d0b23d15572" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;exception&amp;gt;&lt;/code&gt; provides several classes and functions related to exception handling in C++ programs.</source>
          <target state="translated">标头 &lt;code&gt;&amp;lt;exception&amp;gt;&lt;/code&gt; 提供了一些与C ++程序中的异常处理相关的类和功能。</target>
        </trans-unit>
        <trans-unit id="bc6caf28cb4847d14f957dc4f821e46a30b84457" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; behaves as if it defines (directly or indirectly) an instance of &lt;code&gt;std::ios_base::Init&lt;/code&gt; with static storage duration: this makes it safe to access the standard I/O streams in the constructors and destructors of static objects with &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;ordered initialization&lt;/a&gt; (as long as &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt; is included in the translation unit before these objects were defined).</source>
          <target state="translated">标头 &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; 的行为就好像它（直接或间接）定义了具有静态存储持续时间的 &lt;code&gt;std::ios_base::Init&lt;/code&gt; 实例：这样可以安全地访问静态对象的构造函数和析构函数中的标准I / O流。用&lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;有序初始化&lt;/a&gt;（只要 &lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt; 被包括在转换单元中被定义这些对象之前）。</target>
        </trans-unit>
        <trans-unit id="fd4ecbc573accaaae87826b6f734bf136d186983" translate="yes" xml:space="preserve">
          <source>The header &lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt; defines types and functions used to report error conditions originating from the operating system, streams I/O, &lt;code&gt;&lt;a href=&quot;thread/future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, or other low-level APIs.</source>
          <target state="translated">标头 &lt;code&gt;&amp;lt;system_error&amp;gt;&lt;/code&gt; 定义了用于报告源自操作系统，流I / O， &lt;code&gt;&lt;a href=&quot;thread/future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 或其他低级API的错误情况的类型和功能。</target>
        </trans-unit>
        <trans-unit id="57e8428ad704374a45b4d8a73edeba81162f1a2e" translate="yes" xml:space="preserve">
          <source>The headers &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt; are meaningless in C++ because the macros they provide in C are language keywords in C++.</source>
          <target state="translated">标头 &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;cstdalign&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;cstdbool&amp;gt;&lt;/code&gt; 在C ++中是无意义的，因为它们在C中提供的宏是C ++中的语言关键字。</target>
        </trans-unit>
        <trans-unit id="7e08bc9e99ec8f39019e1085b8cf1191154179ba" translate="yes" xml:space="preserve">
          <source>The headers &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt; do not contain any content from the C standard library and instead merely include other headers from the C++ standard library. The use of all these headers is deprecated in C++.</source>
          <target state="translated">标头 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;ccomplex&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;ctgmath&amp;gt;&lt;/code&gt; 不包含C标准库中的任何内容，而仅包含C ++标准库中的其他标头。在C ++中，不建议使用所有这些标头。</target>
        </trans-unit>
        <trans-unit id="9d743155eef03d9de2f708dc85802d31a16ee771" translate="yes" xml:space="preserve">
          <source>The hexadecimal floating-point literals were not part of C++ until C++17, although they can be parsed and printed by the I/O functions since C++11: both C++ I/O streams when &lt;code&gt;&lt;a href=&quot;../io/manip/fixed&quot;&gt;std::hexfloat&lt;/a&gt;&lt;/code&gt; is enabled and the C I/O streams: &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/c/fscanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt;, etc. See &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; for the format description.</source>
          <target state="translated">十六进制浮点文字直到C ++ 17才成为C ++的一部分，尽管自C ++ 11以来，它们可以由I / O函数解析和打印：启用 &lt;code&gt;&lt;a href=&quot;../io/manip/fixed&quot;&gt;std::hexfloat&lt;/a&gt;&lt;/code&gt; 时，两个C ++ I / O流都已启用，并且CI / O流： &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../io/c/fscanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; 等。有关格式说明，请参见 &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bcfe16e4a34071ba0fe16d4ac0cbe3af5aafda3" translate="yes" xml:space="preserve">
          <source>The hinted insert (3,4) does not return a boolean in order to be signature-compatible with positional insert on sequential containers, such as &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;. This makes it possible to create generic inserters such as &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt;. One way to check success of a hinted insert is to compare &lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt; before and after.</source>
          <target state="translated">提示插入（3,4）不返回布尔值，以便与顺序容器（例如 &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; 上的位置插入进行签名兼容。这样便可以创建通用插入器，例如 &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt; 。检查提示插入是否成功的一种方法是比较&lt;a href=&quot;size&quot;&gt;大小&lt;/a&gt;前后的size（）。</target>
        </trans-unit>
        <trans-unit id="25af4f74a579fcba3c500fb626cf10f9c5227e2b" translate="yes" xml:space="preserve">
          <source>The hinted insert (4-6) does not return a boolean in order to be signature-compatible with positional insert on sequential containers, such as &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;. This makes it possible to create generic inserters such as &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt;. One way to check success of a hinted insert is to compare &lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt; before and after.</source>
          <target state="translated">提示插入（4-6）不返回布尔值，以便与顺序容器（例如 &lt;code&gt;&lt;a href=&quot;../vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; 上的位置插入进行签名兼容。这样便可以创建通用插入器，例如 &lt;code&gt;&lt;a href=&quot;../../iterator/inserter&quot;&gt;std::inserter&lt;/a&gt;&lt;/code&gt; 。检查提示插入是否成功的一种方法是比较&lt;a href=&quot;size&quot;&gt;大小&lt;/a&gt;前后的size（）。</target>
        </trans-unit>
        <trans-unit id="60466cfba360b12a497fdcbd2421cdfcee028890" translate="yes" xml:space="preserve">
          <source>The identifier &lt;code&gt;override&lt;/code&gt;, if used, appears immediately after the &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; in the syntax of a member function declaration or a member function definition inside a class definition.</source>
          <target state="translated">如果使用了标识符 &lt;code&gt;override&lt;/code&gt; ，则在类定义内的成员函数声明或成员函数定义的语法中，该标识符后立即出现在&lt;a href=&quot;function&quot;&gt;声明&lt;/a&gt;符之后。</target>
        </trans-unit>
        <trans-unit id="855cd3f29b0c4d0647de6b78163ac3dde4862c47" translate="yes" xml:space="preserve">
          <source>The identifier in any capture without an initializer (other than the &lt;code&gt;this&lt;/code&gt;-capture) is looked up using usual &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt; in the</source>
          <target state="translated">使用常规的&lt;a href=&quot;lookup&quot;&gt;非限定名称查找来查找&lt;/a&gt;没有初始化程序（ &lt;code&gt;this&lt;/code&gt; -capture除外）的任何捕获中的标识符在</target>
        </trans-unit>
        <trans-unit id="e9e7a102d6df5884074f2499d6bb5f69817edee5" translate="yes" xml:space="preserve">
          <source>The identifier then becomes the name of an lvalue that refers to the object bound to said variable.</source>
          <target state="translated">然后,标识符成为指向所述变量绑定的对象的l值的名称。</target>
        </trans-unit>
        <trans-unit id="822a7edda6406f5fc42188900a3b551e64031aa7" translate="yes" xml:space="preserve">
          <source>The immediate input function &lt;a href=&quot;../basic_istream/readsome&quot;&gt;&lt;code&gt;basic_istream::readsome&lt;/code&gt;&lt;/a&gt;, if &lt;a href=&quot;../basic_streambuf/in_avail&quot;&gt;&lt;code&gt;basic_streambuf::in_avail&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="translated">如果&lt;a href=&quot;../basic_streambuf/in_avail&quot;&gt; &lt;code&gt;basic_streambuf::in_avail&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;-1&lt;/code&gt; ，则立即输入函数&lt;a href=&quot;../basic_istream/readsome&quot;&gt; &lt;code&gt;basic_istream::readsome&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc1a01ff9f1f5abac042b758d317c3db71ae72ed" translate="yes" xml:space="preserve">
          <source>The implementation is guaranteed to support the registration of at least &lt;code&gt;32&lt;/code&gt; functions. The exact limit is implementation-defined.</source>
          <target state="translated">该实现可保证支持至少 &lt;code&gt;32&lt;/code&gt; 个功能的注册。确切的限制是实现定义的。</target>
        </trans-unit>
        <trans-unit id="d765572265bbb1c2ba3ca90d43753fb5f543201a" translate="yes" xml:space="preserve">
          <source>The implementation is required to ensure that the</source>
          <target state="translated">落实的要求,以确保</target>
        </trans-unit>
        <trans-unit id="f14c981912c9ec5ad33b5a6c478bfe2e9cbdf180" translate="yes" xml:space="preserve">
          <source>The implementation may define additional macro constants in &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; to identify additional floating-point exceptions. All such constants begin with &lt;code&gt;FE_&lt;/code&gt; followed by at least one uppercase letter.</source>
          <target state="translated">该实现可以在 &lt;code&gt;&amp;lt;cfenv&amp;gt;&lt;/code&gt; 中定义其他宏常量，以标识其他浮点异常。所有此类常量 &lt;code&gt;FE_&lt;/code&gt; 后接至少一个大写字母。</target>
        </trans-unit>
        <trans-unit id="22e5ff471a91c192911b7ddaa27337e54bd023f9" translate="yes" xml:space="preserve">
          <source>The implementation may extend the behavior of the first overload of &lt;code&gt;std::async&lt;/code&gt; by enabling additional (implementation-defined) bits in the default launch policy.</source>
          <target state="translated">该实现可以扩展 &lt;code&gt;std::async&lt;/code&gt; 的第一个重载的行为通过在默认启动策略中启用其他（实现定义的）位。</target>
        </trans-unit>
        <trans-unit id="66f2e43503845c9ed791a5293976886ce8971522" translate="yes" xml:space="preserve">
          <source>The implementation may meet the requirements without creating a temporary &lt;code&gt;shared_ptr&lt;/code&gt; object.</source>
          <target state="translated">实现可能满足要求，而无需创建临时的 &lt;code&gt;shared_ptr&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="64697b003de59849a6866340318f593ae74fc065" translate="yes" xml:space="preserve">
          <source>The implementation may meet the requirements without creating a temporary &lt;code&gt;weak_ptr&lt;/code&gt; object.</source>
          <target state="translated">该实现可以满足要求，而无需创建临时的 &lt;code&gt;weak_ptr&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="7b237d3793f32597e507f67af416d68948b4ad9d" translate="yes" xml:space="preserve">
          <source>The implementation may support other date formats besides the ones required by the standard.</source>
          <target state="translated">除了标准所要求的日期格式外,实现可以支持其他日期格式。</target>
        </trans-unit>
        <trans-unit id="12a35a278ea92405afc482e169257edd666c8c44" translate="yes" xml:space="preserve">
          <source>The implementation shall provide sufficient additional &lt;code&gt;constexpr&lt;/code&gt; and &lt;code&gt;noexcept&lt;/code&gt; overloads of these functions so that a &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; object &lt;code&gt;sv&lt;/code&gt; may be compared to another object &lt;code&gt;t&lt;/code&gt; with an implicit conversion to &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt;, with semantics identical to comparing &lt;code&gt;sv&lt;/code&gt; and &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="translated">该实现应提供足够的附加 &lt;code&gt;constexpr&lt;/code&gt; 和这些函数的 &lt;code&gt;noexcept&lt;/code&gt; 重载，以便可以将 &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; 对象 &lt;code&gt;sv&lt;/code&gt; 与另一个对象 &lt;code&gt;t&lt;/code&gt; 进行比较，并隐式转换为 &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; ，其语义与比较 &lt;code&gt;sv&lt;/code&gt; 和 &lt;code&gt;basic_string_view&amp;lt;CharT,Traits&amp;gt;(t)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8fa4c86d6d639e7f910fb3c11363bc126fb0186" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; before the call and throw a &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; with an error condition of &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">我们鼓励实现检测的情况下 &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 的调用之前和抛出 &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 与错误条件 &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ef09408705d9954ea1018c6860f6e1b66768503" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;valid == false&lt;/code&gt; before the call and throw a &lt;a href=&quot;../future_error&quot;&gt;&lt;code&gt;future_error&lt;/code&gt;&lt;/a&gt; with an error condition of &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_errc::no_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">我们鼓励实现检测的情况下 &lt;code&gt;valid == false&lt;/code&gt; 呼叫之前和抛出&lt;a href=&quot;../future_error&quot;&gt; &lt;code&gt;future_error&lt;/code&gt; &lt;/a&gt;与错误条件&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_errc::no_state&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="46992c68e68dfb44f3f1d1f0f1a081b8b330576b" translate="yes" xml:space="preserve">
          <source>The implementations are encouraged to detect the case when &lt;code&gt;valid == false&lt;/code&gt; before the call and throw a &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; with an error condition of &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">我们鼓励实现检测的情况下 &lt;code&gt;valid == false&lt;/code&gt; 呼叫之前和抛出 &lt;code&gt;&lt;a href=&quot;../future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 与错误条件 &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc::no_state&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="30a185593e3d55839d1d436fbf8fa472dc5d96a9" translate="yes" xml:space="preserve">
          <source>The implementations in &lt;a href=&quot;http://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc++&lt;/a&gt; and &lt;a href=&quot;http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc++&lt;/a&gt; expect &lt;code&gt;token&lt;/code&gt; to be the name of a character device that produces random numbers when read from, with the default value &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt;, although where the CPU instruction RDRND is available, libstdc++ uses that as the default.</source>
          <target state="translated">在实施方式中&lt;a href=&quot;http://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;的libc ++&lt;/a&gt;和&lt;a href=&quot;http://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;的libstdc ++&lt;/a&gt;期望 &lt;code&gt;token&lt;/code&gt; 是产生从阅读时的随机数，与所述默认值的字符设备的名称 &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt; ，虽然在这里CPU指令RDRND可用，的libstdc ++用途，作为默认。</target>
        </trans-unit>
        <trans-unit id="07ff6cacb8ff12c796c80e4fa51112a73181e2ed" translate="yes" xml:space="preserve">
          <source>The implementations in &lt;a href=&quot;https://llvm.org/svn/llvm-project/libcxx/trunk/src/random.cpp&quot;&gt;libc++&lt;/a&gt; and &lt;a href=&quot;https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%20%20-v3/src/c%20%2011/random.cc?view=markup#l77&quot;&gt;libstdc++&lt;/a&gt; expect &lt;code&gt;token&lt;/code&gt; to be the name of a character device that produces random numbers when read from, with the default value &lt;code&gt;&quot;/dev/urandom&quot;&lt;/code&gt;, although where the CPU instruction RDRND is available, libstdc++ uses that as the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1bd066a7f11748e7bb0264fc2e8c480f468bd7" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) copy assignment operator has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">隐式声明的（或默认在其第一声明）复制赋值运算符有异常规范中所描述&lt;a href=&quot;except_spec&quot;&gt;的动态异常规范&lt;/a&gt;（直到C ++ 17）&lt;a href=&quot;noexcept_spec&quot;&gt;异常规范&lt;/a&gt;（自C ++ 17起）中所述。</target>
        </trans-unit>
        <trans-unit id="94f03f3d0e083d8f05c0d3d27ca9e6043e7f1447" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) copy constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">隐式声明的（或默认在其第一声明）拷贝构造有异常规范中所描述&lt;a href=&quot;except_spec&quot;&gt;的动态异常规范&lt;/a&gt;（直到C ++ 17）&lt;a href=&quot;noexcept_spec&quot;&gt;异常规范&lt;/a&gt;（因为C ++ 17）。</target>
        </trans-unit>
        <trans-unit id="c3a2dc4c3c835b9d7e3746bb1d579e66f0b3d256" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) default constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">隐式声明（或在其第一个声明中默认）的默认构造函数具有一个异常规范，如&lt;a href=&quot;except_spec&quot;&gt;动态异常规范&lt;/a&gt;（直到C ++ 17）&lt;a href=&quot;noexcept_spec&quot;&gt;异常规范&lt;/a&gt;（自C ++ 17起）中所述。</target>
        </trans-unit>
        <trans-unit id="ad35568398ddbdf1c5594f6799a40acc879779b5" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) move assignment operator has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">隐式声明的（或默认在其第一声明）移动赋值运算符具有如图中记载的异常规范&lt;a href=&quot;except_spec&quot;&gt;动态异常规范&lt;/a&gt;（直到C ++ 17）&lt;a href=&quot;noexcept_spec&quot;&gt;异常规范&lt;/a&gt;（因为C ++ 17）。</target>
        </trans-unit>
        <trans-unit id="3deae4df87e12fce8a01835c91a2ac9242a339b1" translate="yes" xml:space="preserve">
          <source>The implicitly-declared (or defaulted on its first declaration) move constructor has an exception specification as described in &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;(until C++17)&lt;a href=&quot;noexcept_spec&quot;&gt;exception specification&lt;/a&gt;(since C++17).</source>
          <target state="translated">隐式声明的（或默认在其第一声明）移动的构造具有如上述异常规范&lt;a href=&quot;except_spec&quot;&gt;动态异常规范&lt;/a&gt;（直到C ++ 17）&lt;a href=&quot;noexcept_spec&quot;&gt;异常规范&lt;/a&gt;（因为C ++ 17）。</target>
        </trans-unit>
        <trans-unit id="3213a8544ac4c22b0682928a2ce16724be0fb301" translate="yes" xml:space="preserve">
          <source>The implicitly-declared copy constructor for class &lt;code&gt;T&lt;/code&gt; is undefined if any of the following conditions are true:</source>
          <target state="translated">如果满足以下任一条件，则未定义类 &lt;code&gt;T&lt;/code&gt; 的隐式声明的副本构造函数：</target>
        </trans-unit>
        <trans-unit id="6fae264774979621faa26711431abb58dbca09db" translate="yes" xml:space="preserve">
          <source>The implicitly-declared destructor is virtual (because the base class has a virtual destructor) and the lookup for the deallocation function (&lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;()&lt;/code&gt; results in a call to ambiguous, deleted, or inaccessible function.</source>
          <target state="translated">隐式声明的析构函数是虚拟的（因为基类具有虚拟的析构函数），并且对释放函数的查找（ &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;()&lt;/code&gt; 导致对模糊，删除或不可访问的函数的调用）。</target>
        </trans-unit>
        <trans-unit id="50ffc691488ff90f9bb81089da927863779b099a" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted copy constructor for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="translated">类 &lt;code&gt;T&lt;/code&gt; 的隐式声明或默认副本构造函数定义为</target>
        </trans-unit>
        <trans-unit id="08afe67b1a14690a725702d4c692f1dc10c64e2f" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted default constructor for class &lt;code&gt;T&lt;/code&gt; is  undefined (until C++11)defined as deleted(since C++11) if any of the following is true:</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 类的隐式声明或默认的默认构造函数如果满足以下任一条件，则未定义（直到C ++ 11）定义为delete（自C ++ 11起）：</target>
        </trans-unit>
        <trans-unit id="65cafdb084858cf182d0ce28289e802bf9e83822" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted destructor for class &lt;code&gt;T&lt;/code&gt; is  undefined (until C++11)defined as</source>
          <target state="translated">类 &lt;code&gt;T&lt;/code&gt; 的隐式声明或默认的析构函数未定义（直到C ++ 11）定义为</target>
        </trans-unit>
        <trans-unit id="e8b5ed6dfa8b272f8c00f443dfeac236e2515204" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted move assignment operator for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="translated">类 &lt;code&gt;T&lt;/code&gt; 的隐式声明或默认的移动分配运算符定义为</target>
        </trans-unit>
        <trans-unit id="4ce2934ef2171aeb2c0ad6a343b987738915dab2" translate="yes" xml:space="preserve">
          <source>The implicitly-declared or defaulted move constructor for class &lt;code&gt;T&lt;/code&gt; is defined as</source>
          <target state="translated">类 &lt;code&gt;T&lt;/code&gt; 的隐式声明或默认的move构造函数定义为</target>
        </trans-unit>
        <trans-unit id="ad92a1e56a9451101a860f2143c244760ecd26c4" translate="yes" xml:space="preserve">
          <source>The implicitly-defined special member functions are typically incorrect if the class is managing a resource whose handle is an object of non-class type (raw pointer, POSIX file descriptor, etc), whose destructor does nothing and copy constructor/assignment operator performs a &quot;shallow copy&quot; (copy the value of the handle, without duplicating the underlying resource).</source>
          <target state="translated">如果类管理的资源的句柄是一个非类类型的对象(原始指针、POSIX文件描述符等),其destructor什么都不做,copy构造函数/赋值运算符执行 &quot;浅层复制&quot;(复制句柄的值,不重复底层资源),那么隐式定义的特殊成员函数通常是不正确的。</target>
        </trans-unit>
        <trans-unit id="192f6f2391fc950f581ebc15e6c0166986a4e41a" translate="yes" xml:space="preserve">
          <source>The implicitly-generated member functions and any member function declared as defaulted on its first declaration are inline just like any other function defined inside a class definition.</source>
          <target state="translated">隐式生成的成员函数和任何在其第一次声明时声明为默认的成员函数都是内联的,就像在类定义内定义的任何其他函数一样。</target>
        </trans-unit>
        <trans-unit id="d43d2eaebfe91ea20d3c9ee4934fb21de74d02b4" translate="yes" xml:space="preserve">
          <source>The implied &lt;code&gt;lk.unlock&lt;/code&gt; is</source>
          <target state="translated">隐含的 &lt;code&gt;lk.unlock&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="34929ac211f53c3511c4b293c3b116cd7ed0a254" translate="yes" xml:space="preserve">
          <source>The index stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">存储在 &lt;code&gt;*this&lt;/code&gt; 中的索引。</target>
        </trans-unit>
        <trans-unit id="09af74812a9060b648ff5292103d113c603a82ef" translate="yes" xml:space="preserve">
          <source>The index-based overloads (1-4) fail to compile if the index &lt;code&gt;I&lt;/code&gt; is neither 0 nor 1.</source>
          <target state="translated">如果索引 &lt;code&gt;I&lt;/code&gt; 既不是0也不是1，则基于索引的重载（1-4）无法编译。</target>
        </trans-unit>
        <trans-unit id="46437bdc4c7e2e85424bc222273ad44e53f18e36" translate="yes" xml:space="preserve">
          <source>The indicated operator can be applied to type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">指示的运算符可以应用于类型 &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7846514f422b5378fb77af4cf9b31d07acbbdb16" translate="yes" xml:space="preserve">
          <source>The indirection and member operators are overloaded by many iterators and smart pointer classes.</source>
          <target state="translated">许多迭代器和智能指针类都重载了间接和成员操作符。</target>
        </trans-unit>
        <trans-unit id="8129cebea0ce621764c93ae2762d3f9a991933ef" translate="yes" xml:space="preserve">
          <source>The indirection operator expressions have the form.</source>
          <target state="translated">间接操作符表达式的形式。</target>
        </trans-unit>
        <trans-unit id="9f172228ef4f13bff865c966d96876715b4f88e1" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration, and may be obtained by the member functions of &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt;. During directory iteration, calling &lt;code&gt;status&lt;/code&gt; again is unnecessary.</source>
          <target state="translated">该函数提供的信息通常也作为目录迭代的副产品提供，并且可以通过 &lt;code&gt;&lt;a href=&quot;directory_entry&quot;&gt;directory_entry&lt;/a&gt;&lt;/code&gt; 的成员函数获得。目录迭代期间，调用 &lt;code&gt;status&lt;/code&gt; 不需要再次。</target>
        </trans-unit>
        <trans-unit id="0116c386923508482ffe7b197c85ac890bdc4bf4" translate="yes" xml:space="preserve">
          <source>The information provided by this function is usually also provided as a byproduct of directory iteration. During directory iteration, calling &lt;code&gt;exists(*iterator)&lt;/code&gt; is less efficient than &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt;.</source>
          <target state="translated">此功能提供的信息通常也作为目录迭代的副产品提供。在目录迭代过程中，调用 &lt;code&gt;exists(*iterator)&lt;/code&gt; 的效率要低于 &lt;code&gt;exists(iterator-&amp;gt;status())&lt;/code&gt; 效率。</target>
        </trans-unit>
        <trans-unit id="a8eeab648787f5a49f075a54a3ff963c76b7abfc" translate="yes" xml:space="preserve">
          <source>The inherited constructors are equivalent to user-defined constructors with an empty body and with a &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; consisting of a single nested-name-specifier, which forwards all of its arguments to the base class constructor.</source>
          <target state="translated">继承的构造函数等效于用户定义的构造函数，该主体具有空主体，并且&lt;a href=&quot;constructor&quot;&gt;成员初始化程序列表&lt;/a&gt;由单个嵌套名称说明符组成，该嵌套说明符将其所有参数转发给基类构造函数。</target>
        </trans-unit>
        <trans-unit id="d9039e574ac657d6dcb969a83965e5c07901ebe3" translate="yes" xml:space="preserve">
          <source>The initial value may be provided in the initializer section of a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; or a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt;. It also takes place during function calls: function parameters and the function return values are also initialized.</source>
          <target state="translated">初始值可以在&lt;a href=&quot;declarations&quot;&gt;声明程序&lt;/a&gt;或&lt;a href=&quot;new&quot;&gt;新表达式&lt;/a&gt;的初始值设定项中提供。它也发生在函数调用期间：函数参数和函数返回值也被初始化。</target>
        </trans-unit>
        <trans-unit id="dca3507cd72234d2aa0fdea51eb1cebb2b9753f0" translate="yes" xml:space="preserve">
          <source>The initializers where class-or-identifier names a &lt;a href=&quot;derived_class&quot;&gt;virtual base class&lt;/a&gt; are ignored during execution of constructors of any class that is not the most derived class of the object that's being constructed.</source>
          <target state="translated">在执行不是构造对象的最大派生类的任何类的构造函数的过程中，将忽略使用类或标识符命名&lt;a href=&quot;derived_class&quot;&gt;虚拟基类&lt;/a&gt;的初始化器。</target>
        </trans-unit>
        <trans-unit id="51f3e6edc128bfcb0be013fd2d1ae1da69f60e07" translate="yes" xml:space="preserve">
          <source>The injected-class-name is the name of a class within the scope of said class.</source>
          <target state="translated">注入的类名是所述类的范围内的类名。</target>
        </trans-unit>
        <trans-unit id="606b29738683260e78646411c4bd2990a0c81802" translate="yes" xml:space="preserve">
          <source>The injected-class-name of a class template or class template specialization can be used either as a template-name or a type-name wherever it is in scope.</source>
          <target state="translated">类模板或类模板特殊化的注入类名可以作为模板名或类型名使用,只要它在范围内。</target>
        </trans-unit>
        <trans-unit id="588b0a23a80aa452a55821a2b55a11188b48a689" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot be used with a function or variable(since C++17) declaration at block scope (inside another function).</source>
          <target state="translated">inline指定符不能与函数或变量(自C++17以来)在块作用域(另一个函数内部)的声明一起使用。</target>
        </trans-unit>
        <trans-unit id="11abde87d1d2ac1bfae6d03e1fd645c8d719bd0d" translate="yes" xml:space="preserve">
          <source>The inline specifier cannot re-declare a function or variable(since C++17) that was already defined in the translation unit as non-inline.</source>
          <target state="translated">内联指定符不能重新声明一个已经在翻译单元中定义为非内联的函数或变量(自C++17起)。</target>
        </trans-unit>
        <trans-unit id="5dbd088428b0bac15f8a60242c8b9596e62e2450" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with the conversion specifier selected in Stage 1</source>
          <target state="translated">就像通过 &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; 来解析输入一样，在阶段1中选择了转换说明符</target>
        </trans-unit>
        <trans-unit id="e89c213728057cbded885c2e82d2eb3ce4460233" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;float&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;long double&lt;/code&gt;&lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">输入被解析为如果由 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; 为带符号的整数 &lt;code&gt;v&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 无符号整数 &lt;code&gt;v&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtof&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;float&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt; ，或 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;long double&lt;/code&gt; &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41603f2c61d6937ed51388a6bc806662aaa244d7" translate="yes" xml:space="preserve">
          <source>The input is parsed as if by &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; for signed integer &lt;code&gt;v&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; for unsigned integer &lt;code&gt;v&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; for floating-point &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">输入的解析方式类似于 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtol&quot;&gt;std::strtoll&lt;/a&gt;&lt;/code&gt; 对于带符号整数 &lt;code&gt;v&lt;/code&gt; )， &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 对于无符号整数 &lt;code&gt;v&lt;/code&gt; ）或 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtof&quot;&gt;std::strtold&lt;/a&gt;&lt;/code&gt; 对于浮点 &lt;code&gt;v&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1eae9126bfe2845e4a7f3d75fa1de5c6799e7530" translate="yes" xml:space="preserve">
          <source>The inputs to an expression consist of its operands.</source>
          <target state="translated">一个表达式的输入由操作数组成。</target>
        </trans-unit>
        <trans-unit id="607e5d93133cf024a79ee0801db268525f2aa983" translate="yes" xml:space="preserve">
          <source>The insertion operation in &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; 的插入操作表现为&lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7c7b3ed830ddfb4f12cf5eaf80d05dfaf6783a2" translate="yes" xml:space="preserve">
          <source>The instantiation of a</source>
          <target state="translated">的实例化。</target>
        </trans-unit>
        <trans-unit id="e91461402009e482fb1a78f2f939226ff4aded6b" translate="yes" xml:space="preserve">
          <source>The integer value that is stored together with the callback is typically an index obtained from &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与回调一起存储的整数值通常是从 &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; 获得的索​​引。</target>
        </trans-unit>
        <trans-unit id="e754c5d2f0c37f77dbd459373feccfde0264f302" translate="yes" xml:space="preserve">
          <source>The integral type generated by the engine. Results are undefined if this is not an unsigned integral type.</source>
          <target state="translated">由引擎生成的积分类型,如果不是无符号积分类型,则结果未定义。如果不是无符号积分类型,则结果未定义。</target>
        </trans-unit>
        <trans-unit id="40c53aad3caa79b07c6f8ca53ea06f1869a292cc" translate="yes" xml:space="preserve">
          <source>The intent of concepts is to model semantic categories (Number, Range, RegularFunction) rather than syntactic restrictions (HasPlus, Array). According to &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;ISO C++ core guideline T.20&lt;/a&gt;, &quot;The ability to specify a meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint.&quot;</source>
          <target state="translated">概念的目的是为语义类别（Number，Range，RegularFunction）建模，而不是对语法限制（HasPlus，Array）建模。根据&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t20-avoid-concepts-without-meaningful-semantics&quot;&gt;ISO C ++核心指南T.20&lt;/a&gt;，&amp;ldquo;指定有意义的语义的能力是真实概念的定义特征，而不是语法约束。&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="619a8685fc9309dd7fa35fcbb4dc104bf7401e8a" translate="yes" xml:space="preserve">
          <source>The intent of this function is to allow &lt;a href=&quot;../../language/range-for&quot;&gt;range for loops&lt;/a&gt; to work with valarrays, not to provide container semantics.</source>
          <target state="translated">此功能的目的是允许&lt;a href=&quot;../../language/range-for&quot;&gt;范围循环&lt;/a&gt;与valarray一起使用，而不是提供容器语义。</target>
        </trans-unit>
        <trans-unit id="8413f561941f9afa4883b6089ece4689223790be" translate="yes" xml:space="preserve">
          <source>The intent of this requirement is to preserve binary compatibility between the C++ library complex number types and the &lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;C language complex number types&lt;/a&gt; (and arrays thereof), which have an identical object representation requirement.</source>
          <target state="translated">此要求的目的是保留具有相同对象表示要求的C ++库复数类型和&lt;a href=&quot;http://en.cppreference.com/w/c/language/arithmetic_types.html#Complex_floating_types&quot;&gt;C语言复数类型&lt;/a&gt;（及其数组）之间的二进制兼容性。</target>
        </trans-unit>
        <trans-unit id="8f653c0dd9ae48a2397aac170d1b0f16776c082f" translate="yes" xml:space="preserve">
          <source>The interface of C++ standard library is defined by the following collection of headers.</source>
          <target state="translated">C++标准库的接口由以下的头文件集合定义。</target>
        </trans-unit>
        <trans-unit id="6b2570d1e40f42d32deec64488687b81c00f5106" translate="yes" xml:space="preserve">
          <source>The internal pathname in generic pathname format, converted to specified string type.</source>
          <target state="translated">通用路径名格式的内部路径名,转换为指定的字符串类型。</target>
        </trans-unit>
        <trans-unit id="9e600bbfc64aa5e497181bbfbd63f0f68de6a8dc" translate="yes" xml:space="preserve">
          <source>The internal pathname in native pathname format, converted to specified string type.</source>
          <target state="translated">原生路径名格式的内部路径名,转换为指定的字符串类型。</target>
        </trans-unit>
        <trans-unit id="004ca417b1356b06ecce1a0eded3b5b9c702a405" translate="yes" xml:space="preserve">
          <source>The inverse of the referenced bit.</source>
          <target state="translated">参考位的倒数。</target>
        </trans-unit>
        <trans-unit id="94b5c297f476b2d4707fabdba8af9c74ed678810" translate="yes" xml:space="preserve">
          <source>The invocation of &lt;code&gt;setjmp&lt;/code&gt; must appear only in one of the following contexts:</source>
          <target state="translated">&lt;code&gt;setjmp&lt;/code&gt; 的调用只能出现在以下上下文之一中：</target>
        </trans-unit>
        <trans-unit id="e9cf86ded4e35142c7778644f54d0174bfb84173" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multimap&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">不需要此容器的迭代顺序稳定（因此，例如， &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; 不能用于比较两个 &lt;code&gt;std::unordered_multimap&lt;/code&gt; ），除了其键比较的每组元素</target>
        </trans-unit>
        <trans-unit id="97c9b700924b706247c8bc9808f1bc7725c3a1aa" translate="yes" xml:space="preserve">
          <source>The iteration order of this container is not required to be stable (so, for example, &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; cannot be used to compare two &lt;code&gt;std::unordered_multiset&lt;/code&gt;s), except that every group of elements whose keys compare</source>
          <target state="translated">不需要此容器的迭代顺序稳定（因此，例如， &lt;code&gt;&lt;a href=&quot;../algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; 不能用于比较两个 &lt;code&gt;std::unordered_multiset&lt;/code&gt; ），除了其键比较的每组元素</target>
        </trans-unit>
        <trans-unit id="1863ed213c7ef5f7feaa4f2890c2f01f674b7ab4" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;first&lt;/code&gt; does not need to be dereferenceable if &lt;code&gt;first==last&lt;/code&gt;: erasing an empty range is a no-op.</source>
          <target state="translated">如果 &lt;code&gt;first==last&lt;/code&gt; 则迭代器 &lt;code&gt;first&lt;/code&gt; 不必是可解除引用的：擦除空范围是无操作的。</target>
        </trans-unit>
        <trans-unit id="416bf9a217d579e782b2dcb1f169937401418ec1" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferencable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">迭代器 &lt;code&gt;pos&lt;/code&gt; 必须有效且可取消引用。因此， &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 迭代器（有效但不可取消）不能用作 &lt;code&gt;pos&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="b61e02fbf920d53ad39bacd79891eb0d1792824a" translate="yes" xml:space="preserve">
          <source>The iterator &lt;code&gt;pos&lt;/code&gt; must be valid and dereferenceable. Thus the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator (which is valid, but is not dereferenceable) cannot be used as a value for &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">迭代器 &lt;code&gt;pos&lt;/code&gt; 必须有效且可取消引用。因此， &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 迭代器（有效但不可取消引用）不能用作 &lt;code&gt;pos&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="2eb90b5d51c71efded43df27cab17311bc850303" translate="yes" xml:space="preserve">
          <source>The iterator equal to &lt;code&gt;first + (last - n_first)&lt;/code&gt;.</source>
          <target state="translated">迭代器等于 &lt;code&gt;first + (last - n_first)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abfb235c9222b9db1250ee25ae21c35e487f8f38" translate="yes" xml:space="preserve">
          <source>The iterator library provides definitions for five(until C++17)six(since C++17) kinds of iterators as well as iterator traits, adaptors, and utility functions.</source>
          <target state="translated">迭代器库提供了5种(直到C++17)6种(自C++17以来)迭代器的定义,以及迭代器特征、适配器和实用函数。</target>
        </trans-unit>
        <trans-unit id="196d09b17633c1d18330b9904d4f41189e178366" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function is invalidated when the member function &lt;code&gt;resize()&lt;/code&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">当成员函数从该函数而获得的迭代器被无效 &lt;code&gt;resize()&lt;/code&gt; 被调用在阵列 &lt;code&gt;v&lt;/code&gt; 或当的寿命 &lt;code&gt;v&lt;/code&gt; 端部，以先到者为准。</target>
        </trans-unit>
        <trans-unit id="05de9016d2fdcc550169519b30085812eef58929" translate="yes" xml:space="preserve">
          <source>The iterator obtained from this function template is invalidated when the member function &lt;a href=&quot;resize&quot;&gt;&lt;code&gt;resize()&lt;/code&gt;&lt;/a&gt; is called on the array &lt;code&gt;v&lt;/code&gt; or when the lifetime of &lt;code&gt;v&lt;/code&gt; ends, whichever comes first.</source>
          <target state="translated">当成员函数从该函数模板获得的迭代器被无效&lt;a href=&quot;resize&quot;&gt; &lt;code&gt;resize()&lt;/code&gt; &lt;/a&gt;被调用在阵列 &lt;code&gt;v&lt;/code&gt; 或当的寿命 &lt;code&gt;v&lt;/code&gt; 端部，以先到者为准。</target>
        </trans-unit>
        <trans-unit id="6f533c17b31181fda7a7478422455fda0c5a1103" translate="yes" xml:space="preserve">
          <source>The iterator past the end of the first partition within &lt;code&gt;[first, last)&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">如果所有元素都满足 &lt;code&gt;p&lt;/code&gt; ,则迭代器在 &lt;code&gt;[first, last)&lt;/code&gt; 或 &lt;code&gt;last&lt;/code&gt; 中第一个分区的末尾经过。</target>
        </trans-unit>
        <trans-unit id="476e11b985ea98b293af90f225eabcc6be286b5e" translate="yes" xml:space="preserve">
          <source>The key comparison function object.</source>
          <target state="translated">键比较函数对象。</target>
        </trans-unit>
        <trans-unit id="de179c257b2f3167c894faa5512c2c228fcea52f" translate="yes" xml:space="preserve">
          <source>The key comparison function.</source>
          <target state="translated">键比较功能。</target>
        </trans-unit>
        <trans-unit id="4c74d4bbf1c90d9364823e4f3ebbd85ffbb952ff" translate="yes" xml:space="preserve">
          <source>The keyword &lt;a href=&quot;../keyword/template&quot;&gt;&lt;code&gt;template&lt;/code&gt;&lt;/a&gt; may appear in qualified identifiers as necessary to disambiguate &lt;a href=&quot;dependent_name&quot;&gt;dependent template names&lt;/a&gt;.</source>
          <target state="translated">必要时，关键字&lt;a href=&quot;../keyword/template&quot;&gt; &lt;code&gt;template&lt;/code&gt; &lt;/a&gt;可以出现在合格的标识符中，以消除&lt;a href=&quot;dependent_name&quot;&gt;从属模板名称的&lt;/a&gt;歧义。</target>
        </trans-unit>
        <trans-unit id="49c5ea1550a8c0099418f191e52d2190bdb35cb8" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;nullptr&lt;/code&gt; denotes the pointer literal. It is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;. There exist &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; from &lt;code&gt;nullptr&lt;/code&gt; to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any null pointer constant, which includes values of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; as well as the macro &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">关键字 &lt;code&gt;nullptr&lt;/code&gt; 表示指针文字。这是 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 类型的&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;。存在从 &lt;code&gt;nullptr&lt;/code&gt; 到任何指针类型以及任何指向成员类型的指针的null指针值的&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt;。对于任何空指针常量，都存在类似的转换，该常量包括 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 类型的值以及宏 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc50291017180e4feb23c15b01028337ea026e19" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is also used to begin a</source>
          <target state="translated">关键字 &lt;code&gt;requires&lt;/code&gt; 也用于开始</target>
        </trans-unit>
        <trans-unit id="38ca54bb4a4020554bc23191438cf8b9378a16b3" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;requires&lt;/code&gt; is used to introduce a</source>
          <target state="translated">关键字 &lt;code&gt;requires&lt;/code&gt; 用于引入一个</target>
        </trans-unit>
        <trans-unit id="0f400e14a3942078db12d200e17dbee2a1ed3dcd" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;template&lt;/code&gt; may only be used in this way after operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access through pointer), and &lt;code&gt;.&lt;/code&gt; (member access), the following are all valid examples:</source>
          <target state="translated">只能在运算符 &lt;code&gt;::&lt;/code&gt; :（作用域分辨率）， &lt;code&gt;-&amp;gt;&lt;/code&gt; （通过指针访问成员）和之后使用关键字 &lt;code&gt;template&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; （成员访问权限），以下均为有效示例：</target>
        </trans-unit>
        <trans-unit id="13bd0f41e6a40479c82db81587bd210c9975f65f" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt; whose value is the address of the object, on which the member function is being called. It can appear in the following contexts:</source>
          <target state="translated">关键字 &lt;code&gt;this&lt;/code&gt; 是一个&lt;a href=&quot;value_category&quot;&gt;prvalue &lt;/a&gt;&lt;a href=&quot;expressions&quot;&gt;表达式，&lt;/a&gt;其值是对象的地址，在该对象上调用成员函数。它可以出现在以下上下文中：</target>
        </trans-unit>
        <trans-unit id="5fb21cb06e25fb3ea23dccf8da1e5fef70f7615d" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; can be used even outside of templates.</source>
          <target state="translated">即使在模板之外也可以使用关键字 &lt;code&gt;typename&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78b1b9af4e7e3fe2a278d800536b1dea324a61db" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; may only be used in this way before qualified names (e.g. &lt;code&gt;T::x&lt;/code&gt;), but the names need not be dependent.</source>
          <target state="translated">只能在限定名称（例如 &lt;code&gt;T::x&lt;/code&gt; ）之前以这种方式使用关键字 &lt;code&gt;typename&lt;/code&gt; ，但是名称不必是依赖的。</target>
        </trans-unit>
        <trans-unit id="79655a71967b64b901ff64e9dbeb497972506960" translate="yes" xml:space="preserve">
          <source>The keyword &lt;code&gt;typename&lt;/code&gt; must only be used in template declarations and definitions and only in contexts in which dependent names can be used. This excludes explicit specialization declarations and explicit instantiation declarations.</source>
          <target state="translated">关键字 &lt;code&gt;typename&lt;/code&gt; 只能在模板声明和定义中使用，并且只能在可以使用从属名称的上下文中使用。这不包括显式的专门化声明和显式的实例化声明。</target>
        </trans-unit>
        <trans-unit id="95a190feaf53fdb99612657d6559e66695dae193" translate="yes" xml:space="preserve">
          <source>The keyword is unused and reserved.</source>
          <target state="translated">该关键字未被使用和保留。</target>
        </trans-unit>
        <trans-unit id="58bf644951168b25add914fb2af57f56e1426658" translate="yes" xml:space="preserve">
          <source>The keyword-like forms (&lt;code&gt;and&lt;/code&gt;,&lt;code&gt;or&lt;/code&gt;,&lt;code&gt;not&lt;/code&gt;) and the symbol-like forms (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;,&lt;code&gt;||&lt;/code&gt;,&lt;code&gt;!&lt;/code&gt;) can be used interchangeably (See &lt;a href=&quot;operator_alternative&quot;&gt;alternative representations&lt;/a&gt;)</source>
          <target state="translated">关键字样的形式（ &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ， &lt;code&gt;not&lt;/code&gt; ）和符号般的形式（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ， &lt;code&gt;||&lt;/code&gt; ， &lt;code&gt;!&lt;/code&gt; ）可以互换使用（见&lt;a href=&quot;operator_alternative&quot;&gt;替换表示&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8387e8b5a34e9a813a529166973aeadc61823549" translate="yes" xml:space="preserve">
          <source>The lambda expression is a prvalue expression of unique unnamed non-union non-aggregate class type, known as</source>
          <target state="translated">lambda表达式是一个唯一的未命名的非union非集合类类型的prvalue表达式,称为</target>
        </trans-unit>
        <trans-unit id="1dc3cef4c1069bfe1bc8a146544fa3fcdd7f2326" translate="yes" xml:space="preserve">
          <source>The largest allocation size that is required to be fulfilled using the pooling mechanism. Attempts to allocate a single block larger than this threshold will be allocated directly from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;largest_required_pool_block&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose a pass-through threshold larger than specified in this field.</source>
          <target state="translated">使用池机制需要满足的最大分配大小。尝试分配大于此阈值的单个块的尝试将直接从上游 &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; 。如果 &lt;code&gt;largest_required_pool_block&lt;/code&gt; 为零或大于实现定义的限制，则使用该限制。该实现可以选择大于此字段中指定的通过阈值。</target>
        </trans-unit>
        <trans-unit id="0f76fd3117478f278b8a26d22cae6980cc3dc7bc" translate="yes" xml:space="preserve">
          <source>The largest block size and maximum chunk size may be tuned by passing a &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; struct to its constructor.</source>
          <target state="translated">可以通过将 &lt;code&gt;&lt;a href=&quot;pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; 结构传递给其构造函数来调整最大块大小和最大块大小。</target>
        </trans-unit>
        <trans-unit id="5a4ed139500fd5d555f2f6faa85fd84cfda82ebd" translate="yes" xml:space="preserve">
          <source>The largest possible number of char-like objects that can be referred to by a &lt;code&gt;basic_string_view&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;basic_string_view&lt;/code&gt; 可以引用的最大数目的类似于char的对象。</target>
        </trans-unit>
        <trans-unit id="a8c1d33c39832e1576d640ab855b96a2c40bccb6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::nearbyint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">可表示的最大浮点值是所有标准浮点格式中的精确整数，因此 &lt;code&gt;std::nearbyint&lt;/code&gt; 绝不会自己溢出；但是，当存储在整数变量中时，结果可能会溢出任何整数类型（包括 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0e0e71108205254bc43c1052dde67ff6846b625e" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::rint&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">可表示的最大浮点值是所有标准浮点格式中的精确整数，因此 &lt;code&gt;std::rint&lt;/code&gt; 绝不会自己溢出；但是，当存储在整数变量中时，结果可能会溢出任何整数类型（包括 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="fdc448092c1ae5b510cac2bc24fecc523a9a01e6" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so &lt;code&gt;std::round&lt;/code&gt; never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">可表示的最大浮点值是所有标准浮点格式中的精确整数，因此 &lt;code&gt;std::round&lt;/code&gt; 绝不会自己溢出；但是，当存储在整数变量中时，结果可能会溢出任何整数类型（包括 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="149a06b50d59b602c5dedd71bc2f5b4d4782a259" translate="yes" xml:space="preserve">
          <source>The largest representable floating-point values are exact integers in all standard floating-point formats, so this function never overflows on its own; however the result may overflow any integer type (including &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt;), when stored in an integer variable.</source>
          <target state="translated">可表示的最大浮点值是所有标准浮点格式中的精确整数，因此此函数永远不会溢出。但是结果可能会溢出任何整数类型（包括 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; ，当存储在整数变量中时 std :: intmax_t）。</target>
        </trans-unit>
        <trans-unit id="ccc3bae22c3039b6aa4ddd26ffed5dd3a3801a47" translate="yes" xml:space="preserve">
          <source>The last character in</source>
          <target state="translated">最后一个字符</target>
        </trans-unit>
        <trans-unit id="d97f60f8595e3388c7571dd07273229e64ab3160" translate="yes" xml:space="preserve">
          <source>The last modification time for the referred-to filesystem object.</source>
          <target state="translated">引用到的文件系统对象的最后修改时间。</target>
        </trans-unit>
        <trans-unit id="003204e389b9da8284fc1fb45f6c42edd43b43df" translate="yes" xml:space="preserve">
          <source>The latin &lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;letter 'ſ' (U+017F)&lt;/a&gt; is the alternative lowercase form of 'S' (U+0053).</source>
          <target state="translated">拉丁文&lt;a href=&quot;https://en.wikipedia.org/wiki/Long_s&quot;&gt;字母's'（U +拉丁文扩展-A）&lt;/a&gt;是'S'（U + 0053）的替代形式小写。</target>
        </trans-unit>
        <trans-unit id="7e8b919f2dc439db08daff4c3a4bb57cb3581675" translate="yes" xml:space="preserve">
          <source>The leading zero generated by the conversion specification &lt;code&gt;#o&lt;/code&gt; (resulting from the combination of &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; for example) is not counted as a padding character.</source>
          <target state="translated">转换规范 &lt;code&gt;#o&lt;/code&gt; 生成的前导零（由 &lt;code&gt;&lt;a href=&quot;../../io/manip/showbase&quot;&gt;std::showbase&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../io/manip/hex&quot;&gt;std::oct&lt;/a&gt;&lt;/code&gt; ）不算作填充字符。</target>
        </trans-unit>
        <trans-unit id="bae67611e59a74badd8c128046df5c4dafdb9b1d" translate="yes" xml:space="preserve">
          <source>The length of character sequence pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">所指向的字符序列的长度 &lt;code&gt;s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="198958162200c69daf435147f9c229df71f282ff" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">最大初始段的长度，该段仅包含来自字节串的字符（由指向） &lt;code&gt;src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63de454d6ebc822ff35b5de2988085c7a2c0e23c" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters from wide string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">最大初始段的长度，仅包含 &lt;code&gt;src&lt;/code&gt; 指向的宽字符串中的字符。</target>
        </trans-unit>
        <trans-unit id="83dc1b81260e13a56926b8fcc5b2fc9652de1176" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the byte string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">最大初始段的长度，该段仅包含在由指向的字节字符串中找不到的字符 &lt;code&gt;src&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f772a2bec6f10a883f7267bd67367b712ef3954" translate="yes" xml:space="preserve">
          <source>The length of the maximum initial segment that contains only characters not found in the character string pointed to by &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">最大初始段的长度，仅包含 &lt;code&gt;src&lt;/code&gt; 指向的字符串中找不到的字符。</target>
        </trans-unit>
        <trans-unit id="8fe0dd8d74988395bb6129f5a7e4490356eb2a0b" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated character string.</source>
          <target state="translated">空尾字符的长度。</target>
        </trans-unit>
        <trans-unit id="c0686acb8c60390ca16c8404e742b7a9caf518b0" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">以零结尾的字符串 &lt;code&gt;str&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="70aa39cc3ba65fdf92c15438e02fd88c74004295" translate="yes" xml:space="preserve">
          <source>The length of the null-terminated wide string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">空终止的宽字符串 &lt;code&gt;str&lt;/code&gt; 的长度。</target>
        </trans-unit>
        <trans-unit id="569fe0bc480cb2d8fd1b576d50ac246394b981a8" translate="yes" xml:space="preserve">
          <source>The length of the specified match or sub-match.</source>
          <target state="translated">指定的匹配或子匹配的长度。</target>
        </trans-unit>
        <trans-unit id="593d216bcb63cbce0afb160433d1ab015cf4835d" translate="yes" xml:space="preserve">
          <source>The length of the transformed string, not including the terminating null-character.</source>
          <target state="translated">转换后的字符串的长度,不包括结束的空字符。</target>
        </trans-unit>
        <trans-unit id="e3b3ec34feef4d29ba71c02ffc289279c3d65e7e" translate="yes" xml:space="preserve">
          <source>The length of the transformed wide string, not including the terminating null-character.</source>
          <target state="translated">转化后的宽字符串的长度,不包括终止的空字符。</target>
        </trans-unit>
        <trans-unit id="ed8baa6719cd710e95a7b3c07ae38fff0961e9d8" translate="yes" xml:space="preserve">
          <source>The level of support for the open modes other than &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; varies among implementations. C++11 explicitly specifies the support for &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; and in this constructor, but &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; have different effects on different implementations.</source>
          <target state="translated">除 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::out&lt;/a&gt;&lt;/code&gt; 以外的其他开放模式的支持级别因实现而异。C ++ 11 在 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 和此构造函数中明确指定了对 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt;&lt;/code&gt; 的支持，但 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::app&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::trunc&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::binary&lt;/a&gt;&lt;/code&gt; 对不同的实现有不同的影响。</target>
        </trans-unit>
        <trans-unit id="557e0b119e086c3a7c5bcdd2f05ba46d098531ff" translate="yes" xml:space="preserve">
          <source>The library provides overloads for all signed and unsigned integer types and &lt;code&gt;char&lt;/code&gt; as the referenced type of the parameter &lt;code&gt;value&lt;/code&gt;. 2-4) Floating-point parsers: Expects the pattern identical to the one used by &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale, except that</source>
          <target state="translated">该库提供所有有符号和无符号整数类型的重载，并提供 &lt;code&gt;char&lt;/code&gt; 作为参数 &lt;code&gt;value&lt;/code&gt; 的引用类型。2-4）浮点解析器：期望模式与默认（&amp;ldquo; C&amp;rdquo;）语言环境中 &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; 使用的模式相同，除了</target>
        </trans-unit>
        <trans-unit id="0c00bda8553a4155113db78626e8f2751d276761" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;的库版本</target>
        </trans-unit>
        <trans-unit id="8ed95002f088794bbcb4dda6067ef23523590d14" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;和&lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/strong&gt;的库版本&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be0df0b3b3695421bdf2d17b88a03ae80713339f" translate="yes" xml:space="preserve">
          <source>The library versions of &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt;和&lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;的库版本</target>
        </trans-unit>
        <trans-unit id="9a277b5aee4eef17b2deb4d6d21114b2a958a7d0" translate="yes" xml:space="preserve">
          <source>The lifetime of a &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; begins when its initialization is complete and ends as if it were a scalar object.</source>
          <target state="translated">&lt;a href=&quot;reference&quot;&gt;引用&lt;/a&gt;的生存期始于其初始化完成，然后结束，就好像它是一个标量对象一样。</target>
        </trans-unit>
        <trans-unit id="89060782836e6f22829eef94ab23da8fa518fbc4" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object created when evaluating the default arguments of a default constructor used to initialize an element of an array ends before the next element of the array begins initialization.</source>
          <target state="translated">当评估用于初始化一个数组元素的缺省构造函数的缺省参数时,创建的临时对象的寿命在数组的下一个元素开始初始化之前结束。</target>
        </trans-unit>
        <trans-unit id="d83f5d7c17e682f051804ccec8769174402ff049" translate="yes" xml:space="preserve">
          <source>The lifetime of a temporary object may be extended by binding to a const lvalue reference or to an rvalue reference(since C++11), see &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;reference initialization&lt;/a&gt; for details.</source>
          <target state="translated">可以通过绑定到const左值引用或右值引用（自C ++ 11起）来延长临时对象的生存期，有关详细信息，请参见&lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;引用初始化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="076f84edd8eb9b71ed85703e28397b69b08f0333" translate="yes" xml:space="preserve">
          <source>The lifetime of an object must exceed the lifetime of all &lt;code&gt;atomic_ref&lt;/code&gt;s that references the object. While any &lt;code&gt;atomic_ref&lt;/code&gt; instances referencing an object exists, the object must be exclusively accessed through these &lt;code&gt;atomic_ref&lt;/code&gt; instances. No subobject of an object referenced by an &lt;code&gt;atomic_ref&lt;/code&gt; object may be concurrently referenced by any other &lt;code&gt;atomic_ref&lt;/code&gt; object.</source>
          <target state="translated">对象的生存期必须超过引用该对象的所有 &lt;code&gt;atomic_ref&lt;/code&gt; 的生存期。当存在任何引用对象的 &lt;code&gt;atomic_ref&lt;/code&gt; 实例时，必须通过这些 &lt;code&gt;atomic_ref&lt;/code&gt; 实例以独占方式访问该对象。由 &lt;code&gt;atomic_ref&lt;/code&gt; 对象引用的对象的子对象不能由任何其他 &lt;code&gt;atomic_ref&lt;/code&gt; 对象同时引用。</target>
        </trans-unit>
        <trans-unit id="a71cb474b6739261f5b46ecfbc97690fb132e551" translate="yes" xml:space="preserve">
          <source>The lifetime of the array pointed to by the returned pointer is not specified, but in practice it persist as long as the RTTI data structure for the given type exists, which has application lifetime unless loaded from a dynamic library (that can be unloaded).</source>
          <target state="translated">返回指针指向的数组的寿命没有指定,但实际上只要给定类型的RTTI数据结构存在,它就会持久存在,除非从动态库中加载(可以卸载),否则它有应用寿命。</target>
        </trans-unit>
        <trans-unit id="f43e95e8be78827b0fca16403fd5210ff788dde7" translate="yes" xml:space="preserve">
          <source>The lifetime of the coroutine state is strictly nested within the lifetime of the caller, and</source>
          <target state="translated">coroutine状态的寿命严格嵌套在调用者的寿命内,而</target>
        </trans-unit>
        <trans-unit id="5a0b7c168044f4f8abc53a10a8fba540177660d1" translate="yes" xml:space="preserve">
          <source>The list of base classes is provided in the base-clause of the &lt;a href=&quot;class&quot;&gt;class declaration syntax&lt;/a&gt;. The base-clause consists of the character &lt;code&gt;:&lt;/code&gt; followed by a comma-separated list of one or more base-specifiers.</source>
          <target state="translated">基本类的列表在&lt;a href=&quot;class&quot;&gt;类声明语法&lt;/a&gt;的基本条款中提供。基本条款由以下字符组成 &lt;code&gt;:&lt;/code&gt; ,后接一个逗号分隔的一个或多个基本说明符列表。</target>
        </trans-unit>
        <trans-unit id="e8509d637336c6e1606720db4e003e047c2a510a" translate="yes" xml:space="preserve">
          <source>The list of exceptions in a &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; may also be a pack expansion.</source>
          <target state="translated">&lt;a href=&quot;except_spec&quot;&gt;动态异常规范&lt;/a&gt;中的异常列表也可以是包扩展。</target>
        </trans-unit>
        <trans-unit id="1d2a38cb5249a278425f59d24c4f0053fd48d52a" translate="yes" xml:space="preserve">
          <source>The list of parameters, as in &lt;a href=&quot;function&quot;&gt;named functions&lt;/a&gt;, except that &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; are not allowed(until C++14). If &lt;code&gt;auto&lt;/code&gt; is used as a type of a parameter, the lambda is a</source>
          <target state="translated">参数列表，与&lt;a href=&quot;function&quot;&gt;命名函数一样&lt;/a&gt;，只是不允许使用&lt;a href=&quot;default_arguments&quot;&gt;默认参数&lt;/a&gt;（直到C ++ 14）。如果将 &lt;code&gt;auto&lt;/code&gt; 用作参数的类型，则lambda是</target>
        </trans-unit>
        <trans-unit id="56ba40ec75d4e586507c6a313f3b68e7ecfe238c" translate="yes" xml:space="preserve">
          <source>The locale before the call to this function. Effectively returns the result of expression &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">调用此函数之前的语言环境。有效地返回表达式 &lt;code&gt;traits_i.imbue(loc)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="5a529ceb5bbb923af9b086a8c649b5e092235f98" translate="yes" xml:space="preserve">
          <source>The locale facility includes internationalization support for character classification and string collation, numeric, monetary, and date/time formatting and parsing, and message retrieval. Locale settings control the behavior of stream I/O, regular expression library, and other components of the C++ standard library.</source>
          <target state="translated">本地化设施包括对字符分类和字符串整理、数字、货币和日期/时间格式化和解析以及消息检索的国际化支持。本地化设置控制了流I/O、正则表达式库和C++标准库的其他组件的行为。</target>
        </trans-unit>
        <trans-unit id="6a18c5b3999c487308a7e91b96715e80aeb807b2" translate="yes" xml:space="preserve">
          <source>The locale object, associated with the stream before the operation.</source>
          <target state="translated">操作前与流相关联的locale对象。</target>
        </trans-unit>
        <trans-unit id="634778b18ec9739eca32858af18b0dca1f0f0da1" translate="yes" xml:space="preserve">
          <source>The locale used for localized behavior in the regular expression. Must be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">正则表达式中用于本地化行为的语言环境。必须是可&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;复制的&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8def683f0d8be3b6186d5dfddb9cf73b5969d06c" translate="yes" xml:space="preserve">
          <source>The logic operator expressions have the form.</source>
          <target state="translated">逻辑运算符表达式有如下形式。</target>
        </trans-unit>
        <trans-unit id="c3300cacfe4a9fc0c17331372ee202459b693b68" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;pred(x)&lt;/code&gt; 结果的逻辑补码。</target>
        </trans-unit>
        <trans-unit id="cba68059335b1355e50f5ebe51cc201e645ee88a" translate="yes" xml:space="preserve">
          <source>The logical complement of the result of calling &lt;code&gt;pred(x, y)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;pred(x, y)&lt;/code&gt; 的结果的逻辑补码。</target>
        </trans-unit>
        <trans-unit id="8fdd4b0ecee0c4aa58c8a23319359361fe1a2339" translate="yes" xml:space="preserve">
          <source>The lognormal_distribution random number distribution produces random numbers x &amp;gt; 0 according to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;log-normal distribution&lt;/a&gt;:  f(x; m,s) =</source>
          <target state="translated">所述lognormal_distribution随机数分布根据产生的随机数x&amp;gt; 0 &lt;a href=&quot;https://en.wikipedia.org/wiki/Log-normal_distribution&quot;&gt;数正态分布&lt;/a&gt;：F（X; M，S）=</target>
        </trans-unit>
        <trans-unit id="c212e644a85dc2243b9b6984f045c993a30403ee" translate="yes" xml:space="preserve">
          <source>The lookup for member &lt;code&gt;get&lt;/code&gt; ignores accessibility as usual and also ignores the exact type of the non-type template parameter. A private &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; member will cause the member interpretation to be used, even though it is ill-formed.</source>
          <target state="translated">对成员 &lt;code&gt;get&lt;/code&gt; 的查找照常忽略可访问性，并且也忽略非类型模板参数的确切类型。私有 &lt;code&gt;template&amp;lt;char*&amp;gt; void get();&lt;/code&gt; 成员将导致使用成员解释，即使其格式不正确。</target>
        </trans-unit>
        <trans-unit id="25f8094c991911b431b2e09c25ab9f0d486ffb8e" translate="yes" xml:space="preserve">
          <source>The lookup for the identifier &lt;code&gt;swap&lt;/code&gt; in the exception specification finds this function template in addition to anything found by the usual lookup rules, making the exception specification equivalent to C++17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">除了通过常规查找规则找到的内容外，在异常规范中查找标识符 &lt;code&gt;swap&lt;/code&gt; 的查找还可以找到此函数模板，从而使异常规范等效于C ++ 17 &lt;code&gt;&lt;a href=&quot;../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d22abe7f13a33e5aaa7ba9fe7d2fe4cac70e1316" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; may be used to determine the offset of any member from the beginning of a standard-layout class.</source>
          <target state="translated">宏 &lt;code&gt;&lt;a href=&quot;../types/offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; 可用于确定任何成员从标准布局类的开头开始的偏移。</target>
        </trans-unit>
        <trans-unit id="c041240d72efe54a8080b43aef6a5e9d20fb0e98" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; can only be used with standard-layout classes.</source>
          <target state="translated">宏 &lt;code&gt;&lt;a href=&quot;offsetof&quot;&gt;offsetof&lt;/a&gt;&lt;/code&gt; 只能与标准布局类一起使用。</target>
        </trans-unit>
        <trans-unit id="a80e1699fb25e0be7eaf64d7cde6fed39109e343" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NAN&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to a quiet not-a-number (QNaN) value. If the implementation does not support QNaNs, this macro constant is not defined.</source>
          <target state="translated">宏 &lt;code&gt;NAN&lt;/code&gt; 扩展为 &lt;code&gt;float&lt;/code&gt; 类型的常量表达式，该表达式的计算结果为安静的非数字（QNaN）值。如果实现不支持QNaN，则不定义此宏常量。</target>
        </trans-unit>
        <trans-unit id="511bc44ac64af1c05b670d54015e303e4e44b53b" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;NULL&lt;/code&gt; is an implementation-defined null pointer constant, which may be.</source>
          <target state="translated">宏 &lt;code&gt;NULL&lt;/code&gt; 是实现定义的空指针常量，可以是。</target>
        </trans-unit>
        <trans-unit id="e7a478300d3bf8ff1fa598a5f4a3701de66a2d50" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;offsetof&lt;/code&gt; expands to an integral constant expression of type &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, the value of which is the offset, in bytes, from the beginning of an object of specified type to its specified member, including padding if any.</source>
          <target state="translated">宏 &lt;code&gt;offsetof&lt;/code&gt; 扩展为 &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 类型的整数常量表达式，其值是从指定类型的对象开始到其指定成员的偏移量（以字节为单位），包括填充（如果有）。</target>
        </trans-unit>
        <trans-unit id="a5a472a05b4e53b9216f7fc0c3e059710e59c4a4" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;, which expands to the bitwise OR of all other &lt;code&gt;FE_*&lt;/code&gt;, is always defined and is zero if floating-point exceptions are not supported by the implementation.</source>
          <target state="translated">宏常量 &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; 扩展为所有其他 &lt;code&gt;FE_*&lt;/code&gt; 的按位或，始终定义，并且如果实现不支持浮点异常，则该常量为零。</target>
        </trans-unit>
        <trans-unit id="44aac1c9879022e9fba891603df04ea9ca8e044a" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;FE_DFL_ENV&lt;/code&gt; expands to an expression of type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, which points to a full copy of the default floating-point environment, that is, the environment as loaded at program startup.</source>
          <target state="translated">宏常量 &lt;code&gt;FE_DFL_ENV&lt;/code&gt; 扩展为 &lt;code&gt;const std::fenv_t*&lt;/code&gt; 类型的表达式，该表达式指向默认浮点环境（即程序启动时加载的环境）的完整副本。</target>
        </trans-unit>
        <trans-unit id="4e6484c8cfd3a1b8d998f588b04075f3f3fb6a9f" translate="yes" xml:space="preserve">
          <source>The macro constant &lt;code&gt;math_errhandling&lt;/code&gt; expands to an expression of type &lt;code&gt;int&lt;/code&gt; that is either equal to &lt;code&gt;MATH_ERRNO&lt;/code&gt;, or equal to &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt;, or equal to their bitwise OR (&lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt;).</source>
          <target state="translated">宏常量 &lt;code&gt;math_errhandling&lt;/code&gt; 扩展为 &lt;code&gt;int&lt;/code&gt; 类型的表达式，该表达式等于 &lt;code&gt;MATH_ERRNO&lt;/code&gt; 或 &lt;code&gt;MATH_ERREXCEPT&lt;/code&gt; ，或者等于它们的按位OR（ &lt;code&gt;MATH_ERRNO | MATH_ERREXCEPT&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1d50b82bba3614372048e0562a743464334498a2" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked with arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt;) are implemented as functions returning objects of unspecified type. These manipulators define their own &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; which perform the requested manipulation.</source>
          <target state="translated">用参数（例如 &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/setw&quot;&gt;std::setw&lt;/a&gt;(10);&lt;/code&gt; ）调用的操纵器实现为返回未​​指定类型对象的函数。这些操纵器定义了自己的 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 或 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; ，它们执行请求的操纵。</target>
        </trans-unit>
        <trans-unit id="016c7618765bc086feb76ffa7317750d2349efbd" translate="yes" xml:space="preserve">
          <source>The manipulators that are invoked without arguments (e.g. &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt;) are implemented as functions that take a reference to a stream as their only argument. The special overloads of &lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; accept pointers to these functions. These functions (or instantiations of function templates) are the only &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;addressable functions&lt;/a&gt; in the standard library.(since C++20).</source>
          <target state="translated">被不带参数调用的操纵器（例如 &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; &lt;a href=&quot;manip/hex&quot;&gt;std::hex&lt;/a&gt;;&lt;/code&gt; ）作为该取作为其唯一的参数传递给一个流的引用的功能来实现。&lt;a href=&quot;basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;的特殊重载接受指向这些函数的指针。这些函数（或函数模板的实例化）是标准库中唯一&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std#Addressable_functions&quot;&gt;可寻址的函数&lt;/a&gt;。（自C ++ 20起）。</target>
        </trans-unit>
        <trans-unit id="0acdda7356c347f1e3a711be9e894cc6cb8fd66c" translate="yes" xml:space="preserve">
          <source>The manner in which &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; is made space efficient (as well as whether it is optimized at all) is implementation defined. One potential optimization involves coalescing vector elements such that each element occupies a single bit instead of &lt;code&gt;sizeof(bool)&lt;/code&gt; bytes.</source>
          <target state="translated">实现方式定义了 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; 提高空间效率（以及是否进行了优化）的方式。一种潜在的优化方法是合并向量元素，以使每个元素占据单个位而不是 &lt;code&gt;sizeof(bool)&lt;/code&gt; 个字节。</target>
        </trans-unit>
        <trans-unit id="08f5f3a85d25f2d17a7f4389b37fef34e9befb11" translate="yes" xml:space="preserve">
          <source>The manner in which the arguments given at the OS command line are converted into the multibyte character arrays referenced by &lt;code&gt;argv&lt;/code&gt; may involve implementation-defined processing:</source>
          <target state="translated">在OS命令行中给定的参数转换为 &lt;code&gt;argv&lt;/code&gt; 引用的多字节字符数组的方式可能涉及实现定义的处理：</target>
        </trans-unit>
        <trans-unit id="58a4e89b5d75599c18d4cf2463da2bc790d5e376" translate="yes" xml:space="preserve">
          <source>The mapped value of &lt;code&gt;ch&lt;/code&gt; using the mapping identified by &lt;code&gt;desc&lt;/code&gt; in LC_CTYPE facet of the current C locale.</source>
          <target state="translated">使用在当前C语言环境的LC_CTYPE方面中由 &lt;code&gt;desc&lt;/code&gt; 标识的映射来映射 &lt;code&gt;ch&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="8da49c2641d38472ced25e1d078a923e49026a41" translate="yes" xml:space="preserve">
          <source>The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">为了避免创建不必要的临时对象，通常会尽可能长时间地延迟临时对象的实现：请参见&lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="030e1db264f4cf63958d4ac7eff5a182391b9628" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of arc sine is asin z = -</source>
          <target state="translated">弧形正弦的本值的数学定义是asin z=-。</target>
        </trans-unit>
        <trans-unit id="97d3912b761a5766d76f8e019b7647d3c28a58a9" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic cosine is acosh z = ln(z + &amp;radic;z+1&amp;radic;z-1)  For any z, acosh(z) =</source>
          <target state="translated">反双曲余弦值的数学定义是acosh z = ln（z +&amp;radic;z+1&amp;radic;z-1）对于任何z，acosh（z）=</target>
        </trans-unit>
        <trans-unit id="2ee0c302057514ba3aa0f5c20f8146065a6d4cf3" translate="yes" xml:space="preserve">
          <source>The mathematical definition of the principal value of the inverse hyperbolic sine is asinh z = ln(z + &amp;radic;1+z2</source>
          <target state="translated">反双曲正弦值的数学定义为asinh z = ln（z +&amp;radic;1+ z2</target>
        </trans-unit>
        <trans-unit id="e0ab357d29d58615b6db4b151ccaf98654e0e8b9" translate="yes" xml:space="preserve">
          <source>The mathematical functions in the standard library components do not throw this exception (mathematical functions report range errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">标准库组件中的数学函数不会引发此异常（数学函数报告 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 中指定的范围错误）。</target>
        </trans-unit>
        <trans-unit id="58113db72a97ac5e55ee3d47627cc11fbb811664" translate="yes" xml:space="preserve">
          <source>The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::overflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">标准库组件的数学函数不会引发此异常（数学函数报告 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 中指定的溢出错误）。但是，第三方库使用此库。例如，如果启用了 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; （默认设置），则&lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt;会引发 &lt;code&gt;std::overflow_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43eb628800204d96d7e81842c715db4a7e602e27" translate="yes" xml:space="preserve">
          <source>The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::overflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ce23e380db1867330cee83f35a43a3c26b63df" translate="yes" xml:space="preserve">
          <source>The maximum allocation size for OuterAlloc.</source>
          <target state="translated">OuterAlloc的最大分配大小。</target>
        </trans-unit>
        <trans-unit id="e6a66616954e988ad69d8232b96f5ad75ebaeb3d" translate="yes" xml:space="preserve">
          <source>The maximum number of &lt;code&gt;ExternT&lt;/code&gt; characters that could be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; to produce one &lt;code&gt;InternT&lt;/code&gt; character.</source>
          <target state="translated">如果由 &lt;code&gt;&lt;a href=&quot;in&quot;&gt;in()&lt;/a&gt;&lt;/code&gt; 转换以产生一个 &lt;code&gt;InternT&lt;/code&gt; 字符，则可能消耗的 &lt;code&gt;ExternT&lt;/code&gt; 字符的最大数目。</target>
        </trans-unit>
        <trans-unit id="c5d2605f57cf7a516878f1456bacc8bf68ff240d" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks that will be allocated at once from the upstream &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; to replenish the pool. If the value of &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; is zero or is greater than an implementation-defined limit, that limit is used instead. The implementation may choose to use a smaller value than is specified in this field and may use different values for different pools.</source>
          <target state="translated">从上游 &lt;code&gt;&lt;a href=&quot;memory_resource&quot;&gt;std::pmr::memory_resource&lt;/a&gt;&lt;/code&gt; 一次分配以补充池的最大块数。如果 &lt;code&gt;max_blocks_per_chunk&lt;/code&gt; 的值为零或大于实现定义的限制，则使用该限制。该实现可以选择使用比此字段中指定的值小的值，并且可以为不同的池使用不同的值。</target>
        </trans-unit>
        <trans-unit id="ef98d6b10d2a64071a19841e541af22baf6b008a" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">最高级别的所有权未指定。如果超出此数目，对 &lt;code&gt;try_lock&lt;/code&gt; 的调用将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf578a55e820eb222bfd9c3060644e38bddddff9" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_for&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">最高级别的所有权未指定。如果超出此数目，对 &lt;code&gt;try_lock_for&lt;/code&gt; 的调用将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7496f6de330e88cd441a674882cf192e5823a0c2" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. A call to &lt;code&gt;try_lock_until&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt; if this number is exceeded.</source>
          <target state="translated">最高级别的所有权未指定。如果超出此数目，对 &lt;code&gt;try_lock_until&lt;/code&gt; 的调用将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="516d0ea27a06242455894ddf3d9021aca322b598" translate="yes" xml:space="preserve">
          <source>The maximum number of levels of ownership is unspecified. An exception of type &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; will be thrown if this number is exceeded.</source>
          <target state="translated">最高级别的所有权未指定。如果超出此数目，将引发类型为 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="3f7c181bde374eeb6452476ff6b3a7543371ba08" translate="yes" xml:space="preserve">
          <source>The maximum number of times that a &lt;code&gt;recursive_mutex&lt;/code&gt; may be locked is unspecified, but after that number is reached, calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; will throw &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; and calls to &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">未指定 &lt;code&gt;recursive_mutex&lt;/code&gt; 可能被锁定的最大次数，但是达到该次数后，对&lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; 的&lt;/a&gt;调用将引发 &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 而对&lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; 的&lt;/a&gt;调用将返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a24b749dcce9aa560cb6a3f3aa6c86777a9e5381" translate="yes" xml:space="preserve">
          <source>The maximum of the elements.</source>
          <target state="translated">元素的最大值。</target>
        </trans-unit>
        <trans-unit id="2d061d5c7925797cceba9d91fa06eb294531985d" translate="yes" xml:space="preserve">
          <source>The maximum potentially generated value.</source>
          <target state="translated">最大潜在生成值。</target>
        </trans-unit>
        <trans-unit id="69a097b71a9a8b372efe8c272aa3e609c3c54fe8" translate="yes" xml:space="preserve">
          <source>The maximum supported allocation size.</source>
          <target state="translated">支持的最大分配规模。</target>
        </trans-unit>
        <trans-unit id="8c16c9cf3f818c29edfdff221593b78944e7d444" translate="yes" xml:space="preserve">
          <source>The maximum value potentially generated by the distribution.</source>
          <target state="translated">分布可能产生的最大价值。</target>
        </trans-unit>
        <trans-unit id="f173db7218831b033970ba26eec47af5157e549e" translate="yes" xml:space="preserve">
          <source>The meaning and the type of the result of this function is implementation-defined. On a POSIX system, this may be a value of type &lt;code&gt;pthread_cond_t*&lt;/code&gt;. On a Windows system, this may be a &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt;.</source>
          <target state="translated">此函数结果的含义和类型由实现定义。在POSIX系统上，这可以是 &lt;code&gt;pthread_cond_t*&lt;/code&gt; 类型的值。在Windows系统上，这可能是 &lt;code&gt;PCONDITION_VARIABLE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8b50f9c9a68f338aee12b4deb4d472419d36c02" translate="yes" xml:space="preserve">
          <source>The meaning of the format specifiers are:</source>
          <target state="translated">格式指定符的含义是:</target>
        </trans-unit>
        <trans-unit id="5c2b2f950c575d77dea5f7dca516f87942977025" translate="yes" xml:space="preserve">
          <source>The mechanism for selecting the build level is implementation-defined. Combining translation units that were translated at different build levels is conditionally-supported.</source>
          <target state="translated">选择构建级别的机制由实施定义。有条件地支持合并在不同构建级别翻译的翻译单元。</target>
        </trans-unit>
        <trans-unit id="69ef650d47f1d92c2572bf80d049412bb1aad754" translate="yes" xml:space="preserve">
          <source>The member &lt;code&gt;operator()&lt;/code&gt; effectively returns the same value as &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">成员 &lt;code&gt;operator()&lt;/code&gt; 有效地返回与 &lt;code&gt;&lt;a href=&quot;hash_code&quot;&gt;hash_code()&lt;/a&gt;&lt;/code&gt; 相同的值。</target>
        </trans-unit>
        <trans-unit id="68d7297c4dbfb9ca93d5a11a625ec7d05314ebfc" translate="yes" xml:space="preserve">
          <source>The member access operator expressions have the form.</source>
          <target state="translated">成员访问操作符表达式的形式为:。</target>
        </trans-unit>
        <trans-unit id="9ac4e03045a811db7fdf9a33fae47eaa532e51b8" translate="yes" xml:space="preserve">
          <source>The member access operator expressions through pointers to members have the form.</source>
          <target state="translated">通过指向成员的指针的成员访问操作符表达式具有这样的形式。</target>
        </trans-unit>
        <trans-unit id="d1f68969edf8b53ae807e1ece64ebe13ea9b9298" translate="yes" xml:space="preserve">
          <source>The member access through pointer to member &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;smart pointer interface&lt;/a&gt;, and in fact is used in that capacity by actors in &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt;. It is more common in EDSLs such as &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt;.</source>
          <target state="translated">成员通过指向成员 &lt;code&gt;operator-&amp;gt;*&lt;/code&gt; 的指针进行访问。重载此运算符没有特定的缺点，但实际上很少使用。有人建议它可以是&lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;智能指针接口的&lt;/a&gt;一部分，并且实际上由&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix中&lt;/a&gt;的参与者以这种方式使用。它在cpp.react等&lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;EDSL中&lt;/a&gt;更为常见。</target>
        </trans-unit>
        <trans-unit id="89feaad6ef39273143072a5bab0c6502c099dc36" translate="yes" xml:space="preserve">
          <source>The member access through pointer to member &lt;code&gt;operator-&amp;gt;*&lt;/code&gt;. There are no specific downsides to overloading this operator, but it is rarely used in practice. It was suggested that it could be part of &lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Oct_1999.pdf&quot;&gt;smart pointer interface&lt;/a&gt;, and in fact is used in that capacity by actors in &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/phoenix/doc/html/phoenix/modules/operator.html#phoenix.modules.operator.member_pointer_operator&quot;&gt;boost.phoenix&lt;/a&gt;. It is more common in EDSLs such as &lt;a href=&quot;https://github.com/schlangster/cpp.react/blob/master/include/react/Signal.h#L557&quot;&gt;cpp.react&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="239a9f71d3cf420873e0877dbfed19f440ad8974" translate="yes" xml:space="preserve">
          <source>The member character sequence in a buffer open for writing can be over-allocated for efficiency purposes. In that case, only the</source>
          <target state="translated">为了提高效率,可以超额分配打开的缓冲区中待写的成员字符序列。在这种情况下,只有</target>
        </trans-unit>
        <trans-unit id="05e762769a30065e204bb28bf51cb0273777e561" translate="yes" xml:space="preserve">
          <source>The member constants in &lt;code&gt;basic_regex&lt;/code&gt; are duplicates of the &lt;a href=&quot;syntax_option_type&quot;&gt;syntax_option_type&lt;/a&gt; constants defined in the namespace &lt;code&gt;std::regex_constants&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;basic_regex&lt;/code&gt; 中的成员常量是在名称空间 &lt;code&gt;std::regex_constants&lt;/code&gt; 定义的&lt;a href=&quot;syntax_option_type&quot;&gt;语法_option_type&lt;/a&gt;常量的重复。</target>
        </trans-unit>
        <trans-unit id="15df05692a271ee845f25f3cb5b040794f20a534" translate="yes" xml:space="preserve">
          <source>The member function &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">调用成员函数 &lt;code&gt;&lt;a href=&quot;optional/reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efb92cc5bc9ac09558948d91fa6f04f3671a172b" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; 的Searcher重载调用的成员函数，以使用此Searcher 执行搜索。</target>
        </trans-unit>
        <trans-unit id="02d35ef45a2be736ac5d48567bf5243bd00060f5" translate="yes" xml:space="preserve">
          <source>The member function called by the Searcher overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; to perform a search with this searcher. &lt;code&gt;RandomIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">由 &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; 的Searcher重载调用的成员函数，以使用此Searcher 执行搜索。 &lt;code&gt;RandomIt2&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d5b7b86f4cef7432fea2b9bc1aebd9323994e41" translate="yes" xml:space="preserve">
          <source>The member functions introduced by a using-declaration into a derived class are considered to be members of the derived class for the purpose of defining the type of the</source>
          <target state="translated">使用声明引入派生类的成员函数被认为是派生类的成员,以便定义派生类的类型。</target>
        </trans-unit>
        <trans-unit id="764b4e1ee289e17bad4f60ec0a9d42691689afe9" translate="yes" xml:space="preserve">
          <source>The member functions of &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; and the &lt;code&gt;std::initializer_list&lt;/code&gt; overloads of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 的成员函数以及 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;std::initializer_list&lt;/code&gt; 重载</target>
        </trans-unit>
        <trans-unit id="bc2f6b335fdc83b3a9f3feda6af5eaac09524b21" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the hash of the underlying type might throw.</source>
          <target state="translated">这个特殊化的成员函数不保证是noexcept,因为底层类型的哈希可能会抛出。</target>
        </trans-unit>
        <trans-unit id="ef67f3b96aad3f43ceefc11f4c679e1c0ac92843" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept because the pointer may be a fancy pointer and its hash might throw.</source>
          <target state="translated">这个特殊化的成员函数不保证是noexcept,因为指针可能是一个花哨的指针,其哈希可能会抛出。</target>
        </trans-unit>
        <trans-unit id="833dfb1c2bf2f506172d76aae796695e09f833e7" translate="yes" xml:space="preserve">
          <source>The member functions of this specialization are not guaranteed to be noexcept.</source>
          <target state="translated">本专业的成员函数不保证是noexcept。</target>
        </trans-unit>
        <trans-unit id="5e5711660055f235ace0e4ed3873cb22e451c3b1" translate="yes" xml:space="preserve">
          <source>The member functions return defined default values unless the &lt;code&gt;matched&lt;/code&gt; member is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">成员函数返回定义的默认值，除非 &lt;code&gt;matched&lt;/code&gt; 成员为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b48a3030fca44418386968b5abfc5df76aac60a3" translate="yes" xml:space="preserve">
          <source>The member interpretation is used if the range type has a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt;. This is done regardless of whether the member is a type, data member, function, or enumerator, and regardless of its accessibility. Thus a class like &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; cannot be used with the range-based for loop even if the namespace-scope begin/end functions are present.</source>
          <target state="translated">如果范围类型具有名为 &lt;code&gt;begin&lt;/code&gt; 的成员和名为 &lt;code&gt;end&lt;/code&gt; 的成员，则使用成员解释。无论成员是类型，数据成员，函数还是枚举数，以及其可访问性如何，都将执行此操作。因此，像 &lt;code&gt;class meow { enum { begin = 1, end = 2}; /* rest of class */ };&lt;/code&gt; 这样的类{枚举{开始= 1，结束= 2}; / *课程的其余部分* /}; 即使存在命名空间范围的开始/结束功能，也不能与基于范围的for循环一起使用。</target>
        </trans-unit>
        <trans-unit id="d02cf71c651a6bbe450e9796516bdcd13d4f27a6" translate="yes" xml:space="preserve">
          <source>The member names of the</source>
          <target state="translated">的成员名称。</target>
        </trans-unit>
        <trans-unit id="b6068893a255d37e81d9aa5432b3ceed4971bdcc" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;conjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;conjunction&lt;/code&gt;.</source>
          <target state="translated">除 &lt;code&gt;conjunction&lt;/code&gt; 和 &lt;code&gt;operator=&lt;/code&gt; 以外，基类的成员名称未隐藏，并且可以明确地使用 &lt;code&gt;conjunction&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab1bc84edd2dcc31d9c428be3ac37ab55ba141eb" translate="yes" xml:space="preserve">
          <source>The member names of the base class, other than &lt;code&gt;disjunction&lt;/code&gt; and &lt;code&gt;operator=&lt;/code&gt;, are not hidden and are unambiguously available in &lt;code&gt;disjunction&lt;/code&gt;.</source>
          <target state="translated">除 &lt;code&gt;disjunction&lt;/code&gt; 和 &lt;code&gt;operator=&lt;/code&gt; 以外，基类的成员名称未隐藏，并且在 &lt;code&gt;disjunction&lt;/code&gt; 中明确可用。</target>
        </trans-unit>
        <trans-unit id="88413da3549b10a5d3c5e5a05a9f77dbd30567cc" translate="yes" xml:space="preserve">
          <source>The member operator() is noexcept if the &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; expression it calls is noexcept (in other words, it preserves the exception specification of the underlying call operator).</source>
          <target state="translated">如果其 &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; 的std :: invoke表达式为noexcept，则成员operator（）为noexcept （换句话说，它保留基础调用运算符的异常规范）。</target>
        </trans-unit>
        <trans-unit id="99180f77f5a8ca80c11eb2a7965cbabfd4d9c9cc" translate="yes" xml:space="preserve">
          <source>The member specification, or the</source>
          <target state="translated">成员规格,或</target>
        </trans-unit>
        <trans-unit id="6247f710bbdb924881ced1b35c970d774f909927" translate="yes" xml:space="preserve">
          <source>The member template class &lt;code&gt;rebind&lt;/code&gt; provides a way to obtain an allocator for a different type. For example,</source>
          <target state="translated">成员模板类 &lt;code&gt;rebind&lt;/code&gt; 提供了一种获取不同类型的分配器的方法。例如，</target>
        </trans-unit>
        <trans-unit id="03f1ae3b478686fb238fb267920a6735d4e1a474" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;X::pointer&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">成员类型 &lt;code&gt;X::pointer&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2a0ec56c51738314ed8d919d00be55a70b110d4" translate="yes" xml:space="preserve">
          <source>The member type &lt;code&gt;is_transparent&lt;/code&gt; indicates to the caller that this function object is a</source>
          <target state="translated">成员类型 &lt;code&gt;is_transparent&lt;/code&gt; 向调用者指示此函数对象是一个</target>
        </trans-unit>
        <trans-unit id="97d1ac879c7a04ed1084ddb26ee5600ac333f1dc" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::iterator&lt;/code&gt; and &lt;code&gt;X::const_iterator&lt;/code&gt; are &lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterators&lt;/a&gt;</source>
          <target state="translated">成员类型 &lt;code&gt;X::iterator&lt;/code&gt; 和 &lt;code&gt;X::const_iterator&lt;/code&gt; 是&lt;a href=&quot;contiguousiterator&quot;&gt;LegacyContiguousIterators&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="189eb458b5906253d856798d17eff7858e326e0c" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;X::pointer&lt;/code&gt;, &lt;code&gt;X::const_pointer&lt;/code&gt;, &lt;code&gt;X::void_pointer&lt;/code&gt; and &lt;code&gt;X::const_void_pointer&lt;/code&gt; of every &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">每个&lt;a href=&quot;allocator&quot;&gt;分配器&lt;/a&gt;类型 &lt;code&gt;X&lt;/code&gt; 的成员类型 &lt;code&gt;X::pointer&lt;/code&gt; ， &lt;code&gt;X::const_pointer&lt;/code&gt; ， &lt;code&gt;X::void_pointer&lt;/code&gt; 和 &lt;code&gt;X::const_void_pointer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="743df5645d4509941f7715864c429844824ed55b" translate="yes" xml:space="preserve">
          <source>The member types &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; may be aliases to the same type. Since &lt;code&gt;iterator&lt;/code&gt; is convertible to &lt;code&gt;const_iterator&lt;/code&gt;, &lt;code&gt;const_iterator&lt;/code&gt; should be used in function parameter lists to avoid violations of the One Definition Rule.</source>
          <target state="translated">成员类型的 &lt;code&gt;iterator&lt;/code&gt; 和 &lt;code&gt;const_iterator&lt;/code&gt; 可以是同一类型的别名。由于 &lt;code&gt;iterator&lt;/code&gt; 可以转换为 &lt;code&gt;const_iterator&lt;/code&gt; ， &lt;code&gt;const_iterator&lt;/code&gt; 应该在函数参数列表中使用，以避免违反一个定义规则。</target>
        </trans-unit>
        <trans-unit id="4efe6ec44ec82b96dea5c4b0710d2c28b043d1ac" translate="yes" xml:space="preserve">
          <source>The members have the following meaning:</source>
          <target state="translated">这些成员具有以下含义:</target>
        </trans-unit>
        <trans-unit id="e6dadd198818909e166ec932a678a2a940461078" translate="yes" xml:space="preserve">
          <source>The memory available to a C++ program is one or more contiguous sequences of</source>
          <target state="translated">一个C++程序可用的内存是一个或多个连续的序列,这些序列包括</target>
        </trans-unit>
        <trans-unit id="037dde83ce079503b4e08f9c73501e2afb83137e" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;succ&lt;/code&gt; and &lt;code&gt;fail&lt;/code&gt; respectively. The (1-2) versions use &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; by default.</source>
          <target state="translated">读-修改-写和加载操作的内存模型分别为 &lt;code&gt;succ&lt;/code&gt; 和 &lt;code&gt;fail&lt;/code&gt; 。（1-2）版本默认使用 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a1f66f39bcd63450604a4fcb472208a00fc0663" translate="yes" xml:space="preserve">
          <source>The memory models for the read-modify-write and load operations are &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;failure&lt;/code&gt; respectively. In the (2) and (4) versions &lt;code&gt;order&lt;/code&gt; is used for both read-modify-write and load operations, except that &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; are used for the load operation if &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">读-修改-写和加载操作的内存模型分别是 &lt;code&gt;success&lt;/code&gt; 和 &lt;code&gt;failure&lt;/code&gt; 。在（2）和（4）版本中， &lt;code&gt;order&lt;/code&gt; 用于读取，修改，写入和加载操作，但如果 &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../memory_order&quot;&gt;std :: memory_order_acq_rel&lt;/a&gt;，则将 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; 用于加载操作，或 &lt;code&gt;order == &lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../memory_order&quot;&gt;std :: memory_order_release&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1aed46d8db03878f84ce9975ff764e9083e6702c" translate="yes" xml:space="preserve">
          <source>The memory resource pointer used by this polymorphic allocator.</source>
          <target state="translated">该多态分配器使用的内存资源指针。</target>
        </trans-unit>
        <trans-unit id="6f83b6ed70462af18ce1b14250e467f4f95844bf" translate="yes" xml:space="preserve">
          <source>The memory-writing conversion specifier &lt;code&gt;%n&lt;/code&gt; is a common target of security exploits where format strings depend on user input and is not supported by the bounds-checked &lt;code&gt;printf_s&lt;/code&gt; family of functions.</source>
          <target state="translated">内存写入转换说明符 &lt;code&gt;%n&lt;/code&gt; 是安全漏洞利用的常见目标，其中格式字符串取决于用户输入，并且不受边界检查的 &lt;code&gt;printf_s&lt;/code&gt; 函数家族的支持。</target>
        </trans-unit>
        <trans-unit id="f9bdd1c45276cceff72dd22eaf8b65416fc4d7fe" translate="yes" xml:space="preserve">
          <source>The message from the catalog or a copy of &lt;code&gt;dfault&lt;/code&gt; if none was found.</source>
          <target state="translated">目录中的消息或 &lt;code&gt;dfault&lt;/code&gt; 副本（如果未找到）。</target>
        </trans-unit>
        <trans-unit id="9d90f0cf5503392d1c2a08fa622e0683a067c582" translate="yes" xml:space="preserve">
          <source>The minimum of the elements.</source>
          <target state="translated">元素的最小值。</target>
        </trans-unit>
        <trans-unit id="c57eecd663caaf3065c20e7f0d66aee57b9dc3f2" translate="yes" xml:space="preserve">
          <source>The minimum potentially generated value.</source>
          <target state="translated">潜在产生的最小值;</target>
        </trans-unit>
        <trans-unit id="537c9aead08e9763da9b55897fd3bfcdaaa4e86a" translate="yes" xml:space="preserve">
          <source>The minimum value potentially generated by the distribution.</source>
          <target state="translated">分布可能产生的最小值;</target>
        </trans-unit>
        <trans-unit id="b3bcade615775889eac9bb5e7a58de484f254bd4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EC&lt;/code&gt; writes the locale's alternative representation of the century.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%EC&lt;/code&gt; 编写了世纪的语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="75f0dc4bd53f64c06e6fa0ff392db719eabb0f3d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; interprets the locale's alternate time representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%EX&lt;/code&gt; 解释语言环境的备用时间表示形式。</target>
        </trans-unit>
        <trans-unit id="8bec27fca38ee75b95e3d0eaf504b8384963b028" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EX&lt;/code&gt; writes the locale's alternate time representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%EX&lt;/code&gt; 写入语言环境的备用时间表示形式。</target>
        </trans-unit>
        <trans-unit id="ee3cd7f7d1a25a1212fb29ddd03a9ef8472c165d" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%EY&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%EY&lt;/code&gt; 解释语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="1c68da4605fcc44c21d173eb10055c069c70b906" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; interprets the locale's alternative date and time representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ec&lt;/code&gt; 解释语言环境的替代日期和时间表示。</target>
        </trans-unit>
        <trans-unit id="a9a1950a1c24f9659bd1e5f981ceb85d050b8767" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ec&lt;/code&gt; writes the locale's alternative date and time representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ec&lt;/code&gt; 写入语言环境的替代日期和时间表示。</target>
        </trans-unit>
        <trans-unit id="e5775f2037b71dc38628c3500d791bc260bbebcb" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; interprets the locale's alternate date representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ex&lt;/code&gt; 解释语言环境的备用日期表示形式。</target>
        </trans-unit>
        <trans-unit id="bb64ab15333504747771454a51c8294973e64441" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ex&lt;/code&gt; produces the locale's alternate date representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ex&lt;/code&gt; 生成语言环境的备用日期表示形式。</target>
        </trans-unit>
        <trans-unit id="14f6995f41f4a2d2134344889d2b79f5bfd0bf66" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%OH&lt;/code&gt; 解释语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="da00c4361910133feb2655f2790d2c1bb35c3217" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OH&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%OH&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="02e1996d6f854882e96f32146e024df272f3e789" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OI&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%OI&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="283ff3b42755095dc2a58cb25631e8f808fd7dc4" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%OM&lt;/code&gt; 解释语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="2256cc6eb2ce9c6dcb14d9932189e3173fe6fb7b" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OM&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%OM&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="e18d9132406fc6f5671d9b0f4de1913dbd9ea54c" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%OS&lt;/code&gt; 解释语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="735aa83ce9d55484119953184990a8a3c5ef2bf3" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OS&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%OS&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="8dc1c917e7b33d49bec0f32a6ee8ce91fe3898be" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OU&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%OU&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="fed0585fe25d67debd6eae7991bab2b8338b1306" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OV&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%OV&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="39e0e2ebc4225fd4de3a9212027bfa57ba77c5c1" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%OW&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%OW&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="b8c0342bc98a8d9ac901f7fa48dc3728088a24cf" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Od&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Od&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="23a1adfc45649b52f8d2f79649429566f6756cd0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Oe&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Oe&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="3f211113e01d87804b53bf0839dc4545235c21b5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Om&lt;/code&gt; 解释语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="6bfc0f055c1fd26cc9dfcc3dd3e7269715d8fbdd" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Om&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Om&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="4738bf4fa0770676817bc173268ec85ebdefcba5" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ou&lt;/code&gt; 解释语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="28885626f1f9a4c0bc54a2f829547cf0075f8fc0" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ou&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ou&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="46f001b91727d0cd13635e13519f0c94ccb1c799" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; interprets the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ow&lt;/code&gt; 解释语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="116f6b00825f4347d9b3ad162c904523d7a741ec" translate="yes" xml:space="preserve">
          <source>The modified command &lt;code&gt;%Ow&lt;/code&gt; writes the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ow&lt;/code&gt; 写入语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="eeffbf82acb0112a4308b4adc0a39d3f2e8cd8e8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%EC&lt;/code&gt; and &lt;code&gt;%OC&lt;/code&gt; interpret the locale's alternative representation of the century.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%EC&lt;/code&gt; 和 &lt;code&gt;%OC&lt;/code&gt; 解释了语言环境对世纪的替代表示。</target>
        </trans-unit>
        <trans-unit id="1f8b1cf22bf3b662efdfa9705f03b9deebed9290" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ed&lt;/code&gt; and &lt;code&gt;%Ee&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ed&lt;/code&gt; 和 &lt;code&gt;%Ee&lt;/code&gt; 解释语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="3d9c4fc10338b78eb69266a4a35ef3927badf16c" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ey&lt;/code&gt; and &lt;code&gt;%Oy&lt;/code&gt; interpret the locale's alternative representation.</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ey&lt;/code&gt; 和 &lt;code&gt;%Oy&lt;/code&gt; 解释语言环境的替代表示形式。</target>
        </trans-unit>
        <trans-unit id="c680b13d4cfe115916d50f79a4e761597d1ce5f8" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; insert a &lt;code&gt;:&lt;/code&gt; between the hours and minutes (e.g., &lt;code&gt;-04:30&lt;/code&gt;).</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ez&lt;/code&gt; 和 &lt;code&gt;%Oz&lt;/code&gt; 在小时和分钟之间插入一个 &lt;code&gt;:&lt;/code&gt; (例如 &lt;code&gt;-04:30&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="967e201acaf95797b9f2a6182b751263d355c430" translate="yes" xml:space="preserve">
          <source>The modified commands &lt;code&gt;%Ez&lt;/code&gt; and &lt;code&gt;%Oz&lt;/code&gt; parses the format &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; (i.e., requiring a &lt;code&gt;:&lt;/code&gt; between the hours and minutes and making the leading zero for hour optional).</source>
          <target state="translated">修改后的命令 &lt;code&gt;%Ez&lt;/code&gt; 和 &lt;code&gt;%Oz&lt;/code&gt; 解析格式 &lt;code&gt;[+|-]h[h][:mm]&lt;/code&gt; （即，在小时和分钟之间需要一个 &lt;code&gt;:&lt;/code&gt; ，并使小时的前导零成为可选）。</target>
        </trans-unit>
        <trans-unit id="b675bd758d57655fae835bb898a51c3bcb35971b" translate="yes" xml:space="preserve">
          <source>The monetary format is an array of four &lt;code&gt;char&lt;/code&gt;s convertible to &lt;code&gt;std::money_base::part&lt;/code&gt;. In that sequence, each of &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;sign&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt; appears exactly once, and either &lt;code&gt;space&lt;/code&gt; or &lt;code&gt;none&lt;/code&gt; appears in the remaining position. The value &lt;code&gt;none&lt;/code&gt;, if present, is not first; the value &lt;code&gt;space&lt;/code&gt;, if present, is neither first nor last.</source>
          <target state="translated">货币格式是可转换为 &lt;code&gt;std::money_base::part&lt;/code&gt; 的四个 &lt;code&gt;char&lt;/code&gt; 的数组。在该序列中，每个 &lt;code&gt;symbol&lt;/code&gt; ， &lt;code&gt;sign&lt;/code&gt; ，和 &lt;code&gt;value&lt;/code&gt; 出现恰好一次，并且或者 &lt;code&gt;space&lt;/code&gt; 或 &lt;code&gt;none&lt;/code&gt; 出现在其余位置。如果存在值 &lt;code&gt;none&lt;/code&gt; ，则它不是第一个；值 &lt;code&gt;space&lt;/code&gt; （如果存在）既不是第一个也不是最后一个。</target>
        </trans-unit>
        <trans-unit id="57df9eb0b96a23c853c95f72ee4e1aa61512a265" translate="yes" xml:space="preserve">
          <source>The month value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">存储在 &lt;code&gt;*this&lt;/code&gt; 中的月份值。</target>
        </trans-unit>
        <trans-unit id="e90e2ca09851d3473823a48772a0e35e7c3866b3" translate="yes" xml:space="preserve">
          <source>The most-derived type of &lt;code&gt;other&lt;/code&gt; may not match the most derived type of &lt;code&gt;*this&lt;/code&gt;. A derived class implementation therefore must typically check whether the most derived types of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; match using &lt;code&gt;dynamic_cast&lt;/code&gt;, and immediately return &lt;code&gt;false&lt;/code&gt; if the cast fails.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 类型的最派生类型可能与 &lt;code&gt;*this&lt;/code&gt; 的最大派生类型不匹配。因此，派生类实现通常必须使用 &lt;code&gt;dynamic_cast&lt;/code&gt; 检查 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 类的最派生类型是否匹配，如果强制转换失败，则立即返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16d05d9f68ef63dd77ebb7c2b2b018270c08172b" translate="yes" xml:space="preserve">
          <source>The motivation behind &lt;code&gt;std::result_of&lt;/code&gt; is to determine the result of invoking a &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;, in particular if that result type is different for different sets of arguments.</source>
          <target state="translated">&lt;code&gt;std::result_of&lt;/code&gt; 背后的动机是确定调用&lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;的结果，尤其是对于不同的参数集而言，如果该结果类型不同。</target>
        </trans-unit>
        <trans-unit id="be939183f398e144c5a9f5a26339a5ff2df358bf" translate="yes" xml:space="preserve">
          <source>The move assignment operator for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">如果满足以下所有条件，则类别 &lt;code&gt;T&lt;/code&gt; 的移动分配运算符很简单：</target>
        </trans-unit>
        <trans-unit id="913a05bd12f57d4991f4c434437ba8fdc8ca96af" translate="yes" xml:space="preserve">
          <source>The move assignment operator is called whenever it is selected by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.</source>
          <target state="translated">只要通过&lt;a href=&quot;overload_resolution&quot;&gt;重载分辨率&lt;/a&gt;选择了移动赋值运算符，就将调用该赋值运算符，例如，当一个对象出现在赋值表达式的左侧时，其中右侧是相同或隐式可转换类型的右值。</target>
        </trans-unit>
        <trans-unit id="964822bbec02f38193fe2598cdea03b6e1354a55" translate="yes" xml:space="preserve">
          <source>The move constructor for class &lt;code&gt;T&lt;/code&gt; is trivial if all of the following is true:</source>
          <target state="translated">如果满足以下所有条件，则类 &lt;code&gt;T&lt;/code&gt; 的move构造函数是微不足道的：</target>
        </trans-unit>
        <trans-unit id="43ecab829b4442770406c7743a4c24f8d39184e8" translate="yes" xml:space="preserve">
          <source>The move constructor is typically called when an object is &lt;a href=&quot;initialization&quot;&gt;initialized&lt;/a&gt; (by &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; or &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;) from &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; (xvalue or prvalue)(until C++17)xvalue(since C++17) of the same type, including.</source>
          <target state="translated">从相同类型的&lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt;（xvalue或prvalue）（直到C ++ 17）xvalue（自C ++ 17起）&lt;a href=&quot;initialization&quot;&gt;初始化&lt;/a&gt;（通过&lt;a href=&quot;direct_initialization&quot;&gt;直接初始化&lt;/a&gt;或&lt;a href=&quot;copy_initialization&quot;&gt;复制初始化&lt;/a&gt;）对象时，通常会调用move构造函数。</target>
        </trans-unit>
        <trans-unit id="6c57480f2676fa3a3bf78ec56583003322efec68" translate="yes" xml:space="preserve">
          <source>The multibyte encoding used by this function is specified by the currently active C locale.</source>
          <target state="translated">该函数使用的多字节编码由当前活动的C语言区指定。</target>
        </trans-unit>
        <trans-unit id="3934767ca9f156dfb707eb56bde26fbae9cf9bf0" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored.</source>
          <target state="translated">多字节空字符进行了转换和存储。</target>
        </trans-unit>
        <trans-unit id="a13f36d11d813ad1aa81620c3624a0829c3d680e" translate="yes" xml:space="preserve">
          <source>The multibyte null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">多字节空字符已转换并存储。 &lt;code&gt;src&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;*ps&lt;/code&gt; 表示初始移位状态。</target>
        </trans-unit>
        <trans-unit id="afaeafb6cba6f4e054dc4876689069feee1d4951" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution in shared mode, otherwise, the behavior is undefined.</source>
          <target state="translated">该mutex必须被共享模式下的当前执行线程锁定,否则,该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="9efc369f87fb8cd445bfe13d9edeb971e0837953" translate="yes" xml:space="preserve">
          <source>The mutex must be locked by the current thread of execution, otherwise, the behavior is undefined.</source>
          <target state="translated">该mutex必须被当前执行的线程锁定,否则,该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="2c6d8525b20aacdba1419fafc3fc7f5ae08bc2dd" translate="yes" xml:space="preserve">
          <source>The n distribution parameter.</source>
          <target state="translated">n分布参数。</target>
        </trans-unit>
        <trans-unit id="96123ca150593776b8703cdefba85a9b3570e940" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;array::elems&lt;/code&gt; is only for exposition, it's not part of the interface.</source>
          <target state="translated">名称 &lt;code&gt;array::elems&lt;/code&gt; 仅用于说明，它不是接口的一部分。</target>
        </trans-unit>
        <trans-unit id="db9a37193da19fc9dd60f45b310779d49a73e6a1" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;posix&lt;/code&gt; is reserved for a future top-level namespace. The behavior is undefined if a program declares or defines anything in that namespace.</source>
          <target state="translated">名称 &lt;code&gt;posix&lt;/code&gt; 保留用于将来的顶级名称空间。如果程序在该名称空间中声明或定义了任何内容，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="3705e1c5df92bb63d55f69679ede335b0b4b0b65" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="translated">名称 &lt;code&gt;proxy&lt;/code&gt; 仅用于说明。</target>
        </trans-unit>
        <trans-unit id="fc982d2e54ad63316d942020cd2cc954f5238174" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;ranges::swap&lt;/code&gt; denotes a</source>
          <target state="translated">名称 &lt;code&gt;ranges::swap&lt;/code&gt; 表示一个</target>
        </trans-unit>
        <trans-unit id="2aed87bc0a44df46c92723b411bf691a391dd142" translate="yes" xml:space="preserve">
          <source>The name of a non-static data member or a non-static member function can only appear in the following three situations:</source>
          <target state="translated">非静态数据成员或非静态成员函数的名称只能在以下三种情况下出现。</target>
        </trans-unit>
        <trans-unit id="89cb222de00d870b7103bfa145f09bcde84c1415" translate="yes" xml:space="preserve">
          <source>The name of an enumerator introduced in a &lt;a href=&quot;enum&quot;&gt;scoped enumeration&lt;/a&gt; begins at the point of declaration and ends at the end of the enum specifier (in contrast, unscoped enumerators are in scope after the end of the enum specifier).</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt;范围&lt;/a&gt;枚举中引入的枚举器的名称始于声明点，并终止于枚举说明符的末尾（相比之下，未作用域的枚举器在范围内位于枚举说明符的末尾）。</target>
        </trans-unit>
        <trans-unit id="10cae2ebd2504e13706f02700ec469c53921536e" translate="yes" xml:space="preserve">
          <source>The name of an unscoped enumeration may be omitted: such declaration only introduces the enumerators into the enclosing scope:</source>
          <target state="translated">未覆盖的枚举的名称可以省略:这样的声明只是将枚举者引入到包围的作用域中。</target>
        </trans-unit>
        <trans-unit id="814dfe2ccc46c197be3bf6a8df03805774f01aa8" translate="yes" xml:space="preserve">
          <source>The name of every &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; member (static, non-static, function, type, etc) has an associated &quot;member access&quot;. When a name of the member is used anywhere a program, its access is checked, and if it does not satisfy the access rules, the program does not compile:</source>
          <target state="translated">每个&lt;a href=&quot;class&quot;&gt;类&lt;/a&gt;成员的名称（静态，非静态，函数，类型等）都有关联的&amp;ldquo;成员访问权&amp;rdquo;。当在程序的任何位置使用成员的名称时，将检查其访问权限，如果不满足访问规则，则该程序不会编译：</target>
        </trans-unit>
        <trans-unit id="59568709b5ee764a18b13d2df686742954820331" translate="yes" xml:space="preserve">
          <source>The name of the associated &lt;code&gt;type_info&lt;/code&gt; object.</source>
          <target state="translated">关联的 &lt;code&gt;type_info&lt;/code&gt; 对象的名称。</target>
        </trans-unit>
        <trans-unit id="ccf301417aa7c5ce4d3a1d2609e3c2ea16a28b7f" translate="yes" xml:space="preserve">
          <source>The name of the locale or &quot;*&quot; if unnamed.</source>
          <target state="translated">地点名称,如果未命名,则为 &quot;*&quot;。</target>
        </trans-unit>
        <trans-unit id="ab62ba490e7db4c1ba2cce1f51033276d065dbc5" translate="yes" xml:space="preserve">
          <source>The name of the nested class exists in the scope of the enclosing class, and name lookup from a member function of a nested class visits the scope of the enclosing class after examining the scope of the nested class. Like any member of its enclosing class, the nested class has access to all names (private, protected, etc) to which the enclosing class has access, but it is otherwise independent and has no special access to the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer of the enclosing class.</source>
          <target state="translated">嵌套类的名称存在于封闭类的范围内，并且在检查嵌套类的范围之后，从嵌套类的成员函数进行的名称查找将访问封闭类的范围。像其封闭类的任何成员一样，嵌套类可以访问封闭类可以访问的所有名称（私有，受保护等），但是它是独立的，并且对封闭类的&lt;a href=&quot;this&quot;&gt;this&lt;/a&gt;指针没有特殊的访问权限。</target>
        </trans-unit>
        <trans-unit id="8748ab247c13f054caf5ac6393ba32b0c81004a9" translate="yes" xml:space="preserve">
          <source>The name of the parameter is optional:</source>
          <target state="translated">参数的名称是可选的。</target>
        </trans-unit>
        <trans-unit id="5fef32c68362194a9310ccea4c204a96d5f83c27" translate="yes" xml:space="preserve">
          <source>The name of the required language linkage</source>
          <target state="translated">所需语言联系的名称</target>
        </trans-unit>
        <trans-unit id="6a22edb52d9ca8d339db6db0919c173b04d7cfae" translate="yes" xml:space="preserve">
          <source>The name of this function can have one of the two forms:</source>
          <target state="translated">该函数的名称可以有两种形式之一。</target>
        </trans-unit>
        <trans-unit id="2e85a699586442a78b31c18e7ca7ed56aace9084" translate="yes" xml:space="preserve">
          <source>The name of this function stands for &quot;stream: how many characters?&quot;, so it is pronounced &quot;S how many C&quot;, rather than &quot;show many C&quot;</source>
          <target state="translated">这个函数的名字代表 &quot;流:多少个字符?&quot;,所以读作 &quot;S多少个C&quot;,而不是 &quot;显示多少个C&quot;</target>
        </trans-unit>
        <trans-unit id="4177d34d388a7f7f015fd91e4b891be839e0252a" translate="yes" xml:space="preserve">
          <source>The name of this time zone (e.g., &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt;).</source>
          <target state="translated">该时区的名称（例如 &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b1f3d7cdd9264d99f9f78cc280cd57b23e748c7e" translate="yes" xml:space="preserve">
          <source>The name stands for &quot;string pointer break&quot;, because it returns a pointer to the first of the separator (&quot;break&quot;) characters.</source>
          <target state="translated">这个名字代表 &quot;字符串指针中断&quot;,因为它返回一个指向分隔符(&quot;中断&quot;)第一个字符的指针。</target>
        </trans-unit>
        <trans-unit id="1ee1404e6d3d16d932267176149d19223296bb12" translate="yes" xml:space="preserve">
          <source>The names &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt; are arbitrary, as well as the representation of the types of the parameters: &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; is equally valid.</source>
          <target state="translated">名称 &lt;code&gt;argc&lt;/code&gt; 和 &lt;code&gt;argv&lt;/code&gt; 是任意的，以及参数类型的表示形式： &lt;code&gt;int main(int ac, char** av)&lt;/code&gt; 同等有效。</target>
        </trans-unit>
        <trans-unit id="15246282307805d7fde541df72df9de56fc0168b" translate="yes" xml:space="preserve">
          <source>The names used in the default arguments are looked up, checked for &lt;a href=&quot;access&quot;&gt;accessibility&lt;/a&gt;, and bound at the point of declaration, but are executed at the point of the function call:</source>
          <target state="translated">默认参数中使用的名称在声明时进行查找，检查是否具有&lt;a href=&quot;access&quot;&gt;可访问性&lt;/a&gt;并已绑定，但在函数调用时执行：</target>
        </trans-unit>
        <trans-unit id="dc8c0c1bca9964f296fb879c9e2285406fd9815a" translate="yes" xml:space="preserve">
          <source>The namespace &lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt; provides generic operators &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, and &lt;code&gt;&amp;gt;=&lt;/code&gt;</source>
          <target state="translated">命名空间&lt;a href=&quot;../utility/rel_ops/operator_cmp&quot;&gt;rel_ops&lt;/a&gt;提供通用运算符 &lt;code&gt;!=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; 和 &lt;code&gt;&amp;gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="747b64b0884ce26c6ee214fc6fa900b44b84b929" translate="yes" xml:space="preserve">
          <source>The namespace &lt;code&gt;std&lt;/code&gt; is used to place names of the standard C++ library. See &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;Extending namespace std&lt;/a&gt; for the rules about adding names to it.</source>
          <target state="translated">命名空间 &lt;code&gt;std&lt;/code&gt; 用于放置标准C ++库的名称。有关添加名称的规则，请参见&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;扩展名称空间std&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="029adc599436884611e1679c479ef261e73420f2" translate="yes" xml:space="preserve">
          <source>The namespace alias &lt;code&gt;std::view&lt;/code&gt; is provided as a shorthand for &lt;code&gt;std::ranges::view&lt;/code&gt;.</source>
          <target state="translated">提供命名空间别名 &lt;code&gt;std::view&lt;/code&gt; 作为 &lt;code&gt;std::ranges::view&lt;/code&gt; 的简写。</target>
        </trans-unit>
        <trans-unit id="a00a6ec7f2538958f4971dfcb23715d488c7aa23" translate="yes" xml:space="preserve">
          <source>The namespace-body defines a &lt;a href=&quot;scope&quot;&gt;namespace scope&lt;/a&gt;, which affects &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">namespace-body定义了一个&lt;a href=&quot;scope&quot;&gt;命名空间范围&lt;/a&gt;，这会影响&lt;a href=&quot;lookup&quot;&gt;名称查找&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="44461e8e669298aaabf78d64c5cf761c5b270b21" translate="yes" xml:space="preserve">
          <source>The native handle of this condition variable.</source>
          <target state="translated">这个条件变量的本机句柄。</target>
        </trans-unit>
        <trans-unit id="0fd9941f111f60c6088fd13f324a4124b6730d22" translate="yes" xml:space="preserve">
          <source>The native string representation of the pathname, using native syntax, native character type, and native character encoding. This string is suitable for use with OS APIs.</source>
          <target state="translated">路径名的本机字符串表示,使用本机语法、本机字符类型和本机字符编码。这个字符串适用于OS APIs。</target>
        </trans-unit>
        <trans-unit id="da3734864c7a6f4ae8da4b63030befa1148f5321" translate="yes" xml:space="preserve">
          <source>The natural logarithm of a complex number z with polar coordinate components (r,&amp;theta;) equals ln r + i(&amp;theta;+2n&amp;pi;), with the principal value ln r + i&amp;theta;</source>
          <target state="translated">具有极坐标分量（r，&amp;theta;）的复数z的自然对数等于ln r + i（&amp;theta;+2n&amp;pi;），主值ln r +i&amp;theta;</target>
        </trans-unit>
        <trans-unit id="3e1f12a369d7befe692c93f44687eb7110ca778a" translate="yes" xml:space="preserve">
          <source>The nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">根据&lt;a href=&quot;../fenv/fe_round&quot;&gt;当前舍入模式&lt;/a&gt;，返回最接近 &lt;code&gt;arg&lt;/code&gt; 的整数值。</target>
        </trans-unit>
        <trans-unit id="a00868e0a58251c056ae90a3de93adcb746a8300" translate="yes" xml:space="preserve">
          <source>The new alias alias_name provides an alternate method of accessing ns_name.</source>
          <target state="translated">新的别名alias_name提供了另一种访问ns_name的方法。</target>
        </trans-unit>
        <trans-unit id="429783cbe5a2b5c7d1031e7777e0e7ddc7639a9d" translate="yes" xml:space="preserve">
          <source>The new expression looks for appropriate allocation function's name firstly in the class scope, and after that in the global scope. Note, that as per &lt;a href=&quot;../../language/lookup&quot;&gt;name lookup rules&lt;/a&gt;, any allocation functions declared in class scope hides all global allocation functions for the new-expressions that attempt to allocate objects of this class.</source>
          <target state="translated">新表达式首先在类范围内，然后在全局范围内寻找适当的分配函数的名称。请注意，按照&lt;a href=&quot;../../language/lookup&quot;&gt;名称查找规则&lt;/a&gt;，在类作用域中声明的所有分配函数都会为尝试分配此类对象的new表达式隐藏所有全局分配函数。</target>
        </trans-unit>
        <trans-unit id="b4f387edefbb790808ceeca9099abd48faba678a" translate="yes" xml:space="preserve">
          <source>The new string can be one of:</source>
          <target state="translated">新的字符串可以是以下之一:</target>
        </trans-unit>
        <trans-unit id="c9828879c32005d467860b7e9f5f3d8c58eb5420" translate="yes" xml:space="preserve">
          <source>The new value of &lt;code&gt;rv&lt;/code&gt; is unspecified.</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; 的新值未指定。</target>
        </trans-unit>
        <trans-unit id="5d39b572de7e7c5941b91ef76f32e21e73a603a2" translate="yes" xml:space="preserve">
          <source>The new, nameless, locale.</source>
          <target state="translated">新的,无名的,地点。</target>
        </trans-unit>
        <trans-unit id="da2f7bd8f4e5182cfeb3ed50ce6c838f6be3f42c" translate="yes" xml:space="preserve">
          <source>The new-expression allocates storage by calling the appropriate &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;. If &lt;code&gt;type&lt;/code&gt; is a non-array type, the name of the function is &lt;code&gt;operator new&lt;/code&gt;. If &lt;code&gt;type&lt;/code&gt; is an array type, the name of the function is &lt;code&gt;operator new[]&lt;/code&gt;.</source>
          <target state="translated">new-expression通过调用适当的&lt;a href=&quot;../memory/new/operator_new&quot;&gt;分配函数来&lt;/a&gt;分配存储。如果 &lt;code&gt;type&lt;/code&gt; 是非数组类型，则函数的名称为 &lt;code&gt;operator new&lt;/code&gt; 。如果 &lt;code&gt;type&lt;/code&gt; 是数组类型，则函数的名称为 &lt;code&gt;operator new[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f81c62ecf75f1df624cbf52969b5f6fcc7a10310" translate="yes" xml:space="preserve">
          <source>The new-line character &lt;code&gt;\n&lt;/code&gt; has special meaning when used in &lt;a href=&quot;../io/c&quot;&gt;text mode I/O&lt;/a&gt;: it is converted to the OS-specific newline representation, usually a byte or byte sequence. Some systems mark their lines with length fields instead.</source>
          <target state="translated">当在&lt;a href=&quot;../io/c&quot;&gt;文本模式I / O中&lt;/a&gt;使用换行符 &lt;code&gt;\n&lt;/code&gt; 具有特殊含义：它将转换为特定于OS的换行符表示形式，通常是字节或字节序列。某些系统改为使用长度字段标记其行。</target>
        </trans-unit>
        <trans-unit id="5004a5f082175ce95c41ab6d7df587cd32a7942b" translate="yes" xml:space="preserve">
          <source>The newly-created object of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">新创建的类型为 &lt;code&gt;T&lt;/code&gt; 的对象。</target>
        </trans-unit>
        <trans-unit id="6a3ab198cc816c45e12af507dd340aff4fdc62a4" translate="yes" xml:space="preserve">
          <source>The next character in the get area, &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; on success, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">获取区域中的下一个字符，成功时为 &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; ，失败时为 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b97d648e7c3b9a6a63758b3451bbdb0486f22240" translate="yes" xml:space="preserve">
          <source>The next character is extracted from &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;char_type ct = *in;&lt;/code&gt;</source>
          <target state="translated">从 &lt;code&gt;in&lt;/code&gt; 中提取下一个字符，就像通过 &lt;code&gt;char_type ct = *in;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4680ffa8ce226ac6776cedbea3e5f170c27a198" translate="yes" xml:space="preserve">
          <source>The next multibyte character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">下一个要存储的多字节字符将超过 &lt;code&gt;len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ceaab5e3743ebc5e67758c93a0ae4928508e66de" translate="yes" xml:space="preserve">
          <source>The next wide character from the stream or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file has been reached. If an encoding error occurred, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">流中的下一个宽字符或 &lt;code&gt;WEOF&lt;/code&gt; (如果发生错误或已到达文件末尾）。如果发生编码错误， &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 设置为 &lt;code&gt;EILSEQ&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e768a510933a94e869abc7fbe11cfe3c7af6736" translate="yes" xml:space="preserve">
          <source>The next wide character to be stored would exceed &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">下一个要存储的宽字符将超过 &lt;code&gt;len&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01a927ab9df8533e7f8f33e9f6abfb695cfb7e25" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is a part of the function type and may appear as part of any &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt;.</source>
          <target state="translated">noexcept规范是函数类型的一部分，并且可能作为任何&lt;a href=&quot;function&quot;&gt;函数声明&lt;/a&gt;符的一部分出现。</target>
        </trans-unit>
        <trans-unit id="7e8e2aa7b768b907757e4c37f13e697b69a77fae" translate="yes" xml:space="preserve">
          <source>The noexcept-specification is not a part of the function type (just like &lt;a href=&quot;except_spec&quot;&gt;dynamic exception specification&lt;/a&gt;) and can only appear as a part of a &lt;a href=&quot;lambda&quot;&gt;lambda declarator&lt;/a&gt; or a top-level &lt;a href=&quot;function&quot;&gt;function declarator&lt;/a&gt; when declaring functions, variables, non-static data members of type function, pointer to function, reference to function, or pointer to member function, and also when declaring a parameter or a return type in one of those declarations that in turn happens to be a pointer or reference to function. It cannot appear in a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt; declaration.</source>
          <target state="translated">noexcept规范不是函数类型的一部分（就像&lt;a href=&quot;except_spec&quot;&gt;动态异常规范一样&lt;/a&gt;），并且在声明类型的函数，变量，非静态数据成员时，只能作为&lt;a href=&quot;lambda&quot;&gt;lambda声明器&lt;/a&gt;或顶级&lt;a href=&quot;function&quot;&gt;函数声明器&lt;/a&gt;的一部分出现函数，指向函数的指针，指向函数的引用或指向成员函数的指针，以及在其中一个声明中又恰好是指向函数的指针或引用的声明中声明参数或返回类型时。它不能出现在&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;或&lt;a href=&quot;type_alias&quot;&gt;类型别名&lt;/a&gt;声明中。</target>
        </trans-unit>
        <trans-unit id="91d5dbc9bc5e94a5126d0bce53badf87576b47e0" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; always returns &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">非转换的专业化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 始终返回 &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc09343d894c712f42534e3a3a7a2e71d277a115" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">非转换专业化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3181f2172f64e8c18c66b621b97fc46888a027ba" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt;.</source>
          <target state="translated">不转换的专业化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 返回 &lt;code&gt;&lt;a href=&quot;../../algorithm/min&quot;&gt;std::min&lt;/a&gt;(max, from_end-from)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a64105f39486401f5acc80b055bc1c3fc01a2fb5" translate="yes" xml:space="preserve">
          <source>The non-converting specialization &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">非转换专业化 &lt;code&gt;&lt;a href=&quot;../codecvt&quot;&gt;std::codecvt&lt;/a&gt;&amp;lt;char, char, &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e57a9aa4e3c88808abdb8487b916a663a9f0cec4" translate="yes" xml:space="preserve">
          <source>The non-negative value of type &lt;code&gt;catalog&lt;/code&gt; that can be used with &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;. Returns a negative value if the catalog could not be opened.</source>
          <target state="translated">可以与 &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 一起使用的type &lt;code&gt;catalog&lt;/code&gt; 的非负值。如果无法打开目录，则返回负值。</target>
        </trans-unit>
        <trans-unit id="02e334d13769a2c905eebc3be84f4142a27bd649" translate="yes" xml:space="preserve">
          <source>The non-throwing overload has no special action on error.</source>
          <target state="translated">非投掷式过载对错误没有特殊作用。</target>
        </trans-unit>
        <trans-unit id="34e36164ec9a95125dc49a45834357890507b833" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;-1&lt;/code&gt; on errors.</source>
          <target state="translated">非抛出重载在错误时返回 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa28e66303348738c761475c96ff70e7788d369b" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;false&lt;/code&gt; on errors.</source>
          <target state="translated">非抛出重载在错误时返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="919ace58ca21119d988f2559255ddff1ca1db7ec" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on errors.</source>
          <target state="translated">非抛出重载在错误时返回 &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="998e79778beab53392bc4f00d5142904ec8702e3" translate="yes" xml:space="preserve">
          <source>The non-throwing overload returns an empty path on errors.</source>
          <target state="translated">非抛出式重载在错误时返回一个空路径。</target>
        </trans-unit>
        <trans-unit id="afb768fa11ed8a7e400ee259f3f1ed7b0405bd1e" translate="yes" xml:space="preserve">
          <source>The non-throwing overload sets all members to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; on error.</source>
          <target state="translated">非抛出重载会在发生错误时将所有成员设置为 &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa9c9a7d355030087b9f4a3bf568048262b6a45c" translate="yes" xml:space="preserve">
          <source>The norm calculated by this function is also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;field norm&lt;/a&gt; or &lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;absolute square&lt;/a&gt;.</source>
          <target state="translated">通过此函数计算出的范数也称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Field_norm&quot;&gt;场范数&lt;/a&gt;或&lt;a href=&quot;http://mathworld.wolfram.com/AbsoluteSquare.html&quot;&gt;绝对平方&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e486b6025e3738e962c61297301601872036ad5" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;(E)&lt;/code&gt; is the normal form of &lt;code&gt;E&lt;/code&gt;;</source>
          <target state="translated">表达式 &lt;code&gt;(E)&lt;/code&gt; 的范式是 &lt;code&gt;E&lt;/code&gt; 的范式；</target>
        </trans-unit>
        <trans-unit id="9bddf9d40a32b5e00d57e01971707d640e804497" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt;, where &lt;code&gt;C&lt;/code&gt; names a concept, is the normal form of the constraint expression of &lt;code&gt;C&lt;/code&gt;, after substituting A1, A2, ... , AN for &lt;code&gt;C&lt;/code&gt;'s respective template parameters in the parameter mappings of each atomic constraint of C. If any such substitution into the parameter mappings results in an invalid type or expression, the program is ill-formed, no diagnostic required.</source>
          <target state="translated">表达式 &lt;code&gt;C&amp;lt;A1, A2, ... , AN&amp;gt;&lt;/code&gt; 的正则形式（其中 &lt;code&gt;C&lt;/code&gt; 表示概念）是 &lt;code&gt;C&lt;/code&gt; 的约束表达式的正则形式，然后用A1，A2，...，AN代替 &lt;code&gt;C&lt;/code&gt; ' C的每个原子约束的参数映射中的各自模板参数。如果对参数映射的任何此类替换导致无效的类型或表达式，则程序格式错误，无需诊断。</target>
        </trans-unit>
        <trans-unit id="5086c57862725f37980d863e1b8836e88a15cef7" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; is the conjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;E1 &amp;amp;&amp;amp; E2&lt;/code&gt; 的正常形式是 &lt;code&gt;E1&lt;/code&gt; 和 &lt;code&gt;E2&lt;/code&gt; 的正常形式的合取。</target>
        </trans-unit>
        <trans-unit id="218bd31f9dfc47e61adeda7a1fae8d05c1d9c91a" translate="yes" xml:space="preserve">
          <source>The normal form of an expression &lt;code&gt;E1 || E2&lt;/code&gt; is the disjunction of the normal forms of &lt;code&gt;E1&lt;/code&gt; and &lt;code&gt;E2&lt;/code&gt;.</source>
          <target state="translated">表达式 &lt;code&gt;E1 || E2&lt;/code&gt; 的正常形式 E2是 &lt;code&gt;E1&lt;/code&gt; 和 &lt;code&gt;E2&lt;/code&gt; 的正常形式的析取。</target>
        </trans-unit>
        <trans-unit id="3cfc995fd9a247d5a41e7c2c9e5f1255a95384b9" translate="yes" xml:space="preserve">
          <source>The normal form of any other expression &lt;code&gt;E&lt;/code&gt; is the atomic constraint whose expression is &lt;code&gt;E&lt;/code&gt; and whose parameter mapping is the identity mapping. This includes all &lt;a href=&quot;fold&quot;&gt;fold expressions&lt;/a&gt;, even those folding over the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; operators.</source>
          <target state="translated">任何其他表达式 &lt;code&gt;E&lt;/code&gt; 的范式是原子约束，其表达式为 &lt;code&gt;E&lt;/code&gt; 且参数映射为身份映射。这包括所有&lt;a href=&quot;fold&quot;&gt;折叠表达式&lt;/a&gt;，甚至那些在 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;||&lt;/code&gt; 上折叠的表达式 操作员。</target>
        </trans-unit>
        <trans-unit id="fe2c62a2f9883108b9601f6b362958e238efecab" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock.</source>
          <target state="translated">通知线程不需要在同一个mutex上持有与等待线程持有的锁;事实上,这样做是一种悲观的做法,因为被通知的线程会立即再次阻塞,等待通知线程释放锁。</target>
        </trans-unit>
        <trans-unit id="74b817b062ef6088a10c131453eb749d4d9679d7" translate="yes" xml:space="preserve">
          <source>The notifying thread does not need to hold the lock on the same mutex as the one held by the waiting thread(s); in fact doing so is a pessimization, since the notified thread would immediately block again, waiting for the notifying thread to release the lock. However, some implementations (in particular many implementations of pthreads) recognize this situation and avoid this &quot;hurry up and wait&quot; scenario by transferring the waiting thread from the condition variable's queue directly to the queue of the mutex within the notify call, without waking it up.</source>
          <target state="translated">通知线程不需要在与等待线程持有的锁相同的mutex上持有锁;事实上,这样做是一种悲观的做法,因为被通知的线程会立即再次阻塞,等待通知线程释放锁。不过,有些实现(尤其是很多pthreads的实现)认识到了这种情况,并避免了这种 &quot;着急等待 &quot;的情况,在通知调用中直接将等待线程从条件变量的队列中转移到mutex的队列中,而不唤醒它。</target>
        </trans-unit>
        <trans-unit id="d72947b7a5e5177d55e7da50e671e2cfaa9b935b" translate="yes" xml:space="preserve">
          <source>The null character (&lt;code&gt;'\0'&lt;/code&gt;, &lt;code&gt;L'\0'&lt;/code&gt;, &lt;code&gt;char16_t()&lt;/code&gt;, etc) is always appended to the string literal: thus, a string literal &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; is a &lt;code&gt;const char[6]&lt;/code&gt; holding the characters &lt;code&gt;'H'&lt;/code&gt;, &lt;code&gt;'e'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'o'&lt;/code&gt;, and &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">空字符（ &lt;code&gt;'\0'&lt;/code&gt; ， &lt;code&gt;L'\0'&lt;/code&gt; ， &lt;code&gt;char16_t()&lt;/code&gt; 等）始终附加在字符串文字之后：因此，字符串文字 &lt;code&gt;&quot;Hello&quot;&lt;/code&gt; 是包含字符 &lt;code&gt;'H'&lt;/code&gt; 的 &lt;code&gt;const char[6]&lt;/code&gt; ， &lt;code&gt;'e'&lt;/code&gt; ， &lt;code&gt;'l'&lt;/code&gt; ， &lt;code&gt;'l'&lt;/code&gt; ， &lt;code&gt;'o'&lt;/code&gt; 和 &lt;code&gt;'\0'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="faf4539050f33260142e5e1942efa29dd4846fe8" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored.</source>
          <target state="translated">空字符进行了转换和存储。</target>
        </trans-unit>
        <trans-unit id="248246a3944930a0737208d795018f3412610899" translate="yes" xml:space="preserve">
          <source>The null character was converted and stored. &lt;code&gt;src&lt;/code&gt; is set to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">空字符已转换并存储。 &lt;code&gt;src&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;*ps&lt;/code&gt; 表示初始移位状态。</target>
        </trans-unit>
        <trans-unit id="c07d16928e24253bdda00754b26c48658241a00d" translate="yes" xml:space="preserve">
          <source>The null directive (&lt;code&gt;#&lt;/code&gt; followed by a line break) is allowed and has no effect.</source>
          <target state="translated">允许使用空指令（ &lt;code&gt;#&lt;/code&gt; 后跟换行符），该指令无效。</target>
        </trans-unit>
        <trans-unit id="025c68351e84ef6a409e2a0b3cccd1343af71a32" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the string.</source>
          <target state="translated">字符串中 &lt;code&gt;CharT&lt;/code&gt; 元素的数量。</target>
        </trans-unit>
        <trans-unit id="ed5405dde434342736b19ab060ea61207493342f" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;CharT&lt;/code&gt; elements in the view.</source>
          <target state="translated">视图中 &lt;code&gt;CharT&lt;/code&gt; 元素的数量。</target>
        </trans-unit>
        <trans-unit id="e56138bf523de60c8f035f5f12250f1f8ed8ee0d" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;externT&lt;/code&gt; characters that would be consumed if converted by &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; until either all &lt;code&gt;from_end-from&lt;/code&gt; characters were consumed or &lt;code&gt;max&lt;/code&gt;&lt;code&gt;internT&lt;/code&gt; characters were produced, or a conversion error occurred.</source>
          <target state="translated">的数量 &lt;code&gt;externT&lt;/code&gt; 如果换算通过将消耗字符 &lt;code&gt;&lt;a href=&quot;in&quot;&gt;do_in()&lt;/a&gt;&lt;/code&gt; ，直到所有 &lt;code&gt;from_end-from&lt;/code&gt; 字符被消耗或 &lt;code&gt;max&lt;/code&gt; &lt;code&gt;internT&lt;/code&gt; 字符被生产，或者发生了转换错误。</target>
        </trans-unit>
        <trans-unit id="7563f8961703d5358be5cd18a6c7fd7caeb16313" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;shared_ptr&lt;/code&gt; instances sharing the ownership of the managed object at the instant of the call.</source>
          <target state="translated">在调用的瞬间共享托管对象所有权的 &lt;code&gt;shared_ptr&lt;/code&gt; 实例的数量。</target>
        </trans-unit>
        <trans-unit id="69061d2f8b406eee14a4cb45eba7155a2d754383" translate="yes" xml:space="preserve">
          <source>The number of bits in a bit field sets the limit to the range of values it can hold:</source>
          <target state="translated">位字段中的位数设置了它所能容纳的数值范围的限制。</target>
        </trans-unit>
        <trans-unit id="3f9099e3c7d873d70b362e3a89df1f5709452578" translate="yes" xml:space="preserve">
          <source>The number of buckets in the container.</source>
          <target state="translated">容器中的桶数。</target>
        </trans-unit>
        <trans-unit id="c785090a06b869af10617d403684a6661945ed63" translate="yes" xml:space="preserve">
          <source>The number of bytes (between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt;) that complete a valid multibyte character.</source>
          <target state="translated">完成有效的多字节字符的字节数（介于 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 之间）。</target>
        </trans-unit>
        <trans-unit id="4be8b408517c6e0f5de03175a85f9c74465aa587" translate="yes" xml:space="preserve">
          <source>The number of bytes stored in the array object (including any shift sequences). This may be zero when &lt;code&gt;c8&lt;/code&gt; is not the final code unit in the UTF-8 representation of a code point.</source>
          <target state="translated">数组对象中存储的字节数（包括任何移位序列）。当 &lt;code&gt;c8&lt;/code&gt; 不是代码点的UTF-8表示形式中的最终代码单位时，该值为零。</target>
        </trans-unit>
        <trans-unit id="1b02eec6dc83ccdd83bcea1a56eb671b42ec3a69" translate="yes" xml:space="preserve">
          <source>The number of bytes written into the character array pointed to by &lt;code&gt;str&lt;/code&gt; not including the terminating &lt;code&gt;'\0'&lt;/code&gt; on success. If &lt;code&gt;count&lt;/code&gt; was reached before the entire string could be stored, &lt;code&gt;​0​&lt;/code&gt; is returned and the contents are undefined.</source>
          <target state="translated">成功指向 &lt;code&gt;str&lt;/code&gt; 指向的字符数组中写入的字节数不包括终止符 &lt;code&gt;'\0'&lt;/code&gt; 。如果 &lt;code&gt;count&lt;/code&gt; 达到可存储整个字符串之前， &lt;code&gt;​0​&lt;/code&gt; 返回和内容是不确定的。</target>
        </trans-unit>
        <trans-unit id="d8967c57de8e646af979d9e3d24efce148b0348b" translate="yes" xml:space="preserve">
          <source>The number of characters actually extracted.</source>
          <target state="translated">实际提取的字符数。</target>
        </trans-unit>
        <trans-unit id="a55f46f0cba247803d518fc84899892627e6d13a" translate="yes" xml:space="preserve">
          <source>The number of characters available for non-blocking read (either the size of the get area or the number of characters ready for reading from the associated character sequence), or &lt;code&gt;-1&lt;/code&gt; if no characters are available in the associated sequence as far as &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; can tell.</source>
          <target state="translated">字符可用于非阻塞阅读次数器（get区域的规模或准备字符从相关的字符序列读取的数量），或 &lt;code&gt;-1&lt;/code&gt; ，如果没有的字符是在相关序列提供尽可能 &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; 可以告诉。</target>
        </trans-unit>
        <trans-unit id="8ec083d621e3f753125e182fe5084fd848f34df3" translate="yes" xml:space="preserve">
          <source>The number of characters available for reading from the file, or &lt;code&gt;-1&lt;/code&gt; if the end of file was reached.</source>
          <target state="translated">可从文件中读取的字符数；如果已到达文件末尾，则为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daf9eb1b235764a22547b341d3cc6ad96b107014" translate="yes" xml:space="preserve">
          <source>The number of characters consumed by the most recent conversion operation.</source>
          <target state="translated">最近一次转换操作所消耗的字符数。</target>
        </trans-unit>
        <trans-unit id="31a745112d734fafc43f6e526f229e8cc0817594" translate="yes" xml:space="preserve">
          <source>The number of characters extracted by the last unformatted input operation.</source>
          <target state="translated">最后一次非格式化输入操作所提取的字符数。</target>
        </trans-unit>
        <trans-unit id="025f13559fc4a76405d90651c0e5de33b6d88a9a" translate="yes" xml:space="preserve">
          <source>The number of characters in the put area, or zero if nothing was output.</source>
          <target state="translated">放置区的字符数,如果没有输出,则为零。</target>
        </trans-unit>
        <trans-unit id="b36a0d1d6266f14401ce912fa34b84443739b9ed" translate="yes" xml:space="preserve">
          <source>The number of characters successfully read. If it is less than &lt;code&gt;count&lt;/code&gt; the input sequence has reached the end.</source>
          <target state="translated">成功读取的字符数。如果小于 &lt;code&gt;count&lt;/code&gt; 则输入序列已结束。</target>
        </trans-unit>
        <trans-unit id="755b4ee802930b67c7f96314436110b4b1007db7" translate="yes" xml:space="preserve">
          <source>The number of characters successfully written.</source>
          <target state="translated">成功书写的字符数。</target>
        </trans-unit>
        <trans-unit id="0424ddfc94d33a5b039d2cf4e4fb1ccac4396955" translate="yes" xml:space="preserve">
          <source>The number of characters that are certainly available in the associated character sequence, or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;showmanyc&lt;/code&gt; can determine, without blocking, that no characters are available. If &lt;code&gt;showmanyc&lt;/code&gt; returns &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; will definitely return &lt;code&gt;Traits::eof&lt;/code&gt; or throw.</source>
          <target state="translated">在关联的字符序列中肯定可用的字符数；如果 &lt;code&gt;showmanyc&lt;/code&gt; 可以无阻碍地确定没有可用的字符，则为 &lt;code&gt;-1&lt;/code&gt; 。如果 &lt;code&gt;showmanyc&lt;/code&gt; 返回 &lt;code&gt;-1&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; 肯定会返回 &lt;code&gt;Traits::eof&lt;/code&gt; 或throw。</target>
        </trans-unit>
        <trans-unit id="572abc135ef958490a79fa0e1af5c7c67e142749" translate="yes" xml:space="preserve">
          <source>The number of characters written to the put area.</source>
          <target state="translated">写到放区的字符数。</target>
        </trans-unit>
        <trans-unit id="be9d72f9b5ea67854905c61a719c823300aee734" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most 2 * log</source>
          <target state="translated">比较的数量是 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 之间的距离的对数（最多2 * log</target>
        </trans-unit>
        <trans-unit id="d7d13597f2fd284fd58cd626f0e7ce58b0a1966e" translate="yes" xml:space="preserve">
          <source>The number of comparisons performed is logarithmic in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; (At most log</source>
          <target state="translated">比较的次数是 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 之间的距离的对数（最多为对数）</target>
        </trans-unit>
        <trans-unit id="91c8ac1c75a7c617f2a0ac89cd3799820e4457ed" translate="yes" xml:space="preserve">
          <source>The number of digits between the &lt;code&gt;thousand-sep&lt;/code&gt;s (maximum size of &lt;code&gt;digits&lt;/code&gt;) is specified by the result of &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;thousand-sep&lt;/code&gt; 位间隔之间的位数（最大 &lt;code&gt;digits&lt;/code&gt; ）由 &lt;code&gt;&lt;a href=&quot;numpunct/grouping&quot;&gt;grouping()&lt;/a&gt;&lt;/code&gt; 的结果指定。</target>
        </trans-unit>
        <trans-unit id="3f0b350cad560ae534bf63d3c358b99770cd98ec" translate="yes" xml:space="preserve">
          <source>The number of digits to be displayed after the decimal point. In common U.S. locales, this is the value &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">小数点后要显示的位数。在美国常见语言环境中，该值为 &lt;code&gt;2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c33eec86884077ae614b5177f47626b4225aee87" translate="yes" xml:space="preserve">
          <source>The number of elements in &lt;code&gt;Ints&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Ints&lt;/code&gt; 中的元素数。</target>
        </trans-unit>
        <trans-unit id="8b450587ddfddf28cae24e2b30442386956861df" translate="yes" xml:space="preserve">
          <source>The number of elements in the bucket &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">存储桶中元素的数量 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa1ca4d47e01f9e18e5e6074af9cfd49cb03a9d8" translate="yes" xml:space="preserve">
          <source>The number of elements in the container.</source>
          <target state="translated">容器中元素的数量。</target>
        </trans-unit>
        <trans-unit id="68853860c0d5a8f06c3b286e4f1020c334bca256" translate="yes" xml:space="preserve">
          <source>The number of elements in the span.</source>
          <target state="translated">跨度中元素的数量。</target>
        </trans-unit>
        <trans-unit id="20396f56c8e3a0c13e5e36b7f2622f3b64ae5d64" translate="yes" xml:space="preserve">
          <source>The number of elements removed.</source>
          <target state="translated">删除的元素数量;</target>
        </trans-unit>
        <trans-unit id="57b03f33847e8f2cd5650b62940211a1dd591b64" translate="yes" xml:space="preserve">
          <source>The number of hard links for &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 的硬链接数。</target>
        </trans-unit>
        <trans-unit id="cce184fd3e4e941c3606117950b45af922d77f66" translate="yes" xml:space="preserve">
          <source>The number of hard links for the referred-to filesystem object.</source>
          <target state="translated">引用到文件系统对象的硬链接数量。</target>
        </trans-unit>
        <trans-unit id="61f0b12e8e21833dacb834088dec03bd1d45a5bc" translate="yes" xml:space="preserve">
          <source>The number of increments needed to go from &lt;code&gt;first&lt;/code&gt; to &lt;code&gt;last&lt;/code&gt;. The value may be negative if random-access iterators are used and &lt;code&gt;first&lt;/code&gt; is reachable from &lt;code&gt;last&lt;/code&gt;(since C++11).</source>
          <target state="translated">需要增加的数量从去 &lt;code&gt;first&lt;/code&gt; 到 &lt;code&gt;last&lt;/code&gt; 。如果使用了随机访问迭代器，则该值可以为负，并且 &lt;code&gt;first&lt;/code&gt; 可以从 &lt;code&gt;last&lt;/code&gt; 访问（从C ++ 11开始）。</target>
        </trans-unit>
        <trans-unit id="50988967f711f6f1b94fadc8faa1c4123b2c14c3" translate="yes" xml:space="preserve">
          <source>The number of marked sub-expressions within the regular expression.</source>
          <target state="translated">正则表达式中标记的子表达式的数量。</target>
        </trans-unit>
        <trans-unit id="c70fa04485fef696ceac1a34cbd7f1b495aed9ee" translate="yes" xml:space="preserve">
          <source>The number of submatches.</source>
          <target state="translated">子的数量。</target>
        </trans-unit>
        <trans-unit id="d956e6449331c6b04b931088c9ef0870fa076aa0" translate="yes" xml:space="preserve">
          <source>The number of ticks for this duration.</source>
          <target state="translated">这个持续时间的滴答次数。</target>
        </trans-unit>
        <trans-unit id="d4eed26281a1ccba1c3fbe30a41dad631fb16096" translate="yes" xml:space="preserve">
          <source>The numbers that are supported by &lt;code&gt;std::numpunct&lt;/code&gt; have the format described below. Here &lt;code&gt;digit&lt;/code&gt; represents the radix set specified by the &lt;code&gt;fmtflags&lt;/code&gt; argument value, &lt;code&gt;thousands-sep&lt;/code&gt; and &lt;code&gt;decimal-point&lt;/code&gt; are the results of &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; functions respectively. The format of integer values is as follows:</source>
          <target state="translated">&lt;code&gt;std::numpunct&lt;/code&gt; 支持的数字具有以下描述的格式。这里 &lt;code&gt;digit&lt;/code&gt; 代表由指定的基数集 &lt;code&gt;fmtflags&lt;/code&gt; 参数值， &lt;code&gt;thousands-sep&lt;/code&gt; 和 &lt;code&gt;decimal-point&lt;/code&gt; 是的结果 &lt;code&gt;&lt;a href=&quot;numpunct/thousands_sep&quot;&gt;thousands_sep()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;numpunct/decimal_point&quot;&gt;decimal_point()&lt;/a&gt;&lt;/code&gt; 分别功能。整数值的格式如下：</target>
        </trans-unit>
        <trans-unit id="9bab7274b85a85fa328c276ae190e2933c1da232" translate="yes" xml:space="preserve">
          <source>The numeric input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the end of the stream was encountered while reading the next character, on Stage 2 of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; processing. Depending on the parsing state, &lt;code&gt;failbit&lt;/code&gt; may or may not be set at the same time: for example, &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; sets &lt;code&gt;eofbit&lt;/code&gt;, but not &lt;code&gt;failbit&lt;/code&gt;: the integer &lt;code&gt;1&lt;/code&gt; was successfully parsed and stored in &lt;code&gt;n&lt;/code&gt;. On the other hand, &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; sets both &lt;code&gt;eofbit&lt;/code&gt; and &lt;code&gt;failbit&lt;/code&gt;: there was not enough characters to complete the parsing of the boolean &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果在&lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt;处理的第2阶段读取下一个字符时遇到流的末尾，则&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;的数字输入重载。根据解析状态， &lt;code&gt;failbit&lt;/code&gt; 可能会或可能不会同时设置：例如， &lt;code&gt;int n; istringstream buf(&quot;1&quot;); buf &amp;gt;&amp;gt; n;&lt;/code&gt; 设置 &lt;code&gt;eofbit&lt;/code&gt; ，但不设置 &lt;code&gt;failbit&lt;/code&gt; ：成功解析整数 &lt;code&gt;1&lt;/code&gt; 并将其存储在 &lt;code&gt;n&lt;/code&gt; 中。另一方面， &lt;code&gt;bool b; istringstream buf(&quot;tr&quot;); buf &amp;gt;&amp;gt; boolalpha &amp;gt;&amp;gt; b;&lt;/code&gt; 设置 &lt;code&gt;eofbit&lt;/code&gt; 和 &lt;code&gt;failbit&lt;/code&gt; ：没有足够的字符来完成对布尔值 &lt;code&gt;true&lt;/code&gt; 的解析。</target>
        </trans-unit>
        <trans-unit id="1d4dfe124ae3866d608f524aa57220b740c6faaa" translate="yes" xml:space="preserve">
          <source>The numeric value if &lt;code&gt;ch&lt;/code&gt; indeed represents a digit in the currently imbued locale that is valid for the numeric base &lt;code&gt;radix&lt;/code&gt;, or &lt;code&gt;-1&lt;/code&gt; on error.</source>
          <target state="translated">如果 &lt;code&gt;ch&lt;/code&gt; 确实表示当前输入区域设置中的数字，该数字对于数字基数 &lt;code&gt;radix&lt;/code&gt; 有效，或者在错误时为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cea1f54bd02da8f425b152ab8d2a7f0fbeca2475" translate="yes" xml:space="preserve">
          <source>The numeric, pointer, and boolean input overloads of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; (technically, the overloads of &lt;a href=&quot;../../locale/num_get/get&quot;&gt;&lt;code&gt;num_get::get&lt;/code&gt;&lt;/a&gt; they call), if the input cannot be parsed as a valid value or if the value parsed does not fit in the destination type.</source>
          <target state="translated">如果不能将输入解析为有效值或解析的值不适合输入法，则&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;的数字，指针和布尔输入重载（从技术上讲，是&lt;a href=&quot;../../locale/num_get/get&quot;&gt; &lt;code&gt;num_get::get&lt;/code&gt; &lt;/a&gt;的重载）。目标类型。</target>
        </trans-unit>
        <trans-unit id="0220d8c40333a0093943bf969db90f89079c2dd9" translate="yes" xml:space="preserve">
          <source>The object</source>
          <target state="translated">对象</target>
        </trans-unit>
        <trans-unit id="984c0e6a80490ef643982434d691b02d8e724169" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialized&lt;/a&gt;</source>
          <target state="translated">对象 &lt;code&gt;u&lt;/code&gt; 是&lt;a href=&quot;../language/default_initialization&quot;&gt;默认初始化的&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60fdf35addca2d2e61228bbe293b020ce2b060c9" translate="yes" xml:space="preserve">
          <source>The object &lt;code&gt;u&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">对象 &lt;code&gt;u&lt;/code&gt; 是&lt;a href=&quot;../language/value_initialization&quot;&gt;值初始化的&lt;/a&gt;或&lt;a href=&quot;../language/aggregate_initialization&quot;&gt;集合初始化的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d66e0c5c8edf403a2575eab1d9bd1a5f03140bf4" translate="yes" xml:space="preserve">
          <source>The object created by a new-expression is initialized according to the following rules:</source>
          <target state="translated">新表达式创建的对象按照以下规则进行初始化。</target>
        </trans-unit>
        <trans-unit id="6a3691e4261c0727fb8c31da0443f64d25b8f791" translate="yes" xml:space="preserve">
          <source>The object denoted by the glvalue is not accessed if:</source>
          <target state="translated">在以下情况下,glvalue所表示的对象不会被访问。</target>
        </trans-unit>
        <trans-unit id="25231b05a1580da27ff890c7619a820a11b0eb7b" translate="yes" xml:space="preserve">
          <source>The object is default-initialized.</source>
          <target state="translated">该对象是默认初始化的。</target>
        </trans-unit>
        <trans-unit id="43048e7b920911676623be86d837ae144bd2a9c0" translate="yes" xml:space="preserve">
          <source>The object is destroyed using &lt;a href=&quot;../language/delete&quot;&gt;&lt;code&gt;delete-expression&lt;/code&gt;&lt;/a&gt; or a custom deleter that is supplied to &lt;code&gt;shared_ptr&lt;/code&gt; during construction.</source>
          <target state="translated">使用&lt;a href=&quot;../language/delete&quot;&gt; &lt;code&gt;delete-expression&lt;/code&gt; &lt;/a&gt;或在构建过程中提供给 &lt;code&gt;shared_ptr&lt;/code&gt; 的自定义删除程序销毁该对象。</target>
        </trans-unit>
        <trans-unit id="ff26c6e45a2e565960b0a55f98032b59b34935b9" translate="yes" xml:space="preserve">
          <source>The object is disposed of using a potentially user-supplied deleter by calling &lt;code&gt;get_deleter()(ptr)&lt;/code&gt;. The default deleter uses the &lt;code&gt;delete&lt;/code&gt; operator, which destroys the object and deallocates the memory.</source>
          <target state="translated">通过调用 &lt;code&gt;get_deleter()(ptr)&lt;/code&gt; 来使用可能由用户提供的删除器来处置该对象。默认的删除器使用 &lt;code&gt;delete&lt;/code&gt; 运算符，该运算符销毁对象并重新分配内存。</target>
        </trans-unit>
        <trans-unit id="3d70e838df487033e13d3e82fefeabf6dda9f65a" translate="yes" xml:space="preserve">
          <source>The object is disposed of using the associated deleter when either of the following happens:</source>
          <target state="translated">当发生以下情况之一时,使用关联的deleter对对象进行处理。</target>
        </trans-unit>
        <trans-unit id="6079965a1e8cbec0fa1c764e9dc6325a1f66300d" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or an &lt;code&gt;optional&lt;/code&gt; object that</source>
          <target state="translated">该对象使用 &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; 类型的值或一个 &lt;code&gt;optional&lt;/code&gt; 对象进行初始化/从其分配</target>
        </trans-unit>
        <trans-unit id="2eb07629fc5eb59fd1eeea479f34c50d51c4b7cf" translate="yes" xml:space="preserve">
          <source>The object is initialized with/assigned from a value of type &lt;code&gt;T&lt;/code&gt; or another &lt;code&gt;optional&lt;/code&gt; that</source>
          <target state="translated">该目的是初始化/从类型的值分配 &lt;code&gt;T&lt;/code&gt; 或另一个 &lt;code&gt;optional&lt;/code&gt; 的是</target>
        </trans-unit>
        <trans-unit id="106e7472fad2690d4a66e2210e0161c76f0e3d6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;a href=&quot;../money_base&quot;&gt;&lt;code&gt;std::money_base::format&lt;/code&gt;&lt;/a&gt; describing the formatting used by this locale.</source>
          <target state="translated">类型为&lt;a href=&quot;../money_base&quot;&gt; &lt;code&gt;std::money_base::format&lt;/code&gt; &lt;/a&gt;的对象，描述此语言环境使用的格式。</target>
        </trans-unit>
        <trans-unit id="a2654facce30fa17d2f2a6f53431efdc1fad3b19" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::moneypunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 的对象保存组。 &lt;code&gt;std::moneypunct&lt;/code&gt; 的标准专业化返回空字符串，表示没有分组。典型的分组（例如， &lt;code&gt;en_US&lt;/code&gt; 语言环境）返回 &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2953e9f8be35412309323e09c4560896f13bada8" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; holding the groups. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return an empty string, indicating no grouping. Typical groupings (e.g. the &lt;code&gt;en_US&lt;/code&gt; locale) return &lt;code&gt;&quot;\003&quot;&lt;/code&gt;.</source>
          <target state="translated">类型 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 的对象保存组。 &lt;code&gt;std::numpunct&lt;/code&gt; 的标准专业化返回空字符串，表示没有分组。典型的分组（例如， &lt;code&gt;en_US&lt;/code&gt; 语言环境）返回 &lt;code&gt;&quot;\003&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f2911ed4a3e7e4e904c59b8350c8e9466228f6c" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;CharT&lt;/code&gt; holding the decimal point character.</source>
          <target state="translated">&lt;code&gt;CharT&lt;/code&gt; 类型的对象，保留小数点字符。</target>
        </trans-unit>
        <trans-unit id="4f95c2c5399637a34a9ee8645410f77e300b41a0" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. In common U.S. locales, this is &lt;code&gt;','&lt;/code&gt; or &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char_type&lt;/code&gt; 类型的对象用作千位分隔符。在美国常见语言环境中，这是 &lt;code&gt;','&lt;/code&gt; 或 &lt;code&gt;L','&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80bb88b1b4433caf62a715152b1b50f8ad2b9e79" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;char_type&lt;/code&gt; to use as the thousands separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;','&lt;/code&gt; and &lt;code&gt;L','&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char_type&lt;/code&gt; 类型的对象用作千位分隔符。 &lt;code&gt;std::numpunct&lt;/code&gt; 的标准专业化返回 &lt;code&gt;','&lt;/code&gt; 和 &lt;code&gt;L','&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a260dce16a0baabc887328041b098cae9e79f602" translate="yes" xml:space="preserve">
          <source>The object of type &lt;code&gt;string_type&lt;/code&gt; holding the currency symbol or code.</source>
          <target state="translated">类型为 &lt;code&gt;string_type&lt;/code&gt; 的对象，其中包含货币符号或代码。</target>
        </trans-unit>
        <trans-unit id="16c53b267fd0abe28bee8b120878e85d544083a4" translate="yes" xml:space="preserve">
          <source>The object or the type declared by such a declaration will have its &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; equal to the strictest (largest) non-zero expression of all &lt;code&gt;alignas&lt;/code&gt; specifiers used in the declaration, unless it would weaken the natural alignment of the type.</source>
          <target state="translated">此类声明所声明的对象或类型的&lt;a href=&quot;objects#Alignment&quot;&gt;对齐要求将&lt;/a&gt;等于声明中使用的所有 &lt;code&gt;alignas&lt;/code&gt; 指示符的最严格（最大）非零表达式，除非它会削弱类型的自然对齐。</target>
        </trans-unit>
        <trans-unit id="50b34d11b1100c8ed664baedbf8283fc21bb891d" translate="yes" xml:space="preserve">
          <source>The objects are locked by an unspecified series of calls to &lt;code&gt;lock&lt;/code&gt;, &lt;code&gt;try_lock&lt;/code&gt;, and &lt;code&gt;unlock&lt;/code&gt;. If a call to &lt;code&gt;lock&lt;/code&gt; or &lt;code&gt;unlock&lt;/code&gt; results in an exception, &lt;code&gt;unlock&lt;/code&gt; is called for any locked objects before rethrowing.</source>
          <target state="translated">对象通过对 &lt;code&gt;lock&lt;/code&gt; ， &lt;code&gt;try_lock&lt;/code&gt; 和 &lt;code&gt;unlock&lt;/code&gt; 的一系列未指定的调用来锁定。如果调用 &lt;code&gt;lock&lt;/code&gt; 或 &lt;code&gt;unlock&lt;/code&gt; 导致异常，则在重新抛出之前，将对所有锁定对象调用 &lt;code&gt;unlock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="833b82da6caa8dd8aeb20cf9477fe5f85be57f81" translate="yes" xml:space="preserve">
          <source>The objects created by new-expressions (objects with dynamic storage duration) persist until the pointer returned by the new-expression is used in a matching &lt;a href=&quot;delete&quot;&gt;delete-expression&lt;/a&gt;. If the original value of pointer is lost, the object becomes unreachable and cannot be deallocated: a</source>
          <target state="translated">由new-expressions创建的对象（具有动态存储持续时间的对象）将一直保留，直到在匹配的&lt;a href=&quot;delete&quot;&gt;delete-expression中&lt;/a&gt;使用new-expression返回的指针为止。如果指针的原始值丢失，则该对象将变得不可访问且无法释放：</target>
        </trans-unit>
        <trans-unit id="b2967e2fb3ae07f3f5e3a1fec435ab589fa1f55b" translate="yes" xml:space="preserve">
          <source>The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">对象可能重叠：复制就像将字符复制到临时字符数组一样进行，然后将字符从数组复制到 &lt;code&gt;dest&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a17a553ce0d57587be0e8416824c075ef07c922" translate="yes" xml:space="preserve">
          <source>The obtained character on success or &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">成功时获得的字符，失败时获得 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04be47c26eb26c26238109edcd20d6d4d1bb0dc8" translate="yes" xml:space="preserve">
          <source>The obtained wide character or &lt;code&gt;WEOF&lt;/code&gt; if an error has occurred or the end of file reached.</source>
          <target state="translated">获得的宽字符或 &lt;code&gt;WEOF&lt;/code&gt; (如果发生错误或到达文件末尾）。</target>
        </trans-unit>
        <trans-unit id="2110df2bf8befabdd98eb59b3910b478af8f2dcc" translate="yes" xml:space="preserve">
          <source>The official document on Feature Test Recommendations</source>
          <target state="translated">关于功能测试的官方文件推荐</target>
        </trans-unit>
        <trans-unit id="f708415e16cfe9e7bf1990f786292e4c9e381ac6" translate="yes" xml:space="preserve">
          <source>The offset of the first member of a standard-layout type is always zero (&lt;a href=&quot;../language/ebo&quot;&gt;empty-base optimization&lt;/a&gt; is mandatory).</source>
          <target state="translated">标准布局类型的第一个成员的偏移量始终为零（必须进行&lt;a href=&quot;../language/ebo&quot;&gt;空基优化&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="607857504a9e70bca8a47464af6277ec197d69cc" translate="yes" xml:space="preserve">
          <source>The old value of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 的旧值。</target>
        </trans-unit>
        <trans-unit id="3d886bb54edd589fbd6ce35fc4f8d5d2fed63519" translate="yes" xml:space="preserve">
          <source>The only data stored in a &lt;code&gt;duration&lt;/code&gt; is a tick count of type &lt;code&gt;Rep&lt;/code&gt;. If &lt;code&gt;Rep&lt;/code&gt; is floating point, then the &lt;code&gt;duration&lt;/code&gt; can represent fractions of ticks. &lt;code&gt;Period&lt;/code&gt; is included as part of the duration's type, and is only used when converting between different durations.</source>
          <target state="translated">&lt;code&gt;duration&lt;/code&gt; 存储的唯一数据是 &lt;code&gt;Rep&lt;/code&gt; 类型的滴答计数。如果 &lt;code&gt;Rep&lt;/code&gt; 是浮点，则 &lt;code&gt;duration&lt;/code&gt; 可以表示滴答声的分数。 &lt;code&gt;Period&lt;/code&gt; 作为持续时间类型的一部分包括在内，并且仅在不同持续时间之间进行转换时才使用。</target>
        </trans-unit>
        <trans-unit id="b2218d6760efda73de78e40ceb5f652b71248a9b" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::nearbyint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;std::nearbyint&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::nearbyint&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; 之间的唯一区别是 &lt;code&gt;std::nearbyint&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 永远不会引发FE_INEXACT。</target>
        </trans-unit>
        <trans-unit id="50d45e1a42306e63fbd2dd995b7cef21bbf82264" translate="yes" xml:space="preserve">
          <source>The only difference between &lt;code&gt;std::rint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; never raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::rint&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 之间的唯一区别是 &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; nearbyint永远不会引发FE_INEXACT。</target>
        </trans-unit>
        <trans-unit id="fb56d0a76a6c53bff26b5b866f1ad038bed2665b" translate="yes" xml:space="preserve">
          <source>The only exceptions are that non-type template parameters of</source>
          <target state="translated">唯一的例外是,非类型模板参数的</target>
        </trans-unit>
        <trans-unit id="f6e8829ff8f2f1e7710d51780b5775f091279131" translate="yes" xml:space="preserve">
          <source>The only specifier that is allowed to appear twice in a decl-specifier-seq is &lt;code&gt;long&lt;/code&gt; (which can appear twice). All other repeats, such as &lt;code&gt;const static const&lt;/code&gt;, or &lt;code&gt;virtual inline virtual&lt;/code&gt; are errors.</source>
          <target state="translated">在decl-specifier-seq中唯一允许出现两次的说明符很 &lt;code&gt;long&lt;/code&gt; （可以出现两次）。所有其他重复，例如 &lt;code&gt;const static const&lt;/code&gt; 或 &lt;code&gt;virtual inline virtual&lt;/code&gt; 都是错误。</target>
        </trans-unit>
        <trans-unit id="776dd59d6ff8d1a9ef4d3f03ca55cae7469eb4a0" translate="yes" xml:space="preserve">
          <source>The only specifiers allowed in the decl-specifier-seq of a constructor declaration are &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;, &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;code&gt;explicit&lt;/code&gt; and &lt;code&gt;constexpr&lt;/code&gt; (in particular, no return type is allowed). Note that &lt;a href=&quot;member_functions&quot;&gt;cv- and ref-qualifiers&lt;/a&gt; are not allowed either; const and volatile semantics of an object under construction don't kick in until the most-derived constructor completes.</source>
          <target state="translated">构造函数声明的decl-specifier-seq中允许的唯一说明符是&lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt;，&lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;， &lt;code&gt;explicit&lt;/code&gt; 和 &lt;code&gt;constexpr&lt;/code&gt; （特别是不允许返回类型）。请注意，也不允许使用&lt;a href=&quot;member_functions&quot;&gt;cv-和ref限定词&lt;/a&gt;；直到最派生的构造函数完成后，构造对象的const和volatile语义才起作用。</target>
        </trans-unit>
        <trans-unit id="d61491cad2b2617e213366873d893b816a75646e" translate="yes" xml:space="preserve">
          <source>The only standard &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; member constant &lt;code&gt;is_always_lock_free&lt;/code&gt; is also provided by this specialization.</source>
          <target state="translated">该专业化还提供唯一的标准 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 成员常量 &lt;code&gt;is_always_lock_free&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b892e85a0c7fdd49003290d933695bc0a6e29fec" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">唯一引发此异常的标准库组件是 &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/from_bytes&quot;&gt;std::wstring_convert::from_bytes&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../locale/wstring_convert/to_bytes&quot;&gt;std::wstring_convert::to_bytes&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2e814e1afd8365ad73dca6904c0b4c6f214183c" translate="yes" xml:space="preserve">
          <source>The only standard library components that throw this exception are &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">唯一引发此异常的标准库组件是 &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ulong&quot;&gt;std::bitset::to_ulong&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../utility/bitset/to_ullong&quot;&gt;std::bitset::to_ullong&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3648d0d11e1d50129adc447f795d03447db5902" translate="yes" xml:space="preserve">
          <source>The only trivially copyable types are scalar types, trivially copyable classes, and arrays of such types/classes (possibly const-qualified, but not volatile-qualified).</source>
          <target state="translated">唯一可复制的类型是标量类型、可复制的类和这类类型/类的数组(可能是const-qualified,但不是volatile-qualified)。</target>
        </trans-unit>
        <trans-unit id="b25a51f5e3f4b6ece2ce4ed04dda4a2b91159629" translate="yes" xml:space="preserve">
          <source>The only valid use of &lt;code&gt;operator*&lt;/code&gt; with an output iterator is on the left of an assignment: &lt;code&gt;operator*&lt;/code&gt; may return a proxy object, which defines a member &lt;code&gt;operator=&lt;/code&gt; (which may be a template).</source>
          <target state="translated">&lt;code&gt;operator*&lt;/code&gt; 与输出迭代器的唯一有效用法是在赋值的左侧： &lt;code&gt;operator*&lt;/code&gt; 可能返回一个代理对象，该对象定义了一个成员 &lt;code&gt;operator=&lt;/code&gt; （可能是模板）。</target>
        </trans-unit>
        <trans-unit id="b9566ed81642e87a223297fba2ea3d2e3900b558" translate="yes" xml:space="preserve">
          <source>The only way to replace an allocator is copy-assignment, move-assignment, and swap:</source>
          <target state="translated">替换分配器的方法只有复制-分配、移动-分配和交换。</target>
        </trans-unit>
        <trans-unit id="d1f3d8e5a7c4ed4c1fad80ee519fc4a484fdc734" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in postfix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. The result is &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; copy of the original value of the operand. As a side-effect, for non-boolean operands, the expression &lt;code&gt;x++&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;x--&lt;/code&gt; modifies the value of its operand as if by evaluating &lt;code&gt;x -= 1&lt;/code&gt;. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">内置后缀递增或递减运算符的操作数expr必须是非布尔算术类型的可修改（非const）&lt;a href=&quot;value_category&quot;&gt;左值&lt;/a&gt;或指向完整&lt;a href=&quot;type-id&quot;&gt;对象类型的&lt;/a&gt;指针。结果是操作数原始值的&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;复制。作为副作用，对于非布尔操作数，表达式 &lt;code&gt;x++&lt;/code&gt; 就像通过评估 &lt;code&gt;x += 1&lt;/code&gt; 修改其操作数的值，而表达式 &lt;code&gt;x--&lt;/code&gt; 就像通过评估 &lt;code&gt;x -= 1&lt;/code&gt; 修改其操作数的值。。为&lt;a href=&quot;operator_arithmetic&quot;&gt;算术运算符&lt;/a&gt;定义的所有算术转换规则和指针算术规则 应用并确定应用于操作数的隐式转换（如果有）以及表达式的返回类型。</target>
        </trans-unit>
        <trans-unit id="46362931546b6ab532aa0058b79c1a3e9f6e3d4e" translate="yes" xml:space="preserve">
          <source>The operand expr of a built-in prefix increment or decrement operator must be a modifiable (non-const) &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; of non-boolean arithmetic type or pointer to complete &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt;. For non-boolean operands, the expression &lt;code&gt;++x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x += 1&lt;/code&gt;, and the expression &lt;code&gt;--x&lt;/code&gt; is exactly equivalent to &lt;code&gt;x -= 1&lt;/code&gt;, that is, the prefix increment or decrement is an lvalue expression that identifies the modified operand. All arithmetic conversion rules and pointer arithmetic rules defined for &lt;a href=&quot;operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; apply and determine the implicit conversion (if any) applied to the operand as well as the return type of the expression.</source>
          <target state="translated">内置前缀递增或递减运算符的操作数expr必须是非布尔算术类型的可修改（非const）&lt;a href=&quot;value_category&quot;&gt;左值&lt;/a&gt;或指向完整&lt;a href=&quot;type-id&quot;&gt;对象类型的&lt;/a&gt;指针。对于非布尔操作数，表达式 &lt;code&gt;++x&lt;/code&gt; 完全等效于 &lt;code&gt;x += 1&lt;/code&gt; ，而表达式 &lt;code&gt;--x&lt;/code&gt; 完全等效于 &lt;code&gt;x -= 1&lt;/code&gt; ，即，前缀增量或减量是一个左值表达式，用于标识修改的操作数。为&lt;a href=&quot;operator_arithmetic&quot;&gt;算术运算符&lt;/a&gt;定义的所有算术转换规则和指针算术规则都将应用并确定应用于操作数的隐式转换（如果有）以及表达式的返回类型。</target>
        </trans-unit>
        <trans-unit id="87d402fbb54b3649a9536c28ce47e12a587d6550" translate="yes" xml:space="preserve">
          <source>The operand of &lt;code&gt;sizeof&lt;/code&gt; can't be a C-style type cast: the expression &lt;code&gt;sizeof (int) * p&lt;/code&gt; is unambiguously interpreted as &lt;code&gt;(sizeof(int)) * p&lt;/code&gt;, but not &lt;code&gt;sizeof((int)*p)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; 的操作数不能是C风格的类型转换：表达式 &lt;code&gt;sizeof (int) * p&lt;/code&gt; 明确地解释为 &lt;code&gt;(sizeof(int)) * p&lt;/code&gt; ，但不是 &lt;code&gt;sizeof((int)*p)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="085c6a701b7e7a71f8bd49b79840a23c53c15e50" translate="yes" xml:space="preserve">
          <source>The operand of the built-in indirection operator must be pointer to object or a pointer to function, and the result is the lvalue referring to the pointer or function to which expr points.</source>
          <target state="translated">内置的indirection操作符的操作数必须是指向对象的指针或指向函数的指针,结果是指向expr指向的指针或函数的lvalue。</target>
        </trans-unit>
        <trans-unit id="a41ba177e9a175366d24e342abbe5cb594a72284" translate="yes" xml:space="preserve">
          <source>The operands of any operator may be other expressions or primary expressions (e.g. in &lt;code&gt;1+2*3&lt;/code&gt;, the operands of operator+ are the subexpression &lt;code&gt;2*3&lt;/code&gt; and the primary expression &lt;code&gt;1&lt;/code&gt;).</source>
          <target state="translated">任何运算符的操作数可以是其他表达式或主表达式（例如，在 &lt;code&gt;1+2*3&lt;/code&gt; 中，operator +的操作数是子表达式 &lt;code&gt;2*3&lt;/code&gt; 和主表达式 &lt;code&gt;1&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d012c764a34c8f374b29407cde1eb1fdbb47c2a6" translate="yes" xml:space="preserve">
          <source>The operands of the operators &lt;a href=&quot;typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sizeof&quot;&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;noexcept&quot;&gt;&lt;code&gt;noexcept&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;decltype&quot;&gt;&lt;code&gt;decltype&lt;/code&gt;&lt;/a&gt;(since C++11) are expressions that are not evaluated (unless they are polymorphic glvalues and are the operands of &lt;code&gt;typeid&lt;/code&gt;), since these operators only query the compile-time properties of their operands. Thus, &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; does not perform console output.</source>
          <target state="translated">操作符&lt;a href=&quot;typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;sizeof&quot;&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;noexcept&quot;&gt; &lt;code&gt;noexcept&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;decltype&quot;&gt; &lt;code&gt;decltype&lt;/code&gt; &lt;/a&gt;的操作数（自C ++ 11起）是未计算的表达式（除非它们是多态glvalues并且是 &lt;code&gt;typeid&lt;/code&gt; 的操作数），因为这些操作符仅查询编译时属性他们的操作数。因此， &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt; n = sizeof(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 42);&lt;/code&gt; 不执行控制台输出。</target>
        </trans-unit>
        <trans-unit id="85054a8ab24569b5d580787ed8730ffc9c0905a7" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">该操作的行为就像 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;set_exception_at_thread_exit&lt;/code&gt; 获取与promise对象关联的单个互斥锁，同时更新了promise对象。</target>
        </trans-unit>
        <trans-unit id="ff918beb1f805c40357e0f6201e33f727cf409ae" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_value_at_thread_exit&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">该操作的行为就像 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;set_value_at_thread_exit&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; 获取与promise对象关联的单个互斥锁，同时更新了promise对象。</target>
        </trans-unit>
        <trans-unit id="0dc1d1f6cd97262d10d4163c6f4669641d9589c9" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;set_exception&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">该操作的行为就像 &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;set_exception&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; 获取与promise对象关联的单个互斥锁，同时更新了promise对象。</target>
        </trans-unit>
        <trans-unit id="894be649e20a0f667a76b29adef6436e4b7cbd04" translate="yes" xml:space="preserve">
          <source>The operation behaves as though &lt;code&gt;set_value&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; acquire a single mutex associated with the promise object while updating the promise object.</source>
          <target state="translated">该操作的行为就像 &lt;code&gt;set_value&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; 获取与promise对象关联的单个互斥锁，同时更新了promise对象。</target>
        </trans-unit>
        <trans-unit id="ada6c00780096e7ea571132eafd7f86af9d8f166" translate="yes" xml:space="preserve">
          <source>The operation is performed as if the following is executed:</source>
          <target state="translated">该操作的执行方式如同下面的执行方式。</target>
        </trans-unit>
        <trans-unit id="9c665cf102b9a36a3c0f45e7d1968e4deab591b0" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;operator!&lt;/code&gt; is commonly overloaded by the user-defined classes that are intended to be used in boolean contexts. Such classes also provide a user-defined conversion function &lt;code&gt;explicit operator bool()&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; for the standard library example), and the expected behavior of &lt;code&gt;operator!&lt;/code&gt; is to return the value opposite of &lt;code&gt;operator bool&lt;/code&gt;.</source>
          <target state="translated">运算 &lt;code&gt;operator!&lt;/code&gt; 运算符！通常由打算在布尔上下文中使用的用户定义的类重载。这些类还提供了用户定义的转换函数，即 &lt;code&gt;explicit operator bool()&lt;/code&gt; （有关标准库示例，请参见 &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; ），以及 &lt;code&gt;operator!&lt;/code&gt; 的预期行为！是返回与 &lt;code&gt;operator bool&lt;/code&gt; 相反的值。</target>
        </trans-unit>
        <trans-unit id="f80c851a7fa156f63455e4364c3b3e9685929eb0" translate="yes" xml:space="preserve">
          <source>The operators &lt;code&gt;::&lt;/code&gt; (scope resolution), &lt;code&gt;.&lt;/code&gt; (member access), &lt;code&gt;.*&lt;/code&gt; (member access through pointer to member), and &lt;code&gt;?:&lt;/code&gt; (ternary conditional) cannot be overloaded.</source>
          <target state="translated">运营商 &lt;code&gt;::&lt;/code&gt; （范围分辨率） &lt;code&gt;.&lt;/code&gt; （成员访问权）， &lt;code&gt;.*&lt;/code&gt; （通过指向成员的指针访问成员）和 &lt;code&gt;?:&lt;/code&gt; (三进制条件）不能重载。</target>
        </trans-unit>
        <trans-unit id="aac712726a5efd650938a3acaadc33f6fc3919ae" translate="yes" xml:space="preserve">
          <source>The order of destruction of non-local variables is described in &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">非局部变量的销毁顺序在 &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 描述。</target>
        </trans-unit>
        <trans-unit id="35758388f82a3ab09aa2cb82071589277664456d" translate="yes" xml:space="preserve">
          <source>The order of equal elements is not guaranteed to be preserved. The order of the remaining elements in the range &lt;code&gt;[middle, last)&lt;/code&gt; is unspecified.</source>
          <target state="translated">相等元素的顺序不能保证得到保留。未指定 &lt;code&gt;[middle, last)&lt;/code&gt; 范围内其余元素的顺序。</target>
        </trans-unit>
        <trans-unit id="8b4e996418f65beaf879b200f677d977522bbc6c" translate="yes" xml:space="preserve">
          <source>The order of member initializers in the list is irrelevant: the actual order of initialization is as follows:</source>
          <target state="translated">成员初始化器在列表中的顺序无关紧要:实际的初始化顺序如下。</target>
        </trans-unit>
        <trans-unit id="4ee2462340320dfffdb2356e18adfc9d73dab60f" translate="yes" xml:space="preserve">
          <source>The order of the elements that are not erased is preserved. (This makes it possible to erase individual elements while iterating through the container.).</source>
          <target state="translated">未被擦除的元素的顺序被保留。(这使得它可以在遍历容器时擦除单个元素。)。</target>
        </trans-unit>
        <trans-unit id="45de463a3e1e66d3a48db307eb7e59ab651dcd8a" translate="yes" xml:space="preserve">
          <source>The order of the elements that compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">比较等价的元素的顺序是插入顺序,不会改变。(自C++11起)。</target>
        </trans-unit>
        <trans-unit id="abd27fd7960ecb4b3cee9ed3bc8fa827648946bf" translate="yes" xml:space="preserve">
          <source>The order of the key-value pairs whose keys compare equivalent is the order of insertion and does not change. (since C++11).</source>
          <target state="translated">键值比较相等的键值对的顺序是插入顺序,不会改变。(自C++11起)。</target>
        </trans-unit>
        <trans-unit id="a9ef10d36f3c0c975aa40ae381346f09fe5d7ab9" translate="yes" xml:space="preserve">
          <source>The ordering comparisons are done lexicographically -- the comparison is performed by a function equivalent to &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">顺序比较是按字典顺序进行的-比较是通过等效于 &lt;code&gt;&lt;a href=&quot;../../algorithm/lexicographical_compare&quot;&gt;std::lexicographical_compare&lt;/a&gt;&lt;/code&gt; 的函数进行的。</target>
        </trans-unit>
        <trans-unit id="f0966d7161405c174477a1237dbe2bf1df99477d" translate="yes" xml:space="preserve">
          <source>The ordering is strict weak ordering relation.</source>
          <target state="translated">排序是严格的弱排序关系。</target>
        </trans-unit>
        <trans-unit id="1f12ff5d7e6a675fd2031dd36912c9789309ddc9" translate="yes" xml:space="preserve">
          <source>The original intent of the &lt;code&gt;inline&lt;/code&gt; keyword was to serve as an indicator to the optimizer that &lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;inline substitution of a function&lt;/a&gt; is preferred over function call, that is, instead of executing the function call CPU instruction to transfer control to the function body, a copy of the function body is executed without generating the call. This avoids overhead created by the function call (passing the arguments and retrieving the result) but it may result in a larger executable as the code for the function has to be repeated multiple times.</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 关键字的初衷是作为优化程序的指示，即&lt;a href=&quot;https://en.wikipedia.org/wiki/inline_expansion&quot;&gt;函数的内联替换&lt;/a&gt;优于函数调用，即，代替执行函数调用CPU指令将控制权转移到函数主体，它的副本在不生成调用的情况下执行函数主体。这样可以避免函数调用（传递参数和检索结果）所产生的开销，但是由于必须重复执行该函数的代码多次，因此可能导致可执行文件更大。</target>
        </trans-unit>
        <trans-unit id="083eed7b2639f184e8f8cd016a58c77c340553d1" translate="yes" xml:space="preserve">
          <source>The output iterator &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; makes it possible for standard algorithms to store results in uninitialized memory. Whenever the algorithm writes an object of type &lt;code&gt;T&lt;/code&gt; to the dereferenced iterator, the object is copy-constructed into the location in the uninitialized storage pointed to by the iterator. The template parameter &lt;code&gt;OutputIt&lt;/code&gt; is any type that meets the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and has &lt;code&gt;operator*&lt;/code&gt; defined to return an object, for which &lt;code&gt;operator&amp;amp;&lt;/code&gt; returns an object of type &lt;code&gt;T*&lt;/code&gt;. Usually, the type &lt;code&gt;T*&lt;/code&gt; is used as &lt;code&gt;OutputIt&lt;/code&gt;.</source>
          <target state="translated">输出迭代器 &lt;code&gt;std::raw_storage_iterator&lt;/code&gt; 使标准算法可以将结果存储在未初始化的内存中。每当算法将类型 &lt;code&gt;T&lt;/code&gt; 的对象写入已取消引用的迭代器时，该对象就会被复制构造到迭代器指向的未初始化存储中的位置。模板参数 &lt;code&gt;OutputIt&lt;/code&gt; 是满足&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;要求并定义了 &lt;code&gt;operator*&lt;/code&gt; 以返回对象的任何类型，为此 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 返回 &lt;code&gt;T*&lt;/code&gt; 类型的对象。通常，类型 &lt;code&gt;T*&lt;/code&gt; 用作 &lt;code&gt;OutputIt&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e482ce31b119d64121012b0392dad700a664ac70" translate="yes" xml:space="preserve">
          <source>The outputs of an expression consist of its result and all operands modified by the expression (if any).</source>
          <target state="translated">表达式的输出包括其结果和所有被表达式修改的操作数(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="9c85e268da67030ad87455310612ee6e33a42e99" translate="yes" xml:space="preserve">
          <source>The overload (3) only participates in overload resolution if &lt;code&gt;Sseq&lt;/code&gt; qualifies as a &lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;. In particular, it is excluded from the set of candidate functions if &lt;code&gt;Sseq&lt;/code&gt; is convertible to &lt;code&gt;result_type&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Sseq&lt;/code&gt; 合格为&lt;a href=&quot;../../../named_req/seedsequence&quot;&gt;SeedSequence，&lt;/a&gt;则重载（3）仅参与重载解析。特别是，如果 &lt;code&gt;Sseq&lt;/code&gt; 可转换为 &lt;code&gt;result_type&lt;/code&gt; ，则将其从候选函数集中排除。</target>
        </trans-unit>
        <trans-unit id="06bb537d779118fbd7f2e14985ef313bb0e992d7" translate="yes" xml:space="preserve">
          <source>The overload (3) zeroes out elements of non-class types such as &lt;code&gt;int&lt;/code&gt;, which is different from the behavior of &lt;a href=&quot;../../language/new&quot;&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;/a&gt;, which leaves them uninitialized. To match the behavior of &lt;code&gt;new[]&lt;/code&gt;, a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt; can be provided which leaves such elements uninitialized.</source>
          <target state="translated">重载（3）将非类类型的元素（例如 &lt;code&gt;int&lt;/code&gt; )清零，这与&lt;a href=&quot;../../language/new&quot;&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;/a&gt;的行为不同，该行为使它们未初始化。为了匹配 &lt;code&gt;new[]&lt;/code&gt; 的行为，可以提供一个&lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;自定义的Allocator :: construct&lt;/a&gt;，使此类元素未初始化。</target>
        </trans-unit>
        <trans-unit id="b0d7a75e51aff3dfb39b338a8d075fab0f39ca24" translate="yes" xml:space="preserve">
          <source>The overload (3) zeroes out elements of non-class types such as &lt;code&gt;int&lt;/code&gt;, which is different from the behavior of &lt;a href=&quot;../../language/new&quot;&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;/a&gt;, which leaves them uninitialized. To match the behavior of &lt;code&gt;new[]&lt;/code&gt;, a &lt;a href=&quot;https://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt; can be provided which leaves such elements uninitialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf1e7ebfe0e6d90d794292aee13cc0558b63e2d" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">的过载 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; 用于 &lt;code&gt;initializer_list&lt;/code&gt; 的指针返回到的第一个元素 &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="038f0a2e5a071bb2843d1c518dc177b71222920c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the first element in the numeric array.</source>
          <target state="translated">的过载 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;&lt;/code&gt; 对 &lt;code&gt;valarray&lt;/code&gt; 回报未指定的类型指的是第一个元素的数字阵列中的一个迭代。</target>
        </trans-unit>
        <trans-unit id="84c575ea93991f4dfe1b4bf2acfc46b67a8cd82c" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns a pointer to one past the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">超负荷 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; 了 &lt;code&gt;initializer_list&lt;/code&gt; 返回一个指向一个过去的最后一个元素 &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3e880f9ab6d60647899982795a8dda9c2944720" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;valarray&lt;/code&gt; returns an iterator of unspecified type referring to the one past the last element in the numeric array.</source>
          <target state="translated">的过载 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;&lt;/code&gt; 对 &lt;code&gt;valarray&lt;/code&gt; 返回未指定类型参照一个过去的数字阵列中的最后一个元素的一个迭代。</target>
        </trans-unit>
        <trans-unit id="dc73911917476c7646928434557b596727d6486b" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the last element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">超负荷 &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;initializer_list&lt;/code&gt; 返回一个 &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; 在最后一个元素指向 &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce6318ab93622dbaf9e7b41535ac8be907e21159" translate="yes" xml:space="preserve">
          <source>The overload of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;initializer_list&lt;/code&gt; returns an &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; pointing at the first element of &lt;code&gt;il&lt;/code&gt;.</source>
          <target state="translated">的过载 &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;initializer_list&lt;/code&gt; 返回一个 &lt;code&gt;&lt;a href=&quot;../../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; 在所述第一元件指向 &lt;code&gt;il&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c43a69d1f5e72f32062b0ff1de3c8b0d1df1068" translate="yes" xml:space="preserve">
          <source>The overload of operator &lt;code&gt;-&amp;gt;&lt;/code&gt; must either return a raw pointer, or return an object (by reference or by value) for which operator &lt;code&gt;-&amp;gt;&lt;/code&gt; is in turn overloaded.</source>
          <target state="translated">操作符 &lt;code&gt;-&amp;gt;&lt;/code&gt; 的重载必须返回原始指针，或者返回对象（按引用或按值），而操作符 &lt;code&gt;-&amp;gt;&lt;/code&gt; 的对象又被重载。</target>
        </trans-unit>
        <trans-unit id="59c7e08ff39317162bda21db4d04832d07f05332" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">不带 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会在底层OS API错误上引发&lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;，该错误由 &lt;code&gt;p&lt;/code&gt; 作为第一个路径参数，而OS错误代码作为错误代码参数构造。如果OS API调用失败，则采用 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会将其设置为OS API错误代码，如果没有错误发生，则执行 &lt;code&gt;ec.clear()&lt;/code&gt; 。如果内存分配失败，任何未标记为 &lt;code&gt;noexcept&lt;/code&gt; 的重载都可能引发 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68156db91adc064f5a1b3f123b0b56bb2aa82cf8" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;../filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">不带 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会在底层OS API错误上引发&lt;a href=&quot;../filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;，该错误是使用OS错误代码作为错误代码参数构造的。如果OS API调用失败，则采用 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会将其设置为OS API错误代码，如果没有错误发生，则执行 &lt;code&gt;ec.clear()&lt;/code&gt; 。如果内存分配失败，任何未标记为 &lt;code&gt;noexcept&lt;/code&gt; 的重载都可能引发 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a24af84b98cf1ff1037189e681754591d35e0d1f" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;from&lt;/code&gt; as the first path argument, &lt;code&gt;to&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">不带 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会在底层OS API错误上引发&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;，该错误 &lt;code&gt;from&lt;/code&gt; 作为第一个路径参数， &lt;code&gt;to&lt;/code&gt; 作为第二个路径参数以及OS错误代码作为错误代码参数构造。如果OS API调用失败，则采用 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会将其设置为OS API错误代码，如果没有错误发生，则执行 &lt;code&gt;ec.clear()&lt;/code&gt; 。如果内存分配失败，任何未标记为 &lt;code&gt;noexcept&lt;/code&gt; 的重载都可能引发 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c99e4f6d242cae156fe8c53c180077d5056a8e5" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;old_p&lt;/code&gt; as the first path argument, &lt;code&gt;new_p&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">不带 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会在底层OS API错误上引发&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;，该错误由 &lt;code&gt;old_p&lt;/code&gt; 作为第一个路径参数， &lt;code&gt;new_p&lt;/code&gt; 作为第二个路径参数以及OS错误代码作为错误代码参数构造。如果OS API调用失败，则采用 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会将其设置为OS API错误代码，如果没有错误发生，则执行 &lt;code&gt;ec.clear()&lt;/code&gt; 。如果内存分配失败，任何未标记为 &lt;code&gt;noexcept&lt;/code&gt; 的重载都可能引发 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0951321ca4ae56851938cae8c8021bfe0924467" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p1&lt;/code&gt; as the first path argument, &lt;code&gt;p2&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">不带 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会在底层OS API错误上引发&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;，该错误由 &lt;code&gt;p1&lt;/code&gt; 作为第一个路径参数， &lt;code&gt;p2&lt;/code&gt; 作为第二个路径参数以及OS错误代码作为错误代码参数构成。如果OS API调用失败，则采用 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会将其设置为OS API错误代码，如果没有错误发生，则执行 &lt;code&gt;ec.clear()&lt;/code&gt; 。如果内存分配失败，任何未标记为 &lt;code&gt;noexcept&lt;/code&gt; 的重载都可能引发 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="097925b28af9c725f044eb3f3ff1a0803fb41ab3" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">不带 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会在底层OS API错误上引发&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;，该错误由 &lt;code&gt;p&lt;/code&gt; 作为第一个路径参数，而OS错误代码作为错误代码参数构造。如果OS API调用失败，则采用 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会将其设置为OS API错误代码，如果没有错误发生，则执行 &lt;code&gt;ec.clear()&lt;/code&gt; 。如果内存分配失败，任何未标记为 &lt;code&gt;noexcept&lt;/code&gt; 的重载都可能引发 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2743dce817550a96f75513fc032ccf30bdcdc608" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;p&lt;/code&gt; as the first path argument, &lt;code&gt;base&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">不带 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会在底层OS API错误上引发&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;，该错误由 &lt;code&gt;p&lt;/code&gt; 作为第一个路径参数， &lt;code&gt;base&lt;/code&gt; 作为第二个路径参数以及OS错误代码作为错误代码参数构造。如果OS API调用失败，则采用 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会将其设置为OS API错误代码，如果没有错误发生，则执行 &lt;code&gt;ec.clear()&lt;/code&gt; 。如果内存分配失败，任何未标记为 &lt;code&gt;noexcept&lt;/code&gt; 的重载都可能引发 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45cad57e74ff3ba3f508e070185a6b0faa062d9c" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;path to be returned&lt;/code&gt; as the first path argument and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">不带 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会在基础OS API错误上引发&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;，该基础API错误 &lt;code&gt;path to be returned&lt;/code&gt; 的路径作为第一个路径参数以及OS错误代码作为错误代码参数构造的。如果OS API调用失败，则采用 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会将其设置为OS API错误代码，如果没有错误发生，则执行 &lt;code&gt;ec.clear()&lt;/code&gt; 。如果内存分配失败，任何未标记为 &lt;code&gt;noexcept&lt;/code&gt; 的重载都可能引发 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="63b27ca41e532a5a7a9cbe39b5246376a55b9912" translate="yes" xml:space="preserve">
          <source>The overload that does not take a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter throws &lt;a href=&quot;filesystem_error&quot;&gt;&lt;code&gt;filesystem_error&lt;/code&gt;&lt;/a&gt; on underlying OS API errors, constructed with &lt;code&gt;target&lt;/code&gt; as the first path argument, &lt;code&gt;link&lt;/code&gt; as the second path argument, and the OS error code as the error code argument. The overload taking a &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; parameter sets it to the OS API error code if an OS API call fails, and executes &lt;code&gt;ec.clear()&lt;/code&gt; if no errors occur. Any overload not marked &lt;code&gt;noexcept&lt;/code&gt; may throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">不带 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会在底层OS API错误上引发&lt;a href=&quot;filesystem_error&quot;&gt; &lt;code&gt;filesystem_error&lt;/code&gt; &lt;/a&gt;，该错误是使用 &lt;code&gt;target&lt;/code&gt; 作为第一个路径参数， &lt;code&gt;link&lt;/code&gt; 作为第二个路径参数以及OS错误代码作为错误代码参数构造的。如果OS API调用失败，则采用 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&amp;amp;&lt;/code&gt; 参数的重载会将其设置为OS API错误代码，如果没有错误发生，则执行 &lt;code&gt;ec.clear()&lt;/code&gt; 。如果内存分配失败，任何未标记为 &lt;code&gt;noexcept&lt;/code&gt; 的重载都可能引发 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b44057a826fb8d870cd4cdd23aeed9b3f71f525" translate="yes" xml:space="preserve">
          <source>The overload with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; reports errors as follows:</source>
          <target state="translated">具有名为 &lt;code&gt;ExecutionPolicy&lt;/code&gt; 的模板参数的重载报告错误，如下所示：</target>
        </trans-unit>
        <trans-unit id="be64bc9e876275165a0c7eba9eb5ad84ea913bf6" translate="yes" xml:space="preserve">
          <source>The overloads (2-6) provide allocator propagation into &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;, which supports neither leading-allocator nor trailing-allocator calling conventions (unlike, e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, which uses leading-allocator convention).</source>
          <target state="translated">重载（2-6）提供了分配器传播到 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; ，既不支持前导分配器也不支持尾随分配器调用约定（与 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; ，它使用前导分配器约定）。</target>
        </trans-unit>
        <trans-unit id="684f3f556fb197adb926e01a526a9556d8043a2d" translate="yes" xml:space="preserve">
          <source>The overloads (5,6) are often implemented as a loop that calls the overload (3) with &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; as the hint; they are optimized for appending a sorted sequence (such as another set) whose smallest element is greater than the last element in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">重载（5,6）通常实现为一个循环，该循环以 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 作为提示来调用重载（3）。它们经过优化以附加排序的序列（例如另一个集合），该序列的最小元素大于 &lt;code&gt;*this&lt;/code&gt; 中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="70d94f85af425ede81ffbbe7061489408578ee30" translate="yes" xml:space="preserve">
          <source>The overloads are marked as &lt;code&gt;constexpr&lt;/code&gt; since C++14.</source>
          <target state="translated">从C ++ 14开始，重载被标记为 &lt;code&gt;constexpr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44fe9b19e02fae03d565fc0de302ad3d97db79e7" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">不将 &lt;code&gt;opts&lt;/code&gt; 作为参数的重载使用&lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; &lt;/a&gt;的默认构造实例作为选项。不将 &lt;code&gt;upstream&lt;/code&gt; 作为参数的重载使用 &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; 的返回值作为上游内存资源。</target>
        </trans-unit>
        <trans-unit id="5088ac896f932a6a0d4f549d22b00102f8ee7619" translate="yes" xml:space="preserve">
          <source>The overloads not taking &lt;code&gt;opts&lt;/code&gt; as a parameter uses a default constructed instance of &lt;a href=&quot;../pool_options&quot;&gt;&lt;code&gt;pool_options&lt;/code&gt;&lt;/a&gt; as the options. The overloads not taking &lt;code&gt;upstream&lt;/code&gt; as a parameter uses the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; as the upstream memory resource.</source>
          <target state="translated">不将 &lt;code&gt;opts&lt;/code&gt; 作为参数的重载使用&lt;a href=&quot;../pool_options&quot;&gt; &lt;code&gt;pool_options&lt;/code&gt; &lt;/a&gt;的默认构造实例作为选项。不将 &lt;code&gt;upstream&lt;/code&gt; 作为参数的重载使用 &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;&lt;/code&gt; 的返回值作为上游内存资源。</target>
        </trans-unit>
        <trans-unit id="8126e43884394c17d3457633c0894495b6f29864" translate="yes" xml:space="preserve">
          <source>The overloads of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; that take a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; as the left hand argument are known as insertion and extraction operators. Since they take the user-defined type as the right argument (&lt;code&gt;b&lt;/code&gt; in a@b), they must be implemented as non-members.</source>
          <target state="translated">带有 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆或 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&amp;amp;&lt;/code&gt; ＆作为左手参数的 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 的重载称为插入和提取运算符。由于它们将用户定义的类型作为正确的参数（ &lt;code&gt;b&lt;/code&gt; @ b中的b），因此必须将它们实现为非成员。</target>
        </trans-unit>
        <trans-unit id="435446cb476ebaebe355f8cf48105e0dddc8213e" translate="yes" xml:space="preserve">
          <source>The overloads of operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; lose short-circuit evaluation.</source>
          <target state="translated">运算符 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 的重载 失去短路评估。</target>
        </trans-unit>
        <trans-unit id="c77c38e018a2a03f4663ee8fdfa0fd3a61518b4d" translate="yes" xml:space="preserve">
          <source>The overloads taking parameters named &lt;code&gt;pos1&lt;/code&gt; or &lt;code&gt;pos2&lt;/code&gt; throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if the argument is out of range.</source>
          <target state="translated">如果参数超出范围，则使用名为 &lt;code&gt;pos1&lt;/code&gt; 或 &lt;code&gt;pos2&lt;/code&gt; 的参数的重载将引发 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15de6f30385481ec7a64ac4f54a04bf7a70486ea" translate="yes" xml:space="preserve">
          <source>The overloads that do not use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument becomes the element of a pair. The overloads that use &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; assume that each tuple argument is used to construct, piecewise, a new object of specified type, which will become the element of the pair.</source>
          <target state="translated">不使用 &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; 的重载假定每个元组参数成为一对的元素。使用 &lt;code&gt;std::piecewise_construct_t&lt;/code&gt; 的重载假定每个元组参数用于逐段构造指定类型的新对象，该对象将成为该对的元素。</target>
        </trans-unit>
        <trans-unit id="b7bdb96b9c09362e092f33a4cbae2fe72c83f4e2" translate="yes" xml:space="preserve">
          <source>The overloads with a template parameter named &lt;code&gt;ExecutionPolicy&lt;/code&gt; report errors as follows:</source>
          <target state="translated">具有名为 &lt;code&gt;ExecutionPolicy&lt;/code&gt; 的模板参数的重载报告错误，如下所示：</target>
        </trans-unit>
        <trans-unit id="a864b224232c408c9511f10f7feafcbf33889a52" translate="yes" xml:space="preserve">
          <source>The override for the virtual member function &lt;code&gt;what()&lt;/code&gt; may by provided, but is not required.</source>
          <target state="translated">可以提供但不要求对虚拟成员函数 &lt;code&gt;what()&lt;/code&gt; 进行覆盖。</target>
        </trans-unit>
        <trans-unit id="8d89be08f6f6c31578200be6591584e87d1fdf78" translate="yes" xml:space="preserve">
          <source>The overriders of &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt; functions do not acquire the default arguments from the base class declarations, and when the virtual function call is made, the default arguments are decided based on the static type of the object (note: this can be avoided with &lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;non-virtual interface&lt;/a&gt; pattern).</source>
          <target state="translated">&lt;a href=&quot;virtual&quot;&gt;虚拟&lt;/a&gt;函数的重写器不会从基类声明中获取默认参数，并且在调用虚拟函数时，将根据对象的静态类型来确定默认参数（注意：使用&lt;a href=&quot;http://www.gotw.ca/publications/mill18.htm&quot;&gt;非虚拟方法&lt;/a&gt;可以避免这种情况）接口模式）。</target>
        </trans-unit>
        <trans-unit id="c2ff4997fdc8d657823adaf82ddae1edd807b428" translate="yes" xml:space="preserve">
          <source>The ownership of an object can only be shared with another &lt;code&gt;shared_ptr&lt;/code&gt; by copy constructing or copy assigning its value to another &lt;code&gt;shared_ptr&lt;/code&gt;. Constructing a new &lt;code&gt;shared_ptr&lt;/code&gt; using the raw underlying pointer owned by another &lt;code&gt;shared_ptr&lt;/code&gt; leads to undefined behavior.</source>
          <target state="translated">对象的所有权只能与另一个共享 &lt;code&gt;shared_ptr&lt;/code&gt; 通过拷贝构建或复制分配它的值到另一个 &lt;code&gt;shared_ptr&lt;/code&gt; 的。使用另一个 &lt;code&gt;shared_ptr&lt;/code&gt; 拥有的原始基础指针构造新的 &lt;code&gt;shared_ptr&lt;/code&gt; 会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="fa11b27c4386988848a8387d60af610e8a21c655" translate="yes" xml:space="preserve">
          <source>The paragraph defining the strict aliasing rule in the standard contains two additional bullets partially inherited from C:</source>
          <target state="translated">标准中定义严格的别名规则的段落包含两个额外的圆点,部分继承自C。</target>
        </trans-unit>
        <trans-unit id="8d946d0089157a6f8805e15b4ad51c2da0943b9d" translate="yes" xml:space="preserve">
          <source>The parallelizable version of this algorithm, &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt;, requires &lt;code&gt;op1&lt;/code&gt; and &lt;code&gt;op2&lt;/code&gt; to be commutative and associative, but &lt;code&gt;std::inner_product&lt;/code&gt; makes no such requirement, and always performs the operations in the order given.</source>
          <target state="translated">该算法的可并行化版本 &lt;code&gt;&lt;a href=&quot;transform_reduce&quot;&gt;std::transform_reduce&lt;/a&gt;&lt;/code&gt; 要求 &lt;code&gt;op1&lt;/code&gt; 和 &lt;code&gt;op2&lt;/code&gt; 是可交换和关联的，但 &lt;code&gt;std::inner_product&lt;/code&gt; 却没有这样的要求，并且始终按照给定的顺序执行操作。</target>
        </trans-unit>
        <trans-unit id="88022664eeccd42a9c9975d465fba66ce4506250" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared type of the variable that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt; or, if the initialization is copy-list-initialization, with &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the initializer expression. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;P&lt;/code&gt; to get the actual variable type:</source>
          <target state="translated">参数 &lt;code&gt;P&lt;/code&gt; 的获取方式如下：在 &lt;code&gt;T&lt;/code&gt; 中，包括 &lt;code&gt;auto&lt;/code&gt; 在内的变量的声明类型，每次 &lt;code&gt;auto&lt;/code&gt; 都用虚构类型模板参数 &lt;code&gt;U&lt;/code&gt; 替换，或者，如果初始化为copy-list-initialization，则替换为 &lt;code&gt;std::initializer_list&amp;lt;U&amp;gt;&lt;/code&gt; 。参数 &lt;code&gt;A&lt;/code&gt; 是初始化程序表达式。扣除 &lt;code&gt;U&lt;/code&gt; 从 &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 遵循上述的规则，推导的 &lt;code&gt;U&lt;/code&gt; 代入 &lt;code&gt;P&lt;/code&gt; 以获得实际的变量类型：</target>
        </trans-unit>
        <trans-unit id="ced868183336be7e9556ada04c5529aea418503e" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;i&lt;/code&gt; shall be less than the number of elements in the array; otherwise, the behavior is undefined.</source>
          <target state="translated">参数 &lt;code&gt;i&lt;/code&gt; 应小于数组中元素的数量；否则，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="399902f69cf10a83ab53fc5cc2b8d7444ca7d8d2" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;init&lt;/code&gt; appears last, differing from &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt;, because it is optional for this function.</source>
          <target state="translated">参数 &lt;code&gt;init&lt;/code&gt; 出现在最后，与 &lt;code&gt;&lt;a href=&quot;transform_exclusive_scan&quot;&gt;std::transform_exclusive_scan&lt;/a&gt;&lt;/code&gt; 不同，因为此函数是可选的。</target>
        </trans-unit>
        <trans-unit id="309510cf9024b1695506845548ff6ef69f7b6db0" translate="yes" xml:space="preserve">
          <source>The parameter is passed by value and is subject to slicing.</source>
          <target state="translated">参数是通过值来传递的,要进行分片。</target>
        </trans-unit>
        <trans-unit id="7f622764221043c46158533031680f20b679054a" translate="yes" xml:space="preserve">
          <source>The parameter types and the return type of the function must match the target exactly, no implicit conversions are considered (e.g. a function returning a pointer to derived won't get selected when initializing a pointer to function returning a pointer to base).</source>
          <target state="translated">函数的参数类型和返回类型必须与目标完全匹配,不考虑隐式转换(例如,当初始化一个返回指向派生的指针的函数时,返回指向base的指针的函数不会被选中)。</target>
        </trans-unit>
        <trans-unit id="04103a3447a63b6cf20e5c231a8fc7a4ccdc71ac" translate="yes" xml:space="preserve">
          <source>The parameter types, as well as the return type of a function cannot be &lt;a href=&quot;incomplete_type&quot;&gt;incomplete&lt;/a&gt;&lt;a href=&quot;class&quot;&gt;class types&lt;/a&gt;, except for deleted functions(since C++11). The completeness check is made in the context of the function</source>
          <target state="translated">除了已删除的函数（自C ++ 11起）外，函数的参数类型以及返回类型不能为&lt;a href=&quot;incomplete_type&quot;&gt;不完整的&lt;/a&gt;&lt;a href=&quot;class&quot;&gt;类类型&lt;/a&gt;。完整性检查是在函数的上下文中进行的</target>
        </trans-unit>
        <trans-unit id="72593e2e10e937d3bd8a9e45b5e7630cd1c55e97" translate="yes" xml:space="preserve">
          <source>The parameters declared in the declarator of a function definition are &lt;a href=&quot;scope&quot;&gt;in scope&lt;/a&gt; within the body. If a parameter is not used in the function body, it does not need to be named (it's sufficient to use an abstract declarator).</source>
          <target state="translated">在函数定义的声明程序中声明的参数在主体的&lt;a href=&quot;scope&quot;&gt;范围&lt;/a&gt;内。如果在函数体中未使用参数，则无需对其进行命名（使用抽象声明符就足够了）。</target>
        </trans-unit>
        <trans-unit id="d233ef2eab4dce31ee515ec28dc0e9bc316caee3" translate="yes" xml:space="preserve">
          <source>The parameters m and s are, respectively, the mean and standard deviation of the natural logarithm of x.</source>
          <target state="translated">参数m和s分别是x的自然对数的平均值和标准差。</target>
        </trans-unit>
        <trans-unit id="cef460ed950b6b80761f1b32499ca34a65c8b52d" translate="yes" xml:space="preserve">
          <source>The parameters of a distribution object may be changed either permanently, by using &lt;code&gt;d.param(p)&lt;/code&gt; or just for the duration of a single operator() call, by using &lt;code&gt;d(g,p)&lt;/code&gt;.</source>
          <target state="translated">分发对象的参数可以通过使用 &lt;code&gt;d.param(p)&lt;/code&gt; 进行永久更改，也可以仅在单个operator（）调用期间通过使用 &lt;code&gt;d(g,p)&lt;/code&gt; 进行更改。</target>
        </trans-unit>
        <trans-unit id="d2936a021e331baf2a03da363a001e002fbef98a" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, size and stride respectively.</source>
          <target state="translated">切片的参数--分别是开始、大小和步幅。</target>
        </trans-unit>
        <trans-unit id="0269c7638cb516f0a5e4f2122a21b168b3bc2795" translate="yes" xml:space="preserve">
          <source>The parameters of the slice -- start, sizes and strides respectively.</source>
          <target state="translated">切片的参数 --分别是开始、尺寸和步长。</target>
        </trans-unit>
        <trans-unit id="467dc40c372e73f0c2c12405d62c7e8ef32d3367" translate="yes" xml:space="preserve">
          <source>The parameters of the two-parameter form of the main function allow arbitrary multibyte character strings to be passed from the execution environment (these are typically known as</source>
          <target state="translated">主函数的两个参数形式的参数允许从执行环境中传递任意的多字节字符串(这些字符串通常称为</target>
        </trans-unit>
        <trans-unit id="3c5a1d2074edfc3d26b83a970525326f7df017be" translate="yes" xml:space="preserve">
          <source>The parsed date is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">解析的日期存储在参数 &lt;code&gt;t&lt;/code&gt; 指向的 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 结构的相应字段中。</target>
        </trans-unit>
        <trans-unit id="6f535b74a20fe9252e07e454d87e684ef404bcaa" translate="yes" xml:space="preserve">
          <source>The parsed month is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt;.</source>
          <target state="translated">解析的月份存储在 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 字段 &lt;code&gt;t-&amp;gt;tm_mon&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="d5c30cfbbbd6f7927a29d7fcfe63ecd32a351360" translate="yes" xml:space="preserve">
          <source>The parsed time is stored in the corresponding fields of the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure pointed to by the argument &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">解析的时间存储在参数 &lt;code&gt;t&lt;/code&gt; 指向的 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 结构的相应字段中。</target>
        </trans-unit>
        <trans-unit id="14f5b5d4d2f8aed5cb8f99bcda8328dda074ac91" translate="yes" xml:space="preserve">
          <source>The parsed weekday is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; field &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt;.</source>
          <target state="translated">解析的工作日存储在 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 字段 &lt;code&gt;t-&amp;gt;tm_wday&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="0cdf3188b56cdad85a77a2a64d2b697625de2a7b" translate="yes" xml:space="preserve">
          <source>The parsed year is stored in the &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; structure field &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt;.</source>
          <target state="translated">解析的年份存储在 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 结构字段 &lt;code&gt;t-&amp;gt;tm_year&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="c55bd34e7cff3055dc08d70fe226b40f2972b1b5" translate="yes" xml:space="preserve">
          <source>The partial specialization (5) only exists if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; is not convertible to &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;Rep&amp;gt;&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 并且 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep, Period&amp;gt;&lt;/code&gt; 无法转换为 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;&lt;/code&gt; chrono :: seconds时，才存在部分专业化（5）。</target>
        </trans-unit>
        <trans-unit id="23f549c7dd61d901fe54500a09da11aa34be717c" translate="yes" xml:space="preserve">
          <source>The partial specialization of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; for pairs provides a compile-time way to obtain the number of elements in a pair, which is always 2, using tuple-like syntax.</source>
          <target state="translated">对偶的 &lt;code&gt;&lt;a href=&quot;../tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&lt;/code&gt; 的部分专业化提供了一种编译时方式，可使用类似tuple的语法获取对中的元素数量，该数量始终为2。</target>
        </trans-unit>
        <trans-unit id="c5221fc4cfc2057c802611cbc8029455768b8710" translate="yes" xml:space="preserve">
          <source>The partial specializations of &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if &lt;code&gt;I &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="translated">对的 &lt;code&gt;&lt;a href=&quot;../tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&lt;/code&gt; 的部分专业化提供了使用类似元组的语法的编译时对对元素类型的访问。如果 &lt;code&gt;I &amp;gt;= 2&lt;/code&gt; 则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="c9182a1c88da6a522cf7ab9faaecc8994e994260" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate shared_ptr objects atomically.</source>
          <target state="translated">的模板偏特 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 允许用户操纵的shared_ptr原子对象。</target>
        </trans-unit>
        <trans-unit id="eb0acd7ca55c8a975ce7a1790dcea9fa121ca3b5" translate="yes" xml:space="preserve">
          <source>The partial template specialization of &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to manipulate weak_ptr objects atomically.</source>
          <target state="translated">的模板偏特 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 允许用户操纵的weak_ptr原子对象。</target>
        </trans-unit>
        <trans-unit id="3b413e1a3d2902ad2bd6f7353c7ed24fbd704a4c" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator deserves particular mention. In general this iterator is invalidated as though it were a normal iterator to a non-erased element. So &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; is never invalidated, &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; is invalidated only on rehash, &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; is always invalidated (since it is always after the modified elements), and so on.</source>
          <target state="translated">过去的迭代器值得特别提及。通常，此迭代器是无效的，就好像它是未擦除元素的普通迭代器一样。因此， &lt;code&gt;&lt;a href=&quot;container/set/end&quot;&gt;std::set::end&lt;/a&gt;&lt;/code&gt; 永远不会失效， &lt;code&gt;&lt;a href=&quot;container/unordered_set/end&quot;&gt;std::unordered_set::end&lt;/a&gt;&lt;/code&gt; 仅在重新哈希时失效， &lt;code&gt;&lt;a href=&quot;container/vector/end&quot;&gt;std::vector::end&lt;/a&gt;&lt;/code&gt; 总是无效的（因为它总是在修改后的元素之后），依此类推。</target>
        </trans-unit>
        <trans-unit id="4b284ed6473a51bd21fc130bcb9ebaf961cac342" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator is also invalidated unless the erased elements are at the beginning of the container and the last element is not erased.</source>
          <target state="translated">除非被擦除的元素在容器的开头,并且最后一个元素没有被擦除,否则过去-结束迭代器也是无效的。</target>
        </trans-unit>
        <trans-unit id="b0677f6c9e33d408c8fc74dad13a28a32a573cdb" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator may be invalidated (implementation defined)</source>
          <target state="translated">过去的末尾迭代器可能会失效(实现定义)</target>
        </trans-unit>
        <trans-unit id="3b5524c20e358d594b020e8bdb5b108f709ab7d9" translate="yes" xml:space="preserve">
          <source>The past-the-end iterator.</source>
          <target state="translated">过去的结束迭代器。</target>
        </trans-unit>
        <trans-unit id="5e5a668c57f23b6460fdf63ef2455241134daf73" translate="yes" xml:space="preserve">
          <source>The path &lt;code&gt;&quot;/&quot;&lt;/code&gt; is absolute on a POSIX OS, but is relative on Windows.</source>
          <target state="translated">路径 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 在POSIX操作系统上是绝对的，但在Windows上是相对的。</target>
        </trans-unit>
        <trans-unit id="82f5c6939e80a9a4b63791641284d31cb36ab963" translate="yes" xml:space="preserve">
          <source>The path can be traversed element-wise via iterators returned by the &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; functions, which views the path in generic format and iterates over root name, root directory, and the subsequent file name elements (directory separators are skipped except the one that identifies the root directory). If the very last element in the path is a directory separator, the last iterator will dereference to an empty element.</source>
          <target state="translated">可以通过 &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;path/begin&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 函数返回的迭代器逐元素遍历路径，这些迭代器以通用格式查看路径并遍历根名称，根目录和后续的文件名元素（跳过目录分隔符，除了标识根目录的目录）。如果路径中的最后一个元素是目录分隔符，则最后一个迭代器将取消引用一个空元素。</target>
        </trans-unit>
        <trans-unit id="1e16e300f585e54bf938d0439911d56726dd815b" translate="yes" xml:space="preserve">
          <source>The path constructed from the input string after conversion from UTF-8 to the filesystem's native character encoding.</source>
          <target state="translated">从输入字符串从UTF-8转换为文件系统的本地字符编码后构建的路径。</target>
        </trans-unit>
        <trans-unit id="6e603cf030e4d0195d580420c1da816f92ceb1c9" translate="yes" xml:space="preserve">
          <source>The path name has the following syntax:</source>
          <target state="translated">路径名称的语法如下。</target>
        </trans-unit>
        <trans-unit id="e8eb701045d3a46c2ebb72285abb0e82f58fd37e" translate="yes" xml:space="preserve">
          <source>The path to the parent directory.</source>
          <target state="translated">父目录的路径。</target>
        </trans-unit>
        <trans-unit id="1ceffb6cd0e4fed5091cf63b5f6b9f72943aad5c" translate="yes" xml:space="preserve">
          <source>The perimeter of an ellipse with eccentricity &lt;code&gt;k&lt;/code&gt; and semimajor axis a equals 4aE(k), where E is &lt;code&gt;std::comp_ellint_2&lt;/code&gt;. When eccentricity equals 0, the ellipse degenerates to a circle with radius a and the perimeter equals 2&amp;pi;a, so E(0) = &amp;pi;/2. When eccentricity equals 1, the ellipse degenerates to a line of length 2a, whose perimeter is 4a, so E(1) = 1.</source>
          <target state="translated">偏心率为 &lt;code&gt;k&lt;/code&gt; 且半长轴为a 的椭圆的周长等于4aE（k），其中E为 &lt;code&gt;std::comp_ellint_2&lt;/code&gt; 。当偏心率等于0时，椭圆会退化为半径为a且圆周等于2&amp;pi;a的圆，因此E（0）=&amp;pi;/ 2。当离心率等于1时，椭圆退化为长度为2a的线，其周长为4a，因此E（1）= 1。</target>
        </trans-unit>
        <trans-unit id="e4b5a30aa03db848f6592cd57db56eefa2e1e7f9" translate="yes" xml:space="preserve">
          <source>The period of the resulting duration is the greatest common divisor of &lt;code&gt;Period1&lt;/code&gt; and &lt;code&gt;Period2&lt;/code&gt;.</source>
          <target state="translated">结果持续时间的周期是 &lt;code&gt;Period1&lt;/code&gt; 和 &lt;code&gt;Period2&lt;/code&gt; 的最大公约数。</target>
        </trans-unit>
        <trans-unit id="6b1ecc6341dad0825427d240ecf259972a63f062" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; can be used in conversion-type-id, indicating a &lt;a href=&quot;function#Return_type_deduction&quot;&gt;deduced return type&lt;/a&gt;:</source>
          <target state="translated">占位符&lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;可以在conversion-type-id中使用，指示&lt;a href=&quot;function#Return_type_deduction&quot;&gt;推导的返回类型&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="11988032bccc6150348612dc3dc97330efc38f94" translate="yes" xml:space="preserve">
          <source>The placeholder &lt;code&gt;auto&lt;/code&gt; may be accompanied by modifiers, such as &lt;code&gt;const&lt;/code&gt; or &lt;code&gt;&amp;amp;&lt;/code&gt;, which will participate in the type deduction. The placeholder &lt;code&gt;decltype(auto)&lt;/code&gt; must be the the sole constituent of the declared type.(since C++14).</source>
          <target state="translated">占位符 &lt;code&gt;auto&lt;/code&gt; 可能附带修饰符，例如 &lt;code&gt;const&lt;/code&gt; 或 &lt;code&gt;&amp;amp;&lt;/code&gt; ，它们将参与类型推导。占位符 &lt;code&gt;decltype(auto)&lt;/code&gt; 必须是声明的类型的唯一组成部分。（从C ++ 14开始）。</target>
        </trans-unit>
        <trans-unit id="8188f0beadbdc9f67fbcab0cca288be6624dd85d" translate="yes" xml:space="preserve">
          <source>The placement form &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; is not allowed because the matching signature of the deallocation function, &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt;, is a usual (not placement) deallocation function.</source>
          <target state="translated">不允许使用布局形式 &lt;code&gt;void* operator new(std::size_t, std::size_t)&lt;/code&gt; 因为取消分配函数的匹配签名 &lt;code&gt;void operator delete(void*, std::size_t)&lt;/code&gt; 是常见的（非布局）释放功能。</target>
        </trans-unit>
        <trans-unit id="5912c23fdb49cda02bccb62c7fc1895dae110adc" translate="yes" xml:space="preserve">
          <source>The platform-dependent error value.</source>
          <target state="translated">平台相关的错误值。</target>
        </trans-unit>
        <trans-unit id="22e0322c3fe2739912f4200c9d7cc04be3a7791f" translate="yes" xml:space="preserve">
          <source>The point of declaration for an &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt; is immediately following the opening brace of its class (or class template) definition.</source>
          <target state="translated">&lt;a href=&quot;injected-class-name&quot;&gt;注入的类名&lt;/a&gt;的声明点紧随其类（或类模板）定义的大括号之后。</target>
        </trans-unit>
        <trans-unit id="0cc6d0e2bd00875eb3b647ab691eaf3a40b734e4" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt; is immediately after the identifier-list of the structured binding declaration, but structured binding initializers are prohibited from referring to any of the names being introduced.</source>
          <target state="translated">&lt;a href=&quot;structured_binding&quot;&gt;结构化绑定&lt;/a&gt;的声明要紧接在结构化绑定声明的标识符列表之后，但是结构化绑定初始化器禁止引用任何引入的名称。</target>
        </trans-unit>
        <trans-unit id="d2eaa3ef9aed1f964e68ecd40fdb0b4090b12a22" translate="yes" xml:space="preserve">
          <source>The point of declaration of a &lt;a href=&quot;type_alias&quot;&gt;type alias or alias template&lt;/a&gt; is immediately after the type-id to which the alias refers:</source>
          <target state="translated">&lt;a href=&quot;type_alias&quot;&gt;类型别名或别名模板&lt;/a&gt;的声明点紧跟在别名所指的type-id之后：</target>
        </trans-unit>
        <trans-unit id="fead0939c1b9750ab484b917a8bc503ed969f8da" translate="yes" xml:space="preserve">
          <source>The point of declaration of a class or template is immediately after the identifier that names the class (or the &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; that names the template specialization) appears in its &lt;a href=&quot;classes&quot;&gt;class-head&lt;/a&gt;, and is already in scope in the list of the base classes:</source>
          <target state="translated">一个类或模板的声明的要点是立即标识后命名的类（或&lt;a href=&quot;templates#template-id&quot;&gt;模板id&lt;/a&gt;名称模板专业化）出现在其&lt;a href=&quot;classes&quot;&gt;班头&lt;/a&gt;，并且已经在范围在基类的列表：</target>
        </trans-unit>
        <trans-unit id="9f0644324f7e4cf1aefd74a5866f04764d1f1056" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumeration is immediately after the identifier that names it appears in the &lt;a href=&quot;enum&quot;&gt;enum specifier&lt;/a&gt; or opaque enum declaration, whichever is used first:</source>
          <target state="translated">枚举的声明点紧随在&lt;a href=&quot;enum&quot;&gt;枚举说明符&lt;/a&gt;或不透明的枚举声明中出现的名称标识符之后，以先使用者为准：</target>
        </trans-unit>
        <trans-unit id="47421c40dd3c8897ae17db10f6de7045e0604b49" translate="yes" xml:space="preserve">
          <source>The point of declaration of an enumerator is immediately after its definition (not before the initializer as it is for variables):</source>
          <target state="translated">枚举器的声明点是紧接在其定义之后(而不是像变量那样在初始化器之前)。</target>
        </trans-unit>
        <trans-unit id="82b67920a9148c6fc228fb43bc313b703cc12c0e" translate="yes" xml:space="preserve">
          <source>The pointed-to type of a pointer-to-member may be a pointer-to-member itself: pointers to members can be multilevel, and can be cv-qualifed differently at every level. Mixed multi-level combinations of pointers and pointers-to-members are also allowed:</source>
          <target state="translated">指向成员的指针类型可以是指向成员本身的指针:指向成员的指针可以是多级的,并且可以在每一级都有不同的cv限定。指针和指针到成员的多级混合组合也是允许的。</target>
        </trans-unit>
        <trans-unit id="857df6b1a996ed03a792d5426b8be017166c9590" translate="yes" xml:space="preserve">
          <source>The pointer held by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*this&lt;/code&gt; 持有的指针。</target>
        </trans-unit>
        <trans-unit id="1a569ae03f99a2e029c35053360ec402ea8825c3" translate="yes" xml:space="preserve">
          <source>The pointer held by the &lt;code&gt;shared_ptr&lt;/code&gt; directly is the one returned by &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;, while the pointer/object held by the control block is the one that will be deleted when the number of shared owners reaches zero. These pointers are not necessarily equal.</source>
          <target state="translated">由 &lt;code&gt;shared_ptr&lt;/code&gt; 直接持有的指针是由 &lt;code&gt;&lt;a href=&quot;shared_ptr/get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; 返回的指针，而由控制块持有的指针/对象是当共享所有者的数量达到零时将被删除的指针/对象。这些指针不一定相等。</target>
        </trans-unit>
        <trans-unit id="0b9194591fdc314a0ecc3f4298cf510d1793c0b0" translate="yes" xml:space="preserve">
          <source>The pointer is such that the range &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; is valid and the values in it correspond to the values stored in the string with an additional null character after the last position.</source>
          <target state="translated">指针的范围是 &lt;code&gt;[c_str(); c_str() + size()]&lt;/code&gt; 有效，并且其中的值与存储在字符串中的值相对应，最后一个位置后还有一个附加的空字符。</target>
        </trans-unit>
        <trans-unit id="bc4de43f158ae279800dabe183ad787c290be28c" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">从 &lt;code&gt;c_str()&lt;/code&gt; 获得的指针可能通过以下方式无效：</target>
        </trans-unit>
        <trans-unit id="25f266f248c76589a2ccd4234acbb0c2d4e4eacd" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;c_str()&lt;/code&gt; may only be treated as a pointer to a null-terminated character string if the string object does not contain other null characters.</source>
          <target state="translated">如果字符串对象不包含其他空字符，则只能将从 &lt;code&gt;c_str()&lt;/code&gt; 获得的指针视为以空终止的字符串的指针。</target>
        </trans-unit>
        <trans-unit id="83480f14010d5cb1f67d2563b68adf44bf7bc56e" translate="yes" xml:space="preserve">
          <source>The pointer obtained from &lt;code&gt;data()&lt;/code&gt; may be invalidated by:</source>
          <target state="translated">从 &lt;code&gt;data()&lt;/code&gt; 获得的指针可能通过以下方式无效：</target>
        </trans-unit>
        <trans-unit id="f8a783b19ce6451ba52b4dc182db830ef0e17f42" translate="yes" xml:space="preserve">
          <source>The pointer returned by the call to &lt;code&gt;a.allocate(n)&lt;/code&gt;.</source>
          <target state="translated">调用返回到 &lt;code&gt;a.allocate(n)&lt;/code&gt; 的指针。</target>
        </trans-unit>
        <trans-unit id="62efe07fde27af3eb6cd42fa101df3a460a161fb" translate="yes" xml:space="preserve">
          <source>The pointer safety used by this implementation.</source>
          <target state="translated">本实施例使用的指针安全。</target>
        </trans-unit>
        <trans-unit id="cdcc993eb7230b5cf2a0e319e9141223d606af16" translate="yes" xml:space="preserve">
          <source>The pointer to convert</source>
          <target state="translated">要转换的指针</target>
        </trans-unit>
        <trans-unit id="3616897fc4a7fb62d60e2791e6f3b00f4006b358" translate="yes" xml:space="preserve">
          <source>The pointer to the allocated storage.</source>
          <target state="translated">指向分配的存储空间的指针。</target>
        </trans-unit>
        <trans-unit id="3c8844a746827bb53e8a970ddaf5df27d6244fac" translate="yes" xml:space="preserve">
          <source>The pointer to the block of storage to be reclaimed is passed to the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; that was selected by the process above as the first argument. The size of the block is passed as the optional &lt;code&gt;std::size_t&lt;/code&gt; argument. The alignment requirement is passed as the optional &lt;code&gt;std::align_val_t&lt;/code&gt; argument.(since C++17).</source>
          <target state="translated">指向要回收的存储块的指针将传递到由上述过程选择作为第一个参数的&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;释放函数&lt;/a&gt;。块的大小作为可选的 &lt;code&gt;std::size_t&lt;/code&gt; 参数传递。对齐要求作为可选的 &lt;code&gt;std::align_val_t&lt;/code&gt; 参数传递。（自C ++ 17起）。</target>
        </trans-unit>
        <trans-unit id="2f9790c4ee1ba3e3c2d585a13b1c938331446c70" translate="yes" xml:space="preserve">
          <source>The popular Edsger W. Dijkstra essay, &lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;&amp;ldquo;Goto Considered Harmful&amp;rdquo;&lt;/a&gt;, presents a survey of the many subtle problems the careless use of this keyword can introduce.</source>
          <target state="translated">流行的Edsger W. Dijkstra文章&lt;a href=&quot;http://david.tribble.com/text/goto.html&quot;&gt;&amp;ldquo; Goto被认为有害&amp;rdquo;&lt;/a&gt;，介绍了对该关键字的粗心使用可能引起的许多细微问题。</target>
        </trans-unit>
        <trans-unit id="3db1aee0e463b1a7e37a693db9028dc4dd6c01b3" translate="yes" xml:space="preserve">
          <source>The portion of the declaration preceding &lt;code&gt;[&lt;/code&gt; applies to the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;, not to the introduced identifiers.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; 之前的声明部分适用于隐藏变量 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; ，不适用于引入的标识符。</target>
        </trans-unit>
        <trans-unit id="63e5a10c38c160db27db345693a402cc1e1242ee" translate="yes" xml:space="preserve">
          <source>The position of the first character of the specified match or sub-match.</source>
          <target state="translated">指定匹配或子匹配的第一个字符的位置。</target>
        </trans-unit>
        <trans-unit id="28cd458ec55f909805d8bb05b742449475997ff5" translate="yes" xml:space="preserve">
          <source>The possible values for this type (&lt;code&gt;icase&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, etc.) are duplicated inside &lt;a href=&quot;basic_regex/constants&quot;&gt;std::basic_regex&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;basic_regex/constants&quot;&gt;std :: basic_regex&lt;/a&gt;内部复制了该类型的可能值（ &lt;code&gt;icase&lt;/code&gt; ， &lt;code&gt;optimize&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="f158078e6b12f488989a09d27a17236fe92bc958" translate="yes" xml:space="preserve">
          <source>The possible values of FLT_ROUNDS match the possible values of &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt;, returned by &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">FLT_ROUNDS的可能值与 &lt;code&gt;&lt;a href=&quot;../numeric_limits/round_style&quot;&gt;std::numeric_limits::round_style&lt;/a&gt;&lt;/code&gt; 返回的 &lt;code&gt;&lt;a href=&quot;../numeric_limits/float_round_style&quot;&gt;std::float_round_style&lt;/a&gt;&lt;/code&gt; 的可能值匹配。</target>
        </trans-unit>
        <trans-unit id="eb1f284e6c90d25d80dca04b6d988a3435fc3bfd" translate="yes" xml:space="preserve">
          <source>The postconditions are as follows:</source>
          <target state="translated">后置条件如下:</target>
        </trans-unit>
        <trans-unit id="61121624309d02b453ed84455806314e9c9e17f9" translate="yes" xml:space="preserve">
          <source>The postfix increment and decrement expressions have the form.</source>
          <target state="translated">后缀递增和递减表达式的形式。</target>
        </trans-unit>
        <trans-unit id="6bb958d510683e21b0e77aaa67075c099774e223" translate="yes" xml:space="preserve">
          <source>The potential scope of a function parameter (including parameters of a lambda expression) or of a function-local predefined variable begins at its point of declaration.</source>
          <target state="translated">一个函数参数(包括lambda表达式的参数)或一个函数局部预定义变量的潜在范围从其声明点开始。</target>
        </trans-unit>
        <trans-unit id="f221d1f923c37987bf0e3c89da004e995c3dde61" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt; begins at the point of declaration and includes the rest of the class body and all function bodies (even if defined outside the class definition or before the declaration of the name), default arguments, exception specifications, in-class brace-or-equal initializers, &lt;a href=&quot;attributes/contract&quot;&gt;contract conditions&lt;/a&gt;(since C++20), and all these things in nested classes, recursively.</source>
          <target state="translated">在&lt;a href=&quot;class&quot;&gt;类中&lt;/a&gt;声明的名称的潜在范围始于声明时，包括其余的类主体和所有函数主体（即使在类定义之外或在名称声明之前定义），默认参数，异常说明，类大括号或相等的初始化程序，&lt;a href=&quot;attributes/contract&quot;&gt;协定条件&lt;/a&gt;（自C ++ 20起）以及嵌套类中的所有这些内容都递归地进行。</target>
        </trans-unit>
        <trans-unit id="2d5497083d21c504b3ed59ade0ed30f3ffbb92bc" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in an exception handler begins at the point of declaration and ends when the exception handler ends, and is not in scope in another exception handler or in the enclosing block.</source>
          <target state="translated">异常处理程序中声明的名称的潜在作用域从声明时开始,到异常处理程序结束时结束,不在另一个异常处理程序或包围块的作用域内。</target>
        </trans-unit>
        <trans-unit id="86aa2a90d28cbbde1fb0589dd802c3a11b1e29f7" translate="yes" xml:space="preserve">
          <source>The potential scope of a name declared in the</source>
          <target state="translated">中声明的名称的潜在范围。</target>
        </trans-unit>
        <trans-unit id="a17d45e1f219a3300a9f28b3d08fce8f429503aa" translate="yes" xml:space="preserve">
          <source>The potential scope of a template parameter name begins immediately at the point of declaration and continues to the end of the smallest template declaration in which it was introduced. In particular, a template parameter can be used in the declarations of subsequent template parameters and in the specifications of base classes, but can't be used in the declarations of the preceding template parameters.</source>
          <target state="translated">模板参数名称的潜在范围从声明点立即开始,一直到引入该参数的最小模板声明结束。特别是,一个模板参数可以在后续模板参数的声明和基类的规范中使用,但不能在前面模板参数的声明中使用。</target>
        </trans-unit>
        <trans-unit id="32a82cbca985e3e0dfa23c0dbaf5a6027c95d501" translate="yes" xml:space="preserve">
          <source>The potential scope of a variable introduced by a declaration in a &lt;a href=&quot;statements#Compound_statements&quot;&gt;block (compound statement)&lt;/a&gt; begins at the point of declaration and ends at the end of the block. Actual scope is the same as potential scope unless there is a nested block with a declaration that introduces identical name (in which case, the entire potential scope of the nested declaration is excluded from the scope of the outer declaration).</source>
          <target state="translated">由声明在&lt;a href=&quot;statements#Compound_statements&quot;&gt;块（compound语句）中&lt;/a&gt;引入的变量的潜在范围始于声明点，结束于块的末尾。实际范围与潜在范围相同，除非存在带有引入相同名称的声明的嵌套块（在这种情况下，嵌套声明的整个潜在范围将从外部声明的范围中排除）。</target>
        </trans-unit>
        <trans-unit id="3ba3386f44571d8f14970c593d609182dd9626af" translate="yes" xml:space="preserve">
          <source>The potential scope of any entity declared in a &lt;a href=&quot;namespace&quot;&gt;namespace&lt;/a&gt; begins at the declaration and consists of the concatenation of all namespace definitions for the same namespace name that follow, plus, for any &lt;a href=&quot;namespace&quot;&gt;using-directive&lt;/a&gt; that introduced this name or its entire namespace into another scope, the rest of that scope.</source>
          <target state="translated">在&lt;a href=&quot;namespace&quot;&gt;命名空间中&lt;/a&gt;声明的任何实体的潜在作用域始于声明，并由随后的同一个命名空间名称的所有命名空间定义的串联组成，再加&lt;a href=&quot;namespace&quot;&gt;上将&lt;/a&gt;这个名称或其整个命名空间引入另一个作用域的任何using指令，该范围的其余部分。</target>
        </trans-unit>
        <trans-unit id="4ae5d318818acfe339b9d375cb9ce2cfc0456829" translate="yes" xml:space="preserve">
          <source>The potential scope of the name of the parameter of a template template parameter is the smallest template parameter list in which that name appears.</source>
          <target state="translated">模板模板参数的参数名称的潜在范围是该名称出现的最小模板参数列表。</target>
        </trans-unit>
        <trans-unit id="124da4714b4bf54af7be4c07efe71d32136057e5" translate="yes" xml:space="preserve">
          <source>The precision of the result is at least &lt;code&gt;std::chrono::seconds&lt;/code&gt;, and will be finer if the argument has finer precision.</source>
          <target state="translated">结果的精度至少为 &lt;code&gt;std::chrono::seconds&lt;/code&gt; ，如果参数具有更高的精度，则精度会更高。</target>
        </trans-unit>
        <trans-unit id="a20b15248f8c5353561f8b4cb6be91d86d20e646" translate="yes" xml:space="preserve">
          <source>The predicate of a contract condition has the same semantic restrictions as if it appeared as the first &lt;a href=&quot;../statements#Expression_statements&quot;&gt;expression statement&lt;/a&gt; in the body of the function it applies to.</source>
          <target state="translated">合同条件的谓词具有相同的语义限制，就好像它作为它所应用的函数主体中的第一个&lt;a href=&quot;../statements#Expression_statements&quot;&gt;表达式语句&lt;/a&gt;一样出现。</target>
        </trans-unit>
        <trans-unit id="e2463bc948c065d9d75e509585a1ee11887f0dca" translate="yes" xml:space="preserve">
          <source>The prefix increment and decrement expressions have the form.</source>
          <target state="translated">前缀递增和递减表达式的形式。</target>
        </trans-unit>
        <trans-unit id="05a52076d2dc5c8b894927a5e244dc4ac56fe7ce" translate="yes" xml:space="preserve">
          <source>The preprocessing directives control the behavior of the preprocessor. Each directive occupies one line and has the following format:</source>
          <target state="translated">预处理指令控制了预处理机的行为。每条指令占一行,格式如下:</target>
        </trans-unit>
        <trans-unit id="cb413a6249ff3f9ad8dd052d27dcc328f60aee81" translate="yes" xml:space="preserve">
          <source>The preprocessor has the source file translation capabilities:</source>
          <target state="translated">预处理器具有源文件翻译功能。</target>
        </trans-unit>
        <trans-unit id="6aa350ea11bb9c5aa25e6e5ec9306cca0035172c" translate="yes" xml:space="preserve">
          <source>The preprocessor is executed at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 4&lt;/a&gt;, before the compilation. The result of preprocessing is a single file which is then passed to the actual compiler.</source>
          <target state="translated">在&lt;a href=&quot;language/translation_phases&quot;&gt;编译&lt;/a&gt;之前，预处理器在转换阶段4执行。预处理的结果是一个文件，然后将其传递给实际的编译器。</target>
        </trans-unit>
        <trans-unit id="e2bdd9572501029c63f84fab6d94f93d8f91603f" translate="yes" xml:space="preserve">
          <source>The preprocessor supports conditional compilation of parts of source file. This behavior is controlled by &lt;code&gt;#if&lt;/code&gt;, &lt;code&gt;#else&lt;/code&gt;, &lt;code&gt;#elif&lt;/code&gt;, &lt;code&gt;#ifdef&lt;/code&gt;, &lt;code&gt;#ifndef&lt;/code&gt; and &lt;code&gt;#endif&lt;/code&gt; directives.</source>
          <target state="translated">预处理器支持源文件各部分的条件编译。此行为由 &lt;code&gt;#if&lt;/code&gt; ， &lt;code&gt;#else&lt;/code&gt; ， &lt;code&gt;#elif&lt;/code&gt; ， &lt;code&gt;#ifdef&lt;/code&gt; ， &lt;code&gt;#ifndef&lt;/code&gt; 和 &lt;code&gt;#endif&lt;/code&gt; 指令控制。</target>
        </trans-unit>
        <trans-unit id="d389a7945641ac5522e189cd36aef892dd202d1a" translate="yes" xml:space="preserve">
          <source>The preprocessor supports text macro replacement. Function-like text macro replacement is also supported.</source>
          <target state="translated">前处理程序支持文本宏替换。也支持类似函数的文本宏替换。</target>
        </trans-unit>
        <trans-unit id="0e2ac736e4b9518fd1201761b13af480e31f9a2e" translate="yes" xml:space="preserve">
          <source>The previous locale, as returned by &lt;code&gt;ios_base::imbue(loc)&lt;/code&gt;.</source>
          <target state="translated">上一个语言环境，由 &lt;code&gt;ios_base::imbue(loc)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e848927c4ddc2faed727fdcad88567a9f851617" translate="yes" xml:space="preserve">
          <source>The previous value of the global C++ locale.</source>
          <target state="translated">全局C++语言环境的前一个值。</target>
        </trans-unit>
        <trans-unit id="cf70cdf040bccb32e02858713f2da17f9c793063" translate="yes" xml:space="preserve">
          <source>The previously-installed new handler, or a null pointer value if none was installed.</source>
          <target state="translated">之前安装的新处理程序,如果没有安装,则为空指针值。</target>
        </trans-unit>
        <trans-unit id="a35f0efbfe83164488e9c67a5958dce490abc58e" translate="yes" xml:space="preserve">
          <source>The previously-installed terminate handler, or a null pointer value if none was installed.</source>
          <target state="translated">之前安装的终止处理程序,如果没有安装,则为空指针值。</target>
        </trans-unit>
        <trans-unit id="d1f9375683ee644e852554818b0e7f65b024d681" translate="yes" xml:space="preserve">
          <source>The previously-installed unexpected handler, or a null pointer value if none was installed.</source>
          <target state="translated">之前安装的意外处理程序,如果没有安装,则为空指针值。</target>
        </trans-unit>
        <trans-unit id="9af84654120543bdc403c77640e19172f575072a" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; satisfying both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;. The program is ill-formed if any of following values is &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">主 &lt;code&gt;std::atomic&lt;/code&gt; 模板可以与任何被实例化&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;类型 &lt;code&gt;T&lt;/code&gt; 同时满足&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;和&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;。如果以下任何值为 &lt;code&gt;false&lt;/code&gt; ,则程序格式错误：</target>
        </trans-unit>
        <trans-unit id="175466bae183473a68237507d57dfae6c15d71d1" translate="yes" xml:space="preserve">
          <source>The primary &lt;code&gt;std::atomic_ref&lt;/code&gt; template may be instantiated with any &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type &lt;code&gt;T&lt;/code&gt; (including &lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">主 &lt;code&gt;std::atomic_ref&lt;/code&gt; 模板可以与任何被实例化&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;类型 &lt;code&gt;T&lt;/code&gt; （包括 &lt;code&gt;bool&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="7b6fd84220d2a0c86df329eafb7ba3556e2d99b3" translate="yes" xml:space="preserve">
          <source>The primary purpose of function-try-blocks is to respond to an exception thrown from the member initializer list in a constructor by logging and rethrowing, modifying the exception object and rethrowing, throwing a different exception instead, or terminating the program. They are rarely used with destructors or with regular functions.</source>
          <target state="translated">函数尝试块的主要目的是响应构造函数中成员初始化器列表抛出的异常,方法是记录并重抛,修改异常对象并重抛,抛出不同的异常,或者终止程序。它们很少与析构函数或常规函数一起使用。</target>
        </trans-unit>
        <trans-unit id="3f7bdf2c45988d2e398ec47fc464d9bf36ad8ecc" translate="yes" xml:space="preserve">
          <source>The primary sort key for the character sequence &lt;code&gt;[first, last)&lt;/code&gt; in the currently imbued locale, ignoring case, variant, diacritics, etc.</source>
          <target state="translated">当前使用的语言环境中字符序列的 &lt;code&gt;[first, last)&lt;/code&gt; 排序键（第一个，最后一个），忽略大小写，变体，变音符号等。</target>
        </trans-unit>
        <trans-unit id="f9b3c50b7c4e0adf0fa987d32fbfaf6e0639923e" translate="yes" xml:space="preserve">
          <source>The primary template (1) is not defined; four specializations are provided to handle four different levels of precision.</source>
          <target state="translated">主模板(1)没有定义;提供了四种特殊化,以处理四种不同级别的精度。</target>
        </trans-unit>
        <trans-unit id="4f13817f1998ddc17a9521a91f34ffa2754e64b4" translate="yes" xml:space="preserve">
          <source>The primary template is an empty struct. The standard defines the following specializations:</source>
          <target state="translated">主模板是一个空结构。标准定义了以下的特殊化。</target>
        </trans-unit>
        <trans-unit id="32aa772a60f7448e2e58e9b419a72a7e62908590" translate="yes" xml:space="preserve">
          <source>The primary template is empty. A specialization is provided for &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt;, the default time zone pointer type.</source>
          <target state="translated">主模板为空。为 &lt;code&gt;const &lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;*&lt;/code&gt; （默认的时区指针类型）提供了特殊化。</target>
        </trans-unit>
        <trans-unit id="5795dc517124b691e8ea332cfeb4ab8696d76a2b" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; 的主要用途是提供可以从 &lt;code&gt;operator[]&lt;/code&gt; 返回的l值。</target>
        </trans-unit>
        <trans-unit id="895b09aec5064e185b6472594b973b52d8ec16a6" translate="yes" xml:space="preserve">
          <source>The primary use of &lt;code&gt;std::bitset::reference&lt;/code&gt; is to provide an l-value that can be returned from &lt;a href=&quot;operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::bitset::reference&lt;/code&gt; 的主要用途是提供可以从&lt;a href=&quot;operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt;返回的l值。</target>
        </trans-unit>
        <trans-unit id="44ca87a7b0da64f5b77109af8b1bf5da6aee13a7" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; member is not affected by this assignment operator.</source>
          <target state="translated">私有 &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 成员不受此分配运算符的影响。</target>
        </trans-unit>
        <trans-unit id="b15b5ef90ed5ddcf44be29f564148c6afcb6afcc" translate="yes" xml:space="preserve">
          <source>The probability of &lt;code&gt;h(a)==h(b)&lt;/code&gt; for &lt;code&gt;a!=b&lt;/code&gt; should approach &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">的概率 &lt;code&gt;h(a)==h(b)&lt;/code&gt; 为 &lt;code&gt;a!=b&lt;/code&gt; 应接近 &lt;code&gt;1.0/&lt;a href=&quot;../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;::max()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95fdc02e0f2a75a69ee3b45caa87c045c455c0be" translate="yes" xml:space="preserve">
          <source>The program is ill-formed</source>
          <target state="translated">程序不规范</target>
        </trans-unit>
        <trans-unit id="f17c9446e3d0891d6f0a550093638571c34482fa" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; is not true.</source>
          <target state="translated">该程序格式错误，如果 &lt;code&gt;(std::is_same_v&amp;lt;T, U&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; 不正确，格式错误。</target>
        </trans-unit>
        <trans-unit id="80681cb4437f6410dadbaf99fd1bc0640c36b450" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;Duration&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;Duration&lt;/code&gt; 不是以下内容的专业化，则该程序格式不正确 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba17539f8936e17a1b0aee08e3a960ba67a68e62" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is negative. If &lt;code&gt;N&lt;/code&gt; is zero, the indicated type is &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;N&lt;/code&gt; 为负，则程序格式错误。如果 &lt;code&gt;N&lt;/code&gt; 为零，则指示的类型为 &lt;code&gt;integer_sequence&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5a8f5795052236111eac68e22aa48d3e329cc1b" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;N&lt;/code&gt; is not a power of 2. The behavior is undefined if &lt;code&gt;ptr&lt;/code&gt; does not point to an object of type &lt;code&gt;T&lt;/code&gt; (ignoring cv-qualification at every level), or if the object's alignment is not at least &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;N&lt;/code&gt; 不是2的幂，则该程序格式错误。如果 &lt;code&gt;ptr&lt;/code&gt; 不指向类型 &lt;code&gt;T&lt;/code&gt; 的对象，则该行为不确定（忽略每个级别的cv限定），或者对象的对齐方式至少为 &lt;code&gt;N&lt;/code&gt; ，则。</target>
        </trans-unit>
        <trans-unit id="67bdd1bd8f7bc35a5850d5aff836099617861a78" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is a function type or (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是函数类型或（可能是cv限定），则程序格式错误 &lt;code&gt;void&lt;/code&gt; ,则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="965acd7bfed42ab433acdc02bbf59b653e8dc291" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if an explicit or partial specialization of &lt;code&gt;std::initializer_list&lt;/code&gt; is declared.</source>
          <target state="translated">如果声明了 &lt;code&gt;std::initializer_list&lt;/code&gt; 的显式或部分专业化，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="a07725707756ca1bff455b3ddbe27d61f7822a9f" translate="yes" xml:space="preserve">
          <source>The program is ill-formed if any of the following is not &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">如果以下任何一项不 &lt;code&gt;true&lt;/code&gt; 则程序格式错误：</target>
        </trans-unit>
        <trans-unit id="f0c2c540025d21052bca08f15510071c65acf1a0" translate="yes" xml:space="preserve">
          <source>The program is well-formed (compiles) only if there exists one unambiguous</source>
          <target state="translated">只有当存在一个明确无误的</target>
        </trans-unit>
        <trans-unit id="86e09b8d70231ec8b200a5fc3393b854ca51d06f" translate="yes" xml:space="preserve">
          <source>The programmer must ensure that no threads attempt to wait on &lt;code&gt;*this&lt;/code&gt; once the destructor has been started, especially when the waiting threads are calling the wait functions in a loop or are using the overloads of the wait functions that take a predicate.</source>
          <target state="translated">一旦析构函数启动，程序员必须确保没有线程试图等待 &lt;code&gt;*this&lt;/code&gt; ，特别是当等待线程正在循环中调用wait函数或使用带有谓词的wait函数的重载时。</target>
        </trans-unit>
        <trans-unit id="74ef69212c8f3a8d15110cc0d0e198f7faccc793" translate="yes" xml:space="preserve">
          <source>The programming language &lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt; was first to introduce value categories for expressions: all CPL expressions can be evaluated in &quot;right-hand mode&quot;, but only certain kinds of expression are meaningful in &quot;left-hand mode&quot;. When evaluated in right-hand mode, an expression is regarded as being a rule for the computation of a value (the right-hand value, or</source>
          <target state="translated">编程语言&lt;a href=&quot;https://en.wikipedia.org/wiki/CPL_(programming_language)&quot;&gt;CPL&lt;/a&gt;最初引入了表达式的值类别：所有CPL表达式都可以在&amp;ldquo;右手模式&amp;rdquo;下求值，但只有某些类型的表达式在&amp;ldquo;左手模式&amp;rdquo;下才有意义。在右手模式下进行评估时，表达式被视为计算值（右手值或</target>
        </trans-unit>
        <trans-unit id="67ad89355eacc86b3d6314eddebeebee7f14036d" translate="yes" xml:space="preserve">
          <source>The promise is the &quot;push&quot; end of the promise-future communication channel: the operation that stores a value in the shared state</source>
          <target state="translated">承诺是承诺-未来通信通道的 &quot;推 &quot;端:在共享状态中存储一个值的操作。</target>
        </trans-unit>
        <trans-unit id="3f2caa469d3c691e3afe5b09718f95bd2b49a72b" translate="yes" xml:space="preserve">
          <source>The public functions of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; call this function only if &lt;code&gt;gptr() == nullptr&lt;/code&gt; or &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;gptr() == nullptr&lt;/code&gt; 或 &lt;code&gt;gptr() &amp;gt;= egptr()&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 的公共函数才调用此函数。</target>
        </trans-unit>
        <trans-unit id="775a778b55294eaa175c0471abd743cb50326787" translate="yes" xml:space="preserve">
          <source>The purpose of strict aliasing and related rules is to enable type-based alias analysis, which would be decimated if a program can validly create a situation where two pointers to unrelated types (e.g., an &lt;code&gt;int*&lt;/code&gt; and a &lt;code&gt;float*&lt;/code&gt;) could simultaneously exist and both can be used to load or store the same memory (see &lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;this email on SG12 reflector&lt;/a&gt;). Thus, any technique that is seemingly capable of creating such a situation necessarily invokes undefined behavior.</source>
          <target state="translated">严格的别名和相关规则的目的是启用基于类型的别名分析，如果程序可以有效地创建两个不相关类型的指针（例如， &lt;code&gt;int*&lt;/code&gt; 和 &lt;code&gt;float*&lt;/code&gt; ）可以同时存在并且两者均可用于加载或存储相同的内存（请参阅&lt;a href=&quot;http://www.open-std.org/pipermail/ub/2016-February/000565.html&quot;&gt;SG12反射器上的此电子邮件&lt;/a&gt;）。因此，任何看似能够造成这种情况的技术都必然会引起未定义的行为。</target>
        </trans-unit>
        <trans-unit id="537f9c0125fb3b536c8c2bddb97b517098935b00" translate="yes" xml:space="preserve">
          <source>The purpose of this adaptor is to correctly initialize stateful allocators in nested containers, such as when all levels of a nested container must be placed in the same shared memory segment. The adaptor's constructor takes the arguments for all allocators in the list, and each nested container obtains its allocator's state from the adaptor as needed.</source>
          <target state="translated">这个适配器的目的是正确地初始化嵌套容器中的有状态分配器,例如当一个嵌套容器的所有级别必须放在同一个共享内存段中时。适配器的构造函数接收列表中所有分配器的参数,每个嵌套容器根据需要从适配器中获取其分配器的状态。</target>
        </trans-unit>
        <trans-unit id="7c2a811b6c5574010f60bbd62805b17f3c0731ed" translate="yes" xml:space="preserve">
          <source>The purpose of this exception type is similar to the error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; (thrown in &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; from member functions of &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;) and the related errno constant &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此异常类型的用途类似于错误条件 &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; （来自 &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 成员函数的std :: &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 引发）和相关的errno常量 &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;EINVAL&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e645b45a5ffa08db62d4e0d26bad721f50ada62" translate="yes" xml:space="preserve">
          <source>The purpose of this rule is to help guard against violations of the &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODR&lt;/a&gt; for template instantiations:</source>
          <target state="translated">该规则的目的是帮助防止违反&lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;ODR&lt;/a&gt;模板实例：</target>
        </trans-unit>
        <trans-unit id="e80a3e01ac05bea47ec62aef3af475352cd5d29f" translate="yes" xml:space="preserve">
          <source>The question mark escape sequence &lt;code&gt;\?&lt;/code&gt; is used to prevent &lt;a href=&quot;operator_alternative&quot;&gt;trigraphs&lt;/a&gt; from being interpreted inside string literals: a string such as &lt;code&gt;&quot;??/&quot;&lt;/code&gt; is compiled as &lt;code&gt;&quot;\&quot;&lt;/code&gt;, but if the second question mark is escaped, as in &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt;, it becomes &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</source>
          <target state="translated">问号转义序列 &lt;code&gt;\?&lt;/code&gt; 用于防止&lt;a href=&quot;operator_alternative&quot;&gt;Trigraph&lt;/a&gt;在字符串文字中解释：诸如 &lt;code&gt;&quot;??/&quot;&lt;/code&gt; 类的字符串被编译为 &lt;code&gt;&quot;\&quot;&lt;/code&gt; ，但是如果第二个问号被转义，例如 &lt;code&gt;&quot;?\?/&quot;&lt;/code&gt; ，则变为 &lt;code&gt;&quot;??/&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20eb771689c7638596c471df8669135309db406f" translate="yes" xml:space="preserve">
          <source>The quiet NaN value that corresponds to the identifying string &lt;code&gt;arg&lt;/code&gt; or zero if the implementation does not support quiet NaNs.</source>
          <target state="translated">如果实现不支持静默NaN ，则静默NaN值对应于标识字符串 &lt;code&gt;arg&lt;/code&gt; 或零。</target>
        </trans-unit>
        <trans-unit id="eeac3ad06c66b3de50e5a83b3d29765e5993887a" translate="yes" xml:space="preserve">
          <source>The quotient is rounded in implementation-defined direction.</source>
          <target state="translated">商数按执行定义的方向取整。</target>
        </trans-unit>
        <trans-unit id="ee33d1b33c8c2f838818ad7eab65d1c620ffa44b" translate="yes" xml:space="preserve">
          <source>The quotient is the algebraic quotient with any fractional part discarded (truncated towards zero). The remainder is such that &lt;code&gt;quot * y + rem == x&lt;/code&gt;.</source>
          <target state="translated">商是舍弃任何小数部分（截断为零）的代数商。余数是 &lt;code&gt;quot * y + rem == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="501288be26edd4ded7871c5498abfbb8d63a43ff" translate="yes" xml:space="preserve">
          <source>The quotient is the result of the expression &lt;code&gt;x/y&lt;/code&gt;. The remainder is the result of the expression &lt;code&gt;x%y&lt;/code&gt;.</source>
          <target state="translated">商是表达式 &lt;code&gt;x/y&lt;/code&gt; 的结果。余数是表达式 &lt;code&gt;x%y&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="0fcb33188a4836ac6fb56038cd09dd6ed5942b11" translate="yes" xml:space="preserve">
          <source>The quotient is truncated towards zero (fractional part is discarded).</source>
          <target state="translated">商数被截断为零(小数部分被舍弃)。</target>
        </trans-unit>
        <trans-unit id="9dadf256e2d94d3cccaced5125b0d93a91578c9e" translate="yes" xml:space="preserve">
          <source>The random number library provides classes that generate random and pseudo-random numbers. These classes include:</source>
          <target state="translated">随机数库提供了生成随机数和伪随机数的类。这些类包括:</target>
        </trans-unit>
        <trans-unit id="b2af36c522baaa6141e4d68a47e9b38cf32d1814" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">范围 &lt;code&gt;[first, last)&lt;/code&gt; 必须相对于 &lt;code&gt;value&lt;/code&gt; 至少部分排序，即它必须满足以下所有要求：</target>
        </trans-unit>
        <trans-unit id="cc9d0a4e1c6b28a575aa6a4d6fa56412715ff389" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; or &lt;code&gt;!comp(value, element)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">范围 &lt;code&gt;[first, last)&lt;/code&gt; 必须根据表达式 &lt;code&gt;!(value &amp;lt; element)&lt;/code&gt; 或 &lt;code&gt;!comp(value, element)&lt;/code&gt; 进行分区，即，表达式为 &lt;code&gt;true&lt;/code&gt; 的所有元素必须在表达式为 &lt;code&gt;false&lt;/code&gt; 的所有元素之前。完全分类的范围满足此条件。</target>
        </trans-unit>
        <trans-unit id="531a6257f348bdfa0bffcab8f3aeb4dc7a540c17" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first, last)&lt;/code&gt; must be partitioned with respect to the expression &lt;code&gt;element &amp;lt; value&lt;/code&gt; or &lt;code&gt;comp(element, value)&lt;/code&gt;, i.e., all elements for which the expression is &lt;code&gt;true&lt;/code&gt; must precede all elements for which the expression is &lt;code&gt;false&lt;/code&gt;. A fully-sorted range meets this criterion.</source>
          <target state="translated">范围 &lt;code&gt;[first, last)&lt;/code&gt; 必须相对于表达式 &lt;code&gt;element &amp;lt; value&lt;/code&gt; 或 &lt;code&gt;comp(element, value)&lt;/code&gt; 进行分区，即，表达式为 &lt;code&gt;true&lt;/code&gt; 的所有元素必须在表达式为 &lt;code&gt;false&lt;/code&gt; 的所有元素之前。完全分类的范围满足此条件。</target>
        </trans-unit>
        <trans-unit id="17dad5b9e23c675ce64ce4c16ba529098428b325" translate="yes" xml:space="preserve">
          <source>The ranges library provides components for dealing with ranges of elements, including a variety of view adapters.</source>
          <target state="translated">ranges库提供了处理元素范围的组件,包括各种视图适配器。</target>
        </trans-unit>
        <trans-unit id="bce2ca348110e7ef080f1a3a0d8246186d739693" translate="yes" xml:space="preserve">
          <source>The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to &lt;a href=&quot;implicit_cast&quot;&gt;three conversions&lt;/a&gt;).</source>
          <target state="translated">标准转换序列的等级是它所持有的标准转换等级中最差的（最多可能有&lt;a href=&quot;implicit_cast&quot;&gt;3次转换&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="ebf3fa4c200bf79dc188b73503ec27a644a93938" translate="yes" xml:space="preserve">
          <source>The raw pointer overloads assume ownership of the pointed-to object. Therefore, constructing a &lt;code&gt;shared_ptr&lt;/code&gt; using the raw pointer overload for an object that is already managed by a &lt;code&gt;shared_ptr&lt;/code&gt;, such as by &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; is likely to lead to undefined behavior, even if the object is of a type derived from &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">原始指针重载假定所指向对象的所有权。因此，对于已由 &lt;code&gt;shared_ptr&lt;/code&gt; 管理的对象 &lt;code&gt;shared_ptr(ptr.get())&lt;/code&gt; 例如，由shared_ptr（ptr.get（）））使用原始指针重载来构造 &lt;code&gt;shared_ptr&lt;/code&gt; 可能会导致未定义的行为，即使该对象的类型是从 &lt;code&gt;&lt;a href=&quot;../enable_shared_from_this&quot;&gt;std::enable_shared_from_this&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad324bd2c8bc22b00758a73ea2fd6b6e48382778" translate="yes" xml:space="preserve">
          <source>The reallocation is done by either:</source>
          <target state="translated">重新分配的方式有两种。</target>
        </trans-unit>
        <trans-unit id="cb5dae53afd6af85ce084febad2ae76f3864e626" translate="yes" xml:space="preserve">
          <source>The rebind member template alias makes it possible, given a pointer-like type that points to T, to obtain the same pointer-like type that points to U. For example,</source>
          <target state="translated">通过rebind成员模板别名,给定一个指向T的指针类类型,就可以得到指向U的相同的指针类类型,例如。</target>
        </trans-unit>
        <trans-unit id="3a46abffdd1369d6dca8a8856866579f7f37a7e3" translate="yes" xml:space="preserve">
          <source>The recognized byte order marks are:</source>
          <target state="translated">认可的字节顺序标志是:</target>
        </trans-unit>
        <trans-unit id="39e0ee2810678b74b9059ddc4c64426403f4f32c" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;iword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;iword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by a previous call to &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;ios_base&lt;/code&gt; 对象上的任何操作（包括对 &lt;code&gt;iword()&lt;/code&gt; 的另一次调用）都可以使该引用无效，但是保留所存储的值，以便以后从具有相同索引的 &lt;code&gt;iword(index)&lt;/code&gt; 读取将产生相同的值（直到下一个调用 &lt;code&gt;&lt;a href=&quot;../basic_ios/copyfmt&quot;&gt;std::basic_ios::copyfmt()&lt;/a&gt;&lt;/code&gt; ）。该值可用于任何目的。元素的索引必须通过先前对 &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; 的调用来获取，否则行为是不确定的。新元素被初始化为 &lt;code&gt;​0​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6ac5c33641fd17dd4dcc39d735304c205b8e343f" translate="yes" xml:space="preserve">
          <source>The reference may be invalidated by any operation on this &lt;code&gt;ios_base&lt;/code&gt; object, including another call to &lt;code&gt;pword()&lt;/code&gt;, but the stored values are retained, so that reading from &lt;code&gt;pword(index)&lt;/code&gt; with the same index later will produce the same value (until the next call to &lt;code&gt;copyfmt()&lt;/code&gt;). The value can be used for any purpose. The index of the element must be obtained by &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt;, otherwise the behavior is undefined. New elements are initialized to &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该 &lt;code&gt;ios_base&lt;/code&gt; 对象上的任何操作（包括对 &lt;code&gt;pword()&lt;/code&gt; 的另一次调用）都可以使该引用无效，但是保留所存储的值，以便 &lt;code&gt;pword(index)&lt;/code&gt; 从具有相同索引的pword（index）读取将产生相同的值（直到下一个调用 &lt;code&gt;copyfmt()&lt;/code&gt; ）。该值可用于任何目的。元素的索引必须通过 &lt;code&gt;&lt;a href=&quot;xalloc&quot;&gt;xalloc()&lt;/a&gt;&lt;/code&gt; 获得，否则行为是不确定的。新元素被初始化为 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f727f18de8aecc68a97ca4d05e8709c96ae21252" translate="yes" xml:space="preserve">
          <source>The referenced bit.</source>
          <target state="translated">引用的位。</target>
        </trans-unit>
        <trans-unit id="01bad1a5bcb168d5223121e0f4bf36c7d217674b" translate="yes" xml:space="preserve">
          <source>The regex iterators are used to traverse the entire set of regular expression matches found within a sequence.</source>
          <target state="translated">regex迭代器用于遍历在一个序列中找到的整个正则表达式匹配集。</target>
        </trans-unit>
        <trans-unit id="743f5a5a38b3f31dca5dec3dbda309eac3fee182" translate="yes" xml:space="preserve">
          <source>The regex library uses this trait to match characters against equivalence classes. For example, the regex &lt;code&gt;[[=a=]]&lt;/code&gt; is equivalent to the character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; is equivalent to &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; (which is true for any &lt;code&gt;c1&lt;/code&gt; from &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; in the U.S. English locale). Note that &lt;code&gt;transform_primary()&lt;/code&gt; takes a character sequence argument because equivalence classes may be multicharacter, such as &lt;code&gt;[[=ch=]]&lt;/code&gt; in Czech or &lt;code&gt;[[=dzs=]]&lt;/code&gt; in Hungarian.</source>
          <target state="translated">正则表达式库使用此特征将字符与等效类进行匹配。例如，正则表达式 &lt;code&gt;[[=a=]]&lt;/code&gt; 等同于字符 &lt;code&gt;c1&lt;/code&gt; 如果 &lt;code&gt;traits.transform_primary(c1)&lt;/code&gt; 是相当于 &lt;code&gt;traits.transform_primary(&quot;a&quot;)&lt;/code&gt; （其为任何真 &lt;code&gt;c1&lt;/code&gt; 从 &lt;code&gt;&quot;A&amp;Agrave;&amp;Aacute;&amp;Acirc;&amp;Atilde;&amp;Auml;&amp;Aring;a&amp;agrave;&amp;aacute;&amp;acirc;&amp;atilde;&amp;auml;&amp;aring;&quot;&lt;/code&gt; 在美国英文语言环境）。请注意， &lt;code&gt;transform_primary()&lt;/code&gt; 采用字符序列参数，因为等效类可能是多字符，例如捷克语中的 &lt;code&gt;[[=ch=]]&lt;/code&gt; 或匈牙利语中的 &lt;code&gt;[[=dzs=]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f22234d3d01dbb3d192f98f1564dcc90f3845ce" translate="yes" xml:space="preserve">
          <source>The regex traits class is used to encapsulate the localizable aspects of a regex.</source>
          <target state="translated">regex特征类用于封装一个regex的可本地化方面。</target>
        </trans-unit>
        <trans-unit id="8e02428e99c6a674a0fa0458c46a3675989e16b2" translate="yes" xml:space="preserve">
          <source>The registered functions will not be called on &lt;a href=&quot;exit&quot;&gt;normal program termination&lt;/a&gt;. If a function need to be called in that case, &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; must be used.</source>
          <target state="translated">在&lt;a href=&quot;exit&quot;&gt;正常程序终止时，&lt;/a&gt;不会调用已注册的功能。如果在这种情况下需要调用函数，则必须使用 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f472a11dda174644bf194c3cc7207153d73cf754" translate="yes" xml:space="preserve">
          <source>The regular expressions library provides a class that represents &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expressions&lt;/a&gt;, which are a kind of mini-language used to perform pattern matching within strings. Almost all operations with regexes can be characterized by operating on several of the following objects:</source>
          <target state="translated">正则表达式库提供了一个表示&lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;正则表达式&lt;/a&gt;的类，正则表达式是一种用于在字符串内执行模式匹配的小语言。对正则表达式的几乎所有操作都可以通过对以下几个对象进行操作来表征：</target>
        </trans-unit>
        <trans-unit id="2e11489a7a30fc1b23c96dca40b2ff8e966f4c67" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="translated">相关的POSIX函数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt;使 &lt;code&gt;command&lt;/code&gt; 生成的输出对调用者可用。</target>
        </trans-unit>
        <trans-unit id="882b56e07684c56a82fb47ac99ca4f95e58df12c" translate="yes" xml:space="preserve">
          <source>The related POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/popen.html&quot;&gt;popen&lt;/a&gt; makes the output generated by &lt;code&gt;command&lt;/code&gt; available to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315f5ac4df7e6df130a13d2b962900690dfeac97" translate="yes" xml:space="preserve">
          <source>The related function &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; appends a newline character to the output, while &lt;code&gt;std::fputs&lt;/code&gt; writes the string unmodified.</source>
          <target state="translated">相关功能 &lt;code&gt;&lt;a href=&quot;puts&quot;&gt;std::puts&lt;/a&gt;&lt;/code&gt; 将换行符追加到输出，而 &lt;code&gt;std::fputs&lt;/code&gt; 将未修改的字符串写入。</target>
        </trans-unit>
        <trans-unit id="d291a968b1bde0de4066d9697100b3323d6aed59" translate="yes" xml:space="preserve">
          <source>The removal of the top-level cv-qualifiers does not affect the type of the parameter as it appears within the function:</source>
          <target state="translated">去掉顶层的cv-限定符不会影响参数的类型,因为它出现在函数中。</target>
        </trans-unit>
        <trans-unit id="5f57795c7e42d94ba6cd16bf8ded7489abce05bb" translate="yes" xml:space="preserve">
          <source>The replaceable deallocation functions (1-10) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. These functions are</source>
          <target state="translated">即使不包括 &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; 标头，可替换的释放函数（1-10）也会在每个转换单元中隐式声明。这些功能是</target>
        </trans-unit>
        <trans-unit id="757b1dc67e0f36307d54e167b8d8bfa8908ff42c" translate="yes" xml:space="preserve">
          <source>The representation of the named collating element as a character string.</source>
          <target state="translated">将命名的整理元素表示为一个字符串。</target>
        </trans-unit>
        <trans-unit id="b55071f5f9ba9ea7bf92c82884c22a3d16d81678" translate="yes" xml:space="preserve">
          <source>The representation type of &lt;code&gt;C1::duration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C1::duration&lt;/code&gt; 的表示类型。</target>
        </trans-unit>
        <trans-unit id="1064d717e4d3fd4142b0aa2898a18bce9888f7d4" translate="yes" xml:space="preserve">
          <source>The requested subspan &lt;code&gt;r&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt;. If &lt;code&gt;Count&lt;/code&gt; is &lt;code&gt;std::dynamic_extent&lt;/code&gt;, &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt;; otherwise &lt;code&gt;r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">请求的子跨度 &lt;code&gt;r&lt;/code&gt; ，例如 &lt;code&gt;r.data() == this-&amp;gt;data() + Offset&lt;/code&gt; 。如果 &lt;code&gt;Count&lt;/code&gt; 是 &lt;code&gt;std::dynamic_extent&lt;/code&gt; ， &lt;code&gt;r.size() == this-&amp;gt;size() - Offset&lt;/code&gt; ; 否则 &lt;code&gt;r.size() == Count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe5a8c15412cf1fce3c28473df37a2f3d1062165" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements.</source>
          <target state="translated">对元素施加的要求取决于对容器执行的实际操作。通常，要求元素类型是完整类型并满足&lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;的要求，但是许多成员函数提出了更严格的要求。</target>
        </trans-unit>
        <trans-unit id="f623316ac29c804d31fa0890dce0da472d8e6d58" translate="yes" xml:space="preserve">
          <source>The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of &lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;, but many member functions impose stricter requirements. This container (but not its members) can be instantiated with an incomplete element type if the allocator satisfies the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">对元素施加的要求取决于对容器执行的实际操作。通常，要求元素类型满足&lt;a href=&quot;../named_req/eraseable&quot;&gt;Erasable&lt;/a&gt;的要求，但是许多成员函数提出了更严格的要求。如果分配器满足&lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;分配器完整性要求，&lt;/a&gt;则可以使用一个不完整的元素类型实例化此容器（但不能使用其成员）。</target>
        </trans-unit>
        <trans-unit id="7e9510a237cd6950e335a276b93cd34d804cbc1a" translate="yes" xml:space="preserve">
          <source>The result is</source>
          <target state="translated">结果是</target>
        </trans-unit>
        <trans-unit id="c3b6b8e653050978d1c05509c50d363265c5437e" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;false&lt;/code&gt; if the expression contains at least one of the following potentially evaluated constructs:</source>
          <target state="translated">如果表达式至少包含以下可能评估的构造之一，则结果为 &lt;code&gt;false&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d1a4aaa48d46c71750bcb89a022288521d191ab7" translate="yes" xml:space="preserve">
          <source>The result is &lt;code&gt;true&lt;/code&gt; if the set of &lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;potential exceptions&lt;/i&gt;&lt;/a&gt; of the expression is empty, and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">如果表达式的&lt;a href=&quot;except_spec&quot;&gt;&lt;i&gt;潜在异常&lt;/i&gt;&lt;/a&gt;集为空，则结果为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="be94375a32ef05e8f88fd30d56ae6e5233b9d27e" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">结果是 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 专业化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; ，使得给定 &lt;code&gt;Num == R1::num * R2::den + R2::num * R1::den&lt;/code&gt; 和 &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; （无算术溢出计算）， &lt;code&gt;U&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; ， &lt;code&gt;V&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2524aa66759b404de95e3dd437f92ac60fcc7942" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">结果是 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 专业化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; ，使得给定 &lt;code&gt;Num == R1::num * R2::den - R2::num * R1::den&lt;/code&gt; 和 &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; （无算术溢出计算）， &lt;code&gt;U&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; ， &lt;code&gt;V&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acb3b2cb8d2a5ff6feda727827cb87392d9546ad" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">结果是 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 专业化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; ，这样使得给定的 &lt;code&gt;Num == R1::num * R2::den&lt;/code&gt; 和 &lt;code&gt;Denom == R1::den * R2::num&lt;/code&gt; （不计算算术溢出）， &lt;code&gt;U&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 而 &lt;code&gt;V&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f389c36e6b41ab6b3fdb4d5ce8f967c0c0ccebe" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; specialization &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt;, such that given &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; and &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; (computed without arithmetic overflow), &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt;.</source>
          <target state="translated">其结果是一个 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 专业化 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;U, V&amp;gt;&lt;/code&gt; ，使得给定 &lt;code&gt;Num == R1::num * R2::num&lt;/code&gt; 和 &lt;code&gt;Denom == R1::den * R2::den&lt;/code&gt; （计算无算术溢出）， &lt;code&gt;U&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::num&lt;/code&gt; 而 &lt;code&gt;V&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;ratio&quot;&gt;std::ratio&lt;/a&gt;&amp;lt;Num, Denom&amp;gt;::den&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e68dbec571d137df08d9f883c38ccb0b5e7b5985" translate="yes" xml:space="preserve">
          <source>The result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="translated">结果是 &lt;code&gt;bool&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="e2c4bb4518db49d6f285ab22da7870886f0081c4" translate="yes" xml:space="preserve">
          <source>The result is ready</source>
          <target state="translated">结果已经准备好了</target>
        </trans-unit>
        <trans-unit id="580dbf951c94723d3af7b9d08b23514681e24e3d" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the enum's underlying type to the destination type.</source>
          <target state="translated">结果与从枚举的基础类型到目标类型的&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt;相同。</target>
        </trans-unit>
        <trans-unit id="cbbaf37dfe4267e58c22583ee6fab6ad33d0d8fd" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration, and then to the enumeration type.</source>
          <target state="translated">结果与&lt;a href=&quot;implicit_cast#Floating.E2.80.93integral_conversions&quot;&gt;将&lt;/a&gt;原始值首先转换为枚举的基础类型，然后转换为枚举类型相同。</target>
        </trans-unit>
        <trans-unit id="a957f8ea1f391e7935ddb74dad2e1448951ecef7" translate="yes" xml:space="preserve">
          <source>The result may have little or no significance if the magnitude of &lt;code&gt;arg&lt;/code&gt; is large.</source>
          <target state="translated">如果 &lt;code&gt;arg&lt;/code&gt; 的大小很大，则结果可能没有意义或没有意义。</target>
        </trans-unit>
        <trans-unit id="870fcd3df093829aaa26fd2db3dbce5ac0e9700e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;!arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;!arg&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="e6e1af8324720028e132b94fe61c4514f56e4941" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;-arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-arg&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="3a411985e21ab920e38a5852e204b8af0e20a27e" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">的结果 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) == &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80ec200a207a639219d15d9ccfe372f86eab6036" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">的结果 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) | &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e64ce1e5aed1c40811afecb3dc7fbb9b0c9b98a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt;.</source>
          <target state="translated">的结果 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(lhs) || &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee0825f237fb1718d9a9117588e0d38939c42fd3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; is implementation-defined.</source>
          <target state="translated">的结果 &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;(0, 0)&lt;/code&gt; 是实现定义。</target>
        </trans-unit>
        <trans-unit id="acf2c3f21b47e9f1630796369e072a4335640eda" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs != rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs != rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="4e6e472de88efa439e4f8ac01ef503fb42158a44" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs % rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs % rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="d4c5e47c305ac62f9aa59e69771dddcae5c999a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;amp; rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="e95d02148bc8a4f7ae12814dcba7c7fe81fbedaf" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;amp;&amp;amp; rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="fa6dd6207a762f8224d24ca1b87c1fcc621652fa" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;gt; rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="9f4b083947ef6aa836be0e4780f07e0aadcf1e43" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;gt;= rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="e8f2b531e796e45b234ba714ef92019621ac8f1b" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;lt; rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="d3e99c51790273d3fd02297fcb57fd200d05fec1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs &amp;lt;= rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="e05f6b812268f1065a685db8b9a51d0ed85af871" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs * rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs * rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="fa8335ddae097460592407def0f6f7f6531b4bde" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs + rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs + rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="632ae131fa96ce384c426b305a35eb2730ac7e17" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs - rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs - rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="914a5eae959d8077c3946fcd30325aab12d6c2f1" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs / rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs / rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="1542bda1bc0df08cd4e2da32ce9c1c4158ea1b29" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs ^ rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs ^ rhs&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="f829b25d22cfb56ef72ca8c031ffcc768468e0a2" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs | rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs | rhs&lt;/code&gt; 的结果| rhs。</target>
        </trans-unit>
        <trans-unit id="c15c8b1e6d71bff19e0100cd1bb43d0aaf22d25a" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;lhs || rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs || rhs&lt;/code&gt; 的结果 rhs。</target>
        </trans-unit>
        <trans-unit id="8a2cfe39bb4bca238a75c100d57a8e16e49b74ab" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;operator*&lt;/code&gt; or &lt;code&gt;operator-&amp;gt;&lt;/code&gt; on the end iterator is undefined behavior.</source>
          <target state="translated">结果 &lt;code&gt;operator*&lt;/code&gt; 或 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 在结束迭代是不确定的行为。</target>
        </trans-unit>
        <trans-unit id="006f10ce7b3c5cdf0abdf83cfb46f3ea491450f3" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;sizeof&lt;/code&gt; is always nonzero, even if applied to an empty class type.</source>
          <target state="translated">即使应用于空类类型， &lt;code&gt;sizeof&lt;/code&gt; 的结果也始终为非零。</target>
        </trans-unit>
        <trans-unit id="cff04ad9446c1f408f431157236a6d0631af546f" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;~arg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;~arg&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="e9685a2aebbafc6d384174b50e75064f891cc1ef" translate="yes" xml:space="preserve">
          <source>The result of attempting to determine the size of a directory (as well as any other file that is not a regular file or a symlink) is implementation-defined.</source>
          <target state="translated">试图确定一个目录(以及任何其他不是常规文件或符号链接的文件)的大小的结果是由实施定义的。</target>
        </trans-unit>
        <trans-unit id="247e8d93cf388f43a2c1c6cc6c4100ee34ada80f" translate="yes" xml:space="preserve">
          <source>The result of calling most member functions of the match_results object that is not</source>
          <target state="translated">调用match_results对象的大多数成员函数的结果,如果不属于</target>
        </trans-unit>
        <trans-unit id="21e3ce4be4c110e9cc76bfe73bc7a78e82910174" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to members (after conversions) is defined as follows:</source>
          <target state="translated">将两个指针比较为成员(转换后)的结果定义如下。</target>
        </trans-unit>
        <trans-unit id="32f37ca48793604634e4bf49c6103814193272fa" translate="yes" xml:space="preserve">
          <source>The result of comparing two pointers to objects (after conversions) is defined as follows:</source>
          <target state="translated">比较两个指向对象的指针(转换后)的结果定义如下。</target>
        </trans-unit>
        <trans-unit id="0290b3221f34a8546049c1fe37f0a1d16a5a5bef" translate="yes" xml:space="preserve">
          <source>The result of converting a negative number string into an unsigned integer was specified to produce zero until C++17, although some implementations followed the protocol of &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; which negates in the target type, giving &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&quot;-1&quot;&lt;/code&gt;, and so produce the largest value of the target type instead. As of C++17, strictly following &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; is the correct behavior.</source>
          <target state="translated">将负数字符串转换为无符号整数的结果指定为在C ++ 17之前产生零，尽管某些实现遵循 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 协议，该协议否定了目标类型，为 &lt;code&gt;&quot;-1&quot;&lt;/code&gt; 给出了 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; ，并且因此，请产生目标类型的最大值。从C ++ 17开始，严格遵循 &lt;code&gt;&lt;a href=&quot;../../string/byte/strtoul&quot;&gt;std::strtoull&lt;/a&gt;&lt;/code&gt; 是正确的行为。</target>
        </trans-unit>
        <trans-unit id="dd0729a11dfb5de4b72c38a2205cbf06dfb22a46" translate="yes" xml:space="preserve">
          <source>The result of equality comparison of two pointers (after conversions) is defined as follows:</source>
          <target state="translated">两个指针的平等比较结果(转换后)定义如下。</target>
        </trans-unit>
        <trans-unit id="47a73f53b39aa715441c99e5f455152b99e4705b" translate="yes" xml:space="preserve">
          <source>The result of operator~ is the bitwise NOT (one's complement) value of the argument (after promotion). The result of operator&amp;amp; is the bitwise AND value of the operands (after usual arithmetic conversions). The result of operator| is the bitwise OR value of the operands (after usual arithmetic conversions). The result of operator^ is the bitwise XOR value of the operands (after usual arithmetic conversions).</source>
          <target state="translated">operator〜的结果是参数（提升后）的按位NOT（一个补码）值。 operator＆的结果是操作数的按位与值（在通常的算术转换之后）。运算符的结果|是操作数的按位或值（在通常的算术转换之后）。 operator ^的结果是操作数的按位XOR值（在通常的算术转换之后）。</target>
        </trans-unit>
        <trans-unit id="e0eb608d51cf5832fadd72c5babd7a6e03e98a43" translate="yes" xml:space="preserve">
          <source>The result of path concatenation.</source>
          <target state="translated">路径连接的结果。</target>
        </trans-unit>
        <trans-unit id="4f62a6ed94a5ad3247f5fc515a6a3e14d480ed26" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. That duration unit represents the length of the average Gregorian month, and the resulting duration bears no relationship to the number of days in the particular months represented by the operands. For example, &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; is not the number of seconds in March (&lt;code&gt;2678400s&lt;/code&gt;), but &lt;code&gt;2629746s&lt;/code&gt; (30.436875 days).</source>
          <target state="translated">减去 &lt;code&gt;month&lt;/code&gt; 值的结果是类型为 &lt;code&gt;std::chrono::months&lt;/code&gt; 的持续时间。该持续时间单位表示平均格里高利月的长度，而得出的持续时间与操作数所表示的特定月份中的天数无关。例如， &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt; - &lt;a href=&quot;../month&quot;&gt;std::chrono::March&lt;/a&gt;)&lt;/code&gt; 不是三月的秒数（ &lt;code&gt;2678400s&lt;/code&gt; ），而是 &lt;code&gt;2629746s&lt;/code&gt; （30.436875天）。</target>
        </trans-unit>
        <trans-unit id="17172fd81702e28b82e8d13798f7b61c7c8f7b83" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::years&lt;/code&gt;. This duration unit represents the length of the average Gregorian year, and the resulting duration bears no relationship to the number of days in the particular years represented by the operands. For example, the result of &lt;code&gt;2018y - 2017y&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt;, which represents 365.2425 days, not 365 days.</source>
          <target state="translated">减去两者的结果 &lt;code&gt;year&lt;/code&gt; 值是一个类型的持续时间 &lt;code&gt;std::chrono::years&lt;/code&gt; 。此持续时间单位表示平均格里高利历年的长度，而得出的持续时间与操作数所表示的特定年份中的天数无关。例如， &lt;code&gt;2018y - 2017y&lt;/code&gt; 的结果是 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::years&lt;/a&gt;(1)&lt;/code&gt; chrono :: years（1），它表示365.2425天，而不是365天。</target>
        </trans-unit>
        <trans-unit id="36c4afa551c41832fffe70e348da9af50d440abe" translate="yes" xml:space="preserve">
          <source>The result of subtracting two &lt;code&gt;year_month&lt;/code&gt; values is a duration of type &lt;code&gt;std::chrono::months&lt;/code&gt;. This duration unit represents the length of the average Gregorian month (30.436875 days), and the resulting duration bears no relationship to the actual number of days in the time period at issue. For example, the result of &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt;, even though February 2017 only contains 28 days.</source>
          <target state="translated">减去两个 &lt;code&gt;year_month&lt;/code&gt; 值的结果是类型为 &lt;code&gt;std::chrono::months&lt;/code&gt; 的持续时间。该持续时间单位表示平均格里高利月（30.436875天）的长度，并且得出的持续时间与所讨论的时间段中的实际天数没有关系。例如，即使2017年2月仅包含28天， &lt;code&gt;2017y/3 - 2017y/2&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::months&lt;/a&gt;(1)&lt;/code&gt; chrono :: months（1）。</target>
        </trans-unit>
        <trans-unit id="a3315b545d55c361d494aaf334e4af2659a2548d" translate="yes" xml:space="preserve">
          <source>The result of the comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*obj&lt;/code&gt; was equal to &lt;code&gt;*expected&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">比较的结果：如果 &lt;code&gt;*obj&lt;/code&gt; 等于 &lt;code&gt;*expected&lt;/code&gt; 则为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e25c0d3525dfeb8bfa6ff74fcf703d161b32cfb4" translate="yes" xml:space="preserve">
          <source>The result of the conversion as described above:</source>
          <target state="translated">如上所述的转换结果。</target>
        </trans-unit>
        <trans-unit id="3870571eecc090d22dc21a8b93d45f1df9a1dda1" translate="yes" xml:space="preserve">
          <source>The result of the conversion, determined as described above.</source>
          <target state="translated">如上所述确定的转换结果。</target>
        </trans-unit>
        <trans-unit id="5cfae012b116826024fbc12ba5aac5a29cc79ff0" translate="yes" xml:space="preserve">
          <source>The result of the expression always has type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">表达式的结果始终为 &lt;code&gt;void&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d11a68b7fc68b552ec64c618e13fe680bd75b63e" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, or &lt;code&gt;long double&lt;/code&gt;.</source>
          <target state="translated">生成器生成的结果类型。如果它不是 &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 或 &lt;code&gt;long double&lt;/code&gt; 之一，则效果不确定。</target>
        </trans-unit>
        <trans-unit id="9e80eecc0596c35730188bd9f4d1c551f3febc94" translate="yes" xml:space="preserve">
          <source>The result type generated by the generator. The effect is undefined if this is not one of &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;.</source>
          <target state="translated">生成器生成的结果类型。如果它不是 &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;long long&lt;/code&gt; ， &lt;code&gt;unsigned short&lt;/code&gt; ， &lt;code&gt;unsigned int&lt;/code&gt; ， &lt;code&gt;unsigned long&lt;/code&gt; 或 &lt;code&gt;unsigned long long&lt;/code&gt; 之一，则效果不确定。</target>
        </trans-unit>
        <trans-unit id="5521797ee22c876e97965af0d7522808846e3d59" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;T&lt;/code&gt; (1-3) or &lt;code&gt;bool&lt;/code&gt; (4).</source>
          <target state="translated">结果值可以明确转换为 &lt;code&gt;T&lt;/code&gt; （1-3）或 &lt;code&gt;bool&lt;/code&gt; （4）。</target>
        </trans-unit>
        <trans-unit id="f6bb786c46da806f276663a0a370a0140bec8af4" translate="yes" xml:space="preserve">
          <source>The result value can be unambiguously converted to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">结果值可以明确转换为 &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43655266ec179e649b00784deeb0b1a3c97d236d" translate="yes" xml:space="preserve">
          <source>The resultant offset converted to &lt;code&gt;pos_type&lt;/code&gt; on success or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">结果偏移量在成功时转换为 &lt;code&gt;pos_type&lt;/code&gt; ，在失败时转换为pos_type &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef23966d370102deb412213da03cdcdb6c680d1f" translate="yes" xml:space="preserve">
          <source>The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">产生的范围不能与任何一个输入范围重叠。</target>
        </trans-unit>
        <trans-unit id="29d5035de2621e71a90038d6802a888a677db3c5" translate="yes" xml:space="preserve">
          <source>The resulting range is also sorted. Equivalent elements are treated individually, that is, if some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; times. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">结果范围也被排序。等效的元件被单独地处理，也就是，如果某些元件是发现 &lt;code&gt;m&lt;/code&gt; 在倍 &lt;code&gt;[first1, last1)&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 倍 &lt;code&gt;[first2, last2)&lt;/code&gt; ，它会被复制到 &lt;code&gt;d_first&lt;/code&gt; 准确 &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(m-n, 0)&lt;/code&gt; 次。结果范围不能与任何一个输入范围重叠。</target>
        </trans-unit>
        <trans-unit id="aaddb0a6756a877f4864ff06a8fc5e72ffd2f6e1" translate="yes" xml:space="preserve">
          <source>The resulting string contains &lt;code&gt;N&lt;/code&gt; characters with the first character corresponds to the last (&lt;code&gt;N-1&lt;/code&gt;th) bit and the last character corresponding to the first bit.</source>
          <target state="translated">结果字符串包含 &lt;code&gt;N&lt;/code&gt; 个字符，第一个字符对应于最后（第 &lt;code&gt;N-1&lt;/code&gt; ）位，而最后一个字符对应于第一位。</target>
        </trans-unit>
        <trans-unit id="b17d4cd7b0868b24196c899cf5191cb1faa7ed25" translate="yes" xml:space="preserve">
          <source>The resulting valarray with circularly shifted elements.</source>
          <target state="translated">结果是带有圆周移动元素的valarray。</target>
        </trans-unit>
        <trans-unit id="7458cef4d81e04aca531157faaf437f90b8b5f76" translate="yes" xml:space="preserve">
          <source>The resulting valarray with shifted elements.</source>
          <target state="translated">结果是带有移位元素的valarray。</target>
        </trans-unit>
        <trans-unit id="83ad9cb498edc1aa4891b4efbe63cabce32603fe" translate="yes" xml:space="preserve">
          <source>The resulting valarray with values acquired by applying function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">得到的valarray具有通过应用 &lt;code&gt;func&lt;/code&gt; 函数获取的值。</target>
        </trans-unit>
        <trans-unit id="4e5c65b16e68930d61a611b38a71296f2506a4cf" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;).</source>
          <target state="translated">结果值（即，&lt;a href=&quot;../memory_order#Modification_order&quot;&gt;按照&lt;/a&gt; &lt;code&gt;*this&lt;/code&gt; 的修改顺序，将相应的二元运算符应用于紧接在相应成员函数作用之前的值的结果）。</target>
        </trans-unit>
        <trans-unit id="e814d10c5d370f3f42c2fca47efc512b44b14a3c" translate="yes" xml:space="preserve">
          <source>The resulting value (that is, the result of applying the corresponding binary operator to the value immediately preceding the effects of the corresponding member function).</source>
          <target state="translated">结果值(即对紧接在相应成员函数效果之前的值应用相应的二进制运算符的结果)。</target>
        </trans-unit>
        <trans-unit id="3389100e45b720cf6eb81e6827f7706cb90c9259" translate="yes" xml:space="preserve">
          <source>The return from the</source>
          <target state="translated">归来</target>
        </trans-unit>
        <trans-unit id="53209406292002d9313d7e4939097156f31cc15e" translate="yes" xml:space="preserve">
          <source>The return statements in a discarded statement do not participate in function return type deduction:</source>
          <target state="translated">丢弃语句中的返回语句不参与函数返回类型的扣减。</target>
        </trans-unit>
        <trans-unit id="3ed22644873dd55c750986fea93019dbd3388a1d" translate="yes" xml:space="preserve">
          <source>The return type does not add more than two levels of template nesting over the most deeply-nested argument type.</source>
          <target state="translated">返回类型不会在最深嵌套的参数类型上增加两层以上的模板嵌套。</target>
        </trans-unit>
        <trans-unit id="7613f3aef88eece4db1f4660060fab1d18285727" translate="yes" xml:space="preserve">
          <source>The return type is &lt;code&gt;void*&lt;/code&gt; (rather than, e.g., &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt;) to support conversion to an arbitrary pointer type &lt;code&gt;U*&lt;/code&gt; by &lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">返回类型为 &lt;code&gt;void*&lt;/code&gt; （而不是 &lt;code&gt;&lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&lt;/code&gt; ），以支持通过 &lt;code&gt;static_cast&amp;lt;U*&amp;gt;&lt;/code&gt; 转换为任意指针类型 &lt;code&gt;U*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d5d71418aa972f29b239eb90d69468e90bb0941" translate="yes" xml:space="preserve">
          <source>The return type is the type of the left operand after integral promotions.</source>
          <target state="translated">返回类型是积分推广后左操作数的类型。</target>
        </trans-unit>
        <trans-unit id="4fa9717f5967413803e02aa6bb2883c955d4365a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;../numeric/valarray/begin2&quot;&gt;&lt;code&gt;begin(valarray)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../numeric/valarray/end2&quot;&gt;&lt;code&gt;end(valarray)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../numeric/valarray/begin2&quot;&gt; &lt;code&gt;begin(valarray)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../numeric/valarray/end2&quot;&gt; &lt;code&gt;end(valarray)&lt;/code&gt; &lt;/a&gt;的返回类型</target>
        </trans-unit>
        <trans-unit id="4b467b24eb3e95658db04cc2efccee281ce62fa6" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a function. Otherwise, not defined</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是一个函数，则返回 &lt;code&gt;T&lt;/code&gt; 的类型。否则，未定义</target>
        </trans-unit>
        <trans-unit id="fc619118262950fb869b5d544147bd07c7f92619" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::begin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter_view::begin&lt;/code&gt; 的返回类型。</target>
        </trans-unit>
        <trans-unit id="8a173a812528e6c04c2d8704d2f8d1773cc20a31" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;filter_view::end&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filter_view::end&lt;/code&gt; 的返回类型。</target>
        </trans-unit>
        <trans-unit id="7f8cc94f3fe57edcbe4e00cf3aaac26990fe1598" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::begin&lt;/code&gt;.</source>
          <target state="translated">返回类型为 &lt;code&gt;iota_view::begin&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7eef554336055de8435461fe71844804d344403e" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;iota_view::end&lt;/code&gt;.</source>
          <target state="translated">返回类型为 &lt;code&gt;iota_view::end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d16c75ab67ddd9e46691a2a894ba5baeac787d8" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and one object per each of &lt;code&gt;args...&lt;/code&gt;, of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt;, similarly constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::bind&lt;/code&gt; 的返回类型保存一个成员类型为 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;F&amp;gt;::type&lt;/code&gt; 对象，该成员对象由 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; 构造，每个 &lt;code&gt;args...&lt;/code&gt; 一个对象，类型为 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Arg_i&amp;gt;::type&lt;/code&gt; ，类似地从 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Arg_i&amp;gt;(arg_i)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fde0844a0606e7893f2ea00fd18105a16696460c" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise. The type defines the following members:</source>
          <target state="translated">的返回类型 &lt;code&gt;std::bind&lt;/code&gt; 是&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;，如果所有其成员对象（上面指定的）的是可复制构造，并且是&lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;否则。该类型定义以下成员：</target>
        </trans-unit>
        <trans-unit id="6c0953e38415f15fb34763f7446d0d031ca5c65a" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::bind_front&lt;/code&gt; behaves as if its copy/move constructors perform a memberwise copy/move. It is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; if all of its member objects (specified above) are CopyConstructible, and is &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;std::bind_front&lt;/code&gt; 的返回类型的行为就像其复制/移动构造函数执行成员复制/移动一样。它是&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;，如果所有其成员对象（上面指定的）的是可复制构造，并且是&lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;否则。</target>
        </trans-unit>
        <trans-unit id="f29ace211ba147bca17300e0f5b8c1b51fd281da" translate="yes" xml:space="preserve">
          <source>The return type of &lt;code&gt;std::not_fn&lt;/code&gt; holds a member object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">返回类型为 &lt;code&gt;std::not_fn&lt;/code&gt; 的成员对象类型为 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="313e4bd0b86dc792bb66113e7c07635c9c275b3f" translate="yes" xml:space="preserve">
          <source>The return type of a conditional operator is also accessible as the binary type trait &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">条件运算符的返回类型也可以作为二进制类型特征 &lt;code&gt;&lt;a href=&quot;../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76f32cdf7dc810987e937f22df27363914ee508e" translate="yes" xml:space="preserve">
          <source>The return type of a function call expression is the return type of the chosen function, decided using static binding (ignoring the &lt;code&gt;virtual&lt;/code&gt; keyword), even if the overriding function that's actually called returns a different type. This allows the overriding functions to return pointers or references to classes that are derived from the return type returned by the base function, i.e. C++ supports &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;covariant return types&lt;/a&gt;. If &lt;code&gt;E&lt;/code&gt; specifies a destructor, the return type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">函数调用表达式的返回类型是所选函数的返回类型，它是使用静态绑定（忽略 &lt;code&gt;virtual&lt;/code&gt; 关键字）确定的，即使实际上调用的重写函数返回的是其他类型。这允许重写函数返回从基本函数返回的返回类型派生的指针或对类的引用，即C ++支持&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariant_return_type&quot;&gt;协变返回类型&lt;/a&gt;。如果 &lt;code&gt;E&lt;/code&gt; 指定一个析构函数，则返回类型为 &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6bd94bee25a2724e9aec02300daa9aa8d7ac730" translate="yes" xml:space="preserve">
          <source>The return type of a function cannot be a function type or an array type (but can be a pointer or reference to those).</source>
          <target state="translated">函数的返回类型不能是函数类型或数组类型(但可以是指向这些类型的指针或引用)。</target>
        </trans-unit>
        <trans-unit id="a43d728e1df955f1a8f98c6da37b2ab9a5744ca1" translate="yes" xml:space="preserve">
          <source>The return value may differ significantly from what &lt;code&gt;std::cout&lt;/code&gt; prints by default, see the example.</source>
          <target state="translated">默认情况下，返回值可能与 &lt;code&gt;std::cout&lt;/code&gt; 打印的内容大不相同，请参见示例。</target>
        </trans-unit>
        <trans-unit id="39db23f7094ebdbb293d88cb43a6cdf8f30e157e" translate="yes" xml:space="preserve">
          <source>The return value of the called function.</source>
          <target state="translated">被调用函数的返回值。</target>
        </trans-unit>
        <trans-unit id="181f5da030f77aa6d4d1c3eb608e9f1004e2dfd0" translate="yes" xml:space="preserve">
          <source>The return value of the function call operation applied to an object of a type satisfying Compare, when &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;, yields &lt;code&gt;true&lt;/code&gt; if the first argument of the call appears before the second in the</source>
          <target state="translated">如果在&lt;a href=&quot;../language/implicit_cast&quot;&gt;上下文&lt;/a&gt;中将调用的第一个参数出现在第二个参数之前，则将函数调用操作的返回值应用于满足Compare类型的对象，如果上下文将其转换为 &lt;code&gt;bool&lt;/code&gt; ，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9d8bf866400df7265b9950e52989553174c0d39" translate="yes" xml:space="preserve">
          <source>The returned array is not required to be null-terminated.</source>
          <target state="translated">返回的数组不需要以空结尾。</target>
        </trans-unit>
        <trans-unit id="ee570e1ba2b43205f25df937e0cf18a3c9775dfe" translate="yes" xml:space="preserve">
          <source>The returned array is null-terminated, that is, &lt;code&gt;data()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; perform the same function.</source>
          <target state="translated">返回的数组以null终止，即 &lt;code&gt;data()&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;c_str&quot;&gt;c_str()&lt;/a&gt;&lt;/code&gt; 执行相同的功能。</target>
        </trans-unit>
        <trans-unit id="15def1750d934cba236118e97433bceee9bb7467" translate="yes" xml:space="preserve">
          <source>The returned object (call wrapper) has the following properties:</source>
          <target state="translated">返回的对象(调用包装器)具有以下属性。</target>
        </trans-unit>
        <trans-unit id="be9a9d8ae5b68cc7ac697a304429ef14785fc160" translate="yes" xml:space="preserve">
          <source>The returned object behaves as if it holds a member object &lt;code&gt;fd&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; constructed from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;, and an &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; object &lt;code&gt;tup&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; (this unwraps any &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;s), except that the returned object's assignment behavior is unspecified and the names are for exposition only.</source>
          <target state="translated">返回的对象表现为好像它拥有一个成员对象 &lt;code&gt;fd&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; 从构造 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; ，和一个 &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 对象 &lt;code&gt;tup&lt;/code&gt; 与构造 &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; （这将取消包装任何 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; ），但未指定返回对象的分配行为，并且名称仅用于说明。</target>
        </trans-unit>
        <trans-unit id="0b9ca1ed6de835f3a54269685f7c58a1fccb4f90" translate="yes" xml:space="preserve">
          <source>The returned pointer may outlive the last &lt;code&gt;shared_ptr&lt;/code&gt; if, for example, &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;s remain and the implementation doesn't destroy the deleter until the entire control block is destroyed.</source>
          <target state="translated">例如，如果保留了 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; ，并且实现直到销毁整个控制块后才销毁删除器，则返回的指针可能会超过最后一个 &lt;code&gt;shared_ptr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db84c45c9a8b4735697eb1edd0bf4e4888aff852" translate="yes" xml:space="preserve">
          <source>The returned range is defined by two iterators, one pointing to the first element that is</source>
          <target state="translated">返回的范围由两个迭代器定义,其中一个迭代器指向的第一个元素是</target>
        </trans-unit>
        <trans-unit id="fe922ac7f6db254043abd336f6ccd992ca241559" translate="yes" xml:space="preserve">
          <source>The returned string is constructed as if by &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt;, which implies that the returned string's allocator will be default-constructed &amp;mdash; the new allocator will</source>
          <target state="translated">返回的字符串的构造方式类似于 &lt;code&gt;basic_string(data()+pos, count)&lt;/code&gt; ，这意味着返回的字符串的分配器将是默认构造的-新的分配器将</target>
        </trans-unit>
        <trans-unit id="be7ba042cf486f9205da2c739695a1dd6890e1f2" translate="yes" xml:space="preserve">
          <source>The returned string must not be modified by the program, but may be overwritten by a subsequent call to the &lt;code&gt;strerror&lt;/code&gt; function. &lt;code&gt;strerror&lt;/code&gt; is not required to be thread-safe. Implementations may be returning different pointers to static read-only string literals or may be returning the same pointer over and over, pointing at a static buffer in which strerror places the string.</source>
          <target state="translated">返回的字符串不能由程序修改，但是可以被后续对 &lt;code&gt;strerror&lt;/code&gt; 函数的调用所覆盖。 &lt;code&gt;strerror&lt;/code&gt; 不需要是线程安全的。实现可能会返回指向静态只读字符串文字的不同指针，或者一遍又一遍地返回相同的指针，指向指向strerror放置字符串的静态缓冲区。</target>
        </trans-unit>
        <trans-unit id="6d5cdc0268f97ea1271d25f2faca49793842f74b" translate="yes" xml:space="preserve">
          <source>The returned value has the same sign as &lt;code&gt;x&lt;/code&gt; and is less than &lt;code&gt;y&lt;/code&gt; in magnitude.</source>
          <target state="translated">返回的值与 &lt;code&gt;x&lt;/code&gt; 具有相同的符号，并且幅度小于 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9cdb2a3429ed04aaceb9e604669e39a56f8c661" translate="yes" xml:space="preserve">
          <source>The returned value is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and independent of the current &lt;a href=&quot;../fenv/fe_round&quot;&gt;rounding mode&lt;/a&gt;.</source>
          <target state="translated">返回值是精确的（永远不会提高 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; ），并且与当前的&lt;a href=&quot;../fenv/fe_round&quot;&gt;舍入模式&lt;/a&gt;无关。</target>
        </trans-unit>
        <trans-unit id="724b8307d3008dac328f6b273599dff3480427e3" translate="yes" xml:space="preserve">
          <source>The returned value is exact, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">返回值是正确的，&lt;a href=&quot;../fenv/fe_round&quot;&gt;当前舍入模式将&lt;/a&gt;被忽略</target>
        </trans-unit>
        <trans-unit id="f67fd770b1a87fd05c53e4a98601aa49812e9bb3" translate="yes" xml:space="preserve">
          <source>The reverse is not necessarily true: two objects of &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; type with different object representations may represent the same value. For example, multiple floating-point bit patterns represent the same special value &lt;a href=&quot;../numeric/math/nan&quot;&gt;NaN&lt;/a&gt;. More commonly, some bits of the object representation may not participate in the value representation at all; such bits may be padding introduced to satisfy &lt;a href=&quot;objects#Alignment&quot;&gt;alignment requirements&lt;/a&gt;, &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; sizes, etc.</source>
          <target state="translated">相反的情况不一定成立：两个具有不同对象表示形式的&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;类型的对象可以表示相同的值。例如，多个浮点位模式表示相同的特殊值&lt;a href=&quot;../numeric/math/nan&quot;&gt;NaN&lt;/a&gt;。更常见的是，对象表示的某些位可能根本不参与值的表示。可以对这些位进行填充以满足&lt;a href=&quot;objects#Alignment&quot;&gt;对齐要求&lt;/a&gt;，&lt;a href=&quot;bit_field&quot;&gt;位字段&lt;/a&gt;大小等。</target>
        </trans-unit>
        <trans-unit id="4612adf8349954cddb8de34f362396a471ea78cb" translate="yes" xml:space="preserve">
          <source>The root directory of the path.</source>
          <target state="translated">路径的根目录。</target>
        </trans-unit>
        <trans-unit id="48c9793d32d94f49061760abdfca8adc649ed9d7" translate="yes" xml:space="preserve">
          <source>The root name of the path.</source>
          <target state="translated">路径的根名。</target>
        </trans-unit>
        <trans-unit id="6a021f552f47982e6c4bf64045a925f56bdd2012" translate="yes" xml:space="preserve">
          <source>The root path of the path.</source>
          <target state="translated">的根路径。</target>
        </trans-unit>
        <trans-unit id="744a04bfacb0b83210251e4e038c93877d0b3385" translate="yes" xml:space="preserve">
          <source>The rounding mode can be changed with &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;FLT_ROUNDS&lt;/code&gt; reflects that change.</source>
          <target state="translated">可以使用 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; 更改舍入模式，并且 &lt;code&gt;FLT_ROUNDS&lt;/code&gt; 反映该更改。</target>
        </trans-unit>
        <trans-unit id="cfa7f1285b2f2a30572b8c02c0ae8fcae8230942" translate="yes" xml:space="preserve">
          <source>The rule about &quot;more efficient implementations&quot; permits bulk I/O without intermediate buffering: that's how &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; simply passes the pointer to the POSIX &lt;code&gt;read()&lt;/code&gt; system call in some implementations of iostreams.</source>
          <target state="translated">关于&amp;ldquo;更有效的实现&amp;rdquo;的规则允许在不进行中间缓冲的情况下进行大量I / O：这就是 &lt;code&gt;&lt;a href=&quot;../basic_istream/read&quot;&gt;std::ifstream::read&lt;/a&gt;&lt;/code&gt; 在iostream的某些实现中只是将指针传递给POSIX &lt;code&gt;read()&lt;/code&gt; 系统调用的方式。</target>
        </trans-unit>
        <trans-unit id="f0e4bed8bfc25aa394d951bf5cd88212770eda2b" translate="yes" xml:space="preserve">
          <source>The rule of three/five/zero</source>
          <target state="translated">三/五/零规则</target>
        </trans-unit>
        <trans-unit id="d764d84251b9e1e79eaf8ddf3fa38a07d394b2ff" translate="yes" xml:space="preserve">
          <source>The safe bool problem</source>
          <target state="translated">安全布尔问题</target>
        </trans-unit>
        <trans-unit id="f2d334ca41df29ef25e36114b826d7adfb1af5ef" translate="yes" xml:space="preserve">
          <source>The same applies to the constructors of the next class in the I/O hierarchy, &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt;. Further-derived classes (&lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;) are always constructed with a concrete streambuffer object and call &lt;a href=&quot;../basic_ios/init&quot;&gt;&lt;code&gt;basic_ios::init()&lt;/code&gt;&lt;/a&gt;, possibly more than once, to complete initialization of their virtual base.</source>
          <target state="translated">这同样适用于I / O层次结构中下一个类 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; 的构造函数。进一步派生的类（ &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; ）始终使用具体的streambuffer对象构造，并调用&lt;a href=&quot;../basic_ios/init&quot;&gt; &lt;code&gt;basic_ios::init()&lt;/code&gt; &lt;/a&gt;，可能不止一次，以完成其虚拟基础的初始化。</target>
        </trans-unit>
        <trans-unit id="49089319d0e011162dc486f0fa5c79c193f99bb8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;S(il.begin(), il.end())&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;S(il.begin(), il.end())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1208e3c0bd83fd14a6cdf867c21125c8a325392a" translate="yes" xml:space="preserve">
          <source>The same function may be registered more than once.</source>
          <target state="translated">同一功能可以注册一次以上。</target>
        </trans-unit>
        <trans-unit id="9cb1515f8feac0bd625cac49b53fdf5bc0c4a06a" translate="yes" xml:space="preserve">
          <source>The same value is returned every time this function is called.</source>
          <target state="translated">每次调用这个函数都会返回相同的值。</target>
        </trans-unit>
        <trans-unit id="16a9673c83d6b7f5a89950887b3ffafe04e2f9d5" translate="yes" xml:space="preserve">
          <source>The same words are defined in the C programming language in the include file &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; as macros. Because in C++ these are built into the language, the C++ version of &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;, as well as &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt;, does not define anything.</source>
          <target state="translated">在C编程语言中，包含文件 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 中的宏定义为相同的单词。由于这些语言是C ++内置的语言，因此 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;ciso646&amp;gt;&lt;/code&gt; 的C ++版本未定义任何内容。</target>
        </trans-unit>
        <trans-unit id="73fcd6a6bc40829dafc0c35e7f085fcf47650726" translate="yes" xml:space="preserve">
          <source>The scope of an entity declared in an unnamed namespace or in an inline namespace includes the enclosing namespace;</source>
          <target state="translated">在未命名命名空间或内联命名空间中声明的实体的作用域包括包围的命名空间。</target>
        </trans-unit>
        <trans-unit id="3bae590b6111c1b60bedc945d731d9c449dedcba" translate="yes" xml:space="preserve">
          <source>The scope of the name introduced by condition, if it is a declaration, is the combined scope of both statements' bodies:</source>
          <target state="translated">条件引入的名称的范围,如果是声明,则是两个声明体的合并范围。</target>
        </trans-unit>
        <trans-unit id="3e817d7c9bc7bbed9e0982e173160a7e98299780" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;choose&lt;/code&gt; can be passed to certain member functions of &lt;code&gt;std::chrono::time_zone&lt;/code&gt; and &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; to control how ambiguous or nonexistent local times should be resolved. Passing &lt;code&gt;choose::earliest&lt;/code&gt; causes the earlier time point to be returned, while passing &lt;code&gt;choose::latest&lt;/code&gt; causes the later time point to be returned. (For nonexistent local times, these two time points are identical.).</source>
          <target state="translated">可以将范围内的枚举 &lt;code&gt;choose&lt;/code&gt; 传递给 &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; &lt;code&gt;std::chrono::time_zone&lt;/code&gt; 和std :: chrono :: zoned_time的某些成员函数，以控制应如何解决模棱两可或不存在的本地时间。传递 &lt;code&gt;choose::earliest&lt;/code&gt; 导致返回较早的时间点，而传递 &lt;code&gt;choose::latest&lt;/code&gt; 导致返回较晚的时间点。（对于不存在的本地时间，这两个时间点是相同的。）。</target>
        </trans-unit>
        <trans-unit id="840423b9be273862a9c8be4dd758424980f72802" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::cv_status&lt;/code&gt; describes whether a timed wait returned because of timeout or not.</source>
          <target state="translated">范围枚举 &lt;code&gt;std::cv_status&lt;/code&gt; 描述是否由于超时而返回了定时等待。</target>
        </trans-unit>
        <trans-unit id="a95fd75e62cf2bde9aca6a6e4779c05a5b287de7" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::errc&lt;/code&gt; defines the values of portable error conditions that correspond to the POSIX error codes.</source>
          <target state="translated">范围枚举 &lt;code&gt;std::errc&lt;/code&gt; 定义了与POSIX错误代码相对应的可移植错误条件的值。</target>
        </trans-unit>
        <trans-unit id="0ef7ce4c4de2f78554ef3fcfe42b9b69c424fdff" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::future_errc&lt;/code&gt; defines the error codes reported by &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; and related classes in &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; exception objects. Only four error codes are required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::future_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">作用域枚举 &lt;code&gt;std::future_errc&lt;/code&gt; 定义了 &lt;code&gt;&lt;a href=&quot;future_error&quot;&gt;std::future_error&lt;/a&gt;&lt;/code&gt; 异常对象中 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 和相关类报告的错误代码。尽管实现可能会定义其他错误代码，但仅需要四个错误代码。由于提供了 &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; 的适当专业化，因此类型 &lt;code&gt;std::future_errc&lt;/code&gt; 值可以隐式转换为 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca50a2fc4180751cf2b50c765d0d95358b35a4a9" translate="yes" xml:space="preserve">
          <source>The scoped enumeration &lt;code&gt;std::io_errc&lt;/code&gt; defines the error codes reported by I/O streams in &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; exception objects. Only one error code (&lt;code&gt;std::io_errc::stream&lt;/code&gt;) is required, although the implementation may define additional error codes. Because the appropriate specialization of &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; is provided, values of type &lt;code&gt;std::io_errc&lt;/code&gt; are implicitly convertible to &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">范围枚举 &lt;code&gt;std::io_errc&lt;/code&gt; 定义了 &lt;code&gt;&lt;a href=&quot;ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 异常对象中I / O流报告的错误代码。尽管实现可能会定义其他错误代码，但仅需要一个错误代码（ &lt;code&gt;std::io_errc::stream&lt;/code&gt; ）。因为提供了 &lt;code&gt;&lt;a href=&quot;../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; 的适当专业化，所以类型 &lt;code&gt;std::io_errc&lt;/code&gt; 值可以隐式转换为 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf90aead8c2a5530e7c352d89f0a4c787a4c9dca" translate="yes" xml:space="preserve">
          <source>The scoped enumeration type &lt;code&gt;pointer_safety&lt;/code&gt; lists the pointer safety modes supported by C++</source>
          <target state="translated">范围枚举类型的 &lt;code&gt;pointer_safety&lt;/code&gt; 列出了C ++支持的指针安全模式</target>
        </trans-unit>
        <trans-unit id="2dc9a7f6fd0f7a91a7650300695af1e539734973" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is a name of (formally, an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; that names) a data member or member function of &lt;code&gt;T&lt;/code&gt; or of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt; (e.g. &lt;code&gt;E1.E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt;), optionally &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified&lt;/a&gt; (e.g. &lt;code&gt;E1.B::E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt;), optionally using &lt;a href=&quot;dependent_name&quot;&gt;template disambiguator&lt;/a&gt; (e.g. &lt;code&gt;E1.template E2&lt;/code&gt; or &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt;).</source>
          <target state="translated">两个运营商的第二操作数是出了名（正式地说，一个&lt;a href=&quot;name#In_expressions&quot;&gt;ID-表达式&lt;/a&gt;名称）的数据成员或成员函数 &lt;code&gt;T&lt;/code&gt; 或一个明确的和可访问的基类的 &lt;code&gt;B&lt;/code&gt; 的 &lt;code&gt;T&lt;/code&gt; （例如 &lt;code&gt;E1.E2&lt;/code&gt; 或 &lt;code&gt;E1-&amp;gt;E2&lt;/code&gt; ） ，可选地&lt;a href=&quot;name#Qualified_identifiers&quot;&gt;合格&lt;/a&gt;（例如 &lt;code&gt;E1.B::E2&lt;/code&gt; 或 &lt;code&gt;E1-&amp;gt;B::E2&lt;/code&gt; ），可选地使用&lt;a href=&quot;dependent_name&quot;&gt;模板消歧器&lt;/a&gt;（例如 &lt;code&gt;E1.template E2&lt;/code&gt; 或 &lt;code&gt;E1-&amp;gt;template E2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="19215a02c420276aa98badc49ffb9d2736ab482c" translate="yes" xml:space="preserve">
          <source>The second operand of both operators is an expression of type pointer to member ( &lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;data&lt;/a&gt; or &lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;function&lt;/a&gt;) of &lt;code&gt;T&lt;/code&gt; or pointer to member of an unambiguous and accessible base class &lt;code&gt;B&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">两个运营商的第二操作数的类型指针的构件（表达式&lt;a href=&quot;pointer#Pointers_to_data_members&quot;&gt;数据&lt;/a&gt;或&lt;a href=&quot;pointer#Pointers_to_member_functions&quot;&gt;功能&lt;/a&gt;的） &lt;code&gt;T&lt;/code&gt; 或指针一个明确的和可访问的基类的成员 &lt;code&gt;B&lt;/code&gt; 的 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c55eea87a0f8d8889265157fbe6787960184823" translate="yes" xml:space="preserve">
          <source>The second overload contains a separate template parameter for the head of the arguments and a parameter pack, this allows the recursive call to pass only the tail of the parameters until it becomes empty.</source>
          <target state="translated">第二个重载包含一个单独的模板参数,用于参数的头部和一个参数包,这使得递归调用只传递参数的尾部,直到它变成空的。</target>
        </trans-unit>
        <trans-unit id="be075fc3b764cc15641e30da0af7956f238d21f0" translate="yes" xml:space="preserve">
          <source>The second pass through the callbacks may be used to deep-copy the user-defined objects pointed to by the pointers in &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">回调的第二次传递可用于深度复制 &lt;code&gt;&lt;a href=&quot;../ios_base/pword&quot;&gt;std::ios_base::pword&lt;/a&gt;&lt;/code&gt; 的指针所指向的用户定义的对象。</target>
        </trans-unit>
        <trans-unit id="b0a5b7b985ce580725fc7689da25a9594bd797ad" translate="yes" xml:space="preserve">
          <source>The second signature behaves as if called with &lt;code&gt;opts&lt;/code&gt; set to &lt;code&gt;perm_options::replace&lt;/code&gt;.</source>
          <target state="translated">第二个签名的行为就像在 &lt;code&gt;opts&lt;/code&gt; 设置为 &lt;code&gt;perm_options::replace&lt;/code&gt; 情况下调用一样。</target>
        </trans-unit>
        <trans-unit id="2748b8b2515518309d2bd896dc6dc045638385c8" translate="yes" xml:space="preserve">
          <source>The selected elements must exist.</source>
          <target state="translated">所选元素必须存在。</target>
        </trans-unit>
        <trans-unit id="da6776cef8700dee0f22e58931e5d3627bef7c47" translate="yes" xml:space="preserve">
          <source>The semantics of inheriting constructors were retroactively changed by a &lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;defect report against C++11&lt;/a&gt;. Previously, an inheriting constructor declaration caused a set of synthesized constructor declarations to be injected into the derived class, which caused redundant argument copies/moves, had problematic interactions with some forms of SFINAE, and in some cases can be unimplementable on major ABIs. Older compilers may still implement the previous semantics.</source>
          <target state="translated">通过&lt;a href=&quot;using_declaration#Defect_reports&quot;&gt;针对C ++ 11&lt;/a&gt;的缺陷报告，可追溯地更改继承构造函数的语义。以前，继承的构造函数声明导致将一组综合的构造函数声明注入到派生类中，这导致冗余的参数副本/移动，与某些形式的SFINAE的交互存在问题，并且在某些情况下可能无法在主要的ABI上实现。较早的编译器可能仍会实现以前的语义。</target>
        </trans-unit>
        <trans-unit id="bfeb9ddde9efbc3c0ab3714a0a6e7a8a3efc2e2c" translate="yes" xml:space="preserve">
          <source>The semantics of the member functions are defined are as follows.</source>
          <target state="translated">成员函数的语义定义如下。</target>
        </trans-unit>
        <trans-unit id="276fbc8f397db984b2189ed81138a185a9b8f9c5" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt;&lt;code&gt;clog&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数的语义旨在与C函数&lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/clog.html&quot;&gt; &lt;code&gt;clog&lt;/code&gt; &lt;/a&gt;一致。</target>
        </trans-unit>
        <trans-unit id="630a0686e90df2d1198d4a4bff7aa262b9655ed1" translate="yes" xml:space="preserve">
          <source>The semantics of this function are intended to be consistent with the C function &lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt;&lt;code&gt;csqrt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此函数的语义旨在与C函数&lt;a href=&quot;http://en.cppreference.com/w/c/numeric/complex/csqrt.html&quot;&gt; &lt;code&gt;csqrt&lt;/code&gt; &lt;/a&gt;一致。</target>
        </trans-unit>
        <trans-unit id="f09342387ba1e64c32080173dab4604297f52ab0" translate="yes" xml:space="preserve">
          <source>The sequence denoted by this pair of iterators consists of the following:</source>
          <target state="translated">这对迭代器所表示的序列包括以下内容。</target>
        </trans-unit>
        <trans-unit id="8cf1423eae846ac729f66d139e28a402cef688fa" translate="yes" xml:space="preserve">
          <source>The sequence of &lt;code&gt;char&lt;/code&gt;s accumulated in Stage 2 is converted to a numeric value</source>
          <target state="translated">第2阶段中累积的 &lt;code&gt;char&lt;/code&gt; 序列将转换为数值</target>
        </trans-unit>
        <trans-unit id="61ab9fb3fc586d17241f33750480c6a753617cad" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;d.param()&lt;/code&gt;</source>
          <target state="translated">根据 &lt;code&gt;d.param()&lt;/code&gt; 参数化的分布，通过连续调用相同 &lt;code&gt;g&lt;/code&gt; 的调用连续返回的数字序列是随机分布的</target>
        </trans-unit>
        <trans-unit id="8ad57e0d60c4213ba3be7acf41e0955df808546a" translate="yes" xml:space="preserve">
          <source>The sequence of numbers returned by successive invocations of this call with the same &lt;code&gt;g&lt;/code&gt; are randomly distributed according to the distribution parametrized by &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">由相同 &lt;code&gt;g&lt;/code&gt; 的该调用的连续调用返回的数字序列根据 &lt;code&gt;p&lt;/code&gt; 设置的分布随机分布</target>
        </trans-unit>
        <trans-unit id="326be078a4bda5f44b21dfc8b70dd484a2be09be" translate="yes" xml:space="preserve">
          <source>The set of candidate functions and the list of arguments is prepared in a unique way for each of the contexts where overload resolution is used:</source>
          <target state="translated">候选函数集和参数列表是以独特的方式为每个使用过载解析的上下文准备的。</target>
        </trans-unit>
        <trans-unit id="5fc5fc4fdccda5729ebc678de9b6bf863450c8f5" translate="yes" xml:space="preserve">
          <source>The set of candidate functions to be submitted for overload resolution is a union of the sets above. The argument list for the purpose of overload resolution consists of the operands of the operator except for &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, where the second operand is not an argument for the function call (see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;).</source>
          <target state="translated">要提交的用于重载解决方案的候选函数集是上述集合的并集。用于重载解析的参数列表由操作符的操作数组成，但 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 除外，其中第二个操作数不是函数调用的参数（请参阅&lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;成员访问操作符&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a1904e66df24bc3e43e3c61d84a3ad2129497a05" translate="yes" xml:space="preserve">
          <source>The set of declarations found by ordinary &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; and the set of declarations found in all elements of the associated set produced by ADL, are merged, with the following special rules.</source>
          <target state="translated">普通的&lt;a href=&quot;lookup&quot;&gt;不合格查找&lt;/a&gt;所找到的声明集和ADL产生的关联集的所有元素中找到的声明集将与以下特殊规则合并。</target>
        </trans-unit>
        <trans-unit id="633b59c91cf4f999e02e8403d839498119457c8d" translate="yes" xml:space="preserve">
          <source>The set of interval boundaries b</source>
          <target state="translated">区间边界的集合b</target>
        </trans-unit>
        <trans-unit id="e3b735a300b426d2245b4cf296a3150fc21a63b1" translate="yes" xml:space="preserve">
          <source>The set of valid values for base is {0,2,3,...,36}. The set of valid digits for base-2 integers is &lt;code&gt;{0,1&lt;/code&gt;}, for base-3 integers is &lt;code&gt;{0,1,2&lt;/code&gt;}, and so on. For bases larger than &lt;code&gt;10&lt;/code&gt;, valid digits include alphabetic characters, starting from &lt;code&gt;Aa&lt;/code&gt; for base-11 integer, to &lt;code&gt;Zz&lt;/code&gt; for base-36 integer. The case of the characters is ignored.</source>
          <target state="translated">底数的有效值集为{0,2,3，...，36}。以2为底的整数的有效数字集为 &lt;code&gt;{0,1&lt;/code&gt; }，以3为底的整数的有效数字集为 &lt;code&gt;{0,1,2&lt;/code&gt; }，依此类推。对于大于 &lt;code&gt;10&lt;/code&gt; 的基数，有效的数字包括字母字符，从 &lt;code&gt;Aa&lt;/code&gt; (对于11 进制整数）开始，到 &lt;code&gt;Zz&lt;/code&gt; (对于36整数整数）。字符的大小写将被忽略。</target>
        </trans-unit>
        <trans-unit id="54f77766bc9f988f0c109a0b9a274a2d62a58aff" translate="yes" xml:space="preserve">
          <source>The shared state already stores a value or exception. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">共享状态已存储值或异常。错误类别设置为&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dd74c3ed26047fa14c5abbda7f8120251339635c" translate="yes" xml:space="preserve">
          <source>The shared state has already been retrieved via a call to &lt;code&gt;get_future&lt;/code&gt;. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_already_retrieved&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">共享状态已通过调用 &lt;code&gt;get_future&lt;/code&gt; 检索到。错误类别设置为&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_already_retrieved&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="817c4cd2132343bd97c84575fd05e4ae8b2ee89e" translate="yes" xml:space="preserve">
          <source>The shared state is only made ready after the current thread exits and all objects of</source>
          <target state="translated">只有在当前线程退出后,共享状态才会被准备好,并且所有对象的</target>
        </trans-unit>
        <trans-unit id="6e13e04bbcf515d86b1c971f508fc8ad239fb065" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;conjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">短路实例化分化带来 &lt;code&gt;conjunction&lt;/code&gt; 从折叠的表达式：一个倍的表达等 &lt;code&gt;(... &amp;amp;&amp;amp; Bs::value)&lt;/code&gt; 实例化每个 &lt;code&gt;B&lt;/code&gt; 在 &lt;code&gt;Bs&lt;/code&gt; ，而 &lt;code&gt;std::conjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; 停止实例一旦可确定的值。如果后面的类型实例化很昂贵，或者在使用错误类型实例化时可能导致硬错误，则这特别有用。</target>
        </trans-unit>
        <trans-unit id="4b6b7f6a466d865c0d71c17ba70598d418424cc5" translate="yes" xml:space="preserve">
          <source>The short-circuit instantiation differentiates &lt;code&gt;disjunction&lt;/code&gt; from fold expressions: a fold expression like &lt;code&gt;(... || Bs::value)&lt;/code&gt; instantiates every &lt;code&gt;B&lt;/code&gt; in &lt;code&gt;Bs&lt;/code&gt;, while &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; stops instantiation once the value can be determined. This is particularly useful if the later type is expensive to instantiate or can cause a hard error when instantiated with the wrong type.</source>
          <target state="translated">短路实例化分化带来 &lt;code&gt;disjunction&lt;/code&gt; 从折叠的表达式：一个倍的表达等 &lt;code&gt;(... || Bs::value)&lt;/code&gt; 实例化每个 &lt;code&gt;B&lt;/code&gt; 在 &lt;code&gt;Bs&lt;/code&gt; ，而 &lt;code&gt;std::disjunction_v&amp;lt;Bs...&amp;gt;&lt;/code&gt; 停止实例化一次的值可以是决心。如果后面的类型实例化很昂贵，或者在使用错误类型实例化时可能导致硬错误，则这特别有用。</target>
        </trans-unit>
        <trans-unit id="a6fb9e43d23dc62112f027d6321e004ed3458fa2" translate="yes" xml:space="preserve">
          <source>The side-effect A on a scalar M (a write) is</source>
          <target state="translated">标量M上的副作用A(写)是</target>
        </trans-unit>
        <trans-unit id="35d03624f1f46c34b182260c7be6e91d340366f1" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of bytes (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the objects being compared.</source>
          <target state="translated">结果的符号是在比较对象中不同的第一对字节值（均被解释为 &lt;code&gt;unsigned char&lt;/code&gt; ）之间的差异的符号。</target>
        </trans-unit>
        <trans-unit id="e97cc12d1f3f2487de1b90ed0cc2090797374f8e" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of characters (both interpreted as &lt;code&gt;unsigned char&lt;/code&gt;) that differ in the strings being compared.</source>
          <target state="translated">结果的符号是在比较的字符串中不同的第一对字符值（均被解释为 &lt;code&gt;unsigned char&lt;/code&gt; ）之间的差异的符号。</target>
        </trans-unit>
        <trans-unit id="cde6f3dc011075607068991f0904ec95fd72723b" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the arrays being compared.</source>
          <target state="translated">结果的符号是指被比较的数组中,第一对宽字符的值差异的符号。</target>
        </trans-unit>
        <trans-unit id="f67aeb4832459c9bfc7aeb9f457a87aa921f1247" translate="yes" xml:space="preserve">
          <source>The sign of the result is the sign of the difference between the values of the first pair of wide characters that differ in the strings being compared.</source>
          <target state="translated">结果的符号是指被比较的字符串中,第一对宽字符的差值的符号。</target>
        </trans-unit>
        <trans-unit id="7c011cc304f5801ea8e7fc6376c1a87eaf494c1e" translate="yes" xml:space="preserve">
          <source>The signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;.</source>
          <target state="translated">签名不需要具有 &lt;code&gt;const &amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d5cf620ffd0c069fb09e6109069ba28e165d978" translate="yes" xml:space="preserve">
          <source>The signature of the comparison function should be equivalent to the following:</source>
          <target state="translated">比较函数的签名应等同于以下内容:</target>
        </trans-unit>
        <trans-unit id="a6eece811de82334f897e04a0286d22b8a1880ad" translate="yes" xml:space="preserve">
          <source>The signature of the function should be equivalent to the following:</source>
          <target state="translated">该函数的签名应等同于以下内容:</target>
        </trans-unit>
        <trans-unit id="e16d376fc732d9fd890a8e68862e00b90427d089" translate="yes" xml:space="preserve">
          <source>The signature of the predicate function should be equivalent to the following:</source>
          <target state="translated">谓词函数的签名应等同于以下内容:</target>
        </trans-unit>
        <trans-unit id="5471ac941bf0f0fd4abf99ed5f3d659518a0c817" translate="yes" xml:space="preserve">
          <source>The similarly-named container member functions &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/list/remove&quot;&gt;&lt;code&gt;list::remove_if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../container/forward_list/remove&quot;&gt;&lt;code&gt;forward_list::remove_if&lt;/code&gt;&lt;/a&gt; erase the removed elements.</source>
          <target state="translated">具有类似名称的容器成员函数&lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../container/list/remove&quot;&gt; &lt;code&gt;list::remove_if&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../container/forward_list/remove&quot;&gt; &lt;code&gt;forward_list::remove_if&lt;/code&gt; &lt;/a&gt;删除已删除的元素。</target>
        </trans-unit>
        <trans-unit id="d18977a380068b230c78baa2354437eff8114c95" translate="yes" xml:space="preserve">
          <source>The sine is an entire function on the complex plane, and has no branch cuts.  Mathematical definition of the sine is sin z =</source>
          <target state="translated">正弦是复数平面上的一个整体函数,并且没有分支切口。正弦的数学定义是:sin z=。</target>
        </trans-unit>
        <trans-unit id="b269c185388406409d66b389ee290905aa3250c2" translate="yes" xml:space="preserve">
          <source>The single total order might not be consistent with</source>
          <target state="translated">单总顺序可能不符合</target>
        </trans-unit>
        <trans-unit id="a1e4ac9052c7611ed3e612ed7782e64fa0ddd565" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;A&lt;/code&gt;'s state is no less than the size of &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">的大小 &lt;code&gt;A&lt;/code&gt; 的状态是不小于的尺寸 &lt;code&gt;b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa4ef58b6f217f15dfbc54c8b0b3fa97f978e5a" translate="yes" xml:space="preserve">
          <source>The size of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 或 &lt;code&gt;array&lt;/code&gt; 的大小。</target>
        </trans-unit>
        <trans-unit id="1a42f803c92acdfd49c509a1473d94317255f86f" translate="yes" xml:space="preserve">
          <source>The size of any &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; or member subobject (unless &lt;code&gt;[[no_unique_address]]&lt;/code&gt; -- see below)(since C++20) is required to be at least 1 even if the type is an empty &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (that is, a class or struct that has no non-static data members), in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct.</source>
          <target state="translated">任何&lt;a href=&quot;objects&quot;&gt;对象&lt;/a&gt;或成员子对象的大小（除非 &lt;code&gt;[[no_unique_address]]&lt;/code&gt; -参见下文）（自C ++ 20起）都必须至少为1，即使该类型是空的&lt;a href=&quot;class&quot;&gt;类类型&lt;/a&gt;（即，类或具有非静态数据成员的struct），以便能够保证相同类型的不同对象的地址始终是不同的。</target>
        </trans-unit>
        <trans-unit id="60fb803f3af93287267581b597b353fbed331445" translate="yes" xml:space="preserve">
          <source>The size of the file, in bytes.</source>
          <target state="translated">文件的大小,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="fdc6fa0a097f223b138fc7c44f70083d5b4bcb5a" translate="yes" xml:space="preserve">
          <source>The size of the private container that was populated at construction time.</source>
          <target state="translated">施工时被填充的私人集装箱的大小。</target>
        </trans-unit>
        <trans-unit id="3facb159d302e57398e2b32d50c748002ccee995" translate="yes" xml:space="preserve">
          <source>The size of the pushback buffer varies in practice from 4k (Linux, MacOS) to as little as 4 (Solaris) or the guaranteed minimum 1 (HPUX, AIX).</source>
          <target state="translated">在实践中,推送缓冲区的大小从4k(Linux、MacOS)到4(Solaris)或保证最小的1(HPUX、AIX)不等。</target>
        </trans-unit>
        <trans-unit id="c2459bce198cb000b381177d5cc738c181699405" translate="yes" xml:space="preserve">
          <source>The size of the referred-to filesystem object.</source>
          <target state="translated">引用到的文件系统对象的大小。</target>
        </trans-unit>
        <trans-unit id="2a786a72bf82ea447c9d87b5be65ed00ac14cb03" translate="yes" xml:space="preserve">
          <source>The size of the sequence in bytes, i.e., &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt;.</source>
          <target state="translated">序列的 &lt;code&gt;size() * sizeof(element_type)&lt;/code&gt; 以字节为单位），即size（）* sizeof（element_type）。</target>
        </trans-unit>
        <trans-unit id="66997ef04e230b1f79e491df0b1540977ef30033" translate="yes" xml:space="preserve">
          <source>The sizeof... operator</source>
          <target state="translated">运营商的大小...</target>
        </trans-unit>
        <trans-unit id="e03ce5e1c2c2d6a504f6be8da7e802aa894a2643" translate="yes" xml:space="preserve">
          <source>The smallest &lt;code&gt;q&lt;/code&gt; in &lt;code&gt;[p,p+n)&lt;/code&gt; such that &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; is true</source>
          <target state="translated">&lt;code&gt;[p,p+n)&lt;/code&gt; 中的最小 &lt;code&gt;q&lt;/code&gt; ，使得 &lt;code&gt;X​::​eq(*q, c)&lt;/code&gt; 为真</target>
        </trans-unit>
        <trans-unit id="164a8a1e2ed3ac9211701d99d6d1f9abf5da92d6" translate="yes" xml:space="preserve">
          <source>The smallest integral power of two that is not smaller than &lt;code&gt;x&lt;/code&gt;, or an unspecified value if the result cannot be represented in &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">不小于 &lt;code&gt;x&lt;/code&gt; 的2的最小整数幂，如果结果不能用 &lt;code&gt;T&lt;/code&gt; 表示，则为不指定的值。</target>
        </trans-unit>
        <trans-unit id="6019aa352c36bf78f73a83e660e2da74f2e4c2ce" translate="yes" xml:space="preserve">
          <source>The socket is not connected</source>
          <target state="translated">插座未连接</target>
        </trans-unit>
        <trans-unit id="c1a77c31870ff87a240876e0120da8708b5e5e1e" translate="yes" xml:space="preserve">
          <source>The sole exceptions to the maximal munch rule are:</source>
          <target state="translated">最大咀嚼规则的唯一例外是:</target>
        </trans-unit>
        <trans-unit id="023ae07779bac9c8efdef6a9eb724121da731b80" translate="yes" xml:space="preserve">
          <source>The source of the messages is implementation-defined.</source>
          <target state="translated">消息的来源由实施定义。</target>
        </trans-unit>
        <trans-unit id="be9039b113cba4c87f833cb8a33bdd196413e28b" translate="yes" xml:space="preserve">
          <source>The span must have static extent (i.e., &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;I&lt;/code&gt; must be an integer value in range &lt;code&gt;[0, N)&lt;/code&gt;. This is enforced at compile time as opposed to &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">范围必须具有静态范围（即 &lt;code&gt;N != &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt; ），并且 &lt;code&gt;I&lt;/code&gt; 必须是 &lt;code&gt;[0, N)&lt;/code&gt; 范围内的整数。这是在编译时强制执行的，而不是 &lt;code&gt;operator[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e5608fbdb3aeacdd6ea3d40e4a18d5358477dba" translate="yes" xml:space="preserve">
          <source>The special pathname dot (&lt;code&gt;&quot;.&quot;&lt;/code&gt;) is a hard link to its parent directory. The special pathname dot-dot &lt;code&gt;&quot;..&quot;&lt;/code&gt; is a hard link to the directory that is the parent of its parent.</source>
          <target state="translated">特殊路径名点（ &lt;code&gt;&quot;.&quot;&lt;/code&gt; ）是与其父目录的硬链接。特殊路径名点-点 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 是到作为其父级目录的目录的硬链接。</target>
        </trans-unit>
        <trans-unit id="d5b3112d1aecd8e0bc024d6e95c5b21d74c58b9f" translate="yes" xml:space="preserve">
          <source>The special pathnames dot and dot-dot are skipped.</source>
          <target state="translated">特殊路径名dot和dot-dot被跳过。</target>
        </trans-unit>
        <trans-unit id="3fec246ae7b3831f5d777421b3527ac038580e09" translate="yes" xml:space="preserve">
          <source>The special unnamed bit field of size zero can be forced to break up padding. It specifies that the next bit field begins at the beginning of its allocation unit:</source>
          <target state="translated">尺寸为0的特殊未命名位字段可以强制打断填充。它指定下一个位字段从它的分配单位开始。</target>
        </trans-unit>
        <trans-unit id="05614a0a97be351dbad65c4504f830ce86618f1b" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace()&lt;/code&gt; member until C++14.</source>
          <target state="translated">在C ++ 14之前，专业化&lt;a href=&quot;../vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;&lt;/a&gt;没有 &lt;code&gt;emplace()&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="c0c58597769cd63f71580480f8d3215395bbf758" translate="yes" xml:space="preserve">
          <source>The specialization &lt;a href=&quot;../vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; did not have &lt;code&gt;emplace_back()&lt;/code&gt; member until C++14.</source>
          <target state="translated">在C ++ 14之前，专业化&lt;a href=&quot;../vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;&lt;/a&gt;没有 &lt;code&gt;emplace_back()&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="8bec2e9d713031b66c24ef679d2b78ee8bb1782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">专业化 &lt;code&gt;std::conjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; 具有一个公开且明确的基础。</target>
        </trans-unit>
        <trans-unit id="3d5cf9884b92e823e93ea4f01a9bf287d1156634" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; has a public and unambiguous base that is.</source>
          <target state="translated">专业化 &lt;code&gt;std::disjunction&amp;lt;B1, ..., BN&amp;gt;&lt;/code&gt; 具有一个公开且明确的基础。</target>
        </trans-unit>
        <trans-unit id="186f2d291b8a6a9a42e951016f0b61a5ce492295" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">如果启用了 &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 则启用特殊化 &lt;code&gt;std::hash&amp;lt;optional&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; （请参阅 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; ），否则将禁用。</target>
        </trans-unit>
        <trans-unit id="600411d4c48669f0d407c466842e7104a0cdd005" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if &lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">如果启用了 &lt;code&gt;std::hash&amp;lt;typename std::unique_ptr&amp;lt;T,D&amp;gt;::pointer&amp;gt;&lt;/code&gt; ，并且启用了特殊化 &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;lt;T,D&amp;gt;&amp;gt;&lt;/code&gt; （请参阅 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; ），并且否则禁用。</target>
        </trans-unit>
        <trans-unit id="42f1297302612956b663a74e0024532e227a782e" translate="yes" xml:space="preserve">
          <source>The specialization &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; is enabled (see &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;) if every specialization in &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; is enabled, and is disabled otherwise.</source>
          <target state="translated">如果启用了 &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;Types&amp;gt;&amp;gt;...&lt;/code&gt; 每个特殊化，则启用特殊化 &lt;code&gt;std::hash&amp;lt;std::variant&amp;lt;Types...&amp;gt;&amp;gt;&lt;/code&gt; （请参阅 &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; ），否则被禁用。</target>
        </trans-unit>
        <trans-unit id="2c76460cbd0b8d4d937dbc5c694d6c7635ce71fd" translate="yes" xml:space="preserve">
          <source>The specializations &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt;, &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; are &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt; for representing and manipulating &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;complex numbers&lt;/a&gt;.</source>
          <target state="translated">特殊化 &lt;code&gt;std::complex&amp;lt;float&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::complex&amp;lt;double&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::complex&amp;lt;long double&amp;gt;&lt;/code&gt; 是用于表示和处理&lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_number&quot;&gt;复数的&lt;/a&gt;&lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralTypes&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86590d0709c4e9c53d7a3642895c8ee4ba57e923" translate="yes" xml:space="preserve">
          <source>The specification of release-consume ordering is being revised, and the use of &lt;code&gt;memory_order_consume&lt;/code&gt; is temporarily discouraged.</source>
          <target state="translated">正在修订发布-消费排序的规范，并且暂时不建议使用 &lt;code&gt;memory_order_consume&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29817af7f9fc3c9588fba123d6e7dc6efdcdd019" translate="yes" xml:space="preserve">
          <source>The specified non-type arguments must either match the types of the corresponding non-type template parameters, or be &lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;convertible to them&lt;/a&gt;.</source>
          <target state="translated">指定的非类型参数必须与相应的非类型模板参数的类型匹配，或者可以&lt;a href=&quot;template_parameters#Template_non-type_arguments&quot;&gt;转换为它们&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5cd71ab6119537a05f604ee514973d18be587dd3" translate="yes" xml:space="preserve">
          <source>The specified template arguments must match the template parameters in kind (i.e., type for type, non-type for non-type, and template for template). There cannot be more arguments than there are parameters (unless one parameter is a parameter pack, in which case there has to be an argument for each non-pack parameter).</source>
          <target state="translated">指定的模板参数必须与模板参数的种类相匹配(即类型的为类型,非类型的为非类型,模板的为模板)。参数的数量不能多于参数的数量(除非一个参数是参数包,在这种情况下,每个非包参数必须有一个参数)。</target>
        </trans-unit>
        <trans-unit id="f0a5a1232f69709176b03e5e2f09bcf1138b3d55" translate="yes" xml:space="preserve">
          <source>The standard 32-bit IEEE 754 floating-point type has a 24 bit fractional part (23 bits written, one implied), which may suggest that it can represent 7 digit decimals (&lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 7.22), but relative rounding errors are non-uniform and some floating-point values with 7 decimal digits do not survive conversion to 32-bit float and back: the smallest positive example is &lt;code&gt;8.589973e9&lt;/code&gt;, which becomes &lt;code&gt;8.589974e9&lt;/code&gt; after the roundtrip. These rounding errors cannot exceed one bit in the representation, and &lt;code&gt;digits10&lt;/code&gt; is calculated as &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt;, which is 6.92. Rounding down results in the value 6.</source>
          <target state="translated">标准的32位IEEE 754浮点类型具有24位小数部分（写入了23位，暗含一个），这可能表明它可以表示7位小数（ &lt;code&gt;24 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; 为7.22），但是相对的舍入误差是不一致的，并且某些具有7个十进制数字的浮点值无法转换为32位浮点数和返回值：最小的正例为 &lt;code&gt;8.589973e9&lt;/code&gt; ，在往返之后变为 &lt;code&gt;8.589974e9&lt;/code&gt; 。这些舍入误差不能超过表示中的一位，并且 &lt;code&gt;digits10&lt;/code&gt; 的计算公式为 &lt;code&gt;(24-1)*&lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; ，即6.92。四舍五入得出值6。</target>
        </trans-unit>
        <trans-unit id="73e09cdf1b741ad1b3350d5372e33ae3558bb73f" translate="yes" xml:space="preserve">
          <source>The standard C streams are the following: &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标准C流如下： &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stderr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bc3d7739fd70319e077ff236f69aa7397545b58" translate="yes" xml:space="preserve">
          <source>The standard C++ streams are the following: &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标准的C ++流如下： &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::clog&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::wcin&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::wcout&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../clog&quot;&gt;std::wclog&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1559238f4f96f1308a43f7cac736eb900505d58" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">标准容器 &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 满足这些要求。</target>
        </trans-unit>
        <trans-unit id="9b92ff236d7217d097c5d77ce3d7b6e24187e96b" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; satisfy these requirements.</source>
          <target state="translated">标准容器 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 满足这些要求。</target>
        </trans-unit>
        <trans-unit id="3348805983e91545ed6f0183b3ad7d17819a000e" translate="yes" xml:space="preserve">
          <source>The standard containers &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; satisfy these requirements. By default, if no container class is specified for a particular stack class instantiation, the standard container &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">标准容器 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 满足这些要求。默认情况下，如果没有为特定的堆栈类实例指定容器类，则使用标准容器 &lt;code&gt;&lt;a href=&quot;deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da4c870ff1fa0a006bae378b114850461217f6df" translate="yes" xml:space="preserve">
          <source>The standard defines a set of &lt;a href=&quot;preprocessor/replace&quot;&gt;preprocessor macros&lt;/a&gt; corresponding to C++ language and library features introduced in C++11 or later. They are intended as a simple and portable way to detect the presence of said features.</source>
          <target state="translated">该标准定义了一组&lt;a href=&quot;preprocessor/replace&quot;&gt;预处理程序宏，它们&lt;/a&gt;对应于C ++ 11或更高版本中引入的C ++语言和库功能。它们旨在作为检测所述特征的存在的简单且便携式的方式。</target>
        </trans-unit>
        <trans-unit id="7a975074992a026641c667980782c267b65820dd" translate="yes" xml:space="preserve">
          <source>The standard does not define any behavior for this function except that &lt;code&gt;setbuf(0, 0)&lt;/code&gt; called before any I/O has taken place is required to set unbuffered output.</source>
          <target state="translated">该标准没有定义此函数的任何行为，只是需要在发生任何I / O之前调用 &lt;code&gt;setbuf(0, 0)&lt;/code&gt; 来设置无缓冲输出。</target>
        </trans-unit>
        <trans-unit id="11c9f11d649487cf00471f2a0a3ced302b1b169d" translate="yes" xml:space="preserve">
          <source>The standard encourages, but doesn't require that the main thread and the threads started by &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; offer concurrent forward progress guarantee.</source>
          <target state="translated">该标准鼓励但不要求主线程和由 &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 启动的线程提供并发向前进度保证。</target>
        </trans-unit>
        <trans-unit id="3769b4f39ad7629c09afe04cb807040c01f86974" translate="yes" xml:space="preserve">
          <source>The standard error condition &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; typically indicates the condition where the result, rather than the input, is out of range, and is more closely related to &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">标准错误条件 &lt;code&gt;&lt;a href=&quot;../errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; 通常表示结果（而不是输入）超出范围，并且与 &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; 密切相关的条件。</target>
        </trans-unit>
        <trans-unit id="6ea76ab6562da741fc1f1f80fa940f195cc6f7f0" translate="yes" xml:space="preserve">
          <source>The standard itself doesn't specify precedence levels. They are derived from the grammar.</source>
          <target state="translated">标准本身并没有规定优先级别。它们是从语法中得出的。</target>
        </trans-unit>
        <trans-unit id="464d44c8fa9af2bc062b88f7cb6e09d51921375c" translate="yes" xml:space="preserve">
          <source>The standard library</source>
          <target state="translated">标准库</target>
        </trans-unit>
        <trans-unit id="501d2fd270600c1ad4722fe615b8c6d60795a8cf" translate="yes" xml:space="preserve">
          <source>The standard library also defines a function template &lt;a href=&quot;../../algorithm/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt; taking a pair of iterators and a value, this overload is one of the standard &lt;a href=&quot;../../algorithm&quot;&gt;algorithms&lt;/a&gt;.</source>
          <target state="translated">标准库还定义了一个函数模板&lt;a href=&quot;../../algorithm/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt;它带有一对迭代器和一个值，此重载是标准&lt;a href=&quot;../../algorithm&quot;&gt;算法之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f9befce5f0ccf765011ba595f540e481507757b" translate="yes" xml:space="preserve">
          <source>The standard library also defines an overload of &lt;code&gt;std::remove&lt;/code&gt; taking &lt;code&gt;const char*&lt;/code&gt;, used to delete files: &lt;a href=&quot;../io/c/remove&quot;&gt;&lt;code&gt;std::remove&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">标准库还定义了过载 &lt;code&gt;std::remove&lt;/code&gt; 采取 &lt;code&gt;const char*&lt;/code&gt; ，用于删除文件：&lt;a href=&quot;../io/c/remove&quot;&gt; &lt;code&gt;std::remove&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0eb84bf9201f6099169c60c1dc16401b24988119" translate="yes" xml:space="preserve">
          <source>The standard library also provides a number of pre-defined &lt;a href=&quot;../utility/functional&quot;&gt;function object templates&lt;/a&gt; as well as the methods to compose new ones (including &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">标准库还提供了许多预定义的&lt;a href=&quot;../utility/functional&quot;&gt;函数对象模板&lt;/a&gt;以及组成新模板的方法（包括 &lt;code&gt;&lt;a href=&quot;../utility/functional/mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../utility/functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b555b9bc9fd6124abd76d1e9d57fcd86813932ea" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; allows for creating a substitution failure in order to enable or disable particular overloads based on a condition evaluated at compile time.</source>
          <target state="translated">标准库组件 &lt;code&gt;&lt;a href=&quot;../types/enable_if&quot;&gt;std::enable_if&lt;/a&gt;&lt;/code&gt; 允许创建替换失败，以便根据编译时评估的条件启用或禁用特定的重载。</target>
        </trans-unit>
        <trans-unit id="4fdaf88b78e9440c1d7c4b829cd2c20de63b3687" translate="yes" xml:space="preserve">
          <source>The standard library component &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; is another utility metafunction that simplifies SFINAE applications.</source>
          <target state="translated">标准库组件 &lt;code&gt;&lt;a href=&quot;../types/void_t&quot;&gt;std::void_t&lt;/a&gt;&lt;/code&gt; 是另一个简化SFINAE应用程序的实用程序元函数。</target>
        </trans-unit>
        <trans-unit id="90d7e9c58cdd097e6e1be1842b8c59bbecc70529" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report domain errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::domain_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">标准库组件不会引发此异常（数学函数报告 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 中指定的域错误）。但是，第三方库使用此库。例如，如果启用了 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; （默认设置），则&lt;a href=&quot;http://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt;会引发 &lt;code&gt;std::domain_error&lt;/code&gt; domain_error。</target>
        </trans-unit>
        <trans-unit id="4dffee91fae753bda05b684cabb9727f41e1ecf3" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report domain errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;https://www.boost.org/doc/libs/1_55_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::domain_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46dcc8a3d08bda1ff1e95e9b8404ca3dc28f1aeb" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report underflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::underflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="translated">标准库组件不会引发此异常（数学函数报告 &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 中指定的下溢错误）。但是，第三方库使用此库。例如，如果启用了 &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; （默认设置），则&lt;a href=&quot;http://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt;会引发 &lt;code&gt;std::underflow_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5163045812559a0cfa0dfff651b770d63211f5c3" translate="yes" xml:space="preserve">
          <source>The standard library components do not throw this exception (mathematical functions report underflow errors as specified in &lt;code&gt;&lt;a href=&quot;../../numeric/math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;). Third-party libraries, however, use this. For example, &lt;a href=&quot;https://www.boost.org/doc/libs/1_66_0/libs/math/doc/html/math_toolkit/error_handling.html&quot;&gt;boost.math&lt;/a&gt; throws &lt;code&gt;std::underflow_error&lt;/code&gt; if &lt;code&gt;boost::math::policies::throw_on_error&lt;/code&gt; is enabled (the default setting).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b5eeaea89ac1fd73a4e45ba45af272f555ab4a" translate="yes" xml:space="preserve">
          <source>The standard library defines two trivial awaitables: &lt;code&gt;std::suspend_always&lt;/code&gt; and &lt;code&gt;std::suspend_never&lt;/code&gt;.</source>
          <target state="translated">标准库定义了两个简单的等待对象： &lt;code&gt;std::suspend_always&lt;/code&gt; 和 &lt;code&gt;std::suspend_never&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="131ce88470ae44f681ca4c49d07e5f0002f442b1" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (5-8) directly calls the corresponding throwing versions (1-4). The standard library implementation of the throwing array versions (2,4) directly calls the corresponding single-object version (1,3). Thus, replacing the throwing single object allocation functions is sufficient to handle all allocations.</source>
          <target state="translated">标准库实现的nothrow版本(5-8)直接调用对应的抛物版本(1-4)。标准库实现的抛数组版本(2,4)直接调用对应的单对象版本(1,3)。因此,替换抛出单对象分配函数就可以处理所有的分配。</target>
        </trans-unit>
        <trans-unit id="987bfd8dffed15aac50d7b564b0338f3cfc187ca" translate="yes" xml:space="preserve">
          <source>The standard library implementations of the nothrow versions (9,10) directly call the corresponding throwing versions (1,2). The standard library implementations of the size-aware deallocation functions (5-8) directly call the corresponding size-unaware deallocation functions (1-4). The standard library implementations of size-unaware throwing array forms (2,4) directly calls the corresponding single-object forms (1,3).</source>
          <target state="translated">标准库实现的nothrow版本(9,10)直接调用相应的throwing版本(1,2)。标准库实现的siz-aware deallocation函数(5-8)直接调用对应的siz-unaware deallocation函数(1-4)。标准库实现的大小不知道的抛数组形式(2,4)直接调用相应的单对象形式(1,3)。</target>
        </trans-unit>
        <trans-unit id="6f67e8db943a7e5f11fa3e591652be01e6c72c81" translate="yes" xml:space="preserve">
          <source>The standard library placement forms of operator delete (13,14) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement delete (25,26) with matching signature: &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; or &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt;.</source>
          <target state="translated">操作符删除（13,14）的标准库放置形式不能替换，并且只能在放置new-expression不使用 &lt;code&gt;::new&lt;/code&gt; 语法的情况下进行自定义，方法是提供特定于类的放置删除（25,26）匹配的签名： &lt;code&gt;void T::operator delete(void*, void*)&lt;/code&gt; 或 &lt;code&gt;void T::operator delete[](void*, void*)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f331f596fff7bf452e9368230c890e4ad858b73" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::bit_and&lt;/code&gt; ，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="51b8639942df5edd3c966b0d456710b62ece3289" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::bit_not&lt;/code&gt; ，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="3f85f5fb8d6b87c4f54a098871a34860fd38598a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::bit_or&lt;/code&gt; ，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="0cf5638980a6e182479f5dbc4a0b88370ff66486" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::bit_xor&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::bit_xor&lt;/code&gt; ，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="b457595199deea57bcd493866c929556b33e76c3" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::divides&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::divides&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="424b00c8e42201af9548ab0448e6ee7a2e60cfef" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::equal_to&lt;/code&gt; ，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="445dfbf3571b7bf4a2bdaa8ee7d29b4668dc155f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::greater&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="2e57796087a77aba47733fc29c950505cf26b1be" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::greater_equal&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="d03ee57547fa44cc25d3f2cc6819498bf61e5b4f" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::less&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="1df3c94ad21dfdfe9d3b7d094b740848f19b97b6" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::less_equal&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::less_equal&lt;/code&gt; ，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="c43777e85f59e5d1bbafcf4b62e738707fc73cc8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_and&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">标准库提供 &lt;code&gt;std::logical_and&lt;/code&gt; 的特殊化功能，当未指定 &lt;code&gt;T&lt;/code&gt; 时，可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="22cce0c9b0e471c051bc216994974900fed662a5" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_not&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::logical_not&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="b18a6f7d7f176eaa205b868246f5b1e0eaa0fbbe" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::logical_or&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::logical_or&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="4a1acb46cad97b294ab7069cf7f2c49e0f7cf8b1" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::minus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::minus&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="6416b0b039efddd187d08d4923fac1b5ea6b2919" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::modulus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::modulus&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="9e894075f88d07cc0fe2281d2c4c9b7877d9b39c" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::multiplies&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::multiplies&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="f5aca230aea77b0bd8892a57f74c1c692d9e92c8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::negate&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::negate&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="3a6ba7f3f95659a4fcbc1e1535d8d51d3f4d4522" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::not_equal_to&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::not_equal_to&lt;/code&gt; ，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="b5b5790ca4e3a36f7013249f817e8e9a00cbb0f8" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::owner_less&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified. In this case, the parameter types are deduced from the arguments (each of which must still be either a &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">标准库提供的特化 &lt;code&gt;std::owner_less&lt;/code&gt; 时 &lt;code&gt;T&lt;/code&gt; 没有被指定。在这种情况下，参数类型由参数推导（每个参数仍必须是 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="120610675bef9d2af7c4846670094bb75886286b" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::plus&lt;/code&gt; when &lt;code&gt;T&lt;/code&gt; is not specified, which leaves the parameter types and return type to be deduced.</source>
          <target state="translated">当未指定 &lt;code&gt;T&lt;/code&gt; 时，标准库提供 &lt;code&gt;std::plus&lt;/code&gt; 的特殊化，从而可以推导出参数类型和返回类型。</target>
        </trans-unit>
        <trans-unit id="e47ae8777ca4465b596890ef95a90b212d5b7e1a" translate="yes" xml:space="preserve">
          <source>The standard library provides a specialization of &lt;code&gt;std::vector&lt;/code&gt; for the type &lt;code&gt;bool&lt;/code&gt;, which may be optimized for space efficiency.</source>
          <target state="translated">标准库为 &lt;code&gt;bool&lt;/code&gt; 类型提供了 &lt;code&gt;std::vector&lt;/code&gt; 的特殊化，可以针对空间效率进行优化。</target>
        </trans-unit>
        <trans-unit id="0fefa50e2fa7d26d5c3b1a75d91a4ce66ae1e5fa" translate="yes" xml:space="preserve">
          <source>The standard library provides facilities to obtain values that are returned and to catch exceptions that are thrown by asynchronous tasks (i.e. functions launched in separate threads). These values are communicated in a</source>
          <target state="translated">标准库提供了获取返回的值和捕获异步任务(即在不同线程中启动的函数)抛出的异常的设施。这些值是在一个</target>
        </trans-unit>
        <trans-unit id="093ef8202a6c5dfcd0f104f718c58b45c3a78863" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic&lt;/code&gt; template for the following types with additional properties that the primary template does not have:</source>
          <target state="translated">标准库为以下类型的 &lt;code&gt;std::atomic&lt;/code&gt; 模板提供了部分专业化功能，以及主模板不具备的其他属性：</target>
        </trans-unit>
        <trans-unit id="228f6a886c12bbc3f7a888fe93cf312d114dba7e" translate="yes" xml:space="preserve">
          <source>The standard library provides partial specializations of the &lt;code&gt;std::atomic_ref&lt;/code&gt; template for for all pointer types. In addition to the operations provided for all atomic types, these specializations additionally support atomic arithmetic operations appropriate to pointer types, such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">标准库为所有指针类型提供了 &lt;code&gt;std::atomic_ref&lt;/code&gt; 模板的部分专业化。除了为所有原子类型提供的操作之外，这些专业还额外支持适用于指针类型的原子算术运算，例如&lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ad36dcf418bbed48c178ac3a02f2b5e9c8c7da73" translate="yes" xml:space="preserve">
          <source>The standard library provides the following searchers:</source>
          <target state="translated">标准库提供以下检索器:</target>
        </trans-unit>
        <trans-unit id="3b2efd68490dfb7a4918757f6cf2c4bb0801f472" translate="yes" xml:space="preserve">
          <source>The standard library types that are aliases of arithmetic types (such as &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt;) may also be examined with the &lt;code&gt;std::numeric_limits&lt;/code&gt; type traits.</source>
          <target state="translated">也可以使用 &lt;code&gt;std::numeric_limits&lt;/code&gt; 类型特征来检查作为算术类型别名的标准库类型（例如 &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ffd7a9f649b4d9408cc4e3d1e7589d2c8b29d694" translate="yes" xml:space="preserve">
          <source>The standard library's non-allocating placement forms of operator new (9-10) cannot be replaced and can only be customized if the placement new-expression did not use the &lt;code&gt;::new&lt;/code&gt; syntax, by providing a class-specific placement new (19,20) with matching signature: &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; or &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt;.</source>
          <target state="translated">标准库的非分配的operator new（9-10）的放置形式无法替代的，如果放置新的表达没有使用只能定制 &lt;code&gt;::new&lt;/code&gt; 语法，通过提供一类特定的新位置（19， 20）具有匹配的签名： &lt;code&gt;void* T::operator new(size_t, void*)&lt;/code&gt; 或 &lt;code&gt;void* T::operator new[](size_t, void*)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4981b4624e460e124e89bf34f4ff3f0393f76006" translate="yes" xml:space="preserve">
          <source>The standard output objects &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; have their &lt;code&gt;unitbuf&lt;/code&gt; bit set by default.</source>
          <target state="translated">默认情况下，标准输出对象 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::wcerr&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;unitbuf&lt;/code&gt; 位置1。</target>
        </trans-unit>
        <trans-unit id="9e153cc38ba0d2871317e848fbb767c71742cdb1" translate="yes" xml:space="preserve">
          <source>The standard recommends that a &lt;a href=&quot;../../chrono/steady_clock&quot;&gt;&lt;code&gt;steady_clock&lt;/code&gt;&lt;/a&gt; is used to measure the duration. If an implementation uses a &lt;a href=&quot;../../chrono/system_clock&quot;&gt;&lt;code&gt;system_clock&lt;/code&gt;&lt;/a&gt; instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">该标准建议使用&lt;a href=&quot;../../chrono/steady_clock&quot;&gt; &lt;code&gt;steady_clock&lt;/code&gt; &lt;/a&gt;来测量持续时间。如果实现改为使用&lt;a href=&quot;../../chrono/system_clock&quot;&gt; &lt;code&gt;system_clock&lt;/code&gt; &lt;/a&gt;，则等待时间也可能对时钟调整敏感。</target>
        </trans-unit>
        <trans-unit id="4670d79858faa026fd927ad092884ff7288c02f9" translate="yes" xml:space="preserve">
          <source>The standard recommends that a steady clock is used to measure the duration. If an implementation uses a system clock instead, the wait time may also be sensitive to clock adjustments.</source>
          <target state="translated">标准建议使用稳定的时钟来测量持续时间。如果一个实现使用系统时钟,等待时间也可能对时钟调整敏感。</target>
        </trans-unit>
        <trans-unit id="3e741a6a70c81c69a623d13af6d5fd11444c21c7" translate="yes" xml:space="preserve">
          <source>The standard signed integer types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt;;</source>
          <target state="translated">标准的带符号整数类型：带 &lt;code&gt;signed char&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; 和 &lt;code&gt;long long&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="f7faa7d4edc03214148f1c3967ed705a6e4cf33e" translate="yes" xml:space="preserve">
          <source>The standard specializations of &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; return the pattern &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; 的标准专业化返回模式 &lt;code&gt;{symbol, sign, none, value}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="297a7545b93be6b8ae2bf103d5942d598d8acf23" translate="yes" xml:space="preserve">
          <source>The standard unsigned integer types: &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, and &lt;code&gt;unsigned long long&lt;/code&gt;;</source>
          <target state="translated">标准的无符号整数类型： &lt;code&gt;unsigned char&lt;/code&gt; ， &lt;code&gt;unsigned short&lt;/code&gt; ， &lt;code&gt;unsigned int&lt;/code&gt; ， &lt;code&gt;unsigned long&lt;/code&gt; 和 &lt;code&gt;unsigned long long&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="b3faee826fe7d429ac217f2296c04e167f193a78" translate="yes" xml:space="preserve">
          <source>The start of the get area, for all writeable &lt;code&gt;std::strstreambuf&lt;/code&gt; objects constructed through the interface provided by &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;, is also the start of the put area.</source>
          <target state="translated">对于通过 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; 提供的接口构造的所有可写 &lt;code&gt;std::strstreambuf&lt;/code&gt; 对象，获取区域的开始也是放置区域的开始。</target>
        </trans-unit>
        <trans-unit id="29e1675652ac7f6393431e47f0ec2642d6a47e2b" translate="yes" xml:space="preserve">
          <source>The starting directory has depth of 0, its subdirectories have depth 1, etc.</source>
          <target state="translated">起始目录的深度为0,其子目录的深度为1,以此类推。</target>
        </trans-unit>
        <trans-unit id="9c4774217cf581390531d456216df78cfba88d58" translate="yes" xml:space="preserve">
          <source>The state of &lt;code&gt;A&lt;/code&gt; includes the state of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">的状态 &lt;code&gt;A&lt;/code&gt; 包括的状态 &lt;code&gt;B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf3c2fc8c65fee8f63cb40617161a425c9833d2a" translate="yes" xml:space="preserve">
          <source>The statement that begins with &lt;code&gt;if constexpr&lt;/code&gt; is known as the</source>
          <target state="translated">以 &lt;code&gt;if constexpr&lt;/code&gt; 开头的语句称为</target>
        </trans-unit>
        <trans-unit id="8d7a45218be20de00c71ea80e61b6068a9ec7bbd" translate="yes" xml:space="preserve">
          <source>The static data members &lt;code&gt;nom&lt;/code&gt; and &lt;code&gt;den&lt;/code&gt; representing the numerator and denominator are calculated by dividing &lt;code&gt;Num&lt;/code&gt; and &lt;code&gt;Denom&lt;/code&gt; by their greatest common divisor. However, two &lt;code&gt;std::ratio&lt;/code&gt; with different &lt;code&gt;Num&lt;/code&gt; or &lt;code&gt;Denom&lt;/code&gt; are distinct types even if they represent the same rational number (after reduction). A &lt;code&gt;ratio&lt;/code&gt; type can be reduced to the lowest terms via its &lt;code&gt;type&lt;/code&gt; member: &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; is &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">表示分子和分母的静态数据成员 &lt;code&gt;nom&lt;/code&gt; 和 &lt;code&gt;den&lt;/code&gt; 是通过将 &lt;code&gt;Num&lt;/code&gt; 和 &lt;code&gt;Denom&lt;/code&gt; 除以它们的最大公约数来计算的。但是，具有不同 &lt;code&gt;Num&lt;/code&gt; 或 &lt;code&gt;Denom&lt;/code&gt; 的两个 &lt;code&gt;std::ratio&lt;/code&gt; 是不同的类型，即使它们表示相同的有理数（在归约后）也是如此。甲 &lt;code&gt;ratio&lt;/code&gt; 类型可以通过其被减少到最低术语 &lt;code&gt;type&lt;/code&gt; 构件： &lt;code&gt;std::ratio&amp;lt;3, 6&amp;gt;::type&lt;/code&gt; 是 &lt;code&gt;std::ratio&amp;lt;1, 2&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0f731b0d49e9b2f3318f0fcd7bbe6ca8c907339" translate="yes" xml:space="preserve">
          <source>The status of the file referred to by the entry.</source>
          <target state="translated">条目所涉及的文件的状态。</target>
        </trans-unit>
        <trans-unit id="6e3ebc55efb178a42fb9d7d48d59cf130b8a23d3" translate="yes" xml:space="preserve">
          <source>The status of the pending recursion flag can be queried with &lt;a href=&quot;recursion_pending&quot;&gt;&lt;code&gt;recursion_pending()&lt;/code&gt;&lt;/a&gt;, which is &lt;code&gt;false&lt;/code&gt; after this call. It is reset back to &lt;code&gt;true&lt;/code&gt; after &lt;a href=&quot;increment&quot;&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/a&gt;, and its initial value is also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">可以使用&lt;a href=&quot;recursion_pending&quot;&gt; &lt;code&gt;recursion_pending()&lt;/code&gt; &lt;/a&gt;查询挂起的递归标志的状态，此调用之后为 &lt;code&gt;false&lt;/code&gt; 。&lt;a href=&quot;increment&quot;&gt; &lt;code&gt;increment&lt;/code&gt; &lt;/a&gt;后将其重置为 &lt;code&gt;true&lt;/code&gt; ，并且其初始值也为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cb43bc5c74e77ae80142a18f784fbac3e0c33b7" translate="yes" xml:space="preserve">
          <source>The stem of the filename identified by the path (i.e. the filename without the final extension).</source>
          <target state="translated">由路径确定的文件名(即没有最后扩展名的文件名)。</target>
        </trans-unit>
        <trans-unit id="11590b2e7256668527e3216f99ac4fd9c7a4d00b" translate="yes" xml:space="preserve">
          <source>The storage class specifiers are a part of the decl-specifier-seq of a name's &lt;a href=&quot;declarations&quot;&gt;declaration syntax&lt;/a&gt;. Together with the &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; of the name, they control two independent properties of the name: its</source>
          <target state="translated">存储类说明符是名称&lt;a href=&quot;declarations&quot;&gt;声明语法&lt;/a&gt;的decl-specifier-seq的一部分。与名称的&lt;a href=&quot;scope&quot;&gt;范围&lt;/a&gt;一起，它们控制名称的两个独立属性：</target>
        </trans-unit>
        <trans-unit id="2f39d087c3a629b33b3a42976145e493b6fa58f5" translate="yes" xml:space="preserve">
          <source>The storage of a deque is automatically expanded and contracted as needed. Expansion of a deque is cheaper than the expansion of a &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; because it does not involve copying of the existing elements to a new memory location. On the other hand, deques typically have large minimal memory cost; a deque holding just one element has to allocate its full internal array (e.g. 8 times the object size on 64-bit libstdc++; 16 times the object size or 4096 bytes, whichever is larger, on 64-bit libc++).</source>
          <target state="translated">双端队列的存储会根据需要自动扩展和收缩。扩展双端队列比扩展 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 便宜，因为它不涉及将现有元素复制到新的内存位置。另一方面，双端队列通常具有很大的最小存储成本。仅持有一个元素的双端队列必须分配其完整的内部数组（例如，在64位libstdc ++上为对象大小的8倍；在64位libc ++上为对象大小的16倍或4096字节，以较大者为准）。</target>
        </trans-unit>
        <trans-unit id="b072292a5a1e2322c8e92bfdf268810f5282c203" translate="yes" xml:space="preserve">
          <source>The storage of the vector is handled automatically, being expanded and contracted as needed. Vectors usually occupy more space than static arrays, because more memory is allocated to handle future growth. This way a vector does not need to reallocate each time an element is inserted, but only when the additional memory is exhausted. The total amount of allocated memory can be queried using &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; function.  Extra memory can be returned to the system via a call to &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt;.(since C++11).</source>
          <target state="translated">向量的存储是自动处理的，可以根据需要进行扩展和收缩。向量通常比静态数组占用更多的空间，因为分配了更多的内存来处理将来的增长。这样，向量不必在每次插入元素时都重新分配，而仅在附加内存耗尽时才需要重新分配。可以使用 &lt;code&gt;&lt;a href=&quot;vector/capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 函数查询已分配的内存总量。自C ++ 11起，可以通过调用 &lt;code&gt;&lt;a href=&quot;vector/shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; 将多余的内存返回给系统。</target>
        </trans-unit>
        <trans-unit id="5892901fc4af7c4daeffcdff331dcbef5c156bb6" translate="yes" xml:space="preserve">
          <source>The stored callable object is called the</source>
          <target state="translated">存储的可调用对象被称为</target>
        </trans-unit>
        <trans-unit id="80952d2ca5513e2ab7bc4e81a28581ccd51f605f" translate="yes" xml:space="preserve">
          <source>The stored deleter object.</source>
          <target state="translated">存储的deleter对象。</target>
        </trans-unit>
        <trans-unit id="17b16ef531268271e85ec6f43ec173d4f90c59ff" translate="yes" xml:space="preserve">
          <source>The stored duration.</source>
          <target state="translated">储存的持续时间。</target>
        </trans-unit>
        <trans-unit id="09a69b97d4bafa467ed76343a615b25a40c0cb70" translate="yes" xml:space="preserve">
          <source>The stored error category.</source>
          <target state="translated">存储的错误类别。</target>
        </trans-unit>
        <trans-unit id="2281cefb9cf8d901883c448695a82804629a024b" translate="yes" xml:space="preserve">
          <source>The stored error code.</source>
          <target state="translated">存储的错误代码。</target>
        </trans-unit>
        <trans-unit id="8af42892a4e54ba3e506e55de93429bf0536f70e" translate="yes" xml:space="preserve">
          <source>The stored pointer.</source>
          <target state="translated">存储的指针。</target>
        </trans-unit>
        <trans-unit id="433b5f42f978f29dcfd09128154cee8fea3f71e9" translate="yes" xml:space="preserve">
          <source>The stored reference.</source>
          <target state="translated">存储的引用。</target>
        </trans-unit>
        <trans-unit id="6c6f751d334cb9f8c0297588312a1852b3d27541" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;promise_already_satisfied&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">存储的任务已被调用。错误类别设置为&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;promise_already_satisfied&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4df572d2c0e354b7f394388b3d124d21e95f48d8" translate="yes" xml:space="preserve">
          <source>The stored task has already been invoked. The error category is set to &lt;code&gt;promise_already_satisfied&lt;/code&gt;.</source>
          <target state="translated">存储的任务已被调用。错误类别设置为 &lt;code&gt;promise_already_satisfied&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="657cc28deb3f80f24e72e3ed2e272bb85d039858" translate="yes" xml:space="preserve">
          <source>The stream-based I/O library uses &lt;a href=&quot;io/manip&quot;&gt; I/O manipulators&lt;/a&gt; (e.g. &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt;, etc.) to control how streams behave.</source>
          <target state="translated">基于流的I / O库使用&lt;a href=&quot;io/manip&quot;&gt;I / O操纵器&lt;/a&gt;（例如 &lt;code&gt;&lt;a href=&quot;io/manip/boolalpha&quot;&gt;std::boolalpha&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;io/manip/hex&quot;&gt;std::hex&lt;/a&gt;&lt;/code&gt; 等）来控制流的行为。</target>
        </trans-unit>
        <trans-unit id="f1f8e1bf31666f17d818c7fb3629dbe63dce8038" translate="yes" xml:space="preserve">
          <source>The stream-based input/output library is organized around abstract input/output devices. These abstract devices allow the same code to handle input/output to files, memory streams, or custom adaptor devices that perform arbitrary operations (e.g. compression) on the fly.</source>
          <target state="translated">基于流的输入/输出库是围绕抽象的输入/输出设备组织的。这些抽象设备允许相同的代码处理对文件、内存流或自定义适配器设备的输入/输出,这些设备在运行中执行任意操作(如压缩)。</target>
        </trans-unit>
        <trans-unit id="685e0728588ef7b354ca6ae06a3e39b651660d7d" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt;&lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt; if the streambuf argument is a null pointer or if no characters were inserted into the streambuf.</source>
          <target state="translated">&lt;a href=&quot;../basic_istream/operator_gtgt&quot;&gt; &lt;code&gt;basic_istream::operator&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;的streambuf重载，如果streambuf参数为空指针，或者没有字符插入streambuf中。</target>
        </trans-unit>
        <trans-unit id="2d18ba3c4f605fc8501feb5b3351b46aa1577fcc" translate="yes" xml:space="preserve">
          <source>The streambuf overload of &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;&lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; if the function inserts no characters.</source>
          <target state="translated">如果函数不插入任何字符，则&lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt; &lt;code&gt;basic_ostream::operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;的streambuf重载。</target>
        </trans-unit>
        <trans-unit id="1ef23ffa702914245f81e5026dac9d4ebc2e587a" translate="yes" xml:space="preserve">
          <source>The string converted to the specified floating point type.</source>
          <target state="translated">转换为浮点类型的字符串。</target>
        </trans-unit>
        <trans-unit id="47c093236b31b3a204fe8f923fb21ca46aefe47b" translate="yes" xml:space="preserve">
          <source>The string converted to the specified signed integer type.</source>
          <target state="translated">转换为指定的带符号整数类型的字符串。</target>
        </trans-unit>
        <trans-unit id="ce8f7eeb006b0c3d2b2b94eccb0b5ba0bb13623e" translate="yes" xml:space="preserve">
          <source>The string converted to the specified unsigned integer type.</source>
          <target state="translated">将字符串转换为指定的无符号整数类型。</target>
        </trans-unit>
        <trans-unit id="90cd8c741b9656548cd7c47ccb8f4e7b236d4d51" translate="yes" xml:space="preserve">
          <source>The string input function &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; if it completes by reaching the end of the stream, as opposed to reaching the specified terminating character.</source>
          <target state="translated">字符串输入函数 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;&lt;/code&gt; 是否通过到达流的末尾而不是到达指定的终止字符来完成。</target>
        </trans-unit>
        <trans-unit id="fe144c3255daec881252d2a4f155b9abf0e72d73" translate="yes" xml:space="preserve">
          <source>The string library also provides class template &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; that defines types and functions for &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;(since C++17). The following specializations are defined:</source>
          <target state="translated">字符串库还提供了类模板 &lt;code&gt;&lt;a href=&quot;string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; ，用于定义 &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 类型和函数（自C ++ 17起）。定义了以下专业：</target>
        </trans-unit>
        <trans-unit id="7a1c4ed4b5630d5ddaa1db0afbceba65c0447876" translate="yes" xml:space="preserve">
          <source>The string literal.</source>
          <target state="translated">字符串。</target>
        </trans-unit>
        <trans-unit id="fe351b72d36bc72e8b0524c53861ac272e34795a" translate="yes" xml:space="preserve">
          <source>The string of type &lt;code&gt;string_type&lt;/code&gt; holding the characters to be used as positive or negative sign.</source>
          <target state="translated">类型为 &lt;code&gt;string_type&lt;/code&gt; 的字符串，其中包含要用作正号或负号的字符。</target>
        </trans-unit>
        <trans-unit id="645bada75f5704a14a70ee6b3ad9c4dbbc4a0cd1" translate="yes" xml:space="preserve">
          <source>The string transformed so that lexicographic comparison of the transformed strings may be used instead of collating of the originals. In the &quot;C&quot; locale, the returned string is the exact copy of &lt;code&gt;[low, high)&lt;/code&gt;. In other locales, the contents of the returned string are implementation-defined, and the size may be considerably longer.</source>
          <target state="translated">转换后的字符串，以便可以对转换后的字符串进行字典比较，而不是对原始字符串进行整理。在&amp;ldquo; C&amp;rdquo;语言环境中，返回的字符串是 &lt;code&gt;[low, high)&lt;/code&gt; 的精确副本。在其他语言环境中，返回字符串的内容是实现定义的，并且大小可能会更长。</target>
        </trans-unit>
        <trans-unit id="bed8f4fdf0727af913eee7d7f8de3facf8e379a9" translate="yes" xml:space="preserve">
          <source>The string_literal is typically a short program written in assembly language, which is executed whenever this declaration is executed. Different C++ compilers have wildly varying rules for asm-declarations, and different conventions for the interaction with the surrounding C++ code.</source>
          <target state="translated">string_literal通常是一个用汇编语言编写的短程序,每当这个声明被执行时,就会被执行。不同的C++编译器对asm-declarations的规则千差万别,与周围C++代码的交互也有不同的约定。</target>
        </trans-unit>
        <trans-unit id="f3fd3bc3bb5bbc2174bee8f5c8d22f3d7dbcda9d" translate="yes" xml:space="preserve">
          <source>The string_view literal.</source>
          <target state="translated">string_view字面意思。</target>
        </trans-unit>
        <trans-unit id="9ed1cae434c8ab95486c8c0f6cf75e8ebd7662a2" translate="yes" xml:space="preserve">
          <source>The struct combines the performance and accessibility of a C-style array with the benefits of a standard container, such as knowing its own size, supporting assignment, random access iterators, etc.</source>
          <target state="translated">该结构结合了C式数组的性能和可访问性,以及标准容器的优点,如知道自己的大小,支持赋值,随机访问迭代器等。</target>
        </trans-unit>
        <trans-unit id="771b48d395936f4ddd7641ad97ebda6634abdf95" translate="yes" xml:space="preserve">
          <source>The subscript operator expressions have the form.</source>
          <target state="translated">下标运算符表达式的形式。</target>
        </trans-unit>
        <trans-unit id="1ee3ffed03585e5f9ff776a096eb8348d437e9c7" translate="yes" xml:space="preserve">
          <source>The substitution of template arguments into a requires-expression used in a declaration of a &lt;a href=&quot;templates#Templated_entity&quot;&gt;templated entity&lt;/a&gt; may result in the formation of invalid types or expressions in its requirements, or the violation of semantic constraints of those requirements. In such cases, the requires-expression evaluates to &lt;code&gt;false&lt;/code&gt; and does not cause the program to be ill-formed. The substitution and semantic constraint checking proceeds in lexical order and stops when a condition that determines the result of the requires-expression is encountered. If substitution (if any) and semantic constraint checking succeed, the requires-expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">将模板参数替换为模板&lt;a href=&quot;templates#Templated_entity&quot;&gt;实体&lt;/a&gt;的声明中使用的require-表达式可能会导致其要求中形成无效的类型或表达式，或者违反这些要求的语义约束。在这种情况下，requires表达式的计算结果为 &lt;code&gt;false&lt;/code&gt; ，并且不会导致程序格式错误。替换和语义约束检查以词法顺序进行，并在遇到确定require-expression结果的条件时停止。如果替换（如果有）和语义约束检查成功，则require-expression的计算结果为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2246f7cf19b24f35ba44d7128f9f00cdf8cea437" translate="yes" xml:space="preserve">
          <source>The sum of the elements.</source>
          <target state="translated">元素之和。</target>
        </trans-unit>
        <trans-unit id="89d93f088c99aca77c5be8b564b1d94b144b5b67" translate="yes" xml:space="preserve">
          <source>The sum of the returned value and the value stored in &lt;code&gt;*iptr&lt;/code&gt; gives &lt;code&gt;x&lt;/code&gt; (allowing for rounding).</source>
          <target state="translated">返回值与 &lt;code&gt;*iptr&lt;/code&gt; 中存储的值之和为 &lt;code&gt;x&lt;/code&gt; （允许四舍五入）。</target>
        </trans-unit>
        <trans-unit id="ff4ca6cf4d2e109c127290c18455fd2a7491a92c" translate="yes" xml:space="preserve">
          <source>The supplied lock &lt;code&gt;lk&lt;/code&gt; is held until the thread exits. Once this function has been called, no more threads may acquire the same lock in order to wait on &lt;code&gt;cond&lt;/code&gt;. If some thread is waiting on this condition variable, it should not attempt to release and reacquire the lock when it wakes up spuriously.</source>
          <target state="translated">所提供的锁 &lt;code&gt;lk&lt;/code&gt; 一直保持到线程退出。调用此函数后，不再有线程可以获取相同的锁以等待 &lt;code&gt;cond&lt;/code&gt; 。如果某个线程正在等待此条件变量，则当它虚假唤醒时，它不应尝试释放并重新获取该锁。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
