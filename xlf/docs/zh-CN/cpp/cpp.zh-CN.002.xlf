<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="419ec8df85caf452084df24b9de678dedfbc50bf" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;Key&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; in order to use overloads (1-2).</source>
          <target state="translated">- &lt;code&gt;Key&lt;/code&gt; 必须满足&lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;的要求才能使用重载（1-2）。</target>
        </trans-unit>
        <trans-unit id="a4e09b6b6e2a7b3a2ac2a06b04359abecdd52cc3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;Key&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (3-6). The ordering relation must establish total order.</source>
          <target state="translated">- &lt;code&gt;Key&lt;/code&gt; 必须满足&lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;的要求才能使用重载（3-6）。订购关系必须建立总订单。</target>
        </trans-unit>
        <trans-unit id="b9361c83e3b358d5a3956e330cbd7371301b7ad7" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt1, OutputIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt1, OutputIt2&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="698247f9c442eed3999e5a308ab1fc6756e36992" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="55c36864300a0332162362f1e29021f2ab4046bf" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="deed4a8e960de7cf907cc39e9c0acfd7ac778bf6" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e86ead3f4d883e644468b1c73f514708a02964c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;. both &lt;code&gt;acc&lt;/code&gt; (the accumulated value) and the result of &lt;code&gt;val - acc&lt;/code&gt; or &lt;code&gt;op(val, acc)&lt;/code&gt;(until C++20)&lt;code&gt;val - std::move(acc)&lt;/code&gt; or &lt;code&gt;op(val, std::move(acc))&lt;/code&gt;(since C++20) must be writable to &lt;code&gt;OutputIt&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;。两个 &lt;code&gt;acc&lt;/code&gt; （累计值）和的结果 &lt;code&gt;val - acc&lt;/code&gt; 或 &lt;code&gt;op(val, acc)&lt;/code&gt; 直至C ++ 20） &lt;code&gt;val - std::move(acc)&lt;/code&gt; 或 &lt;code&gt;op(val, std::move(acc))&lt;/code&gt; （因为C ++ 20）必须可 &lt;code&gt;OutputIt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29da965fe354af11657ff5012d6cd7bb66771aa3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;PopulationIterator&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;PopulationIterator&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d962f474ba3dfaef590a955a0518ed4efa12212e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;PopulationIterator&lt;/code&gt;'s value type must be writeable to &lt;code&gt;out&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;PopulationIterator&lt;/code&gt; 的值类型必须是可写来 &lt;code&gt;out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71157d30139e1a4b4b81eda084b08fc43eb764e1" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d2f607ae40468ef5797894774fc38482f0178173" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="98251c9b55e7f4abf11f37378ad898be6c5fadbe" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/valueswappable&quot;&gt;ValueSwappable&lt;/a&gt; and &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/valueswappable&quot;&gt;ValueSwappable&lt;/a&gt;和&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eaa2c05a56bacd05704242d3bd6df30c4b6e4975" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;SampleIterator&lt;/code&gt; must also meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; if &lt;code&gt;PopulationIterator&lt;/code&gt; doesn't meet &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">- 如果 &lt;code&gt;PopulationIterator&lt;/code&gt; 不符合&lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;，则&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;SampleIterator&lt;/a&gt;还必须满足 &lt;code&gt;SampleIterator&lt;/code&gt; 的要求</target>
        </trans-unit>
        <trans-unit id="d5cd603525645d89d81ecb0a97fa5b1104647059" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;SampleIterator&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;SampleIterator&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c4c58a4b3733fe1a63015c88ad95da66afcddc7" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;Searcher&lt;/code&gt; must meet the requirements of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;Searcher&lt;/code&gt; 必须满足的要求&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;搜索者&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49b4b6f9f94d3a83ae0da6bac2f0d41b3f5ec92f" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;State&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;State&lt;/code&gt; 必须满足的要求，&lt;a href=&quot;../named_req/destructible&quot;&gt;可破坏的&lt;/a&gt;，&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;，&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;和&lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;可缺省&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5a348b317d61568eab4c548d7c228a34e3f64305" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (if init is provided)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T (if init is provided)&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;。所有 &lt;code&gt;binary_op(init, *first)&lt;/code&gt; ， &lt;code&gt;binary_op(init, init)&lt;/code&gt; 和 &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; 必须都可以转换为T</target>
        </trans-unit>
        <trans-unit id="c2a5020c510f0262502557c93ed89e0865951c7c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (if init is provided)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T (if init is provided)&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;。所有 &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; ， &lt;code&gt;binary_op(init, init)&lt;/code&gt; 和 &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; 必须都可以转换为T</target>
        </trans-unit>
        <trans-unit id="7810d2997b36f05550f6cb1bf31a4fa633ff590f" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="905e21cacfad5c81bbffce9900de32849620bb35" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;，&lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;和&lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5106e515e150117a5ed081858723525bce75264" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;和&lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="084180c1730ee9ff3511af3a7074aed52956ecd0" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T, Key&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; in order to use overloads (1-2).</source>
          <target state="translated">- &lt;code&gt;T, Key&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;是相等性&lt;/a&gt;，以使用过载（1-2）。</target>
        </trans-unit>
        <trans-unit id="fa70cdcafe4b0432bf8e4d5ec413cbc51a7d1ce1" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T2&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/swappable&quot;&gt;拔插&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff7f4cc18db9ac03597b82461300318cff643a4e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be a complete object type for overload (2)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须是过载一个完整的对象类型（2）</target>
        </trans-unit>
        <trans-unit id="22d8a29c2d428307356a96301dfe48b10dd001df" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be an arithmetic type other than &lt;code&gt;bool&lt;/code&gt; for overload (1)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须比其他的运算类型 &lt;code&gt;bool&lt;/code&gt; 为过载（1）</target>
        </trans-unit>
        <trans-unit id="d4b7bba184604960afabdacbe04cef7c29efc646" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be constructible from &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Args...&lt;/code&gt; for overload (2)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须从constructible &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;Args...&lt;/code&gt; 为过载（2）</target>
        </trans-unit>
        <trans-unit id="14bba7cc3b7a63c191dec2116f925714b85fb80e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be constructible from &lt;code&gt;Args...&lt;/code&gt; for overload (1)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须从constructible &lt;code&gt;Args...&lt;/code&gt; 为过载（1）</target>
        </trans-unit>
        <trans-unit id="cffb5df90bd109b7434a393187dfa1b30b748828" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- 为了使用重载（1）， &lt;code&gt;T&lt;/code&gt; 必须满足&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;和&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="7930781c7243e63a8390ec04eb0aa2c04af85f82" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (3).</source>
          <target state="translated">- 为了使用重载（3）， &lt;code&gt;T&lt;/code&gt; 必须满足&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;和&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="471088387fa31e08d2a02da4c72d9a7a716ef167" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;复制构造&lt;/a&gt;以使用过载（1）。</target>
        </trans-unit>
        <trans-unit id="73f5abb3110caba0a3cbfda038bb47a33bd701aa" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;以使用过载（1）。</target>
        </trans-unit>
        <trans-unit id="e73f59dbfdbaf5c4dcce09ce496037063fb9358b" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;以使用过载（2）。</target>
        </trans-unit>
        <trans-unit id="eb108a09e5c7c38be67b06f6c9bffab1dded20be" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt;以使用过载（1）。</target>
        </trans-unit>
        <trans-unit id="81a64d3f2c5aed9f2ea58d39ee0dc7d25692b198" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; in order to use overload (4,5).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;以使用过载（4,5）。</target>
        </trans-unit>
        <trans-unit id="f777ee2027b95d030923b905f9b74c5248eea4b9" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; in order to use overloads (1-2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable的&lt;/a&gt;以使用过载（1-2）。</target>
        </trans-unit>
        <trans-unit id="96a89708385e36960066ed1cb1ad4a6270b18f9e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;是相等性&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f655a15216004caebe0d4c1842ff1c7c85e72dc8" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (3-6). The ordering relation must establish total order.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;小于关系&lt;/a&gt;，以使用过载（3-6）。订购关系必须建立总订单。</target>
        </trans-unit>
        <trans-unit id="8bc0ec3645431f4a729c83f7d0b332dedc67a6c2" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- 为了使用重载（2）， &lt;code&gt;T&lt;/code&gt; 必须满足&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;和&lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="83b8abfb3b109f24460367855ff84231d42acd86" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (4). required only if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; but not &lt;a href=&quot;../../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;. (until C++17)</source>
          <target state="translated">- 为了使用重载（4）， &lt;code&gt;T&lt;/code&gt; 必须满足&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;和&lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;的要求。仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;而不是&lt;a href=&quot;../../named_req/forwarditerator&quot;&gt;LegacyForwardIterator时才需要&lt;/a&gt;。（直到C ++ 17）</target>
        </trans-unit>
        <trans-unit id="46f5218ad771272834f2938c2efb000b08e092d8" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a30288177c8d2ae9070305e88321759803254602" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;以使用过载（2）。</target>
        </trans-unit>
        <trans-unit id="df2dc067304b7bdd11cb64bd744da7390dc15e7c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- 为了使用重载（1）， &lt;code&gt;T&lt;/code&gt; 必须满足&lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;和&lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="c75ea7942181849fe154d4fe56f7d5a7e8e077b3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;以使用过载（2）。</target>
        </trans-unit>
        <trans-unit id="dd12a83a8a21dd2faf8db14c717a62119dacb3df" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="955e988bcc8c424fa42f194f883da98cda7a48a2" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (4,5). (since C++17)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../../named_req/swappable&quot;&gt;可交换&lt;/a&gt;，&lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;，&lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;和&lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;以使用过载（4,5）。（自C ++ 17起）</target>
        </trans-unit>
        <trans-unit id="afbeaf062ea6fd0595970eeb503e2e6f5c5e7744" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;和&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab460245f5ca1cfa08f3d1ec2722e5c78976ffcb" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; in order to use overloads (3,4).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求，&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;，以使用过载（3,4）。</target>
        </trans-unit>
        <trans-unit id="7b670662fdaf16909ed9b4448468795dec02b564" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;小于关系&lt;/a&gt;，以使用过载（1）。</target>
        </trans-unit>
        <trans-unit id="a320cda4651b152682eb79c8e8e99ea2769e8c5e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (1,3).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;小于关系&lt;/a&gt;，以使用过载（1,3）。</target>
        </trans-unit>
        <trans-unit id="48fe196760fc1f1946ea79d3075055f7b6aeaabd" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;和&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="32c23e4f427e0609ed933c05aa132bcda1ee2718" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overloads (2,5). and the result of the expressions &lt;code&gt;binary_op1(init, binary_op2(*first1, *first2))&lt;/code&gt;, &lt;code&gt;binary_op1(binary_op2(*first1, *first2), init)&lt;/code&gt;, &lt;code&gt;binary_op1(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;以使用过载（2,5）。以及结果的结果 &lt;code&gt;binary_op1(init, binary_op2(*first1, *first2))&lt;/code&gt; ， &lt;code&gt;binary_op1(binary_op2(*first1, *first2), init)&lt;/code&gt; ， &lt;code&gt;binary_op1(init, init)&lt;/code&gt; 和 &lt;code&gt;binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))&lt;/code&gt; 必须可转换为T</target>
        </trans-unit>
        <trans-unit id="b61c2e4c2acdbcf060f22b54d7687f0c61f22811" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overloads (3,6). and the result of the expressions &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(unary_op(*first), init)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;以使用过载（3,6）。以及结果的结果 &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; ， &lt;code&gt;binary_op(unary_op(*first), init)&lt;/code&gt; ， &lt;code&gt;binary_op(init, init)&lt;/code&gt; 和 &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; 必须可转换为T</target>
        </trans-unit>
        <trans-unit id="735f48ddde8598786438eb6c8a0e27a9a20e41fa" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;。所有的 &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; ， &lt;code&gt;binary_op(init, init)&lt;/code&gt; 和 &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; 必须可转换为 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4830e7790cb0a3a97c614ec99dee4fd4f76bde82" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. Also, it must be possible to move-assign objects of type &lt;code&gt;U&lt;/code&gt; to objects of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;。同样，必须有可能将 &lt;code&gt;U&lt;/code&gt; 类型的对象移动到 &lt;code&gt;T&lt;/code&gt; 类型的对象</target>
        </trans-unit>
        <trans-unit id="070995c3e11380f1a759c287d70004246a336f84" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. and &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(*first, init)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;。和 &lt;code&gt;binary_op(init, *first)&lt;/code&gt; ， &lt;code&gt;binary_op(*first, init)&lt;/code&gt; ， &lt;code&gt;binary_op(init, init)&lt;/code&gt; 和 &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; 必须可转换为 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ebbe51e0d271ce6d4ccbb7dd18d09cb13e0244" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. and &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;。和 &lt;code&gt;binary_op(init, *first)&lt;/code&gt; ， &lt;code&gt;binary_op(init, init)&lt;/code&gt; 和 &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; 必须可转换为 &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="240b36ac63aedc5650c0eebdca5e66141ce3bde5" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;U&amp;amp;&amp;amp;&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;U&amp;amp;&amp;amp;&lt;/code&gt; 必须转换为 &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b81d5e3c63c353df7206ad9ffec731b9d09453db" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryFunction2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;UnaryFunction2&lt;/code&gt; 必须满足的要求，&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6014d7e4016480f38e962647d7142d9618786712" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryFunction&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. Does not have to be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">- &lt;code&gt;UnaryFunction&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;。不必是&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec2173dc69a67195292305ee0f463384bf04a493" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryPredicate&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/predicate&quot;&gt;Predicate&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;UnaryPredicate&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/predicate&quot;&gt;谓语&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29292267e10038a5997139362f189f03885b9b0c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;W&lt;/code&gt; must be greater than zero, and no greater than &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;UIntType&amp;gt;::digits&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;W&lt;/code&gt; 必须大于零，并且不大于 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;UIntType&amp;gt;::digits&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f89b6a8131c4a3381b15946e9051f71792126a60" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;key_type&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;key_type&lt;/code&gt; 必须满足的要求，&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="129d57481bdef249acefaffbce24cd66b9f3b73a" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;mapped_type&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;mapped_type&lt;/code&gt; 必须满足的要求，&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;和&lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;可缺省&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="debd7c798d0035e7d613bf22525a497feb4eac68" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;std::decay_t&amp;lt;ValueType&amp;gt;&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;std::decay_t&amp;lt;ValueType&amp;gt;&lt;/code&gt; 必须满足的要求，&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1d5acc57403e947250368f57577287097a8c8cc4" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;std::is_constructible_v&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;, F&amp;gt;&lt;/code&gt; is required to be true</source>
          <target state="translated">- &lt;code&gt;std::is_constructible_v&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;, F&amp;gt;&lt;/code&gt; 需要为真</target>
        </trans-unit>
        <trans-unit id="3a79a46e3b7ff92c381844fb9a39002a4b0fa232" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;value_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt;. When the default allocator is used, this means that &lt;code&gt;key_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;code&gt;mapped_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;value_type&lt;/code&gt; 必须&lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;从 &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; 。使用默认分配器时，这意味着 &lt;code&gt;key_type&lt;/code&gt; 必须为&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible，&lt;/a&gt;而 &lt;code&gt;mapped_type&lt;/code&gt; 必须为&lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d97831a170788f8d67b47b8d93ff132ec0bb8c06" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;value_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(std::move(key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt;. When the default allocator is used, this means that &lt;code&gt;key_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;code&gt;mapped_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;value_type&lt;/code&gt; 必须&lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;从 &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(std::move(key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; 。使用默认分配器时，这意味着 &lt;code&gt;key_type&lt;/code&gt; 必须为&lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible，&lt;/a&gt;而 &lt;code&gt;mapped_type&lt;/code&gt; 必须为&lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff8015eb2b1855f53bb4336bf8d4411ac6c84c5b" translate="yes" xml:space="preserve">
          <source>-E</source>
          <target state="translated">-E</target>
        </trans-unit>
        <trans-unit id="47c47adf6da44571449c368a24b1dbbce9c4896b" translate="yes" xml:space="preserve">
          <source>-No increment, assignment, comparison, or indirection through valid instances of &lt;code&gt;ForwardIt&lt;/code&gt; may throw exceptions.</source>
          <target state="translated">-通过 &lt;code&gt;ForwardIt&lt;/code&gt; 的有效实例进行的任何增量，赋值，比较或间接调用都不会引发异常。</target>
        </trans-unit>
        <trans-unit id="eb831d16a34da446211de736f7a976a6da2d183b" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;BidirIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">-取消引用的 &lt;code&gt;BidirIt&lt;/code&gt; 类型必须满足&lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;和&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="fea212bdfb63511131a24166d6cf8c37f24a9977" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;ForwardIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">-取消引用的 &lt;code&gt;ForwardIt&lt;/code&gt; 的类型必须满足&lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;和&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="9070dc7500842363fa2c05017f765046615dbb95" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;ForwardIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">-The型复引用的 &lt;code&gt;ForwardIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6111d8d5184d2a92b766306033c8f746e15ff45" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">-The型复引用的 &lt;code&gt;InputIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5f5377d372d149a9da9efea14ca7295541e3b278" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;. if &lt;code&gt;InputIt&lt;/code&gt; does not satisfy &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">-The型复引用的 &lt;code&gt;InputIt&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;。如果 &lt;code&gt;InputIt&lt;/code&gt; 不满足&lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35d8052956297290de757a81ca77db43e329f302" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;. if neither &lt;code&gt;InputIt&lt;/code&gt; nor &lt;code&gt;OutputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, or if &lt;code&gt;InputIt&lt;/code&gt; does not satisfy &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; and the value type of &lt;code&gt;InputIt&lt;/code&gt; differs from that of &lt;code&gt;OutputIt&lt;/code&gt;</source>
          <target state="translated">-The型复引用的 &lt;code&gt;InputIt&lt;/code&gt; 必须满足的要求，&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;可复制构造&lt;/a&gt;。如果既不 &lt;code&gt;InputIt&lt;/code&gt; 也不 &lt;code&gt;OutputIt&lt;/code&gt; 满足&lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;，或者如果 &lt;code&gt;InputIt&lt;/code&gt; 不满足&lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;和的值类型 &lt;code&gt;InputIt&lt;/code&gt; 从不同的 &lt;code&gt;OutputIt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1033b058712ba4bd32d56b528177040435614bb2" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">-取消引用的 &lt;code&gt;RandomIt&lt;/code&gt; 类型必须满足&lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;和&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="961a73e39e89cb3f2795f5bbf3cbdb9625270fdd" translate="yes" xml:space="preserve">
          <source>-The types of dereferenced &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;</source>
          <target state="translated">-The类型间接引用的 &lt;code&gt;ForwardIt1&lt;/code&gt; 和 &lt;code&gt;ForwardIt2&lt;/code&gt; 必须满足的要求&lt;a href=&quot;../named_req/swappable&quot;&gt;可交换&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee0fc4c6e8c36c2cdf1bf0caedd9cb01843102d7" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be &lt;code&gt;char&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; 值类型必须为 &lt;code&gt;char&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="943fa25d062c8405568c4ff3a57ad45d9288723a" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be &lt;code&gt;char&lt;/code&gt; to use the overload (7))</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; 值类型必须为 &lt;code&gt;char&lt;/code&gt; 以使用重载（7））</target>
        </trans-unit>
        <trans-unit id="386d13b86abcf4b9bca6e76ef852ed6b2ad732cb" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be one of the character types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, (since C++20)&lt;code&gt;char16_t&lt;/code&gt; and &lt;code&gt;char32_t&lt;/code&gt; to use the overload (5))</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; 值类型必须是字符类型 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;wchar_t&lt;/code&gt; ， &lt;code&gt;char8_t&lt;/code&gt; ，（自C ++ 20起） &lt;code&gt;char16_t&lt;/code&gt; 和 &lt;code&gt;char32_t&lt;/code&gt; 之一才能使用重载（5））</target>
        </trans-unit>
        <trans-unit id="85af98cd8f2584c8a1bf3193d2a9453c4a0696b3" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be one of the encoded character types (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt; and &lt;code&gt;char32_t&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;InputIt&lt;/code&gt; 值类型必须是编码的字符类型之一（ &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;wchar_t&lt;/code&gt; ， &lt;code&gt;char16_t&lt;/code&gt; 和 &lt;code&gt;char32_t&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="781c92c6f4232004d3a5ca088f526ac147d9db22" translate="yes" xml:space="preserve">
          <source>-a, where &lt;code&gt;b&lt;/code&gt; is the number of bits after promotion.</source>
          <target state="translated">-a，其中 &lt;code&gt;b&lt;/code&gt; 是提升后的位数。</target>
        </trans-unit>
        <trans-unit id="8a9cd7781044a79a622806d2c71e18d259189aab" translate="yes" xml:space="preserve">
          <source>-arg</source>
          <target state="translated">-arg</target>
        </trans-unit>
        <trans-unit id="16372868051b38c9793bfcfb1bab9865824a7cf8" translate="yes" xml:space="preserve">
          <source>-e-arg</source>
          <target state="translated">-e-arg</target>
        </trans-unit>
        <trans-unit id="36105b9bc31e91d70aff56af9dcd73894e1e5181" translate="yes" xml:space="preserve">
          <source>-e-iz</source>
          <target state="translated">-e-iz</target>
        </trans-unit>
        <trans-unit id="c6ea641826a7102b4cb61da3fbe5c8784257cca9" translate="yes" xml:space="preserve">
          <source>-e-z</source>
          <target state="translated">-e-z</target>
        </trans-unit>
        <trans-unit id="af8605005221d6158480c209167abfb0fad20613" translate="yes" xml:space="preserve">
          <source>-eiz</source>
          <target state="translated">-eiz</target>
        </trans-unit>
        <trans-unit id="6d358556e5f27dfee6bf6eb686c8965aebf7a90e" translate="yes" xml:space="preserve">
          <source>-th</source>
          <target state="translated">-th</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="9ab9cbe186911e3306c2471a07f4d73488a998c2" translate="yes" xml:space="preserve">
          <source>. (the value of M, determined by B, will be the value stored by one of these side effects).</source>
          <target state="translated">。（由B确定的M值将是由这些副作用之一存储的值）。</target>
        </trans-unit>
        <trans-unit id="4c867670cfdf2b3d78e9b9332a77e4cae54f2ca7" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;*this&lt;/code&gt; is</source>
          <target state="translated">。 &lt;code&gt;*this&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="858e49b217359edfde089556fcb3a0afd53dff9d" translate="yes" xml:space="preserve">
          <source>. A program that has two conflicting evaluations has a</source>
          <target state="translated">。具有两个冲突评估的程序具有</target>
        </trans-unit>
        <trans-unit id="40cdcbb4fcaaf112141529b2f4aa097584351c61" translate="yes" xml:space="preserve">
          <source>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least</source>
          <target state="translated">。除匹配的字符外，总是存储空字符（因此参数数组必须至少有空间</target>
        </trans-unit>
        <trans-unit id="6c8c268081021c567c19d1d620072b0fc7e50c0e" translate="yes" xml:space="preserve">
          <source>. Any use of a deleted function is ill-formed (the program will not compile). This includes calls, both explicit (with a function call operator) and implicit (a call to deleted overloaded operator, special member function, allocation function etc), constructing a pointer or pointer-to-member to a deleted function, and even the use of a deleted function in an unevaluated expression. However, implicit &lt;a href=&quot;definition#ODR-use&quot;&gt;ODR-use&lt;/a&gt; of a non-pure virtual member function that happens to be deleted is allowed.</source>
          <target state="translated">。删除功能的任何使用都格式不正确（程序将无法编译）。这包括显式调用（使用函数调用运算符）和隐式调用（对删除的重载运算符的调用，特殊成员函数，分配函数等），构造指向已删除函数的指针或指向成员的指针，甚至使用未评估表达式中已删除函数的名称。但是，允许隐式&lt;a href=&quot;definition#ODR-use&quot;&gt;ODR使用&lt;/a&gt;恰好被删除的非纯虚拟成员函数。</target>
        </trans-unit>
        <trans-unit id="a1b0da760b32f18ba3fc29ea2034487403e7abfa" translate="yes" xml:space="preserve">
          <source>. Each byte in memory has a unique</source>
          <target state="translated">。内存中的每个字节都有一个唯一的</target>
        </trans-unit>
        <trans-unit id="5cddd5dfbecb9801772fe2221afa601ead96b52d" translate="yes" xml:space="preserve">
          <source>. Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint:</source>
          <target state="translated">。每个概念都是一个谓词，在编译时进行评估，并成为模板接口的一部分，并在其中用作约束条件：</target>
        </trans-unit>
        <trans-unit id="33dec4f9c20f32729da42cd862630e951a31724b" translate="yes" xml:space="preserve">
          <source>. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories:</source>
          <target state="translated">。每个表达式都有一些非引用类型，每个表达式恰好属于三个主要值类别之一：</target>
        </trans-unit>
        <trans-unit id="b705286f65efb9ff5d067129a4b52aa7b3a64f86" translate="yes" xml:space="preserve">
          <source>. Evaluation of the predicate must not have any side effects other than modification of non-volatile objects whose lifetimes begin and end within that evaluation; otherwise the behavior is undefined. If the evaluation of a predicate exits via an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">。谓词的评估除修改其生命周期在评估中开始和结束的非易失性对象外，不得有任何其他副作用；否则，行为是不确定的。如果谓词的求值通过异常退出，则调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdbadb9492e1aaa923f351b943afd53e801082db" translate="yes" xml:space="preserve">
          <source>. For example, &lt;code&gt;&quot;ch&quot;&lt;/code&gt; in Czech follows &lt;code&gt;&quot;h&quot;&lt;/code&gt; and precedes &lt;code&gt;&quot;i&quot;&lt;/code&gt;, and &lt;code&gt;&quot;dzs&quot;&lt;/code&gt; in Hungarian follows &lt;code&gt;&quot;dz&quot;&lt;/code&gt; and precedes &lt;code&gt;&quot;g&quot;&lt;/code&gt;.</source>
          <target state="translated">。例如， &lt;code&gt;&quot;ch&quot;&lt;/code&gt; 在捷克如下 &lt;code&gt;&quot;h&quot;&lt;/code&gt; 和先于 &lt;code&gt;&quot;i&quot;&lt;/code&gt; ，和 &lt;code&gt;&quot;dzs&quot;&lt;/code&gt; 在匈牙利如下 &lt;code&gt;&quot;dz&quot;&lt;/code&gt; 和先于 &lt;code&gt;&quot;g&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d82d917e197ae463a094b584241f35f782aec1e5" translate="yes" xml:space="preserve">
          <source>. Four data models found wide acceptance:</source>
          <target state="translated">。四个数据模型被广泛接受：</target>
        </trans-unit>
        <trans-unit id="a33d10a95384cd1ea7eb9f897911c689939d7a04" translate="yes" xml:space="preserve">
          <source>. If &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; the first substring is &lt;code&gt;[pos1, size())&lt;/code&gt;. Likewise, &lt;code&gt;count2 &amp;gt; str.size() - pos2&lt;/code&gt; the second substring is &lt;code&gt;[pos2, str.size())&lt;/code&gt;.</source>
          <target state="translated">。如果 &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; 则第一个子字符串为 &lt;code&gt;[pos1, size())&lt;/code&gt; 。同样， &lt;code&gt;count2 &amp;gt; str.size() - pos2&lt;/code&gt; 的第二个子字符串是 &lt;code&gt;[pos2, str.size())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60d4561c4e6d1d28e7602ab1f96bac585b6ca3dc" translate="yes" xml:space="preserve">
          <source>. If &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; the substring is &lt;code&gt;[pos1, size())&lt;/code&gt;.</source>
          <target state="translated">。如果 &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; 则子字符串为 &lt;code&gt;[pos1, size())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b84f7bfde392ca0b0a0eb7c2fd807319d5660eee" translate="yes" xml:space="preserve">
          <source>. If a name has linkage, it refers to the same entity as the same name introduced by a declaration in another scope. If a variable, function, or another entity with the same name is declared in several scopes, but does not have sufficient linkage, then several instances of the entity are generated.</source>
          <target state="translated">。如果名称具有链接，则它与另一个作​​用域中的声明引入的相同名称引用相同的实体。如果在多个作用域中声明了变量，函数或具有相同名称的另一个实体，但是没有足够的链接，则将生成该实体的多个实例。</target>
        </trans-unit>
        <trans-unit id="68e5fa4e1855031b0502b2881746502d1ee32b93" translate="yes" xml:space="preserve">
          <source>. If an expression of class type is used where an integral constant expression is expected, the expression is &lt;a href=&quot;implicit_cast&quot;&gt;contextually implicitly converted&lt;/a&gt; to an integral or unscoped enumeration type.</source>
          <target state="translated">。如果在期望使用整数常量表达式的情况下使用了类类型的表达式，则该表达式将在&lt;a href=&quot;implicit_cast&quot;&gt;上下文中隐式转换&lt;/a&gt;为整数或无范围的枚举类型。</target>
        </trans-unit>
        <trans-unit id="bf4f7b247734c7ffb151a9d2d9c1116744a29510" translate="yes" xml:space="preserve">
          <source>. If it is missing (and the first element other than the root name is a file name), then the path is</source>
          <target state="translated">。如果缺少（根名称以外的第一个元素是文件名），则路径为</target>
        </trans-unit>
        <trans-unit id="3cdae61a821a7400c029c87da2e0ad8e4d9f82b6" translate="yes" xml:space="preserve">
          <source>. If new_type is (possibly &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;) &lt;code&gt;void&lt;/code&gt;, the expression is a void prvalue without a result object(since C++17).. This is the only cast expression that can create an &lt;a href=&quot;array#Array_rvalues&quot;&gt;array prvalue&lt;/a&gt;.</source>
          <target state="translated">。如果new_type是（可能是&lt;a href=&quot;cv&quot;&gt;cv限定的&lt;/a&gt;） &lt;code&gt;void&lt;/code&gt; ，则该表达式是一个没有结果对象的void prvalue（从C ++ 17开始）。这是唯一可以创建&lt;a href=&quot;array#Array_rvalues&quot;&gt;数组prvalue的强制转换&lt;/a&gt;表达式。</target>
        </trans-unit>
        <trans-unit id="77e403132e08047bd2d3bc12dda0f4a4a2d76de8" translate="yes" xml:space="preserve">
          <source>. If the character specified by a universal character name isn't a member of the execution character set, the result is implementation-defined, but is guaranteed not to be a null (wide) character.</source>
          <target state="translated">。如果由通用字符名称指定的字符不是执行字符集的成员，则结果是实现定义的，但保证不是空（宽）字符。</target>
        </trans-unit>
        <trans-unit id="2055582e493f90d8029965151d08ca03337c25b6" translate="yes" xml:space="preserve">
          <source>. In other words, class members in each of the three member access modes are positioned in memory in order of declaration.</source>
          <target state="translated">。换句话说，三种成员访问模式中的每一个的类成员都按声明的顺序放置在内存中。</target>
        </trans-unit>
        <trans-unit id="a005fba78ddbc77b4129b39813eedeab22a6e135" translate="yes" xml:space="preserve">
          <source>. In other words, they results of comparing the pointers is the same as the result of comparing the indexes of the elements they point to.</source>
          <target state="translated">。换句话说，它们比较指针的结果与比较它们指向的元素的索引的结果相同。</target>
        </trans-unit>
        <trans-unit id="99a683fd566c429de6986c8efcc6c2533955f501" translate="yes" xml:space="preserve">
          <source>. In particular, OS-dependent end-of-line indicators are replaced by newline characters. The</source>
          <target state="translated">。特别是，依赖于OS的行尾指示器由换行符代替。的</target>
        </trans-unit>
        <trans-unit id="2971dbfe9f7c9e49e1f8b10e03b7c5f6dac51f41" translate="yes" xml:space="preserve">
          <source>. Invoking the</source>
          <target state="translated">。调用</target>
        </trans-unit>
        <trans-unit id="c1128618249b42b2681dcf948859823c7068abc2" translate="yes" xml:space="preserve">
          <source>. It is a form of &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt;(since C++11) or &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt;(since C++20).</source>
          <target state="translated">。它是&lt;a href=&quot;list_initialization&quot;&gt;列表初始化&lt;/a&gt;（自C ++ 11起）或&lt;a href=&quot;direct_initialization&quot;&gt;直接初始化&lt;/a&gt;（自C ++ 20起）的一种形式。</target>
        </trans-unit>
        <trans-unit id="356bc0604f7850722bb7374a264e1089f903613e" translate="yes" xml:space="preserve">
          <source>. It is implementation-defined if &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../memory/allocator/allocate&quot;&gt;std::allocator::allocate&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../memory/get_temporary_buffer&quot;&gt;std::get_temporary_buffer&lt;/a&gt;&lt;/code&gt; support over-aligned types. &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocators&lt;/a&gt; instantiated with over-aligned types are allowed to fail to instantiate at compile time, to throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; at runtime, to silently ignore unsupported alignment requirement, or to handle them correctly.</source>
          <target state="translated">。如果&lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;， &lt;code&gt;&lt;a href=&quot;../memory/allocator/allocate&quot;&gt;std::allocator::allocate&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../memory/get_temporary_buffer&quot;&gt;std::get_temporary_buffer&lt;/a&gt;&lt;/code&gt; 支持超对齐类型，则它是实现定义的。使用过度对齐类型实例化的&lt;a href=&quot;../named_req/allocator&quot;&gt;分配器&lt;/a&gt;在编译时无法实例化，在运行时抛出 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; ，静默忽略不支持的对齐要求，或正确处理它们。</target>
        </trans-unit>
        <trans-unit id="ab7e947eb2a49ecc9700edf726245f07e8311cd4" translate="yes" xml:space="preserve">
          <source>. It is often used to provide an empty body to a &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; or &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop. It can also be used to carry a label in the end of a compound statement.</source>
          <target state="translated">。它通常用于为&lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;或&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;循环提供一个空的主体。它也可以在复合语句的末尾带有标签。</target>
        </trans-unit>
        <trans-unit id="ab056dbc0ad8ac12b777fec3697e10f3e1de1b4a" translate="yes" xml:space="preserve">
          <source>. It takes no arguments, returns void, and performs no action other than initial evaluation of &lt;code&gt;E1&lt;/code&gt;. This is the only case where the left-hand operand of &lt;code&gt;operator.&lt;/code&gt; has non-class type. Allowing pseudo destructor call makes it possible to write code without having to know if a destructor exists for a given type.</source>
          <target state="translated">。除了 &lt;code&gt;E1&lt;/code&gt; 的初始求值之外，它不接受任何参数，返回void且不执行任何操作。这是唯一的 &lt;code&gt;operator.&lt;/code&gt; 左侧操作数的情况。具有非类类型。允许伪析构函数调用使编写代码成为可能，而不必知道给定类型是否存在析构函数。</target>
        </trans-unit>
        <trans-unit id="eef30cb415d5d8eda6e82cbfa234d079d7a185fc" translate="yes" xml:space="preserve">
          <source>. Language linkage encapsulates the set of requirements necessary to link with a module written in another programming language: &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;calling convention&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling&quot;&gt;name mangling&lt;/a&gt; algorithm, etc.</source>
          <target state="translated">。语言链接封装了与使用另一种编程语言编写的模块链接所必需的一组要求：&lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;调用约定&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling&quot;&gt;名称处理&lt;/a&gt;算法等。</target>
        </trans-unit>
        <trans-unit id="5e2ad60e04fa8a32b82dd4ab36a67fe1ce73577f" translate="yes" xml:space="preserve">
          <source>. Literal types are the types of &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr variables&lt;/a&gt; and they can be constructed, manipulated, and returned from &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr functions&lt;/a&gt;.</source>
          <target state="translated">。文字类型是&lt;a href=&quot;../language/constexpr&quot;&gt;constexpr变量&lt;/a&gt;的类型，可以从&lt;a href=&quot;../language/constexpr&quot;&gt;constexpr函数&lt;/a&gt;构造，操作和返回它们。</target>
        </trans-unit>
        <trans-unit id="3fd05493594e79b94be80621c509c9e737da3b3c" translate="yes" xml:space="preserve">
          <source>. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</source>
          <target state="translated">。在此存储之前或之后，无法对当前线程中的任何内存读取或写入进行重新排序。修改之前，其他线程中释放相同原子变量的所有写操作都是可见的，而修改在其他获得相同原子变量的线程中可见。</target>
        </trans-unit>
        <trans-unit id="4043f50b8367eb4e26dc8f87a7a82decf69d22dd" translate="yes" xml:space="preserve">
          <source>. Objects of this type are &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic objects&lt;/a&gt; and have runtime type information stored as part of the object representation, which may be queried with &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; and &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;. Virtual member functions participate in dynamic binding.</source>
          <target state="translated">。此类型的&lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;对象&lt;/a&gt;是多态对象，并且具有运行时类型信息作为对象表示的一部分存储，可以使用&lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;和&lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;进行查询。虚拟成员函数参与动态绑定。</target>
        </trans-unit>
        <trans-unit id="a9a5f93018a465748262f4fd922c0b10831e96e6" translate="yes" xml:space="preserve">
          <source>. Only then &lt;code&gt;std::feof&lt;/code&gt; returns non-zero.</source>
          <target state="translated">。只有这样， &lt;code&gt;std::feof&lt;/code&gt; 返回非零值。</target>
        </trans-unit>
        <trans-unit id="2a930ffd122a65a9f25ff1e6d9f9938ba49636a8" translate="yes" xml:space="preserve">
          <source>. Otherwise the pointer value is unchanged. Conversion of any pointer to pointer to void and back to pointer to the original (or more cv-qualified) type preserves its original value.</source>
          <target state="translated">。否则，指针值将保持不变。将任何指针转换为指向void的指针，再返回指向原始（或更具有cv资格的）指针的转换将保留其原始值。</target>
        </trans-unit>
        <trans-unit id="f7c05934e49017a55ffd7f8db5e6be448b7c6949" translate="yes" xml:space="preserve">
          <source>. Otherwise, it is a</source>
          <target state="translated">。否则，这是一个</target>
        </trans-unit>
        <trans-unit id="7d7ba1a37c76c90cfc05299fdb7d66d00cdf8dca" translate="yes" xml:space="preserve">
          <source>. Pointers to single objects are treated as pointers to arrays of one: &lt;code&gt;&amp;amp;obj+1&lt;/code&gt; compares greater than &lt;code&gt;&amp;amp;obj&lt;/code&gt;(since C++17)</source>
          <target state="translated">。指向单个对象的指针被视为指向一个对象的数组的指针： &lt;code&gt;&amp;amp;obj+1&lt;/code&gt; 比较大于 &lt;code&gt;&amp;amp;obj&lt;/code&gt; （从C ++ 17开始）</target>
        </trans-unit>
        <trans-unit id="79ab5295086cf1cff1d188640da5082b74e6f20b" translate="yes" xml:space="preserve">
          <source>. Rounding to nearest representable value results in 0x1.999999999999a*2-4</source>
          <target state="translated">。四舍五入到最接近的可表示值将得出0x1.999999999999a * 2-4</target>
        </trans-unit>
        <trans-unit id="cbad6d2df5c35e8f921fcaa593ace506841238a7" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;virtual&quot;&gt;virtual functions&lt;/a&gt; and &lt;a href=&quot;abstract_class&quot;&gt;abstract classes&lt;/a&gt; for details.</source>
          <target state="translated">。有关详细信息，请参见&lt;a href=&quot;virtual&quot;&gt;虚拟函数&lt;/a&gt;和&lt;a href=&quot;abstract_class&quot;&gt;抽象类&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ac736feb756a0662765565c1ddf5c54714fbc2b" translate="yes" xml:space="preserve">
          <source>. That is, the last iterator &lt;code&gt;it&lt;/code&gt; for which range &lt;code&gt;[first, it)&lt;/code&gt; is a</source>
          <target state="translated">。也就是说， &lt;code&gt;it&lt;/code&gt; 的最后一个迭代器的范围 &lt;code&gt;[first, it)&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="3cb17b45da870b7ec9baaca006a81afb0e3f404f" translate="yes" xml:space="preserve">
          <source>. The function then searches from that point on for the first character that</source>
          <target state="translated">。然后，函数从该点开始搜索第一个字符</target>
        </trans-unit>
        <trans-unit id="2923ece4a0bd3546cfdc4f62787758294b263ad1" translate="yes" xml:space="preserve">
          <source>. The function then searches from that point on for the first wide character that</source>
          <target state="translated">。然后，函数从该点开始搜索第一个宽字符</target>
        </trans-unit>
        <trans-unit id="61b94db5d99f08f0c694055d17375cb798fa4521" translate="yes" xml:space="preserve">
          <source>. The name</source>
          <target state="translated">。名字</target>
        </trans-unit>
        <trans-unit id="85de12fb456918c6facd124a016788e336a84025" translate="yes" xml:space="preserve">
          <source>. The name can be referred to from all scopes in the current translation unit.</source>
          <target state="translated">。可以在当前翻译单元的所有范围中引用该名称。</target>
        </trans-unit>
        <trans-unit id="f523417ea4918f53f6a9f95baf7712b34a86eae4" translate="yes" xml:space="preserve">
          <source>. The name can be referred to from the scopes in the other translation units. Variables and functions with external linkage also have &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt;, which makes it possible to link translation units written in different programming languages.</source>
          <target state="translated">。可以从其他翻译单位的范围中引用该名称。具有外部链接的变量和函数也具有&lt;a href=&quot;language_linkage&quot;&gt;语言链接&lt;/a&gt;，这使得可以链接以不同编程语言编写的翻译单元。</target>
        </trans-unit>
        <trans-unit id="8a09d851d0a6928714c77e7574c1b6d959c9da3c" translate="yes" xml:space="preserve">
          <source>. The name can be referred to only from the scope it is in.</source>
          <target state="translated">。只能从其作用域中引用该名称。</target>
        </trans-unit>
        <trans-unit id="b998270ca375ea5551f58f59298525f0cd92ff73" translate="yes" xml:space="preserve">
          <source>. The name of such a class only exists within the function scope, and is not accessible outside.</source>
          <target state="translated">。此类的名称仅存在于功能范围内，而无法在外部访问。</target>
        </trans-unit>
        <trans-unit id="3aca28dc5685eb1627cfa6227295b744c7c32887" translate="yes" xml:space="preserve">
          <source>. The parent directory can be represented by the relative pathname &lt;code&gt;&quot;..&quot;&lt;/code&gt;.</source>
          <target state="translated">。父目录可以由相对路径名 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af5191925264a6f1222eec36d0e558d7114acafb" translate="yes" xml:space="preserve">
          <source>. The point of declaration of the name is immediately following the opening brace of the class definition.</source>
          <target state="translated">。名称的声明点紧跟在类定义的开头大括号之后。</target>
        </trans-unit>
        <trans-unit id="d73ce905c7e8caed5bcf6a0c8b9740ee594fd215" translate="yes" xml:space="preserve">
          <source>. The syntax of the type-id that names type T is exactly the syntax of a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a variable or function of type T, with the identifier omitted, except that</source>
          <target state="translated">。命名类型T的type-id的语法与类型T的变量或函数的&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;的语法完全相同，省略了标识符，除了</target>
        </trans-unit>
        <trans-unit id="0cd178f8d5684f66e16a2083635f91143d51a96e" translate="yes" xml:space="preserve">
          <source>. These attributes may be applied to the function type in a function declaration:</source>
          <target state="translated">。这些属性可以在函数声明中应用于函数类型：</target>
        </trans-unit>
        <trans-unit id="e0b9b65bd5ab61cf0eba414c562588f6d88e9b46" translate="yes" xml:space="preserve">
          <source>. These include.</source>
          <target state="translated">。这些包括。</target>
        </trans-unit>
        <trans-unit id="9b6b8144c37744c4c78e2ca9a7775e22e96ba479" translate="yes" xml:space="preserve">
          <source>. This allows certain errors to be detected at the point of definition, rather than instantiation, and removes the requirement on the &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; disambiguators for dependent names, see below.</source>
          <target state="translated">。这使得在定义的点被检测到特定错误，而不是实例化，并消除对需求 &lt;code&gt;typename&lt;/code&gt; 和 &lt;code&gt;template&lt;/code&gt; disambiguators供养的名字，见下文。</target>
        </trans-unit>
        <trans-unit id="844564e7cf1c47f7ea75e5e1bf440e8f19afffd2" translate="yes" xml:space="preserve">
          <source>. This allows more efficient implementation of &lt;code&gt;memory_order_acquire&lt;/code&gt; and &lt;code&gt;memory_order_release&lt;/code&gt; on some CPUs. It can produce surprising results when &lt;code&gt;memory_order_acquire&lt;/code&gt; and &lt;code&gt;memory_order_release&lt;/code&gt; are mixed with &lt;code&gt;memory_order_seq_cst&lt;/code&gt;.</source>
          <target state="translated">。这样可以在某些CPU上更有效地实现 &lt;code&gt;memory_order_acquire&lt;/code&gt; 和 &lt;code&gt;memory_order_release&lt;/code&gt; 。当 &lt;code&gt;memory_order_acquire&lt;/code&gt; 和 &lt;code&gt;memory_order_release&lt;/code&gt; 与 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 混合使用时，可能会产生令人惊讶的结果。</target>
        </trans-unit>
        <trans-unit id="c6ccbd031282697c64122e93a678f06f4c45fff4" translate="yes" xml:space="preserve">
          <source>. This constructor does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. It is a trivial constructor if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">。除非 &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,否则此构造函数不参与重载解析。如果 &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则它是一个简单的构造函数。</target>
        </trans-unit>
        <trans-unit id="732d85aea2bce0e040fb4cd1659b35c6d1bc3c4a" translate="yes" xml:space="preserve">
          <source>. This constructor is defined as deleted if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. It is a trivial constructor if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">。如果 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ,则此构造函数定义为已删除。如果 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则它是一个简单的构造函数。</target>
        </trans-unit>
        <trans-unit id="026c3d7e9a1fe8d5a967d61011a3beec752b15fd" translate="yes" xml:space="preserve">
          <source>. This distribution is used when estimating the</source>
          <target state="translated">。在估算</target>
        </trans-unit>
        <trans-unit id="b316862e19fe4e350514297be86c991beb03e9ba" translate="yes" xml:space="preserve">
          <source>. This downcast is ill-formed if &lt;code&gt;B&lt;/code&gt; is ambiguous, inaccessible, or virtual base (or a base of a virtual base) of &lt;code&gt;D&lt;/code&gt;. Such &lt;code&gt;static_cast&lt;/code&gt; makes no runtime checks to ensure that the object's runtime type is actually &lt;code&gt;D&lt;/code&gt;, and may only be used safely if this precondition is guaranteed by other means, such as when implementing &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism&quot;&gt;static polymorphism&lt;/a&gt;. Safe downcast may be done with &lt;a href=&quot;dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">。如果 &lt;code&gt;B&lt;/code&gt; 是模棱两可，不可访问或 &lt;code&gt;D&lt;/code&gt; 的虚拟基数（或虚拟基数的基数），则此向下转换格式错误。这种 &lt;code&gt;static_cast&lt;/code&gt; 不会进行任何运行时检查以确保对象的运行时类型实际上是 &lt;code&gt;D&lt;/code&gt; ，并且只有在通过其他方式（例如实现&lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism&quot;&gt;静态多态性&lt;/a&gt;）保证了此前提条件的情况下，才可以安全地使用它。安全下调可以通过&lt;a href=&quot;dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt;完成。</target>
        </trans-unit>
        <trans-unit id="b398f2ef722f3eef80e8eb8655b49aa4fcb0fcec" translate="yes" xml:space="preserve">
          <source>. This has the effect of removing the first (largest) element from the heap defined by the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">。这具有从范围 &lt;code&gt;[first, last)&lt;/code&gt; 定义的堆中删除第一个（最大）元素的效果。</target>
        </trans-unit>
        <trans-unit id="23e6923e524364fd639ec62ad6d11c97fd7da1cf" translate="yes" xml:space="preserve">
          <source>. Two types are covariant if they satisfy all of the following requirements:</source>
          <target state="translated">。如果两个类型都满足以下所有要求，则它们是协变的：</target>
        </trans-unit>
        <trans-unit id="a9b5d1fd23fc7c5b4e6066615fc95994a5d113ca" translate="yes" xml:space="preserve">
          <source>. init-declarator-list is optional when declaring a named class/struct/union or a named enumeration</source>
          <target state="translated">。在声明命名的类/结构/联合或命名的枚举时，init-declarator-list是可选的</target>
        </trans-unit>
        <trans-unit id="e996ce306a5268a292c41ab30ab0b1d4f7db02b0" translate="yes" xml:space="preserve">
          <source>. where S is the sum of all weights.</source>
          <target state="translated">。其中S是所有权重的总和。</target>
        </trans-unit>
        <trans-unit id="9786fc35b53afb831a179c1e43a95571ec28165a" translate="yes" xml:space="preserve">
          <source>.(since C++14)</source>
          <target state="translated">。（C ++ 14起）</target>
        </trans-unit>
        <trans-unit id="6eae3a5b062c6d0d79f070c26e6d62486b40cb46" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>
        </trans-unit>
        <trans-unit id="faffb901ea5e603d448d5c651bc2ce1feb7ab56d" translate="yes" xml:space="preserve">
          <source>...Ints</source>
          <target state="translated">...Ints</target>
        </trans-unit>
        <trans-unit id="f29a917fc93c5cb1d8973220b883033399f48be1" translate="yes" xml:space="preserve">
          <source>...Ts</source>
          <target state="translated">...Ts</target>
        </trans-unit>
        <trans-unit id="e5f0d5fb385bca81078ad2a8707bbb8625cae265" translate="yes" xml:space="preserve">
          <source>...unless the parameter was expanded from a parameter pack</source>
          <target state="translated">...除非从参数包扩展了参数</target>
        </trans-unit>
        <trans-unit id="19f7ec135b5a79de79d6e7cc40d22413fe2af23d" translate="yes" xml:space="preserve">
          <source>/* implementation-defined */</source>
          <target state="translated">/ *实现定义的* /</target>
        </trans-unit>
        <trans-unit id="1ac5a1a38af02527751fd769c995e2b77199e5bf" translate="yes" xml:space="preserve">
          <source>/* non-specialized */</source>
          <target state="translated">/ *非专业* /</target>
        </trans-unit>
        <trans-unit id="3555c1ad8bfe63c321204c247721dcd8a380c1e1" translate="yes" xml:space="preserve">
          <source>/* proxy */</source>
          <target state="translated">/* 代理 */</target>
        </trans-unit>
        <trans-unit id="a269eaf502d0961ec13dad33647c50aef6df1f0b" translate="yes" xml:space="preserve">
          <source>/* unspecified */</source>
          <target state="translated">/ *未指定* /</target>
        </trans-unit>
        <trans-unit id="b6589fc6ab0dc82cf12099d1c2d40ab994e8410c" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>
        </trans-unit>
        <trans-unit id="3e51cc904afd7e59e35c80a6ddcf5cd8135109f4" translate="yes" xml:space="preserve">
          <source>0 and the rest are initialized iteratively, for i=1-n,...,-1, each X</source>
          <target state="translated">0,其余迭代初始化,对于i=1-n,...,-1,每个X</target>
        </trans-unit>
        <trans-unit id="a234edb1dd1ba7b125c0f9eacd66f79c2ee53496" translate="yes" xml:space="preserve">
          <source>0 are zero, and if all other X</source>
          <target state="translated">0为零,如果其他所有X</target>
        </trans-unit>
        <trans-unit id="cbdfc7a60b2a1b991b37673e31df028f7727131b" translate="yes" xml:space="preserve">
          <source>0 if for each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; is true</source>
          <target state="translated">0，如果为每个 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;[0,n)&lt;/code&gt; ， &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; 为真</target>
        </trans-unit>
        <trans-unit id="a385b6d4430ed31871595e71093124d9e635d5b3" translate="yes" xml:space="preserve">
          <source>0 with 2w-1</source>
          <target state="translated">0与2w-1</target>
        </trans-unit>
        <trans-unit id="a0bd242d4e9823dde121cf81241caa8cb18b052a" translate="yes" xml:space="preserve">
          <source>0&amp;ndash;8</source>
          <target state="translated">0&amp;ndash;8</target>
        </trans-unit>
        <trans-unit id="a8df62a2404776e4a9f650425f66aba3e1c6eafd" translate="yes" xml:space="preserve">
          <source>0&amp;radic;1-k2</source>
          <target state="translated">0&amp;radic;1-k2</target>
        </trans-unit>
        <trans-unit id="b7a2c9b34dc2f4bec112398ca4ad2750f1912a7c" translate="yes" xml:space="preserve">
          <source>0,...,P</source>
          <target state="translated">0,...,P</target>
        </trans-unit>
        <trans-unit id="2bd186dce3970b7834f34e8ecaf95f82ee6270fe" translate="yes" xml:space="preserve">
          <source>0-qualified pointer to cv1</source>
          <target state="translated">0-限定指针,指向cv1。</target>
        </trans-unit>
        <trans-unit id="fe1e007660532039a2e8edd7bcd53a0d3a1d5908" translate="yes" xml:space="preserve">
          <source>0-qualified pointer to cv2</source>
          <target state="translated">0-限定指针,指向cv2。</target>
        </trans-unit>
        <trans-unit id="7abe581e3bbbaa5fdd179596f8a0dc409c4c5006" translate="yes" xml:space="preserve">
          <source>0tx-1</source>
          <target state="translated">0tx-1</target>
        </trans-unit>
        <trans-unit id="356a192b7913b04c54574d18c28d46e6395428ab" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>
        </trans-unit>
        <trans-unit id="6811f7a8f41e917fb0d97233a1567d9f7103a1c6" translate="yes" xml:space="preserve">
          <source>1 &amp;lt; K+1 = M &amp;le; N</source>
          <target state="translated">1 &amp;lt;K + 1 = M&amp;le;N</target>
        </trans-unit>
        <trans-unit id="f785463204330c080875e98ef24f1d1d3a6bddb4" translate="yes" xml:space="preserve">
          <source>1 &amp;minus; p if &lt;code&gt;b == false&lt;/code&gt;</source>
          <target state="translated">1 &amp;minus; p如果 &lt;code&gt;b == false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1948bd668a05b546ade4e87c5dc1e44b28d6388d" translate="yes" xml:space="preserve">
          <source>1 if the first string is greater than the second (that is, follows the second in the collation order), -1 if the first string is less than the second (precedes the second in the collation order), zero if the two strings are equivalent.</source>
          <target state="translated">如果第一个字符串大于第二个字符串(即在整理顺序上跟随第二个字符串),则为1;如果第一个字符串小于第二个字符串(在整理顺序上跟随第二个字符串),则为-1;如果两个字符串相等,则为0。</target>
        </trans-unit>
        <trans-unit id="47b4d0a7e4e7a4b47f71461424c2bc278b9cf1bf" translate="yes" xml:space="preserve">
          <source>1 op (... op (E</source>
          <target state="translated">1对...上(E</target>
        </trans-unit>
        <trans-unit id="86fb1242522651d4f696d9af9c16480d53bf7888" translate="yes" xml:space="preserve">
          <source>1 op E</source>
          <target state="translated">1对E</target>
        </trans-unit>
        <trans-unit id="7856021a1dd28ad72b926a915ecc0aad8c99768f" translate="yes" xml:space="preserve">
          <source>1) (deprecated in C++17) If &lt;code&gt;F&lt;/code&gt; is a pointer to function or a pointer to member function, &lt;code&gt;result_type&lt;/code&gt; is the return type of &lt;code&gt;F&lt;/code&gt;. If &lt;code&gt;F&lt;/code&gt; is a class type with nested typedef &lt;code&gt;result_type&lt;/code&gt;, then &lt;code&gt;result_type&lt;/code&gt; is &lt;code&gt;F::result_type&lt;/code&gt;. Otherwise no &lt;code&gt;result_type&lt;/code&gt; is defined.</source>
          <target state="translated">1）（在C ++ 17中不推荐使用）如果 &lt;code&gt;F&lt;/code&gt; 是指向函数的指针或指向成员函数的指针，则 &lt;code&gt;result_type&lt;/code&gt; 是 &lt;code&gt;F&lt;/code&gt; 的返回类型。如果 &lt;code&gt;F&lt;/code&gt; 是具有嵌套typedef &lt;code&gt;result_type&lt;/code&gt; 的类类型，则 &lt;code&gt;result_type&lt;/code&gt; 是 &lt;code&gt;F::result_type&lt;/code&gt; 。否则，未定义 &lt;code&gt;result_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83ea50c76bc44cdd9e4f766c317db5c2037df0e1" translate="yes" xml:space="preserve">
          <source>1) (none)</source>
          <target state="translated">1)(无)</target>
        </trans-unit>
        <trans-unit id="86452ff75dcaffc8160d808ad365b65ef26fd4f4" translate="yes" xml:space="preserve">
          <source>1) (none)  2).</source>
          <target state="translated">1)(无)2)。</target>
        </trans-unit>
        <trans-unit id="34a572a24e5822c38c6b3ac46db113826995572c" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;CT(lhs).count() == CT(rhs).count()&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;CT(lhs).count() == CT(rhs).count()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a6a38143daa43b50349154fefdef085b81c3ad69" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;U&amp;amp;&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;; &lt;code&gt;T&lt;/code&gt; otherwise.</source>
          <target state="translated">1） &lt;code&gt;U&amp;amp;&lt;/code&gt; 如果 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; ; 否则为 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="356a0877a891d6c9b60ef01cb7aaa9edeed1d1b1" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c22d94e3201de96926713e0b0f3b78a82a762b89" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt; is a copy of &lt;code&gt;*this&lt;/code&gt; or has an identical name, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1）如果 &lt;code&gt;other&lt;/code&gt; 是 &lt;code&gt;*this&lt;/code&gt; 的副本或具有相同的名称，则为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6622eb011b611aae7e8c72a24755377368ad3a3" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;std::get&amp;lt;i&amp;gt;(lhs) == std::get&amp;lt;i&amp;gt;(rhs)&lt;/code&gt; for all i in &lt;code&gt;[0, sizeof...(Types))&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. For two empty tuples returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;true&lt;/code&gt; 要是 &lt;code&gt;std::get&amp;lt;i&amp;gt;(lhs) == std::get&amp;lt;i&amp;gt;(rhs)&lt;/code&gt; 对所有我在 &lt;code&gt;[0, sizeof...(Types))&lt;/code&gt; ，否则 &lt;code&gt;false&lt;/code&gt; 。对于两个空元组，返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="287dd3f95063f279870312b22bda28b87cd0fd6d" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if both &lt;code&gt;lhs.first == rhs.first&lt;/code&gt; and &lt;code&gt;lhs.second == rhs.second&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;true&lt;/code&gt; 如果两个 &lt;code&gt;lhs.first == rhs.first&lt;/code&gt; 和 &lt;code&gt;lhs.second == rhs.second&lt;/code&gt; ，否则 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27a520d2b54a1f6646b3759539dd07d9fa75978e" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the distribution objects are equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1）如果分布对象相等，则为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1288e43751f25875bb27e07c4078a20e14710ced" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the underlying &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; objects refer to the same type, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1）如果基础 &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 对象引用相同的类型，则为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="104870c8f3088e1326f88bd2c5413aebdc6b362c" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the value of each bit in &lt;code&gt;*this&lt;/code&gt; equals the value of the corresponding bit in &lt;code&gt;rhs&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;*this&lt;/code&gt; 中每个位的值等于 &lt;code&gt;rhs&lt;/code&gt; 中相应位的值，则为 &lt;code&gt;true&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f71bf93702e13dec1d236cb721728da440f6f871" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;x.get() == y.get()&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;x.get() == y.get()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11d9b8b52ebd3e1a3a024e6ccd57926c21a2e926" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;​0​&lt;/code&gt; on success, non-zero otherwise.</source>
          <target state="translated">1） &lt;code&gt;​0​&lt;/code&gt; 上的成功，否则返回非零值。</target>
        </trans-unit>
        <trans-unit id="6a3ae1acf7b6dec0a07ba83e824584db212e3584" translate="yes" xml:space="preserve">
          <source>1) A</source>
          <target state="translated">1)A</target>
        </trans-unit>
        <trans-unit id="20fbef856206918a3d8fb45dbe16ba8dc8b0ab41" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;std::chrono::sys_info&lt;/code&gt; structure &lt;code&gt;i&lt;/code&gt; containing the time zone information in effect for this time zone at the time point &lt;code&gt;tp&lt;/code&gt;. &lt;code&gt;tp&lt;/code&gt; will be in the range &lt;code&gt;[i.begin, i.end)&lt;/code&gt;.</source>
          <target state="translated">1）一个 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; 结构 &lt;code&gt;i&lt;/code&gt; ,其中包含在时间点 &lt;code&gt;tp&lt;/code&gt; 对该时区有效的时区信息。 &lt;code&gt;tp&lt;/code&gt; 将在 &lt;code&gt;[i.begin, i.end)&lt;/code&gt; 范围内。</target>
        </trans-unit>
        <trans-unit id="d73fc0de5837fb35ed94e495176a1ab53919bb87" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;sys_time&lt;/code&gt; representing the same point in time as the argument.</source>
          <target state="translated">1） &lt;code&gt;sys_time&lt;/code&gt; 表示与参数相同的时间点。</target>
        </trans-unit>
        <trans-unit id="cabaf2c8fe8bd5c8a1098bdc266583d59f4973d7" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;utc_time&lt;/code&gt; representing the same point in time as the argument.</source>
          <target state="translated">1） &lt;code&gt;utc_time&lt;/code&gt; 表示与参数相同的时间点。</target>
        </trans-unit>
        <trans-unit id="b8328f6a84aae122e8939d2fec2a952c6930f619" translate="yes" xml:space="preserve">
          <source>1) A is</source>
          <target state="translated">1)A是</target>
        </trans-unit>
        <trans-unit id="5f587efae23c247ca28924e943089a9746064083" translate="yes" xml:space="preserve">
          <source>1) A is a modification, and B reads the value stored by A 2) A precedes B in the</source>
          <target state="translated">1)A是修饰,B读出A存储的值 2)A在B之前的是</target>
        </trans-unit>
        <trans-unit id="2dbafc39b4109d874a6ef2cacd1b60fbe55da610" translate="yes" xml:space="preserve">
          <source>1) A non-type template parameter pack with an optional name</source>
          <target state="translated">1)非类型模板参数包,名称可选。</target>
        </trans-unit>
        <trans-unit id="af46537a854cfc07af90d00edb90238c2ee6d6fd" translate="yes" xml:space="preserve">
          <source>1) A non-type template parameter with an optional name.</source>
          <target state="translated">1)非类型模板参数,名称可选。</target>
        </trans-unit>
        <trans-unit id="4fe90bdfc834565a8e6349626f28a49a60b68cd0" translate="yes" xml:space="preserve">
          <source>1) A performs a</source>
          <target state="translated">1)A执行的是</target>
        </trans-unit>
        <trans-unit id="fbc6fe14c6af3cf8418f033f94d06174d8d80ddb" translate="yes" xml:space="preserve">
          <source>1) A range adaptor that produces a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of no elements of a particular type.</source>
          <target state="translated">1）范围适配器，不产生没有特定类型元素的&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0b9ae19f16d299250d9ad0aaf00550a8d1c41fae" translate="yes" xml:space="preserve">
          <source>1) A range adaptor that represents &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of an underlying sequence without the elements that fail to satisfy a predicate.</source>
          <target state="translated">1）范围适配器，表示基础序列的&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;，而没有不满足谓词的元素。</target>
        </trans-unit>
        <trans-unit id="b9956ba464175b6f57bff8b5d832269a811d8115" translate="yes" xml:space="preserve">
          <source>1) A range factory that generates a sequence of elements by repeatedly incrementing an initial value. Can be both bounded and unbounded (infinite)</source>
          <target state="translated">1)通过反复递增一个初始值来生成元素序列的范围工厂。既可以是有界的,也可以是无界的(无限)。</target>
        </trans-unit>
        <trans-unit id="fe4686de1a7da6422a6cf066a0610a3a80118153" translate="yes" xml:space="preserve">
          <source>1) A reference to the global &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; singleton.</source>
          <target state="translated">1）对全局 &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; 单例的引用。</target>
        </trans-unit>
        <trans-unit id="82947af8d2369ef592a5e98e3d4604eb5d6af50d" translate="yes" xml:space="preserve">
          <source>1) A set of</source>
          <target state="translated">1)一套</target>
        </trans-unit>
        <trans-unit id="a299040649a8f9f824a466b99cd8accb4069fd60" translate="yes" xml:space="preserve">
          <source>1) A span constructed with &lt;code&gt;{reinterpret_cast&amp;lt;const &lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&amp;gt;(s.data()), s.size_bytes()}&lt;/code&gt;.</source>
          <target state="translated">1）使用 &lt;code&gt;{reinterpret_cast&amp;lt;const &lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&amp;gt;(s.data()), s.size_bytes()}&lt;/code&gt; 构造一个范围。</target>
        </trans-unit>
        <trans-unit id="424f7940a81075143bd01c42816d096ec4cc3e70" translate="yes" xml:space="preserve">
          <source>1) A standard conversion sequence is always</source>
          <target state="translated">1)标准的转换序列总是</target>
        </trans-unit>
        <trans-unit id="a46604118cc45bb8f1fc823ba39ae021f0682a23" translate="yes" xml:space="preserve">
          <source>1) A string object holding a copy of this buffer's underlying character sequence.</source>
          <target state="translated">1)一个字符串对象,持有这个缓冲区底层字符序列的副本。</target>
        </trans-unit>
        <trans-unit id="46e69a24f3f32aa99efec236d8f802a03d6df127" translate="yes" xml:space="preserve">
          <source>1) A template template parameter with an optional name.</source>
          <target state="translated">1)模板模板参数,名称可选。</target>
        </trans-unit>
        <trans-unit id="bf76071f8f71da36945babb431edddf84fe21626" translate="yes" xml:space="preserve">
          <source>1) A type alias declaration introduces a name which can be used as a synonym for the type denoted by type-id. It does not introduce a new type and it cannot change the meaning of an existing type name. There is no difference between a type alias declaration and &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; declaration. This declaration may appear in block scope, class scope, or namespace scope.</source>
          <target state="translated">1）类型别名声明引入了一个名称，该名称可以用作由type-id表示的类型的同义词。它不会引入新类型，也无法更改现有类型名称的含义。类型别名声明和&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;声明之间没有区别。该声明可能出现在块作用域，类作用域或名称空间作用域中。</target>
        </trans-unit>
        <trans-unit id="d39d12e44cd655e37c42c123e3133548497ae9ed" translate="yes" xml:space="preserve">
          <source>1) A type template parameter without a default.</source>
          <target state="translated">1)没有默认的类型模板参数。</target>
        </trans-unit>
        <trans-unit id="173390dfcc7b8ee2a586fea4454de09b477814e3" translate="yes" xml:space="preserve">
          <source>1) Accesses (reads and writes) to &lt;a href=&quot;cv&quot;&gt;volatile&lt;/a&gt; objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are &lt;a href=&quot;../atomic/memory_order&quot;&gt;not reordered&lt;/a&gt; with respect to other volatile accesses on the same thread.</source>
          <target state="translated">1）严格根据&lt;a href=&quot;cv&quot;&gt;易失性&lt;/a&gt;对象所在的表达式的语义来进行访问（读取和写入）。特别是，它们&lt;a href=&quot;../atomic/memory_order&quot;&gt;不会&lt;/a&gt;相对于同一线程上的其他易失性访问而重新排序。</target>
        </trans-unit>
        <trans-unit id="82db348ccd128d42ca8c97273d60b073e85127a3" translate="yes" xml:space="preserve">
          <source>1) All characters in &lt;a href=&quot;character_literal&quot;&gt;character literals&lt;/a&gt; and &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are converted from the source character set to the</source>
          <target state="translated">1）&lt;a href=&quot;character_literal&quot;&gt;字符文字&lt;/a&gt;和&lt;a href=&quot;string_literal&quot;&gt;字符串文字&lt;/a&gt;中的所有字符都将从源字符集转换为</target>
        </trans-unit>
        <trans-unit id="66bfdbf9083c74e9a1866c3e2e464fc8189cefc5" translate="yes" xml:space="preserve">
          <source>1) All memory allocations are performed by &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">1）所有的内存分配由执行 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="048a26efa0caafdd751840d3dafcd66eba62dbea" translate="yes" xml:space="preserve">
          <source>1) Amortized constant</source>
          <target state="translated">1)摊销后的常数</target>
        </trans-unit>
        <trans-unit id="5981b7305017c9545a89a5a35fe66de383130acf" translate="yes" xml:space="preserve">
          <source>1) An expression of integral, enumeration, pointer, or pointer-to-member type can be converted to its own type. The resulting value is the same as the value of &lt;code&gt;expression&lt;/code&gt;. (since C++11)</source>
          <target state="translated">1）整数，枚举，指针或指针到成员类型的表达式可以转换为自己的类型。结果值与 &lt;code&gt;expression&lt;/code&gt; 的值相同。（自C ++ 11起）</target>
        </trans-unit>
        <trans-unit id="95cffb88bccbe314e1530157850332433d961b24" translate="yes" xml:space="preserve">
          <source>1) An implementation-defined type that holds a reference to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1）一个实现定义的类型，其中包含对 &lt;code&gt;*this&lt;/code&gt; 的引用</target>
        </trans-unit>
        <trans-unit id="66c9b9f664df38161f10437106d4643e64c7e947" translate="yes" xml:space="preserve">
          <source>1) An object of class &lt;code&gt;any&lt;/code&gt; stores an instance of any type that satisfies the constructor requirements or is empty, and this is referred to as the</source>
          <target state="translated">1） &lt;code&gt;any&lt;/code&gt; 类的对象都存储一个满足构造函数要求或为空的任何类型的实例，这被称为</target>
        </trans-unit>
        <trans-unit id="61dc882dd7d34d7d4ad75d6cb735240681e1867e" translate="yes" xml:space="preserve">
          <source>1) Analyzes generic range &lt;code&gt;[first,last)&lt;/code&gt;. Match results are returned in &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1）分析通用范围 &lt;code&gt;[first,last)&lt;/code&gt; 。匹配结果以 &lt;code&gt;m&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="80ba3076eb89d7a3ef079f9e8618c645e77976f7" translate="yes" xml:space="preserve">
          <source>1) Appends &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt;</source>
          <target state="translated">1）追加字符 &lt;code&gt;ch&lt;/code&gt; 的 &lt;code&gt;count&lt;/code&gt; 副本</target>
        </trans-unit>
        <trans-unit id="0f4fd2232e22aac2b19529e6e3b82510ab23c6ef" translate="yes" xml:space="preserve">
          <source>1) Applies the given function object &lt;code&gt;f&lt;/code&gt; to the result of dereferencing every iterator in the range &lt;code&gt;[first, first + n)&lt;/code&gt;, in order.</source>
          <target state="translated">1）将给定的函数对象 &lt;code&gt;f&lt;/code&gt; 依次应用于解引用范围为 &lt;code&gt;[first, first + n)&lt;/code&gt; 每个迭代器的结果。</target>
        </trans-unit>
        <trans-unit id="9326d78a127c522e3d8f1f7afedde286e2d81452" translate="yes" xml:space="preserve">
          <source>1) Applies the given function object &lt;code&gt;f&lt;/code&gt; to the result of dereferencing every iterator in the range &lt;code&gt;[first, last)&lt;/code&gt;, in order.</source>
          <target state="translated">1）将给定的函数对象 &lt;code&gt;f&lt;/code&gt; 依次应用于解引用范围为 &lt;code&gt;[first, last)&lt;/code&gt; 每个迭代器的结果。</target>
        </trans-unit>
        <trans-unit id="a269e932f278e6dc2ae1bfe911e2855a58c5ae13" translate="yes" xml:space="preserve">
          <source>1) Applies the language specification string-literal to all function types, function names with external linkage and variables with external linkage declared in declaration-seq.</source>
          <target state="translated">1)将语言规范string-literal应用于声明-seq中声明的所有函数类型、带外部链接的函数名和带外部链接的变量。</target>
        </trans-unit>
        <trans-unit id="0f9581ab834f137fbae8882fe84416428e32951d" translate="yes" xml:space="preserve">
          <source>1) Applies the offset &lt;code&gt;d&lt;/code&gt; to &lt;code&gt;pt&lt;/code&gt;. Effectively, &lt;code&gt;d&lt;/code&gt; is added to the internally stored duration &lt;code&gt;d_&lt;/code&gt; as &lt;code&gt;d_ += d&lt;/code&gt;.</source>
          <target state="translated">1）将偏移量 &lt;code&gt;d&lt;/code&gt; 应用于 &lt;code&gt;pt&lt;/code&gt; 。有效地，将 &lt;code&gt;d&lt;/code&gt; 作为 &lt;code&gt;d_ += d&lt;/code&gt; 添加到内部存储的持续时间 &lt;code&gt;d_&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="bd44368f1ec313c9be1e54cec6967210632f57be" translate="yes" xml:space="preserve">
          <source>1) Applies to a statement to allow the compiler to optimize for the case where paths of execution including that statement are more likely than any alternative path of execution that does not include such a statement.</source>
          <target state="translated">1)适用于一条语句,允许编译器针对包含该语句的执行路径比不包含该语句的任何替代执行路径更有可能的情况进行优化。</target>
        </trans-unit>
        <trans-unit id="8f5ccf9c295ab95bc3305d17a3414892b4f79ae1" translate="yes" xml:space="preserve">
          <source>1) As a part of class member access expression, in which the class either has this member or is derived from a class that has this member, including the implicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; member access expressions that appear when a non-static member name is used in any of the contexts where &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; is allowed (inside member function bodies, in member initializer lists, in the in-class default member initializers).</source>
          <target state="translated">1）作为类成员访问表达式的一部分，其中该类具有该成员或从具有该成员的类派生，包括使用非静态成员名称时出现的隐式 &lt;code&gt;this-&amp;gt;&lt;/code&gt; 成员访问表达式在任何地方上下文的&lt;a href=&quot;this&quot;&gt;这个&lt;/a&gt;是允许的（成员函数体内部，在成员初始化列表，在一流的默认成员初始化函数）。</target>
        </trans-unit>
        <trans-unit id="0cc54ba39b78a1ff9452057d5e234e2f1c5cc09c" translate="yes" xml:space="preserve">
          <source>1) As the comma may be used in the current locale as decimal separator, the output may be ambiguous. This can be solved with &lt;code&gt;&lt;a href=&quot;../../io/manip/showpoint&quot;&gt;std::showpoint&lt;/a&gt;&lt;/code&gt; which forces the decimal separator to be visible.</source>
          <target state="translated">1）由于逗号可能在当前语言环境中用作小数点分隔符，因此输出可能不明确。这可以通过 &lt;code&gt;&lt;a href=&quot;../../io/manip/showpoint&quot;&gt;std::showpoint&lt;/a&gt;&lt;/code&gt; 解决，它强制小数点分隔符可见。</target>
        </trans-unit>
        <trans-unit id="bf4f5eebb3756e5992406e2db6b3544a4860b1b1" translate="yes" xml:space="preserve">
          <source>1) Assigns &lt;code&gt;value&lt;/code&gt; to all of the elements.</source>
          <target state="translated">1）为所有元素分配 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0471cc16b46b1f8592b99a5def70ecd023e5db86" translate="yes" xml:space="preserve">
          <source>1) Assigns &lt;code&gt;x&lt;/code&gt; to the real part of the complex number. Imaginary part is set to zero.</source>
          <target state="translated">1）将 &lt;code&gt;x&lt;/code&gt; 赋给复数的实部。虚部设置为零。</target>
        </trans-unit>
        <trans-unit id="bd74c1606493d2cb5c5263fcb597f13362ee0e84" translate="yes" xml:space="preserve">
          <source>1) Assigns a copy of</source>
          <target state="translated">1)指定一份</target>
        </trans-unit>
        <trans-unit id="14686248fd4c999e4263d1cbae14e46f33834fac" translate="yes" xml:space="preserve">
          <source>1) Assigns by copying the state of &lt;code&gt;rhs&lt;/code&gt;, as if by &lt;code&gt;any(rhs).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1）通过复制 &lt;code&gt;rhs&lt;/code&gt; 的状态来 &lt;code&gt;any(rhs).swap(*this)&lt;/code&gt; ，就像通过any（rhs）.swap（* this）一样。</target>
        </trans-unit>
        <trans-unit id="79f8283f561eb803af10bf64d307d128f5f83943" translate="yes" xml:space="preserve">
          <source>1) Assigns character &lt;code&gt;a&lt;/code&gt; to character &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">1）将字符 &lt;code&gt;a&lt;/code&gt; 分配给字符 &lt;code&gt;r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b50adfd66ed3872fa645e5d68c15f0490c3528ad" translate="yes" xml:space="preserve">
          <source>1) Assigns each element in range &lt;code&gt;[first, last)&lt;/code&gt; a value generated by the given function object &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">1）给范围 &lt;code&gt;[first, last)&lt;/code&gt; 的每个元素分配由给定功能对象 &lt;code&gt;g&lt;/code&gt; 生成的值。</target>
        </trans-unit>
        <trans-unit id="27023b4931499f367feb0a7ac32948b060a43b0d" translate="yes" xml:space="preserve">
          <source>1) Assigns the contents of &lt;code&gt;other&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;flags&quot;&gt;flags()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; are equivalent to the values of &lt;code&gt;other.flags()&lt;/code&gt; and &lt;code&gt;other.mark_count()&lt;/code&gt; after the call.</source>
          <target state="translated">1）分配 &lt;code&gt;other&lt;/code&gt; 的内容。 &lt;code&gt;&lt;a href=&quot;flags&quot;&gt;flags()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; 等效于调用后的 &lt;code&gt;other.flags()&lt;/code&gt; 和 &lt;code&gt;other.mark_count()&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="3cb923639f2556c1a0b92d6585fc6bae83d4f775" translate="yes" xml:space="preserve">
          <source>1) Assigns the given &lt;code&gt;value&lt;/code&gt; to the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">1）将给定 &lt;code&gt;value&lt;/code&gt; 分配给 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的元素。</target>
        </trans-unit>
        <trans-unit id="cc010e5348cf35fe3386539e2bcb8ef2deb9b2f0" translate="yes" xml:space="preserve">
          <source>1) Assigns the given &lt;code&gt;value&lt;/code&gt; to the first &lt;code&gt;count&lt;/code&gt; elements in the range beginning at &lt;code&gt;first&lt;/code&gt; if &lt;code&gt;count &amp;gt; 0&lt;/code&gt;. Does nothing otherwise.</source>
          <target state="translated">1）分配给定 &lt;code&gt;value&lt;/code&gt; 到所述第一 &lt;code&gt;count&lt;/code&gt; 的范围内开始元件在 &lt;code&gt;first&lt;/code&gt; ，如果 &lt;code&gt;count &amp;gt; 0&lt;/code&gt; 。否则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="44657b2873420948c5a550c8cea126cd3bcf8a02" translate="yes" xml:space="preserve">
          <source>1) Assigns the pathname identified by the detected-format string &lt;code&gt;source&lt;/code&gt;, which is left in valid, but unspecified state.</source>
          <target state="translated">1）分配由检测到的格式字符串 &lt;code&gt;source&lt;/code&gt; 标识的路径名，该路径名保持有效但未指定状态。</target>
        </trans-unit>
        <trans-unit id="1c5a2378f7a4b4f8c3112c22372e803c7c5df859" translate="yes" xml:space="preserve">
          <source>1) Assigns values, generated by given function object &lt;code&gt;g&lt;/code&gt;, to the first &lt;code&gt;count&lt;/code&gt; elements in the range beginning at &lt;code&gt;first&lt;/code&gt;, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;. Does nothing otherwise.</source>
          <target state="translated">1）将值分配，通过给定函数对象生成 &lt;code&gt;g&lt;/code&gt; ，到所述第一 &lt;code&gt;count&lt;/code&gt; 的范围内的元素开始在 &lt;code&gt;first&lt;/code&gt; ，如果 &lt;code&gt;count&amp;gt;0&lt;/code&gt; 。否则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="1eab96dc5e46fc4e8f1977dffe840d7d81e24fe4" translate="yes" xml:space="preserve">
          <source>1) At every &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;, the values of all &lt;a href=&quot;cv&quot;&gt;volatile&lt;/a&gt; objects are stable (previous evaluations are complete, new evaluations not started)</source>
          <target state="translated">1）在每个&lt;a href=&quot;eval_order&quot;&gt;序列点&lt;/a&gt;，所有&lt;a href=&quot;cv&quot;&gt;易失&lt;/a&gt;对象的值都是稳定的（以前的评估已完成，新的评估未开始）</target>
        </trans-unit>
        <trans-unit id="2d2df9e87c835521a32a8b38e0df7638b8c0360b" translate="yes" xml:space="preserve">
          <source>1) Atomic types are not copy/move assignable</source>
          <target state="translated">1)原子类型是不可复制/移动分配的。</target>
        </trans-unit>
        <trans-unit id="1e1dd757f206c6d84410b18d446f5857c8473733" translate="yes" xml:space="preserve">
          <source>1) Atomically assigns a value &lt;code&gt;desired&lt;/code&gt; to the atomic variable. Equivalent to &lt;code&gt;store(desired)&lt;/code&gt;.</source>
          <target state="translated">1）以原子方式为原子变量分配 &lt;code&gt;desired&lt;/code&gt; 的值。等效于 &lt;code&gt;store(desired)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20eba43ce6c7c735f06737453bb9f5d0dcd49f5a" translate="yes" xml:space="preserve">
          <source>1) Atomically assigns a value &lt;code&gt;desired&lt;/code&gt; to the referenced object. Equivalent to &lt;code&gt;store(desired)&lt;/code&gt;.</source>
          <target state="translated">1）以原子方式为参考对象分配 &lt;code&gt;desired&lt;/code&gt; 的值。等效于 &lt;code&gt;store(desired)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="917158b5056f9fcbc3944d1e3cd72bab0516b4f5" translate="yes" xml:space="preserve">
          <source>1) Atomically obtains the value pointed to by &lt;code&gt;obj&lt;/code&gt; as if by &lt;code&gt;obj-&amp;gt;load()&lt;/code&gt;</source>
          <target state="translated">1）以原子方式获取 &lt;code&gt;obj&lt;/code&gt; 所指向的值，就像 &lt;code&gt;obj-&amp;gt;load()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d17583e702426f0634bea84e519c1633a6c029e1" translate="yes" xml:space="preserve">
          <source>1) Atomically releases &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed, or when the absolute time point &lt;code&gt;timeout_time&lt;/code&gt; is reached. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait_until&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1）以原子方式释放 &lt;code&gt;lock&lt;/code&gt; ，阻塞当前正在执行的线程，并将其添加到等待 &lt;code&gt;*this&lt;/code&gt; 的线程列表中。当执行 &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; 或达到绝对时间点 &lt;code&gt;timeout_time&lt;/code&gt; 时，该线程将被解除阻塞。它也可能会被虚假地阻止。解除阻止后，无论原因如何，都将重新获得 &lt;code&gt;lock&lt;/code&gt; ，并且 &lt;code&gt;wait_until&lt;/code&gt; 退出。如果此函数通过异常退出，则还将重新获得 &lt;code&gt;lock&lt;/code&gt; 。（直到C ++ 14）</target>
        </trans-unit>
        <trans-unit id="39228d6c9d016ca7d710e477075b422412a6e3a1" translate="yes" xml:space="preserve">
          <source>1) Atomically releases &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed, or when the relative timeout &lt;code&gt;rel_time&lt;/code&gt; expires. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait_for()&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1）以原子方式释放 &lt;code&gt;lock&lt;/code&gt; ，阻塞当前正在执行的线程，并将其添加到等待 &lt;code&gt;*this&lt;/code&gt; 的线程列表中。当执行 &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; 或相对超时 &lt;code&gt;rel_time&lt;/code&gt; 到期时，该线程将被解除阻塞。它也可能会被虚假地阻止。解除阻止后，无论出于何种原因，都 &lt;code&gt;lock&lt;/code&gt; 重新获得锁定，并退出 &lt;code&gt;wait_for()&lt;/code&gt; 。如果此函数通过异常退出，则还将重新获得 &lt;code&gt;lock&lt;/code&gt; 。（直到C ++ 14）</target>
        </trans-unit>
        <trans-unit id="2fda25784c4cf15cdc68975c9a93b19127874b2f" translate="yes" xml:space="preserve">
          <source>1) Atomically replaces the value pointed to by &lt;code&gt;obj&lt;/code&gt; with the value of &lt;code&gt;desr&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously, as if by &lt;code&gt;obj-&amp;gt;exchange(desr)&lt;/code&gt;</source>
          <target state="translated">1）以原子方式将 &lt;code&gt;obj&lt;/code&gt; 指向的值替换为 &lt;code&gt;desr&lt;/code&gt; 的值，并返回先前保存的值 &lt;code&gt;obj&lt;/code&gt; ，就像 &lt;code&gt;obj-&amp;gt;exchange(desr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a87743df627f94e6483569a8db0b5f5cafd7d8e" translate="yes" xml:space="preserve">
          <source>1) Atomically replaces the value pointed to by &lt;code&gt;obj&lt;/code&gt; with the value of &lt;code&gt;desr&lt;/code&gt; as if by &lt;code&gt;obj-&amp;gt;store(desr)&lt;/code&gt;</source>
          <target state="translated">1）以原子取代的值所指向的 &lt;code&gt;obj&lt;/code&gt; 与值 &lt;code&gt;desr&lt;/code&gt; 仿佛由 &lt;code&gt;obj-&amp;gt;store(desr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="407470d00a6b62854b98afb591359164b8cb7889" translate="yes" xml:space="preserve">
          <source>1) Atomically unlocks &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1）以原子方式解锁 &lt;code&gt;lock&lt;/code&gt; ，阻塞当前正在执行的线程，并将其添加到等待 &lt;code&gt;*this&lt;/code&gt; 的线程列表中。执行 &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; 时，该线程将被解除阻塞。它也可能会被虚假地阻止。解除阻止后，无论原因如何，都将重新获得 &lt;code&gt;lock&lt;/code&gt; 并 &lt;code&gt;wait&lt;/code&gt; 退出。如果此函数通过异常退出，则还将重新获得 &lt;code&gt;lock&lt;/code&gt; 。（直到C ++ 14）</target>
        </trans-unit>
        <trans-unit id="84cf693490eeb5e15a9f6ac3f4c02c6a3441ac7b" translate="yes" xml:space="preserve">
          <source>1) Attempts to create an object of type, denoted by the &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;&lt;code&gt;type&lt;/code&gt;, which may be array type, and may include a &lt;a href=&quot;auto&quot;&gt;placeholder type specifier&lt;/a&gt;(since C++11), or include a class template name whose argument is to be deduced by &lt;a href=&quot;deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;(since C++17).</source>
          <target state="translated">1）尝试创建由&lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id &lt;/a&gt; &lt;code&gt;type&lt;/code&gt; 表示的类型的对象，该对象可以是数组类型，并且可以包含&lt;a href=&quot;auto&quot;&gt;占位符类型说明符&lt;/a&gt;（自C ++ 11起），或者包含其参数为由&lt;a href=&quot;deduction_guide&quot;&gt;类模板参数推论&lt;/a&gt;推导出（自C ++ 17开始）。</target>
        </trans-unit>
        <trans-unit id="f48a394185752e2c4944c4fec900dc772a3b157b" translate="yes" xml:space="preserve">
          <source>1) Attempts to establish the floating-point rounding direction equal to the argument &lt;code&gt;round&lt;/code&gt;, which is expected to be one of the &lt;a href=&quot;fe_round&quot;&gt;floating point rounding macros&lt;/a&gt;.</source>
          <target state="translated">1）尝试建立等于自变量 &lt;code&gt;round&lt;/code&gt; 的浮点舍入方向，该方向应为&lt;a href=&quot;fe_round&quot;&gt;浮点舍入宏之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e3a5800b099aa0f75fced4ac6f2262d5f08936e" translate="yes" xml:space="preserve">
          <source>1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">1）尝试以获得在所述位掩码参数中列出的浮点异常标志的全部内容 &lt;code&gt;excepts&lt;/code&gt; ，这是一个按位的OR &lt;a href=&quot;fe_exceptions&quot;&gt;浮点异常宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="76935444316711f1ef025f07ccf80865f5a71493" translate="yes" xml:space="preserve">
          <source>1) Attempts to store the status of the floating-point environment in the object pointed to by &lt;code&gt;envp&lt;/code&gt;.</source>
          <target state="translated">1）尝试将浮点环境的状态存储在 &lt;code&gt;envp&lt;/code&gt; 指向的对象中。</target>
        </trans-unit>
        <trans-unit id="c537d0344b241074eb3e0571ce11684b3a4576f9" translate="yes" xml:space="preserve">
          <source>1) Average case: constant, worst case: &lt;code&gt;c.size()&lt;/code&gt;</source>
          <target state="translated">1）平均情况：常数，最坏情况： &lt;code&gt;c.size()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9b3845de48d795b10c6d53a55eac9b66f856548" translate="yes" xml:space="preserve">
          <source>1) Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;input.gcount()&lt;/code&gt; is not affected. After constructing and checking the sentry object, performs the following:</source>
          <target state="translated">1）表现为&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;，除了 &lt;code&gt;input.gcount()&lt;/code&gt; 不受影响。构造并检查哨兵对象后，执行以下操作：</target>
        </trans-unit>
        <trans-unit id="6af5c4964210e22b364a62aef34f203069bc01d3" translate="yes" xml:space="preserve">
          <source>1) Behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, determines the output format padding as follows:</source>
          <target state="translated">1）表现为&lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;。在构造并检查了哨兵对象之后，按如下方式确定输出格式的填充：</target>
        </trans-unit>
        <trans-unit id="abde054c511c98ef59ea6a6219a0d40067429c5f" translate="yes" xml:space="preserve">
          <source>1) Behaves as an &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, extracts a character and stores it to &lt;code&gt;ch&lt;/code&gt;. If no character is available, sets &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/a&gt; (in addition to &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/a&gt; that is set as required of a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;).</source>
          <target state="translated">1）表现为&lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;。在构造并检查了可能跳过前导空白的哨兵对象之后，提取一个字符并将其存储到 &lt;code&gt;ch&lt;/code&gt; 。如果没有可用的字符，则设置&lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;failbit&lt;/code&gt; &lt;/a&gt;（除了由&lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;要求设置的&lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;eofbit&lt;/code&gt; &lt;/a&gt;之外）。</target>
        </trans-unit>
        <trans-unit id="66cf5e2bc278327aafd28d7df89e620a0de46000" translate="yes" xml:space="preserve">
          <source>1) Behaves as an &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, inserts the character &lt;code&gt;ch&lt;/code&gt;. If the type of the character is not &lt;code&gt;CharT&lt;/code&gt;, it is first converted with &lt;code&gt;os.widen(ch)&lt;/code&gt;. Padding is determined as follows: if &lt;code&gt;os.width()&amp;gt;1&lt;/code&gt;, then &lt;code&gt;os.width()-1&lt;/code&gt; copies of &lt;code&gt;os.fill()&lt;/code&gt; are added to the output character to form the output character sequence. If &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, the fill characters are placed after the output character, otherwise before. After insertion, &lt;code&gt;os.width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">1）表现为&lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;。在构造并检查了哨兵对象之后，插入字符 &lt;code&gt;ch&lt;/code&gt; 。如果字符类型不是 &lt;code&gt;CharT&lt;/code&gt; ，则首先使用 &lt;code&gt;os.widen(ch)&lt;/code&gt; 进行转换。填充如下确定：如果 &lt;code&gt;os.width()&amp;gt;1&lt;/code&gt; ，则 &lt;code&gt;os.width()-1&lt;/code&gt; 个的副本 &lt;code&gt;os.fill()&lt;/code&gt; 被添加到输出字符，以形成输出字符序列。如果 &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; ，则填充字符放置在输出字符之后，否则放置在输出字符之后。插入后， &lt;code&gt;os.width(0)&lt;/code&gt; 来取消的影响 &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; （如果有）。</target>
        </trans-unit>
        <trans-unit id="c4d17ec70cbf5d4f592fc6b2f432bf9f5427d7e3" translate="yes" xml:space="preserve">
          <source>1) Behaves as if (2) is called with &lt;code&gt;policy&lt;/code&gt; being &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt; | &lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt;. In other words, &lt;code&gt;f&lt;/code&gt; may be executed in another thread or it may be run synchronously when the resulting &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; is queried for a value.</source>
          <target state="translated">1）行为就好像（2）是在 &lt;code&gt;policy&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt; | &lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; 。换句话说，当查询结果 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 以获取值时， &lt;code&gt;f&lt;/code&gt; 可以在另一个线程中执行，也可以同步运行。</target>
        </trans-unit>
        <trans-unit id="1561ba4be61858948b7fed01763fdb3a6eb95b15" translate="yes" xml:space="preserve">
          <source>1) Behaves as if defined as follows:</source>
          <target state="translated">1)行为如定义如下:</target>
        </trans-unit>
        <trans-unit id="8175e77df8cae0e91832bcbf197a16dc79ef925d" translate="yes" xml:space="preserve">
          <source>1) Behaves in implementation-defined manner</source>
          <target state="translated">(1)以实施定义的方式行事。</target>
        </trans-unit>
        <trans-unit id="9b4755491e2aea36644386cd6d0dbcbbe4600c5a" translate="yes" xml:space="preserve">
          <source>1) Binds the first argument of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Effectively calls &lt;code&gt;&lt;a href=&quot;binder12&quot;&gt;std::binder1st&lt;/a&gt;&amp;lt;F&amp;gt;(f, typename F::first_argument_type(x))&lt;/code&gt;.</source>
          <target state="translated">1）将 &lt;code&gt;f&lt;/code&gt; 的第一个参数绑定到 &lt;code&gt;x&lt;/code&gt; 。有效地调用 &lt;code&gt;&lt;a href=&quot;binder12&quot;&gt;std::binder1st&lt;/a&gt;&amp;lt;F&amp;gt;(f, typename F::first_argument_type(x))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="984a8150c7ac39a66022118522276911d7cc5f49" translate="yes" xml:space="preserve">
          <source>1) Binds the first parameter to the value &lt;code&gt;value&lt;/code&gt; given at the construction of the object.</source>
          <target state="translated">1）结合的第一个参数的值 &lt;code&gt;value&lt;/code&gt; 在所述对象的构造给出。</target>
        </trans-unit>
        <trans-unit id="64831980f81dae6254ff1d82d0c72182c81bbba9" translate="yes" xml:space="preserve">
          <source>1) Both ranges must be sorted with &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">1）两个范围都必须使用 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 排序。</target>
        </trans-unit>
        <trans-unit id="6e7001be6592e516d5b51c004a74838c40e04025" translate="yes" xml:space="preserve">
          <source>1) Called by &lt;a href=&quot;../../language/delete&quot;&gt;delete-expressions&lt;/a&gt; to deallocate storage previously allocated for a single object. The behavior of the standard library implementation of this function is undefined unless &lt;code&gt;ptr&lt;/code&gt; is a null pointer or is a pointer previously obtained from the standard library implementation of &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t, &lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1）由&lt;a href=&quot;../../language/delete&quot;&gt;delete-expressions&lt;/a&gt;调用以取消分配先前为单个对象分配的存储。除非 &lt;code&gt;ptr&lt;/code&gt; 是空指针，或者是先前从 &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t, &lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;)&lt;/code&gt; 的标准库实现中获取的指针，否则未定义此函数的标准库实现的行为。</target>
        </trans-unit>
        <trans-unit id="b29fa0fabda5d69f4442be6c5fdef616a24dd581" translate="yes" xml:space="preserve">
          <source>1) Called by non-array &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate storage required for a single object. The standard library implementation allocates &lt;code&gt;count&lt;/code&gt; bytes from free store. In case of failure, the standard library implementation calls the function pointer returned by &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; and repeats allocation attempts until new handler does not return or becomes a null pointer, at which time it throws &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;. This function is required to return a pointer suitably aligned to hold an object of any fundamental alignment.</source>
          <target state="translated">1）由非数组&lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt;调用，以分配单个对象所需的存储。标准库实现从免费存储区分配 &lt;code&gt;count&lt;/code&gt; 字节。如果失败，标准库实现将调用 &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; 返回的函数指针，并重复分配尝试，直到新处理程序不返回或变为空指针为止，此时它将抛出 &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。需要此函数来返回适当对齐的指针，以容纳任何基本对齐的对象。</target>
        </trans-unit>
        <trans-unit id="1201c06b6c4799b1fe55caec61e97450a74c02c7" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;((T*)p)-&amp;gt;~T()&lt;/code&gt;</source>
          <target state="translated">1）调用 &lt;code&gt;((T*)p)-&amp;gt;~T()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60cf179e7f48d67030a9b02c5b10f02cbd88fc74" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::allocate(outer_allocator(), n)&lt;/code&gt;</source>
          <target state="translated">1）调用 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::allocate(outer_allocator(), n)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75d0c1937c63022053420ca73afdc6c6c3f42d8d" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;a.allocate(n)&lt;/code&gt;</source>
          <target state="translated">1）调用 &lt;code&gt;a.allocate(n)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="612ce7599a47183d9e5a7f878c33edddf6b15c5f" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;delete&lt;/code&gt; (primary template) or &lt;code&gt;delete[]&lt;/code&gt; (array specialization) on &lt;code&gt;ptr&lt;/code&gt;2) Defined as deleted</source>
          <target state="translated">1）在 &lt;code&gt;ptr&lt;/code&gt; 上调用 &lt;code&gt;delete&lt;/code&gt; （主模板）或 &lt;code&gt;delete[]&lt;/code&gt; （数组专门化）2）定义为delete</target>
        </trans-unit>
        <trans-unit id="f9949dd29b950802c3d58375f6e80bddb5aa08d9" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;delete&lt;/code&gt; on &lt;code&gt;ptr&lt;/code&gt;2) Calls &lt;code&gt;delete[]&lt;/code&gt; on &lt;code&gt;ptr&lt;/code&gt;. This function will only participate in overload resolution if &lt;code&gt;U(*)[]&lt;/code&gt; is implicitly convertible to &lt;code&gt;T(*)[]&lt;/code&gt;.</source>
          <target state="translated">1）调用 &lt;code&gt;delete&lt;/code&gt; 上 &lt;code&gt;ptr&lt;/code&gt; 2）调用 &lt;code&gt;delete[]&lt;/code&gt; 上 &lt;code&gt;ptr&lt;/code&gt; 。如果 &lt;code&gt;U(*)[]&lt;/code&gt; 可隐式转换为 &lt;code&gt;T(*)[]&lt;/code&gt; ,则此函数将仅参与重载解析。</target>
        </trans-unit>
        <trans-unit id="18edfbb5ff4b58d729699ca4db1ff32af0d3018f" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;new((void *)p) T(val)&lt;/code&gt;</source>
          <target state="translated">1）调用 &lt;code&gt;new((void *)p) T(val)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d55a7910f52d41d1727553c431ed7d3dd8fbe500" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）调用最派生类的 &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1275e8a0c91e8f2137761ada491aefdcab7cbfe3" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;seekpos(pos, which)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）调用最派生类的 &lt;code&gt;seekpos(pos, which)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ce04d40fb13795e660c624012ebc10673555aff" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;setbuf(s, n)&lt;/code&gt; of the most derived class</source>
          <target state="translated">1）调用派生程度最高的类的 &lt;code&gt;setbuf(s, n)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="189c8c3b03cc9ff928fbd4420e4f08a2f0060d6d" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;str.erase()&lt;/code&gt;</source>
          <target state="translated">1）调用 &lt;code&gt;str.erase()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="968bf3d903f71b89d9f7ec9294f33c57ce120fc1" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;sync()&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）调用最派生类的 &lt;code&gt;sync()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="730f19f3ac0934ef27532bf7c9384f807d2f9aed" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;xsgetn(s, count)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）调用最派生类的 &lt;code&gt;xsgetn(s, count)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec64be5663b85a72b50b7ff9f40df45f3c1977e7" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;xsputn(s, count)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）调用最派生类的 &lt;code&gt;xsputn(s, count)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="168b614f9f40ac5f9718c1bbf48c0be54f15eee3" translate="yes" xml:space="preserve">
          <source>1) Calls every callback registered by &lt;code&gt;&lt;a href=&quot;../ios_base/register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; passing &lt;a href=&quot;../ios_base/event&quot;&gt;&lt;code&gt;erase_event&lt;/code&gt;&lt;/a&gt; as parameter</source>
          <target state="translated">1）调用 &lt;code&gt;&lt;a href=&quot;../ios_base/register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 注册的每个回调，并通过参数&lt;a href=&quot;../ios_base/event&quot;&gt; &lt;code&gt;erase_event&lt;/code&gt; &lt;/a&gt;进行调用</target>
        </trans-unit>
        <trans-unit id="9815ff59a707fc80fc245c084207918bbda81cd8" translate="yes" xml:space="preserve">
          <source>1) Catch-clause that declares a named formal parameter</source>
          <target state="translated">1)声明一个命名的形式参数的Catch-lause。</target>
        </trans-unit>
        <trans-unit id="a2e6973b14cedb89a76d6c2303ae23c129573389" translate="yes" xml:space="preserve">
          <source>1) Changes the current preprocessor line number to lineno. Expansions of the macro &lt;code&gt;__LINE__&lt;/code&gt; beyond this point will expand to lineno plus the number of actual source code lines encountered since.</source>
          <target state="translated">1）将当前的预处理器行号更改为lineno。宏 &lt;code&gt;__LINE__&lt;/code&gt; 的扩展将扩展为lineno加上此后遇到的实际源代码行的数量。</target>
        </trans-unit>
        <trans-unit id="251ac3216df00c46dba0c1fcacce145761ea51d6" translate="yes" xml:space="preserve">
          <source>1) Character width: unset, narrow or wide</source>
          <target state="translated">1)字符宽度:未设置,窄或宽。</target>
        </trans-unit>
        <trans-unit id="528a3c47bcb0f4bda9d76624cab85acce69f7c8b" translate="yes" xml:space="preserve">
          <source>1) Checks if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1）检查 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 是否相等。</target>
        </trans-unit>
        <trans-unit id="653944661bbab0d4335db30edc3fcd7d09dead4d" translate="yes" xml:space="preserve">
          <source>1) Checks if all bits are set to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1）检查所有位是否都设置为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c372d3881ed1d3880dc2bcd3c0763ed5a3e843a" translate="yes" xml:space="preserve">
          <source>1) Checks if the character &lt;code&gt;c&lt;/code&gt; is classified by the mask &lt;code&gt;m&lt;/code&gt; according to the classification table returned by the member function &lt;code&gt;table()&lt;/code&gt;. Effectively calculates &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt;</source>
          <target state="translated">1）根据成员函数 &lt;code&gt;table()&lt;/code&gt; 返回的分类表，检查字符 &lt;code&gt;c&lt;/code&gt; 是否由掩码 &lt;code&gt;m&lt;/code&gt; 分类。有效地计算 &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="055fc3ccc188ca6bb065e219ee940c38e7022dff" translate="yes" xml:space="preserve">
          <source>1) Checks if there is an element with key equivalent to &lt;code&gt;key&lt;/code&gt; in the container.</source>
          <target state="translated">1）检查容器中是否存在具有与key等效的 &lt;code&gt;key&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="01ce0d85d642a69a60a7bd7021acaa1e1acddc49" translate="yes" xml:space="preserve">
          <source>1) Checks if unary predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">1）检查一元谓词 &lt;code&gt;p&lt;/code&gt; 是否对 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的所有元素返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="807fd23a250c000cd2d3ce89e2e7e20500a459ae" translate="yes" xml:space="preserve">
          <source>1) Checks if unary predicate &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; (after projecting with the projection &lt;code&gt;proj&lt;/code&gt;).</source>
          <target state="translated">1）检查一元谓词 &lt;code&gt;pred&lt;/code&gt; 是否对 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的所有元素返回 &lt;code&gt;true&lt;/code&gt; （使用投影 &lt;code&gt;proj&lt;/code&gt; 投影之后）。</target>
        </trans-unit>
        <trans-unit id="af5a0d7b95029857fc67f9aec30edea70c5bdbe5" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;a href=&quot;root_path&quot;&gt;&lt;code&gt;root_path()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">1）检查&lt;a href=&quot;root_path&quot;&gt; &lt;code&gt;root_path()&lt;/code&gt; &lt;/a&gt;是否为空。</target>
        </trans-unit>
        <trans-unit id="faa74b887ee96c25a3492d6735e13770ce680b0e" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same object.</source>
          <target state="translated">1）检查 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 是否引用相同的对象。</target>
        </trans-unit>
        <trans-unit id="2dba4b22cc7fa19bfacb9c9df88e70c92a237039" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1）检查 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 是否相等。</target>
        </trans-unit>
        <trans-unit id="e8185a1925a4fbfb166981361f79075e2ee33f60" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal. Equivalent to &lt;code&gt;!(lhs &amp;lt; rhs) &amp;amp;&amp;amp; !(rhs &amp;lt; lhs)&lt;/code&gt;.</source>
          <target state="translated">1）检查 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 是否相等。等效于 &lt;code&gt;!(lhs &amp;lt; rhs) &amp;amp;&amp;amp; !(rhs &amp;lt; lhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fcbd95aabb4ff5227cf670c7cd313a716db3f1b" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">1）检查 &lt;code&gt;lhs&lt;/code&gt; 是否</target>
        </trans-unit>
        <trans-unit id="025b85874b3e1d46d1eddf5eb17f542191097060" translate="yes" xml:space="preserve">
          <source>1) Compares &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for equality.</source>
          <target state="translated">1）比较 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是否相等。</target>
        </trans-unit>
        <trans-unit id="ba27d1cf06b36c7b4c27679328ea9f73d35759e5" translate="yes" xml:space="preserve">
          <source>1) Compares &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; for equality.</source>
          <target state="translated">1）比较 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 是否相等。</target>
        </trans-unit>
        <trans-unit id="379cb0f357c5f6804b447714bf22e588013d0adb" translate="yes" xml:space="preserve">
          <source>1) Compares this string to</source>
          <target state="translated">1)将此字符串与</target>
        </trans-unit>
        <trans-unit id="95bc5c17aaacd83f1d13fbd093132d7300e74abf" translate="yes" xml:space="preserve">
          <source>1) Compares two &lt;code&gt;sub_match&lt;/code&gt; directly by comparing their underlying character sequences. Equivalent to &lt;code&gt;str().compare(m.str())&lt;/code&gt;.</source>
          <target state="translated">1）直接比较两个 &lt;code&gt;sub_match&lt;/code&gt; ，方法是比较它们的基础字符序列。等效于 &lt;code&gt;str().compare(m.str())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="babefe1ac4774ec2ba6d2f9315221ca39913970c" translate="yes" xml:space="preserve">
          <source>1) Compares two distribution objects for equality.</source>
          <target state="translated">1)比较两个分配对象是否平等。</target>
        </trans-unit>
        <trans-unit id="35a9eb1fa11c8a233e6c0a2c9a6bd06330c5cb30" translate="yes" xml:space="preserve">
          <source>1) Computes the</source>
          <target state="translated">1)计算</target>
        </trans-unit>
        <trans-unit id="29e45200813ec27005f84e8b35b75cfdc6f3c406" translate="yes" xml:space="preserve">
          <source>1) Computes the (physicist's) &lt;a href=&quot;https://en.wikipedia.org/wiki/Hermite_polynomials&quot;&gt;Hermite polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1）计算（物理学家的）&lt;a href=&quot;https://en.wikipedia.org/wiki/Hermite_polynomials&quot;&gt;埃尔米特多项式&lt;/a&gt;的程度的 &lt;code&gt;n&lt;/code&gt; 和参数 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cd529178d75829687d759cf3575835519db392b" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Associated_Legendre_polynomials&quot;&gt;associated Legendre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Associated_Legendre_polynomials&quot;&gt;相关联的勒让德多项式&lt;/a&gt;的程度的 &lt;code&gt;n&lt;/code&gt; ，顺序 &lt;code&gt;m&lt;/code&gt; 和参数 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11b6095d1bbc46a80dd8c941788ea2de6b4c76aa" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1&quot;&gt;cylindrical Bessel function of the first kind&lt;/a&gt; of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1&quot;&gt;的第一种圆柱形贝塞尔函数&lt;/a&gt;的 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09a1bb2811a36108b87f462b1c39d364fc3d72dc" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_second_kind:_Y.CE.B1&quot;&gt;cylindrical Neumann function&lt;/a&gt; (also known as Bessel function of the second kind or Weber function) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1）计算 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的&lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_second_kind:_Y.CE.B1&quot;&gt;圆柱诺依曼函数&lt;/a&gt;（也称为第二类贝塞尔函数或韦伯函数）。</target>
        </trans-unit>
        <trans-unit id="4c4124d09b398c54819810bb7083904eeb5106df" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;irregular modified cylindrical Bessel function&lt;/a&gt; (also known as modified Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1）计算 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的&lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;不规则修正圆柱Bessel函数&lt;/a&gt;（也称为第二种修正贝塞尔函数）。</target>
        </trans-unit>
        <trans-unit id="ccf9684995d2a46db4ec7d7201afb8deb62574e0" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;regular modified cylindrical Bessel function&lt;/a&gt; of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;规则改性圆柱形贝塞尔函数&lt;/a&gt;的 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61a6248b455016d83fb9f4ae46600e92647e97f9" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;spherical Bessel function of the first kind&lt;/a&gt; of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;的第一种球形贝塞尔函数&lt;/a&gt;的 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58bd3e8ee95098c0c96f4de4b3b5b3f2da549f3f" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;spherical Bessel function of the second kind&lt;/a&gt;, also known as the spherical Neumann function, of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1）计算 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;的第二种球形贝塞尔函数&lt;/a&gt;，也称为球形诺伊曼函数。</target>
        </trans-unit>
        <trans-unit id="bd5509c7dd414eeed186d9c04f5e19a8ae9447d6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function&quot;&gt;beta function&lt;/a&gt; of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">1）计算的&lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function&quot;&gt;&amp;beta;函数&lt;/a&gt;的 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20e020a9e1ce8ef730c0d0cab5e6865004161b48" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_conjugate&quot;&gt;complex conjugate&lt;/a&gt; of &lt;code&gt;z&lt;/code&gt; by reversing the sign of the imaginary part.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_conjugate&quot;&gt;复共轭&lt;/a&gt;的 &lt;code&gt;z&lt;/code&gt; 通过反转虚部的符号。</target>
        </trans-unit>
        <trans-unit id="bed7cd35295f9a8460aa9f26a5fd423e0f5632e6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_first_kind&quot;&gt;complete elliptic integral of the first kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">1）计算的&lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_first_kind&quot;&gt;第一类完全椭圆积分&lt;/a&gt;的 &lt;code&gt;k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33b1e6d2c533af4241eec10ee1fc6c7a568c2e97" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_second_kind&quot;&gt;complete elliptic integral of the second kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_second_kind&quot;&gt;所述第二种完全椭圆积分&lt;/a&gt;的 &lt;code&gt;k&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d44887ee66b13404fd46bfb48d18761afabeb530" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_third_kind&quot;&gt;complete elliptic integral of the third kind&lt;/a&gt; of the arguments &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;nu;&lt;/code&gt;.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_third_kind&quot;&gt;第三种&lt;/a&gt;参数 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;&amp;nu;&lt;/code&gt; 的完全椭圆积分。</target>
        </trans-unit>
        <trans-unit id="34c90fd51c4b11003b3fbb3c42c725019e1184d5" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Elliptic_integral_of_the_first_kind&quot;&gt;incomplete elliptic integral of the first kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Elliptic_integral_of_the_first_kind&quot;&gt;的第一种不完全椭圆积分&lt;/a&gt;的 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;&amp;phi;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18c3b8c68fe18231bc4683a4dab18461556c8a6e" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_second_kind&quot;&gt;incomplete elliptic integral of the second kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_second_kind&quot;&gt;所述第二种不完全椭圆积分&lt;/a&gt;的 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;&amp;phi;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2a10c9a8d077e7cf3be02757334df49842de441" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_third_kind&quot;&gt;incomplete elliptic integral of the third kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;&amp;nu;&lt;/code&gt;, and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_third_kind&quot;&gt;的第三种不完全椭圆积分&lt;/a&gt;的 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;&amp;nu;&lt;/code&gt; ，和 &lt;code&gt;&amp;phi;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a057675fa979fcdd978ffe3a864ce85d4f81ad27" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_integral&quot;&gt;exponential integral&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_integral&quot;&gt;指数积分&lt;/a&gt;的 &lt;code&gt;arg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="194521a0cc3e924de1e24b00830776378f111bf6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials&quot;&gt;associated Laguerre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials&quot;&gt;相关联的拉盖尔多项式&lt;/a&gt;的程度的 &lt;code&gt;n&lt;/code&gt; ，顺序 &lt;code&gt;m&lt;/code&gt; 和参数 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="447c8a8a3695dfb2c0135ecd809d50a81ac60799" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Riemann_zeta_function&quot;&gt;Riemann zeta function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1）计算&lt;a href=&quot;https://en.wikipedia.org/wiki/Riemann_zeta_function&quot;&gt;黎曼&amp;zeta;函数&lt;/a&gt;的 &lt;code&gt;arg&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec4c5063d8c1e5217253c6566900149f02eb3ff3" translate="yes" xml:space="preserve">
          <source>1) Computes the inverse tangent of each pair of corresponding values from &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1）从 &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 计算每对对应值的反正切。</target>
        </trans-unit>
        <trans-unit id="9f69a96b516d331be6b80e58bbf178ccead673fa" translate="yes" xml:space="preserve">
          <source>1) Computes the non-associated &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials&quot;&gt;Laguerre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1）计算非关联&lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials&quot;&gt;拉盖尔多项式&lt;/a&gt;的程度的 &lt;code&gt;n&lt;/code&gt; 和参数 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96823949bd54a22f8ca1311f8a8c38cf707e34c9" translate="yes" xml:space="preserve">
          <source>1) Computes the spherical associated Legendre function of degree &lt;code&gt;l&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and polar angle &lt;code&gt;&amp;theta;&lt;/code&gt;.</source>
          <target state="translated">1）计算度数 &lt;code&gt;l&lt;/code&gt; ，阶次 &lt;code&gt;m&lt;/code&gt; 和极角 &lt;code&gt;&amp;theta;&lt;/code&gt; 的球面关联勒让德函数。</target>
        </trans-unit>
        <trans-unit id="494b5451cb229192203200646404e640730476f1" translate="yes" xml:space="preserve">
          <source>1) Computes the unassociated &lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;Legendre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1）计算非关联&lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;Legendre多项式&lt;/a&gt;的程度的 &lt;code&gt;n&lt;/code&gt; 和参数 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="021f4354ef970a1b656513a9b0be260507748eec" translate="yes" xml:space="preserve">
          <source>1) Computes the values of each element in the numeric array &lt;code&gt;base&lt;/code&gt; raised to the power specified by the corresponding element from the numeric array &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">1）计算数字数组 &lt;code&gt;base&lt;/code&gt; 中每个元素的值，并提高到数字数组 &lt;code&gt;exp&lt;/code&gt; 中相应元素指定的幂。</target>
        </trans-unit>
        <trans-unit id="58d25c5a734cad90917e4f1983b210515311a450" translate="yes" xml:space="preserve">
          <source>1) Const reference to the value stored in the shared state. Accessing the value through this reference is undefined after the shared state has been destroyed.</source>
          <target state="translated">1)存储在共享状态中的值的Const引用。在共享状态被销毁后,通过该引用访问该值是未定义的。</target>
        </trans-unit>
        <trans-unit id="1fda2d3df21980fc0c991439c0b017a5cbfcceaa" translate="yes" xml:space="preserve">
          <source>1) Constant</source>
          <target state="translated">1)常数</target>
        </trans-unit>
        <trans-unit id="883376fb1cd5c259eb6c95ea63e4001892914fb5" translate="yes" xml:space="preserve">
          <source>1) Constant.</source>
          <target state="translated">1)恒定。</target>
        </trans-unit>
        <trans-unit id="8348152efcbbea63fdeddd6840b070be4fb7a774" translate="yes" xml:space="preserve">
          <source>1) Constructs &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage starting at &lt;code&gt;first&lt;/code&gt; by &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1）在未初始化存储中构造类型为 &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; &lt;code&gt;n&lt;/code&gt; 个对象，该对象 &lt;code&gt;first&lt;/code&gt; 从&lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization开始&lt;/a&gt;，就像</target>
        </trans-unit>
        <trans-unit id="a76414f38c38467178589672432e927144d5fca1" translate="yes" xml:space="preserve">
          <source>1) Constructs &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage starting at &lt;code&gt;first&lt;/code&gt; by &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1）构建 &lt;code&gt;n&lt;/code&gt; 类型的对象 &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; 在起始于未初始化的存储 &lt;code&gt;first&lt;/code&gt; 通过&lt;a href=&quot;../language/value_initialization&quot;&gt;值初始化&lt;/a&gt;，仿佛被</target>
        </trans-unit>
        <trans-unit id="8cfad2bd0fe265d0360e216522ed743e93e164f6" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;polymorphic_allocator&lt;/code&gt; using the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; as the underlying memory resource.</source>
          <target state="translated">1）使用 &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; （）的返回值作为基础内存资源构造一个 &lt;code&gt;polymorphic_allocator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="caf585f0b2cbecc991027b2c5d5ade0ff9fa6a44" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;shared_lock&lt;/code&gt; with no associated mutex.</source>
          <target state="translated">1）构造一个没有关联互斥锁的 &lt;code&gt;shared_lock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1691406fb44b80bf86d25e8199ea7826da306af" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::basic_filebuf&lt;/code&gt; object, initializing the base class by calling the default constructor of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;. The created &lt;code&gt;basic_filebuf&lt;/code&gt; is not associated with a file, and &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1）构造一个 &lt;code&gt;std::basic_filebuf&lt;/code&gt; 对象，通过调用 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 的默认构造函数来初始化基类。创建的 &lt;code&gt;basic_filebuf&lt;/code&gt; 不与文件关联， &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ed2e91b75fa0fbaf5c3602ace32ee3a481e1def" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::default_delete&lt;/code&gt; object.</source>
          <target state="translated">1）构造一个 &lt;code&gt;std::default_delete&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="d62c4ae5cb1598e1b293081929462849a710f111" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::packaged_task&lt;/code&gt; object with no task and no shared state.</source>
          <target state="translated">1）构造一个没有任务且没有共享状态的 &lt;code&gt;std::packaged_task&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="28c93deb18867bda8fc7f9df6c0fa46001aabb5a" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::strstreambuf&lt;/code&gt; object: initializes the base class by calling the default constructor of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;, initializes the buffer state to &quot;dynamic&quot; (the buffer will be allocated as needed), initializes allocated size to the provided &lt;code&gt;alsize&lt;/code&gt;, initializes the allocation and the deallocation functions to null (will use &lt;code&gt;new[]&lt;/code&gt; and &lt;code&gt;delete[]&lt;/code&gt;)</source>
          <target state="translated">1）构造一个 &lt;code&gt;std::strstreambuf&lt;/code&gt; 对象：通过调用 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 的默认构造函数初始化基类，将缓冲区状态初始化为&amp;ldquo;动态&amp;rdquo;（缓冲区将根据需要分配），将分配的大小初始化为提供的 &lt;code&gt;alsize&lt;/code&gt; ，将分配和释放函数初始化为null（将使用 &lt;code&gt;new[]&lt;/code&gt; 和 &lt;code&gt;delete[]&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="64cc8935216e3aea1780a77626ea547c25b59b13" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::unique_ptr&lt;/code&gt; that owns nothing. Value-initializes the stored pointer and the stored deleter. Requires that &lt;code&gt;Deleter&lt;/code&gt; is &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; and that construction does not throw an exception.</source>
          <target state="translated">1）构造没有任何内容的 &lt;code&gt;std::unique_ptr&lt;/code&gt; 。值初始化存储的指针和存储的删除器。要求 &lt;code&gt;Deleter&lt;/code&gt; 是&lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;，并且构造不会引发异常。</target>
        </trans-unit>
        <trans-unit id="2d37caf20ed678ee45772f6932c0c59569e653b3" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;unique_lock&lt;/code&gt; with no associated mutex.</source>
          <target state="translated">1）构造一个没有关联互斥锁的 &lt;code&gt;unique_lock&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b90797f613a746c0c6afab39848b6f01ca99d6fc" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;weekday_indexed&lt;/code&gt; from &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt;. The result represents the &lt;code&gt;index&lt;/code&gt;-th weekday in some yet-to-be-specified month. If &lt;code&gt;index&lt;/code&gt; is not in the range [1, 5] or if &lt;code&gt;!ok()&lt;/code&gt; the values held in the result is unspecified.</source>
          <target state="translated">1）从 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;index&lt;/code&gt; 构造一个 &lt;code&gt;weekday_indexed&lt;/code&gt; 。结果表示未指定月份中的第-个工作日 &lt;code&gt;index&lt;/code&gt; 。如果 &lt;code&gt;index&lt;/code&gt; 不在[1，5]范围内，或者 &lt;code&gt;!ok()&lt;/code&gt; ，则结果中保留的值未指定。</target>
        </trans-unit>
        <trans-unit id="a877e234ee1a9651490a92e199612268aa6c085f" translate="yes" xml:space="preserve">
          <source>1) Constructs a distribution object with</source>
          <target state="translated">1)构造一个带有</target>
        </trans-unit>
        <trans-unit id="5839abe97e388fd0beeb46fbe0cbbe23df700f9c" translate="yes" xml:space="preserve">
          <source>1) Constructs a distribution object with n = 1, &amp;rho;0 = 1, b0 = 0, and b1 = 1.</source>
          <target state="translated">1）构造一个n = 1，&amp;rho;0= 1，b0 = 0和b1 = 1的分布对象。</target>
        </trans-unit>
        <trans-unit id="5c36468c5ae16e3151bf49dbb6037065bdee5887" translate="yes" xml:space="preserve">
          <source>1) Constructs a non-array type &lt;code&gt;T&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; are passed to the constructor of &lt;code&gt;T&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is not an array type. The function is equivalent to:</source>
          <target state="translated">1）构造一个非阵列类型 &lt;code&gt;T&lt;/code&gt; 。参数 &lt;code&gt;args&lt;/code&gt; 传递给 &lt;code&gt;T&lt;/code&gt; 的构造函数。如果 &lt;code&gt;T&lt;/code&gt; 不是数组类型，则此重载仅参与重载解析。该功能等效于：</target>
        </trans-unit>
        <trans-unit id="b5bbbb231a62824534ca087741ebf1ecc513e1ae" translate="yes" xml:space="preserve">
          <source>1) Constructs a value at the location the iterator points to from &lt;code&gt;el&lt;/code&gt;.</source>
          <target state="translated">1）在迭代器从 &lt;code&gt;el&lt;/code&gt; 指向的位置构造一个值。</target>
        </trans-unit>
        <trans-unit id="c1e6b4ba149ed3478a1436d89169e5bb7c611e15" translate="yes" xml:space="preserve">
          <source>1) Constructs an &lt;code&gt;atomic_ref&lt;/code&gt; object referencing the object &lt;code&gt;obj&lt;/code&gt;. The behavior is undefined if &lt;code&gt;obj&lt;/code&gt; is not aligned to &lt;a href=&quot;required_alignment&quot;&gt;&lt;code&gt;required_alignment&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1）构造一个引用对象 &lt;code&gt;obj&lt;/code&gt; 的 &lt;code&gt;atomic_ref&lt;/code&gt; 对象。如果 &lt;code&gt;obj&lt;/code&gt; 未与&lt;a href=&quot;required_alignment&quot;&gt; &lt;code&gt;required_alignment&lt;/code&gt; &lt;/a&gt;对齐，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="3f46d867616b349884c0eaec36a04a2b5e2f106e" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty container.</source>
          <target state="translated">1)构造一个空容器。</target>
        </trans-unit>
        <trans-unit id="bb6630efd81f0800437bcdd0637108688772c997" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty object.</source>
          <target state="translated">1)构造一个空对象。</target>
        </trans-unit>
        <trans-unit id="4aba85a0be5aa34c1a435f0e6a4e3db1b5c1bb67" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty path.</source>
          <target state="translated">1)构造一个空路径。</target>
        </trans-unit>
        <trans-unit id="92b1b20a2cb45b6fe0dfa5cf07ed62cbeefa5879" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty span whose &lt;code&gt;data() == nullptr&lt;/code&gt; and &lt;code&gt;size() == 0&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;extent == 0 || extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1）构造一个空跨度，其 &lt;code&gt;data() == nullptr&lt;/code&gt; 和 &lt;code&gt;size() == 0&lt;/code&gt; 。仅当 &lt;code&gt;extent == 0 || extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt; 此重载才参与重载解析。范围== std :: dynamic_extent。</target>
        </trans-unit>
        <trans-unit id="3c2ed7e86ad1634668a4421e8843d4216d314452" translate="yes" xml:space="preserve">
          <source>1) Constructs an end-of-stream iterator.</source>
          <target state="translated">1)构造一个流末迭代器。</target>
        </trans-unit>
        <trans-unit id="6a91b7a4528438ec1c732b76f2082be352aaa60b" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;T&lt;/code&gt; and wraps it in a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt; as the parameter list for the constructor of &lt;code&gt;T&lt;/code&gt;. The object is constructed as if by the expression &lt;code&gt;::new (pv) T(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;, where &lt;code&gt;pv&lt;/code&gt; is an internal &lt;code&gt;void*&lt;/code&gt; pointer to storage suitable to hold an object of type &lt;code&gt;T&lt;/code&gt;. The storage is typically larger than &lt;code&gt;sizeof(T)&lt;/code&gt; in order to use one allocation for both the control block of the shared pointer and the &lt;code&gt;T&lt;/code&gt; object. The &lt;code&gt;std::shared_ptr&lt;/code&gt; constructor called by this function enables &lt;code&gt;shared_from_this&lt;/code&gt; with a pointer to the newly constructed object of type &lt;code&gt;T&lt;/code&gt;. This overload only participates in overload resolution if T is not an array type</source>
          <target state="translated">1）构造类型为 &lt;code&gt;T&lt;/code&gt; 的对象，并使用 &lt;code&gt;args&lt;/code&gt; 作为 &lt;code&gt;T&lt;/code&gt; 的构造函数的参数列表将其包装在 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 。该对象就像由表达式 &lt;code&gt;::new (pv) T(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Args&amp;gt;（args）...）构造一样，其中 &lt;code&gt;pv&lt;/code&gt; 是内部 &lt;code&gt;void*&lt;/code&gt; 指向适合保存 &lt;code&gt;T&lt;/code&gt; 类型对象的存储的指针。存储通常大于 &lt;code&gt;sizeof(T)&lt;/code&gt; ，以便对共享指针和 &lt;code&gt;T&lt;/code&gt; 对象的控制块使用一种分配。此函数调用的 &lt;code&gt;std::shared_ptr&lt;/code&gt; 构造函数启用 &lt;code&gt;shared_from_this&lt;/code&gt; ，带有指向新构造的 &lt;code&gt;T&lt;/code&gt; 类型对象的指针。如果T不是数组类型，则此重载仅参与重载解析</target>
        </trans-unit>
        <trans-unit id="c65fce56c4a3fe00bfc3974bed79655a9cad1369" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;T&lt;/code&gt; and wraps it in a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt; as the parameter list for the constructor of &lt;code&gt;T&lt;/code&gt;. The object is constructed as if by the expression &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::construct(a, pv, v)&lt;/code&gt;, where &lt;code&gt;pv&lt;/code&gt; is an internal &lt;code&gt;void*&lt;/code&gt; pointer to storage suitable to hold an object of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is a copy of the allocator rebound to &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. The storage is typically larger than &lt;code&gt;sizeof(T)&lt;/code&gt; in order to use one allocation for both the control block of the shared pointer and the &lt;code&gt;T&lt;/code&gt; object. The &lt;code&gt;std::shared_ptr&lt;/code&gt; constructor called by this function enables &lt;code&gt;shared_from_this&lt;/code&gt; with a pointer to the newly constructed object of type &lt;code&gt;T&lt;/code&gt;. All memory allocation is done using a copy of &lt;code&gt;alloc&lt;/code&gt;, which must satisfy the &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirements. This overload only participates in overload resolution if T is not an array type</source>
          <target state="translated">1）构造类型为 &lt;code&gt;T&lt;/code&gt; 的对象，并使用 &lt;code&gt;args&lt;/code&gt; 作为 &lt;code&gt;T&lt;/code&gt; 的构造函数的参数列表将其包装在 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 。该对象就像通过表达式 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::construct(a, pv, v)&lt;/code&gt; &amp;lt;A2&amp;gt; :: construct（a，pv，v）进行构造，其中 &lt;code&gt;pv&lt;/code&gt; 是内部 &lt;code&gt;void*&lt;/code&gt; 指向适合保存 &lt;code&gt;T&lt;/code&gt; 类型对象的存储的指针，而 &lt;code&gt;a&lt;/code&gt; 是副本分配器反弹到 &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt;的时间。存储通常大于 &lt;code&gt;sizeof(T)&lt;/code&gt; ，以便对共享指针和 &lt;code&gt;T&lt;/code&gt; 的控制块使用一种分配目的。此函数调用的 &lt;code&gt;std::shared_ptr&lt;/code&gt; 构造函数使用指向新构造的 &lt;code&gt;T&lt;/code&gt; 类型对象的指针启用 &lt;code&gt;shared_from_this&lt;/code&gt; 。所有内存分配均使用 &lt;code&gt;alloc&lt;/code&gt; 副本完成，该副本必须满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator的&lt;/a&gt;要求。如果T不是数组类型，则此重载仅参与重载解析</target>
        </trans-unit>
        <trans-unit id="d78eaa4f8c9d96c9388558353abf67888821bd40" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;std::condition_variable&lt;/code&gt;.</source>
          <target state="translated">1）构造一个类型为 &lt;code&gt;std::condition_variable&lt;/code&gt; 的对象。</target>
        </trans-unit>
        <trans-unit id="c33554f7a405b880b69fcd197b5b45d0faf555d7" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;std::condition_variable_any&lt;/code&gt;.</source>
          <target state="translated">1）构造一个类型为 &lt;code&gt;std::condition_variable_any&lt;/code&gt; 的对象。</target>
        </trans-unit>
        <trans-unit id="4dca4893623f5a9eb91426447332e43a629e5e08" translate="yes" xml:space="preserve">
          <source>1) Constructs an object that</source>
          <target state="translated">1)构造一个对象,该对象</target>
        </trans-unit>
        <trans-unit id="a42c5463387778d35ce09fb74ca7c06a1d5d3fe5" translate="yes" xml:space="preserve">
          <source>1) Constructs empty container. Sets &lt;code&gt;max_load_factor()&lt;/code&gt; to 1.0. For the default constructor, the number of buckets is implementation-defined.</source>
          <target state="translated">1）构造空容器。将 &lt;code&gt;max_load_factor()&lt;/code&gt; 设置为1.0。对于默认构造函数，存储桶数由实现定义。</target>
        </trans-unit>
        <trans-unit id="cc74e3008936c370fbc2e91fcb346c72690c77ec" translate="yes" xml:space="preserve">
          <source>1) Constructs error code with default value. Equivalent to &lt;code&gt;error_code(0, &lt;a href=&quot;../system_category&quot;&gt;std::system_category&lt;/a&gt;())&lt;/code&gt;.</source>
          <target state="translated">1）构造具有默认值的错误代码。等效于 &lt;code&gt;error_code(0, &lt;a href=&quot;../system_category&quot;&gt;std::system_category&lt;/a&gt;())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f925a3f60c069a032e3937c5003b55a8c2dfe979" translate="yes" xml:space="preserve">
          <source>1) Constructs objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage designated by the range &lt;code&gt;[first, last)&lt;/code&gt; by &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1）通过&lt;a href=&quot;../language/default_initialization&quot;&gt;默认初始化&lt;/a&gt;在类型为 &lt;code&gt;[first, last)&lt;/code&gt; 的未初始化存储中构造类型类型为 &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; 对象，就像通过</target>
        </trans-unit>
        <trans-unit id="5ca8d62a3455adf4d9e43d7b921708a6d8a9a285" translate="yes" xml:space="preserve">
          <source>1) Constructs objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage designated by the range &lt;code&gt;[first, last)&lt;/code&gt; by &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1）构建体的类型的对象 &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; 在由范围指定的未初始化的存储 &lt;code&gt;[first, last)&lt;/code&gt; 由&lt;a href=&quot;../language/value_initialization&quot;&gt;值初始化&lt;/a&gt;，仿佛被</target>
        </trans-unit>
        <trans-unit id="c7e73e079cc70c58b19eccb9290637293ccbae99" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;auto_ptr&lt;/code&gt; with pointer &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">1）使用指针 &lt;code&gt;p&lt;/code&gt; 构造 &lt;code&gt;auto_ptr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0164e8149e0956c863ac9c36b9359f6da1d2d078" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_istream&lt;/code&gt; object, assigning initial values to the base class by calling &lt;code&gt;basic_ios::init(sb)&lt;/code&gt;. The value of &lt;code&gt;gcount()&lt;/code&gt; is initialized to zero.</source>
          <target state="translated">1）构造 &lt;code&gt;basic_istream&lt;/code&gt; 对象，通过调用 &lt;code&gt;basic_ios::init(sb)&lt;/code&gt; 将初始值分配给基类。的值 &lt;code&gt;gcount()&lt;/code&gt; 被初始化为零。</target>
        </trans-unit>
        <trans-unit id="9f59a9d9a66d857f281383b9ee9838b4c7e8b9e9" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_ostream&lt;/code&gt; object, assigning initial values to the base class by calling &lt;code&gt;&lt;a href=&quot;../basic_ios/init&quot;&gt;basic_ios::init(sb)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1）构造 &lt;code&gt;basic_ostream&lt;/code&gt; 对象，通过调用 &lt;code&gt;&lt;a href=&quot;../basic_ios/init&quot;&gt;basic_ios::init(sb)&lt;/a&gt;&lt;/code&gt; 将初始值分配给基类。</target>
        </trans-unit>
        <trans-unit id="e770895769dd6c60169d7f4420f35a940b3c3d4d" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_streambuf&lt;/code&gt; object, initializes the six pointer members (&lt;code&gt;eback()&lt;/code&gt;, &lt;code&gt;gptr()&lt;/code&gt;, &lt;code&gt;egptr()&lt;/code&gt;, &lt;code&gt;pbase()&lt;/code&gt;, &lt;code&gt;pptr()&lt;/code&gt;, and &lt;code&gt;epptr()&lt;/code&gt;) to null pointer values, and the locale member to &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt;, a copy of the global C++ locale at the time of construction.</source>
          <target state="translated">1）构造的 &lt;code&gt;basic_streambuf&lt;/code&gt; 对象，初始化六个指针部件（ &lt;code&gt;eback()&lt;/code&gt; ， &lt;code&gt;gptr()&lt;/code&gt; ， &lt;code&gt;egptr()&lt;/code&gt; ， &lt;code&gt;pbase()&lt;/code&gt; ， &lt;code&gt;pptr()&lt;/code&gt; ，和 &lt;code&gt;epptr()&lt;/code&gt; ），以空指针值，并且区域设置部件 &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt; ，是构建时全局C ++语言环境的副本。</target>
        </trans-unit>
        <trans-unit id="5a712e507b705a86029303f1b2e6b91abd34eca3" translate="yes" xml:space="preserve">
          <source>1) Constructs the complex number from real and imaginary parts.</source>
          <target state="translated">1)由实部和虚部构造复数。</target>
        </trans-unit>
        <trans-unit id="4d3565cc629e222a14a77967cd93c38e99b2c25e" translate="yes" xml:space="preserve">
          <source>1) Constructs the end iterator.</source>
          <target state="translated">1)构造末端迭代器。</target>
        </trans-unit>
        <trans-unit id="36c43a3b623f36dd562263833f62942dcde59be1" translate="yes" xml:space="preserve">
          <source>1) Constructs the end-of-stream iterator, value-initializes the stored value. This constructor is constexpr if the initializer in the definition &lt;code&gt;auto x = T();&lt;/code&gt; is a constant initializer.</source>
          <target state="translated">1）构造流结束迭代器，对存储的值进行值初始化。如果定义中的初始化器为 &lt;code&gt;auto x = T();&lt;/code&gt; 则此构造函数为constexpr 。是一个常量初始化器。</target>
        </trans-unit>
        <trans-unit id="567317c97bb9e808725c51c31daff371c53a7183" translate="yes" xml:space="preserve">
          <source>1) Constructs the iterator with &lt;code&gt;stream&lt;/code&gt; as the associated stream and &lt;code&gt;delim&lt;/code&gt; as the delimiter.</source>
          <target state="translated">1）构造迭代器，并将 &lt;code&gt;stream&lt;/code&gt; 作为关联流，并将 &lt;code&gt;delim&lt;/code&gt; 作为分隔符。</target>
        </trans-unit>
        <trans-unit id="21e8282094e94dff47b05cfa55b86fa929f80bfb" translate="yes" xml:space="preserve">
          <source>1) Constructs the iterator with the private &lt;code&gt;streambuf_type*&lt;/code&gt; member set to &lt;code&gt;buffer&lt;/code&gt; and the failed() bit set to &lt;code&gt;false&lt;/code&gt;. The behavior is undefined if &lt;code&gt;buffer&lt;/code&gt; is a null pointer.</source>
          <target state="translated">1）构造迭代器，并将私有 &lt;code&gt;streambuf_type*&lt;/code&gt; 成员设置为 &lt;code&gt;buffer&lt;/code&gt; ，而failed（）位设置为 &lt;code&gt;false&lt;/code&gt; 。如果 &lt;code&gt;buffer&lt;/code&gt; 为空指针，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="c0e385bee1b61c9f84d4023fcbdea59f912b0207" translate="yes" xml:space="preserve">
          <source>1) Constructs the mutex. The mutex is in unlocked state after the call.</source>
          <target state="translated">1)构造mutex。调用后,mutex处于解锁状态。</target>
        </trans-unit>
        <trans-unit id="6facaef49db759622faeb9fa50ba66a91993a2b8" translate="yes" xml:space="preserve">
          <source>1) Constructs the mutex. The mutex is in unlocked state after the constructor completes.</source>
          <target state="translated">1)构造mutex。构造函数完成后,mutex处于解锁状态。</target>
        </trans-unit>
        <trans-unit id="29377ade75ac8ee862d1d21eb062d5bb53a5931b" translate="yes" xml:space="preserve">
          <source>1) Constructs with error code &lt;code&gt;ec&lt;/code&gt;</source>
          <target state="translated">1）错误代码为 &lt;code&gt;ec&lt;/code&gt; 的构造</target>
        </trans-unit>
        <trans-unit id="0535a299ea56e25c15331c583b9b9f5ad995759c" translate="yes" xml:space="preserve">
          <source>1) Conversion that involves pointer to bool or pointer-to-member to bool is worse than the one that doesn't</source>
          <target state="translated">1)涉及到指针到bool或指针到成员到bool的转换比不涉及到指针到成员到bool的转换要差。</target>
        </trans-unit>
        <trans-unit id="e16d54f0bf7a4de50ea66eef76a20a090e2f4413" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;byte&lt;/code&gt; as if it was a string of length &lt;code&gt;1&lt;/code&gt; to wide_string.</source>
          <target state="translated">1）将 &lt;code&gt;byte&lt;/code&gt; （好像是长度为 &lt;code&gt;1&lt;/code&gt; 的字符串）转换为wide_string。</target>
        </trans-unit>
        <trans-unit id="197a10e3da9ede6e2bf81aba04bc89f7b2c98603" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;wchar&lt;/code&gt; as if it was a string of length &lt;code&gt;1&lt;/code&gt;, to &lt;code&gt;byte_string&lt;/code&gt;.</source>
          <target state="translated">1）将 &lt;code&gt;wchar&lt;/code&gt; ，如果它是长度的串 &lt;code&gt;1&lt;/code&gt; ，到 &lt;code&gt;byte_string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce60559adca1ecbc763b846b0ebcd3ea0bcd2729" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;T&amp;amp;&lt;/code&gt; as if by &lt;code&gt;T&amp;amp; t = &lt;a href=&quot;../../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(x);&lt;/code&gt;, then stores a reference to &lt;code&gt;t&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;typename &lt;a href=&quot;../../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;U&amp;gt;::type&lt;/code&gt; is not the same type as &lt;code&gt;reference_wrapper&lt;/code&gt; and the expression &lt;code&gt;FUN(&lt;a href=&quot;../../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; is well-formed, where &lt;code&gt;FUN&lt;/code&gt; names the set of imaginary functions</source>
          <target state="translated">1）将 &lt;code&gt;x&lt;/code&gt; 转换为 &lt;code&gt;T&amp;amp;&lt;/code&gt; 就像通过 &lt;code&gt;T&amp;amp; t = &lt;a href=&quot;../../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(x);&lt;/code&gt; ，然后存储对 &lt;code&gt;t&lt;/code&gt; 的引用。仅当 &lt;code&gt;typename &lt;a href=&quot;../../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;U&amp;gt;::type&lt;/code&gt; 与 &lt;code&gt;reference_wrapper&lt;/code&gt; 的类型不同并且表达式 &lt;code&gt;FUN(&lt;a href=&quot;../../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; 的格式正确，且 &lt;code&gt;FUN&lt;/code&gt; 将其命名为虚函数集</target>
        </trans-unit>
        <trans-unit id="3b2e425231980e3b26025193db6c0158ff8d1aa6" translate="yes" xml:space="preserve">
          <source>1) Converts a signed decimal integer to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%d&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">1）将带符号的十进制整数转换为与 &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%d&quot;, value)&lt;/code&gt; 对于足够大的 &lt;code&gt;buf&lt;/code&gt; 会产生相同内容的字符串。</target>
        </trans-unit>
        <trans-unit id="8e981b67a7ad4cb8a3d3ec53bfb06c19e2cd41df" translate="yes" xml:space="preserve">
          <source>1) Converts a signed decimal integer to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%d&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">1）将带符号的十进制整数转换为宽字符串，其内容与为足够大的 &lt;code&gt;buf&lt;/code&gt; 会产生的 &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%d&quot;, value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dc8e4275413329fa1e66540999bd4062579b6f2" translate="yes" xml:space="preserve">
          <source>1) Converts the &lt;code&gt;file_time&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to a &lt;code&gt;sys_time&lt;/code&gt; representing the same point in time.</source>
          <target state="translated">1）将 &lt;code&gt;file_time&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 转换为代表相同时间点的 &lt;code&gt;sys_time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbc6867b0f47d015a04ea763b2e464a464fd6f94" translate="yes" xml:space="preserve">
          <source>1) Converts the &lt;code&gt;file_time&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to a &lt;code&gt;utc_time&lt;/code&gt; representing the same point in time.</source>
          <target state="translated">1）将 &lt;code&gt;file_time&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; 转换为表示相同时间点的 &lt;code&gt;utc_time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="076c6e693f308ce0f6a0c89dfaa4b7efdd201143" translate="yes" xml:space="preserve">
          <source>1) Converts the two durations to their common type and creates a duration whose tick count is the sum of the tick counts after conversion.</source>
          <target state="translated">1)将两个持续时间转换为它们的共同类型,并创建一个持续时间,其tick计数是转换后tick计数的总和。</target>
        </trans-unit>
        <trans-unit id="888ab527c89c913804d1c2c29b389f2611f52687" translate="yes" xml:space="preserve">
          <source>1) Copies &lt;code&gt;count&lt;/code&gt; elements from a range beginning at &lt;code&gt;first&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1）复制 &lt;code&gt;count&lt;/code&gt; 从一系列元素开始在 &lt;code&gt;first&lt;/code&gt; 到未初始化的存储器区域在开始 &lt;code&gt;d_first&lt;/code&gt; 仿佛由</target>
        </trans-unit>
        <trans-unit id="a5b971875873e04ebbd8f3dd90705985a75d4ec9" translate="yes" xml:space="preserve">
          <source>1) Copies all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; starting from first and proceeding to last - 1. The behavior is undefined if &lt;code&gt;d_first&lt;/code&gt; is within the range &lt;code&gt;[first, last)&lt;/code&gt;. In this case, &lt;code&gt;&lt;a href=&quot;copy_backward&quot;&gt;std::copy_backward&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="translated">1）从first开始复制并复制到last-1 范围内的 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的所有元素。如果 &lt;code&gt;d_first&lt;/code&gt; 在 &lt;code&gt;[first, last)&lt;/code&gt; 范围内，则行为不确定。在这种情况下，可以代替使用 &lt;code&gt;&lt;a href=&quot;copy_backward&quot;&gt;std::copy_backward&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06ea4d57b4c85fc6e7bcfe101f3b3fdc533f62f9" translate="yes" xml:space="preserve">
          <source>1) Copies characters in the range &lt;code&gt;[first,last)&lt;/code&gt; to &lt;code&gt;out&lt;/code&gt;, replacing any sequences that match &lt;code&gt;re&lt;/code&gt; with characters formatted by &lt;code&gt;fmt&lt;/code&gt;. In other words:</source>
          <target state="translated">1）将 &lt;code&gt;[first,last)&lt;/code&gt; 范围内的字符复制到 &lt;code&gt;out&lt;/code&gt; ，用 &lt;code&gt;fmt&lt;/code&gt; 格式化的字符替换所有与 &lt;code&gt;re&lt;/code&gt; 匹配的序列。换一种说法：</target>
        </trans-unit>
        <trans-unit id="3c0e21f1d72032ced3cf99d25a163352df8fb16d" translate="yes" xml:space="preserve">
          <source>1) Copies elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1）从范围份数元素 &lt;code&gt;[first, last)&lt;/code&gt; 到一个未初始化的存储器区域在开始 &lt;code&gt;d_first&lt;/code&gt; 仿佛由</target>
        </trans-unit>
        <trans-unit id="eaa8b895fbfe22af946e0d1f21d2e21b2ccbf6f4" translate="yes" xml:space="preserve">
          <source>1) Copies exactly &lt;code&gt;count&lt;/code&gt; values from the range beginning at &lt;code&gt;first&lt;/code&gt; to the range beginning at &lt;code&gt;result&lt;/code&gt;. Formally, for each non-negative integer &lt;code&gt;i &amp;lt; n&lt;/code&gt;, performs &lt;code&gt;*(result + i) = *(first + i)&lt;/code&gt;. Overlap of ranges is not permitted.</source>
          <target state="translated">1）从 &lt;code&gt;first&lt;/code&gt; 开始的范围到从 &lt;code&gt;result&lt;/code&gt; 开始的范围精确 &lt;code&gt;count&lt;/code&gt; 数值。形式上，对于每个非负整数 &lt;code&gt;i &amp;lt; n&lt;/code&gt; ，执行 &lt;code&gt;*(result + i) = *(first + i)&lt;/code&gt; 。范围的重叠是不允许的。</target>
        </trans-unit>
        <trans-unit id="2428bbef7516a0c37d09fb2808331b76c9c46ca3" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to another range beginning at &lt;code&gt;d_first&lt;/code&gt; in such a way that the elements in the new range are in reverse order.</source>
          <target state="translated">1）以这样的方式将元素从 &lt;code&gt;[first, last)&lt;/code&gt; 范围复制到另一个以 &lt;code&gt;d_first&lt;/code&gt; 开始的范围，即新范围中的元素的顺序相反。</target>
        </trans-unit>
        <trans-unit id="4614ab1a6d2346fd0652f2db85a8f495164eebe2" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to two different ranges depending on the value returned by the predicate &lt;code&gt;p&lt;/code&gt;. The elements that satisfy the predicate &lt;code&gt;p&lt;/code&gt; are copied to the range beginning at &lt;code&gt;d_first_true&lt;/code&gt;. The rest of the elements are copied to the range beginning at &lt;code&gt;d_first_false&lt;/code&gt;.</source>
          <target state="translated">1）根据谓词 &lt;code&gt;p&lt;/code&gt; 返回的值 &lt;code&gt;[first, last)&lt;/code&gt; 将元素从[first，last）范围复制到两个不同的范围。将满足谓词 &lt;code&gt;p&lt;/code&gt; 的元素复制到以 &lt;code&gt;d_first_true&lt;/code&gt; 开头的范围。其余元素将复制到 &lt;code&gt;d_first_false&lt;/code&gt; 开头的范围。</target>
        </trans-unit>
        <trans-unit id="98b63d2d9267bc9998d8406ce508196f6fbe30f0" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range beginning at &lt;code&gt;d_first&lt;/code&gt; in such a way, that the element &lt;code&gt;n_first&lt;/code&gt; becomes the first element of the new range and &lt;code&gt;n_first - 1&lt;/code&gt; becomes the last element.</source>
          <target state="translated">1）将元素从 &lt;code&gt;[first, last)&lt;/code&gt; 范围复制到另一个以 &lt;code&gt;d_first&lt;/code&gt; 开始的范围，以使元素 &lt;code&gt;n_first&lt;/code&gt; 成为新范围的第一个元素，而 &lt;code&gt;n_first - 1&lt;/code&gt; 成为最后一个元素。</target>
        </trans-unit>
        <trans-unit id="84fa46dde26717bac9ce3f7378e2314898b8e7d1" translate="yes" xml:space="preserve">
          <source>1) Copies the given &lt;code&gt;value&lt;/code&gt; to an uninitialized memory area, defined by the range &lt;code&gt;[first, last)&lt;/code&gt; as if by</source>
          <target state="translated">1）将给定 &lt;code&gt;value&lt;/code&gt; 复制到未初始化的存储区中，该存储区由范围 &lt;code&gt;[first, last)&lt;/code&gt; 定义，就像</target>
        </trans-unit>
        <trans-unit id="3b6ae258a56e6dc4788e6367a261c4cc04b85921" translate="yes" xml:space="preserve">
          <source>1) Copies the given value &lt;code&gt;value&lt;/code&gt; to the first &lt;code&gt;count&lt;/code&gt; elements in an uninitialized memory area beginning at &lt;code&gt;first&lt;/code&gt; as if by</source>
          <target state="translated">1）将进给定值 &lt;code&gt;value&lt;/code&gt; 到所述第一 &lt;code&gt;count&lt;/code&gt; 中一个未初始化的存储区域的元件开始在 &lt;code&gt;first&lt;/code&gt; 仿佛由</target>
        </trans-unit>
        <trans-unit id="09509cf45826977c55e1dec4baf1527dc8caefbb" translate="yes" xml:space="preserve">
          <source>1) Copy assignment is not allowed.</source>
          <target state="translated">1)不允许复制分配。</target>
        </trans-unit>
        <trans-unit id="3a5410a123be4ffd9084e19a34d5ec5f619c3034" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator is deleted, &lt;code&gt;std::packaged_task&lt;/code&gt; is move-only.</source>
          <target state="translated">1）删除了副本分配运算符， &lt;code&gt;std::packaged_task&lt;/code&gt; 是仅移动的。</target>
        </trans-unit>
        <trans-unit id="2aca2d494628bc0ffa5751c1c324f784c030e885" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns each element of &lt;code&gt;other&lt;/code&gt; to the corresponding element of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1）复制分配运算符。将 &lt;code&gt;other&lt;/code&gt; 的每个元素分配给 &lt;code&gt;*this&lt;/code&gt; 的对应元素。</target>
        </trans-unit>
        <trans-unit id="8cc354b87930ded2400ee0d9fd474ddaa0df3e93" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns the contents of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1）复制分配运算符。分配 &lt;code&gt;other&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="192e116d8a3105a5b39d34793a6599ce2a2b2376" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns the contents of &lt;code&gt;other&lt;/code&gt;. Equivalent to &lt;code&gt;assign(other);&lt;/code&gt;.</source>
          <target state="translated">1）复制分配运算符。分配 &lt;code&gt;other&lt;/code&gt; 的内容。等同于 &lt;code&gt;assign(other);&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc11fa7946da37481c60d78d0a9d3a526f8a12a0" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Each element of &lt;code&gt;*this&lt;/code&gt; is assigned the value of the corresponding element of &lt;code&gt;other&lt;/code&gt;. If the length of &lt;code&gt;other&lt;/code&gt; does not equal the length of &lt;code&gt;*this&lt;/code&gt;,  the behavior is undefined(until C++11) first resizes as if by &lt;code&gt;resize(other.size())&lt;/code&gt;(since C++11).</source>
          <target state="translated">1）复制分配运算符。 &lt;code&gt;*this&lt;/code&gt; 的每个元素都被分配 &lt;code&gt;other&lt;/code&gt; 的对应元素的值。如果 &lt;code&gt;other&lt;/code&gt; 的长度不等于 &lt;code&gt;*this&lt;/code&gt; 的长度，则行为是不确定的（直到C ++ 11），首先像 &lt;code&gt;resize(other.size())&lt;/code&gt; 一样调整大小（自C ++ 11起）。</target>
        </trans-unit>
        <trans-unit id="36cd900ec1105ec865ef3f158da0f2320e8c8dbc" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;c = other.c; comp = other.comp;&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">1）复制分配运算符。将内容替换为 &lt;code&gt;other&lt;/code&gt; 的内容的副本。有效地调用 &lt;code&gt;c = other.c; comp = other.comp;&lt;/code&gt; 。（隐式声明）</target>
        </trans-unit>
        <trans-unit id="a351a0527d89498a7bcb02cb3b6924c0e3fbd9ec" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;c = other.c;&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">1）复制分配运算符。将内容替换为 &lt;code&gt;other&lt;/code&gt; 的内容的副本。有效地调用 &lt;code&gt;c = other.c;&lt;/code&gt; 。（隐式声明）</target>
        </trans-unit>
        <trans-unit id="0ad06eaa3c6a3a682c837daad2aa45d6956113f6" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;.If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the target allocator is replaced by a copy of the source allocator. If the target and the source allocators do not compare equal, the target (&lt;code&gt;*this&lt;/code&gt;) allocator is used to deallocate the memory, then &lt;code&gt;other&lt;/code&gt;'s allocator is used to allocate it before copying the elements.(since C++11).</source>
          <target state="translated">1）复制分配运算符。用的内容的副本替换内容 &lt;code&gt;other&lt;/code&gt; 。如果 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ，则目标分配器由源分配器的副本替换。如果目标分配器与源分配器的比较不相等，则使用目标分配器（ &lt;code&gt;*this&lt;/code&gt; ）分配内存，然后在复制元素之前使用 &lt;code&gt;other&lt;/code&gt; 的分配器分配内存。（自C ++ 11起）。</target>
        </trans-unit>
        <trans-unit id="1e0dbe7fed5c788b8dad718a8b915f89fb6eb4b1" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of other.</source>
          <target state="translated">1)复制分配运算符。将内容替换为其他内容的副本。</target>
        </trans-unit>
        <trans-unit id="7ee786d01693b06ebeb3b6d27fc4eca9ecd9d102" translate="yes" xml:space="preserve">
          <source>1) Creates an object of the given type &lt;code&gt;T&lt;/code&gt; by means of &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;uses-allocator construction&lt;/a&gt; at the uninitialized memory location indicated by p, using OUTERMOST as the allocator. After adjustment for uses-allocator convention expected by T's constructor, calls &lt;code&gt;OUTERMOST_ALLOC_TRAITS(*this)::construct&lt;/code&gt;.</source>
          <target state="translated">1）创建给定类型的一个目的 &lt;code&gt;T&lt;/code&gt; 借助于&lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;用途分配器结构&lt;/a&gt;在未初始化的存储器位置指示用p，使用最外层为分配器。在调整了T的构造函数期望的uses-allocator约定后，调用 &lt;code&gt;OUTERMOST_ALLOC_TRAITS(*this)::construct&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2a543f321b7366feb622ab638584f7e34068656" translate="yes" xml:space="preserve">
          <source>1) Creates an object of the given type &lt;code&gt;U&lt;/code&gt; by means of &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;uses-allocator construction&lt;/a&gt; at the uninitialized memory location indicated by p, using &lt;code&gt;*this&lt;/code&gt; as the allocator. This overload only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;.(until C++20)</source>
          <target state="translated">1）创建给定类型的一个对象 &lt;code&gt;U&lt;/code&gt; 借助于&lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;用途分配器结构&lt;/a&gt;在未初始化的存储器位置指示用p，使用 &lt;code&gt;*this&lt;/code&gt; 作为分配器。如果 &lt;code&gt;U&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 则此重载仅参与重载解析。（直到C ++ 20）</target>
        </trans-unit>
        <trans-unit id="a9a98b74dec90269333d869db789c5323e20c4d2" translate="yes" xml:space="preserve">
          <source>1) Creates an optional object from &lt;code&gt;value&lt;/code&gt;. Effectively calls &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value))&lt;/code&gt;</source>
          <target state="translated">1）从 &lt;code&gt;value&lt;/code&gt; 创建一个可选对象。有效调用 &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c480710a43a80e8adcfecc3be2f3cd25cb1baa89" translate="yes" xml:space="preserve">
          <source>1) Creates and returns a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; object containing a copy of this &lt;code&gt;std::basic_stringbuf&lt;/code&gt;'s underlying character sequence. For input-only streams, the returned string contains the characters from the range &lt;code&gt;[eback(), egptr())&lt;/code&gt;. For input/output or output-only streams, contains the characters from &lt;code&gt;pbase()&lt;/code&gt; to the last character in the sequence regardless of &lt;code&gt;egptr()&lt;/code&gt; and &lt;code&gt;epptr()&lt;/code&gt;.</source>
          <target state="translated">1）创建并返回一个 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 对象，其中包含此 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 的基础字符序列的副本。对于仅输入流，返回的字符串包含 &lt;code&gt;[eback(), egptr())&lt;/code&gt; 范围内的字符。对于输入/输出或仅输出流，无论 &lt;code&gt;egptr()&lt;/code&gt; 和 &lt;code&gt;epptr()&lt;/code&gt; 为何，都包含从 &lt;code&gt;pbase()&lt;/code&gt; 到序列中最后一个字符的字符。</target>
        </trans-unit>
        <trans-unit id="a5389ceb0bc0b5a3365c91e4e5a33417369a0e1f" translate="yes" xml:space="preserve">
          <source>1) Creates new thread object which does not represent a thread.</source>
          <target state="translated">1)创建新的线程对象,它不代表一个线程。</target>
        </trans-unit>
        <trans-unit id="0327a6fbad3860b481ce60cfaf07be7bf277056c" translate="yes" xml:space="preserve">
          <source>1) Creates the directory &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt; with a second argument of &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; (the parent directory must already exist). If the function fails because &lt;code&gt;p&lt;/code&gt; resolves to an existing directory, no error is reported. Otherwise on failure an error is reported.</source>
          <target state="translated">1）就像使用POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt;）创建目录 &lt;code&gt;p&lt;/code&gt; 一样，使用第二个参数 &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;perms&quot;&gt;std :: filesystem :: perms :: all&lt;/a&gt;）（父目录必须已经存在）。如果由于 &lt;code&gt;p&lt;/code&gt; 解析到现有目录而导致函数失败，则不会报告任何错误。否则，将报告错误。</target>
        </trans-unit>
        <trans-unit id="26a64ab38ecb224858cfd7b2b44b0643ae394d5b" translate="yes" xml:space="preserve">
          <source>1) Creates the directory &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt; with a second argument of &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; (the parent directory must already exist). If the function fails because &lt;code&gt;p&lt;/code&gt; resolves to an existing directory, no error is reported. Otherwise on failure an error is reported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf75898238d98a307ea5bb83b21e825fa5f14e6" translate="yes" xml:space="preserve">
          <source>1) Decimal integer literal (base 10, the first digit is the most significant)</source>
          <target state="translated">1)十进制整数字形(基数为10,第一位数字为最重要的数字)</target>
        </trans-unit>
        <trans-unit id="2c073db79516e7eb32cc3d9bb547356532b4dc4d" translate="yes" xml:space="preserve">
          <source>1) Declaration of a default constructor inside of class definition.</source>
          <target state="translated">1)在类定义里面声明一个默认构造函数。</target>
        </trans-unit>
        <trans-unit id="b4e1003653c1efe0f901decca5b2245ba63c2f97" translate="yes" xml:space="preserve">
          <source>1) Declares a named (formal) parameter. For the meanings of decl-specifier-seq and declarator, see &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;.</source>
          <target state="translated">1）声明一个命名（正式）参数。有关decl-specifier-seq和declarator的含义，请参见&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c4a1c3ae36aa2a523075a60794a76350d1cbb46" translate="yes" xml:space="preserve">
          <source>1) Declares a static data member.</source>
          <target state="translated">1)声明一个静态数据成员。</target>
        </trans-unit>
        <trans-unit id="aef76cc087fec5259881aa2a31282705f7c15ad1" translate="yes" xml:space="preserve">
          <source>1) Declares a user-defined conversion function that participates in all &lt;a href=&quot;implicit_cast&quot;&gt;implicit&lt;/a&gt; and &lt;a href=&quot;explicit_cast&quot;&gt;explicit conversions&lt;/a&gt;</source>
          <target state="translated">1）声明一个用户定义的转换函数，该函数参与所有&lt;a href=&quot;implicit_cast&quot;&gt;隐式&lt;/a&gt;和&lt;a href=&quot;explicit_cast&quot;&gt;显式转换&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9bbb455cc0049834ffda69e633f84b7ffdce2f6" translate="yes" xml:space="preserve">
          <source>1) Declares an unscoped enumeration type whose underlying type is not fixed (in this case, the underlying type is an implementation-defined integral type that can represent all enumerator values; this type is not larger than &lt;code&gt;int&lt;/code&gt; unless the value of an enumerator cannot fit in an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt;. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0).</source>
          <target state="translated">1）声明一个未作用域的枚举类型，其基础类型不固定（在这种情况下，基础类型是实现定义的整数类型，可以表示所有枚举器值；除非枚举器的值无法容纳，否则此类型不得大于 &lt;code&gt;int&lt;/code&gt; 在 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;unsigned int&lt;/code&gt; 。如果枚举列表为空，则基本类型是因为如果枚举具有值为0）的单个枚举器。</target>
        </trans-unit>
        <trans-unit id="aad5551fd8cb89e8bb0fe35f15a0c5a90ee8d2c9" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves both the &lt;code&gt;std::chrono::weekday&lt;/code&gt; and the index value uninitialized.</source>
          <target state="translated">1）默认构造函数 &lt;code&gt;std::chrono::weekday&lt;/code&gt; 和未初始化的索引值。</target>
        </trans-unit>
        <trans-unit id="2428761890c8eee7869837b591a34b4aeb8dae13" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the date uninitialized.</source>
          <target state="translated">1)默认的构造函数将日期未初始化。</target>
        </trans-unit>
        <trans-unit id="499e023d2657c02b2972ab6ce587b2b5cf8946cd" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the day value uninitialized.</source>
          <target state="translated">1)默认的构造函数将日值未初始化。</target>
        </trans-unit>
        <trans-unit id="d7eaca31c34a6ae5693ef338f73e6bcd8c29ffb4" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the fields uninitialized.</source>
          <target state="translated">1)默认的构造函数使字段未被初始化。</target>
        </trans-unit>
        <trans-unit id="078562fd7069664d06229783df9c7e3002067686" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the month value uninitialized.</source>
          <target state="translated">1)默认构造函数未初始化月份值。</target>
        </trans-unit>
        <trans-unit id="c36a47fb197929eeaca91e2ccaae79725f495a3f" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the object uninitialized.</source>
          <target state="translated">1)默认构造函数使对象未初始化。</target>
        </trans-unit>
        <trans-unit id="f177bc21211b9f9814da5723e9d7b52c483ab492" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the stored month and day values uninitialized.</source>
          <target state="translated">1)默认构造函数未初始化存储的月和日值。</target>
        </trans-unit>
        <trans-unit id="2b51b3017e5534f01a4fcc3714ba6f3fcca53ace" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the weekday value uninitialized.</source>
          <target state="translated">1)默认构造函数将工作日的值未初始化。</target>
        </trans-unit>
        <trans-unit id="0e624fa6115013ca80f6e91997dffec7202273f9" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the year and month uninitialized.</source>
          <target state="translated">1)默认构造函数未初始化年和月。</target>
        </trans-unit>
        <trans-unit id="131de4c9bed3f450ed7010d48d5a3fdb80330c32" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the year value uninitialized.</source>
          <target state="translated">1)默认构造函数未初始化年份值。</target>
        </trans-unit>
        <trans-unit id="9115058f2c43fa98792950ebe40f71f59fbd9aa0" translate="yes" xml:space="preserve">
          <source>1) Default constructor that calls (4) with &lt;code&gt;&lt;a href=&quot;../file_type&quot;&gt;std::filesystem::file_type::none&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1）使用 &lt;code&gt;&lt;a href=&quot;../file_type&quot;&gt;std::filesystem::file_type::none&lt;/a&gt;&lt;/code&gt; 调用（4）的默认构造函数。</target>
        </trans-unit>
        <trans-unit id="e9d0e85becce06778b271a974bf41a26b72cc575" translate="yes" xml:space="preserve">
          <source>1) Default constructor, creates a &lt;code&gt;time_point&lt;/code&gt; representing the &lt;code&gt;Clock&lt;/code&gt;'s epoch (i.e., &lt;code&gt;&lt;a href=&quot;time_since_epoch&quot;&gt;time_since_epoch()&lt;/a&gt;&lt;/code&gt; is zero).</source>
          <target state="translated">1）默认的构造，创建一个 &lt;code&gt;time_point&lt;/code&gt; 表示 &lt;code&gt;Clock&lt;/code&gt; 的时期（即， &lt;code&gt;&lt;a href=&quot;time_since_epoch&quot;&gt;time_since_epoch()&lt;/a&gt;&lt;/code&gt; 是零）。</target>
        </trans-unit>
        <trans-unit id="ca62ce9ba5ae98ed6cfeefae6805879eef5662f6" translate="yes" xml:space="preserve">
          <source>1) Default constructor.</source>
          <target state="translated">1)默认的构造函数。</target>
        </trans-unit>
        <trans-unit id="4672d91b62baf7495b356cbf3fd2d4ab7185bb97" translate="yes" xml:space="preserve">
          <source>1) Default constructor. &lt;a href=&quot;../../language/value_initialization&quot;&gt;Value-initializes&lt;/a&gt; all elements.</source>
          <target state="translated">1）默认构造函数。&lt;a href=&quot;../../language/value_initialization&quot;&gt;值初始化&lt;/a&gt;所有元素。</target>
        </trans-unit>
        <trans-unit id="2e8a32fa473b151fe2837e9a637eec271c2f495b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. &lt;a href=&quot;what&quot;&gt;&lt;code&gt;what()&lt;/code&gt;&lt;/a&gt; returns an implementation-defined string.</source>
          <target state="translated">1）默认构造函数。&lt;a href=&quot;what&quot;&gt; &lt;code&gt;what()&lt;/code&gt; &lt;/a&gt;返回实现定义的字符串。</target>
        </trans-unit>
        <trans-unit id="c75332d6c29abfeb6ab9132695635439c25e48b8" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a &lt;code&gt;std::future&lt;/code&gt; with no shared state. After construction, &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt;.</source>
          <target state="translated">1）默认构造函数。构造没有共享状态的 &lt;code&gt;std::future&lt;/code&gt; 。构造后，&lt;a href=&quot;valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79261dde24b2758d36f9430c665e3f176df44f39" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a bitset with all bits set to zero.</source>
          <target state="translated">1)默认构造函数。构造一个将所有位设置为零的位集。</target>
        </trans-unit>
        <trans-unit id="011ecb3fe17914dffa88456a32eaa298e263e47b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a copy of the global C++ locale, which is the locale most recently used as the argument to &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; or a copy of &lt;code&gt;&lt;a href=&quot;classic&quot;&gt;std::locale::classic&lt;/a&gt;&lt;/code&gt; if no call to &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; has been made.</source>
          <target state="translated">1）默认构造函数。构建全球C ++语言环境的副本，这是最近作为参数传递给现场 &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; 或副本 &lt;code&gt;&lt;a href=&quot;classic&quot;&gt;std::locale::classic&lt;/a&gt;&lt;/code&gt; ，如果没有呼叫 &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; 有被制成。</target>
        </trans-unit>
        <trans-unit id="895580b59835cf3ea8b8e9ef9fcc3a2446be6649" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a variant holding the &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; value of the first alternative (&lt;a href=&quot;index&quot;&gt;&lt;code&gt;index()&lt;/code&gt;&lt;/a&gt; is zero). This constructor is &lt;code&gt;constexpr&lt;/code&gt; if and only if the value initialization of the alternative type T_0 would satisfy the requirements for a &lt;a href=&quot;../../language/constexpr&quot;&gt;constexpr function&lt;/a&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;T_0&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1）默认构造函数。构造一个变量，该变量保留第一个替代项的&lt;a href=&quot;../../language/value_initialization&quot;&gt;值初始化&lt;/a&gt;值（&lt;a href=&quot;index&quot;&gt; &lt;code&gt;index()&lt;/code&gt; &lt;/a&gt;为零）。此构造是 &lt;code&gt;constexpr&lt;/code&gt; 当且仅当所述替代类型T_0的值初始化将满足对要求&lt;a href=&quot;../../language/constexpr&quot;&gt;constexpr功能&lt;/a&gt;。如果 &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;T_0&amp;gt;&lt;/code&gt; 为true，则此重载仅参与重载解决方案。</target>
        </trans-unit>
        <trans-unit id="9d0e5fa5fa920ac3791488de3b572932835b95ee" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty &lt;code&gt;basic_string_view&lt;/code&gt;. After construction, &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;nullptr&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">1）默认构造函数。构造一个空的 &lt;code&gt;basic_string_view&lt;/code&gt; 。构造之后， &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; 等于 &lt;code&gt;nullptr&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 等于 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eacc35685d23a4fecd10da59ea5f06868759d796" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty container. If no allocator is supplied, allocator is obtained from a default-constructed instance.</source>
          <target state="translated">1)默认构造函数。构造一个空的容器,如果没有提供分配器,则从默认构造的实例中获取分配器。如果没有提供分配器,则从默认构造的实例中获取分配器。</target>
        </trans-unit>
        <trans-unit id="6c17b4644d6ac209e7f22c17144138b18c5931e9" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty numeric array.</source>
          <target state="translated">1)默认构造函数。构造一个空的数字数组。</target>
        </trans-unit>
        <trans-unit id="de0ff732be5a241f66c48250f820f0547487440b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty regular expression which will match nothing.</source>
          <target state="translated">1)默认构造函数。构造一个空的正则表达式,它不会匹配任何东西。</target>
        </trans-unit>
        <trans-unit id="e669d70f06155beb00ecca03586e5c258a586219" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty shared future, that doesn't refer to a shared state, that is &lt;code&gt;valid() == false&lt;/code&gt;.</source>
          <target state="translated">1）默认构造函数。构造一个空的共享未来，它不引用共享状态，即 &lt;code&gt;valid() == false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7565190dee6671c76d3a56a2e2e2a2350105a5f5" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an end iterator.</source>
          <target state="translated">1)默认构造函数。构造一个结束迭代器。</target>
        </trans-unit>
        <trans-unit id="cb5ed3cd804429aa2c7dde21da7ca9ead64884cb" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an end-of-sequence iterator.</source>
          <target state="translated">1)默认构造函数。构造一个序列末尾的迭代器。</target>
        </trans-unit>
        <trans-unit id="9cd879bc1abea042190566e8fd2e0be2513b8de1" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs empty &lt;code&gt;weak_ptr&lt;/code&gt;.</source>
          <target state="translated">1）默认构造函数。构造空的 &lt;code&gt;weak_ptr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f5913ec53e778795e8ead732e87ecf9cfcfc151" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs empty string (zero size and unspecified capacity). If no allocator is supplied, allocator is obtained from a default-constructed instance.</source>
          <target state="translated">1)默认构造函数。构造空字符串(大小为零,容量不详)。如果没有提供分配器,则从默认构造的实例中获取分配器。</target>
        </trans-unit>
        <trans-unit id="fea889f6b10c364b364bead59870fc1ead08d127" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs new underlying string device with the default open mode</source>
          <target state="translated">1)默认构造函数。用默认的打开模式构造新的底层字符串设备。</target>
        </trans-unit>
        <trans-unit id="47dfb990d09b6cf7741d11d703850522bdd37ac1" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the distribution with a single weight p={1}. This distribution will always generate &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1）默认构造函数。用单个权重p = {1}构造分布。这种分布总是会生成 &lt;code&gt;​0​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e80f107318c31b0c58e6aeef75360f44ffd05c03" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the end-of-sequence iterator.</source>
          <target state="translated">1)默认构造函数。构造序列末端迭代器。</target>
        </trans-unit>
        <trans-unit id="5bf185507087fc694124074f527682377e4e4b06" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the promise with an empty shared state.</source>
          <target state="translated">1)默认构造函数。用一个空的共享状态构造承诺。</target>
        </trans-unit>
        <trans-unit id="25239fa19574ad09c0768600521365122e69a28f" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Equivalent to &lt;code&gt;gslice(0, &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(), &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;())&lt;/code&gt;. This constructor exists only to allow construction of arrays of slices.</source>
          <target state="translated">1）默认构造函数。等效于 &lt;code&gt;gslice(0, &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(), &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;())&lt;/code&gt; 。存在此构造函数仅是为了构造切片数组。</target>
        </trans-unit>
        <trans-unit id="25b86c4ec98dd08e9433550d3d731d786fa40f88" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Equivalent to &lt;code&gt;slice(0, 0, 0)&lt;/code&gt;. This constructor exists only to allow construction of arrays of slices.</source>
          <target state="translated">1）默认构造函数。等效于 &lt;code&gt;slice(0, 0, 0)&lt;/code&gt; 。存在此构造函数仅是为了构造切片数组。</target>
        </trans-unit>
        <trans-unit id="0f2c9964918fbbbec4b2a2f80259c25e38ce89a5" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Initializes the error condition with generic category and error code &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1）默认构造函数。初始化与通用类和错误代码错误条件 &lt;code&gt;​0​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a16bc65a9c0bb02a38efb33e034e628db8375633" translate="yes" xml:space="preserve">
          <source>1) Default constructor. It is implementation-defined whether the sequence pointers (&lt;code&gt;eback()&lt;/code&gt;, &lt;code&gt;gptr()&lt;/code&gt;, &lt;code&gt;egptr()&lt;/code&gt;, &lt;code&gt;pbase()&lt;/code&gt;, &lt;code&gt;pptr()&lt;/code&gt;, &lt;code&gt;epptr()&lt;/code&gt;) are initialized to null pointers.</source>
          <target state="translated">1）默认构造函数。它是实现定义是否序列指针（ &lt;code&gt;eback()&lt;/code&gt; ， &lt;code&gt;gptr()&lt;/code&gt; ， &lt;code&gt;egptr()&lt;/code&gt; ， &lt;code&gt;pbase()&lt;/code&gt; ， &lt;code&gt;pptr()&lt;/code&gt; ， &lt;code&gt;epptr()&lt;/code&gt; ）被初始化为空指针。</target>
        </trans-unit>
        <trans-unit id="18cc22e95dd49ea3310825efa9be211fee3b3c2f" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Seeds the engine with &lt;code&gt;default_seed&lt;/code&gt;.</source>
          <target state="translated">1）默认构造函数。使用 &lt;code&gt;default_seed&lt;/code&gt; 播种引擎。</target>
        </trans-unit>
        <trans-unit id="1a1f3b78577783b96afca946ecfdb044a2e2fe03" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Stores an exception object obtained by calling &lt;code&gt;&lt;a href=&quot;../current_exception&quot;&gt;std::current_exception&lt;/a&gt;()&lt;/code&gt; within the new &lt;code&gt;nested_exception&lt;/code&gt; object.</source>
          <target state="translated">1）默认构造函数。将通过调用 &lt;code&gt;&lt;a href=&quot;../current_exception&quot;&gt;std::current_exception&lt;/a&gt;()&lt;/code&gt; 获得的异常对象存储在新的 &lt;code&gt;nested_exception&lt;/code&gt; 对象中。</target>
        </trans-unit>
        <trans-unit id="8a32db41a403e2f63a4fd28475b603a4ec46df42" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The internal state is not initialized. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init()&lt;/a&gt;&lt;/code&gt; must be called before the first use of the object or before destructor, otherwise the behavior is undefined.</source>
          <target state="translated">1）默认构造函数。内部状态未初始化。必须在首次使用该对象之前或在析构函数之前调用 &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init()&lt;/a&gt;&lt;/code&gt; ，否则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="55062aaea6619514669480e39506ff7c999ff520" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The underlying engine is also default-constructed.</source>
          <target state="translated">1)默认构造函数。底层引擎也是默认构造的。</target>
        </trans-unit>
        <trans-unit id="15f4029d373e079f41db83cdd93169d4f5785dcf" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The underlying iterator is value-initialized. Operations on the resulting iterator have defined behavior if and only if the corresponding operations on a value-initialized &lt;code&gt;Iterator&lt;/code&gt; also have defined behavior.</source>
          <target state="translated">1）默认构造函数。基础迭代器是值初始化的。当且仅当值初始化的 &lt;code&gt;Iterator&lt;/code&gt; 上的相应操作也具有定义的行为时，结果迭代器上的操作才具有定义的行为。</target>
        </trans-unit>
        <trans-unit id="2a9d616bbf3734e2be9b10dbac57548362a533dd" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes both elements of the pair, &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;.</source>
          <target state="translated">1）默认构造函数。值初始化对中的两个元素 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;second&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d50a8b3aca03c89f83a8e00c8035cce2b2f943dc" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes the comparator and the underlying container.</source>
          <target state="translated">1)默认构造函数。Value-初始化比较器和底层容器。</target>
        </trans-unit>
        <trans-unit id="d57453057acaf238aba5d7c9f55019284642f9be" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes the container.</source>
          <target state="translated">1)默认构造函数。Value-初始化容器。</target>
        </trans-unit>
        <trans-unit id="85aa7b5f36dda27d22e0568ece5d170840dd6df4" translate="yes" xml:space="preserve">
          <source>1) Default constructor: constructs a stream that is not associated with a file: default-constructs the &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; and constructs the base with the pointer to this default-constructed &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; member.</source>
          <target state="translated">1）默认构造函数：构造与文件不相关的流 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 构造std :: basic_filebuf，并使用指向此默认构造的 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 成员的指针构造基。</target>
        </trans-unit>
        <trans-unit id="3cab7b4fb28e5286d6fa395d1c88c741664448fe" translate="yes" xml:space="preserve">
          <source>1) Default constructor: value-initializes the &lt;code&gt;OuterAlloc&lt;/code&gt; base class and the inner allocator member object, if used by the implementation.</source>
          <target state="translated">1）默认构造函数：如果实现使用value，则初始化 &lt;code&gt;OuterAlloc&lt;/code&gt; 基类和内部分配器成员对象。</target>
        </trans-unit>
        <trans-unit id="f147745323c3c84fec33aec7c8557ca0d3395b0a" translate="yes" xml:space="preserve">
          <source>1) Default constructs a new &lt;code&gt;&lt;a href=&quot;../random_device&quot;&gt;std::random_device&lt;/a&gt;&lt;/code&gt; object with an implementation-defined &lt;code&gt;token&lt;/code&gt;.</source>
          <target state="translated">1）默认构造一个带有实现定义的 &lt;code&gt;token&lt;/code&gt; 的新 &lt;code&gt;&lt;a href=&quot;../random_device&quot;&gt;std::random_device&lt;/a&gt;&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="3d254d4e4e041dda90a59631d7b2960792e803ef" translate="yes" xml:space="preserve">
          <source>1) Default-constructor. Constructs a match result with no established result state (&lt;code&gt;ready() != true&lt;/code&gt;).</source>
          <target state="translated">1）默认构造函数。构造没有结果状态状态的匹配结果（ &lt;code&gt;ready() != true&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1af4fb69cdbe20bca957ea5aab4e348af2793199" translate="yes" xml:space="preserve">
          <source>1) Default-constructs the underlying &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;, which creates a dynamically growing buffer, and initializes the base class with the address of the strstreambuf member.</source>
          <target state="translated">1）默认构造底层的 &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; ，它创建一个动态增长的缓冲区，并使用strstreambuf成员的地址初始化基类。</target>
        </trans-unit>
        <trans-unit id="7d13af42ec3f2ddb8462a572d1b26587eccb3d92" translate="yes" xml:space="preserve">
          <source>1) Default-initializes &lt;code&gt;base_&lt;/code&gt; and &lt;code&gt;pred_&lt;/code&gt;</source>
          <target state="translated">1）默认初始化 &lt;code&gt;base_&lt;/code&gt; 和 &lt;code&gt;pred_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ac5a4d8f549ae70b68112a4ef17cd868cd57e69" translate="yes" xml:space="preserve">
          <source>1) Default-initializes &lt;code&gt;value_&lt;/code&gt; and &lt;code&gt;bound_&lt;/code&gt;</source>
          <target state="translated">1）默认初始化 &lt;code&gt;value_&lt;/code&gt; 和 &lt;code&gt;bound_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1dbaabdc4ff6b70020a151bf2e9abc440948c50" translate="yes" xml:space="preserve">
          <source>1) Defaulted copy assignment operator. Copy-assigns both the stored time point and the stored time zone pointer. &lt;code&gt;zoned_time&lt;/code&gt; has no move assignment operator; a move is a copy.</source>
          <target state="translated">1）默认的副本分配运算符。复制分配存储的时间点和存储的时区指针。 &lt;code&gt;zoned_time&lt;/code&gt; 没有移动分配运算符；一招就是副本。</target>
        </trans-unit>
        <trans-unit id="78b7cc430f5922607ee43272f394fa79b6ed0bac" translate="yes" xml:space="preserve">
          <source>1) Define a non-member swap in the enclosing namespace, which may forward to a member swap if access to non-public data members is required</source>
          <target state="translated">1)在封闭的命名空间中定义一个非成员交换,如果需要访问非公共数据成员,可以转发到成员交换中去</target>
        </trans-unit>
        <trans-unit id="a7de1a6f8b3cc0594b28dcfd6a8f7980d955fbbc" translate="yes" xml:space="preserve">
          <source>1) Defines a</source>
          <target state="translated">1)定义了一个</target>
        </trans-unit>
        <trans-unit id="c6408478c098043618abdb9b577727df78dd08ab" translate="yes" xml:space="preserve">
          <source>1) Definition of an enumeration type.</source>
          <target state="translated">1)枚举类型的定义。</target>
        </trans-unit>
        <trans-unit id="ebbd2ad38e5fa6237bba264cce1284f0bd1cec2c" translate="yes" xml:space="preserve">
          <source>1) Denormalization loss: the delivered result differs from what would have been computed were exponent range unbounded.</source>
          <target state="translated">1)去正化损失:如果指数范围不受限制,交付的结果与计算的结果不同。</target>
        </trans-unit>
        <trans-unit id="4a1bd34fda9394675a66721b9472df8d48990386" translate="yes" xml:space="preserve">
          <source>1) Designates a function or several functions as friends of this class</source>
          <target state="translated">1)指定一个或几个函数为该类的朋友。</target>
        </trans-unit>
        <trans-unit id="cda85d78ffc7280c614df8e23678c3c173935a15" translate="yes" xml:space="preserve">
          <source>1) Destroys one non-array object created by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;</source>
          <target state="translated">1）销毁由&lt;a href=&quot;new&quot;&gt;new表达式&lt;/a&gt;创建的一个非数组对象</target>
        </trans-unit>
        <trans-unit id="2cba7eb8d44c15125cdc52986458ca13f73ba7d1" translate="yes" xml:space="preserve">
          <source>1) Destroys the &lt;code&gt;n&lt;/code&gt; objects in the range starting at &lt;code&gt;first&lt;/code&gt;, as if by</source>
          <target state="translated">1）破坏从 &lt;code&gt;first&lt;/code&gt; 开始的范围内的 &lt;code&gt;n&lt;/code&gt; 个对象，就像</target>
        </trans-unit>
        <trans-unit id="f998857faa7d72f442a5b64bb7bd57852afbb2f4" translate="yes" xml:space="preserve">
          <source>1) Destroys the iterator, including the cached value.</source>
          <target state="translated">1)销毁迭代器,包括缓存的值。</target>
        </trans-unit>
        <trans-unit id="a3f6de15f76b6e6f118c50c482f5797660572e61" translate="yes" xml:space="preserve">
          <source>1) Destroys the objects in the range &lt;code&gt;[first, last)&lt;/code&gt;, as if by</source>
          <target state="translated">1）销毁 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的对象，就像通过</target>
        </trans-unit>
        <trans-unit id="8e3aa580452b25d9999027f1b3cb229e40ec1851" translate="yes" xml:space="preserve">
          <source>1) Detects if the current thread has a live exception object, that is, an exception has been thrown or rethrown and not yet entered a matching catch clause, &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;. In other words, &lt;code&gt;std::uncaught_exception&lt;/code&gt; detects if &lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;stack unwinding&lt;/a&gt; is currently in progress.</source>
          <target state="translated">1）检测当前线程是否具有活动的异常对象，即是否引发或重新抛出了异常且尚未输入匹配的catch子句 &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 。换句话说， &lt;code&gt;std::uncaught_exception&lt;/code&gt; 检测当前是否正在进行&lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;堆栈展开&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="df7a3ba6b3fba13efda3c048c64afee201d66f99" translate="yes" xml:space="preserve">
          <source>1) Determines if the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt; is implemented lock-free, as if by calling &lt;code&gt;obj-&amp;gt;is_lock_free()&lt;/code&gt;. In any given program execution, the result of the lock-free query is the same for all pointers of the same type.</source>
          <target state="translated">1）确定 &lt;code&gt;obj&lt;/code&gt; 指向的原子对象是否实现无锁，就像通过调用 &lt;code&gt;obj-&amp;gt;is_lock_free()&lt;/code&gt; 一样。在任何给定的程序执行中，无锁查询的结果对于相同类型的所有指针都是相同的。</target>
        </trans-unit>
        <trans-unit id="91e01796abcfa6eddc0b11eb63b158b9aba3771c" translate="yes" xml:space="preserve">
          <source>1) Determines if there is a match between the regular expression &lt;code&gt;e&lt;/code&gt; and the entire target character sequence &lt;code&gt;[first,last)&lt;/code&gt;, taking into account the effect of &lt;code&gt;flags&lt;/code&gt;. When determining if there is a match, only potential matches that match the entire character sequence are considered. Match results are returned in &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1）考虑到 &lt;code&gt;flags&lt;/code&gt; 的影响，确定正则表达式 &lt;code&gt;e&lt;/code&gt; 和整个目标字符序列 &lt;code&gt;[first,last)&lt;/code&gt; 之间是否匹配。在确定是否存在匹配项时，仅考虑与整个字符序列匹配的潜在匹配项。匹配结果以 &lt;code&gt;m&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="b58fdc599cf255bac2ae50522ea05922284c1bea" translate="yes" xml:space="preserve">
          <source>1) Determines the type and attributes of the filesystem object identified by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed to their targets). In the following description, &lt;code&gt;prms&lt;/code&gt; is the result of &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is obtained as if by taking &lt;code&gt;st_mode&lt;/code&gt; from the POSIX &lt;code&gt;struct stat&lt;/code&gt; and converting it to the type &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1）确定由 &lt;code&gt;p&lt;/code&gt; 标识的文件系统对象的类型和属性，就像由POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt;（符号链接跟随其目标）一样。在下面的描述中， &lt;code&gt;prms&lt;/code&gt; 是 &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt; ，其中 &lt;code&gt;m&lt;/code&gt; 的获取就像是通过从POSIX &lt;code&gt;struct stat&lt;/code&gt; 获取 &lt;code&gt;st_mode&lt;/code&gt; 并将其转换为类型 &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5469bf43c306c8999eb2674dfaa4919563536e4" translate="yes" xml:space="preserve">
          <source>1) Determines the type and attributes of the filesystem object identified by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed to their targets). In the following description, &lt;code&gt;prms&lt;/code&gt; is the result of &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is obtained as if by taking &lt;code&gt;st_mode&lt;/code&gt; from the POSIX &lt;code&gt;struct stat&lt;/code&gt; and converting it to the type &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a44ae052e348f0eb5abeb579d93acfea11ea715" translate="yes" xml:space="preserve">
          <source>1) Determines whether &lt;code&gt;Fn&lt;/code&gt; can be invoked with the arguments &lt;code&gt;ArgTypes...&lt;/code&gt;. Formally, determines whether &lt;code&gt;INVOKE(declval&amp;lt;Fn&amp;gt;(), declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; is well formed when treated as an unevaluated operand, where &lt;code&gt;INVOKE&lt;/code&gt; is the operation defined in &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;.</source>
          <target state="translated">1）确定是否可以使用参数 &lt;code&gt;ArgTypes...&lt;/code&gt; 调用 &lt;code&gt;Fn&lt;/code&gt; 。形式上，确定当被视为未 &lt;code&gt;INVOKE&lt;/code&gt; 值的操作数时， &lt;code&gt;INVOKE(declval&amp;lt;Fn&amp;gt;(), declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; 是否格式正确，其中INVOKE是&lt;a href=&quot;../named_req/callable&quot;&gt;Callable中&lt;/a&gt;定义的操作。</target>
        </trans-unit>
        <trans-unit id="ca298188df78ab4f447d54b4bad5cd57815e3fe1" translate="yes" xml:space="preserve">
          <source>1) Determines whether atomic access to the shared pointer pointed-to by &lt;code&gt;p&lt;/code&gt; is lock-free.</source>
          <target state="translated">1）确定 &lt;code&gt;p&lt;/code&gt; 指向的共享指针的原子访问是否为无锁。</target>
        </trans-unit>
        <trans-unit id="65005f1a4f1673e794ca8fd566db8cadc1934b30" translate="yes" xml:space="preserve">
          <source>1) Does not throw</source>
          <target state="translated">1)不投掷</target>
        </trans-unit>
        <trans-unit id="fab8fda7614e477a6f71346517837d8a3e567c5f" translate="yes" xml:space="preserve">
          <source>1) Each element is assigned value obtained by applying the corresponding operator to the previous value of the element and corresponding element from &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">1）为每个元素分配值，该值是通过将对应的运算符应用于元素的先前值和来自 &lt;code&gt;v&lt;/code&gt; 的对应元素而获得的。</target>
        </trans-unit>
        <trans-unit id="8a8ff4bbb77a97d615fec33736a3f814af766ce7" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::const_mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1）有效调用 &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::const_mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31e828b09b6dcd4b69af6c0189e9702fd814cda6" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::const_mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1）有效地调用 &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::const_mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46acfc8106489874b0a683e5cfada60e0e48401e" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;pointer_to_unary_function&quot;&gt;std::pointer_to_unary_function&lt;/a&gt;&amp;lt;Arg,Result&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1）有效地调用 &lt;code&gt;&lt;a href=&quot;pointer_to_unary_function&quot;&gt;std::pointer_to_unary_function&lt;/a&gt;&amp;lt;Arg,Result&amp;gt;(f)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7400b67aeeb319d2c89e9f0544cebe1005e1706" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;c.push_back(value); &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std::push_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt;</source>
          <target state="translated">1）有效地调用 &lt;code&gt;c.push_back(value); &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std::push_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d470e4c140bedbd34a1126e97e4400dc788fa04" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;c.push_back(value)&lt;/code&gt;</source>
          <target state="translated">1）有效地调用 &lt;code&gt;c.push_back(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="011d1f5ba60bd9d74dea06b316bbfe4e137bcdaa" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;f(read_symlink(from), to)&lt;/code&gt; where &lt;code&gt;f&lt;/code&gt; is &lt;a href=&quot;create_symlink&quot;&gt;&lt;code&gt;create_symlink&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;create_symlink&quot;&gt;&lt;code&gt;create_directory_symlink&lt;/code&gt;&lt;/a&gt; depending on whether &lt;code&gt;from&lt;/code&gt; resolves to a file or directory.</source>
          <target state="translated">1）有效地调用 &lt;code&gt;f(read_symlink(from), to)&lt;/code&gt; ，其中 &lt;code&gt;f&lt;/code&gt; 是&lt;a href=&quot;create_symlink&quot;&gt; &lt;code&gt;create_symlink&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;create_symlink&quot;&gt; &lt;code&gt;create_directory_symlink&lt;/code&gt; ,&lt;/a&gt;具体取决于 &lt;code&gt;from&lt;/code&gt; 解析为文件还是目录。</target>
        </trans-unit>
        <trans-unit id="e2c0e9b14b9519968975e29f74ca4f737cc3b463" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;m.lock()&lt;/code&gt;. The behavior is undefined if &lt;code&gt;m&lt;/code&gt; is not a recursive mutex and the current thread already owns &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1）有效地调用 &lt;code&gt;m.lock()&lt;/code&gt; 。如果 &lt;code&gt;m&lt;/code&gt; 不是递归互斥并且当前线程已经拥有 &lt;code&gt;m&lt;/code&gt; ,则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="8fbed931d739878efe2242dc69e3c3ec188c93c6" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;reset(r.release())&lt;/code&gt;.</source>
          <target state="translated">1）有效地调用 &lt;code&gt;reset(r.release())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="588791ac3459488ee09ba487973c4664a54285ba" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator&amp;lt;&lt;/code&gt; and the ranges must be sorted with respect to the same.</source>
          <target state="translated">1）使用 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 比较元素，并且必须对范围进行排序。</target>
        </trans-unit>
        <trans-unit id="8cc3c33d923eee557c7b587363c490e22bf00f05" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">1）使用 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 比较元素。</target>
        </trans-unit>
        <trans-unit id="0d09f5debbd2155a625dbd1f35e701b7e3c2ab3b" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator==&lt;/code&gt;.</source>
          <target state="translated">1）使用 &lt;code&gt;operator==&lt;/code&gt; 比较元素。</target>
        </trans-unit>
        <trans-unit id="fc915779f9828f296793ebde353de4de9e382deb" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator==&lt;/code&gt;. The behavior is undefined if it is not an &lt;a href=&quot;https://en.wikipedia.org/wiki/equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;.</source>
          <target state="translated">1）使用 &lt;code&gt;operator==&lt;/code&gt; 比较元素。如果行为不是&lt;a href=&quot;https://en.wikipedia.org/wiki/equivalence_relation&quot;&gt;等价关系&lt;/a&gt;，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="05030b7bb4349fc087ee762a2cc6879e74372695" translate="yes" xml:space="preserve">
          <source>1) Enables the &lt;code&gt;boolalpha&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::boolalpha&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1）启用流 &lt;code&gt;str&lt;/code&gt; 中的 &lt;code&gt;boolalpha&lt;/code&gt; 标志，就像通过调用 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::boolalpha&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: boolalpha&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="96a972a826ee3fcdba20885c2506d308930acc88" translate="yes" xml:space="preserve">
          <source>1) Equality operator for variants:</source>
          <target state="translated">1)变体的平等运算符。</target>
        </trans-unit>
        <trans-unit id="82f9550a944d3a8df60f3b265cda2b488c9da5d5" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + d;&lt;/code&gt;</source>
          <target state="translated">1）等同于 &lt;code&gt;*this = *this + d;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41d083e1f8110bfe1557758d4d4695c37d622fdb" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + dy;&lt;/code&gt;</source>
          <target state="translated">1）等同于 &lt;code&gt;*this = *this + dy;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ce04fa95ba678e6e255c69e3ebde6576457d731" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + y;&lt;/code&gt;</source>
          <target state="translated">1）等效于 &lt;code&gt;*this = *this + y;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d9406b90ecb5fc7caa6afd7e187ab3217839eea" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;++d_; return *this;&lt;/code&gt;</source>
          <target state="translated">1）相当于 &lt;code&gt;++d_; return *this;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f1d88d98b52d4717f7dcfd15653a17e454989f4" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;++rep_; return *this;&lt;/code&gt;</source>
          <target state="translated">1）相当于 &lt;code&gt;++rep_; return *this;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c52d71237ed4fde0f7863911f0865e168009fdf" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_days&lt;/a&gt;(year()/month()/day())&lt;/code&gt;</source>
          <target state="translated">1）等同于 &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_days&lt;/a&gt;(year()/month()/day())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aace9380526b20cb700bec8018bdc6d389438aec" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;Iter tmp = current; return *--tmp;&lt;/code&gt;</source>
          <target state="translated">1）等于 &lt;code&gt;Iter tmp = current; return *--tmp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2aaf37e2ad0a4d3314a70e8a4edea0af77b29fd6" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;bool(*this) ? **this : static_cast&amp;lt;T&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(default_value))&lt;/code&gt;</source>
          <target state="translated">1）等于 &lt;code&gt;bool(*this) ? **this : static_cast&amp;lt;T&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(default_value))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27ca6cdc924e29f6abac7e6f89eb8af6bc1cf7bd" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;default_error_condition(code) == condition&lt;/code&gt;.</source>
          <target state="translated">1）等效于 &lt;code&gt;default_error_condition(code) == condition&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaf68a0e9a1753e7c451d7db374905454c1660ab" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;emplace&amp;lt;I&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;, where &lt;code&gt;I&lt;/code&gt; is the zero-based index of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;std::is_constructible_v&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; occurs exactly once in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">1）相当于 &lt;code&gt;emplace&amp;lt;I&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; ，其中， &lt;code&gt;I&lt;/code&gt; 是从零开始的索引 &lt;code&gt;T&lt;/code&gt; 在 &lt;code&gt;Types...&lt;/code&gt; 。仅当 &lt;code&gt;std::is_constructible_v&amp;lt;T, Args...&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 且 &lt;code&gt;T&lt;/code&gt; 在 &lt;code&gt;Types...&lt;/code&gt; 恰好发生一次时，此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="0c1e7f7def0b0c1e4bc97e06e0f684adad56ecd5" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;exists(s) &amp;amp;&amp;amp; !is_regular_file(s) &amp;amp;&amp;amp; !is_directory(s) &amp;amp;&amp;amp; !is_symlink(s)&lt;/code&gt;.</source>
          <target state="translated">1）等同于 &lt;code&gt;exists(s) &amp;amp;&amp;amp; !is_regular_file(s) &amp;amp;&amp;amp; !is_directory(s) &amp;amp;&amp;amp; !is_symlink(s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3c543a72231a15ed9a65b4120bd54a699a7d90c" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;lhs.equal(rhs)&lt;/code&gt;.</source>
          <target state="translated">1）等效于 &lt;code&gt;lhs.equal(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f78f1b1933f2be104c9b36333cbd8655ec420b2" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;native().c_str()&lt;/code&gt;.</source>
          <target state="translated">1）等效于 &lt;code&gt;native().c_str()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5960311674c16cc0cc1bf3867e9d05c22ddeb540" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;rep_ += d.count(); return *this;&lt;/code&gt;</source>
          <target state="translated">1）等效于 &lt;code&gt;rep_ += d.count(); return *this;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9df00ac4a641d9e8760432c2ae7533cb453b1bce" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return !&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">1）相当于 &lt;code&gt;return !&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d36ac7d6e30651e85b700452df731bf1029a32f0" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return &lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt;</source>
          <target state="translated">1）等效于 &lt;code&gt;return &lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47f69e5f8468517d7589e267f72b1dbbba5c3293" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return D(*this);&lt;/code&gt;</source>
          <target state="translated">1）等价于 &lt;code&gt;return D(*this);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="783946ea6f8a3464885e40163c1c9564f4ceea63" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return r.begin();&lt;/code&gt;</source>
          <target state="translated">1）等效于 &lt;code&gt;return r.begin();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f4fc870674f5fb012dd975ee57837cfeab7d645" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::block&lt;/code&gt;.</source>
          <target state="translated">1）等效于 &lt;code&gt;s.type() == file_type::block&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b1ed7de20f555f8534e2a84d964c966bd9d5cde" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::character&lt;/code&gt;.</source>
          <target state="translated">1）等效于 &lt;code&gt;s.type() == file_type::character&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="897ad8584bbbaddb6b9248b6dea56350ebb88d4c" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::directory&lt;/code&gt;.</source>
          <target state="translated">1）等效于 &lt;code&gt;s.type() == file_type::directory&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a63e546b555f8572521590a9d2ea549dc2ae2235" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::fifo&lt;/code&gt;.</source>
          <target state="translated">1）等效于 &lt;code&gt;s.type() == file_type::fifo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98720eb9c80b5e9a08ada8eb5db1b51aa2e92d32" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::regular&lt;/code&gt;.</source>
          <target state="translated">1）等效于 &lt;code&gt;s.type() == file_type::regular&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05305515a6902b55a79c88270ce56bc514f70239" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::socket&lt;/code&gt;.</source>
          <target state="translated">1）等效于 &lt;code&gt;s.type() == file_type::socket&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab8b95a7b2ea4746283ea27160065e146ccff49a" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::symlink&lt;/code&gt;.</source>
          <target state="translated">1）等效于 &lt;code&gt;s.type() == file_type::symlink&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="179ac5c7fc855225a87152301381a704450b6c4a" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;static_cast&amp;lt;reference&amp;gt;(*base())&lt;/code&gt;;</source>
          <target state="translated">1）等效于 &lt;code&gt;static_cast&amp;lt;reference&amp;gt;(*base())&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="538ab1915dd3230391d766df1b4a3748da3f84c1" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;status_known(s) &amp;amp;&amp;amp; s.type() != file_type::not_found&lt;/code&gt;.</source>
          <target state="translated">1）等同于 &lt;code&gt;status_known(s) &amp;amp;&amp;amp; s.type() != file_type::not_found&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d8fb771283367cf610ecf5e023e663a4fe8645b" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;std::move(*base())&lt;/code&gt;;</source>
          <target state="translated">1）等同于 &lt;code&gt;std::move(*base())&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="8df252cd519d51da4b9b18b92bb448ad32a642e9" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;transform_reduce(first1, last1, first2, init, std::plus&amp;lt;&amp;gt;(), std::multiplies&amp;lt;&amp;gt;());&lt;/code&gt;, effectively parallelized version of the default &lt;code&gt;&lt;a href=&quot;inner_product&quot;&gt;std::inner_product&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1）等效于 &lt;code&gt;transform_reduce(first1, last1, first2, init, std::plus&amp;lt;&amp;gt;(), std::multiplies&amp;lt;&amp;gt;());&lt;/code&gt; ，有效地并行化了默认 &lt;code&gt;&lt;a href=&quot;inner_product&quot;&gt;std::inner_product&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a1464ca469f44a3064f6e7b09b363ce619c9a97" translate="yes" xml:space="preserve">
          <source>1) Equivalent to:</source>
          <target state="translated">1)相当于:</target>
        </trans-unit>
        <trans-unit id="f32c1f81db0f32f22596c137532eaf553b842a7b" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return b = b &amp;lt;&amp;lt; shift;&lt;/code&gt; This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1）等效于： &lt;code&gt;return b = b &amp;lt;&amp;lt; shift;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; 为true，则此重载仅参与重载解析。</target>
        </trans-unit>
        <trans-unit id="ce50226b3eed2748aea0ee2f4a0f21490b16d346" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return l = l | r;&lt;/code&gt;.</source>
          <target state="translated">1）等效于： &lt;code&gt;return l = l | r;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a824e001a18c6b6d534ce889aabe17e30fbd0108" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(b) &amp;lt;&amp;lt; shift);&lt;/code&gt; This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1）等效于： &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(b) &amp;lt;&amp;lt; shift);&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; 为true，则此重载仅参与重载解析。</target>
        </trans-unit>
        <trans-unit id="50ddbf3ee011e6961ef6494bf423ec3c2c018228" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) | static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt;.</source>
          <target state="translated">1）等效于： &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) | static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b33dd7c481fdd2621d129a0b3503bdf96a3c1775" translate="yes" xml:space="preserve">
          <source>1) Erases all elements that compare equal to &lt;code&gt;value&lt;/code&gt; from the container. Equivalent to &lt;code&gt;c.erase(std::remove(c.begin(), c.end(), value), c.end());&lt;/code&gt;</source>
          <target state="translated">1）从容器中擦除所有等于 &lt;code&gt;value&lt;/code&gt; 元素。等效于 &lt;code&gt;c.erase(std::remove(c.begin(), c.end(), value), c.end());&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cb1efcdcc78f435229d9add9af0fde373e753a3" translate="yes" xml:space="preserve">
          <source>1) Erases all elements that compare equal to &lt;code&gt;value&lt;/code&gt; from the container. Equivalent to &lt;code&gt;c.remove_if([&amp;amp;](auto&amp;amp; elem) { return elem == value; });&lt;/code&gt;</source>
          <target state="translated">1）从容器中擦除所有等于 &lt;code&gt;value&lt;/code&gt; 元素。等效于 &lt;code&gt;c.remove_if([&amp;amp;](auto&amp;amp; elem) { return elem == value; });&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1797656c42e6ae99b3e7edb8a97b39fe346fd5bd" translate="yes" xml:space="preserve">
          <source>1) Evaluates the expression, terminates the current function and returns the result of the expression to the caller, after &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; to the function return type. The expression is optional in functions whose return type is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, and disallowed in constructors and in destructors.</source>
          <target state="translated">1）在&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt;为函数返回类型之后，计算表达式，终止当前函数并将表达式的结果返回给调用方。在返回类型为（可能是cv限定） &lt;code&gt;void&lt;/code&gt; 的函数中，表达式是可选的，而在构造函数和析构函数中则不允许使用该表达式。</target>
        </trans-unit>
        <trans-unit id="4a7dddb18cbda7dbc3e902e0510c2c2998153f38" translate="yes" xml:space="preserve">
          <source>1) Exactly &lt;code&gt;N&lt;/code&gt; applications of the predicate and &lt;code&gt;O(N)&lt;/code&gt; swaps if there is enough extra memory. If memory is insufficient, at most &lt;code&gt;N log N&lt;/code&gt; swaps.</source>
          <target state="translated">1）究竟 &lt;code&gt;N&lt;/code&gt; 谓词的应用程序和 &lt;code&gt;O(N)&lt;/code&gt; 如果有足够的额外内存，则 O（N）交换。如果内存不足，则最多 &lt;code&gt;N log N&lt;/code&gt; 交换。</target>
        </trans-unit>
        <trans-unit id="d85c974f9fac4ed00ac82960b3a7f736c51ad8ce" translate="yes" xml:space="preserve">
          <source>1) Exactly N applications of the predicate. At most N/2 swaps if &lt;code&gt;ForwardIt&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, and at most N swaps otherwise.</source>
          <target state="translated">1）谓词恰好有N个应用。如果 &lt;code&gt;ForwardIt&lt;/code&gt; 最多N / 2个交换满足的要求&lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;，和最多N互换否则。</target>
        </trans-unit>
        <trans-unit id="3898a5e907961e19d6f3818b3f6c38e485189ef0" translate="yes" xml:space="preserve">
          <source>1) Exchanges elements between range &lt;code&gt;[first1, last1)&lt;/code&gt; and another range starting at &lt;code&gt;first2&lt;/code&gt;.</source>
          <target state="translated">1）在范围 &lt;code&gt;[first1, last1)&lt;/code&gt; 之间交换元素和另一个从 &lt;code&gt;first2&lt;/code&gt; 开始的范围。</target>
        </trans-unit>
        <trans-unit id="2cd67e4d55cd7feca04c7b3f2ebf39800dd11361" translate="yes" xml:space="preserve">
          <source>1) Explicit instantiation definition</source>
          <target state="translated">1)明确的实例定义</target>
        </trans-unit>
        <trans-unit id="06804e68db44d5febdac7eef45d88e3b0a1f984d" translate="yes" xml:space="preserve">
          <source>1) Explicit instantiation definition (without &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; if every non-default template parameter is explicitly specified)</source>
          <target state="translated">1）显式实例化定义（无 &lt;a href=&quot;template_argument_deduction&quot;&gt;&lt;/a&gt;如果显式指定了每个非默认模板参数，扣除模板参数）</target>
        </trans-unit>
        <trans-unit id="e49d0053d14d536a2855f480783e3fc7be7596bc" translate="yes" xml:space="preserve">
          <source>1) Explicitly defaulted copy assignment operator that copy assigns the base class (&lt;code&gt;OuterAlloc&lt;/code&gt;, the outer allocator) and all inner allocators.</source>
          <target state="translated">1）显式默认的副本分配运算符，用于复制分配基类（ &lt;code&gt;OuterAlloc&lt;/code&gt; ，外部分配器）和所有内部分配器。</target>
        </trans-unit>
        <trans-unit id="a4749611efc7cb267b48bb41ce78225481d0be01" translate="yes" xml:space="preserve">
          <source>1) Fancy pointer overload: If the expression &lt;code&gt;&lt;a href=&quot;pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&amp;lt;Ptr&amp;gt;::to_address(p)&lt;/code&gt; is well-formed, returns the result of that expression. Otherwise, returns &lt;code&gt;std::to_address(p.operator-&amp;gt;())&lt;/code&gt;.</source>
          <target state="translated">1）花式指针重载：如果表达式 &lt;code&gt;&lt;a href=&quot;pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&amp;lt;Ptr&amp;gt;::to_address(p)&lt;/code&gt; 的格式正确，则返回该表达式的结果。否则，返回 &lt;code&gt;std::to_address(p.operator-&amp;gt;())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7990d512de136056ee815911efb4602f71ddedef" translate="yes" xml:space="preserve">
          <source>1) File permissions information.</source>
          <target state="translated">1)文件权限信息。</target>
        </trans-unit>
        <trans-unit id="27c1e10d4c10af58dfddd5cff99066596a87eea5" translate="yes" xml:space="preserve">
          <source>1) File type information.</source>
          <target state="translated">1)文件类型信息。</target>
        </trans-unit>
        <trans-unit id="f4fc5fa63bf321ae1e98780408b5986c98eb7933" translate="yes" xml:space="preserve">
          <source>1) Finds the first character equal to none of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1）查找第一个不等于的字符 &lt;code&gt;str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e79c22b35aadf16bbb2bbdbbd059e4bce47a02e" translate="yes" xml:space="preserve">
          <source>1) Finds the first character equal to one of the characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1）查找等于 &lt;code&gt;str&lt;/code&gt; 中的一个字符的第一个字符。</target>
        </trans-unit>
        <trans-unit id="442f6a60a472a2e1141c1b6fb37c658af721c0e6" translate="yes" xml:space="preserve">
          <source>1) Finds the first character not equal to any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1）从位置 &lt;code&gt;pos&lt;/code&gt; 开始查找此视图中不等于 &lt;code&gt;v&lt;/code&gt; 的任何字符的第一个字符。</target>
        </trans-unit>
        <trans-unit id="51cda46cabb3895bd9df4ec43f3daadbc2f64384" translate="yes" xml:space="preserve">
          <source>1) Finds the first occurence of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1）在位置 &lt;code&gt;pos&lt;/code&gt; 中查找 &lt;code&gt;v&lt;/code&gt; 在该视图中的第一个出现位置。</target>
        </trans-unit>
        <trans-unit id="fd62aaa68509bd9a4fb9fb278bc9c7d8c255380a" translate="yes" xml:space="preserve">
          <source>1) Finds the first occurence of any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1）从位置 &lt;code&gt;pos&lt;/code&gt; 开始查找此视图中 &lt;code&gt;v&lt;/code&gt; 的任何字符的第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="991eb68c46670361f174f149c9bbff9453009cbe" translate="yes" xml:space="preserve">
          <source>1) Finds the first substring equal to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1）查找等于 &lt;code&gt;str&lt;/code&gt; 的第一个子字符串。</target>
        </trans-unit>
        <trans-unit id="6704dbd43b3ce3882e6b0b77ffcd5282c0cd6ca9" translate="yes" xml:space="preserve">
          <source>1) Finds the last character equal to none of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1）查找不等于 &lt;code&gt;str&lt;/code&gt; 中字符的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="ce86bceaea369df79d331c69a11951d70d544899" translate="yes" xml:space="preserve">
          <source>1) Finds the last character equal to one of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1）查找等于 &lt;code&gt;str&lt;/code&gt; 中的一个字符的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="70fd55a6b81aaf507648a0cddd92b8c633cda844" translate="yes" xml:space="preserve">
          <source>1) Finds the last character not equal to any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1）从位置 &lt;code&gt;pos&lt;/code&gt; 开始，查找此视图中不等于 &lt;code&gt;v&lt;/code&gt; 的任何字符的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="7a117a35d4790c36ea6419c73a7d006ccff236b7" translate="yes" xml:space="preserve">
          <source>1) Finds the last occurence of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1）在位置 &lt;code&gt;pos&lt;/code&gt; 中查找 &lt;code&gt;v&lt;/code&gt; 在该视图中的最后一次出现。</target>
        </trans-unit>
        <trans-unit id="950316330142526c0ea12d1cb0ce500d7d27ceb8" translate="yes" xml:space="preserve">
          <source>1) Finds the last occurence of any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, ending at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1）查找此视图中 &lt;code&gt;v&lt;/code&gt; 的任何字符的最后一次出现，在位置处结束 &lt;code&gt;pos&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc6591ef2b8655c84fe527417b8508f21209a752" translate="yes" xml:space="preserve">
          <source>1) Finds the last substring equal to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1）查找等于 &lt;code&gt;str&lt;/code&gt; 的最后一个子字符串。</target>
        </trans-unit>
        <trans-unit id="bfb87cff99851f1a19a7bc551155598781e3afd7" translate="yes" xml:space="preserve">
          <source>1) First calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; to close the associated file, then moves the contents of &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;: the put and get buffers, the associated file, the locale, the openmode, the is_open flag, and any other state. After the move, &lt;code&gt;rhs&lt;/code&gt; is not associated with a file and &lt;code&gt;rhs.is_open() == false&lt;/code&gt;.</source>
          <target state="translated">1）首先调用 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 关闭关联的文件，然后将 &lt;code&gt;rhs&lt;/code&gt; 的内容移动到 &lt;code&gt;*this&lt;/code&gt; ：放置和获取缓冲区，关联的文件，语言环境，openmode，is_open标志以及任何其他状态。移动后， &lt;code&gt;rhs&lt;/code&gt; 不与文件关联，并且 &lt;code&gt;rhs.is_open() == false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd18b72a5a285015ba6ec06d12d8ef6d1cba7955" translate="yes" xml:space="preserve">
          <source>1) First converts &lt;code&gt;f&lt;/code&gt; to some temporary value &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../locale/ctype_base&quot;&gt;std::ctype_base::mask&lt;/a&gt;&lt;/code&gt; in implementation-defined manner</source>
          <target state="translated">1）首先将 &lt;code&gt;f&lt;/code&gt; 转换为 &lt;code&gt;&lt;a href=&quot;../../locale/ctype_base&quot;&gt;std::ctype_base::mask&lt;/a&gt;&lt;/code&gt; 类型的某个临时值 &lt;code&gt;m&lt;/code&gt; 以实现定义的方式</target>
        </trans-unit>
        <trans-unit id="66258cec208a65037d1db76ff3382868c359cbe4" translate="yes" xml:space="preserve">
          <source>1) First, &lt;a href=&quot;copy_initialization&quot;&gt;copy-initializes&lt;/a&gt; the</source>
          <target state="translated">1）首先， &lt;a href=&quot;copy_initialization&quot;&gt;复制初始化&lt;/a&gt;的</target>
        </trans-unit>
        <trans-unit id="cd33253b53a6763ed072481c1c0f67e8204b5635" translate="yes" xml:space="preserve">
          <source>1) First, decl-specifier-seq and the declarator are combined as in any &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; to determine the type.</source>
          <target state="translated">1）首先，像在任何&lt;a href=&quot;declarations&quot;&gt;声明中&lt;/a&gt;一样，将decl-specifier-seq和声明符组合在一起以确定类型。</target>
        </trans-unit>
        <trans-unit id="24a19262c4d1f80ce9e0dc9caab9f79a6b0bff5b" translate="yes" xml:space="preserve">
          <source>1) Flips all bits (like &lt;code&gt;&lt;a href=&quot;operator_logic&quot;&gt;operator~&lt;/a&gt;&lt;/code&gt;, but in-place)</source>
          <target state="translated">1）翻转所有位（例如 &lt;code&gt;&lt;a href=&quot;operator_logic&quot;&gt;operator~&lt;/a&gt;&lt;/code&gt; ，但就位）</target>
        </trans-unit>
        <trans-unit id="5300a7112838d676f5f66db26a00a4959307ece8" translate="yes" xml:space="preserve">
          <source>1) Floating point value identifying the &amp;alpha; parameter</source>
          <target state="translated">1）标识&amp;alpha;参数的浮点值</target>
        </trans-unit>
        <trans-unit id="0e6b85b611c8ca2ab85cbbefdb0db71abdb9bd30" translate="yes" xml:space="preserve">
          <source>1) For an object of type X using the class member access operator</source>
          <target state="translated">1)对于一个类型为X的对象,使用类成员访问操作符</target>
        </trans-unit>
        <trans-unit id="620d62ba1adcb76635cafe39e1be9ff044838905" translate="yes" xml:space="preserve">
          <source>1) For arguments of fundamental type, the associated set of namespaces and classes is empty</source>
          <target state="translated">1)对于基本类型的参数,相关的命名空间和类集为空。</target>
        </trans-unit>
        <trans-unit id="0c378136ab43e1fdcea07a911ec40f85b088db94" translate="yes" xml:space="preserve">
          <source>1) For every named variable with static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;that is not subject to &lt;a href=&quot;constant_initialization&quot;&gt;constant initialization&lt;/a&gt;(since C++14), before any other initialization.</source>
          <target state="translated">1）对于每个具有静态或线程本地&lt;a href=&quot;storage_duration&quot;&gt;存储持续时间的&lt;/a&gt;命名变量，该变量在进行任何其他初始化之前均不进行&lt;a href=&quot;constant_initialization&quot;&gt;常量初始化&lt;/a&gt;（自C ++ 14起）。</target>
        </trans-unit>
        <trans-unit id="a2228ff5f261316a14c0c628f07410bc975495de" translate="yes" xml:space="preserve">
          <source>1) For the built-in operator, one of the expressions (either expr1 or expr2) must be a glvalue of type &amp;ldquo;array of T&amp;rdquo; or a prvalue of type &amp;ldquo;pointer to T&amp;rdquo;, while the other expression (expr2 or expr1, respectively) must be a prvalue of unscoped enumeration or integral type. The result of this expression has the type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">1）对于内置运算符，其中一个表达式（expr1或expr2）必须是&amp;ldquo; T数组&amp;rdquo;类型的glvalue或&amp;ldquo; pointer to T&amp;rdquo;类型的prvalue，而另一个表达式（expr2或expr1，分别为非范围枚举或整数类型的prvalue。该表达式的结果具有类型 &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="908b6cc5f8feeba46b723cf8345b6e77ca24c647" translate="yes" xml:space="preserve">
          <source>1) For user-defined integer literals</source>
          <target state="translated">1)对于用户定义的整数字元</target>
        </trans-unit>
        <trans-unit id="8f2bdea671ba63209e8908fa5f60f318cc0d7593" translate="yes" xml:space="preserve">
          <source>1) Forms lvalue reference to const type of &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">1）形成左值引用 &lt;code&gt;t&lt;/code&gt; 的 const类型</target>
        </trans-unit>
        <trans-unit id="10e52e4189c8c4f69c3b43f760a5733f16a0cecd" translate="yes" xml:space="preserve">
          <source>1) Forwards lvalues as either lvalues or as rvalues, depending on T</source>
          <target state="translated">1)根据T,将l值转发为l值或r值。</target>
        </trans-unit>
        <trans-unit id="0aa251b9780dd1a068e6af33ad51fdab09a9b853" translate="yes" xml:space="preserve">
          <source>1) Full declaration.</source>
          <target state="translated">1)全面申报。</target>
        </trans-unit>
        <trans-unit id="d52437442bfb9b172705dc9281744b3b9dabeae9" translate="yes" xml:space="preserve">
          <source>1) Given &lt;code&gt;current_ptr&lt;/code&gt;, the pointer that was managed by &lt;code&gt;*this&lt;/code&gt;, performs the following actions, in this order:</source>
          <target state="translated">1）给定 &lt;code&gt;current_ptr&lt;/code&gt; ，由 &lt;code&gt;*this&lt;/code&gt; 管理的指针按此顺序执行以下操作：</target>
        </trans-unit>
        <trans-unit id="c25bb4537de07ca2e9c955609fc621b56b5c86ae" translate="yes" xml:space="preserve">
          <source>1) Half the sum of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. No overflow occurs. If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have integer type and the sum is odd, the result is rounded towards &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have floating-point type, at most one inexact operation occurs.</source>
          <target state="translated">1） &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 之和的一半。没有溢出发生。如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 为整数类型，并且总和为奇数，则将结果四舍五入为 &lt;code&gt;a&lt;/code&gt; 。如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 浮点类型，则最多会发生一次不精确的操作。</target>
        </trans-unit>
        <trans-unit id="389c5e318417b817814b4e4cfab6dc113e1fc480" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;*this&lt;/code&gt; contains a value before the call, the contained value is destroyed by calling its destructor as if by &lt;code&gt;value().T::~T()&lt;/code&gt;. &lt;code&gt;*this&lt;/code&gt; does not contain a value after this call.</source>
          <target state="translated">1）如果 &lt;code&gt;*this&lt;/code&gt; 在调用之前包含一个值，则通过调用其析构函数来破坏所包含的值，就像使用 &lt;code&gt;value().T::~T()&lt;/code&gt; 。 &lt;code&gt;*this&lt;/code&gt; 此调用后不包含任何值。</target>
        </trans-unit>
        <trans-unit id="5c29eb73572b5b54b5bde81bc8cece3cd885b3b2" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt; is not satisfied, the copy assignment operator's body is equivalent to &lt;code&gt;if (other) emplace(*other); else reset(); return *this;&lt;/code&gt;.</source>
          <target state="translated">1）如果不满足 &lt;code&gt;&lt;a href=&quot;../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt; ，则副本分配运算符的主体等效于 &lt;code&gt;if (other) emplace(*other); else reset(); return *this;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d43ce007d320a6fcb3a66694c64b2aa6772b3c7" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; stores a copy of the caught exception and if the copy constructor of the exception object caught by &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; throws an exception, the captured exception is an instance of &lt;code&gt;std::bad_exception&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 存储捕获的异常的副本，并且如果 &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; 捕获的异常对象的副本构造函数抛出异常，则捕获的异常是 &lt;code&gt;std::bad_exception&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="871b74ba2e944632eb24642e2095fcaae5540862" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; ，否则 &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2558dfd99cfdc502e01a5c094f7431492308ad2e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;P&lt;/code&gt; is a reference type, the deduced &lt;code&gt;A&lt;/code&gt; (i.e., the type referred to by the reference) can be more cv-qualified than the transformed &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">1）如果 &lt;code&gt;P&lt;/code&gt; 是引用类型，则推导的 &lt;code&gt;A&lt;/code&gt; （即引用所引用的类型）比经过转换的 &lt;code&gt;A&lt;/code&gt; 更具cv限定性：</target>
        </trans-unit>
        <trans-unit id="e6b573b161e778f9527a59ca867befe70e44b598" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;P&lt;/code&gt; is not a reference type,</source>
          <target state="translated">1）如果 &lt;code&gt;P&lt;/code&gt; 不是参考类型，</target>
        </trans-unit>
        <trans-unit id="6f224d7d59ccb2a0648c9f79474f4f6215450b64" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; for some type &lt;code&gt;U&lt;/code&gt;, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names &lt;code&gt;U&amp;amp;&lt;/code&gt;; otherwise, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1）如果对于某些类型 &lt;code&gt;U&lt;/code&gt; ， &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; ，则提供一个名为 &lt;code&gt;U&amp;amp;&lt;/code&gt; 的成员typedef &lt;code&gt;type&lt;/code&gt; ；否则，提供一个名为 &lt;code&gt;T&lt;/code&gt; 的成员typedef &lt;code&gt;type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="533c4f52ff1cea4318aa8c59d1192a5f19648e8c" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;T&lt;/code&gt; 是引用类型，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46015a38f56b223eca9255c907b1367791f0fb7e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is an object or reference type and the variable definition &lt;code&gt;T obj(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...);&lt;/code&gt; is well-formed, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. In all other cases, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;T&lt;/code&gt; 是对象或引用类型，并且变量定义 &lt;code&gt;T obj(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...);&lt;/code&gt; 格式正确，提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。在所有其他情况下， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3b72851ab3519141cf487432144a3f31b79335b" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is an object type or a function type that has no cv- or ref- qualifier, provides a member typedef &lt;code&gt;type&lt;/code&gt; which is &lt;code&gt;T&amp;amp;&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an rvalue reference to some type &lt;code&gt;U&lt;/code&gt;, then &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;U&amp;amp;&lt;/code&gt;. Otherwise, &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;T&lt;/code&gt; 是对象类型或没有cv-或ref限定词的函数类型，则提供成员typedef &lt;code&gt;type&lt;/code&gt; ，即 &lt;code&gt;T&amp;amp;&lt;/code&gt; 。如果 &lt;code&gt;T&lt;/code&gt; 是对某些类型 &lt;code&gt;U&lt;/code&gt; 的右值引用，则 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;U&amp;amp;&lt;/code&gt; 。否则， &lt;code&gt;type&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="84341e9136029ad471cfa5b9061bb952f1306ba2" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is not a referenceable type (i.e., possibly cv-qualified &lt;code&gt;void&lt;/code&gt; or a function type with a</source>
          <target state="translated">1）如果 &lt;code&gt;T&lt;/code&gt; 不是可引用的类型（即，可能是cv限定的 &lt;code&gt;void&lt;/code&gt; 或带有a的函数类型</target>
        </trans-unit>
        <trans-unit id="55b2f140ddb9e139d3eddb758d445d70f330d38a" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;bool(lhs) != bool(rhs)&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">1）如果 &lt;code&gt;bool(lhs) != bool(rhs)&lt;/code&gt; ，则返回 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a4d89d7c12b3e0fdc5475924278afccc9fcb9a0" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;c==EOF&lt;/code&gt;, does nothing</source>
          <target state="translated">1）如果 &lt;code&gt;c==EOF&lt;/code&gt; ，则不执行任何操作</target>
        </trans-unit>
        <trans-unit id="48cff9cec5eee4d48df8a56a52bf392dc360ed81" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;e&lt;/code&gt; is a function call expression, and</source>
          <target state="translated">1）如果 &lt;code&gt;e&lt;/code&gt; 是一个函数调用表达式，并且</target>
        </trans-unit>
        <trans-unit id="8cb38dc250b911397e4c0873f26f0012d9d8ab6e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;ok()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, returns a &lt;code&gt;sys_days&lt;/code&gt; that represents the last &lt;code&gt;weekday()&lt;/code&gt; of the &lt;code&gt;year()&lt;/code&gt; and &lt;code&gt;month()&lt;/code&gt;. Otherwise, the returned value is unspecified.</source>
          <target state="translated">1）如果 &lt;code&gt;ok()&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ，返回 &lt;code&gt;sys_days&lt;/code&gt; 表示最后 &lt;code&gt;weekday()&lt;/code&gt; 中的 &lt;code&gt;year()&lt;/code&gt; 和 &lt;code&gt;month()&lt;/code&gt; 。否则，返回值是不确定的。</target>
        </trans-unit>
        <trans-unit id="ae1ac36ae20a2ced74aaccf2496e723144a48341" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;ok()&lt;/code&gt; is true, the return value holds a count of days from the &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&lt;/code&gt; epoch (1970-01-01) to &lt;code&gt;*this&lt;/code&gt;. The result is negative if &lt;code&gt;*this&lt;/code&gt; represent a date prior to it.</source>
          <target state="translated">1）如果 &lt;code&gt;ok()&lt;/code&gt; 为true，则返回值保留从 &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&lt;/code&gt; 纪元（1970-01-01）到 &lt;code&gt;*this&lt;/code&gt; 的天数。如果 &lt;code&gt;*this&lt;/code&gt; ，结果为负表示早于日期，则。</target>
        </trans-unit>
        <trans-unit id="775e0551aa7721ab9c56d7c9c8e95ac883de5834" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;p.is_absolute() || (p.has_root_name() &amp;amp;&amp;amp; p.root_name() != root_name())&lt;/code&gt;, then replaces the current path with p as if by &lt;code&gt;operator=(p)&lt;/code&gt; and finishes.</source>
          <target state="translated">1）如果 &lt;code&gt;p.is_absolute() || (p.has_root_name() &amp;amp;&amp;amp; p.root_name() != root_name())&lt;/code&gt; ，然后将当前路径替换为p，就好像被 &lt;code&gt;operator=(p)&lt;/code&gt; 结束一样。</target>
        </trans-unit>
        <trans-unit id="5df1170b75f3b245eb679518c7086990da875b8a" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;pos == size()&lt;/code&gt;, the behavior is undefined. 2) If &lt;code&gt;pos == size()&lt;/code&gt;, a reference to the character with value &lt;code&gt;CharT()&lt;/code&gt; (the null character) is returned.</source>
          <target state="translated">1）如果 &lt;code&gt;pos == size()&lt;/code&gt; ，则行为未定义。2）如果 &lt;code&gt;pos == size()&lt;/code&gt; ，则返回对值为 &lt;code&gt;CharT()&lt;/code&gt; 的字符(空字符）的引用。</target>
        </trans-unit>
        <trans-unit id="23b154b4ece6fb3ebf14c379625abd81a94b12f9" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;root_name().native().compare(p.root_name().native())&lt;/code&gt; is nonzero, returns that value.</source>
          <target state="translated">1）如果 &lt;code&gt;root_name().native().compare(p.root_name().native())&lt;/code&gt; 为非零，则返回该值。</target>
        </trans-unit>
        <trans-unit id="8adfe00a74db942dc8cc130967e0f6e088361d3c" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;sizeof...(MutexTypes) == 0&lt;/code&gt;, does nothing. Otherwise, If &lt;code&gt;sizeof...(MutexTypes) == 1&lt;/code&gt;, effectively calls &lt;code&gt;m.lock()&lt;/code&gt;. Otherwise, effectively calls &lt;code&gt;&lt;a href=&quot;../lock&quot;&gt;std::lock&lt;/a&gt;(m...)&lt;/code&gt;. The behavior is undefined if one of &lt;code&gt;MutexTypes&lt;/code&gt; is not a recursive mutex and the current thread already owns the corresponding argument in &lt;code&gt;m...&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;sizeof...(MutexTypes) == 0&lt;/code&gt; ，则不执行任何操作。否则，如果 &lt;code&gt;sizeof...(MutexTypes) == 1&lt;/code&gt; ，则有效地调用 &lt;code&gt;m.lock()&lt;/code&gt; 。否则，有效地调用 &lt;code&gt;&lt;a href=&quot;../lock&quot;&gt;std::lock&lt;/a&gt;(m...)&lt;/code&gt; 。如果 &lt;code&gt;MutexTypes&lt;/code&gt; 之一不是递归互斥体并且当前线程已经拥有 &lt;code&gt;m...&lt;/code&gt; 的相应参数，则该行为是不确定的。。</target>
        </trans-unit>
        <trans-unit id="5ce02c5f4f1088b1082aa38dc45c7ca3365e6a7f" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;v&lt;/code&gt; compares less than &lt;code&gt;lo&lt;/code&gt;, returns &lt;code&gt;lo&lt;/code&gt;; otherwise if &lt;code&gt;hi&lt;/code&gt; compares less than &lt;code&gt;v&lt;/code&gt;, returns &lt;code&gt;hi&lt;/code&gt;; otherwise returns &lt;code&gt;v&lt;/code&gt;. Uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the values.</source>
          <target state="translated">1）如果 &lt;code&gt;v&lt;/code&gt; 比较小于 &lt;code&gt;lo&lt;/code&gt; ，则返回 &lt;code&gt;lo&lt;/code&gt; ；否则，如果 &lt;code&gt;hi&lt;/code&gt; 比较小于 &lt;code&gt;v&lt;/code&gt; ，则返回 &lt;code&gt;hi&lt;/code&gt; ; 否则返回 &lt;code&gt;v&lt;/code&gt; 。使用 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 比较值。</target>
        </trans-unit>
        <trans-unit id="4d06e0518b8e9559ed2e398da1df96960c59c244" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;year().ok() &amp;amp;&amp;amp; month().ok() &amp;amp;&amp;amp; weekday().ok()&lt;/code&gt;:</source>
          <target state="translated">1）如果 &lt;code&gt;year().ok() &amp;amp;&amp;amp; month().ok() &amp;amp;&amp;amp; weekday().ok()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="953c7b17bedfe4cec3a6964917bcb6dd438c090c" translate="yes" xml:space="preserve">
          <source>1) If a key equivalent to &lt;code&gt;k&lt;/code&gt; already exists in the container, does nothing. Otherwise, behaves like &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; except that the element is constructed as &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt;</source>
          <target state="translated">1）如果容器中已经存在等于 &lt;code&gt;k&lt;/code&gt; 的键，则不执行任何操作。否则，除了元素被构造为 &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt; 之外，其行为类似于&lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27c9cac424cf306f64712cae4c73131e4ecf8efa" translate="yes" xml:space="preserve">
          <source>1) If an exception is thrown, &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; is called</source>
          <target state="translated">1）如果抛出异常，则调用 &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="053707ffbcc5a261ff2e9f6e03a44ce4aa6bea54" translate="yes" xml:space="preserve">
          <source>1) If an imaginary struct containing a member object of type &lt;code&gt;T&lt;/code&gt; has a non-deleted destructor, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1）如果包含 &lt;code&gt;T&lt;/code&gt; 型成员对象的虚构结构具有未删除的析构函数，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d6c0a2e0ad065651ccf574c46ce2ec1d6a32e799" translate="yes" xml:space="preserve">
          <source>1) If both operands are null pointer constants, the composite pointer type is &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1）如果两个操作数都是空指针常量，则复合指针类型为 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="001a94641182b36fb39ecd7c6f316dc79e18bf05" translate="yes" xml:space="preserve">
          <source>1) If both pointers to member are null member pointer values, they</source>
          <target state="translated">1)如果指向成员的两个指针都是空的成员指针值,那么它们是</target>
        </trans-unit>
        <trans-unit id="d696aa7c360446c7c92bbb49a9fa4b905e4ea6af" translate="yes" xml:space="preserve">
          <source>1) If either &lt;code&gt;E2&lt;/code&gt; or &lt;code&gt;E3&lt;/code&gt; has type &lt;code&gt;void&lt;/code&gt;, then one of the following must be true, or the program is ill-formed:</source>
          <target state="translated">1）如果 &lt;code&gt;E2&lt;/code&gt; 或 &lt;code&gt;E3&lt;/code&gt; 的类型为 &lt;code&gt;void&lt;/code&gt; ，则以下条件之一必须为true，否则程序格式错误：</target>
        </trans-unit>
        <trans-unit id="619b57caddc542baf25a7d1c5e7745307a747df0" translate="yes" xml:space="preserve">
          <source>1) If only one specialization matches the template arguments, that specialization is used</source>
          <target state="translated">1)如果只有一个特殊化符合模板参数,则使用该特殊化。</target>
        </trans-unit>
        <trans-unit id="4ae7d33e86f2455f29507118c461d795dd425ce1" translate="yes" xml:space="preserve">
          <source>1) If permitted, &lt;a href=&quot;constant_initialization&quot;&gt;Constant initialization&lt;/a&gt; takes place first (see &lt;a href=&quot;constant_initialization&quot;&gt;Constant initialization&lt;/a&gt; for the list of those situations). In practice, constant initialization is usually performed at compile time, and pre-calculated object representations are stored as part of the program image. If the compiler doesn't do that, it still has to guarantee that this initialization happens before any dynamic initialization.</source>
          <target state="translated">1）如果允许，&lt;a href=&quot;constant_initialization&quot;&gt;恒初始化&lt;/a&gt;首先发生（见&lt;a href=&quot;constant_initialization&quot;&gt;常数初始化&lt;/a&gt;对于这些情况的列表）。实际上，常量初始化通常在编译时执行，并且预先计算的对象表示形式作为程序映像的一部分存储。如果编译器不这样做，它仍然必须保证在任何动态初始化之前进行该初始化。</target>
        </trans-unit>
        <trans-unit id="ec76cf635ed5977262cf9ddcc3fb5fe13eaaff7b" translate="yes" xml:space="preserve">
          <source>1) If set to &lt;code&gt;ON&lt;/code&gt;, informs the compiler that the program will access or modify &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt;, which means that optimizations that could subvert flag tests and mode changes (e.g., global common subexpression elimination, code motion, and constant folding) are prohibited. The default value is implementation-defined, usually &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">1）如果设置为 &lt;code&gt;ON&lt;/code&gt; ，则通知编译器程序将访问或修改&lt;a href=&quot;../numeric/fenv&quot;&gt;浮点环境&lt;/a&gt;，这意味着可以破坏标志测试和模式更改的优化（例如，全局通用子表达式消除，代码运动和常数折叠）是禁止。默认值是实现定义的，通常为 &lt;code&gt;OFF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f906d81a6d06437984e964c4636da5851fdcf58f" translate="yes" xml:space="preserve">
          <source>1) If the argument is an unparenthesized &lt;a href=&quot;name&quot;&gt;id-expression&lt;/a&gt; naming a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt;, then decltype yields the</source>
          <target state="translated">1）如果参数是命名&lt;a href=&quot;structured_binding&quot;&gt;结构化绑定的&lt;/a&gt;非括号&lt;a href=&quot;name&quot;&gt;id表达式&lt;/a&gt;，则decltype产生</target>
        </trans-unit>
        <trans-unit id="826d68e87870ec49b6a7fffcc26f9ce675d5f52a" translate="yes" xml:space="preserve">
          <source>1) If the constructor is for the most-derived class, virtual base classes are initialized in the order in which they appear in depth-first left-to-right traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists)</source>
          <target state="translated">1)如果构造函数是针对最派生类的,虚拟基类的初始化顺序是按照基类声明的深度先从左到右遍历的顺序(从左到右指的是在基类规范列表中的出现情况</target>
        </trans-unit>
        <trans-unit id="64bc0d09554e2852fae96f29e67b670b931676e8" translate="yes" xml:space="preserve">
          <source>1) If the current output format is 24-hour, converts to 12-hour time. Otherwise no effects.</source>
          <target state="translated">1)如果当前输出格式为24小时,转换为12小时时间。否则无影响。</target>
        </trans-unit>
        <trans-unit id="0f38fe0a520fad6c56ed541e8d99a4cb99844d3f" translate="yes" xml:space="preserve">
          <source>1) If the declaration of &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;pf&lt;/code&gt;, or &lt;code&gt;pmf&lt;/code&gt; uses &lt;code&gt;throw()&lt;/code&gt;(deprecated) or &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt;, the set is empty. 2) Otherwise, if the declaration of &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;pf&lt;/code&gt;, or &lt;code&gt;pmf&lt;/code&gt; uses a dynamic exception specification(deprecated), the set consists of the types listed in that specification 3) Otherwise, the set is the set of all types</source>
          <target state="translated">1）如果 &lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;pf&lt;/code&gt; 或 &lt;code&gt;pmf&lt;/code&gt; 的声明使用 &lt;code&gt;throw()&lt;/code&gt; （不建议使用）或&lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt;，则该集合为空。2）否则，如果 &lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;pf&lt;/code&gt; 或 &lt;code&gt;pmf&lt;/code&gt; 的声明使用动态异常规范（不建议使用），则该集合由该规范中列出的类型组成3）否则，该集合为所有类型的集合</target>
        </trans-unit>
        <trans-unit id="f9ccd33ddb11cbe7fee8dbccd1e293df7c5318d1" translate="yes" xml:space="preserve">
          <source>1) If the expression &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;() = &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;()&lt;/code&gt; is well-formed in unevaluated context, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to either type.</source>
          <target state="translated">1）如果表达式 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;() = &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;()&lt;/code&gt; 在未 &lt;code&gt;value&lt;/code&gt; 上下文中格式正确，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常量值。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。&lt;a href=&quot;../language/access&quot;&gt;访问检查&lt;/a&gt;就像从与这两种类型都不相关的上下文中一样执行。</target>
        </trans-unit>
        <trans-unit id="3daeab1387736a2e7813fdad3d2e852a5f18e577" translate="yes" xml:space="preserve">
          <source>1) If the expressions &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; and &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;())&lt;/code&gt; are both well-formed in unevaluated context after &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;;&lt;/code&gt; (see &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to either type.</source>
          <target state="translated">1）如果表达式 &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; 和 &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;())&lt;/code&gt; 在 &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;;&lt;/code&gt; 之后，它们都在未评估的上下文中格式良好；（请参阅&lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;），提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。就像从与这两种类型都不相关的上下文中一样执行&lt;a href=&quot;../language/access&quot;&gt;访问检查&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="45059787b4fa742a740d89cbe94d8b03372e1106" translate="yes" xml:space="preserve">
          <source>1) If the imaginary function definition &lt;code&gt;To test() { return &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;(); }&lt;/code&gt; is well-formed, (that is, either &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;()&lt;/code&gt; can be converted to &lt;code&gt;To&lt;/code&gt; using &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicit conversions&lt;/a&gt;, or both &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; are possibly cv-qualified &lt;code&gt;void&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. For the purposes of this check, the use of &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; in the return statement is not considered an &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;.</source>
          <target state="translated">1）如果虚函数定义 &lt;code&gt;To test() { return &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;(); }&lt;/code&gt; 的格式正确（即 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;()&lt;/code&gt; 可以使用&lt;a href=&quot;../language/implicit_cast&quot;&gt;隐式转换&lt;/a&gt;转换为 &lt;code&gt;To&lt;/code&gt; ，或者 &lt;code&gt;From&lt;/code&gt; 和 &lt;code&gt;To&lt;/code&gt; 都可能是cv限定的 &lt;code&gt;void&lt;/code&gt; ），并提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。为了进行此检查，在return语句中使用 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; 不视为&lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6f0b8672e5f29b8486f7709d207643d87be596d9" translate="yes" xml:space="preserve">
          <source>1) If the input sequence has a read position available (&lt;code&gt;egptr() &amp;gt; gptr()&lt;/code&gt;), returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;</source>
          <target state="translated">1）如果输入序列具有可用的读取位置（ &lt;code&gt;egptr() &amp;gt; gptr()&lt;/code&gt; ），则返回 &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c32163286e69234ea02701a99ebdecfd40c8e43" translate="yes" xml:space="preserve">
          <source>1) If the next pointer is null, the operation fails</source>
          <target state="translated">1)如果下一个指针为空,则操作失败</target>
        </trans-unit>
        <trans-unit id="91c47dc3e02728253e0cce0bb00f6bc9a4d38d28" translate="yes" xml:space="preserve">
          <source>1) If the operand is an lvalue expression of some object or function type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;operator&amp;amp;&lt;/code&gt; creates and returns a prvalue of type &lt;code&gt;T*&lt;/code&gt;, with the same cv qualification, that is pointing to the object or function designated by the operand. If the operand has incomplete type, the pointer can be formed, but if that incomplete type happens to be a class that defines its own &lt;code&gt;operator&amp;amp;&lt;/code&gt;, the behavior is undefined(until C++14)it is unspecified whether the built-in or the overload is used(since C++14). For the operands of type with user-defined &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; may be used to obtain the true pointer.</source>
          <target state="translated">1）如果操作数是某个对象或函数类型 &lt;code&gt;T&lt;/code&gt; 的左值表达式， &lt;code&gt;operator&amp;amp;&lt;/code&gt; 将创建并返回具有相同cv限定条件的 &lt;code&gt;T*&lt;/code&gt; 类型的prvalue ，该值指向操作数指定的对象或函数。如果操作数具有不完整的类型，则可以形成指针，但是如果该不完整的类型恰好是定义其自己的 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 的类，则该行为是undefined（直到C ++ 14），不确定是内置还是内部。使用重载（从C ++ 14开始）。对于类型的与用户定义的操作数 &lt;code&gt;operator&amp;amp;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; 可用于获得真实的指针。</target>
        </trans-unit>
        <trans-unit id="a1256320cbee9651ed515f01789527567a38d98e" translate="yes" xml:space="preserve">
          <source>1) If the path is empty, stop (normal form of an empty path is an empty path)</source>
          <target state="translated">1)如果路径为空,则停止(空路径的正常形式为空路径)。</target>
        </trans-unit>
        <trans-unit id="582111318ab00f1208e85c21c22bca92315c07e6" translate="yes" xml:space="preserve">
          <source>1) If the pointer to be repositioned is a null pointer and the new offset &lt;code&gt;newoff&lt;/code&gt; would be non-zero, this function fails.</source>
          <target state="translated">1）如果要重新定位的指针是空指针，而新的偏移量 &lt;code&gt;newoff&lt;/code&gt; 将不为零，则此函数将失败。</target>
        </trans-unit>
        <trans-unit id="fe93a7c23cff4516602f15cbb778ed98afe55fb4" translate="yes" xml:space="preserve">
          <source>1) If the pointers are both null pointer values, they</source>
          <target state="translated">1)如果指针都是空指针值,则它们</target>
        </trans-unit>
        <trans-unit id="fc198593bd9ec378434428d9afd2c41063e2a0a5" translate="yes" xml:space="preserve">
          <source>1) If the type of expression is exactly new_type or a less cv-qualified version of new_type, the result is the value of expression, with type new_type. (In other words, &lt;code&gt;dynamic_cast&lt;/code&gt; can be used to add constness. An implicit conversion and &lt;code&gt;static_cast&lt;/code&gt; can perform this conversion as well.)</source>
          <target state="translated">1）如果表达式的类型恰好是new_type或cv限定的new_type版本，则结果是类型为new_type的表达式的值。（换句话说， &lt;code&gt;dynamic_cast&lt;/code&gt; 可用于添加常量。隐式转换和 &lt;code&gt;static_cast&lt;/code&gt; 也可以执行此转换。）</target>
        </trans-unit>
        <trans-unit id="81e1b3a4903489b6c6f5290600d72bbbee763b8f" translate="yes" xml:space="preserve">
          <source>1) If the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; stores the same &lt;code&gt;T*&lt;/code&gt; as &lt;code&gt;expected&lt;/code&gt; and shares ownership with it, or if both underlying and &lt;code&gt;expected&lt;/code&gt; are empty, assigns from &lt;code&gt;desired&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;, and orders memory according to &lt;code&gt;success&lt;/code&gt;, otherwise assigns from the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;expected&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;, and orders memory according to &lt;code&gt;failure&lt;/code&gt;. The behavior is undefined if &lt;code&gt;failure&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;. On success, the operation is an atomic read-modify-write operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is not accessed after the atomic update. On failure, the operation is an atomic load operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is updated with the existing value read from the atomic object. This update to &lt;code&gt;expected&lt;/code&gt;'s use_count is part of this atomic operation, although the write itself (and any subsequent deallocation/destruction) is not required to be.</source>
          <target state="translated">1）如果底层 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 存储相同的 &lt;code&gt;T*&lt;/code&gt; 作为 &lt;code&gt;expected&lt;/code&gt; 并与它共享所有权，或者如果这两个底层和 &lt;code&gt;expected&lt;/code&gt; 是空的，受让人从 &lt;code&gt;desired&lt;/code&gt; 对底层 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ，然后根据 &lt;code&gt;success&lt;/code&gt; 顺序对内存进行排序，否则从基础 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 分配给 &lt;code&gt;expected&lt;/code&gt; ，返回 &lt;code&gt;false&lt;/code&gt; ，并根据 &lt;code&gt;failure&lt;/code&gt; 进行排序。如果 &lt;code&gt;failure&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 则行为未定义或 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; 。如果成功，操作上原子的读-修改-写操作 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;expected&lt;/code&gt; 的原子更新之后，不会访问。失败时，该操作是对 &lt;code&gt;*this&lt;/code&gt; 的原子加载操作，并且 &lt;code&gt;expected&lt;/code&gt; 会使用从原子对象读取的现有值进行更新。尽管不需要写入本身（以及任何后续的释放/销毁），但对 &lt;code&gt;expected&lt;/code&gt; 的use_count的此更新是此原子操作的一部分。</target>
        </trans-unit>
        <trans-unit id="debd587f8b5b3f706f78c4d8eb91989d3f630fe5" translate="yes" xml:space="preserve">
          <source>1) If the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; stores the same pointer value as &lt;code&gt;expected&lt;/code&gt; and shares ownership with it, or if both underlying and &lt;code&gt;expected&lt;/code&gt; are empty, assigns from &lt;code&gt;desired&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;, and orders memory according to &lt;code&gt;success&lt;/code&gt;, otherwise assigns from the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;expected&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;, and orders memory according to &lt;code&gt;failure&lt;/code&gt;. The behavior is undefined if &lt;code&gt;failure&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;. On success, the operation is an atomic read-modify-write operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is not accessed after the atomic update. On failure, the operation is an atomic load operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is updated with the existing value read from the atomic object. This update to &lt;code&gt;expected&lt;/code&gt;'s use_count is part of this atomic operation, although the write itself (and any subsequent deallocation/destruction) is not required to be.</source>
          <target state="translated">1）如果底层 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 存储作为同一指针值 &lt;code&gt;expected&lt;/code&gt; 和股它的所有权，或如果两个底层和 &lt;code&gt;expected&lt;/code&gt; 是空的，受让人从 &lt;code&gt;desired&lt;/code&gt; 对底层 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ，然后根据 &lt;code&gt;success&lt;/code&gt; 排序内存，否则从底层 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 分配给 &lt;code&gt;expected&lt;/code&gt; ，返回 &lt;code&gt;false&lt;/code&gt; ，并根据 &lt;code&gt;failure&lt;/code&gt; 排序内存。如果 &lt;code&gt;failure&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 或，则行为未定义 &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; 。如果成功，操作上原子的读-修改-写操作 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;expected&lt;/code&gt; 的原子更新之后，不会访问。失败时，该操作是对 &lt;code&gt;*this&lt;/code&gt; 的原子加载操作，并且 &lt;code&gt;expected&lt;/code&gt; 会使用从原子对象读取的现有值进行更新。尽管不需要写入本身（以及任何后续的释放/销毁），但对 &lt;code&gt;expected&lt;/code&gt; 的use_count的此更新是此原子操作的一部分。</target>
        </trans-unit>
        <trans-unit id="e34721beb2d7e5dc88963d3e677eec93a6ef94e9" translate="yes" xml:space="preserve">
          <source>1) If there are &lt;code&gt;M&lt;/code&gt; arguments, the candidate function that has exactly &lt;code&gt;M&lt;/code&gt; parameters is viable</source>
          <target state="translated">1）如果有 &lt;code&gt;M&lt;/code&gt; 个参数，则恰好具有 &lt;code&gt;M&lt;/code&gt; 个参数的候选函数是可行的</target>
        </trans-unit>
        <trans-unit id="ec64a20a9d24c39e596bf41c76e737d99a86058d" translate="yes" xml:space="preserve">
          <source>1) If there is an &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion sequence&lt;/a&gt; from expression to new_type, or if overload resolution for a &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; of an object or reference of type new_type from expression would find at least one viable function, then &lt;code&gt;static_cast&amp;lt;new_type&amp;gt;(expression)&lt;/code&gt; returns the imaginary variable &lt;code&gt;Temp&lt;/code&gt; initialized as if by &lt;code&gt;new_type Temp(expression);&lt;/code&gt;, which may involve &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt;, a call to the &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; of new_type or a call to a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion operator&lt;/a&gt;. For non-reference new_type, the result object of the static_cast prvalue expression is what's direct-initialized(since C++17)</source>
          <target state="translated">1）如果存在从表达式到new_type 的&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换序列&lt;/a&gt;，或者&lt;a href=&quot;direct_initialization&quot;&gt;直接表达式&lt;/a&gt;的对象或引用类型为new_type的引用的重载解析将找到至少一个可行的函数，则 &lt;code&gt;static_cast&amp;lt;new_type&amp;gt;(expression)&lt;/code&gt; 返回虚变量 &lt;code&gt;Temp&lt;/code&gt; 好像由 &lt;code&gt;new_type Temp(expression);&lt;/code&gt; 初始化；，可能涉及&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt;，对new_type 的&lt;a href=&quot;constructor&quot;&gt;构造函数&lt;/a&gt;的调用或对&lt;a href=&quot;cast_operator&quot;&gt;用户定义的转换运算符&lt;/a&gt;的调用。对于非引用new_type，static_cast prvalue表达式的结果对象是直接初始化的（自C ++ 17起）</target>
        </trans-unit>
        <trans-unit id="5e61488d7d7b15353ad536c26150cc3f3d9dfc2a" translate="yes" xml:space="preserve">
          <source>1) If two pointers point to different elements of the same array, or to subobjects within different elements of the same array, the pointer to the element with the higher subscript</source>
          <target state="translated">1)如果两个指针指向同一数组的不同元素,或指向同一数组不同元素内的子对象,则指向下标较高的元素的指针为</target>
        </trans-unit>
        <trans-unit id="a1ef97817e3de9be1ea70784e7655c53546a2dc5" translate="yes" xml:space="preserve">
          <source>1) Ignores all elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1）忽略所有等于 &lt;code&gt;value&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="e94af7fe131aa943bb89af9451c2c83b03715052" translate="yes" xml:space="preserve">
          <source>1) Implements &lt;code&gt;operator!=&lt;/code&gt; in terms of &lt;code&gt;operator==&lt;/code&gt;.</source>
          <target state="translated">1）根据 &lt;code&gt;operator==&lt;/code&gt; 实现 &lt;code&gt;operator!=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dab585f3da6ef91bb449ba583df62136d68e6d58" translate="yes" xml:space="preserve">
          <source>1) Implicitly declared default constructor.</source>
          <target state="translated">1)隐式声明的默认构造函数。</target>
        </trans-unit>
        <trans-unit id="5c681d4553e954943a32a867bbdf85235d7bbe9b" translate="yes" xml:space="preserve">
          <source>1) In a member function declaration, &lt;code&gt;final&lt;/code&gt; may appear in virt-specifier-seq immediately after the declarator, and before the &lt;a href=&quot;abstract_class&quot;&gt;pure-specifier&lt;/a&gt;, if used.</source>
          <target state="translated">1）在成员函数声明中，如果使用了 &lt;code&gt;final&lt;/code&gt; ，则final可能会在声明器之后和&lt;a href=&quot;abstract_class&quot;&gt;pure-specifier&lt;/a&gt;之前立即出现在virt-specifier-seq中。</target>
        </trans-unit>
        <trans-unit id="e87713d6a39f4e0ea9a3dfa0acccc59bf85daffe" translate="yes" xml:space="preserve">
          <source>1) In a member function declaration, &lt;code&gt;override&lt;/code&gt; may appear in virt-specifier-seq immediately after the declarator, and before the &lt;a href=&quot;abstract_class&quot;&gt;pure-specifier&lt;/a&gt;, if used.</source>
          <target state="translated">1）在成员函数声明中， &lt;code&gt;override&lt;/code&gt; 可能会在声明者之后，在&lt;a href=&quot;abstract_class&quot;&gt;pure-specifier&lt;/a&gt;之前（如果使用的话）立即出现在virt-specifier-seq中。</target>
        </trans-unit>
        <trans-unit id="b7f2af54ab23b9453df13b695a120657cdbb78f5" translate="yes" xml:space="preserve">
          <source>1) In the &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; of the constructor.</source>
          <target state="translated">1）在构造函数的&lt;a href=&quot;constructor&quot;&gt;成员初始化器列表&lt;/a&gt;中。</target>
        </trans-unit>
        <trans-unit id="ad85e856c86edd9721a76169fb3382fbd0691a1a" translate="yes" xml:space="preserve">
          <source>1) Index-based non-throwing accessor: If &lt;code&gt;pv&lt;/code&gt; is not a null pointer and &lt;code&gt;pv-&amp;gt;index() == I&lt;/code&gt;, returns a pointer to the value stored in the variant pointed to by &lt;code&gt;pv&lt;/code&gt;. Otherwise, returns a null pointer value. The call is ill-formed if &lt;code&gt;I&lt;/code&gt; is not a valid index in the variant.</source>
          <target state="translated">1）基于索引的非抛出访问器：如果 &lt;code&gt;pv&lt;/code&gt; 不是空指针，并且 &lt;code&gt;pv-&amp;gt;index() == I&lt;/code&gt; ，则返回指向存储在 &lt;code&gt;pv&lt;/code&gt; 指向的变量中的值的指针。否则，返回空指针值。如果 &lt;code&gt;I&lt;/code&gt; 不是变体中的有效索引，则调用格式错误。</target>
        </trans-unit>
        <trans-unit id="9aabcbed245a33739cb3035c8ee0b94c11b43add" translate="yes" xml:space="preserve">
          <source>1) Index-based value accessor: If &lt;code&gt;v.index() == I&lt;/code&gt;, returns a reference to the value stored in &lt;code&gt;v&lt;/code&gt;. Otherwise, throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt;. The call is ill-formed if &lt;code&gt;I&lt;/code&gt; is not a valid index in the variant.</source>
          <target state="translated">1）基于索引的值访问器：如果 &lt;code&gt;v.index() == I&lt;/code&gt; ，则返回对 &lt;code&gt;v&lt;/code&gt; 中存储的值的引用。否则，抛出 &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; 。如果 &lt;code&gt;I&lt;/code&gt; 不是变体中的有效索引，则调用格式错误。</target>
        </trans-unit>
        <trans-unit id="af4fb35a5ec3b4df2a4082311967437cd6c9b5db" translate="yes" xml:space="preserve">
          <source>1) Informs a &lt;code&gt;std::basic_string&lt;/code&gt; object of a planned change in size, so that it can manage the storage allocation appropriately.</source>
          <target state="translated">1）向 &lt;code&gt;std::basic_string&lt;/code&gt; 对象通知计划中的大小更改，以便它可以适当地管理存储分配。</target>
        </trans-unit>
        <trans-unit id="c71413d04de99f2d5426060b5049fea7209088cd" translate="yes" xml:space="preserve">
          <source>1) Initializes &lt;code&gt;r_&lt;/code&gt; with &lt;code&gt;nullptr&lt;/code&gt;. A default-initialized &lt;code&gt;ref_view&lt;/code&gt; references no &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1）用 &lt;code&gt;nullptr&lt;/code&gt; 初始化 &lt;code&gt;r_&lt;/code&gt; 。默认初始化的 &lt;code&gt;ref_view&lt;/code&gt; 不引用&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d666e6ac7a857628bc04dc566500208a77dfdfa4" translate="yes" xml:space="preserve">
          <source>1) Initializes the accumulator &lt;code&gt;acc&lt;/code&gt; with the initial value &lt;code&gt;init&lt;/code&gt; and then</source>
          <target state="translated">1）用初始值 &lt;code&gt;init&lt;/code&gt; 初始化累加器 &lt;code&gt;acc&lt;/code&gt; ，然后</target>
        </trans-unit>
        <trans-unit id="390208e5ec0095fd5b6b97b7b3f847fcb7002d96" translate="yes" xml:space="preserve">
          <source>1) Initializes the base or member named by class-or-identifier using &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; or, if expression-list is empty, &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt;</source>
          <target state="translated">1）使用&lt;a href=&quot;direct_initialization&quot;&gt;直接初始化&lt;/a&gt;或使用如果表达式列表为空的&lt;a href=&quot;value_initialization&quot;&gt;值初始化来初始化&lt;/a&gt;由类或标识符命名的基或成员</target>
        </trans-unit>
        <trans-unit id="0738aa8c98109913fcc387730825b9c7aaa58446" translate="yes" xml:space="preserve">
          <source>1) Initializes the contained value by &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializing&lt;/a&gt; (but not direct-list-initializing) with &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; as parameters.</source>
          <target state="translated">1）通过使用 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; &amp;lt;Args&amp;gt;（args）...作为参数&lt;a href=&quot;../../language/direct_initialization&quot;&gt;直接初始化&lt;/a&gt;（而不是直接列表初始化）来初始化包含的值。</target>
        </trans-unit>
        <trans-unit id="55b3a7a556eb22d3fddafb6be7ce6a255efdaa60" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; to default-constructed value</source>
          <target state="translated">1）将基础的 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 初始化为默认构造的值</target>
        </trans-unit>
        <trans-unit id="56d3077b0b0cef44db878906aa8a6c39943f7a5f" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying &lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; to default-constructed value</source>
          <target state="translated">1）将基础的 &lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; 初始化为默认构造的值</target>
        </trans-unit>
        <trans-unit id="4ac80d611dc008ae2fce6aea9e7cf692cd5e7b32" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying pointer to container with &lt;code&gt;nullptr&lt;/code&gt; and value-initializes the underlying iterator.</source>
          <target state="translated">1）使用 &lt;code&gt;nullptr&lt;/code&gt; 初始化指向容器的基础指针，并值初始化基础迭代器。</target>
        </trans-unit>
        <trans-unit id="e37bfcf43e090a94cd623e83017e50e5bca2fc1a" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying pointer to container with &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">1）使用 &lt;code&gt;nullptr&lt;/code&gt; 初始化指向容器的基础指针。</target>
        </trans-unit>
        <trans-unit id="dcd29c5e81afcd584e544f121d5f47dadd0f4de1" translate="yes" xml:space="preserve">
          <source>1) Initializes with streambuf &lt;code&gt;sb&lt;/code&gt;. The base classes are initialized as &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; and &lt;code&gt;basic_ostream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt;. After the call &lt;code&gt;rdbuf() == sb&lt;/code&gt; and &lt;code&gt;gcount() == 0&lt;/code&gt;.</source>
          <target state="translated">1）用streambuf &lt;code&gt;sb&lt;/code&gt; 初始化。基类被初始化为 &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; 和 &lt;code&gt;basic_ostream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; 。调用后 &lt;code&gt;rdbuf() == sb&lt;/code&gt; 和 &lt;code&gt;gcount() == 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="597197c59314c93c55128912be74ee54b394e721" translate="yes" xml:space="preserve">
          <source>1) Inserts &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt; at the position &lt;code&gt;index&lt;/code&gt;</source>
          <target state="translated">1）在位置 &lt;code&gt;index&lt;/code&gt; 处插入字符 &lt;code&gt;ch&lt;/code&gt; 的 &lt;code&gt;count&lt;/code&gt; 副本</target>
        </trans-unit>
        <trans-unit id="2f9e626ebe4226924cf0f29adddd15e2078d9dc6" translate="yes" xml:space="preserve">
          <source>1) Inserts &lt;code&gt;value_type(key, T())&lt;/code&gt; if the key does not exist. This function is equivalent to &lt;code&gt;return insert(&lt;a href=&quot;../../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(key, T())).first-&amp;gt;second;&lt;/code&gt;</source>
          <target state="translated">1）如果键不存在 &lt;code&gt;value_type(key, T())&lt;/code&gt; 插入value_type（key，T（））。此函数等效于 &lt;code&gt;return insert(&lt;a href=&quot;../../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(key, T())).first-&amp;gt;second;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbcdba0d1f411974c0900c76adfb06fb4ddf41c" translate="yes" xml:space="preserve">
          <source>1) Inserts a &lt;code&gt;value_type&lt;/code&gt; object constructed in-place from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; if the key does not exist.  This function is equivalent to &lt;code&gt;return this-&amp;gt;try_emplace(key).first-&amp;gt;second;&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1）插入从 &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; ，&lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std :: forward_as_tuple&lt;/a&gt;（key），&lt;a href=&quot;../../utility/tuple&quot;&gt;std :: tuple&lt;/a&gt; &amp;lt;&amp;gt;（）（如果该键不存在）就地构造的 &lt;code&gt;value_type&lt;/code&gt; 对象。此函数等效于 &lt;code&gt;return this-&amp;gt;try_emplace(key).first-&amp;gt;second;&lt;/code&gt; （自C ++ 17起）</target>
        </trans-unit>
        <trans-unit id="1ed499190167ff7f4a4dca5f353727adf6c5d67d" translate="yes" xml:space="preserve">
          <source>1) Integer formatters: &lt;code&gt;value&lt;/code&gt; is converted to a string of digits in the given &lt;code&gt;base&lt;/code&gt; (with no redundant leading zeroes). Digits in the range &lt;code&gt;10..35&lt;/code&gt; (inclusive) are represented as lowercase characters &lt;code&gt;a..z&lt;/code&gt;. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type &lt;code&gt;char&lt;/code&gt; as the type of the parameter &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1）整数格式器：将 &lt;code&gt;value&lt;/code&gt; 转换为给定 &lt;code&gt;base&lt;/code&gt; 的数字字符串（不带冗余的前导零）。 &lt;code&gt;10..35&lt;/code&gt; （含）范围内的数字表示为小写字母 &lt;code&gt;a..z&lt;/code&gt; 。如果value小于零，则表示形式以减号开头。该库为所有有符号和无符号整数类型提供重载，并为参数 &lt;code&gt;value&lt;/code&gt; 的类型提供 &lt;code&gt;char&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="2cd742de2bf8d435baa1eb1ba04960df29830e0c" translate="yes" xml:space="preserve">
          <source>1) Integer parsers: Expects the pattern identical to the one used by &lt;code&gt;&lt;a href=&quot;../string/byte/strtol&quot;&gt;std::strtol&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale and the given non-zero numeric base, except that</source>
          <target state="translated">1）整数解析器：期望的模式与默认（&amp;ldquo; C&amp;rdquo;）语言环境中 &lt;code&gt;&lt;a href=&quot;../string/byte/strtol&quot;&gt;std::strtol&lt;/a&gt;&lt;/code&gt; 使用的模式相同，并使用给定的非零数字基数，除了</target>
        </trans-unit>
        <trans-unit id="8a213779ff6418b03ee0523325685afdc5d484b9" translate="yes" xml:space="preserve">
          <source>1) It cannot be used anywhere in the program</source>
          <target state="translated">1)不能在程序中的任何地方使用。</target>
        </trans-unit>
        <trans-unit id="52283fc726cca49a55017924c746b83c68a86057" translate="yes" xml:space="preserve">
          <source>1) It must be declared &lt;code&gt;inline&lt;/code&gt; in every translation unit.</source>
          <target state="translated">1）必须在每个翻译单元中 &lt;code&gt;inline&lt;/code&gt; 声明。</target>
        </trans-unit>
        <trans-unit id="93c41523dfecbacf0866640c365002e86309d551" translate="yes" xml:space="preserve">
          <source>1) Iterator to the element following the erased one, or &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; if no such element exists.</source>
          <target state="translated">1）迭代到已删除元素之后的元素，如果不存在此类元素，则返回 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db998b65059f221b9947c1e2b84b7328aa9c6731" translate="yes" xml:space="preserve">
          <source>1) Iterator to the first element of the path.</source>
          <target state="translated">1)迭代器到路径的第一个元素。</target>
        </trans-unit>
        <trans-unit id="5f63d6bacd5c75bb3d9c40afba52d76d0aa26b7a" translate="yes" xml:space="preserve">
          <source>1) Linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">1）线性 &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bad57cdbf49ee5c9cf8b15794f0ba25ea25faaf6" translate="yes" xml:space="preserve">
          <source>1) Linear in the number of characters compared.</source>
          <target state="translated">1)比较字数的线性。</target>
        </trans-unit>
        <trans-unit id="bfbdf175b676848b3b112f3b7622116e7ae24018" translate="yes" xml:space="preserve">
          <source>1) Linear in the size of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 的大小是线性的。</target>
        </trans-unit>
        <trans-unit id="ae3d9bc82a6c5df2515038c2bc04f8922fb3612d" translate="yes" xml:space="preserve">
          <source>1) Linear in the size of &lt;code&gt;other&lt;/code&gt;</source>
          <target state="translated">1） &lt;code&gt;other&lt;/code&gt; 尺寸线性</target>
        </trans-unit>
        <trans-unit id="b7138a1f54274e2bc82a87855f742eb60f4fcddc" translate="yes" xml:space="preserve">
          <source>1) Literal operators with this parameter list are the</source>
          <target state="translated">1)带有这个参数列表的字面运算符为</target>
        </trans-unit>
        <trans-unit id="d4f26c9f8811c2aa27521ffafb650efe7f636432" translate="yes" xml:space="preserve">
          <source>1) Literals (e.g. &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;&quot;Hello, world&quot;&lt;/code&gt;)</source>
          <target state="translated">1）文字（例如 &lt;code&gt;2&lt;/code&gt; 或 &lt;code&gt;&quot;Hello, world&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="692f0144de0296503caf6eb540cde981dab090e2" translate="yes" xml:space="preserve">
          <source>1) Logical AND (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;). The value for the empty pack is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1）逻辑与（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ）。空包装的值是 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be220faf928704a940a2cf9ed4835d69e6844ef4" translate="yes" xml:space="preserve">
          <source>1) Logical NOT</source>
          <target state="translated">1)逻辑上的NOT</target>
        </trans-unit>
        <trans-unit id="dad928c0d3430b473633cea25234a47b689119c3" translate="yes" xml:space="preserve">
          <source>1) Manages a single object (e.g. allocated with &lt;code&gt;new&lt;/code&gt;)</source>
          <target state="translated">1）管理一个对象（例如，分配有 &lt;code&gt;new&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="c2dafa4c13c344cdd5b36d49ab1c8f9cb1618f3e" translate="yes" xml:space="preserve">
          <source>1) May throw &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; if the thread has no privilege to create a condition variable, &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; if a non-memory resource limitation prevents this initialization, or another implementation-defined value.</source>
          <target state="translated">1）如果线程没有创建条件变量的特权，则可能抛出 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 等于 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; std :: system_error，如果非内存资源限制阻止了此操作，则可能抛出std :: &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; 初始化或其他实现定义的值。</target>
        </trans-unit>
        <trans-unit id="e0f5008a342755f8d0c7df43b3ab66846dd152a1" translate="yes" xml:space="preserve">
          <source>1) May throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; in case of failure, if &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt; ，则在 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 的情况下可能引发std :: ios_base :: failure。</target>
        </trans-unit>
        <trans-unit id="fec14884289d124fcea9cdbca0e3487bb3fefeab" translate="yes" xml:space="preserve">
          <source>1) May throw any exception thrown by the value initialization of the first alternative.</source>
          <target state="translated">1)可以抛出第一个备选值初始化所抛出的任何异常。</target>
        </trans-unit>
        <trans-unit id="6d9856c647bd6f18f2c4199f99dda0d7103b839f" translate="yes" xml:space="preserve">
          <source>1) Member declarations of the form</source>
          <target state="translated">1)会员申报的形式</target>
        </trans-unit>
        <trans-unit id="f54b805bef5f1481100f7bcad5d8d8c57550f520" translate="yes" xml:space="preserve">
          <source>1) Minimum offset between two objects to avoid false sharing. Guaranteed to be at least &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1）两个对象之间的最小偏移，以避免错误共享。保证至少是 &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc024f12038108f0c21d9b9bb7028dab37fcc8fc" translate="yes" xml:space="preserve">
          <source>1) Modifies the &lt;code&gt;&lt;a href=&quot;timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;ts&lt;/code&gt; to hold the current calendar time in the time base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">1）修改 &lt;code&gt;ts&lt;/code&gt; 指向的 &lt;code&gt;&lt;a href=&quot;timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt; 对象，以将当前日历时间保存在时 &lt;code&gt;base&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="019c13e7183a754e9d764c5fd9f436c7e5d5c9dd" translate="yes" xml:space="preserve">
          <source>1) Modifying the character array accessed through the const overload of &lt;code&gt;data&lt;/code&gt; has undefined behavior.</source>
          <target state="translated">1）修改通过 &lt;code&gt;data&lt;/code&gt; 的const重载访问的字符数组具有未定义的行为。</target>
        </trans-unit>
        <trans-unit id="32267b5e71f7ec1d742dce72b339a8c92ce8f8bc" translate="yes" xml:space="preserve">
          <source>1) Move assignment operator. First, abandons the shared state (as in &lt;code&gt;~promise()&lt;/code&gt;), then assigns the shared state of &lt;code&gt;other&lt;/code&gt; as if by executing &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;(std::move(other)).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1）移动分配运算符。首先，放弃共享状态（如 &lt;code&gt;~promise()&lt;/code&gt; ），然后通过执行 &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;(std::move(other)).swap(*this)&lt;/code&gt; （std :: move（other））。swap（* this）来分配 &lt;code&gt;other&lt;/code&gt; 共享状态。</target>
        </trans-unit>
        <trans-unit id="87be123334c79f86e66db927b0f1e69d4152ff3f" translate="yes" xml:space="preserve">
          <source>1) Move assignment operator: Moves the contents of &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. After the move, &lt;code&gt;*this&lt;/code&gt; has the associated string, the open mode, the locale, and all other state formerly held by &lt;code&gt;rhs&lt;/code&gt;. The six pointers of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;*this&lt;/code&gt; are guaranteed to be different from the corresponding pointers in the moved-from &lt;code&gt;rhs&lt;/code&gt; unless null.</source>
          <target state="translated">1）移动赋值运算符：将 &lt;code&gt;rhs&lt;/code&gt; 的内容移动到 &lt;code&gt;*this&lt;/code&gt; 。移动之后， &lt;code&gt;*this&lt;/code&gt; 具有关联的字符串，打开模式，语言环境以及以前由 &lt;code&gt;rhs&lt;/code&gt; 保持的所有其他状态。六大指针 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 在 &lt;code&gt;*this&lt;/code&gt; 保证是从移动，从相应的指针不同 &lt;code&gt;rhs&lt;/code&gt; ，除非空。</target>
        </trans-unit>
        <trans-unit id="7d6353cf0852cf732b2e80b3c54029fc7ed0252d" translate="yes" xml:space="preserve">
          <source>1) Moves &lt;code&gt;count&lt;/code&gt; elements from a range beginning at &lt;code&gt;first&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1）移至 &lt;code&gt;count&lt;/code&gt; 从一系列元素开始在 &lt;code&gt;first&lt;/code&gt; 到未初始化的存储器区域在开始 &lt;code&gt;d_first&lt;/code&gt; 仿佛由</target>
        </trans-unit>
        <trans-unit id="baeda8b2207e79e0e28d467dccba16a337675b05" translate="yes" xml:space="preserve">
          <source>1) Moves all elements from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The elements are inserted after the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The behavior is undefined if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1）将所有 &lt;code&gt;other&lt;/code&gt; 元素移到 &lt;code&gt;*this&lt;/code&gt; 。将这些元素插入到 &lt;code&gt;pos&lt;/code&gt; 指向的元素之后。操作后， &lt;code&gt;other&lt;/code&gt; 容器变空。如果 &lt;code&gt;other&lt;/code&gt; 指向与 &lt;code&gt;*this&lt;/code&gt; 相同的对象，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="cbee85f489bfd5c711863ceb3ce35d639917da93" translate="yes" xml:space="preserve">
          <source>1) Moves elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1）从范围移至元素 &lt;code&gt;[first, last)&lt;/code&gt; 到一个未初始化的存储器区域在开始 &lt;code&gt;d_first&lt;/code&gt; 仿佛由</target>
        </trans-unit>
        <trans-unit id="a02bfb3935e9c4bd8c50e3ceaa51a1ac20773de1" translate="yes" xml:space="preserve">
          <source>1) Moves the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range beginning at &lt;code&gt;d_first&lt;/code&gt;, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.</source>
          <target state="translated">1）将 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的元素移动到 &lt;code&gt;d_first&lt;/code&gt; 开始的另一个范围，从first开始并持续到last-1。执行此操作后，move -from范围内的元素仍将包含相应的有效值类型，但不一定与移动之前的值相同。</target>
        </trans-unit>
        <trans-unit id="3e96eedb6a4729d6cd532f90b4c42d7009c20ae6" translate="yes" xml:space="preserve">
          <source>1) Names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope (which is also the scope of statement).</source>
          <target state="translated">1)init-statement声明的名称(如果init-statement是声明)和condition声明的名称(如果condition是声明)在同一个范围内(也就是声明的范围)。</target>
        </trans-unit>
        <trans-unit id="29f0125e541e7b6cb76f5dbbc2fb2c46cdd5ba5f" translate="yes" xml:space="preserve">
          <source>1) Narrow multibyte string literal. The type of an unprefixed string literal is &lt;code&gt;const char[N]&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the size of the string in code units of the execution narrow encoding, including the null terminator.</source>
          <target state="translated">1）窄多字节字符串文字。无前缀字符串文字的类型为 &lt;code&gt;const char[N]&lt;/code&gt; ，其中 &lt;code&gt;N&lt;/code&gt; 是执行窄编码的代码单元（包括空终止符）中字符串的大小。</target>
        </trans-unit>
        <trans-unit id="d4f47d080da433e4df7de35bc1790426bc94e157" translate="yes" xml:space="preserve">
          <source>1) Non-throwing dynamic exception specification</source>
          <target state="translated">1)不抛出动态异常规范</target>
        </trans-unit>
        <trans-unit id="6a6a9ceef837057cbc352d5ec70b0fd0f2b2c8bd" translate="yes" xml:space="preserve">
          <source>1) Number of elements with key &lt;code&gt;key&lt;/code&gt;, that is either 1 or 0.</source>
          <target state="translated">1）带有key &lt;code&gt;key&lt;/code&gt; 的元素数，即1或0。</target>
        </trans-unit>
        <trans-unit id="1564a87a6e67740b705461f9434aea174e148c19" translate="yes" xml:space="preserve">
          <source>1) Number of elements with key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1）与主要元素的数量 &lt;code&gt;key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3517215f133f6ebfae6482995743c32e01ac79c9" translate="yes" xml:space="preserve">
          <source>1) Obtains the actual address of the object or function &lt;code&gt;arg&lt;/code&gt;, even in presence of overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt;</source>
          <target state="translated">1）即使存在重载的 &lt;code&gt;operator&amp;amp;&lt;/code&gt; ，也 &lt;code&gt;arg&lt;/code&gt; 对象或函数arg的实际地址</target>
        </trans-unit>
        <trans-unit id="63c030571149d7aea7d192bb60285199d1752b0e" translate="yes" xml:space="preserve">
          <source>1) Often known as &quot;C-style&quot; or &quot;multi-line&quot; comments.</source>
          <target state="translated">1)常被称为 &quot;C式 &quot;或 &quot;多行 &quot;注释。</target>
        </trans-unit>
        <trans-unit id="842c5f199cfee8d76155c07d299c1fe9ce02bab8" translate="yes" xml:space="preserve">
          <source>1) Parses the date and time from the input character sequence &lt;code&gt;[beg, end)&lt;/code&gt; according to the format provided in the character sequence &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt;. The format is expected to follow the format described below, although actual processing of each format specifier can be customized by overriding &lt;code&gt;do_get&lt;/code&gt;. The &lt;code&gt;get&lt;/code&gt; function performs the following: First, clears the error bits in &lt;code&gt;err&lt;/code&gt; by executing &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt;. Then enters a loop, which terminates whenever any of the following conditions becomes true (checked in this order):</source>
          <target state="translated">1）根据字符序列 &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; 提供的格式 &lt;code&gt;[beg, end)&lt;/code&gt; 从输入字符序列[beg，end）解析日期和时间。尽管可以通过覆盖 &lt;code&gt;do_get&lt;/code&gt; 来定制每个格式说明符的实际处理，但是该格式应遵循以下描述的格式。在 &lt;code&gt;get&lt;/code&gt; 函数执行以下操作：首先，将清除错误位 &lt;code&gt;err&lt;/code&gt; 通过执行 &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;标准::的ios_base :: goodbit&lt;/a&gt;。然后进入一个循环，只要满足以下任一条件（按此顺序检查），该循环便终止：</target>
        </trans-unit>
        <trans-unit id="4251fa4ac37443b00ba495f01dec70943d49534e" translate="yes" xml:space="preserve">
          <source>1) Performs &lt;code&gt;*this = *this + d;&lt;/code&gt;</source>
          <target state="translated">1）执行 &lt;code&gt;*this = *this + d;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06459854688602a24bce5db298f1ff763c820069" translate="yes" xml:space="preserve">
          <source>1) Performs &lt;code&gt;*this = *this + m;&lt;/code&gt;</source>
          <target state="translated">1）执行 &lt;code&gt;*this = *this + m;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65fb962cbf281356d7871dec0c276ca503ae02f5" translate="yes" xml:space="preserve">
          <source>1) Performs a left rotation on a range of elements.</source>
          <target state="translated">1)对元素的范围进行左旋。</target>
        </trans-unit>
        <trans-unit id="24157bdc426e8751a205fa626eea64b65972c149" translate="yes" xml:space="preserve">
          <source>1) Performs atomic addition. Equivalent to &lt;code&gt;fetch_add(arg)&lt;/code&gt; + arg.</source>
          <target state="translated">1）执行原子加法。等效于 &lt;code&gt;fetch_add(arg)&lt;/code&gt; + arg。</target>
        </trans-unit>
        <trans-unit id="b7b35043c329a05e326ecc4ac09efa80c7ee56f7" translate="yes" xml:space="preserve">
          <source>1) Performs atomic addition. Equivalent to &lt;code&gt;return fetch_add(arg) + arg;&lt;/code&gt;.</source>
          <target state="translated">1）执行原子加法。等效于 &lt;code&gt;return fetch_add(arg) + arg;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0419ff58b80e0ea3e34dbe1120d304b2154ccd33" translate="yes" xml:space="preserve">
          <source>1) Performs atomic pre-increment. Equivalent to &lt;code&gt;fetch_add(1)+1&lt;/code&gt;.</source>
          <target state="translated">1）执行原子预递增。等效于 &lt;code&gt;fetch_add(1)+1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d7cb0da243e1e814c426ca15e77bf948db18b30" translate="yes" xml:space="preserve">
          <source>1) Performs atomic pre-increment. Equivalent to &lt;code&gt;return fetch_add(1) + 1;&lt;/code&gt;.</source>
          <target state="translated">1）执行原子预递增。等效于 &lt;code&gt;return fetch_add(1) + 1;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8165604074e09874cc008cd54a9677022761ce36" translate="yes" xml:space="preserve">
          <source>1) Pre-increment. Returns the updated iterator.</source>
          <target state="translated">1)预增。返回更新后的迭代器。</target>
        </trans-unit>
        <trans-unit id="98b2b73f529f9a9c81704e2afa46fe127b827d7f" translate="yes" xml:space="preserve">
          <source>1) Previous associated locale.</source>
          <target state="translated">1)以前的关联地域。</target>
        </trans-unit>
        <trans-unit id="90eaf4a181c70f4e6dd5dad828ce93c49a0f00b7" translate="yes" xml:space="preserve">
          <source>1) Primary template is an empty struct.</source>
          <target state="translated">1)主模板是一个空结构。</target>
        </trans-unit>
        <trans-unit id="d3b8bab61ba0a04eca35d2c18428e6aaa3ccf10f" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_always_noconv&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_always_noconv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="baf1382568df4bb859c2f19d25f5fa51f0d6c8b6" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_curr_symbol&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_curr_symbol&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8803148252b377ffcd4da972f99e35584fa057b1" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_decimal_point&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_decimal_point&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f5e8bfa91bd146e3eb1c442796dcc622fd2cb53" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_frac_digits&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_frac_digits&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd263bbd005fdfda08890b70706b6c4d80e469da" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_get&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_get&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ea4e6b7dcb9f599bddec78e09271c36d3302c0e" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_grouping&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_grouping&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f1cefcfa79a30f86558cc5d92aa1f12547b1071" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_in&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_in&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="caad5ee2da96131cd137488a3b8e49826497e05d" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_max_length&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_max_length&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c42e6d12a6460383165ecd093240a382422e7a50" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_pos_format&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_pos_format&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc5bc70d6c3c7d1b63e978e2bb5f510449787adf" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_positive_sign&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_positive_sign&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a7fb6649c9c1933430d44d28c9be6af80e73282" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_thousands_sep&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_thousands_sep&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a05a1a4712a55bd65ed1b7c2d0c6498741ebcfac" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_compare&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_compare&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50240ff8cfc5297f7dea433cf9aa0e95cbb740bd" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_date_order&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_date_order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc988aac8e2069c8157a164371668baa84732662" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_get&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_get&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3956434b335523e445a7f66b881b7d9081d9286" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_get_date()&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_get_date()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aa8c3a179dd224f964496fd3cf87120527402883" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_hash&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_hash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5b1e143ebb344d5c93a9cd3e3d5c1234ffeed9a" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_open&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_open&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3021e1c4d5e1cb04a9c13b29e49851c5fc32a48" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_put&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_put&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02f297d72b24e5ec0b50eab50682c4aeb7a9ac16" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_transform&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_transform&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8792ca5b24450313548e3eafb8702266f2eb881c" translate="yes" xml:space="preserve">
          <source>1) Reads one character and returns it if available. Otherwise, returns &lt;code&gt;Traits::eof()&lt;/code&gt; and sets &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;failbit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;eofbit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1）读取一个字符并返回（如果有）。否则，返回 &lt;code&gt;Traits::eof()&lt;/code&gt; 并设置 &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;failbit&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;eofbit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b24556d7aac836f48afb6674f5c717012f92f983" translate="yes" xml:space="preserve">
          <source>1) Reads the data from &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1）从 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 读取数据</target>
        </trans-unit>
        <trans-unit id="7396d1f8b950a76b6370b58eb711a32d6d49c388" translate="yes" xml:space="preserve">
          <source>1) Reads the data from &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1）从 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; 读取数据。</target>
        </trans-unit>
        <trans-unit id="6a217932442a1d0a2f62a838e385afc124dbe4bd" translate="yes" xml:space="preserve">
          <source>1) Refers to a &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object representing the type type. If type is a reference type, the result refers to a &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object representing the referenced type.</source>
          <target state="translated">1）引用代表类型类型的 &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 对象。如果type是引用类型，则结果引用表示引用类型的 &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="861842b860dc887a6543ee6224b6ce48a8a61aa1" translate="yes" xml:space="preserve">
          <source>1) Regular function declarator syntax</source>
          <target state="translated">1)常规函数声明器语法</target>
        </trans-unit>
        <trans-unit id="6cbbb4ec5d9adc038750b690542f0bc0dae8623a" translate="yes" xml:space="preserve">
          <source>1) Releases any shared state and assigns the contents of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. After the assignment, &lt;code&gt;this-&amp;gt;valid() == other.valid()&lt;/code&gt;.</source>
          <target state="translated">1）释放任何共享状态，并将 &lt;code&gt;other&lt;/code&gt; 的内容分配给 &lt;code&gt;*this&lt;/code&gt; 。分配后， &lt;code&gt;this-&amp;gt;valid() == other.valid()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38bb6282680f52e2fda17aa9983f1073eb7c0c47" translate="yes" xml:space="preserve">
          <source>1) Releases any shared state and move-assigns the contents of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. After the assignment, &lt;code&gt;other.valid() == false&lt;/code&gt; and &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;this-&amp;gt;valid()&lt;/code&gt;&lt;/a&gt; will yield the same value as &lt;code&gt;other.valid()&lt;/code&gt; before the assignment.</source>
          <target state="translated">1）释放任何共享状态，并将 &lt;code&gt;other&lt;/code&gt; 的内容分配给 &lt;code&gt;*this&lt;/code&gt; 。分配后， &lt;code&gt;other.valid() == false&lt;/code&gt; 并且&lt;a href=&quot;valid&quot;&gt; &lt;code&gt;this-&amp;gt;valid()&lt;/code&gt; &lt;/a&gt;将产生与分配前的 &lt;code&gt;other.valid()&lt;/code&gt; 相同的值。</target>
        </trans-unit>
        <trans-unit id="b5b667ade567f1b29b3c27fd07f95ac68433c004" translate="yes" xml:space="preserve">
          <source>1) Releases the ownership of the managed object, if any. After the call, &lt;code&gt;*this&lt;/code&gt; manages no object. Equivalent to &lt;code&gt;shared_ptr().swap(*this);&lt;/code&gt;</source>
          <target state="translated">1）释放托管对象的所有权（如果有）。通话后， &lt;code&gt;*this&lt;/code&gt; 管理任何对象。等效于 &lt;code&gt;shared_ptr().swap(*this);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="058dae359c875bb8aea961ac9a8c89d60ef65185" translate="yes" xml:space="preserve">
          <source>1) Removes</source>
          <target state="translated">1)删除</target>
        </trans-unit>
        <trans-unit id="8c4e68b9d2c4305008d048fc061e3772b5809315" translate="yes" xml:space="preserve">
          <source>1) Removes all elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1）删除所有等于 &lt;code&gt;value&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="869efa782ed2427565d277c2e6014424441dd053" translate="yes" xml:space="preserve">
          <source>1) Removes the element at &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1）删除 &lt;code&gt;pos&lt;/code&gt; 处的元素。</target>
        </trans-unit>
        <trans-unit id="ffec9f7979d764e0359835e77f17747b23d8b2dd" translate="yes" xml:space="preserve">
          <source>1) Removes the element following &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1）删除 &lt;code&gt;pos&lt;/code&gt; 之后的元素。</target>
        </trans-unit>
        <trans-unit id="17ef257965eb0ab3b49b26ba1ea702b626c6aa3f" translate="yes" xml:space="preserve">
          <source>1) Reorders the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in such a way that all elements for which the predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; precede the elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. Relative order of the elements is not preserved.</source>
          <target state="translated">1）重新排序的元素中的范围内 &lt;code&gt;[first, last)&lt;/code&gt; 以这样的方式，所有的元素的量，谓词 &lt;code&gt;p&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 上一页为其谓词的元素 &lt;code&gt;p&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。不保留元素的相对顺序。</target>
        </trans-unit>
        <trans-unit id="adce2245dd094ab71b482b217c791cf528174e3e" translate="yes" xml:space="preserve">
          <source>1) Reorders the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in such a way that all elements for which the predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; precede the elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. Relative order of the elements is preserved.</source>
          <target state="translated">1）重新排序的元素中的范围内 &lt;code&gt;[first, last)&lt;/code&gt; 以这样的方式，所有的元素的量，谓词 &lt;code&gt;p&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 上一页为其谓词的元素 &lt;code&gt;p&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。保留元素的相对顺序。</target>
        </trans-unit>
        <trans-unit id="2dac5da3d02f4d437123f2a0b9d56eb2e4fd0857" translate="yes" xml:space="preserve">
          <source>1) Replaces all elements that are equal to &lt;code&gt;old_value&lt;/code&gt;.</source>
          <target state="translated">1）替换所有等于 &lt;code&gt;old_value&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="2e3318a609e82a644898d7222b1da6b96eacbe12" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents of &lt;code&gt;*this&lt;/code&gt; with a pathname whose both native and generic format representations equal those of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">1）用本地和通用格式表示都等于 &lt;code&gt;p&lt;/code&gt; 的路径名替换 &lt;code&gt;*this&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="e240befa148e0203cedd59eee5956df5acad945f" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="translated">1）用字符 &lt;code&gt;ch&lt;/code&gt; 的 &lt;code&gt;count&lt;/code&gt; 副本替换内容。</target>
        </trans-unit>
        <trans-unit id="a6b05f959c13293d5a5d5af2a8637f634e41da89" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with &lt;code&gt;count&lt;/code&gt; copies of value &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">1）用值 &lt;code&gt;value&lt;/code&gt; 的 &lt;code&gt;count&lt;/code&gt; 副本替换内容</target>
        </trans-unit>
        <trans-unit id="29d8d55620552a2c6832d320259ce67308463212" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with a copy of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; are the same object, this function has no effect.</source>
          <target state="translated">1）用 &lt;code&gt;str&lt;/code&gt; 的副本替换内容。如果 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;str&lt;/code&gt; 是同一对象，则此功能无效。</target>
        </trans-unit>
        <trans-unit id="270b4bf667b635c284aba5086d9e163a6e0904f5" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;container-&amp;gt;push_back(value)&lt;/code&gt;</source>
          <target state="translated">1）结果在 &lt;code&gt;container-&amp;gt;push_back(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40ecaa5e7b5b215ddbaec386d81fbe27a35ad522" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;container-&amp;gt;push_front(value)&lt;/code&gt;</source>
          <target state="translated">1）结果在 &lt;code&gt;container-&amp;gt;push_front(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8712ae4fa015816336c007fe3a9a6dcf1cb77223" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;iter = container-&amp;gt;insert(iter, value); ++iter;&lt;/code&gt;</source>
          <target state="translated">1）结果为 &lt;code&gt;iter = container-&amp;gt;insert(iter, value); ++iter;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65e2795a9414bee5546a758244d76abfed9cefbf" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;*lhs.resource() == *rhs.resource()&lt;/code&gt;</source>
          <target state="translated">1）返回 &lt;code&gt;*lhs.resource() == *rhs.resource()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2502d83ce08382fe677e2911a3d1cccaddcc99f3" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;*this&lt;/code&gt; converted to &lt;a href=&quot;../path&quot;&gt;normal form&lt;/a&gt; in its generic format</source>
          <target state="translated">1）返回 &lt;code&gt;*this&lt;/code&gt; 转换为&lt;a href=&quot;../path&quot;&gt;正常形式&lt;/a&gt;在它的一般格式</target>
        </trans-unit>
        <trans-unit id="3a923a689d5fab3840318f3d549827b3318bcbf5" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;iter&lt;/code&gt; unchanged</source>
          <target state="translated">1）返回 &lt;code&gt;iter&lt;/code&gt; 不变</target>
        </trans-unit>
        <trans-unit id="b92bef1e9a732e0b29effd33edcabf38014c435d" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;relative(p, current_path(), ec)&lt;/code&gt;</source>
          <target state="translated">1）返回 &lt;code&gt;relative(p, current_path(), ec)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5de64d91bbdbee0c01c0e8e9cb2b99b1df930700" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1）返回 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a484b37cffb98b770d8354adcf0625dcd7c1759e" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are both end-of-sequence iterators, or if all of the following conditions are true:</source>
          <target state="translated">1）返回 &lt;code&gt;true&lt;/code&gt; ，如果 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 是结束序列的两个迭代器，或者如果所有的以下条件，则：</target>
        </trans-unit>
        <trans-unit id="56de7954cc2d00b655ce1ec3c457bb6134e5cbf3" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1）如果 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 相等，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c94da87dbdee081478fa1d7dee357f47bd78ed41" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">1）返回 &lt;code&gt;true&lt;/code&gt; ，如果 &lt;code&gt;lhs&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="7fac7f5450d225457e6b78589c98f2513f4014ce" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; that satisfy the predicate &lt;code&gt;p&lt;/code&gt; appear before all elements that don't. Also returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;[first, last)&lt;/code&gt; is empty.</source>
          <target state="translated">1）如果满足条件 &lt;code&gt;p&lt;/code&gt; 的 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的所有元素都出现在所有不满足条件的元素之前，则返回 &lt;code&gt;true&lt;/code&gt; 。如果 &lt;code&gt;[first, last)&lt;/code&gt; 为空，也返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2aba12f91ced7a05bef1178e9c4fd5864add3fd6" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if lhs is less than rhs, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1）如果lhs小于rhs，则返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a60b75738d79d6ba929ed47e4bcd56cf5f07f4d" translate="yes" xml:space="preserve">
          <source>1) Returns a &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; containing the result of binary AND on corresponding pairs of bits of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">1）返回一个 &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; 其中包含在 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 的相应位对上的二进制与结果。</target>
        </trans-unit>
        <trans-unit id="e56d712102c4d0fe2dae24e3b57a4a8cfd5aa505" translate="yes" xml:space="preserve">
          <source>1) Returns a copy of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1）返回 &lt;code&gt;*this&lt;/code&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="ca096d06281ae150d54482a6cc1e549ce108c224" translate="yes" xml:space="preserve">
          <source>1) Returns a copy of the underlying string as if by calling &lt;code&gt;rdbuf()-&amp;gt;str()&lt;/code&gt;.</source>
          <target state="translated">1）返回基础字符串的副本，就像通过调用 &lt;code&gt;rdbuf()-&amp;gt;str()&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="a1c616be8d7e9418723ddfcbc3e52606258ec3df" translate="yes" xml:space="preserve">
          <source>1) Returns a null pointer if &lt;code&gt;fail()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, otherwise returns a non-null pointer. This pointer is implicitly convertible to &lt;code&gt;bool&lt;/code&gt; and may be used in boolean contexts.</source>
          <target state="translated">1）如果 &lt;code&gt;fail()&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，则返回空指针，否则返回非空指针。该指针可以隐式转换为 &lt;code&gt;bool&lt;/code&gt; ,并且可以在布尔上下文中使用。</target>
        </trans-unit>
        <trans-unit id="c2284f1e367243c98935f80fc109c83a94a54f3c" translate="yes" xml:space="preserve">
          <source>1) Returns a numeric array of &lt;code&gt;bool&lt;/code&gt; containing elements each of which is obtained by applying the indicated comparison operator to the corresponding values of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">1）返回 &lt;code&gt;bool&lt;/code&gt; 的数字数组，其中包含元素，每个元素都是通过将指示的比较运算符应用于 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 的相应值而获得的</target>
        </trans-unit>
        <trans-unit id="3100a3df15f07b6e5ef0d2e827ee2f7cdbf6175d" translate="yes" xml:space="preserve">
          <source>1) Returns a pointer to the contained value.</source>
          <target state="translated">1)返回一个指向包含值的指针。</target>
        </trans-unit>
        <trans-unit id="0d2c31549336b964b7be2eb179a144f92cc116bc" translate="yes" xml:space="preserve">
          <source>1) Returns a possibly const-qualified iterator to the reverse-beginning of the container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">1）返回一个可能为const限定的迭代器，以反向容器 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a063c1b9ad5e32ce34dcdfd8ca4b82cf3c236ca" translate="yes" xml:space="preserve">
          <source>1) Returns a possibly const-qualified iterator to the reverse-end of the container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">1）返回一个可能为const限定的迭代器到容器 &lt;code&gt;c&lt;/code&gt; 的后端。</target>
        </trans-unit>
        <trans-unit id="13631d6a37bc7ed73ea92514ab164c6764fc704e" translate="yes" xml:space="preserve">
          <source>1) Returns a reference to the current &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1）返回对当前 &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="f3b6280f71abf114f54373c3e7590153910cd5d6" translate="yes" xml:space="preserve">
          <source>1) Returns a reference to the global &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; singleton. If this is the first access to the database, initialize the database. After the initialization, the database will hold a single initialized &lt;code&gt;std::chrono::tzdb&lt;/code&gt; object. This function is thread-safe: concurrent calls to this function from multiple threads do not introduce a data race.</source>
          <target state="translated">1）返回对全局 &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; 单例的引用。如果这是对数据库的首次访问，请初始化数据库。初始化后，数据库将保存单个已初始化 &lt;code&gt;std::chrono::tzdb&lt;/code&gt; 对象。该函数是线程安全的：从多个线程并发调用此函数不会引入数据竞争。</target>
        </trans-unit>
        <trans-unit id="a81e180b9a39b86ed42f18915e1912a4b70010f8" translate="yes" xml:space="preserve">
          <source>1) Returns an implementation-defined type that holds a reference to &lt;code&gt;*this&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; is &lt;a href=&quot;auto_ptr&quot;&gt;convertible&lt;/a&gt; and &lt;a href=&quot;operator=&quot;&gt;assignable&lt;/a&gt; from this template. The implementation is allowed to provide the template with a different name or implement equivalent functionality in other ways.</source>
          <target state="translated">1）返回实现定义的类型，该类型保留对 &lt;code&gt;*this&lt;/code&gt; 的引用。 &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; 是&lt;a href=&quot;auto_ptr&quot;&gt;转换&lt;/a&gt;和&lt;a href=&quot;operator=&quot;&gt;分配&lt;/a&gt;，从这个模板。允许实现为模板提供不同的名称或以其他方式实现等效功能。</target>
        </trans-unit>
        <trans-unit id="1ed78a0dd559758ebfb9c2949e5a988bace3ce62" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator pointing to the first element that is</source>
          <target state="translated">1)返回一个指向第一个元素的迭代器,这个元素就是</target>
        </trans-unit>
        <trans-unit id="6844338cdc96e911c46728c0c867f432dd1a50ec" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first character of the view. Equivalent to &lt;code&gt;sv.begin()&lt;/code&gt;.</source>
          <target state="translated">1）将迭代器返回到视图的第一个字符。相当于 &lt;code&gt;sv.begin()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6cd397aaa829398a2797783162cadf8568d17dba" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first element of the path. If the path is empty, the returned iterator is equal to &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="translated">1）返回一个迭代器到路径的第一个元素。如果路径为空，则返回的迭代器等于 &lt;code&gt;end()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbc84a634be5255d1d6be17b5b6cfff82d9198c3" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first element of the span. Equivalent to &lt;code&gt;s.begin()&lt;/code&gt;.</source>
          <target state="translated">1）将迭代器返回到范围的第一个元素。等效于 &lt;code&gt;s.begin()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="964e9b36a5abe52ebf725814fc0423c129fbe227" translate="yes" xml:space="preserve">
          <source>1) Returns current maximum load factor.</source>
          <target state="translated">1)返回当前的最大负载系数。</target>
        </trans-unit>
        <trans-unit id="cc6b701735443a9096b6e72058c3c17fa0eb40fd" translate="yes" xml:space="preserve">
          <source>1) Returns exactly &lt;code&gt;c.begin()&lt;/code&gt;, which is typically an iterator to the beginning of the sequence represented by &lt;code&gt;c&lt;/code&gt;. If &lt;code&gt;C&lt;/code&gt; is a standard &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, this returns &lt;code&gt;C::iterator&lt;/code&gt; when &lt;code&gt;c&lt;/code&gt; is not const-qualified, and &lt;code&gt;C::const_iterator&lt;/code&gt; otherwise.</source>
          <target state="translated">1）精确返回 &lt;code&gt;c.begin()&lt;/code&gt; ，通常是对 &lt;code&gt;c&lt;/code&gt; 表示的序列开头的迭代器。如果 &lt;code&gt;C&lt;/code&gt; 是标准&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;，则当 &lt;code&gt;c&lt;/code&gt; 不是const限定符时返回 &lt;code&gt;C::iterator&lt;/code&gt; ，否则返回 &lt;code&gt;C::const_iterator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8e94140f9ef40bf1d36874da1c9ebca27cad214" translate="yes" xml:space="preserve">
          <source>1) Returns exactly &lt;code&gt;c.end()&lt;/code&gt;, which is typically an iterator one past the end of the sequence represented by &lt;code&gt;c&lt;/code&gt;. If &lt;code&gt;C&lt;/code&gt; is a standard &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, this returns a &lt;code&gt;C::iterator&lt;/code&gt; when &lt;code&gt;c&lt;/code&gt; is not const-qualified, and a &lt;code&gt;C::const_iterator&lt;/code&gt; otherwise.</source>
          <target state="translated">1）精确返回 &lt;code&gt;c.end()&lt;/code&gt; ，通常是一个迭代器，该迭代器在 &lt;code&gt;c&lt;/code&gt; 表示的序列的末尾经过一个。如果 &lt;code&gt;C&lt;/code&gt; 是标准&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;，则当 &lt;code&gt;c&lt;/code&gt; 不是const限定时，它将返回 &lt;code&gt;C::iterator&lt;/code&gt; ，并且返回a &lt;code&gt;C::const_iterator&lt;/code&gt; 否则返回C :: const_iterator。</target>
        </trans-unit>
        <trans-unit id="d2d79bb6bfb415bc4799cd03340ea976f5e1ad4e" translate="yes" xml:space="preserve">
          <source>1) Returns file permissions information.</source>
          <target state="translated">1)返回文件权限信息。</target>
        </trans-unit>
        <trans-unit id="ca8cb5bb5515d3f764ff15bb64205d48c54ff968" translate="yes" xml:space="preserve">
          <source>1) Returns file type information.</source>
          <target state="translated">1)返回文件类型信息。</target>
        </trans-unit>
        <trans-unit id="cbec588b4dae3ad630f2f6af2e54b55a2be244d6" translate="yes" xml:space="preserve">
          <source>1) Returns status of the entry, as if determined by a &lt;a href=&quot;../status&quot;&gt;status&lt;/a&gt; call (symlinks are followed to their targets)</source>
          <target state="translated">1）返回条目的状态，就像由&lt;a href=&quot;../status&quot;&gt;状态&lt;/a&gt;决定的一样调用（符号链接跟随其目标）</target>
        </trans-unit>
        <trans-unit id="292239ac393513bb2a73e81850757d26b7552c99" translate="yes" xml:space="preserve">
          <source>1) Returns the</source>
          <target state="translated">1)返回</target>
        </trans-unit>
        <trans-unit id="0fb0365146c39ac72ff8fc5a9c4e8c203a48497d" translate="yes" xml:space="preserve">
          <source>1) Returns the &amp;alpha; distribution parameter. It is also known as the shape parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1）返回&amp;alpha;分布参数。也称为形状参数。默认值为 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21227b553d58a19b72f0fe801e0f03bd0a1049b3" translate="yes" xml:space="preserve">
          <source>1) Returns the a distribution parameter (location). The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1）返回分配参数（位置）。默认值为 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="143347fc7ff8e780591f1e29b03e2d7669e75b6f" translate="yes" xml:space="preserve">
          <source>1) Returns the a parameter. It defines the shape of the distribution. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1）返回a参数。它定义了分布的形状。默认值为 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2d1f91a5f400fc1fd6adcb1746a21b04fe35b6f" translate="yes" xml:space="preserve">
          <source>1) Returns the associated parameter set.</source>
          <target state="translated">1)返回相关的参数集。</target>
        </trans-unit>
        <trans-unit id="a15f06fffff72065df3b268612d6a17f5310aa58" translate="yes" xml:space="preserve">
          <source>1) Returns the associated stream buffer. If there is no associated stream buffer, returns a null pointer.</source>
          <target state="translated">1)返回关联的流缓冲区。如果没有关联的流缓冲区,返回一个空指针。</target>
        </trans-unit>
        <trans-unit id="22cd7377868adb410066182a3c8def7ed5f1fa07" translate="yes" xml:space="preserve">
          <source>1) Returns the current field width.</source>
          <target state="translated">1)返回当前的字段宽度。</target>
        </trans-unit>
        <trans-unit id="f41a7bceca1233658cedea4989b3de36c56d029f" translate="yes" xml:space="preserve">
          <source>1) Returns the current precision.</source>
          <target state="translated">1)返回当前精度。</target>
        </trans-unit>
        <trans-unit id="001731be05f0e739b1a39d0921456a3adf786c45" translate="yes" xml:space="preserve">
          <source>1) Returns the current tied stream. If there is no tied stream, a null pointer is returned.</source>
          <target state="translated">1)返回当前的绑定流。如果没有绑定流,则返回一个空指针。</target>
        </trans-unit>
        <trans-unit id="5acdce3496544fa0bd7b2c030f8bf1d9c5f72571" translate="yes" xml:space="preserve">
          <source>1) Returns the exception mask.</source>
          <target state="translated">1)返回异常掩码。</target>
        </trans-unit>
        <trans-unit id="1694f8d96fa622b3f17ae9121b869a1b0312a6ef" translate="yes" xml:space="preserve">
          <source>1) Returns the imaginary component of the complex number &lt;code&gt;z&lt;/code&gt;, i.e. &lt;code&gt;z.imag()&lt;/code&gt;.</source>
          <target state="translated">1）返回复数 &lt;code&gt;z&lt;/code&gt; 的虚部，即 &lt;code&gt;z.imag()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49125a8b6077342f10be4d243d2ed33fbfe22de1" translate="yes" xml:space="preserve">
          <source>1) Returns the imaginary part.</source>
          <target state="translated">1)返回虚部。</target>
        </trans-unit>
        <trans-unit id="af75cb25c63821285d34593afc3031d58d00ddf9" translate="yes" xml:space="preserve">
          <source>1) Returns the list of boundaries of the intervals.</source>
          <target state="translated">1)返回区间的边界列表。</target>
        </trans-unit>
        <trans-unit id="4c3aa7a255032d162e6721d758482183c8e0d4e5" translate="yes" xml:space="preserve">
          <source>1) Returns the log-mean m distribution parameter. It defines the location of the peak. The default value is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">1）返回对数均值分布参数。它定义了峰的位置。预设值为 &lt;code&gt;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb15710c8fbb6d1b45fb72076cb13894fb56f750" translate="yes" xml:space="preserve">
          <source>1) Returns the m (the first degree of freedom) distribution parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1）返回m（第一自由度）分布参数。默认值为 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12bbddb8b9d6e0fbda5e7775b18ff17adbbacb80" translate="yes" xml:space="preserve">
          <source>1) Returns the mean &amp;mu; distribution parameter. The mean specifies the location of the peak. The default value is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">1）返回平均&amp;mu;分布参数。平均值指定峰的位置。预设值为 &lt;code&gt;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47a018754522c2f9b7cd2238570b2ebdebe1376b" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1）使用key &lt;code&gt;key&lt;/code&gt; 返回元素的数量。</target>
        </trans-unit>
        <trans-unit id="4307f7beb5cbf30b6fd034cf152d44ddfc23058a" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key that compares equal to the specified argument &lt;code&gt;key&lt;/code&gt;, which is either 1 or 0 since this container does not allow duplicates.</source>
          <target state="translated">1）返回键等于指定参数的元素数 &lt;code&gt;key&lt;/code&gt; 的为1或0，因为此容器不允许重复。</target>
        </trans-unit>
        <trans-unit id="eb9b09c24f4dd3756959d45d14cfe7322d3d6eb0" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key that compares equal to the specified argument &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1）返回具有等于指定参数 &lt;code&gt;key&lt;/code&gt; 的的元素数。</target>
        </trans-unit>
        <trans-unit id="d0b0dd6464e410f3559cc88a021648404b61cfba" translate="yes" xml:space="preserve">
          <source>1) Returns the object owned by &lt;code&gt;*this&lt;/code&gt;, equivalent to &lt;code&gt;*get()&lt;/code&gt;.</source>
          <target state="translated">1）返回 &lt;code&gt;*this&lt;/code&gt; 拥有的对象，等效于 &lt;code&gt;*get()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efadb8f443ff52a8a06ff3cca490584c99089f22" translate="yes" xml:space="preserve">
          <source>1) Returns the p distribution parameter. It defines the probability of a trial generating &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">1）返回p分布参数。它定义了试验产生 &lt;code&gt;true&lt;/code&gt; 的概率。预设值为 &lt;code&gt;0.5&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06ea4503952409f3d220d8a31ac2c3d9a0b87e8b" translate="yes" xml:space="preserve">
          <source>1) Returns the pointer to the beginning (&quot;base&quot;) of the put area.</source>
          <target state="translated">1)返回指向放置区域的起点(&quot;基地&quot;)的指针。</target>
        </trans-unit>
        <trans-unit id="d711b398059e09252c735c5b767a6c4f3b8c2d28" translate="yes" xml:space="preserve">
          <source>1) Returns the pointer to the beginning of the get area.</source>
          <target state="translated">1)返回指向获取区域起点的指针。</target>
        </trans-unit>
        <trans-unit id="81b834f0d5a61937ab85cb95196e573fab4dbf45" translate="yes" xml:space="preserve">
          <source>1) Returns the real component of the complex number &lt;code&gt;z&lt;/code&gt;, i.e. &lt;code&gt;z.real()&lt;/code&gt;.</source>
          <target state="translated">1）返回复数 &lt;code&gt;z&lt;/code&gt; 的实数部分，即 &lt;code&gt;z.real()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="088dec1497a550df9243695c3279f03c8fb7947b" translate="yes" xml:space="preserve">
          <source>1) Returns the real part.</source>
          <target state="translated">1)返回真实部分。</target>
        </trans-unit>
        <trans-unit id="8f3e1ba68c1324385714f799b9c29d179d2e6b88" translate="yes" xml:space="preserve">
          <source>1) Returns the squared magnitude of the complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1）返回复数 &lt;code&gt;z&lt;/code&gt; 的平方幅度。</target>
        </trans-unit>
        <trans-unit id="c70906930f9cd42e8f972b6ea9d3588d75bb9758" translate="yes" xml:space="preserve">
          <source>1) Returns the stored &lt;code&gt;std::chrono::month&lt;/code&gt; value.</source>
          <target state="translated">1）返回存储的 &lt;code&gt;std::chrono::month&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="ce5d3c03147c08fafbfcc97025b8268f78f5aaea" translate="yes" xml:space="preserve">
          <source>1) Returns the stored &lt;code&gt;std::chrono::year&lt;/code&gt; value.</source>
          <target state="translated">1）返回存储的 &lt;code&gt;std::chrono::year&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="61dadd5c36bffe5a48255156199fa6c44fd84e1d" translate="yes" xml:space="preserve">
          <source>1) Returns the time of the last modification of &lt;code&gt;p&lt;/code&gt;, determined as if by accessing the member &lt;code&gt;st_mtime&lt;/code&gt; of the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed) The non-throwing overload returns &lt;code&gt;file_time_type::min()&lt;/code&gt; on errors.</source>
          <target state="translated">1）返回 &lt;code&gt;p&lt;/code&gt; 的最后修改时间，就好像通过访问POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt;的成员 &lt;code&gt;st_mtime&lt;/code&gt; （遵循符号链接）来确定一样。非抛出重载在出错时返回 &lt;code&gt;file_time_type::min()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2941cfcccb903d8c412b126eb85c8fa8bc0af6f7" translate="yes" xml:space="preserve">
          <source>1) Returns the time of the last modification of &lt;code&gt;p&lt;/code&gt;, determined as if by accessing the member &lt;code&gt;st_mtime&lt;/code&gt; of the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed) The non-throwing overload returns &lt;code&gt;file_time_type::min()&lt;/code&gt; on errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa97c65b799f5efb0b02504a22a02ad70a88e318" translate="yes" xml:space="preserve">
          <source>1) Returns the value of its argument</source>
          <target state="translated">1)返回其参数的值</target>
        </trans-unit>
        <trans-unit id="533e65d4cbce1169e96cd03deb423e1ebed9ef4f" translate="yes" xml:space="preserve">
          <source>1) Returns the value of the file position state</source>
          <target state="translated">1)返回文件位置状态的值。</target>
        </trans-unit>
        <trans-unit id="8bd1eba1fbdf89c5698365e7fe91902373d9c621" translate="yes" xml:space="preserve">
          <source>1) Returns true if all of the bits in &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1）如果 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 中的所有位都相等，则返回true 。</target>
        </trans-unit>
        <trans-unit id="998c1c493c58a67ce9bb205f050c7dbaf76aed9b" translate="yes" xml:space="preserve">
          <source>1) Reverses the order of the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;</source>
          <target state="translated">1）反转 &lt;code&gt;[first, last)&lt;/code&gt; 范围内元素的顺序</target>
        </trans-unit>
        <trans-unit id="8d1ddbebd20349684cf4acb8ec8e6b2d4f4d96e9" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;a href=&quot;iterator_t&quot;&gt;&lt;code&gt;ranges::iterator_t&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;R&lt;/code&gt; models exposition-only concept &lt;a href=&quot;range&quot;&gt;&lt;code&gt;__ForwardingRange&lt;/code&gt;&lt;/a&gt;, otherwise yields &lt;a href=&quot;dangling&quot;&gt;&lt;code&gt;ranges::dangling&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">1）当 &lt;code&gt;R&lt;/code&gt; 模型仅说明概念&lt;a href=&quot;range&quot;&gt; &lt;code&gt;__ForwardingRange&lt;/code&gt; 时&lt;/a&gt;，与&lt;a href=&quot;iterator_t&quot;&gt; &lt;code&gt;ranges::iterator_t&lt;/code&gt; &lt;/a&gt;相同，否则产生&lt;a href=&quot;dangling&quot;&gt; &lt;code&gt;ranges::dangling&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="14f30d52df1968fd80f273b59c9c1e7531df510b" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;a href=&quot;noexcept_spec&quot;&gt;&lt;code&gt;noexcept(true)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">1）与&lt;a href=&quot;noexcept_spec&quot;&gt; &lt;code&gt;noexcept(true)&lt;/code&gt; &lt;/a&gt;相同（true）</target>
        </trans-unit>
        <trans-unit id="4def597a1104c9ab9fae317a750663a62c536d96" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;code&gt;noexcept&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;true&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">1）与 &lt;code&gt;noexcept&lt;/code&gt; 相同 &lt;code&gt;(&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c9b60d20817d9dc8664bdd29847776bc1e84582" translate="yes" xml:space="preserve">
          <source>1) Searches for the file in implementation-defined manner. The intent of this syntax is to search for the files under control of the implementation. Typical implementations search only standard include directories. The standard C++ library and the standard C library are implicitly included in these standard include directories. The standard include directories usually can be controlled by the user through compiler options.</source>
          <target state="translated">1)以实现定义的方式搜索文件。这种语法的意图是搜索实现所控制的文件。典型的实现只搜索标准的包含目录。标准C++库和标准C库隐含在这些标准包含目录中。标准的包含目录通常可以由用户通过编译器选项来控制。</target>
        </trans-unit>
        <trans-unit id="40b026d27109ca4160eaec8af9d9260a322193ab" translate="yes" xml:space="preserve">
          <source>1) Seeds the underlying engine with the default seed value. Effectively calls &lt;code&gt;e.seed()&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the underlying engine.</source>
          <target state="translated">1）使用默认种子值播种基础引擎。有效地调用 &lt;code&gt;e.seed()&lt;/code&gt; ，其中 &lt;code&gt;e&lt;/code&gt; 是基础引擎。</target>
        </trans-unit>
        <trans-unit id="f142d0432d80c80b2801b2b54dcc353009676c5d" translate="yes" xml:space="preserve">
          <source>1) Serializes the internal state of the pseudo-random number engine &lt;code&gt;e&lt;/code&gt; as a sequence of decimal numbers separated by one or more spaces, and inserts it to the stream &lt;code&gt;ost&lt;/code&gt;. The fill character and the formatting flags of the stream are ignored and unaffected.</source>
          <target state="translated">1）将伪随机数引擎 &lt;code&gt;e&lt;/code&gt; 的内部状态序列化为由一个或多个空格分隔的十进制数序列，并将其插入流 &lt;code&gt;ost&lt;/code&gt; 中。流的填充字符和格式标志将被忽略并且不受影响。</target>
        </trans-unit>
        <trans-unit id="08f8da6462aba2a7fffaed13b8fbb52f524e794c" translate="yes" xml:space="preserve">
          <source>1) Serializes the internal state of the pseudo-random number engine adaptor as a sequence of decimal numbers separated by one or more spaces, and inserts it to the stream &lt;code&gt;ost&lt;/code&gt;. The fill character and the formatting flags of the stream are ignored and unaffected.</source>
          <target state="translated">1）将伪随机数引擎适配器的内部状态序列化为由一个或多个空格分隔的十进制数序列，并将其插入流 &lt;code&gt;ost&lt;/code&gt; 中。流的填充字符和格式标志将被忽略并且不受影响。</target>
        </trans-unit>
        <trans-unit id="36a998e3dc0e13d7209092f6c20763322ec5b8e6" translate="yes" xml:space="preserve">
          <source>1) Sets &lt;code&gt;loc&lt;/code&gt; as the associated locale. Calls &lt;code&gt;imbue(loc)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）将 &lt;code&gt;loc&lt;/code&gt; 设置为关联的语言环境。调用最派生类的 &lt;code&gt;imbue(loc)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed7ef78eb4d8ac7ad642d4f6b0d28e5671d8ee52" translate="yes" xml:space="preserve">
          <source>1) Sets all bits to &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">1）将所有位设置为 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="748a476f9f45c4cb135ddad1e581399045772b64" translate="yes" xml:space="preserve">
          <source>1) Sets all bits to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1）将所有位设置为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2021569fa06d5efa69909df75d00a3f4cd2a9408" translate="yes" xml:space="preserve">
          <source>1) Sets the &lt;code&gt;floatfield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;fixed&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1）设置 &lt;code&gt;floatfield&lt;/code&gt; 流 &lt;code&gt;str&lt;/code&gt; 以 &lt;code&gt;fixed&lt;/code&gt; 通过调用仿佛 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50dc184d36fecae99d3273c9a89db78d54bc50c8" translate="yes" xml:space="preserve">
          <source>1) Sets the bits to the result of binary AND on corresponding pairs of bits of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1）将位设置为 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 的相应位对上的二进制AND结果。</target>
        </trans-unit>
        <trans-unit id="a1cd0d7ac969813ee13818267a9de7c1936f1da7" translate="yes" xml:space="preserve">
          <source>1) Sets the formatting flags identified by &lt;code&gt;flags&lt;/code&gt;. Effectively the following operation is performed &lt;code&gt;fl = fl | flags&lt;/code&gt; where &lt;code&gt;fl&lt;/code&gt; defines the state of internal formatting flags.</source>
          <target state="translated">1）设置由flags标识的格式化 &lt;code&gt;flags&lt;/code&gt; 。有效地执行以下操作 &lt;code&gt;fl = fl | flags&lt;/code&gt; ，其中 &lt;code&gt;fl&lt;/code&gt; 定义内部格式化标志的状态。</target>
        </trans-unit>
        <trans-unit id="5a76f71dc224d669d3f23245ebcbc6fe12cf100b" translate="yes" xml:space="preserve">
          <source>1) Shares ownership of the object managed by &lt;code&gt;r&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; manages no object, &lt;code&gt;*this&lt;/code&gt; manages no object too. Equivalent to &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1）共享由 &lt;code&gt;r&lt;/code&gt; 管理的对象的所有权。如果 &lt;code&gt;r&lt;/code&gt; 不管理任何对象，则 &lt;code&gt;*this&lt;/code&gt; 也不管理任何对象。等效于 &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33d51240dc329ad03133b83ed63c310835b93f14" translate="yes" xml:space="preserve">
          <source>1) Shifts the elements towards the beginning of the range. If &lt;code&gt;n &amp;lt;= 0 || n &amp;gt;= last - first&lt;/code&gt;, there are no effects. Otherwise, for every integer &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, last - first - n)&lt;/code&gt;, moves the element originally at position &lt;code&gt;first + n + i&lt;/code&gt; to position &lt;code&gt;first + i&lt;/code&gt;. The moves are performed in increasing order of &lt;code&gt;i&lt;/code&gt; starting from &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1）将元素移到范围的开头。如果 &lt;code&gt;n &amp;lt;= 0 || n &amp;gt;= last - first&lt;/code&gt; ，没有效果。否则，对于每个整数 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;[0, last - first - n)&lt;/code&gt; ，原本在位置移动元件 &lt;code&gt;first + n + i&lt;/code&gt; 到位置 &lt;code&gt;first + i&lt;/code&gt; 。该动作是在增加的顺序来执行 &lt;code&gt;i&lt;/code&gt; 从开始 &lt;code&gt;​0​&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c3c379223399d99299e4dd0ec4e8ae7d2df828f1" translate="yes" xml:space="preserve">
          <source>1) Specifies that a constructor  or conversion function(since C++11) is explicit, that is, it cannot be used for &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;.</source>
          <target state="translated">1）指定构造函数或转换函数（自C ++ 11起）是显式的，即，不能将其用于&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt;和&lt;a href=&quot;copy_initialization&quot;&gt;复制初始化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3fc72a8629768287c31cd486267125fa2a02f24d" translate="yes" xml:space="preserve">
          <source>1) Static or thread-local references, if it is bound to static glvalue, to a temporary object (or its subobject), or to a function, and if every expression (including implicit conversions) in &lt;a href=&quot;reference_initialization&quot;&gt;the initializer&lt;/a&gt; of the reference is a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;.</source>
          <target state="translated">1）静态或线程局部引用，如果它绑定到静态glvalue，临时对象（或其子对象）或函数，并且引用&lt;a href=&quot;reference_initialization&quot;&gt;的初始化程序&lt;/a&gt;中的每个表达式（包括隐式转换）都是&lt;a href=&quot;constant_expression&quot;&gt;常量表达&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7bba5893de10ec808038f251574bf599363a4baa" translate="yes" xml:space="preserve">
          <source>1) Steps through the character sequence &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt;, examining the characters. Every character that is not a part of a format sequence is written to the output iterator &lt;code&gt;out&lt;/code&gt; immediately. To identify format sequences, this function narrows the next character &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char_type&amp;gt;(str.getloc()).narrow(c,0)&lt;/code&gt; and if it equals &lt;code&gt;'%'&lt;/code&gt;, the next one or two characters are compared to the list of format sequences recognized by &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; plus any additional implementation-defined formats supported by this locale. For each valid format sequence, a call to &lt;code&gt;do_put(out, str, fill, t, format, modifier)&lt;/code&gt; is made, where &lt;code&gt;format&lt;/code&gt; is the format sequence character, and &lt;code&gt;modifier&lt;/code&gt; is the optional format sequence modifier (&lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'O'&lt;/code&gt;). A value of &lt;code&gt;'\0'&lt;/code&gt; is used if the modifier is absent.</source>
          <target state="translated">1） &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; 检查字符序列[fmtbeg，fmtend），检查字符。每个人的性格不是一个格式序列的一部分写入到输出迭代 &lt;code&gt;out&lt;/code&gt; 马上。为了识别格式序列，这一功能变窄的下一个字符 &lt;code&gt;c&lt;/code&gt; 在 &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; 仿佛由 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char_type&amp;gt;(str.getloc()).narrow(c,0)&lt;/code&gt; ，以及它是否 &lt;code&gt;'%'&lt;/code&gt; ，接下来的一个或两个字符将与 &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; 识别的格式序列列表以及该语言环境支持的任何其他实现定义的格式进行比较。对于每个有效的格式序列，都会调用 &lt;code&gt;do_put(out, str, fill, t, format, modifier)&lt;/code&gt; 进行制作，其中 &lt;code&gt;format&lt;/code&gt; 是格式序列字符，而 &lt;code&gt;modifier&lt;/code&gt; 是可选的格式序列修饰符（ &lt;code&gt;'E'&lt;/code&gt; 或 &lt;code&gt;'O'&lt;/code&gt; ）。如果没有修饰符，则使用 &lt;code&gt;'\0'&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="dbe4d06a8673e9980bbd8a34d0a33460ddce561c" translate="yes" xml:space="preserve">
          <source>1) Swaps the values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. This overload does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_move_assignable&quot;&gt;std::is_move_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1）交换值 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 。除非 &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_move_assignable&quot;&gt;std::is_move_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,否则此重载不参与重载解析。（自C ++ 17起）</target>
        </trans-unit>
        <trans-unit id="0e334356b91d7cf3ca8b843c79afa340cb4f3a9d" translate="yes" xml:space="preserve">
          <source>1) Template arguments (if any) are substituted into expression;</source>
          <target state="translated">1)模板参数(如果有的话)被替换成表达式。</target>
        </trans-unit>
        <trans-unit id="ce2782af810444b02f25f93a1dd29f5756552166" translate="yes" xml:space="preserve">
          <source>1) The</source>
          <target state="translated">(1)</target>
        </trans-unit>
        <trans-unit id="2bf42c2016441eb61ea13c6e9fa609da95361a52" translate="yes" xml:space="preserve">
          <source>1) The &lt;a href=&quot;../preprocessor&quot;&gt;preprocessor&lt;/a&gt; is executed.</source>
          <target state="translated">1）执行&lt;a href=&quot;../preprocessor&quot;&gt;预处理器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="65e8aa1cffd8b645e51e443b4510d72178b7b831" translate="yes" xml:space="preserve">
          <source>1) The &lt;a href=&quot;name&quot;&gt;name&lt;/a&gt; that is declared.</source>
          <target state="translated">1）声明的&lt;a href=&quot;name&quot;&gt;名称&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f433a0c89c7f1e8799b60485288073c016147e00" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt; concept specifies the requirements of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; type that has constant time copy, move, and assignment operations (e.g. a pair of iterators, or a generator Range that creates its elements on-demand. Notably, the standard library containers are Ranges, but not Views)</source>
          <target state="translated">1） &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt; 概念指定了具有恒定时间复制，移动和分配操作的&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;类型的要求（例如，一对迭代器或按需创建其元素的生成器Range。值得注意的是，标准库容器是Ranges ，但不包含&amp;ldquo;观看次数&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="ec5eeb1c920435edfac9357c193554b45fa0d085" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;Range&lt;/code&gt; concept defines the requirements of a type that allows iteration over its elements by providing an iterator and sentinel that denote the elements of the range.</source>
          <target state="translated">1） &lt;code&gt;Range&lt;/code&gt; 概念定义了一种类型的要求，该类型允许通过提供表示范围元素的迭代器和标记来对其元素进行迭代。</target>
        </trans-unit>
        <trans-unit id="5664b3fe1fc216eb8579abb8ca6fc0ab64244ff1" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;auto&lt;/code&gt; specifier was only allowed for objects declared at block scope or in function parameter lists. It indicated automatic storage duration, which is the default for these kinds of declarations. The meaning of this keyword was changed in C++11.</source>
          <target state="translated">1） &lt;code&gt;auto&lt;/code&gt; 说明符仅允许在块作用域或函数参数列表中声明的对象使用。它指示自动存储持续时间，这是此类声明的默认值。此关键字的含义在C ++ 11中已更改。</target>
        </trans-unit>
        <trans-unit id="5771f1de4aaeaaa160fa4e631f3e630380eaf437" translate="yes" xml:space="preserve">
          <source>1) The a distribution parameter (location).</source>
          <target state="translated">1)a分布参数(位置)。</target>
        </trans-unit>
        <trans-unit id="a56f4b7e28c5e16ec27cb41041cbe5d377ab7dae" translate="yes" xml:space="preserve">
          <source>1) The alternative name this &lt;code&gt;link&lt;/code&gt; object represents.</source>
          <target state="translated">1）此 &lt;code&gt;link&lt;/code&gt; 对象表示的替代名称。</target>
        </trans-unit>
        <trans-unit id="13892ed49e94589b6b3b35aa23f26504383e1f3e" translate="yes" xml:space="preserve">
          <source>1) The argument list cannot be identical to the non-specialized argument list (it must specialize something)</source>
          <target state="translated">1)参数表不能与非特殊化的参数表完全相同(必须特殊化一些东西</target>
        </trans-unit>
        <trans-unit id="55233ebd70c2b08df11e491094ea36d0775f225f" translate="yes" xml:space="preserve">
          <source>1) The associated parameter set.</source>
          <target state="translated">1)相关参数集。</target>
        </trans-unit>
        <trans-unit id="8cb340ccead28657a0f96c703f2768d7cbbcc0cb" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments or with &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; as the argument)</source>
          <target state="translated">1）调用方要求将get区域备份一个字符（不带参数或以 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 作为参数调用 &lt;code&gt;pbackfail()&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="3b59d07570db328903bdf39c6ee15b2e5874d234" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments or with &lt;code&gt;Traits::eof()&lt;/code&gt; as the argument)</source>
          <target state="translated">1）调用方要求将get区域备份一个字符（不带参数或以 &lt;code&gt;Traits::eof()&lt;/code&gt; 作为参数调用 &lt;code&gt;pbackfail()&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="61adb3e6b0b307a7e54bcae25d20d2e0a7936478" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments), in which case, this function re-reads the file starting one byte earlier and decrements &lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;&lt;code&gt;basic_streambuf::gptr()&lt;/code&gt;&lt;/a&gt;, e.g. by calling &lt;code&gt;gbump(-1)&lt;/code&gt;.</source>
          <target state="translated">1）调用方请求将get区域备份一个字符（ &lt;code&gt;pbackfail()&lt;/code&gt; 带任何参数调用pbackfail（）），在这种情况下，此函数从前一个字节开始重新读取文件，并递减&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt; &lt;code&gt;basic_streambuf::gptr()&lt;/code&gt; &lt;/a&gt;例如，通过调用 &lt;code&gt;gbump(-1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1ae7223669c573a68efa4c16b06f3ce8570f1d7" translate="yes" xml:space="preserve">
          <source>1) The concept &lt;code&gt;StrictTotallyOrdered&amp;lt;T&amp;gt;&lt;/code&gt; specifies that the comparison operators &lt;code&gt;==,!=,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=&lt;/code&gt; on &lt;code&gt;T&lt;/code&gt; yield results consistent with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total order&lt;/a&gt; on &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1）概念 &lt;code&gt;StrictTotallyOrdered&amp;lt;T&amp;gt;&lt;/code&gt; 指明所述比较操作符 &lt;code&gt;==,!=,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=&lt;/code&gt; 上 &lt;code&gt;T&lt;/code&gt; 产量结果具有一致的&lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;严格总订单&lt;/a&gt;上 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="692cf4b8d8f5f53ecfe4d474f1ec25af3dddecf7" translate="yes" xml:space="preserve">
          <source>1) The constructor initializes the member object (of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt;) from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;. Throws any exception thrown by the constructor selected</source>
          <target state="translated">1）构造函数从 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; &amp;lt;F&amp;gt;（f）初始化成员对象（类型为 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; ）。抛出所选构造函数引发的任何异常</target>
        </trans-unit>
        <trans-unit id="2b56e5f14d5ec78f7a1a9e935292dc9c4e9c4bc1" translate="yes" xml:space="preserve">
          <source>1) The copy assignment operator is protected, and is deleted. Input streams are not CopyAssignable.</source>
          <target state="translated">1)复制分配运算符是受保护的,被删除。输入流是不可复制赋值的。</target>
        </trans-unit>
        <trans-unit id="cb957de92fc95959bfc746d86ce3609a64f1a4fd" translate="yes" xml:space="preserve">
          <source>1) The copy assignment operator is protected, and is deleted. Output streams are not CopyAssignable.</source>
          <target state="translated">1)复制赋值运算符是受保护的,被删除。输出流是不可复制分配的。</target>
        </trans-unit>
        <trans-unit id="e34654c2e919d3a91813ff3288559504fc22e14a" translate="yes" xml:space="preserve">
          <source>1) The copy constructor is deleted: streams are not copyable.</source>
          <target state="translated">1)复制构造函数被删除:流不可复制。</target>
        </trans-unit>
        <trans-unit id="10e7c6895d9ef10be5943bb1587dc03b33198d2f" translate="yes" xml:space="preserve">
          <source>1) The current exception mask.</source>
          <target state="translated">1)当前的异常掩码。</target>
        </trans-unit>
        <trans-unit id="3abfb5553c81efc2e23dc953228b75d755237163" translate="yes" xml:space="preserve">
          <source>1) The default constructor creates a &lt;code&gt;std::seed_seq&lt;/code&gt; object with an initial seed sequence of length zero.</source>
          <target state="translated">1）默认构造函数创建一个 &lt;code&gt;std::seed_seq&lt;/code&gt; 对象，其初始种子序列的长度为零。</target>
        </trans-unit>
        <trans-unit id="4e2c38841269bc097ae1c47eda71b3fbdeb21c7e" translate="yes" xml:space="preserve">
          <source>1) The default constructor is defaulted.</source>
          <target state="translated">1)默认的构造函数是默认的。</target>
        </trans-unit>
        <trans-unit id="eaa9c330e0c1827f710a288a9214aaa3553943cf" translate="yes" xml:space="preserve">
          <source>1) The default constructor is trivial: no initialization takes place other than &lt;a href=&quot;../../language/zero_initialization&quot;&gt;zero initialization&lt;/a&gt; of static and thread-local objects. &lt;code&gt;&lt;a href=&quot;../atomic_init&quot;&gt;std::atomic_init&lt;/a&gt;&lt;/code&gt; may be used to complete initialization.</source>
          <target state="translated">1）默认构造函数是微不足道的：除了静态和线程本地对象的&lt;a href=&quot;../../language/zero_initialization&quot;&gt;零初始化外&lt;/a&gt;，不进行任何初始化。 &lt;code&gt;&lt;a href=&quot;../atomic_init&quot;&gt;std::atomic_init&lt;/a&gt;&lt;/code&gt; 可以用于完成初始化。</target>
        </trans-unit>
        <trans-unit id="a6475c63291c6da877aa299aa6f4d12b026b2cf4" translate="yes" xml:space="preserve">
          <source>1) The default, equivalent to (2) with &lt;code&gt;copy_options::none&lt;/code&gt; used as &lt;code&gt;options&lt;/code&gt;</source>
          <target state="translated">1）默认值，相当于（2），其中 &lt;code&gt;copy_options::none&lt;/code&gt; 用作 &lt;code&gt;options&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf4124c6a6217a2beb35fda41d126dc7a4ceaa8e" translate="yes" xml:space="preserve">
          <source>1) The destructors of objects with thread local &lt;a href=&quot;../../language/storage_duration&quot;&gt;storage duration&lt;/a&gt; that are associated with the current thread, the destructors of objects with static storage duration, and the functions registered with &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are executed concurrently, while maintaining the following guarantees: a) The last destructor for thread-local objects is &lt;a href=&quot;../../language/eval_order&quot;&gt;sequenced-before&lt;/a&gt; the first destructor for a static object b) If the completion of the constructor or &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;dynamic initialization&lt;/a&gt; for thread-local or static object A was sequenced-before thread-local or static object B, the completion of the destruction of B is sequenced-before the start of the destruction of A c) If the completion of the initialization of a static object A was sequenced-before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F, the call to F during termination is sequenced-before the start of the destruction of A d) If the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F was sequenced-before the completion of initialization of a static object A, the start of the destruction of A is sequenced-before the call to F during termination. e) If a call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F1 was sequenced-before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F2, then the call to F2 during termination is sequenced-before the call to F1</source>
          <target state="translated">1）与线程当前&lt;a href=&quot;../../language/storage_duration&quot;&gt;存储&lt;/a&gt;关联的对象的析构函数与当前线程，具有静态存储持续时间的对象的析构函数以及向 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 注册的函数同时执行，同时保持以下保证：a）线程本地对象的最后一个析构函数在静态对象的第一个析构函数&lt;a href=&quot;../../language/eval_order&quot;&gt;之前排序&lt;/a&gt; b）如果线程本地或静态对象A 的构造函数或&lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;动态初始化&lt;/a&gt;的完成顺序在线程本地或静态对象B之前排序，则B破坏的完成顺序在A的破坏开始之前进行。c）如果静态对象A的初始化完成的顺序在调用A之前进行了排序 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 某些函数F的 std :: atexit，在终止A之前开始对F的调用进行排序d）如果某个函数F的 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 的调用已进行了序列-在a的初始化完成之前静态对象A，销毁A的开始顺序是在终止期间对F的调用之前。 e）如果被调用 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 一些功能F1进行测序，之前调用 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 一些功能F2，然后终止期间调用F2测序，之前调用F1</target>
        </trans-unit>
        <trans-unit id="984436ed4409399ee56d2edafaa76fa5827ade9b" translate="yes" xml:space="preserve">
          <source>1) The execution policy type used as a unique type to disambiguate parallel algorithm overloading and require that a parallel algorithm's execution may not be parallelized. The invocations of element access functions in parallel algorithms invoked with this policy (usually specified as &lt;code&gt;&lt;a href=&quot;execution_policy_tag&quot;&gt;std::execution::seq&lt;/a&gt;&lt;/code&gt;) are indeterminately sequenced in the calling thread.</source>
          <target state="translated">1）执行策略类型用作唯一类型，以消除并行算法过载的歧义，并要求不得并行执行并行算法。用此策略（通常指定为 &lt;code&gt;&lt;a href=&quot;execution_policy_tag&quot;&gt;std::execution::seq&lt;/a&gt;&lt;/code&gt; ）调用的并行算法中元素访问函数的调用在调用线程中不确定地排序。</target>
        </trans-unit>
        <trans-unit id="e362b206dffda02474ab2c007c80f4e6c881bbd6" translate="yes" xml:space="preserve">
          <source>1) The exponent syntax for a decimal floating-point literal</source>
          <target state="translated">1)小数浮点文字的指数语法</target>
        </trans-unit>
        <trans-unit id="64cdf221b5add07010de335de6d59fa388267951" translate="yes" xml:space="preserve">
          <source>1) The file or empty directory identified by the path &lt;code&gt;p&lt;/code&gt; is deleted as if by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove&lt;/a&gt;. Symlinks are not followed (symlink is removed, not its target)</source>
          <target state="translated">1）删除路径 &lt;code&gt;p&lt;/code&gt; 标识的文件或空目录，就像POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove一样&lt;/a&gt;。不遵循符号链接（符号链接已删除，而不是其目标）</target>
        </trans-unit>
        <trans-unit id="efff08eeeee41b2824631c7af356a9f4b8b0d101" translate="yes" xml:space="preserve">
          <source>1) The file or empty directory identified by the path &lt;code&gt;p&lt;/code&gt; is deleted as if by the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove&lt;/a&gt;. Symlinks are not followed (symlink is removed, not its target)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be6415eb11ca6d2a6ae2ef6b1a8ebf53b49733f" translate="yes" xml:space="preserve">
          <source>1) The first operand must be an expression of &lt;a href=&quot;incomplete_type&quot;&gt;complete class type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1）第一个操作数必须是&lt;a href=&quot;incomplete_type&quot;&gt;完整类类型&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 的表达式。</target>
        </trans-unit>
        <trans-unit id="5f5ef6f6f7feb816947d23a3ea4f22b9c37b4705" translate="yes" xml:space="preserve">
          <source>1) The format character sequence is defined by the range &lt;code&gt;[fmt_first, fmt_last)&lt;/code&gt;. The resulting character sequence is copied to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">1）格式字符序列由 &lt;code&gt;[fmt_first, fmt_last)&lt;/code&gt; 范围定义。结果字符序列被复制到 &lt;code&gt;out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95de870e8f49a93ec939ffd632a40a00558bdce7" translate="yes" xml:space="preserve">
          <source>1) The individual bytes of the source code file are mapped (in implementation-defined manner) to the characters of the</source>
          <target state="translated">1)源代码文件的各个字节被映射到(以实现定义的方式)的字符上。</target>
        </trans-unit>
        <trans-unit id="f69e48ffceb6307d147e62ebd3e15bb7bcf22d41" translate="yes" xml:space="preserve">
          <source>1) The length &lt;code&gt;rlen&lt;/code&gt; of the sequences to compare is the smaller of &lt;code&gt;size()&lt;/code&gt; and &lt;code&gt;v.size()&lt;/code&gt;. The function compares the two views by calling &lt;code&gt;traits::compare(data(), v.data(), rlen)&lt;/code&gt;, and returns a value according to the following table:</source>
          <target state="translated">1）要比较的序列的长度 &lt;code&gt;rlen&lt;/code&gt; 是 &lt;code&gt;size()&lt;/code&gt; 和 &lt;code&gt;v.size()&lt;/code&gt; 中的较小者。该函数通过调用 &lt;code&gt;traits::compare(data(), v.data(), rlen)&lt;/code&gt; 比较两个视图，并根据下表返回一个值：</target>
        </trans-unit>
        <trans-unit id="4037f7821b91877636d406cbce1bcacb0689bf42" translate="yes" xml:space="preserve">
          <source>1) The lifetime of the object allocated by E1 strictly contains the lifetime of the object allocated by E2, 2) E1 and E2 would invoke the same replaceable global allocation function 3) For a throwing allocation function, exceptions in E1 and E2 would be first caught in the same handler.</source>
          <target state="translated">1)E1分配的对象的寿命严格包含E2分配的对象的寿命,2)E1和E2会调用同一个可替换的全局分配函数3)对于抛出的分配函数,E1和E2中的异常会先被同一个处理程序捕获。</target>
        </trans-unit>
        <trans-unit id="b5680fbc09a44d73240f35e66072e9eb23f44a63" translate="yes" xml:space="preserve">
          <source>1) The list of boundaries of the intervals.</source>
          <target state="translated">1)区间的边界列表。</target>
        </trans-unit>
        <trans-unit id="b88da70e98e0b2688aca929c023fd479e8e2afd6" translate="yes" xml:space="preserve">
          <source>1) The log-mean m distribution parameter.</source>
          <target state="translated">1)对数均值m分布参数。</target>
        </trans-unit>
        <trans-unit id="58a51494ba725af135bdfe4838b9d7d460044580" translate="yes" xml:space="preserve">
          <source>1) The m (the first degree of freedom) distribution parameter.</source>
          <target state="translated">1)m(第一自由度)分布参数。</target>
        </trans-unit>
        <trans-unit id="253b910778e1d968599094f0f2559f6818ab03e8" translate="yes" xml:space="preserve">
          <source>1) The mean &amp;mu; distribution parameter.</source>
          <target state="translated">1）平均&amp;mu;分布参数。</target>
        </trans-unit>
        <trans-unit id="419ac7c350c315de0c2fc313d43dafe994bfe4ae" translate="yes" xml:space="preserve">
          <source>1) The members declared after the specifier have public member access</source>
          <target state="translated">1)在指定者之后声明的成员具有公共成员的访问权。</target>
        </trans-unit>
        <trans-unit id="bd8f7818635373bb03d0e69a14d67db0b342bd5c" translate="yes" xml:space="preserve">
          <source>1) The nested-name-specifier (everything to the left of the scope resolution operator &lt;code&gt;::&lt;/code&gt;) of a type that was specified using a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified-id&lt;/a&gt;:</source>
          <target state="translated">1）使用&lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified-id&lt;/a&gt;指定的类型的嵌套名称说明符（范围解析运算符 &lt;code&gt;::&lt;/code&gt; 的所有内容）：</target>
        </trans-unit>
        <trans-unit id="c5d2d5ea95e95309310a1f70f09cdbb08741b9eb" translate="yes" xml:space="preserve">
          <source>1) The new element is initialized as a copy of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1）新元素被初始化为 &lt;code&gt;value&lt;/code&gt; 的副本。</target>
        </trans-unit>
        <trans-unit id="805754d1d5d23696faf5387fb9f75302e9f3de82" translate="yes" xml:space="preserve">
          <source>1) The non-specialized &lt;code&gt;default_delete&lt;/code&gt; uses &lt;code&gt;delete&lt;/code&gt; to deallocate memory for a single object.</source>
          <target state="translated">1）非专业的 &lt;code&gt;default_delete&lt;/code&gt; 使用 &lt;code&gt;delete&lt;/code&gt; 来为单个对象释放内存。</target>
        </trans-unit>
        <trans-unit id="078ba3fdb2f0208dd9e2307c39e67cfe68c5c1db" translate="yes" xml:space="preserve">
          <source>1) The non-specialized &lt;code&gt;pointer_traits&lt;/code&gt; declares the following types:</source>
          <target state="translated">1）非专门的 &lt;code&gt;pointer_traits&lt;/code&gt; 声明以下类型：</target>
        </trans-unit>
        <trans-unit id="92f8554972361f85396cc946915b450c4ce836c2" translate="yes" xml:space="preserve">
          <source>1) The normal form of the path</source>
          <target state="translated">1)路径的正常形式</target>
        </trans-unit>
        <trans-unit id="7fcadaf3a1d0805d8241d4dcda9467625d082466" translate="yes" xml:space="preserve">
          <source>1) The operators works on valarrays of the same size and returns a valarray with the same size as the parameters with the operation applied to every elements of the two arguments.</source>
          <target state="translated">1)运算符作用于相同大小的值数组,并返回一个与参数大小相同的值数组,操作应用于两个参数的每个元素。</target>
        </trans-unit>
        <trans-unit id="2682843d9db3de2fe0979f65226c8ec0ffc4a1ff" translate="yes" xml:space="preserve">
          <source>1) The p distribution parameter.</source>
          <target state="translated">1)p分布参数。</target>
        </trans-unit>
        <trans-unit id="52a76b9c4dc5d777618976dffcda053ec848076c" translate="yes" xml:space="preserve">
          <source>1) The pointer to the beginning of the get area.</source>
          <target state="translated">1)获取区域开始的指针。</target>
        </trans-unit>
        <trans-unit id="2788ad850b2bbb3bcd1e26f30ae2197560170280" translate="yes" xml:space="preserve">
          <source>1) The pointer to the beginning of the put area.</source>
          <target state="translated">1)指向投放区域起点的指针。</target>
        </trans-unit>
        <trans-unit id="ecd0301c6f2ffe2d0819343a365dcb5dd5fc514c" translate="yes" xml:space="preserve">
          <source>1) The program is ill-formed if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="76d0af0682d39a23e608870d902e924d40731f41" translate="yes" xml:space="preserve">
          <source>1) The random number generator is implementation-defined, but the function &lt;code&gt;&lt;a href=&quot;../numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; is often used.</source>
          <target state="translated">1）随机数生成器是实现定义的，但经常使用函数 &lt;code&gt;&lt;a href=&quot;../numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fcb6ec55992b506b45ac666f76eb78e9d99e9237" translate="yes" xml:space="preserve">
          <source>1) The real part.</source>
          <target state="translated">1)真正的部分。</target>
        </trans-unit>
        <trans-unit id="04499347610e4d853510728a08aea977c3eea26d" translate="yes" xml:space="preserve">
          <source>1) The result of &lt;code&gt;lhs.equal(rhs)&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;lhs.equal(rhs)&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="acdfeea6d1916156d222310691b55c364fcf71aa" translate="yes" xml:space="preserve">
          <source>1) The result of dereferencing the stored pointer, i.e., &lt;code&gt;*get()&lt;/code&gt;</source>
          <target state="translated">1）解引用存储的指针的结果，即 &lt;code&gt;*get()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85369193a6efe2baa8eac212d4d41eca7c7a29a4" translate="yes" xml:space="preserve">
          <source>1) The return type is deduced from the returned expression as if by &lt;code&gt;decltype&lt;/code&gt;. The call is ill-formed if the invocation above is not a valid expression of the same type and value category, for all combinations of alternative types of all variants.</source>
          <target state="translated">1）从返回的表达式中推断出返回类型，就像通过 &lt;code&gt;decltype&lt;/code&gt; 一样。如果对于所有变体的替代类型的所有组合，上述调用不是同一类型和值类别的有效表达式，则调用格式错误。</target>
        </trans-unit>
        <trans-unit id="7a36ba71f6e55e9d3da53e756c59b3b06287b854" translate="yes" xml:space="preserve">
          <source>1) The return type meets the requirements of mutable &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">1）返回类型符合可变&lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="6d3e7aa24867d0d8995a957c6318cd61a05292ec" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="dae9b5cd9ae861b669c70c471b4d08d50f4c940b" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;seekpos(pos, which)&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;seekpos(pos, which)&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="898a982d82a90b60748ffe31055974436184caf1" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;setbuf(s, n)&lt;/code&gt;</source>
          <target state="translated">1） &lt;code&gt;setbuf(s, n)&lt;/code&gt; 的返回值</target>
        </trans-unit>
        <trans-unit id="1e96b281892b82cedb8d59abb7f447580daa3b5f" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;sync()&lt;/code&gt;.</source>
          <target state="translated">1） &lt;code&gt;sync()&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="7ca5f89c229d3f7753b51b3a66ee13e45d0b0f54" translate="yes" xml:space="preserve">
          <source>1) The source file is decomposed into &lt;a href=&quot;../comments&quot;&gt;comments&lt;/a&gt;, sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and</source>
          <target state="translated">1）源文件被分解为&lt;a href=&quot;../comments&quot;&gt;注释&lt;/a&gt;，空白字符序列（空格，水平制表符，换行，垂直制表符和换页），以及</target>
        </trans-unit>
        <trans-unit id="36843ad5bce393e021d99643d395dab108c20cf9" translate="yes" xml:space="preserve">
          <source>1) The sum of the given value and elements in the given range.</source>
          <target state="translated">1)给定值与给定范围内元素的和。</target>
        </trans-unit>
        <trans-unit id="3b61bf4f0d9f6b04457c1b40ba6668a669b49d56" translate="yes" xml:space="preserve">
          <source>1) The time of the last modification of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">1） &lt;code&gt;p&lt;/code&gt; 的最后修改时间</target>
        </trans-unit>
        <trans-unit id="79302ea48e89e5dd8b66c9d489a0b5d0f35c2a34" translate="yes" xml:space="preserve">
          <source>1) The unary operation &lt;code&gt;unary_op&lt;/code&gt; is applied to the range defined by &lt;code&gt;[first1, last1)&lt;/code&gt;.</source>
          <target state="translated">1）一元运算 &lt;code&gt;unary_op&lt;/code&gt; 应用于 &lt;code&gt;[first1, last1)&lt;/code&gt; 定义的范围。</target>
        </trans-unit>
        <trans-unit id="367330e87475392565d07397877349fb08e6bda2" translate="yes" xml:space="preserve">
          <source>1) The value &lt;code&gt;v&lt;/code&gt; stored in the shared state, as &lt;code&gt;std::move(v)&lt;/code&gt;.</source>
          <target state="translated">1）以共享状态存储的值 &lt;code&gt;v&lt;/code&gt; ，如 &lt;code&gt;std::move(v)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86eb511f8878afb18a55683fb47df9cdcc07ce8f" translate="yes" xml:space="preserve">
          <source>1) The value of A is used as an operand of B, &lt;b&gt;except&lt;/b&gt;</source>
          <target state="translated">1）A的值用作B的操作数，&lt;b&gt;除了&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7811702fe1807599a0bc78db6abc9c5bbdecab5f" translate="yes" xml:space="preserve">
          <source>1) The value of the</source>
          <target state="translated">(1)价值</target>
        </trans-unit>
        <trans-unit id="411cbaa6e8bdadb2ed80c96fcee27228278863bb" translate="yes" xml:space="preserve">
          <source>1) The value of the a parameter.</source>
          <target state="translated">1)a参数的值。</target>
        </trans-unit>
        <trans-unit id="ba3ffa0db89ccb1cd6d655154c05da75ee6c8142" translate="yes" xml:space="preserve">
          <source>1) The value of the obtained character.</source>
          <target state="translated">1)获得的字符值。</target>
        </trans-unit>
        <trans-unit id="d34b7e1f53cc8550900ee8f2d0ed3e332b4489a8" translate="yes" xml:space="preserve">
          <source>1) The value returned by the selected invocation of the visitor.</source>
          <target state="translated">1)被选中的访问者的调用所返回的值。</target>
        </trans-unit>
        <trans-unit id="12cff07a54521cd958ba1ef6524cdcabff900eb6" translate="yes" xml:space="preserve">
          <source>1) The version of this function in the non-specialized &lt;code&gt;&lt;a href=&quot;../pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; template simply calls &lt;code&gt;Ptr::pointer_to(r)&lt;/code&gt;, and if Ptr does not provide a static member function &lt;code&gt;pointer_to&lt;/code&gt;, instantiation of this function is a compile-time error.</source>
          <target state="translated">1）在非专业化的 &lt;code&gt;&lt;a href=&quot;../pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; 模板中，此函数的版本仅调用 &lt;code&gt;Ptr::pointer_to(r)&lt;/code&gt; ，如果Ptr没有提供静态成员函数 &lt;code&gt;pointer_to&lt;/code&gt; ，则此函数的实例化是编译时错误。</target>
        </trans-unit>
        <trans-unit id="77538230530c6dca9afa92eaff1c01d3485f9dd2" translate="yes" xml:space="preserve">
          <source>1) There is no putback position in the get area (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments). In this situation, the purpose of &lt;code&gt;pbackfail()&lt;/code&gt; is to back up the get area by one character, if the associated character sequence allows this (e.g. a file-backed streambuf may reload the buffer from a file, starting one character earlier).</source>
          <target state="translated">1）在get区域中没有回退位置（ &lt;code&gt;pbackfail()&lt;/code&gt; 带任何参数调用pbackfail（））。在这种情况下， &lt;code&gt;pbackfail()&lt;/code&gt; 的目的是，如果关联的字符序列允许此操作，则通过一个字符备份get区域（例如，文件支持的streambuf可以从文件中重新加载缓冲区，更早地开始一个字符）。</target>
        </trans-unit>
        <trans-unit id="082233e2ccf1fae9f66efcf578a3583588a32ecb" translate="yes" xml:space="preserve">
          <source>1) There may be &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;more than one definition&lt;/a&gt; of an inline function or variable(since C++17) in the program as long as each definition appears in a different translation unit and (for non-static inline functions and variables(since C++17)) all definitions are identical. For example, an inline function or an inline variable(since C++17) may be defined in a header file that is #include'd in multiple source files.</source>
          <target state="translated">1）程序中的内联函数或变量（自C ++ 17起）可能有&lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;多个定义&lt;/a&gt;，只要每个定义出现在不同的翻译单元中（对于非静态内联函数和变量（自C +起， +17））所有定义都相同。例如，可以在包含在多个源文件中的头文件中定义内联函数或内联变量（自C ++ 17起）。</target>
        </trans-unit>
        <trans-unit id="7d6e10081835eca22b9e463651b1d3a90697a7c7" translate="yes" xml:space="preserve">
          <source>1) This &lt;a href=&quot;../../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; to allow deduction from functions.</source>
          <target state="translated">1）此&lt;a href=&quot;../../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为 &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 提供的，以允许从函数推论。</target>
        </trans-unit>
        <trans-unit id="e77ab4d038ceec4a1c67d2938de66955af3e7eb7" translate="yes" xml:space="preserve">
          <source>1) This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">1）此&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 提供的，以允许从迭代器范围进行推导。仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;并且 &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator时，&lt;/a&gt;此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="4e69d6a2bc178876f9e3235945528240ffcb9250" translate="yes" xml:space="preserve">
          <source>1) This overload only participates in overload resolution if T is not a specialization of std::pair. Returns &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; determined as follows:</source>
          <target state="translated">1）如果T不是std :: pair的特化，则此重载仅参与重载解析。返回 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 确定如下：</target>
        </trans-unit>
        <trans-unit id="5fbbf8a15549659900cafa2f8939bbc4169ae318" translate="yes" xml:space="preserve">
          <source>1) Throws a &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; if the conversion is ambiguous. Throws a &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; if &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time.</source>
          <target state="translated">1）如果转换不 &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; 则抛出std :: chrono :: ambiguous_local_time。如果 &lt;code&gt;tp&lt;/code&gt; 表示不存在的时间，则抛出 &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2906ceaa024eb508139cc21c6337dbb9e099baa0" translate="yes" xml:space="preserve">
          <source>1) Throws an exception if the conversion is ambiguous or if &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time.</source>
          <target state="translated">1）如果转换不明确或 &lt;code&gt;tp&lt;/code&gt; 表示不存在时间，则引发异常。</target>
        </trans-unit>
        <trans-unit id="c11d4dcc55409becc8aa818ff21922ca67ab791c" translate="yes" xml:space="preserve">
          <source>1) Throws any exceptions thrown by &lt;code&gt;m.lock()&lt;/code&gt;</source>
          <target state="translated">1）抛出 &lt;code&gt;m.lock()&lt;/code&gt; 抛出的任何异常</target>
        </trans-unit>
        <trans-unit id="843bb0e7d49c747ed1e190035bed5b051758038e" translate="yes" xml:space="preserve">
          <source>1) Throws any exceptions thrown by &lt;code&gt;m.lock()&lt;/code&gt;.</source>
          <target state="translated">1）抛出 &lt;code&gt;m.lock()&lt;/code&gt; 抛出的任何异常。</target>
        </trans-unit>
        <trans-unit id="50ee3b5d9f3ed3870841a5598217596f3a883f2a" translate="yes" xml:space="preserve">
          <source>1) Transfers all elements from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The elements are inserted before the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The behavior is undefined if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1）将 &lt;code&gt;other&lt;/code&gt; 所有元素转移到 &lt;code&gt;*this&lt;/code&gt; 。元素插入 &lt;code&gt;pos&lt;/code&gt; 指向的元素之前。操作后， &lt;code&gt;other&lt;/code&gt; 容器变空。如果 &lt;code&gt;other&lt;/code&gt; 指向与 &lt;code&gt;*this&lt;/code&gt; 相同的对象，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="6fff766c5a8c7a2f8e138a2e07caea5eb67929f1" translate="yes" xml:space="preserve">
          <source>1) Transfers ownership from &lt;code&gt;r&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; as if by calling &lt;code&gt;reset(r.release())&lt;/code&gt; followed by an assignment of &lt;code&gt;&lt;a href=&quot;get_deleter&quot;&gt;get_deleter()&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;E&amp;gt;(r.get_deleter())&lt;/code&gt;.</source>
          <target state="translated">1）所有权转移从 &lt;code&gt;r&lt;/code&gt; 到 &lt;code&gt;*this&lt;/code&gt; ，仿佛调用 &lt;code&gt;reset(r.release())&lt;/code&gt; ，随后的分配 &lt;code&gt;&lt;a href=&quot;get_deleter&quot;&gt;get_deleter()&lt;/a&gt;&lt;/code&gt; 从 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;E&amp;gt;(r.get_deleter())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f0d222c1ebe564b2e355ea589fe01bb4acb55570" translate="yes" xml:space="preserve">
          <source>1) Trivial default constructor, initializes &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to unspecified state.</source>
          <target state="translated">1）简单的默认构造函数，将 &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 初始化为未指定状态。</target>
        </trans-unit>
        <trans-unit id="fae808fef90ab07a5794289ac4c023c5fa8d10a8" translate="yes" xml:space="preserve">
          <source>1) Turns off the &lt;code&gt;skipws&lt;/code&gt; flag on the input stream</source>
          <target state="translated">1）关闭输入流上的 &lt;code&gt;skipws&lt;/code&gt; 标志</target>
        </trans-unit>
        <trans-unit id="4dfdb643b8926ec8e33691a11829911540004f8c" translate="yes" xml:space="preserve">
          <source>1) Two possibly multilevel pointers to the same type may be converted between each other, regardless of cv-qualifiers at each level.</source>
          <target state="translated">1)两个可能是多级指向同一类型的指针可以相互转换,不管每一级的cv-限定符是什么。</target>
        </trans-unit>
        <trans-unit id="b27ef1c6720ded3dab7eb347fb4e754d45f36dfc" translate="yes" xml:space="preserve">
          <source>1) Typical declaration of a destructor</source>
          <target state="translated">1)典型的析构器声明</target>
        </trans-unit>
        <trans-unit id="c4708cafcd797737afa27ba9753427840fb5b5fb" translate="yes" xml:space="preserve">
          <source>1) Unary right fold (E op ...) becomes (E</source>
          <target state="translated">1)一元对折(E op...)变成(E</target>
        </trans-unit>
        <trans-unit id="257eeefa2a69c169c4e78577629e312d119acf41" translate="yes" xml:space="preserve">
          <source>1) Underflow occurs (and &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; may be raised) if a computation produces a result whose absolute value, computed as though both the exponent range and the precision were unbounded, is smaller than &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt;. Such implementation detects tinyness before rounding (e.g. UltraSparc, POWER).</source>
          <target state="translated">1）如果计算产生的结果的绝对值小于 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; &amp;lt;T&amp;gt; :: min（），则发生下溢（并且可能会提高 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; ）。这样的实现在四舍五入之前会检测到微小（例如UltraSparc，POWER）。</target>
        </trans-unit>
        <trans-unit id="5cd6d3f996be4c51f3f6895463d6cd072a7b915f" translate="yes" xml:space="preserve">
          <source>1) Unlinks the node that contains the element pointed to by &lt;code&gt;position&lt;/code&gt; and returns a &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt; that owns it</source>
          <target state="translated">1）取消链接包含由 &lt;code&gt;position&lt;/code&gt; 指向的元素的节点，并返回拥有它的&lt;a href=&quot;../node_handle&quot;&gt;节点句柄&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f8ce56ad604ec015f939e3d33efff5a54fb49aa" translate="yes" xml:space="preserve">
          <source>1) Unspecified (typically same as &lt;code&gt;Ptr::pointer_to&lt;/code&gt;)</source>
          <target state="translated">1）未指定（通常与 &lt;code&gt;Ptr::pointer_to&lt;/code&gt; 相同）</target>
        </trans-unit>
        <trans-unit id="2316f7e9cdbdf01d620f24a734118320daa43c7c" translate="yes" xml:space="preserve">
          <source>1) Used to obtain the iterator type of the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1）用于获取类型 &lt;code&gt;T&lt;/code&gt; 的迭代器类型。</target>
        </trans-unit>
        <trans-unit id="4cb8f5cd2ca3417e49783847dbe0430c7912497b" translate="yes" xml:space="preserve">
          <source>1) Value of the &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; referred to by this iterator</source>
          <target state="translated">1）此迭代器引用的&lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; 的&lt;/a&gt;值</target>
        </trans-unit>
        <trans-unit id="aba73510e6e868d87c0be08e6f8342096504cd67" translate="yes" xml:space="preserve">
          <source>1) When a named &lt;a href=&quot;reference#Lvalue_references&quot;&gt;lvalue reference&lt;/a&gt; variable is declared with an initializer</source>
          <target state="translated">1）当使用初始化程序声明命名的&lt;a href=&quot;reference#Lvalue_references&quot;&gt;左值引用&lt;/a&gt;变量时</target>
        </trans-unit>
        <trans-unit id="d0bcc30ae3863a5e08bd6f03dc42a4e874ce1e74" translate="yes" xml:space="preserve">
          <source>1) When class member declarations and member function type declarations appear in a &lt;code&gt;&quot;C&quot;&lt;/code&gt; language block, their linkage remains &lt;code&gt;&quot;C++&quot;&lt;/code&gt;.</source>
          <target state="translated">1）当类成员声明和成员函数类型声明出现在 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 语言块中时，它们的链接仍为 &lt;code&gt;&quot;C++&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3820fb6503add189fb9d0185eccf94528cea1c0" translate="yes" xml:space="preserve">
          <source>1) When the</source>
          <target state="translated">1)当</target>
        </trans-unit>
        <trans-unit id="7b36527e4c99ad21a3b5acc56406892e9699bef5" translate="yes" xml:space="preserve">
          <source>1) Whenever backslash appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation; a line ending in two backslashes followed by an empty line does not combine three lines into one. If a universal character name (&lt;code&gt;\uXXXX&lt;/code&gt;) is formed in this phase, the behavior is undefined.</source>
          <target state="translated">1）每当反斜杠出现在行尾（紧跟换行符）时，都会同时删除反斜杠和换行符，从而将两条物理源代码行合并为一条逻辑源代码行。这是一次单次通过操作；以两个反斜杠结尾且后接空行的行不会将三行合并为一个。如果在此阶段形成通用字符名称（ &lt;code&gt;\uXXXX&lt;/code&gt; ），则行为未定义。</target>
        </trans-unit>
        <trans-unit id="84212c704512f8a7c5c7f860970eb1e0b2a423f0" translate="yes" xml:space="preserve">
          <source>1) Within the body of any non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt;, including &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt;</source>
          <target state="translated">1）在任何非静态&lt;a href=&quot;member_functions&quot;&gt;成员函数&lt;/a&gt;的主体内，包括&lt;a href=&quot;constructor&quot;&gt;成员初始化程序列表&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="575e5597bcb538c0ad9a57aef9059faafb04f903" translate="yes" xml:space="preserve">
          <source>1) Wraps a non-const member function with no parameters.</source>
          <target state="translated">1)包裹一个没有参数的非const成员函数。</target>
        </trans-unit>
        <trans-unit id="7d767b3af0e8610ce09659c8206561af10fa3322" translate="yes" xml:space="preserve">
          <source>1) Writes a textual representation of the distribution parameters and internal state to &lt;code&gt;ost&lt;/code&gt; as textual representation. The formatting flags and fill character of &lt;code&gt;ost&lt;/code&gt; are unchanged.</source>
          <target state="translated">1）将分布参数和内部状态的文本表示形式写入 &lt;code&gt;ost&lt;/code&gt; 。 &lt;code&gt;ost&lt;/code&gt; 的格式标志和填充字符不变。</target>
        </trans-unit>
        <trans-unit id="d9c461a040145efb71a7d3ac968e14b99a1e726a" translate="yes" xml:space="preserve">
          <source>1) Writes performed by the same thread that performed A</source>
          <target state="translated">1)由执行A的同一线程执行的写。</target>
        </trans-unit>
        <trans-unit id="0a2b6a35046c21b8b1cdded7e012e4e02b54a352" translate="yes" xml:space="preserve">
          <source>1) Writes the bitset &lt;code&gt;x&lt;/code&gt; to the character stream &lt;code&gt;os&lt;/code&gt; as if by first converting it to a &lt;code&gt;basic_string&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;to_string&quot;&gt;to_string()&lt;/a&gt;&lt;/code&gt;, and then writing it into &lt;code&gt;os&lt;/code&gt; using the &lt;a href=&quot;../../string/basic_string/operator_ltltgtgt&quot;&gt;&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; (which is a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; for strings). The characters to use for ones and zeroes are obtained from the currently-imbued locale by calling &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;(os.getloc()).widen()&lt;/code&gt; with &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'0'&lt;/code&gt; as arguments.</source>
          <target state="translated">1）将bitset &lt;code&gt;x&lt;/code&gt; 写入字符流 &lt;code&gt;os&lt;/code&gt; ，就好象首先通过使用 &lt;code&gt;&lt;a href=&quot;to_string&quot;&gt;to_string()&lt;/a&gt;&lt;/code&gt; 将其转换为 &lt;code&gt;basic_string&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; ，然后使用&lt;a href=&quot;../../string/basic_string/operator_ltltgtgt&quot;&gt; &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt;（这是用于字符串的&lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;）将其写入 &lt;code&gt;os&lt;/code&gt; 一样。的字符使用1和0被从当前充满区域设置通过调用获得 &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;(os.getloc()).widen()&lt;/code&gt; &amp;lt; &lt;a href=&quot;../../locale/ctype&quot;&gt;性病:: CTYPE&lt;/a&gt; &amp;lt;图表&amp;gt;（os.getloc（））。加宽（）用 &lt;code&gt;'1'&lt;/code&gt; 和 &lt;code&gt;'0'&lt;/code&gt; 作为论点。</target>
        </trans-unit>
        <trans-unit id="db026f9be530b92309db59bd7e0e007f78c55584" translate="yes" xml:space="preserve">
          <source>1) Writes the results to &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1）将结果写入 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ca66f352a8a2c3fbfbb18ec52c430b1d4c5c3b4" translate="yes" xml:space="preserve">
          <source>1) Writes to &lt;code&gt;os&lt;/code&gt; the complex number in the form &lt;code&gt;(real,imaginary)&lt;/code&gt;.</source>
          <target state="translated">1）以 &lt;code&gt;(real,imaginary)&lt;/code&gt; 形式向 &lt;code&gt;os&lt;/code&gt; 写复数。</target>
        </trans-unit>
        <trans-unit id="ccfe5f32416ac78a6db71cb95900b356b4fac608" translate="yes" xml:space="preserve">
          <source>1) Yields the size in bytes of the &lt;a href=&quot;objects&quot;&gt;object representation&lt;/a&gt; of type.</source>
          <target state="translated">1）产生类型的&lt;a href=&quot;objects&quot;&gt;对象表示形式&lt;/a&gt;的大小（以字节为单位）。</target>
        </trans-unit>
        <trans-unit id="bf3ab90f79f6983b5959522a0d973a0239a4ed67" translate="yes" xml:space="preserve">
          <source>1) a copy of the &lt;code&gt;std::chrono::month&lt;/code&gt; object stored in &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1）存储在 &lt;code&gt;*this&lt;/code&gt; 中的 &lt;code&gt;std::chrono::month&lt;/code&gt; 对象的副本</target>
        </trans-unit>
        <trans-unit id="f9872d13b34d100347a4789dbcf716915a245364" translate="yes" xml:space="preserve">
          <source>1) a copy of the argument, &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(val)&lt;/code&gt;</source>
          <target state="translated">1）参数 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(val)&lt;/code&gt; &amp;lt;T&amp;gt;（val）的副本</target>
        </trans-unit>
        <trans-unit id="5641277263a9a2b3de3620beebf734b8386a9a9d" translate="yes" xml:space="preserve">
          <source>1) a copy of the underlying string object.</source>
          <target state="translated">1)底层字符串对象的副本。</target>
        </trans-unit>
        <trans-unit id="5c3bdc31cd27db3964c2112a2726a87812d74790" translate="yes" xml:space="preserve">
          <source>1) a copy of this duration object</source>
          <target state="translated">1)该持续时间对象的副本</target>
        </trans-unit>
        <trans-unit id="038d7ce390c65cda2b59d3877a61b171fd122d75" translate="yes" xml:space="preserve">
          <source>1) a declaration of a class member</source>
          <target state="translated">1)一个类成员的声明</target>
        </trans-unit>
        <trans-unit id="d9e22ca8e57fb001efaf8220898429709ee9f67f" translate="yes" xml:space="preserve">
          <source>1) a variable &lt;code&gt;x&lt;/code&gt; in a</source>
          <target state="translated">1）的变量 &lt;code&gt;x&lt;/code&gt; 在</target>
        </trans-unit>
        <trans-unit id="2b6abfcba2f16f34c4b766c8332a1b0e568f8205" translate="yes" xml:space="preserve">
          <source>1) addition</source>
          <target state="translated">1)加法</target>
        </trans-unit>
        <trans-unit id="a2d89e8d3bf7717ac619bee8df3e581c758d7c08" translate="yes" xml:space="preserve">
          <source>1) additional &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;default-inserted&lt;/a&gt; elements are appended</source>
          <target state="translated">1）附加了其他&lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;默认插入的&lt;/a&gt;元素</target>
        </trans-unit>
        <trans-unit id="ac7f27c304fab3327d4825700e7346a78e13d81e" translate="yes" xml:space="preserve">
          <source>1) additional &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;default-inserted&lt;/a&gt; elements are appended 2) additional copies of &lt;code&gt;value&lt;/code&gt; are appended</source>
          <target state="translated">1）附加&lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;默认插入&lt;/a&gt;元件被所附2）的额外拷贝 &lt;code&gt;value&lt;/code&gt; 被附加</target>
        </trans-unit>
        <trans-unit id="6430a3b1d8a483dd3a81fb0ac4d2a6320ef9e24a" translate="yes" xml:space="preserve">
          <source>1) adds both &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="translated">1）同时添加 &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;volatile&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d59d7e196d66c2c5698b37c5fed11d45adb3fba0" translate="yes" xml:space="preserve">
          <source>1) amortized constant</source>
          <target state="translated">1)摊销不变</target>
        </trans-unit>
        <trans-unit id="fec155bd296ef9eab4b5d4cff65799934437e2a4" translate="yes" xml:space="preserve">
          <source>1) an &lt;a href=&quot;../language/throw&quot;&gt;exception is thrown&lt;/a&gt; and not caught (it is implementation-defined whether any stack unwinding is done in this case)</source>
          <target state="translated">1）&lt;a href=&quot;../language/throw&quot;&gt;引发&lt;/a&gt;而不捕获异常（在这种情况下，是否完成堆栈的展开是实现定义的）</target>
        </trans-unit>
        <trans-unit id="0795e639e2d423d045556b10922218964d38d551" translate="yes" xml:space="preserve">
          <source>1) array length is negative.</source>
          <target state="translated">1)阵列长度为负数。</target>
        </trans-unit>
        <trans-unit id="b0fb04259e9dabc8e1469a331eb44c9e0e5ae305" translate="yes" xml:space="preserve">
          <source>1) as soon as atomic operations that are not tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; enter the picture, the sequential consistency guarantee for the program is lost 2) in many cases, &lt;code&gt;memory_order_seq_cst&lt;/code&gt; atomic operations are reorderable with respect to other atomic operations performed by the same thread</source>
          <target state="translated">1）没有标记 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 的原子操作一旦进入画面，程序的顺序一致性保证就会丢失2）在许多情况下， &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 原子操作相对于同一线程执行的其他原子操作是可重新排序的</target>
        </trans-unit>
        <trans-unit id="2e8ab0d12b743aef878ea9e6130cac353570c696" translate="yes" xml:space="preserve">
          <source>1) as soon as atomic operations that are not tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; enter the picture, the sequential consistency is lost 2) the sequentially-consistent fences are only establishing total ordering for the fences themselves, not for the atomic operations in the general case (</source>
          <target state="translated">1）没有标记为 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 的原子操作一旦进入图片，顺序一致性就会丢失2）顺序一致的栅栏仅对栅栏本身建立总排序，在一般情况下不对原子操作建立总排序（</target>
        </trans-unit>
        <trans-unit id="27196f9d734245d194416b40b601d5214e843c87" translate="yes" xml:space="preserve">
          <source>1) base template</source>
          <target state="translated">1)基本模板</target>
        </trans-unit>
        <trans-unit id="cb41c99c432b78323d4f377b74a0c397256353fa" translate="yes" xml:space="preserve">
          <source>1) bitwise NOT</source>
          <target state="translated">1)位上不</target>
        </trans-unit>
        <trans-unit id="f724933955aea428b179d4bd6c5ef4df12c510d5" translate="yes" xml:space="preserve">
          <source>1) buffer state, a bitmask type which can represent any combination of the four values &quot;allocated&quot; (destructor will deallocate), &quot;constant&quot; (output not allowed), &quot;dynamic&quot; (output may reallocate), or &quot;frozen&quot; (deallocation and reallocation are not allowed)</source>
          <target state="translated">1)缓冲区状态,是一个比特掩码类型,它可以代表 &quot;分配&quot;(destructor将deallocate)、&quot;常量&quot;(不允许输出)、&quot;动态&quot;(输出可以重分配)或 &quot;冻结&quot;(不允许deallocation和reallocation)四个值的任意组合。</target>
        </trans-unit>
        <trans-unit id="9bd596e30c7448227178639da643b5d2845998b0" translate="yes" xml:space="preserve">
          <source>1) by the members and friends of &lt;code&gt;Base&lt;/code&gt;</source>
          <target state="translated">1）由 &lt;code&gt;Base&lt;/code&gt; 的成员和朋友</target>
        </trans-unit>
        <trans-unit id="de134b2dabb1a0cc9228c6962d95367bc50eab97" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</source>
          <target state="translated">1）调用 &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c34ba446a37c84b0cf54a590242f4ba5233f98dd" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</source>
          <target state="translated">1）调用 &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77e091034262c03ebbe67a594c859ba4cd168524" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">1）调用 &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26e3683b3a1f07d2796ab25306d2631c55c16c20" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtoul&quot;&gt;std::strtoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstoul&quot;&gt;std::wcstoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">1）调用 &lt;code&gt;&lt;a href=&quot;../byte/strtoul&quot;&gt;std::strtoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../wide/wcstoul&quot;&gt;std::wcstoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aaa2f9b040d07d7262ac1b6d9ffdb1abe31c9d94" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;buf.set_emit_on_sync(true)&lt;/code&gt;</source>
          <target state="translated">1）调用 &lt;code&gt;buf.set_emit_on_sync(true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c82f9dfecce0de1545c8b1bc95f3a2951730d87a" translate="yes" xml:space="preserve">
          <source>1) comma-separated list of arbitrary expressions and braced-init-lists in parentheses</source>
          <target state="translated">1)以逗号分隔的任意表达式列表,并在括号中加入括号-init-list。</target>
        </trans-unit>
        <trans-unit id="292744bfc0b144652fe365e89093b1f3f3546203" translate="yes" xml:space="preserve">
          <source>1) conjunctions</source>
          <target state="translated">(1)连词</target>
        </trans-unit>
        <trans-unit id="a27605e813fa2e284a617a94d0b1c02a41db1130" translate="yes" xml:space="preserve">
          <source>1) constant</source>
          <target state="translated">1)常数</target>
        </trans-unit>
        <trans-unit id="04557674944b51204be3247544693f0e0724501f" translate="yes" xml:space="preserve">
          <source>1) constructs an object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt;, &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-non-list-initialized&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;, as the contained object. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, Args...&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1）构建类型的对象 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; ，&lt;a href=&quot;../../language/direct_initialization&quot;&gt;直接非列表初始化&lt;/a&gt;从 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; ，作为所包含的对象。仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, Args...&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 时,此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="ecf7299f36a57142311fe5ff018991aec05d1d9b" translate="yes" xml:space="preserve">
          <source>1) counts the elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1）计算等于 &lt;code&gt;value&lt;/code&gt; 的元素。</target>
        </trans-unit>
        <trans-unit id="78923f4701cc466ff69a7e4c618b38c216680976" translate="yes" xml:space="preserve">
          <source>1) creates a facet with starting reference count &lt;code&gt;refs&lt;/code&gt;. If &lt;code&gt;refs&lt;/code&gt; is non-zero, the facet will not be deleted when the last locale referencing it goes out of scope. A facet with static or dynamic storage duration should always be constructed with a non-zero &lt;code&gt;refs&lt;/code&gt;.</source>
          <target state="translated">1）创建具有起始参考计数 &lt;code&gt;refs&lt;/code&gt; 的构面。如果 &lt;code&gt;refs&lt;/code&gt; 非零，则当最后一个引用该区域的语言环境超出范围时，该构面将不会被删除。具有静态或动态存储持续时间的构面应始终使用非零 &lt;code&gt;refs&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="16f7bc88ebe12e9f46129bbcbe37a17442c63648" translate="yes" xml:space="preserve">
          <source>1) current maximum load factor.</source>
          <target state="translated">1)当前最大负荷系数。</target>
        </trans-unit>
        <trans-unit id="020d736193c4f224afbc308288813ddd03120330" translate="yes" xml:space="preserve">
          <source>1) declares a scoped enumeration type whose underlying type is &lt;code&gt;int&lt;/code&gt; (the keywords &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt; are exactly equivalent) 2) declares a scoped enumeration type whose underlying type is type3) opaque enum declaration for a scoped enumeration whose underlying type is &lt;code&gt;int&lt;/code&gt;4) opaque enum declaration for a scoped enumeration whose underlying type is type</source>
          <target state="translated">1）声明其基础类型为 &lt;code&gt;int&lt;/code&gt; 的作用域枚举类型（关键字 &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;struct&lt;/code&gt; 完全等效）2）声明其基础类型为type的作用域枚举类型3）不透明的枚举，其基础类型为 &lt;code&gt;int&lt;/code&gt; 的作用域枚举声明4）opaque基本类型为type的作用域枚举的枚举声明</target>
        </trans-unit>
        <trans-unit id="9a00831c1516deb4278ae9da70bb95962035c0b1" translate="yes" xml:space="preserve">
          <source>1) default constructor: creates an object of type &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; with implementation-specific content.</source>
          <target state="translated">1）默认构造函数：创建一个类型为 &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; 的对象，其中包含特定于实现的内容。</target>
        </trans-unit>
        <trans-unit id="dde1237e4c299d5a88703d284c2d9f1b0330d7bc" translate="yes" xml:space="preserve">
          <source>1) destructors of objects with static storage duration are called in reverse order of completion of their constructors or the completion of their &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;dynamic initialization&lt;/a&gt;, and the functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are called in reverse order they are registered (last one first). a) any static objects whose initialization was completed before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F will be destroyed after the call to F during program termination. b) any static objects whose construction began after the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F will be destroyed before the call to F during program termination (this includes the case where &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; was called from the constructor of the static object)</source>
          <target state="translated">1）具有静态存储持续时间的对象的析构函数以其构造函数完成或&lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;动态初始化&lt;/a&gt;完成的相反顺序被调用，传递给 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 的函数以相反的顺序被调用，它们被注册（最后一个优先）。 a）在某些函数F 调用 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 之前初始化已完成的所有静态对象，在程序终止期间对F的调用之后将被销毁。 b）任何静态对象的构造在调用某些函数F的 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 之后开始构造的，都将在程序终止期间在调用F之前销毁（这包括从静态对象的构造函数调用 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 的情况））</target>
        </trans-unit>
        <trans-unit id="dcf7f086d26c92140d5665521d6f972ea28b4075" translate="yes" xml:space="preserve">
          <source>1) elaborated type specifier for a class type</source>
          <target state="translated">1)类型的详细类型说明者。</target>
        </trans-unit>
        <trans-unit id="6160fe4e565fb3d9b2b12c87b05a83e491dcc6e4" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showbase&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showbase&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1）像调用 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showbase&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: showbase&lt;/a&gt;）一样在流 &lt;code&gt;str&lt;/code&gt; 中启用 &lt;code&gt;showbase&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="3c9bb54bfcf8d4b0934ee7a2b61ffada58ca8f70" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showpoint&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpoint&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1）启用流 &lt;code&gt;str&lt;/code&gt; 中的 &lt;code&gt;showpoint&lt;/code&gt; 标志，就像通过调用 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpoint&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: showpoint&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="5cbc68830f2af6be690ee57ddb1a020743ee8a1f" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showpos&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpos&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1）像调用 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpos&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: showpos&lt;/a&gt;）一样在流 &lt;code&gt;str&lt;/code&gt; 中启用 &lt;code&gt;showpos&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="ec4fee75897569d1ba002fd796b242776e66d768" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;skipws&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::skipws&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1）启用流 &lt;code&gt;str&lt;/code&gt; 中的 &lt;code&gt;skipws&lt;/code&gt; 标志，就像通过调用 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::skipws&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: skipws&lt;/a&gt;）一样。</target>
        </trans-unit>
        <trans-unit id="e78cc3813053d3dcc3353f63d38c9f3c40480169" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;unitbuf&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1）启用流 &lt;code&gt;str&lt;/code&gt; 中的 &lt;code&gt;unitbuf&lt;/code&gt; 标志，就像通过调用 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: unitbuf&lt;/a&gt;）一样。</target>
        </trans-unit>
        <trans-unit id="e6c512f457d94c1407d26442e22f6caaa812de6e" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;uppercase&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::uppercase&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1）启用流 &lt;code&gt;str&lt;/code&gt; 中的 &lt;code&gt;uppercase&lt;/code&gt; 标志，就像通过调用 &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::uppercase&lt;/a&gt;)&lt;/code&gt; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std :: ios_base :: uppercase&lt;/a&gt;）一样。</target>
        </trans-unit>
        <trans-unit id="fca12c96ad1be6c8785cc47ea43d3c81665b28d0" translate="yes" xml:space="preserve">
          <source>1) expression statements;</source>
          <target state="translated">1)表达式语句。</target>
        </trans-unit>
        <trans-unit id="4f15378fe06eb783737d9e09aa30928eef4d729d" translate="yes" xml:space="preserve">
          <source>1) forms a literal &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; with the real part zero and imaginary part &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">1）与实数部分零和虚数部分 &lt;code&gt;arg&lt;/code&gt; 形成文字 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1be539d05656ffe16187d9f074b5f435a3f1a78" translate="yes" xml:space="preserve">
          <source>1) function parameter of a function template declared as rvalue reference to cv-unqualified &lt;a href=&quot;template_parameters&quot;&gt;type template parameter&lt;/a&gt; of that same function template:</source>
          <target state="translated">1）声明为右值引用的函数模板的函数参数引用同一函数模板的cv-不合格&lt;a href=&quot;template_parameters&quot;&gt;类型模板参数&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="933951affe5827f2ddb2f2c9addfe63c922b58e8" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;static&quot;&gt;static data member&lt;/a&gt;:</source>
          <target state="translated">1）如果 &lt;code&gt;E2&lt;/code&gt; 是&lt;a href=&quot;static&quot;&gt;静态数据成员&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f24447a09ca19b04649b1c980278aea007b7651a" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;E2&lt;/code&gt; is a pointer to data member,</source>
          <target state="translated">1）如果 &lt;code&gt;E2&lt;/code&gt; 是指向数据成员的指针，</target>
        </trans-unit>
        <trans-unit id="fd8cbf371492e8ec4bdc5da5949d838ae310b0b6" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a class type with at least one user-provided constructor of any kind, the &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt; is called; 2) if &lt;code&gt;T&lt;/code&gt; is a non-union class type without any user-provided constructors, every non-static data member and base-class component of T is value-initialized;</source>
          <target state="translated">1）如果 &lt;code&gt;T&lt;/code&gt; 是具有至少一个用户提供的任何类型的构造函数的类类型，则调用&lt;a href=&quot;default_constructor&quot;&gt;默认构造函数&lt;/a&gt;；2）如果 &lt;code&gt;T&lt;/code&gt; 是没有用户提供的构造函数的非联合类类型，则T的每个非静态数据成员和基类组件都将被值初始化；</target>
        </trans-unit>
        <trans-unit id="cc5cbe2c36375ecb8459cbffdcc5e56194637eb7" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a class type with no default constructor or with a user-provided or deleted default constructor, the object is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;; 2) if &lt;code&gt;T&lt;/code&gt; is a class type with a default constructor that is neither user-provided nor deleted (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is &lt;a href=&quot;zero_initialization&quot;&gt;zero-initialized&lt;/a&gt; and then it is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt; if it has a non-trivial default constructor;</source>
          <target state="translated">1）如果 &lt;code&gt;T&lt;/code&gt; 是没有默认构造函数或具有用户提供或删除的默认构造函数的类类型，则该对象将被&lt;a href=&quot;default_initialization&quot;&gt;默认初始化&lt;/a&gt;；2）如果 &lt;code&gt;T&lt;/code&gt; 是具有默认构造函数的类类型，该构造函数既不是用户提供的也不是未删除的（也就是说，它可能是带有隐式定义或默认默认构造函数的类），则将该对象&lt;a href=&quot;zero_initialization&quot;&gt;初始化为零&lt;/a&gt;，然后将其如果具有非平凡的默认构造&lt;a href=&quot;default_initialization&quot;&gt;函数，&lt;/a&gt;则默认初始化；</target>
        </trans-unit>
        <trans-unit id="2567e503e479ddfa34c6e4c7e7e466e63c7a9083" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes one argument of type &lt;code&gt;A1&lt;/code&gt;, then &lt;code&gt;argument_type&lt;/code&gt; is &lt;code&gt;A1&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;T&lt;/code&gt; 是采用一个类型为 &lt;code&gt;A1&lt;/code&gt; 的参数的函数或指向函数的指针，则 &lt;code&gt;argument_type&lt;/code&gt; 为 &lt;code&gt;A1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05248e1e5cafa82d974bc4d2920820bbd80169d6" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes two arguments of type s &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt;, then &lt;code&gt;second_argument_type&lt;/code&gt; is &lt;code&gt;A2&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;T&lt;/code&gt; 是采用两个类型为s &lt;code&gt;A1&lt;/code&gt; 和 &lt;code&gt;A2&lt;/code&gt; 的参数的函数或指向函数的指针，则 &lt;code&gt;second_argument_type&lt;/code&gt; 为 &lt;code&gt;A2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ccfd08717e620a2adb1e880c6d6d8a684f02c9b9" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes two arguments of types &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt;, then &lt;code&gt;first_argument_type&lt;/code&gt; is &lt;code&gt;A1&lt;/code&gt;.</source>
          <target state="translated">1）如果 &lt;code&gt;T&lt;/code&gt; 是采用两个类型为 &lt;code&gt;A1&lt;/code&gt; 和 &lt;code&gt;A2&lt;/code&gt; 的参数的函数或指向函数的指针，则 &lt;code&gt;first_argument_type&lt;/code&gt; 为 &lt;code&gt;A1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a431179612485d24bc273e5248075c581ebeb99d" translate="yes" xml:space="preserve">
          <source>1) if A and B are &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, and A</source>
          <target state="translated">1）如果A和B是 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 操作，而A</target>
        </trans-unit>
        <trans-unit id="649d80319d06d238094897a0c7387db3f34a9dba" translate="yes" xml:space="preserve">
          <source>1) initialization of a named variable with a</source>
          <target state="translated">1)初始化一个命名的变量,用一个</target>
        </trans-unit>
        <trans-unit id="1368a73e49095bf4c57e55786671e41410e57ea6" translate="yes" xml:space="preserve">
          <source>1) initialization with a nonempty parenthesized list of expressions or braced-init-lists(since C++11)</source>
          <target state="translated">1)用一个非空的大括号的表达式列表或带括号的init-list进行初始化(自C++11起)</target>
        </trans-unit>
        <trans-unit id="99f4faeed3de5d70f2b4ff261841eff7c00945ba" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::hours&lt;/a&gt;(hrs)&lt;/code&gt;</source>
          <target state="translated">1）整数文字，精确返回 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::hours&lt;/a&gt;(hrs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b87dde5587a9a2ce938326ff6f293bb389b57a11" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::microseconds&lt;/a&gt;(us)&lt;/code&gt;</source>
          <target state="translated">1）整数文字，精确返回 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::microseconds&lt;/a&gt;(us)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73237f5b88515e9f07510adba322ff008703bf77" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::milliseconds&lt;/a&gt;(ms)&lt;/code&gt;</source>
          <target state="translated">1）整数文字，精确返回 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::milliseconds&lt;/a&gt;(ms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75957235d93ab14971c5ead82631c15f8903fa9f" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::minutes&lt;/a&gt;(mins)&lt;/code&gt;</source>
          <target state="translated">1）整数文字，精确返回 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::minutes&lt;/a&gt;(mins)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a65c38cb3e887f8107e9bb7e034295d9e9ba661" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::nanoseconds&lt;/a&gt;(nsec)&lt;/code&gt;</source>
          <target state="translated">1）整数文字，精确返回 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::nanoseconds&lt;/a&gt;(nsec)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2ff5af48ac230f178ca8f7aae38f7e5b97cd4ae" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(secs)&lt;/code&gt;</source>
          <target state="translated">1）整数文字，精确返回 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(secs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2ec705f86909dc012b45e0a5e5eac830bf7b5e" translate="yes" xml:space="preserve">
          <source>1) it may apply to the parameter declarations of a function or lambda-expressions, in which case it indicates that initialization of the parameter carries dependency into lvalue-to-rvalue conversion of that object.</source>
          <target state="translated">1)它可能适用于函数或lambda-表达式的参数声明,在这种情况下,它表示参数的初始化带有依赖性,进入该对象的l值到r值的转换。</target>
        </trans-unit>
        <trans-unit id="f08aa13ffd87bf5b57bd2b5c39f8fe2c531e8de4" translate="yes" xml:space="preserve">
          <source>1) left shift of lhs by rhs bits</source>
          <target state="translated">1)lhs位左移,rhs位左移。</target>
        </trans-unit>
        <trans-unit id="a0ef1b765d867fe5ee7805c81437d622e4207832" translate="yes" xml:space="preserve">
          <source>1) linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">1）线性 &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ff0e7aba3a51ab3e96b766a29da0e2d4e95d71e" translate="yes" xml:space="preserve">
          <source>1) linear in size of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">1） &lt;code&gt;str&lt;/code&gt; 大小线性</target>
        </trans-unit>
        <trans-unit id="9ba4f8c918b38171c581014561921c19d85a056e" translate="yes" xml:space="preserve">
          <source>1) make more memory available</source>
          <target state="translated">1)使更多的内存可用</target>
        </trans-unit>
        <trans-unit id="a0c8b5c53f4a3270d0819e3eea46631ace784dc4" translate="yes" xml:space="preserve">
          <source>1) may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if an exception is thrown during output.</source>
          <target state="translated">1）如果在输出过程中引发异常，则可能引发 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="818942971c8d5e6d4f974a900c33b24a7f7a56bb" translate="yes" xml:space="preserve">
          <source>1) may throw, e.g. if &lt;code&gt;pointer&lt;/code&gt; defines a throwing &lt;code&gt;operator*&lt;/code&gt;</source>
          <target state="translated">1）可能会抛出，例如，如果 &lt;code&gt;pointer&lt;/code&gt; 定义了抛出 &lt;code&gt;operator*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b746d566df1bafa8f84adef1c6b1bd18579c2ad4" translate="yes" xml:space="preserve">
          <source>1) multiplication</source>
          <target state="translated">1)乘法</target>
        </trans-unit>
        <trans-unit id="63b22e6c68841953ed2ca6a9ca96cff9639efe85" translate="yes" xml:space="preserve">
          <source>1) narrow character literal or ordinary character literal, e.g. &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; or &lt;code&gt;'\13'&lt;/code&gt;. Such literal has type &lt;code&gt;char&lt;/code&gt; and the value equal to the representation of c-char in the execution character set. If c-char is not representable as a single byte in the execution character set, the literal has type &lt;code&gt;int&lt;/code&gt; and implementation-defined value</source>
          <target state="translated">1）窄字符文字或普通字符文字，例如 &lt;code&gt;'a'&lt;/code&gt; 或 &lt;code&gt;'\n'&lt;/code&gt; 或 &lt;code&gt;'\13'&lt;/code&gt; 。这种文字的类型为 &lt;code&gt;char&lt;/code&gt; ，其值等于执行字符集中c-char的表示形式。如果c-char在执行字符集中不能表示为单个字节，则文字具有 &lt;code&gt;int&lt;/code&gt; 类型和实现定义的值</target>
        </trans-unit>
        <trans-unit id="b3526fa909cbee863631df5a0dd6e3dfe3d40b87" translate="yes" xml:space="preserve">
          <source>1) op E</source>
          <target state="translated">(1)在E级</target>
        </trans-unit>
        <trans-unit id="4adc80c0600353b3a1170e14f5e464ff13775a27" translate="yes" xml:space="preserve">
          <source>1) overloaded operator;</source>
          <target state="translated">1)超载作业人员。</target>
        </trans-unit>
        <trans-unit id="5e09baa491e636964ed3becfd3445f8709e44fad" translate="yes" xml:space="preserve">
          <source>1) p made relative against base.</source>
          <target state="translated">1)p使相对于基数。</target>
        </trans-unit>
        <trans-unit id="f807176049911b041a40e01ee8ab370dcdb89766" translate="yes" xml:space="preserve">
          <source>1) postfix increment (post-increment)</source>
          <target state="translated">1)postfix增量(post-increment)。</target>
        </trans-unit>
        <trans-unit id="2d5856705fcd5ea07c48025861fe3b1f79bc0d2c" translate="yes" xml:space="preserve">
          <source>1) prefix increment (pre-increment)</source>
          <target state="translated">1)前缀增量(pre-increment)。</target>
        </trans-unit>
        <trans-unit id="daa92feecb37a0d054ee8b707dc9aac07a31a3ea" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_encoding&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_encoding&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5328462b7087b609c543e78bd8d46692bea782df" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_length&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_length&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53f57d286d6e754d726ea6cccf746a676dfa1638" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_out&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e4db4e3900ed888101fc0f5f38719bd3c6326b25" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_unshift&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的成员函数 &lt;code&gt;do_unshift&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36bebe33f8e9dfba4ec0a7482223647307e5d502" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_close&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_close&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="087deceeef2229bfa0f69093a5dde5435352bc10" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_monthname&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_get_monthname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="54d273175a96ff13269f617ec3bfb9a5e807469d" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_time&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护虚拟成员函数 &lt;code&gt;do_get_time&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a24196c23f9b282e50225c8ce404605af1d591e" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_weekday&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_get_weekday&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c90b5960dcfdbae543519fd42dff106975cf6a49" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_year&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_get_year&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ced48bdf0ef79442409261aece9019fc894855a2" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_scan_is&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护虚拟成员函数 &lt;code&gt;do_scan_is&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="278c95483ac183d21fe5237adc621b7ef3fd15ff" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_scan_not&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1）公共成员函数，调用最派生类的受保护的虚拟成员函数 &lt;code&gt;do_scan_not&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5100d04826728fa57d41699139922616240294d" translate="yes" xml:space="preserve">
          <source>1) regular function body</source>
          <target state="translated">1)常规功能体</target>
        </trans-unit>
        <trans-unit id="aeec3a3b882e59daf64402de22ed548e3658687c" translate="yes" xml:space="preserve">
          <source>1) removes the topmost &lt;code&gt;const&lt;/code&gt;, the topmost &lt;code&gt;volatile&lt;/code&gt;, or both, if present.</source>
          <target state="translated">1）删除最上面的 &lt;code&gt;const&lt;/code&gt; ，最上面的 &lt;code&gt;volatile&lt;/code&gt; 或两者（如果存在）。</target>
        </trans-unit>
        <trans-unit id="1791c7ad104cbda662a1ae0402149dd47873c5da" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">1）返回 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;{str, len}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f85b4809a3f0e34d7e0945ed1b8a2c6c86889a9" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::string_view&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">1）返回 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::string_view&lt;/a&gt;{str, len}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e1e200684cc13c5bab72f139037d8694e2ed55a" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;c.empty()&lt;/code&gt;</source>
          <target state="translated">1）返回 &lt;code&gt;c.empty()&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
