<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="1cefc4c9c8c79e1f5ffc310e3b76ce47f7f95b53" translate="yes" xml:space="preserve">
          <source>The type of the underlying container to use to store the elements. The container must satisfy the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;, and its iterators must satisfy the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;. Additionally, it must provide the following functions with the usual semantics:</source>
          <target state="translated">用于存储元素的基础容器的类型。容器必须满足&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;的要求，并且其迭代器必须满足&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;的要求。此外，它必须提供具有通常语义的以下功能：</target>
        </trans-unit>
        <trans-unit id="42baf44de229b353e2dc10d945c14ad4f7f1e2dd" translate="yes" xml:space="preserve">
          <source>The type of the underlying container to use to store the elements. The container must satisfy the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;. Additionally, it must provide the following functions with the usual semantics:</source>
          <target state="translated">用于存储元素的基础容器的类型。容器必须满足&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;的要求。此外，它必须提供具有通常语义的以下功能：</target>
        </trans-unit>
        <trans-unit id="4b1400789f4da2eef8d9f804a8241c3f62471b09" translate="yes" xml:space="preserve">
          <source>The type produced when specializing an alias template is not allowed to directly or indirectly make use of its own type:</source>
          <target state="translated">对别名模板进行特殊化时产生的类型不允许直接或间接使用自己的类型。</target>
        </trans-unit>
        <trans-unit id="447849d54c1d67d6b61329201208de7c3155cd27" translate="yes" xml:space="preserve">
          <source>The type representing all floating-point status flags collectively</source>
          <target state="translated">代表所有浮点状态标志的类型。</target>
        </trans-unit>
        <trans-unit id="66cad8bd68a6349c324c8b818f25bd23910481f3" translate="yes" xml:space="preserve">
          <source>The type representing the entire floating-point environment</source>
          <target state="translated">代表整个浮点环境的类型</target>
        </trans-unit>
        <trans-unit id="e0d3b983420a08441dc26163e85fa14573af6da4" translate="yes" xml:space="preserve">
          <source>The type trait template &lt;code&gt;regex_traits&lt;/code&gt; supplies &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; with the set of types and functions necessary to operate on the type &lt;code&gt;CharT&lt;/code&gt;.</source>
          <target state="translated">类型特征模板 &lt;code&gt;regex_traits&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 提供了对类型 &lt;code&gt;CharT&lt;/code&gt; 进行操作所需的类型和函数集。</target>
        </trans-unit>
        <trans-unit id="a7ff3701335c6b61f893828424d0d4397e6f94e7" translate="yes" xml:space="preserve">
          <source>The type, value, and value category of the result of the comma expression are exactly the type, value, and value category of the second operand, &lt;code&gt;E2&lt;/code&gt;. If &lt;code&gt;E2&lt;/code&gt; is a temporary expression(since C++17), the result of the expression is that temporary expression(since C++17). If &lt;code&gt;E2&lt;/code&gt; is a bit-field, the result is a bit-field.</source>
          <target state="translated">逗号表达式的结果的类型，值和值类别恰好是第二个操作数 &lt;code&gt;E2&lt;/code&gt; 的类型，值和值类别。如果 &lt;code&gt;E2&lt;/code&gt; 是一个临时表达式（自C ++ 17起），则表达式的结果就是该临时表达式（自C ++ 17起）。如果 &lt;code&gt;E2&lt;/code&gt; 是位字段，则结果是位字段。</target>
        </trans-unit>
        <trans-unit id="201b401441e563392e93db134426f0b5823a14fe" translate="yes" xml:space="preserve">
          <source>The type-based overloads (5-12) fail to compile if the types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are the same.</source>
          <target state="translated">如果类型 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;U&lt;/code&gt; ,则基于类型的重载（5-12）无法编译相同，。</target>
        </trans-unit>
        <trans-unit id="a8ad5442d02de3fb2204cec5285533422e5d8a60" translate="yes" xml:space="preserve">
          <source>The typedef-names are aliases for existing types, and are not declarations of new types. Typedef cannot be used to change the meaning of an existing type name (including a typedef-name). Once declared, a typedef-name may only be redeclared to refer to the same type again. Typedef names are only in effect in the scope where they are visible: different functions or class declarations may define identically-named types with different meaning.</source>
          <target state="translated">typedef-name是现有类型的别名,而不是新类型的声明。Typedef不能用来改变现有类型名称的含义(包括一个typedef-name)。Typedef-name一旦被声明,只能重新声明以再次引用同一类型。Typedef名称只在它们可见的作用域中有效:不同的函数或类声明可能会定义相同名称的类型,但意义不同。</target>
        </trans-unit>
        <trans-unit id="208a0dcd155f30aca58e4747af4e8c084fcc2a94" translate="yes" xml:space="preserve">
          <source>The typeid expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; which refers to an object with &lt;a href=&quot;static&quot;&gt;static storage duration&lt;/a&gt;, of the polymorphic type &lt;code&gt;const &lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; or of some type derived from it.</source>
          <target state="translated">typeid表达式是一个&lt;a href=&quot;value_category&quot;&gt;左值表达式&lt;/a&gt;，它引用具有多态类型 &lt;code&gt;const &lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../types/type_info&quot;&gt;std :: type_info&lt;/a&gt;或从其派生的某种类型的具有&lt;a href=&quot;static&quot;&gt;静态存储持续时间&lt;/a&gt;的对象。</target>
        </trans-unit>
        <trans-unit id="7e208b7b23417d25a7cf6cca148a35ee8446742b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;TC::rep&lt;/code&gt;, &lt;code&gt;TC::duration&lt;/code&gt;, and &lt;code&gt;TC::time_point&lt;/code&gt; satisfy the requirements of &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;, &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and &lt;a href=&quot;numerictype&quot;&gt;NumericType&lt;/a&gt;.</source>
          <target state="translated">类型 &lt;code&gt;TC::rep&lt;/code&gt; ， &lt;code&gt;TC::duration&lt;/code&gt; 和 &lt;code&gt;TC::time_point&lt;/code&gt; 满足&lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;，&lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;，&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;，&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;，&lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;，&lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;和&lt;a href=&quot;numerictype&quot;&gt;NumericType的要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61760bebb6411fc7a1b89f4a6a4d2b47b837a78f" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;BidirIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">&lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 类型必须使得 &lt;code&gt;BidirIt&lt;/code&gt; 类型的对象可以被取消引用，然后隐式转换为它们两者。</target>
        </trans-unit>
        <trans-unit id="10efac4cd9ec3d4ae0fd700440a7ab91e4529fc8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">&lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 类型必须这样， &lt;code&gt;ForwardIt&lt;/code&gt; 可以取消引用ForwardIt类型的对象，然后将其隐式转换为它们两者。</target>
        </trans-unit>
        <trans-unit id="cfb5cffb02876fdfc335e83f9d620b313612c1b0" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">&lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 类型必须使得 &lt;code&gt;InputIt&lt;/code&gt; 类型的对象可以被取消引用，然后隐式转换为它们两者。</target>
        </trans-unit>
        <trans-unit id="3c179ed315abab6c17ee556701b26c5d282772f2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;RandomIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">&lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 类型必须使得可以取消引用 &lt;code&gt;RandomIt&lt;/code&gt; 类型的对象，然后将其隐式转换为它们两者。</target>
        </trans-unit>
        <trans-unit id="193be796c5e76cc692dcacf4d03a9c74c36dcc11" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;, and an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">类型 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 必须使得类型 &lt;code&gt;T&lt;/code&gt; 的对象可以隐式转换为 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; ，并且类型为 &lt;code&gt;ForwardIt&lt;/code&gt; 的对象可以被取消引用，然后隐式转换为 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4447fe84d3b9ebfd730e495965e02d0c7f2a157" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to both of them. ​</source>
          <target state="translated">&lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 类型必须使得 &lt;code&gt;T&lt;/code&gt; 类型的对象可以隐式转换为它们两者。</target>
        </trans-unit>
        <trans-unit id="55aca5b917e7d46505eef0c5864d5092e23045de" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;forward_list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">&lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 类型必须使得可以取消引用类型为 &lt;code&gt;forward_list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; 的对象，然后隐式转换为它们两者。</target>
        </trans-unit>
        <trans-unit id="c2c308d3a55373567a39aa9cf81fb0182d8c2878" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be implicitly converted to both of them. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">&lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 类型必须使得 &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; 类型的对象可以隐式转换为它们两者。 &lt;code&gt;Ret&lt;/code&gt; 类型必须如此， &lt;code&gt;OutputIt&lt;/code&gt; 可以取消引用OutputIt类型的对象并为其分配值 &lt;code&gt;Ret&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86218894e5a217ad2ba71c5d5b88c13c7c91af26" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">类型 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 必须使得类型的对象 &lt;code&gt;list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; 可以解除引用，然后隐式转换为它们两者。</target>
        </trans-unit>
        <trans-unit id="255e7b7cb8a9a07dcebb8ff409c528b78435bb0c" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. ​</source>
          <target state="translated">类型 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 必须使得类型的对象 &lt;code&gt;ForwardIt1&lt;/code&gt; 和 &lt;code&gt;ForwardIt2&lt;/code&gt; 可以解除引用，然后隐式转换为 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="8bf40db03397e57c92c014d425524b6be371768c" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">类型 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 必须使得类型的对象 &lt;code&gt;InputIt1&lt;/code&gt; 和 &lt;code&gt;InputIt2&lt;/code&gt; 可以解除引用，然后隐式转换为 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 分别。 &lt;code&gt;Ret&lt;/code&gt; 类型必须如此， &lt;code&gt;OutputIt&lt;/code&gt; 可以取消引用OutputIt类型的对象并为其分配值 &lt;code&gt;Ret&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea66afd749f321b8a7fbd2dfec0b25993b20d429" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;Type3&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">类型 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 必须使得类型的对象 &lt;code&gt;InputIt1&lt;/code&gt; 和 &lt;code&gt;InputIt2&lt;/code&gt; 可以解除引用，然后隐式转换为 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 分别。类型 &lt;code&gt;Ret&lt;/code&gt; 必须使得类型的对象 &lt;code&gt;Type3&lt;/code&gt; 可以分配类型的值 &lt;code&gt;Ret&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="697ca99a8e5d22b550dc1162bfdf3113cb87ca5b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. ​</source>
          <target state="translated">类型 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 必须使得类型的对象 &lt;code&gt;InputIt1&lt;/code&gt; 和 &lt;code&gt;InputIt2&lt;/code&gt; 可以解除引用，然后隐式转换为 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 分别。</target>
        </trans-unit>
        <trans-unit id="c5097f11a8110609e26afb57ed62da129a5503cf" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">类型 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 必须是这样的类型， &lt;code&gt;InputIt2&lt;/code&gt; 可以取消引用类型 &lt;code&gt;InputIt1&lt;/code&gt; 和InputIt2的对象，然后将其隐式转换为 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c30caab1908aa629ad3fea15c152763576c8875" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;Type3&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">类型 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 必须使得类型的对象 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;Type3&lt;/code&gt; 可以隐式转换到 &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 分别。类型 &lt;code&gt;Ret&lt;/code&gt; 必须使得类型 &lt;code&gt;T&lt;/code&gt; 的对象可以被分配类型 &lt;code&gt;Ret&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="50e24e2bc41cc279e1a3c9515fef0b78775237a9" translate="yes" xml:space="preserve">
          <source>The types in the parameter pack &lt;code&gt;T&lt;/code&gt; shall each be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound. Otherwise, the behavior is undefined.</source>
          <target state="translated">参数包 &lt;code&gt;T&lt;/code&gt; 中的类型应分别为完整类型（可能是cv限定） &lt;code&gt;void&lt;/code&gt; 或未知边界数组。否则，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="fa81b9c4cb4ce5f942c1234f0bfa8aee24861f94" translate="yes" xml:space="preserve">
          <source>The types of the placeholder objects are &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, their default copy/move constructors do not throw exceptions, and for any placeholder &lt;code&gt;_N&lt;/code&gt;, the type &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;decltype(_N)&amp;gt;&lt;/code&gt; is defined and is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">占位符对象的类型为&lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;和&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;，其默认的复制/移动构造函数不会引发异常，并且对于任何占位符 &lt;code&gt;_N&lt;/code&gt; ，都定义了类型 &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;decltype(_N)&amp;gt;&lt;/code&gt; 并从 &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, N&amp;gt;&lt;/code&gt; 派生。&amp;lt;int，N&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="75478ba3404fb0cfdef1c92955897a42cd9e34cf" translate="yes" xml:space="preserve">
          <source>The types used to determine the order depend on the context:</source>
          <target state="translated">用于确定顺序的类型取决于上下文。</target>
        </trans-unit>
        <trans-unit id="81e4b2422bd4fd5cd5d02082af7aa37f47bd2430" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;istrstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;istrstream&lt;/code&gt; 的典型实现仅包含一个非派生的数据成员： &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 类型的对象。</target>
        </trans-unit>
        <trans-unit id="48a376de82dbe48c2684a6707ba9148135410249" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;ostrstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ostrstream&lt;/code&gt; 的典型实现仅包含一个非派生的数据成员： &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 类型的对象。</target>
        </trans-unit>
        <trans-unit id="4926fe384c3bbd6e8ecfe4635962d969889b9270" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;strstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strstream&lt;/code&gt; 的典型实现仅包含一个非派生的数据成员： &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; 类型的对象。</target>
        </trans-unit>
        <trans-unit id="8b6e26a516b34b7af57fc7012be60e25328df076" translate="yes" xml:space="preserve">
          <source>The unary arithmetic operator expressions have the form.</source>
          <target state="translated">单元算术运算符表达式有如下形式。</target>
        </trans-unit>
        <trans-unit id="b22b858c0fd42effe64ef379a02aba7e1e499dac" translate="yes" xml:space="preserve">
          <source>The unary operator &lt;code&gt;co_await&lt;/code&gt; suspends a coroutine and returns control to the caller. Its operand is an expression whose type must either define &lt;code&gt;operator co_await&lt;/code&gt;, or be convertible to such type by means of the current coroutine's &lt;code&gt;Promise::await_transform&lt;/code&gt;.</source>
          <target state="translated">一元运算符 &lt;code&gt;co_await&lt;/code&gt; 暂停协程并将控制权返回给调用方。它的操作数是一个表达式，其类型必须定义 &lt;code&gt;operator co_await&lt;/code&gt; ，或者可以通过当前协程的 &lt;code&gt;Promise::await_transform&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36a5614de76d4b58b628c43d48b3afb8e58937c2" translate="yes" xml:space="preserve">
          <source>The unary predicate type must define a member type, &lt;code&gt;argument_type&lt;/code&gt;, that is convertible to the predicate's parameter type. The unary function objects obtained from &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; have this type defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一元谓词类型必须定义一个成员类型 &lt;code&gt;argument_type&lt;/code&gt; ，该成员类型可以转换为谓词的参数类型。从 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 或从对 &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; 另一个调用中获得的一元函数对象定义了这种类型，从不推荐使用的 &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt; 函数对象也是如此。</target>
        </trans-unit>
        <trans-unit id="7c177ac717f26cdcf71092d833a69d98891213b9" translate="yes" xml:space="preserve">
          <source>The unary predicate type must define a member type, &lt;code&gt;argument_type&lt;/code&gt;, that is convertible to the predicate's parameter type. The unary function objects obtained from &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;std::not1&lt;/code&gt; have this type defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">一元谓词类型必须定义一个成员类型 &lt;code&gt;argument_type&lt;/code&gt; ，该成员类型可以转换为谓词的参数类型。从 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; 或从对 &lt;code&gt;std::not1&lt;/code&gt; 另一个调用中获得的一元函数对象定义了这种类型，从不推荐使用的 &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt; 函数对象也是如此。</target>
        </trans-unit>
        <trans-unit id="9a8868abcc7899aa017c841a57e1f892c57cdec6" translate="yes" xml:space="preserve">
          <source>The underlying array is a &lt;a href=&quot;../language/implicit_cast#Temporary_materialization&quot;&gt;temporary&lt;/a&gt; array of type &lt;code&gt;const T[N]&lt;/code&gt;, in which each element is &lt;a href=&quot;../language/copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; (except that narrowing conversions are invalid) from the corresponding element of the original initializer list. The lifetime of the underlying array is the same as any other &lt;a href=&quot;../language/lifetime#Temporary_object_lifetime&quot;&gt;temporary object&lt;/a&gt;, except that initializing an initializer_list object from the array extends the lifetime of the array exactly like &lt;a href=&quot;../language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;binding a reference to a temporary&lt;/a&gt; (with the same exceptions, such as for initializing a non-static class member). The underlying array may be allocated in read-only memory.</source>
          <target state="translated">基础数组是类型为 &lt;code&gt;const T[N]&lt;/code&gt; 的&lt;a href=&quot;../language/implicit_cast#Temporary_materialization&quot;&gt;临时&lt;/a&gt;数组，其中每个元素都从原始初始值设定项列表的相应元素进行&lt;a href=&quot;../language/copy_initialization&quot;&gt;复制初始化&lt;/a&gt;（除非缩小转换无效）。基础数组的生存期与任何其他&lt;a href=&quot;../language/lifetime#Temporary_object_lifetime&quot;&gt;临时对象&lt;/a&gt;相同，不同之处在于，从该数组初始化initializer_list对象可以延长数组的生存期，就像&lt;a href=&quot;../language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;将引用绑定到临时对象一样&lt;/a&gt;（但有相同的例外，例如用于初始化非临时对象）。-static类成员）。底层数组可以分配在只读存储器中。</target>
        </trans-unit>
        <trans-unit id="4eb3a7f051a86b23a775a499c1446a22117e43f7" translate="yes" xml:space="preserve">
          <source>The underlying array is not guaranteed to exist after the lifetime of the original initializer list object has ended. The storage for &lt;code&gt;std::initializer_list&lt;/code&gt; is unspecified (i.e. it could be automatic, temporary, or static read-only memory, depending on the situation).</source>
          <target state="translated">在原始初始化程序列表对象的生存期结束后，不能保证基础数组存在。未指定 &lt;code&gt;std::initializer_list&lt;/code&gt; 的存储（即取决于情况，它可以是自动，临时或静态只读存储器）。</target>
        </trans-unit>
        <trans-unit id="7eadf4d50d87bb977c930c01738a9f8d29a30fb0" translate="yes" xml:space="preserve">
          <source>The underlying engine.</source>
          <target state="translated">底层引擎。</target>
        </trans-unit>
        <trans-unit id="97e77189c09808726f0123e32d74be4afcdbd112" translate="yes" xml:space="preserve">
          <source>The underlying iterator is assigned the value of the underlying iterator of &lt;code&gt;other&lt;/code&gt;, i.e. &lt;code&gt;other.base()&lt;/code&gt;.</source>
          <target state="translated">为基础迭代器分配了 &lt;code&gt;other&lt;/code&gt; 的基础迭代器的值，即 &lt;code&gt;other.base()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b646602f4defaa19568e9e4e03c04b49576b8ef7" translate="yes" xml:space="preserve">
          <source>The underlying iterator.</source>
          <target state="translated">底层迭代器。</target>
        </trans-unit>
        <trans-unit id="79cf0218a59dc2d4dbf82fe2261c98e6c65758c3" translate="yes" xml:space="preserve">
          <source>The unevaluated operands are considered to be</source>
          <target state="translated">未经过评估的操作数被认为是</target>
        </trans-unit>
        <trans-unit id="979a12b00a42a8fc276019493ceedcb85eb1918e" translate="yes" xml:space="preserve">
          <source>The unformatted input functions &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;basic_istream::get&lt;/code&gt;&lt;/a&gt; if they fails to extract any characters.</source>
          <target state="translated">未格式化的输入函数&lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;basic_istream::get&lt;/code&gt; &lt;/a&gt;如果它们未能提取任何字符。</target>
        </trans-unit>
        <trans-unit id="abe9991ee5e0486321d659e85ed0325fe1bbb797" translate="yes" xml:space="preserve">
          <source>The unformatted input functions &lt;a href=&quot;../basic_istream/read&quot;&gt;&lt;code&gt;basic_istream::read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;basic_istream::get&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_istream/peek&quot;&gt;&lt;code&gt;basic_istream::peek&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../basic_istream/getline&quot;&gt;&lt;code&gt;basic_istream::getline&lt;/code&gt;&lt;/a&gt;, when reaching the end of the stream.</source>
          <target state="translated">当到达流的末尾时，未格式化的输入函数&lt;a href=&quot;../basic_istream/read&quot;&gt; &lt;code&gt;basic_istream::read&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;basic_istream::get&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../basic_istream/peek&quot;&gt; &lt;code&gt;basic_istream::peek&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../basic_istream/getline&quot;&gt; &lt;code&gt;basic_istream::getline&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e384fd665d52aa51e3748fff4ef48a28e7937c70" translate="yes" xml:space="preserve">
          <source>The union is only as big as necessary to hold its largest data member. The other data members are allocated in the same bytes as part of that largest member. The details of that allocation are implementation-defined, and it's undefined behavior to read from the member of the union that wasn't most recently written. Many compilers implement, as a non-standard language extension, the ability to read inactive members of a union.</source>
          <target state="translated">联合体的大小只限于容纳其最大的数据成员所需的大小。其他数据成员作为最大成员的一部分,以相同的字节分配。这种分配的细节是由实现定义的,从联合体的成员中读取最近没有写入的数据是未定义的行为。许多编译器作为一种非标准语言扩展,实现了读取联盟中不活动成员的能力。</target>
        </trans-unit>
        <trans-unit id="e952952a6e837db3083d43ddef77a18d33df5f91" translate="yes" xml:space="preserve">
          <source>The unordered associative containers &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; use specializations of the template &lt;code&gt;std::hash&lt;/code&gt; as the default hash function.</source>
          <target state="translated">无序关联容器 &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 使用模板 &lt;code&gt;std::hash&lt;/code&gt; 特殊化作为默认哈希函数。</target>
        </trans-unit>
        <trans-unit id="fb9ee6c51de186554c2e06f60fe8377ba45da283" translate="yes" xml:space="preserve">
          <source>The upper bound of the largest range beginning at &lt;code&gt;first&lt;/code&gt; in which the elements are sorted in ascending order. That is, the last iterator &lt;code&gt;it&lt;/code&gt; for which range &lt;code&gt;[first, it)&lt;/code&gt; is sorted.</source>
          <target state="translated">上结合的最大范围在开始的 &lt;code&gt;first&lt;/code&gt; ，其中元件被按升序排序。也就是说，最后的迭代 &lt;code&gt;it&lt;/code&gt; 对于其范围 &lt;code&gt;[first, it)&lt;/code&gt; 被排序。</target>
        </trans-unit>
        <trans-unit id="153cc2e9c85ca94fbb56ca3af1786c3042753255" translate="yes" xml:space="preserve">
          <source>The upper bound of the largest range beginning at &lt;code&gt;first&lt;/code&gt; which is a</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 开始的最大范围的上限是</target>
        </trans-unit>
        <trans-unit id="0a7c6b2e95b8914f758d75e392b6d55f793089e4" translate="yes" xml:space="preserve">
          <source>The use of the class key &lt;code&gt;union&lt;/code&gt; results in a &lt;a href=&quot;union&quot;&gt;union definition&lt;/a&gt;, which defines a class that holds only one of its data members at a time.</source>
          <target state="translated">使用类键 &lt;code&gt;union&lt;/code&gt; 导致&lt;a href=&quot;union&quot;&gt;联合定义&lt;/a&gt;，该定义定义了一次仅包含其数据成员之一的类。</target>
        </trans-unit>
        <trans-unit id="7c930b3ae6f3ca4c4f3a29eb336a3a8321980de8" translate="yes" xml:space="preserve">
          <source>The user-defined callback function is not allowed to throw exceptions.</source>
          <target state="translated">用户定义的回调函数不允许抛出异常。</target>
        </trans-unit>
        <trans-unit id="7440e695d7d2b47e772a3f0ba0922c8f1015cfd1" translate="yes" xml:space="preserve">
          <source>The user-defined conversion functions are considered to be members of the</source>
          <target state="translated">用户定义的转换函数被认为是下列函数的成员</target>
        </trans-unit>
        <trans-unit id="a2449ea9418355b1634632974372ad5423959cfe" translate="yes" xml:space="preserve">
          <source>The using-directive &lt;code&gt;using namespace std;&lt;/code&gt; at any namespace scope introduces every name from the namespace &lt;code&gt;std&lt;/code&gt; into the global namespace (since the global namespace is the nearest namespace that contains both &lt;code&gt;std&lt;/code&gt; and any user-declared namespace), which may lead to undesirable name collisions. This, and other using directives are generally considered bad practice at file scope of a header file.</source>
          <target state="translated">using指令 &lt;code&gt;using namespace std;&lt;/code&gt; 在任何名称空间范围内，将名称空间 &lt;code&gt;std&lt;/code&gt; 中的每个名称引入全局名称空间（因为全局名称空间是包含 &lt;code&gt;std&lt;/code&gt; 和任何用户声明的名称空间的最近的名称空间），这可能导致不希望的名称冲突。在头文件的文件范围内，通常将此方法和其他using伪指令视为不良做法。</target>
        </trans-unit>
        <trans-unit id="a0a29bcf7f924ca3c9afb16892af9ad80008618f" translate="yes" xml:space="preserve">
          <source>The usual rules for reference-binding to temporaries (including lifetime-extension) apply if a ref-operator is present and the expression is a prvalue. In those cases the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is a reference that binds to the temporary variable &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from the prvalue expression, extending its lifetime. As usual, the binding will fail if &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is a non-const lvalue reference:</source>
          <target state="translated">如果存在ref运算符并且表达式为prvalue，则适用于对临时对象进行引用绑定（包括生命周期扩展）的通常规则。在这些情况下，隐变量 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 是参考结合于临时变量&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;物化&lt;/a&gt;从prvalue表达，延长其寿命。通常，如果 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 是非常量左值引用，绑定将失败：</target>
        </trans-unit>
        <trans-unit id="d143db4cb73d031e48783561f534e5977a6951dc" translate="yes" xml:space="preserve">
          <source>The utility functions &lt;code&gt;std::make_obj_using_allocator&lt;/code&gt;, and &lt;code&gt;std::uninitialized_construct_using_allocator&lt;/code&gt; may be used to explicitly create an object following the above protocol, and &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; can be used to prepare the argument list that matches the flavor of uses-allocator construction expected by the type.</source>
          <target state="translated">实用程序函数 &lt;code&gt;std::make_obj_using_allocator&lt;/code&gt; 和 &lt;code&gt;std::uninitialized_construct_using_allocator&lt;/code&gt; 可用于按照上述协议显式创建对象，并且 &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; 可用于准备与用户期望的uses-allocator构造风格相匹配的参数列表。方式。</target>
        </trans-unit>
        <trans-unit id="fe1efdbf774195a43f57a666949496b9864e4331" translate="yes" xml:space="preserve">
          <source>The valid values (inherited from &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base&lt;/a&gt;&lt;/code&gt;) are:</source>
          <target state="translated">有效值（从 &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base&lt;/a&gt;&lt;/code&gt; 继承）是：</target>
        </trans-unit>
        <trans-unit id="ea8585806be7732f5b1559533a0afabee4e31468" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;false&lt;/code&gt; (the default) indicates that any flush will be postponed until a call to emit.</source>
          <target state="translated">值 &lt;code&gt;false&lt;/code&gt; （默认值）指示刷新将被推迟到发出呼叫之前。</target>
        </trans-unit>
        <trans-unit id="bec74bfd762b8f94824661d08795516a39875971" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;std::codecvt_base::partial&lt;/code&gt; is used to indicate that either the destination range is too short to receive the results of the conversion or the input is truncated in the middle of an otherwise valid multibyte character.</source>
          <target state="translated">值 &lt;code&gt;std::codecvt_base::partial&lt;/code&gt; 用来指示目标范围太短而无法接收转换结果，或者输入在有效的多字节字符中间被截断。</target>
        </trans-unit>
        <trans-unit id="b59da2ec2014ac9c518b1aadf220e6d3e58b2e01" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;true&lt;/code&gt; makes flushes apply immediately.</source>
          <target state="translated">值 &lt;code&gt;true&lt;/code&gt; 使刷新立即生效。</target>
        </trans-unit>
        <trans-unit id="b297662cf0a9d877fef1ea088b887dc762885510" translate="yes" xml:space="preserve">
          <source>The value category of a function call expression is lvalue if the function returns an lvalue reference or an rvalue reference to function, is an xvalue if the function returns an rvalue reference to object, and is a prvalue otherwise. If the function call expression is a prvalue of object type, it must have complete type except when the prvalue is not materialized, such as(since C++17) when used as the operand of &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; (or as the right operand of a &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;built-in comma operator expression&lt;/a&gt; that is the operand of &lt;code&gt;decltype&lt;/code&gt;).</source>
          <target state="translated">如果函数返回对函数的左值引用或右值引用，则函数调用表达式的值类别为左值；如果函数返回对对象的右值引用，则值为xvalue；否则为prvalue。如果函数调用表达式是对象类型的prvalue，则它必须具有完整的类型，除非prvalue没有实现，例如（自C ++ 17起）当用作&lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt;的操作数（或作为已&lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;构建对象&lt;/a&gt;的正确操作数）-逗号运算符表达式，它是 &lt;code&gt;decltype&lt;/code&gt; 的操作数）。</target>
        </trans-unit>
        <trans-unit id="67e47b55490dd997d102458418a048c6890cf272" translate="yes" xml:space="preserve">
          <source>The value comparison function object.</source>
          <target state="translated">值比较函数对象。</target>
        </trans-unit>
        <trans-unit id="e3315b1caebdb1fc309be2d0ec78502282dc56fc" translate="yes" xml:space="preserve">
          <source>The value computed by the three-argument version of this function is the distance of the point &lt;code&gt;(x,y,z)&lt;/code&gt; from the origin &lt;code&gt;(0,0,0)&lt;/code&gt;.</source>
          <target state="translated">该函数的三参数版本计算出的值是点 &lt;code&gt;(x,y,z)&lt;/code&gt; 距原点 &lt;code&gt;(0,0,0)&lt;/code&gt; 的距离。</target>
        </trans-unit>
        <trans-unit id="f316342cf5de6fdab5febb1bc73226832477d458" translate="yes" xml:space="preserve">
          <source>The value computed by the two-argument version of this function is the length of the hypotenuse of a right-angled triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or the distance of the point &lt;code&gt;(x,y)&lt;/code&gt; from the origin &lt;code&gt;(0,0)&lt;/code&gt;, or the magnitude of a complex number &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt;.</source>
          <target state="translated">该函数的两个参数的版本计算出的值是直角三角形的斜边的长度，直角三角形的边长为 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; ，或者点 &lt;code&gt;(x,y)&lt;/code&gt; 距原点 &lt;code&gt;(0,0)&lt;/code&gt; ）的距离）或复数 &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7044fe5027fd6004978c59ea869f2af588568b11" translate="yes" xml:space="preserve">
          <source>The value held previously by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 指向的原子对象先前保存的值。</target>
        </trans-unit>
        <trans-unit id="5b53ba13c1b7ad772fd50ae6d7f505fae71221a4" translate="yes" xml:space="preserve">
          <source>The value immediately preceding the effects of this function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">值紧接在该功能中的作用前述&lt;a href=&quot;../memory_order#Modification_order&quot;&gt;修饰顺序&lt;/a&gt;的 &lt;code&gt;*this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21ba436ae4d60c1b3df6f313a5e847a739f28e04" translate="yes" xml:space="preserve">
          <source>The value immediately preceding the effects of this function in the &lt;a href=&quot;memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*obj&lt;/code&gt;.</source>
          <target state="translated">值立即在此功能的影响前述&lt;a href=&quot;memory_order#Modification_order&quot;&gt;修饰顺序&lt;/a&gt;的 &lt;code&gt;*obj&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ad12bc074bf532e8969a9847c8c0936a889cc81" translate="yes" xml:space="preserve">
          <source>The value obtained is the number of successes in a sequence of t yes/no experiments, each of which succeeds with probability p.</source>
          <target state="translated">得到的值是t个是/否实验序列中的成功次数,每个实验的成功概率为p。</target>
        </trans-unit>
        <trans-unit id="33a4fa47add8b297d431d6dce6cb94e9aeac4af7" translate="yes" xml:space="preserve">
          <source>The value obtained is the probability of exactly i occurrences of a random event if the expected,</source>
          <target state="translated">得到的值是随机事件正好出现i次的概率,如果预期。</target>
        </trans-unit>
        <trans-unit id="873f84075d8ee3fa467aeba44e733298e1a32864" translate="yes" xml:space="preserve">
          <source>The value obtained is the time/distance until the next random event if random events occur at constant rate &amp;lambda; per unit of time/distance. For example, this distribution describes the time between the clicks of a Geiger counter or the distance between point mutations in a DNA strand.</source>
          <target state="translated">如果随机事件以每单位时间/距离的恒定速率&amp;lambda;发生，则获得的值是直到下一个随机事件的时间/距离。例如，此分布描述了盖革计数器点击之间的时间或DNA链中点突变之间的距离。</target>
        </trans-unit>
        <trans-unit id="baf914d043e381313277e30f951edd923276b030" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits10&lt;/code&gt; is the number of base-10 digits that can be represented by the type &lt;code&gt;T&lt;/code&gt; without change, that is, any number with this many significant decimal digits can be converted to a value of type &lt;code&gt;T&lt;/code&gt; and back to decimal form, without change due to rounding or overflow. For base-&lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; types, it is the value of &lt;a href=&quot;digits&quot;&gt;digits&lt;/a&gt; (&lt;code&gt;digits-1&lt;/code&gt; for floating-point types) multiplied by log</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits10&lt;/code&gt; IS的碱基10位可以由类型来表示数 &lt;code&gt;T&lt;/code&gt; 没有变化，即，任意数量的与该许多显著十进制数字可以被转换为值键入 &lt;code&gt;T&lt;/code&gt; 并返回十进制形式，但不会由于四舍五入或溢出而发生变化。对于&lt;a href=&quot;radix&quot;&gt;基数&lt;/a&gt;类型，它是&lt;a href=&quot;digits&quot;&gt;数字&lt;/a&gt;的值（对于浮点类型，为 &lt;code&gt;digits-1&lt;/code&gt; ）乘以log</target>
        </trans-unit>
        <trans-unit id="c32d6df5f25bd1c67469d66fa412b07db9fb23e7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; is the number of digits in base-&lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; that can be represented by the type &lt;code&gt;T&lt;/code&gt; without change. For integer types, this is the number of bits not counting the sign bit and the padding bits (if any). For floating-point types, this is the number of digits in the mantissa.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; 就是在碱基数字位数&lt;a href=&quot;radix&quot;&gt;基数&lt;/a&gt;可以由类型来表示 &lt;code&gt;T&lt;/code&gt; 没有变化。对于整数类型，这是不计算符号位和填充位（如果有）的位数。对于浮点类型，这是尾数中的位数。</target>
        </trans-unit>
        <trans-unit id="0efce6844d5328b9d552d5e22fa416002bf69dda" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm&lt;/code&gt; identifies the floating-point types that support &lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number&quot;&gt;subnormal values&lt;/a&gt;.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm&lt;/code&gt; 识别浮点类型的支持&lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number&quot;&gt;低于正常值&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="818565d8873864260ed4bd3755ec119254a0a789" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm_loss&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; that detect loss of precision when creating a subnormal number as denormalization loss rather than as inexact result (see below).</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm_loss&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 的所有浮点类型 &lt;code&gt;T&lt;/code&gt; 创建的次正规数反规范化损失时，而不是作为不精确的结果（见下文），其检测精度的损失。</target>
        </trans-unit>
        <trans-unit id="49fe53c8f4920123566acbcd270a4d7a6cb8ff5d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the positive infinity as a distinct special value. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 的所有类型 &lt;code&gt;T&lt;/code&gt; 能够表示正无穷大作为不同的特殊的价值。该常数是有意义的所有浮点类型和保证是 &lt;code&gt;true&lt;/code&gt; ，如果 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72efab69a379a3baec3c747ef72e6384302c8f11" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the special value &quot;Quiet &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt;&quot;. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 的所有类型 &lt;code&gt;T&lt;/code&gt; 能够表示特殊值的&amp;ldquo;安静&lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;不-A-数&lt;/a&gt; &amp;rdquo;。该常数是有意义的所有浮点类型和保证是 &lt;code&gt;true&lt;/code&gt; ，如果 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13d78c72e37aa6610d8da4c27392455c38353258" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the special value &quot;Signaling &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt;&quot;. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 的所有类型 &lt;code&gt;T&lt;/code&gt; 能够表示特殊值&amp;ldquo;信令的&lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;不-A-数&lt;/a&gt; &amp;rdquo;。该常数是有意义的所有浮点类型和保证是 &lt;code&gt;true&lt;/code&gt; ，如果 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f98212fab0bd1fe8a4594e818456712a7e96f5af" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_bounded&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that represent a finite set of values. While all fundamental types are bounded, this constant would be &lt;code&gt;false&lt;/code&gt; in a specialization of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; for a library-provided arbitrary precision arithmetic type.</source>
          <target state="translated">对于表示有限值集的所有算术类型 &lt;code&gt;T&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_bounded&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 。尽管所有基本类型都有界，但对于由库提供的任意精度算术类型，在以 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; 特殊化的情况下，此常量将为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3bc9c048c67471591b1728199b12d7c643bc09a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that use exact representation.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact&lt;/code&gt; 就是 &lt;code&gt;true&lt;/code&gt; 所有算术类型 &lt;code&gt;T&lt;/code&gt; 使用精确的表示。</target>
        </trans-unit>
        <trans-unit id="0de1e0807da9a49f5b6ab2b0b1d4bdf3282315d4" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; which fulfill the requirements of IEC 559 (&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754&lt;/a&gt;) standard. If &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; are also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 的所有浮点类型 &lt;code&gt;T&lt;/code&gt; 其满足IEC 559（的要求&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754&lt;/a&gt;）标准。如果 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; 也是 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5566e2270326a63be00f7caa114991c2e742497" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all integer arithmetic types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; otherwise. This constant is meaningful for all specializations.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 的所有整数算术类型 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 否则。该常数对所有专业都有意义。</target>
        </trans-unit>
        <trans-unit id="658be2ec18bfcdb89b874906fd0e9a2788a963dc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_modulo&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that are possible to (until C++11)handle overflows with modulo arithmetic, that is, if the result of addition, subtraction, multiplication, or division of this type would fall outside the range &lt;code&gt;[min(), max()]&lt;/code&gt;, the value returned by such operation differs from the expected value by a multiple of &lt;code&gt;max()-min()+1&lt;/code&gt;.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_modulo&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 的所有算术类型 &lt;code&gt;T&lt;/code&gt; 是可能的（直至C ++ 11）与手柄模运算，即溢出时，如果相加的结果，减法，乘法，或此类型的除法将落在 &lt;code&gt;[min(), max()]&lt;/code&gt; 范围之外，此类操作返回的值与期望值之差为 &lt;code&gt;max()-min()+1&lt;/code&gt; 的倍数。</target>
        </trans-unit>
        <trans-unit id="31c7c70df24e3cc025f30c7660467183acd0bc12" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_signed&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all signed arithmetic types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; for the unsigned types. This constant is meaningful for all specializations.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_signed&lt;/code&gt; 就是 &lt;code&gt;true&lt;/code&gt; 的所有符号的算术运算类型的 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; 的无符号类型。该常数对所有专业都有意义。</target>
        </trans-unit>
        <trans-unit id="c387cb47b15566bbeed0c9ac97ac7422cc757b9c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T&lt;/code&gt; for which there exists a specialization of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; 就是 &lt;code&gt;true&lt;/code&gt; 所有 &lt;code&gt;T&lt;/code&gt; 存在用于其的专门化 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a6c251458907976d9505f9f19b57f15d678ee8d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_digits10&lt;/code&gt; is the number of base-10 digits that are necessary to uniquely represent all distinct values of the type &lt;code&gt;T&lt;/code&gt;, such as necessary for serialization/deserialization to text. This constant is meaningful for all floating-point types.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_digits10&lt;/code&gt; 是底数为10的位数所必需的唯一地表示所述类型的所有不同值的数目 &lt;code&gt;T&lt;/code&gt; ，如必需的序列化/反序列化到文本。该常数对所有浮点类型都有意义。</target>
        </trans-unit>
        <trans-unit id="95ede15e1ccfe9c08910652785a578f9aff770fc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent10&lt;/code&gt; is the largest positive number &lt;code&gt;n&lt;/code&gt; such that 10n</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent10&lt;/code&gt; 是最大的正数 &lt;code&gt;n&lt;/code&gt; 使得10N</target>
        </trans-unit>
        <trans-unit id="4428910011b11510b83f35d9325633de507bd21f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent&lt;/code&gt; is the largest positive number &lt;code&gt;n&lt;/code&gt; such that rn-1</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent&lt;/code&gt; 是最大的正数 &lt;code&gt;n&lt;/code&gt; 使得RN-1</target>
        </trans-unit>
        <trans-unit id="3a8e50309322655b0b34d76c3ee924a26b2a1631" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent10&lt;/code&gt; is the lowest negative number &lt;code&gt;n&lt;/code&gt; such that 10n</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent10&lt;/code&gt; 是最低的负数 &lt;code&gt;n&lt;/code&gt; 使得10N</target>
        </trans-unit>
        <trans-unit id="d7d35efd9d6ad828da236c558d6eb68513df2887" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent&lt;/code&gt; is the lowest negative number &lt;code&gt;n&lt;/code&gt; such that rn-1</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent&lt;/code&gt; 是最低的负数 &lt;code&gt;n&lt;/code&gt; 使得RN-1</target>
        </trans-unit>
        <trans-unit id="67d3622bd53f05bb8c505d5f1632f3a6e465c7e7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::radix&lt;/code&gt; is the base of the number system used in the representation of the type. It is 2 for all binary numeric types, but it may be, for example, 10 for IEEE 754 &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal64_floating-point_format&quot;&gt;decimal floating-point types&lt;/a&gt; or for third-party &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;binary-coded decimal&lt;/a&gt; integers. This constant is meaningful for all specializations.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::radix&lt;/code&gt; 为式中的表示所使用的数系的基础。对于所有二进制数字类型，它均为2，但是对于IEEE 754 &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal64_floating-point_format&quot;&gt;十进制浮点类型&lt;/a&gt;或第三方&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;二进制编码的十进制&lt;/a&gt;整数，它可以为10 。该常数对所有专业都有意义。</target>
        </trans-unit>
        <trans-unit id="ad3e3b6d189c403f77654a78e8b8fce06565fd64" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::round_style&lt;/code&gt; identifies the rounding style used by the floating-point type &lt;code&gt;T&lt;/code&gt; whenever a value that is not one of the exactly repesentable values of &lt;code&gt;T&lt;/code&gt; is stored in an object of that type.</source>
          <target state="translated">每当不是 &lt;code&gt;T&lt;/code&gt; 的确切可表示值之一的值存储在该类型的对象中时， &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::round_style&lt;/code&gt; 的值将标识浮点类型 &lt;code&gt;T&lt;/code&gt; 使用的舍入样式。</target>
        </trans-unit>
        <trans-unit id="929804192ce1c0c75b72779392cd6ef40eb4db5c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::tinyness_before&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; that test results of floating-point expressions for underflow before rounding.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::tinyness_before&lt;/code&gt; 就是 &lt;code&gt;true&lt;/code&gt; 所有浮点类型 &lt;code&gt;T&lt;/code&gt; 对于舍入之前下溢浮点表达式的测试结果。</target>
        </trans-unit>
        <trans-unit id="f1ed74039ebf1d42dca61166c833be8f6cd7f491" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that have at least one value that, if used as an argument to an arithmetic operation, will generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;trap&lt;/a&gt;.</source>
          <target state="translated">的值 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; 就是 &lt;code&gt;true&lt;/code&gt; 所有算术类型 &lt;code&gt;T&lt;/code&gt; 具有至少一个值，如果使用作为参数传递给算术运算，将产生一个&lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;陷阱&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7772c8f78a06c27107be30f83bed9d48e68fe602" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;T(rv)&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the initialization.</source>
          <target state="translated">的值 &lt;code&gt;T(rv)&lt;/code&gt; 是相当于所述数值 &lt;code&gt;rv&lt;/code&gt; 的初始化之前。</target>
        </trans-unit>
        <trans-unit id="e603736762efe81e0cad9751283ad8e5a1c288ee" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;T(v)&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">的值 &lt;code&gt;T(v)&lt;/code&gt; 相当于值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8ede44778ad8d0c527731cf4a992de2cbbc6337" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is a/2b</source>
          <target state="translated">&lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; 的值是a / 2b</target>
        </trans-unit>
        <trans-unit id="0e75326e3adb574a4a577f0c6f90eb22555c8d18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is the unique value congruent to a * 2b</source>
          <target state="translated">值 &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 是独特的价值一致的* 2B</target>
        </trans-unit>
        <trans-unit id="74363b0d87e71eb3303d92bd255f435d2a3c664f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;base&lt;/code&gt; if successful, zero otherwise.</source>
          <target state="translated">如果成功，则 &lt;code&gt;base&lt;/code&gt; 的值，否则为零。</target>
        </trans-unit>
        <trans-unit id="56ee130795a5dbf75897c6a6783296c3ad1b779f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt; at program startup, and although library functions are allowed to write positive integers to &lt;code&gt;errno&lt;/code&gt; whether or not an error occurred, library functions never store &lt;code&gt;​0​&lt;/code&gt; in &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">值 &lt;code&gt;errno&lt;/code&gt; 是 &lt;code&gt;​0​&lt;/code&gt; ，程序启动时，尽管库函数可以写正整数到 &lt;code&gt;errno&lt;/code&gt; 是否发生了错误，库函数永远保存 &lt;code&gt;​0​&lt;/code&gt; 的 &lt;code&gt;errno&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da2294d8108c3a6f801f89b03514268af0f31351" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;math_errhandling&lt;/code&gt; indicates the type of error handling that is performed by the floating-point operators and &lt;a href=&quot;../math&quot;&gt;functions&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;math_errhandling&lt;/code&gt; 的值指示由浮点运算符和&lt;a href=&quot;../math&quot;&gt;函数&lt;/a&gt;执行的错误处理的类型：</target>
        </trans-unit>
        <trans-unit id="7588ffd7a3be6d286f7a94c5cb61054a64fe7ac0" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;required_alignment&lt;/code&gt; is the required alignment for an object to be referenced by an atomic reference, which is at least &lt;code&gt;alignof(T)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;required_alignment&lt;/code&gt; 的值是原子引用要引用的对象的必需对齐，至少应为 &lt;code&gt;alignof(T)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a34573176a6c9f015786e0ff510ba4a79a46897b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">的值 &lt;code&gt;t&lt;/code&gt; 等于的值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="236ee56b867559bead4e59b54a4e12b218879b5a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;u&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the initialization.</source>
          <target state="translated">价值 &lt;code&gt;u&lt;/code&gt; 等同于价值 &lt;code&gt;rv&lt;/code&gt; 在初始化之前。</target>
        </trans-unit>
        <trans-unit id="29aad058a8f1625b999d87663e4e7194ff6bfb72" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;u&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">价值 &lt;code&gt;u&lt;/code&gt; 等同于价值 &lt;code&gt;v&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c88528c3373936092717d4d0ad525f88f8c4c725" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;v&lt;/code&gt; is unchanged.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 的值不变。</target>
        </trans-unit>
        <trans-unit id="1e00c73d0ffbf3ea2f54f0b446263ab8f6d39011" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;std::contract_violation&lt;/code&gt; argument passed to the violation handler is otherwise implementation-defined.</source>
          <target state="translated">否则，传递给违反处理程序的 &lt;code&gt;std::contract_violation&lt;/code&gt; 参数的值是实现定义的。</target>
        </trans-unit>
        <trans-unit id="50fc3e65512141062b28f772c21ab1b1ae455710" translate="yes" xml:space="preserve">
          <source>The value of the atomic variable before the call.</source>
          <target state="translated">调用前原子变量的值。</target>
        </trans-unit>
        <trans-unit id="a3e86cc39cfa2d8064dc4c87f48911c38b5823b0" translate="yes" xml:space="preserve">
          <source>The value of the character pointed to by the</source>
          <target state="translated">指向的字符的值。</target>
        </trans-unit>
        <trans-unit id="a2c309bf2bbc046c6f48e885d2ea4de4c5bf6803" translate="yes" xml:space="preserve">
          <source>The value of the character that was pointed to by the</source>
          <target state="translated">指向的字符的值。</target>
        </trans-unit>
        <trans-unit id="1d70250e3d2b884af86af7d39be631bda55177ff" translate="yes" xml:space="preserve">
          <source>The value of the character that was read and consumed in case of success, or &lt;code&gt;Traits::eof()&lt;/code&gt; in case of failure.</source>
          <target state="translated">如果成功则读取和使用的字符值，如果失败则读取 &lt;code&gt;Traits::eof()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8f39527ddfa65bb2b87383657aeac9ba9fbcb938" translate="yes" xml:space="preserve">
          <source>The value of the device entropy, or zero if not applicable.</source>
          <target state="translated">器件的熵值,如果不适用,则为零。</target>
        </trans-unit>
        <trans-unit id="9650465fffa6e1c6a542896eedb2d7c139c42b4e" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;std::ilogb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;std::ilogb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">由于不同的规范化要求， &lt;code&gt;std::ilogb&lt;/code&gt; 返回的指数的值总是比 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; 的指数小1 ：对于 &lt;code&gt;std::ilogb&lt;/code&gt; 返回的指数 &lt;code&gt;e&lt;/code&gt; ，| arg * re</target>
        </trans-unit>
        <trans-unit id="296087b3564287e313cec1b7f024f1690f7740f9" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;std::logb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;std::logb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">由于标准化要求不同， &lt;code&gt;std::logb&lt;/code&gt; 返回的指数的值总是比 &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; 的指数小1 ：对于 &lt;code&gt;std::logb&lt;/code&gt; 返回的指数 &lt;code&gt;e&lt;/code&gt; ，| arg * re</target>
        </trans-unit>
        <trans-unit id="1875dc13670139d279ca0c0bbdce2d158a5cdbab" translate="yes" xml:space="preserve">
          <source>The value of the next character. If the input sequence has been exhausted, &lt;code&gt;Traits::eof()&lt;/code&gt; is returned.</source>
          <target state="translated">下一个字符的值。如果输入序列已用尽，则返回 &lt;code&gt;Traits::eof()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="753fa9ec46bd8acaa1bc2b9508919ca2004c1c39" translate="yes" xml:space="preserve">
          <source>The value of the parameter is passed to the object at the construction time and stored within the object. Whenever the function object is invoked though &lt;code&gt;operator()&lt;/code&gt;, the stored value is passed as one of the arguments, the other argument is passed as an argument of &lt;code&gt;operator()&lt;/code&gt;. The resulting function object is an unary function.</source>
          <target state="translated">参数的值在构造时传递给对象，并存储在对象中。每当通过 &lt;code&gt;operator()&lt;/code&gt; 调用功能对象时，存储的值将作为参数之一传递，另一个参数将作为 &lt;code&gt;operator()&lt;/code&gt; 的参数传递。结果函数对象是一元函数。</target>
        </trans-unit>
        <trans-unit id="fba7a209e09ccfdda21dc54ae2df8a504208cb4c" translate="yes" xml:space="preserve">
          <source>The value of the referenced object before the call.</source>
          <target state="translated">调用前被引用对象的值。</target>
        </trans-unit>
        <trans-unit id="579ea98c704ce031e4e668b7afec012ffc8fd162" translate="yes" xml:space="preserve">
          <source>The value of the referenced object, immediately preceding the effects of this function.</source>
          <target state="translated">被引用对象的值,紧接在本函数的效果之前。</target>
        </trans-unit>
        <trans-unit id="7e259073fe670a628dfb34370ab4b87683b659c4" translate="yes" xml:space="preserve">
          <source>The value of this constant is consistent with both the macro &lt;code&gt;ATOMIC_xxx_LOCK_FREE&lt;/code&gt;, where defined, with the member function &lt;code&gt;is_lock_free&lt;/code&gt; and non-member function &lt;code&gt;&lt;a href=&quot;../atomic_is_lock_free&quot;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该常量的值与宏 &lt;code&gt;ATOMIC_xxx_LOCK_FREE&lt;/code&gt; （在其中定义）与成员函数 &lt;code&gt;is_lock_free&lt;/code&gt; 和非成员函数 &lt;code&gt;&lt;a href=&quot;../atomic_is_lock_free&quot;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50845a026f496d39a63c3b0808c04361d0c8d58a" translate="yes" xml:space="preserve">
          <source>The value of this constant is consistent with the result of member function &lt;code&gt;is_lock_free&lt;/code&gt;.</source>
          <target state="translated">该常数的值与成员函数 &lt;code&gt;is_lock_free&lt;/code&gt; 的结果一致。</target>
        </trans-unit>
        <trans-unit id="3403e199b11ef7fa0931fa58eddb8861252d4576" translate="yes" xml:space="preserve">
          <source>The value of type &lt;code&gt;char_type&lt;/code&gt; to use as the decimal separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;L'.'&lt;/code&gt;.</source>
          <target state="translated">用作小数点分隔符的 &lt;code&gt;char_type&lt;/code&gt; 类型的值。 &lt;code&gt;std::numpunct&lt;/code&gt; 的标准专业化返回 &lt;code&gt;'.'&lt;/code&gt; 和 &lt;code&gt;L'.'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d17479026d3ea907d688db9d63f82d0f2b54dabe" translate="yes" xml:space="preserve">
          <source>The value or reference, if any, returned by the above call to &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">上面对 &lt;code&gt;Container::emplace_back&lt;/code&gt; 调用返回的值或引用（如果有）。</target>
        </trans-unit>
        <trans-unit id="c811b075e6e49eb2c35eb490d71ce4d51653f77f" translate="yes" xml:space="preserve">
          <source>The value previously held by the flag pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">先前由 &lt;code&gt;p&lt;/code&gt; 指向的标志保存的值。</target>
        </trans-unit>
        <trans-unit id="2e567269120efb53b09110c26a8c4b9df966cef5" translate="yes" xml:space="preserve">
          <source>The value represented by the digit &lt;code&gt;c&lt;/code&gt; in base &lt;code&gt;I&lt;/code&gt; if the character &lt;code&gt;c&lt;/code&gt; is a valid digit in base &lt;code&gt;I&lt;/code&gt;</source>
          <target state="translated">由数字表示的值 &lt;code&gt;c&lt;/code&gt; 在碱 &lt;code&gt;I&lt;/code&gt; 如果字符 &lt;code&gt;c&lt;/code&gt; 是在碱的有效位数的 &lt;code&gt;I&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f109c11a81bea0070c0d68dbb9891509f2180fe" translate="yes" xml:space="preserve">
          <source>The value represents the number of failures in a series of independent yes/no trials (each succeeds with probability p), before exactly k successes occur.</source>
          <target state="translated">该值表示在一系列独立的是/否试验中(每一次成功的概率为p),在正好k次成功之前的失败次数。</target>
        </trans-unit>
        <trans-unit id="8e434c235337a8e747f5dea3bd883fac3c017159" translate="yes" xml:space="preserve">
          <source>The value represents the number of yes/no trials (each succeeding with probability p) which are necessary to obtain a single success.</source>
          <target state="translated">该值表示获得一次成功所需的 &quot;是&quot;/&quot;否 &quot;试验次数(每次成功的概率为p)。</target>
        </trans-unit>
        <trans-unit id="bf46f4d3ca59d9f0505163079a8aeb0e0dc873f3" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;clock()&lt;/code&gt; may wrap around on some implementations. For example, on a machine with 32-bit &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt;, it wraps after 2147 seconds or 36 minutes.</source>
          <target state="translated">&lt;code&gt;clock()&lt;/code&gt; 返回的值可能会在某些实现中回绕。例如，在具有32位 &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; ，它在2147秒或36分钟后自动换行。</target>
        </trans-unit>
        <trans-unit id="ad4cdd680a12e6dfddb5ab5b51fcd6bb72586940" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 返回的值。</target>
        </trans-unit>
        <trans-unit id="2f06ccf9b4233e6226d4ee4962b6bec1aa785187" translate="yes" xml:space="preserve">
          <source>The value returned by the called function.</source>
          <target state="translated">被调用函数返回的值。</target>
        </trans-unit>
        <trans-unit id="601b8abd8b6436ee946fa9803b76f69133a0a540" translate="yes" xml:space="preserve">
          <source>The value returned by this conversion function is a pointer to a function with C++ &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; that, when invoked, has the same effect as invoking the closure object's function call operator directly.</source>
          <target state="translated">此转换函数返回的值是指向具有C ++ &lt;a href=&quot;language_linkage&quot;&gt;语言链接&lt;/a&gt;的函数的指针，该函数在被调用时与直接调用闭包对象的函数调用操作符具有相同的作用。</target>
        </trans-unit>
        <trans-unit id="fdd035144b0ab851484c1c365e56cbd1dcc1b54a" translate="yes" xml:space="preserve">
          <source>The value returned shall be independent of the case of the characters in the sequence.</source>
          <target state="translated">返回的值应与序列中字符的大小写无关。</target>
        </trans-unit>
        <trans-unit id="b7fb32b3c03551e69bd2a36e0056ba4535fa1910" translate="yes" xml:space="preserve">
          <source>The value that is held by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;obj&lt;/code&gt; 指向的原子对象持有的值。</target>
        </trans-unit>
        <trans-unit id="833d5a34e8e09458e1d01611adfdc9d19f4256ea" translate="yes" xml:space="preserve">
          <source>The value that results from assigning or initializing a signed bit field with a value out of range, or from incrementing a signed bit field past its range.</source>
          <target state="translated">赋值或初始化超出范围的有符号的位字段,或递增超过范围的有符号的位字段所产生的值。</target>
        </trans-unit>
        <trans-unit id="da945c5370b89f1c8352311f12a54ddba345a51b" translate="yes" xml:space="preserve">
          <source>The value type of &lt;code&gt;RandomIt1&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;RandomIt1&lt;/code&gt; 的值类型必须为&lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;，&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;和&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cf2f9d6307fbcb0677baa700e9f0dbc912c45998" translate="yes" xml:space="preserve">
          <source>The value zero (for integral, floating-point, and unscoped enumeration) and the null pointer and the null pointer-to-member values become &lt;code&gt;false&lt;/code&gt;. All other values become &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">零值（用于整数，浮点数和无作用域枚举）以及null指针和null指向成员的值将变为 &lt;code&gt;false&lt;/code&gt; 。所有其他值变为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ba8effa4c27f0ba732998c45f3421c98781d70d" translate="yes" xml:space="preserve">
          <source>The values in the returned struct may differ from those supplied to the constructor in the following ways:</source>
          <target state="translated">返回的结构中的值可能与提供给构造函数的值不同,具体如下。</target>
        </trans-unit>
        <trans-unit id="7a76aed414f920671ac2d5636063f80c02930b91" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sep_by_space&lt;/code&gt;, &lt;code&gt;n_sep_by_space&lt;/code&gt;, &lt;code&gt;int_p_sep_by_space&lt;/code&gt;, &lt;code&gt;int_n_sep_by_space&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">值 &lt;code&gt;p_sep_by_space&lt;/code&gt; ， &lt;code&gt;n_sep_by_space&lt;/code&gt; ， &lt;code&gt;int_p_sep_by_space&lt;/code&gt; ， &lt;code&gt;int_n_sep_by_space&lt;/code&gt; 的解释如下：</target>
        </trans-unit>
        <trans-unit id="77672f917a9b339a086c2698e191450e19cf6727" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sign_posn&lt;/code&gt;, &lt;code&gt;n_sign_posn&lt;/code&gt;, &lt;code&gt;int_p_sign_posn&lt;/code&gt;, &lt;code&gt;int_n_sign_posn&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">值 &lt;code&gt;p_sign_posn&lt;/code&gt; ， &lt;code&gt;n_sign_posn&lt;/code&gt; ， &lt;code&gt;int_p_sign_posn&lt;/code&gt; ， &lt;code&gt;int_n_sign_posn&lt;/code&gt; 的解释如下：</target>
        </trans-unit>
        <trans-unit id="33abc0ae5b48791fecb22e74c9f73d03bb18aa24" translate="yes" xml:space="preserve">
          <source>The values of the member typedefs are as follows.</source>
          <target state="translated">成员类型定义的值如下:</target>
        </trans-unit>
        <trans-unit id="e9fe6d1f76a572b29a8d3484a98866cb41ec603b" translate="yes" xml:space="preserve">
          <source>The values of these macros (except for &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.</source>
          <target state="translated">这些宏的值（ &lt;code&gt;__FILE__&lt;/code&gt; 和 &lt;code&gt;__LINE__&lt;/code&gt; 除外）在整个翻译单元中保持不变。尝试重新定义或取消定义这些宏会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="98bfbbcd22ae41d5573869cfcb9522362b10fb4c" translate="yes" xml:space="preserve">
          <source>The version of this function provided in the standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; does the following:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 的标准库专业提供的此函数的版本执行以下操作：</target>
        </trans-unit>
        <trans-unit id="a622961aafca050ec72f078b30740b239e4cfd26" translate="yes" xml:space="preserve">
          <source>The versions (1-4) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. Versions (1-8) are</source>
          <target state="translated">即使不包含 &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; 标头，也会在每个翻译单元中隐式声明版本（1-4）。版本（1-8）是</target>
        </trans-unit>
        <trans-unit id="b0b7d7c2aa828b9a641d26b6867ec8872ed88500" translate="yes" xml:space="preserve">
          <source>The weak forms ((1) and (3)) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*obj != *expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</source>
          <target state="translated">函数的弱形式（（1）和（3））允许虚假地失败，即，即使它们相等，也表现为 &lt;code&gt;*obj != *expected&lt;/code&gt; 。当比较和交换处于循环中时，弱版本将在某些平台上产生更好的性能。</target>
        </trans-unit>
        <trans-unit id="053ece5439dd03785d396cff64f13b7779aae0c4" translate="yes" xml:space="preserve">
          <source>The weak forms (1-2) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*this != expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</source>
          <target state="translated">函数的弱形式（1-2）允许虚假地失败，即，即使它们相等，也表现为 &lt;code&gt;*this != expected&lt;/code&gt; 。当比较和交换处于循环中时，弱版本将在某些平台上产生更好的性能。</target>
        </trans-unit>
        <trans-unit id="61282ad563d58ac6dca223420c82a6fda52cb8a1" translate="yes" xml:space="preserve">
          <source>The weakest alignment (the smallest alignment requirement) is the alignment of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt;, which equals 1; the largest</source>
          <target state="translated">最弱的对齐方式（最小的对齐要求）是 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;signed char&lt;/code&gt; 和 &lt;code&gt;unsigned char&lt;/code&gt; 的对齐方式，等于1；最大的</target>
        </trans-unit>
        <trans-unit id="6636ab7a40ed20b3758bf9d6aa3f53a69dfb3fd6" translate="yes" xml:space="preserve">
          <source>The weekday value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">工作日值存储在 &lt;code&gt;*this&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="147c41b97d63a5ff943a4dff64e656850433bca6" translate="yes" xml:space="preserve">
          <source>The whitespace skipping is performed by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt;, which reads and discards the characters classified as whitespace by the &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet of the stream's imbued locale.</source>
          <target state="translated">空格跳过由 &lt;code&gt;&lt;a href=&quot;../basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt; 的构造函数执行，该构造函数读取并丢弃由流注入区域设置的 &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 面分类为空格的字符。</target>
        </trans-unit>
        <trans-unit id="28861a2e9cac8a64e7e6c9de02d8f4ad1d432f65" translate="yes" xml:space="preserve">
          <source>The width property of the stream will be reset to zero (meaning &quot;unspecified&quot;) if any of the following functions are called:</source>
          <target state="translated">如果调用以下任何一个函数,流的宽度属性将被重置为零(意味着 &quot;未指定&quot;)。</target>
        </trans-unit>
        <trans-unit id="75482b7330efd238856a66fa9534aa457b8aac86" translate="yes" xml:space="preserve">
          <source>The written character, converted to &lt;code&gt;int_type&lt;/code&gt; with &lt;code&gt;Traits::to_int_type(ch)&lt;/code&gt; on success.</source>
          <target state="translated">写入的字符在成功时通过 &lt;code&gt;Traits::to_int_type(ch)&lt;/code&gt; 转换为 &lt;code&gt;int_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1270ca56a41a6e7f02e1f97ce0b715f2fb7199a2" translate="yes" xml:space="preserve">
          <source>The year value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">存储在 &lt;code&gt;*this&lt;/code&gt; 中的年份值。</target>
        </trans-unit>
        <trans-unit id="d323f4076e0841438d41510cd53cbcfb9286a841" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;replacement&lt;/code&gt; is appended as if by &lt;code&gt;operator+=(replacement)&lt;/code&gt;.</source>
          <target state="translated">然后 &lt;code&gt;replacement&lt;/code&gt; 被附加，好像是由 &lt;code&gt;operator+=(replacement)&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="373a08cad37838d1afc67f2d26d81125cf6dd627" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;std::launder(p)&lt;/code&gt; returns a value of type &lt;code&gt;T*&lt;/code&gt; that points to the object &lt;code&gt;X&lt;/code&gt;. Otherwise, the behavior is undefined.</source>
          <target state="translated">然后 &lt;code&gt;std::launder(p)&lt;/code&gt; 返回类型的值 &lt;code&gt;T*&lt;/code&gt; 指向对象 &lt;code&gt;X&lt;/code&gt; 。否则，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="a8cef55836d6512dfe4dc252602d2fb2a942c56d" translate="yes" xml:space="preserve">
          <source>Then converts the argument &lt;code&gt;dir&lt;/code&gt; to a value &lt;code&gt;whence&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt; as follows:</source>
          <target state="translated">然后将参数转换 &lt;code&gt;dir&lt;/code&gt; 的值 &lt;code&gt;whence&lt;/code&gt; 类型的 &lt;code&gt;int&lt;/code&gt; 如下：</target>
        </trans-unit>
        <trans-unit id="d114c31b8c85d68931469ea5e0153732743033d0" translate="yes" xml:space="preserve">
          <source>Then for the expression &lt;code&gt;w1 == w2&lt;/code&gt; and &lt;code&gt;w1 != w2&lt;/code&gt; either or both objects may be replaced by an</source>
          <target state="translated">然后，对于表达式 &lt;code&gt;w1 == w2&lt;/code&gt; 和 &lt;code&gt;w1 != w2&lt;/code&gt; ，可以将一个或两个对象替换为</target>
        </trans-unit>
        <trans-unit id="5664e9f77aa6963c92dfdd8b0b7e6f96d1c31677" translate="yes" xml:space="preserve">
          <source>Then performs move-assignment by moving all contents from &lt;code&gt;other&lt;/code&gt;, including the temporary storage, the wrapped stream pointer, policy, and all other state (such as the mutex pointer). After move, &lt;code&gt;other&lt;/code&gt; is not associated with a stream, and &lt;code&gt;other.get_wrapped()==nullptr&lt;/code&gt;. The put area member pointers of the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;other&lt;/code&gt; are guaranteed to be null. Destroying a moved-from &lt;code&gt;other&lt;/code&gt; will not produce any output.</source>
          <target state="translated">然后，通过移动 &lt;code&gt;other&lt;/code&gt; 所有内容（包括临时存储，包装的流指针，策略和所有其他状态（例如互斥锁指针））来执行移动分配。移动之后， &lt;code&gt;other&lt;/code&gt; 不与流关联， &lt;code&gt;other.get_wrapped()==nullptr&lt;/code&gt; 。基类的投放区域成员指针 &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;other&lt;/code&gt; 保证是零。销毁 &lt;code&gt;other&lt;/code&gt; 移动设备不会产生任何输出。</target>
        </trans-unit>
        <trans-unit id="688a34f8e387e542a111a325ed5ac02b72fbb6e9" translate="yes" xml:space="preserve">
          <source>Then repositions the file pointer, as if by calling &lt;code&gt;&lt;a href=&quot;../c/fsetpos&quot;&gt;std::fsetpos()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">然后重新定位文件指针，就像通过调用 &lt;code&gt;&lt;a href=&quot;../c/fsetpos&quot;&gt;std::fsetpos()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c6cd6761eff74a4e8721e60e098e84a0745d88f" translate="yes" xml:space="preserve">
          <source>Then stores each character from the resulting sequence (the contents of &lt;code&gt;str&lt;/code&gt; plus padding) to the output stream &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt;.</source>
          <target state="translated">然后将结果序列中的每个字符（ &lt;code&gt;str&lt;/code&gt; 和padding 的内容）存储到输出流 &lt;code&gt;os&lt;/code&gt; 中，就像通过调用 &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; ，其中 &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89dd54897998475390b292a027e7346fd0e80fba" translate="yes" xml:space="preserve">
          <source>Then stores each character from the resulting sequence (the contents of &lt;code&gt;v&lt;/code&gt; plus padding) to the output stream &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt;.</source>
          <target state="translated">然后将结果序列中的每个字符（ &lt;code&gt;v&lt;/code&gt; 的内容加上填充）存储到输出流 &lt;code&gt;os&lt;/code&gt; 中，就像通过调用 &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; ，其中 &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b71560ffb9f745af8a0de8c02270fff34828d1a4" translate="yes" xml:space="preserve">
          <source>Then template-1 is more specialized than template-2. If the conditions above are true after switching template order, than template-2 is more specialized than template-1. Otherwise, neither template is more specialized than the other. In case of a tie, if one function template has a trailing parameter pack and the other does not, the one with the omitted parameter is considered to be more specialized than the one with the empty parameter pack.</source>
          <target state="translated">那么模板-1比模板-2更专业。如果切换模板顺序后上述条件为真,则模板-2比模板-1更专业。否则,两个模板都不比另一个模板更专业。如果出现相同的情况,如果一个函数模板有尾部参数包,而另一个没有,则省略参数的模板被认为比空参数包的模板更专业。</target>
        </trans-unit>
        <trans-unit id="d3271caf912e95526fbf0f4e50e8dacc62c22392" translate="yes" xml:space="preserve">
          <source>Then the function behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, if any &lt;code&gt;ios_base::iostate&lt;/code&gt; flags are set, the function sets &lt;code&gt;failbit&lt;/code&gt; and returns. Otherwise, calls &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt;.</source>
          <target state="translated">然后，该函数表现为&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;。构造并检查哨兵对象后，如果设置了任何 &lt;code&gt;ios_base::iostate&lt;/code&gt; 标志，则该函数将设置 &lt;code&gt;failbit&lt;/code&gt; 并返回。否则，调用 &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36f34a067b6d5809ad8db68785a0d829422e3317" translate="yes" xml:space="preserve">
          <source>Then this function in the class &lt;code&gt;Derived&lt;/code&gt; is also</source>
          <target state="translated">那么在 &lt;code&gt;Derived&lt;/code&gt; 类中的这个函数也是</target>
        </trans-unit>
        <trans-unit id="7f48f8e860002b0a6fca10b3b58cdef248ff8167" translate="yes" xml:space="preserve">
          <source>Then, &lt;code&gt;awaiter.await_ready()&lt;/code&gt; is called (this is a short-cut to avoid the cost of suspension if it's known that the result is ready or can be completed synchronously). If its result, contextually-converted to bool is &lt;code&gt;false&lt;/code&gt; then.</source>
          <target state="translated">然后， &lt;code&gt;awaiter.await_ready()&lt;/code&gt; （这是一种捷径，如果知道结果已准备好或可以同步完成，则可以避免因挂起而产生的费用）。如果根据上下文转换为bool的结果为 &lt;code&gt;false&lt;/code&gt; ，则为假。</target>
        </trans-unit>
        <trans-unit id="8f56bc35fde57e5d45735f7118718bf8634008b7" translate="yes" xml:space="preserve">
          <source>Then, a dot character is appended to the generic-format view of the pathname, if &lt;code&gt;replacement&lt;/code&gt; is not empty or does not begin with a dot character.</source>
          <target state="translated">然后，如果 &lt;code&gt;replacement&lt;/code&gt; 不为空或不是以点字符开头，则将点字符附加到路径名的通用格式视图中。</target>
        </trans-unit>
        <trans-unit id="7a8ce560ef479ac7bd437cfaae9fee813911dce4" translate="yes" xml:space="preserve">
          <source>Then, closes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, regardless of whether any of the preceding calls succeeded or failed.</source>
          <target state="translated">然后，就像调用 &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; 一样关闭文件，而不管前面的任何调用成功还是失败。</target>
        </trans-unit>
        <trans-unit id="bb70360ec88c4bb9dac2644a98645695f52f42d5" translate="yes" xml:space="preserve">
          <source>Then, for the expressions &lt;code&gt;p1 == p2&lt;/code&gt;, &lt;code&gt;p1 != p2&lt;/code&gt;, &lt;code&gt;p1 &amp;lt; p2&lt;/code&gt;&lt;code&gt;p1 &amp;lt;= p2&lt;/code&gt;, &lt;code&gt;p1 &amp;gt;= p2&lt;/code&gt;, &lt;code&gt;p1 &amp;gt; p2&lt;/code&gt;, &lt;code&gt;p1 - p2&lt;/code&gt;} either or both objects may be replaced by an</source>
          <target state="translated">然后，对于表达式 &lt;code&gt;p1 == p2&lt;/code&gt; ， &lt;code&gt;p1 != p2&lt;/code&gt; ， &lt;code&gt;p1 &amp;lt; p2&lt;/code&gt; &lt;code&gt;p1 &amp;lt;= p2&lt;/code&gt; ， &lt;code&gt;p1 &amp;gt;= p2&lt;/code&gt; ， &lt;code&gt;p1 &amp;gt; p2&lt;/code&gt; ， &lt;code&gt;p1 - p2&lt;/code&gt; }可以用</target>
        </trans-unit>
        <trans-unit id="03792c753032d7cb9233d55af244f2b35fa6ba5a" translate="yes" xml:space="preserve">
          <source>Then, if &lt;code&gt;seq.size() &amp;lt; out.width()&lt;/code&gt;, adds &lt;code&gt;out.width()-seq.size()&lt;/code&gt; copies of the fill character &lt;code&gt;out.fill()&lt;/code&gt; either at the end of the sequence (if &lt;code&gt;ios_base::left&lt;/code&gt; is set in &lt;code&gt;out.flags()&lt;/code&gt;) or at the beginning of the sequence (in all other cases).</source>
          <target state="translated">然后，如果 &lt;code&gt;seq.size() &amp;lt; out.width()&lt;/code&gt; ，则在序列的末尾添加 &lt;code&gt;out.width()-seq.size()&lt;/code&gt; 填充字符 &lt;code&gt;out.fill()&lt;/code&gt; 的副本（如果 &lt;code&gt;ios_base::left&lt;/code&gt; 可以在 &lt;code&gt;out.flags()&lt;/code&gt; 中设置，也可以在序列的开头设置（在所有其他情况下）。</target>
        </trans-unit>
        <trans-unit id="9b66cf1ae7e463d5761dc0c8e4b85c87a42f6ae4" translate="yes" xml:space="preserve">
          <source>Then, if the character encoding is fixed-width (&lt;code&gt;codecvt::encoding()&lt;/code&gt; returns some positive number &lt;code&gt;width&lt;/code&gt;, moves the file pointer as if by &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, width*off, whence)&lt;/code&gt;.</source>
          <target state="translated">然后，如果字符编码为固定宽度（ &lt;code&gt;codecvt::encoding()&lt;/code&gt; 返回正数 &lt;code&gt;width&lt;/code&gt; ，则通过 &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, width*off, whence)&lt;/code&gt; 移动文件指针。</target>
        </trans-unit>
        <trans-unit id="1588837f0abae43644f6a59f2a7e9d05829935b3" translate="yes" xml:space="preserve">
          <source>Then, if the current emit-on-sync policy is &lt;code&gt;true&lt;/code&gt;, makes a call to &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">然后，如果当前的异步同步策略为 &lt;code&gt;true&lt;/code&gt; ，则调用一下&lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e328ed3f5e3fe95a687636b98322058fa4cd84c4" translate="yes" xml:space="preserve">
          <source>Then, move-assigns the wrapped &lt;code&gt;std::basic_syncbuf&lt;/code&gt; from the corresponding member of &lt;code&gt;other&lt;/code&gt; (after this move-assignment, &lt;code&gt;other.get_wrapped()&lt;/code&gt; returns a null pointer and destruction of &lt;code&gt;other&lt;/code&gt; produces no output) and &lt;a href=&quot;../basic_ostream/operator=&quot;&gt;move-assigns&lt;/a&gt; the base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; (this swaps all stream state variables except for &lt;code&gt;rdbuf&lt;/code&gt; between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;).</source>
          <target state="translated">然后，从 &lt;code&gt;other&lt;/code&gt; 的相应成员移动分配包装的 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; （在此移动分配之后， &lt;code&gt;other.get_wrapped()&lt;/code&gt; 返回空指针，而对 &lt;code&gt;other&lt;/code&gt; 的销毁不产生任何输出），并&lt;a href=&quot;../basic_ostream/operator=&quot;&gt;移动分配&lt;/a&gt;基本 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; ::: basic_ostream（这将在 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间交换除 &lt;code&gt;rdbuf&lt;/code&gt; 之外的所有流状态变量）。</target>
        </trans-unit>
        <trans-unit id="cac51d51872e9519bbc0bc669f0606d196b2f4a3" translate="yes" xml:space="preserve">
          <source>Then, the awaiter object is obtained, as follows:</source>
          <target state="translated">然后,得到等待者对象,如下所示。</target>
        </trans-unit>
        <trans-unit id="6b9e0d6ed6f7b1751b629f6e3ddc80ecb32c6693" translate="yes" xml:space="preserve">
          <source>Then, whether &lt;code&gt;to&lt;/code&gt; already existed or was just created, iterates over the files contained in &lt;code&gt;from&lt;/code&gt; as if by &lt;code&gt;for (const &lt;a href=&quot;directory_entry&quot;&gt;std::filesystem::directory_entry&lt;/a&gt;&amp;amp; x : &lt;a href=&quot;directory_iterator&quot;&gt;std::filesystem::directory_iterator&lt;/a&gt;(from))&lt;/code&gt; and for each directory entry, recursively calls &lt;code&gt;copy(x.path(), to/x.path().filename(), options | in-recursive-copy)&lt;/code&gt;, where</source>
          <target state="translated">然后，无论 &lt;code&gt;to&lt;/code&gt; 已经存在还是刚刚创建的，都对by中的文件进行迭代 &lt;code&gt;from&lt;/code&gt; 就像by &lt;code&gt;for (const &lt;a href=&quot;directory_entry&quot;&gt;std::filesystem::directory_entry&lt;/a&gt;&amp;amp; x : &lt;a href=&quot;directory_iterator&quot;&gt;std::filesystem::directory_iterator&lt;/a&gt;(from))&lt;/code&gt; 和每个目录条目一样，递归调用 &lt;code&gt;copy(x.path(), to/x.path().filename(), options | in-recursive-copy)&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="e9125d469bb8f6aff93d3721871c0958a43dafdd" translate="yes" xml:space="preserve">
          <source>Then, x1 and x2 are</source>
          <target state="translated">那么,x1和x2是</target>
        </trans-unit>
        <trans-unit id="c5bb0afc7219a935f5a73b87436c78d57282e9f3" translate="yes" xml:space="preserve">
          <source>Then.</source>
          <target state="translated">Then.</target>
        </trans-unit>
        <trans-unit id="dcb618e3bc4e6760e6d24a1d8c4732cdb2523ec0" translate="yes" xml:space="preserve">
          <source>Theoretical maximum allocation size.</source>
          <target state="translated">理论上最大分配规模。</target>
        </trans-unit>
        <trans-unit id="7dcca98b4934dc33e5546547c327611fcc667809" translate="yes" xml:space="preserve">
          <source>There are alternative spellings for several operators and other tokens that use non-ISO646 characters. In all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the &lt;a href=&quot;../preprocessor/replace&quot;&gt;stringification operator&lt;/a&gt; can make the spelling visible). The two-letter alternative tokens are sometimes called &quot;digraphs&quot;</source>
          <target state="translated">对于使用非ISO646字符的多个运算符和其他标记，还有其他拼写。在语言的所有方面，每个替代标记的行为都与其主要标记完全相同，除了其拼写（&lt;a href=&quot;../preprocessor/replace&quot;&gt;字符串化运算符&lt;/a&gt;可以使拼写可见）。两个字母的替代令牌有时称为&amp;ldquo;有向图&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="8e6f3eaebb9a3927bc985adcb62df7d15d191025" translate="yes" xml:space="preserve">
          <source>There are compiler extensions that may be used to generate C++ exceptions automatically whenever a floating-point exception is raised:</source>
          <target state="translated">有一些编译器扩展可以用来在浮点异常发生时自动生成C++异常。</target>
        </trans-unit>
        <trans-unit id="3f225f0e74f08c0d0f2caf0e296a39e971ff8239" translate="yes" xml:space="preserve">
          <source>There are five available return types:</source>
          <target state="translated">有五种可用的返回类型。</target>
        </trans-unit>
        <trans-unit id="c8b561cc0eef33e481077a8d77db9eb795dcf585" translate="yes" xml:space="preserve">
          <source>There are five(until C++17)six(since C++17) kinds of iterators: &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, &lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, and &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;(since C++17).</source>
          <target state="translated">（自C ++ 17起）有五种（自C ++ 17起）六种迭代器：&lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;，&lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;，&lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;，&lt;a href=&quot;named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;，&lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;和&lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;（从C ++ 17开始）。</target>
        </trans-unit>
        <trans-unit id="9778100d7798733f17cf489450cafd2088023fa7" translate="yes" xml:space="preserve">
          <source>There are many different NaN values with different sign bits and payloads, see &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;std::nan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits/quiet_nan&quot;&gt;std::numeric_limits::quiet_NaN&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有许多不同的NaN值具有不同的符号位和有效载荷，请参阅 &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;std::nan&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits/quiet_nan&quot;&gt;std::numeric_limits::quiet_NaN&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e03334de5cfa0b9f96707c08d7bef755bc11a3c" translate="yes" xml:space="preserve">
          <source>There are many different NaN values, differentiated by their payloads and their sign bits. The contents of the payload and the sign bit of the NaN generated by the macro &lt;code&gt;NAN&lt;/code&gt; are implementation-defined.</source>
          <target state="translated">有许多不同的NaN值，它们的有效载荷和符号位不同。宏 &lt;code&gt;NAN&lt;/code&gt; 生成的有效载荷的内容和NaN的符号位是实现定义的。</target>
        </trans-unit>
        <trans-unit id="a956cc8cb0205c1b4676cee813cb10d9f4679af6" translate="yes" xml:space="preserve">
          <source>There are many types for which equality makes sense, but not less-than ordering: a common example are the complex numbers, or any pair of numbers in general:</source>
          <target state="translated">有很多类型的平等是有意义的,但不克不及排序:一个常见的例子是复数,或一般的任何一对数。</target>
        </trans-unit>
        <trans-unit id="694fc92221739aa50089385fa6fdb3ce4ff4a1f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt; for bit fields: &lt;code&gt;int b : 1 = 0;&lt;/code&gt; and &lt;code&gt;int b : 1 {0}&lt;/code&gt; are ill-formed.</source>
          <target state="translated">位域没有&lt;a href=&quot;data_members#Member_initialization&quot;&gt;默认的成员初始化程序&lt;/a&gt;： &lt;code&gt;int b : 1 = 0;&lt;/code&gt; 和 &lt;code&gt;int b : 1 {0}&lt;/code&gt; 格式错误。</target>
        </trans-unit>
        <trans-unit id="db2de29aa1d33752b78c0dd7d6ec96850ff5a7be" translate="yes" xml:space="preserve">
          <source>There are no arrays of references or arrays of functions.</source>
          <target state="translated">没有引用的数组或函数的数组。</target>
        </trans-unit>
        <trans-unit id="37439af54c020a64a12e9c758da796ee25c34c35" translate="yes" xml:space="preserve">
          <source>There are no bit field &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt;: lvalue-to-rvalue conversion always produces an object of the underlying type of the bit field.</source>
          <target state="translated">没有位字段&lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt;：从左值到右值的转换始终会生成位字段的基础类型的对象。</target>
        </trans-unit>
        <trans-unit id="f39ab94881006d285c7e811db2e42c17ba7a7d98" translate="yes" xml:space="preserve">
          <source>There are no guarantees as to the quality of the random sequence produced. In the past, some implementations of &lt;code&gt;rand()&lt;/code&gt; have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; between calls).</source>
          <target state="translated">不能保证所产生的随机序列的质量。过去， &lt;code&gt;rand()&lt;/code&gt; 的某些实现在生成的序列的随机性，分布和周期方面存在严重缺陷（在一个众所周知的示例中，低阶位在调用之间仅在 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;0&lt;/code&gt; 之间交替）。</target>
        </trans-unit>
        <trans-unit id="991d3d81eb996d06aa3347bc77bacaef91a6483e" translate="yes" xml:space="preserve">
          <source>There are no negative integer literals. Expressions such as &lt;code&gt;-1&lt;/code&gt; apply the &lt;a href=&quot;operator_arithmetic&quot;&gt;unary minus operator&lt;/a&gt; to the value represented by the literal, which may involve implicit type conversions.</source>
          <target state="translated">没有负整数文字。诸如 &lt;code&gt;-1&lt;/code&gt; 之类的表达式将&lt;a href=&quot;operator_arithmetic&quot;&gt;一元减运算符&lt;/a&gt;应用于文字表示的值，这可能涉及隐式类型转换。</target>
        </trans-unit>
        <trans-unit id="bcb7f46103fbd100a4f9cb6ff99abb2c28199213" translate="yes" xml:space="preserve">
          <source>There are no optional references; a program is ill-formed if it instantiates an &lt;code&gt;optional&lt;/code&gt; with a reference type. Alternatively, an &lt;code&gt;optional&lt;/code&gt; of a &lt;code&gt;&lt;a href=&quot;functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; may be used to hold a reference. In addition, a program is ill-formed if it instantiates an &lt;code&gt;optional&lt;/code&gt; with the tag types &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;in_place&quot;&gt;std::in_place_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">没有可选的参考；如果程序使用引用类型实例化了一个 &lt;code&gt;optional&lt;/code&gt; 程序，则该程序格式错误。或者，可以使用类型 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;optional&lt;/code&gt; 内容来保存引用。另外，如果程序使用标签类型 &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;in_place&quot;&gt;std::in_place_t&lt;/a&gt;&lt;/code&gt; 实例化一个 &lt;code&gt;optional&lt;/code&gt; 程序，则该程序格式错误。</target>
        </trans-unit>
        <trans-unit id="8419f6809e1cf19b6fb3b6a22f4638d4c5849b20" translate="yes" xml:space="preserve">
          <source>There are no overload for pointers to non-static member, pointers to volatile, or function pointers (other than the ones with signatures accepted by the (10-12) overloads). Attempting to output such objects invokes implicit conversion to &lt;code&gt;bool&lt;/code&gt;, and, for any non-null pointer value, the value &lt;code&gt;1&lt;/code&gt; is printed (unless &lt;code&gt;boolalpha&lt;/code&gt; was set, in which case &lt;code&gt;true&lt;/code&gt; is printed).</source>
          <target state="translated">指向非静态成员的指针，指向volatile的指针或函数指针没有重载（具有（10-12）重载可接受的签名的指针除外）。尝试输出此类对象会调用对 &lt;code&gt;bool&lt;/code&gt; 的隐式转换，并且对于任何非null指针值，将打印值 &lt;code&gt;1&lt;/code&gt; （除非设置了 &lt;code&gt;boolalpha&lt;/code&gt; ，在这种情况下，将打印 &lt;code&gt;true&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3e3662fa8ed3550ea700d26fee022c4ac95bb7d6" translate="yes" xml:space="preserve">
          <source>There are no pointers to &lt;a href=&quot;reference&quot;&gt;references&lt;/a&gt; and there are no pointers to &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;. Typically, mentions of &quot;pointers&quot; without elaboration do not include pointers to (non-static) members.</source>
          <target state="translated">没有指向&lt;a href=&quot;reference&quot;&gt;引用的&lt;/a&gt;指针，也没有指向&lt;a href=&quot;bit_field&quot;&gt;位字段的&lt;/a&gt;指针。通常，没有详细说明的&amp;ldquo;指针&amp;rdquo;不包括指向（非静态）成员的指针。</target>
        </trans-unit>
        <trans-unit id="337c29a8a2b7567bb32c86a4abf4bf2501e7a2ab" translate="yes" xml:space="preserve">
          <source>There are no references to &lt;code&gt;void&lt;/code&gt; and no references to references.</source>
          <target state="translated">没有对 &lt;code&gt;void&lt;/code&gt; 的引用，也没有对引用的引用。</target>
        </trans-unit>
        <trans-unit id="1deb84f794c63103b9555294bae8bd9107563871" translate="yes" xml:space="preserve">
          <source>There are no standard complexity guarantees, typical implementations behave similar to &lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;.</source>
          <target state="translated">没有标准的复杂性保证，典型的实现与&lt;a href=&quot;../../container/vector/insert&quot;&gt;std :: vector :: insert&lt;/a&gt;相似。</target>
        </trans-unit>
        <trans-unit id="5ef11a32cf3433c799eb8a56e867da73440715a2" translate="yes" xml:space="preserve">
          <source>There are non-member function template equivalents for all member functions of &lt;code&gt;std::atomic&lt;/code&gt;. Those non-member functions may be additionally overloaded for types that are not specializations of &lt;code&gt;std::atomic&lt;/code&gt;, but are able to guarantee atomicity. The only such type in the standard library is &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::atomic&lt;/code&gt; 所有成员函数都有等效的非成员函数模板。对于不是 &lt;code&gt;std::atomic&lt;/code&gt; 专业化但能够保证原子性的类型，可以额外地重载那些非成员函数。标准库中唯一这样的类型是 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e79772c53f1ce2b7a68f39acb9950fc2f71b6e0" translate="yes" xml:space="preserve">
          <source>There are special rules for unqualified name lookup for class members when virtual inheritance is involved (sometimes referred to as the rules of dominance), see &lt;a href=&quot;unqualified_lookup#Member_function_definition&quot;&gt;unqualified_lookup#Member_function_definition&lt;/a&gt;.</source>
          <target state="translated">当涉及到虚拟继承时，有一些特殊的规则用于类成员的非限定名称查找（有时称为主导规则），请参阅&lt;a href=&quot;unqualified_lookup#Member_function_definition&quot;&gt;unqualified_lookup＃Member_function_definition&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9a402f4ecfc55e94136a1e80cc1d6a5286b19956" translate="yes" xml:space="preserve">
          <source>There are still a few inaccuracies in this section, refer to individual member function pages for more detail.</source>
          <target state="translated">本部分还有一些不准确的地方,详情请参考各个会员功能页面。</target>
        </trans-unit>
        <trans-unit id="941295990d20765c0666a8c77b5e2c06086eb3fc" translate="yes" xml:space="preserve">
          <source>There are still a few inaccuracies in this section. Refer to individual member function pages for more detail.</source>
          <target state="translated">本节仍有一些不准确的地方。详细内容请参考各个成员功能页面。</target>
        </trans-unit>
        <trans-unit id="fbc45885aff604aaea2abb7208dd0c18b8bc3d95" translate="yes" xml:space="preserve">
          <source>There are three conventions of passing an allocator &lt;code&gt;alloc&lt;/code&gt; to a constructor of some type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">将分配器 &lt;code&gt;alloc&lt;/code&gt; 传递给 &lt;code&gt;T&lt;/code&gt; 类型的构造函数有三种约定：</target>
        </trans-unit>
        <trans-unit id="eb2f200b57b0d8a9c6686c50668bd2b80b8b6b29" translate="yes" xml:space="preserve">
          <source>There are three types of constraints:</source>
          <target state="translated">有三种类型的约束。</target>
        </trans-unit>
        <trans-unit id="0f09bbf4176190877beb129c86ae3e9c8e358d71" translate="yes" xml:space="preserve">
          <source>There are three types of null-terminated strings:</source>
          <target state="translated">有三种类型的空端字符串。</target>
        </trans-unit>
        <trans-unit id="7c2a33396de83eb35e9628e69e71f05f450481e2" translate="yes" xml:space="preserve">
          <source>There are two distinct kinds of enumerations:</source>
          <target state="translated">有两种不同的列举。</target>
        </trans-unit>
        <trans-unit id="6f669e5024934effcd4278fb23f0f95ad252bc52" translate="yes" xml:space="preserve">
          <source>There are two exceptions from that:</source>
          <target state="translated">有两个例外。</target>
        </trans-unit>
        <trans-unit id="36231641abbbc5cce8b62cf3185cc936bfddd00e" translate="yes" xml:space="preserve">
          <source>There are two kinds of implementations defined by the C++ standard:</source>
          <target state="translated">C++标准定义的实现有两种。</target>
        </trans-unit>
        <trans-unit id="e504119c92fe73e0c1cae5141f8e4e4cd1909108" translate="yes" xml:space="preserve">
          <source>There are two versions of &lt;code&gt;std::unique_ptr&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; 有两个版本：</target>
        </trans-unit>
        <trans-unit id="31bf78ac4643c55ed74c0dfba62be6194d38f599" translate="yes" xml:space="preserve">
          <source>There can be more than one definition in a program, as long as each definition appears in a different translation unit, of each of the following: class type, enumeration type, inline function with external linkage inline variable with external linkage(since C++17), class template, non-static function template, static data member of a class template, member function of a class template, partial template specialization, &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;,(since C++20) as long as all of the following is true:</source>
          <target state="translated">程序中可以有多个定义，只要每个定义出现在不同的翻译单元中，则每个定义如下：类类型，枚举类型，具有外部链接的内联函数具有外部链接的内联变量（自C ++起） 17），类模板，非静态函数模板，类模板的静态数据成员，类模板的成员函数，部分模板专业化，&lt;a href=&quot;constraints&quot;&gt;概念&lt;/a&gt;（自C ++ 20起），只要满足以下所有条件即可：</target>
        </trans-unit>
        <trans-unit id="3787f2ae99932166a7dcbb82d18d8948ed35d334" translate="yes" xml:space="preserve">
          <source>There exists an atomic object M,</source>
          <target state="translated">存在一个原子对象M。</target>
        </trans-unit>
        <trans-unit id="79c74ac70167e62133877fbfab7ff339ffa4b43b" translate="yes" xml:space="preserve">
          <source>There exists an atomic read Y (with any memory order) in thread B</source>
          <target state="translated">线程B中存在一个原子读Y(任意内存顺序)。</target>
        </trans-unit>
        <trans-unit id="7b325c9ba4bba31055eea3a7f3839a38f5af398a" translate="yes" xml:space="preserve">
          <source>There exists an atomic write X (with any memory order) that modifies M in thread A</source>
          <target state="translated">在线程A中存在一个修改M的原子写X(具有任意内存顺序)。</target>
        </trans-unit>
        <trans-unit id="b5311041dd1561f12757a5b111f905e8cf9ceb71" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple &lt;code&gt;%n&lt;/code&gt; results in the same variable or, as an edge case, printing a string modified by an earlier &lt;code&gt;%n&lt;/code&gt; within the same call.</source>
          <target state="translated">每个转换说明符的作用后都有一个&lt;a href=&quot;../../language/eval_order&quot;&gt;序列点&lt;/a&gt;；这样就可以在同一变量中存储多个 &lt;code&gt;%n&lt;/code&gt; 结果，或者在边缘情况下，在同一调用中打印由较早 &lt;code&gt;%n&lt;/code&gt; 修改的字符串。</target>
        </trans-unit>
        <trans-unit id="3baee1a6a7acc4dbecfba1cab14149a6beefecea" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple fields in the same &quot;sink&quot; variable.</source>
          <target state="translated">每个转换说明符的作用后都有一个&lt;a href=&quot;../../language/eval_order&quot;&gt;序列点&lt;/a&gt;；这允许将多个字段存储在同一个&amp;ldquo;接收器&amp;rdquo;变量中。</target>
        </trans-unit>
        <trans-unit id="ab3c5acf0d5e4ba77cc962cd2ce83a7c967eb424" translate="yes" xml:space="preserve">
          <source>There is a non-standard function named &lt;code&gt;gamma&lt;/code&gt; in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;lgamma&lt;/code&gt;, but 4.4BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;tgamma&lt;/code&gt;.</source>
          <target state="translated">在各种实现中都有一个名为 &lt;code&gt;gamma&lt;/code&gt; 的非标准函数，但其定义不一致。例如，glibc和4.2BSD版本的 &lt;code&gt;gamma&lt;/code&gt; 执行 &lt;code&gt;lgamma&lt;/code&gt; ，而4.4BSD版本的 &lt;code&gt;gamma&lt;/code&gt; 执行 &lt;code&gt;tgamma&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9f50508274427b995c9b808fe7d2253e68aed64" translate="yes" xml:space="preserve">
          <source>There is a single total order S on all &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, including fences, that satisfies the following constraints:</source>
          <target state="translated">满足以下约束的所有 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 操作（包括栅栏）上只有一个总订单S ：</target>
        </trans-unit>
        <trans-unit id="d4002dc28152d428b1e9f887a2afb18cb864b3ff" translate="yes" xml:space="preserve">
          <source>There is a special case for a zero-length array (&lt;code&gt;N == 0&lt;/code&gt;). In that case, &lt;code&gt;array.begin() == array.end()&lt;/code&gt;, which is some unique value. The effect of calling &lt;code&gt;front()&lt;/code&gt; or &lt;code&gt;back()&lt;/code&gt; on a zero-sized array is undefined.</source>
          <target state="translated">零长度数组（ &lt;code&gt;N == 0&lt;/code&gt; ）有一种特殊情况。在这种情况下， &lt;code&gt;array.begin() == array.end()&lt;/code&gt; ，这是一些唯一值。大小为零的数组上调用 &lt;code&gt;front()&lt;/code&gt; 或 &lt;code&gt;back()&lt;/code&gt; 的效果是不确定的。</target>
        </trans-unit>
        <trans-unit id="4c58212f0810e755496085c2333304612a8c9ba1" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from lvalues and rvalues of array type to rvalues of pointer type: it constructs a pointer to the first element of an array. This conversion is used whenever arrays appear in context where arrays are not expected, but pointers are:</source>
          <target state="translated">从数组类型的左值和右值到指针类型的右值存在&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt;：它构造了一个指向数组第一个元素的指针。每当数组出现在不需要数组但指针为以下内容的上下文中时，都会使用此转换：</target>
        </trans-unit>
        <trans-unit id="adb96efa8dd15697ca7b238b3ac30f5bc2029721" translate="yes" xml:space="preserve">
          <source>There is no &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt; from pointer type because it is impossible to distinguish a pointer obtained from array and non-array forms of &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">指针类型没有&lt;a href=&quot;../../language/deduction_guide&quot;&gt;类模板自变量的推论&lt;/a&gt;，因为无法区分从 &lt;code&gt;new&lt;/code&gt; 的数组形式和非数组形式获得的指针。</target>
        </trans-unit>
        <trans-unit id="b717a5566f4d275ca27affef23f0b5a37db23c45" translate="yes" xml:space="preserve">
          <source>There is no alternative spelling (such as &lt;code&gt;eq&lt;/code&gt;) for the equality operator &lt;code&gt;==&lt;/code&gt; because the character &lt;code&gt;=&lt;/code&gt; was present in all supported charsets.</source>
          <target state="translated">等式运算符 &lt;code&gt;==&lt;/code&gt; 没有替代拼写（例如 &lt;code&gt;eq&lt;/code&gt; ），因为在所有受支持的字符集中都存在字符 &lt;code&gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6359bb2da55b35e94c9ad0b9d3423bdf850ab557" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the same &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; instance will be referred to by all evaluations of the typeid expression on the same type, although &lt;code&gt;&lt;a href=&quot;../types/type_info/hash_code&quot;&gt;std::type_info::hash_code&lt;/a&gt;&lt;/code&gt; of those type_info objects would be identical, as would be their &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">尽管这些type_info对象的 &lt;code&gt;&lt;a href=&quot;../types/type_info/hash_code&quot;&gt;std::type_info::hash_code&lt;/a&gt;&lt;/code&gt; 相同，而且它们的 &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; 也相同，但不能保证相同类型的typeid表达式的所有求值将引用相同的 &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; 实例。 ：type_index。</target>
        </trans-unit>
        <trans-unit id="46c70b420b1fd4cd4eb814c6e21ea48fec268ba0" translate="yes" xml:space="preserve">
          <source>There is no move constructor: moving from an object derived from &lt;code&gt;shared_from_this&lt;/code&gt; does not transfer its shared identity.</source>
          <target state="translated">没有移动构造函数：从 &lt;code&gt;shared_from_this&lt;/code&gt; 派生的对象移动不会转移其共享身份。</target>
        </trans-unit>
        <trans-unit id="c081f6007cfe842825dd149d42264efa0313278f" translate="yes" xml:space="preserve">
          <source>There is no non-member function equivalent of this static member constant because non-member functions take pointers to atomic types, and therefore aren't as useful in &lt;a href=&quot;../../language/constant_expression&quot;&gt;constant expressions&lt;/a&gt;.</source>
          <target state="translated">没有与该静态成员常量等效的非成员函数，因为非成员函数采用指向原子类型的指针，因此在&lt;a href=&quot;../../language/constant_expression&quot;&gt;常量表达式&lt;/a&gt;中没有用。</target>
        </trans-unit>
        <trans-unit id="b70d83494235e850b17f2e48a3299bb098ff2e94" translate="yes" xml:space="preserve">
          <source>There is no portable way to define primary sort key in terms of &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; since the conversion from the collation key returned by &lt;code&gt;std::collate::transform()&lt;/code&gt; to the primary equivalence key is locale-specific, and if the user replaces the &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet, that conversion is no longer known to the standard library's &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt;. Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return an empty string unless the &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet of the currently-imbued locale was not replaced by the user, and still matches the system-supplied &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet), in which case &lt;code&gt;&lt;a href=&quot;../../locale/collate_byname&quot;&gt;std::collate_byname&lt;/a&gt;&amp;lt;charT&amp;gt;::transform(first, last)&lt;/code&gt; is executed and the sort key it produces is converted to the expected primary sort key using a locale-specific conversion.</source>
          <target state="translated">没有从 &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; 定义主排序键的便携式方法，因为从 &lt;code&gt;std::collate::transform()&lt;/code&gt; 返回的归类键到主等价键的转换是特定于语言环境的，并且如果用户替换在 &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; 方面，标准库的 &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 不再知道该转换。标准库专业化 &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; 返回一个空字符串，除非用户未替换当前导入的语言环境的 &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; 方面，并且仍与系统提供的 &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; 方面匹配，在这种情况下为 &lt;code&gt;&lt;a href=&quot;../../locale/collate_byname&quot;&gt;std::collate_byname&lt;/a&gt;&amp;lt;charT&amp;gt;::transform(first, last)&lt;/code&gt; 执行并使用特定于语言环境的转换将其产生的排序键转换为预期的主排序键。</target>
        </trans-unit>
        <trans-unit id="3f7acf604b21fa7efd6ebb9fae0bd32cd0e76516" translate="yes" xml:space="preserve">
          <source>There is no separate tag for &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;没有单独的标记。</target>
        </trans-unit>
        <trans-unit id="cb42e4a03c1413932f97ef53ea3df59cf6f0618f" translate="yes" xml:space="preserve">
          <source>There is no specialization for C strings. &lt;code&gt;std::hash&amp;lt;const char*&amp;gt;&lt;/code&gt; produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array.</source>
          <target state="translated">C字符串没有专门的名称。 &lt;code&gt;std::hash&amp;lt;const char*&amp;gt;&lt;/code&gt; 生成指针值（内存地址）的哈希，它不检查任何字符数组的内容。</target>
        </trans-unit>
        <trans-unit id="932b5b0c5bba8ae4965a8c49c5fcc30eedb86b32" translate="yes" xml:space="preserve">
          <source>There is no standard-compliant way for the user to construct a &lt;code&gt;future_error&lt;/code&gt; prior to C++17. C++11 and C++14 depict an exposition-only public constructor taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, and some implementations provide such a constructor.</source>
          <target state="translated">用户没有符合标准的方法来在C ++ 17之前构造 &lt;code&gt;future_error&lt;/code&gt; 。C ++ 11和C ++ 14描述了采用 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 的仅公开的公共构造函数，某些实现提供了这种构造函数。</target>
        </trans-unit>
        <trans-unit id="1a76b382fdb365f1f430efc3fd3ffef21f74d56b" translate="yes" xml:space="preserve">
          <source>There is no way to explicitly specify template arguments to &lt;a href=&quot;operators&quot;&gt;overloaded operators&lt;/a&gt;, &lt;a href=&quot;cast_operator&quot;&gt;conversion functions&lt;/a&gt;, and constructors, because they are called without the use of the function name.</source>
          <target state="translated">无法为&lt;a href=&quot;operators&quot;&gt;重载的运算符&lt;/a&gt;，&lt;a href=&quot;cast_operator&quot;&gt;转换函数&lt;/a&gt;和构造函数显式指定模板参数，因为它们是在不使用函数名的情况下调用的。</target>
        </trans-unit>
        <trans-unit id="cfe1eeb34c7bedb3e0ea6d678c0bd6012a61623b" translate="yes" xml:space="preserve">
          <source>There is one exception: an erasure which deletes the last element of a &lt;code&gt;&lt;a href=&quot;container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">有一个例外：删除会删除 &lt;code&gt;&lt;a href=&quot;container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt; 的最后一个元素</target>
        </trans-unit>
        <trans-unit id="341db5eb1053e74392cf71602cdbdbaadad998bb" translate="yes" xml:space="preserve">
          <source>There is partial ordering of cv-qualifiers by the order of increasing restrictions. The type can be said</source>
          <target state="translated">cv-限定词有部分按限制增加的顺序排序。该类型可以说是</target>
        </trans-unit>
        <trans-unit id="89bd5d5858a6e7136749a6ba025c5ec9f6ed276d" translate="yes" xml:space="preserve">
          <source>There's no way to access the time zone pointer when &lt;code&gt;TimeZonePtr&lt;/code&gt; is a move-only type.</source>
          <target state="translated">如果 &lt;code&gt;TimeZonePtr&lt;/code&gt; 是仅移动类型，则无法访问时区指针。</target>
        </trans-unit>
        <trans-unit id="e85687808f760523e3241d93ae510041ac781f16" translate="yes" xml:space="preserve">
          <source>Therefore, private members can be transferred to implementation as-is, and push_back can forward to an implementation that does not use T in the interface either:</source>
          <target state="translated">因此,私有成员可以原封不动地转移到实现上,push_back也可以转发到接口中不使用T的实现上。</target>
        </trans-unit>
        <trans-unit id="99d6d9ce6d1c6685dc210a906c540e2a567fe084" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; are provided for unordered_map to allow deduction from an iterator range (overloads (1,3-5)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,6-8)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为unordered_map提供的，以允许从迭代器范围（重载（1,3-5））和 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （重载（2,6-8））中进行推导。仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;， &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;， &lt;code&gt;Hash&lt;/code&gt; 或 &lt;code&gt;Pred&lt;/code&gt; 都不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;且 &lt;code&gt;Hash&lt;/code&gt; 不是整数类型时，这些重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="d838aa17089c69886e8a6da521887bdae3d66e6e" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; are provided for unordered_multimap to allow deduction from an iterator range (overloads (1,3-5)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,6-8)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为unordered_multimap提供的，以允许从迭代器范围（重载（1,3-5））和 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （重载（2,6-8））中进行推导。仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;， &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;， &lt;code&gt;Hash&lt;/code&gt; 或 &lt;code&gt;Pred&lt;/code&gt; 都不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;且 &lt;code&gt;Hash&lt;/code&gt; 不是整数类型时，这些重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="71a2bff7b98f49c9c4e24066b486d0981c520060" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; to allow deduction from underlying container type (overloads (1,3)) and from an iterator range (overload (2)) This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;code&gt;Allocator&lt;/code&gt;, &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (3), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Alloc&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为 &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; 提供的，以允许从基础容器类型（过载（1,3））和迭代器范围（过载（2））进行 &lt;code&gt;InputIt&lt;/code&gt; 仅当InputIt满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator时&lt;/a&gt;，此过载才参与过载解析， &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;， &lt;code&gt;Comp&lt;/code&gt; 不满足 &lt;code&gt;Allocator&lt;/code&gt; ， &lt;code&gt;Container&lt;/code&gt; 不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator，&lt;/a&gt;并且对于重载（3），如果 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Alloc&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8e10d57340ef11936ebd04620951a44a41b981f3" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides.</source>
          <target state="translated">这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 提供的，以解决隐式推导指南遗漏的边缘情况。</target>
        </trans-unit>
        <trans-unit id="12b353145b514386eb3d03070811d07e0bad084c" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides, in particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="translated">这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为 &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 提供的，以解决隐式推导指南遗漏的边缘情况，尤其是不可复制的参数和数组到指针的转换。</target>
        </trans-unit>
        <trans-unit id="0d7729eb7a1438721d7721c8ec45ca17c31eb830" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for multiset to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;针对多集提供，以允许从迭代器范围（过载（1,3））和 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （过载（2,4））中进行推导。这些重载只参加重载如果 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;， &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;和 &lt;code&gt;Comp&lt;/code&gt; 不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="70a6bdbef179c3a4732cac088b62e8b6f4ff8948" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for queue to allow deduction from underlying container type. This overload only participates in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (2), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;扣除指南&lt;/a&gt;用于队列，以允许从基础容器类型中扣除。此重载仅参与重载解析如果 &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;，和 &lt;code&gt;Container&lt;/code&gt; 不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;，并且对于过载（2）中，如果 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d564ca21e1c30be4928dd9500b875ed1d963057" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for set to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">提供这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;以允许从迭代器范围（过载（1,3））和 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （过载（2,4））中进行推导。这些重载只参加重载如果 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;， &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;和 &lt;code&gt;Comp&lt;/code&gt; 不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13ef785aba459afe56d345cd56062fe469f5d0da" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for stack to allow deduction from underlying container type. This overload only participates in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (2), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;扣减指南&lt;/a&gt;用于堆叠，以允许从下面的容器类型扣减。此重载仅参与重载解析如果 &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;，和 &lt;code&gt;Container&lt;/code&gt; 不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;，并且对于过载（2）中，如果 &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dafdd32c659086dffb3edda268826ae9c158e33" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for unordered_multiset to allow deduction from an iterator range (overloads (1,3,4)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,5.6)). This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">为unordered_multiset提供了这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;，以允许从迭代器范围（重载（1,3,4））和 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （重载（2,5.6））中进行推导。仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;， &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;， &lt;code&gt;Hash&lt;/code&gt; 或 &lt;code&gt;Pred&lt;/code&gt; 都不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;， &lt;code&gt;Hash&lt;/code&gt; 不是整数类型时，此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="9bb6043ae0763bf108698a03aeb652cc5820df07" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for unordered_set to allow deduction from an iterator range (overloads (1,3,4)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,5.6)). This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">为unordered_set提供了这些&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;，以允许从迭代器范围（重载（1、3、4））和 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （重载（2,5.6））中进行推导。仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;， &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;， &lt;code&gt;Hash&lt;/code&gt; 或 &lt;code&gt;Pred&lt;/code&gt; 都不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;， &lt;code&gt;Hash&lt;/code&gt; 不是整数类型时，此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="998a40ef4627e5e01e4248114651ccad38e51377" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;operator/&lt;/code&gt; overloads provide a conventional syntax for the creation of Gregorian calendar dates.</source>
          <target state="translated">这些 &lt;code&gt;operator/&lt;/code&gt; 重载提供了用于创建公历日期的常规语法。</target>
        </trans-unit>
        <trans-unit id="74e2c10444921183c350121d5ff7c2b2d260e16b" translate="yes" xml:space="preserve">
          <source>These algorithms cannot be used with associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; because ForwardIt does not dereference to a MoveAssignable type (the keys in these containers are not modifiable).</source>
          <target state="translated">这些算法不能与 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 等关联容器一起使用，因为ForwardIt不会取消引用MoveAssignable类型（这些容器中的键不可修改）。</target>
        </trans-unit>
        <trans-unit id="dc6f538fd8e7e831a029d42e6c3295c5ce6547d3" translate="yes" xml:space="preserve">
          <source>These are the directives defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or cause a compile-time error. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive &lt;code&gt;#warning&lt;/code&gt; which emits a user-defined message during compilation.</source>
          <target state="translated">这些是标准定义的指令。该标准未定义其他指令的行为：它们可能会被忽略，具有某些有用的含义或导致编译时错误。即使以其他方式被忽略，它们也将在预处理器完成后从源代码中删除。常见的非标准扩展名是 &lt;code&gt;#warning&lt;/code&gt; 指令，它在编译期间发出用户定义的消息。</target>
        </trans-unit>
        <trans-unit id="ec4ebc2b939ff4d66f10267f6f032b0dd31634b9" translate="yes" xml:space="preserve">
          <source>These are type categories defined by the core language. They are included here as named requirements only for consistency.</source>
          <target state="translated">这些是核心语言定义的类型类别。为保持一致,在此将它们作为命名的要求列入。</target>
        </trans-unit>
        <trans-unit id="41f69a0ad4c5384189f3c5f07ef1de6088dafb43" translate="yes" xml:space="preserve">
          <source>These attributes may be applied to labels and statements (other than declaration-statements). They may not be simultaneously applied to the same label or statement.</source>
          <target state="translated">这些属性可应用于标签和语句(声明语句除外)。这些属性不得同时应用于同一个标签或声明。</target>
        </trans-unit>
        <trans-unit id="f1b3468a96579cdd8f43ddee81097dc1e729403b" translate="yes" xml:space="preserve">
          <source>These bullets describe situations that cannot arise in C++ and therefore are omitted from the discussion above. In C, aggregate copy and assignment access the aggregate object as a whole. But in C++ such actions are always performed through a member function call, which accesses the individual subobjects rather than the entire object (or, in the case of unions, copies the object representation, i.e., via &lt;code&gt;unsigned char&lt;/code&gt;). See &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051&quot;&gt;core issue 2051&lt;/a&gt;.</source>
          <target state="translated">这些项目符号描述了C ++中不会出现的情况，因此在上面的讨论中被省略。在C中，聚合副本和赋值访问整个聚合对象。但是在C ++中，此类操作始终是通过成员函数调用执行的，该成员函数调用访问单个子对象而不是整个对象（或者，如果是并集，则复制对象表示，即，通过 &lt;code&gt;unsigned char&lt;/code&gt; ）。参见&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051&quot;&gt;核心问题2051&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7e2e85ea89bf8851056faa66c86c8a89f763163c" translate="yes" xml:space="preserve">
          <source>These classes encapsulate a regular expression and the results of matching a regular expression within a target sequence of characters.</source>
          <target state="translated">这些类封装了正则表达式以及在目标字符序列中匹配正则表达式的结果。</target>
        </trans-unit>
        <trans-unit id="5187a740adf841afb17f5f37d5efc0eafaa7fbe7" translate="yes" xml:space="preserve">
          <source>These constants are duplicated from &lt;code&gt;std::regex_constants&lt;/code&gt;:</source>
          <target state="translated">这些常量是从 &lt;code&gt;std::regex_constants&lt;/code&gt; 复制的：</target>
        </trans-unit>
        <trans-unit id="19ba3734849d9efa52a071b6c74031883732795a" translate="yes" xml:space="preserve">
          <source>These constants provide a portable way to access the L1 data cache line size.</source>
          <target state="translated">这些常量提供了一种可移植的方式来访问L1数据缓存行大小。</target>
        </trans-unit>
        <trans-unit id="5aeef84fd68b04dfd62540295b4e58ffbc1ad7c5" translate="yes" xml:space="preserve">
          <source>These constructors additionally do not participate in overload resolution if the expression &lt;code&gt;d(ptr)&lt;/code&gt; is not well-formed, or if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果表达式 &lt;code&gt;d(ptr)&lt;/code&gt; 的格式不正确，或者 &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则这些构造函数将不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="2cd12e66c1b571e2605eacf313edfc5ca3855042" translate="yes" xml:space="preserve">
          <source>These constructors are typically called by the constructors of &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些构造函数通常由 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; 的构造函数调用。</target>
        </trans-unit>
        <trans-unit id="7ee89583b6197fe5f3d8e0eab3b74e26c4d4069c" translate="yes" xml:space="preserve">
          <source>These conversions are purely lexical. They do not check that the paths exist, do not follow symlinks, and do not access the filesystem at all. For symlink-following counterparts of &lt;code&gt;lexically_relative&lt;/code&gt; and &lt;code&gt;lexically_proximate&lt;/code&gt;, see &lt;a href=&quot;../relative&quot;&gt;&lt;code&gt;relative&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../relative&quot;&gt;&lt;code&gt;proximate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">这些转换纯粹是词汇上的。他们不检查路径是否存在，不遵循符号链接，也完全不访问文件系统。有关 &lt;code&gt;lexically_relative&lt;/code&gt; 和 &lt;code&gt;lexically_proximate&lt;/code&gt; 后面的符号链接的对等物，请参见&lt;a href=&quot;../relative&quot;&gt; &lt;code&gt;relative&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../relative&quot;&gt; &lt;code&gt;proximate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3b066eecc1428c4afc05b8473b0ce8b6682781dc" translate="yes" xml:space="preserve">
          <source>These conversions model the type conversion applied to all function arguments when passed by value.</source>
          <target state="translated">这些转换模型在值传递时应用于所有函数参数的类型转换。</target>
        </trans-unit>
        <trans-unit id="1f828b6e7c5612d3683245cf9a5d3fa76a3dbee3" translate="yes" xml:space="preserve">
          <source>These fictional constructors are public members of the hypothetical class type. They are explicit if the guide was formed from an explicit constructor. If overload resolution fails, the program is ill-formed. Otherwise, the return type of the selected &lt;code&gt;F&lt;/code&gt; template specialization becomes the deduced class template specialization.</source>
          <target state="translated">这些虚构的构造函数是假设类类型的公共成员。如果指南是由显式构造函数构成的，则它们是显式的。如果重载解析失败，则程序格式错误。否则，所选 &lt;code&gt;F&lt;/code&gt; 模板特化的返回类型将成为推导的类模板特化。</target>
        </trans-unit>
        <trans-unit id="9e1185e2ec5ad6dc826827fc0bc8b26aeb766d26" translate="yes" xml:space="preserve">
          <source>These function templates are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; , and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">这些函数模板对于普通的&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;非限定&lt;/a&gt;或&lt;a href=&quot;../../language/qualified_lookup&quot;&gt;限定查找&lt;/a&gt;不可见，并且仅当 &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; 是参数的关联类时，才可以通过&lt;a href=&quot;../../language/adl&quot;&gt;依赖&lt;/a&gt;于参数的查找来找到。这可以防止在 &lt;code&gt;using namespace std::filesystem;&lt;/code&gt; 的情况下进行不必要的转换。</target>
        </trans-unit>
        <trans-unit id="043baecb502250e4140c666b26e06dd43b796356" translate="yes" xml:space="preserve">
          <source>These function templates are optional: an implementation may choose to instead provide &lt;code&gt;to_sys&lt;/code&gt; and &lt;code&gt;from_sys&lt;/code&gt;.</source>
          <target state="translated">这些功能模板是可选的：实现可以选择提供 &lt;code&gt;to_sys&lt;/code&gt; 和 &lt;code&gt;from_sys&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7805c9adadba15da9ce1789282d1fdeae7db0ab" translate="yes" xml:space="preserve">
          <source>These function templates are optional: an implementation may choose to instead provide &lt;code&gt;to_utc&lt;/code&gt; and &lt;code&gt;from_utc&lt;/code&gt;.</source>
          <target state="translated">这些功能模板是可选的：实现可以选择提供 &lt;code&gt;to_utc&lt;/code&gt; 和 &lt;code&gt;from_utc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7487a9c951b04abd0ea64aae0657bd6c80e75211" translate="yes" xml:space="preserve">
          <source>These function templates behave as if they.</source>
          <target state="translated">这些函数模板的行为就像他们。</target>
        </trans-unit>
        <trans-unit id="419d5c3b82807fda6edd67b01bc6da49f1a27023" translate="yes" xml:space="preserve">
          <source>These functions are defined in terms of member functions of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">这些函数是根据 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 的成员函数定义的：</target>
        </trans-unit>
        <trans-unit id="706bfb2aebd27a90d3a3878dfe394992ff31ffb1" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; , and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">这些函数对于普通的&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;非限定&lt;/a&gt;或&lt;a href=&quot;../../language/qualified_lookup&quot;&gt;限定查找&lt;/a&gt;是不可见的，并且仅当 &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; 是参数的关联类时，才可以通过&lt;a href=&quot;../../language/adl&quot;&gt;依赖&lt;/a&gt;于参数的查找来找到。这可以防止在 &lt;code&gt;using namespace std::filesystem;&lt;/code&gt; 的情况下进行不必要的转换。</target>
        </trans-unit>
        <trans-unit id="2f3e6ab375e463f1612d61a87d214ea836c037d5" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::basic_string_view&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">这些函数对于普通的&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;非限定&lt;/a&gt;或&lt;a href=&quot;../../language/qualified_lookup&quot;&gt;限定查找&lt;/a&gt;是不可见的，并且仅当 &lt;code&gt;std::basic_string_view&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; 是参数的关联类时，才可以通过&lt;a href=&quot;../../language/adl&quot;&gt;依赖&lt;/a&gt;于参数的查找找到。</target>
        </trans-unit>
        <trans-unit id="71d3bc1bc9cc67bb93448628acb0478629973b75" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::span&amp;lt;T, Extent&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">这些函数对于普通的&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;非限定&lt;/a&gt;或&lt;a href=&quot;../../language/qualified_lookup&quot;&gt;限定查找&lt;/a&gt;是不可见的，并且仅当 &lt;code&gt;std::span&amp;lt;T, Extent&amp;gt;&lt;/code&gt; 是参数的关联类时，才可以通过&lt;a href=&quot;../../language/adl&quot;&gt;依赖&lt;/a&gt;于参数的查找找到。</target>
        </trans-unit>
        <trans-unit id="9cafa0c4c816e506567effd571a10a76ae52acd3" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::ranges::empty_view&amp;lt;T&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">这些函数对于普通的&lt;a href=&quot;../language/unqualified_lookup&quot;&gt;非限定&lt;/a&gt;或&lt;a href=&quot;../language/qualified_lookup&quot;&gt;限定查找&lt;/a&gt;是不可见的，并且仅当 &lt;code&gt;std::ranges::empty_view&amp;lt;T&amp;gt;&lt;/code&gt; 是参数的关联类时，才可以通过&lt;a href=&quot;../language/adl&quot;&gt;依赖&lt;/a&gt;于参数的查找找到。</target>
        </trans-unit>
        <trans-unit id="13ae74af435260e5a8fc58a9b3b8f8b649c48761" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::ranges::ref_view&amp;lt;R&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">这些函数对于普通的&lt;a href=&quot;../language/unqualified_lookup&quot;&gt;非限定&lt;/a&gt;或&lt;a href=&quot;../language/qualified_lookup&quot;&gt;限定查找&lt;/a&gt;是不可见的，并且仅当 &lt;code&gt;std::ranges::ref_view&amp;lt;R&amp;gt;&lt;/code&gt; 是参数的关联类时，才可以通过&lt;a href=&quot;../language/adl&quot;&gt;依赖&lt;/a&gt;于参数的查找找到。</target>
        </trans-unit>
        <trans-unit id="96489aaabbabce3adba15d3840295fb8191f8911" translate="yes" xml:space="preserve">
          <source>These functions are provided to make &lt;code&gt;span&lt;/code&gt; rvalues work with &lt;code&gt;std::ranges::begin&lt;/code&gt; and &lt;code&gt;std::ranges::end&lt;/code&gt;, which reject rvalue arguments by default in order to prevent dangling iterator.</source>
          <target state="translated">提供这些函数是为了使 &lt;code&gt;span&lt;/code&gt; 右值与 &lt;code&gt;std::ranges::begin&lt;/code&gt; 和 &lt;code&gt;std::ranges::end&lt;/code&gt; ，默认情况下它们会拒绝rvalue参数以防止悬空迭代器。</target>
        </trans-unit>
        <trans-unit id="5f45f69461ef9381b69148d33ccefcd3eafb9116" translate="yes" xml:space="preserve">
          <source>These functions are provided to make &lt;code&gt;string_view&lt;/code&gt; rvalues work with &lt;code&gt;std::ranges::begin&lt;/code&gt; and &lt;code&gt;std::ranges::end&lt;/code&gt;, which reject rvalue arguments by default in order to prevent dangling iterator.</source>
          <target state="translated">提供这些函数是为了使 &lt;code&gt;string_view&lt;/code&gt; rvalues与 &lt;code&gt;std::ranges::begin&lt;/code&gt; 和 &lt;code&gt;std::ranges::end&lt;/code&gt; ，默认情况下它们会拒绝rvalue参数以防止悬空迭代器。</target>
        </trans-unit>
        <trans-unit id="be2ae68f22369098426dd815dea838deb2f9b140" translate="yes" xml:space="preserve">
          <source>These functions are typically implemented using mutexes, stored in a global hash table where the pointer value is used as the key.</source>
          <target state="translated">这些函数通常使用mutexes来实现,存储在一个全局哈希表中,其中指针值被用作键。</target>
        </trans-unit>
        <trans-unit id="326f105b45787866cfe222f982d0d9e27243f9ff" translate="yes" xml:space="preserve">
          <source>These functions are used to apply the regular expression encapsulated in a regex to a target sequence of characters.</source>
          <target state="translated">这些函数用于将regex中封装的正则表达式应用于目标字符序列。</target>
        </trans-unit>
        <trans-unit id="7585335f42669921d2b1bf3e543316f127948a1e" translate="yes" xml:space="preserve">
          <source>These functions do not participate in overload resolution (or, for the copy assignment operator, is defined as deleted) if any required assignment operation is invalid or if there is a size mismatch. Specifically:</source>
          <target state="translated">如果任何所需的赋值操作无效或存在大小不匹配的情况下,这些函数不参与过载解析(或者,对于复制赋值操作符,定义为删除)。具体来说。</target>
        </trans-unit>
        <trans-unit id="d30d68da83412d7ae98ce606334319e3d70b73d8" translate="yes" xml:space="preserve">
          <source>These functions do not participate in overload resolution (or, for the copy assignment operator, is defined as deleted) if any required assignment operation is invalid. Specifically:</source>
          <target state="translated">如果任何所需的赋值操作无效,这些函数不参与过载解析(或者,对于复制赋值操作符,定义为删除)。具体来说。</target>
        </trans-unit>
        <trans-unit id="cafe750e84a77bd66ed9b0e48c90443f0b94fd28" translate="yes" xml:space="preserve">
          <source>These functions do not throw exceptions.</source>
          <target state="translated">这些函数不会产生异常。</target>
        </trans-unit>
        <trans-unit id="6ee20f7717337989ef84b3eb0d3af4c0f3efbcb1" translate="yes" xml:space="preserve">
          <source>These functions effectively yield an approximation of the meaning of the argument path &lt;code&gt;p&lt;/code&gt; in an environment where &lt;code&gt;*this&lt;/code&gt; is the starting directory.</source>
          <target state="translated">在 &lt;code&gt;*this&lt;/code&gt; 是起始目录的环境中，这些函数有效地产生了参数路径 &lt;code&gt;p&lt;/code&gt; 的含义的近似值。</target>
        </trans-unit>
        <trans-unit id="b7da2559e16d851f64895f9b8ce4e64008d143d3" translate="yes" xml:space="preserve">
          <source>These functions provide access to the program-wide time zone database.</source>
          <target state="translated">这些功能提供了对全程序时区数据库的访问。</target>
        </trans-unit>
        <trans-unit id="e5ab52d07da85043f4b5804364445cb1d17fd3ed" translate="yes" xml:space="preserve">
          <source>These functions take a result of 3-way comparison and convert it to the result of one of the six relational operators.</source>
          <target state="translated">这些函数将3向比较的结果转换成6个关系运算符之一的结果。</target>
        </trans-unit>
        <trans-unit id="09dc533f744ccd968da17e107b1a623a70147eb2" translate="yes" xml:space="preserve">
          <source>These functions were deprecated in favor of the specializations of the &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; template: &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">为支持 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 模板： &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; 的专业化，不赞成使用这些功能。</target>
        </trans-unit>
        <trans-unit id="e8ebef2701474b9ea6a2624b079221ae9fed097b" translate="yes" xml:space="preserve">
          <source>These hashes equal the hashes of corresponding &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; classes: If S is one of the standard basic_string types, SV is the corresponding string view type, and s is an object of type S, then &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt;.</source>
          <target state="translated">这些哈希等于对应的 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 类的哈希：如果S是标准basic_string类型之一，则SV是对应的字符串视图类型，而s是类型S的对象，则 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="04c0518ba136c51c78f2d27b7888f66813a53b9f" translate="yes" xml:space="preserve">
          <source>These hashes equal the hashes of corresponding &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; classes: If S is one of these string types, SV is the corresponding string view type, and s is an object of type S, then &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt;.</source>
          <target state="translated">这些哈希等于相应的 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; 类的哈希：如果S是这些字符串类型之一，SV是相应的字符串视图类型，并且s是类型S的对象，则 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="378bbcb4a72a73dada77e96ee58fc0765cdcf81d" translate="yes" xml:space="preserve">
          <source>These headers are allowed to also declare the same names in the &lt;code&gt;std&lt;/code&gt; namespace, and the corresponding &lt;code&gt;cxxx&lt;/code&gt; headers are allowed to also declare the same names in the global namespace: including &amp;lt;cstdlib&amp;gt; definitely provides &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; and may also provide &lt;code&gt;::malloc&lt;/code&gt;. Including &amp;lt;stdlib.h&amp;gt; definitely provides &lt;code&gt;::malloc&lt;/code&gt; and may also provide &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;. This applies even to functions and function overloads that are not part of C standard library.</source>
          <target state="translated">这些标头也可以在 &lt;code&gt;std&lt;/code&gt; 名称空间中声明相同的名称，而相应的 &lt;code&gt;cxxx&lt;/code&gt; 标头也可以在全局名称空间中声明相同的名称：包括&amp;lt;cstdlib&amp;gt;绝对提供 &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; ，也可以提供 &lt;code&gt;::malloc&lt;/code&gt; 。包括&amp;lt;stdlib.h&amp;gt;肯定提供 &lt;code&gt;::malloc&lt;/code&gt; ，也可能提供 &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; 。这甚至适用于不属于C标准库的函数和函数重载。</target>
        </trans-unit>
        <trans-unit id="9c301ca8ee91cc2dc03b93b934d87b55d872e6ac" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;../iterator/iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这些成员类型必须通过继承 &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;../iterator/iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="269f91543a7d747d3318687896f196744a919ccf" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt; &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::iterator_category&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::value_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::difference_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::pointer&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::reference&lt;br/&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这些成员类型需要通过从 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt; &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::iterator_category&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::value_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::difference_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::pointer&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::reference&lt;br/&gt; &amp;gt;&lt;/code&gt; 继承来获取:: iterator_traits &amp;lt;Iter&amp;gt; :: pointer ，std :: iterator_traits &amp;lt;Iter&amp;gt; :: reference &amp;gt;。</target>
        </trans-unit>
        <trans-unit id="b52b486a05c84f8a4581d34abd369500f9977646" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, CharT, Traits::off_type, /* unspecified, usually CharT* */, CharT&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这些成员类型需要通过继承 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, CharT, Traits::off_type, /* unspecified, usually CharT* */, CharT&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a01f1d5ca0fbf0d6be5d6ec44fedf3a57f36c70d" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, T, Distance, const T*, const T&amp;amp;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这些成员类型必须通过继承 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, T, Distance, const T*, const T&amp;amp;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae3da083cb674670645135b104ff6e1e31af7384" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">这些成员类型必须通过继承 &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6dd91df6ca3cc382c9fe0e450bbf5c087b01c8bc" translate="yes" xml:space="preserve">
          <source>These non-member functions enable the use of &lt;code&gt;directory_iterator&lt;/code&gt;s with range-based for loops.</source>
          <target state="translated">这些非成员函数允许将 &lt;code&gt;directory_iterator&lt;/code&gt; 与基于范围的for循环一起使用。</target>
        </trans-unit>
        <trans-unit id="d44ff77d7541183f5d7e43423582626b5049a546" translate="yes" xml:space="preserve">
          <source>These non-member functions enable the use of &lt;code&gt;recursive_directory_iterator&lt;/code&gt;s with range-based for loops.</source>
          <target state="translated">这些非成员函数使 &lt;code&gt;recursive_directory_iterator&lt;/code&gt; 可以与基于范围的for循环一起使用。</target>
        </trans-unit>
        <trans-unit id="f216125f2ad7bca05acbed754c42e867a1a09cab" translate="yes" xml:space="preserve">
          <source>These non-member functions provide a generic interface for containers, plain arrays, and &lt;code&gt;&lt;a href=&quot;utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些非成员函数为容器，纯数组和 &lt;code&gt;&lt;a href=&quot;utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 提供通用接口。</target>
        </trans-unit>
        <trans-unit id="b6245e0fb4125a31e0f987895270819c57ced919" translate="yes" xml:space="preserve">
          <source>These objects are guaranteed to be initialized during or before the first time an object of type &lt;code&gt;&lt;a href=&quot;ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; is constructed and are available for use in the constructors and destructors of static objects with &lt;a href=&quot;../language/initialization#Non-local_variables&quot;&gt;ordered initialization&lt;/a&gt; (as long as &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; is included before the object is defined).</source>
          <target state="translated">确保在第一次构造 &lt;code&gt;&lt;a href=&quot;ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; 类型的对象期间或之前初始化这些对象，并且可用于按&lt;a href=&quot;../language/initialization#Non-local_variables&quot;&gt;顺序进行初始化&lt;/a&gt;的静态对象的构造函数和析构函数中使用（只要 &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; 为包括在定义对象之前）。</target>
        </trans-unit>
        <trans-unit id="e1ea5b16593fd62c406fa74578d8a51e69297d84" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::chrono_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;chrono_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt;.</source>
          <target state="translated">这些运算符在名称空间 &lt;code&gt;std::literals::chrono_literals&lt;/code&gt; ，其中 &lt;code&gt;literals&lt;/code&gt; 和 &lt;code&gt;chrono_literals&lt;/code&gt; 都是内联名称空间。 &lt;code&gt;using namespace std::literals&lt;/code&gt; ， &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt; 以及 &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt; 可以访问这些运算符。</target>
        </trans-unit>
        <trans-unit id="c775ca0f064f8efbb0eebd72489c895fca0cd5d9" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::complex_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;complex_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::complex_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::complex_literals&lt;/code&gt;.</source>
          <target state="translated">这些运算符在名称空间 &lt;code&gt;std::literals::complex_literals&lt;/code&gt; ，其中 &lt;code&gt;literals&lt;/code&gt; 和 &lt;code&gt;complex_literals&lt;/code&gt; 都是内联名称空间。 &lt;code&gt;using namespace std::literals&lt;/code&gt; ， &lt;code&gt;using namespace std::complex_literals&lt;/code&gt; 和 &lt;code&gt;using namespace std::literals::complex_literals&lt;/code&gt; 可以获得对这些运算符的访问权。</target>
        </trans-unit>
        <trans-unit id="23ceae8d0ac1ad1f53f34bde5fef4212a07b1d5a" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::string_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;string_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::string_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::string_literals&lt;/code&gt;.</source>
          <target state="translated">这些运算符在名称空间 &lt;code&gt;std::literals::string_literals&lt;/code&gt; ，其中 &lt;code&gt;literals&lt;/code&gt; 和 &lt;code&gt;string_literals&lt;/code&gt; 都是内联名称空间。 &lt;code&gt;using namespace std::literals&lt;/code&gt; ， &lt;code&gt;using namespace std::string_literals&lt;/code&gt; 以及 &lt;code&gt;using namespace std::literals::string_literals&lt;/code&gt; 可以访问这些运算符。</target>
        </trans-unit>
        <trans-unit id="37f431af515778abb156bc8a341491c98c563acc" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::string_view_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;string_view_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::string_view_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::string_view_literals&lt;/code&gt;.</source>
          <target state="translated">这些运算符在名称空间 &lt;code&gt;std::literals::string_view_literals&lt;/code&gt; ，其中 &lt;code&gt;literals&lt;/code&gt; 和 &lt;code&gt;string_view_literals&lt;/code&gt; 都是内联名称空间。 &lt;code&gt;using namespace std::literals&lt;/code&gt; ， &lt;code&gt;using namespace std::string_view_literals&lt;/code&gt; 以及 &lt;code&gt;using namespace std::literals::string_view_literals&lt;/code&gt; 可以访问这些运算符。</target>
        </trans-unit>
        <trans-unit id="be85bd7cbe4be2517bbbe6791661ad5c07a4cbe3" translate="yes" xml:space="preserve">
          <source>These operators are sometimes implemented as &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt;.</source>
          <target state="translated">这些运算符有时被实现为&lt;a href=&quot;friend&quot;&gt;好友功能&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="71b614f00aac3b3aedb1ef8cf1ee4d989be39411" translate="yes" xml:space="preserve">
          <source>These operators were not &lt;code&gt;constexpr&lt;/code&gt; in C++11, this was corrected in C++14.</source>
          <target state="translated">这些运算符在C ++ 11 中不是 &lt;code&gt;constexpr&lt;/code&gt; ，在C ++ 14中已得到纠正。</target>
        </trans-unit>
        <trans-unit id="86bd9326b779710e8e7e30da617be0d3ac76c4df" translate="yes" xml:space="preserve">
          <source>These overloads do not participate in overload resolution unless the following conditions are met:</source>
          <target state="translated">除非满足以下条件,否则这些过载不参与过载解决。</target>
        </trans-unit>
        <trans-unit id="e48cfeb3277137050ec5b9718b8d37fe7f54cb7e" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is not a pointer type.</source>
          <target state="translated">这些重载仅在 &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 并且 &lt;code&gt;Deleter&lt;/code&gt; 不是指针类型时才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="88f134a2bed08d434e838bcdda34ccb397f8eca8" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if the corresponding &lt;code&gt;from_stream&lt;/code&gt; expression is well-formed.</source>
          <target state="translated">如果相应的 &lt;code&gt;from_stream&lt;/code&gt; 表达式格式正确，则这些重载仅参与重载解析。</target>
        </trans-unit>
        <trans-unit id="a2d116b1f38656e4ef14e8e4c82c85d94f84a468" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if.</source>
          <target state="translated">这些过载只有在以下情况下才会参与过载解决:</target>
        </trans-unit>
        <trans-unit id="78f7dc8ed866031cd5d45fb8e30c10dc7cab0d38" translate="yes" xml:space="preserve">
          <source>These pair-wise comparisons are applied to all viable functions. If exactly one viable function is better than all others, overload resolution succeeds and this function is called. Otherwise, compilation fails.</source>
          <target state="translated">这些成对的比较被应用于所有可行的函数。如果正好有一个可行的函数比其他所有函数都好,那么过载解析成功,这个函数被调用。否则,编译失败。</target>
        </trans-unit>
        <trans-unit id="87d3e33f926d43ebf3e0bc3d2ed5785d5f7e359f" translate="yes" xml:space="preserve">
          <source>These pointer arithmetic operators allow pointers to satisfy the &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; requirements.</source>
          <target state="translated">这些指针算术运算符允许指针满足&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;要求。</target>
        </trans-unit>
        <trans-unit id="91cc6d32c62a3af187353d24cb8355a046134850" translate="yes" xml:space="preserve">
          <source>These specializations make it possible to use &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::wregex&lt;/a&gt;&lt;/code&gt;). To use &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; with other character types (for example, &lt;code&gt;char32_t&lt;/code&gt;), a user-provided trait class must be used.</source>
          <target state="translated">这些专业知识使得可以使用 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; （aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; （aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::wregex&lt;/a&gt;&lt;/code&gt; ）。要将 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 与其他字符类型（例如 &lt;code&gt;char32_t&lt;/code&gt; ）一起使用，必须使用用户提供的特征类。</target>
        </trans-unit>
        <trans-unit id="8fb1d3f8496237287e2630d9516276eb8186eeef" translate="yes" xml:space="preserve">
          <source>These transformation traits were required</source>
          <target state="translated">这些转变特征是必需的</target>
        </trans-unit>
        <trans-unit id="25f1f4bdd72a09c080801d8fffb8ec4bf62a753c" translate="yes" xml:space="preserve">
          <source>These two alias templates are used by some &lt;a href=&quot;../algorithm/ranges&quot;&gt;constrained algorithms&lt;/a&gt; to avoid returning potentially dangling iterators or views.</source>
          <target state="translated">这两个别名模板被某些&lt;a href=&quot;../algorithm/ranges&quot;&gt;约束算法&lt;/a&gt;使用，以避免返回可能悬挂的迭代器或视图。</target>
        </trans-unit>
        <trans-unit id="c7a8b1fbd19de341e5ad49bc78a2acbfda770aec" translate="yes" xml:space="preserve">
          <source>These type transformations honor reference collapse rules:</source>
          <target state="translated">这些类型转换尊重引用折叠规则。</target>
        </trans-unit>
        <trans-unit id="dbcace5dd757886bde993d55984f6189eef2a5ad" translate="yes" xml:space="preserve">
          <source>These values are constants, and do not reflect the changes to the rounding made by &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt;. The changed values may be obtained from &lt;code&gt;&lt;a href=&quot;../climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fegetround&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这些值是常量，并不反映 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; 对舍入所做的更改。更改后的值可以从 &lt;code&gt;&lt;a href=&quot;../climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fegetround&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce671f14cf50f53efd465a7781656ad990f4484e" translate="yes" xml:space="preserve">
          <source>They are commonly used as a convenient shortcut for long or deeply-nested namespaces.</source>
          <target state="translated">它们通常被用作长的或深嵌套的命名空间的方便快捷方式。</target>
        </trans-unit>
        <trans-unit id="0c8a84aed3ced580611d15354b0869a722fa11d7" translate="yes" xml:space="preserve">
          <source>They are used to specify locking strategies for &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">它们用于为 &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; 指定锁定策略。</target>
        </trans-unit>
        <trans-unit id="11cfa3f63f9b9843169a75987765b90b1df36aef" translate="yes" xml:space="preserve">
          <source>They can also be used to implement pass-by-reference semantics in function calls:</source>
          <target state="translated">它们也可以用来实现函数调用中的逐次引用语义。</target>
        </trans-unit>
        <trans-unit id="404264233979032de1c13fb29f764da6094435a2" translate="yes" xml:space="preserve">
          <source>Third version</source>
          <target state="translated">第三版</target>
        </trans-unit>
        <trans-unit id="674677ba31e30e4e6af559bc6fc67687b54c0a70" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; to allow deduction from an iterator range.</source>
          <target state="translated">为 &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 提供了此&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;，以允许从迭代器范围进行推导。</target>
        </trans-unit>
        <trans-unit id="4c01d9032d07a333deef547c5311682cb32b0369" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; to allow deduction from array and size (note that deduction from pointer and size is covered by the implicit guides).</source>
          <target state="translated">此&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 提供的，以允许从数组和大小推导（请注意，隐式指南涵盖了从指针和大小推导的内容）。</target>
        </trans-unit>
        <trans-unit id="080faae34fcef190f2de9f444682b5ad95d98c79" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for deque to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">提供此&lt;a href=&quot;../../language/deduction_guide&quot;&gt;扣除指南&lt;/a&gt;用于双端队列，以允许从迭代器范围进行扣除。仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;并且 &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator时，&lt;/a&gt;此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="1a6452884a208e722e9625cf9199c504d50511f4" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for forward_list to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为forward_list提供的，以允许从迭代器范围进行推导。仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;并且 &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator时，&lt;/a&gt;此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="491ded200502330a3077bffc8f20aba48e33a32f" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for list to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">提供此&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;以允许从迭代器范围进行推导。仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;并且 &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator时，&lt;/a&gt;此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="d250c6703a67ce4010a480cdc0512de03c8d6af8" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for map to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">该&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为map提供的，以允许从迭代器范围（过载（1,3））和 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （过载（2,4））中进行推导。这些重载只参加重载如果 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;， &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;和 &lt;code&gt;Comp&lt;/code&gt; 不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="472f8efb63db0b27b39e33719d752a5b58fa4ac0" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for multimap to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">本&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;是为multimap提供的，以允许从迭代器范围（重载（1,3））和 &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; （重载（2,4））中推导。这些重载只参加重载如果 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;， &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;和 &lt;code&gt;Comp&lt;/code&gt; 不满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;分配器&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="404371bbe2687bcdbddb8c17f22af8568b34d514" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for vector to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">为矢量提供了此&lt;a href=&quot;../../language/deduction_guide&quot;&gt;推导指南&lt;/a&gt;，以允许从迭代器范围进行推导。仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;并且 &lt;code&gt;Alloc&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator时，&lt;/a&gt;此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="9d19a67c2a590fb3edea166f3993c75495030081" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is only defined if the capture list of the lambda-expression is empty. It is a public, constexpr,(since C++17) non-virtual, non-explicit, const noexcept(since C++14) member function of the closure object. It is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the function call operator of the lambda is an immediate function.(since C++20).</source>
          <target state="translated">仅当lambda表达式的捕获列表为空时，才定义此&lt;a href=&quot;cast_operator&quot;&gt;用户定义的转换函数&lt;/a&gt;。它是闭包对象的公共，constexpr（自C ++ 17起）非虚拟，非显式，const noexcept（自C ++ 14起）成员函数。如果lambda的函数调用运算符是&lt;a href=&quot;consteval&quot;&gt;立即函数，&lt;/a&gt;则它是立即函数。（自C ++ 20起）。</target>
        </trans-unit>
        <trans-unit id="9dd4d9a7e5470c751564a0b43d9bb48488ca73ae" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is primarily intended for debugging use. For control over formatting, use &lt;code&gt;std::chrono::format&lt;/code&gt;.</source>
          <target state="translated">此 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 主要用于调试。要控制格式，请使用 &lt;code&gt;std::chrono::format&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdeeb8bd8306a58bb3de2426d5fca261070137d1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is primarily intended for debugging use. When used with non-default stream flags, the output may be surprising:</source>
          <target state="translated">此 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 主要用于调试。当与非默认流标志一起使用时，输出可能令人惊讶：</target>
        </trans-unit>
        <trans-unit id="45d5bafe4e82677bb34e8489531cf8b9395463b2" translate="yes" xml:space="preserve">
          <source>This algorithm is a more general form of &lt;code&gt;&lt;a href=&quot;lower_bound&quot;&gt;std::lower_bound&lt;/a&gt;&lt;/code&gt;, which can be expressed in terms of &lt;code&gt;std::partition_point&lt;/code&gt; with the predicate &lt;code&gt;[&amp;amp;](auto const&amp;amp; e) { return e &amp;lt; value; });&lt;/code&gt;.</source>
          <target state="translated">该算法是 &lt;code&gt;&lt;a href=&quot;lower_bound&quot;&gt;std::lower_bound&lt;/a&gt;&lt;/code&gt; 的更一般形式，可以用带有谓词 &lt;code&gt;[&amp;amp;](auto const&amp;amp; e) { return e &amp;lt; value; });&lt;/code&gt; 的 &lt;code&gt;std::partition_point&lt;/code&gt; 表示：{return e &amp;lt;value; }）; 。</target>
        </trans-unit>
        <trans-unit id="823f5a9d51f4a4e6c775e32f3efd9551b4b6ecbf" translate="yes" xml:space="preserve">
          <source>This algorithm is different from &lt;code&gt;&lt;a href=&quot;../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(&lt;a href=&quot;min_element&quot;&gt;std::min_element&lt;/a&gt;(), &lt;a href=&quot;max_element&quot;&gt;std::max_element&lt;/a&gt;())&lt;/code&gt;, not only in efficiency, but also in that this algorithm finds the</source>
          <target state="translated">该算法与 &lt;code&gt;&lt;a href=&quot;../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(&lt;a href=&quot;min_element&quot;&gt;std::min_element&lt;/a&gt;(), &lt;a href=&quot;max_element&quot;&gt;std::max_element&lt;/a&gt;())&lt;/code&gt; ，不仅效率高，而且算法可以找到</target>
        </trans-unit>
        <trans-unit id="25bb18b7071a3878825d2611ae20fefcf112dcd2" translate="yes" xml:space="preserve">
          <source>This algorithm performs a similar task as &lt;code&gt;&lt;a href=&quot;merge&quot;&gt;std::merge&lt;/a&gt;&lt;/code&gt; does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;). If any equivalent values appeared &lt;code&gt;n&lt;/code&gt; times in the first range and &lt;code&gt;m&lt;/code&gt; times in the second, &lt;code&gt;std::merge&lt;/code&gt; would output all &lt;code&gt;n+m&lt;/code&gt; occurrences whereas &lt;code&gt;std::set_union&lt;/code&gt; would output &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; ones only. So &lt;code&gt;std::merge&lt;/code&gt; outputs exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; values and &lt;code&gt;std::set_union&lt;/code&gt; may produce less.</source>
          <target state="translated">该算法执行与 &lt;code&gt;&lt;a href=&quot;merge&quot;&gt;std::merge&lt;/a&gt;&lt;/code&gt; 相似的任务。两者都消耗两个已排序的输入范围，并使用来自两个输入的元素生成一个已排序的输出。这两种算法之间的区别在于处理来自两个输入范围的值，这些值比较等效项（请参阅&lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable上的&lt;/a&gt;注释）。如果任何等效值在第一个范围中出现 &lt;code&gt;n&lt;/code&gt; 次，在第二个范围中出现 &lt;code&gt;m&lt;/code&gt; 次，则 &lt;code&gt;std::merge&lt;/code&gt; 将输出所有 &lt;code&gt;n+m&lt;/code&gt; 次出现，而 &lt;code&gt;std::set_union&lt;/code&gt; 输出 &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; 。所以 &lt;code&gt;std::merge&lt;/code&gt; 精确地输出 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; 值和 &lt;code&gt;std::set_union&lt;/code&gt; 可能会产生更少的结果。</target>
        </trans-unit>
        <trans-unit id="7d29fc2206a5224dabc98e893d9a9b64464432d3" translate="yes" xml:space="preserve">
          <source>This algorithm performs a similar task as &lt;code&gt;&lt;a href=&quot;set_union&quot;&gt;std::set_union&lt;/a&gt;&lt;/code&gt; does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;). If any equivalent values appeared &lt;code&gt;n&lt;/code&gt; times in the first range and &lt;code&gt;m&lt;/code&gt; times in the second, &lt;code&gt;std::merge&lt;/code&gt; would output all &lt;code&gt;n+m&lt;/code&gt; occurrences whereas &lt;code&gt;std::set_union&lt;/code&gt; would output &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; ones only. So &lt;code&gt;std::merge&lt;/code&gt; outputs exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; values and &lt;code&gt;std::set_union&lt;/code&gt; may produce fewer.</source>
          <target state="translated">该算法执行与 &lt;code&gt;&lt;a href=&quot;set_union&quot;&gt;std::set_union&lt;/a&gt;&lt;/code&gt; 类似的任务。两者都消耗两个已排序的输入范围，并使用来自两个输入的元素生成一个已排序的输出。这两种算法之间的区别在于处理来自两个输入范围的值，这些值比较等效项（请参阅&lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable上的&lt;/a&gt;注释）。如果任何等效值在第一个范围中出现 &lt;code&gt;n&lt;/code&gt; 次，在第二个范围中出现 &lt;code&gt;m&lt;/code&gt; 次，则 &lt;code&gt;std::merge&lt;/code&gt; 将输出所有 &lt;code&gt;n+m&lt;/code&gt; 次出现，而 &lt;code&gt;std::set_union&lt;/code&gt; 输出 &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; 。所以 &lt;code&gt;std::merge&lt;/code&gt; 精确地输出 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; 值和 &lt;code&gt;std::set_union&lt;/code&gt; 可能会产生更少的值。</target>
        </trans-unit>
        <trans-unit id="67039572a7b1266afd41cb596fd8e9903073b309" translate="yes" xml:space="preserve">
          <source>This allows &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt;, &lt;a href=&quot;move_operator&quot;&gt;move assignment&lt;/a&gt; operators, and other move-aware functions (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back()&lt;/a&gt;&lt;/code&gt;) to be automatically selected when suitable.</source>
          <target state="translated">这允许在合适时自动选择&lt;a href=&quot;move_constructor&quot;&gt;移动构造函数&lt;/a&gt;，&lt;a href=&quot;move_operator&quot;&gt;移动分配&lt;/a&gt;运算符和其他移动感知功能（例如 &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back()&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6b23439395d3de2ec476135a3b042e5160bd72c2" translate="yes" xml:space="preserve">
          <source>This allows objects of small class types, such as &lt;code&gt;&lt;a href=&quot;../numeric/complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::span&lt;/code&gt;, to be passed to or returned from functions in registers.</source>
          <target state="translated">这允许将小类类型的对象（例如 &lt;code&gt;&lt;a href=&quot;../numeric/complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;std::span&lt;/code&gt; 传递到寄存器中的函数或从寄存器中返回。</target>
        </trans-unit>
        <trans-unit id="1ba1397263db3733d0fec3f4eee183f7dd40c32d" translate="yes" xml:space="preserve">
          <source>This also makes it possible to capture by const reference, with &lt;code&gt;&amp;amp;cr = &lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;(x)&lt;/code&gt; or similar.</source>
          <target state="translated">这也使得可以使用 &lt;code&gt;&amp;amp;cr = &lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;(x)&lt;/code&gt; 或类似名称通过const引用进行捕获。</target>
        </trans-unit>
        <trans-unit id="b270e0b13927c9c7d55e1dcef0f35f6860aa9231" translate="yes" xml:space="preserve">
          <source>This applies even to variants of non-class types:</source>
          <target state="translated">这甚至适用于非类类型的变体。</target>
        </trans-unit>
        <trans-unit id="c7b69ba009614b0512956cea74a4d37944d632b2" translate="yes" xml:space="preserve">
          <source>This applies to the members of the class template: unless the member is used in the program, it is not instantiated, and does not require a definition.</source>
          <target state="translated">这适用于类模板的成员:除非该成员在程序中使用,否则它不会被实例化,也不需要定义。</target>
        </trans-unit>
        <trans-unit id="afda8940351e810bc83ac7a0844c6ee697d190f3" translate="yes" xml:space="preserve">
          <source>This attribute applies to the name of the function being declared in function declarations only. The behavior is undefined if the function with this attribute actually returns.</source>
          <target state="translated">这个属性只适用于在函数声明中被声明的函数名。如果带有此属性的函数实际返回,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="a6310c0c875c2cc4202df04650e9b8684a1ea09d" translate="yes" xml:space="preserve">
          <source>This attribute can appear in the declaration of the following entities:</source>
          <target state="translated">这个属性可以出现在以下实体的声明中。</target>
        </trans-unit>
        <trans-unit id="48e9f5d2fd561ba7f787f00554eb0339866d9697" translate="yes" xml:space="preserve">
          <source>This attribute is allowed in declarations of the following names or entities:</source>
          <target state="translated">在以下名称或实体的声明中允许使用该属性。</target>
        </trans-unit>
        <trans-unit id="bc9a88af611a842f4ad52d91eb1d0dc9725b08e4" translate="yes" xml:space="preserve">
          <source>This attribute may appear in two situations:</source>
          <target state="translated">这个属性可能出现在两种情况下。</target>
        </trans-unit>
        <trans-unit id="492617afde39ac181a5c63ce324178dcbd2c9236" translate="yes" xml:space="preserve">
          <source>This attribute must appear on the first declaration of a function or one of its parameters in any translation unit. If it is not used on the first declaration of a function or one of its parameters in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">这个属性必须出现在任何翻译单元中函数或其参数之一的第一次声明中。如果它没有被用于一个函数的第一次声明或它在另一个翻译单元中的一个参数上,那么该程序是不合格的;不需要诊断。</target>
        </trans-unit>
        <trans-unit id="da819209a9e30721dffd50c194d372495640b66c" translate="yes" xml:space="preserve">
          <source>This class defines the type of objects thrown as exceptions to report errors from the regular expressions library.</source>
          <target state="translated">这个类定义了从正则表达式库中作为异常报告错误而抛出的对象类型。</target>
        </trans-unit>
        <trans-unit id="d05fe9ff7a9efe7a6be4213effba38b5678ca3d8" translate="yes" xml:space="preserve">
          <source>This class is designed for use as key in associative containers, both ordered and unordered.</source>
          <target state="translated">该类被设计用于关联容器中的键,包括有序和无序。</target>
        </trans-unit>
        <trans-unit id="c77922f02193571f4c08570b0423206a1a325b4d" translate="yes" xml:space="preserve">
          <source>This class is used to ensure that the default C++ streams (&lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, etc.) are properly initialized and destructed. The class tracks how many instances of it are created and initializes the C++ streams when the first instance is constructed as well as flushes the output streams when the last instance is destructed.</source>
          <target state="translated">此类用于确保正确初始化和销毁默认C ++流（ &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 等）。该类跟踪创建它的实例数，并在构造第一个实例时初始化C ++流，并在销毁最后一个实例时刷新输出流。</target>
        </trans-unit>
        <trans-unit id="4782fa86482a6f5000533d5566f5443e1b31c285" translate="yes" xml:space="preserve">
          <source>This class template is the preferred comparison predicate when building associative containers with &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; as keys, that is,</source>
          <target state="translated">当使用 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 作为键构建关联容器时，此类模板是首选的比较谓词，即，</target>
        </trans-unit>
        <trans-unit id="d4129ee928b19fe777216b3fc0a11eb88a14da35" translate="yes" xml:space="preserve">
          <source>This class template makes the implicit character conversion functionality of &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; available for any &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该类模板使 &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 的隐式字符转换功能可用于任何 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67af0e94f21d7e3028f080552ccfa30f81f3903f" translate="yes" xml:space="preserve">
          <source>This classification allows the following errors to be detected at the point of template definition (rather than instantiation):</source>
          <target state="translated">通过这种分类,可以在模板定义(而不是实例化)时检测到以下错误。</target>
        </trans-unit>
        <trans-unit id="58ce9513b35dc96e87c0d70ac154af849efb1443" translate="yes" xml:space="preserve">
          <source>This constructor does not participate in overload resolution if &lt;code&gt;std::decay_t&amp;lt;Function&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;std::decay_t&amp;lt;Function&amp;gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 具有相同的类型，则此构造方法不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="a905969e8e69e6e88d275ad307f8717581731297" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;deque(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 是整数类型 &lt;code&gt;deque(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 则此构造方法与deque（static_cast &amp;lt;size_type&amp;gt;（first），static_cast &amp;lt;value_type&amp;gt;（last），a）具有相同的作用。</target>
        </trans-unit>
        <trans-unit id="7a2d779c18396eab1ee0e06cc486a3335e7edd14" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;forward_list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 是整数类型 &lt;code&gt;forward_list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 则此构造函数与forward_list（static_cast &amp;lt;size_type&amp;gt;（first），static_cast &amp;lt;value_type&amp;gt;（last），a）具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="11411ad8214fe6e6c7202887522fc136fe3e90db" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 是整数类型 &lt;code&gt;list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 则此构造方法与list（static_cast &amp;lt;size_type&amp;gt;（first），static_cast &amp;lt;value_type&amp;gt;（last），a）具有相同的作用。</target>
        </trans-unit>
        <trans-unit id="d0215f7826bd287562237b0c5f6bbd13fcaf0661" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;vector(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 是整数类型 &lt;code&gt;vector(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; 则此构造函数与vector（static_cast &amp;lt;size_type&amp;gt;（first），static_cast &amp;lt;value_type&amp;gt;（last），a）具有相同的作用。</target>
        </trans-unit>
        <trans-unit id="16d9b8332d1923e6161015fdc9a2cff3bdfaa0b6" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;constexpr&lt;/code&gt; if every operation it performs is &lt;code&gt;constexpr&lt;/code&gt;. For the empty tuple &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;&lt;/code&gt;, it is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">如果构造函数执行的每个操作均为 &lt;code&gt;constexpr&lt;/code&gt; ,则此构造函数为 &lt;code&gt;constexpr&lt;/code&gt; 。对于空元组 &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;&lt;/code&gt; ，它是 &lt;code&gt;constexpr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39b96837fbee6ff8b11f2afbe55d19be8b5237f0" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ti&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for at least one &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">当且仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ti&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; &amp;lt;const Ti＆，Ti&amp;gt; :: value对于至少一个 &lt;code&gt;i&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 时，此构造函数才是 &lt;code&gt;explicit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="533bf2fceb953a9339da3a3efe2403151289bf62" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U&amp;amp;&amp;amp;, T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当且仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U&amp;amp;&amp;amp;, T&amp;gt;&lt;/code&gt; &amp;lt;U &amp;amp;&amp;amp;，T&amp;gt;为 &lt;code&gt;false&lt;/code&gt; 时，此构造函数才是 &lt;code&gt;explicit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="956eea7f4a03a0995417ca7671e86890da8c691a" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U2&amp;amp;&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当且仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, first_type&amp;gt;&lt;/code&gt; &amp;lt;U1 &amp;amp;&amp;amp;，first_type&amp;gt;为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U2&amp;amp;&amp;amp;, second_type&amp;gt;&lt;/code&gt; &amp;lt;U2 &amp;amp;&amp;amp;，second_type&amp;gt;为 &lt;code&gt;false&lt;/code&gt; 时，此构造函数才是 &lt;code&gt;explicit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00d14d163d5ca5d7a526cb55477d4d3d44718aa1" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U&amp;amp;, T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当且仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U&amp;amp;, T&amp;gt;&lt;/code&gt; &amp;lt;const U＆，T&amp;gt;为 &lt;code&gt;false&lt;/code&gt; 时，此构造函数才是 &lt;code&gt;explicit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="703819705f083463e0d7af074684609042e9b532" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U1&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U2&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当且仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U1&amp;amp;, first_type&amp;gt;&lt;/code&gt; &amp;lt;const U1＆，first_type&amp;gt;为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U2&amp;amp;, second_type&amp;gt;&lt;/code&gt; &amp;lt;const U2＆，second_type&amp;gt;为 &lt;code&gt;false&lt;/code&gt; 时，此构造函数才是 &lt;code&gt;explicit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2d388bc3de25d32e823ab3902c5cb2c7f0bb128" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const first_type&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const second_type&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">当且仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const first_type&amp;amp;, first_type&amp;gt;&lt;/code&gt; &amp;lt;const first_type＆，first_type&amp;gt;为 &lt;code&gt;false&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const second_type&amp;amp;, second_type&amp;gt;&lt;/code&gt; &amp;lt;const second_type＆，second_type&amp;gt;为 &lt;code&gt;false&lt;/code&gt; 时，此构造函数才是 &lt;code&gt;explicit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c083a7d9073cd96386cc41c8aa08c4631002fa1" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if either &lt;code&gt;first_type&lt;/code&gt; or &lt;code&gt;second_type&lt;/code&gt; is not implicitly default-constructible.</source>
          <target state="translated">当且仅当 &lt;code&gt;first_type&lt;/code&gt; 或 &lt;code&gt;second_type&lt;/code&gt; 不能隐式默认构造时，此构造函数才是 &lt;code&gt;explicit&lt;/code&gt; 式的。</target>
        </trans-unit>
        <trans-unit id="9e3f4b55350fb3f6d920bcec2b1f50c5260e2934" translate="yes" xml:space="preserve">
          <source>This constructor is ill-formed if &lt;code&gt;Deleter&lt;/code&gt; is of pointer or reference type.</source>
          <target state="translated">如果 &lt;code&gt;Deleter&lt;/code&gt; 是指针或引用类型，则此构造函数格式错误。</target>
        </trans-unit>
        <trans-unit id="8f4ffe9c6a9e19f1b0de1f70aa1c6912c5d13790" translate="yes" xml:space="preserve">
          <source>This constructor only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator，&lt;/a&gt;则此构造方法仅参与重载解析。</target>
        </trans-unit>
        <trans-unit id="6429d3c8a00cca9524476fd5e7bc85b284721fa1" translate="yes" xml:space="preserve">
          <source>This constructor only participates in overload resolution if all of the following is true:</source>
          <target state="translated">只有当以下所有条件为真时,该构造函数才会参与重载解析。</target>
        </trans-unit>
        <trans-unit id="5189004f2798523a38b087278bd624f438a82960" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当且仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 时，此构造方法才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="4726fe3e137ecc9cfdc444c3524298098da680a8" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, const U1&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, const U2&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当且仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, const U1&amp;amp;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, const U2&amp;amp;&amp;gt;&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 时，此构造方法才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="b97d7fbb9211117804e8e5c015e20e35239347ae" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当且仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 时,此构造方法才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="efe7ac6a6eaa86bb5c97cb1a9afabf3305f77bd2" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当且仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; 都为 &lt;code&gt;true&lt;/code&gt; 时,此构造方法才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="a9636e46cd99b7aa6a5346c674ec8170c547d2f3" translate="yes" xml:space="preserve">
          <source>This container is an aggregate type with the same semantics as a struct holding a &lt;a href=&quot;../language/array&quot;&gt;C-style array&lt;/a&gt;&lt;code&gt;T[N]&lt;/code&gt; as its only non-static data member. Unlike a C-style array, it doesn't decay to &lt;code&gt;T*&lt;/code&gt; automatically. As an aggregate type, it can be initialized with &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialization&lt;/a&gt; given at most &lt;code&gt;N&lt;/code&gt; initializers that are convertible to &lt;code&gt;T&lt;/code&gt;: &lt;code&gt;std::array&amp;lt;int, 3&amp;gt; a = {1,2,3};&lt;/code&gt;.</source>
          <target state="translated">此容器是一种聚合类型，其语义与将&lt;a href=&quot;../language/array&quot;&gt;C型数组&lt;/a&gt; &lt;code&gt;T[N]&lt;/code&gt; 作为其唯一的非静态数据成员的结构具有相同的语义。与C样式的数组不同，它不会自动衰减为 &lt;code&gt;T*&lt;/code&gt; 。作为一种聚合类型，可以使用最多可转换为 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;N&lt;/code&gt; 个初始化&lt;a href=&quot;../language/aggregate_initialization&quot;&gt;器&lt;/a&gt;给定的聚合初始化来初始化： &lt;code&gt;std::array&amp;lt;int, 3&amp;gt; a = {1,2,3};&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2bf0aa51a2fd1da025ddbd712b50083980038a0d" translate="yes" xml:space="preserve">
          <source>This conversion models the act of reading a value from a memory location into a CPU register.</source>
          <target state="translated">这个转换模型是将一个值从内存位置读到CPU寄存器的行为。</target>
        </trans-unit>
        <trans-unit id="486e8ea678d2260d566d72fdb476e2364e350e4a" translate="yes" xml:space="preserve">
          <source>This declaration may declare &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; and non-static &lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt; and &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;, member &lt;a href=&quot;typedef&quot;&gt;typedefs&lt;/a&gt;, member &lt;a href=&quot;enum&quot;&gt;enumerations&lt;/a&gt;, and &lt;a href=&quot;nested_classes&quot;&gt;nested classes&lt;/a&gt;. It may also be a &lt;a href=&quot;friend&quot;&gt;friend declaration&lt;/a&gt;.</source>
          <target state="translated">该声明可以声明&lt;a href=&quot;static&quot;&gt;静态&lt;/a&gt;和非静态&lt;a href=&quot;data_members&quot;&gt;数据成员&lt;/a&gt;和&lt;a href=&quot;member_functions&quot;&gt;成员函数&lt;/a&gt;，成员&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;，成员&lt;a href=&quot;enum&quot;&gt;枚举&lt;/a&gt;和&lt;a href=&quot;nested_classes&quot;&gt;嵌套类&lt;/a&gt;。也可能是&lt;a href=&quot;friend&quot;&gt;朋友声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="790f40ee47446044b6d23c3286797ccea1e6e155" translate="yes" xml:space="preserve">
          <source>This declaration must declare a constructor, destructor, or user-defined type &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt;. It can only be used as part of a &lt;a href=&quot;templates&quot;&gt;template declaration&lt;/a&gt;, &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt;, or explicit instantiation.</source>
          <target state="translated">该声明必须声明一个构造函数，析构函数或用户定义的类型&lt;a href=&quot;cast_operator&quot;&gt;转换函数&lt;/a&gt;。它只能用作&lt;a href=&quot;templates&quot;&gt;模板声明&lt;/a&gt;，&lt;a href=&quot;template_specialization&quot;&gt;显式专门&lt;/a&gt;化或显式实例化的一部分。</target>
        </trans-unit>
        <trans-unit id="b21c4afc7d9f44a231494182ce929f3873dbd60e" translate="yes" xml:space="preserve">
          <source>This definition is treated as a definition of a namespace with unique name and a</source>
          <target state="translated">该定义被视为一个具有唯一名称的命名空间的定义,并有一个</target>
        </trans-unit>
        <trans-unit id="f5d805f6f41052ad913a678cd3a3f6f56d5cd6ca" translate="yes" xml:space="preserve">
          <source>This destruction is empty: the members of this &lt;code&gt;basic_streambuf&lt;/code&gt; (the pointers and the locale) are destructed in accordance with the usual object destruction sequence after this destructor returns. However, since it is declared public virtual, it allows the objects that are derived from &lt;code&gt;std::basic_streambuf&lt;/code&gt; to be deleted through a pointer to base class.</source>
          <target state="translated">此销毁是空的：在此析构函数返回之后，将根据通常的对象销毁顺序来销毁 &lt;code&gt;basic_streambuf&lt;/code&gt; 的成员（指针和语言环境）。但是，由于已将其声明为公共虚拟，因此它允许通过指向基类的指针删除从 &lt;code&gt;std::basic_streambuf&lt;/code&gt; 派生的对象。</target>
        </trans-unit>
        <trans-unit id="566d630222759bb1a22c3aebcb32a3363161c684" translate="yes" xml:space="preserve">
          <source>This destructor does not perform any operation on the underlying stream buffer (&lt;code&gt;rdbuf()&lt;/code&gt;): the destructors of the derived streams such as &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; are responsible for calling the destructors of the stream buffers.</source>
          <target state="translated">此析构函数不对基础流缓冲区（ &lt;code&gt;rdbuf()&lt;/code&gt; ）执行任何操作：派生流的析构函数，例如 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; 负责调用流缓冲区的析构函数。</target>
        </trans-unit>
        <trans-unit id="131f49f893678b58d7f7539c38777963fe7160b1" translate="yes" xml:space="preserve">
          <source>This destructor does not perform any operation on the underlying streambuffer (&lt;code&gt;rdbuf()&lt;/code&gt;): the destructors of the derived input streams such as &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; are responsible for calling the destructors of the streambuffers.</source>
          <target state="translated">此析构函数不对基础流 &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;rdbuf()&lt;/code&gt; ）执行任何操作：派生的输入流的析构函数，例如std :: basic_ifstream和 &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; 负责调用流缓冲区的析构函数。</target>
        </trans-unit>
        <trans-unit id="1b99959c6ca09f07071faff9ad3d0e8aafb11452" translate="yes" xml:space="preserve">
          <source>This destructor is &lt;code&gt;virtual&lt;/code&gt; because the base class destructor, &lt;a href=&quot;../ios_base/~ios_base&quot;&gt;&lt;code&gt;ios_base::~ios_base&lt;/code&gt;&lt;/a&gt; is virtual.</source>
          <target state="translated">此析构函数是 &lt;code&gt;virtual&lt;/code&gt; 因为基类析构函数&lt;a href=&quot;../ios_base/~ios_base&quot;&gt; &lt;code&gt;ios_base::~ios_base&lt;/code&gt; &lt;/a&gt;是虚拟的。</target>
        </trans-unit>
        <trans-unit id="e7593a44c2d3c23ae4a80ac5cc6624863832641b" translate="yes" xml:space="preserve">
          <source>This destructor is trivial if &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">该析构函数平凡的，如果 &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; 就是 &lt;code&gt;true&lt;/code&gt; 为所有 &lt;code&gt;T_i&lt;/code&gt; 在 &lt;code&gt;Types...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6df8c5501bb72be0811f778d216bdc599b74a410" translate="yes" xml:space="preserve">
          <source>This destructor is typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此析构函数通常由 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; 的析构函数调用。</target>
        </trans-unit>
        <trans-unit id="bb5e9bde864785c69be529012ab31825d767db62" translate="yes" xml:space="preserve">
          <source>This directive is used by some automatic code generation tools which produce C++ source files from a file written in another language. In that case, &lt;code&gt;#line&lt;/code&gt; directives may be inserted in the generated C++ file referencing line numbers and the file name of the original (human-editable) source file.</source>
          <target state="translated">一些自动代码生成工具使用此伪指令，这些工具从用另一种语言编写的文件中生成C ++源文件。在这种情况下，可以在生成的C ++文件中插入 &lt;code&gt;#line&lt;/code&gt; 指令，以引用行号和原始（人类可编辑）源文件的文件名。</target>
        </trans-unit>
        <trans-unit id="2160c0fc9b1d6f99749583e4a431b1db823b687a" translate="yes" xml:space="preserve">
          <source>This element acts as a placeholder; attempting to access it results in undefined behavior.</source>
          <target state="translated">该元素作为一个占位符;试图访问它将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="e1d92326ee038395416fb47c3929e52bba4b4b4a" translate="yes" xml:space="preserve">
          <source>This example demonistrates how to apply monetary formatting rules of another language without changing the rest of the locale.</source>
          <target state="translated">这个例子演示了如何应用另一种语言的货币格式规则,而不改变其他地方。</target>
        </trans-unit>
        <trans-unit id="699b77b3a2b284060799465bf0aef3eb6c604dfb" translate="yes" xml:space="preserve">
          <source>This example demonistrates how to apply numeric punctuation rules of another language without changing the rest of the locale.</source>
          <target state="translated">这个例子演示了如何应用另一种语言的数字标点符号规则,而不改变当地的其他部分。</target>
        </trans-unit>
        <trans-unit id="03a8f1b5ffb01757d8be09e129dc569a5400d2fc" translate="yes" xml:space="preserve">
          <source>This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; to observe changes to the atomics &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; in opposite order.</source>
          <target state="translated">本示例说明了需要顺序排序的情况。任何其他顺序都可能触发断言，因为线程 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 可能以相反的顺序观察原子 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的变化。</target>
        </trans-unit>
        <trans-unit id="6c12e1f3885c29be2bfca0cfe53639bf6159022e" translate="yes" xml:space="preserve">
          <source>This example demonstrates dependency-ordered synchronization for pointer-mediated publication: the integer data is not related to the pointer to string by a data-dependency relationship, thus its value is undefined in the consumer.</source>
          <target state="translated">这个例子演示了以指针为媒介的发布的依赖顺序同步:整数数据与指向字符串的指针没有数据依赖关系,因此它的值在消费者中是未定义的。</target>
        </trans-unit>
        <trans-unit id="6b01d954af477e04c266f80ede6e5280ccdc0a60" translate="yes" xml:space="preserve">
          <source>This example demonstrates perfect forwarding of the parameter(s) to the argument of the constructor of class &lt;code&gt;T&lt;/code&gt;. Also, perfect forwarding of parameter packs is demonstrated.</source>
          <target state="translated">此示例演示了将参数完美转发到类 &lt;code&gt;T&lt;/code&gt; 的构造函数的参数的过程。此外，还演示了参数包的完美转发。</target>
        </trans-unit>
        <trans-unit id="41d2d00ba30c148282801448fd5c841e57daf05e" translate="yes" xml:space="preserve">
          <source>This example demonstrates reading a GB18030-encoded file using the codecvt facet from a GB18030-aware locale.</source>
          <target state="translated">这个例子演示了使用codecvt面从一个GB18030识别的区域读取一个GB18030编码的文件。</target>
        </trans-unit>
        <trans-unit id="4d303a5fae16ce79fa6d0c697ce2d0fc19b5301e" translate="yes" xml:space="preserve">
          <source>This example demonstrates the Euler's identity ei&amp;pi;</source>
          <target state="translated">这个例子说明了欧拉的身份特征</target>
        </trans-unit>
        <trans-unit id="076b866beacb08cccde9a7cbeb026a03c41cdec2" translate="yes" xml:space="preserve">
          <source>This example demonstrates the difference between clock() time and real time.</source>
          <target state="translated">这个例子展示了clock()时间和实时之间的区别。</target>
        </trans-unit>
        <trans-unit id="ec322c19fb258d9310f125341429ba2dbaa4630e" translate="yes" xml:space="preserve">
          <source>This example displays information about the execution time of a function call:</source>
          <target state="translated">本例显示函数调用的执行时间信息。</target>
        </trans-unit>
        <trans-unit id="b6a1d0dea16b8362b800d36d34e475e44374f92b" translate="yes" xml:space="preserve">
          <source>This example measures the execution time of a function.</source>
          <target state="translated">本例测量函数的执行时间。</target>
        </trans-unit>
        <trans-unit id="f9f8065b3b5128d3a408cb9f21a45bf456306b8f" translate="yes" xml:space="preserve">
          <source>This example prints current time using the &quot;C&quot; locale with the time_put facet replaced by various time_put_byname facets.</source>
          <target state="translated">这个例子使用 &quot;C &quot;语言打印当前时间,并以不同的time_put_byname面代替time_put面。</target>
        </trans-unit>
        <trans-unit id="4b380662a79a86a43a8e6ddbc4fae89b7137cd02" translate="yes" xml:space="preserve">
          <source>This example shows a 10 seconds block.</source>
          <target state="translated">这个例子显示了一个10秒的块。</target>
        </trans-unit>
        <trans-unit id="68e2616f4fe4dbb587d170dace9a4de7c97af570" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;unlock&lt;/code&gt; can be used to protect shared data.</source>
          <target state="translated">此示例说明如何使用 &lt;code&gt;lock&lt;/code&gt; 和 &lt;code&gt;unlock&lt;/code&gt; 来保护共享数据。</target>
        </trans-unit>
        <trans-unit id="b265f51b6f5d54fac0a395f6360e177b329bb440" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;promise&amp;lt;int&amp;gt;&lt;/code&gt; can be used as signals between threads.</source>
          <target state="translated">此示例说明如何将 &lt;code&gt;promise&amp;lt;int&amp;gt;&lt;/code&gt; 用作线程之间的信号。</target>
        </trans-unit>
        <trans-unit id="7e9ee0c7c7b464f5720460296151cb05bd7054a5" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;promise&amp;lt;void&amp;gt;&lt;/code&gt; can be used as signals between threads.</source>
          <target state="translated">本示例说明如何将 &lt;code&gt;promise&amp;lt;void&amp;gt;&lt;/code&gt; 用作线程之间的信号。</target>
        </trans-unit>
        <trans-unit id="9cc1e77d4a4ec9dcaa9ce1202b289473c0fe3f32" translate="yes" xml:space="preserve">
          <source>This example shows how a &lt;code&gt;mutex&lt;/code&gt; can be used to protect a &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; shared between two threads.</source>
          <target state="translated">此示例显示了 &lt;code&gt;mutex&lt;/code&gt; 如何用于保护两个线程之间共享的 &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="648fa6a16a6dcfeed9894c57ffbd6224f1ffea42" translate="yes" xml:space="preserve">
          <source>This example shows how to define several custom duration types and convert between types:</source>
          <target state="translated">这个例子展示了如何定义几种自定义的持续时间类型并在类型之间进行转换。</target>
        </trans-unit>
        <trans-unit id="0af6770609a4caa5cf880a836ce6717cfed6d527" translate="yes" xml:space="preserve">
          <source>This example shows how to pass a lambda to a generic algorithm and how objects resulting from a lambda declaration can be stored in &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="translated">本示例说明如何将lambda传递给通用算法，以及如何将lambda声明产生的对象存储在 &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 对象中。</target>
        </trans-unit>
        <trans-unit id="ccfdcc1737a5e9e6732e2a5414a8ae4ca8c5cc92" translate="yes" xml:space="preserve">
          <source>This example shows how to use a namespace to create a class that already has been named in the &lt;code&gt;std&lt;/code&gt; namespace.</source>
          <target state="translated">本示例说明如何使用命名空间创建已在 &lt;code&gt;std&lt;/code&gt; 命名空间中命名的类。</target>
        </trans-unit>
        <trans-unit id="4812778eaab911430b4291ca314167dcaef2c221" translate="yes" xml:space="preserve">
          <source>This exception is thrown by &lt;code&gt;&lt;a href=&quot;../../utility/bitset/bitset&quot;&gt;std::bitset::bitset&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stof&lt;/a&gt;&lt;/code&gt; families of functions.</source>
          <target state="translated">此异常由 &lt;code&gt;&lt;a href=&quot;../../utility/bitset/bitset&quot;&gt;std::bitset::bitset&lt;/a&gt;&lt;/code&gt; 以及 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stof&lt;/a&gt;&lt;/code&gt; 函数族抛出。</target>
        </trans-unit>
        <trans-unit id="a6233e2c685f108dd3cbe5ebed91c5d014b2b2b2" translate="yes" xml:space="preserve">
          <source>This exception is thrown by &lt;code&gt;std::chrono::time_zone::to_sys&lt;/code&gt; and functions that call it (such as the constructors of &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; that takes a &lt;code&gt;std::chrono::local_time&lt;/code&gt;).</source>
          <target state="translated">此异常由 &lt;code&gt;std::chrono::time_zone::to_sys&lt;/code&gt; 和调用它的函数（例如，带有 &lt;code&gt;std::chrono::local_time&lt;/code&gt; &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; :: local_time的std :: chrono :: zoned_time的构造函数）引发。</target>
        </trans-unit>
        <trans-unit id="d06332298cae245fc7de591665ed289988d734a8" translate="yes" xml:space="preserve">
          <source>This exception is thrown by member functions of &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../container/vector/reserve&quot;&gt;std::vector::reserve&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此异常由 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../container/vector/reserve&quot;&gt;std::vector::reserve&lt;/a&gt;&lt;/code&gt; 的成员函数引发。</target>
        </trans-unit>
        <trans-unit id="61d73663b9152dc36fe73750ad1a87fd639e49c2" translate="yes" xml:space="preserve">
          <source>This feature is used in template metaprogramming.</source>
          <target state="translated">此功能在模板元编程中使用。</target>
        </trans-unit>
        <trans-unit id="ebe57327a03912c16a8791570ac9fd18d3a3f421" translate="yes" xml:space="preserve">
          <source>This form automatically provides &lt;a href=&quot;exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;, but prohibits resource reuse.</source>
          <target state="translated">该表格自动提供&lt;a href=&quot;exceptions&quot;&gt;强大的异常保证&lt;/a&gt;，但禁止资源重用。</target>
        </trans-unit>
        <trans-unit id="a5c081dc7229ad13536ca7204c599487bcfa19aa" translate="yes" xml:space="preserve">
          <source>This function (for double argument) behaves as if (except for the freedom to not raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;) implemented by the following code:</source>
          <target state="translated">此函数（用于双参数）的行为类似于（由不引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 的自由）由以下代码实现：</target>
        </trans-unit>
        <trans-unit id="6a68eec804ec3c10883600f6bcfaeb90b1f9c1d6" translate="yes" xml:space="preserve">
          <source>This function and the related types are deprecated as of C++11 in favor of the more general &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, both of which create callable adapter-compatible function objects from plain functions.</source>
          <target state="translated">从C ++ 11开始不推荐使用此函数和相关类型，而推荐使用更通用的 &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; ，这两个函数均从普通函数创建可调用的适配器兼容函数对象。</target>
        </trans-unit>
        <trans-unit id="8855f9b9dc1d262207716dd8128c053ea2ad8bb0" translate="yes" xml:space="preserve">
          <source>This function and the related types were deprecated in C++11 and removed in C++17 in favor of the more general &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, both of which create callable adapter-compatible function objects from member functions.</source>
          <target state="translated">在C ++ 11中不推荐使用此函数和相关类型，而在C ++ 17中则删除了该函数和相关类型，而采用了更为通用的 &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; ，这两个函数均从成员函数创建可调用的适配器兼容函数对象。</target>
        </trans-unit>
        <trans-unit id="9d11c6f40fc460580b4545f369d83a5f3011308f" translate="yes" xml:space="preserve">
          <source>This function attempts to allocate a temporary buffer equal in size to the sequence to be sorted. If the allocation fails, the less efficient algorithm is chosen.</source>
          <target state="translated">该函数试图分配一个临时缓冲区,其大小与要排序的序列相等。如果分配失败,则选择效率较低的算法。</target>
        </trans-unit>
        <trans-unit id="0dc2280353aa9f39b639bbe5806d955bd65f2c7d" translate="yes" xml:space="preserve">
          <source>This function attempts to allocate a temporary buffer. If the allocation fails, the less efficient algorithm is chosen.</source>
          <target state="translated">该函数试图分配一个临时缓冲区。如果分配失败,则选择效率较低的算法。</target>
        </trans-unit>
        <trans-unit id="56dabe59df1e13c9e7227a371ae542e03583d74a" translate="yes" xml:space="preserve">
          <source>This function behaves as if implemented as follows:</source>
          <target state="translated">该函数的运行方式如下。</target>
        </trans-unit>
        <trans-unit id="e024c278b12913b9314d8bc74236e17366fbdd60" translate="yes" xml:space="preserve">
          <source>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by &lt;code&gt;ptr&lt;/code&gt; is smaller than &lt;code&gt;count&lt;/code&gt;, but the match is found within the array, the behavior is well-defined.</source>
          <target state="translated">该函数的行为就像它顺序读取字符并在找到匹配字符后立即停止：如果 &lt;code&gt;ptr&lt;/code&gt; 指向的数组小于 &lt;code&gt;count&lt;/code&gt; ，但是在数组内找到匹配项，则行为是明确定义的。</target>
        </trans-unit>
        <trans-unit id="70a20794d71c34f9a147e7b2e7b15ccb7dd382d5" translate="yes" xml:space="preserve">
          <source>This function can be used when implementing &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt; and &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt;:</source>
          <target state="translated">在实现&lt;a href=&quot;../language/move_operator&quot;&gt;移动分配运算符&lt;/a&gt;和&lt;a href=&quot;../language/move_constructor&quot;&gt;移动构造&lt;/a&gt;函数时可以使用此函数：</target>
        </trans-unit>
        <trans-unit id="074233c87f0a8381f8c33e772677b1882b2b89cc" translate="yes" xml:space="preserve">
          <source>This function can make a write position available if the stringbuf is open for output (&lt;code&gt;mode &amp;amp; ios_base::out) != 0&lt;/code&gt;): in this case, it reallocates (or initially allocates) the buffer big enough to hold the entire current buffer plus at least one more character. If the stringbuf is also open for input (&lt;code&gt;(mode &amp;amp; ios_base::in) != 0&lt;/code&gt;), then &lt;code&gt;overflow&lt;/code&gt; also increases the size of the get area by moving &lt;code&gt;egptr()&lt;/code&gt; to point just past the new write position.</source>
          <target state="translated">如果stringbuf已打开以供输出（ &lt;code&gt;mode &amp;amp; ios_base::out) != 0&lt;/code&gt; ，则此函数可以使写位置可用：在这种情况下，它将重新分配（或初始分配）足够大的缓冲区以容纳整个当前缓冲区以及至少再增加一个字符。如果stringbuf也为输入打开（ &lt;code&gt;(mode &amp;amp; ios_base::in) != 0&lt;/code&gt; ），则 &lt;code&gt;overflow&lt;/code&gt; 还会通过移动 &lt;code&gt;egptr()&lt;/code&gt; 使其指向刚经过新的写入位置来增加get区域的大小。</target>
        </trans-unit>
        <trans-unit id="80dad3848a318d7ecb43c15430bc70acc0b353eb" translate="yes" xml:space="preserve">
          <source>This function detects the sign bit of zeroes, infinities, and NaNs. Along with &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;std::copysign&lt;/a&gt;&lt;/code&gt;, std::signbit is one of the only two portable ways to examine the sign of a NaN.</source>
          <target state="translated">此功能检测零，无穷大和NaN的符号位。与 &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;std::copysign&lt;/a&gt;&lt;/code&gt; ，std :: signbit是检查NaN符号的仅有的两种便携式方法之一。</target>
        </trans-unit>
        <trans-unit id="8e1aa01daec415e7f5af69e6b0d04848557bd2e6" translate="yes" xml:space="preserve">
          <source>This function does not call constructors or initialize memory in any way. There are no ready-to-use smart pointers that could guarantee that the matching deallocation function is called. The preferred method of memory allocation in C++ is using RAII-ready functions &lt;code&gt;&lt;a href=&quot;../unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt;, container constructors, etc, and, in low-level library code, &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt;.</source>
          <target state="translated">此函数不会以任何方式调用构造函数或初始化内存。没有可以保证调用匹配的解除分配功能的即用型智能指针。在C ++中，内存分配的首选方法是使用支持RAII的函数 &lt;code&gt;&lt;a href=&quot;../unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; ，容器构造函数等，以及在低级库代码中使用&lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4587b2ca7a4f0c1305b825fddf8669b0a594052" translate="yes" xml:space="preserve">
          <source>This function does not commit any changes to the filesystem.</source>
          <target state="translated">该函数不会对文件系统进行任何修改。</target>
        </trans-unit>
        <trans-unit id="9a9157bc8e19134921e346295ad23635f0edc637" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; is true.</source>
          <target state="translated">除非 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; 为true，否则此函数不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="34f86c4c962be5f53b674478758ba7b4aac25784" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt; is true for all i from 0 to &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt; 对从0到 &lt;code&gt;sizeof...(Types)&lt;/code&gt; 所有i为true，否则此函数不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="430ec4ee0ab3ae68ef199618d00c231487c566a4" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;first_type&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;first_type&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ,否则此函数不参与重载解析。</target>
        </trans-unit>
        <trans-unit id="93f49364b5d0b6ce3643e79ff41e9aa02af91573" translate="yes" xml:space="preserve">
          <source>This function exploits the signature compatibility between hinted insert for associative containers (such as &lt;code&gt;&lt;a href=&quot;../../container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt;) and positional insert for sequential containers (such as &lt;code&gt;&lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">此函数利用了关联容器的提示插入（例如 &lt;code&gt;&lt;a href=&quot;../../container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt; ）和顺序容器的位置插入（例如 &lt;code&gt;&lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; ）之间的签名兼容性。</target>
        </trans-unit>
        <trans-unit id="77f1becd52cdb4bb82d9005b4cfb7fd4243343b4" translate="yes" xml:space="preserve">
          <source>This function has no effect. Memory used by a &lt;code&gt;monotonic_buffer_resource&lt;/code&gt;, as its name indicates, increases monotonically until the resource is destroyed.</source>
          <target state="translated">此功能无效。顾名思义，monotonic_buffer_resource 使用的内存会 &lt;code&gt;monotonic_buffer_resource&lt;/code&gt; 增加，直到资源被销毁为止。</target>
        </trans-unit>
        <trans-unit id="003c7fca2e592f4d453e6d2795ce41a60cc8ae9a" translate="yes" xml:space="preserve">
          <source>This function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex is not currenly exclusively locked by any other thread.</source>
          <target state="translated">即使互斥锁没有被任何其他线程专门锁定，此函数也可能因错误而失败并返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4aff8f3ce667147891a0800fe1ffe344229b2457" translate="yes" xml:space="preserve">
          <source>This function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex is not currently locked by any other thread.</source>
          <target state="translated">即使互斥对象当前未被任何其他线程锁定，也可以使此函数 &lt;code&gt;false&lt;/code&gt; 地失败并返回false。</target>
        </trans-unit>
        <trans-unit id="581170c63a0c34f4d8ef486e52f25f659195a185" translate="yes" xml:space="preserve">
          <source>This function is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the function call operator (or specialization, for generic lambdas) is an immediate function.</source>
          <target state="translated">此功能是一个&lt;a href=&quot;consteval&quot;&gt;直接的函数&lt;/a&gt;，如果函数调用运算符（或专业，通用lambda表达式）是立即功能。</target>
        </trans-unit>
        <trans-unit id="7d1b9d31c1cd20909db730ecb0adb4933d6936b7" translate="yes" xml:space="preserve">
          <source>This function is called (through &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;) by any allocator-aware object, such as &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::pmr::vector&lt;/a&gt;&lt;/code&gt; (or another &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; that was given a &lt;code&gt;std::std::polymorphic_allocator&lt;/code&gt; as the allocator to use).</source>
          <target state="translated">任何知道分配器的对象都将调用此函数（通过 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; ），例如 &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::pmr::vector&lt;/a&gt;&lt;/code&gt; （或另一个被赋予 &lt;code&gt;std::std::polymorphic_allocator&lt;/code&gt; 作为分配器的 &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f22521ea8de0d211401620c2c0ceeebcc98c2413" translate="yes" xml:space="preserve">
          <source>This function is called (through &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;) by any allocator-aware object, such as &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, that was given a &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; as the allocator to use. Since &lt;code&gt;inner_allocator&lt;/code&gt; is itself an instance of &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt;, this function will also be called when the allocator-aware objects constructed through this function start constructing their own members.</source>
          <target state="translated">该函数由任何知道分配器的对象（例如 &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ）调用（通过 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; ），该对象被赋予 &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; 作为要使用的分配器。由于 &lt;code&gt;inner_allocator&lt;/code&gt; 本身是 &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; 的实例，因此通过此函数构造的可识别分配器的对象开始构造自己的成员时，也会调用此函数。</target>
        </trans-unit>
        <trans-unit id="1604a10d0bd65894de0fdd375bd44a25850704e0" translate="yes" xml:space="preserve">
          <source>This function is called automatically when swapping &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::fstream&lt;/a&gt;&lt;/code&gt; objects, it is rarely necessary to call it directly.</source>
          <target state="translated">交换 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::fstream&lt;/a&gt;&lt;/code&gt; 对象时，将自动调用此函数，很少需要直接调用它。</target>
        </trans-unit>
        <trans-unit id="0e78d40edd5ecace775e3b468b3346c7031f470e" translate="yes" xml:space="preserve">
          <source>This function is called automatically when swapping &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; objects, it is rarely necessary to call it directly.</source>
          <target state="translated">交换 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; 对象时，将自动调用此函数，很少需要直接调用它。</target>
        </trans-unit>
        <trans-unit id="c4734f8a6748c0cb4415534ce967c7c8880cdda2" translate="yes" xml:space="preserve">
          <source>This function is called by &lt;code&gt;std::basic_filebuf::close()&lt;/code&gt; and in other situations when finalizing a state-dependent multibyte character sequence.</source>
          <target state="translated">该函数由 &lt;code&gt;std::basic_filebuf::close()&lt;/code&gt; 调用，并且在其他情况下，最终确定与状态有关的多字节字符序列时，将调用此函数。</target>
        </trans-unit>
        <trans-unit id="32de367add154511d8a09e86e9af636ea74ff7b5" translate="yes" xml:space="preserve">
          <source>This function is called by the constructor of &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; when given an &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">给定 &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; 参数时，此函数由 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 的构造函数调用。</target>
        </trans-unit>
        <trans-unit id="cbcb817100be7c6ebcd72951487118723a0a15af" translate="yes" xml:space="preserve">
          <source>This function is called by the copy constructors of all standard library containers. It allows the allocator used by the constructor's argument to become aware that the container is being copied and modify state if necessary.</source>
          <target state="translated">这个函数被所有标准库容器的复制构造函数所调用,它允许构造函数的参数所使用的分配器意识到容器正在被复制,并在必要时修改状态。它允许构造函数的参数所使用的分配器意识到容器正在被复制,并在必要时修改状态。</target>
        </trans-unit>
        <trans-unit id="bfb34e88abba67d43669caa31797e35aed808cba" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_fstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">当流对象超出范围时,这个函数被basic_fstream的析构器调用,通常不直接调用。</target>
        </trans-unit>
        <trans-unit id="9586654e6d5f24f563ef041033abacd3e6aaef3e" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_ifstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">当流对象超出范围时,这个函数被basic_ifstream的析构器调用,通常不直接调用。</target>
        </trans-unit>
        <trans-unit id="0b0b9fa6d17fdf350f225d78773a873a4f6a210f" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_ofstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">当流对象超出范围时,这个函数被basic_ofstream的析构器调用,通常不直接调用。</target>
        </trans-unit>
        <trans-unit id="ae182d564b01a9cc3f1cbb5dd2383b385c515a22" translate="yes" xml:space="preserve">
          <source>This function is constexpr if the function call operator (or specialization, for generic lambdas) is constexpr.</source>
          <target state="translated">如果函数调用操作符(或特殊化,对于通用lambdas)是constexpr,那么这个函数就是constexpr。</target>
        </trans-unit>
        <trans-unit id="6cb839c1449d28abb8b1ad7d5627544f12403184" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiple times to obtain successive tokens from the same string.</source>
          <target state="translated">这个函数被设计成可以多次调用,从同一个字符串中获得连续的标记。</target>
        </trans-unit>
        <trans-unit id="db0f3821e4deee5da8554e13cdcbbb92c017d0a9" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiples times to obtain successive tokens from the same string.</source>
          <target state="translated">这个函数被设计成可以多次调用,从同一个字符串中获得连续的标记。</target>
        </trans-unit>
        <trans-unit id="776743886aba3fc5ea926a51a096528c0531353d" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; cannot be used as the first argument of &lt;code&gt;strtok&lt;/code&gt;.</source>
          <target state="translated">此函数具有破坏性：它将 &lt;code&gt;'\0'&lt;/code&gt; 字符写入字符串 &lt;code&gt;str&lt;/code&gt; 的元素中。特别是，&lt;a href=&quot;../../language/string_literal&quot;&gt;字符串文字&lt;/a&gt;不能用作 &lt;code&gt;strtok&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="aaae01573deddc58b640a93ca69e57c3af20acb3" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;L'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a wide string literal cannot be used as the first argument of &lt;code&gt;std::wcstok&lt;/code&gt;.</source>
          <target state="translated">此函数具有破坏性：它将 &lt;code&gt;L'\0'&lt;/code&gt; 字符写入字符串 &lt;code&gt;str&lt;/code&gt; 的元素中。特别是，不能将宽字符串文字用作 &lt;code&gt;std::wcstok&lt;/code&gt; 的第一个参数。</target>
        </trans-unit>
        <trans-unit id="ae117e98847c242edb80799fb082fc22f8c51c75" translate="yes" xml:space="preserve">
          <source>This function is different from a typical &lt;code&gt;overflow()&lt;/code&gt; which moves the contents of the buffer to the associated character sequence because for a &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;, the buffer and the associated sequence are one and the same.</source>
          <target state="translated">此函数不同于典型的将缓冲区内容移至关联字符序列的 &lt;code&gt;overflow()&lt;/code&gt; ，因为对于 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; ，缓冲区和关联序列相同。</target>
        </trans-unit>
        <trans-unit id="bf7eaed7da997c4b5d39d94135b3ff5c00bc6632" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; for some hidden object &lt;code&gt;internal&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;, except that the expression &lt;code&gt;ps&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">对于某些 &lt;code&gt;internal&lt;/code&gt; 类型为 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 隐藏对象，此函数等效于调用 &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; ，但表达式 &lt;code&gt;ps&lt;/code&gt; 仅被计算一次。</target>
        </trans-unit>
        <trans-unit id="9101f15eeb95d6b33b0fdb8d4808ce7c08cccbd4" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt;, except that conversion state of &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; is unaffected.</source>
          <target state="translated">此函数等效于调用 &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt; ，但 &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; 转换状态不受影响。</target>
        </trans-unit>
        <trans-unit id="1963bc98196193cc320458fc455ddd3e328dde8a" translate="yes" xml:space="preserve">
          <source>This function is infrequently used directly by application code. Instead, one of the non-member comparison operators are used.</source>
          <target state="translated">这个函数不经常被应用代码直接使用。相反,会使用其中一个非成员比较运算符。</target>
        </trans-unit>
        <trans-unit id="403f2759a06c2803350631fa5d221bae46fd2b6b" translate="yes" xml:space="preserve">
          <source>This function is inherently racy if the managed object is shared among threads. In particular, a false result may become stale before it can be used. A true result is reliable.</source>
          <target state="translated">如果被管理对象在线程间共享,这个函数本身就很狂暴。特别是,一个错误的结果可能在被使用之前就已经过时了。真实的结果是可靠的。</target>
        </trans-unit>
        <trans-unit id="452207e6d60059763d001256a30bc736ba869131" translate="yes" xml:space="preserve">
          <source>This function is intended to replace &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;. Unlike std::bind, it does not support arbitrary argument rearrangement and has no special treatment for nested bind-expressions. On the other hand, it pays attention to the value category of the call wrapper object and propagates exception specification of the underlying call operator.</source>
          <target state="translated">此函数旨在替换 &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 。与std :: bind不同，它不支持任意参数重排，并且对嵌套的bind-expressions没有特殊的处理。另一方面，它注意调用包装对象的值类别，并传播基础调用操作程序的异常规范。</target>
        </trans-unit>
        <trans-unit id="bc919d55a6f87a71a7f9eff45b45a6e0e62a8ce5" translate="yes" xml:space="preserve">
          <source>This function is not expected to be called directly: it is called through &lt;a href=&quot;../basic_osyncstream/get_wrapped&quot;&gt;&lt;code&gt;std::basic_osyncstream::get_wrapped&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">不应直接调用此函数：通过&lt;a href=&quot;../basic_osyncstream/get_wrapped&quot;&gt; &lt;code&gt;std::basic_osyncstream::get_wrapped&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="57e7dd85f600e213ae40f7d97225e1e1697e505f" translate="yes" xml:space="preserve">
          <source>This function is not fully implemented in some standard libraries. For example, &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/src/random.cpp#L174&quot;&gt;LLVM libc++&lt;/a&gt; always returns zero even though the device is non-deterministic. In comparison, Microsoft Visual C++ implementation always returns 32, and &lt;a href=&quot;https://github.com/boostorg/random/blob/master/src/random_device.cpp#L242&quot;&gt;boost.random&lt;/a&gt; returns 10.</source>
          <target state="translated">在某些标准库中，此功能未完全实现。例如，即使设备是不确定的，&lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/src/random.cpp#L174&quot;&gt;LLVM libc ++&lt;/a&gt;始终返回零。相比之下，Microsoft Visual C ++实现始终返回32，而&lt;a href=&quot;https://github.com/boostorg/random/blob/master/src/random_device.cpp#L242&quot;&gt;boost.random&lt;/a&gt;返回10。</target>
        </trans-unit>
        <trans-unit id="bf2280640237c525c2d62eefb26aff9f2856c11f" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it copies: nulls as well as invalid characters are copied too.</source>
          <target state="translated">此函数对语言环境不敏感，并且不关注它复制的 &lt;code&gt;wchar_t&lt;/code&gt; 对象的值：空值以及无效字符也会被复制。</target>
        </trans-unit>
        <trans-unit id="67fe14d7992c12e6d5c157b600ec2cde52ad0774" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it examines: nulls as well as invalid wide characters are compared too.</source>
          <target state="translated">此函数对语言环境不敏感，并且不关注它检查的 &lt;code&gt;wchar_t&lt;/code&gt; 对象的值：还比较了null和无效的宽字符。</target>
        </trans-unit>
        <trans-unit id="9c3cb718222d314cabd06a082b4892a3a4ab3e26" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it writes: nulls as well as invalid wide characters are written too.</source>
          <target state="translated">此函数对语言环境不敏感，并且不关注它编写的 &lt;code&gt;wchar_t&lt;/code&gt; 对象的值：还会写入null以及无效的宽字符。</target>
        </trans-unit>
        <trans-unit id="cc19c16caa38c36df06e04a2db5301e73e2f5836" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, and the order may not be meaningful when characters from different Unicode blocks are used together or when the order of code units does not match collation order.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; 不同，此函数对语言环境不敏感，并且当来自不同Unicode块的字符一起使用或代码单元的顺序与排序规则不匹配时，该顺序可能没有意义。</target>
        </trans-unit>
        <trans-unit id="743f719e1c7876947aef41d3da4d327b2152c1ab" translate="yes" xml:space="preserve">
          <source>This function is not overloaded for the types &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, unlike the formatted &lt;a href=&quot;operator_ltlt2&quot;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;</source>
          <target state="translated">与带 &lt;code&gt;unsigned char&lt;/code&gt; &lt;a href=&quot;operator_ltlt2&quot;&gt;运算符&amp;lt;&amp;lt;&lt;/a&gt;不同，此函数对于带 &lt;code&gt;signed char&lt;/code&gt; 或无符号字符类型不会重载。</target>
        </trans-unit>
        <trans-unit id="d3b72d4451a67b0f8e9ff04bab97998d9cac5a6e" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.</source>
          <target state="translated">这个函数不需要对零号敏感,尽管一些实现额外地强制要求如果一个参数是+0,另一个是-0,那么返回+0。</target>
        </trans-unit>
        <trans-unit id="1e7653f07d484a2f1a2819f2a881f15b3743184c" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.</source>
          <target state="translated">这个函数不需要对零号敏感,尽管一些实现额外地强制要求如果一个参数是+0,另一个是-0,那么返回-0。</target>
        </trans-unit>
        <trans-unit id="63ff1f7a80d3a2498f6c2c57080a31e1fe86d34e" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="translated">不需要此函数是线程安全的。对getenv的另一个调用以及对POSIX函数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv（）&lt;/a&gt;，&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv（）&lt;/a&gt;和&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv（）的&lt;/a&gt;调用可能会使先前调用返回的指针无效，或修改从先前调用获得的字符串。</target>
        </trans-unit>
        <trans-unit id="f78d178d130886a2b5afb503f15940c3ad73bbf9" translate="yes" xml:space="preserve">
          <source>This function is not subject to any errors specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数不受 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 中指定的任何错误的影响。</target>
        </trans-unit>
        <trans-unit id="a2abffafc50a2795cbfb3627bf5fb2f042437061" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the error conditions specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数不受 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 中指定的任何错误条件的约束。</target>
        </trans-unit>
        <trans-unit id="e653a40d5b5f3d4ecc32e287a36ac0f0a3489976" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the errors specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数不受 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 中指定的任何错误的影响。</target>
        </trans-unit>
        <trans-unit id="da22a8cee5382549c532104db50c4ef68f7574e4" translate="yes" xml:space="preserve">
          <source>This function is not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">该函数对于普通的&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;非限定&lt;/a&gt;或&lt;a href=&quot;../../language/qualified_lookup&quot;&gt;限定查找&lt;/a&gt;不可见，并且仅当 &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; 是参数的关联类时，才可以通过&lt;a href=&quot;../../language/adl&quot;&gt;依赖&lt;/a&gt;于参数的查找来找到。这可以防止在 &lt;code&gt;using namespace std::filesystem;&lt;/code&gt; 的情况下进行不必要的转换。</target>
        </trans-unit>
        <trans-unit id="356a2955e71eb2ff664ad638e29c0c881711ba2c" translate="yes" xml:space="preserve">
          <source>This function is optional, it may return &lt;code&gt;no_order&lt;/code&gt; in every case.</source>
          <target state="translated">该函数是可选的，在每种情况下都可能返回 &lt;code&gt;no_order&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ffa5bc6979d4d788a32f52d1a8c3d6238bb88fba" translate="yes" xml:space="preserve">
          <source>This function is optional. If not implemented, this function returns &lt;code&gt;​0​&lt;/code&gt; (since the base class version &lt;code&gt;std::basic_streambuf::showmanyc&lt;/code&gt; gets called).</source>
          <target state="translated">此功能是可选的。如果不执行，这个函数返回 &lt;code&gt;​0​&lt;/code&gt; （因为基类版本 &lt;code&gt;std::basic_streambuf::showmanyc&lt;/code&gt; 被调用）。</target>
        </trans-unit>
        <trans-unit id="94f083987e438e8f45398655d60ea441662342f7" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::basic_filebuf&lt;/code&gt;.</source>
          <target state="translated">该函数是受保护的虚拟函数，只能通过 &lt;code&gt;pubsetbuf()&lt;/code&gt; 或从 &lt;code&gt;std::basic_filebuf&lt;/code&gt; 派生的用户定义类的成员函数中调用。</target>
        </trans-unit>
        <trans-unit id="e90def3890bd5c122a703d2eae4d728a21e862ac" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::basic_stringbuf&lt;/code&gt;.</source>
          <target state="translated">该函数是受保护的虚拟函数，只能通过 &lt;code&gt;pubsetbuf()&lt;/code&gt; 或从 &lt;code&gt;std::basic_stringbuf&lt;/code&gt; 派生的用户定义类的成员函数中调用。</target>
        </trans-unit>
        <trans-unit id="b7f492276aa00c278aeca31b34dc935f13689be2" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::strstreambuf&lt;/code&gt;.</source>
          <target state="translated">该函数是受保护的虚拟函数，只能通过 &lt;code&gt;pubsetbuf()&lt;/code&gt; 或从 &lt;code&gt;std::strstreambuf&lt;/code&gt; 派生的用户定义类的成员函数中调用。</target>
        </trans-unit>
        <trans-unit id="503edf2bb2eb0295ac5dcd3fad68fe3498303d2a" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with C. If the compatibility is not required, &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; may be initialized through their non-default constructors.</source>
          <target state="translated">提供此函数是为了与C兼容。如果不需要兼容性，则可以通过其非默认构造函数初始化 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0233eac438664696f470dcb4a6305de8bdfaa672" translate="yes" xml:space="preserve">
          <source>This function is thread-safe (calling it from multiple threads does not introduce a data race) as long as no other function modifies the host environment. In particular, the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; would introduce a data race if called without synchronization.</source>
          <target state="translated">只要没有其他函数修改主机环境，此函数就是线程安全的（从多个线程调用它不会引入数据争用）。特别是，如果调用POSIX函数&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv（）&lt;/a&gt;，&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv（）&lt;/a&gt;和&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv（），则它们&lt;/a&gt;会在没有同步的情况下引入数据争用。</target>
        </trans-unit>
        <trans-unit id="a752e45b1c1e76a0bf7ba715c5f6c403c0eed278" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::pmr::set_default_resource&lt;/code&gt;</source>
          <target state="translated">此函数是线程安全的。每次调用 &lt;code&gt;std::pmr::set_default_resource&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a166d5bd1c79123ccec86898cc471f7c6a1e389e" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_new_handler&lt;/code&gt;</source>
          <target state="translated">此函数是线程安全的。每次调用 &lt;code&gt;std::set_new_handler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f8d53be444102a8285b0653a05c85e675ae55c4" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_terminate&lt;/code&gt;</source>
          <target state="translated">此函数是线程安全的。每次调用 &lt;code&gt;std::set_terminate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c7aea13c02b97924864411502ae4053e055e059" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_unexpected&lt;/code&gt;</source>
          <target state="translated">此函数是线程安全的。每次调用 &lt;code&gt;std::set_unexpected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d270b8becf9b193ce734289e056a679cfdfc26" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Previous call to &lt;code&gt;&lt;a href=&quot;set_default_resource&quot;&gt;std::pmr::set_default_resource&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">此函数是线程安全的。先前对 &lt;code&gt;&lt;a href=&quot;set_default_resource&quot;&gt;std::pmr::set_default_resource&lt;/a&gt;&lt;/code&gt; 调用</target>
        </trans-unit>
        <trans-unit id="b1ab230cef40ffc4e792b092936b1dc96c9a5607" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Previous call to &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">此函数是线程安全的。先前对 &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; 调用</target>
        </trans-unit>
        <trans-unit id="419521c15e45c9bfd4ee0de0dfa28aaf76875995" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Prior call to &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">此函数是线程安全的。事先调用 &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="991dd801c88141cd8662fd187f9759911775d74d" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Prior call to &lt;code&gt;std::set_unexpected&lt;/code&gt;</source>
          <target state="translated">此函数是线程安全的。事先调用 &lt;code&gt;std::set_unexpected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2b7ba4b79851f8176eac8ec16e5a1575927b2d7" translate="yes" xml:space="preserve">
          <source>This function is thread-safe; concurrent access by multiple threads does not result in a data race.(since C++14).</source>
          <target state="translated">这个函数是线程安全的,多个线程的并发访问不会导致数据竞赛(自C++14)。</target>
        </trans-unit>
        <trans-unit id="6c9ad1a43ed57cf75b0c052d412e9c8c3e821c79" translate="yes" xml:space="preserve">
          <source>This function is typically accessed through &lt;code&gt;std::basic_stringstream::str()&lt;/code&gt;.</source>
          <target state="translated">通常通过 &lt;code&gt;std::basic_stringstream::str()&lt;/code&gt; 访问此函数。</target>
        </trans-unit>
        <trans-unit id="8638be2f7c43a80edc7dee020c03393b731e9858" translate="yes" xml:space="preserve">
          <source>This function is typically called by &lt;code&gt;&lt;a href=&quot;../basic_fstream/is_open&quot;&gt;std::basic_fstream::is_open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数通常由 &lt;code&gt;&lt;a href=&quot;../basic_fstream/is_open&quot;&gt;std::basic_fstream::is_open()&lt;/a&gt;&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="db17dd608d932664bed4bd45648d18848b7cdb88" translate="yes" xml:space="preserve">
          <source>This function is typically called through the &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">通常通过 &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; 接口调用此函数。</target>
        </trans-unit>
        <trans-unit id="6b70e23981de2eddfb5cf1b279f2272ffbaab4c5" translate="yes" xml:space="preserve">
          <source>This function is used by the standard library containers when inserting, copying, or moving elements.</source>
          <target state="translated">当插入、复制或移动元素时,该函数被标准库容器使用。</target>
        </trans-unit>
        <trans-unit id="1c6ccf8ad1ccab32debfac40525ef074436c2ec6" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same string or set of strings, because it is more efficient to use &lt;code&gt;std::strxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当使用同一字符串或一组字符串进行多个与语言环境相关的比较时，使用此函数，因为使用 &lt;code&gt;std::strxfrm&lt;/code&gt; 仅转换一次所有字符串，然后将转换后的字符串与 &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; 比较会更有效。</target>
        </trans-unit>
        <trans-unit id="ca9d1d936d9fcef21052e9b31a8d09c354e45148" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same wide string or set of wide strings, because it is more efficient to use &lt;code&gt;std::wcsxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed wide strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当使用同 &lt;code&gt;std::wcsxfrm&lt;/code&gt; 宽字符串或一组宽字符串进行多个与语言环境相关的比较时，使用此函数，因为使用std :: wcsxfrm一次转换所有字符串，然后将转换后的宽字符串与 &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; 进行比较会更有效。:: wcscmp。</target>
        </trans-unit>
        <trans-unit id="5926d0f12bf7b7909e57150c062279d2ee706942" translate="yes" xml:space="preserve">
          <source>This function is useful in generic programming, since it uses &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; as fallbacks when &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; is not available.</source>
          <target state="translated">该函数在通用编程中很有用，因为当 &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; 不可用时，它使用 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;==&lt;/code&gt; 作为后备。</target>
        </trans-unit>
        <trans-unit id="be58b3707f3fcdf36615b4d19faec6a6dc05f29c" translate="yes" xml:space="preserve">
          <source>This function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(&amp;pi;x) for a very large &lt;code&gt;x&lt;/code&gt;, calling &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; directly may result in a large error, but if the function argument is first reduced with &lt;code&gt;std::remquo&lt;/code&gt;, the low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.</source>
          <target state="translated">当执行周期函数时，周期可以精确地表示为浮点值时，此函数很有用：对于非常大的 &lt;code&gt;x&lt;/code&gt; 计算sin（&amp;pi;x）时，直接调用 &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; 可能会导致较大的错误，但是如果函数参数首先使用 &lt;code&gt;std::remquo&lt;/code&gt; 将其降低，商的低位可用于确定周期内结果的正负号和八进制，而余数可用于高精度计算值。</target>
        </trans-unit>
        <trans-unit id="9314ee2e726c67b60305538d50add991082d26bc" translate="yes" xml:space="preserve">
          <source>This function is usually case-insensitive.</source>
          <target state="translated">该函数通常不区分大小写。</target>
        </trans-unit>
        <trans-unit id="6c9ee1f3188431817a670ceef41258274cd55d11" translate="yes" xml:space="preserve">
          <source>This function may be used as an alternative to &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt;. The trade-offs are:</source>
          <target state="translated">此函数可以用作 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt; 的替代方法。权衡是：</target>
        </trans-unit>
        <trans-unit id="0255ee7edd077c96e23883d7db760fc3da2e3d71" translate="yes" xml:space="preserve">
          <source>This function may be used e.g. in the implementation of &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/underflow&quot;&gt;std::basic_filebuf::underflow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/overflow&quot;&gt;std::basic_filebuf::overflow&lt;/a&gt;&lt;/code&gt; to use bulk character copy instead of calling &lt;code&gt;&lt;a href=&quot;in&quot;&gt;std::codecvt::in&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; if it is known that the locale imbued in the &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; does not perform any conversions.</source>
          <target state="translated">例如，在实现 &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/underflow&quot;&gt;std::basic_filebuf::underflow&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/overflow&quot;&gt;std::basic_filebuf::overflow&lt;/a&gt;&lt;/code&gt; 的实现中，可以使用此功能来使用批量字符复制，而不是调用 &lt;code&gt;&lt;a href=&quot;in&quot;&gt;std::codecvt::in&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; 如果有的话）已知 &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 中插入的语言环境不会执行任何转换。</target>
        </trans-unit>
        <trans-unit id="332c6aa9bcea925b9a927e3ad7173bbcf6a2f86d" translate="yes" xml:space="preserve">
          <source>This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; after clearing the unwanted exceptions.</source>
          <target state="translated">该函数可以在子例程的开头使用，该子例程必须隐藏它可能从调用方引发的浮点异常。如果仅必须抑制某些异常，而必须报告其他异常，则在清除不需要的异常之后，通常以调用 &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; 结束非停止模式。</target>
        </trans-unit>
        <trans-unit id="653f6e88a7890bf08216060f0a91617ba728c746" translate="yes" xml:space="preserve">
          <source>This function may be used to end the non-stop mode established by an earlier call to &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数可用于结束由先前对 &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt; 调用建立的不停止模式。</target>
        </trans-unit>
        <trans-unit id="23b1aaf9597250b14a85a5f063ebcaa36211aeee" translate="yes" xml:space="preserve">
          <source>This function may be used to output object representations, i.e. binary output.</source>
          <target state="translated">该函数可用于输出对象表示,即二进制输出。</target>
        </trans-unit>
        <trans-unit id="856950bcb4c9f3dcc5895c41de9e090f268e6ccd" translate="yes" xml:space="preserve">
          <source>This function may block for longer than &lt;code&gt;sleep_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">由于调度或资源争用延迟，此功能可能会阻塞比 &lt;code&gt;sleep_duration&lt;/code&gt; 更长的时间。</target>
        </trans-unit>
        <trans-unit id="6c2d0b323f5f9df1da55d663b9642600ad42960c" translate="yes" xml:space="preserve">
          <source>This function may block for longer than &lt;code&gt;timeout_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">由于调度或资源争用延迟，此功能可能阻塞的时间超过 &lt;code&gt;timeout_duration&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88aa144342c719b2d0cf02f7ae6cd001dc8b8b1c" translate="yes" xml:space="preserve">
          <source>This function may implement selection sampling or reservoir sampling.</source>
          <target state="translated">该功能可以实现选择采样或水库采样。</target>
        </trans-unit>
        <trans-unit id="f6b6f1463d12ffb2bc42127132a8ac643fc238fe" translate="yes" xml:space="preserve">
          <source>This function may not be thread-safe.</source>
          <target state="translated">这个功能可能不安全。</target>
        </trans-unit>
        <trans-unit id="a4a88b9d5b7b6f8931799bf82d9c71dd06343e4a" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;std::setvbuf&lt;/code&gt;).</source>
          <target state="translated">仅在将 &lt;code&gt;stream&lt;/code&gt; 与打开的文件相关联之后，但在任何其他操作之前（对 &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;std::setvbuf&lt;/code&gt; 调用失败除外），才可以使用此功能。</target>
        </trans-unit>
        <trans-unit id="19731f6b76843a49446fd5784cfb942c7dfca160" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;std::setbuf&lt;/code&gt;/&lt;code&gt;std::setvbuf&lt;/code&gt;).</source>
          <target state="translated">仅在将 &lt;code&gt;stream&lt;/code&gt; 与打开的文件相关联之后，但在任何其他操作之前（对 &lt;code&gt;std::setbuf&lt;/code&gt; / &lt;code&gt;std::setvbuf&lt;/code&gt; 调用失败除外），才可以使用此功能。</target>
        </trans-unit>
        <trans-unit id="717983186dc4c6865ae3eed7bfe5f5461be1682a" translate="yes" xml:space="preserve">
          <source>This function moves the &lt;code&gt;src&lt;/code&gt; pointer to the end of the converted multibyte string. This doesn't happen if &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此函数将 &lt;code&gt;src&lt;/code&gt; 指针移到转换后的多字节字符串的末尾。如果 &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 则不会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="53568c58dccc50911b4df0d8fe32be0fd89e385d" translate="yes" xml:space="preserve">
          <source>This function never modifies the file, only the get area of the in-memory buffer.</source>
          <target state="translated">这个函数从不修改文件,只修改内存缓冲区的获取区域。</target>
        </trans-unit>
        <trans-unit id="a3149df38d014eb7ad815af8ec580ac7ae565936" translate="yes" xml:space="preserve">
          <source>This function object provides owner-based (as opposed to value-based) mixed-type ordering of both &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. The order is such that two smart pointers compare equivalent only if they are both empty or if they share ownership, even if the values of the raw pointers obtained by &lt;code&gt;get()&lt;/code&gt; are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="translated">此函数对象提供 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 的基于所有者（而不是基于值）的混合类型排序。这样的顺序使得两个智能指针仅在它们均为空或共享所有权时才比较等效项，即使通过 &lt;code&gt;get()&lt;/code&gt; 获得的原始指针的值不同（例如，因为它们指向同一对象内的不同子对象） 。</target>
        </trans-unit>
        <trans-unit id="501340bd50fbe27100db1419cc8b73a966d53dac" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as reported by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt;, which returned the last byte of a file, &lt;code&gt;std::feof&lt;/code&gt; returns zero. The next &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; fails and changes the stream state to</source>
          <target state="translated">此功能仅报告最新I / O操作报告的流状态，不检查关联的数据源。例如，如果最新的I / O是 &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; ，它返回了文件的最后一个字节，则 &lt;code&gt;std::feof&lt;/code&gt; 返回零。下一个 &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; 失败，并将流状态更改为</target>
        </trans-unit>
        <trans-unit id="7ad9af23b2df5c7bd59daf117807cb419335155c" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as set by the most recent I/O operation; it does not examine the associated data source. For example, if the most recent I/O was a &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; which returned the last byte of a file, &lt;code&gt;eof()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The next &lt;code&gt;get()&lt;/code&gt; fails to read anything and sets the &lt;code&gt;eofbit&lt;/code&gt;. Only then does &lt;code&gt;eof()&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">此功能仅报告由最新I / O操作设置的流状态。它不检查关联的数据源。例如，如果最新的I / O是返回文件最后字节的&lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt;，则 &lt;code&gt;eof()&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。下一个 &lt;code&gt;get()&lt;/code&gt; 无法读取任何内容并设置 &lt;code&gt;eofbit&lt;/code&gt; 。只有这样， &lt;code&gt;eof()&lt;/code&gt; 才会返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="982c99a7d72d510dc31dfb3379380b9b994f3b5b" translate="yes" xml:space="preserve">
          <source>This function reads &lt;a href=&quot;../../language/objects&quot;&gt;object representations&lt;/a&gt;, not the object values, and is typically only meaningful for trivially-copyable objects with no padding. For example, &lt;code&gt;memcmp()&lt;/code&gt; between two objects of type &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; will not compare their contents, and &lt;code&gt;memcmp()&lt;/code&gt; between two objects of type &lt;code&gt;struct{char c; int n;}&lt;/code&gt; will compare the padding bytes whose values may differ when the values of &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are the same.</source>
          <target state="translated">该函数读取&lt;a href=&quot;../../language/objects&quot;&gt;对象表示形式&lt;/a&gt;，而不是对象值，并且通常仅对没有填充的平凡可复制对象有意义。例如，两个 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 类型的对象之间的 &lt;code&gt;memcmp()&lt;/code&gt; 不会比较它们的内容，而 &lt;code&gt;struct{char c; int n;}&lt;/code&gt; 类型的两个对象之间的 &lt;code&gt;memcmp()&lt;/code&gt; 不会进行比较。int n;}将比较 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 的值相同时其值可能不同的填充字节。</target>
        </trans-unit>
        <trans-unit id="3b2572fd11a91d196e72bf228b8fdec17f7a295e" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;true&lt;/code&gt; immediately after construction or an increment. Recursion can be disabled via &lt;code&gt;&lt;a href=&quot;disable_recursion_pending&quot;&gt;disable_recursion_pending()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">该函数在构造或增量后立即返回 &lt;code&gt;true&lt;/code&gt; 。可以通过 &lt;code&gt;&lt;a href=&quot;disable_recursion_pending&quot;&gt;disable_recursion_pending()&lt;/a&gt;&lt;/code&gt; 禁用递归。</target>
        </trans-unit>
        <trans-unit id="36528001254a3bd82486f8ac96e239eda107e919" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. In addition, it modifies the static &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object which may be shared with &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;std::gmtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt;. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">该函数返回指向静态数据的指针，并且不是线程安全的。另外，它修改了静态 &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 对象，该对象可以与 &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;std::gmtime&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt; 共享。POSIX将该功能标记为过时，建议使用 &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1f290d85406220b6b3adbcd72ba71618d9d4c4a" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">该函数返回指向静态数据的指针，并且不是线程安全的。POSIX将该功能标记为过时，建议使用 &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c08549c92d5f75cd55b61fde267f92bfcf2bd81" translate="yes" xml:space="preserve">
          <source>This function template does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">除非 &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; ,否则此函数模板不会参与重载解析。</target>
        </trans-unit>
        <trans-unit id="e017cba1b1d7f0a849984253cc947eb2d5f913c0" translate="yes" xml:space="preserve">
          <source>This function template is &lt;code&gt;constexpr&lt;/code&gt; if and only if each of &lt;code&gt;To&lt;/code&gt;, &lt;code&gt;From&lt;/code&gt; and the types of all subobjects of &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt;:</source>
          <target state="translated">当且仅当 &lt;code&gt;To&lt;/code&gt; ， &lt;code&gt;From&lt;/code&gt; 和 &lt;code&gt;To&lt;/code&gt; 和 &lt;code&gt;From&lt;/code&gt; 的所有子对象的类型分别是，此函数模板才是 &lt;code&gt;constexpr&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="d23f50db250e473fa7ba998015f5ef4335528d35" translate="yes" xml:space="preserve">
          <source>This function was deprecated in C++17 and removed in C++20 because &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; is only an approximation in multithreaded environment (see Notes in &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">此功能在C ++ 17中已弃用，在C ++ 20中已删除，因为 &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; 仅是多线程环境中的近似值（请参阅 &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; 中的注释）。</target>
        </trans-unit>
        <trans-unit id="c95a6c84f8a7a3d63141f96f96d764fc5141f797" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization as a shortcut to avoid having to rebind from &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt;, and having to call &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;construct&lt;/code&gt;, and &lt;code&gt;deallocate&lt;/code&gt; individually.</source>
          <target state="translated">引入此函数是为了与完全专业的分配器 &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; ，但是它在任何专业化中都可以用作避免不必从 &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; 重新绑定到 &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt; 的快捷方式&amp;gt;，并且必须分别调用 &lt;code&gt;allocate&lt;/code&gt; ， &lt;code&gt;construct&lt;/code&gt; 和 &lt;code&gt;deallocate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cdecbddba7a122a33bb2e1a5f3720fe34c7dff59" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization as a shortcut to avoid having to rebind from &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">引入此函数是为了与完全专业的分配器 &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; ，但是它在任何专业化中都可以用作避免不必从 &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; 重新绑定到 &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt; 的快捷方式&amp;gt;。</target>
        </trans-unit>
        <trans-unit id="2ae120608bb11c2db86fc6eaad00ab05ea738813" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization.</source>
          <target state="translated">引入此函数是为了与完全专业化的分配器 &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; ，但是在任何专门化中它都可能有用。</target>
        </trans-unit>
        <trans-unit id="afc3c5ff95ee968755d1d67223367b55662ab586" translate="yes" xml:space="preserve">
          <source>This function's analog for byte strings is &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;std::strncpy&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">字节字符串的此函数模拟是 &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;std::strncpy&lt;/a&gt;&lt;/code&gt; ，而不是 &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2cb86dd21cb66b4b0098463876ae7c777232781" translate="yes" xml:space="preserve">
          <source>This function, if defined, is the inverse of &lt;code&gt;pointer_to&lt;/code&gt;, and exists as the customization point to be called by &lt;a href=&quot;../to_address&quot;&gt;&lt;code&gt;std::to_address&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果定义此函数，则它是 &lt;code&gt;pointer_to&lt;/code&gt; 的逆函数，并且作为要由&lt;a href=&quot;../to_address&quot;&gt; &lt;code&gt;std::to_address&lt;/code&gt; &lt;/a&gt;调用的自定义点而存在。</target>
        </trans-unit>
        <trans-unit id="2345f7fbcd183e468d0ac0a235350d0b6c2895ee" translate="yes" xml:space="preserve">
          <source>This functions invalidates all pointers and references to elements in the array.</source>
          <target state="translated">这个函数使所有指向数组中元素的指针和引用无效。</target>
        </trans-unit>
        <trans-unit id="5e4969b70b796f9ee282c9f3e8a0064ce14f7b5c" translate="yes" xml:space="preserve">
          <source>This header contains forward declarations for the &lt;a href=&quot;../io&quot;&gt;Input/output&lt;/a&gt; library.</source>
          <target state="translated">此头包含&lt;a href=&quot;../io&quot;&gt;输入/输出&lt;/a&gt;库的前向声明。</target>
        </trans-unit>
        <trans-unit id="a9faf08967a6670c687da4edbcf69fb38e394a6f" translate="yes" xml:space="preserve">
          <source>This header is for &lt;a href=&quot;../string/byte&quot;&gt;C-style null-terminated byte strings&lt;/a&gt;.</source>
          <target state="translated">此标头用于&lt;a href=&quot;../string/byte&quot;&gt;C样式的以null终止的字节字符串&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="15d0710db508b245029a9ef7a8057846c8c18ceb" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../algorithm&quot;&gt;algorithm&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../algorithm&quot;&gt;算法&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="58c127bf99321a87db0770e187db96005473b488" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../atomic&quot;&gt;atomic operations&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../atomic&quot;&gt;原子操作&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="e7de3a818aa933f4120df06f08cef712f022314a" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../chrono&quot;&gt;date and time&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../chrono&quot;&gt;日期和时间&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="7df038a6142795810cf58cc3edc5892a6604ef81" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../chrono/c&quot;&gt;C-style date and time&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../chrono/c&quot;&gt;C样式日期和时间&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="fc145a04217e02f635144bea666233647838e7fd" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../concepts&quot;&gt;concepts&lt;/a&gt; library.</source>
          <target state="translated">该头是&lt;a href=&quot;../concepts&quot;&gt;概念&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="920e039f9619877e9581d36218e4eb4ba48fec2f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../container&quot;&gt;container&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../container&quot;&gt;容器&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="acbb3dd4e1d46d22f68d17b978a7136be93e2436" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../container&quot;&gt;containers&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../container&quot;&gt;容器&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="6b732c1d1cd4791f71bccf52bcce002f80d4d61f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../error&quot;&gt;error handling&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../error&quot;&gt;错误处理&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="d135ae9415d668b3740baa8d1c6202b3114e61db" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../filesystem&quot;&gt;filesystem support&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../filesystem&quot;&gt;文件系统支持&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="a2b0a9ff42b16169188356ee975f844196e0ec79" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;Input/Output&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../io&quot;&gt;输入/输出&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="b25ea2a66813773c5a403aa1ec3e976f8574b721" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;Input/output&lt;/a&gt; library.</source>
          <target state="translated">该头是&lt;a href=&quot;../io&quot;&gt;输入/输出&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="0686693c4046ba7c301b43bc07e6f7bdc8f026ab" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;input/output&lt;/a&gt; library.</source>
          <target state="translated">该头是&lt;a href=&quot;../io&quot;&gt;输入/输出&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="5dc95614835592456bfaab6702f6224650e49b18" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io/c&quot;&gt;C-style input/output&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../io/c&quot;&gt;C风格输入/输出&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="741ade6dc30c88b9370c305e6f3e63644225b886" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io/manip&quot;&gt;Input/output manipulators&lt;/a&gt; library.</source>
          <target state="translated">此头是&lt;a href=&quot;../io/manip&quot;&gt;输入/输出操纵器&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="7cb909214b55ea54c4a3636e2ff95e66a61c1e7b" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../iterator&quot;&gt;iterator&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../iterator&quot;&gt;迭代器&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="09eabf0e3af531f8459c8a3e9d34d078049d494f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../locale&quot;&gt;Localization&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../locale&quot;&gt;本地化&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="e0027a344c3001e03b17fff554e048e844e18b05" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../locale&quot;&gt;localization&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../locale&quot;&gt;本地化&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="1909ccb2df983190ad8b340b81a78cddcac0bc66" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../memory&quot;&gt;dynamic memory management&lt;/a&gt; library, in particular provides &lt;a href=&quot;../memory/new&quot;&gt;low level memory management&lt;/a&gt; features.</source>
          <target state="translated">该头是&lt;a href=&quot;../memory&quot;&gt;动态内存管理&lt;/a&gt;库的一部分，特别是提供了&lt;a href=&quot;../memory/new&quot;&gt;低级内存管理&lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="923f654a5fb3f2b4a9e337168f6734bf9fb2d4f9" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../memory&quot;&gt;dynamic memory management&lt;/a&gt; library.</source>
          <target state="translated">该头是&lt;a href=&quot;../memory&quot;&gt;动态内存管理&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="dbf3371c4bdf5d7b9e212f0bbd00a12907e1875c" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric&quot;&gt;numeric&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../numeric&quot;&gt;数字&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="83d799881dc970620d81655aaa5b6c445cc22101" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../numeric/fenv&quot;&gt;浮点环境&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="5ec3ff74347947b9a2d2ce7512f774f5d52354a7" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/random&quot;&gt;pseudo-random number generation&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../numeric/random&quot;&gt;伪随机数生成&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="732e0c7c47f9d69b203e65c610a0bfd158dff524" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/ratio&quot;&gt;compile-time rational arithmetic&lt;/a&gt; library.</source>
          <target state="translated">该头文件是&lt;a href=&quot;../numeric/ratio&quot;&gt;编译时有理算法&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="c1ad47862381ddb91c08db8090600c5d4bf4e4dc" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../ranges&quot;&gt;ranges&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../ranges&quot;&gt;范围&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="d97fc3d50637471b41b3efb43e5a6b0e3a2b4a01" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../regex&quot;&gt;regular expressions&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../regex&quot;&gt;正则表达式&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="a2342c5c0987e5fec030e1218936937ec44df653" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string&quot;&gt;strings&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../string&quot;&gt;字符串&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="92a5be8272a47414f0e0bdc904667ee202af3267" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/byte&quot;&gt;null-terminated byte strings&lt;/a&gt; library.</source>
          <target state="translated">该头是&lt;a href=&quot;../string/byte&quot;&gt;空终止字节字符串&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="15b12e7c5f34f001bead642c260ad11a6ffaa39d" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/multibyte&quot;&gt;null-terminated multibyte strings&lt;/a&gt; library.</source>
          <target state="translated">该头是&lt;a href=&quot;../string/multibyte&quot;&gt;空终止的多字节字符串&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="2c42908621e154cf0ec843b46350efa2d0035aee" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/wide&quot;&gt;C-style null-terminated wide strings&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../string/wide&quot;&gt;C样式的以null终止的宽字符串&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="1fa75679068a99053300a010d141f6d8edb54561" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../thread&quot;&gt;thread support&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../thread&quot;&gt;线程支持&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="5d0c64faa54ec66b25a58a11c78064009bdd8b01" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library, in particular it's part of the &lt;a href=&quot;../types/climits&quot;&gt;C numeric limits interface&lt;/a&gt;.</source>
          <target state="translated">此标头是&lt;a href=&quot;../types&quot;&gt;类型支持&lt;/a&gt;库的一部分，尤其是&lt;a href=&quot;../types/climits&quot;&gt;C数字限制接口&lt;/a&gt;的一部分。</target>
        </trans-unit>
        <trans-unit id="65d3f063deae384355d6746093849a4b449165a4" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library, providing &lt;a href=&quot;../types/integer&quot;&gt;fixed width integer types&lt;/a&gt; and part of &lt;a href=&quot;../types/climits&quot;&gt;C numeric limits interface&lt;/a&gt;.</source>
          <target state="translated">此标头是&lt;a href=&quot;../types&quot;&gt;类型支持&lt;/a&gt;库的一部分，提供&lt;a href=&quot;../types/integer&quot;&gt;固定宽度的整数类型&lt;/a&gt;和&lt;a href=&quot;../types/climits&quot;&gt;C数字限制接口的一部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="436886a411e9e8d5ffe11352a732faef34f88757" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../types&quot;&gt;类型支持&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="7edf0c9c8e7cef800a48133a201ddbc070132a48" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;types support&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../types&quot;&gt;类型支持&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="58facb47ff5cf9d880e42e8852e016436ed3f78a" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility&quot;&gt;general utility&lt;/a&gt; library.</source>
          <target state="translated">该头是&lt;a href=&quot;../utility&quot;&gt;常规实用程序&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="31843b16c0e12afb62de520dcdac5733f6cee8c2" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility&quot;&gt;utility&lt;/a&gt; library.</source>
          <target state="translated">该头是&lt;a href=&quot;../utility&quot;&gt;实用程序&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="b3ee827480d7d8d279e03c27c6ed6cca87cad739" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility#Language_support&quot;&gt;language support&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../utility#Language_support&quot;&gt;语言支持&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="a4ff4d258bc17960105e2ea2601ffd3a5889df5f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility/functional&quot;&gt;function objects&lt;/a&gt; library and provides the standard &lt;a href=&quot;../utility/hash&quot;&gt;hash function&lt;/a&gt;.</source>
          <target state="translated">该头文件是&lt;a href=&quot;../utility/functional&quot;&gt;函数对象&lt;/a&gt;库的一部分，并提供标准的&lt;a href=&quot;../utility/hash&quot;&gt;哈希函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ac972c91cec61981b8a812ec6acfd57ff806586" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility/program&quot;&gt;program support&lt;/a&gt; library.</source>
          <target state="translated">此标头是&lt;a href=&quot;../utility/program&quot;&gt;程序支持&lt;/a&gt;库的一部分。</target>
        </trans-unit>
        <trans-unit id="e22299e67c4b7f2d10a4eb976dbfff224a6c2122" translate="yes" xml:space="preserve">
          <source>This header is part of the null-terminated &lt;a href=&quot;../string/wide&quot;&gt;wide&lt;/a&gt; and &lt;a href=&quot;../string/multibyte&quot;&gt;multibyte&lt;/a&gt; strings libraries. It also provides some &lt;a href=&quot;../io/c&quot;&gt;C-style I/O&lt;/a&gt; functions and conversion from &lt;a href=&quot;../chrono/c&quot;&gt;C-style Date&lt;/a&gt;.</source>
          <target state="translated">该头是空终止的&lt;a href=&quot;../string/wide&quot;&gt;宽&lt;/a&gt;和&lt;a href=&quot;../string/multibyte&quot;&gt;多字节&lt;/a&gt;字符串库的一部分。它还提供了一些&lt;a href=&quot;../io/c&quot;&gt;C风格的I / O&lt;/a&gt;功能以及从&lt;a href=&quot;../chrono/c&quot;&gt;C风格的Date进行&lt;/a&gt;转换。</target>
        </trans-unit>
        <trans-unit id="d0be451883776fa4f5f243412345fc9b51386469" translate="yes" xml:space="preserve">
          <source>This header provides miscellaneous utilities. Symbols defined here are used by several library components.</source>
          <target state="translated">这个头提供了各种实用工具。这里定义的符号被几个库组件使用。</target>
        </trans-unit>
        <trans-unit id="3d8521103b2fed33ffe104b06e729876d4b7f2c8" translate="yes" xml:space="preserve">
          <source>This header provides support for &lt;a href=&quot;../utility/variadic&quot;&gt;C-style variadic functions&lt;/a&gt;.</source>
          <target state="translated">此标头提供对&lt;a href=&quot;../utility/variadic&quot;&gt;C样式可变参数的&lt;/a&gt;支持。</target>
        </trans-unit>
        <trans-unit id="1f5444765226ce0bdb5af9dadf8c355721e6f565" translate="yes" xml:space="preserve">
          <source>This header supplies implementation-dependent information about the standard library (such as implementation-specific library version macros).</source>
          <target state="translated">这个头提供有关标准库的实现相关信息(如实现特定的库版本宏)。</target>
        </trans-unit>
        <trans-unit id="e3d2a98c9481a36d1f279d320f5b70a26a7e3330" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a392d9aa2ebe01e48b3d01961d845f5d0588e04" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="21d14ed988bc023e0af2e53864603e6cda2885be" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68c78f91644f281b447ad60cdbb1634c09a9119a" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此标头最初在C标准库中为 &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02e483f5fd629df3b87fff596e49a80d8b8c0425" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6e03bbb8695dbcceecc16e98c0e964b5fefd852" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此标头最初在C标准库中为 &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d59783125b891e429043f2f2d5f576fd72a06c1c" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此标头最初在C标准库中为 &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02fccbdf35494b28df2accdc8d41b5a89580c3c0" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db14ba2bad874c7dde2374ac32527f2c381efc33" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此标头最初在C标准库中为 &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="53af078bd74b84f0423e1e9211b917adea77b920" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此标头最初在C标准库中为 &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fc6197b328bad98f05fff68010e58025c14a9b1" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此标头最初在C标准库中为 &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98d8ce7d2ea217c30464e6a8895e55e50e6eb6dd" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此标头最初在C标准库中为 &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4db152ded5e9f8b82696d238d20533a05044bdc8" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbf2ebc0d4f0372f0d23dcfc1ff48e2cc5e172fa" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此标头最初在C标准库中为 &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="552c8fb5c454bd957020620ff32c98f913c6ec6f" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1fc778831b537c9627fb3177ad740d51c764464" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该标头最初在C标准库中为 &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea55cad81c5a499ab61c2f336f793e79c2cde22b" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4e4679e2a1edfcea3588f047e41db14f9335c2e" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b100c9fc2e0568f0798665b7418667c38edba953" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9724180e3c20c4e3ccde319664bad3907db8ef2" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">此标头最初在C标准库中为 &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6d57c16a998701ee531191c284ccfc0598fb9ad8" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aeb4dad38844729f6a773adfa6b26a2500e3724e" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="78466c124900e096d16d9eac15396f90464c889b" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bc1e66e0693def74a913c9f83e9fd4b6579b986" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2e4ff735f64305108a77807fb191c4cc62d9e14" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16d7a74374a4accebff96ae1f6f2de097d3b0cae" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">该头文件最初在C标准库中为 &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aedb64fc9e75ef3b36a2ef43e03fc20db3e03e5b" translate="yes" xml:space="preserve">
          <source>This holds for every objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that are not aliases of one another.</source>
          <target state="translated">对于不互为别名的每个对象 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 成立。</target>
        </trans-unit>
        <trans-unit id="05ebbbf417474068cc1404af21d2b363f30ea1c1" translate="yes" xml:space="preserve">
          <source>This implies that the class has no &lt;a href=&quot;../language/virtual&quot;&gt;virtual functions&lt;/a&gt; or &lt;a href=&quot;../language/derived_class#Virtual_base_classes&quot;&gt;virtual base classes&lt;/a&gt;.</source>
          <target state="translated">这意味着该类没有&lt;a href=&quot;../language/virtual&quot;&gt;虚拟函数&lt;/a&gt;或&lt;a href=&quot;../language/derived_class#Virtual_base_classes&quot;&gt;虚拟基类&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2f0ae52b3b410d1e9be7d3f883c6f57fc4873c3a" translate="yes" xml:space="preserve">
          <source>This includes &lt;a href=&quot;type-id&quot;&gt;integral types&lt;/a&gt;, &lt;a href=&quot;pointer&quot;&gt;pointer types&lt;/a&gt;, &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;pointer to member type&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, as well as enumeration types with no custom &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; overload, but excludes floating-point types.</source>
          <target state="translated">这包括&lt;a href=&quot;type-id&quot;&gt;整数类型&lt;/a&gt;，&lt;a href=&quot;pointer&quot;&gt;指针类型&lt;/a&gt;，&lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;成员类型的指针&lt;/a&gt;， &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; ，以及没有自定义 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 重载的枚举类型，但不包括浮点类型。</target>
        </trans-unit>
        <trans-unit id="d9b2e0a6f64a6667926bbe46e5290f95959e8907" translate="yes" xml:space="preserve">
          <source>This information is provided via specializations of the &lt;code&gt;numeric_limits&lt;/code&gt; template. The standard library makes available specializations for all arithmetic types:</source>
          <target state="translated">该信息是通过 &lt;code&gt;numeric_limits&lt;/code&gt; 模板的特殊化提供的。标准库可为所有算术类型提供专用化：</target>
        </trans-unit>
        <trans-unit id="30fa8f162edae84e00655c850b76032946d786f6" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;V&lt;/code&gt; models &lt;a href=&quot;bidirectionalrange&quot;&gt;&lt;code&gt;BidirectionalRange&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;V&lt;/code&gt; models &lt;a href=&quot;forwardrange&quot;&gt;&lt;code&gt;ForwardRange&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">这是一个&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; &lt;/a&gt;如果 &lt;code&gt;V&lt;/code&gt; 车型&lt;a href=&quot;bidirectionalrange&quot;&gt; &lt;code&gt;BidirectionalRange&lt;/code&gt; &lt;/a&gt;，一个&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; &lt;/a&gt;如果 &lt;code&gt;V&lt;/code&gt; 车型&lt;a href=&quot;forwardrange&quot;&gt; &lt;code&gt;ForwardRange&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; 的&lt;/a&gt;其他方式。</target>
        </trans-unit>
        <trans-unit id="8b29d4dc98b35c7b6aae2a923e6c330c4c737570" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models _Advanceable, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models _Decrementable, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Incrementable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">这是一个&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;RandomAccessIterator&lt;/code&gt; 的&lt;/a&gt;，如果 &lt;code&gt;W&lt;/code&gt; 车型_Advanceable，一个&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; &lt;/a&gt;如果 &lt;code&gt;W&lt;/code&gt; &amp;macr;&amp;macr;模型_Decrementable，一个&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; &lt;/a&gt;如果 &lt;code&gt;W&lt;/code&gt; &amp;macr;&amp;macr;模型&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Incrementable&lt;/code&gt; &lt;/a&gt;，而&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; 的&lt;/a&gt;其他方式。</target>
        </trans-unit>
        <trans-unit id="ab311fc847c477a15d5b1d9860db2b6b4cc68c90" translate="yes" xml:space="preserve">
          <source>This is a copy of the the private mutable &lt;code&gt;weak_ptr&lt;/code&gt; member that is part of &lt;code&gt;enable_shared_from_this&lt;/code&gt;.</source>
          <target state="translated">这是私有可变的副本 &lt;code&gt;weak_ptr&lt;/code&gt; 的成员是一部分 &lt;code&gt;enable_shared_from_this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9c2a70dd0a39c1457e77f347c24e87c6d5cad7cb" translate="yes" xml:space="preserve">
          <source>This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading.</source>
          <target state="translated">这是C++中保留的关键字列表。由于这些关键字是由语言使用的,所以不能重新定义或重载。</target>
        </trans-unit>
        <trans-unit id="317fe1d241fce7e8d40b91008c64f80e35d56f6c" translate="yes" xml:space="preserve">
          <source>This is a low-level data structure; typical conversions from &lt;code&gt;local_time&lt;/code&gt; to &lt;code&gt;sys_time&lt;/code&gt; will use it implicitly rather than explicitly.</source>
          <target state="translated">这是一个低级的数据结构。从 &lt;code&gt;local_time&lt;/code&gt; 到 &lt;code&gt;sys_time&lt;/code&gt; 的典型转换将隐式而不是显式地使用它。</target>
        </trans-unit>
        <trans-unit id="06fb932be30caede5a481a8189299e404a6d4974" translate="yes" xml:space="preserve">
          <source>This is a reference of the core C++ language constructs.</source>
          <target state="translated">这是一个C++语言核心结构的参考。</target>
        </trans-unit>
        <trans-unit id="e31b548ee1fbca7fa6d3494affb746a0a1a2457c" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the largest value representable by the type &lt;code&gt;std::size_t&lt;/code&gt;, used as the return type of &lt;code&gt;index()&lt;/code&gt; when &lt;code&gt;valueless_by_exception()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">这是一个特殊值，它等于 &lt;code&gt;std::size_t&lt;/code&gt; 类型可表示的最大值，当 &lt;code&gt;valueless_by_exception()&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，它用作 &lt;code&gt;index()&lt;/code&gt; 的返回类型。</target>
        </trans-unit>
        <trans-unit id="a39c0c855473751858895d7068c8ca7b082d5f62" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the maximum value representable by the type &lt;code&gt;size_type&lt;/code&gt;. The exact meaning depends on context, but it is generally used either as end of string indicator by the functions that expect a string index or as the error indicator by the functions that return a string index.</source>
          <target state="translated">这是一个特殊值，等于 &lt;code&gt;size_type&lt;/code&gt; 类型可表示的最大值。确切的含义取决于上下文，但通常由期望字符串索引的函数用作字符串指示符的结尾，或者由返回字符串索引的函数用作错误指示符。</target>
        </trans-unit>
        <trans-unit id="8ef208e1bc26501dbfeecb667b7796cbd9eef4a6" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the maximum value representable by the type &lt;code&gt;size_type&lt;/code&gt;. The exact meaning depends on context, but it is generally used either as end of view indicator by the functions that expect a view index or as the error indicator by the functions that return a view index.</source>
          <target state="translated">这是一个特殊值，等于 &lt;code&gt;size_type&lt;/code&gt; 类型可表示的最大值。确切的含义取决于上下文，但是通常由期望视图索引的函数用作视图结束指示符，或者由返回视图索引的函数用作错误指示符。</target>
        </trans-unit>
        <trans-unit id="2d9f89f3207c56d0f6ab075de354388d63d28553" translate="yes" xml:space="preserve">
          <source>This is a specialized allocator-aware container. It can only be default created, obtained from &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt;, or modified by &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt;. Because &lt;code&gt;std::match_results&lt;/code&gt; holds &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;es, each of which is a pair of iterators into the original character sequence that was matched, it's undefined behavior to examine &lt;code&gt;std::match_results&lt;/code&gt; if the original character sequence was destroyed or iterators to it were invalidated for other reasons.</source>
          <target state="translated">这是一个专门的分配器感知容器。它只能默认创建，从 &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; 或通过 &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; 。由于 &lt;code&gt;std::match_results&lt;/code&gt; 持有 &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; es，每个es是一对匹配到原始字符序列的迭代器，因此检查 &lt;code&gt;std::match_results&lt;/code&gt; 是否为原始字符序列被破坏或迭代器是否存在是不确定的行为。由于其他原因而无效。</target>
        </trans-unit>
        <trans-unit id="dcbd4929cfc88985415e596c60e165a57a093570" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::fixed&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::scientific&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个I / O操作器，它可以与一个表达称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::fixed&lt;/code&gt; 为任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 或用表达如 &lt;code&gt;in &amp;gt;&amp;gt; std::scientific&lt;/code&gt; 为任何 &lt;code&gt;in&lt;/code&gt; 的输入 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="937bf19df4c0af79385dda35f013197f369e8f37" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::noskipws&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::noskipws&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个I / O操作器，它可以与一个表达称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::noskipws&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 或用表达如 &lt;code&gt;in &amp;gt;&amp;gt; std::noskipws&lt;/code&gt; 任何 &lt;code&gt;in&lt;/code&gt; 的输入 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b42315a6cd8a7f333df8749952b733651d2fec90" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showbase&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showbase&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个I / O操作器，它可以与一个表达称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::showbase&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 或用表达如 &lt;code&gt;in &amp;gt;&amp;gt; std::showbase&lt;/code&gt; 任何 &lt;code&gt;in&lt;/code&gt; 的输入 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70463fd9c90aded7947bc0ce3158695492cf938d" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showpoint&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showpoint&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个I / O操作器，它可以与一个表达称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::showpoint&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 或如表达 &lt;code&gt;in &amp;gt;&amp;gt; std::showpoint&lt;/code&gt; 任何 &lt;code&gt;in&lt;/code&gt; 的输入 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf76b611f62f218dd5340fb19c1a0b0493038e0e" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showpos&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showpos&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个I / O操作器，它可以与一个表达称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::showpos&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 或用表达如 &lt;code&gt;in &amp;gt;&amp;gt; std::showpos&lt;/code&gt; 任何 &lt;code&gt;in&lt;/code&gt; 的输入 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b963cb12fe265e17a4ede1e827c0c6875636dad" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::unitbuf&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::unitbuf&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个I / O操作器，它可以与一个表达称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::unitbuf&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 或用表达如 &lt;code&gt;in &amp;gt;&amp;gt; std::unitbuf&lt;/code&gt; 任何 &lt;code&gt;in&lt;/code&gt; 的输入 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc0de5a017268c93f9adb1760286b7389369587a" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::uppercase&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::uppercase&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个I / O操作器，它可以与一个表达称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::uppercase&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 或用表达如 &lt;code&gt;in &amp;gt;&amp;gt; std::uppercase&lt;/code&gt; 为任何 &lt;code&gt;in&lt;/code&gt; 的输入 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daf2205ff27f5d190edd20850443509692eb70e0" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator. It may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::hex&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::hex&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个I / O操作器。它可以与一个表达被称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::hex&lt;/code&gt; 为任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 的表达或与如 &lt;code&gt;in &amp;gt;&amp;gt; std::hex&lt;/code&gt; 为任何 &lt;code&gt;in&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9f3502e7e7df95e12c9da2ae171edd9ba6a04db" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator. It may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::left&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::left&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个I / O操作器。它可以与一个表达被称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::left&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 或用表达如 &lt;code&gt;in &amp;gt;&amp;gt; std::left&lt;/code&gt; 任何 &lt;code&gt;in&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c0b02e3721ebe7f5ac3c4b5ffc6c0f2d28f4fc9" translate="yes" xml:space="preserve">
          <source>This is an N:M conversion facet, and cannot be used with &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (which only permits 1:N conversions, such as UTF-32/UTF-8, between the internal and the external encodings). This facet can be used with &lt;code&gt;&lt;a href=&quot;wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个N：M转换方面，不能与 &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 一起使用（它仅允许内部和外部编码之间进行1：N转换，例如UTF-32 / UTF-8）。此构面可与 &lt;code&gt;&lt;a href=&quot;wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; 一起使用。</target>
        </trans-unit>
        <trans-unit id="8f532dd6dda7ce4e7fef9024ca6a90c38fdddd97" translate="yes" xml:space="preserve">
          <source>This is an input-only I/O manipulator, it may be called with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::ws&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是仅输入的I / O操纵器，对于任何类型为 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; &lt;code&gt;in&lt;/code&gt; ，都可以使用诸如 &lt;code&gt;in &amp;gt;&amp;gt; std::ws&lt;/code&gt; 之类的表达式来调用。</target>
        </trans-unit>
        <trans-unit id="e42acc2eabf231ad6ab330a8662f12700cd267a5" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::emit_on_flush&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个只输出I / O操作器，它可以与一个表达被称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::emit_on_flush&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60e12fb0d661bde8d9b081c1cd879d866b874d0f" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::endl&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个只输出I / O操作器，它可以与一个表达被称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::endl&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="651708b37cd7ae8cdbb511a6453c7ac66edb7063" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::ends&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个只输出I / O操作器，它可以与一个表达被称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::ends&lt;/code&gt; 为任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cb0b93b12bb860d769cac7587fe1bddc043d0e17" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::flush&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个只输出I / O操作器，它可以与一个表达被称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::flush&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="297f17cae564feba63e3617363eb17ca7ff29374" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::flush_emit&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是一个只输出I / O操作器，它可以与一个表达被称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::flush_emit&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="042aa022f3538e0380d9238f1617babc4f91044d" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">这是通过调用 &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 和 &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="6d1a687deef64a2de24aab2940536db537dc7c30" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">这是通过调用 &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 和 &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="8519863f445ff4dc4073c63885010fc835c9d17f" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">这是通过调用 &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 和 &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="36ff5f6b7bbdd8db83afcceb063e1cc859a416c7" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">这是通过调用 &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 和 &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="82ad146be2cb4f18f794320cb99236e3f0e5a7de" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">这是通过调用 &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 和 &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="786b3029313db82a7b7425ea04d749d77cb88554" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">这是通过调用 &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; 和 &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; 来完成的。</target>
        </trans-unit>
        <trans-unit id="acd8409ce8140988c0f9cd5273c17f072a8e1133" translate="yes" xml:space="preserve">
          <source>This is no longer allowed in C++17. Instead the array form &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; should be used.</source>
          <target state="translated">C ++ 17不再允许这样做。相反，应使用数组形式 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="873c5086291117573f8d6d6edce6a8a27dcea191" translate="yes" xml:space="preserve">
          <source>This is the case only for futures that were not default-constructed or moved from (i.e. returned by &lt;code&gt;&lt;a href=&quot;../promise/get_future&quot;&gt;std::promise::get_future()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../packaged_task/get_future&quot;&gt;std::packaged_task::get_future()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async()&lt;/a&gt;&lt;/code&gt;) until the first time &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;share&quot;&gt;share()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">仅对于不是默认构造或未从其转移（即由 &lt;code&gt;&lt;a href=&quot;../promise/get_future&quot;&gt;std::promise::get_future()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../packaged_task/get_future&quot;&gt;std::packaged_task::get_future()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async()&lt;/a&gt;&lt;/code&gt; ）的期货才是这种情况时间 &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;share&quot;&gt;share()&lt;/a&gt;&lt;/code&gt; 被调用。</target>
        </trans-unit>
        <trans-unit id="cf0f969d26a72355354c117d383b2d725eed3830" translate="yes" xml:space="preserve">
          <source>This is the case only for futures that were not default-constructed or moved from. Unlike &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::shared_future&lt;/code&gt;'s shared state is not invalidated when &lt;code&gt;get()&lt;/code&gt; is called.</source>
          <target state="translated">这仅适用于未默认构建或未从中转移的期货。与 &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;std::shared_future&lt;/code&gt; 的共享状态在调用 &lt;code&gt;get()&lt;/code&gt; 时不会无效。</target>
        </trans-unit>
        <trans-unit id="654479f728093b995df666411bdb28aa8834e6ea" translate="yes" xml:space="preserve">
          <source>This is the class returned by the &lt;a href=&quot;../language/typeid&quot;&gt; typeid&lt;/a&gt; operator.</source>
          <target state="translated">这是&lt;a href=&quot;../language/typeid&quot;&gt;typeid&lt;/a&gt;运算符返回的类。</target>
        </trans-unit>
        <trans-unit id="a54fb420dbec256007f5b5fe39b66f1e973e225c" translate="yes" xml:space="preserve">
          <source>This is the class returned by the &lt;a href=&quot;language/typeid&quot;&gt; typeid&lt;/a&gt; operator.</source>
          <target state="translated">这是&lt;a href=&quot;language/typeid&quot;&gt;typeid&lt;/a&gt;运算符返回的类。</target>
        </trans-unit>
        <trans-unit id="b68e57b066a7bc6709ae7f2c462030b2b3f61772" translate="yes" xml:space="preserve">
          <source>This is the continuous counterpart of &lt;code&gt;&lt;a href=&quot;geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">这是 &lt;code&gt;&lt;a href=&quot;geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt; 的连续副本。</target>
        </trans-unit>
        <trans-unit id="4bd023e111f5d2be5d722aa1cd31d0bb87464c42" translate="yes" xml:space="preserve">
          <source>This is the initialization performed when a variable is constructed with an empty initializer.</source>
          <target state="translated">这是用空初始化器构造变量时进行的初始化。</target>
        </trans-unit>
        <trans-unit id="e592a74f67ac1f9613e037ec54f2110302e91afd" translate="yes" xml:space="preserve">
          <source>This is the initialization performed when a variable is constructed with no initializer.</source>
          <target state="translated">这是在没有初始化器的情况下构造变量时进行的初始化。</target>
        </trans-unit>
        <trans-unit id="df01ca6b36b691a562048440349e8dc25830ccb7" translate="yes" xml:space="preserve">
          <source>This is the iterator returned by member functions &lt;code&gt;rbegin()&lt;/code&gt; and &lt;code&gt;rend()&lt;/code&gt; of the standard library containers.</source>
          <target state="translated">这是标准库容器的成员函数 &lt;code&gt;rbegin()&lt;/code&gt; 和 &lt;code&gt;rend()&lt;/code&gt; 返回的迭代器。</target>
        </trans-unit>
        <trans-unit id="f5ad9a77cced8620a8dd7901ec2fb07df1c2718e" translate="yes" xml:space="preserve">
          <source>This is the only publicly accessible and defined constructor.</source>
          <target state="translated">这是唯一可公开访问和定义的构造函数。</target>
        </trans-unit>
        <trans-unit id="678d1fe5005da438d1e76e438f6b694064724ab0" translate="yes" xml:space="preserve">
          <source>This is the only way to initialize &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to a definite value: the value held after any other initialization is unspecified.</source>
          <target state="translated">这是将 &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 初始化为确定值的唯一方法：未指定任何其他初始化之后保存的值。</target>
        </trans-unit>
        <trans-unit id="812af2a36c3f95774b9b7221df53591bbffef4a8" translate="yes" xml:space="preserve">
          <source>This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.</source>
          <target state="translated">这通常适用于ASCII字符集的字符,因为大多数多字节编码(如UTF-8)使用单字节来编码这些字符。</target>
        </trans-unit>
        <trans-unit id="4d2e82e79a4c00e49cbeb6cd456e401a3f7c67b6" translate="yes" xml:space="preserve">
          <source>This is used to capture move-only types with a capture such as &lt;code&gt;x = std::move(x)&lt;/code&gt;.</source>
          <target state="translated">这用于捕获带有捕获的仅移动类型，例如 &lt;code&gt;x = std::move(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d03b82ce1e09a94b53a9663441cf142803eed2e" translate="yes" xml:space="preserve">
          <source>This is used, for example, by &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt;, which may have to allocate new storage and then move or copy elements from old storage to new storage. If an exception occurs during this operation, &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; undoes everything it did to this point, which is only possible if &lt;code&gt;std::move_if_noexcept&lt;/code&gt; was used to decide whether to use move construction or copy construction. (unless copy constructor is not available, in which case move constructor is used either way and the strong exception guarantee may be waived).</source>
          <target state="translated">例如， &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; 可以使用它，它可能必须分配新的存储，然后将元素从旧存储移动或复制到新存储。如果在此操作期间发生异常，则 &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; 撤消到目前为止所做的一切，只有在使用 &lt;code&gt;std::move_if_noexcept&lt;/code&gt; 来决定使用移动构造还是复制构造时，这才是可能的。 （除非复制构造函数不可用，在这种情况下，无论哪种方式都使用move构造函数，并且可以放弃强异常保证）。</target>
        </trans-unit>
        <trans-unit id="65497cbcaeca38825fa3feca97f3678010e28f07" translate="yes" xml:space="preserve">
          <source>This lookup with the reversed arguments order makes it possible to write just one &lt;code&gt;operatror&amp;lt;=&amp;gt;(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;, const char*)&lt;/code&gt; to generate all comparisons between &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;const char*&lt;/code&gt;, both ways. See &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt; for more detail.</source>
          <target state="translated">这种具有相反参数顺序的查找使得仅编写一个 &lt;code&gt;operatror&amp;lt;=&amp;gt;(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;, const char*)&lt;/code&gt; 即可生成 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;const char*&lt;/code&gt; 之间的所有比较（两种方式）。有关更多详细信息，请参见&lt;a href=&quot;default_comparisons&quot;&gt;默认比较&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7c00bd2988f8e6fd1c69153710829dd41df339f1" translate="yes" xml:space="preserve">
          <source>This macro is primarily provided for compatibility with C; it behaves the same as the constructor of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">提供此宏主要是为了与C兼容；它的行为与 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 的构造函数相同。</target>
        </trans-unit>
        <trans-unit id="69dae22caf55af4023255754b9c726f9f5527dad" translate="yes" xml:space="preserve">
          <source>This makes it possible to introduce new integer types (e.g. SafeInt) that enjoy the same existing calling conventions as their underlying integer types, even on ABIs that penalize passing/returning structures by value.</source>
          <target state="translated">这使得引入新的整数类型(例如SafeInt)成为可能,这些整数类型与它们的底层整数类型享有相同的现有调用惯例,甚至在惩罚按值传递/返回结构的ABI上也是如此。</target>
        </trans-unit>
        <trans-unit id="1fced9487368a0914863ecd65a116e588baecbc7" translate="yes" xml:space="preserve">
          <source>This makes it possible to move out of an object in scope that is no longer needed:</source>
          <target state="translated">这使得它可以从范围内不再需要的对象中移出。</target>
        </trans-unit>
        <trans-unit id="9c4ec0eda49a5a6eec06bfb350abc5e50dec706c" translate="yes" xml:space="preserve">
          <source>This manipulator is typically used with &lt;code&gt;&lt;a href=&quot;../ostrstream&quot;&gt;std::ostrstream&lt;/a&gt;&lt;/code&gt;, when the associated output buffer needs to be null-terminated to be processed as a C string.</source>
          <target state="translated">该操纵器通常与 &lt;code&gt;&lt;a href=&quot;../ostrstream&quot;&gt;std::ostrstream&lt;/a&gt;&lt;/code&gt; ，当关联的输出缓冲区需要以null终止以作为C字符串处理时。</target>
        </trans-unit>
        <trans-unit id="0d033cddb2872a1515d402a6be03415f6aa84c5a" translate="yes" xml:space="preserve">
          <source>This manipulator may be used to produce a line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush of &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; is also necessary before a call to &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;, if the spawned process performs any screen I/O. In most other usual interactive I/O scenarios, &lt;code&gt;std::endl&lt;/code&gt; is redundant when used with &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; because any input from &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, output to &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, or program termination forces a call to &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt;. Use of &lt;code&gt;std::endl&lt;/code&gt; in place of &lt;code&gt;'\n'&lt;/code&gt;, encouraged by some sources, may significantly degrade output performance.</source>
          <target state="translated">该操纵器可用于立即产生一行输出，例如，当显示长时间运行的进程的输出，多个线程的日志记录活动或程序的日志记录活动时，它们可能会意外崩溃。如果生成的进程执行任何屏幕I / O，则在调用 &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; 之前也必须显式刷新 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 。在大多数其他常见的交互式I / O方案中， &lt;code&gt;std::endl&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 一起使用时是多余的，因为任何来自 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; 输入，输出到 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; 或程序终止都将强制调用 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; .flush（）。使用 &lt;code&gt;std::endl&lt;/code&gt; 代替 &lt;code&gt;'\n'&lt;/code&gt; 在某些来源的鼓励下，可能会严重降低输出性能。</target>
        </trans-unit>
        <trans-unit id="c4f2d1bbb43a26f1c14fa7b3e243baca9ad4d3dc" translate="yes" xml:space="preserve">
          <source>This manipulator may be used to produce an incomplete line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush of &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; is also necessary before a call to &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;, if the spawned process performs any screen I/O (a common example is &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;(&quot;pause&quot;)&lt;/code&gt; on Windows). In most other usual interactive I/O scenarios, &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; is redundant when used with &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; because any input from &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, output to &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, or program termination forces a call to &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt;.</source>
          <target state="translated">该操纵器可用于立即产生不完整的输出行，例如，当显示长时间运行的进程的输出，多个线程的日志记录活动或程序的日志记录活动时，它们可能会意外崩溃。如果生成的进程执行任何屏幕I / O（在Windows上，常见的示例是 &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;(&quot;pause&quot;)&lt;/code&gt; （&amp;ldquo;暂停&amp;rdquo;）），则在调用 &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; 之前也必须显式刷新 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 。在大多数其他常见的交互式I / O方案中， &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; 一起使用时是多余的，因为任何来自 &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; 输入，输出到 &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; 或程序终止都将强制调用 &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; .flush（）。</target>
        </trans-unit>
        <trans-unit id="b8bc45ac3ed46d59a0178ef3c27e45979eabda25" translate="yes" xml:space="preserve">
          <source>This may be used to avoid unnecessary &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; fences when the dependency chain leaves function scope (and the function does not have the &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; attribute).</source>
          <target state="translated">当依赖关系链离开函数范围（并且该函数不具有 &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; &lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carry_dependency&lt;/a&gt; ]]属性）时，这可以用于避免不必要的 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56eb878738bcafe0dda45a9b25b2771a66434232" translate="yes" xml:space="preserve">
          <source>This may happen if the pointer is assigned to:</source>
          <target state="translated">如果指针被分配到以下位置,可能会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="263227da37307b0a3267455a4c633b69bc493839" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;match[i].position()&lt;/code&gt; gives the offset from the beginning of the target sequence, which is often not the same as the offset from the sequence passed in the call to &lt;code&gt;regex_search&lt;/code&gt;.</source>
          <target state="translated">这意味着 &lt;code&gt;match[i].position()&lt;/code&gt; 给出从目标序列开始的偏移量，通常与调用 &lt;code&gt;regex_search&lt;/code&gt; 中传递的序列的偏移量不同。</target>
        </trans-unit>
        <trans-unit id="2cdccbba38d49dbd4067105548f38475359bb552" translate="yes" xml:space="preserve">
          <source>This means that in a conforming implementation, including this header has no effect.</source>
          <target state="translated">这意味着在一个符合要求的实现中,包含这个头没有任何效果。</target>
        </trans-unit>
        <trans-unit id="558bc6404fe9a7280ef6a558ff20ea8606c413a8" translate="yes" xml:space="preserve">
          <source>This means that there are no aliases in the elements and this property can be used to perform some kinds of optimization.</source>
          <target state="translated">这意味着元素中没有别名,这个属性可以用来进行一些优化。</target>
        </trans-unit>
        <trans-unit id="81b15552e359daa797fa96a9d36a5f3772826f69" translate="yes" xml:space="preserve">
          <source>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression.</source>
          <target state="translated">这种机制使得使用模板操作符成为可能,因为除了将操作符重新写成函数调用表达式之外,没有任何语法可以为操作符指定模板参数。</target>
        </trans-unit>
        <trans-unit id="baabe2e811ea477176a6b1ba57aacf61a6c0bf94" translate="yes" xml:space="preserve">
          <source>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression:</source>
          <target state="translated">这种机制使得使用模板运算符成为可能,因为除了将运算符重新写成函数调用表达式之外,没有任何语法可以为运算符指定模板参数。</target>
        </trans-unit>
        <trans-unit id="631b5699cc80fd8b4a70a5399e59151e856f7a18" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; once the associated stream buffer is known. Until this function is called, every member function (including the destructor) of the default-constructed &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; invokes undefined behavior. Note that &lt;code&gt;basic_ios&lt;/code&gt; is a virtual base class, and therefore its constructor is not called by the constructors of those directly derived classes, which is why two-stage initialization is necessary.</source>
          <target state="translated">此成员函数受保护：一旦知道关联的流缓冲区，派生流类 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 的构造函数将调用它。在调用此函数之前，默认构造的 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; 每个成员函数（包括析构函数）都将调用未定义的行为。注意 &lt;code&gt;basic_ios&lt;/code&gt; 是一个虚拟基类，因此那些直接派生类的构造函数不会调用其构造函数，这就是为什么需要两阶段初始化的原因。</target>
        </trans-unit>
        <trans-unit id="9ff0b24c8b1bcff91c847b5b05e80e90bc1f2ed8" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the move constructors of the derived streams such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, as the final step after constructing the base class and after moving the stream buffer: only the most derived stream class knows how to correctly move the stream buffer, but &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; needs to be made aware of the stream's new location so that its public member functions can access it.</source>
          <target state="translated">此成员函数受保护：派生流的移动构造函数（例如 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; ，作为构造基类和移动流缓冲区之后的最后一步：仅派生最多的流类知道如何正确移动流缓冲区，但是需要使 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; 知道流的新位置，以便其公共成员函数可以访问它。</target>
        </trans-unit>
        <trans-unit id="9c3c6a60b1284f57464c304d4f49e3141a9265a5" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the protected move constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;, which, in turn, are called by the public move constructors of the further derived stream classes such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly move the associated streambuffer.</source>
          <target state="translated">此成员函数受保护：它由派生的流类 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 的受保护的move构造函数调用，而后者又由进一步派生的流类（例如 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 的public move构造函数调用。:: basic_ofstream，它知道如何正确移动关联的流缓冲区。</target>
        </trans-unit>
        <trans-unit id="6018aedea85c8af7152a8d08f9289d2de94a185f" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the swap member functions of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated stream buffers.</source>
          <target state="translated">此成员函数受保护：它由派生流类 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 的swap成员函数调用，它们知道如何正确交换关联的流缓冲区。</target>
        </trans-unit>
        <trans-unit id="194eca0c3ce225b7c17b35f16086bbd18ea24522" translate="yes" xml:space="preserve">
          <source>This metafunction is a convenient way to leverage &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; to conditionally remove functions from &lt;a href=&quot;../language/overload_resolution&quot;&gt;overload resolution&lt;/a&gt; based on type traits and to provide separate function overloads and specializations for different type traits. &lt;code&gt;std::enable_if&lt;/code&gt; can be used as an additional function argument (not applicable to operator overloads), as a return type (not applicable to constructors and destructors), or as a class template or function template parameter.</source>
          <target state="translated">此元函数是一种方便的方法，可以利用&lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt;基于类型特征有条件地从&lt;a href=&quot;../language/overload_resolution&quot;&gt;重载解析中&lt;/a&gt;删除函数，并为不同的类型特征提供单独的函数重载和专门化。 &lt;code&gt;std::enable_if&lt;/code&gt; 可用作附加函数参数（不适用于运算符重载），返回类型（不适用于构造函数和析构函数）或用作类模板或函数模板参数。</target>
        </trans-unit>
        <trans-unit id="a1422282434c61f7b9a780c953c50b153fde9dfb" translate="yes" xml:space="preserve">
          <source>This metafunction is used in template metaprogramming to detect ill-formed types in SFINAE context:</source>
          <target state="translated">这个元函数在模板元编程中用于检测SFINAE上下文中的错误类型。</target>
        </trans-unit>
        <trans-unit id="1a68dc4a214d5a2f0c86986f5fcbb662600bbbaa" translate="yes" xml:space="preserve">
          <source>This only applies if the arithmetic is two's complement which is only required for the &lt;a href=&quot;../types/integer&quot;&gt;exact-width integer types&lt;/a&gt;. Note, however, that at the moment all platforms with a C++ compiler use two's complement arithmetic</source>
          <target state="translated">仅当算术运算是二进制补码时才适用，这仅对于&lt;a href=&quot;../types/integer&quot;&gt;精确宽度整数类型&lt;/a&gt;才需要。但是请注意，目前所有带有C ++编译器的平台都使用二进制补码算法</target>
        </trans-unit>
        <trans-unit id="28bba53040cc59e4ebfb5e6b23947d5f3e555523" translate="yes" xml:space="preserve">
          <source>This operation</source>
          <target state="translated">此操作</target>
        </trans-unit>
        <trans-unit id="ee376cb133ce3fa6134bf19377f3a3fc9a03d186" translate="yes" xml:space="preserve">
          <source>This operation is commonly implemented in hardware as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;fused multiply-add&lt;/a&gt; CPU instruction. If supported by hardware, the appropriate &lt;code&gt;FP_FAST_FMA*&lt;/code&gt; macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.</source>
          <target state="translated">此操作通常在硬件中实现为 &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;融合乘加&lt;/a&gt; CPU指令。如果硬件支持，则应该定义适当的 &lt;code&gt;FP_FAST_FMA*&lt;/code&gt; 宏，但是即使未定义宏，许多实现也会利用CPU指令。</target>
        </trans-unit>
        <trans-unit id="677f69ad7dd084269c9619b79f0d75fdd900458e" translate="yes" xml:space="preserve">
          <source>This operation is stable: for equivalent elements in the two lists, the elements from &lt;code&gt;*this&lt;/code&gt; shall always precede the elements from &lt;code&gt;other&lt;/code&gt;, and the order of equivalent elements of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; does not change.</source>
          <target state="translated">此操作是稳定的：对于两个列表中的等效元素， &lt;code&gt;*this&lt;/code&gt; 中的元素应始终在 &lt;code&gt;other&lt;/code&gt; 中的元素之前，以及*中等效元素的顺序 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 中不会改变。</target>
        </trans-unit>
        <trans-unit id="e1a54e7ed923b5cbda29b41bb3cef5210c3e3c16" translate="yes" xml:space="preserve">
          <source>This operator does not check whether the optional contains a value! You can do so manually by using &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;has_value()&lt;/a&gt;&lt;/code&gt; or simply &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;operator bool()&lt;/a&gt;&lt;/code&gt;. Alternatively, if checked access is needed, &lt;code&gt;&lt;a href=&quot;value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;value_or&quot;&gt;value_or()&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">该运算符不检查可选值是否包含值！您可以使用 &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;has_value()&lt;/a&gt;&lt;/code&gt; 或简单地通过 &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;operator bool()&lt;/a&gt;&lt;/code&gt; 手动进行操作。或者，如果需要检查的访问权限，则 &lt;code&gt;&lt;a href=&quot;value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;value_or&quot;&gt;value_or()&lt;/a&gt;&lt;/code&gt; 则可以使用 value_or（）。</target>
        </trans-unit>
        <trans-unit id="76837e505361cd0d1e62fe926fca10a41668aadc" translate="yes" xml:space="preserve">
          <source>This operator is declared in the namespace &lt;code&gt;std::literals::chrono_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;chrono_literals&lt;/code&gt; are inline namespaces. Access to this operator can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt;.</source>
          <target state="translated">此操作符在名称空间 &lt;code&gt;std::literals::chrono_literals&lt;/code&gt; ，其中 &lt;code&gt;literals&lt;/code&gt; 和 &lt;code&gt;chrono_literals&lt;/code&gt; 都是内联名称空间。可以 &lt;code&gt;using namespace std::literals&lt;/code&gt; ， &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt; 以及 &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt; 来访问此运算符。</target>
        </trans-unit>
        <trans-unit id="c90a4015c270f47b35bf150eaa6f8ff8b7041fe0" translate="yes" xml:space="preserve">
          <source>This operator makes it possible to use streams and functions that return references to streams as loop conditions, resulting in the idiomatic C++ input loops such as &lt;code&gt;while(stream &amp;gt;&amp;gt; value) {...}&lt;/code&gt; or &lt;code&gt;while(getline(stream, string)){...}&lt;/code&gt;. Such loops execute the loop's body only if the input operation succeeded.</source>
          <target state="translated">使用该运算符可以使用返回 &lt;code&gt;while(stream &amp;gt;&amp;gt; value) {...}&lt;/code&gt; 引用作为循环条件的流和函数，从而导致惯用的C ++输入循环，例如while（stream &amp;gt;&amp;gt; value）{...}或 &lt;code&gt;while(getline(stream, string)){...}&lt;/code&gt; 。仅当输入操作成功时，此类循环才执行循环的主体。</target>
        </trans-unit>
        <trans-unit id="70eb80993771f43d98c8f63a162d2abf81c3b412" translate="yes" xml:space="preserve">
          <source>This order determines the order in which constraints are instantiated when checking for satisfaction.</source>
          <target state="translated">这个顺序决定了检查满足度时约束条件实例化的顺序。</target>
        </trans-unit>
        <trans-unit id="ebf5e8fbc6ec56b576aeb159cdeac4bba0a41f70" translate="yes" xml:space="preserve">
          <source>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through &lt;code&gt;&lt;a href=&quot;../owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此顺序用于使共享和弱指针可以用作关联容器中的键，通常通过 &lt;code&gt;&lt;a href=&quot;../owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1a82251ba96a19d119ca9bfa58e9f2f497a9f62" translate="yes" xml:space="preserve">
          <source>This overload does not subtract the parsed offset (if any) from the parsed timestamp, unlike the &lt;code&gt;from_stream&lt;/code&gt; overloads for the &lt;code&gt;time_point&lt;/code&gt; of other clocks.</source>
          <target state="translated">与其他时钟的 &lt;code&gt;time_point&lt;/code&gt; 的 &lt;code&gt;from_stream&lt;/code&gt; 重载不同，此重载不会从已解析的时间戳中减去已解析的偏移量（如果有）。</target>
        </trans-unit>
        <trans-unit id="4bf7c4e2eb5387c99cb1a1ffeb6f0e5e88754a17" translate="yes" xml:space="preserve">
          <source>This overload doesn't participate in overload resolution if &lt;code&gt;std::unique_ptr&amp;lt;Y, Deleter&amp;gt;::pointer&lt;/code&gt; is not</source>
          <target state="translated">如果 &lt;code&gt;std::unique_ptr&amp;lt;Y, Deleter&amp;gt;::pointer&lt;/code&gt; 不是，则此重载不参与重载解析</target>
        </trans-unit>
        <trans-unit id="bc6f7584722885d728d6854cb8736855f9270a48" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (1) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 是整数类型，则此过载与过载（1）具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="1fa4602d949f8f6973ff6fea1f4b9e68fc722e4c" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (3) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 是整数类型，则此过载与过载（3）具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="7a8485de9a7d7bca2cd829541418ca26242baca3" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (6) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 是整数类型，则此过载与过载（6）具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="70e5d40a020e1e29942bf932764b7fdcf68a80bf" translate="yes" xml:space="preserve">
          <source>This overload is necessary because &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; does not have a member function &lt;code&gt;rbegin&lt;/code&gt;. No overload is needed for &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::crbegin&lt;/a&gt;&lt;/code&gt; because it is implemented in terms of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此重载是必要的，因为 &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 没有成员函数 &lt;code&gt;rbegin&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::crbegin&lt;/a&gt;&lt;/code&gt; 不需要重载，因为它是根据 &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ade89453e12ddb644d64137481026bf6616fd814" translate="yes" xml:space="preserve">
          <source>This overload is necessary because &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; does not have a member function &lt;code&gt;rend&lt;/code&gt;. No overload is needed for &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::crend&lt;/a&gt;&lt;/code&gt; because it is implemented in terms of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">此重载是必要的，因为 &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; 没有成员函数 &lt;code&gt;rend&lt;/code&gt; 。 &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::crend&lt;/a&gt;&lt;/code&gt; 不需要重载，因为它是根据 &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83116be95b91d59c09d4b41fc31292dca9c27808" translate="yes" xml:space="preserve">
          <source>This overload makes it possible to forward a result of an expression (such as function call), which may be rvalue or lvalue, as the original value category of a forwarding reference argument.</source>
          <target state="translated">这个重载使得转发一个表达式(如函数调用)的结果成为可能,这个表达式可能是rvalue或lvalue,作为转发引用参数的原始值类别。</target>
        </trans-unit>
        <trans-unit id="814368a4e79aa44fdd2b8a96b22ebf135a87ef17" translate="yes" xml:space="preserve">
          <source>This overload may be used to ignore spurious awakenings while waiting for a specific condition to become true.  Note that &lt;code&gt;lock&lt;/code&gt; must be acquired before entering this method, and it is reacquired after &lt;code&gt;wait(lock)&lt;/code&gt; exits, which means that &lt;code&gt;lock&lt;/code&gt; can be used to guard access to &lt;code&gt;pred()&lt;/code&gt;.</source>
          <target state="translated">在等待特定条件变为真时，可以使用此重载来忽略虚假唤醒。请注意，必须在进入此方法之前获取 &lt;code&gt;lock&lt;/code&gt; ，并且必须在 &lt;code&gt;wait(lock)&lt;/code&gt; 退出后重新获取锁，这意味着可以使用 &lt;code&gt;lock&lt;/code&gt; 来保护对 &lt;code&gt;pred()&lt;/code&gt; 的访问。</target>
        </trans-unit>
        <trans-unit id="7a8eb3282f5afae84e29833c36cc610e1de569a0" translate="yes" xml:space="preserve">
          <source>This overload may be used to ignore spurious wakeups.</source>
          <target state="translated">这种过载可以用来忽略虚假的唤醒。</target>
        </trans-unit>
        <trans-unit id="7c7c9be7921bc5aca3e14ee52c3bb2b260dbf024" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if</source>
          <target state="translated">只有在以下情况下,该过载才会参与过载解决。</target>
        </trans-unit>
        <trans-unit id="337c9fa9042558efca853cc7d8b71cfcdf68fa7c" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is not a pointer type. The program is ill-formed if this constructor is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 并且 &lt;code&gt;Deleter&lt;/code&gt; 不是指针类型时，此重载才参与重载解析。如果通过&lt;a href=&quot;../../language/deduction_guide&quot;&gt;类模板参数deduction&lt;/a&gt;选择了此构造方法，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="bdb1577a846fa638ef9c34146d7b837c8cfaff57" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;</source>
          <target state="translated">仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时,此重载才参与重载解析对所有 &lt;code&gt;i&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="a2aee11b4d79b3a5270ceef56a825350cf5c37c2" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Compare&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Compare&amp;gt;::value&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; ,则此重载仅参与重载解析。</target>
        </trans-unit>
        <trans-unit id="f2c027e2ce963431b11c8b99a81bfd995a2cc23b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时,此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="687473bac79368096aa9ed3ccf13fad71a9af81b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; 为true，则此重载仅参与重载解析。</target>
        </trans-unit>
        <trans-unit id="1224a3aab62459562f6b5317091c0ef8684c06e6" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; qualifies as &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, to avoid ambiguity with the overload (3).</source>
          <target state="translated">如果 &lt;code&gt;InputIt&lt;/code&gt; 符合以下条件，则此重载仅参与重载解决方案：&lt;a href=&quot;../../named_req/inputiterator&quot;&gt; LegacyInputIterator时&lt;/a&gt;，，以避免与重载（3）产生歧义。</target>
        </trans-unit>
        <trans-unit id="4a089419777f0efe565129e644b4712117969f47" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; qualifies as an &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;InputIt&lt;/code&gt; 符合LegacyInputIterator资格时，此重载才参与重载解决&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;方案&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a09d792b815aa7158d605c39a17d568db1e73837" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, to avoid ambiguity with the overload (2).</source>
          <target state="translated">仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator时&lt;/a&gt;，此重载才参与重载解析，以避免与重载（2）产生歧义。</target>
        </trans-unit>
        <trans-unit id="f321cae2fd6e4fe1eb7c60fdcbc221e29351732f" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;InputIt&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator时，&lt;/a&gt;此重载才参与重载解析。</target>
        </trans-unit>
        <trans-unit id="84fbda8e9476b834f4eff0a23e019d728cbe538b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;N == 0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;N == 0&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; 为N，则此重载仅参与重载解决方案。 &lt;code&gt;true&lt;/code&gt; 时,。</target>
        </trans-unit>
        <trans-unit id="5843b6cae5eeb5b966317747e078206da1c4f50c" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is an unsigned integer type (that is, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, or an extended unsigned integer type).</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是无符号整数类型（即， &lt;code&gt;unsigned char&lt;/code&gt; ， &lt;code&gt;unsigned short&lt;/code&gt; ， &lt;code&gt;unsigned int&lt;/code&gt; ， &lt;code&gt;unsigned long&lt;/code&gt; ， &lt;code&gt;unsigned long long&lt;/code&gt; )，则此重载仅参与重载解析。或扩展的unsigned integer类型）。</target>
        </trans-unit>
        <trans-unit id="c6e60dbde6c8fbc3507ef1d94ecfd0c08c022a59" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;U&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 则此重载仅参与重载解析。</target>
        </trans-unit>
        <trans-unit id="29384bbe452ccd42b0340a2c398a159c418dc484" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;is_move_constructible_v&amp;lt;T_i&amp;gt;&lt;/code&gt; and &lt;code&gt;is_swappable_v&amp;lt;T_i&amp;gt;&lt;/code&gt; are both true for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;is_move_constructible_v&amp;lt;T_i&amp;gt;&lt;/code&gt; 和 &lt;code&gt;is_swappable_v&amp;lt;T_i&amp;gt;&lt;/code&gt; 对于所有 &lt;code&gt;T_i&lt;/code&gt; 均为true，则此重载仅参与重载解决方案在 &lt;code&gt;Types...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc0ee950915984baafe9981e2de7fbbd58afb03e" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;os &amp;lt;&amp;lt; p.get()&lt;/code&gt; is a valid expression.</source>
          <target state="translated">仅当 &lt;code&gt;os &amp;lt;&amp;lt; p.get()&lt;/code&gt; 此重载才参与重载解析是有效表达式时，。</target>
        </trans-unit>
        <trans-unit id="213ea4feb3d364f895c517e5bb074dd31d585156" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof(To) == sizeof(From)&lt;/code&gt; and both &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt; are &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types.</source>
          <target state="translated">仅当 &lt;code&gt;sizeof(To) == sizeof(From)&lt;/code&gt; 且 &lt;code&gt;To&lt;/code&gt; 和 &lt;code&gt;From&lt;/code&gt; 都是&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable时，&lt;/a&gt;此重载才参与重载解析类型时，。</target>
        </trans-unit>
        <trans-unit id="114c800d36b0c72a9adfc7fc9888fa4bbb2bb7e2" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; 并且 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; 对所有 &lt;code&gt;i&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，此重载才参与重载解析。。</target>
        </trans-unit>
        <trans-unit id="47f721ed5d5ad88fd42fa2395ca7086485e17473" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">仅当 &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; 并且 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 都为重载时，此重载才参与重载解析 &lt;code&gt;true&lt;/code&gt; 时</target>
        </trans-unit>
        <trans-unit id="2f1425caf63dd41a44a75daddc54c5b669d9e819" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0,const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">仅当 &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; 并且 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0,const U1&amp;amp;&amp;gt;::value&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; 都为重载时，此重载才参与重载解析 &lt;code&gt;true&lt;/code&gt; 时</target>
        </trans-unit>
        <trans-unit id="db813f0c83ff1627df30808c046963cca19b044a" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; and &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; 和 &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; 并且 &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，此重载才参与重载解析 &lt;code&gt;i&lt;/code&gt; 所有的。</target>
        </trans-unit>
        <trans-unit id="bfc7e8a0241026e6c0b8875fd31fd121edcd01be" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;typename Duration::rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Duration(1) &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(1)&lt;/code&gt;.</source>
          <target state="translated">仅当 &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;typename Duration::rep&amp;gt;&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 并且 &lt;code&gt;Duration(1) &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(1)&lt;/code&gt; &lt;a href=&quot;../duration&quot;&gt;std :: chrono :: days&lt;/a&gt;（1）时，此重载才参与重载解析。。</target>
        </trans-unit>
        <trans-unit id="bea87dfd18560dbaabd48c593a450285fb991964" translate="yes" xml:space="preserve">
          <source>This page describes the core language feature adopted for C++20. For named type requirements used in the specification of the standard library, see &lt;a href=&quot;../named_req&quot;&gt;named requirements&lt;/a&gt;. For the Concepts TS version of this feature, see &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">本页描述了C ++ 20所采用的核心语言功能。有关标准库规范中使用的命名类型需求，请参见&lt;a href=&quot;../named_req&quot;&gt;命名需求&lt;/a&gt;。有关此功能的Concepts TS版本，请参见&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;此处&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88455b072941af9e8a59177f52c213a26676d97c" translate="yes" xml:space="preserve">
          <source>This partial code fragment illustrates how &lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; can be used to avoid accessing data that depends on thread locals while those thread locals are in the process of being destructed:</source>
          <target state="translated">此部分代码片段说明了如何使用 &lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; 来避免在那些线程局部变量正在被销毁的过程中访问依赖于线程局部变量的数据：</target>
        </trans-unit>
        <trans-unit id="7c5fecf341fbcf23eb1c8bab2cc52b3d4ac7b65d" translate="yes" xml:space="preserve">
          <source>This problem may be worked around using init-statement:</source>
          <target state="translated">这个问题可以用init-statement来解决。</target>
        </trans-unit>
        <trans-unit id="6fb590b83ec483a8b56a2365c3f69fb2ed4d882e" translate="yes" xml:space="preserve">
          <source>This process is called</source>
          <target state="translated">这个过程被称为</target>
        </trans-unit>
        <trans-unit id="a7c693f3363fc29f57e0a818f5fcc2fa68ec620d" translate="yes" xml:space="preserve">
          <source>This program determines the longest substring that is simultaneously found at the very beginning of the given string and at the very end of it, in reverse order (possibly overlapping).</source>
          <target state="translated">这个程序确定同时在给定字符串的开头和结尾处找到的最长子串,顺序相反(可能重叠)。</target>
        </trans-unit>
        <trans-unit id="eafef78a966daecd6d7bcd73bf31b0e1e5ad496e" translate="yes" xml:space="preserve">
          <source>This program simulates throwing 6-sided dice.</source>
          <target state="translated">这个程序模拟投掷6面骰子。</target>
        </trans-unit>
        <trans-unit id="2ea85151fe97fd5e5b0aa44d16e405ebe318a32c" translate="yes" xml:space="preserve">
          <source>This protected virtual function is called by the public functions &lt;a href=&quot;../basic_streambuf/sungetc&quot;&gt;&lt;code&gt;basic_streambuf::sungetc&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_streambuf/sputbackc&quot;&gt;&lt;code&gt;basic_streambuf::sputbackc&lt;/code&gt;&lt;/a&gt; (which, in turn, are called by &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">此受保护的虚拟函数由公共函数&lt;a href=&quot;../basic_streambuf/sungetc&quot;&gt; &lt;code&gt;basic_streambuf::sungetc&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../basic_streambuf/sputbackc&quot;&gt; &lt;code&gt;basic_streambuf::sputbackc&lt;/code&gt; &lt;/a&gt;（而后者又由&lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt;调用）。</target>
        </trans-unit>
        <trans-unit id="996fa56c79f2b555734e9e9593669a195ee9fc8b" translate="yes" xml:space="preserve">
          <source>This protected virtual function is called by the public functions &lt;code&gt;&lt;a href=&quot;sungetc&quot;&gt;sungetc()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sputbackc&quot;&gt;sputbackc()&lt;/a&gt;&lt;/code&gt; (which, in turn, are called by &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt;) when either:</source>
          <target state="translated">该受保护的虚拟函数由以下公共函数 &lt;code&gt;&lt;a href=&quot;sungetc&quot;&gt;sungetc()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;sputbackc&quot;&gt;sputbackc()&lt;/a&gt;&lt;/code&gt; （依次由&lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt;调用）调用：</target>
        </trans-unit>
        <trans-unit id="01f04b9a6bf8f295e5a70f9d8714851ba0b2aba1" translate="yes" xml:space="preserve">
          <source>This regenerates the hash table.</source>
          <target state="translated">这将重新生成哈希表。</target>
        </trans-unit>
        <trans-unit id="2062b86cfcefc181f616f82dcb480679b9c947da" translate="yes" xml:space="preserve">
          <source>This rule also appears in the C++ Core Guidelines as &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero&quot;&gt;C.20: If you can avoid defining default operations, do&lt;/a&gt;.</source>
          <target state="translated">此规则在C ++核心准则中也显示为&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero&quot;&gt;C.20：如果可以避免定义默认操作，请执行&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4ac284d6084ae4faac12c7c88cba2efd5c565f23" translate="yes" xml:space="preserve">
          <source>This rule applies during overload resolution of function templates: When &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;substituting&lt;/a&gt; the explicitly specified or &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced type&lt;/a&gt; for the template parameter fails, the specialization is discarded from the &lt;a href=&quot;overload_resolution&quot;&gt;overload set&lt;/a&gt; instead of causing a compile error.</source>
          <target state="translated">此规则在函数模板的重载解析期间适用：当&lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;用&lt;/a&gt;显式指定的或&lt;a href=&quot;template_argument_deduction&quot;&gt;推导的类型&lt;/a&gt;替换 template参数失败时，将从&lt;a href=&quot;overload_resolution&quot;&gt;重载集中&lt;/a&gt;放弃专业化而不会引起编译错误。</target>
        </trans-unit>
        <trans-unit id="d7cbe3e2801d332154dbf0acb579c831d5324d92" translate="yes" xml:space="preserve">
          <source>This rule enables type-based alias analysis, in which a compiler assumes that the value read through a glvalue of one type is not modified by a write to a glvalue of a different type (subject to the exceptions noted above).</source>
          <target state="translated">这条规则实现了基于类型的别名分析,在这种情况下,编译器假定通过一种类型的glvalue读出的值不会被写到另一种类型的glvalue所修改(除了上面提到的例外情况)。</target>
        </trans-unit>
        <trans-unit id="0ed01ea49dcd8fc7a8834c7e1f6f57d09b9ceaaf" translate="yes" xml:space="preserve">
          <source>This section provides definitions for the specific terminology and the concepts used when describing the C++ programming language.</source>
          <target state="translated">本节提供了描述C++编程语言时使用的特定术语和概念的定义。</target>
        </trans-unit>
        <trans-unit id="28ad28e60d5a5cc2b8a106dc95cfe732a7105f9e" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informs other library components that all objects of type &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; support</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; 这种专业化通知其他库组件所有类型为 &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; 对象都受支持</target>
        </trans-unit>
        <trans-unit id="8c6b990eab9edf93292f6979537f3edb00a094bd" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; informs other library components that values of type &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&lt;/code&gt; are enumerations that hold error codes, which makes them implicitly convertible and assignable to objects of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; 这种专业化通知其他库组件， &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&lt;/code&gt; 类型的值是包含错误代码的枚举，这使得它们可以隐式转换和分配给 &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 类型的对象。</target>
        </trans-unit>
        <trans-unit id="bdc8c9de3fc6d0e6ce5408d37d8e773fda6b9547" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informs other library components that tuples support</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; 这种专业化会通知其他元组支持的库组件</target>
        </trans-unit>
        <trans-unit id="038a0d1d441b9b41c30e5117e6ae3ac1df058c8d" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; encapsulates character classification features for type &lt;code&gt;char&lt;/code&gt;. Unlike general-purpose &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt;, which uses virtual functions, this specialization uses table lookup to classify characters (which is generally faster).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 这种专业化封装了 &lt;code&gt;char&lt;/code&gt; 类型的字符分类功能。与使用虚函数的通用 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 不同，此专业使用表查找来对字符进行分类（通常更快）。</target>
        </trans-unit>
        <trans-unit id="fe9803ffee86bd599903f2123e0bb2aa07aae79a" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; encapsulates character classification features for type &lt;code&gt;char&lt;/code&gt;. Like its base class &lt;code&gt;std::ctype&amp;lt;char&amp;gt;&lt;/code&gt; and unlike general-purpose &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt;, table lookup is used to classify characters.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; 这种专业化封装了 &lt;code&gt;char&lt;/code&gt; 类型的字符分类功能。与其基类 &lt;code&gt;std::ctype&amp;lt;char&amp;gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; ，并且与通用std :: ctype_byname不同，表查找用于对字符进行分类。</target>
        </trans-unit>
        <trans-unit id="3ddf81e9b15f2fdf0bb22d822a3952f3ead8b84b" translate="yes" xml:space="preserve">
          <source>This specification may appear only on lambda-declarator or on a function declarator that is the top-level(until C++17) declarator of a function, variable, or non-static data member, whose type is a function type, a pointer to function type, a reference to function type, a pointer to member function type. It may appear on the declarator of a parameter or on the declarator of a return type.</source>
          <target state="translated">这个规范只能出现在lambda-declarator上,或者出现在函数声明器上,它是函数、变量或非静态数据成员的顶层(直到C++17)声明器,其类型是函数类型、函数类型指针、函数类型引用、成员函数类型指针。它可以出现在参数的声明符上,也可以出现在返回类型的声明符上。</target>
        </trans-unit>
        <trans-unit id="95164148c00adc35d63c91ae48d3bfe549e3eabc" translate="yes" xml:space="preserve">
          <source>This swap function is protected: it is called by the swap member functions of the derived stream classes such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">此交换函数受保护：它由派生流类的交换成员函数调用，例如 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; ，它们知道如何正确交换关联的。</target>
        </trans-unit>
        <trans-unit id="203ee242898fb95403122a811df27a6f5e11668f" translate="yes" xml:space="preserve">
          <source>This syntax for variadic arguments was introduced in 1983 C++ without the comma before the ellipsis. When C89 adopted function prototypes from C++, it replaced the syntax with one requiring the comma. For compatibility, C++98 accepts both C++-style &lt;code&gt;f(int n...)&lt;/code&gt; and C-style &lt;code&gt;f(int n, ...)&lt;/code&gt;.</source>
          <target state="translated">可变参量的语法是在1983 C ++中引入的，省略号前没有逗号。当C89采用C ++的函数原型时，它用需要逗号的语法代替了语法。为了兼容性，C ++ 98接受C ++样式 &lt;code&gt;f(int n...)&lt;/code&gt; 和C样式 &lt;code&gt;f(int n, ...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="90ab5c64e037f5bd0606d3f5a893f7a9a8254324" translate="yes" xml:space="preserve">
          <source>This technical specification is supported by GCC as of version 6.1 (requires &lt;code&gt;-fgnu-tm&lt;/code&gt; to enable). An older variant of this specification was &lt;a href=&quot;http://www-users.cs.umn.edu/~boutcher/stm/&quot;&gt;supported in GCC&lt;/a&gt; as of 4.7.</source>
          <target state="translated">从6.1版开始，GCC支持该技术规范（需要启用 &lt;code&gt;-fgnu-tm&lt;/code&gt; ）。&lt;a href=&quot;http://www-users.cs.umn.edu/~boutcher/stm/&quot;&gt;GCC支持&lt;/a&gt;此规范的较旧版本从4.7开始。</target>
        </trans-unit>
        <trans-unit id="419df6ad5807d184b62cd3a9400a351c6d85612c" translate="yes" xml:space="preserve">
          <source>This technique is used to construct C++ library interfaces with stable ABI and to reduce compile-time dependencies.</source>
          <target state="translated">该技术用于构建具有稳定ABI的C++库接口,减少编译时的依赖性。</target>
        </trans-unit>
        <trans-unit id="a685713d9d750fdc943f666575768010c6772551" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">该模板可以专门用于用户定义的类型 &lt;code&gt;T&lt;/code&gt; ,以实现&lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt;与</target>
        </trans-unit>
        <trans-unit id="25830dd69fe1f966afb7508601b149f9651d15fd" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type to indicate that the type is eligible for &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">该模板可能专用于用户定义的类型，以指示该类型符合 &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 自动转换的条件。</target>
        </trans-unit>
        <trans-unit id="921636ccd7ae628df6b1d450ba1978e54fd38c56" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type to indicate that the type is eligible for &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">该模板可以专门用于用户定义的类型，以指示该类型符合 &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 自动转换的条件。</target>
        </trans-unit>
        <trans-unit id="f8d9894e4d5b931e86a98ac460a720072feb42c9" translate="yes" xml:space="preserve">
          <source>This trait does not check anything outside the immediate context of the assignment expression: if the use of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual assignment may not compile even if &lt;code&gt;std::is_assignable&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compiles and evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">此特征不会检查赋值表达式的直接上下文之外的任何内容：如果使用 &lt;code&gt;T&lt;/code&gt; 或 &lt;code&gt;U&lt;/code&gt; 会触发模板专门化，隐式定义的特殊成员函数的生成等，并且这些函数有错误，则即使编译实际赋值也可能无法编译 &lt;code&gt;std::is_assignable&amp;lt;T,U&amp;gt;::value&lt;/code&gt; 编译并评估为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb8840cec417013032e8555b42ffbfcba15618b0" translate="yes" xml:space="preserve">
          <source>This trait does not check anything outside the immediate context of the swap expressions: if the use of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual swap may not compile even if &lt;code&gt;std::is_swappable_with&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compiles and evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">此特征不检查交换表达式的直接上下文之外的任何内容：如果使用 &lt;code&gt;T&lt;/code&gt; 或 &lt;code&gt;U&lt;/code&gt; 会触发模板专门化，隐式定义的特殊成员函数的生成等，并且这些函数有错误，则即使发生交换，实际交换也可能无法编译 &lt;code&gt;std::is_swappable_with&amp;lt;T,U&amp;gt;::value&lt;/code&gt; 编译并评估为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98c54288dcf9d77d236eeecd6daa6884dc0b5970" translate="yes" xml:space="preserve">
          <source>This trait was introduced to make it possible to determine whether a type can be correctly hashed by hashing its object representation as a byte array.</source>
          <target state="translated">引入这个特性的目的是为了通过将一个类型的对象表示为字节数组进行散列,从而确定该类型是否可以正确地进行散列。</target>
        </trans-unit>
        <trans-unit id="aea90bedb8f6381211ab3408991531636fb5ffc1" translate="yes" xml:space="preserve">
          <source>This type can be specialized if the representation &lt;code&gt;Rep&lt;/code&gt; requires a specific implementation to return these duration objects.</source>
          <target state="translated">如果表示形式 &lt;code&gt;Rep&lt;/code&gt; 需要特定的实现来返回这些工期对象，则此类型可以是专用的。</target>
        </trans-unit>
        <trans-unit id="0087c0a1dcbf0b0f0625fe12349f4e248d5e9491" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the &lt;a href=&quot;copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;copy_file&quot;&gt;&lt;code&gt;copy_file()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">此类型表示控制&lt;a href=&quot;copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt;行为的可用选项和&lt;a href=&quot;copy_file&quot;&gt; &lt;code&gt;copy_file()&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="9e417e5db45320da2073da483bb3a5847a750f26" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the &lt;a href=&quot;directory_iterator&quot;&gt;&lt;code&gt;directory_iterator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recursive_directory_iterator&quot;&gt;&lt;code&gt;recursive_directory_iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型表示控制&lt;a href=&quot;directory_iterator&quot;&gt; &lt;code&gt;directory_iterator&lt;/code&gt; &lt;/a&gt;行为的可用选项和&lt;a href=&quot;recursive_directory_iterator&quot;&gt; &lt;code&gt;recursive_directory_iterator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ed15c087ab4da8efef6f8cef5da62d8cc51d1d4d" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the function &lt;a href=&quot;permissions&quot;&gt;&lt;code&gt;permissions()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">此类型表示控制功能行为的可用选项 &lt;a href=&quot;permissions&quot;&gt; &lt;code&gt;permissions()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="19b6990a7534cc1c45af33110b91b0350924b0e8" translate="yes" xml:space="preserve">
          <source>This type represents file access permissions. &lt;code&gt;perms&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type).</source>
          <target state="translated">此类型表示文件访问权限。 &lt;code&gt;perms&lt;/code&gt; 满足&lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;的要求（这意味着按位运算符 &lt;code&gt;operator&amp;amp;&lt;/code&gt; ， &lt;code&gt;operator|&lt;/code&gt; ， &lt;code&gt;operator^&lt;/code&gt; ， &lt;code&gt;operator~&lt;/code&gt; ， &lt;code&gt;operator&amp;amp;=&lt;/code&gt; ， &lt;code&gt;operator|=&lt;/code&gt; 为此类型定义和 &lt;code&gt;operator^=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="157a64e0ec4c85a12b01b53324ef0dcdfb157238" translate="yes" xml:space="preserve">
          <source>This type requirement is deprecated in the C++ standard. All of its uses have been replaced by the more refined type requirements, such as &lt;a href=&quot;trivialtype&quot;&gt;TrivialType&lt;/a&gt;.</source>
          <target state="translated">在C ++标准中不赞成使用此类型要求。它的所有用途已被更精细的类型要求所取代，例如&lt;a href=&quot;trivialtype&quot;&gt; TrivialType）取代&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="23b4cbf67168a660a04e5a36fcd5bf13a48ffa59" translate="yes" xml:space="preserve">
          <source>This type trait is used by &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;. It may also be used by custom allocators or wrapper types to determine whether the object or member being constructed is itself capable of using an allocator (e.g. is a container), in which case an allocator should be passed to its constructor.</source>
          <target state="translated">此类型特征由 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt; 。定制分配器或包装器类型也可以使用它来确定所构造的对象或成员本身是否能够使用分配器（例如，是容器），在这种情况下，应将分配器传递给其构造函数。</target>
        </trans-unit>
        <trans-unit id="99d2afd28d674bc31d956763a004b7cd9b730d51" translate="yes" xml:space="preserve">
          <source>This type trait may be specialized for user-provided types that may be used as iterators. The standard library provides two partial specializations for pointer types T*, which makes it possible to use all iterator-based algorithms with raw pointers.</source>
          <target state="translated">这个类型特征可以对用户提供的可用作迭代器的类型进行特殊化。标准库为指针类型T*提供了两个部分特化,这使得使用原始指针的所有基于迭代器的算法成为可能。</target>
        </trans-unit>
        <trans-unit id="c5c25f5c1d60bf97a090f5b80fe5a2c0ab183ce7" translate="yes" xml:space="preserve">
          <source>This type trait predates the &lt;a href=&quot;../language/alignof&quot;&gt;alignof keyword&lt;/a&gt;, which can be used to obtain the same value with less verbosity.</source>
          <target state="translated">这种类型特征早于 &lt;a href=&quot;../language/alignof&quot;&gt; alignof关键字&lt;/a&gt;，该关键字可用于以较少的冗长程度获得相同的值。</target>
        </trans-unit>
        <trans-unit id="e0410ce23d7ebcff7e3be952fdf86650da4cb323" translate="yes" xml:space="preserve">
          <source>This value typically reflects the theoretical limit on the size of the container, at most &lt;code&gt;std::numeric_limits&amp;lt;difference_type&amp;gt;::max()&lt;/code&gt;. At runtime, the size of the container may be limited to a value smaller than &lt;code&gt;max_size()&lt;/code&gt; by the amount of RAM available.</source>
          <target state="translated">该值通常反映容器大小的理论极限，最多为 &lt;code&gt;std::numeric_limits&amp;lt;difference_type&amp;gt;::max()&lt;/code&gt; 。在运行时，容器的大小可能会被限制为小于可用内存的 &lt;code&gt;max_size()&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="277c3ad089ba0f3cf12d3db7126822c9d80a4896" translate="yes" xml:space="preserve">
          <source>This variable has block scope and static storage duration:</source>
          <target state="translated">该变量具有块范围和静态存储时间。</target>
        </trans-unit>
        <trans-unit id="fae180c729e28c3be7b371f92b90451d0013d47d" translate="yes" xml:space="preserve">
          <source>Those data members that correspond to captures without initializers are &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; when the lambda-expression is evaluated. Those that correspond to captures with initializers are initialized as the initializer requires (could be copy- or direct-initialization). If an array is captured, array elements are direct-initialized in increasing index order. The order in which the data members are initialized is the order in which they are declared (which is unspecified).</source>
          <target state="translated">在评估lambda表达式时，将&lt;a href=&quot;direct_initialization&quot;&gt;直接初始化&lt;/a&gt;那些与没有初始化程序的捕获相对应的数据成员。与初始化程序捕获相对应的捕获程序将按照初始化程序的要求进行初始化（可以是复制初始化或直接初始化）。如果捕获了数组，则数组元素将以递增的索引顺序直接初始化。初始化数据成员的顺序是声明它们的顺序（未指定）。</target>
        </trans-unit>
        <trans-unit id="f4a567a9b52d0caa922bc0235781e01fdf5d4c89" translate="yes" xml:space="preserve">
          <source>Thousands separator and decimal point characters are inserted as required by &lt;code&gt;mp.grouping()&lt;/code&gt;, &lt;code&gt;mp.frac_digits()&lt;/code&gt;, &lt;code&gt;mp.decimal_point()&lt;/code&gt;, and &lt;code&gt;mp.thousands_sep()&lt;/code&gt;, and the resulting string is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;value&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">根据 &lt;code&gt;mp.grouping()&lt;/code&gt; ， &lt;code&gt;mp.frac_digits()&lt;/code&gt; ， &lt;code&gt;mp.decimal_point()&lt;/code&gt; 和 &lt;code&gt;mp.thousands_sep()&lt;/code&gt; 的要求，插入千位分隔符和小数点字符，并将结果字符串放置在输出序列中，其中 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;value&lt;/a&gt;&lt;/code&gt; 显示在格式化模式。</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="translated">螺纹安全</target>
        </trans-unit>
        <trans-unit id="604ac3e54d45a1053374b3b32afdb7b25fbf1ed4" translate="yes" xml:space="preserve">
          <source>Thread support</source>
          <target state="translated">线程支持</target>
        </trans-unit>
        <trans-unit id="e2d8ff11421f3eaf1af17a9be19957f5569bce89" translate="yes" xml:space="preserve">
          <source>Thread support library</source>
          <target state="translated">线程支持库</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e7a80c12335015336479b7097a8b8db3ed660872" translate="yes" xml:space="preserve">
          <source>Threads and data races</source>
          <target state="translated">线程和数据竞赛</target>
        </trans-unit>
        <trans-unit id="c1492359cb9886c9909e1a4316a9b1847c65e9e9" translate="yes" xml:space="preserve">
          <source>Threads begin execution immediately upon construction of the associated thread object (pending any OS scheduling delays), starting at the top-level function provided as a &lt;a href=&quot;thread/thread&quot;&gt;constructor argument&lt;/a&gt;. The return value of the top-level function is ignored and if it terminates by throwing an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. The top-level function may communicate its return value or an exception to the caller via &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or by modifying shared variables (which may require synchronization, see &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">线程在构造关联的线程对象（等待任何OS调度延迟）后立即开始执行，从作为&lt;a href=&quot;thread/thread&quot;&gt;构造函数参数&lt;/a&gt;提供的顶级函数开始。顶级函数的返回值将被忽略，如果它通过引发异常终止，则将调用 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。顶层函数可以通过 &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 或通过修改共享变量（可能需要同步，请参见 &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f4eb730a2ea2fcff234ce55322a48d3d91657b7e" translate="yes" xml:space="preserve">
          <source>Threads enable programs to execute across several processor cores.</source>
          <target state="translated">线程使程序能够跨多个处理器内核执行。</target>
        </trans-unit>
        <trans-unit id="a246e49f5181769dcbe8963551805985ea8e8c89" translate="yes" xml:space="preserve">
          <source>Three conditions where &lt;code&gt;std::bad_array_new_length&lt;/code&gt; should be thrown:</source>
          <target state="translated">三个条件在哪里 &lt;code&gt;std::bad_array_new_length&lt;/code&gt; 应该抛出std :: bad_array_new_length的：</target>
        </trans-unit>
        <trans-unit id="b9e36378830759894e6fe278bd9aa261b8ff8830" translate="yes" xml:space="preserve">
          <source>Three-way comparison</source>
          <target state="translated">三方比较</target>
        </trans-unit>
        <trans-unit id="762d1a20f1e0eccc439b6c76140f77d0e64ffbd4" translate="yes" xml:space="preserve">
          <source>Three-way comparison can be automatically generated for class types, see &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt;.</source>
          <target state="translated">可以自动生成类类型的三向比较，请参见 &lt;a href=&quot;default_comparisons&quot;&gt;默认比较&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="89dc893d701abc8f17f1b70a529a23fb35201ff0" translate="yes" xml:space="preserve">
          <source>Throughout the standard library, bitwise shift operators are commonly overloaded with I/O stream (&lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&amp;amp;&lt;/code&gt; or one of the classes derived from it) as both the left operand and return type. Such operators are known as</source>
          <target state="translated">在整个标准库中，按位移位运算符通常会因I / O流（ &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&amp;amp;&lt;/code&gt; 或从其派生的类之一）作为左操作数和返回类型。这样的运算符称为</target>
        </trans-unit>
        <trans-unit id="f13c54f785e2da5ceb32427977752efac6c1f5cc" translate="yes" xml:space="preserve">
          <source>Throw any exception thrown by the currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">抛出当前安装的 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; 引发的任何异常。</target>
        </trans-unit>
        <trans-unit id="0ab6516c23d4a4cf955f60f3139340567e17455c" translate="yes" xml:space="preserve">
          <source>Throwing an exception is used to signal errors from functions, where &quot;errors&quot; are typically limited to only the following&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;exceptions#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;exceptions#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;exceptions#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;:</source>
          <target state="translated">引发异常用于从功能中发出错误，其中&amp;ldquo;错误&amp;rdquo;通常仅限于以下&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;exceptions#cite_note-1&quot;&gt;[1] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;exceptions#cite_note-2&quot;&gt;[2] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;exceptions#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;：</target>
        </trans-unit>
        <trans-unit id="7c890cb1e360c745fea29256ca1365d6a4c1baf1" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;n &amp;gt; SIZE_MAX / sizeof(T)&lt;/code&gt;; may also any exceptions thrown by the call to &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;n &amp;gt; SIZE_MAX / sizeof(T)&lt;/code&gt; 则抛出 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; ; 可能还会调用引发任何异常 &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef7207c238414b15063664465aad815055211c96" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;new_cap&lt;/code&gt; 大于 &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; ,则抛出 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31e238d5140b17c25d7cced51cc7d8f65270714a" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if the length of the constructed string would exceed &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; (for example, if &lt;code&gt;count &amp;gt; max_size()&lt;/code&gt; for (2)). Calls to &lt;code&gt;Allocator::allocate&lt;/code&gt; may throw.</source>
          <target state="translated">如果构造的字符串的长度超过 &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; ，则抛出 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; （例如，如果（2）的 &lt;code&gt;count &amp;gt; max_size()&lt;/code&gt; ））。调用 &lt;code&gt;Allocator::allocate&lt;/code&gt; 可能会引发。</target>
        </trans-unit>
        <trans-unit id="5bd5e3a71ffb663ec4af5da4ee91146199c73db9" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt; 则抛出 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0988508382bdadbf64519b871fd4199f1f7e88db" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; if no such &lt;code&gt;time_zone&lt;/code&gt; can be found.</source>
          <target state="translated">如果找不到这样的 &lt;code&gt;time_zone&lt;/code&gt; ,则抛出 &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b00d37fc6c817e49da501c1d4283379499ed17c" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; when errors occur, including errors from the underlying operating system that would prevent &lt;code&gt;lock&lt;/code&gt; from meeting its specifications. The mutex is not locked in the case of any exception being thrown.</source>
          <target state="translated">发生错误时引发 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; ，包括来自底层操作系统的错误，这些错误会阻止 &lt;code&gt;lock&lt;/code&gt; 满足其规范。如果抛出任何异常，则互斥锁不会被锁定。</target>
        </trans-unit>
        <trans-unit id="442b654cd69e928843823a7f4be327a06a469dea" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with error condition &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; if the launch policy equals &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and the implementation is unable to start a new thread (if the policy is &lt;code&gt;async|deferred&lt;/code&gt; or has additional bits set, it will fall back to deferred or the implementation-defined policies in this case), or &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory for the internal data structures could not be allocated.</source>
          <target state="translated">如果启动策略等于 &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; 并且实现无法启动新线程（如果策略为 &lt;code&gt;async|deferred&lt;/code&gt; 或设置了其他位），则抛出 &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 且错误条件为 &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; ，如果无法分配用于内部数据结构的内存，则在这种情况下将返回到延迟策略或实现定义的策略）或 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7fd45fe2a76b5c26edcf480fd318099061d96452" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; throws.</source>
          <target state="translated">如果 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 抛出 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="61e7abab0e5d103b8f9ee327388ae0a478e7343f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if allocation fails.</source>
          <target state="translated">如果分配失败，则抛出 &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="610b978856ae75c3eef4b6f3051d9b89a88b02ba" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; if any variant in &lt;code&gt;vars&lt;/code&gt; is &lt;a href=&quot;valueless_by_exception&quot;&gt;&lt;code&gt;valueless_by_exception&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">抛出 &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; 如果任何变种 &lt;code&gt;vars&lt;/code&gt; 是&lt;a href=&quot;valueless_by_exception&quot;&gt; &lt;code&gt;valueless_by_exception&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2ccf84cf2370a76be5d96fc6954ac7aa274274a8" translate="yes" xml:space="preserve">
          <source>Throws an exception if storage of the requested size and alignment cannot be obtained.</source>
          <target state="translated">如果不能获得所要求的大小和对齐方式的存储,则抛出异常。</target>
        </trans-unit>
        <trans-unit id="78d4655bb8c331d30d35c5dca21382a3023d8907" translate="yes" xml:space="preserve">
          <source>Throws an implementation-defined exception derived from &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; if a random number could not be generated.</source>
          <target state="translated">如果无法生成随机数，则抛出从 &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; exception派生的实现定义的异常。</target>
        </trans-unit>
        <trans-unit id="c71eb890289859862d506be6577481a6155d7187" translate="yes" xml:space="preserve">
          <source>Throws an implementation-defined exceptions derived from &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">在失败时引发从 &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; 派生的实现定义的异常。</target>
        </trans-unit>
        <trans-unit id="7035dd91c99b009a7736d3114cd02d3205a59146" translate="yes" xml:space="preserve">
          <source>Throws any exception thrown by &lt;code&gt;T&lt;/code&gt;'s constructor. If an exception is thrown, the previously contained object (if any) has been destroyed, and &lt;code&gt;*this&lt;/code&gt; does not contain a value.</source>
          <target state="translated">引发 &lt;code&gt;T&lt;/code&gt; 的构造函数引发的任何异常。如果抛出异常，则先前包含的对象（如果有）已被破坏，并且 &lt;code&gt;*this&lt;/code&gt; 不包含值。</target>
        </trans-unit>
        <trans-unit id="c4b5347955a68d7b49fb60df96bc4c1fe1be392e" translate="yes" xml:space="preserve">
          <source>Throws any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">抛出 &lt;code&gt;T&lt;/code&gt; 的构造函数引发的任何异常。</target>
        </trans-unit>
        <trans-unit id="62b00b9bd5afe726c1c402b63375bc4866d56f7c" translate="yes" xml:space="preserve">
          <source>Throws no exceptions, unless the construction of &lt;code&gt;fd&lt;/code&gt; throws.</source>
          <target state="translated">除非构造 &lt;code&gt;fd&lt;/code&gt; 抛出异常，否则不会抛出异常。</target>
        </trans-unit>
        <trans-unit id="2e4fed0e085b765b71b25a3a55fd75c68b497a32" translate="yes" xml:space="preserve">
          <source>Throws no exceptions.</source>
          <target state="translated">不抛出例外情况。</target>
        </trans-unit>
        <trans-unit id="c77dbbe1f17eaa70afe33271369b7e39a68c956a" translate="yes" xml:space="preserve">
          <source>Throws nothing unless calling &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource throws.</source>
          <target state="translated">除非在上游内存资源抛出上调用 &lt;code&gt;allocate()&lt;/code&gt; ，否则不会抛出任何异常。</target>
        </trans-unit>
        <trans-unit id="3473cebcbcfaf057526db12532a7e05950b9a394" translate="yes" xml:space="preserve">
          <source>Throws nothing.</source>
          <target state="translated">什么也不扔。</target>
        </trans-unit>
        <trans-unit id="d36a7251aa285e37e60059fda10d55905771330c" translate="yes" xml:space="preserve">
          <source>Throws only if an operation on &lt;code&gt;dest&lt;/code&gt; throws.</source>
          <target state="translated">仅在对 &lt;code&gt;dest&lt;/code&gt; 的操作抛出异常时抛出。</target>
        </trans-unit>
        <trans-unit id="1ec2a611e5f00a6feb428658f1aa68f1b6da7754" translate="yes" xml:space="preserve">
          <source>Throws the previously captured exception object, referred to by the exception pointer &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">抛出由异常指针 &lt;code&gt;p&lt;/code&gt; 引用的先前捕获的异常对象。</target>
        </trans-unit>
        <trans-unit id="bcec7ea351c0f526e56ea2d8f983f85ec1b9038a" translate="yes" xml:space="preserve">
          <source>Thus, replacing the throwing single object deallocation functions (1,3) is sufficient to handle all deallocations.</source>
          <target state="translated">因此,替换抛出单对象deallocation函数(1,3)足以处理所有deallocation。</target>
        </trans-unit>
        <trans-unit id="c43feecba43a30ac9fc0c134e6e8cb0382c660f2" translate="yes" xml:space="preserve">
          <source>Time manipulation</source>
          <target state="translated">时间操纵</target>
        </trans-unit>
        <trans-unit id="6a48c0a81754a0e5cd402f2b5b7b65e0802b3ae0" translate="yes" xml:space="preserve">
          <source>Time of day</source>
          <target state="translated">一天中的时间</target>
        </trans-unit>
        <trans-unit id="848d63dd0e0417a6a6d0653d6feba98b946a8d6e" translate="yes" xml:space="preserve">
          <source>Time point</source>
          <target state="translated">时间点</target>
        </trans-unit>
        <trans-unit id="99536a3f0c0c578df6810c5e30a06d3b2da45179" translate="yes" xml:space="preserve">
          <source>Time point (a &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">时间点（一个 &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b99a31f7aded92da84e5f21bdba7429ff03b583d" translate="yes" xml:space="preserve">
          <source>Time point family</source>
          <target state="translated">时间点家庭</target>
        </trans-unit>
        <trans-unit id="3e17e972e7d70a2b0ea19965e0edbbdd317996ef" translate="yes" xml:space="preserve">
          <source>Time since epoch as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; object on success or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;time&lt;/code&gt; cannot be represented as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">时间纪元以来的 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; 成功对象或 &lt;code&gt;-1&lt;/code&gt; ，如果 &lt;code&gt;time&lt;/code&gt; 不能表示为一个 &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="baff479affe7646bf932c42ec983a595bbc4b1cf" translate="yes" xml:space="preserve">
          <source>Time tracking (e.g. &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;), C-style date and time (e.g. &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/c/clock&quot;&gt;std::clock&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">时间跟踪（例如 &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; :: chrono :: duration），C风格的日期和时间（例如 &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;chrono/c/clock&quot;&gt;std::clock&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="eea79afd832854a3b24153b928ee9c62c7457dbe" translate="yes" xml:space="preserve">
          <source>Time zone</source>
          <target state="translated">时区</target>
        </trans-unit>
        <trans-unit id="932d3e6f9a587b1ed93ccda36b7118239840479f" translate="yes" xml:space="preserve">
          <source>Time zone pointer (denoted &lt;code&gt;zone&lt;/code&gt;)</source>
          <target state="translated">时区指针（表示为 &lt;code&gt;zone&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="40349a8ed2b426d8558214c08ff878c9b7836d5c" translate="yes" xml:space="preserve">
          <source>TimedLockable</source>
          <target state="translated">TimedLockable</target>
        </trans-unit>
        <trans-unit id="7a1979526d24991a3fdc66189422c80b7c9499d1" translate="yes" xml:space="preserve">
          <source>TimedMutex</source>
          <target state="translated">TimedMutex</target>
        </trans-unit>
        <trans-unit id="3d854366021896ce0345060f9138ad581720da11" translate="yes" xml:space="preserve">
          <source>To access the variadic arguments from the function body, the following library facilities are provided:</source>
          <target state="translated">为了从函数体中访问变量参数,提供了以下库设施。</target>
        </trans-unit>
        <trans-unit id="2c3649f8d8e3f7fb8fa9a2e0b81692c7c0d56f26" translate="yes" xml:space="preserve">
          <source>To avoid data races, once a shared pointer is passed to any of these functions, it cannot be accessed non-atomically. In particular, you cannot dereference such a shared_ptr without first atomically loading it into another shared_ptr object, and then dereferencing through the second object.</source>
          <target state="translated">为了避免数据竞赛,一旦共享指针被传递到这些函数中的任何一个,它就不能被非原子地访问。特别是,如果不先将它原子化地加载到另一个shared_ptr对象中,然后再通过第二个对象进行解除引用,就不能解除引用这样一个shared_ptr。</target>
        </trans-unit>
        <trans-unit id="7c35636471d229cbd245a9382f85e9b6dce24337" translate="yes" xml:space="preserve">
          <source>To avoid these quirks, &lt;code&gt;result_of&lt;/code&gt; is often used with reference types as &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;Args...&lt;/code&gt;. For example:</source>
          <target state="translated">为了避免这些怪癖，通常将 &lt;code&gt;result_of&lt;/code&gt; 与 &lt;code&gt;F&lt;/code&gt; 和 &lt;code&gt;Args...&lt;/code&gt; 引用类型一起使用。例如：</target>
        </trans-unit>
        <trans-unit id="9af4209978b81d53f6e3f0d4dfaa5d56a5095a25" translate="yes" xml:space="preserve">
          <source>To avoid unnecessary copying of the exception object and object slicing, the best practice for catch clauses is to catch by reference.&lt;sup id=&quot;cite_ref-10&quot;&gt;&lt;a href=&quot;exceptions#cite_note-10&quot;&gt;[10]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-11&quot;&gt;&lt;a href=&quot;exceptions#cite_note-11&quot;&gt;[11]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-12&quot;&gt;&lt;a href=&quot;exceptions#cite_note-12&quot;&gt;[12]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-13&quot;&gt;&lt;a href=&quot;exceptions#cite_note-13&quot;&gt;[13]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">为了避免不必要地复制异常对象和对象切片，catch子句的最佳实践是按引用进行捕获。&lt;sup id=&quot;cite_ref-10&quot;&gt;&lt;a href=&quot;exceptions#cite_note-10&quot;&gt;[10] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-11&quot;&gt;&lt;a href=&quot;exceptions#cite_note-11&quot;&gt;[11] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-12&quot;&gt;&lt;a href=&quot;exceptions#cite_note-12&quot;&gt;[12] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-13&quot;&gt;&lt;a href=&quot;exceptions#cite_note-13&quot;&gt;[13]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32227a48661c43cebdc36000ab948c6c4f0e7732" translate="yes" xml:space="preserve">
          <source>To be included in the set of viable functions, the candidate function must satisfy the following:</source>
          <target state="translated">要列入可行函数集,候选函数必须满足以下条件:</target>
        </trans-unit>
        <trans-unit id="1d9269c47d9ba025b6ff347184af6dae00b4781f" translate="yes" xml:space="preserve">
          <source>To call the function,</source>
          <target state="translated">要调用该函数。</target>
        </trans-unit>
        <trans-unit id="3e00e2418f0d13b96de319ccb14e33b157fe6ecf" translate="yes" xml:space="preserve">
          <source>To compile a call to a function template, the compiler has to decide between non-template overloads, template overloads, and the specializations of the template overloads.</source>
          <target state="translated">为了编译对函数模板的调用,编译器必须在非模板重载、模板重载和模板重载的特殊化之间做出决定。</target>
        </trans-unit>
        <trans-unit id="648fa0a42ad74259537f74f99862470566d205e4" translate="yes" xml:space="preserve">
          <source>To convert a reference or a pointer to a cv-qualified type to a reference or pointer to a</source>
          <target state="translated">要将指向cv限定类型的引用或指针转换为指向cv限定类型的引用或指针。</target>
        </trans-unit>
        <trans-unit id="479a613a1f4b0b411389efeda8d5cbee450b5792" translate="yes" xml:space="preserve">
          <source>To create a distribution over the closed interval [a,b], &lt;code&gt;&lt;a href=&quot;../../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; may be used as the second parameter.</source>
          <target state="translated">为了在闭合间隔[a，b]上创建分布，可以将 &lt;code&gt;&lt;a href=&quot;../../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; 用作第二个参数。</target>
        </trans-unit>
        <trans-unit id="d960d66e52b0039243dd579fef5b5e0189abe40c" translate="yes" xml:space="preserve">
          <source>To create a distribution over the closed interval [a,b], &lt;code&gt;&lt;a href=&quot;../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; may be used as the second parameter.</source>
          <target state="translated">为了在闭合间隔[a，b]上创建分布，可以将 &lt;code&gt;&lt;a href=&quot;../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; 用作第二个参数。</target>
        </trans-unit>
        <trans-unit id="99e393ae840d4dfdfd8ab0ea9c4989b21f3b3380" translate="yes" xml:space="preserve">
          <source>To declare a variadic function, an ellipsis is used as the last parameter, e.g. &lt;code&gt;int printf(const char* format, ...);&lt;/code&gt;. See &lt;a href=&quot;../language/variadic_arguments&quot;&gt;Variadic arguments&lt;/a&gt; for additional detail on the syntax, automatic argument conversions and the alternatives.</source>
          <target state="translated">为了声明可变参数函数，将省略号用作最后一个参数，例如 &lt;code&gt;int printf(const char* format, ...);&lt;/code&gt; 。看到&lt;a href=&quot;../language/variadic_arguments&quot;&gt;&lt;/a&gt;语法，自动参数转换和替代方法的更多详细信息，可变参数。</target>
        </trans-unit>
        <trans-unit id="22cd3be1d2fb287ce824540ee1391a62cb561144" translate="yes" xml:space="preserve">
          <source>To ensure that the program benefits from the optimizations enabled by &lt;code&gt;assume_aligned&lt;/code&gt;, it is important to access the object via its return value:</source>
          <target state="translated">为确保程序受益于由 &lt;code&gt;assume_aligned&lt;/code&gt; 启用的优化，通过对象的返回值访问该对象很重要：</target>
        </trans-unit>
        <trans-unit id="525fd31bb668048344f8a31de0c1142305eb7415" translate="yes" xml:space="preserve">
          <source>To generate enough entropy, &lt;code&gt;generate_canonical()&lt;/code&gt; will call &lt;code&gt;g()&lt;/code&gt; exactly k times, where \(k = max(1, \lceil \frac{b}{log_2 R} \rceil)\)k = max(1, &amp;lceil; b / log</source>
          <target state="translated">为了产生足够的熵， &lt;code&gt;generate_canonical()&lt;/code&gt; 将调用 &lt;code&gt;g()&lt;/code&gt; 精确地 k次，其中\（k = max（1，\ lceil \ frac {b} {log_2 R} \ rceil）\）k = max（1，&amp;lceil;b /日志</target>
        </trans-unit>
        <trans-unit id="2c0e3e28251239ee8bfb2240bdd1fc0f1ed54c3c" translate="yes" xml:space="preserve">
          <source>To grant access to additional functions or classes to protected or private members, a &lt;a href=&quot;friend&quot;&gt;friendship declaration&lt;/a&gt; may be used.</source>
          <target state="translated">为了向受保护或私有成员授予访问其他功能或类的权限，可以使用&lt;a href=&quot;friend&quot;&gt;友谊声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="878939687f32a6c24537c7a73b290843588b7164" translate="yes" xml:space="preserve">
          <source>To initialize a pointer to null or to assign the null value to an existing pointer, the null pointer literal &lt;code&gt;nullptr&lt;/code&gt;, the null pointer constant &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, or the &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the integer value &lt;code&gt;​0​&lt;/code&gt; may be used.</source>
          <target state="translated">要初始化指向null的指针或将null值分配给现有指针，请使用null指针文字 &lt;code&gt;nullptr&lt;/code&gt; ，null指针常量 &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 或从整数值进行&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt; &lt;code&gt;​0​&lt;/code&gt; 可以被使用。</target>
        </trans-unit>
        <trans-unit id="e3122235602ec384e5e6446cb56e5141efaef34c" translate="yes" xml:space="preserve">
          <source>To iterate over the current directory, construct the iterator as &lt;code&gt;directory_iterator(&quot;.&quot;)&lt;/code&gt; instead of &lt;code&gt;directory_iterator(&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">要遍历当前目录，请将迭代器构造为 &lt;code&gt;directory_iterator(&quot;.&quot;)&lt;/code&gt; 而不是 &lt;code&gt;directory_iterator(&quot;&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="724317f9ed9523d1d5aa4de4bf63c61feb5cf73f" translate="yes" xml:space="preserve">
          <source>To make ADL examine a user-defined namespace, either &lt;code&gt;std::vector&lt;/code&gt; should be replaced by a user-defined class or its element type should be a user-defined class:</source>
          <target state="translated">为了使ADL检查用户定义的名称空间，可以使用 &lt;code&gt;std::vector&lt;/code&gt; 应将替换为用户定义的类，或者其元素类型应为用户定义的类：</target>
        </trans-unit>
        <trans-unit id="9dacb8ab35ec1963dda5bb3c402d87f89eb9adc7" translate="yes" xml:space="preserve">
          <source>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. For example, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; relies on &lt;code&gt;&lt;a href=&quot;../utility/move_if_noexcept&quot;&gt;std::move_if_noexcept&lt;/a&gt;&lt;/code&gt; to choose between move and copy when the elements need to be relocated.</source>
          <target state="translated">为了使强大的异常保证成为可能，用户定义的move构造函数不应抛出异常。例如， &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 依靠 &lt;code&gt;&lt;a href=&quot;../utility/move_if_noexcept&quot;&gt;std::move_if_noexcept&lt;/a&gt;&lt;/code&gt; 在需要重定位元素时在移动和复制之间进行选择。</target>
        </trans-unit>
        <trans-unit id="fbaf135ff4214aca3306677fb2ad01282f0bd0a8" translate="yes" xml:space="preserve">
          <source>To match a template template argument &lt;code&gt;A&lt;/code&gt; to a template template parameter &lt;code&gt;P&lt;/code&gt;, each of the template parameters of &lt;code&gt;A&lt;/code&gt; must match corresponding template parameters of &lt;code&gt;P&lt;/code&gt; exactly(until C++17)&lt;code&gt;P&lt;/code&gt; must be at least as specialized as &lt;code&gt;A&lt;/code&gt;(since C++17). If &lt;code&gt;P&lt;/code&gt;'s parameter list includes a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt;, zero or more template parameters (or parameter packs) from &lt;code&gt;A&lt;/code&gt;'s template parameter list are matched by it.</source>
          <target state="translated">要将模板模板参数 &lt;code&gt;A&lt;/code&gt; 与模板模板参数 &lt;code&gt;P&lt;/code&gt; 匹配， &lt;code&gt;A&lt;/code&gt; 的每个模板参数必须完全匹配 &lt;code&gt;P&lt;/code&gt; 的对应模板参数（直到C ++ 17） &lt;code&gt;P&lt;/code&gt; 必须至少与 &lt;code&gt;A&lt;/code&gt; 一样专业（因为C ++ 17）。如果 &lt;code&gt;P&lt;/code&gt; 的参数列表包含一个&lt;a href=&quot;parameter_pack&quot;&gt;参数包&lt;/a&gt;，则来自 &lt;code&gt;A&lt;/code&gt; 的零个或多个模板参数（或参数包）则它匹配的模板参数列表中的。</target>
        </trans-unit>
        <trans-unit id="1653fef798170fad22ce8f246671d9967ebf88bf" translate="yes" xml:space="preserve">
          <source>To provide multidimensional array access semantics, e.g. to implement a 3D array access &lt;code&gt;a[i][j][k] = x;&lt;/code&gt;, operator[] has to return a reference to a 2D plane, which has to have its own operator[] which returns a reference to a 1D row, which has to have operator[] which returns a reference to the element. To avoid this complexity, some libraries opt for overloading &lt;code&gt;operator()&lt;/code&gt; instead, so that 3D access expressions have the Fortran-like syntax &lt;code&gt;a(i, j, k) = x;&lt;/code&gt;</source>
          <target state="translated">提供多维数组访问语义，例如实现3D数组访问 &lt;code&gt;a[i][j][k] = x;&lt;/code&gt; ，operator []必须返回对2D平面的引用，该二维平面必须具有自己的operator []，该操作员返回对1D行的引用，而二维行必须具有operator []，该行返回对元素的引用。为了避免这种复杂性，某些库改为选择重载 &lt;code&gt;operator()&lt;/code&gt; ，以便3D访问表达式具有类似于Fortran的语法 &lt;code&gt;a(i, j, k) = x;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="106dedcf05132b51eabb9b06f962997250951fc9" translate="yes" xml:space="preserve">
          <source>To refer to a static member &lt;code&gt;m&lt;/code&gt; of class &lt;code&gt;T&lt;/code&gt;, two forms may be used: qualified name &lt;code&gt;T::m&lt;/code&gt; or member access expression &lt;code&gt;E.m&lt;/code&gt; or &lt;code&gt;E-&amp;gt;m&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression that evaluates to &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt; respectively. When in the same class scope, the qualification is unnecessary:</source>
          <target state="translated">要引用类 &lt;code&gt;T&lt;/code&gt; 的静态成员 &lt;code&gt;m&lt;/code&gt; ，可以使用两种形式：合格名称 &lt;code&gt;T::m&lt;/code&gt; 或成员访问表达式 &lt;code&gt;E.m&lt;/code&gt; 或 &lt;code&gt;E-&amp;gt;m&lt;/code&gt; ，其中 &lt;code&gt;E&lt;/code&gt; 是分别计算为 &lt;code&gt;T&lt;/code&gt; 或 &lt;code&gt;T*&lt;/code&gt; 的表达式。在同一班级范围内时，不需要资格：</target>
        </trans-unit>
        <trans-unit id="3726bd5210fa66b99d1405f1d23513ff4e9a847a" translate="yes" xml:space="preserve">
          <source>To reopen an existing namespace (formally, to be an</source>
          <target state="translated">要重新打开一个现有的命名空间(正式说来,就是要成为一个</target>
        </trans-unit>
        <trans-unit id="6766595568bdee575215126dcd221dc1330e2532" translate="yes" xml:space="preserve">
          <source>To replace the managed object while supplying a new deleter as well, move assignment operator may be used.</source>
          <target state="translated">如果要替换被管理的对象,同时提供一个新的删除器,可以使用移动分配操作符。</target>
        </trans-unit>
        <trans-unit id="f22138cc2032a2d9e0e8461eb5887bb980094c3c" translate="yes" xml:space="preserve">
          <source>To satisfy this requirement, types that do not have built-in &lt;a href=&quot;../language/operator_comparison&quot;&gt;comparison operators&lt;/a&gt; have to provide a &lt;a href=&quot;../language/operators&quot;&gt;user-defined operator==&lt;/a&gt;.</source>
          <target state="translated">为了满足此要求，没有内置&lt;a href=&quot;../language/operator_comparison&quot;&gt;比较运算符的&lt;/a&gt;类型必须提供&lt;a href=&quot;../language/operators&quot;&gt;用户定义的operator ==&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="129c710e9009508a2e1a7fdb48457bda967c930d" translate="yes" xml:space="preserve">
          <source>To satisfy this requirement, types that do not have built-in &lt;a href=&quot;../language/operator_comparison&quot;&gt;comparison operators&lt;/a&gt; have to provide a &lt;a href=&quot;../language/operators#Relational_operators&quot;&gt;user-defined operator&amp;lt;&lt;/a&gt;</source>
          <target state="translated">为了满足此要求，没有内置&lt;a href=&quot;../language/operator_comparison&quot;&gt;比较运算符的&lt;/a&gt;类型必须提供&lt;a href=&quot;../language/operators#Relational_operators&quot;&gt;用户定义的运算符&amp;lt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17417ca14266e537b698e5e14276654d4c17a975" translate="yes" xml:space="preserve">
          <source>To satisfy thread safety requirements, the reference counters are typically incremented using an equivalent of &lt;code&gt;&lt;a href=&quot;../atomic/atomic/fetch_add&quot;&gt;std::atomic::fetch_add&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; (decrementing requires stronger ordering to safely destroy the control block).</source>
          <target state="translated">为了满足线程安全要求，通常使用与 &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; 等效的 &lt;code&gt;&lt;a href=&quot;../atomic/atomic/fetch_add&quot;&gt;std::atomic::fetch_add&lt;/a&gt;&lt;/code&gt; 来递增引用计数器（递减要求更强的顺序以安全地破坏控制块）。</target>
        </trans-unit>
        <trans-unit id="8878bda84316e640272f36cf3fc4a73005bafae8" translate="yes" xml:space="preserve">
          <source>To simplify management of dynamically-allocated objects, the result of a new-expression is often stored in a</source>
          <target state="translated">为了简化对动态分配对象的管理,新表达式的结果通常存储在一个</target>
        </trans-unit>
        <trans-unit id="72759510b678f958968f4cb0b51ad3056400cce9" translate="yes" xml:space="preserve">
          <source>To test the last two conditions, compilers may first perform a trial constant evaluation of the initializers. It is not recommended to depend on the result in this case.</source>
          <target state="translated">为了测试最后两个条件,编译器可以先对初始化器进行一次试验性的常量评估。在这种情况下,不建议依赖结果。</target>
        </trans-unit>
        <trans-unit id="2ef767a66957791708ed92649c40f252de18b675" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; (&lt;/code&gt;arg1, arg2, ...&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; (&lt;/code&gt; arg1，arg2，... &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fd5e6c8eaf332caffe8f6fbe44a90cd7d1b98a0" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; {&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;=&lt;/code&gt;arg1&lt;code&gt;,&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;{&lt;/code&gt;arg2&lt;code&gt;} &lt;/code&gt;... &lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; {&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 标志 &lt;code&gt;=&lt;/code&gt; ARG1 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 指示符 &lt;code&gt;{&lt;/code&gt; arg2 &lt;code&gt;} &lt;/code&gt; ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8524224705b06e86014d7113489a9fa766f785d6" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; {&lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt; {&lt;/code&gt; arg1，arg2，... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fa04374ca1b3d5854920daae3a860b764cf4bc1" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;( &lt;/code&gt;arg1, arg2, ...&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;( &lt;/code&gt; arg1，arg2，... &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad21f03c3b6e98547a57e446e234ea4a3bc549c4" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;( &lt;/code&gt;arg&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;( &lt;/code&gt; arg &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73dc4cf67a69ee8abf0145c5834683df2e89c44e" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8be85a4e1d42709d6cc3339f92d0ed646df7afbf" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;= {&lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;= {&lt;/code&gt; arg1，arg2，... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="749c4b6dafadee83198511f34995fe4793451e2c" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;&lt;code&gt; {&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;=&lt;/code&gt;arg1&lt;code&gt;,&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;{&lt;/code&gt;arg2&lt;code&gt;} &lt;/code&gt;... &lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">TObject的 &lt;code&gt;=&lt;/code&gt; &lt;code&gt; {&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 标志 &lt;code&gt;=&lt;/code&gt; ARG1 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; 指示符 &lt;code&gt;{&lt;/code&gt; arg2 &lt;code&gt;} &lt;/code&gt; ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66d34b7b6a63046c11e32cb28d0bfdc320edb9c6" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;other&lt;code&gt;} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; 其他 &lt;code&gt;} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca0bdecf7ffe3b07ea0bd6237e1e29b32609b1b3" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;=&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="709755aaf5485c722f9b0e75a1395ff736803b24" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;{ &lt;/code&gt; arg1，arg2，... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61782cc12972859d36df728c91f3cae207b1187e" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{ &lt;/code&gt;arg&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Tobject &lt;code&gt;{ &lt;/code&gt; arg &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f01015bfa0f56ac60d1e5a7cf450991d276e29b7" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{};&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;{};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddb24f2589165d45d6ccb527543d8886fc657afc" translate="yes" xml:space="preserve">
          <source>Together with identifiers they are known as</source>
          <target state="translated">与标识符一起被称为</target>
        </trans-unit>
        <trans-unit id="3eff2f682c2bec3252c55e73a2e17235c924d9ac" translate="yes" xml:space="preserve">
          <source>Toggles each &lt;code&gt;bool&lt;/code&gt; in the vector (replaces with its opposite value).</source>
          <target state="translated">切换向量中的每个 &lt;code&gt;bool&lt;/code&gt; 值（替换为其相反的值）。</target>
        </trans-unit>
        <trans-unit id="f77fbd9a82d243179f6ff219e1e46df3d7caa6d5" translate="yes" xml:space="preserve">
          <source>Too many files open in system</source>
          <target state="translated">系统中打开的文件太多</target>
        </trans-unit>
        <trans-unit id="2e0d2eef3cc8719301cd02a8aeecb9e956e88cf1" translate="yes" xml:space="preserve">
          <source>Too many levels of symbolic links</source>
          <target state="translated">象征性联系层次太多</target>
        </trans-unit>
        <trans-unit id="4113b4c9ebd053469430304ab17dc16ea1d01df9" translate="yes" xml:space="preserve">
          <source>Too many links</source>
          <target state="translated">链接太多</target>
        </trans-unit>
        <trans-unit id="171702bf2e722b21f3bd6c8ccb2927b1ba5f9e5e" translate="yes" xml:space="preserve">
          <source>Total ordering relation opposite to &lt;code&gt;a &amp;lt; b&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 相反的总排序关系</target>
        </trans-unit>
        <trans-unit id="00914541a4417609db5b497e533746eecb783cd5" translate="yes" xml:space="preserve">
          <source>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.</source>
          <target state="translated">完全顺序排序需要在所有多核系统上使用完整的内存栅栏CPU指令。这可能会成为性能瓶颈,因为它迫使受影响的内存访问传播到每个核心。</target>
        </trans-unit>
        <trans-unit id="dad674e48704a92597b8a13244ba1d8ca29324b7" translate="yes" xml:space="preserve">
          <source>Trade-offs</source>
          <target state="translated">Trade-offs</target>
        </trans-unit>
        <trans-unit id="ef3b5b7a3bf5164b6e6ee23c058ba72528930808" translate="yes" xml:space="preserve">
          <source>Trade-offs / usage notes</source>
          <target state="translated">权衡/使用说明</target>
        </trans-unit>
        <trans-unit id="7cf26da75debf6bbf1e4104795dc48892c4d5484" translate="yes" xml:space="preserve">
          <source>Trailing return type, useful if the return type depends on argument names, such as &lt;code&gt;template &amp;lt;class T, class U&amp;gt; auto add(T t, U u) -&amp;gt; decltype(t + u);&lt;/code&gt; or is complicated, such as in &lt;code&gt;auto fpif(int)-&amp;gt;int(*)(int)&lt;/code&gt;</source>
          <target state="translated">尾随返回类型，如果返回类型取决于参数名称，则很有用，例如 &lt;code&gt;template &amp;lt;class T, class U&amp;gt; auto add(T t, U u) -&amp;gt; decltype(t + u);&lt;/code&gt; 或很复杂，例如在 &lt;code&gt;auto fpif(int)-&amp;gt;int(*)(int)&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="cd91d96e3393ae0f62bad1c5ed125449050e450f" translate="yes" xml:space="preserve">
          <source>Transaction-safe functions</source>
          <target state="translated">交易安全功能</target>
        </trans-unit>
        <trans-unit id="79ed6ec4dd6c977b5231ac5a3a3185c0bc9188fd" translate="yes" xml:space="preserve">
          <source>Transaction-safe virtual functions</source>
          <target state="translated">交易安全的虚拟函数</target>
        </trans-unit>
        <trans-unit id="28bf6d401ae77b97e36abdf2221c6cfe2e85fc1e" translate="yes" xml:space="preserve">
          <source>Transactional memory</source>
          <target state="translated">事务性记忆</target>
        </trans-unit>
        <trans-unit id="76f8221e9e089679019e2f0fa532136f150e6dc7" translate="yes" xml:space="preserve">
          <source>Transactional memory is a concurrency synchronization mechanism that combines groups of statements in transactions, that are.</source>
          <target state="translated">事务性内存是一种并发同步机制,它将事务中的语句组结合起来,是。</target>
        </trans-unit>
        <trans-unit id="6b317497e33c505c0091e508e0f819e953607bb9" translate="yes" xml:space="preserve">
          <source>Transfers control to one of the several statements, depending on the value of a condition.</source>
          <target state="translated">根据条件的值,将控制权转移到几个语句中的一个。</target>
        </trans-unit>
        <trans-unit id="3ae0e89e8b68942479d9172eed374b0285eee3cc" translate="yes" xml:space="preserve">
          <source>Transfers control unconditionally.</source>
          <target state="translated">无条件地转移控制权。</target>
        </trans-unit>
        <trans-unit id="1f702e1322ae9e879ee08e3f62c5bdb1e12300d8" translate="yes" xml:space="preserve">
          <source>Transfers elements from one list to another.</source>
          <target state="translated">将元素从一个列表转移到另一个列表。</target>
        </trans-unit>
        <trans-unit id="3de309422c516a3c7cf8622a78d8e35f6e1be1eb" translate="yes" xml:space="preserve">
          <source>Transfers the shared state of &lt;code&gt;*this&lt;/code&gt;, if any, to a &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; object. Multiple &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; objects may reference the same shared state, which is not possible with &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;*this&lt;/code&gt; 的共享状态（如果有）转移到 &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; 对象。多个 &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; 对象可以引用相同的共享状态，而 &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 则不可能。</target>
        </trans-unit>
        <trans-unit id="17a159e3083a2a40c26d036cc1b99d55a3a0d7c4" translate="yes" xml:space="preserve">
          <source>Transform the elements of the output range according to the following algorithm:</source>
          <target state="translated">根据以下算法变换输出范围的元素。</target>
        </trans-unit>
        <trans-unit id="0d2ad20c7dacbba2fdbdd4ce378e8828c433c3a1" translate="yes" xml:space="preserve">
          <source>TransformationTrait</source>
          <target state="translated">TransformationTrait</target>
        </trans-unit>
        <trans-unit id="7bfde37a73ea6090d21989590088e7aade736914" translate="yes" xml:space="preserve">
          <source>TransformationTraits Redux</source>
          <target state="translated">TransformationTrait Redux</target>
        </trans-unit>
        <trans-unit id="4ce48d092354c3cfaf58f19e47f595e8893390a1" translate="yes" xml:space="preserve">
          <source>Transforms each element in the range &lt;code&gt;[first, last)&lt;/code&gt; with &lt;code&gt;unary_op&lt;/code&gt;, then computes an exclusive prefix sum operation using &lt;code&gt;binary_op&lt;/code&gt; over the resulting range, with &lt;code&gt;init&lt;/code&gt; as the initial value, and writes the results to the range beginning at &lt;code&gt;d_first&lt;/code&gt;. &quot;exclusive&quot; means that the i-th input element is not included in the i-th sum.</source>
          <target state="translated">变换范围内的每个元素 &lt;code&gt;[first, last)&lt;/code&gt; 与 &lt;code&gt;unary_op&lt;/code&gt; ，然后计算使用专用前缀和操作 &lt;code&gt;binary_op&lt;/code&gt; 在由此获得的范围，与 &lt;code&gt;init&lt;/code&gt; 为初始值，并且在所述结果的范围内开始写入 &lt;code&gt;d_first&lt;/code&gt; 。 &amp;ldquo;排他&amp;rdquo;表示第i个输入元素不包括在第i个和中。</target>
        </trans-unit>
        <trans-unit id="76499db2839b046f9ef84418dd0b227738ab59b2" translate="yes" xml:space="preserve">
          <source>Transforms each element in the range &lt;code&gt;[first, last)&lt;/code&gt; with &lt;code&gt;unary_op&lt;/code&gt;, then computes an inclusive prefix sum operation using &lt;code&gt;binary_op&lt;/code&gt; over the resulting range, optionally with &lt;code&gt;init&lt;/code&gt; as the initial value, and writes the results to the range beginning at &lt;code&gt;d_first&lt;/code&gt;. &quot;inclusive&quot; means that the i-th input element is included in the i-th sum.</source>
          <target state="translated">变换范围内的每个元素 &lt;code&gt;[first, last)&lt;/code&gt; 与 &lt;code&gt;unary_op&lt;/code&gt; ，然后计算使用一个包容前缀和操作 &lt;code&gt;binary_op&lt;/code&gt; 在由此获得的范围，任选地与 &lt;code&gt;init&lt;/code&gt; 为初始值，并且在所述结果的范围内开始写入 &lt;code&gt;d_first&lt;/code&gt; 。&amp;ldquo;包含&amp;rdquo;是指第i个输入元素包括在第i个和中。</target>
        </trans-unit>
        <trans-unit id="1c65f6d1ba0f638d5024c5624db7ea27406001c1" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">将 &lt;code&gt;src&lt;/code&gt; 指向的以空值结尾的字节字符串转换为实现定义的形式，以便在当前C语言环境中，将两个转换后的字符串与 &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; 进行比较得出的结果与将原始字符串与 &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt; 进行比较时具有相同的结果。</target>
        </trans-unit>
        <trans-unit id="b23c453442ba4c19cf270e32634b19b7e31b8f29" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated wide string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">将 &lt;code&gt;src&lt;/code&gt; 指向的以空值终止的宽字符串转换为实现定义的形式，以便在当前C语言环境中，将两个转换后的字符串与 &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; 进行比较得出的结果与将原始字符串与 &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; 进行比较时具有相同的结果。</target>
        </trans-unit>
        <trans-unit id="e9473bce26df240bf7fc3c05c82131b0eac3181d" translate="yes" xml:space="preserve">
          <source>Transforms the range &lt;code&gt;[first, last)&lt;/code&gt; into the next permutation from the set of all permutations that are lexicographically ordered with respect to &lt;code&gt;operator&amp;lt;&lt;/code&gt; or &lt;code&gt;comp&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if such permutation exists, otherwise transforms the range into the first permutation (as if by &lt;code&gt;std::sort(first, last)&lt;/code&gt;) and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将范围 &lt;code&gt;[first, last)&lt;/code&gt; 转换为相对于 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 或 &lt;code&gt;comp&lt;/code&gt; 按字典顺序排序的所有排列的集合中的下一个排列。如果存在这样的排列，则返回 &lt;code&gt;true&lt;/code&gt; ；否则，将范围转换为第一个排列（就像通过 &lt;code&gt;std::sort(first, last)&lt;/code&gt; ），并返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb941d77364b3c591f0e4eb102ebc186c04f6079" translate="yes" xml:space="preserve">
          <source>Transforms the range &lt;code&gt;[first, last)&lt;/code&gt; into the previous permutation from the set of all permutations that are lexicographically ordered with respect to &lt;code&gt;operator&amp;lt;&lt;/code&gt; or &lt;code&gt;comp&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if such permutation exists, otherwise transforms the range into the last permutation (as if by &lt;code&gt;std::sort(first, last); std::reverse(first, last);&lt;/code&gt;) and returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">将范围 &lt;code&gt;[first, last)&lt;/code&gt; 转换为相对于 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 或 &lt;code&gt;comp&lt;/code&gt; 按字典顺序排序的所有排列的集合中的上一个排列。如果存在这样的排列，则返回 &lt;code&gt;true&lt;/code&gt; ；否则，将范围转换为最后一个排列（就像通过 &lt;code&gt;std::sort(first, last); std::reverse(first, last);&lt;/code&gt; ），并返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c2ca105c8eba32a022ebfb50e700557700476d5" translate="yes" xml:space="preserve">
          <source>Translation units, instantiation units, and library components needed to satisfy external references are collected into a program image which contains information needed for execution in its execution environment.</source>
          <target state="translated">翻译单元、实例化单元和满足外部引用所需的库组件被收集到一个程序映像中,该映像包含了在其执行环境中执行所需的信息。</target>
        </trans-unit>
        <trans-unit id="7d38d008dd097b51dab00ca0d0265de5ece13e59" translate="yes" xml:space="preserve">
          <source>Transparent operator functors (&lt;code&gt;std::less&amp;lt;&amp;gt;&lt;/code&gt; et al)</source>
          <target state="translated">透明的运算子函子（ &lt;code&gt;std::less&amp;lt;&amp;gt;&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="f559c0b6272ddc2453ea357e3fd076a9c199929c" translate="yes" xml:space="preserve">
          <source>Tries to lock each of the given &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; objects &lt;code&gt;lock1&lt;/code&gt;, &lt;code&gt;lock2&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt;, &lt;code&gt;lockn&lt;/code&gt; by calling &lt;code&gt;try_lock&lt;/code&gt; in order beginning with the first.</source>
          <target state="translated">尝试锁定每个给定的&lt;a href=&quot;../named_req/lockable&quot;&gt;可锁定&lt;/a&gt;对象的 &lt;code&gt;lock1&lt;/code&gt; ， &lt;code&gt;lock2&lt;/code&gt; ， &lt;code&gt;...&lt;/code&gt; ， &lt;code&gt;lockn&lt;/code&gt; 调用 &lt;code&gt;try_lock&lt;/code&gt; 为了开始与第一。</target>
        </trans-unit>
        <trans-unit id="c4193e3be0c6f62e0de2fa977aca25d7c84cd476" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode without blocking. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;.</source>
          <target state="translated">尝试将相关的互斥锁锁定为共享模式而不会阻塞。有效地调用 &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="445a39a47a50a54d92796a9b19a41f46bc55486e" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;.</source>
          <target state="translated">尝试将关联的互斥锁锁定为共享模式。阻塞直到指定的 &lt;code&gt;timeout_duration&lt;/code&gt; 过去或获得锁为止，以先到者为准。成功获取锁后，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。有效地调用 &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d62e4c34ffec7ca2a5475cc557db13010bc5bb6" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex in shared mode. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. May block for longer than until &lt;code&gt;timeout_time&lt;/code&gt; has been reached.</source>
          <target state="translated">尝试将关联的互斥锁锁定为共享模式。阻塞直到达到指定的 &lt;code&gt;timeout_time&lt;/code&gt; 或获取锁（以先到者为准）。成功获取锁后，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。可能阻塞的时间长于达到 &lt;code&gt;timeout_time&lt;/code&gt; 的时间。</target>
        </trans-unit>
        <trans-unit id="04ec6c6d28a28396ea8160dff620c7f0dfdc1cb4" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex without blocking. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt;.</source>
          <target state="translated">尝试锁定相关联的互斥对象而不会阻塞。有效地调用 &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6391979884d59018323155d5442d884835e91f04" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. Effectively calls &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;.</source>
          <target state="translated">尝试锁定关联的互斥锁。阻塞直到指定的 &lt;code&gt;timeout_duration&lt;/code&gt; 过去或获得锁为止，以先到者为准。成功获取锁后，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。有效地调用 &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a394eb5a6a96eb4cd0cc26ea32b6b9f1cd9d182" translate="yes" xml:space="preserve">
          <source>Tries to lock the associated mutex. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;. May block for longer than until &lt;code&gt;timeout_time&lt;/code&gt; has been reached.</source>
          <target state="translated">尝试锁定关联的互斥锁。阻塞直到达到指定的 &lt;code&gt;timeout_time&lt;/code&gt; 或获取锁（以先到者为准）。成功获取锁后，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。可能阻塞的时间长于达到 &lt;code&gt;timeout_time&lt;/code&gt; 的时间。</target>
        </trans-unit>
        <trans-unit id="72f71ef27869580f57937ef46f54e56b64d5c90b" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the shared lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">尝试将互斥锁锁定为共享模式。阻塞直到指定的 &lt;code&gt;timeout_duration&lt;/code&gt; 过去或获取共享锁（以先到者为准）。成功获取锁后，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df7a6fe3b4499e718fdf154332580ad7e0556935" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">尝试将互斥锁锁定为共享模式。阻塞直到达到指定的 &lt;code&gt;timeout_time&lt;/code&gt; 或获取锁（以先到者为准）。成功获取锁后，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b6575b72289c55a38b072b5941884cdd93486461" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex in shared mode. Returns immediately. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">尝试将互斥锁锁定为共享模式。立即返回。成功获取锁后，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aaf4054705ad98c056fff4ec6d5fb719dbed8bab" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">尝试锁定互斥锁。阻塞直到指定的 &lt;code&gt;timeout_duration&lt;/code&gt; 过去或获得锁为止，以先到者为准。成功获取锁后，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2674b35e9268fb4c504fe5e2d2bb178899b976f5" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Blocks until specified &lt;code&gt;timeout_time&lt;/code&gt; has been reached or the lock is acquired, whichever comes first. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">尝试锁定互斥锁。阻塞直到达到指定的 &lt;code&gt;timeout_time&lt;/code&gt; 或获取锁（以先到者为准）。成功获取锁后，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e62eb4cb137d58a9975627d408c2d834c1eb07b2" translate="yes" xml:space="preserve">
          <source>Tries to lock the mutex. Returns immediately. On successful lock acquisition returns &lt;code&gt;true&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">尝试锁定互斥锁。立即返回。成功获取锁后，返回 &lt;code&gt;true&lt;/code&gt; ，否则返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">三角函数</target>
        </trans-unit>
        <trans-unit id="e719a16c184c9946c83f511d812044089e2e21c9" translate="yes" xml:space="preserve">
          <source>Trigraph</source>
          <target state="translated">Trigraph</target>
        </trans-unit>
        <trans-unit id="624b7d0a9acb19117360ca1ff7b46aba679ee393" translate="yes" xml:space="preserve">
          <source>Trigraphs (removed in C++17)</source>
          <target state="translated">三段式(在C++17中被删除</target>
        </trans-unit>
        <trans-unit id="69f8428973485177159d95cfc6a7d68111da93c3" translate="yes" xml:space="preserve">
          <source>Trivial copy assignment operator</source>
          <target state="translated">琐碎的复制分配运算符</target>
        </trans-unit>
        <trans-unit id="16966819b78d2f2d7ddd3b34badb4de1f0eb65b0" translate="yes" xml:space="preserve">
          <source>Trivial copy constructor</source>
          <target state="translated">琐碎的复制构造函数</target>
        </trans-unit>
        <trans-unit id="488ca1baf6cc68b8aa948384e1e53809bfb207a8" translate="yes" xml:space="preserve">
          <source>Trivial default constructor</source>
          <target state="translated">琐碎的默认构造函数</target>
        </trans-unit>
        <trans-unit id="1418411e56b71fbadd57e0c387a8ef7df89b350e" translate="yes" xml:space="preserve">
          <source>Trivial destructor</source>
          <target state="translated">Trivial Destroyer</target>
        </trans-unit>
        <trans-unit id="763ea1f3e981b84a927acd942aec71e9eacc4358" translate="yes" xml:space="preserve">
          <source>Trivial move assignment operator</source>
          <target state="translated">琐碎的移动分配操作员</target>
        </trans-unit>
        <trans-unit id="3f57a92cdd79d69c213d32b4b4bd7fbcb0c55720" translate="yes" xml:space="preserve">
          <source>Trivial move constructor</source>
          <target state="translated">琐碎的移动构造函数</target>
        </trans-unit>
        <trans-unit id="80e20b4c9b75f288215983370eace6b3830f2454" translate="yes" xml:space="preserve">
          <source>TrivialClock</source>
          <target state="translated">TrivialClock</target>
        </trans-unit>
        <trans-unit id="ca5b69f8f16141b8ecbd3e5d55417b7f08e4df66" translate="yes" xml:space="preserve">
          <source>TrivialType</source>
          <target state="translated">TrivialType</target>
        </trans-unit>
        <trans-unit id="739bada034f0d62036e7eca3d1c171b7fb2990b4" translate="yes" xml:space="preserve">
          <source>TriviallyCopyable</source>
          <target state="translated">TriviallyCopyable</target>
        </trans-unit>
        <trans-unit id="2c34bab22f35dd84ab5cbfaaab89a66cdb64744f" translate="yes" xml:space="preserve">
          <source>Try blocks</source>
          <target state="translated">尝试块</target>
        </trans-unit>
        <trans-unit id="ac5f250a73945a1c4524cddeb6862a489849434a" translate="yes" xml:space="preserve">
          <source>Try blocks provide the ability to catch exceptions thrown when executing other statements.</source>
          <target state="translated">尝试块提供了捕捉执行其他语句时抛出的异常的能力。</target>
        </trans-unit>
        <trans-unit id="44a77a68bb962e7ff3fb9dc11c9de3319527edbe" translate="yes" xml:space="preserve">
          <source>Tt&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tt &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc53d2c6ca548777a6fc9b944e807c006a2c9d96" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;match_results&lt;/code&gt; are equal if the following conditions are met:</source>
          <target state="translated">如果满足以下条件，则两个 &lt;code&gt;match_results&lt;/code&gt; 相等：</target>
        </trans-unit>
        <trans-unit id="d1e05e300f7cf45c9afa0f4cbce3042b969f9a51" translate="yes" xml:space="preserve">
          <source>Two &lt;code&gt;memory_resource&lt;/code&gt;s compare equal if and only if memory allocated from one &lt;code&gt;memory_resource&lt;/code&gt; can be deallocated from the other and vice versa.</source>
          <target state="translated">当且仅当从一个 &lt;code&gt;memory_resource&lt;/code&gt; 分配的内存可以从另一个memory_resource释放，并且反之亦然时，两个 &lt;code&gt;memory_resource&lt;/code&gt; 的比较相等。</target>
        </trans-unit>
        <trans-unit id="18e2cfdfc01b97bd020c553267d7b3079b8d27e3" translate="yes" xml:space="preserve">
          <source>Two accesses to the same object of type &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;std::sig_atomic_t&lt;/a&gt;&lt;/code&gt; do not result in a data race if both occur in the same thread, even if one or more occurs in a signal handler. For each signal handler invocation, evaluations performed by the thread invoking a signal handler can be divided into two groups A and B, such that no evaluations in B</source>
          <target state="translated">两次访问同一类型 &lt;code&gt;volatile &lt;a href=&quot;sig_atomic_t&quot;&gt;std::sig_atomic_t&lt;/a&gt;&lt;/code&gt; 对象不会导致数据争用，即使它们都发生在同一线程中，即使一个或多个发生在信号处理程序中也是如此。对于每次信号处理程序调用，可以将由调用信号处理程序的线程执行的评估分为A组和B组，以便B中没有评估</target>
        </trans-unit>
        <trans-unit id="af211090fdec69c271770be6c158a8a93a7a9156" translate="yes" xml:space="preserve">
          <source>Two atomic constraints are considered</source>
          <target state="translated">两种原子约束被认为是</target>
        </trans-unit>
        <trans-unit id="281cdcd9fceacdd0a42e26b288d042b3cef41c39" translate="yes" xml:space="preserve">
          <source>Two consecutive left square bracket tokens (&lt;code&gt;[[&lt;/code&gt;) may only appear when introducing an attribute-specifier or inside an attribute argument.</source>
          <target state="translated">两个连续的左方括号标记（ &lt;code&gt;[[&lt;/code&gt; ）仅在引入属性说明符或在属性参数内时出现。</target>
        </trans-unit>
        <trans-unit id="60290606d4c62d76f3da7e32e693534176b08979" translate="yes" xml:space="preserve">
          <source>Two convenience typedefs are provided by the standard library.</source>
          <target state="translated">标准库提供了两个方便的类型定义。</target>
        </trans-unit>
        <trans-unit id="7aa31cc07dd369014ec64e33766626d690657b52" translate="yes" xml:space="preserve">
          <source>Two empty ranges are lexicographically</source>
          <target state="translated">两个空的范围在词法上是</target>
        </trans-unit>
        <trans-unit id="6b78b90a2edac1ec50aec2ddead8be1711dcb40b" translate="yes" xml:space="preserve">
          <source>Two expressions involving template parameters are called</source>
          <target state="translated">涉及模板参数的两个表达式被称为</target>
        </trans-unit>
        <trans-unit id="401bc70a8b4f3d2ca441828fbf93f9236de2257b" translate="yes" xml:space="preserve">
          <source>Two function templates are considered</source>
          <target state="translated">两种功能模板被认为是</target>
        </trans-unit>
        <trans-unit id="9a61fe0c1252c74ede2b7eafa0a43c49b8412afe" translate="yes" xml:space="preserve">
          <source>Two functions with the same name and the same parameter list in the same namespace cannot have two different language linkages (note, however, that linkage of a parameter may permit such overloading, as in the case of &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;std::qsort&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../algorithm/bsearch&quot;&gt;std::bsearch&lt;/a&gt;&lt;/code&gt;). Likewise, two variables in the same namespace cannot have two different language linkages.</source>
          <target state="translated">在相同名称空间中具有相同名称和相同参数列表的两个函数不能具有两种不同的语言链接（但是，请注意，参数链接可能会允许这种重载，例如在 &lt;code&gt;&lt;a href=&quot;../algorithm/qsort&quot;&gt;std::qsort&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../algorithm/bsearch&quot;&gt;std::bsearch&lt;/a&gt;&lt;/code&gt; ）。同样，同一名称空间中的两个变量不能具有两种不同的语言链接。</target>
        </trans-unit>
        <trans-unit id="4eb187c84dda2874b690bed58603b32136278ed1" translate="yes" xml:space="preserve">
          <source>Two global basic_istream objects are provided by the standard library.</source>
          <target state="translated">标准库提供了两个全局的 basic_istream 对象。</target>
        </trans-unit>
        <trans-unit id="c90f6f3b7bfcc952e158fda77bf6551f5a0e53dd" translate="yes" xml:space="preserve">
          <source>Two instances of &lt;code&gt;std::exception_ptr&lt;/code&gt; compare equal only if they are both null or both point at the same exception object.</source>
          <target state="translated">仅当 &lt;code&gt;std::exception_ptr&lt;/code&gt; 两个实例均为null或都指向同一个异常对象时，它们的实例才相等。</target>
        </trans-unit>
        <trans-unit id="88171adec9acfe4a9d538ee2177a7d8b88253347" translate="yes" xml:space="preserve">
          <source>Two lists of contract conditions are the same if they contain the same contract conditions in the same order. Two contract conditions are the same if they are the same kind of contract condition and have the same contract-level and the same predicate. Two predicates are the same if they would satisfy the &lt;a href=&quot;../definition#One_Definition_Rule&quot;&gt;one-definition rule&lt;/a&gt; were they to appear in function definitions, except for the renaming of function and template parameters and return value identifiers (if any).</source>
          <target state="translated">如果两个合同条件清单包含相同顺序的相同合同条件，则它们是相同的。如果两个合同条件属于相同种类的合同条件，并且具有相同的合同级别和谓词，则它们是相同的。如果两个谓词要满足&lt;a href=&quot;../definition#One_Definition_Rule&quot;&gt;一个定义规则（&lt;/a&gt;如果它们出现在函数定义中），则它们是相同的，除了函数和模板参数的重命名以及返回值标识符（如果有）之外。</target>
        </trans-unit>
        <trans-unit id="0977497139bae8229d1cacd7b1fe5a5dee1adc52" translate="yes" xml:space="preserve">
          <source>Two objects</source>
          <target state="translated">两个物体</target>
        </trans-unit>
        <trans-unit id="86ee35dfa9a139a871795ed018153e9a56ec14e3" translate="yes" xml:space="preserve">
          <source>Two objects of this type can be dereferenced and the resulting values can be swapped using unqualified function call &lt;code&gt;swap()&lt;/code&gt; in the context where both &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; and the user-defined &lt;code&gt;swap()&lt;/code&gt;s are visible.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; 和用户定义的 &lt;code&gt;swap()&lt;/code&gt; 都可见的情况下，可以取消引用此类型的两个对象，并可以使用不合格的函数调用 &lt;code&gt;swap()&lt;/code&gt; 交换结果值。</target>
        </trans-unit>
        <trans-unit id="e1ee0382cebdb37edb5b66d39ad57ccf190aa34e" translate="yes" xml:space="preserve">
          <source>Two paths are considered to resolve to the same file system entity if the two candidate entities the paths resolve to are located on the same device at the same location. For POSIX, this means that the &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_ino&lt;/code&gt; members of their POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;stat structure&lt;/a&gt;, obtained as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt;, are equal.</source>
          <target state="translated">如果路径解析的两个候选实体位于同一设备上的相同位置，则认为两个路径解析为相同的文件系统实体。对于POSIX，这意味着它们的POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;统计信息结构&lt;/a&gt;的 &lt;code&gt;st_dev&lt;/code&gt; 和 &lt;code&gt;st_ino&lt;/code&gt; 成员（就像通过POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt;获得的）相等。</target>
        </trans-unit>
        <trans-unit id="437b76b7571ce600be5aa3f3e921a20de1e39123" translate="yes" xml:space="preserve">
          <source>Two ranges are compared element by element.</source>
          <target state="translated">两个范围逐个元素进行比较。</target>
        </trans-unit>
        <trans-unit id="8ec06cfed5aca5636f6337ef590ec50fe665f57a" translate="yes" xml:space="preserve">
          <source>Two ranges are considered equal if they have the same number of elements and, for every iterator &lt;code&gt;i&lt;/code&gt; in the range &lt;code&gt;[first1,last1)&lt;/code&gt;, &lt;code&gt;*i&lt;/code&gt; equals &lt;code&gt;*(first2 + (i - first1))&lt;/code&gt;. The overloads (1,2,5,6) use &lt;code&gt;operator==&lt;/code&gt; to determine if two elements are equal, whereas overloads (3,4,7,8) use the given binary predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">如果两个范围具有相同数量的元素，则认为两个范围相等；对于范围 &lt;code&gt;[first1,last1)&lt;/code&gt; 中的每个迭代器 &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;*i&lt;/code&gt; 等于 &lt;code&gt;*(first2 + (i - first1))&lt;/code&gt; 。重载（1,2,5,6）使用 &lt;code&gt;operator==&lt;/code&gt; 来确定两个元素是否相等，而重载（3,4,7,8）使用给定的二进制谓词 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f3d6e085b1a690a184f8a241caaace1cd422427" translate="yes" xml:space="preserve">
          <source>Two specializations are provided by the standard library.</source>
          <target state="translated">标准库提供了两个专业。</target>
        </trans-unit>
        <trans-unit id="9ea29714490f77c2342f60db455484af8982a069" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are also defined:</source>
          <target state="translated">此外,还定义了两种常见字符类型的特殊化。</target>
        </trans-unit>
        <trans-unit id="395a556fd3ef9112d9577c9ebc5df6fd4309e718" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are also provided:</source>
          <target state="translated">此外,还提供了两种常见字符类型的特殊化。</target>
        </trans-unit>
        <trans-unit id="abc68b66bf994ad49ab50a82c81510a0ae793170" translate="yes" xml:space="preserve">
          <source>Two specializations for common character types are defined:</source>
          <target state="translated">定义了两种常见字符类型的特殊化。</target>
        </trans-unit>
        <trans-unit id="644226c6c6857e7526a3f749326009205374c9cd" translate="yes" xml:space="preserve">
          <source>Two specializations of &lt;code&gt;&lt;a href=&quot;types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&lt;/code&gt; for the type &lt;code&gt;bool&lt;/code&gt; are provided:</source>
          <target state="translated">提供了两种 &lt;code&gt;bool&lt;/code&gt; 类型的 &lt;code&gt;&lt;a href=&quot;types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&lt;/code&gt; 专业化：</target>
        </trans-unit>
        <trans-unit id="38cc0b6c98f9bf0b6f230727bb0b37ccdc3ce423" translate="yes" xml:space="preserve">
          <source>Two specializations of &lt;code&gt;std::regex_traits&lt;/code&gt; are defined by the standard library:</source>
          <target state="translated">标准库定义了 &lt;code&gt;std::regex_traits&lt;/code&gt; 两个特化：</target>
        </trans-unit>
        <trans-unit id="1c45317442511240ca7c73c4b544304cf52c5c50" translate="yes" xml:space="preserve">
          <source>Two standalone (locale-independent) full specializations and two partial specializations are provided by the standard library:</source>
          <target state="translated">标准库提供了两个独立的(独立于本地的)完全特化和两个部分特化。</target>
        </trans-unit>
        <trans-unit id="f02ffd61fc180d1f64496b8d587f3d5cce7df2b7" translate="yes" xml:space="preserve">
          <source>Two standalone (locale-independent) specializations are provided by the standard library:</source>
          <target state="translated">标准库提供了两个独立的(独立于本地的)特殊化。</target>
        </trans-unit>
        <trans-unit id="2cf5b83a88ef7188b905ff555b89323fdaa04f77" translate="yes" xml:space="preserve">
          <source>Two standard-layout non-union class types are called</source>
          <target state="translated">两种标准布局的非工会类类型被称为</target>
        </trans-unit>
        <trans-unit id="1b0ea8abccf06468ba7e2e711860c3d383b65c96" translate="yes" xml:space="preserve">
          <source>Two standard-layout non-union class types may have a</source>
          <target state="translated">两种标准布局的非工会类类型可以有一个。</target>
        </trans-unit>
        <trans-unit id="2034537c92fce35c44c1810a5621d0a63f6246c5" translate="yes" xml:space="preserve">
          <source>Two standard-layout unions are called</source>
          <target state="translated">两种标准布局的结合称为</target>
        </trans-unit>
        <trans-unit id="cb0d34718d67d002a55c599c7fb017311e7a205d" translate="yes" xml:space="preserve">
          <source>Two strings are equal if both the size of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal and each character in &lt;code&gt;lhs&lt;/code&gt; has equivalent character in &lt;code&gt;rhs&lt;/code&gt; at the same position.</source>
          <target state="translated">如果 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 的大小相等，并且 &lt;code&gt;lhs&lt;/code&gt; 中的每个字符在同一位置的 &lt;code&gt;rhs&lt;/code&gt; 中具有相等的字符，则两个字符串相等。</target>
        </trans-unit>
        <trans-unit id="d818143c3e7668e852c1ed4b1bfcf0387a3c91b0" translate="yes" xml:space="preserve">
          <source>Two typedefs for the common case where &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; are provided:</source>
          <target state="translated">对于 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;bool&lt;/code&gt; 的常见情况，提供了两种typedef ：</target>
        </trans-unit>
        <trans-unit id="ab704f0a65282b62f2101424e6b2f0abfc336948" translate="yes" xml:space="preserve">
          <source>Two views are equal if both the size of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal and each character in &lt;code&gt;lhs&lt;/code&gt; has an equivalent character in &lt;code&gt;rhs&lt;/code&gt; at the same position.</source>
          <target state="translated">如果 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 的大小相等并且 &lt;code&gt;lhs&lt;/code&gt; 中的每个字符在同一位置的 &lt;code&gt;rhs&lt;/code&gt; 中具有相等的字符，则两个视图相等。</target>
        </trans-unit>
        <trans-unit id="e4adb4f5d7d971d5f33d8bf32d6573b59f4c2c1c" translate="yes" xml:space="preserve">
          <source>Two-way comparison</source>
          <target state="translated">双向比较</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="7d5b0442ddd6e6a3b47c1fb7cfdb53626e952034" translate="yes" xml:space="preserve">
          <source>Type SFINAE</source>
          <target state="translated">SFINAE型</target>
        </trans-unit>
        <trans-unit id="c78ea93e5901f3567162bc1f5cabf9c0cb321ce8" translate="yes" xml:space="preserve">
          <source>Type U is swappable with type T if, for any object u of type U and any object t of type T,</source>
          <target state="translated">如果对于任何类型U的对象u和任何类型T的对象t,类型U是可以与类型T互换的。</target>
        </trans-unit>
        <trans-unit id="ba8b607d229159b7de176502ebe44f1a8317de01" translate="yes" xml:space="preserve">
          <source>Type alias</source>
          <target state="translated">类型别名</target>
        </trans-unit>
        <trans-unit id="5e72885576f31f0e1d9c64866f5a1621945f1d64" translate="yes" xml:space="preserve">
          <source>Type alias is a name that refers to a previously defined type (similar to &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;).</source>
          <target state="translated">类型别名是引用先前定义的类型的名称（类似于&lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1722c89a494d0f4cd3e0c044b1bcfcd056571bad" translate="yes" xml:space="preserve">
          <source>Type alias, alias template (since C++11)</source>
          <target state="translated">类型别名,别名模板(自C++11起)</target>
        </trans-unit>
        <trans-unit id="58cf557846d7f65d34e8a92739eef2665164fad4" translate="yes" xml:space="preserve">
          <source>Type aliases</source>
          <target state="translated">类型别名</target>
        </trans-unit>
        <trans-unit id="cd126df756f5f399b0ed73a4824b22f02643ea98" translate="yes" xml:space="preserve">
          <source>Type aliases are provided for &lt;code&gt;bool&lt;/code&gt; and all integral types listed above, as follows:</source>
          <target state="translated">为 &lt;code&gt;bool&lt;/code&gt; 和上面列出的所有整数类型提供了类型别名，如下所示：</target>
        </trans-unit>
        <trans-unit id="0621d5c6fbe8bcf7d94a8aeaee4b8e9171cf0f16" translate="yes" xml:space="preserve">
          <source>Type aliasing</source>
          <target state="translated">类型别名</target>
        </trans-unit>
        <trans-unit id="6c1aa9cebe6e183271d6415c7410657e8ccc6473" translate="yes" xml:space="preserve">
          <source>Type classification</source>
          <target state="translated">类型分类</target>
        </trans-unit>
        <trans-unit id="faebe1b53837fa610eefb9f421b0013abc2c2ee3" translate="yes" xml:space="preserve">
          <source>Type deduction does not consider implicit conversions (other than type adjustments listed above): that's the job for &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, which happens later.</source>
          <target state="translated">类型推导不考虑隐式转换（上面列出的类型调整除外）：这是&lt;a href=&quot;overload_resolution&quot;&gt;超载解析&lt;/a&gt;的工作，稍后会发生。</target>
        </trans-unit>
        <trans-unit id="6b6c1979aa63474d39a31dd947373aa3f5876803" translate="yes" xml:space="preserve">
          <source>Type identification</source>
          <target state="translated">类型识别</target>
        </trans-unit>
        <trans-unit id="8e2511e093ef713b765be9963ac67a42b99f36a7" translate="yes" xml:space="preserve">
          <source>Type modification templates create new type definitions by applying modifications on a template parameter. The resulting type can then be accessed through &lt;code&gt;type&lt;/code&gt; member typedef.</source>
          <target state="translated">类型修改模板通过对模板参数进行修改来创建新的类型定义。然后可以通过 &lt;code&gt;type&lt;/code&gt; 成员typedef 访问结果类型。</target>
        </trans-unit>
        <trans-unit id="077701eb2407963fce08e9b207dd8581a8385722" translate="yes" xml:space="preserve">
          <source>Type modifications</source>
          <target state="translated">类型修改</target>
        </trans-unit>
        <trans-unit id="476a2ca549c0288e513cdd3a95b50bf4cb76b469" translate="yes" xml:space="preserve">
          <source>Type naming</source>
          <target state="translated">命名类型</target>
        </trans-unit>
        <trans-unit id="2885fa4c886876dbf27aa8c6e61e019d3364b3e1" translate="yes" xml:space="preserve">
          <source>Type operations</source>
          <target state="translated">类型操作</target>
        </trans-unit>
        <trans-unit id="d05a5058829543344892b6ea903ebf7acc0cbacb" translate="yes" xml:space="preserve">
          <source>Type properties</source>
          <target state="translated">类型属性</target>
        </trans-unit>
        <trans-unit id="712780a85df08fbd996eeeec1c3d3e6e3b629d3c" translate="yes" xml:space="preserve">
          <source>Type relationships</source>
          <target state="translated">类型关系</target>
        </trans-unit>
        <trans-unit id="c4153f3895b73933a5c58c3f766c82d580c4d612" translate="yes" xml:space="preserve">
          <source>Type requirements</source>
          <target state="translated">类型要求</target>
        </trans-unit>
        <trans-unit id="5c3dec20e8df5a43918b8faf39633e46723561db" translate="yes" xml:space="preserve">
          <source>Type specifier</source>
          <target state="translated">类型说明者</target>
        </trans-unit>
        <trans-unit id="ebdbe0be2297808a43109ed1cd29e12d3786ec7d" translate="yes" xml:space="preserve">
          <source>Type support</source>
          <target state="translated">类型支持</target>
        </trans-unit>
        <trans-unit id="d99c924b5e5c496d209cd1138d79fd4d82ae89bd" translate="yes" xml:space="preserve">
          <source>Type support (basic types, RTTI, type traits)</source>
          <target state="translated">类型支持(基本类型、RTTI、类型特征)</target>
        </trans-unit>
        <trans-unit id="86913cb67681548c98606e442d98428c1ae65742" translate="yes" xml:space="preserve">
          <source>Type template parameter</source>
          <target state="translated">模板参数类型</target>
        </trans-unit>
        <trans-unit id="4a285087e3a01a1f61420542eebe3d7ad0cbe7d5" translate="yes" xml:space="preserve">
          <source>Type template parameter cannot be deduced from the type of a function default argument:</source>
          <target state="translated">类型模板参数不能从函数默认参数的类型中推断出来。</target>
        </trans-unit>
        <trans-unit id="b3802db54ebe40c4f9d8e147e5ec66e48e2b252c" translate="yes" xml:space="preserve">
          <source>Type traits</source>
          <target state="translated">类型特征</target>
        </trans-unit>
        <trans-unit id="2824df384c0d515b0957ced6c76365b01bfeb9fa" translate="yes" xml:space="preserve">
          <source>Type traits (since C++11)</source>
          <target state="translated">类型特征(自C++11起)</target>
        </trans-unit>
        <trans-unit id="fb365f218572167960956b20fa3e4a8fab51cd73" translate="yes" xml:space="preserve">
          <source>Type traits defines a compile-time template-based interface to query or modify the properties of types.</source>
          <target state="translated">类型特征定义了一个基于编译时模板的接口来查询或修改类型的属性。</target>
        </trans-unit>
        <trans-unit id="d26fb74bad254a05310c922f3a48638fd66d9e0c" translate="yes" xml:space="preserve">
          <source>Type traits variable templates (&lt;code&gt;&lt;a href=&quot;types/is_void&quot;&gt;std::is_void_v&lt;/a&gt;&lt;/code&gt;, etc)</source>
          <target state="translated">类型特征变量模板（ &lt;code&gt;&lt;a href=&quot;types/is_void&quot;&gt;std::is_void_v&lt;/a&gt;&lt;/code&gt; 等）</target>
        </trans-unit>
        <trans-unit id="1ce3ad96399788f64f133fb490b5f7a722f3d935" translate="yes" xml:space="preserve">
          <source>Type-dependent expressions</source>
          <target state="translated">类型依赖性表达</target>
        </trans-unit>
        <trans-unit id="9923b968817bae672aedebaea069d1e0f05c3d5f" translate="yes" xml:space="preserve">
          <source>Type-id</source>
          <target state="translated">Type-id</target>
        </trans-unit>
        <trans-unit id="ca804ab74bf9fa2667ceb8c95926b696eb69be50" translate="yes" xml:space="preserve">
          <source>Typedefs</source>
          <target state="translated">Typedefs</target>
        </trans-unit>
        <trans-unit id="6b028941a936328652669d0fdcfadace96df8cb3" translate="yes" xml:space="preserve">
          <source>Typedefs and specializations</source>
          <target state="translated">类型定义和专门化</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="14a6b912930173876d4ddc87ab0ee1e78929d71f" translate="yes" xml:space="preserve">
          <source>Types allowed for integer literals</source>
          <target state="translated">允许整数字型的类型</target>
        </trans-unit>
        <trans-unit id="0aebd15ac247c772915a487e8beaa6ae702bbaf4" translate="yes" xml:space="preserve">
          <source>Types are grouped in various categories based on their properties:</source>
          <target state="translated">类型根据其属性分为不同的类别。</target>
        </trans-unit>
        <trans-unit id="432f7a9995f3c47c26ea06ac5e31bfbd1ce7f343" translate="yes" xml:space="preserve">
          <source>Types defined in all function definitions are also the same in all translation units.</source>
          <target state="translated">所有函数定义中定义的类型在所有翻译单元中也是一样的。</target>
        </trans-unit>
        <trans-unit id="f4721af617a03c18f8008b522a45437293348f79" translate="yes" xml:space="preserve">
          <source>Types of lookup</source>
          <target state="translated">查询类型</target>
        </trans-unit>
        <trans-unit id="7b0613fc7fabdfb018b52d357936b837a2cab911" translate="yes" xml:space="preserve">
          <source>Types that do not have names often need to be referred to in C++ programs; the syntax for that is known as</source>
          <target state="translated">在C++程序中经常需要引用那些没有名字的类型,其语法称为</target>
        </trans-unit>
        <trans-unit id="b2566175d7363d465c10ed984db01277b4e1b9cf" translate="yes" xml:space="preserve">
          <source>Types without a move constructor, but with a copy constructor that accepts &lt;code&gt;const T&amp;amp;&lt;/code&gt; arguments, satisfy &lt;code&gt;std::is_move_constructible&lt;/code&gt;.</source>
          <target state="translated">没有移动构造函数，但具有接受 &lt;code&gt;const T&amp;amp;&lt;/code&gt; 参数的复制构造函数的类型，请满足 &lt;code&gt;std::is_move_constructible&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70739c5bd846379403ad7504d3db0427e14c707a" translate="yes" xml:space="preserve">
          <source>Types...</source>
          <target state="translated">Types...</target>
        </trans-unit>
        <trans-unit id="fbbef98f2687c637a775659b0dc25c3eaf7a67c3" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy assignment operator when &lt;a href=&quot;operators#Assignment_operator&quot;&gt;copy-and-swap idiom&lt;/a&gt; can be used.</source>
          <target state="translated">可以使用&lt;a href=&quot;operators#Assignment_operator&quot;&gt;复制和交换惯用法&lt;/a&gt;时，复制分配操作符的典型声明。</target>
        </trans-unit>
        <trans-unit id="918b3549bbd396e01bbb7e6f14e565a830f15731" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy assignment operator when copy-and-swap idiom cannot be used (non-swappable type or degraded performance).</source>
          <target state="translated">当不能使用复制和交换习语(不可交换类型或性能下降)时,复制分配操作符的典型声明。</target>
        </trans-unit>
        <trans-unit id="f8ce748f05c8c5befc02b9aebb0d8d634d05750d" translate="yes" xml:space="preserve">
          <source>Typical declaration of a copy constructor.</source>
          <target state="translated">复制构造函数的典型声明。</target>
        </trans-unit>
        <trans-unit id="73cd36e771bfce67068d8e880baa5998fadf8c14" translate="yes" xml:space="preserve">
          <source>Typical declaration of a move assignment operator.</source>
          <target state="translated">移动分配运算符的典型声明。</target>
        </trans-unit>
        <trans-unit id="21fff4e24aeaedc99f5d443b9c3e1bb3e8fe60f0" translate="yes" xml:space="preserve">
          <source>Typical declaration of a move constructor.</source>
          <target state="translated">移动构造函数的典型声明。</target>
        </trans-unit>
        <trans-unit id="d37091da1e22a1f61c981f61d556e4bc6ba5eecd" translate="yes" xml:space="preserve">
          <source>Typical implementation holds an instance of a &lt;code&gt;std::scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; as a member object.</source>
          <target state="translated">典型的实现将 &lt;code&gt;std::scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; 的实例作为成员对象保存。</target>
        </trans-unit>
        <trans-unit id="06d4cc727848bd1fdf903e8119b98940ee7e586c" translate="yes" xml:space="preserve">
          <source>Typical implementation holds member constants corresponding to all values of fmtflags, iostate, openmode, and seekdir shown below, member variables to maintain current precision, width, and formatting flags, the exception mask, the buffer error state, a resizeable container holding the callbacks, the currently imbued locale, the private storage, and a static integer variable for xalloc().</source>
          <target state="translated">典型的实现拥有对应于下面所示的fmtflags、iostate、openmode和seekdir的所有值的成员常量,维持当前精度、宽度和格式化标志的成员变量,异常掩码,缓冲区错误状态,持有回调的可调整大小的容器,当前灌输的locale,私有存储,以及用于xalloc()的静态整数变量。</target>
        </trans-unit>
        <trans-unit id="588a768f54b40d99ef1543297e7072645cb90743" translate="yes" xml:space="preserve">
          <source>Typical implementation of &lt;code&gt;std::basic_osyncstream&lt;/code&gt; holds only one member: the wrapped &lt;code&gt;std::basic_syncbuf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_osyncstream&lt;/code&gt; 典型实现仅包含一个成员：包装的 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9aa2b00209f5ddcdf5c18ed5a9a504d20d2daca" translate="yes" xml:space="preserve">
          <source>Typical implementation of &lt;code&gt;std::basic_syncbuf&lt;/code&gt; holds a pointer to the wrapped &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;, a boolean flag indicating whether the buffer will transmit its contents to the wrapped buffer on sync (flush), a boolean flag indicating a pending flush when the policy is to not emit on sync, an internal buffer that uses &lt;code&gt;Allocator&lt;/code&gt; (such as std::string), and a pointer to a mutex used to synchronize emit between multiple threads accessing the same wrapped stream buffer (these mutexes may be in a hash map with pointers to basic_streambuf objects used as keys).</source>
          <target state="translated">&lt;code&gt;std::basic_syncbuf&lt;/code&gt; 典型实现包含指向包装好的 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 的指针，这是一个布尔标志，指示缓冲区是否在同步（刷新）时将其内容传输到包装的缓冲区，一个布尔标志，指示当策略为false时挂起的刷新为了不同步发出，使用 &lt;code&gt;Allocator&lt;/code&gt; 的内部缓冲区（例如std :: string），以及用于互斥的互斥体的指针，该互斥体用于在访问同一包装的流缓冲区的多个线程之间进行同步发出（这些互斥体可能位于带有指向用作键的basic_streambuf对象的指针）。</target>
        </trans-unit>
        <trans-unit id="7250127c92df894b58e56d580f5f517195bd7d5f" translate="yes" xml:space="preserve">
          <source>Typical implementation of a &lt;code&gt;std::strstreambuf&lt;/code&gt; holds four private data members:</source>
          <target state="translated">&lt;code&gt;std::strstreambuf&lt;/code&gt; 典型实现包含四个私有数据成员：</target>
        </trans-unit>
        <trans-unit id="ef6d40404da26e1e6eadc90e2e0a92c1349c9710" translate="yes" xml:space="preserve">
          <source>Typical implementation of the &lt;code&gt;std::basic_streambuf&lt;/code&gt; base class holds only the six &lt;code&gt;CharT*&lt;/code&gt; pointers and a copy of &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; as data members. In addition, implementations may keep cached copies of locale facets, which are invalidated whenever &lt;code&gt;imbue()&lt;/code&gt; is called. The concrete buffers such as &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;std::basic_streambuf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_streambuf&lt;/code&gt; 基类的典型实现仅包含六个 &lt;code&gt;CharT*&lt;/code&gt; 指针和一个 &lt;code&gt;&lt;a href=&quot;../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; 副本作为数据成员。此外，实现可能会保留区域设置方面的缓存副本，每当调用 &lt;code&gt;imbue()&lt;/code&gt; 时，这些副本都会失效。诸如 &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 类的具体缓冲区是从 &lt;code&gt;std::basic_streambuf&lt;/code&gt; 派生的。</target>
        </trans-unit>
        <trans-unit id="7cd7cae1a881bd65509f3fc54f4e619c9e90350a" translate="yes" xml:space="preserve">
          <source>Typical implementations either.</source>
          <target state="translated">典型实施要么。</target>
        </trans-unit>
        <trans-unit id="9e133aef83ccff0d4f3491a9890dd2084b61042d" translate="yes" xml:space="preserve">
          <source>Typical implementations of &lt;code&gt;std::basic_stringbuf&lt;/code&gt; hold an object of type &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; or equivalent resizeable sequence container directly as a data member and use it as both the controlled character sequence (the array where the six pointers of &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; are pointing to) and as the associated character sequence (the source of characters for all input operations and the target for the output).</source>
          <target state="translated">&lt;code&gt;std::basic_stringbuf&lt;/code&gt; 典型实现包含一个类型的对象 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 或等效的可调整大小的序列容器直接作为数据成员，并使用它作为既控制字符序列（其中的六个指针数组 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 都指向）并作为关联的字符序列（所有输入操作的字符源和输出目标）。</target>
        </trans-unit>
        <trans-unit id="68f2d8f77480725b5e25bbfbe1250bd18f26ff6c" translate="yes" xml:space="preserve">
          <source>Typical implementations use hardware transactional memory where supported and to the limits that it is available (e.g. until the changeset is saturated) and fall back to software transactional memory, usually implemented with optimistic concurrency: if another transaction updated some of the variables used by a transaction, it is silently retried. For that reason, retriable transactions (&quot;atomic blocks&quot;) can only call transaction-safe functions.</source>
          <target state="translated">典型的实现在支持的地方使用硬件事务性内存,并在其可用的范围内(例如直到变化集饱和),并回落到软件事务性内存,通常以乐观的并发性来实现:如果另一个事务更新了一个事务使用的一些变量,它将被默默地重试。出于这个原因,可重试的事务(&quot;原子块&quot;)只能调用事务安全的函数。</target>
        </trans-unit>
        <trans-unit id="1b555741394ae9339e15f18c3b6d7121a3052b4c" translate="yes" xml:space="preserve">
          <source>Typical use cases for this ordering involve read access to rarely written concurrent data structures (routing tables, configuration, security policies, firewall rules, etc) and publisher-subscriber situations with pointer-mediated publication, that is, when the producer publishes a pointer through which the consumer can access information: there is no need to make everything else the producer wrote to memory visible to the consumer (which may be an expensive operation on weakly-ordered architectures). An example of such scenario is &lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt;.</source>
          <target state="translated">这种排序的典型用例包括对很少写入的并发数据结构（路由表，配置，安全策略，防火墙规则等）的读取访问，以及通过指针介导的发布（即生产者通过以下方式发布指针）的发布者－订阅者情况。消费者可以访问的信息：消费者无需使生产者写到存储器的其他所有内容对消费者可见（在弱顺序体系结构上这可能是昂贵的操作）。这种情况的一个示例是&lt;a href=&quot;https://en.wikipedia.org/wiki/Read-copy-update&quot;&gt;rcu_dereference&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dcc9e60517620bd3f403ef0a6408dee8d18e7887" translate="yes" xml:space="preserve">
          <source>Typical use for relaxed memory ordering is incrementing counters, such as the reference counters of &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, since this only requires atomicity, but not ordering or synchronization (note that decrementing the shared_ptr counters requires acquire-release synchronization with the destructor).</source>
          <target state="translated">宽松的内存排序的典型用法是增加计数器，例如 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 的引用计数器，因为这仅需要原子性，而不需要排序或同步（请注意，减少shared_ptr计数器需要与析构函数进行获取/释放同步）。</target>
        </trans-unit>
        <trans-unit id="d1c41b285173ad8718230a87a1a5d2d17b3b7903" translate="yes" xml:space="preserve">
          <source>Typical use of iword storage is to pass information (e.g. custom formatting flags) from user-defined I/O manipulators to user-defined &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or to user-defined formatting facets imbued into standard streams.</source>
          <target state="translated">iword存储的典型用法是将信息（例如，自定义格式标志）从用户定义的I / O操作器传递到用户定义 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 或传递到嵌入到标准流中的用户定义的格式化方面。</target>
        </trans-unit>
        <trans-unit id="a0c7297f2b0ebce4780a49bd855246e6cc47d6d3" translate="yes" xml:space="preserve">
          <source>Typical uses of &lt;code&gt;std::launder&lt;/code&gt; include:</source>
          <target state="translated">的典型用途 &lt;code&gt;std::launder&lt;/code&gt; 包括：</target>
        </trans-unit>
        <trans-unit id="f88c003eb42b9ea1375635c3ec171fc7d9d436f1" translate="yes" xml:space="preserve">
          <source>Typically called by the appropriate constructors of &lt;code&gt;std::basic_osyncstream&lt;/code&gt;.</source>
          <target state="translated">通常由适当的构造函数调用 &lt;code&gt;std::basic_osyncstream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b96ee3f3e487127e3b6fea8c21cfa2b830940d4d" translate="yes" xml:space="preserve">
          <source>Typically called by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常由的构造函数调用 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47bd33f18f5f8634e7375df48b7f7fb6bccdec60" translate="yes" xml:space="preserve">
          <source>Typically called by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常由的构造函数调用 &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d635d5eec3d8618476f770fe4d864ab867b778b" translate="yes" xml:space="preserve">
          <source>Typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">通常由析构函数调用 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f750e5d2112c892940c039aca52de35a7711eef8" translate="yes" xml:space="preserve">
          <source>Typically, once &lt;code&gt;operator&amp;lt;&lt;/code&gt; is provided, the other relational operators are implemented in terms of &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">通常，一次 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 被提供，其他关系运算符在以下方面实现的 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41f3db6f3ed64eb215d6838b5f2754196444b79e" translate="yes" xml:space="preserve">
          <source>U+00A8</source>
          <target state="translated">U+00A8</target>
        </trans-unit>
        <trans-unit id="853cbdaa93204f86fe9e28c7fa4f0cdff4d3b9bc" translate="yes" xml:space="preserve">
          <source>U+00AA</source>
          <target state="translated">U+00AA</target>
        </trans-unit>
        <trans-unit id="dd5c9cc4b863c82bc928546a1f85d66803a8211b" translate="yes" xml:space="preserve">
          <source>U+00AD</source>
          <target state="translated">U+00AD</target>
        </trans-unit>
        <trans-unit id="5b12a6b1423f6d50cbadc422ccde7e82e285061a" translate="yes" xml:space="preserve">
          <source>U+00AF</source>
          <target state="translated">U+00AF</target>
        </trans-unit>
        <trans-unit id="7b152417fcfe4c5eb703ff0a0c4980c4a5bdcc7f" translate="yes" xml:space="preserve">
          <source>U+00B2 - U+00B5</source>
          <target state="translated">U+00B2-U+00B5</target>
        </trans-unit>
        <trans-unit id="a000abf8eda220f3b5a2485e895780d87238cc05" translate="yes" xml:space="preserve">
          <source>U+00B7 - U+00BA</source>
          <target state="translated">U+00B7-U+00BA.</target>
        </trans-unit>
        <trans-unit id="3e0f991583121de4997412ddc791f2cce64673ed" translate="yes" xml:space="preserve">
          <source>U+00BC - U+00BE</source>
          <target state="translated">U+00BC-U+00BE</target>
        </trans-unit>
        <trans-unit id="8da270e5988e53f6a16cfbbffdc343231a853e7f" translate="yes" xml:space="preserve">
          <source>U+00C0 - U+00D6</source>
          <target state="translated">U+00C0-U+00D6</target>
        </trans-unit>
        <trans-unit id="21a7086c2d62117c31f8128dd2f55f8f6e915e24" translate="yes" xml:space="preserve">
          <source>U+00D8 - U+00F6</source>
          <target state="translated">U+00D8-U+00F6:</target>
        </trans-unit>
        <trans-unit id="bf28cde9daefd91ebc927ccb81f1551b46c4d078" translate="yes" xml:space="preserve">
          <source>U+00F8 - U+167F</source>
          <target state="translated">U+00F8-U+167F.</target>
        </trans-unit>
        <trans-unit id="a317fb85190fd3c7b724d3aedb81fe25713813f0" translate="yes" xml:space="preserve">
          <source>U+0300 - U+036F</source>
          <target state="translated">U+0300-U+036F</target>
        </trans-unit>
        <trans-unit id="820e59791c5dbc98084a89fd4c68a5caddd9a3e8" translate="yes" xml:space="preserve">
          <source>U+10000 - U+1FFFD</source>
          <target state="translated">U+10000-U+1FFFD</target>
        </trans-unit>
        <trans-unit id="172792565a185595c59af72f4ae5f6a9a6e9ad8f" translate="yes" xml:space="preserve">
          <source>U+1681 - U+180D</source>
          <target state="translated">U+1681-U+180D</target>
        </trans-unit>
        <trans-unit id="d84a34f5a6d7a409f7d9c6df8ad6471fbc79b9b0" translate="yes" xml:space="preserve">
          <source>U+180F - U+1FFF</source>
          <target state="translated">U+180F-U+1FFF.</target>
        </trans-unit>
        <trans-unit id="f3c3d44148796e35a5035d711e351a1697c2759f" translate="yes" xml:space="preserve">
          <source>U+1DC0 - U+1DFF</source>
          <target state="translated">U+1DC0-U+1DFF.</target>
        </trans-unit>
        <trans-unit id="330cb234316d66348fc89aff6e84b6015dadcf43" translate="yes" xml:space="preserve">
          <source>U+20000 - U+2FFFD</source>
          <target state="translated">U+20000-U+2FFFD;</target>
        </trans-unit>
        <trans-unit id="5b3b9b21095522acbe168717fae555c1cfa7a1f4" translate="yes" xml:space="preserve">
          <source>U+200B - U+200D</source>
          <target state="translated">U+200B-U+200D</target>
        </trans-unit>
        <trans-unit id="3214f797fec510b86bf1cbf6434d683974a2248a" translate="yes" xml:space="preserve">
          <source>U+202A - U+202E</source>
          <target state="translated">U+202A-U+202E</target>
        </trans-unit>
        <trans-unit id="e97d49eff3295448f03d9e228444cd7f9a6734e9" translate="yes" xml:space="preserve">
          <source>U+203F - U+2040</source>
          <target state="translated">U+203F-U+2040</target>
        </trans-unit>
        <trans-unit id="0c09a7a1795e4fec0be94dc7e91b80a0bf26947f" translate="yes" xml:space="preserve">
          <source>U+2054</source>
          <target state="translated">U+2054</target>
        </trans-unit>
        <trans-unit id="cdc2d82bb3995d9b19eb2ac346b26a7a77b2e28c" translate="yes" xml:space="preserve">
          <source>U+2060 - U+218F</source>
          <target state="translated">U+2060-U+218F</target>
        </trans-unit>
        <trans-unit id="dc13f074c0cd31a6bc8af3c06df64a92b1be84c7" translate="yes" xml:space="preserve">
          <source>U+20D0 - U+20FF</source>
          <target state="translated">U+20D0-U+20FF.</target>
        </trans-unit>
        <trans-unit id="46981b50f5cdfcf424f38b4b3c8b461b58872a28" translate="yes" xml:space="preserve">
          <source>U+2460 - U+24FF</source>
          <target state="translated">U+2460-U+24FF</target>
        </trans-unit>
        <trans-unit id="8e2adfcb84ba00df4ef947391a6eab237e18db97" translate="yes" xml:space="preserve">
          <source>U+2776 - U+2793</source>
          <target state="translated">U+2776-U+2793</target>
        </trans-unit>
        <trans-unit id="0ef4d0c6e728306dc714d1b3534d9c4ee993dccf" translate="yes" xml:space="preserve">
          <source>U+2C00 - U+2DFF</source>
          <target state="translated">U+2C00-U+2DFF.</target>
        </trans-unit>
        <trans-unit id="acd49fd22f227c59f753777c2766efc982471a9a" translate="yes" xml:space="preserve">
          <source>U+2E80 - U+2FFF</source>
          <target state="translated">U+2E80-U+2FFF.</target>
        </trans-unit>
        <trans-unit id="e220b857ae2172b856a1a2e9b7ea31ff3edb4b96" translate="yes" xml:space="preserve">
          <source>U+30000 - U+3FFFD</source>
          <target state="translated">U+30000-U+3FFFD.</target>
        </trans-unit>
        <trans-unit id="311cc5830e93c014a42f3cfe3f333942cdff5c89" translate="yes" xml:space="preserve">
          <source>U+3004 - U+3007</source>
          <target state="translated">U+3004-U+3007</target>
        </trans-unit>
        <trans-unit id="3518418be013a416f360fbc05bd7961da58adcba" translate="yes" xml:space="preserve">
          <source>U+3021 - U+302F</source>
          <target state="translated">U+3021-U+302F</target>
        </trans-unit>
        <trans-unit id="22bc0729fee97afe351038d4206a56bdf37b8cc5" translate="yes" xml:space="preserve">
          <source>U+3031 - U+D7FF</source>
          <target state="translated">U+3031-U+D7FF.</target>
        </trans-unit>
        <trans-unit id="75623274217241111dd8aadc0414c3684e3527d1" translate="yes" xml:space="preserve">
          <source>U+40000 - U+4FFFD</source>
          <target state="translated">U+40000-U+4FFFD;</target>
        </trans-unit>
        <trans-unit id="ad684b1e2d51f2021e6096ff323c755de9835267" translate="yes" xml:space="preserve">
          <source>U+50000 - U+5FFFD</source>
          <target state="translated">U+50000-U+5FFFD;</target>
        </trans-unit>
        <trans-unit id="f48e64f1d20e3e1aa5cf849c51bec6aec208261d" translate="yes" xml:space="preserve">
          <source>U+60000 - U+6FFFD</source>
          <target state="translated">U+60000-U+6FFFD.</target>
        </trans-unit>
        <trans-unit id="27a70a77fa9d62033c98d2e43a4e257bfcba0a32" translate="yes" xml:space="preserve">
          <source>U+70000 - U+7FFFD</source>
          <target state="translated">U+70000-U+7FFFD;</target>
        </trans-unit>
        <trans-unit id="e47ee2f5ce5c5823a3427abfdcb793008f1f9afa" translate="yes" xml:space="preserve">
          <source>U+80000 - U+8FFFD</source>
          <target state="translated">U+80000-U+8FFFD.</target>
        </trans-unit>
        <trans-unit id="ae42c9725173d1af60cd9ee4fec2a5e915a289c9" translate="yes" xml:space="preserve">
          <source>U+90000 - U+9FFFD</source>
          <target state="translated">U+90000-U+9FFFD;</target>
        </trans-unit>
        <trans-unit id="a29e4d5dbda0a54f8aba629dfae926d4d31c7fa4" translate="yes" xml:space="preserve">
          <source>U+A0000 - U+AFFFD</source>
          <target state="translated">U+A0000-U+AFFFD.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
