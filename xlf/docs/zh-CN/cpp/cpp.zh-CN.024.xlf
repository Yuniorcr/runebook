<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="42d66c9df47506c2bbd054315689658beb84bc9e" translate="yes" xml:space="preserve">
          <source>U+B0000 - U+BFFFD</source>
          <target state="translated">U+B0000-U+BFFFD.</target>
        </trans-unit>
        <trans-unit id="cdba1c6047783563972c12317b4d72868b21fd76" translate="yes" xml:space="preserve">
          <source>U+C0000 - U+CFFFD</source>
          <target state="translated">U+C0000-U+CFFFD.</target>
        </trans-unit>
        <trans-unit id="010072229c529f3ca79fb579b3df7190d32934a1" translate="yes" xml:space="preserve">
          <source>U+D0000 - U+DFFFD</source>
          <target state="translated">U+D0000-U+DFFFD.</target>
        </trans-unit>
        <trans-unit id="ce5b442ae1391ac6f3397af8e6e2ed8bbfa37b7f" translate="yes" xml:space="preserve">
          <source>U+E0000 - U+EFFFD</source>
          <target state="translated">U+E0000-U+EFFFD.</target>
        </trans-unit>
        <trans-unit id="520d6df0bba5aba46938723a37a68ea22f05a23c" translate="yes" xml:space="preserve">
          <source>U+F900 - U+FD3D</source>
          <target state="translated">U+F900-U+FD3D</target>
        </trans-unit>
        <trans-unit id="163422b76168f04b02797dee7a00db38f358ee53" translate="yes" xml:space="preserve">
          <source>U+FD40 - U+FDCF</source>
          <target state="translated">U+FD40-U+FDCF</target>
        </trans-unit>
        <trans-unit id="fb7bec8d977e924e7257c5655dae76a42823e7a8" translate="yes" xml:space="preserve">
          <source>U+FDF0 - U+FE44</source>
          <target state="translated">U+FDF0-U+FE44</target>
        </trans-unit>
        <trans-unit id="04089c7fc7f2ca3bf063171c8d318a9d6ea6bbde" translate="yes" xml:space="preserve">
          <source>U+FE20 - U+FE2F</source>
          <target state="translated">U+FE20-U+FE2F</target>
        </trans-unit>
        <trans-unit id="f56e67971694a5871856f55e8563ac4dbbcaec84" translate="yes" xml:space="preserve">
          <source>U+FE47 - U+FFFD</source>
          <target state="translated">U+FE47-U+FFFD</target>
        </trans-unit>
        <trans-unit id="270912477818594d05da0936d300cdd48568315a" translate="yes" xml:space="preserve">
          <source>U&lt;code&gt;( { &lt;/code&gt;arg1, arg2, ...&lt;code&gt;} )&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;( { &lt;/code&gt; arg1，arg2，... &lt;code&gt;} )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="931d496adbd3f197940b61b27f25bcf6e5ce6062" translate="yes" xml:space="preserve">
          <source>UB</source>
          <target state="translated">UB</target>
        </trans-unit>
        <trans-unit id="02625f3ba5ef5ecc340624e8cdbc7bbea1792597" translate="yes" xml:space="preserve">
          <source>UB and optimization</source>
          <target state="translated">UB和优化</target>
        </trans-unit>
        <trans-unit id="fc4cea3d19213a9f2ad0bf9e1d25fcd42a13416e" translate="yes" xml:space="preserve">
          <source>UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</source>
          <target state="translated">UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</target>
        </trans-unit>
        <trans-unit id="2cfb9dd16496ce85eff96d27557f7b42dd5f480d" translate="yes" xml:space="preserve">
          <source>UCS2</source>
          <target state="translated">UCS2</target>
        </trans-unit>
        <trans-unit id="cc245ae082a0221ea07ed3630dd9a406b15ac831" translate="yes" xml:space="preserve">
          <source>UCS2(Windows)</source>
          <target state="translated">UCS2(Windows)</target>
        </trans-unit>
        <trans-unit id="fb192521136df48247e2057851a45e670921483e" translate="yes" xml:space="preserve">
          <source>UDL</source>
          <target state="translated">UDL</target>
        </trans-unit>
        <trans-unit id="b326c17ee1a8eb3c225550246d3d3c78e82f8b2f" translate="yes" xml:space="preserve">
          <source>UINT8_CUINT16_CUINT32_CUINT64_C</source>
          <target state="translated">UINT8_CUINT16_CUINT32_CUINT64_C</target>
        </trans-unit>
        <trans-unit id="6fc76eff0c2b7cb02126a9c106ac3442a9727995" translate="yes" xml:space="preserve">
          <source>UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</source>
          <target state="translated">UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</target>
        </trans-unit>
        <trans-unit id="9ba6e74bce3dda604b2bb3467dd7e8066580c7b5" translate="yes" xml:space="preserve">
          <source>UINTMAX_C</source>
          <target state="translated">UINTMAX_C</target>
        </trans-unit>
        <trans-unit id="5b83709ee00794f8873850a1d8ed0fb42b4fb169" translate="yes" xml:space="preserve">
          <source>UINTMAX_MAX</source>
          <target state="translated">UINTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="ce620a4e99af76df2964e767b6f8444400deb8ca" translate="yes" xml:space="preserve">
          <source>UINTPTR_MAX</source>
          <target state="translated">UINTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="bfda17e335d33e8db92bdb55c45171d922a6859c" translate="yes" xml:space="preserve">
          <source>UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</source>
          <target state="translated">UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="ad74c7ce12e14f74c8c414a0ec98ea6351f500a5" translate="yes" xml:space="preserve">
          <source>UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</source>
          <target state="translated">UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="4196b39d1eebc6a19e223c4aac2d97a9aacf8120" translate="yes" xml:space="preserve">
          <source>UIntType</source>
          <target state="translated">UIntType</target>
        </trans-unit>
        <trans-unit id="469dc1d6169a7065a141b529a6260202a1c8ab1a" translate="yes" xml:space="preserve">
          <source>UNDERTIE - CHARACTER TIE</source>
          <target state="translated">UNDERTIE-人物领带</target>
        </trans-unit>
        <trans-unit id="505551a88f566bb8fb83e0abedb58180312ddfab" translate="yes" xml:space="preserve">
          <source>URBGs and distributions are designed to be used together to produce random values. All of the random number engines may be specifically seeded, serialized, and deserialized for use with repeatable simulators.</source>
          <target state="translated">URBG和分布被设计为一起使用以产生随机值。所有的随机数引擎都可以进行特殊的种子化、序列化和反序列化,以便与可重复的模拟器一起使用。</target>
        </trans-unit>
        <trans-unit id="5a9da893be5fd5fae314bea8dcdeeee12beeec4b" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>
        </trans-unit>
        <trans-unit id="2b2540046f34663d3e4a6d43e9cf9715c955300b" translate="yes" xml:space="preserve">
          <source>UTF-16 big-endian</source>
          <target state="translated">UTF-16大字头</target>
        </trans-unit>
        <trans-unit id="3e0f2acffc4ed45f148e707196e35bf9de816b83" translate="yes" xml:space="preserve">
          <source>UTF-16 little-endian</source>
          <target state="translated">UTF-16小英译本</target>
        </trans-unit>
        <trans-unit id="9d90671c2d02729e29282121f3418c32309d8132" translate="yes" xml:space="preserve">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>
        </trans-unit>
        <trans-unit id="627eba919968fb21d35e780ba4de3a0334bac3b5" translate="yes" xml:space="preserve">
          <source>UTF-32(non-Windows)</source>
          <target state="translated">UTF-32(non-Windows)</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="a2cdcc963eb83efa7c23e1cb852551ce54343476" translate="yes" xml:space="preserve">
          <source>UTF-8 (no effect on endianness)</source>
          <target state="translated">UTF-8(对保密性无影响)</target>
        </trans-unit>
        <trans-unit id="e6f9cf72db2d174ebd905a64df572642f988ef15" translate="yes" xml:space="preserve">
          <source>Unary &lt;a href=&quot;operator_arithmetic#Unary_arithmetic_operators&quot;&gt;plus and minus&lt;/a&gt;</source>
          <target state="translated">一元&lt;a href=&quot;operator_arithmetic#Unary_arithmetic_operators&quot;&gt;加减&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5a792933066b9a9e2ac32f6f06b8c7c9b9c310a" translate="yes" xml:space="preserve">
          <source>Unary arithmetic operators</source>
          <target state="translated">一元算术运算符</target>
        </trans-unit>
        <trans-unit id="3b2a4a75a6716bd612609078150c84a2711d8a91" translate="yes" xml:space="preserve">
          <source>UnaryTypeTrait</source>
          <target state="translated">UnaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="487d4ab7256ac0a9d6c0537cc67b1af3240a7a6a" translate="yes" xml:space="preserve">
          <source>Unblocks all threads currently waiting for &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">取消阻止当前正在等待 &lt;code&gt;*this&lt;/code&gt; 的所有线程。</target>
        </trans-unit>
        <trans-unit id="a36f6dfc5a6d8e565414aa5eb95d57c3673c1b95" translate="yes" xml:space="preserve">
          <source>Undefined Behavior</source>
          <target state="translated">未定义的行为</target>
        </trans-unit>
        <trans-unit id="ae22d7da41718d2107d501afa593d0dc097c049a" translate="yes" xml:space="preserve">
          <source>Undefined Behavior and Fermat&amp;rsquo;s Last Theorem</source>
          <target state="translated">不确定行为和费马最后定理</target>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="translated">未定义的行为</target>
        </trans-unit>
        <trans-unit id="675cd8702b8351b311d54416e35e1e88d24ddc83" translate="yes" xml:space="preserve">
          <source>Undefined behavior can result in time travel (among other things, but time travel is the funkiest)</source>
          <target state="translated">未定义的行为会导致时空旅行(除此之外,但时空旅行是最有趣的)。</target>
        </trans-unit>
        <trans-unit id="148339d92ffb0ef43ac5c644f243daf7596715dc" translate="yes" xml:space="preserve">
          <source>Under a</source>
          <target state="translated">在a下</target>
        </trans-unit>
        <trans-unit id="9b9209c5de57506f2fda8e822d2a3ad3f311f55e" translate="yes" xml:space="preserve">
          <source>Under the following circumstances, the compilers are permitted, but not required to omit the copy and move(since C++11) construction of class objects even if the copy/move(since C++11) constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. This is an optimization: even when it takes place and the copy/move(since C++11) constructor is not called, it still must be present and accessible (as if no optimization happened at all), otherwise the program is ill-formed:</source>
          <target state="translated">在以下情况下,编译器允许但不要求省略类对象的复制和移动(自C++11起)构造,即使复制/移动(自C++11起)构造函数和析构函数有可观察的副作用。对象被直接构造到存储中,否则它们会被复制/移动到那里。这是一种优化:即使发生了这种优化,并且没有调用copy/move(since C++11)构造函数,它仍然必须存在并且可以访问(就像根本没有发生优化一样),否则程序就会不正常。</target>
        </trans-unit>
        <trans-unit id="3bea3f4316b2cc744d56328e836cf72a7190a46d" translate="yes" xml:space="preserve">
          <source>Under the following circumstances, the compilers are required to omit the copy and move construction of class objects, even if the copy/move constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. The copy/move constructors need not be present or accessible, as the language rules ensure that no copy/move operation takes place, even conceptually:</source>
          <target state="translated">在以下情况下,编译器需要省略类对象的复制和移动构造,即使复制/移动构造函数和析构函数具有可观察的副作用。对象被直接构造到存储中,否则它们将被复制/移动到哪里。复制/移动构造函数不需要存在或可访问,因为语言规则确保不会发生复制/移动操作,即使是在概念上。</target>
        </trans-unit>
        <trans-unit id="9c33868b413394e75c10c66bbcac09ee4be1866f" translate="yes" xml:space="preserve">
          <source>Under these conditions, it can be shown that &lt;code&gt;e&lt;/code&gt; is an equivalence relation, and &lt;code&gt;r&lt;/code&gt; induces a strict total ordering on the equivalence classes determined by &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">在这些条件下，可以证明 &lt;code&gt;e&lt;/code&gt; 是一个等价关系，并且 &lt;code&gt;r&lt;/code&gt; 对由 &lt;code&gt;e&lt;/code&gt; 确定的等价类引起严格的总排序。</target>
        </trans-unit>
        <trans-unit id="b828bc3cb0b877121715201877f23784c033074d" translate="yes" xml:space="preserve">
          <source>Underflow is guaranteed if &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt;*(sqrt(&amp;pi;)/2)&lt;/code&gt;  erf(</source>
          <target state="translated">如果 &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt;*(sqrt(&amp;pi;)/2)&lt;/code&gt; 保证下溢 &amp;lt; DBL_MIN *（sqrt（&amp;pi;）/ 2） erf（</target>
        </trans-unit>
        <trans-unit id="5b4fe0953f656d5c3e07304963135e1851f6e5c7" translate="yes" xml:space="preserve">
          <source>Understanding Integer Overflow in C/C++</source>
          <target state="translated">了解C/C++中的整数溢出</target>
        </trans-unit>
        <trans-unit id="5e6066d0264c25a17abb92da4543d5a1bb3137db" translate="yes" xml:space="preserve">
          <source>Unevaluated expressions</source>
          <target state="translated">未评价的表达方式</target>
        </trans-unit>
        <trans-unit id="28df9f930dfb483b42b3b26d6ba0e60a90d200c5" translate="yes" xml:space="preserve">
          <source>Unformatted input</source>
          <target state="translated">非格式化输入</target>
        </trans-unit>
        <trans-unit id="123f1fcb3edd17ce760e7f03ab6319443c344106" translate="yes" xml:space="preserve">
          <source>Unformatted input/output</source>
          <target state="translated">非格式化输入/输出</target>
        </trans-unit>
        <trans-unit id="b123c392cb4c8cf5311ee23670ea9ec4b71c524c" translate="yes" xml:space="preserve">
          <source>Unformatted output</source>
          <target state="translated">非格式化输出</target>
        </trans-unit>
        <trans-unit id="1103a0808298976db7d8e2eb535bd8a9ef0b0697" translate="yes" xml:space="preserve">
          <source>UnformattedInputFunction</source>
          <target state="translated">UnformattedInputFunction</target>
        </trans-unit>
        <trans-unit id="57c86519dc947e7a7668db91684400955bbea92e" translate="yes" xml:space="preserve">
          <source>UnformattedOutputFunction</source>
          <target state="translated">UnformattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="746515815dbd70aa366c5c8ded38ceac411af5b5" translate="yes" xml:space="preserve">
          <source>Unicode characters in identifiers</source>
          <target state="translated">标识符中的Unicode字符</target>
        </trans-unit>
        <trans-unit id="54c4cd3614eda1ec572a80ea2561789d6ec07f9a" translate="yes" xml:space="preserve">
          <source>Unicode conversion facilities</source>
          <target state="translated">统一码转换设施</target>
        </trans-unit>
        <trans-unit id="518945c57eea6f988b28705fe9a73ae61f28aad7" translate="yes" xml:space="preserve">
          <source>Unicode string literals</source>
          <target state="translated">Unicode 字符串</target>
        </trans-unit>
        <trans-unit id="1d88fe66c0582c456f5ec5c8716a0f875d9594aa" translate="yes" xml:space="preserve">
          <source>Uniform container erasure</source>
          <target state="translated">统一的容器擦除</target>
        </trans-unit>
        <trans-unit id="2d5f1d913211ede3bdf584eacf2d1f866d30dd39" translate="yes" xml:space="preserve">
          <source>Uniform distributions</source>
          <target state="translated">统一分配</target>
        </trans-unit>
        <trans-unit id="ebaf278dff4a479e5c381e2d14da13ed28569d5b" translate="yes" xml:space="preserve">
          <source>Uniform random bit generator requirements</source>
          <target state="translated">统一随机比特发生器要求</target>
        </trans-unit>
        <trans-unit id="43fc79a87964e43367c8f806ef4c1bc6c3c17e50" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators</source>
          <target state="translated">统一随机比特发生器</target>
        </trans-unit>
        <trans-unit id="304d61b117a4be33152a4987bccb311ec8786d3d" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators (URBGs), which include both random number engines, which are pseudo-random number generators that generate integer sequences with a uniform distribution, and true random number generators if available;</source>
          <target state="translated">统一随机位发生器(URBG),既包括随机数引擎,即产生统一分布的整数序列的伪随机数发生器,也包括真随机数发生器(如果有的话)。</target>
        </trans-unit>
        <trans-unit id="9961b884b0d41e9f96e9b47f18701458382481af" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators are not intended to be used as random number generators: they are used as the source of random bits (generated in bulk, for efficiency). Any uniform random bit generator may be plugged into any &lt;a href=&quot;../numeric/random&quot;&gt;random number distribution&lt;/a&gt; in order to obtain a random number (formally, a random variate).</source>
          <target state="translated">统一随机位生成器不打算用作随机数生成器：它们用作随机位的源（为了效率而批量生成）。可以将任何统一的随机位生成器插入任何&lt;a href=&quot;../numeric/random&quot;&gt;随机数分布&lt;/a&gt;中，以获得随机数（形式上是随机变量）。</target>
        </trans-unit>
        <trans-unit id="274ada2867567ab3047cbbf8de81549c088960b3" translate="yes" xml:space="preserve">
          <source>UniformRandomBitGenerator</source>
          <target state="translated">UniformRandomBitGenerator</target>
        </trans-unit>
        <trans-unit id="a1a52383b2bc722ac899de02954f212432e3b35b" translate="yes" xml:space="preserve">
          <source>Uninitialized scalar</source>
          <target state="translated">未初始化的标量</target>
        </trans-unit>
        <trans-unit id="78a4eb44ac157ac9e3cfb278647cea168bf4035b" translate="yes" xml:space="preserve">
          <source>Uninitialized storage</source>
          <target state="translated">未初始化存储</target>
        </trans-unit>
        <trans-unit id="669a8f132f6da5ef9c5ce154e361c127d5e3b34d" translate="yes" xml:space="preserve">
          <source>Union declaration</source>
          <target state="translated">联盟宣言</target>
        </trans-unit>
        <trans-unit id="8b963a92c98e754dacda8255ebe746d63728ca26" translate="yes" xml:space="preserve">
          <source>Union-like classes</source>
          <target state="translated">类似工会的班级</target>
        </trans-unit>
        <trans-unit id="3c64374ae8a1f69718dd9c2a053e7f58d07b77ab" translate="yes" xml:space="preserve">
          <source>Union-like classes can be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;tagged unions&lt;/a&gt;.</source>
          <target state="translated">类联合类可用于实现带&lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;标签的联合&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b88a7a2c81e25c95a2b907495a6fc73639f9b55f" translate="yes" xml:space="preserve">
          <source>Unions cannot contain a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, &lt;a href=&quot;as_operator&quot;&gt;copy-assignment&lt;/a&gt; operator, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;).</source>
          <target state="translated">联合不得包含具有非平凡特殊成员函数（&lt;a href=&quot;copy_constructor&quot;&gt;复制构造函数&lt;/a&gt;，&lt;a href=&quot;as_operator&quot;&gt;复制分配&lt;/a&gt;运算符或&lt;a href=&quot;destructor&quot;&gt;析构函数&lt;/a&gt;）的非静态数据成员。</target>
        </trans-unit>
        <trans-unit id="bfa43e96dbedcb883a94acbaaea9cf15eba0504f" translate="yes" xml:space="preserve">
          <source>Unique integer for use as pword/iword index.</source>
          <target state="translated">作为pword/iword索引的唯一整数。</target>
        </trans-unit>
        <trans-unit id="d66a64b1da303d5c4d195ea302bf616e42aaa173" translate="yes" xml:space="preserve">
          <source>Unit type intended for use as a well-behaved empty alternative in &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;. In particular, a variant of non-default-constructible types may list &lt;code&gt;std::monostate&lt;/code&gt; as its first alternative: this makes the variant itself default-constructible.</source>
          <target state="translated">打算在 &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; 用作行为良好的空替代形式的单位类型。特别是，非默认可构造类型的变体可以将 &lt;code&gt;std::monostate&lt;/code&gt; 列为其第一选择：这使该变体本身是默认可构造的。</target>
        </trans-unit>
        <trans-unit id="43b3c1af3450df3cd0e1ac52c9b04b756ccd01b6" translate="yes" xml:space="preserve">
          <source>Unix and Unix-like systems (Linux, Mac OS X)</source>
          <target state="translated">Unix和类似Unix的系统(Linux、Mac OS X)</target>
        </trans-unit>
        <trans-unit id="efec0246344a5eba097c63d394ab6c8738a45789" translate="yes" xml:space="preserve">
          <source>Unknown permissions (e.g. when &lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt; is created without permissions)</source>
          <target state="translated">未知权限（例如，创建没有权限的&lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt;时）</target>
        </trans-unit>
        <trans-unit id="689c51725b427087666b6048cec59bcb29fcbece" translate="yes" xml:space="preserve">
          <source>Unknown specializations</source>
          <target state="translated">不明专业</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="2103e6143f9ffb325540052fdb6e95f6374d7553" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;OFF&lt;/code&gt;, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is, optimizations that omit rounding errors and floating-point exceptions are allowed. For example, C++ allows the implementation of &lt;code&gt;(x*y) + z&lt;/code&gt; with a single fused multiply-add CPU instruction or optimization of &lt;code&gt;a = x*x*x*x;&lt;/code&gt; as &lt;code&gt;tmp = x *x; a = tmp*tmp&lt;/code&gt;.</source>
          <target state="translated">除非支持&lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt; &lt;/a&gt;并将其设置为 &lt;code&gt;OFF&lt;/code&gt; ，否则所有浮点运算都可以像中间结果具有无限范围和精度一样执行，即允许忽略舍入错误和浮点异常的优化。例如，C ++允许通过单个融合的乘法加法CPU指令或（ &lt;code&gt;a = x*x*x*x;&lt;/code&gt; 优化 &lt;code&gt;(x*y) + z&lt;/code&gt; 实现（x * y）+ z ；如 &lt;code&gt;tmp = x *x; a = tmp*tmp&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07db20d2d23583077e6ea6e7dac4ed0dbdee1a6b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted input.</source>
          <target state="translated">除非发出了 &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; ，否则从格式化和未格式化输入的多个线程同时访问这些对象是安全的。</target>
        </trans-unit>
        <trans-unit id="24cf8fcc45f1c3c9991d569649560b6a524615c5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted output.</source>
          <target state="translated">除非发出了 &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; ，否则可以安全地从多个线程同时访问这些对象以进行格式化和未格式化输出。</target>
        </trans-unit>
        <trans-unit id="ffb634a2a2ce0ccfeec2cc3fe27d921270b24978" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">除非发生范围错误，否则将忽略&lt;a href=&quot;../fenv/fe_round&quot;&gt;当前舍入模式&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b15a066b3b603647166b0b65f64183254893ada5" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised (the result is exact)</source>
          <target state="translated">除非发生范围错误， &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; 永远不会引发FE_INEXACT（结果正确）</target>
        </trans-unit>
        <trans-unit id="7a8fedd6b20728353d81d9da733470bcfcd14b54" translate="yes" xml:space="preserve">
          <source>Unless a variable template was &lt;a href=&quot;template_specialization&quot;&gt;explicitly specialized&lt;/a&gt; or explicitly instantiated, it is implicitly instantiated when a specialization of the variable template is used.</source>
          <target state="translated">除非变量模板被&lt;a href=&quot;template_specialization&quot;&gt;显式专用&lt;/a&gt;化或显式实例化，否则在使用变量模板的专用化时将隐式实例化。</target>
        </trans-unit>
        <trans-unit id="73ad983fb74c97b086aa0802f13da903aa886831" translate="yes" xml:space="preserve">
          <source>Unless noted otherwise, every expression used in a</source>
          <target state="translated">除非另有说明,否则在</target>
        </trans-unit>
        <trans-unit id="0e8d48b8c7d263f43322d50666aca5a3f152bb21" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, all standard library objects that have been moved from are placed in a valid but unspecified state. That is, only the functions without preconditions, such as the assignment operator, can be safely used on the object after it was moved from:</source>
          <target state="translated">除非另有规定,否则所有被移出的标准库对象都会被置于有效但未指定的状态。也就是说,只有无前提条件的函数,如赋值运算符,才能安全地在移出后的对象上使用。</target>
        </trans-unit>
        <trans-unit id="50f2a51822d2bc1f7472ad730cc910af100ceb07" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../optional/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt;&lt;/a&gt;, hash of a variant does not typically equal the hash of the contained value; this makes it possible to distinguish &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; holding the same value as different alternatives.</source>
          <target state="translated">与&lt;a href=&quot;../optional/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt; &lt;/a&gt;，变量的哈希通常不等于所包含值的哈希；这样就可以区分具有相同值的 &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; 作为不同的选择。</target>
        </trans-unit>
        <trans-unit id="338f8ce75fb81cb04c2ab9cbb733a6def87c3d13" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, it can be used in multipass algorithms.</source>
          <target state="translated">与&lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;和&lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;不同，它可以在多遍算法中使用。</target>
        </trans-unit>
        <trans-unit id="612a7e68b15f6d911dae610df0e6c53ee095c272" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt;. In addition, &lt;code&gt;try_emplace&lt;/code&gt; treats the key and the arguments to the &lt;code&gt;mapped_type&lt;/code&gt; separately, unlike &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, which requires the arguments to construct a &lt;code&gt;value_type&lt;/code&gt; (that is, a &lt;code&gt;std::pair&lt;/code&gt;).</source>
          <target state="translated">与&lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt;或&lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;不同，如果不执行插入操作，这些函数不会从rvalue参数中移出，这使操作值仅为移动类型的 &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt; （如std :: map &amp;lt;std :: string，std：:）变得容易。unique_ptr &amp;lt;foo &amp;gt;&amp;gt;。此外， &lt;code&gt;try_emplace&lt;/code&gt; 对待密钥和参数给 &lt;code&gt;mapped_type&lt;/code&gt; 分开，不像&lt;a href=&quot;emplace&quot;&gt;布设&lt;/a&gt;，这需要的参数来构建 &lt;code&gt;value_type&lt;/code&gt; （即，一个 &lt;code&gt;std::pair&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6875db19fce8401ca9aebbb20205b26bb728d1fd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as &lt;code&gt;std::unordered_map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt;. In addition, &lt;code&gt;try_emplace&lt;/code&gt; treats the key and the arguments to the &lt;code&gt;mapped_type&lt;/code&gt; separately, unlike &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, which requires the arguments to construct a &lt;code&gt;value_type&lt;/code&gt; (that is, a &lt;code&gt;std::pair&lt;/code&gt;).</source>
          <target state="translated">与&lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt;或&lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;不同，如果不执行插入操作，这些函数不会从rvalue参数移出，这使操作值仅为移动类型的映射（如 &lt;code&gt;std::unordered_map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt; 变得容易。unique_ptr &amp;lt;foo &amp;gt;&amp;gt;。此外， &lt;code&gt;try_emplace&lt;/code&gt; 对待密钥和参数给 &lt;code&gt;mapped_type&lt;/code&gt; 分开，不像&lt;a href=&quot;emplace&quot;&gt;布设&lt;/a&gt;，这需要的参数来构建 &lt;code&gt;value_type&lt;/code&gt; （即，一个 &lt;code&gt;std::pair&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2de29ed23c34ba831619b83b8554947943971200" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../basic_string/data&quot;&gt;std::basic_string::data()&lt;/a&gt;&lt;/code&gt; and string literals, &lt;code&gt;data()&lt;/code&gt; may return a pointer to a buffer that is not null-terminated. Therefore it is typically a mistake to pass &lt;code&gt;data()&lt;/code&gt; to a routine that takes just a &lt;code&gt;const CharT*&lt;/code&gt; and expects a null-terminated string.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../basic_string/data&quot;&gt;std::basic_string::data()&lt;/a&gt;&lt;/code&gt; 和字符串文字不同， &lt;code&gt;data()&lt;/code&gt; 可能会返回一个指向非空终止缓冲区的指针。因此，将 &lt;code&gt;data()&lt;/code&gt; 传递到仅接受 &lt;code&gt;const CharT*&lt;/code&gt; 并期望以空值结尾的字符串的例程通常是一个错误。</target>
        </trans-unit>
        <trans-unit id="b42b73288e226f5ad79616019df229c7343f10e7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../basic_string/operator_at&quot;&gt;std::basic_string::operator[]&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::basic_string_view::operator[](size())&lt;/code&gt; has undefined behavior instead of returning &lt;code&gt;CharT()&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../basic_string/operator_at&quot;&gt;std::basic_string::operator[]&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;std::basic_string_view::operator[](size())&lt;/code&gt; 具有未定义的行为，而不是返回 &lt;code&gt;CharT()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82cf3dbf0c22a41175cd7995812ae5e616d63672" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;std::strtok&lt;/a&gt;&lt;/code&gt;, this function does not update static storage: it stores the parser state in the user-provided location.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;std::strtok&lt;/a&gt;&lt;/code&gt; 不同，此函数不会更新静态存储：它将解析器状态存储在用户提供的位置。</target>
        </trans-unit>
        <trans-unit id="4887cd4b1d808c0fb500939d898308b30c68c620" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::greater&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;gt;&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;std::ranges::greater&lt;/code&gt; 要求所有六个比较运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 都是有效的（通过&lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt;约束），并且完全根据 &lt;code&gt;std::ranges::less&lt;/code&gt; 定义:: ranges :: less。但是，该实现可以自由地直接使用 &lt;code&gt;operator&amp;gt;&lt;/code&gt; ，因为这些概念要求比较运算符的结果保持一致。</target>
        </trans-unit>
        <trans-unit id="76b2faafc9a3dbd22464e63c0ec0383467b9c99f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::greater_equal&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;gt;=&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;std::ranges::greater_equal&lt;/code&gt; 要求所有六个比较运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 都是有效的（通过&lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt;约束），并且完全根据 &lt;code&gt;std::ranges::less&lt;/code&gt; 定义:: ranges :: less。但是，该实现可以自由地直接使用 &lt;code&gt;operator&amp;gt;=&lt;/code&gt; ，因为这些概念要求比较运算符的结果保持一致。</target>
        </trans-unit>
        <trans-unit id="78dbcad5e4fbe558a33518be37657107f091659c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::less_equal&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;lt;=&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;std::ranges::less_equal&lt;/code&gt; 要求所有六个比较运算符 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;=&lt;/code&gt; ， &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 都是有效的（通过&lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt;约束），并且完全根据 &lt;code&gt;std::ranges::less&lt;/code&gt; 定义:: ranges :: less。但是，该实现可自由直接使用 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; ，因为这些概念要求比较运算符的结果保持一致。</target>
        </trans-unit>
        <trans-unit id="98c9c16f2e98cd689703db22c46385c7c82dbbfc" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../map/operator_at&quot;&gt;std::map::operator[]&lt;/a&gt;&lt;/code&gt;, this operator never inserts a new element into the container.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../map/operator_at&quot;&gt;std::map::operator[]&lt;/a&gt;&lt;/code&gt; ，此运算符从不向容器中插入新元素。</target>
        </trans-unit>
        <trans-unit id="83c22ec940642abd3fc1b2b3f91bda4fefd9187c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::not_equal_to&lt;/code&gt; requires both &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/equalitycomparable&quot;&gt;&lt;code&gt;EqualityComparableWith&lt;/code&gt;&lt;/a&gt; constraint), and is entirely defined in terms of &lt;code&gt;std::ranges::equal_to&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator!=&lt;/code&gt; directly, because those concepts require the results of &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be consistent.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;std::ranges::not_equal_to&lt;/code&gt; 要求 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 都有效（通过&lt;a href=&quot;../../../concepts/equalitycomparable&quot;&gt; &lt;code&gt;EqualityComparableWith&lt;/code&gt; &lt;/a&gt;约束），并且完全根据 &lt;code&gt;std::ranges::equal_to&lt;/code&gt; 。但是，该实现可自由直接使用 &lt;code&gt;operator!=&lt;/code&gt; ，因为这些概念要求 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt; 的结果保持一致。</target>
        </trans-unit>
        <trans-unit id="a93ac31e396db5acf4776ae92718a031c6e2a35d" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; (which has &lt;code&gt;&lt;a href=&quot;../shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;std::make_unique&lt;/code&gt; does not have an allocator-aware counterpart. A hypothetical &lt;code&gt;allocate_unique&lt;/code&gt; would be required to invent the deleter type &lt;code&gt;D&lt;/code&gt; for the &lt;code&gt;unique_ptr&amp;lt;T,D&amp;gt;&lt;/code&gt; it returns which would contain an allocator object and invoke both &lt;code&gt;destroy&lt;/code&gt; and &lt;code&gt;deallocate&lt;/code&gt; in its &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; （具有 &lt;code&gt;&lt;a href=&quot;../shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt; ）不同， &lt;code&gt;std::make_unique&lt;/code&gt; 没有可识别分配器的副本。需要一个假设的 &lt;code&gt;allocate_unique&lt;/code&gt; 来为它返回的 &lt;code&gt;unique_ptr&amp;lt;T,D&amp;gt;&lt;/code&gt; 发明删除器类型 &lt;code&gt;D&lt;/code&gt; ，该类型将包含分配器对象并在其 &lt;code&gt;operator()&lt;/code&gt; 中调用 &lt;code&gt;destroy&lt;/code&gt; 和 &lt;code&gt;deallocate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfa95d30700702ce194a65101a9f73a0be8c3e37" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, the deleter of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; is invoked even if the managed pointer is null.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 不同，即使托管指针为null，也会调用 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 的删除器。</target>
        </trans-unit>
        <trans-unit id="bcc84ea13a79573b43e6585e6b696a907d0811f1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt;, this manipulator does not flush the stream.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; 不同，此操纵器不会刷新流。</target>
        </trans-unit>
        <trans-unit id="efa45df35e365dacc26b0c10d8f1d5381eb5b951" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt;, performs a bounds check and throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos&lt;/code&gt; does not correspond to a valid position in the bitset.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt; 不同，如果 &lt;code&gt;pos&lt;/code&gt; 不对应于位集中的有效位置，则执行边界检查并抛出 &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; out_of_range。</target>
        </trans-unit>
        <trans-unit id="f987fe2de50e7bdc36ad5bea121ee3e9648279c4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::forward_list::remove&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt; accepts heterogenous types and does not force a conversion to the container's value type before invoking the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::forward_list::remove&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;erase&lt;/code&gt; 接受异构类型，并且在调用 &lt;code&gt;==&lt;/code&gt; 运算符之前不会强制转换为容器的值类型。</target>
        </trans-unit>
        <trans-unit id="173b793fffeab067a076675a0bbf0ba3c09de869" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::list::remove&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt; accepts heterogenous types and does not force a conversion to the container's value type before invoking the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::list::remove&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;erase&lt;/code&gt; 接受 &lt;code&gt;==&lt;/code&gt; 运算符之前接受异类类型，并且不强制转换为容器的值类型。</target>
        </trans-unit>
        <trans-unit id="4c977d4a7c4e43375bfbd8db6568cbdff01d3089" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::unique_ptr&lt;/code&gt; may manage an object through any custom handle type that satisfies &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;. This allows, for example, managing objects located in shared memory, by supplying a &lt;code&gt;Deleter&lt;/code&gt; that defines &lt;code&gt;typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; or another &lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;fancy pointer&lt;/a&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 不同， &lt;code&gt;std::unique_ptr&lt;/code&gt; 可以通过满足&lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer的&lt;/a&gt;任何自定义句柄类型来管理对象。例如，这允许通过提供定义 &lt;code&gt;typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost :: offset_ptr&lt;/a&gt;指针的 &lt;code&gt;Deleter&lt;/code&gt; 来管理位于共享内存中的对象。或其他&lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;花哨的指针&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1573c755f58e9c4746c81740477c0b3b24dac236" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;test&quot;&gt;test()&lt;/a&gt;&lt;/code&gt;, does not throw exceptions: the behavior is undefined if &lt;code&gt;pos&lt;/code&gt; is out of bounds.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;test&quot;&gt;test()&lt;/a&gt;&lt;/code&gt; 不同，它不会引发异常：如果 &lt;code&gt;pos&lt;/code&gt; 超出范围，则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="6eba30f9f21127f9176b2a660cfad2f04c8b9efb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;static_cast&lt;/code&gt;, but like &lt;code&gt;const_cast&lt;/code&gt;, the &lt;code&gt;reinterpret_cast&lt;/code&gt; expression does not compile to any CPU instructions (except when converting between integers and pointers or on obscure architectures where pointer representation depends on its type). It is purely a compile-time directive which instructs the compiler to treat expression as if it had the type new_type.</source>
          <target state="translated">与 &lt;code&gt;static_cast&lt;/code&gt; 不同，但与 &lt;code&gt;const_cast&lt;/code&gt; 一样， &lt;code&gt;reinterpret_cast&lt;/code&gt; 表达式不会编译为任何CPU指令（在整数和指针之间进行转换时，或者在指针表示形式取决于其类型的晦涩架构上除外）。它纯粹是一个编译时指令，它指示编译器将表达式视为具有new_type类型。</target>
        </trans-unit>
        <trans-unit id="f39585865906a9f2075869fd7919be30089c3370" translate="yes" xml:space="preserve">
          <source>Unlike Rule of Three, failing to provide move constructor and move assignment is usually not an error, but a missed optimization opportunity.</source>
          <target state="translated">与规则三不同的是,没有提供移动构造函数和移动分配通常不是错误,而是错过了优化机会。</target>
        </trans-unit>
        <trans-unit id="57237dac9eb413318550844e3881a717ec402781" translate="yes" xml:space="preserve">
          <source>Unlike explicit constructors, which are only considered during &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; (which includes &lt;a href=&quot;explicit_cast&quot;&gt;explicit conversions&lt;/a&gt; such as &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt;), converting constructors are also considered during &lt;a href=&quot;copy_initialization&quot;&gt;copy initialization&lt;/a&gt;, as part of &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequence&lt;/a&gt;.</source>
          <target state="translated">与仅在&lt;a href=&quot;direct_initialization&quot;&gt;直接初始化&lt;/a&gt;（包括&lt;a href=&quot;explicit_cast&quot;&gt;显式转换，&lt;/a&gt;例如&lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt;）时才考虑的显式构造函数不同，在&lt;a href=&quot;copy_initialization&quot;&gt;拷贝初始化&lt;/a&gt;期间，也将转换的构造函数视为&lt;a href=&quot;implicit_cast&quot;&gt;用户定义的转换序列的&lt;/a&gt;一部分，因此不考虑这些构造函数。</target>
        </trans-unit>
        <trans-unit id="0519031d106f159f57ffffbcb3c189318dbf95d8" translate="yes" xml:space="preserve">
          <source>Unlike for &lt;code&gt;&lt;a href=&quot;../../container/vector/clear&quot;&gt;std::vector::clear&lt;/a&gt;&lt;/code&gt;, the C++ standard does not explicitly require that &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt; is unchanged by this function, but existing implementations do not change capacity. This means that they do not release the allocated memory (see also &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../../container/vector/clear&quot;&gt;std::vector::clear&lt;/a&gt;&lt;/code&gt; ，C ++标准没有明确要求此功能不变 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt; ，但是现有实现不更改容量。这意味着它们不会释放分配的内存（另请参见 &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="005bffdc5ce748f5fa7ecab037e6b4ba23fd3f4c" translate="yes" xml:space="preserve">
          <source>Unlike formatted output functions, this function does not set the &lt;code&gt;failbit&lt;/code&gt; if the output fails.</source>
          <target state="translated">不像格式化输出函数，此函数不设置 &lt;code&gt;failbit&lt;/code&gt; 如果输出失败。</target>
        </trans-unit>
        <trans-unit id="c11ef1e4f5cbd932283bfef60dfc1f2ad7da6484" translate="yes" xml:space="preserve">
          <source>Unlike functions or references to functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, etc.</source>
          <target state="translated">与函数或函数引用不同的是,函数的指针是对象,因此可以在数组中存储、复制、分配等。</target>
        </trans-unit>
        <trans-unit id="4fc1a9b3bf127389b70df7d40bbc2018c53338a0" translate="yes" xml:space="preserve">
          <source>Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with &lt;code&gt;#pragma once&lt;/code&gt; files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.</source>
          <target state="translated">与标头保护程序不同，此实用程序使得不可能在多个文件中错误地使用相同的宏名。另一方面，由于使用 &lt;code&gt;#pragma once&lt;/code&gt; 根据文件系统级别的身份将文件排除在外，如果文件头存在于项目中的多个位置，则无法避免两次包含文件头。</target>
        </trans-unit>
        <trans-unit id="ee79da911cfc98f59e02246e9625087f966f6ee4" translate="yes" xml:space="preserve">
          <source>Unlike many related functions, this function is</source>
          <target state="translated">与许多相关函数不同,这个函数是</target>
        </trans-unit>
        <trans-unit id="c7ea1f99bf46737fd3a9eb5569bcdb5f3547a949" translate="yes" xml:space="preserve">
          <source>Unlike most assignment operators, the assignment operator for &lt;code&gt;atomic_ref&lt;/code&gt; does not return a reference to its left-hand argument. It returns a copy of the stored value instead.</source>
          <target state="translated">与大多数赋值运算符不同， &lt;code&gt;atomic_ref&lt;/code&gt; 的赋值运算符不会返回对其左侧参数的引用。而是返回存储值的副本。</target>
        </trans-unit>
        <trans-unit id="1a4db73f4f2b5f3d23685150e26ab0e326ffc436" translate="yes" xml:space="preserve">
          <source>Unlike most assignment operators, the assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">与大多数赋值运算符不同,原子类型的赋值运算符不返回对左手参数的引用。它们返回的是存储值的副本。</target>
        </trans-unit>
        <trans-unit id="3697fcced78a8dc2e1dd58511d1675942ea9902d" translate="yes" xml:space="preserve">
          <source>Unlike most compound assignment operators, the compound assignment operators for &lt;code&gt;atomic_ref&lt;/code&gt; do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">与大多数复合赋值运算符不同， &lt;code&gt;atomic_ref&lt;/code&gt; 的复合赋值运算符不会返回对其左侧参数的引用。他们返回存储值的副本。</target>
        </trans-unit>
        <trans-unit id="139203564aef61dc9e502ac41ea33308504a0622" translate="yes" xml:space="preserve">
          <source>Unlike most compound assignment operators, the compound assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">与大多数复合赋值运算符不同,原子类型的复合赋值运算符不返回对左手参数的引用。它们返回的是存储值的副本。</target>
        </trans-unit>
        <trans-unit id="dda22864e1900bb6a87e878513e661e3ee5d8ee4" translate="yes" xml:space="preserve">
          <source>Unlike most mathematical operations, the conversion of a floating-point value to text and back is</source>
          <target state="translated">与大多数数学运算不同的是,将浮点值转换为文本,然后再转换回来。</target>
        </trans-unit>
        <trans-unit id="76a29065db67fecaafea29ca64388623baf0bcbc" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;std::wcstok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">与大多数其他标记器不同， &lt;code&gt;std::wcstok&lt;/code&gt; 的分隔符对于每个后续标记都可以不同，甚至可以取决于先前标记的内容。</target>
        </trans-unit>
        <trans-unit id="c348ec3650d4d97ed9bc09e83c2572c81d376d68" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;strtok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">与大多数其他标记器不同， &lt;code&gt;strtok&lt;/code&gt; 中的分隔符对于每个后续标记都可以不同，甚至可以取决于先前标记的内容。</target>
        </trans-unit>
        <trans-unit id="e499b26c05a23f391924b25bade94974b21959a1" translate="yes" xml:space="preserve">
          <source>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for &lt;code&gt;atomic_ref&lt;/code&gt; do not return a reference to the modified object. They return a copy of the stored value instead.</source>
          <target state="translated">与大多数预递增和递减运算符不同， &lt;code&gt;atomic_ref&lt;/code&gt; 的预递增和递减运算符不会返回对已修改对象的引用。他们返回存储值的副本。</target>
        </trans-unit>
        <trans-unit id="247d65607595333e4901228f7023c088dbe9e552" translate="yes" xml:space="preserve">
          <source>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for atomic types do not return a reference to the modified object. They return a copy of the stored value instead.</source>
          <target state="translated">与大多数预增和预减运算符不同,原子类型的预增和预减运算符不返回对修改对象的引用。它们返回的是存储值的副本。</target>
        </trans-unit>
        <trans-unit id="536f52cdb9582b6792ddf498c21f83ff3bc9d9a5" translate="yes" xml:space="preserve">
          <source>Unlike other formatting functions in C++ and C libraries, &lt;code&gt;std::to_chars&lt;/code&gt; is locale-independent, non-allocating, and non-throwing. Only a small subset of formatting policies used by other libraries (such as &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::sprintf&lt;/a&gt;&lt;/code&gt;) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange (JSON or XML).</source>
          <target state="translated">与C ++和C库中的其他格式化函数不同， &lt;code&gt;std::to_chars&lt;/code&gt; 是与语言环境无关的，非分配的和非抛出的。仅提供其他库使用的一小部分格式化策略（例如 &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::sprintf&lt;/a&gt;&lt;/code&gt; ）。这旨在允许在常见的高吞吐量上下文（例如基于文本的交换（JSON或XML））中使用的最快可能的实现。</target>
        </trans-unit>
        <trans-unit id="960cf91e24a03ae762e9fec6a351793c82e6e03d" translate="yes" xml:space="preserve">
          <source>Unlike other functions that take &lt;code&gt;std::valarray&lt;/code&gt; arguments, &lt;code&gt;begin()&lt;/code&gt; cannot accept the replacement types (such as the types produced by expression templates) that may be returned from expressions involving valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(v1 + v2)&lt;/code&gt; is not portable, &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; has to be used instead.</source>
          <target state="translated">与采用 &lt;code&gt;std::valarray&lt;/code&gt; 参数的其他函数不同， &lt;code&gt;begin()&lt;/code&gt; 无法接受可能从涉及valarrays的表达式返回的替换类型（例如表达式模板生成的类型）： &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(v1 + v2)&lt;/code&gt; 不具有可移植性，必须使用 &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07020cc0a6112afa1a94ca2a985fb8992ea81c5d" translate="yes" xml:space="preserve">
          <source>Unlike other functions that take &lt;code&gt;std::valarray&lt;/code&gt; arguments, &lt;code&gt;end()&lt;/code&gt; cannot accept the replacement types (such as the types produced by expression templates) that may be returned from expressions involving valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(v1 + v2)&lt;/code&gt; is not portable, &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; has to be used instead.</source>
          <target state="translated">与其他 &lt;code&gt;std::valarray&lt;/code&gt; 参数的函数不同， &lt;code&gt;end()&lt;/code&gt; 无法接受可能从涉及valarrays的表达式返回的替换类型（例如，表达式模板生成的类型）： &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(v1 + v2)&lt;/code&gt; 是不可移植的，必须使用 &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82b08c1bafac008cc3356484b3bea8b8da199f4c" translate="yes" xml:space="preserve">
          <source>Unlike other parsing functions in C++ and C libraries, &lt;code&gt;std::from_chars&lt;/code&gt; is locale-independent, non-allocating, and non-throwing. Only a small subset of parsing policies used by other libraries (such as &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::sscanf&lt;/a&gt;&lt;/code&gt;) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange (JSON or XML).</source>
          <target state="translated">与C ++和C库中的其他解析函数不同， &lt;code&gt;std::from_chars&lt;/code&gt; 是与语言环境无关的，非分配的和非抛出的。仅提供其他库（例如 &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::sscanf&lt;/a&gt;&lt;/code&gt; ）使用的一小部分解析策略。这旨在允许在常见的高吞吐量上下文（例如基于文本的交换（JSON或XML））中使用的最快可能的实现。</target>
        </trans-unit>
        <trans-unit id="bc22867a4de3145dca568d4e66ffa742bf46b614" translate="yes" xml:space="preserve">
          <source>Unlike other temporary objects, the exception object is considered to be an lvalue argument when initializing the catch clause parameters, so it can be caught by lvalue reference, modified, and rethrown.</source>
          <target state="translated">与其他临时对象不同的是,异常对象在初始化catch子句参数时被认为是一个lvalue参数,所以可以通过lvalue引用来捕获、修改和重抛。</target>
        </trans-unit>
        <trans-unit id="40e4049da792f251c064108725448595e7fb81c8" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; named requirement, &lt;code&gt;std::Destructible&lt;/code&gt; requires the destructor to be &lt;code&gt;noexcept(true)&lt;/code&gt;, not merely non-throwing when invoked, and allows reference types and array types.</source>
          <target state="translated">与&lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;命名需求不同， &lt;code&gt;std::Destructible&lt;/code&gt; 要求析构函数为 &lt;code&gt;noexcept(true)&lt;/code&gt; ，不仅在调用时是非抛出的，而且还允许引用类型和数组类型。</target>
        </trans-unit>
        <trans-unit id="f2ff26def44fad2ae044095e7f187e2f9c03b39d" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; constructors, &lt;code&gt;std::make_shared&lt;/code&gt; does not allow a custom deleter.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 构造函数不同， &lt;code&gt;std::make_shared&lt;/code&gt; 不允许自定义删除器。</target>
        </trans-unit>
        <trans-unit id="1c6f8d4294a5e322f2430ee23bff35686e775144" translate="yes" xml:space="preserve">
          <source>Unlike the primary template &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt;, this specialization does not perform a virtual function call when classifying characters. To customize the behavior, a derived class may provide a non-default classification table to the base class constructor.</source>
          <target state="translated">与主要模板 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; ，此专业分类字符时不会执行虚拟函数调用。为了自定义行为，派生类可以向基类构造函数提供非默认分类表。</target>
        </trans-unit>
        <trans-unit id="3a3c250893800a21b88186ef185aadaf831d7992" translate="yes" xml:space="preserve">
          <source>Unlike the promotions, numeric conversions may change the values, with potential loss of precision.</source>
          <target state="translated">与促销不同的是,数值转换可能会改变数值,有可能损失精度。</target>
        </trans-unit>
        <trans-unit id="5cf90c59183d16b061b44fcdd59d790f2d00de63" translate="yes" xml:space="preserve">
          <source>Unlike the rest of the algorithms, for_each is not allowed to make copies of the elements in the sequence even if they are trivially copyable.</source>
          <target state="translated">与其他算法不同的是,for_each不允许对序列中的元素进行复制,即使这些元素是可复制的。</target>
        </trans-unit>
        <trans-unit id="db1ac6c9a5b777adb044dcf5cc2c8e1d9362ebb5" translate="yes" xml:space="preserve">
          <source>Unlike the std::shared_ptr constructors, std::allocate_shared does not accept a separate custom deleter: the supplied allocator is used for destruction of the control block and the &lt;code&gt;T&lt;/code&gt; object, and for deallocation of their shared memory block.</source>
          <target state="translated">与std :: shared_ptr构造函数不同，std :: allocate_shared不接受单独的自定义删除器：提供的分配器用于销毁控制块和 &lt;code&gt;T&lt;/code&gt; 对象，以及释放它们的共享内存块。</target>
        </trans-unit>
        <trans-unit id="66abfa107dcdc9f5699b86a1259047a6420b2c52" translate="yes" xml:space="preserve">
          <source>Unlike type template parameter declaration, template template parameter declaration can only use the keyword &lt;code&gt;class&lt;/code&gt; and not &lt;code&gt;typename&lt;/code&gt;.</source>
          <target state="translated">与类型模板参数声明不同，模板模板参数声明只能使用关键字 &lt;code&gt;class&lt;/code&gt; ,而不能使用 &lt;code&gt;typename&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d675911d340ea7fe2bddf254d2a266f734dde906" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;code&gt;&lt;a href=&quot;append&quot;&gt;append()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;append&quot;&gt;operator/=&lt;/a&gt;&lt;/code&gt;, additional directory separators are never introduced.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;append&quot;&gt;append()&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;append&quot;&gt;operator/=&lt;/a&gt;&lt;/code&gt; 不同，从不引入其他目录分隔符。</target>
        </trans-unit>
        <trans-unit id="9795510ddaf8f7b584f9cfa5390b07d1db4d7240" translate="yes" xml:space="preserve">
          <source>Unlocks the associated mutex and releases ownership.</source>
          <target state="translated">解锁相关的mutex并释放所有权。</target>
        </trans-unit>
        <trans-unit id="f433ee5a4f5ef551015f8cbf8189774e6d42e0da" translate="yes" xml:space="preserve">
          <source>Unlocks the associated mutex from shared mode. Effectively calls &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;.</source>
          <target state="translated">从共享模式解锁关联的互斥锁。有效地调用 &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="961e1771431741648b7410afa7f25aec8f8bb6ba" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex if its level of ownership is &lt;code&gt;1&lt;/code&gt; (there was exactly one more call to &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; than there were calls to &lt;code&gt;unlock()&lt;/code&gt; made by this thread), reduces the level of ownership by 1 otherwise.</source>
          <target state="translated">如果互斥锁的所有权级别为 &lt;code&gt;1&lt;/code&gt; ,则解锁互斥 &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; 与该线程进行的对 &lt;code&gt;unlock()&lt;/code&gt; 的调用相比，对lock（）的调用要多一个），否则将其所有权级别降低1。</target>
        </trans-unit>
        <trans-unit id="3292cba2e9fa684816c3433f5e680ff1211985aa" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex.</source>
          <target state="translated">解锁mutex。</target>
        </trans-unit>
        <trans-unit id="e5ecb1ac5a3284b964b98f95170550776c6f7221" translate="yes" xml:space="preserve">
          <source>Unnamed functions can be generated by &lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt;.</source>
          <target state="translated">未命名的函数可以由&lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt;生成。</target>
        </trans-unit>
        <trans-unit id="f4abed0ca00f10480f822ed4f5c54c15d912133a" translate="yes" xml:space="preserve">
          <source>Unnamed namespaces</source>
          <target state="translated">未命名的命名空间</target>
        </trans-unit>
        <trans-unit id="ce07e4c5885039551bddbc7d0f27189dfc040aaa" translate="yes" xml:space="preserve">
          <source>Unnamed namespaces as well as all namespaces declared directly or indirectly within an unnamed namespace have &lt;a href=&quot;storage_duration#Linkage&quot;&gt;internal linkage&lt;/a&gt;, which means that any name that is declared within an unnamed namespace has internal linkage.</source>
          <target state="translated">未命名的命名空间以及在未命名的命名空间中直接或间接声明的所有命名空间都具有&lt;a href=&quot;storage_duration#Linkage&quot;&gt;内部链接&lt;/a&gt;，这意味着在未命名的命名空间中声明的任何名称都具有内部链接。</target>
        </trans-unit>
        <trans-unit id="55c746743e689c2f62e5b9408423fdd2d1439715" translate="yes" xml:space="preserve">
          <source>Unordered associative containers</source>
          <target state="translated">无序关联容器</target>
        </trans-unit>
        <trans-unit id="67512286f8974c10c046fc1f0f6675019780544f" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are &lt;a href=&quot;container&quot;&gt;Containers&lt;/a&gt; that provide fast lookup of objects based on keys. Worst case complexity is linear but on average much faster for most of the operations.</source>
          <target state="translated">无序关联容器是根据键提供对对象的快速查找的&lt;a href=&quot;container&quot;&gt;容器&lt;/a&gt;。最坏情况下的复杂度是线性的，但是对于大多数操作而言，平均速度要快得多。</target>
        </trans-unit>
        <trans-unit id="5721c8ff7733bb174444b2a6b021b024c56a1897" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are parametrized by &lt;code&gt;Key&lt;/code&gt;; &lt;code&gt;Hash&lt;/code&gt;, a &lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt; function object which acts as hash function on &lt;code&gt;Key&lt;/code&gt;; and &lt;code&gt;Pred&lt;/code&gt;, a &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; evaluating equivalence between &lt;code&gt;Key&lt;/code&gt;s. &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; also have a mapped type &lt;code&gt;T&lt;/code&gt; associated with the &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">无序关联容器由 &lt;code&gt;Key&lt;/code&gt; 参数化; &lt;code&gt;Hash&lt;/code&gt; ，一个&lt;a href=&quot;hash&quot;&gt;哈希&lt;/a&gt;函数对象，在 &lt;code&gt;Key&lt;/code&gt; 上充当哈希函数;和 &lt;code&gt;Pred&lt;/code&gt; ，一个&lt;a href=&quot;binarypredicate&quot;&gt;用于&lt;/a&gt;评估 &lt;code&gt;Key&lt;/code&gt; 的等效性的BinaryPredicate。 &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 也有一个映射类型 &lt;code&gt;T&lt;/code&gt; 与相关联的 &lt;code&gt;Key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27d0b13503ae28a6d2a746765f82094c67a9edd8" translate="yes" xml:space="preserve">
          <source>Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (O(1) amortized, O(n) worst-case complexity).</source>
          <target state="translated">无序关联容器实现了可以快速搜索的无排序(散列)数据结构(O(1)摊开,O(n)最差情况下的复杂度)。</target>
        </trans-unit>
        <trans-unit id="b3e4ddc4a7977312b5ea810e7307eb4d25f9ced4" translate="yes" xml:space="preserve">
          <source>Unordered associative containers in the standard library</source>
          <target state="translated">标准库中的无序关联容器。</target>
        </trans-unit>
        <trans-unit id="9cbf323cb4f143925595576784d5b591b9699888" translate="yes" xml:space="preserve">
          <source>Unordered associative containers meet the requirements of &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;. For &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; the requirements of &lt;code&gt;value_type&lt;/code&gt; in &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; apply to &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; (not to &lt;code&gt;value_type&lt;/code&gt;).</source>
          <target state="translated">无序关联容器符合&lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;的要求。对于 &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; ，&lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;中 &lt;code&gt;value_type&lt;/code&gt; 的要求适用于 &lt;code&gt;key_type&lt;/code&gt; 和 &lt;code&gt;mapped_type&lt;/code&gt; （不适用于 &lt;code&gt;value_type&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c05e882164dc6c352b2a91db5033a7f29679961d" translate="yes" xml:space="preserve">
          <source>Unordered dynamic initialization</source>
          <target state="translated">无序动态初始化</target>
        </trans-unit>
        <trans-unit id="6f584009e4c537a97fa6a23c2a4e0d998b8f9266" translate="yes" xml:space="preserve">
          <source>Unordered map is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.</source>
          <target state="translated">无序映射是一个关联容器,包含具有唯一键的键值对。元素的搜索、插入和删除具有平均的恒定时间复杂性。</target>
        </trans-unit>
        <trans-unit id="a040e6bfa2ff6a84c4d4e54ec666b82a142217ba" translate="yes" xml:space="preserve">
          <source>Unordered multimap is an unordered associative container that supports equivalent keys (an unordered_multimap may contain multiple copies of each key value) and that associates values of another type with the keys. The unordered_multimap class supports forward iterators. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">unordered multimap是一个无序的关联容器,它支持等价键(一个unordered_multimap可以包含每个键值的多个副本),并将另一种类型的值与键关联起来。unordered_multimap类支持前向迭代器。搜索、插入和删除具有平均的恒定时间复杂性。</target>
        </trans-unit>
        <trans-unit id="781e73a9d10b79ea8423bbe4c282e042b203ed02" translate="yes" xml:space="preserve">
          <source>Unordered multiset is an associative container that contains set of possibly non-unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">无序多集是一个关联容器,它包含了Key类型的可能非唯一的对象集。搜索、插入和删除具有平均的恒定时间复杂性。</target>
        </trans-unit>
        <trans-unit id="6c35c1e1852ab51c8cfda8139fbce10f60da69d7" translate="yes" xml:space="preserve">
          <source>Unordered set is an associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">无序集是一个关联的容器,它包含一组类型为Key的唯一对象。搜索、插入和删除具有平均的恒定时间复杂性。</target>
        </trans-unit>
        <trans-unit id="20ec84b0a684780da8ecd14376ab54e3d64c049a" translate="yes" xml:space="preserve">
          <source>UnorderedAssociativeContainer</source>
          <target state="translated">UnorderedAssociativeContainer</target>
        </trans-unit>
        <trans-unit id="5ed38d76cf76e990be50933f309543cd72253e57" translate="yes" xml:space="preserve">
          <source>Unqualified and qualified name lookup rules for class members are detailed in &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">类成员的不合格和合格名称查找规则在&lt;a href=&quot;lookup&quot;&gt;名称查找&lt;/a&gt;中详细说明。</target>
        </trans-unit>
        <trans-unit id="a712c79b38b9542c96589abf3e1dda8d1042e2a4" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;abs&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;std::abs&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;abs&lt;/code&gt; ）用于执行计算。如果该功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;std::abs&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc119a198d533d4b0bbb7710d68460cff957292e" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;acos&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;std::acos&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;acos&lt;/code&gt; ）用于执行计算。如果此类功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;std::acos&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f215557e10fbc19791a7df65c388833c1a7dd11c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;asin&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;std::asin&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;asin&lt;/code&gt; ）用于执行计算。如果此类功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;std::asin&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f3c5a7de17deb7da848c19ab6e3fce9f64dca13" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;atan2&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;std::atan2&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;atan2&lt;/code&gt; ）用于执行计算。如果此类功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;std::atan2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa3a701b0983c693521c1ddd5947f77acceaace8" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;atan&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;std::atan&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;atan&lt;/code&gt; ）用于执行计算。如果此类功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;std::atan&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39d51e27856339476f1d01bf7073fed7dc2b3dbb" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;cos&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;std::cos&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;cos&lt;/code&gt; ）用于执行计算。如果此类功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;std::cos&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dbf3b6db25b09f0814d7e5a7fef391df5875da2a" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;cosh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;std::cosh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">非限定函数（ &lt;code&gt;cosh&lt;/code&gt; ）用于执行计算。如果此类功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;std::cosh&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e8abb5dd0c771afacf6766178d00da2ba065a2ec" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;exp&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;exp&lt;/code&gt; ）用于执行计算。如果该函数不可用，则由于依赖于参数而使用 &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd8575417503ea5be7c9d78fb49d54a74a502a5c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;log10&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/log10&quot;&gt;std::log10&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;log10&lt;/code&gt; ）用于执行计算。如果此类功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/log10&quot;&gt;std::log10&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42fd42135c1c4e85d3b6e8229754e9d9e009486f" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;log&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;log&lt;/code&gt; ）用于执行计算。如果此类函数不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8f42595543cd910c448cec8e9b024326f375da5" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;pow&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;pow&lt;/code&gt; ）用于执行计算。如果此类功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0b45579c9b454c00347186dba4b670a1612acd28" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sin&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;sin&lt;/code&gt; ）用于执行计算。如果此类函数不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="609a5411e92bb2e442b9695a0c7f1a35b0bcda38" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sinh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;std::sinh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;sinh&lt;/code&gt; ）用于执行计算。如果此类函数不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;std::sinh&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0b2457b178abb1fbcd11ec0b12722a8184da253" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sqrt&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;sqrt&lt;/code&gt; ）用于执行计算。如果此类功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa91ca5ff514fc595bf3f51f24fdd9e313d69b9c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;tan&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;std::tan&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;tan&lt;/code&gt; ）用于执行计算。如果该功能不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;std::tan&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2d13c70f9b62f9ac241cafdef0b167740b73e83" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;tanh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;std::tanh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">不合格函数（ &lt;code&gt;tanh&lt;/code&gt; ）用于执行计算。如果此类函数不可用，则由于依赖于参数而进行查找，因此将使用 &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;std::tanh&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e538cf96d743b1733d4cf064e3d13d77d3aa646" translate="yes" xml:space="preserve">
          <source>Unqualified identifiers</source>
          <target state="translated">无条件的标识符</target>
        </trans-unit>
        <trans-unit id="30683cf405f082292810a7676e96130ea1ebbac6" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup</source>
          <target state="translated">非限定名称查询</target>
        </trans-unit>
        <trans-unit id="42e9848a70274fa4e3ee76d98636ebc5974dc7bd" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup of the name used to the left of the function-call operator (and, equivalently, operator in an expression) is described in &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;adl&quot;&gt;依赖&lt;/a&gt;于参数的查询中描述了在函数调用运算符（以及等效地，表达式中的运算符）左侧使用的名称的非限定名称查询。</target>
        </trans-unit>
        <trans-unit id="79648146553ba52f72840dfe58fd2d9c089e5fda" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup that finds static members of &lt;code&gt;B&lt;/code&gt;, nested types of &lt;code&gt;B&lt;/code&gt;, and enumerators declared in &lt;code&gt;B&lt;/code&gt; is unambiguous even if there are multiple non-virtual base subobjects of type &lt;code&gt;B&lt;/code&gt; in the inheritance tree of the class being examined:</source>
          <target state="translated">不合格的名称查找，用于查找的静态成员 &lt;code&gt;B&lt;/code&gt; ，嵌套类型的 &lt;code&gt;B&lt;/code&gt; ，和枚举中声明 &lt;code&gt;B&lt;/code&gt; 是明确的，即使有类型的多个非虚拟基子对象 &lt;code&gt;B&lt;/code&gt; 在类存在的继承树检查：</target>
        </trans-unit>
        <trans-unit id="f0214ce4cc35b4369eeab0b471b29274746a99bb" translate="yes" xml:space="preserve">
          <source>Unregisters a range earlier registered with &lt;code&gt;&lt;a href=&quot;declare_no_pointers&quot;&gt;std::declare_no_pointers&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">注销先前在 &lt;code&gt;&lt;a href=&quot;declare_no_pointers&quot;&gt;std::declare_no_pointers&lt;/a&gt;()&lt;/code&gt; 注册的范围。</target>
        </trans-unit>
        <trans-unit id="866d0de5757a1581405e841976c7443463cb9f92" translate="yes" xml:space="preserve">
          <source>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与收缩无关，浮点算术的中间结果可能具有与其类型所指示的结果不同的范围和精度，请参见 &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c38c9bea005b30ba6a290df566acf1664518f308" translate="yes" xml:space="preserve">
          <source>Unscoped enumeration</source>
          <target state="translated">无范围列举</target>
        </trans-unit>
        <trans-unit id="6222e920759d4ffc44da225d807dad755988a0aa" translate="yes" xml:space="preserve">
          <source>Unscoped enumeration type</source>
          <target state="translated">无范围的枚举类型</target>
        </trans-unit>
        <trans-unit id="326065904fc6d55f14165c03f41503850d0a81df" translate="yes" xml:space="preserve">
          <source>Unsequenced execution policies are the only case where function calls are</source>
          <target state="translated">无序执行策略是唯一的一种情况,在这种情况下,函数的调用是</target>
        </trans-unit>
        <trans-unit id="001f5aa9e95578bdbf624cdd233afcd23b9e1b0b" translate="yes" xml:space="preserve">
          <source>Unsets the formatting flags identified by &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="translated">取消设置由 &lt;code&gt;flags&lt;/code&gt; 标识的格式化标志。</target>
        </trans-unit>
        <trans-unit id="e58bf16bb4075ebd2ecdad4cd86deb15d7942bb7" translate="yes" xml:space="preserve">
          <source>Unsigned integer arithmetic is always performed modulo 2n</source>
          <target state="translated">无符号整数算术总是以2n为模数进行。</target>
        </trans-unit>
        <trans-unit id="73db4e2949bacc582e416479a510daae92386ab7" translate="yes" xml:space="preserve">
          <source>Unsigned integer of at least 32 bits</source>
          <target state="translated">至少32位的无符号整数。</target>
        </trans-unit>
        <trans-unit id="4e7bbf9fbab3d07bb38581701f9d99705350278e" translate="yes" xml:space="preserve">
          <source>Unsigned integer type (usually &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">无符号整数类型（通常为 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="1569ce9087643318f5b374c7177d610cac24614f" translate="yes" xml:space="preserve">
          <source>Unsigned integers : maximum value</source>
          <target state="translated">无符号整数:最大值</target>
        </trans-unit>
        <trans-unit id="6fe5f2a61d9b8437ce58885d4aebe34e13639a40" translate="yes" xml:space="preserve">
          <source>UnsignedIntegral</source>
          <target state="translated">UnsignedIntegral</target>
        </trans-unit>
        <trans-unit id="5097984a5f9238c911d1b186817d23c6f3bcfe68" translate="yes" xml:space="preserve">
          <source>Unspecified order</source>
          <target state="translated">未指定顺序</target>
        </trans-unit>
        <trans-unit id="d37821663cc5797b1388ccb9821c1c66f6dc7be6" translate="yes" xml:space="preserve">
          <source>Unspecified.</source>
          <target state="translated">Unspecified.</target>
        </trans-unit>
        <trans-unit id="42bff37b51ec7b1fccab4a5d361519fa088bb006" translate="yes" xml:space="preserve">
          <source>Unsupported C headers</source>
          <target state="translated">不支持的C字头</target>
        </trans-unit>
        <trans-unit id="3910cc8152231b6ede905978fe57cac1a0d03d97" translate="yes" xml:space="preserve">
          <source>Until &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558&quot;&gt;CWG 1558&lt;/a&gt; (a C++14 defect), unused parameters in &lt;a href=&quot;../language/type_alias&quot;&gt;alias templates&lt;/a&gt; were not guaranteed to ensure SFINAE and could be ignored, so earlier compilers require a more complex definition of &lt;code&gt;void_t&lt;/code&gt;, such as.</source>
          <target state="translated">在&lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558&quot;&gt;CWG 1558&lt;/a&gt;（C ++ 14缺陷）之前，不能保证&lt;a href=&quot;../language/type_alias&quot;&gt;别名模板&lt;/a&gt;中的未使用参数可确保SFINAE，因此可以忽略这些参数，因此，较早的编译器需要更复杂的 &lt;code&gt;void_t&lt;/code&gt; 定义，例如。</target>
        </trans-unit>
        <trans-unit id="f7718ae633302ee609828ca76d3c8d3d51cfea89" translate="yes" xml:space="preserve">
          <source>Until C++11, &lt;code&gt;auto&lt;/code&gt; had the semantic of a &lt;a href=&quot;storage_duration&quot;&gt;storage duration specifier&lt;/a&gt;.</source>
          <target state="translated">在C ++ 11之前， &lt;code&gt;auto&lt;/code&gt; 具有&lt;a href=&quot;storage_duration&quot;&gt;存储期限说明符&lt;/a&gt;的语义。</target>
        </trans-unit>
        <trans-unit id="965548c423c2af9ebf773d28ec036a9f63c4b83f" translate="yes" xml:space="preserve">
          <source>Until C++11, aggregate initialization could not be used in a constructor initializer list due to syntax restrictions.</source>
          <target state="translated">在C++11之前,由于语法限制,聚合初始化不能用于构造函数初始化列表中。</target>
        </trans-unit>
        <trans-unit id="9f555151d6b7d5f7a9ff7843af6a57a54b0a5819" translate="yes" xml:space="preserve">
          <source>Until C++11, classes that overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt; were not CopyConstructible and thus weren't usable in the standard library containers. As of C++11, the standard library uses &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; whenever the address of an object is needed.</source>
          <target state="translated">直到C ++ 11，重载 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 的类才可以使用CopyConstructible，因此无法在标准库容器中使用。从C ++ 11开始，只要需要对象的地址，标准库就使用 &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f5f5ea9e92fa642a1d809852878c2987d57848b" translate="yes" xml:space="preserve">
          <source>Until C++11, it was unspecified whether &lt;code&gt;basic_streambuf&lt;/code&gt; or any of its derived classes is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421&quot;&gt;LWG issue 421&lt;/a&gt;), and different C++ library implementations provided different options.</source>
          <target state="translated">在C ++ 11之前，&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;尚不&lt;/a&gt;确定 &lt;code&gt;basic_streambuf&lt;/code&gt; 或其任何派生类是否为CopyConstructible（&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421&quot;&gt;LWG问题421&lt;/a&gt;），并且不同的C ++库实现提供了不同的选项。</target>
        </trans-unit>
        <trans-unit id="328855c59d216dad3422e6e98a3125cd6d816dcf" translate="yes" xml:space="preserve">
          <source>Until C++11, narrowing conversions were permitted in aggregate initialization, but they are no longer allowed, except that, as of C++20, they are allowed when aggregate initialization uses round parentheses.</source>
          <target state="translated">在C++11之前,在集合初始化中允许窄化转换,但现在已经不允许了,只是从C++20开始,当集合初始化使用圆括号时,允许窄化转换。</target>
        </trans-unit>
        <trans-unit id="6e17e7cb9fc8a5970b94833c26c3d5625cb274e1" translate="yes" xml:space="preserve">
          <source>Until C++11, the rounding direction of the quotient and the sign of the remainder in the &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;built-in division and remainder operators&lt;/a&gt; was implementation-defined if either of the operands was negative, but it was well-defined in &lt;code&gt;std::div&lt;/code&gt;.</source>
          <target state="translated">在C ++ 11之前，如果两个操作数中的任何一个为负数，则&lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;内置&lt;/a&gt;定义除法和余数运算符的商的舍入方向和余数的符号，但在 &lt;code&gt;std::div&lt;/code&gt; 定义良好。</target>
        </trans-unit>
        <trans-unit id="2dd75578b3cf163fd9cdf707fa3febbd8933afe1" translate="yes" xml:space="preserve">
          <source>Until C++11, which introduced &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_signal_fence&quot;&gt;std::atomic_signal_fence&lt;/a&gt;&lt;/code&gt;, about the only thing a strictly conforming program could do in a signal handler was to assign a value to a &lt;code&gt;volatile static std::sig_atomic_t&lt;/code&gt; variable and promptly return.</source>
          <target state="translated">在引入了 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_signal_fence&quot;&gt;std::atomic_signal_fence&lt;/a&gt;&lt;/code&gt; C ++ 11之前，严格符合标准的程序在信号处理程序中可以做的唯一一件事就是为 &lt;code&gt;volatile static std::sig_atomic_t&lt;/code&gt; 变量分配一个值并立即返回。</target>
        </trans-unit>
        <trans-unit id="4d3ae3907e74b1b45f48b10e1e68c5b46d8f4619" translate="yes" xml:space="preserve">
          <source>Until C++14, the direct-initialization form &lt;code&gt;T a {args..}&lt;/code&gt; did not permit brace elision.</source>
          <target state="translated">在C ++ 14之前，直接初始化形式 &lt;code&gt;T a {args..}&lt;/code&gt; 不允许大括号删除。</target>
        </trans-unit>
        <trans-unit id="7f752f60fcef0ea971b808f8f6eaf483ad584079" translate="yes" xml:space="preserve">
          <source>Until C++17, a function could not return a tuple using list-initialization:</source>
          <target state="translated">在C++17之前,函数不能使用list-initialization返回元组。</target>
        </trans-unit>
        <trans-unit id="58fb383e77b7fb0335ad97e0f3c210c1e1d6f098" translate="yes" xml:space="preserve">
          <source>Until the introduction of explicit conversion functions in C++11, designing a class that should be usable in boolean contexts (e.g. &lt;code&gt;if(obj) { ... }&lt;/code&gt;) presented a problem: given a user-defined conversion function, such as &lt;code&gt;T::operator bool() const;&lt;/code&gt;, the implicit conversion sequence allowed one additional standard conversion sequence after that function call, which means the resultant &lt;code&gt;bool&lt;/code&gt; could be converted to &lt;code&gt;int&lt;/code&gt;, allowing such code as &lt;code&gt;obj &amp;lt;&amp;lt; 1;&lt;/code&gt; or &lt;code&gt;int i = obj;&lt;/code&gt;.</source>
          <target state="translated">在C ++ 11中引入显式转换函数之前，设计一个应在布尔上下文中使用的类（例如 &lt;code&gt;if(obj) { ... }&lt;/code&gt; ）提出了一个问题：给定用户定义的转换函数，例如 &lt;code&gt;T::operator bool() const;&lt;/code&gt; ，则隐式转换序列允许在该函数调用之后再执行一个标准转换序列，这意味着可以将生成的 &lt;code&gt;bool&lt;/code&gt; 转换为 &lt;code&gt;int&lt;/code&gt; ，从而允许使用诸如 &lt;code&gt;obj &amp;lt;&amp;lt; 1;&lt;/code&gt; 类的代码；或 &lt;code&gt;int i = obj;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b46999a4d771dcf596a583d2c8bf0dbc1bb017bc" translate="yes" xml:space="preserve">
          <source>Until variable templates were introduced in C++14, parametrized variables were typically implemented as either static data members of class templates or as constexpr function templates returning the desired values.</source>
          <target state="translated">在C++14中引入变量模板之前,参数化变量通常被实现为类模板的静态数据成员或作为constexpr函数模板返回所需值。</target>
        </trans-unit>
        <trans-unit id="c65bb8e4818155db56e2464c0be89b93b4aa7fb0" translate="yes" xml:space="preserve">
          <source>Upon return to the scope of &lt;code&gt;setjmp&lt;/code&gt;, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; was executed, except for the non-&lt;a href=&quot;../../language/cv&quot;&gt;volatile&lt;/a&gt; local variables in &lt;code&gt;setjmp&lt;/code&gt;'s scope, whose values are indeterminate if they have been changed since the setjmp invocation.</source>
          <target state="translated">返回 &lt;code&gt;setjmp&lt;/code&gt; 的范围后，抽象机的所有可访问对象，浮点状态标志和其他组件的值与执行 &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 时的值相同，但 &lt;code&gt;setjmp&lt;/code&gt; 中的非易失&lt;a href=&quot;../../language/cv&quot;&gt;性&lt;/a&gt;局部变量除外的作用域，如果自setjmp调用以来已更改其值，则其值不确定。</target>
        </trans-unit>
        <trans-unit id="30e91e701960bb8a2f2ddc9e70cec3e0f356f152" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 的大写版本或未修改的 &lt;code&gt;ch&lt;/code&gt; (如果当前C语言环境中未列出大写版本）。</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e2fa3e294a40d353ff7bd0279d846fe85eb6a460" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;mem_fn&lt;/code&gt; to store and execute a member function and a member object:</source>
          <target state="translated">使用 &lt;code&gt;mem_fn&lt;/code&gt; 存储和执行成员函数和成员对象：</target>
        </trans-unit>
        <trans-unit id="ccd4cdfea5815983783eb398f954b34dd3308ca2" translate="yes" xml:space="preserve">
          <source>Use ECMAScript rules to construct strings in &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; (&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;syntax documentation&lt;/a&gt;)</source>
          <target state="translated">使用ECMAScript规则在 &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; 构建字符串（&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;语法文档&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="7d2ca269005572f7dcc4f93975b5006fe75b32fe" translate="yes" xml:space="preserve">
          <source>Use POSIX</source>
          <target state="translated">使用POSIX</target>
        </trans-unit>
        <trans-unit id="59088c12cff257aabcfd96c2bff5eb6d63196ace" translate="yes" xml:space="preserve">
          <source>Use of an indeterminate value obtained by default-initializing a non-class variable of any type is &lt;a href=&quot;ub&quot;&gt;undefined behavior&lt;/a&gt; (in particular, it may be a &lt;a href=&quot;objects#Object_representation_and_value_representation&quot;&gt;trap representation&lt;/a&gt;), except in the following cases:</source>
          <target state="translated">通过缺省初始化任何类型的非类变量而获得的不确定值的使用是&lt;a href=&quot;ub&quot;&gt;未定义的行为&lt;/a&gt;（特别是，它可能是&lt;a href=&quot;objects#Object_representation_and_value_representation&quot;&gt;陷阱表示&lt;/a&gt;），但在以下情况下除外：</target>
        </trans-unit>
        <trans-unit id="1343357d8857f07ed216045e4630d2360702830a" translate="yes" xml:space="preserve">
          <source>Use of pImpl requires a dedicated translation unit (a header-only library cannot use pImpl), introduces an additional class, a set of forwarding functions, and, if allocators are used, exposes the implementation detail of allocator use in the public interface.</source>
          <target state="translated">使用pImpl需要一个专门的翻译单元(只使用头的库不能使用pImpl),引入一个额外的类,一组转发函数,如果使用分配器,则在公共接口中公开分配器使用的实现细节。</target>
        </trans-unit>
        <trans-unit id="5c95344b6a2f2f118527f061626aec54628cfeac" translate="yes" xml:space="preserve">
          <source>Use of this invalid value as an argument to any &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; member taking a value of this type is undefined behaviour</source>
          <target state="translated">将此无效值用作采用此类型的值的任何 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; 成员的参数是未定义的行为</target>
        </trans-unit>
        <trans-unit id="6eb61fe88f9155e92fd5505231d51581c0a1f378" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript&quot;&gt;Modified ECMAScript regular expression grammar&lt;/a&gt;</source>
          <target state="translated">使用&lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript&quot;&gt;修改后的ECMAScript正则表达式语法&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b59f8d4a6e7623991a4148e772aefe99cb9c959" translate="yes" xml:space="preserve">
          <source>Use the basic POSIX regular expression grammar (&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="translated">使用基本的POSIX正则表达式语法（&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;语法文档&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4032118ad7e10c8a56fe81c51513bcd0f4198612" translate="yes" xml:space="preserve">
          <source>Use the extended POSIX regular expression grammar (&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="translated">使用扩展的POSIX正则表达式语法（&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;语法文档&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="efdfc5f80485169681a19ba23803d6f84ff4e293" translate="yes" xml:space="preserve">
          <source>Use the regular expression grammar used by the</source>
          <target state="translated">使用的正则表达式语法。</target>
        </trans-unit>
        <trans-unit id="b6f72b04e0e8a80cecbd0a1176096ac1763ecf62" translate="yes" xml:space="preserve">
          <source>Used as a more readable equivalent to the traditional &lt;a href=&quot;for&quot;&gt; for loop&lt;/a&gt; operating over a range of values, such as all elements in a container.</source>
          <target state="translated">用作与传统&lt;a href=&quot;for&quot;&gt;for循环&lt;/a&gt;等效的可读性更高的for循环，可在一定范围的值上运行，例如容器中的所有元素。</target>
        </trans-unit>
        <trans-unit id="5a1c568d8c824c8779a7fbd4ddf0353bf241da96" translate="yes" xml:space="preserve">
          <source>Used fields</source>
          <target state="translated">使用过的领域</target>
        </trans-unit>
        <trans-unit id="df4ac21ba90d03bbec4f8d92680ff358bb022c1a" translate="yes" xml:space="preserve">
          <source>Used to mark a &lt;a href=&quot;../language/class_template&quot;&gt;template definition&lt;/a&gt;</source>
          <target state="translated">用于标记&lt;a href=&quot;../language/class_template&quot;&gt;模板定义&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af59dbcc1c5fb76dabc78981244f1492f92bd30a" translate="yes" xml:space="preserve">
          <source>Used to refer to the character type</source>
          <target state="translated">用于指字符类型</target>
        </trans-unit>
        <trans-unit id="452240ee9951387e7059a7bfdc9cc878fb58e6e5" translate="yes" xml:space="preserve">
          <source>Used to refer to the character type.</source>
          <target state="translated">用来指代字符类型。</target>
        </trans-unit>
        <trans-unit id="0411cff330fe1f926e098add76bac8d23f3a24cd" translate="yes" xml:space="preserve">
          <source>Used when actual size of the object must be known.</source>
          <target state="translated">当必须知道对象的实际尺寸时使用。</target>
        </trans-unit>
        <trans-unit id="cd3a7677f14605e188f81a1607ce0b998a59e8fc" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.</source>
          <target state="translated">当使用条件语句忽略循环的剩余部分很不方便时使用。</target>
        </trans-unit>
        <trans-unit id="73641814b8ae560f3493eb824a0db1bde1f528d6" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.</source>
          <target state="translated">当使用条件表达式和条件语句终止循环时,否则会很尴尬。</target>
        </trans-unit>
        <trans-unit id="e80aa66e106a415e8288da7170c66b3a43f1b6c5" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise impossible to transfer control to the desired location using other statements.</source>
          <target state="translated">当无法使用其他语句将控制权转移到所需位置时使用。</target>
        </trans-unit>
        <trans-unit id="7062a1fb9e1b49180bc64e78c1788d8e78b97581" translate="yes" xml:space="preserve">
          <source>Used where code needs to be executed based on a run-time or compile-time condition.</source>
          <target state="translated">用于根据运行时或编译时条件需要执行代码的地方。</target>
        </trans-unit>
        <trans-unit id="bf16483f532d4a8853cf1010caa2cb57d0f33c2f" translate="yes" xml:space="preserve">
          <source>Used where the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of a &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic object&lt;/a&gt; must be known and for static type identification.</source>
          <target state="translated">用于必须知道&lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;多态对象&lt;/a&gt;的&lt;a href=&quot;type-id#Dynamic_type&quot;&gt;动态类型&lt;/a&gt;的地方，并用于静态类型识别。</target>
        </trans-unit>
        <trans-unit id="42d90e90aadfee8047aec9690cf0574d0347d7d2" translate="yes" xml:space="preserve">
          <source>User code should usually use &lt;code&gt;std::chrono::clock_cast&lt;/code&gt;, which provides a generic interface to convert time points between clocks, rather than call these functions directly.</source>
          <target state="translated">用户代码通常应该使用 &lt;code&gt;std::chrono::clock_cast&lt;/code&gt; ，它提供了一个通用接口来在时钟之间转换时间点，而不是直接调用这些函数。</target>
        </trans-unit>
        <trans-unit id="22f079a53befe874a015e16af5dac8a9dbe1d7c3" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">全局&lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; 的&lt;/a&gt;用户替换版本</target>
        </trans-unit>
        <trans-unit id="beecf2d4915648f8f0efab35c62b4b57d5f5b1df" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">全局&lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;和&lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; 的&lt;/strong&gt;用户替换版本&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36a2cff95d451b8ddda6e6fad777fc4eedb46043" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">全局&lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt;和&lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; 的&lt;/a&gt;用户替换版本</target>
        </trans-unit>
        <trans-unit id="f9aac68f1811d0c886372a7b6aa12dfd47145f36" translate="yes" xml:space="preserve">
          <source>User specializations may define the member type &lt;code&gt;iterator_concept&lt;/code&gt; to one of &lt;a href=&quot;iterator_tags&quot;&gt;iterator category tags&lt;/a&gt;, to indicate conformance to the iterator concepts.</source>
          <target state="translated">用户专业化可以将成员类型 &lt;code&gt;iterator_concept&lt;/code&gt; 定义为&lt;a href=&quot;iterator_tags&quot;&gt;迭代器类别标签之一&lt;/a&gt;，以指示与迭代器概念的一致性。</target>
        </trans-unit>
        <trans-unit id="691620a9d9530e81a0d5cd25eb278071f62c4739" translate="yes" xml:space="preserve">
          <source>User-Defined Literals</source>
          <target state="translated">用户定义文字</target>
        </trans-unit>
        <trans-unit id="d55e108d604fa5cfa1e00711a9ffe9ad9af9acb8" translate="yes" xml:space="preserve">
          <source>User-defined Literals for std::complex</source>
          <target state="translated">用户为std::complex定义的字元。</target>
        </trans-unit>
        <trans-unit id="66b100ca6f92096c7cc2adfb8fd94dcf564c734d" translate="yes" xml:space="preserve">
          <source>User-defined character traits may be used to provide &lt;a href=&quot;http://www.gotw.ca/gotw/029.htm&quot;&gt;case-insensitive comparison&lt;/a&gt;.</source>
          <target state="translated">用户定义的字符特征可用于提供&lt;a href=&quot;http://www.gotw.ca/gotw/029.htm&quot;&gt;不区分大小写的比较&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="521384c0aef8e04b593ebebfeb20da581eaab716" translate="yes" xml:space="preserve">
          <source>User-defined classes and enumerations that implement the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; are required to overload the bitwise arithmetic operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt;, and may optionally overload the shift operators &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;operator&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;operator&amp;lt;&amp;lt;=&lt;/code&gt;. The canonical implementations usually follow the pattern for binary arithmetic operators described above.</source>
          <target state="translated">需要使用实现&lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;要求的用户定义的类和枚举来重载按位算术运算符 &lt;code&gt;operator&amp;amp;&lt;/code&gt; ， &lt;code&gt;operator|&lt;/code&gt; ， &lt;code&gt;operator^&lt;/code&gt; ， &lt;code&gt;operator~&lt;/code&gt; ， &lt;code&gt;operator&amp;amp;=&lt;/code&gt; ， &lt;code&gt;operator|=&lt;/code&gt; 和 &lt;code&gt;operator^=&lt;/code&gt; ，并且可以选择使移位运算 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; ， &lt;code&gt;operator&amp;gt;&amp;gt;=&lt;/code&gt; 和 &lt;code&gt;operator&amp;lt;&amp;lt;=&lt;/code&gt; 。规范的实现通常遵循上述二进制算术运算符的模式。</target>
        </trans-unit>
        <trans-unit id="41ab182df7e7de75a62a46e254284df8495915ff" translate="yes" xml:space="preserve">
          <source>User-defined classes that provide array-like access that allows both reading and writing typically define two overloads for &lt;code&gt;operator[]&lt;/code&gt;: const and non-const variants:</source>
          <target state="translated">用户定义的类提供类似数组的访问，允许读取和写入，它们通常为 &lt;code&gt;operator[]&lt;/code&gt; 定义两个重载：const和非const变体：</target>
        </trans-unit>
        <trans-unit id="9759d0c809ae6bc40bb8a39c15779393d91b25b2" translate="yes" xml:space="preserve">
          <source>User-defined conversion function is invoked on the second stage of the &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt;, which consists of zero or one &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; or zero or one user-defined conversion function.</source>
          <target state="translated">在&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt;的第二阶段调用用户定义的转换函数，该隐式转换由零或一个&lt;a href=&quot;converting_constructor&quot;&gt;转换构造函数&lt;/a&gt;或零或一个用户定义的转换函数组成。</target>
        </trans-unit>
        <trans-unit id="43fb76a0004d3479d12ac1d1092e34daa13fde1a" translate="yes" xml:space="preserve">
          <source>User-defined conversions (both converting constructors and user-defined conversion functions) are prohibited from taking part in implicit conversion sequence where it would make it possible to apply more than one user-defined conversion. Specifically, they are not considered if the target of the conversion is the first parameter of a constructor or the implicit object parameter of a user-defined conversion function, and that constructor/user-defined conversion is a candidate for.</source>
          <target state="translated">用户定义的转换(包括转换构造函数和用户定义的转换函数)被禁止参加隐式转换序列,因为在这种情况下,有可能应用一个以上的用户定义的转换。具体来说,如果转换的目标是构造函数的第一个参数或用户定义转换函数的隐式对象参数,并且该构造函数/用户定义转换是以下情况的候选者,则不考虑它们:</target>
        </trans-unit>
        <trans-unit id="c8869104cf44d820cb55c49ce74b8353880870a6" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides</source>
          <target state="translated">用户自定义扣除指南</target>
        </trans-unit>
        <trans-unit id="ef26f7121e5a45ae6e617a4103dcbb63ab5dc3ab" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides do not have to be templates:</source>
          <target state="translated">用户自定义的扣款指南不一定是模板。</target>
        </trans-unit>
        <trans-unit id="ada924d219c774c38ebbaa26b6b0ac7bd8284f27" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides must name a class template and must be introduced within the same semantic scope of the class template (which could be namespace or enclosing class) and, for a member class template, must have the same access, but deduction guides do not become members of that scope.</source>
          <target state="translated">用户定义的推导指南必须为类模板命名,并且必须在类模板的同一语义范围内引入(可以是命名空间或包围类),对于成员类模板,必须具有相同的访问权限,但推导指南不会成为该范围的成员。</target>
        </trans-unit>
        <trans-unit id="9f7140ad8b86562edf1af76c7b4d2ecd3daf0a05" translate="yes" xml:space="preserve">
          <source>User-defined literals</source>
          <target state="translated">用户定义的字数</target>
        </trans-unit>
        <trans-unit id="27875895c12b2d250978e1e13877f06ad81a62ef" translate="yes" xml:space="preserve">
          <source>User-defined literals (since C++11)</source>
          <target state="translated">用户自定义字元(自C++11起)</target>
        </trans-unit>
        <trans-unit id="f9e1a4e3fe3d8c4879519e8d07a0503e9a4c9e72" translate="yes" xml:space="preserve">
          <source>User-defined literals for string types</source>
          <target state="translated">用户自定义字符串类型的字元</target>
        </trans-unit>
        <trans-unit id="d0490dae080d561474031e5c0e2c4ef6347ced31" translate="yes" xml:space="preserve">
          <source>User-defined literals for time types</source>
          <target state="translated">用户自定义时间类型的字元</target>
        </trans-unit>
        <trans-unit id="fc5e25714db01eb56b2bf86b5e7921777fc9f4c1" translate="yes" xml:space="preserve">
          <source>User-defined overloads</source>
          <target state="translated">用户自定义过载</target>
        </trans-unit>
        <trans-unit id="33745b553a69e48bb26d5d43ad7a22124cb88491" translate="yes" xml:space="preserve">
          <source>User-defined overloads of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; have no effect on constraint normalization.</source>
          <target state="translated">用户定义的 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;||&lt;/code&gt; 重载 对约束规范化没有影响。</target>
        </trans-unit>
        <trans-unit id="9d6ddc3c3044ee87f524355e003d05e7748d65d0" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;leap&lt;/code&gt; objects except by copying from existing &lt;code&gt;leap&lt;/code&gt; objects. The library implementation creates &lt;code&gt;leap&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">用户不能构造 &lt;code&gt;leap&lt;/code&gt; 对象，除非从现有的 &lt;code&gt;leap&lt;/code&gt; 对象进行复制。库实现在初始化时区数据库并提供对这些对象的 &lt;code&gt;const&lt;/code&gt; 访问时会创建 &lt;code&gt;leap&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="f9e764d8a62224f28652f9477d145424640947d7" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;link&lt;/code&gt; objects. The library implementation creates &lt;code&gt;link&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">用户无法构造 &lt;code&gt;link&lt;/code&gt; 对象。库实现在初始化时区数据库并提供对这些对象的 &lt;code&gt;const&lt;/code&gt; 访问时会创建 &lt;code&gt;link&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="af2f54042c747b54c3093610083361c67a39fbfd" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;time_zone&lt;/code&gt; objects. The library implementation creates &lt;code&gt;time_zone&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">用户无法构造 &lt;code&gt;time_zone&lt;/code&gt; 对象。库实现在初始化时区数据库并提供对这些对象的 &lt;code&gt;const&lt;/code&gt; 访问时会创建 &lt;code&gt;time_zone&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="946304840b5dd2cc7ea35261e0218a4ed1cc1b01" translate="yes" xml:space="preserve">
          <source>Users may derive from &lt;code&gt;view_base&lt;/code&gt; or specialize &lt;code&gt;enable_view&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; for types which model &lt;code&gt;View&lt;/code&gt;, and specialize &lt;code&gt;enable_view&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for types which do not.</source>
          <target state="translated">用户可以从获得 &lt;code&gt;view_base&lt;/code&gt; 或专攻 &lt;code&gt;enable_view&lt;/code&gt; 到 &lt;code&gt;true&lt;/code&gt; 的类型的模型 &lt;code&gt;View&lt;/code&gt; ，并专注 &lt;code&gt;enable_view&lt;/code&gt; 以 &lt;code&gt;false&lt;/code&gt; 对不种。</target>
        </trans-unit>
        <trans-unit id="d77619d2d2aeedbc5912e54a11fc69314fc4b9b4" translate="yes" xml:space="preserve">
          <source>Users may specialize &lt;code&gt;common_type&lt;/code&gt; for types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; if.</source>
          <target state="translated">如果是，则用户可以将 &lt;code&gt;common_type&lt;/code&gt; 专门用于类型 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="44312d9b5ba550e3bf714285fd931d65780211eb" translate="yes" xml:space="preserve">
          <source>Uses base class pword storage for runtime type identification of derived stream objects.</source>
          <target state="translated">使用基类pword存储,用于派生流对象的运行时类型识别。</target>
        </trans-unit>
        <trans-unit id="435dd26a3c29e79ab39283f08d206249de9658d9" translate="yes" xml:space="preserve">
          <source>Uses native_handle to enable realtime scheduling of C++ threads on a POSIX system.</source>
          <target state="translated">在POSIX系统上使用native_handle来实现C++线程的实时调度。</target>
        </trans-unit>
        <trans-unit id="47d9c5030129b909d30f38ba61ff22e289ed4dc7" translate="yes" xml:space="preserve">
          <source>Uses the allocator &lt;code&gt;a&lt;/code&gt; to allocate &lt;code&gt;n*sizeof(Alloc::value_type)&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">使用分配器 &lt;code&gt;a&lt;/code&gt; 分配 &lt;code&gt;n*sizeof(Alloc::value_type)&lt;/code&gt; 个未初始化存储的字节。</target>
        </trans-unit>
        <trans-unit id="5774066b9e43fa4c8cddba29af3f1729deeb9d50" translate="yes" xml:space="preserve">
          <source>Uses the allocator &lt;code&gt;a&lt;/code&gt; to deallocate the storage referenced by &lt;code&gt;p&lt;/code&gt;, by calling &lt;code&gt;a.deallocate(p, n)&lt;/code&gt;.</source>
          <target state="translated">使用分配器 &lt;code&gt;a&lt;/code&gt; 通过调用 &lt;code&gt;a.deallocate(p, n)&lt;/code&gt; 来释放 &lt;code&gt;p&lt;/code&gt; 引用的存储。</target>
        </trans-unit>
        <trans-unit id="1ba97051617e132658e923e2cd0500400c48654b" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to allocate uninitialized storage.</source>
          <target state="translated">使用外部分配器来分配未初始化的存储。</target>
        </trans-unit>
        <trans-unit id="b3f5f74569dd5173607ac926d852b70e7c657155" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to call the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;, by calling.</source>
          <target state="translated">使用外部分配器通过调用来调用 &lt;code&gt;p&lt;/code&gt; 指向的对象的析构函数。</target>
        </trans-unit>
        <trans-unit id="1233805d22778d94a1a1092f4fdeffec6effe4da" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to deallocate the storage referenced by &lt;code&gt;p&lt;/code&gt;, by calling &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::deallocate(outer_allocator(), p, n)&lt;/code&gt;.</source>
          <target state="translated">通过调用 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::deallocate(outer_allocator(), p, n)&lt;/code&gt; &amp;lt;OuterAlloc&amp;gt; :: deallocate（outer_allocator（），p，n）使用外部分配器来释放 &lt;code&gt;p&lt;/code&gt; 引用的存储。</target>
        </trans-unit>
        <trans-unit id="9d6bd96d2b4bc007cec5dbc13bffdb43818c467e" translate="yes" xml:space="preserve">
          <source>Uses-allocator construction</source>
          <target state="translated">用途-分配器结构</target>
        </trans-unit>
        <trans-unit id="e8ccfd79bce11a76a3f0a27cd61f22c4be4a0529" translate="yes" xml:space="preserve">
          <source>Using a member typedef or alias template in a constructor or constructor template's parameter list does not, by itself, render the corresponding parameter of the implicitly generated guide a non-deduced context.</source>
          <target state="translated">在构造函数或构造模板的参数列表中使用成员类型化ef或别名模板,其本身并不会使隐式生成的指南的相应参数成为非演绎上下文。</target>
        </trans-unit>
        <trans-unit id="3973ba3748f277f1b1247e46879f1a5b0ff12c85" translate="yes" xml:space="preserve">
          <source>Using this library may require additional compiler/linker options. GNU implementation requires linking with &lt;code&gt;-lstdc++fs&lt;/code&gt; and LLVM implementation requires linking with &lt;code&gt;-lc++fs&lt;/code&gt;.</source>
          <target state="translated">使用此库可能需要其他编译器/链接器选项。GNU实现需要与 &lt;code&gt;-lstdc++fs&lt;/code&gt; 链接，而LLVM实现需要与 &lt;code&gt;-lc++fs&lt;/code&gt; 链接。</target>
        </trans-unit>
        <trans-unit id="478f8e8f8e40a23e1335aa300d9b135f2ed07fd9" translate="yes" xml:space="preserve">
          <source>Using-declaration</source>
          <target state="translated">Using-declaration</target>
        </trans-unit>
        <trans-unit id="e192f9ebd97a059b8b3818089ff571a2768e5ba3" translate="yes" xml:space="preserve">
          <source>Using-declaration introduces a member of a base class into the derived class definition, such as to expose a protected member of base as public member of derived. In this case, nested-name-specifier must name a base class of the one being defined. If the name is the name of an overloaded member function of the base class, all base class member functions with that name are introduced. If the derived class already has a member with the same name, parameter list, and qualifications, the derived class member hides or overrides (doesn't conflict with) the member that is introduced from the base class.</source>
          <target state="translated">使用-声明将基类的成员引入到派生类定义中,例如将基类的受保护成员公开为派生类的公共成员。在这种情况下,嵌套-name-specifier必须命名一个被定义的基类。如果该名称是基类的重载成员函数的名称,那么所有使用该名称的基类成员函数都会被引入。如果派生类已经有一个具有相同名称、参数列表和限定条件的成员,则派生类成员隐藏或覆盖(不与基类引入的成员冲突)。</target>
        </trans-unit>
        <trans-unit id="647139d11b1988510ebdf137fbaac198034c6a6b" translate="yes" xml:space="preserve">
          <source>Using-declaration introduces a member of another namespace into current namespace or block scope.</source>
          <target state="translated">使用声明将另一个命名空间的成员引入当前命名空间或块作用域。</target>
        </trans-unit>
        <trans-unit id="96ab3f618e4bb79ceae244afaf56510df88fbaa8" translate="yes" xml:space="preserve">
          <source>Using-declarations</source>
          <target state="translated">Using-declarations</target>
        </trans-unit>
        <trans-unit id="89ce2da2bf0809daefed3588888e71ab6c4b17a5" translate="yes" xml:space="preserve">
          <source>Using-declarations can be used to introduce namespace members into other namespaces and block scopes, or to introduce base class members into derived class definitions.</source>
          <target state="translated">使用声明可以用来将命名空间成员引入其他命名空间和块作用域,或者将基类成员引入派生类定义中。</target>
        </trans-unit>
        <trans-unit id="1afd86105bb6b7eae3d1c2ff8ebac8080cc93c0b" translate="yes" xml:space="preserve">
          <source>Using-declarations cannot name &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;, namespace, or a scoped enumerator. Each declarator in a using-declaration introduces one and only one name, for example using-declaration for an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; does not introduce any of its enumerators.</source>
          <target state="translated">使用声明不能命名&lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;，名称空间或作用域枚举器。using-声明中的每个声明器只能引入一个名称，例如，&lt;a href=&quot;enum&quot;&gt;枚举的using-&lt;/a&gt;声明不会引入其任何枚举​​器。</target>
        </trans-unit>
        <trans-unit id="243bb7e4adba8af291f9b9518cc9a875ccf74e65" translate="yes" xml:space="preserve">
          <source>Using-declarations in derived classes cannot refer to specializations of template conversion functions from base classes.</source>
          <target state="translated">派生类中的使用声明不能引用基类中模板转换函数的特殊化。</target>
        </trans-unit>
        <trans-unit id="890b0e8bf12e6e2f8622f4d2164034f01e35b67b" translate="yes" xml:space="preserve">
          <source>Using-directive does not add any names to the declarative region in which it appears (unlike the using-declaration), and thus does not prevent identical names from being declared.</source>
          <target state="translated">use-directive不会在它出现的声明区域中添加任何名称(与using-declaration不同),因此不会阻止相同的名称被声明。</target>
        </trans-unit>
        <trans-unit id="9267f4ac5eb849d97bac3ea55d519f3646d7511f" translate="yes" xml:space="preserve">
          <source>Using-directives</source>
          <target state="translated">Using-directives</target>
        </trans-unit>
        <trans-unit id="e478a805aae96b5ada7799a77a72b64e59439220" translate="yes" xml:space="preserve">
          <source>Using-directives are allowed only in namespace &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; and in block scope. From the point of view of unqualified &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; of any name after a using-directive and until the end of the scope in which it appears, every name from namespace-name is visible as if it were declared in the nearest enclosing namespace which contains both the using-directive and namespace-name.</source>
          <target state="translated">仅在名称空间&lt;a href=&quot;scope&quot;&gt;范围&lt;/a&gt;和块范围中才允许使用指令。从在使用指令之后直到在其出现范围之前的任何名称的无限定&lt;a href=&quot;lookup&quot;&gt;名称查找&lt;/a&gt;的角度来看，namespace-name中的每个名称都是可见的，就像在包含两个元素的最近的封闭名称空间中声明它一样using-directive和namespace-name。</target>
        </trans-unit>
        <trans-unit id="fe20c085207b808c419801ec01c3f2d69d1e53a9" translate="yes" xml:space="preserve">
          <source>Using-directives are transitive for the purposes of &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt;: if a scope contains a using-directive that nominates a namespace-name, which itself contains using-directive for some namespace-name-2, the effect is as if the using directives from the second namespace appear within the first. The order in which these transitive namespaces occur does not influence name lookup.</source>
          <target state="translated">using-directives是可传递的，用于&lt;a href=&quot;lookup&quot;&gt;无条件查找&lt;/a&gt;：如果作用域包含一个提名一个namespace-name的using-directive，而该本身又包含某些namespace-name-2的using-directive，则效果就好像来自第二个名称空间出现在第一个名称空间内。这些可传递名称空间的出现顺序不会影响名称查找。</target>
        </trans-unit>
        <trans-unit id="90e771e57dbe271295562deb5815544ce47acec2" translate="yes" xml:space="preserve">
          <source>Usual &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name lookup&lt;/a&gt; is used for the identifier prefixed by &lt;code&gt;typename&lt;/code&gt;. Unlike the case with &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;, the lookup rules do not change despite the qualifier:</source>
          <target state="translated">通常的&lt;a href=&quot;qualified_lookup&quot;&gt;合格名称查找&lt;/a&gt;用于以 &lt;code&gt;typename&lt;/code&gt; 为前缀的标识符。与&lt;a href=&quot;elaborated_type_specifier&quot;&gt;精心设计的类型说明符不同&lt;/a&gt;，尽管使用了限定符，查找规则也不会改变：</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="72c1f2942e6c2f59eb16eb2f336358c3428f04e8" translate="yes" xml:space="preserve">
          <source>Utilities library</source>
          <target state="translated">实用工具库</target>
        </trans-unit>
        <trans-unit id="c238357565249d5db64377b7321a861ff74e6a3d" translate="yes" xml:space="preserve">
          <source>Utility components</source>
          <target state="translated">实用组件</target>
        </trans-unit>
        <trans-unit id="69be11f41a3c37842e99473568839d6e6c14c854" translate="yes" xml:space="preserve">
          <source>Utility library</source>
          <target state="translated">实用程序库</target>
        </trans-unit>
        <trans-unit id="6c204fbda83dad99b4764ac479029ca8981e718e" translate="yes" xml:space="preserve">
          <source>Utility metafunction that maps a sequence of any types to the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">实用程序元函数，可将任何类型的序列映射到 &lt;code&gt;void&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="b0d7fadc1640d7f4704fe07fafd860ef56a6519b" translate="yes" xml:space="preserve">
          <source>VERTICAL KANA REPEAT MARK - HANGUL JONGSEONG PHIEUPH-THIEUTH</source>
          <target state="translated">VERTICAL KANA REPEAT MARK-HANGUL JONGSEONG PHIEUPH-TIEUTH.</target>
        </trans-unit>
        <trans-unit id="5a815286d91c46561b98d7d910a0542f7fa603a7" translate="yes" xml:space="preserve">
          <source>VULGAR FRACTION ONE QUARTER - VULGAR FRACTION THREE QUARTERS</source>
          <target state="translated">恶性循环一季度-恶性循环三季度。</target>
        </trans-unit>
        <trans-unit id="2a85014316c857fc68366f2d4cfeef4ccca44072" translate="yes" xml:space="preserve">
          <source>Valid non-zero alignments that are weaker than another &lt;code&gt;alignas&lt;/code&gt; on the same declaration are ignored.</source>
          <target state="translated">比同一个声明中的另一个 &lt;code&gt;alignas&lt;/code&gt; 弱的有效非零对齐方式将被忽略。</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f00df19eab61f9bc6b193ebf7f79f580e312b435" translate="yes" xml:space="preserve">
          <source>Value (hex)</source>
          <target state="translated">值(十六进制)</target>
        </trans-unit>
        <trans-unit id="6ccf81011273d24c106e237774966bec5a3f3d04" translate="yes" xml:space="preserve">
          <source>Value (octal)</source>
          <target state="translated">价值(八进制)</target>
        </trans-unit>
        <trans-unit id="842d5c71fd285df07d76b3a931200aef4027bbe5" translate="yes" xml:space="preserve">
          <source>Value array containing</source>
          <target state="translated">含值数组</target>
        </trans-unit>
        <trans-unit id="8f9d98449ec4c8f79f22636316b3a0e923c947ef" translate="yes" xml:space="preserve">
          <source>Value array containing absolute values of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的绝对值的值数组。</target>
        </trans-unit>
        <trans-unit id="bba712cfd9f7651aa772da136f89a61149be2ac1" translate="yes" xml:space="preserve">
          <source>Value array containing arc cosines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的反余弦的值数组。</target>
        </trans-unit>
        <trans-unit id="918e7d00363d34ea17b81a2896797c2d5407de29" translate="yes" xml:space="preserve">
          <source>Value array containing arc sines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的反正弦值的值数组。</target>
        </trans-unit>
        <trans-unit id="7dd43aa4756d43fc4b8be056b5da614e7ae17fe0" translate="yes" xml:space="preserve">
          <source>Value array containing arc tangents of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的反正切值的值数组。</target>
        </trans-unit>
        <trans-unit id="7a16b1209abeda990f5a71b8d2e227e0b6c93b82" translate="yes" xml:space="preserve">
          <source>Value array containing common logarithms of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的常用对数的值数组。</target>
        </trans-unit>
        <trans-unit id="a311ab5baa8093138875ac8a94b0cea46530bc77" translate="yes" xml:space="preserve">
          <source>Value array containing cosines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的余弦值的值数组。</target>
        </trans-unit>
        <trans-unit id="67e25f3a01cf3ed1b997a81a0d9b1d557b7e592b" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic cosine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的双曲余弦值的值数组。</target>
        </trans-unit>
        <trans-unit id="9d4fd3ea31174e2ad27a712e67ef9575efad3f21" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic sine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的双曲正弦值的值数组。</target>
        </trans-unit>
        <trans-unit id="2a5794dbb6788174721a7201fba5775845755af6" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic tangent of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的双曲正切值的值数组。</target>
        </trans-unit>
        <trans-unit id="788503847d55a0b843da66ecc9eb7e909c8e81ea" translate="yes" xml:space="preserve">
          <source>Value array containing natural logarithms of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的自然对数的值数组。</target>
        </trans-unit>
        <trans-unit id="8d94e0b0bb891cd281312eef3d7cafb82f9093c2" translate="yes" xml:space="preserve">
          <source>Value array containing sine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值正弦值的值数组。</target>
        </trans-unit>
        <trans-unit id="4bcd496b550ea36f6a6a5da52708746dfc984226" translate="yes" xml:space="preserve">
          <source>Value array containing square roots of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的平方根的值数组。</target>
        </trans-unit>
        <trans-unit id="acec93cb24e8ed07513e328851e06115700eaed0" translate="yes" xml:space="preserve">
          <source>Value array containing tangents of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">包含 &lt;code&gt;va&lt;/code&gt; 中值的切线的值数组。</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">价值类别</target>
        </trans-unit>
        <trans-unit id="82a222afd8aa1f50591d47af3a1da440d1b6c1c9" translate="yes" xml:space="preserve">
          <source>Value initialization is performed in these situations:</source>
          <target state="translated">在这些情况下会进行值初始化。</target>
        </trans-unit>
        <trans-unit id="44ee88d7a37283ed3f2e5c6bb77a69fd4b4ff443" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="f316bf9562d1f2536d1f98b558dad75f56bae376" translate="yes" xml:space="preserve">
          <source>Value of a floating-point or &lt;a href=&quot;../../types/is_integral&quot;&gt;Integral type&lt;/a&gt;</source>
          <target state="translated">浮点或&lt;a href=&quot;../../types/is_integral&quot;&gt;整数类型的值&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8868e91c4a5c3eea6c88793879068066054670cd" translate="yes" xml:space="preserve">
          <source>Value of a type &lt;code&gt;Y&lt;/code&gt; whose &lt;a href=&quot;../container/node_handle&quot;&gt;node handles&lt;/a&gt; are compatible with X</source>
          <target state="translated">一个类型的值 &lt;code&gt;Y&lt;/code&gt; 其&lt;a href=&quot;../container/node_handle&quot;&gt;节点句柄&lt;/a&gt;与X兼容</target>
        </trans-unit>
        <trans-unit id="a6d7a9a5f8f421d8d8d1289caa1073e525a68c0c" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X::size_type&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;X::size_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3076d857f6bafe8bc4b757157d8b7e92030d350" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;X&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="bdc99e4fc02f27b3e7f0e86f72aae50003652dc4" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports multiple keys</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 支持多个键时，类型 &lt;code&gt;X&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="d88b2ce84fd44f3d069f80a1cad885599a530444" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports unique keys</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 支持唯一键时，类型 &lt;code&gt;X&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="b2e637fb234b0c6b9d295e0383f8ac972d2e9be2" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;float&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="1c7cea36bd22384e74ce5693b3a96747824e4406" translate="yes" xml:space="preserve">
          <source>Value range</source>
          <target state="translated">价值范围</target>
        </trans-unit>
        <trans-unit id="51127d011c590cc06c1287343706272a08f0dc2d" translate="yes" xml:space="preserve">
          <source>Value too large to be stored in data type</source>
          <target state="translated">值太大,无法存储在数据类型中</target>
        </trans-unit>
        <trans-unit id="af99e0d3d72b238f81c500119ae328f4acda13dc" translate="yes" xml:space="preserve">
          <source>Value transformations</source>
          <target state="translated">价值转换</target>
        </trans-unit>
        <trans-unit id="60a41a8af03cf015b251f42ec4877faede44cfa3" translate="yes" xml:space="preserve">
          <source>Value transformations are conversions that change the &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of an expression. They take place whenever an expression appears as an operand of an operator that expects an expression of a different value category.</source>
          <target state="translated">值转换是更改表达式的&lt;a href=&quot;value_category&quot;&gt;值类别&lt;/a&gt;的转换。每当表达式作为需要不同值类别的表达式的运算符的操作数出现时，它们就会发生。</target>
        </trans-unit>
        <trans-unit id="912f89db75340dd536695f5900751cb79605c44e" translate="yes" xml:space="preserve">
          <source>Value-dependent expressions</source>
          <target state="translated">与价值相关的表达式</target>
        </trans-unit>
        <trans-unit id="1c83d35b39b8a1674f047686e39badc8092fea73" translate="yes" xml:space="preserve">
          <source>ValueSwappable</source>
          <target state="translated">ValueSwappable</target>
        </trans-unit>
        <trans-unit id="5cfdbdef621053e4c2adb3e5800cfd3510d6d549" translate="yes" xml:space="preserve">
          <source>ValueType</source>
          <target state="translated">ValueType</target>
        </trans-unit>
        <trans-unit id="e3d8fb1ed748d78b39416572c15d6566892835be" translate="yes" xml:space="preserve">
          <source>Values of &lt;code&gt;base&lt;/code&gt; other than 8, 10, or 16 reset &lt;code&gt;basefield&lt;/code&gt; to zero, which corresponds to decimal output and prefix-dependent input.</source>
          <target state="translated">的值 &lt;code&gt;base&lt;/code&gt; 大于8，10，或16复位其它 &lt;code&gt;basefield&lt;/code&gt; 到零，其对应于十进制输出和前缀相关的输入。</target>
        </trans-unit>
        <trans-unit id="699b7fde74d4bad2ed32bf4fdac5cb581d05b675" translate="yes" xml:space="preserve">
          <source>Values of integer, floating-point, and enumeration types can be converted by &lt;a href=&quot;static_cast&quot;&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;explicit_cast&quot;&gt;explicit cast&lt;/a&gt;, to any enumeration type. If the underlying type is not fixed, the result is unspecified(until C++17)undefined behavior(since C++17) if the source value (first converted to the enumeration's underlying type if floating-point) is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration). Otherwise, the result is the same as the result of &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; to the underlying type.</source>
          <target state="translated">整数，浮点数和枚举类型的值可以通过&lt;a href=&quot;static_cast&quot;&gt; &lt;code&gt;static_cast&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;explicit_cast&quot;&gt;explicit cast&lt;/a&gt;转换为任何枚举类型。如果基础类型不是固定的，则如果源值（如果浮点数首先转换为枚举的基础类型）超出范围，则结果是不确定的（直到C ++ 17）未定义的行为（自C ++ 17开始）该范围是最小位字段的所有可能值，该值足够大以容纳目标枚举的所有枚举数。否则，结果与&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt;为基础类型的结果相同。</target>
        </trans-unit>
        <trans-unit id="622c99b5f957359968fbce43706c282c2086981e" translate="yes" xml:space="preserve">
          <source>Values of unscoped enumeration type are &lt;a href=&quot;implicit_cast&quot;&gt;implicitly-convertible&lt;/a&gt; to integral types. If the underlying type is not fixed, the value is convertible to the first type from the following list able to hold their entire value range: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;. If the underlying type is fixed, the values can be converted to their promoted underlying type.</source>
          <target state="translated">无作用域枚举类型的值可以&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt;为整数类型。如果基础类型不是固定的，则该值可转换为以下列表中的第一种类型，该列表可以保留其整个值范围： &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;unsigned int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;unsigned long&lt;/code&gt; ， &lt;code&gt;long long&lt;/code&gt; 或 &lt;code&gt;unsigned long long&lt;/code&gt; 。如果基础类型是固定的，则可以将值转换为其提升的基础类型。</target>
        </trans-unit>
        <trans-unit id="f8df93af76ffcc18fdab0d35c919d46adda08d0a" translate="yes" xml:space="preserve">
          <source>Values of zero will be replaced with implementation-specified defaults;</source>
          <target state="translated">零的值将被替换为执行中指定的默认值。</target>
        </trans-unit>
        <trans-unit id="052336d34e395136fdc7b0ea68de9e6ce0735430" translate="yes" xml:space="preserve">
          <source>Values returned from &lt;code&gt;lookup_classname&lt;/code&gt; can be bitwise or'ed together; the resulting value represents membership in either of the corresponding character classes</source>
          <target state="translated">从 &lt;code&gt;lookup_classname&lt;/code&gt; 返回的值可以按位或在一起。结果值表示相应字符类别中的成员身份</target>
        </trans-unit>
        <trans-unit id="df08eb1d25241fdec3135b3385380633b3feb713" translate="yes" xml:space="preserve">
          <source>Variable template(since C++14)</source>
          <target state="translated">变量模板(自C++14起)</target>
        </trans-unit>
        <trans-unit id="07e0c173abb12ff926e54a677500672fc6b6b986" translate="yes" xml:space="preserve">
          <source>Variable templates</source>
          <target state="translated">可变模板</target>
        </trans-unit>
        <trans-unit id="bb8bc60fbcd37b30cc10bb1c4aefe4bd77138258" translate="yes" xml:space="preserve">
          <source>Variable templates cannot be used as &lt;a href=&quot;template_parameters#Template_template_arguments&quot;&gt;template template arguments&lt;/a&gt;.</source>
          <target state="translated">变量模板不能用作&lt;a href=&quot;template_parameters#Template_template_arguments&quot;&gt;模板模板参数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf60c912c256eebe5d2b8b031ec6bed1e0afbc9c" translate="yes" xml:space="preserve">
          <source>Variable templates for type traits</source>
          <target state="translated">类型特征的可变模板</target>
        </trans-unit>
        <trans-unit id="d41def7a6d8846ea38dabfb67345e2e0a09f52e7" translate="yes" xml:space="preserve">
          <source>Variables declared at block scope with the specifier &lt;code&gt;static&lt;/code&gt; have static storage duration but are initialized the first time control passes through their declaration (unless their initialization is &lt;a href=&quot;zero_initialization&quot;&gt;zero-&lt;/a&gt; or &lt;a href=&quot;constant_initialization&quot;&gt;constant-initialization&lt;/a&gt;, which can be performed before the block is first entered). On all further calls, the declaration is skipped.</source>
          <target state="translated">在块范围内使用说明符 &lt;code&gt;static&lt;/code&gt; 声明的变量具有静态存储持续时间，但在控件第一次通过其声明时进行初始化（除非其初始化&lt;a href=&quot;zero_initialization&quot;&gt;为零&lt;/a&gt;或&lt;a href=&quot;constant_initialization&quot;&gt;常量初始化&lt;/a&gt;，可以在首次进入该块之前执行该初始化）。在所有其他调用上，将跳过声明。</target>
        </trans-unit>
        <trans-unit id="56198fe808c824ddba06784c100164faedd427c3" translate="yes" xml:space="preserve">
          <source>Variadic &lt;code&gt;&lt;a href=&quot;thread/lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;std::scoped_lock&lt;/code&gt;)</source>
          <target state="translated">可变参数 &lt;code&gt;&lt;a href=&quot;thread/lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; （ &lt;code&gt;std::scoped_lock&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a8548e5a783f6964c2b71215ac2f1cf031c3e8a0" translate="yes" xml:space="preserve">
          <source>Variadic arguments</source>
          <target state="translated">变量参数</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">变量函数</target>
        </trans-unit>
        <trans-unit id="04c44e45105b6cf53a83ce33f663f4af86c9d0a7" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions (e.g. &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;) which take a &lt;a href=&quot;../language/variadic_arguments&quot;&gt;variable number of arguments&lt;/a&gt;.</source>
          <target state="translated">可变参数函数是带有&lt;a href=&quot;../language/variadic_arguments&quot;&gt;可变数量参数的&lt;/a&gt;函数（例如 &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="8a308087e2905028e7ad5d2c240717d97448c333" translate="yes" xml:space="preserve">
          <source>Variadic templates</source>
          <target state="translated">变化模板</target>
        </trans-unit>
        <trans-unit id="40aa5342cc8cddbbe71fe77cdf48f02a16642a52" translate="yes" xml:space="preserve">
          <source>Various &lt;a href=&quot;utility&quot;&gt; utility components&lt;/a&gt;</source>
          <target state="translated">各种&lt;a href=&quot;utility&quot;&gt;实用程序组件&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43dfbbdcd916a0c6741ae6b7703f2bf5dd8096c3" translate="yes" xml:space="preserve">
          <source>Vector capacity is never reduced when resizing to smaller size because that would invalidate all iterators, rather than only the ones that would be invalidated by the equivalent sequence of pop_back() calls.</source>
          <target state="translated">当调整大小到较小的尺寸时,向量容量永远不会减少,因为那样会使所有的迭代器无效,而不是只有那些会被等价的pop_back()调用序列所无效的迭代器。</target>
        </trans-unit>
        <trans-unit id="5519001c19e39db626b1e56d5b3636ed5b38cb6f" translate="yes" xml:space="preserve">
          <source>Version (2) of the &lt;code&gt;#define&lt;/code&gt; directive defines a simple function-like macro.</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 指令的版本（2）定义了一个类似于函数的简单宏。</target>
        </trans-unit>
        <trans-unit id="ae3376f429640ab77c59ef69b6eeee356493fa80" translate="yes" xml:space="preserve">
          <source>Version (3) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments. The additional arguments (called</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 指令的版本（3）定义了具有可变参数数量的类函数宏。附加参数（称为</target>
        </trans-unit>
        <trans-unit id="3243986759cbfdbcf8f3fe70af12570a24f20c76" translate="yes" xml:space="preserve">
          <source>Version (4) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments (called</source>
          <target state="translated">&lt;code&gt;#define&lt;/code&gt; 指令的版本（4）定义了类似函数的宏，具有可变数量的参数，但没有常规参数。参数（称为</target>
        </trans-unit>
        <trans-unit id="1c26c7d8a48f6ecef280cf0b203307778072892d" translate="yes" xml:space="preserve">
          <source>Viable functions</source>
          <target state="translated">可行的职能</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="57dde08ae7e4931bf4b1d9d8203c8fb2aa6c4ddb" translate="yes" xml:space="preserve">
          <source>View of the substring &lt;code&gt;[pos, pos + rcount)&lt;/code&gt;.</source>
          <target state="translated">子字符串 &lt;code&gt;[pos, pos + rcount)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08776128bd18b59c55542f61081a01440f41b01c" translate="yes" xml:space="preserve">
          <source>ViewableRange</source>
          <target state="translated">ViewableRange</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c911ee9da5495317a3fd2048e2a77408d0f7651d" translate="yes" xml:space="preserve">
          <source>Violations of constraints are detected at compile time, early in the template instantiation process, which leads to easy to follow error messages.</source>
          <target state="translated">在编译时,在模板实例化过程的早期,就可以检测到违反约束的情况,这就导致了易于遵循的错误信息。</target>
        </trans-unit>
        <trans-unit id="9b18a97a2fd2836708868d06e1ce4ef84d86615c" translate="yes" xml:space="preserve">
          <source>Virtual and pure virtual functions</source>
          <target state="translated">虚拟和纯虚拟功能</target>
        </trans-unit>
        <trans-unit id="f68e04bd9e3e62f1affa5f5cd95daed9e7141704" translate="yes" xml:space="preserve">
          <source>Virtual base classes</source>
          <target state="translated">虚拟基类</target>
        </trans-unit>
        <trans-unit id="bb2875a5baa367827268a607eb3795f455c6012e" translate="yes" xml:space="preserve">
          <source>Virtual destructor</source>
          <target state="translated">虚拟毁灭者</target>
        </trans-unit>
        <trans-unit id="5066038f5f1b55b5a2bc0bc13c582fae42181817" translate="yes" xml:space="preserve">
          <source>Virtual destructors</source>
          <target state="translated">虚拟破坏者</target>
        </trans-unit>
        <trans-unit id="f6fe3c659ed8077db8d0b5920aa4b5764bff62d6" translate="yes" xml:space="preserve">
          <source>Virtual functions (whether declared virtual or overriding one) cannot have any associated constraints.</source>
          <target state="translated">虚拟函数(无论是声明为虚拟函数还是覆盖函数)不能有任何相关的约束。</target>
        </trans-unit>
        <trans-unit id="7f5fcb0f75cbb4813db427832ef8357c8c51c72a" translate="yes" xml:space="preserve">
          <source>Virtual functions are member functions whose behavior can be overridden in derived classes. As opposed to non-virtual functions, the overridden behavior is preserved even if there is no compile-time information about the actual type of the class. If a derived class is handled using pointer or reference to the base class, a call to an overridden virtual function would invoke the behavior defined in the derived class. This behavior is suppressed if the function is selected using &lt;a href=&quot;lookup&quot;&gt;qualified name lookup&lt;/a&gt; (that is, if the function's name appears to the right of the scope resolution operator &lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">虚函数是成员函数，其行为可以在派生类中被覆盖。与非虚拟函数相反，即使没有有关该类实际类型的编译时信息，也可以保留重写的行为。如果使用指针或对基类的引用来处理派生类，则对重写的虚函数的调用将调用派生类中定义的行为。如果使用&lt;a href=&quot;lookup&quot;&gt;限定名称查找&lt;/a&gt;选择了函数（即，如果函数的名称显示在范围解析运算符 &lt;code&gt;::&lt;/code&gt; 的右侧），则会抑制此行为。</target>
        </trans-unit>
        <trans-unit id="d022c012c3444ee6f002dccdfcd5905c70efa42e" translate="yes" xml:space="preserve">
          <source>Visible side-effects</source>
          <target state="translated">可见的副作用</target>
        </trans-unit>
        <trans-unit id="30c3d8194815052f5f9f54a1fac519295b84ad3f" translate="yes" xml:space="preserve">
          <source>Visual Studio 2010</source>
          <target state="translated">Visual Studio 2010</target>
        </trans-unit>
        <trans-unit id="a50605af7e7015b16739f3db40248d1a64076a37" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 Inline Assembler</source>
          <target state="translated">Visual Studio 2013 Inline Assembler</target>
        </trans-unit>
        <trans-unit id="359a03f62e49986ef991446210499529db3fc418" translate="yes" xml:space="preserve">
          <source>Void expressions</source>
          <target state="translated">虚无缥缈的表达方式</target>
        </trans-unit>
        <trans-unit id="f135b48d956f6ca097c1656d0a1863579947c9fb" translate="yes" xml:space="preserve">
          <source>Void expressions have no</source>
          <target state="translated">虚无的表达方式没有</target>
        </trans-unit>
        <trans-unit id="e8f5359cab08d3573121923f7436c0f33fc92629" translate="yes" xml:space="preserve">
          <source>Void type</source>
          <target state="translated">虚空型</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="c0bc38123ad63ab545d3b75627acdac77e9b79a6" translate="yes" xml:space="preserve">
          <source>WCHAR_MAX</source>
          <target state="translated">WCHAR_MAX</target>
        </trans-unit>
        <trans-unit id="04ea5fdfa0eae316269a47c7f10e8316337146a4" translate="yes" xml:space="preserve">
          <source>WCHAR_MIN</source>
          <target state="translated">WCHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c37a74a6f2d73286ec534a439a5c059b13230ec6" translate="yes" xml:space="preserve">
          <source>WEOF</source>
          <target state="translated">WEOF</target>
        </trans-unit>
        <trans-unit id="8d070188c9052ddde44bc280e3aced3c983ed8c7" translate="yes" xml:space="preserve">
          <source>WINT_MAX</source>
          <target state="translated">WINT_MAX</target>
        </trans-unit>
        <trans-unit id="cb08e31a881a0bd7697665afb678cdce175c2f59" translate="yes" xml:space="preserve">
          <source>WINT_MIN</source>
          <target state="translated">WINT_MIN</target>
        </trans-unit>
        <trans-unit id="d7d72e040861a1f86b9b248b64986ff2db87de0a" translate="yes" xml:space="preserve">
          <source>WORD JOINER - TURNED DIGIT THREE</source>
          <target state="translated">WORD JOINER--转位数三</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="8c8066383629449e748934ef44df8baa244ceb3f" translate="yes" xml:space="preserve">
          <source>Waits for the result to become available. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the result becomes available, whichever comes first. Returns value identifies the state of the result.</source>
          <target state="translated">等待结果变为可用。阻塞直到指定的 &lt;code&gt;timeout_duration&lt;/code&gt; 过去或结果变为可用（以先到者为准）。返回值标识结果的状态。</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="128348550537d17215c4e4e19183a94c6cae96fb" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; to denote the type of the expression &lt;code&gt;e&lt;/code&gt;. (In other words, &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is the equivalent of &lt;code&gt;&lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype((e))&amp;gt;&lt;/code&gt;.).</source>
          <target state="translated">我们使用 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 表示表达式 &lt;code&gt;e&lt;/code&gt; 的类型。（换句话说， &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype((e))&amp;gt;&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="ff2d0e12c8d86e48e138480e627a03522625fd5b" translate="yes" xml:space="preserve">
          <source>Weak equality</source>
          <target state="translated">脆弱的平等</target>
        </trans-unit>
        <trans-unit id="cc0eeac220c48abd1f4d8a9066580d68089b7e2a" translate="yes" xml:space="preserve">
          <source>Weak ordering</source>
          <target state="translated">秩序薄弱</target>
        </trans-unit>
        <trans-unit id="5f9aead2f88dbe4721a67660c3e46cd95c9d01ce" translate="yes" xml:space="preserve">
          <source>Weakly parallel forward progress</source>
          <target state="translated">弱平行前进</target>
        </trans-unit>
        <trans-unit id="32d5d9f2881f15e8163749d6edac5a8dd285e442" translate="yes" xml:space="preserve">
          <source>WeaklyIncrementable</source>
          <target state="translated">WeaklyIncrementable</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="1d901e38ea200c08db624662589c69e315e01ff1" translate="yes" xml:space="preserve">
          <source>Week/day of the year</source>
          <target state="translated">一年中的星期/日期</target>
        </trans-unit>
        <trans-unit id="17a74d187c8a04abdcb5c0a680b6e9d660e85fba" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #1/3</source>
          <target state="translated">每一个C程序员都应该知道的未定义行为#1/3。</target>
        </trans-unit>
        <trans-unit id="8b7904dfab491b34141248cdfa81f76b99500ce8" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #2/3</source>
          <target state="translated">每个C程序员都应该知道的未定义行为#2/3。</target>
        </trans-unit>
        <trans-unit id="faec1f8b604ae7cb007c3f28c6244f78ba75f633" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #3/3</source>
          <target state="translated">每个C程序员都应该知道的未定义行为#3/3</target>
        </trans-unit>
        <trans-unit id="5345ef8ed5a57eddad0fc38e73e7287b6270366c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, or &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; satisfies the LegacyOutputIterator requirements in addition to its own requirements, it is described as &lt;b&gt;mutable&lt;/b&gt;.</source>
          <target state="translated">当&lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;，&lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;或&lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;除了自身的要求之外还满足LegacyOutputIterator要求时，它被描述为&lt;b&gt;mutable&lt;/b&gt;。</target>
        </trans-unit>
        <trans-unit id="cc0170dca8716eb24882edf591a81dee83e562ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;#&lt;/code&gt; appears before &lt;code&gt;__VA_ARGS__&lt;/code&gt;, the entire expanded __VA_ARGS__ is enclosed in quotes:</source>
          <target state="translated">当 &lt;code&gt;#&lt;/code&gt; 出现在 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 之前时，整个扩展的__VA_ARGS__都用引号引起来：</target>
        </trans-unit>
        <trans-unit id="046623a30719eaa626e9121030272ea2805083f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, it is unspecified whether function (1) is declared.</source>
          <target state="translated">当 &lt;code&gt;T&lt;/code&gt; 是（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; 时，不确定是否声明函数（1）。</target>
        </trans-unit>
        <trans-unit id="bf6dcc3dc3f6b7e5ebe9923c510cc70615782d54" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is an array type, it is unspecified whether these member functions are declared, and if they are, what their return type is, except that the declaration (not necessarily the definition) of these functions is well-formed.</source>
          <target state="translated">当 &lt;code&gt;T&lt;/code&gt; 是数组类型时，除了这些函数的声明（不一定是定义）格式正确之外，不确定是否声明了这些成员函数，以及是否声明了它们的返回类型。</target>
        </trans-unit>
        <trans-unit id="97a2afc24ba5f22063e77c7d297d40d35897008d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is not an array type, it is unspecified whether this function is declared. If the function is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 不是数组类型，则不确定是否声明此函数。如果声明了该函数，则除了可以保证该函数的声明（尽管不一定是定义）是合法的之外，尚不确定其返回类型是什么。</target>
        </trans-unit>
        <trans-unit id="841913a7a092250d0d74debefdc20a6387cf98d1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is not an array type, the overloads (3), (4), and (6) enable &lt;code&gt;shared_from_this&lt;/code&gt; with &lt;code&gt;ptr&lt;/code&gt;, and the overload (13) enables &lt;code&gt;shared_from_this&lt;/code&gt; with the pointer returned by &lt;code&gt;r.release()&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;T&lt;/code&gt; 不是数组类型，重载（3），（4），和（6）使 &lt;code&gt;shared_from_this&lt;/code&gt; 与 &lt;code&gt;ptr&lt;/code&gt; ，和过载（13）使得能够 &lt;code&gt;shared_from_this&lt;/code&gt; 与由返回的指针 &lt;code&gt;r.release()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="933697ca9b43c7b723b629859ce79b9ed2a3265c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isfinite(a) &amp;amp;&amp;amp; isfinite(b)&lt;/code&gt;, the following properties are guaranteed:</source>
          <target state="translated">当 &lt;code&gt;isfinite(a) &amp;amp;&amp;amp; isfinite(b)&lt;/code&gt; ，保证以下属性：</target>
        </trans-unit>
        <trans-unit id="57eacd6a7d9600dd8cd2e42c3f2ae19d11ad628e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shared_ptr&lt;/code&gt; is created by calling &lt;code&gt;&lt;a href=&quot;shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt;, the memory for both the control block and the managed object is created with a single allocation. The managed object is constructed in-place in a data member of the control block. When &lt;code&gt;shared_ptr&lt;/code&gt; is created via one of the &lt;code&gt;shared_ptr&lt;/code&gt; constructors, the managed object and the control block must be allocated separately. In this case, the control block stores a pointer to the managed object.</source>
          <target state="translated">当 &lt;code&gt;shared_ptr&lt;/code&gt; 的是通过调用创建 &lt;code&gt;&lt;a href=&quot;shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt; ，用于控制块和管理对象都存储与单个分配创建。被管理对象在控制块的数据成员中就地构造。当 &lt;code&gt;shared_ptr&lt;/code&gt; 经由之一创建 &lt;code&gt;shared_ptr&lt;/code&gt; 的构造中，管理对象和所述控制块必须单独分配。在这种情况下，控制块存储指向被管理对象的指针。</target>
        </trans-unit>
        <trans-unit id="4833d1b8e7740b741eed936468b06c1d2f60499d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;t&lt;/code&gt; is a &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;forwarding reference&lt;/a&gt; (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt; it had when passed to the calling function.</source>
          <target state="translated">当 &lt;code&gt;t&lt;/code&gt; 是&lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;转发引用&lt;/a&gt;（一个函数参数被声明为对cv不合格的函数模板参数的右值引用）时，此重载会将参数转发给另一个函数，该函数具有传递给调用函数时具有的&lt;a href=&quot;../language/value_category&quot;&gt;值类别&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f05559f6187d0eff998ef174b497dd5f9e035c58" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;lock_guard&lt;/code&gt; object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the &lt;code&gt;lock_guard&lt;/code&gt; object was created, the &lt;code&gt;lock_guard&lt;/code&gt; is destructed and the mutex is released.</source>
          <target state="translated">当 &lt;code&gt;lock_guard&lt;/code&gt; 对象被创建，它试图把它给出互斥体的所有权。当控制离开在其中创建 &lt;code&gt;lock_guard&lt;/code&gt; 对象的作用域时，将破坏 &lt;code&gt;lock_guard&lt;/code&gt; 并释放互斥量。</target>
        </trans-unit>
        <trans-unit id="e69de8ba0616baddc63eba743d4447e24a787005" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;scoped_lock&lt;/code&gt; object is created, it attempts to take ownership of the mutexes it is given. When control leaves the scope in which the &lt;code&gt;scoped_lock&lt;/code&gt; object was created, the &lt;code&gt;scoped_lock&lt;/code&gt; is destructed and the mutexes are released, in reverse order. If several mutexes are given, deadlock avoidance algorithm is used as if by &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;scoped_lock&lt;/code&gt; 的对象被创建，它试图把它给出互斥的所有权。当控制离开在其中创建 &lt;code&gt;scoped_lock&lt;/code&gt; 对象的作用域时，将以相反的顺序破坏 &lt;code&gt;scoped_lock&lt;/code&gt; 并释放互斥体。如果给出了几个互斥锁，则使用死锁避免算法，就像 &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="303d35d938cb833eac9338017dabe149a1c1712f" translate="yes" xml:space="preserve">
          <source>When a base class is intended for polymorphic use, its destructor may have to be declared public and virtual. This blocks implicit moves (and deprecates implicit copies), and so the special member functions have to be declared as defaulted&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;rule_of_three#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">当基类打算用于多态时，可能必须将其析构函数声明为public和virtual。这会阻止隐式移动（并弃用隐式副本），因此必须将特殊成员函数声明为默认&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;rule_of_three#cite_note-2&quot;&gt;[2]。&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a38cdff86c855a9f5b8dafef92329da17987f83a" translate="yes" xml:space="preserve">
          <source>When a block declaration appears &lt;a href=&quot;statements#Compound_statements&quot;&gt;inside a block&lt;/a&gt;, and an identifier introduced by a declaration was previously declared in an outer block, the &lt;a href=&quot;scope&quot;&gt;outer declaration is hidden&lt;/a&gt; for the remainder of the block.</source>
          <target state="translated">当块声明出现&lt;a href=&quot;statements#Compound_statements&quot;&gt;在块内部时&lt;/a&gt;，并且先前在外部块中声明了由声明引入的标识符，则&lt;a href=&quot;scope&quot;&gt;外部声明&lt;/a&gt;对于该块的其余部分是隐藏的。</target>
        </trans-unit>
        <trans-unit id="da9117b375eefc957e65150185d8008bdc45763a" translate="yes" xml:space="preserve">
          <source>When a class or variable(since C++14) template is instantiated, and there are partial specializations available, the compiler has to decide if the primary template is going to be used or one of its partial specializations.</source>
          <target state="translated">当一个类或变量(自C++14以来)模板被实例化,并且有部分特殊化可用时,编译器必须决定是使用主模板还是其部分特殊化之一。</target>
        </trans-unit>
        <trans-unit id="fea65df3178fced8b0ade7c9ce2a6ba4bc611c76" translate="yes" xml:space="preserve">
          <source>When a class template specialization is referenced in context that requires a complete object type, or when a function template specialization is referenced in context that requires a function definition to exist, the template is</source>
          <target state="translated">当类模板特化在上下文中引用需要一个完整的对象类型时,或者当函数模板特化在上下文中引用需要一个函数定义存在时,模板是</target>
        </trans-unit>
        <trans-unit id="5769c7acaf1d2335b2ca90b0ec55efa0d236a336" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;private&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public and protected members of the base class are accessible as private members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">当一个类使用 &lt;code&gt;private&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;成员访问说明符&lt;/a&gt;从某个基类派生时，该基类的所有公共成员和受保护成员都可以作为该派生类的私有成员进行访问（除非成为友好成员，否则永远无法访问该基类的私有成员）。</target>
        </trans-unit>
        <trans-unit id="2fcd782f662cbfb240e5bd78fca278b024889cc7" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;protected&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public and protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">当一个类使用 &lt;code&gt;protected&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;成员访问说明符&lt;/a&gt;从某个基类派生时，该基类的所有公共成员和受保护成员都可以作为该派生类的受保护成员进行访问（除非成为友好成员，否则永远不能访问该基类的私有成员）。</target>
        </trans-unit>
        <trans-unit id="774bfe4108db2bde44499cb4a6ab68ddca8b923c" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;public&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public members of the base class are accessible as public members of the derived class and all protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">当类使用 &lt;code&gt;public&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;成员访问说明符&lt;/a&gt;从基类派生时，可以将基类的所有公共成员作为派生类的公共成员来访问，并且可以将基类的所有受保护成员作为派生类的受保护成员来访问（私有成员）除非有朋友，否则永远都无法访问该基地）。</target>
        </trans-unit>
        <trans-unit id="731c55e17d6e6e68ab60a46f9b70a72e60e6dd67" translate="yes" xml:space="preserve">
          <source>When a complete line of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">当需要刷新完整的输出行时，可以使用 &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; 机械手。</target>
        </trans-unit>
        <trans-unit id="c302c1bc7c6fed86bcea489bc973092937f86e79" translate="yes" xml:space="preserve">
          <source>When a coroutine begins execution, it performs the following:</source>
          <target state="translated">当一个coroutine开始执行时,它会执行以下操作。</target>
        </trans-unit>
        <trans-unit id="f150d08af5c8d72aecd740bc32ce2f1f91de3c2d" translate="yes" xml:space="preserve">
          <source>When a coroutine reaches a suspension point.</source>
          <target state="translated">当芯线达到悬点时。</target>
        </trans-unit>
        <trans-unit id="0c56a2828a8dc079acafa0f6578250d1ca9ad491" translate="yes" xml:space="preserve">
          <source>When a coroutine reaches the &lt;code&gt;co_return&lt;/code&gt; statement, it performs the following:</source>
          <target state="translated">当协程到达 &lt;code&gt;co_return&lt;/code&gt; 语句时，它将执行以下操作：</target>
        </trans-unit>
        <trans-unit id="cf467bf3385d5e1232a7b50fd987d1bda1eb5b07" translate="yes" xml:space="preserve">
          <source>When a feature changes significantly, the macro will be updated accordingly.</source>
          <target state="translated">当某一功能发生重大变化时,宏会相应地进行更新。</target>
        </trans-unit>
        <trans-unit id="a1204ab37d3f0482e454433db039fd14f2d10599" translate="yes" xml:space="preserve">
          <source>When a file is included, it is processed by &lt;a href=&quot;../language/translation_phases&quot;&gt;translation phases&lt;/a&gt; 1-4, which may include, recursively, expansion of the nested &lt;code&gt;#include&lt;/code&gt; directives. To avoid repeated inclusion of the same file and endless recursion when a file includes itself, perhaps transitively,</source>
          <target state="translated">当包含文件时，将在&lt;a href=&quot;../language/translation_phases&quot;&gt;翻译阶段&lt;/a&gt; 1-4中处理该文件，该翻译阶段可能包括递归扩展嵌套的 &lt;code&gt;#include&lt;/code&gt; 指令。为了避免重复包含同一文件并在文件包含自身时（可能是在传递时）进行无穷递归，</target>
        </trans-unit>
        <trans-unit id="0f6ee751ce2ae6f2e1fe4fc82e2efbe71ee15f4f" translate="yes" xml:space="preserve">
          <source>When a friend declaration refers to a full specialization of a function template, the keyword &lt;code&gt;inline&lt;/code&gt; and default arguments cannot be used.</source>
          <target state="translated">当好友声明引用函数模板的完全专业化时，不能使用关键字 &lt;code&gt;inline&lt;/code&gt; 和默认参数。</target>
        </trans-unit>
        <trans-unit id="dd03b884a832ad273a2adbacad6fb75f476bfdf0" translate="yes" xml:space="preserve">
          <source>When a function is invoked, e.g. in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function-call expression&lt;/a&gt;, the parameters are initialized from the arguments (either provided at the place of call or &lt;a href=&quot;default_arguments&quot;&gt;defaulted&lt;/a&gt;) and the statements in the function body are executed.</source>
          <target state="translated">调用函数时（例如，在&lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;函数调用表达式中）&lt;/a&gt;，将从参数（在调用位置提供或&lt;a href=&quot;default_arguments&quot;&gt;默认值&lt;/a&gt;）初始化参数，并执行函数主体中的语句。</target>
        </trans-unit>
        <trans-unit id="056da6db0024a8fc9e2178af3caa77a54e3aa303" translate="yes" xml:space="preserve">
          <source>When a function's return type is lvalue reference, the function call expression becomes an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt;:</source>
          <target state="translated">当函数的返回类型为左值引用时，函数调用表达式将成为&lt;a href=&quot;value_category&quot;&gt;左值表达式&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="4616bf2b5d98e8563f41341866c844e7ac6e8d1f" translate="yes" xml:space="preserve">
          <source>When a function-style cast or declaration of a variable uses the name of a primary class template &lt;code&gt;C&lt;/code&gt; without an argument list as the type specifier, deduction will proceed as follows:</source>
          <target state="translated">当函数样式的强制转换或变量声明使用不带参数列表的主类模板 &lt;code&gt;C&lt;/code&gt; 的名称作为类型说明符时，推导将如下进行：</target>
        </trans-unit>
        <trans-unit id="703e91dee14a5d41272ff0618515064124c5ca74" translate="yes" xml:space="preserve">
          <source>When a lambda captures a member using implicit by-copy capture, it does not make a copy of that member variable: the use of a member variable &lt;code&gt;m&lt;/code&gt; is treated as an expression &lt;code&gt;(*this).m&lt;/code&gt;, and &lt;code&gt;*this&lt;/code&gt; is always implicitly captured by reference:</source>
          <target state="translated">当lambda使用隐式按拷贝捕获捕获成员时，它不会复制该成员变量：成员变量 &lt;code&gt;m&lt;/code&gt; 的使用被视为表达式 &lt;code&gt;(*this).m&lt;/code&gt; ，而 &lt;code&gt;*this&lt;/code&gt; 始终被隐式捕获引用：</target>
        </trans-unit>
        <trans-unit id="3ea6ad3dcd073f66ca30ba43dbc0f20952f4603c" translate="yes" xml:space="preserve">
          <source>When a local class declares an unqualified function or class as a friend, only functions and classes in the innermost non-class scope are &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt;, not the global functions:</source>
          <target state="translated">当本地类将不合格的函数或类声明为朋友时，仅&lt;a href=&quot;lookup&quot;&gt;查找&lt;/a&gt;最内部非类范围内的函数和类，而不是全局函数：</target>
        </trans-unit>
        <trans-unit id="8b46570618f5daf88923faf7d12da8873e3be80a" translate="yes" xml:space="preserve">
          <source>When a member is redeclared within the same class, it must do so under the same member access:</source>
          <target state="translated">当一个成员在同一个类内重新声明时,必须在同一个成员访问下进行。</target>
        </trans-unit>
        <trans-unit id="f224ac0d371f052e58a2217d4de98b1976737b0e" translate="yes" xml:space="preserve">
          <source>When a non-static class member is used in any of the contexts where the &lt;code&gt;this&lt;/code&gt; keyword is allowed (non-static member function bodies, member initializer lists, default member initializers), the implicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; is automatically added before the name, resulting in a member access expression (which, if the member is a virtual member function, results in a virtual function call).</source>
          <target state="translated">在允许使用 &lt;code&gt;this&lt;/code&gt; 关键字的任何上下文中使用非静态类成员（非静态成员函数体，成员初始化器列表，默认成员初始化器）时，隐式 &lt;code&gt;this-&amp;gt;&lt;/code&gt; 会自动添加到名称之前，从而在成员访问表达式中（如果成员是虚拟成员函数，则导致虚拟函数调用）。</target>
        </trans-unit>
        <trans-unit id="c996fe1da1454bb286aadf030b85cfad7cae8fed" translate="yes" xml:space="preserve">
          <source>When a pointer to a protected member is formed, it must use a derived class in its declaration:</source>
          <target state="translated">当形成一个指向受保护成员的指针时,它必须在声明中使用派生类。</target>
        </trans-unit>
        <trans-unit id="7fe22ece7b8d4604836b61b68f07304156388fd8" translate="yes" xml:space="preserve">
          <source>When a qualified name is used as a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, then &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified lookup&lt;/a&gt; of the names used in the same declarator that follow that qualified name, but not the names that precede it, is performed in the scope of the member's class or namespace:</source>
          <target state="translated">当使用合格名称作为&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;符时，将在成员的类或命名空间的范围内对在该合格名称之后的同一声明&lt;a href=&quot;unqualified_lookup&quot;&gt;符&lt;/a&gt;中使用的名称进行非限定性查找，而不是在其前面的名称进行查找：</target>
        </trans-unit>
        <trans-unit id="7128500ddb4a19baad89fa94da4a6a51b2aa2144" translate="yes" xml:space="preserve">
          <source>When a signaling NaN is used as an argument to an arithmetic expression, the appropriate floating-point exception may be raised and the NaN is &quot;quieted&quot;, that is, the expression returns a quiet NaN.</source>
          <target state="translated">当一个信号NaN被用作算术表达式的参数时,可能会引发相应的浮点异常,并使NaN &quot;安静 &quot;下来,即表达式返回一个安静的NaN。</target>
        </trans-unit>
        <trans-unit id="7f3acde83607f5ff6b438f0d494f026c16dc4d51" translate="yes" xml:space="preserve">
          <source>When a thread owns a &lt;code&gt;mutex&lt;/code&gt;, all other threads will block (for calls to &lt;a href=&quot;mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;) or receive a &lt;code&gt;false&lt;/code&gt; return value (for &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;) if they attempt to claim ownership of the &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="translated">当一个线程拥有一个 &lt;code&gt;mutex&lt;/code&gt; ，所有其他线程如果试图声明对该 &lt;code&gt;mutex&lt;/code&gt; 所有权，将阻塞（用于调用&lt;a href=&quot;mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;）或接收到 &lt;code&gt;false&lt;/code&gt; 返回值（用于&lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="48235a61557c038c024774d3984da66f889dd511" translate="yes" xml:space="preserve">
          <source>When a thread owns a &lt;code&gt;recursive_mutex&lt;/code&gt;, all other threads will block (for calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;) or receive a &lt;code&gt;false&lt;/code&gt; return value (for &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;) if they attempt to claim ownership of the &lt;code&gt;recursive_mutex&lt;/code&gt;.</source>
          <target state="translated">当线程拥有 &lt;code&gt;recursive_mutex&lt;/code&gt; 时，如果所有其他线程试图声明对 &lt;code&gt;recursive_mutex&lt;/code&gt; 的所有权，则它们将阻塞（用于调用&lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;）或接收到 &lt;code&gt;false&lt;/code&gt; 返回值（对于&lt;a href=&quot;recursive_mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="78d07a1734d460127f218d90a8985eff2cc5268d" translate="yes" xml:space="preserve">
          <source>When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; for details on the order in which writes made from threads become visible to other threads.</source>
          <target state="translated">当线程从内存位置读取值时，它可能会看到初始值，在同一线程中写入的值或在另一线程中写入的值。有关从线程进行的写入对其他线程可见的顺序的详细信息，请参见 &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35914adcda38d9bc606dedbc8e87f226f4c33d60" translate="yes" xml:space="preserve">
          <source>When a unary fold is used with a pack expansion of length zero, only the following operators are allowed:</source>
          <target state="translated">当使用长度为零的包扩展的单利折叠时,只允许使用以下运算符。</target>
        </trans-unit>
        <trans-unit id="a5725eb8b03373883cd17dd14b578f1aefe9ae18" translate="yes" xml:space="preserve">
          <source>When a union is initialized by aggregate initialization, only its first non-static data member is initialized.</source>
          <target state="translated">当一个联合体被集合初始化时,只有它的第一个非静态数据成员被初始化。</target>
        </trans-unit>
        <trans-unit id="75156726fb61b37daeae849a8c23a8d3e99ac431" translate="yes" xml:space="preserve">
          <source>When a user-defined class overloads the function call operator, &lt;code&gt;operator()&lt;/code&gt;, it becomes a &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; type. Many standard algorithms, from &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../algorithm/accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; accept objects of such types to customize behavior. There are no particularly notable canonical forms of &lt;code&gt;operator()&lt;/code&gt;, but to illustrate the usage.</source>
          <target state="translated">当用户定义的类重载函数调用操作 &lt;code&gt;operator()&lt;/code&gt; ，它将变为&lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt;类型。从 &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;../algorithm/accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; 许多标准算法都接受此类类型的对象以自定义行为。没有任何特别值得注意的规范形式的 &lt;code&gt;operator()&lt;/code&gt; ，只是为了说明用法。</target>
        </trans-unit>
        <trans-unit id="48f53b62820f7fe3746951152075f1cdb1ddd004" translate="yes" xml:space="preserve">
          <source>When a variadic function is called, after lvalue-to-rvalue, array-to-pointer, and function-to-pointer &lt;a href=&quot;implicit_cast#Lvalue_transformations&quot;&gt;conversions&lt;/a&gt;, each argument that is a part of the variable argument list undergoes additional conversions known as</source>
          <target state="translated">调用可变参数函数时，在左值到右值，数组到指针和函数到指针的&lt;a href=&quot;implicit_cast#Lvalue_transformations&quot;&gt;转换之后&lt;/a&gt;，作为变量参数列表一部分的每个参数都经历了称为</target>
        </trans-unit>
        <trans-unit id="4fc2bc7f5954311ab6cd53cf773a77f33b1fad76" translate="yes" xml:space="preserve">
          <source>When a virtual function call is made, the type returned by the final overrider is &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to the return type of the overridden function that was called:</source>
          <target state="translated">进行虚函数调用时，最终重写&lt;a href=&quot;implicit_cast&quot;&gt;器&lt;/a&gt;返回的类型将隐式转换为被调用的重写函数的返回类型：</target>
        </trans-unit>
        <trans-unit id="93489141e89c6d227a8966329ac45e5e0c099d81" translate="yes" xml:space="preserve">
          <source>When a virtual function is called directly or indirectly from a constructor or from a destructor (including during the construction or destruction of the class&amp;rsquo;s non-static data members, e.g. in a member &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt;), and the object to which the call applies is the object under construction or destruction, the function called is the final overrider in the constructor&amp;rsquo;s or destructor&amp;rsquo;s class and not one overriding it in a more-derived class. In other words, during construction or destruction, the more-derived classes do not exist.</source>
          <target state="translated">当从构造函数或析构函数直接或间接调用虚拟函数时（包括在构造或破坏类的非静态数据成员的过程中，例如在成员&lt;a href=&quot;constructor&quot;&gt;初始化程序列表中&lt;/a&gt;），并且调用所应用的对象是在构造或销毁对象时，调用的函数是构造函数或析构函数的类中的最终重写器，而不是在派生更高的类中对其进行覆盖的函数。换句话说，在构造或破坏期间，不存在派生性更高的类。</target>
        </trans-unit>
        <trans-unit id="c93bab45e9c1d0dfc9ec2e952c16e1c1852bb4fb" translate="yes" xml:space="preserve">
          <source>When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of &lt;code&gt;T&lt;/code&gt; may include padding bits,(until C++20) trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.</source>
          <target state="translated">当弱的比较交换需要一个循环而强循环则不需要一个循环时，除非 &lt;code&gt;T&lt;/code&gt; 的对象表示可以包括填充位，（直到C ++ 20）陷阱位或提供多个对象表示，否则强的比较可取。对于相同的值（例如，浮点NaN）。在这些情况下，弱比较和交换通常可以工作，因为它可以快速收敛于某些稳定的对象表示形式。</target>
        </trans-unit>
        <trans-unit id="b549d145a45bd55485a97603e36455b405b7f9e4" translate="yes" xml:space="preserve">
          <source>When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of &lt;code&gt;T&lt;/code&gt; may include trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.</source>
          <target state="translated">当弱比较和交换将需要一个循环而强循环则不需要一个循环时，除非 &lt;code&gt;T&lt;/code&gt; 的对象表示可能包括陷阱位或为同一值提供多个对象表示（例如，浮点NaN），否则最好使用强循环）。在这些情况下，弱比较和交换通常可以工作，因为它可以快速收敛于某些稳定的对象表示形式。</target>
        </trans-unit>
        <trans-unit id="3267a8eb3fe0cea3cd97459c2f9b3b8e6692761b" translate="yes" xml:space="preserve">
          <source>When active member of a union is switched by an assignment expression of the form &lt;code&gt;E1 = E2&lt;/code&gt; that uses either the built-in assignment operator or a trivial assignment operator, for each union member X that appears in the member access and array subscript subexpressions of &lt;code&gt;E1&lt;/code&gt; that is not a class with non-trivial or deleted default constructors, if modification of X would have undefined behavior under type aliasing rules, an object of the type of X is implicitly created in the nominated storage; no initialization is performed and the beginning of its lifetime is sequenced after the value computation of the left and right operands and before the assignment.</source>
          <target state="translated">当使用形式为 &lt;code&gt;E1 = E2&lt;/code&gt; 的赋值表达式（使用内置赋值运算符或平凡的赋值运算符）来切换联合的活动成员时，对于出现在 &lt;code&gt;E1&lt;/code&gt; 的成员访问和数组下标子表达式中的每个联合成员X 这不是具有非平凡的或默认的构造函数的类，如果在类型别名规则下对X的修改将具有未定义的行为，则会在指定的存储中隐式创建X类型的对象；不执行初始化，并且其寿命的开始在左右操作数的值计算之后和赋值之前进行排序。</target>
        </trans-unit>
        <trans-unit id="d56d5c0d1a9783bd328d5ceefac5e3f1fa5681a7" translate="yes" xml:space="preserve">
          <source>When all template arguments have been specified, deduced or obtained from default template arguments, every use of a template parameter in the function parameter list is replaced with the corresponding template arguments.</source>
          <target state="translated">当所有模板参数都已被指定、推导或从默认模板参数中获得时,函数参数列表中每使用一个模板参数都会被相应的模板参数所替代。</target>
        </trans-unit>
        <trans-unit id="b6e6698c4323b10a60e0746ae78192f4bab23b17" translate="yes" xml:space="preserve">
          <source>When allocating an object whose alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; or an array of such objects, the new-expression passes the alignment requirement (wrapped in &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) as the second argument for the allocation function (for placement forms, &lt;code&gt;placement_params&lt;/code&gt; appear after the alignment, as the third, fourth, etc arguments). If overload resolution fails (which happens when a class-specific allocation function is defined with a different signature, since it hides the globals), overload resolution is attempted a second time, without alignment in the argument list. This allows alignment-unaware class-specific allocation functions to take precedence over the global alignment-aware allocation functions.</source>
          <target state="translated">当分配对象的对齐要求超过 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 或此类对象的数组时，new表达式会将对齐要求（包装在 &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; ）作为分配函数的第二个参数（对于放置形式， &lt;code&gt;placement_params&lt;/code&gt; 在对齐之后出现，作为第三个，第四个等参数）。如果重载解析失败（这种情况在使用不同的签名定义特定于类的分配函数时会发生，因为它隐藏了全局变量），那么将再次尝试重载解析，而无需在参数列表中对齐。这允许不了解对齐的类特定的分配功能优先于全局了解对齐的分配功能。</target>
        </trans-unit>
        <trans-unit id="32f253fd06f69fca2aca9bf86ab82833c3ab166b" translate="yes" xml:space="preserve">
          <source>When allocating objects and arrays of objects whose alignment exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-aware function signatures, then for alignment-unaware function signatures.</source>
          <target state="translated">在分配对齐方式超过 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 的对象和对象数组时，与常规形式一样，对放置表单的重载解析将执行两次：首先，对于可对齐的功能签名，然后对于不对齐的功能签名。</target>
        </trans-unit>
        <trans-unit id="fc6458ca664e9adb25872544f8c6cbc1b8d2ef56" translate="yes" xml:space="preserve">
          <source>When allocating objects and arrays of objects whose alignment exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, overload resolution is performed twice: first, for alignment-aware function signatures, then for alignment-unaware function signatures. This means that if a class with extended alignment has an alignment-unaware class-specific allocation function, it is the function that will be called, not the global alignment-aware allocation function. This is intentional: the class member is expected to know best how to handle that class.</source>
          <target state="translated">分配对齐方式超过 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; 的对象和对象数组时，将执行两次重载解析：首先，对可识别对齐的功能签名，然后对不对齐的功能签名。这意味着，如果具有扩展对齐方式的类具有不知道对齐方式的类特定的分配函数，则将调用该函数，而不是全局了解对齐方式的分配函数。这是故意的：希望班级成员最了解如何处理该班级。</target>
        </trans-unit>
        <trans-unit id="dbe54944a43bccf5cf205c899d78217a14037efa" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;eval_order&quot;&gt;evaluation&lt;/a&gt; of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to</source>
          <target state="translated">当一个表达式的&lt;a href=&quot;eval_order&quot;&gt;评估值&lt;/a&gt;写入一个存储位置，而另一个评估值读取或修改相同的存储器位置时，这些表达式被称为</target>
        </trans-unit>
        <trans-unit id="f54b782cb8a2443df3f24c71942278de560d6c94" translate="yes" xml:space="preserve">
          <source>When an exception of type &lt;code&gt;E&lt;/code&gt; is thrown by any statement in compound-statement, it is matched against the types of the formal parameters &lt;code&gt;T&lt;/code&gt; of each catch-clause in handler-seq, in the order in which the catch clauses are listed. The exception is a match if any of the following is true:</source>
          <target state="translated">当复合语句中的任何语句引发类型 &lt;code&gt;E&lt;/code&gt; 的异常时，它都会按照catch子句的列出顺序与handler-seq中每个catch子句的形式参数 &lt;code&gt;T&lt;/code&gt; 的类型进行匹配。如果满足以下任一条件，则为匹配项：</target>
        </trans-unit>
        <trans-unit id="141971b19d6009b0db3fb823a2039b332a4e6a99" translate="yes" xml:space="preserve">
          <source>When an explicit instantiation names a class template specialization, it serves as an explicit instantiation of the same kind (declaration or definition) of each of its non-inherited non-template members that has not been previously explicitly specialized in the translation unit. If this explicit instantiation is a definition, it is also an explicit instantiation definition only for the members that have been defined at this point.</source>
          <target state="translated">当一个显式实例化命名了一个类模板专化时,它作为它的每一个非继承的非模板成员的同类(声明或定义)的显式实例化,而这些成员之前在翻译单元中没有被显式专化。如果这个显式实例化是一个定义,那么它也是一个显式实例化定义,只针对此时已经定义的成员。</target>
        </trans-unit>
        <trans-unit id="2e3df706304532f1fafe99d11c7b971952d33cd6" translate="yes" xml:space="preserve">
          <source>When an expression that uses type or non-type template parameters appears in the function parameter list or in the return type, that expression remains a part of the function template signature for the purpose of overloading:</source>
          <target state="translated">当一个使用类型或非类型模板参数的表达式出现在函数参数列表或返回类型中时,该表达式仍然是函数模板签名的一部分,以便于重载。</target>
        </trans-unit>
        <trans-unit id="d6a2958786f5f2e3f6b231cd1ab5ade2e4415a58" translate="yes" xml:space="preserve">
          <source>When an incomplete line of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;flush&quot;&gt;std::flush&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">当需要清除不完整的输出行时，可以使用 &lt;code&gt;&lt;a href=&quot;flush&quot;&gt;std::flush&lt;/a&gt;&lt;/code&gt; 操纵器。</target>
        </trans-unit>
        <trans-unit id="ddca8d5dd1fab756efa48fbbb7d3a9d39e978269" translate="yes" xml:space="preserve">
          <source>When an object is first created, the cv-qualifiers used (which could be part of decl-specifier-seq or part of a declarator in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, or part of type-id in a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;) determine the constness or volatility of the object, as follows:</source>
          <target state="translated">首次创建对象时，使用的cv限定词（可以是decl-specifier-seq的一部分，或者是声明中的&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;符的一部分，或者是&lt;a href=&quot;new&quot;&gt;new-expression中&lt;/a&gt;的type-id的一部分），可以确定以下内容的常数或易变性对象，如下所示：</target>
        </trans-unit>
        <trans-unit id="d130a7fb0dc18dd843e992986efede0bda37daa7" translate="yes" xml:space="preserve">
          <source>When an object of class type X is passed to or returned from a function, if each copy constructor, move constructor, and destructor of X is either trivial or deleted, and X has at least one non-deleted copy or move constructor, implementations are permitted to create a temporary object to hold the function parameter or result object.</source>
          <target state="translated">当类类型X的对象传递给函数或从函数返回时,如果X的每个复制构造函数、移动构造函数和析构函数都是琐碎的或被删除的,而且X至少有一个非删除的复制或移动构造函数,则允许实现者创建一个临时对象来存放函数参数或结果对象。</target>
        </trans-unit>
        <trans-unit id="01dd171c098fe6b55329621a15cc7367dee5f1d4" translate="yes" xml:space="preserve">
          <source>When an object of class type is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt; outside a &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; context, the candidate functions are all constructors of the class being initialized. The argument list is the expression list of the initializer.</source>
          <target state="translated">当在&lt;a href=&quot;copy_initialization&quot;&gt;复制初始化&lt;/a&gt;上下文之外&lt;a href=&quot;direct_initialization&quot;&gt;直接初始化&lt;/a&gt;或&lt;a href=&quot;default_initialization&quot;&gt;默认初始化&lt;/a&gt;类类型的对象时，候选函数都是要初始化的类的所有构造函数。参数列表是初始化程序的表达式列表。</target>
        </trans-unit>
        <trans-unit id="b112f8307a878b858abe15c415401e098531c633" translate="yes" xml:space="preserve">
          <source>When an object of class type is copy-initialized from an object of the same or derived class type, or default-initialized in a copy-initialization context, the candidate functions are all &lt;a href=&quot;converting_constructor&quot;&gt;converting constructors&lt;/a&gt; of the class being initialized. The argument list is the expression of the initializer.</source>
          <target state="translated">当从相同或派生类类型的对象复制初始化类类型的对象，或在复制初始化上下文中将其默认初始化时，候选函数都是正在&lt;a href=&quot;converting_constructor&quot;&gt;转换&lt;/a&gt;的类的构造函数。参数列表是初始化程序的表达式。</target>
        </trans-unit>
        <trans-unit id="6c417ae51346e00b8f2e04143715b97da243d164" translate="yes" xml:space="preserve">
          <source>When an object of non-aggregate class type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;, two-phase overload resolution takes place.</source>
          <target state="translated">当非聚合类类型的对象 &lt;code&gt;T&lt;/code&gt; 是&lt;a href=&quot;list_initialization&quot;&gt;列表初始化&lt;/a&gt;，两相重载发生。</target>
        </trans-unit>
        <trans-unit id="ae6288b4e0c89ad0ee91c5bb7ab0d2b10cfef5c7" translate="yes" xml:space="preserve">
          <source>When an object of some class &lt;code&gt;C&lt;/code&gt; is created, each non-static data member of non-reference type is allocated in some part of the object representation of &lt;code&gt;C&lt;/code&gt;. Whether reference members occupy any storage is implementation-defined, but their &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; is the same as that of the object in which they are members.</source>
          <target state="translated">创建某个类 &lt;code&gt;C&lt;/code&gt; 的对象时，每个非引用类型的非静态数据成员都分配在 &lt;code&gt;C&lt;/code&gt; 的对象表示的某些部分中。引用成员是否占用任何存储空间是实现定义的，但是它们的&lt;a href=&quot;storage_duration&quot;&gt;存储持续时间&lt;/a&gt;与它们作为成员的对象的存储持续时间相同。</target>
        </trans-unit>
        <trans-unit id="63af81fffbdf1a90668b23768fdc0980bed3770a" translate="yes" xml:space="preserve">
          <source>When an object of type optional&amp;lt;T&amp;gt; is &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted to bool&lt;/a&gt;, the conversion returns &lt;code&gt;true&lt;/code&gt; if the object</source>
          <target state="translated">当类型为optional &amp;lt;T&amp;gt;的对象在&lt;a href=&quot;../language/implicit_cast&quot;&gt;上下文中转换为bool时&lt;/a&gt;，如果该对象返回，则转换返回 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1564a3bf1abdab4804c3b45d781d0743bc25fc6d" translate="yes" xml:space="preserve">
          <source>When an operator appears in an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt;, and at least one of its operands has a &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; or an &lt;a href=&quot;enum&quot;&gt;enumeration type&lt;/a&gt;, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; is used to determine the user-defined function to be called among all the functions whose signatures match the following:</source>
          <target state="translated">当运算符出现在&lt;a href=&quot;expressions&quot;&gt;表达式中&lt;/a&gt;，并且其操作数中至少一个具有&lt;a href=&quot;class&quot;&gt;类类型&lt;/a&gt;或&lt;a href=&quot;enum&quot;&gt;枚举类型时&lt;/a&gt;，则使用&lt;a href=&quot;overload_resolution&quot;&gt;重载解析&lt;/a&gt;来确定其签名与以下各项匹配的所有函数中要调用的用户定义函数：</target>
        </trans-unit>
        <trans-unit id="fb0096bc731b7218f872e304d201c5d20ef5e918" translate="yes" xml:space="preserve">
          <source>When an unscoped enumeration is a class member, its enumerators may be accessed using class member access operators &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">当无作用域枚举是类成员时，可以使用类成员访问操作符访问其枚举数 &lt;code&gt;.&lt;/code&gt; 和 &lt;code&gt;-&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="6f67767f1271f59038f6527a10110416f4a16657" translate="yes" xml:space="preserve">
          <source>When applied to a class type, the result is the size of an object of that class plus any additional padding required to place such object in an array.</source>
          <target state="translated">当应用于一个类类型时,结果是该类对象的大小加上将该对象放置在一个数组中所需的任何附加填充。</target>
        </trans-unit>
        <trans-unit id="ad0c1d3f6453f804c34d81d7a95f3f37e5786005" translate="yes" xml:space="preserve">
          <source>When applied to a class, the identifier &lt;code&gt;final&lt;/code&gt; appears at the beginning of the class definition, immediately after the name of the class.</source>
          <target state="translated">当应用于类时，标识符 &lt;code&gt;final&lt;/code&gt; 出现在类定义的开头，紧随类名之后。</target>
        </trans-unit>
        <trans-unit id="ebcafd6f66dd47f9f7ba53777289ab2dbc04fbca" translate="yes" xml:space="preserve">
          <source>When applied to a member function, the identifier &lt;code&gt;final&lt;/code&gt; appears immediately after the &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; in the syntax of a member function declaration or a member function definition inside a class definition.</source>
          <target state="translated">当应用于成员函数时，标识符 &lt;code&gt;final&lt;/code&gt; 会在成员函数声明或类定义内的成员函数定义的语法中紧随&lt;a href=&quot;function&quot;&gt;声明&lt;/a&gt;符之后出现。</target>
        </trans-unit>
        <trans-unit id="64935cc54ab77b2b7e3b4674a370a21df9f2ba1a" translate="yes" xml:space="preserve">
          <source>When applied to a pointer, the subscript expression is always an lvalue.</source>
          <target state="translated">当应用于一个指针时,下标表达式总是一个l值。</target>
        </trans-unit>
        <trans-unit id="3fa5cb2eff44efae521c7cddc759eb971197f991" translate="yes" xml:space="preserve">
          <source>When applied to a reference type, the result is the size of the referenced type.</source>
          <target state="translated">当应用于引用类型时,结果是被引用类型的大小。</target>
        </trans-unit>
        <trans-unit id="f4ae2ed79afdeb8f6c2a098503944e0bac2fe877" translate="yes" xml:space="preserve">
          <source>When applied to an array, the subscript expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; if the array is an lvalue, and an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; if it isn't(since C++11).</source>
          <target state="translated">当应用于数组时，如果数组为左值，则下标表达式为&lt;a href=&quot;value_category&quot;&gt;左&lt;/a&gt;值，否则为&lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt;（因为C ++ 11）。</target>
        </trans-unit>
        <trans-unit id="b3759c1c966a143bdfd4814a06fb7b793ddc31c8" translate="yes" xml:space="preserve">
          <source>When applied to an expression of polymorphic type, evaluation of a typeid expression may involve runtime overhead (a virtual table lookup), otherwise typeid expression is resolved at compile time.</source>
          <target state="translated">当应用于多态类型的表达式时,typeid表达式的评估可能会涉及到运行时的开销(虚拟表查找),否则typeid表达式会在编译时解析。</target>
        </trans-unit>
        <trans-unit id="e5ed37890741158bbf054cf52a8ebbc0e73b98c9" translate="yes" xml:space="preserve">
          <source>When applied to an expression, &lt;code&gt;sizeof&lt;/code&gt; does &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;not evaluate the expression&lt;/a&gt;, and even if the expression designates a polymorphic object, the result is the size of the static type of the expression. Lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversions are not performed. &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;Temporary materialization&lt;/a&gt;, however, is (formally) performed for prvalue arguments: sizeof determines the size of the result object.(since C++17).</source>
          <target state="translated">在将表达式应用于表达式时， &lt;code&gt;sizeof&lt;/code&gt; 不会&lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;评估表达式&lt;/a&gt;，即使表达式指定了多态对象，结果也是表达式的静态类型的大小。不执行左值到右值，数组到指针或函数到指针的转换。但是，&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;临时实现&lt;/a&gt;是（正式）对prvalue参数执行的：sizeof确定结果对象的大小。（从C ++ 17开始）。</target>
        </trans-unit>
        <trans-unit id="902efcbdae8639c2479afc412e93c5b16435e58a" translate="yes" xml:space="preserve">
          <source>When calling the allocation function, the new-expression passes the number of bytes requested as the first argument, of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, which is exactly &lt;code&gt;sizeof(T)&lt;/code&gt; for non-array &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">调用分配函数时，new-expression将请求的字节数作为第一个参数传递，其类型为 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ，对于非数组 &lt;code&gt;T&lt;/code&gt; ，正好为 &lt;code&gt;sizeof(T)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7aab9cd14cb0a3097419a3a095e5a8499afb16ff" translate="yes" xml:space="preserve">
          <source>When code refers to a function in context that requires the function definition to exist, and this particular function has not been explicitly instantiated, implicit instantiation occurs. The list of template arguments does not have to be supplied if it can be &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from context.</source>
          <target state="translated">当代码在需要功能定义存在的上下文中引用功能时，并且尚未明确实例化此特定功能时，将发生隐式实例化。如果可以从上下文&lt;a href=&quot;template_argument_deduction&quot;&gt;推断出&lt;/a&gt;模板参数列表，则不必提供。</target>
        </trans-unit>
        <trans-unit id="2f3a994250d478ff5309a561ec4f4f714968e84d" translate="yes" xml:space="preserve">
          <source>When code refers to a template in context that requires a completely defined type, or when the completeness of the type affects the code, and this particular type has not been explicitly instantiated, implicit instantiation occurs. For example, when an object of this type is constructed, but not when a pointer to this type is constructed.</source>
          <target state="translated">当代码在上下文中引用一个模板需要一个完全定义的类型时,或者当类型的完整性影响到代码时,而这个特定的类型还没有被显式实例化,就会发生隐式实例化。例如,当构造了这个类型的对象,但没有构造这个类型的指针时,就会发生隐式实例化。</target>
        </trans-unit>
        <trans-unit id="e579a073bc59e27215b96008dac2e50df4bb57db" translate="yes" xml:space="preserve">
          <source>When comparing entire containers for equality, &lt;code&gt;operator==&lt;/code&gt; for the corresponding container are usually preferred.</source>
          <target state="translated">在比较整个容器的相等性时，通常首选对相应容器使用 &lt;code&gt;operator==&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47745284a6ed97288740ca09ddbb9f643055ef39" translate="yes" xml:space="preserve">
          <source>When considering the argument to a constructor or to a user-defined conversion function, only one standard conversion sequence is allowed (otherwise user-defined conversions could be effectively chained). When converting from one built-in type to another built-in type, only one standard conversion sequence is allowed.</source>
          <target state="translated">当考虑构造函数或用户定义的转换函数的参数时,只允许一个标准的转换序列(否则用户定义的转换可能会被有效地连锁)。当从一个内置类型转换到另一个内置类型时,只允许一个标准转换序列。</target>
        </trans-unit>
        <trans-unit id="553ce681044a1dac36f2a3c93df19f57a9078616" translate="yes" xml:space="preserve">
          <source>When constructing a complex class with multiple branches, within a constructor that belongs to one branch, polymorphism is restricted to that class and its bases: if it obtains a pointer or reference to a base subobject outside this subhierarchy, and attempts to invoke a virtual function call (e.g. using explicit member access), the behavior is undefined:</source>
          <target state="translated">当构造一个具有多个分支的复杂类时,在一个属于一个分支的构造函数内,多态被限制在该类及其基体上:如果它在这个子结构之外获得一个指向基体子对象的指针或引用,并试图调用一个虚拟函数(例如使用显式成员访问),则行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="aed446bf94f330e6e0b55d02da8f34b88ffea9e7" translate="yes" xml:space="preserve">
          <source>When copy elision occurs, the implementation treats the source and target of the omitted copy/move(since C++11) operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization (except that, if the parameter of the selected constructor is an rvalue reference to object type, the destruction occurs when the target would have been destroyed)(since C++17).</source>
          <target state="translated">当发生复制洗脱时,实现将省略复制/移动(自C++11起)操作的源和目标简单地视为对同一对象的两种不同的引用方式,该对象的销毁发生在没有优化的情况下这两个对象本应被销毁的时间中较晚的一个(但如果选择的构造函数的参数是对象类型的rvalue引用,则销毁发生在目标本应被销毁的时候)(自C++17起)。</target>
        </trans-unit>
        <trans-unit id="2dc86f028e3cfb1147dc7e004b4c16749351361e" translate="yes" xml:space="preserve">
          <source>When copying overlapping ranges, &lt;code&gt;std::copy&lt;/code&gt; is appropriate when copying to the left (beginning of the destination range is outside the source range) while &lt;code&gt;std::copy_backward&lt;/code&gt; is appropriate when copying to the right (end of the destination range is outside the source range).</source>
          <target state="translated">复制重叠范围时，向左复制时 &lt;code&gt;std::copy&lt;/code&gt; 是合适的（目标范围的起点在源范围之外），而向右复制时， &lt;code&gt;std::copy_backward&lt;/code&gt; 是合适的（目标范围的末尾在源范围之外）范围）。</target>
        </trans-unit>
        <trans-unit id="63771776b0fe78c4297c086089bcc7b025dc8ded" translate="yes" xml:space="preserve">
          <source>When declaring a function, &lt;a href=&quot;except_spec&quot;&gt; exception specifications&lt;/a&gt; and &lt;a href=&quot;noexcept_spec&quot;&gt; noexcept specifiers&lt;/a&gt; may be provided to limit the types of the exceptions a function may throw.</source>
          <target state="translated">当声明一个函数时，可以提供&lt;a href=&quot;except_spec&quot;&gt;异常规范&lt;/a&gt;和&lt;a href=&quot;noexcept_spec&quot;&gt;noexcept限定符&lt;/a&gt;来限制函数可能抛出的异常类型。</target>
        </trans-unit>
        <trans-unit id="a46821f25349d54835cd348827a97ba1db7215ad" translate="yes" xml:space="preserve">
          <source>When defining a member of an explicitly specialized class template outside the body of the class, the syntax &lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt; is not used, except if it's a member of an explicitly specialized member class template, which is specialized as a class template, because otherwise, the syntax would require such definition to begin with &lt;code&gt;template&amp;lt;parameters&amp;gt;&lt;/code&gt; required by the nested template.</source>
          <target state="translated">在类的主体之外定义显式专门化的类模板的成员时，不使用语法 &lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt; ，除非它是显式专门化的成员类模板（专门化为类模板）的成员，否则，语法将要求此类定义以嵌套模板所需的 &lt;code&gt;template&amp;lt;parameters&amp;gt;&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="80a330b63ba0a84c45e73880291aa572a3efa1e6" translate="yes" xml:space="preserve">
          <source>When determining if two &lt;a href=&quot;dependent_name&quot;&gt;dependent expressions&lt;/a&gt; are equivalent, only the dependent names involved are considered, not the results of name lookup. If multiple declarations of the same template differ in the result of name lookup, the first such declaration is used:</source>
          <target state="translated">在确定两个&lt;a href=&quot;dependent_name&quot;&gt;从属表达式&lt;/a&gt;是否等效时，仅考虑所涉及的从属名称，而不考虑名称查找的结果。如果同一模板的多个声明在名称查找结果中不同，则使用第一个这样的声明：</target>
        </trans-unit>
        <trans-unit id="7ef9fbc568a29fc667929a02fb6d63098b804ede" translate="yes" xml:space="preserve">
          <source>When directly used as the condition of &lt;a href=&quot;../language/static_assert&quot;&gt;&lt;code&gt;static_assert&lt;/code&gt; declaration&lt;/a&gt; or &lt;a href=&quot;../language/if#constexpr_if&quot;&gt;constexpr if statement&lt;/a&gt;, &lt;code&gt;std::is_constant_evaluated()&lt;/code&gt; always returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">当直接用作&lt;a href=&quot;../language/static_assert&quot;&gt; &lt;code&gt;static_assert&lt;/code&gt; 声明&lt;/a&gt;或&lt;a href=&quot;../language/if#constexpr_if&quot;&gt;constexpr if语句&lt;/a&gt;的条件时， &lt;code&gt;std::is_constant_evaluated()&lt;/code&gt; 始终返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18b778058d4f47bf64716da2bbf948a1a5fb94a5" translate="yes" xml:space="preserve">
          <source>When earlier tiebreakers, including partial ordering, failed to distinguish between two candidate function templates, the following rules apply:</source>
          <target state="translated">当早期的平局(包括部分排序)未能区分两个候选函数模板时,适用以下规则。</target>
        </trans-unit>
        <trans-unit id="c5dfcd38376374c25b198c54aa21d3fdad95c984" translate="yes" xml:space="preserve">
          <source>When enabled, for an object &lt;code&gt;o&lt;/code&gt; of type &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; that contains a value, &lt;code&gt;std::hash&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;()(o)&lt;/code&gt; evaluates to the same value as &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;()(*o)&lt;/code&gt;. For an optional that does not contain a value, the hash is unspecified.</source>
          <target state="translated">启用后，对于包含值的 &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; 类型的对象 &lt;code&gt;o&lt;/code&gt; ， &lt;code&gt;std::hash&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;()(o)&lt;/code&gt; 计算结果与 &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;()(*o)&lt;/code&gt; 。对于不包含值的可选字段，未指定哈希值。</target>
        </trans-unit>
        <trans-unit id="903d975e1994ac3a37b90733c8025f08ecf31a3c" translate="yes" xml:space="preserve">
          <source>When enabled,(since C++17) for a given &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt; p&lt;/code&gt;, this specialization ensures that &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;&amp;gt;()(p) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;typename &lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;::pointer&amp;gt;()(p.get())&lt;/code&gt;.</source>
          <target state="translated">启用后（自C ++ 17起）对于给定的 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt; p&lt;/code&gt; ，此特化可确保 &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;&amp;gt;()(p) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;typename &lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;::pointer&amp;gt;()(p.get())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19ae5f22223dec57ebaf47feb7ebf7c7e201fce6" translate="yes" xml:space="preserve">
          <source>When entering a catch clause, if its formal parameter is a base class of the exception type, it is &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; from the base class subobject of the exception object. Otherwise, it is copy-initialized from the exception object (this copy is subject to &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="translated">当输入catch子句时，如果其形式参数是异常类型的基类，则将其从异常对象的基类子对象进行&lt;a href=&quot;copy_initialization&quot;&gt;复制初始化&lt;/a&gt;。否则，它会从异常对象进行复制初始化（此复制受制于&lt;a href=&quot;copy_elision&quot;&gt;复制省略&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="16fd800e4f4545dc8c54147c76bdffd06523fe14" translate="yes" xml:space="preserve">
          <source>When erasing at either end of the deque, references to non-erased elements are not invalidated by &lt;code&gt;&lt;a href=&quot;deque/erase&quot;&gt;erase&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque/pop_front&quot;&gt;pop_front&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque/pop_back&quot;&gt;pop_back&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当在双端队列的任一端擦除，以未经擦除元素的引用不被无效 &lt;code&gt;&lt;a href=&quot;deque/erase&quot;&gt;erase&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;deque/pop_front&quot;&gt;pop_front&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;deque/pop_back&quot;&gt;pop_back&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3e154c534821f10918bbd1a0adb594ebb17181d9" translate="yes" xml:space="preserve">
          <source>When every character of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">当需要刷新输出的每个字符时，可以使用 &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; 操纵器。</target>
        </trans-unit>
        <trans-unit id="3a9eae4e1a206e51541973ab38f172716a809f23" translate="yes" xml:space="preserve">
          <source>When every output operation needs to be flushed, the &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">当需要清除每个输出操作时，可以使用 &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; 机械手。</target>
        </trans-unit>
        <trans-unit id="de9fb1f75fc610360e59b80abf945bf3f980c7f7" translate="yes" xml:space="preserve">
          <source>When formatting a floating point value as hexfloat (i.e., when &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;), the stream's precision is not used; instead, the number is always printed with enough precision to exactly represent the value.</source>
          <target state="translated">将浮点值格式化为十六进制格式时（即，当 &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt; ）时，不使用流的精度；而是始终以足够的精度打印数字以准确表示该值。</target>
        </trans-unit>
        <trans-unit id="a40d58e1eae50e8055be19035d8b5887a01317a2" translate="yes" xml:space="preserve">
          <source>When given reference types, &lt;code&gt;common_reference&lt;/code&gt; attempts to find a reference type to which the supplied reference types can all be bound, but may return a non-reference type if it cannot find such a reference type.</source>
          <target state="translated">给定引用类型时， &lt;code&gt;common_reference&lt;/code&gt; 会尝试查找可以将所有提供的引用类型都绑定到的引用类型，但是如果找不到该引用类型，则可能会返回非引用类型。</target>
        </trans-unit>
        <trans-unit id="dd4bc57db1751ca1bef7fa50506950271e3c5d18" translate="yes" xml:space="preserve">
          <source>When indexing C++ containers, such as &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, etc, the appropriate type is the member typedef &lt;code&gt;size_type&lt;/code&gt; provided by such containers. It is usually defined as a synonym for &lt;code&gt;std::size_t&lt;/code&gt;.</source>
          <target state="translated">索引C ++容器（例如 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 等）时，适当的类型是此类容器提供的成员typedef &lt;code&gt;size_type&lt;/code&gt; 。通常将其定义为 &lt;code&gt;std::size_t&lt;/code&gt; 的同义词。</target>
        </trans-unit>
        <trans-unit id="9ac68fbcc8bc1efc6049dde60f0e30093d3a91f7" translate="yes" xml:space="preserve">
          <source>When initialization of an object of non-class type cv1 &lt;code&gt;T&lt;/code&gt; requires a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; to convert from an initializer expression of class type cv &lt;code&gt;S&lt;/code&gt;, the following functions are candidates:</source>
          <target state="translated">当非类类型cv1 &lt;code&gt;T&lt;/code&gt; 的对象的初始化需要&lt;a href=&quot;cast_operator&quot;&gt;用户定义的转换函数&lt;/a&gt;从类类型cv &lt;code&gt;S&lt;/code&gt; 的初始化表达式进行转换时，可以使用以下函数：</target>
        </trans-unit>
        <trans-unit id="f2f9ef8bbb329e61c10d08ae998e3ab7e71030d3" translate="yes" xml:space="preserve">
          <source>When initializing from a single argument of a type that is a specialization of the class template at issue, copying deduction is generally preferred over wrapping by default:</source>
          <target state="translated">当从一个类型的单一参数初始化时,如果该类型是问题类模板的特殊化,一般默认情况下,复制演绎比包装更受欢迎。</target>
        </trans-unit>
        <trans-unit id="d46960739a911c065792d3eb6a771bd67fb54134" translate="yes" xml:space="preserve">
          <source>When inserting a range, the range version of &lt;code&gt;&lt;a href=&quot;insert&quot;&gt;insert()&lt;/a&gt;&lt;/code&gt; is generally preferable as it preserves the correct capacity growth behavior, unlike &lt;code&gt;reserve()&lt;/code&gt; followed by a series of &lt;code&gt;&lt;a href=&quot;push_back&quot;&gt;push_back()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">插入范围时，通常最好使用 &lt;code&gt;&lt;a href=&quot;insert&quot;&gt;insert()&lt;/a&gt;&lt;/code&gt; 的范围版本，因为它保留了正确的容量增长行为，这与 &lt;code&gt;reserve()&lt;/code&gt; 后跟一系列 &lt;code&gt;&lt;a href=&quot;push_back&quot;&gt;push_back()&lt;/a&gt;&lt;/code&gt; 不同。</target>
        </trans-unit>
        <trans-unit id="906401050b55fc9b72b5d2421e9144fbb190452a" translate="yes" xml:space="preserve">
          <source>When inserting at either end of the deque, references are not invalidated by &lt;code&gt;&lt;a href=&quot;deque/insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque/emplace&quot;&gt;emplace&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在双端队列的任一端插入时， &lt;code&gt;&lt;a href=&quot;deque/insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;deque/emplace&quot;&gt;emplace&lt;/a&gt;&lt;/code&gt; 不会使引用无效。</target>
        </trans-unit>
        <trans-unit id="d58dc4a9c1d64bc2047ee755578c50f3b966be84" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the floating-point types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;std::atomic&lt;/code&gt; provides additional atomic operations appropriate to floating-point types such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当使用浮点类型 &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;long double&lt;/code&gt; 之一实例化时， &lt;code&gt;std::atomic&lt;/code&gt; 提供适合于浮点类型的附加原子操作，例如&lt;a href=&quot;atomic/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="552f6dfa495a4acb2aa66f36a0ba5bf21b95fae5" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the floating-point types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;std::atomic_ref&lt;/code&gt; provides additional atomic operations appropriate to floating-point types such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">当使用浮点类型 &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; 和 &lt;code&gt;long double&lt;/code&gt; 之一实例化时， &lt;code&gt;std::atomic_ref&lt;/code&gt; 提供适合于浮点类型的附加原子操作，例如&lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5bac602845c57306b8db9e963ef0dfc1cad72696" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the following integral types, &lt;code&gt;std::atomic&lt;/code&gt; provides additional atomic operations appropriate to integral types such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_and&quot;&gt;&lt;code&gt;fetch_and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_or&quot;&gt;&lt;code&gt;fetch_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_xor&quot;&gt;&lt;code&gt;fetch_xor&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">当使用以下整数类型之一实例化时， &lt;code&gt;std::atomic&lt;/code&gt; 提供适用于整数类型的附加原子操作，例如&lt;a href=&quot;atomic/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomic/fetch_and&quot;&gt; &lt;code&gt;fetch_and&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomic/fetch_or&quot;&gt; &lt;code&gt;fetch_or&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomic/fetch_xor&quot;&gt; &lt;code&gt;fetch_xor&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="baa8ebba32798819cb5a6086f1e8129674336cd6" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the following integral types, &lt;code&gt;std::atomic_ref&lt;/code&gt; provides additional atomic operations appropriate to integral types such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_and&quot;&gt;&lt;code&gt;fetch_and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_or&quot;&gt;&lt;code&gt;fetch_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_xor&quot;&gt;&lt;code&gt;fetch_xor&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">当使用以下整数类型之一实例化时， &lt;code&gt;std::atomic_ref&lt;/code&gt; 提供适用于整数类型的附加原子操作，例如&lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomic_ref/fetch_and&quot;&gt; &lt;code&gt;fetch_and&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomic_ref/fetch_or&quot;&gt; &lt;code&gt;fetch_or&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;atomic_ref/fetch_xor&quot;&gt; &lt;code&gt;fetch_xor&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="503d40b06333e935efd323a580b4acbb78349e5a" translate="yes" xml:space="preserve">
          <source>When it is needed to interpret the bytes of an object as a value of a different type, &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt;or &lt;a href=&quot;../numeric/bit_cast&quot;&gt;&lt;code&gt;std::bit_cast&lt;/code&gt;&lt;/a&gt;(since C++20)can be used:</source>
          <target state="translated">当需要将对象的字节解释为不同类型的值时，可以使用 &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; 或&lt;a href=&quot;../numeric/bit_cast&quot;&gt; &lt;code&gt;std::bit_cast&lt;/code&gt; &lt;/a&gt;（从C ++ 20开始）：</target>
        </trans-unit>
        <trans-unit id="5281af908beb7c5eb475c7aeb21afb60dcc9c864" translate="yes" xml:space="preserve">
          <source>When language specifications nest, the innermost specification is the one that is in effect.</source>
          <target state="translated">当语言规范嵌套时,最里面的规范才是有效的。</target>
        </trans-unit>
        <trans-unit id="016122add2c9877f6072526697f450c52a1f6394" translate="yes" xml:space="preserve">
          <source>When making an explicit call to the conversion function, the type-id is greedy: it is the longest possible sequence of tokens that is a valid type id (including attributes, if any):</source>
          <target state="translated">当对转换函数进行显式调用时,type-id是贪婪的:它是有效的类型id(包括属性,如果有的话)的可能最长的tokens序列。</target>
        </trans-unit>
        <trans-unit id="c7b5147658508bc213c62aa761a47793df025adb" translate="yes" xml:space="preserve">
          <source>When moving overlapping ranges, &lt;code&gt;std::move&lt;/code&gt; is appropriate when moving to the left (beginning of the destination range is outside the source range) while &lt;code&gt;std::move_backward&lt;/code&gt; is appropriate when moving to the right (end of the destination range is outside the source range).</source>
          <target state="translated">当移动重叠范围时，向左移动时 &lt;code&gt;std::move&lt;/code&gt; 是适当的（目标范围的起点在源范围之外），而向右移动时， &lt;code&gt;std::move_backward&lt;/code&gt; 是合适的（目标范围的末端在源范围之外）范围）。</target>
        </trans-unit>
        <trans-unit id="bcc9e1f7b6bbebc1441b5e338721e2a64a3a6fc2" translate="yes" xml:space="preserve">
          <source>When no more matches are found, copies the remaining non-matched characters to &lt;code&gt;out&lt;/code&gt; as if by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(last_m.suffix().first, last_m.suffix().second, out)&lt;/code&gt; where &lt;code&gt;last_m&lt;/code&gt; is a copy of the last match found.</source>
          <target state="translated">如果找不到更多匹配项，则将剩余的不匹配字符复制到 &lt;code&gt;out&lt;/code&gt; 中，就像通过 &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(last_m.suffix().first, last_m.suffix().second, out)&lt;/code&gt; ，其中 &lt;code&gt;last_m&lt;/code&gt; 是找到的最后一场比赛。</target>
        </trans-unit>
        <trans-unit id="a989818254cf8030ca8ff78fd514d37b03472368" translate="yes" xml:space="preserve">
          <source>When one of them is found by &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;normal unqualified lookup&lt;/a&gt; for the name to the left of the function-call operator, it inhibits &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt;.</source>
          <target state="translated">当通过函数调用运算符左侧的名称的&lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;正常无限定查找&lt;/a&gt;找到其中一个时，它将禁止&lt;a href=&quot;../../language/adl&quot;&gt;依赖于参数的查找&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1514e0d97ec7c21ec7cdc4fc2229658217c2a1d3" translate="yes" xml:space="preserve">
          <source>When one or more lock-free atomic functions run concurrently, at least one of them is guaranteed to complete (all standard library lock-free operations are &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&quot;&gt;lock-free&lt;/a&gt; -- it is the job of the implementation to ensure they cannot be live-locked indefinitely by other threads, such as by continuously stealing the cache line).</source>
          <target state="translated">当一个或多个无锁原子功能同时运行时，保证至少有一个原子功能完成（所有标准库无锁操作都是无&lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&quot;&gt;锁&lt;/a&gt;的，实现的工作是确保它们不能被实时锁定。无限期地由其他线程（例如通过连续窃取高速缓存行）来实现。</target>
        </trans-unit>
        <trans-unit id="c525266500bfb2286ded86306e069bde3c22c32c" translate="yes" xml:space="preserve">
          <source>When one statement is expected, but multiple statements need to be executed in sequence (for example, in an &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement or a loop), a compound statement may be used:</source>
          <target state="translated">如果期望一个语句，但是需要按顺序执行多个语句（例如，在&lt;a href=&quot;if&quot;&gt;if&lt;/a&gt;语句或循环中），则可以使用复合语句：</target>
        </trans-unit>
        <trans-unit id="99ceddfac8288288bcf4a468dfcdde568e2b94f6" translate="yes" xml:space="preserve">
          <source>When only one thread that is not blocked in a standard library function executes an &lt;a href=&quot;../atomic&quot;&gt;atomic function&lt;/a&gt; that is lock-free, that execution is guaranteed to complete (all standard library lock-free operations are &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom&quot;&gt;obstruction-free&lt;/a&gt;).</source>
          <target state="translated">当只有一个未在标准库函数中阻塞的线程执行无锁的&lt;a href=&quot;../atomic&quot;&gt;原子函数时&lt;/a&gt;，可以保证该执行完成（所有标准库无锁操作都是&lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom&quot;&gt;无障碍的&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="be17634a4507a825d9841a9ec6ecaee80238b41e" translate="yes" xml:space="preserve">
          <source>When parsing an expression, an operator which is listed on some row of the table above with a precedence will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it with a lower precedence. For example, the expressions &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a &amp;amp; b&lt;/code&gt; and &lt;code&gt;*p++&lt;/code&gt; are parsed as &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) &amp;amp; b&lt;/code&gt; and &lt;code&gt;*(p++)&lt;/code&gt;, and not as &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; (a &amp;amp; b)&lt;/code&gt; or &lt;code&gt;(*p)++&lt;/code&gt;.</source>
          <target state="translated">解析表达式时，在表的上一行具有优先级的运算符将比在其下一行具有较低优先级的运算符更严格地（如用括号括起来）绑定到其参数。例如，表达式 &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a &amp;amp; b&lt;/code&gt; 和 &lt;code&gt;*p++&lt;/code&gt; 被解析为 &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) &amp;amp; b&lt;/code&gt; 和 &lt;code&gt;*(p++)&lt;/code&gt; ，而不是 &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; (a &amp;amp; b)&lt;/code&gt; 或 &lt;code&gt;(*p)++&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8b48f697df0e524fccfbe77ccb0c6aefdae765c" translate="yes" xml:space="preserve">
          <source>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing &lt;code&gt;&quot;100er&quot;&lt;/code&gt; with the conversion specifier &lt;code&gt;%f&lt;/code&gt;, the sequence &lt;code&gt;&quot;100e&quot;&lt;/code&gt; (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with &lt;code&gt;&quot;r&quot;&lt;/code&gt; remaining. Some existing implementations do not follow this rule and roll back to consume only &lt;code&gt;&quot;100&quot;&lt;/code&gt;, leaving &lt;code&gt;&quot;er&quot;&lt;/code&gt;, e.g. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc bug 1765&lt;/a&gt;.</source>
          <target state="translated">解析不带数字的指数结尾的不完整浮点值时，例如使用转换说明符 &lt;code&gt;%f&lt;/code&gt; 解析 &lt;code&gt;&quot;100er&quot;&lt;/code&gt; 时，将使用序列 &lt;code&gt;&quot;100e&quot;&lt;/code&gt; （可能有效的浮点数的最长前缀） ，导致匹配错误（使用的序列无法转换为浮点数），并且剩余 &lt;code&gt;&quot;r&quot;&lt;/code&gt; 。一些现有的实现不遵循此规则，而是回滚以仅消耗 &lt;code&gt;&quot;100&quot;&lt;/code&gt; ，而保留 &lt;code&gt;&quot;er&quot;&lt;/code&gt; ，例如&lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc错误1765&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f862fd02527b95bbe0a34ac38eb69a8e6f210d9f" translate="yes" xml:space="preserve">
          <source>When performing N:M conversions, this function may return &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::partial&lt;/a&gt;&lt;/code&gt; after consuming all source characters (&lt;code&gt;from_next == from_end&lt;/code&gt;). This means that another internal character is needed to complete the conversion (e.g. when converting UTF-16 to UTF-8, if the last character in the source buffer is a high surrogate).</source>
          <target state="translated">执行N：M转换时，此函数在消耗所有源字符（ &lt;code&gt;from_next == from_end&lt;/code&gt; ）后可能返回 &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::partial&lt;/a&gt;&lt;/code&gt; 。这意味着需要另一个内部字符来完成转换（例如，如果源缓冲区中的最后一个字符是高替代字符，则将UTF-16转换为UTF-8时）。</target>
        </trans-unit>
        <trans-unit id="73238300a6abe634b092cd3c78bfa124e710c17c" translate="yes" xml:space="preserve">
          <source>When performing matches, all marked sub-expressions &lt;code&gt;(expr)&lt;/code&gt; are treated as non-marking sub-expressions &lt;code&gt;(?:expr)&lt;/code&gt;. No matches are stored in the supplied &lt;code&gt;&lt;a href=&quot;../regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; structure and &lt;code&gt;mark_count()&lt;/code&gt; is zero</source>
          <target state="translated">执行匹配时，所有标记的子表达式 &lt;code&gt;(expr)&lt;/code&gt; 都被视为非标记的子表达式 &lt;code&gt;(?:expr)&lt;/code&gt; 。没有匹配项存储在提供的 &lt;code&gt;&lt;a href=&quot;../regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; 结构中，并且 &lt;code&gt;mark_count()&lt;/code&gt; 为零</target>
        </trans-unit>
        <trans-unit id="c20cd38801efcb855e60aac217866665e1148ddd" translate="yes" xml:space="preserve">
          <source>When performing matches, all marked sub-expressions &lt;code&gt;(expr)&lt;/code&gt; are treated as non-marking sub-expressions &lt;code&gt;(?:expr)&lt;/code&gt;. No matches are stored in the supplied &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; structure and &lt;code&gt;mark_count()&lt;/code&gt; is zero</source>
          <target state="translated">执行匹配时，所有标记的子表达式 &lt;code&gt;(expr)&lt;/code&gt; 都被视为非标记的子表达式 &lt;code&gt;(?:expr)&lt;/code&gt; 。没有匹配项存储在提供的 &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; 结构中，并且 &lt;code&gt;mark_count()&lt;/code&gt; 为零</target>
        </trans-unit>
        <trans-unit id="f4f7d6dbe3d540b5d3f8d4a7ca45e962b95c0edb" translate="yes" xml:space="preserve">
          <source>When placeholder types (either &lt;code&gt;auto&lt;/code&gt; or &lt;a href=&quot;../concepts&quot;&gt;Concept auto&lt;/a&gt;) appear in the parameter list of a function declaration or of a function template declaration, the declaration declares a function template, and one invented template parameter for each placeholder is appended to the template parameter list.</source>
          <target state="translated">当占位符类型（ &lt;code&gt;auto&lt;/code&gt; 或&lt;a href=&quot;../concepts&quot;&gt;Concept auto&lt;/a&gt;）出现在函数声明或函数模板声明的参数列表中时，该声明声明一个函数模板，并且每个占位符的一个发明的模板参数将附加到模板参数列表中。</target>
        </trans-unit>
        <trans-unit id="641c7fd3577d0edc6efac99f2f76379fc6931592" translate="yes" xml:space="preserve">
          <source>When reading characters, &lt;code&gt;std::istream_iterator&lt;/code&gt; skips whitespace by default (unless disabled with &lt;code&gt;&lt;a href=&quot;../io/manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; or equivalent), while &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; does not. In addition, &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.</source>
          <target state="translated">读取字符时，默认情况下 &lt;code&gt;std::istream_iterator&lt;/code&gt; 跳过空格（除非已使用 &lt;code&gt;&lt;a href=&quot;../io/manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; 或等效功能禁用），而 &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; 则不会。另外， &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; 效率更高，因为它避免了每个字符一次构造和销毁哨兵对象的开销。</target>
        </trans-unit>
        <trans-unit id="1ab1d2134a41c9628e2098e71305ab92b1cd2216" translate="yes" xml:space="preserve">
          <source>When rethrowing exceptions, the second form must be used to avoid object slicing in the (typical) case where exception objects use inheritance:</source>
          <target state="translated">当重抛异常时,必须使用第二种形式,以避免在异常对象使用继承的(典型)情况下出现对象分片。</target>
        </trans-unit>
        <trans-unit id="f9fb914caea510cf6dfabbb484a007b28ab4e8a3" translate="yes" xml:space="preserve">
          <source>When signal handler is set to a function and a signal occurs, it is implementation defined whether &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.</source>
          <target state="translated">当信号处理程序设置为函数并发生信号时，将定义实现是否在信号处理程序启动之前立即执行 &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; 。同样，该实现可以防止在信号处理程序运行时发生某些实现定义的信号集。</target>
        </trans-unit>
        <trans-unit id="a82c7324d6d1f526ac5299ac166aafff69e4a350" translate="yes" xml:space="preserve">
          <source>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. &lt;code&gt;-ftrapv&lt;/code&gt; in GCC and Clang), or may be completely &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;optimized out by the compiler&lt;/a&gt;.</source>
          <target state="translated">当有符号整数算术运算溢出（结果不适合结果类型）时，行为是不确定的：它可能会根据表示规则（通常为2的补码）进行环绕，可能会陷于某些平台或由于编译器选项（例如，GCC和Clang中的 &lt;code&gt;-ftrapv&lt;/code&gt; ），或者可以&lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;由编译器&lt;/a&gt;完全优化。</target>
        </trans-unit>
        <trans-unit id="9deeffc3f0edffbc9e7bf40fc167f8af90637021" translate="yes" xml:space="preserve">
          <source>When some &lt;a href=&quot;../algorithm/ranges&quot;&gt;constrain algorithms&lt;/a&gt; that usually return an iterator or a subrange of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; take a particular rvalue &lt;code&gt;Range&lt;/code&gt; argument that does not models exposition-only concept &lt;a href=&quot;range&quot;&gt;&lt;code&gt;__ForwardingRange&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;dangling&lt;/code&gt; will be returned instead to avoid returning potentially dangling results.</source>
          <target state="translated">当一些&lt;a href=&quot;../algorithm/ranges&quot;&gt;约束算法&lt;/a&gt;通常返回一个迭代或的子范围&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;采取特定的右值 &lt;code&gt;Range&lt;/code&gt; 的说法是不模型博览会独有的概念&lt;a href=&quot;range&quot;&gt; &lt;code&gt;__ForwardingRange&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;dangling&lt;/code&gt; 将代替返回避免返回潜在的晃来晃去的结果。</target>
        </trans-unit>
        <trans-unit id="8b1e13bc5e72c1d99187d326eff8cc95c6a2ce2a" translate="yes" xml:space="preserve">
          <source>When specializing a function template, its template arguments can be omitted if &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; can provide them from the function arguments:</source>
          <target state="translated">专门化功能模板时，如果&lt;a href=&quot;template_argument_deduction&quot;&gt;模板参数推导&lt;/a&gt;可以从函数参数中提供它们，则可以省略其模板参数：</target>
        </trans-unit>
        <trans-unit id="ca2cbab4c43c7973149386ddec137d524c3e9fe8" translate="yes" xml:space="preserve">
          <source>When string literal concatenation takes place in &lt;a href=&quot;translation_phases&quot;&gt;translation phase 6&lt;/a&gt;, user-defined string literals are concatenated as well, and their ud-suffixes are ignored for the purpose of concatenation, except that only one suffix may appear on all concatenated literals:</source>
          <target state="translated">在&lt;a href=&quot;translation_phases&quot;&gt;转换阶段6中进行&lt;/a&gt;字符串文字串联时，也会同时连接用户定义的字符串文字，并且出于连接的目的，将忽略其ud后缀，但在所有串联文字上只能出现一个后缀：</target>
        </trans-unit>
        <trans-unit id="1799979c98bbbebaef89ed6f1828299ab2b6a5e5" translate="yes" xml:space="preserve">
          <source>When such member function is declared in class X, it performs conversion from X to conversion-type-id:</source>
          <target state="translated">当在类X中声明这样的成员函数时,它执行从X到conversion-type-id的转换。</target>
        </trans-unit>
        <trans-unit id="1b9fe1265be0c139fe6cde0ba421b142a03ada23" translate="yes" xml:space="preserve">
          <source>When template arguments are provided, or, for &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;function&lt;/a&gt; and &lt;a href=&quot;deduction_guide&quot;&gt;class&lt;/a&gt;(since C++17) templates only, deduced, they are substituted for the template parameters to obtain a</source>
          <target state="translated">如果提供了模板参数，或者推导了仅针对&lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;函数&lt;/a&gt;和&lt;a href=&quot;deduction_guide&quot;&gt;类&lt;/a&gt;（自C ++ 17起）的模板，则将其替换为模板参数以获得</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa5703929047ae870cd9bedc4f9eebb911b80493" translate="yes" xml:space="preserve">
          <source>When the argument is a class template, only the primary template is considered when matching the parameter. The partial specializations, if any, are only considered when a specialization based on this template template parameter happens to be instantiated.</source>
          <target state="translated">当参数是一个类模板时,在匹配参数时只考虑主模板。部分特化(如果有的话),只有当基于该模板参数的特化刚好被实例化时才会被考虑。</target>
        </trans-unit>
        <trans-unit id="657c97ad1dccca00440cdc8eb7bd687219c46fbe" translate="yes" xml:space="preserve">
          <source>When the asynchronous operation is ready to send a result to the creator, it can do so by modifying</source>
          <target state="translated">当异步操作准备好向创建者发送结果时,它可以通过修改</target>
        </trans-unit>
        <trans-unit id="b3e1fc309740231aa065058d4a26e16a2e51f547" translate="yes" xml:space="preserve">
          <source>When the compiler encounters a user-defined literal with ud-suffix&lt;code&gt;X&lt;/code&gt;, it performs &lt;a href=&quot;lookup#Unqualified_name_lookup&quot;&gt;unqualified name lookup&lt;/a&gt;, looking for a function with the name &lt;code&gt;operator &quot;&quot; X&lt;/code&gt;. If the lookup does not find a declaration, the program is ill-formed. Otherwise,</source>
          <target state="translated">当编译器遇到带有ud-suffix &lt;code&gt;X&lt;/code&gt; 的用户定义文字时，它将执行&lt;a href=&quot;lookup#Unqualified_name_lookup&quot;&gt;非限定名称查找&lt;/a&gt;，以名称 &lt;code&gt;operator &quot;&quot; X&lt;/code&gt; 查找函数。如果查找未找到声明，则程序格式错误。除此以外，</target>
        </trans-unit>
        <trans-unit id="a6e3ba42f8de770e69687876d93e30231038db0e" translate="yes" xml:space="preserve">
          <source>When the compiler encounters an unknown name in a program, it associates it with the declaration that introduced the name by means of &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, except for the &lt;a href=&quot;dependent_name&quot;&gt;dependent names&lt;/a&gt; in template declarations and definitions (for those names, the compiler determines whether they name a type, a template, or some other entity, which may require &lt;a href=&quot;dependent_name&quot;&gt;explicit disambiguation&lt;/a&gt;).</source>
          <target state="translated">当编译器在程序中遇到未知名称时，它将其与通过&lt;a href=&quot;lookup&quot;&gt;名称查找&lt;/a&gt;引入名称的声明相关联，但模板声明和定义中的&lt;a href=&quot;dependent_name&quot;&gt;从属名称&lt;/a&gt;除外（对于这些名称，编译器将确定它们是否命名类型，模板或其他实体（可能需要&lt;a href=&quot;dependent_name&quot;&gt;明确消除歧义&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="3ffc67b2c989f365607047bd77316e5ecdadcda9" translate="yes" xml:space="preserve">
          <source>When the condition variable is notified, a timeout expires, or a &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;spurious wakeup&lt;/a&gt; occurs, the thread is awakened, and the mutex is atomically reacquired. The thread should then check the condition and resume waiting if the wake up was spurious.</source>
          <target state="translated">通知条件变量时，超时到期或发生&lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;虚假唤醒&lt;/a&gt;，将唤醒线程，并自动重新获取互斥量。然后，线程应检查条件，如果唤醒是虚假的，则应继续等待。</target>
        </trans-unit>
        <trans-unit id="16dd5023449c37e3ee571367f3544e6dbf21123f" translate="yes" xml:space="preserve">
          <source>When the coroutine state is destroyed either because it terminated via co_return or uncaught exception, or because it was destroyed via its handle, it does the following:</source>
          <target state="translated">当coroutine状态因为通过co_return或uncaught异常而终止,或者因为通过其句柄而被销毁时,它将执行以下操作。</target>
        </trans-unit>
        <trans-unit id="d296094acb938c3d5a36e0feef5bea491289a47a" translate="yes" xml:space="preserve">
          <source>When the default allocator is used, this results in the key being copy constructed from &lt;code&gt;key&lt;/code&gt; and the mapped value being &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">当使用默认分配器时，这将导致从 &lt;code&gt;key&lt;/code&gt; 复制构造key，并且对映射的值进行&lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d9fddcbdad59ebcc2389e29ab9d251d255ff093b" translate="yes" xml:space="preserve">
          <source>When the default allocator is used, this results in the key being move constructed from &lt;code&gt;key&lt;/code&gt; and the mapped value being &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">当使用默认分配器时，这将导致从 &lt;code&gt;key&lt;/code&gt; 构造键，并且将映射的值&lt;a href=&quot;../../language/value_initialization&quot;&gt;初始化&lt;/a&gt;为value。</target>
        </trans-unit>
        <trans-unit id="31f633e1dfad19457b495484c1fbe0072bbb264f" translate="yes" xml:space="preserve">
          <source>When the default semantics are not suitable, such as when the members must be compared out of order, or must use a comparison that's different from their natural comparison, then the programmer can write &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; and let the compiler generate the appropriate relational operators. The kind of relational operators generated depends on the return type of the user-defined &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">当默认语义不合适时，例如必须对成员进行无序比较，或者必须使用与自然比较不同的比较，则程序员可以编写 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 并让编译器生成适当的关系运算符。生成的关系运算符的类型取决于用户定义的 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 的返回类型。</target>
        </trans-unit>
        <trans-unit id="5f0cf9abe0b614f53329302ad0d6b53be9c5214c" translate="yes" xml:space="preserve">
          <source>When the element type of an array is another array, it is said that the array is multidimensional:</source>
          <target state="translated">当一个数组的元素类型是另一个数组时,就说这个数组是多维的。</target>
        </trans-unit>
        <trans-unit id="8371d69254feffac85782c93e2437f4715cd1cb6" translate="yes" xml:space="preserve">
          <source>When the initializer is a prvalue, the move constructor call is often optimized out(until C++17)never made(since C++17), see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">当初始值设定项是prvalue时，通常会优化move构造函数调用（直到C ++ 17）再也不进行优化（从C ++ 17开始），请参见&lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10770c6e57727da2d2faacfcf5bbaf211dbc1a9b" translate="yes" xml:space="preserve">
          <source>When the left operand has reference type, the assignment operator modifies the referred-to object.</source>
          <target state="translated">当左操作数具有引用类型时,赋值操作符会修改引用到的对象。</target>
        </trans-unit>
        <trans-unit id="0d0dbe17faf8b2da57c150cba1c216b9daf8702b" translate="yes" xml:space="preserve">
          <source>When the member type &lt;code&gt;pointer&lt;/code&gt; is not a raw pointer type, it is commonly referred to as a &quot;fancy pointer&quot;. Such pointers were introduced to support segmented memory architectures and are used today to access objects allocated in address spaces that differ from the homogeneous virtual address space that is accessed by raw pointers. An example of a fancy pointer is the mapping address-independent pointer &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost::interprocess::offset_ptr&lt;/a&gt;, which makes it possible to allocate node-based data structures such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; in shared memory and memory mapped files mapped in different addresses in every process. Fancy pointers can be used independently of the allocator that provided them, through the class template &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当成员类型 &lt;code&gt;pointer&lt;/code&gt; 不是原始指针类型时，通常称为&amp;ldquo;花式指针&amp;rdquo;。引入了此类指针来支持分段存储器体系结构，如今已用于访问分配在地址空间中的对象，这些地址空间与原始指针访问的同类虚拟地址空间不同。花式指针的一个示例是独立于映射地址的指针&lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost :: interprocess :: offset_ptr&lt;/a&gt;，这使得可以在共享内存中分配基于节点的数据结构（例如 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; ，并在不同地址中映射映射到内存的文件每个过程。通过类模板 &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; ，花式指针可以独立于提供它们的分配器使用。</target>
        </trans-unit>
        <trans-unit id="e345263d3c16be0359604e2c7e37e80d322c6999" translate="yes" xml:space="preserve">
          <source>When the name of a non-type template parameter is used in an expression within the body of the class template, it is an unmodifiable &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; unless its type was an lvalue reference type, or unless its type is a class type(since C++20).</source>
          <target state="translated">当在类模板主体内的表达式中使用非类型模板参数的名称时，除非它的类型是左值引用类型，或者除非它的类型是类类型，否则它是不可修改的&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;（因为C ++ 20）。</target>
        </trans-unit>
        <trans-unit id="0dd4c2cd3956549ff3cdd1f8a7caf6b32e2cea01" translate="yes" xml:space="preserve">
          <source>When the noexcept-specification of a function template specialization is</source>
          <target state="translated">当函数模板特化的noexcept-specification是</target>
        </trans-unit>
        <trans-unit id="cc159284033553cbafc104d522a5cf1ae76e1549" translate="yes" xml:space="preserve">
          <source>When the number of variants is zero or one, the invocation of the callable object is implemented in constant time, i.e. it does not depend on &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">当变体的数量为零或一时，可调用对象的调用在恒定时间内实现，即，它不依赖于 &lt;code&gt;sizeof...(Types)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8b02aaeadad3d163b0d5be165966951d5f6a133" translate="yes" xml:space="preserve">
          <source>When the parameter-list is not empty, an optional comma may precede a &lt;code&gt;...&lt;/code&gt; signifying a variadic function. This provides compatibility with C (which added a requirement for a comma when it adopted function prototypes from C++).</source>
          <target state="translated">当参数列表不为空时，可选逗号可以在 &lt;code&gt;...&lt;/code&gt; 之前，表示可变函数。这提供了与C的兼容性（当采用C ++的函数原型时，这增加了对逗号的要求）。</target>
        </trans-unit>
        <trans-unit id="eadbea007ec076285100c5cbd07b8a2dc8928700" translate="yes" xml:space="preserve">
          <source>When the parser encounters the character sequence &lt;code&gt;&amp;lt;::&lt;/code&gt; and the subsequent character is neither &lt;code&gt;:&lt;/code&gt; nor &lt;code&gt;&amp;gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; is treated as a preprocessing token by itself and not as the first character of the alternative token &lt;code&gt;&amp;lt;:&lt;/code&gt;. Thus &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;::&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; won't be wrongly treated as &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;[:&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">当解析器遇到字符序列 &lt;code&gt;&amp;lt;::&lt;/code&gt; 并且后续字符既不是 &lt;code&gt;:&lt;/code&gt; 也不是 &lt;code&gt;&amp;gt;&lt;/code&gt; 时， &lt;code&gt;&amp;lt;&lt;/code&gt; 本身被视为预处理令牌，而不是替代令牌 &lt;code&gt;&amp;lt;:&lt;/code&gt; 的第一个字符。因此 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;::&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; 不会被错误地视为 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;[:&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cc2032d32ca7885f140b25a96dcbee6c5397ce4" translate="yes" xml:space="preserve">
          <source>When the postfix increment and decrement appear in an expression, the corresponding user-defined function (&lt;code&gt;operator++&lt;/code&gt; or &lt;code&gt;operator--&lt;/code&gt;) is called with an integer argument &lt;code&gt;0&lt;/code&gt;. Typically, it is implemented as &lt;code&gt;T operator++(int)&lt;/code&gt;, where the argument is ignored. The postfix increment and decrement operator is usually implemented in terms of the prefix version:</source>
          <target state="translated">当后缀递增和递减出现在表达式中时，将使用整数参数 &lt;code&gt;0&lt;/code&gt; 调用相应的用户定义函数（ &lt;code&gt;operator++&lt;/code&gt; 或 &lt;code&gt;operator--&lt;/code&gt; ）。通常，将其实现为 &lt;code&gt;T operator++(int)&lt;/code&gt; ，其中忽略该参数。后缀递增和递减运算符通常根据前缀版本实现：</target>
        </trans-unit>
        <trans-unit id="fd043f49a212d5450703bb9a052e4fa639f20396" translate="yes" xml:space="preserve">
          <source>When the regex library needs to match two characters &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; and the flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it executes &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate(c1) == regex_traits&amp;lt;&amp;gt;::translate(c2)&lt;/code&gt;.</source>
          <target state="translated">当正则表达式库需要匹配两个字符 &lt;code&gt;c1&lt;/code&gt; 和 &lt;code&gt;c2&lt;/code&gt; 并且标志 &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，它将执行 &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate(c1) == regex_traits&amp;lt;&amp;gt;::translate(c2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a73f957522574e9d880fc3def8f3dd16383a3e89" translate="yes" xml:space="preserve">
          <source>When the regex library needs to match two characters &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; and the flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it executes &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate_nocase(c1) == regex_traits&amp;lt;&amp;gt;::translate_nocase(c2)&lt;/code&gt;.</source>
          <target state="translated">当正则表达式库需要匹配两个字符 &lt;code&gt;c1&lt;/code&gt; 和 &lt;code&gt;c2&lt;/code&gt; 并且标志 &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，它将执行 &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate_nocase(c1) == regex_traits&amp;lt;&amp;gt;::translate_nocase(c2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="59285875d0142d5e8a1eb450e8a3f9927249ea97" translate="yes" xml:space="preserve">
          <source>When the result of specializing an alias template is a dependent &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;, subsequent substitutions apply to that template-id:</source>
          <target state="translated">当专用化别名模板的结果是从属&lt;a href=&quot;templates#template-id&quot;&gt;模板ID时&lt;/a&gt;，随后的替换将应用于该模板ID：</target>
        </trans-unit>
        <trans-unit id="7e5e471d5aa433ec3a110b9d7e72faf3a90a04a9" translate="yes" xml:space="preserve">
          <source>When the same function template specialization matches more than one overloaded function template (this often results from &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;),</source>
          <target state="translated">当相同的功能模板专业化匹配多个重载的功能模板时（这通常是由&lt;a href=&quot;template_argument_deduction&quot;&gt;模板参数推导产生的&lt;/a&gt;），</target>
        </trans-unit>
        <trans-unit id="b2ff5fd15b40403883483bc89510d97f14914365" translate="yes" xml:space="preserve">
          <source>When the target type is</source>
          <target state="translated">当目标类型为</target>
        </trans-unit>
        <trans-unit id="511cb27754af79d62f22a1bf71b871d3d288ebcd" translate="yes" xml:space="preserve">
          <source>When the template-name of a simple-template-id names a constrained non-function template or a constrained template template-parameter, but not a member template that is a member of an unknown specialization, and all template-arguments in the simple-template-id are non-dependent, the associated constraints of the constrained template must be satisfied:</source>
          <target state="translated">当简单模板-id的模板名命名了一个受约束的非函数模板或受约束的模板模板参数,但不是未知专业化的成员模板,且简单模板-id中的所有模板参数都是非依赖性的,则必须满足受约束模板的相关约束。</target>
        </trans-unit>
        <trans-unit id="adb827bd0954ef807560ec125638e405788fa858" translate="yes" xml:space="preserve">
          <source>When the value of the argument corresponding to a non-type template parameter P that is declared with a dependent type is deduced from an expression, the template parameters in the type of P are deduced from the type of the value.</source>
          <target state="translated">当从表达式中推导出声明有依赖类型的非类型模板参数P所对应的参数值时,P的类型中的模板参数就会从该值的类型中推导出。</target>
        </trans-unit>
        <trans-unit id="a1b257f783065293c124a619280ef8e578d72775" translate="yes" xml:space="preserve">
          <source>When this is the case, member functions &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;equal_range&lt;/code&gt; accept arguments of types other than &lt;code&gt;Key&lt;/code&gt; and expect that &lt;code&gt;Hash&lt;/code&gt; is callable with values of those types, and that &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; is a transparent comparison function such as &lt;code&gt;std::equal_to&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，成员函数 &lt;code&gt;find&lt;/code&gt; ， &lt;code&gt;contains&lt;/code&gt; ， &lt;code&gt;count&lt;/code&gt; 和 &lt;code&gt;equal_range&lt;/code&gt; 接受 &lt;code&gt;Key&lt;/code&gt; 以外类型的参数，并期望 &lt;code&gt;Hash&lt;/code&gt; 可使用这些类型的值进行调用，并且 &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; 是透明的比较函数，例如 &lt;code&gt;std::equal_to&amp;lt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="22fbcacb8ea8a01e09177002c1cd6a745c7d8006" translate="yes" xml:space="preserve">
          <source>When three-way comparison (such as &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/basic_string/compare&quot;&gt;std::string::compare&lt;/a&gt;&lt;/code&gt;) is provided, all six relational operators may be expressed through that:</source>
          <target state="translated">提供三向比较（例如 &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../string/basic_string/compare&quot;&gt;std::string::compare&lt;/a&gt;&lt;/code&gt; ）时，可以通过以下方式表示所有六个关系运算符：</target>
        </trans-unit>
        <trans-unit id="1f2f2e919801487fefca6150ecd5b3b80daddef7" translate="yes" xml:space="preserve">
          <source>When three-way comparison is not required (such as when providing a &lt;code&gt;Compare&lt;/code&gt; argument to standard algorithms such as &lt;code&gt;&lt;a href=&quot;../../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt;), &lt;a href=&quot;../locale/operator()&quot;&gt;&lt;code&gt;std::locale::operator()&lt;/code&gt;&lt;/a&gt; may be more appropriate.</source>
          <target state="translated">如果不需要三向比较（例如，向标准算法（例如 &lt;code&gt;&lt;a href=&quot;../../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; ）提供 &lt;code&gt;Compare&lt;/code&gt; 参数），则&lt;a href=&quot;../locale/operator()&quot;&gt; &lt;code&gt;std::locale::operator()&lt;/code&gt; &lt;/a&gt;可能更合适。</target>
        </trans-unit>
        <trans-unit id="3b2aec7feac4af597a17debffe4c87be12d0ecab" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;template_parameters#Template_arguments&quot;&gt;template argument&lt;/a&gt;, &lt;code&gt;class T&lt;/code&gt; is a type template parameter named &lt;code&gt;T&lt;/code&gt;, not an unnamed non-type parameter whose type &lt;code&gt;T&lt;/code&gt; is introduced by elaborated type specifier.</source>
          <target state="translated">当用作&lt;a href=&quot;template_parameters#Template_arguments&quot;&gt;模板参数时&lt;/a&gt;， &lt;code&gt;class T&lt;/code&gt; 是名为 &lt;code&gt;T&lt;/code&gt; 的类型模板参数，而不是其类型 &lt;code&gt;T&lt;/code&gt; 由详细类型说明符引入的未命名非类型参数。</target>
        </trans-unit>
        <trans-unit id="a89f99191dc9016965a45193765f04ce9fd16336" translate="yes" xml:space="preserve">
          <source>When used as a function argument and when &lt;a href=&quot;overload_resolution&quot;&gt;two overloads&lt;/a&gt; of the function are available, one taking rvalue reference parameter and the other taking lvalue reference to const parameter, an rvalue binds to the rvalue reference overload (thus, if both copy and move constructors are available, an rvalue argument invokes the &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt;, and likewise with copy and move assignment operators).</source>
          <target state="translated">当用作函数参数且函数的&lt;a href=&quot;overload_resolution&quot;&gt;两个重载&lt;/a&gt;可用时，一个重载左值引用参数，另一个重载左值引用const参数，则右重绑定到右值引用重载（因此，如果复制和移动构造函数均可用，一个rvalue参数调用&lt;a href=&quot;move_constructor&quot;&gt;move构造函数&lt;/a&gt;，同样使用copy和move赋值运算符）。</target>
        </trans-unit>
        <trans-unit id="f8ea00edd25f46b83546909c33b9f68661ba3e16" translate="yes" xml:space="preserve">
          <source>When used as an argument in a &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; expression, the placeholder objects are stored in the generated function object, and when that function object is invoked with unbound arguments, each placeholder &lt;code&gt;_N&lt;/code&gt; is replaced by the corresponding Nth unbound argument.</source>
          <target state="translated">当在 &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 表达式中用作参数时，占位符对象存储在生成的函数对象中，并且当使用未绑定参数调用该函数对象时，每个占位符 &lt;code&gt;_N&lt;/code&gt; 都将替换为相应的第N个未绑定参数。</target>
        </trans-unit>
        <trans-unit id="4c90e24b8efd2362ba00ffddb7c37e312b7e82c3" translate="yes" xml:space="preserve">
          <source>When used at class scope, variable template declares a static data member template.</source>
          <target state="translated">当在类作用域使用时,变量模板声明一个静态数据成员模板。</target>
        </trans-unit>
        <trans-unit id="d3e7747ab6e5ee83d7abf31291a18569eac0496f" translate="yes" xml:space="preserve">
          <source>When used immediately after whitespace-delimited input, e.g. after &lt;code&gt;int n; &lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt;, &lt;code&gt;getline&lt;/code&gt; consumes the endline character left on the input stream by &lt;a href=&quot;../../io/basic_istream/operator_gtgt&quot;&gt;operator&amp;gt;&amp;gt;&lt;/a&gt;, and returns immediately. A common solution is to ignore all leftover characters on the line of input with &lt;code&gt;cin.ignore(&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max(), '\n');&lt;/code&gt; before switching to line-oriented input.</source>
          <target state="translated">在用空格分隔的输入后立即使用时，例如 &lt;code&gt;int n; &lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt; ， &lt;code&gt;getline&lt;/code&gt; 使用&lt;a href=&quot;../../io/basic_istream/operator_gtgt&quot;&gt;操作符&amp;gt;&amp;gt;&lt;/a&gt;消耗输入流上剩余的结束符，并立即返回。一个常见的解决方案是使用 &lt;code&gt;cin.ignore(&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max(), '\n');&lt;/code&gt; 忽略输入行上的所有剩余字符。在切换到面向行的输入之前。</target>
        </trans-unit>
        <trans-unit id="810ee96ebb349b821e1635ff4d35660a0d38207d" translate="yes" xml:space="preserve">
          <source>When used in a class definition, &lt;code&gt;final&lt;/code&gt; specifies that this class may not appear in the base-specifier-list of another class definition (in other words, cannot be derived from). The program is ill-formed (a compile-time error is generated) otherwise. &lt;code&gt;final&lt;/code&gt; can also be used with a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; definition, in which case it has no effect (other than on the outcome of &lt;code&gt;&lt;a href=&quot;../types/is_final&quot;&gt;std::is_final&lt;/a&gt;&lt;/code&gt;), since unions cannot be derived from).</source>
          <target state="translated">当在类定义中使用时， &lt;code&gt;final&lt;/code&gt; 指定该类不能出现在另一个类定义的base-specifier-list中（换句话说，不能从该类派生）。否则，程序的格式不正确（生成编译时错误）。 &lt;code&gt;final&lt;/code&gt; 也可以与并&lt;a href=&quot;union&quot;&gt;集&lt;/a&gt;定义一起使用，在这种情况下，它不起作用（除了对 &lt;code&gt;&lt;a href=&quot;../types/is_final&quot;&gt;std::is_final&lt;/a&gt;&lt;/code&gt; 的结果影响不大，因为不能从其派生联合）。</target>
        </trans-unit>
        <trans-unit id="9305de135bb255cca457fdbece5abb6dd9a1674a" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/c/preprocessor/conditional.html&quot;&gt;#elif&lt;/a&gt;, all signed integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; and all unsigned integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">当在&lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt;或&lt;a href=&quot;http://en.cppreference.com/w/c/preprocessor/conditional.html&quot;&gt;#elif&lt;/a&gt;的控制表达式中使用时，所有有符号整数常量的行为就像它们的类型为 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 而所有无符号整数常量的行为就像它们的类型为 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b903d2e014bf8406262e3731d09165f67923eb1" translate="yes" xml:space="preserve">
          <source>When used in a virtual function declaration or definition, &lt;code&gt;final&lt;/code&gt; ensures that the function is virtual and specifies that it may not be overridden by derived classes. The program is ill-formed (a compile-time error is generated) otherwise.</source>
          <target state="translated">当在虚函数声明或定义中使用时， &lt;code&gt;final&lt;/code&gt; 确保该函数是虚函数，并指定派生类不能覆盖该函数。否则，程序的格式不正确（生成编译时错误）。</target>
        </trans-unit>
        <trans-unit id="1a6b7e3d85e506288364ecfff9f25bf551cd3185" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt;, parses the character input as a monetary value, as specified by the &lt;code&gt;&lt;a href=&quot;../../locale/money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in &lt;code&gt;in&lt;/code&gt;, and stores the value in &lt;code&gt;mon&lt;/code&gt;.</source>
          <target state="translated">当在表达式中使用 &lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt; ，解析的字符输入作为货币值，由指定 &lt;code&gt;&lt;a href=&quot;../../locale/money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; 刻面的区域设置的当前在充满 &lt;code&gt;in&lt;/code&gt; ，并将其存储在值 &lt;code&gt;mon&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dba580a9fb7386ece9bcb9047821c34efdbd2cc6" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; get_time(tmb, fmt)&lt;/code&gt;, parses the character input as a date/time value according to format string &lt;code&gt;fmt&lt;/code&gt; according to the &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in the input stream &lt;code&gt;in&lt;/code&gt;. The resultant value is stored in a &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;tmb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in &amp;gt;&amp;gt; get_time(tmb, fmt)&lt;/code&gt; 中的表达式中使用时，根据格式字符串 &lt;code&gt;fmt&lt;/code&gt; 根据当前 &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; 到的输入流 &lt;code&gt;in&lt;/code&gt; 的语言环境的std :: time_get方面，将输入的字符解析为日期/时间值。结果值存储在 &lt;code&gt;tmb&lt;/code&gt; 指向的 &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 对象中。</target>
        </trans-unit>
        <trans-unit id="8f6b6002a8d5ee59f8db2c3ad5177196e34c65dc" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt;, converts the monetary value &lt;code&gt;mon&lt;/code&gt; to its character representation as specified by the &lt;code&gt;&lt;a href=&quot;../../locale/money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">当在表达式中使用 &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; ，货币值转换 &lt;code&gt;mon&lt;/code&gt; 由指定其字符表示 &lt;code&gt;&lt;a href=&quot;../../locale/money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; 面目前在充满的区域设置的 &lt;code&gt;out&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf45d63014365fd6dcec8ecebade756fbe4b1751" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; put_time(tmb, fmt)&lt;/code&gt;, converts the date and time information from a given calendar time &lt;code&gt;tmb&lt;/code&gt; to a character string according to format string &lt;code&gt;fmt&lt;/code&gt;, as if by calling &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../chrono/c/wcsftime&quot;&gt;std::wcsftime&lt;/a&gt;&lt;/code&gt;, or analog (depending on &lt;code&gt;CharT&lt;/code&gt;), according to the &lt;code&gt;&lt;a href=&quot;../../locale/time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in the output stream &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">当在表达式 &lt;code&gt;out &amp;lt;&amp;lt; put_time(tmb, fmt)&lt;/code&gt; ，根据格式字符串 &lt;code&gt;fmt&lt;/code&gt; 将给定日历时间 &lt;code&gt;tmb&lt;/code&gt; 的日期和时间信息转换为字符串，就像通过调用 &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../chrono/c/wcsftime&quot;&gt;std::wcsftime&lt;/a&gt;&lt;/code&gt; 或模拟（取决于 &lt;code&gt;CharT&lt;/code&gt; ），具体取决于当前 &lt;code&gt;&lt;a href=&quot;../../locale/time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; 到输出流 &lt;code&gt;out&lt;/code&gt; 中的语言环境的std :: time_put方面。</target>
        </trans-unit>
        <trans-unit id="c4b7fe6253074e6b867e1474688d0f2693a1f7d0" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; quoted(s, delim, escape)&lt;/code&gt;, where &lt;code&gt;out&lt;/code&gt; is an output stream with &lt;code&gt;char_type&lt;/code&gt; equal to &lt;code&gt;CharT&lt;/code&gt; and, for overloads 2-4, &lt;code&gt;traits_type&lt;/code&gt; equal to &lt;code&gt;Traits&lt;/code&gt;, behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;, which inserts into &lt;code&gt;out&lt;/code&gt; a sequence of characters &lt;code&gt;seq&lt;/code&gt; constructed as follows:</source>
          <target state="translated">在表达式 &lt;code&gt;out &amp;lt;&amp;lt; quoted(s, delim, escape)&lt;/code&gt; ，其中 &lt;code&gt;out&lt;/code&gt; 是 &lt;code&gt;char_type&lt;/code&gt; 等于 &lt;code&gt;CharT&lt;/code&gt; 的输出流，并且对于2-4的重载， &lt;code&gt;traits_type&lt;/code&gt; 等于 &lt;code&gt;Traits&lt;/code&gt; ，其表现为&lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;，插入到 &lt;code&gt;out&lt;/code&gt; 字符序列 &lt;code&gt;seq&lt;/code&gt; 构造如下：</target>
        </trans-unit>
        <trans-unit id="d8ac1ad4097229286f1a455e696150cbe6d78fe1" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; resetiosflags(mask)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; resetiosflags(mask)&lt;/code&gt;, clears all format flags of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; as specified by the &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">在表达式 &lt;code&gt;out &amp;lt;&amp;lt; resetiosflags(mask)&lt;/code&gt; 或 &lt;code&gt;in &amp;gt;&amp;gt; resetiosflags(mask)&lt;/code&gt; ，按 &lt;code&gt;mask&lt;/code&gt; 指定清除流 &lt;code&gt;out&lt;/code&gt; 或 &lt;code&gt;in&lt;/code&gt; 的所有格式标志。</target>
        </trans-unit>
        <trans-unit id="921ff88652686f85b631d9ceb7c724eb668d404a" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setfill(c)&lt;/code&gt; sets the fill character of the stream &lt;code&gt;out&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">当在表达式中使用 &lt;code&gt;out &amp;lt;&amp;lt; setfill(c)&lt;/code&gt; 设置流的填充字符 &lt;code&gt;out&lt;/code&gt; 到 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cb9f3afac80724df521c61b025e7c53651f4eb2" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setiosflags(mask)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setiosflags(mask)&lt;/code&gt;, sets all format flags of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; as specified by the &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">在表达式 &lt;code&gt;out &amp;lt;&amp;lt; setiosflags(mask)&lt;/code&gt; 或 &lt;code&gt;in &amp;gt;&amp;gt; setiosflags(mask)&lt;/code&gt; ，将流的所有格式标志设置为 &lt;code&gt;mask&lt;/code&gt; 指定的 &lt;code&gt;out&lt;/code&gt; 或 &lt;code&gt;in&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a87b307fde755e230f472b8260a494dc64a86904" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setprecision(n)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setprecision(n)&lt;/code&gt;, sets the &lt;code&gt;precision&lt;/code&gt; parameter of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; to exactly &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">当在表达式中使用 &lt;code&gt;out &amp;lt;&amp;lt; setprecision(n)&lt;/code&gt; 或 &lt;code&gt;in &amp;gt;&amp;gt; setprecision(n)&lt;/code&gt; ，设置 &lt;code&gt;precision&lt;/code&gt; 流的参数 &lt;code&gt;out&lt;/code&gt; 或 &lt;code&gt;in&lt;/code&gt; 精确 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c6a94f6a0cf9d3d1d83f0c666f4d933e3aa6770f" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setw(n)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setw(n)&lt;/code&gt;, sets the &lt;code&gt;width&lt;/code&gt; parameter of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; to exactly &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">在表达式 &lt;code&gt;out &amp;lt;&amp;lt; setw(n)&lt;/code&gt; 或 &lt;code&gt;in &amp;gt;&amp;gt; setw(n)&lt;/code&gt; ，将流 &lt;code&gt;out&lt;/code&gt; 或 &lt;code&gt;in&lt;/code&gt; 的 &lt;code&gt;width&lt;/code&gt; 参数设置为正好 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="101375a819be934deee54d8762c9258b209a7717" translate="yes" xml:space="preserve">
          <source>When used with &lt;a href=&quot;new&quot;&gt;new[]-expression&lt;/a&gt;, the size of an array may be zero; such an array has no elements:</source>
          <target state="translated">与&lt;a href=&quot;new&quot;&gt;new []-expression一起使用时&lt;/a&gt;，数组的大小可以为零；这样的数组没有元素：</target>
        </trans-unit>
        <trans-unit id="b5d2f5c5efbba3505a9a104fbd815a3de55bb31d" translate="yes" xml:space="preserve">
          <source>When used with a (non-const) object that has copy-on-write semantics, the range-based for loop may trigger a deep copy by (implicitly) calling the non-const &lt;code&gt;begin()&lt;/code&gt; member function. If that is undesirable (for instance because the loop is not actually modifying the object), &lt;code&gt;&lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;&lt;/code&gt; can be used:</source>
          <target state="translated">当与具有写时复制语义的（非const）对象一起使用时，基于范围的for循环可以通过（隐式）调用非const &lt;code&gt;begin()&lt;/code&gt; 成员函数来触发深层复制。如果不希望这样做（例如，因为循环实际上没有修改对象），则可以使用 &lt;code&gt;&lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="bf6c1868cc765347d09cc64a36b7be944f8dd8fb" translate="yes" xml:space="preserve">
          <source>When using a non-converting locale (the default locale is non-converting), the overrider of this function in &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; may be optimized for zero-copy bulk I/O (by means of overriding &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetn&quot;&gt;std::streambuf::xsgetn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">使用非转换语言环境时（默认语言环境为非转换语言环境），可以针对零拷贝批量I / O优化 &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; 中此函数的替代程序（通过重写 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetn&quot;&gt;std::streambuf::xsgetn&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0986776c60c5c2e2615f44185f446f8dc94a3805" translate="yes" xml:space="preserve">
          <source>When using a non-converting locale (the default locale is non-converting), the overrider of this function in &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; may be optimized for zero-copy bulk I/O (by means of overriding &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sputn&quot;&gt;std::streambuf::xsputn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">使用非转换语言环境时（默认语言环境为非转换语言环境），可以针对零拷贝批量I / O优化 &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; 中此函数的替代项（通过重写 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sputn&quot;&gt;std::streambuf::xsputn&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cbe8e117435e8afed934a7b78bf92466217654af" translate="yes" xml:space="preserve">
          <source>When using parallel execution policy, it is the programmer's responsibility to avoid data races and deadlocks:</source>
          <target state="translated">当使用并行执行策略时,避免数据竞赛和死锁是程序员的责任。</target>
        </trans-unit>
        <trans-unit id="7dd97b15bcdd677ac393fd1531f4ab0a23cce05d" translate="yes" xml:space="preserve">
          <source>When working with the C++ container library, the proper type for the difference between iterators is the member typedef &lt;code&gt;difference_type&lt;/code&gt;, which is often synonymous with &lt;code&gt;std::ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">当与C ++库容器工作，正确类型的迭代器之间的差异是该构件的typedef &lt;code&gt;difference_type&lt;/code&gt; ，这常常是同义 &lt;code&gt;std::ptrdiff_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="744601d71e0a622aae7e049c96112c98fceb410b" translate="yes" xml:space="preserve">
          <source>When writing characters, &lt;code&gt;&lt;a href=&quot;ostreambuf_iterator&quot;&gt;std::ostreambuf_iterator&lt;/a&gt;&lt;/code&gt; is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.</source>
          <target state="translated">编写字符时， &lt;code&gt;&lt;a href=&quot;ostreambuf_iterator&quot;&gt;std::ostreambuf_iterator&lt;/a&gt;&lt;/code&gt; 效率更高，因为它避免了每个字符构造和销毁哨兵对象一次的开销。</target>
        </trans-unit>
        <trans-unit id="6d6a0d2f37c6465daaf393a9cbcafd860707692e" translate="yes" xml:space="preserve">
          <source>Whenever a reference is bound to a temporary or to a subobject thereof, the lifetime of the temporary is extended to match the lifetime of the reference, with the following exceptions:</source>
          <target state="translated">每当一个引用被绑定到临时对象或其子对象时,临时对象的寿命就会被延长,以与引用的寿命相匹配,但有以下例外:</target>
        </trans-unit>
        <trans-unit id="a47ec6b9ae119d13c79d3ecadb3d357577c88006" translate="yes" xml:space="preserve">
          <source>Whenever an attempt is made to read or modify the stored value of an object of type &lt;code&gt;DynamicType&lt;/code&gt; through a glvalue of type &lt;code&gt;AliasedType&lt;/code&gt;, the behavior is undefined unless one of the following is true:</source>
          <target state="translated">每当尝试通过AliasedType类型的 &lt;code&gt;AliasedType&lt;/code&gt; 读取或修改 &lt;code&gt;DynamicType&lt;/code&gt; 类型的对象的存储值时，除非满足以下条件之一，否则行为是不确定的：</target>
        </trans-unit>
        <trans-unit id="9101581b76be4f749934d75b25f2b3f56089760f" translate="yes" xml:space="preserve">
          <source>Whenever the arguments are some C++ basic types, there are no ADL-associated namespaces. Hence, those scenarios are identical with the non-ADL examples above.</source>
          <target state="translated">每当参数是一些C++基本类型时,没有ADL相关的命名空间。因此,这些情况与上面的非ADL例子是相同的。</target>
        </trans-unit>
        <trans-unit id="77eef7bb821cc1a1b8c9c6ab0b0e1de54272ecdc" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/objects#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;std::memcpy&lt;/code&gt; may be used to convert the values.</source>
          <target state="translated">如果&lt;a href=&quot;../../language/objects#Strict_aliasing&quot;&gt;严格的别名&lt;/a&gt;禁止检查与两种不同类型的值相同的内存，则可以使用 &lt;code&gt;std::memcpy&lt;/code&gt; 转换值。</target>
        </trans-unit>
        <trans-unit id="c53cccdafaba481597a722fa2959cf7a851c2ce1" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;weak_this&lt;/code&gt; is the hidden mutable &lt;code&gt;std::weak_ptr&lt;/code&gt; member of &lt;code&gt;std::shared_from_this&lt;/code&gt;. The assignment to the &lt;code&gt;weak_this&lt;/code&gt; member is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to &lt;a href=&quot;../enable_shared_from_this/shared_from_this&quot;&gt;&lt;code&gt;shared_from_this()&lt;/code&gt;&lt;/a&gt; would share ownership with the &lt;code&gt;shared_ptr&lt;/code&gt; created by this raw pointer constructor.</source>
          <target state="translated">凡 &lt;code&gt;weak_this&lt;/code&gt; 是隐藏可变 &lt;code&gt;std::weak_ptr&lt;/code&gt; 成员 &lt;code&gt;std::shared_from_this&lt;/code&gt; 。对 &lt;code&gt;weak_this&lt;/code&gt; 成员的分配不是原子的，并且与对同一对象的任何潜在并发访问冲突。这样可以确保将来对&lt;a href=&quot;../enable_shared_from_this/shared_from_this&quot;&gt; &lt;code&gt;shared_from_this()&lt;/code&gt; 的&lt;/a&gt;调用将与此原始指针构造函数创建的 &lt;code&gt;shared_ptr&lt;/code&gt; 共享所有权。</target>
        </trans-unit>
        <trans-unit id="328d7d83b15b53db0928e0b402874f758e429540" translate="yes" xml:space="preserve">
          <source>Where R is the ordering category type defined above.</source>
          <target state="translated">其中R是上面定义的订购类别类型。</target>
        </trans-unit>
        <trans-unit id="582de0628906c31348c3039934a0f8563d8361ee" translate="yes" xml:space="preserve">
          <source>Where a constant expression is grammatically required, including:</source>
          <target state="translated">凡是在语法上需要常量表达的,包括:</target>
        </trans-unit>
        <trans-unit id="a8ebf782644f9429bc1fc6810b05c7e9c3c03635" translate="yes" xml:space="preserve">
          <source>Where applicable, &lt;a href=&quot;../iterator/iterator_tags#Example&quot;&gt;tag dispatch&lt;/a&gt;, &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt;, and, if available, &lt;a href=&quot;constraints&quot;&gt;concepts&lt;/a&gt;, are usually preferred over direct use of SFINAE.</source>
          <target state="translated">在适用的情况下，相对于直接使用SFINAE而言，通常更喜欢使用&lt;a href=&quot;../iterator/iterator_tags#Example&quot;&gt;标签dispatch&lt;/a&gt;，&lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt;以及如果有的话使用&lt;a href=&quot;constraints&quot;&gt;concepts&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c16c807394bc564276f7b672bb496e133719e00a" translate="yes" xml:space="preserve">
          <source>Where built-in operators return &lt;code&gt;bool&lt;/code&gt;, most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;bool&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">在内置运算符返回 &lt;code&gt;bool&lt;/code&gt; 的情况下，大多数&lt;a href=&quot;operators&quot;&gt;用户定义的重载&lt;/a&gt;也会返回 &lt;code&gt;bool&lt;/code&gt; ,因此用户定义运算符的使用方式与内置函数相同。但是，在用户定义的运算符重载中，任何类型都可以用作返回类型（包括 &lt;code&gt;void&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1889e8caa29d75a1818f0a931ca52b8fe1415229" translate="yes" xml:space="preserve">
          <source>Where class-name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</source>
          <target state="translated">其中class-name必须命名当前的类(或类模板的当前实例),或者,当在命名空间范围或友情声明中声明时,它必须是一个限定的类名。</target>
        </trans-unit>
        <trans-unit id="03f3df53bc82d8371ebdee50da2998db2016a301" translate="yes" xml:space="preserve">
          <source>Where class_name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</source>
          <target state="translated">其中class_name必须命名当前的类(或类模板的当前实例),或者,当在命名空间范围或友情声明中声明时,它必须是一个限定的类名。</target>
        </trans-unit>
        <trans-unit id="d7ad86ffa9afba91a0ed8ad0042113ba1987e71e" translate="yes" xml:space="preserve">
          <source>Where direct access to the elements of the container is not wanted or not possible or distinguishing between lvalue &lt;code&gt;c[i] = v;&lt;/code&gt; and rvalue &lt;code&gt;v = c[i];&lt;/code&gt; usage, operator[] may return a proxy. see for example &lt;code&gt;&lt;a href=&quot;../utility/bitset/operator_at&quot;&gt;std::bitset::operator[]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在不需要或不可能直接访问容器的元素的地方，或者在区分左值 &lt;code&gt;c[i] = v;&lt;/code&gt; 和右值 &lt;code&gt;v = c[i];&lt;/code&gt; 用法，operator []可以返回代理。参见例如 &lt;code&gt;&lt;a href=&quot;../utility/bitset/operator_at&quot;&gt;std::bitset::operator[]&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7544bd14fb0127b9e675324fe322b59d1667847a" translate="yes" xml:space="preserve">
          <source>Where necessary, the compiler may implicitly define the &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt;, &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, &lt;a href=&quot;move_operator&quot;&gt;move assignment operator&lt;/a&gt;, and the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;.</source>
          <target state="translated">必要时，编译器可以隐式定义&lt;a href=&quot;default_constructor&quot;&gt;默认构造函数&lt;/a&gt;，&lt;a href=&quot;copy_constructor&quot;&gt;副本构造函数&lt;/a&gt;，&lt;a href=&quot;move_constructor&quot;&gt;move构造函数&lt;/a&gt;，&lt;a href=&quot;as_operator&quot;&gt;副本赋值运算符&lt;/a&gt;，&lt;a href=&quot;move_operator&quot;&gt;move赋值运算符&lt;/a&gt;和&lt;a href=&quot;destructor&quot;&gt;析构函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d39fc5aa0a8a0218582cd66f3e979536d5af157" translate="yes" xml:space="preserve">
          <source>Where the input for &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imaginary&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.  If an error occurs calls &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;real&lt;/code&gt; 和 &lt;code&gt;imaginary&lt;/code&gt; 的输入必须可转换为 &lt;code&gt;T&lt;/code&gt; 的地方。如果发生错误，则调用 &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f939b6cebddd88e076c47ab7052d80f4f9691f8f" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">通常不指定数学库函数是否 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; ，但可以在函数的描述中明确指定（例如 &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="b0ef570637f0306b69eab32021437454f7aeaff6" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt; bit fields that aren't explicitly &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; are signed or unsigned.</source>
          <target state="translated">无论是 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; ， &lt;code&gt;int&lt;/code&gt; ， &lt;code&gt;long&lt;/code&gt; ，和 &lt;code&gt;long long&lt;/code&gt; 位未明确领域 &lt;code&gt;signed&lt;/code&gt; 或 &lt;code&gt;unsigned&lt;/code&gt; 的带符号。</target>
        </trans-unit>
        <trans-unit id="21520e7d3c4c9457f0b61f7da5be4c28fb0b2934" translate="yes" xml:space="preserve">
          <source>Whether implemented or not, this function is normally called by &lt;code&gt;std::basic_streambuf::in_avail&lt;/code&gt; if the get area is empty.</source>
          <target state="translated">无论是否实现，如果get区域为空，则通常由 &lt;code&gt;std::basic_streambuf::in_avail&lt;/code&gt; 调用此函数。</target>
        </trans-unit>
        <trans-unit id="be104b12a99ce4ffaccf474c68581deb485380ae" translate="yes" xml:space="preserve">
          <source>Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt;, if any, is also disassociated and deallocated if automatic allocation was used.</source>
          <target state="translated">无论操作是否成功，流都不再与文件关联，并且如果使用了自动分配，则 &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; 分配的缓冲区（如果有的话）也将被取消关联并释放。</target>
        </trans-unit>
        <trans-unit id="d46a08839feaec08adbd051313d8939dc9b21b97" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;../money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; uses pos_format for formatting positive values and neg_format for formatting negative values, &lt;code&gt;&lt;a href=&quot;../money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; uses neg_format for parsing all monetary values: it assumes that neg_format is compatible with pos_format.</source>
          <target state="translated">虽然 &lt;code&gt;&lt;a href=&quot;../money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; 使用pos_format格式化正值，使用neg_format格式化负值，而 &lt;code&gt;&lt;a href=&quot;../money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; 使用neg_format解析所有货币值：假定neg_format与pos_format兼容。</target>
        </trans-unit>
        <trans-unit id="4882bae700593de48c423f4a185a6a87fc8e0168" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;codecvt&lt;/code&gt; supports N:M conversions (e.g. UTF-16 to UTF-8, where two internal characters may be necessary to decide what external characters to output), &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; can only use &lt;code&gt;codecvt&lt;/code&gt; facets that define a 1:N conversion, that is it must be able to process one internal character at a time when writing to a file.</source>
          <target state="translated">虽然 &lt;code&gt;codecvt&lt;/code&gt; 支持N：M转换（例如，从UTF-16到UTF-8，其中可能需要两个内部字符来决定要输出哪些外部字符），但 &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 只能使用定义1：N转换的 &lt;code&gt;codecvt&lt;/code&gt; 构面，也就是说，写入文件时必须一次能够处理一个内部字符。</target>
        </trans-unit>
        <trans-unit id="ce692aaa12dee04f1b7857662f9696d7b39d104a" translate="yes" xml:space="preserve">
          <source>While all fundamental types &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact==true&lt;/code&gt; are integer types, a library may define exact types that aren't integers, e.g. a rational arithmetics type representing fractions.</source>
          <target state="translated">虽然所有基本类型 &lt;code&gt;T&lt;/code&gt; 针对 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact==true&lt;/code&gt; 被整数类型，图书馆可以定义确切类型不是整数，例如理性算术TYPE表示级分。</target>
        </trans-unit>
        <trans-unit id="5c6831ef0dd5db6345bc002124c0babc32834531" translate="yes" xml:space="preserve">
          <source>While in C++, the scope of the init-statement and the scope of statement are one and the same, in C the scope of statement is nested within the scope of init-statement:</source>
          <target state="translated">在C++中,init-statement的作用域和语句的作用域是一体的,而在C中,语句的作用域是嵌套在init-statement的作用域中的。</target>
        </trans-unit>
        <trans-unit id="f6a198ae06795de880db0e81ff4942b69fa0d198" translate="yes" xml:space="preserve">
          <source>While it's not true for fundamental C++ floating-point types, a third-party floating-point type &lt;code&gt;T&lt;/code&gt; may exist such that &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::lowest() != -&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">尽管对于基本C ++浮点类型不是正确的，但可能存在第三方浮点类型 &lt;code&gt;T&lt;/code&gt; ，使得 &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::lowest() != -&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdb7f0b47137662d6f73c67c92fda0e6b0d6c3b8" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;std::snprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings, and in order to determine the buffer size, the program may need to call &lt;code&gt;std::swprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">虽然窄字符串提供了 &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;std::snprintf&lt;/a&gt;&lt;/code&gt; ，这使得可以确定所需的输出缓冲区大小，但宽字符串没有等效项，并且为了确定缓冲区大小，程序可能需要调用 &lt;code&gt;std::swprintf&lt;/code&gt; ，检查结果值，并重新分配更大的缓冲区，然后重试直到成功。</target>
        </trans-unit>
        <trans-unit id="2aad7bc15a2badfcfdc2770354ab9bdb48f5b39a" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;std::vsnprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings, and in order to determine the buffer size, the program may need to call &lt;code&gt;std::vswprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">虽然窄字符串提供了 &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;std::vsnprintf&lt;/a&gt;&lt;/code&gt; ，这使得可以确定所需的输出缓冲区大小，但宽字符串没有等效项，并且为了确定缓冲区大小，程序可能需要调用 &lt;code&gt;std::vswprintf&lt;/code&gt; ，检查结果值，并重新分配更大的缓冲区，然后重试直到成功。</target>
        </trans-unit>
        <trans-unit id="3d1b9b2d47483d07a008f2f3460cb714ec262b09" translate="yes" xml:space="preserve">
          <source>While objects of any complete type and cv pointers to void may be thrown as exception objects, all standard library functions throw anonymous temporary objects by value, and the types of those objects are derived (directly or indirectly) from &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt;. User-defined exceptions usually follow this pattern.&lt;sup id=&quot;cite_ref-7&quot;&gt;&lt;a href=&quot;exceptions#cite_note-7&quot;&gt;[7]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-8&quot;&gt;&lt;a href=&quot;exceptions#cite_note-8&quot;&gt;[8]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-9&quot;&gt;&lt;a href=&quot;exceptions#cite_note-9&quot;&gt;[9]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">虽然任何完整类型的对象和指向void的cv指针都可以作为异常对象抛出，但是所有标准库函数都按值抛出匿名临时对象，并且这些对象的类型（直接或间接）是从 &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; 派生的。用户定义的异常通常遵循此模式。&lt;sup id=&quot;cite_ref-7&quot;&gt;&lt;a href=&quot;exceptions#cite_note-7&quot;&gt;[7] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-8&quot;&gt;&lt;a href=&quot;exceptions#cite_note-8&quot;&gt;[8] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-9&quot;&gt;&lt;a href=&quot;exceptions#cite_note-9&quot;&gt;[9]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="dd014792b0e30b26904af64ce06af14ab14dade5" translate="yes" xml:space="preserve">
          <source>While the names &quot;gptr&quot; and &quot;egptr&quot; refer to the get area, the name &quot;eback&quot; refers to the end of the putback area: stepping backwards from gptr, characters can be put back until eback.</source>
          <target state="translated">gptr &quot;和 &quot;egptr &quot;指的是get区域,而 &quot;eback &quot;指的是putback区域的结束:从gptr向后退,字符可以被放回,直到eback为止。</target>
        </trans-unit>
        <trans-unit id="e6aed0f8bf11c0e2ccb4abb52781539645453846" translate="yes" xml:space="preserve">
          <source>While the signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; regardless of &lt;a href=&quot;../../language/value_category&quot;&gt;value category&lt;/a&gt; (thus, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; is not allowed, nor is &lt;code&gt;Type1&lt;/code&gt; unless for &lt;code&gt;Type1&lt;/code&gt; a move is equivalent to a copy(since C++11)).</source>
          <target state="translated">尽管签名不需要具有 &lt;code&gt;const &amp;amp;&lt;/code&gt; ，但该函数不得修改传递给它的对象，并且必须能够接受类型（可能是const） &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 的所有值，而与&lt;a href=&quot;../../language/value_category&quot;&gt;值类别&lt;/a&gt;无关（因此，不允许 &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; 的，也不是 &lt;code&gt;Type1&lt;/code&gt; ，除非对于 &lt;code&gt;Type1&lt;/code&gt; 的举动相当于一个复制（因为C ++ 11））。</target>
        </trans-unit>
        <trans-unit id="b82e35d8b86e026d1b1ef3ee87feedc4e74f5048" translate="yes" xml:space="preserve">
          <source>While the signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; regardless of &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt; (thus, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; is not allowed, nor is &lt;code&gt;Type1&lt;/code&gt; unless for &lt;code&gt;Type1&lt;/code&gt; a move is equivalent to a copy(since C++11)).</source>
          <target state="translated">尽管签名不需要具有 &lt;code&gt;const &amp;amp;&lt;/code&gt; ，但该函数不得修改传递给它的对象，并且必须能够接受类型（可能是const） &lt;code&gt;Type1&lt;/code&gt; 和 &lt;code&gt;Type2&lt;/code&gt; 的所有值，而与&lt;a href=&quot;../language/value_category&quot;&gt;值类别&lt;/a&gt;无关（因此，不允许 &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; 的，也不是 &lt;code&gt;Type1&lt;/code&gt; ，除非对于 &lt;code&gt;Type1&lt;/code&gt; 的举动相当于一个复制（因为C ++ 11））。</target>
        </trans-unit>
        <trans-unit id="90970ed5fc36e4c5fcc7d19dbc8d5693453a089b" translate="yes" xml:space="preserve">
          <source>While the stream is frozen, &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; will not reallocate the buffer and the &lt;code&gt;destructor&lt;/code&gt; will not deallocate the buffer (thereby causing a memory leak).</source>
          <target state="translated">当流被冻结时， &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 将不会重新分配缓冲区，并且 &lt;code&gt;destructor&lt;/code&gt; 将不会重新分配缓冲区（从而导致内存泄漏）。</target>
        </trans-unit>
        <trans-unit id="51e02d156ab35053fbad0f57e42b76301b58ea18" translate="yes" xml:space="preserve">
          <source>While the variable declared in the range_declaration is usually used in the loop_statement, doing so is not required.</source>
          <target state="translated">虽然在range_declaration中声明的变量通常在loop_statement中使用,但不需要这样做。</target>
        </trans-unit>
        <trans-unit id="6c5f647e812d8ac720bd9936607ee574df0ff21f" translate="yes" xml:space="preserve">
          <source>While throw-expression can be used to transfer control to an arbitrary block of code up the execution stack, for arbitrary reasons (similar to &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt;), its intended usage is error handling.</source>
          <target state="translated">尽管可以使用throw-expression将控制权转移到执行堆栈上的任意代码块，但出于任意原因（类似于 &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; ），其预期用途是错误处理。</target>
        </trans-unit>
        <trans-unit id="721c1b250c710b24bfafaf9daadc9fa8642ecac8" translate="yes" xml:space="preserve">
          <source>While with &lt;code&gt;copy_options::recursive&lt;/code&gt;, the subdirectories are also copied, with their content, recursively.</source>
          <target state="translated">当使用 &lt;code&gt;copy_options::recursive&lt;/code&gt; ，子目录及其内容也会被递归地复制。</target>
        </trans-unit>
        <trans-unit id="b7402781ffeb31aaf9f29177f61c8ff4a0f44050" translate="yes" xml:space="preserve">
          <source>Wide character</source>
          <target state="translated">广泛的特性</target>
        </trans-unit>
        <trans-unit id="1fb55327ce03b4f2af732e3d187f25baf551cf61" translate="yes" xml:space="preserve">
          <source>Wide character array manipulation</source>
          <target state="translated">宽字符阵列操作</target>
        </trans-unit>
        <trans-unit id="6808058d5dd776d7c4d9454174f9c39df21f19c7" translate="yes" xml:space="preserve">
          <source>Wide character representation of &lt;code&gt;c&lt;/code&gt; if &lt;code&gt;(unsigned char)c&lt;/code&gt; is a valid single-byte character in the initial shift state, &lt;code&gt;WEOF&lt;/code&gt; otherwise.</source>
          <target state="translated">如果 &lt;code&gt;(unsigned char)c&lt;/code&gt; 在初始移位状态下是有效的单字节字符，则为 &lt;code&gt;c&lt;/code&gt; 的宽字符表示，否则为 &lt;code&gt;WEOF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab38913ae786de6e808a7c7241557b1856fc368e" translate="yes" xml:space="preserve">
          <source>Wide string manipulation</source>
          <target state="translated">宽字符串操作</target>
        </trans-unit>
        <trans-unit id="e56ba2339bc3a2c7efd4a4f1ffa763681a4e7ccb" translate="yes" xml:space="preserve">
          <source>Widening always returns a wide character, but only the characters from the basic source character set (latin letters, digits, and punctuations required to write a C++ program) are guaranteed to have a unique, well-defined, widening transformation, which is also guaranteed to be reversible (by &lt;code&gt;&lt;a href=&quot;narrow&quot;&gt;narrow()&lt;/a&gt;&lt;/code&gt;). In practice, all characters whose multibyte representation is a single byte are usually widened to their wide character counterparts, and the rest of the possible single-byte values are usually mapped into the same placeholder value, typically &lt;code&gt;CharT(-1)&lt;/code&gt;.</source>
          <target state="translated">扩展总是返回一个宽字符，但是只能保证基本源字符集中的字符（编写C ++程序所需的拉丁字母，数字和标点符号）具有唯一的，定义明确的，扩展的转换，这也得到了保证是可逆的（通过 &lt;code&gt;&lt;a href=&quot;narrow&quot;&gt;narrow()&lt;/a&gt;&lt;/code&gt; ）。实际上，通常将多字节表示为单个字节的所有字符扩展为对应的宽字符，而其余可能的单字节值通常映射到相同的占位符值，通常为 &lt;code&gt;CharT(-1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="15d388cfaf360c5681944037eaaad4926f0761c9" translate="yes" xml:space="preserve">
          <source>Widening, if successful, preserves all character classification categories known to &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">扩展 &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt; 如果成功）将保留is（）已知的所有字符分类类别。</target>
        </trans-unit>
        <trans-unit id="4e27d3de30e21293ff54a527696fb3dc557516fd" translate="yes" xml:space="preserve">
          <source>Widens a single-byte character &lt;code&gt;c&lt;/code&gt; to its wide character equivalent.</source>
          <target state="translated">将单字节字符 &lt;code&gt;c&lt;/code&gt; 扩展为等效的宽字符。</target>
        </trans-unit>
        <trans-unit id="3cf16972858ec6c71abfb6fa6d539bdbe451dbf6" translate="yes" xml:space="preserve">
          <source>Width in bits by data model</source>
          <target state="translated">按数据模型分列的位宽</target>
        </trans-unit>
        <trans-unit id="0352671572d548b1b50beb4586216b4e3764d488" translate="yes" xml:space="preserve">
          <source>Win16 API</source>
          <target state="translated">Win16 API</target>
        </trans-unit>
        <trans-unit id="ae7fc6d8171e0e405ed2e200f1d2b5056d479b80" translate="yes" xml:space="preserve">
          <source>Win32 API</source>
          <target state="translated">Win32 API</target>
        </trans-unit>
        <trans-unit id="50f72286ea0c96bccbea595ccc66e3982412d267" translate="yes" xml:space="preserve">
          <source>Win64 API</source>
          <target state="translated">Win64 API</target>
        </trans-unit>
        <trans-unit id="84a4a9dac26edeb0330a247c9af1446aecf202e8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;#pragma once&lt;/code&gt;, the same header appears as.</source>
          <target state="translated">随着 &lt;code&gt;#pragma once&lt;/code&gt; ，相同的标题出现。</target>
        </trans-unit>
        <trans-unit id="1d949445faea1f549e171010cf3291f2a325074c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;N = l - f&lt;/code&gt;, for all &lt;code&gt;0 &amp;lt; i &amp;lt; N&lt;/code&gt;, &lt;code&gt;f[floor(&lt;table&gt;
&lt;tr&gt;&lt;td&gt;i-1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;)]&lt;/code&gt; does not compare less than &lt;code&gt;f[i]&lt;/code&gt;.</source>
          <target state="translated">当 &lt;code&gt;N = l - f&lt;/code&gt; ，对于所有 &lt;code&gt;0 &amp;lt; i &amp;lt; N&lt;/code&gt; ， &lt;code&gt;f[floor(&lt;table&gt; &lt;tr&gt;&lt;td&gt;i-1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;)]&lt;/code&gt; 比较的结果不小于 &lt;code&gt;f[i]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0d81a9b5de91fa98a2d0ef9f4c7f4ecf47988e3" translate="yes" xml:space="preserve">
          <source>With \n instead of endl, the output would be the same, but may not appear in real time.</source>
          <target state="translated">如果用&quot;/n &quot;代替 &quot;endl&quot;,输出结果是一样的,但可能不会实时出现。</target>
        </trans-unit>
        <trans-unit id="47777a8b463cd5f1e3501816b2ffaa3ea107991e" translate="yes" xml:space="preserve">
          <source>With floating point types &lt;code&gt;std::to_string&lt;/code&gt; may yield unexpected results as the number of significant digits in the returned string can be zero, see the example.</source>
          <target state="translated">使用浮点类型 &lt;code&gt;std::to_string&lt;/code&gt; 可能会产生意外结果，因为返回的字符串中的有效位数可以为零，请参见示例。</target>
        </trans-unit>
        <trans-unit id="884b3b619e3ef18e83dc71855fd6e34d05de7659" translate="yes" xml:space="preserve">
          <source>With operands of arithmetic or enumeration type, the result of binary plus is the sum of the operands (after usual arithmetic conversions), and the result of the binary minus operator is the result of subtracting the second operand from the first (after usual arithmetic conversions), except that, if the type supports IEEE floating-point arithmetic (see &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">对于算术或枚举类型的操作数，binary plus的结果是操作数的总和（在常规算术转换之后），binary minus运算符的结果是从第一个操作数减去第二个操作数的结果（在常规算术转换之后） ），除非该类型支持IEEE浮点运算（请参阅 &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt; ），</target>
        </trans-unit>
        <trans-unit id="fa16b9931c1f17c4f80ec1a246f1cc250c5dd37a" translate="yes" xml:space="preserve">
          <source>With the default allocator, this requirement is equivalent to the validity of &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;, which accepts class types with accessible destructors and all scalar types, but rejects array types, function types, reference types, and void.</source>
          <target state="translated">使用默认分配器时，此要求等效于 &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; 的有效性，p-&amp;gt;〜T（）接受具有可访问析构函数的类类型和所有标量类型，但拒绝数组类型，函数类型，引用类型和void。</target>
        </trans-unit>
        <trans-unit id="b4fea2c438a60cf674bf6a42d287a393b3f62920" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;complex.h&lt;/code&gt; , each &lt;code&gt;xxx.h&lt;/code&gt; header included in the C++ standard library places in the global namespace each name that the corresponding &lt;code&gt;cxxx&lt;/code&gt; header would have placed in the &lt;code&gt;std&lt;/code&gt; namespace.</source>
          <target state="translated">除了 &lt;code&gt;complex.h&lt;/code&gt; 之外，C ++标准库中包含的每个 &lt;code&gt;xxx.h&lt;/code&gt; 标头都将其对应的 &lt;code&gt;cxxx&lt;/code&gt; 标头应放在 &lt;code&gt;std&lt;/code&gt; 名称空间中的每个名称放置在全局名称空间中。</target>
        </trans-unit>
        <trans-unit id="5d30f232b7061443bee920972c5d82807b94d345" translate="yes" xml:space="preserve">
          <source>With the introduction of move semantics in C++11, value categories were redefined to characterize two independent properties of expressions&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;value_category#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;:</source>
          <target state="translated">随着C ++ 11中移动语义的引入，值类别被重新定义以表征表达式的两个独立属性&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;value_category#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;：</target>
        </trans-unit>
        <trans-unit id="d7eedc43562dbda358e0af8f66b618c9779da2ba" translate="yes" xml:space="preserve">
          <source>Within a catch-clause, &lt;code&gt;&lt;a href=&quot;../error/current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; can be used to capture the exception in an &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../error/throw_with_nested&quot;&gt;std::throw_with_nested&lt;/a&gt;&lt;/code&gt; may be used to build nested exceptions.</source>
          <target state="translated">在一个 &lt;code&gt;&lt;a href=&quot;../error/throw_with_nested&quot;&gt;std::throw_with_nested&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../error/current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; 可用于捕获 &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; ，而std :: throw_with_nested可用于构建嵌套异常。</target>
        </trans-unit>
        <trans-unit id="245bc5b44f72c46518d49f6231bcdddbab7bc492" translate="yes" xml:space="preserve">
          <source>Within a class template definition (including its member functions and nested classes) some names may be deduced to refer to the</source>
          <target state="translated">在一个类模板定义中(包括它的成员函数和嵌套类),可以推导出一些名称是指的是</target>
        </trans-unit>
        <trans-unit id="bc89bf6548ea7d54b0a391d0d3c8b9447ce5c361" translate="yes" xml:space="preserve">
          <source>Within a scope, &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt; can be used to associate the name with its declaration.</source>
          <target state="translated">在范围内，可以使用&lt;a href=&quot;lookup&quot;&gt;非限定名称查找&lt;/a&gt;将名称与其声明相关联。</target>
        </trans-unit>
        <trans-unit id="00817315634a43af97703fb51abe4ea2bd10d529" translate="yes" xml:space="preserve">
          <source>Within a template definition, certain names are deduced to belong to an</source>
          <target state="translated">在一个模板定义中,某些名称被推断为属于一个</target>
        </trans-unit>
        <trans-unit id="7119f9b6e9a5c41a2215c5c5ab587c351e88a0e6" translate="yes" xml:space="preserve">
          <source>Within a thread of execution, accesses (reads and writes) through &lt;a href=&quot;../language/cv&quot;&gt;volatile glvalues&lt;/a&gt; cannot be reordered past observable side-effects (including other volatile accesses) that are</source>
          <target state="translated">在执行线程中，通过&lt;a href=&quot;../language/cv&quot;&gt;易失性glvalue&lt;/a&gt;进行的访问（读和写）不能重新排列，以免出现以下可观察到的副作用（包括其他易失性访问）</target>
        </trans-unit>
        <trans-unit id="6eda1a3a6846d50df7adc54351dedaf50fda69c3" translate="yes" xml:space="preserve">
          <source>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the &lt;a href=&quot;../utility/variadic&quot;&gt;&amp;lt;cstdarg&amp;gt; library facilities&lt;/a&gt;:</source>
          <target state="translated">在使用可变参数的函数主体中，可以使用&lt;a href=&quot;../utility/variadic&quot;&gt;&amp;lt;cstdarg&amp;gt;库工具&lt;/a&gt;来访问这些参数的值：</target>
        </trans-unit>
        <trans-unit id="af7aded55b08b8ee429002640a601104c0c3e5cf" translate="yes" xml:space="preserve">
          <source>Within the body of a lambda, any use of &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; on any variable with automatic storage duration is as if it were captured and odr-used, even though decltype itself isn't an odr-use and no actual capture takes place:</source>
          <target state="translated">在lambda主体中，对具有自动存储持续时间的任何变量使用&lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt;就像是已捕获并odd用过，即使decltype本身不是odr使用且未发生实际捕获：</target>
        </trans-unit>
        <trans-unit id="078ca0cc0ac40495d119f9a3fdddbbaaae3dc64d" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt;, each identifier that names a non-static member is implicitly transformed to a class member access expression &lt;code&gt;this-&amp;gt;member&lt;/code&gt;.</source>
          <target state="translated">在非静态&lt;a href=&quot;member_functions&quot;&gt;成员函数&lt;/a&gt;的主体内，每个命名非静态成员的标识符都隐式转换为类成员访问表达式 &lt;code&gt;this-&amp;gt;member&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79f7c80c73c316c30ac1674843481cc4326e1a44" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static member function of X, any &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt; E (e.g. an identifier) that resolves to a non-type non-static member of X or of a base class of X, is transformed to a member access expression &lt;code&gt;(*this).E&lt;/code&gt; (unless it's already a part of a member access expression). This does not occur in template definition context, so a name may have to be prefixed with &lt;code&gt;this-&amp;gt;&lt;/code&gt; explicitly to become &lt;a href=&quot;dependent_name&quot;&gt;dependent&lt;/a&gt;.</source>
          <target state="translated">在X的非静态成员函数的主体内，任何解析为X的非类型非静态成员或X的基类的&lt;a href=&quot;expressions&quot;&gt;id表达式&lt;/a&gt; E（例如，标识符）都将转换为成员访问权限表达式 &lt;code&gt;(*this).E&lt;/code&gt; （除非它已经是成员访问表达式的一部分）。在模板定义上下文中不会发生这种情况，因此名称可能必须显式地带有 &lt;code&gt;this-&amp;gt;&lt;/code&gt; 前缀才能成为&lt;a href=&quot;dependent_name&quot;&gt;dependent&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ff9fb1990c434e938a6a0e2d84512b173b30aeb8" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static member function of X, any unqualified-id that resolves to a static member, an enumerator or a nested type of X or of a base class of X, is transformed to the corresponding qualified-id.</source>
          <target state="translated">在X的非静态成员函数的主体中,任何解析到X的静态成员、枚举器或嵌套类型或X的基类的非限定id,都会被转换为相应的限定id。</target>
        </trans-unit>
        <trans-unit id="5ba9b5ad1328d649ca86d8f4a5d41ae2a5633cf1" translate="yes" xml:space="preserve">
          <source>Within the function body, the function-local predefined variable &lt;code&gt;__func__&lt;/code&gt; is defined as if by.</source>
          <target state="translated">在函数体内，函数本地预定义变量 &lt;code&gt;__func__&lt;/code&gt; 被定义为by。</target>
        </trans-unit>
        <trans-unit id="f89ece3e05e483d8d6633832e929cb8220c8daba" translate="yes" xml:space="preserve">
          <source>Within the same thread, evaluation A may be</source>
          <target state="translated">在同一线程中,评价A可以是</target>
        </trans-unit>
        <trans-unit id="c72f89b6f5d83e25d732495d891540e02b9e90aa" translate="yes" xml:space="preserve">
          <source>Within the same thread, evaluation A that is</source>
          <target state="translated">在同一线程内,评价A即</target>
        </trans-unit>
        <trans-unit id="25258e5219c6e5baefb975484506b38b6aa8362b" translate="yes" xml:space="preserve">
          <source>Within the scope of a class template specialization or partial specialization, when the injected-class-name is used as a type-name, it is equivalent to the template-name followed by the template-arguments of the class template specialization or partial specialization enclosed in &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在类模板专业化或部分专业化的范围内，当将Injection-class-name用作类型名称时，它等效于模板名称，后跟包含类模板专业化或部分专业化的模板参数在 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="ce2fab5742c8b33bc0537c80ea3b8dcc2cc835e1" translate="yes" xml:space="preserve">
          <source>Within the scope of a class template, the name of the template without a parameter list is an injected class name, and can be used as a type. In that case, class argument deduction does not happen and template parameters must be supplied explicitly:</source>
          <target state="translated">在类模板的范围内,没有参数列表的模板名是注入的类名,可以作为类型使用。在这种情况下,类参数推导不会发生,必须显式提供模板参数。</target>
        </trans-unit>
        <trans-unit id="05619ddfa2c0d81e8a6ead6a708344745a722242" translate="yes" xml:space="preserve">
          <source>Without std::flush, the output would be the same, but may not appear in real time.</source>
          <target state="translated">如果没有std::flush,输出也会一样,但可能不会实时出现。</target>
        </trans-unit>
        <trans-unit id="d0f55a4102a27df1431160445b96e34d20fd4f3d" translate="yes" xml:space="preserve">
          <source>Without std::unitbuf or another explicit flush, the output is the same, but does not appear in real time.</source>
          <target state="translated">如果没有std::unitbuf或其他显式刷新,输出是一样的,但不会实时出现。</target>
        </trans-unit>
        <trans-unit id="682b37a0a9239f633eb0a18ad35c5e23fe316950" translate="yes" xml:space="preserve">
          <source>Working with a &lt;code&gt;priority_queue&lt;/code&gt; is similar to managing a &lt;a href=&quot;../algorithm/make_heap&quot;&gt; heap&lt;/a&gt; in some random access container, with the benefit of not being able to accidentally invalidate the heap.</source>
          <target state="translated">使用 &lt;code&gt;priority_queue&lt;/code&gt; 类似于在某些随机访问容器中管理&lt;a href=&quot;../algorithm/make_heap&quot;&gt;堆&lt;/a&gt;，其好处是不会意外使堆无效。</target>
        </trans-unit>
        <trans-unit id="8065f27e56565b08250cf2bdf011c92725655e0d" translate="yes" xml:space="preserve">
          <source>Wrapper around a member function pointer. The class instance whose member function to call is passed as a pointer to the &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">成员函数指针周围的包装器。其成员函数要调用的类实例作为指向 &lt;code&gt;operator()&lt;/code&gt; 的指针传递。</target>
        </trans-unit>
        <trans-unit id="a56128931adfe376f6d1c4233b2aee9d4414fed0" translate="yes" xml:space="preserve">
          <source>Wrapper around a member function pointer. The class instance whose member function to call is passed as a reference to the &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">成员函数指针周围的包装器。将要调用其成员函数的类实例作为对 &lt;code&gt;operator()&lt;/code&gt; 的引用传递。</target>
        </trans-unit>
        <trans-unit id="dd35487a2eb7da40332f7fc41452378d92a72445" translate="yes" xml:space="preserve">
          <source>Writable</source>
          <target state="translated">Writable</target>
        </trans-unit>
        <trans-unit id="a9b6a4bb633bad2e9e1e0bcdbb56726b9e0e6146" translate="yes" xml:space="preserve">
          <source>Write to end</source>
          <target state="translated">写到最后</target>
        </trans-unit>
        <trans-unit id="e87fd10313099f92edd69106267a002d4e8466a1" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;. Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">将一个字符写入 &lt;code&gt;ch&lt;/code&gt; 到 &lt;code&gt;stdout&lt;/code&gt; 。在内部，该字符在即将被写入之前会转换为 &lt;code&gt;unsigned char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a96b7df507ca67492643e29e1db1884cf6663933" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">将字符 &lt;code&gt;ch&lt;/code&gt; 写入给定的输出流 &lt;code&gt;stream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="001712686d4b96e8257e062bf8257f5854fb0c91" translate="yes" xml:space="preserve">
          <source>Writes a horizontal tab character.</source>
          <target state="translated">写一个横向的制表字符。</target>
        </trans-unit>
        <trans-unit id="b8a7060cb09fe871077059dd6f46ca33bbda1f49" translate="yes" xml:space="preserve">
          <source>Writes a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">写入文字 &lt;code&gt;%&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="cb18b1353d53796c65bfab0bce5e3151631b33c0" translate="yes" xml:space="preserve">
          <source>Writes a newline character.</source>
          <target state="translated">写一个新行字符。</target>
        </trans-unit>
        <trans-unit id="6924072c304541be0f3e71e77883f2ec6c6a9d14" translate="yes" xml:space="preserve">
          <source>Writes a textual representation of a thread identifier &lt;code&gt;id&lt;/code&gt; to the output stream &lt;code&gt;ost&lt;/code&gt;.</source>
          <target state="translated">将线程标识符 &lt;code&gt;id&lt;/code&gt; 的文本表示形式写入输出流 &lt;code&gt;ost&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="767a6e009054da5918825851e61b1c02bbbf738a" translate="yes" xml:space="preserve">
          <source>Writes a textual representation of the distribution parameters and internal state to &lt;code&gt;os&lt;/code&gt;. The formatting flags and fill character of &lt;code&gt;os&lt;/code&gt; are unchanged.</source>
          <target state="translated">将分布参数和内部状态的文本表示形式写入 &lt;code&gt;os&lt;/code&gt; 。 &lt;code&gt;os&lt;/code&gt; 的格式标志和填充字符未更改。</target>
        </trans-unit>
        <trans-unit id="628a432848d3d2a0f439ca52671452d1eec4d9ff" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">写一个宽字符 &lt;code&gt;ch&lt;/code&gt; 到 &lt;code&gt;stdout&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a61cc5af43d9f51fcd06a3cacfeb3348c1595940" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putwc()&lt;/code&gt; may be implemented as a macro and may evaluate &lt;code&gt;stream&lt;/code&gt; more than once.</source>
          <target state="translated">将宽字符 &lt;code&gt;ch&lt;/code&gt; 写入给定的输出流 &lt;code&gt;stream&lt;/code&gt; 。 &lt;code&gt;putwc()&lt;/code&gt; 可以实现为宏，并且可以多次评估 &lt;code&gt;stream&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb34f2576c279e7725c583723fccb0fc6a3511eb" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; and one additional newline character &lt;code&gt;'\n'&lt;/code&gt; to the output stream &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将以空终止的字符串 &lt;code&gt;str&lt;/code&gt; 和每个附加的换行符 &lt;code&gt;'\n'&lt;/code&gt; 中的每个字符写入输出流 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; ，就像重复执行 &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a503bcd94956c4103d38ea588d00af71b7d3a70" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将以空终止的字符串 &lt;code&gt;str&lt;/code&gt; 中的每个字符写入输出流 &lt;code&gt;stream&lt;/code&gt; ，就像重复执行 &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83ab79edfcdea5e94d3e192eb9d45b8f6bebd9bf" translate="yes" xml:space="preserve">
          <source>Writes every wide character from the null-terminated wide string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;std::fputwc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将以空终止的宽字符串 &lt;code&gt;str&lt;/code&gt; 中的每个宽字符写入输出流 &lt;code&gt;stream&lt;/code&gt; ，就像通过重复执行 &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;std::fputwc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9b88a484ae89e6d4131f01f0c94c90cbf9dc18c" translate="yes" xml:space="preserve">
          <source>Writes one character to the output sequence.</source>
          <target state="translated">将一个字符写入输出序列。</target>
        </trans-unit>
        <trans-unit id="3aeb20d4e3a246faca11563fb03064671edc3f42" translate="yes" xml:space="preserve">
          <source>Writes some data from the put area to the associated character sequence (to the file).</source>
          <target state="translated">将一些数据从put区域写入相关的字符序列(到文件)。</target>
        </trans-unit>
        <trans-unit id="74f04ede6f753ddec049a69f229f7dc13079d99c" translate="yes" xml:space="preserve">
          <source>Writes the ISO 8601 week of the year as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">将ISO 8601年的星期写成十进制数。如果结果是一位数,则以0为前缀。</target>
        </trans-unit>
        <trans-unit id="f7d029ddd98ce63f15114123e69a3596edcb4ab0" translate="yes" xml:space="preserve">
          <source>Writes the ISO 8601 week-based year as a decimal number. If the result is less than four digits it is left-padded with 0 to four digits.</source>
          <target state="translated">将ISO 8601以周为单位的年份写成十进制数。如果结果小于四位数,则用0到四位数左垫。</target>
        </trans-unit>
        <trans-unit id="0cc1164d46d9e7c267ced7895e6152ab0b695562" translate="yes" xml:space="preserve">
          <source>Writes the ISO weekday as a decimal number (1-7), where Monday is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">将ISO工作日写为十进制数字（1-7），其中星期一为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="71166ded75b14ffa703a04ab3f28950a6779e502" translate="yes" xml:space="preserve">
          <source>Writes the day of month as a decimal number. If the result is a single decimal digit, it is prefixed with 0.</source>
          <target state="translated">将月份的日期写成十进制数。如果结果是一个小数点,则以0为前缀。</target>
        </trans-unit>
        <trans-unit id="b0f7893ae9d8e28cab469762cfa8b52ab87190ba" translate="yes" xml:space="preserve">
          <source>Writes the day of month as a decimal number. If the result is a single decimal digit, it is prefixed with a space.</source>
          <target state="translated">将月份的日期写成十进制数。如果结果是一个小数点,则在其前面加一个空格。</target>
        </trans-unit>
        <trans-unit id="1626fbac11740992d51707eebf9b1bc3e70c4e3f" translate="yes" xml:space="preserve">
          <source>Writes the day of the year as a decimal number (January 1 is &lt;code&gt;001&lt;/code&gt;). If the result is less than three digits, it is left-padded with 0 to three digits.</source>
          <target state="translated">将一年中的日期写为十进制数字（1月1日是 &lt;code&gt;001&lt;/code&gt; ）。如果结果少于三位数，则将其用0到三位数进行左填充。</target>
        </trans-unit>
        <trans-unit id="c029d304cd7d0c5128b916f1b7935a6092ee6d60" translate="yes" xml:space="preserve">
          <source>Writes the hour (12-hour clock) as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">将小时(12小时钟)写成十进制数。如果结果是一位数,则以0为前缀。</target>
        </trans-unit>
        <trans-unit id="d586ae48a03fbce6cab63eb6156b184051a469fd" translate="yes" xml:space="preserve">
          <source>Writes the hour (24-hour clock) as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">将小时(24小时钟)写成十进制数。如果结果是一位数,则以0为前缀。</target>
        </trans-unit>
        <trans-unit id="67151c9d086e78a6b607bc1d8cdeea642b931db1" translate="yes" xml:space="preserve">
          <source>Writes the last two decimal digits of the ISO 8601 week-based year. If the result is a single digit it is prefixed by 0.</source>
          <target state="translated">写入ISO 8601以周为单位的年份的最后两位小数。如果结果是一位数,则以0为前缀。</target>
        </trans-unit>
        <trans-unit id="9ff9a700dc66f1c252bd7007b0facde18742ff7d" translate="yes" xml:space="preserve">
          <source>Writes the last two decimal digits of the year. If the result is a single digit it is prefixed by 0.</source>
          <target state="translated">写出年份的最后两位小数。如果结果是一位数,则以0为前缀。</target>
        </trans-unit>
        <trans-unit id="30b48d91697b9f629d02ce9d83e7a421c921e234" translate="yes" xml:space="preserve">
          <source>Writes the locale's 12-hour clock time.</source>
          <target state="translated">写出当地的12小时时钟时间。</target>
        </trans-unit>
        <trans-unit id="a971b059080c39ac822e661aea1c87ec25348313" translate="yes" xml:space="preserve">
          <source>Writes the locale's abbreviated month name.</source>
          <target state="translated">写出当地的缩写月份名称。</target>
        </trans-unit>
        <trans-unit id="f672aa4e85699374012ee1a535ef52d6be86123e" translate="yes" xml:space="preserve">
          <source>Writes the locale's abbreviated weekday name.</source>
          <target state="translated">写出当地工作日的缩写名称。</target>
        </trans-unit>
        <trans-unit id="a93c6febd8287cd73094f5c7fa21ffc07a57cd24" translate="yes" xml:space="preserve">
          <source>Writes the locale's date and time representation.</source>
          <target state="translated">写出当地的日期和时间表示。</target>
        </trans-unit>
        <trans-unit id="8990ab22cb03b6694ce6cb909d61b54ae50e921c" translate="yes" xml:space="preserve">
          <source>Writes the locale's date representation.</source>
          <target state="translated">写入locale的日期表示。</target>
        </trans-unit>
        <trans-unit id="1dec9978ca81332b5e90610cec498718c6ecefef" translate="yes" xml:space="preserve">
          <source>Writes the locale's equivalent of the AM/PM designations associated with a 12-hour clock.</source>
          <target state="translated">写出与12小时钟相关联的AM/PM指定的区域等价物。</target>
        </trans-unit>
        <trans-unit id="4bd0b778c0ca16103f3037347259706f50406b6f" translate="yes" xml:space="preserve">
          <source>Writes the locale's full month name.</source>
          <target state="translated">写出当地的全月名称。</target>
        </trans-unit>
        <trans-unit id="dbcf68702a0a2c1386e6fd13ec2cac6f00c12942" translate="yes" xml:space="preserve">
          <source>Writes the locale's full weekday name.</source>
          <target state="translated">写出该地点的完整工作日名称。</target>
        </trans-unit>
        <trans-unit id="ba5f45187c6fabe4410c47f297770de07e96243b" translate="yes" xml:space="preserve">
          <source>Writes the locale's time representation.</source>
          <target state="translated">写出当地的时间表示。</target>
        </trans-unit>
        <trans-unit id="fc68d043b917adc440f4f576ac7e4b54287ebed4" translate="yes" xml:space="preserve">
          <source>Writes the minute as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">将分钟写成十进制数,如果结果是一位数,则以0为前缀。如果结果是一位数,则以0为前缀。</target>
        </trans-unit>
        <trans-unit id="c30fe76679f32dcce8e852b50af05cbd5aefe9f6" translate="yes" xml:space="preserve">
          <source>Writes the month as a decimal number (January is &lt;code&gt;01&lt;/code&gt;). If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">将月份写为十进制数字（一月为 &lt;code&gt;01&lt;/code&gt; ）。如果结果是一位数字，则以0开头。</target>
        </trans-unit>
        <trans-unit id="8032e3a64c8132ccb6ad44a63e27ef9ad4339e8a" translate="yes" xml:space="preserve">
          <source>Writes the offset from UTC in the ISO 8601 format. For example &lt;code&gt;-0430&lt;/code&gt; refers to 4 hours 30 minutes behind UTC. If the offset is zero, &lt;code&gt;+0000&lt;/code&gt; is used.</source>
          <target state="translated">以ISO 8601格式写入UTC的偏移量。例如 &lt;code&gt;-0430&lt;/code&gt; 表示比UTC 晚 4小时30分钟。如果偏移量为零，则使用 &lt;code&gt;+0000&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d76d87840d6936192aee3cda5289202c38d7018" translate="yes" xml:space="preserve">
          <source>Writes the representation of the matched subsequence &lt;code&gt;m&lt;/code&gt; to the output stream &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">将匹配的子序列 &lt;code&gt;m&lt;/code&gt; 的表示形式写入输出流 &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17feef3d0503048639900d16af24c9e6fe4685c7" translate="yes" xml:space="preserve">
          <source>Writes the second as a decimal number. If the number of seconds is less than 10, the result is prefixed with 0.</source>
          <target state="translated">将秒数写成十进制数。如果秒数小于10,结果以0为前缀。</target>
        </trans-unit>
        <trans-unit id="1a73b5e51c193b1deccbfaf669b4db12b0a55d6d" translate="yes" xml:space="preserve">
          <source>Writes the time zone abbreviation.</source>
          <target state="translated">写出时区的缩写。</target>
        </trans-unit>
        <trans-unit id="1d8938025c2761da9ede064d18f5ef84dcf58261" translate="yes" xml:space="preserve">
          <source>Writes the week number of the year as a decimal number. The first Monday of the year is the first day of week 01. Days of the same year prior to that are in week 00. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">将一年中的周号写成小数。一年中的第一个星期一是01周的第一天。同年之前的日子在00周。如果结果是个位数,则以0为前缀。</target>
        </trans-unit>
        <trans-unit id="370c8fdb39d9f2b4190c27cb6e07474705f3c637" translate="yes" xml:space="preserve">
          <source>Writes the week number of the year as a decimal number. The first Sunday of the year is the first day of week 01. Days of the same year prior to that are in week 00. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">将一年的周号写成小数。一年中的第一个星期日是01周的第一天。在这之前的同年的日子是在00周。如果结果是个位数,则以0为前缀。</target>
        </trans-unit>
        <trans-unit id="dbdae9db0bd7c298a373f28a7cd0509bbbb5b272" translate="yes" xml:space="preserve">
          <source>Writes the weekday as a decimal number (0-6), where Sunday is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">将工作日写为十进制数字（0-6），其中星期日是 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bb21ea8cdea47573e1038fbae721d5dca3fb901b" translate="yes" xml:space="preserve">
          <source>Writes the year as a decimal number. If the result is less than four digits it is left-padded with 0 to four digits.</source>
          <target state="translated">将年份写成十进制数,如果结果小于四位数,则用0到四位数左垫。如果结果小于四位数,则用0到四位数左垫。</target>
        </trans-unit>
        <trans-unit id="26249ba8d699dd0df931793d3da64b00c7c31d1d" translate="yes" xml:space="preserve">
          <source>Writes the year divided by 100 using floored division. If the result is a single decimal digit, it is prefixed with 0.</source>
          <target state="translated">用浮动除法写出年份除以100的结果。如果结果是一位小数点,则以0为前缀。</target>
        </trans-unit>
        <trans-unit id="a77785063b2874f1bbee1b042250317d98d6b33a" translate="yes" xml:space="preserve">
          <source>Writes to &lt;code&gt;os&lt;/code&gt; the textual representation of &lt;code&gt;x&lt;/code&gt;'s current state. In the output, adjacent numbers are separated by one or more space characters. If &lt;code&gt;os&lt;/code&gt;'s fmtflags are not set to &lt;code&gt;ios_base::dec|ios_base::left&lt;/code&gt;, the behavior may be undefined.</source>
          <target state="translated">向 &lt;code&gt;os&lt;/code&gt; 写入 &lt;code&gt;x&lt;/code&gt; 当前状态的文本表示形式。在输出中，相邻数字由一个或多个空格字符分隔。如果 &lt;code&gt;os&lt;/code&gt; 的fmtflags未设置为 &lt;code&gt;ios_base::dec|ios_base::left&lt;/code&gt; ，则行为可能不确定。</target>
        </trans-unit>
        <trans-unit id="0d621d908346c0bfe11eb811537d53c64ce8ec02" translate="yes" xml:space="preserve">
          <source>Writes to fields</source>
          <target state="translated">写入字段</target>
        </trans-unit>
        <trans-unit id="00c192b84cfa44d2bd75c59846c86d17a1e44b25" translate="yes" xml:space="preserve">
          <source>Writes uncommitted changes to the underlying output sequence.</source>
          <target state="translated">将未提交的更改写入底层输出序列。</target>
        </trans-unit>
        <trans-unit id="15ec5b51c4d780460bc9101843d2786a8b364326" translate="yes" xml:space="preserve">
          <source>Writes up to &lt;code&gt;count&lt;/code&gt; binary objects from the given array &lt;code&gt;buffer&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;. The objects are written as if by reinterpreting each object as an array of &lt;code&gt;unsigned char&lt;/code&gt; and calling &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; times for each object to write those &lt;code&gt;unsigned char&lt;/code&gt;s into &lt;code&gt;stream&lt;/code&gt;, in order. The file position indicator for the stream is advanced by the number of characters written.</source>
          <target state="translated">从给定的数组 &lt;code&gt;buffer&lt;/code&gt; 写入 &lt;code&gt;count&lt;/code&gt; 到输出流 &lt;code&gt;stream&lt;/code&gt; 的二进制对象。通过将每个对象重新解释为 &lt;code&gt;unsigned char&lt;/code&gt; 数组，并为每个对象调用 &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; &lt;code&gt;size&lt;/code&gt; 时间，将这些 &lt;code&gt;unsigned char&lt;/code&gt; 依次写入 &lt;code&gt;stream&lt;/code&gt; ，来编写对象。流的文件位置指示符将提前写入的字符数。</target>
        </trans-unit>
        <trans-unit id="c8447596ae9170966e015adf6c315155e2268bda" translate="yes" xml:space="preserve">
          <source>Writing to the character array accessed through &lt;code&gt;c_str()&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">写入通过 &lt;code&gt;c_str()&lt;/code&gt; 访问的字符数组是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="93cad4f773cccfbb33c80bc8546680efa75c09a4" translate="yes" xml:space="preserve">
          <source>X and X</source>
          <target state="translated">X和X</target>
        </trans-unit>
        <trans-unit id="d60cdb3a38da8a130cf91abef198ed0c8df65943" translate="yes" xml:space="preserve">
          <source>X and X appears before B in the Single Total Order</source>
          <target state="translated">X和X出现在单笔总订单的B之前。</target>
        </trans-unit>
        <trans-unit id="2f3f27dde1e0deeab004667545a65bef35394ab9" translate="yes" xml:space="preserve">
          <source>X argument</source>
          <target state="translated">X参数</target>
        </trans-unit>
        <trans-unit id="4ca65c470ec6016fed78ab6aef93dd257702b23f" translate="yes" xml:space="preserve">
          <source>X, X</source>
          <target state="translated">X,X</target>
        </trans-unit>
        <trans-unit id="6db6535836e6c904498ebb911985cfb1ab6cbadf" translate="yes" xml:space="preserve">
          <source>X, Y is</source>
          <target state="translated">X、Y是</target>
        </trans-unit>
        <trans-unit id="9ea35756029154e9210bcca0b65c206107747ec2" translate="yes" xml:space="preserve">
          <source>X, and X</source>
          <target state="translated">X,和X</target>
        </trans-unit>
        <trans-unit id="565e6a618c216015d885283111a97727e2c3f173" translate="yes" xml:space="preserve">
          <source>X, and X is</source>
          <target state="translated">X,而X是</target>
        </trans-unit>
        <trans-unit id="6ba655c53b7c6f7ad109ea6e30e446c19a1740b7" translate="yes" xml:space="preserve">
          <source>Y argument</source>
          <target state="translated">Y论点</target>
        </trans-unit>
        <trans-unit id="ba12622aee8e1cee306fb2ae1705d34dc28d369e" translate="yes" xml:space="preserve">
          <source>Y is sequenced-before F in thread B</source>
          <target state="translated">Y在线程B中的F之前排序。</target>
        </trans-unit>
        <trans-unit id="ed1a905ea4a6fcc0ca7ba73cce1620307e6d6ffa" translate="yes" xml:space="preserve">
          <source>Y is sequenced-before FB in thread B</source>
          <target state="translated">Y在B线程的FB之前排序</target>
        </trans-unit>
        <trans-unit id="3850869b7a202e66b87556b87c42f6e3bad33150" translate="yes" xml:space="preserve">
          <source>Y reads the value written by X (or by the &lt;a href=&quot;memory_order&quot;&gt;release sequence headed by X&lt;/a&gt;)</source>
          <target state="translated">Y读取X写入的值（或&lt;a href=&quot;memory_order&quot;&gt;X开头&lt;/a&gt;的释放序列）</target>
        </trans-unit>
        <trans-unit id="1038aa0966244ed387fbcfee4940af4843ba1a40" translate="yes" xml:space="preserve">
          <source>Y reads the value written by X (or the value would be written by &lt;a href=&quot;memory_order&quot;&gt;release sequence headed by X&lt;/a&gt; if X were a release operation)</source>
          <target state="translated">Y读取X写入的值（如果X是释放操作，则该值将以X开头的&lt;a href=&quot;memory_order&quot;&gt;释放序列&lt;/a&gt;写入）</target>
        </trans-unit>
        <trans-unit id="4d77689f2569037f676a633b110bf28151defd7c" translate="yes" xml:space="preserve">
          <source>Y, and Y is</source>
          <target state="translated">Y,而Y是</target>
        </trans-unit>
        <trans-unit id="879e32326c5217968ac8e3a14e4a8a5214957264" translate="yes" xml:space="preserve">
          <source>Year</source>
          <target state="translated">Year</target>
        </trans-unit>
        <trans-unit id="869ef4891ca6fa4509dc520e3f6640c9b0cfae4a" translate="yes" xml:space="preserve">
          <source>Year, day, month</source>
          <target state="translated">年、日、月</target>
        </trans-unit>
        <trans-unit id="915f26f629fd3d6f51a4b7d5990e0b50d4471157" translate="yes" xml:space="preserve">
          <source>Year, month, day</source>
          <target state="translated">年、月、日</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="f1e34b1b0b0addb32d44f2528bede851abf77e03" translate="yes" xml:space="preserve">
          <source>Yes, except erased element(s)</source>
          <target state="translated">是,但被删除的元素除外</target>
        </trans-unit>
        <trans-unit id="7ed1f0e98f8b97a0cbc079098f9b970f72dbe20e" translate="yes" xml:space="preserve">
          <source>Yield-expression returns a value to the caller and suspends the current coroutine: it is the common building block of resumable generator functions.</source>
          <target state="translated">Yield-expression向调用者返回一个值,并暂停当前的coroutine:它是可恢复生成函数的常见构件。</target>
        </trans-unit>
        <trans-unit id="1791a81aeb4f78d0ab4f9096c83089810fc43595" translate="yes" xml:space="preserve">
          <source>Yields &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; if for some &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;e == X::to_int_type(c)&lt;/code&gt; and &lt;code&gt;f == X::to_int_type(d)&lt;/code&gt;</source>
          <target state="translated">如果对于某些 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; ， &lt;code&gt;e == X::to_int_type(c)&lt;/code&gt; 和 &lt;code&gt;f == X::to_int_type(d)&lt;/code&gt; ，则产生 &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; d）</target>
        </trans-unit>
        <trans-unit id="729d384e3fcd3d72644a0c1418ba7a729b79ac57" translate="yes" xml:space="preserve">
          <source>ZERO WIDTH SPACE - ZERO WIDTH JOINER</source>
          <target state="translated">零宽度空间-零宽度连接器</target>
        </trans-unit>
        <trans-unit id="51c939bb7f5f0758dd76abfc0b3c05c623bebff7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal.</source>
          <target state="translated">如果 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 比较相等，则为零。</target>
        </trans-unit>
        <trans-unit id="917c36f59225ed77c40603a32141411ab5f9fea6" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;x&lt;/code&gt; is zero; otherwise, one plus the base-2 logarithm of &lt;code&gt;x&lt;/code&gt;, with any fractional part discarded.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为零，则为零；否则为零。否则，加上 &lt;code&gt;x&lt;/code&gt; 的以2为底的对数，并丢弃所有小数部分。</target>
        </trans-unit>
        <trans-unit id="0f17813fad92e667b30a4557d41d38bf185f1f8c" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;x&lt;/code&gt; is zero; otherwise, the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 为零，则为零；否则为零。否则，两个的最大积分乘方不大于 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="405ae0fba6c1904278eb371bc24b47d81b1d7d3c" translate="yes" xml:space="preserve">
          <source>Zero initialization is performed in the following situations:</source>
          <target state="translated">在以下情况下进行零初始化。</target>
        </trans-unit>
        <trans-unit id="a1be729d580f443d76655de63a066d43b5c754d5" translate="yes" xml:space="preserve">
          <source>Zero or more of the following:</source>
          <target state="translated">以下零项或多项:</target>
        </trans-unit>
        <trans-unit id="d00bedfb8c02a9e78a0c8655d079c8a74339369e" translate="yes" xml:space="preserve">
          <source>Zero otherwise</source>
          <target state="translated">否则为零</target>
        </trans-unit>
        <trans-unit id="ca77598d8983f14f3898f59c121fdcf1e9e18087" translate="yes" xml:space="preserve">
          <source>[-]d.ddd</source>
          <target state="translated">[-]d.ddd</target>
        </trans-unit>
        <trans-unit id="913e7afee46c7a822906ed5749ddbb4805cee7d2" translate="yes" xml:space="preserve">
          <source>[-]ddd.ddd</source>
          <target state="translated">[-]ddd.ddd</target>
        </trans-unit>
        <trans-unit id="8c2b29412829eefb22455e55f53e2c249d24e11a" translate="yes" xml:space="preserve">
          <source>[-]dddd</source>
          <target state="translated">[-]dddd</target>
        </trans-unit>
        <trans-unit id="c1734847a74561b4543b119ae934914f50b4cfb4" translate="yes" xml:space="preserve">
          <source>[-x3</source>
          <target state="translated">[-x3</target>
        </trans-unit>
        <trans-unit id="d750010a709171aa3f400cbe019efe556b93b506" translate="yes" xml:space="preserve">
          <source>[0,</source>
          <target state="translated">[0,</target>
        </trans-unit>
        <trans-unit id="e61dea886117af6d2ec7f9dcb7bd9a3411c6e61f" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;ranges::begin(E)&lt;/code&gt;, &lt;code&gt;ranges::end(E)&lt;/code&gt;) denotes a range, and</source>
          <target state="translated">[ &lt;code&gt;ranges::begin(E)&lt;/code&gt; ， &lt;code&gt;ranges::end(E)&lt;/code&gt; ）表示一个范围，并且</target>
        </trans-unit>
        <trans-unit id="228f7d207920fb84335fac5b2b06ed7b472ece9e" translate="yes" xml:space="preserve">
          <source>[deleted]</source>
          <target state="translated">[deleted]</target>
        </trans-unit>
        <trans-unit id="73a877ccfe464539ac89cb8083cf71234db18da5" translate="yes" xml:space="preserve">
          <source>[first,first)</source>
          <target state="translated">[first,first)</target>
        </trans-unit>
        <trans-unit id="7231a3611aa5bad8f818b0f7bb419a3d1200483d" translate="yes" xml:space="preserve">
          <source>[first,last)</source>
          <target state="translated">[first,last)</target>
        </trans-unit>
        <trans-unit id="2855c5627ea838aafc570baf3e8f5ddda039170b" translate="yes" xml:space="preserve">
          <source>[last,last)</source>
          <target state="translated">[last,last)</target>
        </trans-unit>
        <trans-unit id="51f320773f671463a4338fa2cd7489e0a7d0a19d" translate="yes" xml:space="preserve">
          <source>[nothrow-]swappable traits</source>
          <target state="translated">[nothrow-]可互换的特征</target>
        </trans-unit>
        <trans-unit id="2706c6dc283ec831e2ea7c5771adc61d0195a5e5" translate="yes" xml:space="preserve">
          <source>[static]</source>
          <target state="translated">[static]</target>
        </trans-unit>
        <trans-unit id="44fed6b6252fc5fda7cc744792424bdd0b7b1020" translate="yes" xml:space="preserve">
          <source>[static](C++11)</source>
          <target state="translated">[static](C++11)</target>
        </trans-unit>
        <trans-unit id="e4b4e5b6ec02f085b66944f0e3a63cac3c002038" translate="yes" xml:space="preserve">
          <source>[static](C++17)</source>
          <target state="translated">[static](C++17)</target>
        </trans-unit>
        <trans-unit id="0352562c44ca57a96c86a8ce2c63b508390a988b" translate="yes" xml:space="preserve">
          <source>[static](C++20)</source>
          <target state="translated">[static](C++20)</target>
        </trans-unit>
        <trans-unit id="85894ee8b74956e4f1ad040534bebb4a92408ba9" translate="yes" xml:space="preserve">
          <source>[static](optional)</source>
          <target state="translated">[static](optional)</target>
        </trans-unit>
        <trans-unit id="e621ceda2c534b69cb910cae3059eb9ff125986d" translate="yes" xml:space="preserve">
          <source>[virtual]</source>
          <target state="translated">[virtual]</target>
        </trans-unit>
        <trans-unit id="986bbf2f9f0c3cbbc6546d685166748b60c20798" translate="yes" xml:space="preserve">
          <source>[virtual](C++11)</source>
          <target state="translated">[virtual](C++11)</target>
        </trans-unit>
        <trans-unit id="8af4f9130ab9142006b068ed0c1ed35271abd3b0" translate="yes" xml:space="preserve">
          <source>[virtual](implicitly declared)</source>
          <target state="translated">[虚拟]（隐式声明）</target>
        </trans-unit>
        <trans-unit id="a80e5ea0695ed7f04f7f2926fafe2f96aa4dcb23" translate="yes" xml:space="preserve">
          <source>[x2</source>
          <target state="translated">[x2</target>
        </trans-unit>
        <trans-unit id="36886f5ee53771548cf5c86e4853a8dcf06d3e14" translate="yes" xml:space="preserve">
          <source>] radians, is returned.</source>
          <target state="translated">]弧度，返回。</target>
        </trans-unit>
        <trans-unit id="12ec352745ee599586db13a925319fe87a988295" translate="yes" xml:space="preserve">
          <source>], is returned.</source>
          <target state="translated">]，返回。</target>
        </trans-unit>
        <trans-unit id="056353e23af4506e74d7003cb38640abbea6a449" translate="yes" xml:space="preserve">
          <source>]1/2</source>
          <target state="translated">]1/2</target>
        </trans-unit>
        <trans-unit id="2543ff7b78f94174e33e9adeb84f297edc54fffa" translate="yes" xml:space="preserve">
          <source>_1, _2, _3, _4, ...</source>
          <target state="translated">_1，_2，_3，_4，...</target>
        </trans-unit>
        <trans-unit id="5903c0497b4b6110dd3051a9b31ef948bae78c64" translate="yes" xml:space="preserve">
          <source>_Exit</source>
          <target state="translated">_Exit</target>
        </trans-unit>
        <trans-unit id="a86d3649d1b2b72954d70aa40f94f98858c527ba" translate="yes" xml:space="preserve">
          <source>_IOFBF_IOLBF_IONBF</source>
          <target state="translated">_IOFBF_IOLBF_IONBF</target>
        </trans-unit>
        <trans-unit id="1b22c1d687dc7c54339d14d0aa2284796291aec8" translate="yes" xml:space="preserve">
          <source>__DATE__</source>
          <target state="translated">__DATE__</target>
        </trans-unit>
        <trans-unit id="9d5d8995523b8b8951428baa81ea663ff0bd2c77" translate="yes" xml:space="preserve">
          <source>__FILE__</source>
          <target state="translated">__FILE__</target>
        </trans-unit>
        <trans-unit id="a51b95694c81c92580bff6f580f8e200ecf86661" translate="yes" xml:space="preserve">
          <source>__LINE__</source>
          <target state="translated">__LINE__</target>
        </trans-unit>
        <trans-unit id="ce0bc0efbd8965b4d82a11aa07f4fab94777d3af" translate="yes" xml:space="preserve">
          <source>__STDCPP_DEFAULT_NEW_ALIGNMENT__</source>
          <target state="translated">__STDCPP_DEFAULT_NEW_ALIGNMENT__</target>
        </trans-unit>
        <trans-unit id="db9a3eaebbc58b7b2dff63e6d1078194a02871a4" translate="yes" xml:space="preserve">
          <source>__STDCPP_STRICT_POINTER_SAFETY__</source>
          <target state="translated">__STDCPP_STRICT_POINTER_SAFETY__</target>
        </trans-unit>
        <trans-unit id="950ee9617b60ace35791cfba67c4eda35d86e1d5" translate="yes" xml:space="preserve">
          <source>__STDCPP_THREADS__</source>
          <target state="translated">__STDCPP_THREADS__</target>
        </trans-unit>
        <trans-unit id="51f3c9479afc9737ac0812162dcb10cc18fbbd51" translate="yes" xml:space="preserve">
          <source>__STDC_HOSTED__</source>
          <target state="translated">__STDC_HOSTED__</target>
        </trans-unit>
        <trans-unit id="aa16038a596c275e6fffc69644dbad7ec1a3ceb3" translate="yes" xml:space="preserve">
          <source>__STDC_ISO_10646__</source>
          <target state="translated">__STDC_ISO_10646__</target>
        </trans-unit>
        <trans-unit id="230648d096a182990dad2c93fa8e616a0bed8465" translate="yes" xml:space="preserve">
          <source>__STDC_MB_MIGHT_NEQ_WC__</source>
          <target state="translated">__STDC_MB_MIGHT_NEQ_WC__</target>
        </trans-unit>
        <trans-unit id="aec164fb4da1e304eadad72b50ba5910b1144c03" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_16__</source>
          <target state="translated">__STDC_UTF_16__</target>
        </trans-unit>
        <trans-unit id="92432151980d707704b3ddfa392fde3ab589eb6c" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_32__</source>
          <target state="translated">__STDC_UTF_32__</target>
        </trans-unit>
        <trans-unit id="04202f9ce8c923e1e74ba2bfa78f2696041116d2" translate="yes" xml:space="preserve">
          <source>__STDC_VERSION__</source>
          <target state="translated">__STDC_VERSION__</target>
        </trans-unit>
        <trans-unit id="e7fe05e43de55659e13d860cf51adc28583a4875" translate="yes" xml:space="preserve">
          <source>__STDC__</source>
          <target state="translated">__STDC__</target>
        </trans-unit>
        <trans-unit id="cf716a68ef036dac529946b2640a330f562725fe" translate="yes" xml:space="preserve">
          <source>__TIME__</source>
          <target state="translated">__TIME__</target>
        </trans-unit>
        <trans-unit id="9c3e29639fd2bfaa4db627da53f4d56eac9f0ec0" translate="yes" xml:space="preserve">
          <source>__alignas_is_defined</source>
          <target state="translated">__alignas_is_defined</target>
        </trans-unit>
        <trans-unit id="d950e8ee18472fe83432e8178dd5392fac322513" translate="yes" xml:space="preserve">
          <source>__bool_true_false_are_defined</source>
          <target state="translated">__bool_true_false_are_defined</target>
        </trans-unit>
        <trans-unit id="a6268e3a2fc1725738e330bb09c9305b72ece231" translate="yes" xml:space="preserve">
          <source>__cplusplus</source>
          <target state="translated">__cplusplus</target>
        </trans-unit>
        <trans-unit id="e03702be2b6d9f308bc474cdb111403f31d2ea87" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_bases</source>
          <target state="translated">__cpp_aggregate_bases</target>
        </trans-unit>
        <trans-unit id="78f7eebcfee8baee7f506621f7ceff180ebb38c2" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_nsdmi</source>
          <target state="translated">__cpp_aggregate_nsdmi</target>
        </trans-unit>
        <trans-unit id="aecf58d673edcb66d050d3e2e7eba5a0afe4185c" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_paren_init</source>
          <target state="translated">__cpp_aggregate_paren_init</target>
        </trans-unit>
        <trans-unit id="4db17205b03376efcf08532704df0a94b80ff2e1" translate="yes" xml:space="preserve">
          <source>__cpp_alias_templates</source>
          <target state="translated">__cpp_alias_templates</target>
        </trans-unit>
        <trans-unit id="1b50ffd26242db4d6bb36e8a073d57b42af92dbe" translate="yes" xml:space="preserve">
          <source>__cpp_aligned_new</source>
          <target state="translated">__cpp_aligned_new</target>
        </trans-unit>
        <trans-unit id="27d2797bf877b1368535c5fbc7789bf8e7a43d75" translate="yes" xml:space="preserve">
          <source>__cpp_attributes</source>
          <target state="translated">__cpp_attributes</target>
        </trans-unit>
        <trans-unit id="fa07d30cba0187822a54da7812f67ef73fb0b29b" translate="yes" xml:space="preserve">
          <source>__cpp_binary_literals</source>
          <target state="translated">__cpp_binary_literals</target>
        </trans-unit>
        <trans-unit id="9233221aaacde95fdd55b38eb0f389324843a986" translate="yes" xml:space="preserve">
          <source>__cpp_capture_star_this</source>
          <target state="translated">__cpp_capture_star_this</target>
        </trans-unit>
        <trans-unit id="fbff2a2d3bc0732868b008428dd2e17daf86c9d1" translate="yes" xml:space="preserve">
          <source>__cpp_char8_t</source>
          <target state="translated">__cpp_char8_t</target>
        </trans-unit>
        <trans-unit id="35879cf6edddadc7f07576b594f812ccd01e0e28" translate="yes" xml:space="preserve">
          <source>__cpp_conditional_explicit</source>
          <target state="translated">__cpp_conditional_explicit</target>
        </trans-unit>
        <trans-unit id="6554a18ee88c8522382d28ab36f8ebd7e175fe13" translate="yes" xml:space="preserve">
          <source>__cpp_constexpr</source>
          <target state="translated">__cpp_constexpr</target>
        </trans-unit>
        <trans-unit id="e1c9cd84aa5ce04eef2027ea160ca3290b7ad000" translate="yes" xml:space="preserve">
          <source>__cpp_coroutines</source>
          <target state="translated">__cpp_coroutines</target>
        </trans-unit>
        <trans-unit id="1a2e5b6980d3ec352ab8610b6aebe0331f7c85de" translate="yes" xml:space="preserve">
          <source>__cpp_decltype</source>
          <target state="translated">__cpp_decltype</target>
        </trans-unit>
        <trans-unit id="30e058b311be2115aab20cb7ab797af4bf73322c" translate="yes" xml:space="preserve">
          <source>__cpp_decltype_auto</source>
          <target state="translated">__cpp_decltype_auto</target>
        </trans-unit>
        <trans-unit id="242a749b73f040bf68fa933b9175781fd85d21c1" translate="yes" xml:space="preserve">
          <source>__cpp_deduction_guides</source>
          <target state="translated">__cpp_deduction_guides</target>
        </trans-unit>
        <trans-unit id="3a8bdd7fb017e4f5b12dd8b2fab50c0f9a716657" translate="yes" xml:space="preserve">
          <source>__cpp_delegating_constructors</source>
          <target state="translated">__cpp_delegating_constructors</target>
        </trans-unit>
        <trans-unit id="975250ed39319bc10f0e4f6ba32b904cf175257c" translate="yes" xml:space="preserve">
          <source>__cpp_enumerator_attributes</source>
          <target state="translated">__cpp_enumerator_attributes</target>
        </trans-unit>
        <trans-unit id="3b5c1d2ec9a03cdd0631a101d55a030f176f3d74" translate="yes" xml:space="preserve">
          <source>__cpp_fold_expressions</source>
          <target state="translated">__cpp_fold_expressions</target>
        </trans-unit>
        <trans-unit id="dd54e558a55e90a31a278a30b8a17bd0470a27e5" translate="yes" xml:space="preserve">
          <source>__cpp_generic_lambdas</source>
          <target state="translated">__cpp_generic_lambdas</target>
        </trans-unit>
        <trans-unit id="5851aabfab46bf1cf3f38d2a662260f69f39fefc" translate="yes" xml:space="preserve">
          <source>__cpp_guaranteed_copy_elision</source>
          <target state="translated">__cpp_guaranteed_copy_elision</target>
        </trans-unit>
        <trans-unit id="64dc522012e8e37b94c68ea1e95e711e0d899c02" translate="yes" xml:space="preserve">
          <source>__cpp_hex_float</source>
          <target state="translated">__cpp_hex_float</target>
        </trans-unit>
        <trans-unit id="3817658cc0a09b582191a5b7ff9d3c12fb638b2d" translate="yes" xml:space="preserve">
          <source>__cpp_if_constexpr</source>
          <target state="translated">__cpp_if_constexpr</target>
        </trans-unit>
        <trans-unit id="01e50fa24457c5e9436a8e8e470f75ec87f89e94" translate="yes" xml:space="preserve">
          <source>__cpp_impl_destroying_delete</source>
          <target state="translated">__cpp_impl_destroying_delete</target>
        </trans-unit>
        <trans-unit id="10f562ee8727c9aeeefccee7e22065b234af8837" translate="yes" xml:space="preserve">
          <source>__cpp_impl_three_way_comparison</source>
          <target state="translated">__cpp_impl_three_way_comparison</target>
        </trans-unit>
        <trans-unit id="8372b211ab7aa3d2db5ef6dbe4bf9e84d46edd52" translate="yes" xml:space="preserve">
          <source>__cpp_inheriting_constructors</source>
          <target state="translated">__cpp_inheriting_constructors</target>
        </trans-unit>
        <trans-unit id="8db78a428ed6164ef434f29d445b397d48025bd3" translate="yes" xml:space="preserve">
          <source>__cpp_init_captures</source>
          <target state="translated">__cpp_init_captures</target>
        </trans-unit>
        <trans-unit id="3331bad3edb7735ec64c6916056cfc10590dcf69" translate="yes" xml:space="preserve">
          <source>__cpp_initializer_lists</source>
          <target state="translated">__cpp_initializer_lists</target>
        </trans-unit>
        <trans-unit id="81e37cead058df9398dca1e6d13208a976c4012c" translate="yes" xml:space="preserve">
          <source>__cpp_inline_variables</source>
          <target state="translated">__cpp_inline_variables</target>
        </trans-unit>
        <trans-unit id="3c68286ccf869158575094937b8b2a98ffb48599" translate="yes" xml:space="preserve">
          <source>__cpp_lambdas</source>
          <target state="translated">__cpp_lambdas</target>
        </trans-unit>
        <trans-unit id="2590a0ceb1649ffba013a25521809a21cd1284de" translate="yes" xml:space="preserve">
          <source>__cpp_namespace_attributes</source>
          <target state="translated">__cpp_namespace_attributes</target>
        </trans-unit>
        <trans-unit id="30cc60a82cc1d4477a2e07c1fa7a6a64cc1023c3" translate="yes" xml:space="preserve">
          <source>__cpp_noexcept_function_type</source>
          <target state="translated">__cpp_noexcept_function_type</target>
        </trans-unit>
        <trans-unit id="2593d2642e9db46e71f999b1bc148024d6d0b831" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_args</source>
          <target state="translated">__cpp_nontype_template_args</target>
        </trans-unit>
        <trans-unit id="1892415e299d418abcb2ce3608af04f19ac199e1" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_parameter_auto</source>
          <target state="translated">__cpp_nontype_template_parameter_auto</target>
        </trans-unit>
        <trans-unit id="8e2497a317030abf3388ed8fcdc0f581460fd74b" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_parameter_class</source>
          <target state="translated">__cpp_nontype_template_parameter_class</target>
        </trans-unit>
        <trans-unit id="6f298ec98a281e895e57730ee42e4b685bf1d6e1" translate="yes" xml:space="preserve">
          <source>__cpp_nsdmi</source>
          <target state="translated">__cpp_nsdmi</target>
        </trans-unit>
        <trans-unit id="7844fe22ff8583f864600cf24c8acf071a07a268" translate="yes" xml:space="preserve">
          <source>__cpp_range_based_for</source>
          <target state="translated">__cpp_range_based_for</target>
        </trans-unit>
        <trans-unit id="e94a403428d4ea97b6f263dbcb0874c541f05fc8" translate="yes" xml:space="preserve">
          <source>__cpp_raw_strings</source>
          <target state="translated">__cpp_raw_strings</target>
        </trans-unit>
        <trans-unit id="2a807128a5985f4aedc323c209f0b26cf031ddc5" translate="yes" xml:space="preserve">
          <source>__cpp_ref_qualifiers</source>
          <target state="translated">__cpp_ref_qualifiers</target>
        </trans-unit>
        <trans-unit id="ec7f8108d8bd7c3189219118c4b92ebae110f376" translate="yes" xml:space="preserve">
          <source>__cpp_return_type_deduction</source>
          <target state="translated">__cpp_return_type_deduction</target>
        </trans-unit>
        <trans-unit id="a27448bb794e05840712bcbb343a4cbf12fadae2" translate="yes" xml:space="preserve">
          <source>__cpp_rvalue_references</source>
          <target state="translated">__cpp_rvalue_references</target>
        </trans-unit>
        <trans-unit id="28d6e14e6e0b8b130a165866cca9649aa7e9d864" translate="yes" xml:space="preserve">
          <source>__cpp_sized_deallocation</source>
          <target state="translated">__cpp_sized_deallocation</target>
        </trans-unit>
        <trans-unit id="d77473f1a619fc342dfc9123063a318297214d20" translate="yes" xml:space="preserve">
          <source>__cpp_static_assert</source>
          <target state="translated">__cpp_static_assert</target>
        </trans-unit>
        <trans-unit id="af80adf8b09bcfceb7e7134decd3d99ebd88c373" translate="yes" xml:space="preserve">
          <source>__cpp_structured_bindings</source>
          <target state="translated">__cpp_structured_bindings</target>
        </trans-unit>
        <trans-unit id="5456a2323fecac083d969b4421be5b3b5e785149" translate="yes" xml:space="preserve">
          <source>__cpp_template_template_args</source>
          <target state="translated">__cpp_template_template_args</target>
        </trans-unit>
        <trans-unit id="ddc5e77386a83826283ed12a4b5d3455f2275f1a" translate="yes" xml:space="preserve">
          <source>__cpp_threadsafe_static_init</source>
          <target state="translated">__cpp_threadsafe_static_init</target>
        </trans-unit>
        <trans-unit id="a51600d8c1a1f10a16f1e43b746d8821a1ba5bff" translate="yes" xml:space="preserve">
          <source>__cpp_unicode_characters</source>
          <target state="translated">__cpp_unicode_characters</target>
        </trans-unit>
        <trans-unit id="696ac6453d6507dd7871ba65e03fe52e19383ef5" translate="yes" xml:space="preserve">
          <source>__cpp_unicode_literals</source>
          <target state="translated">__cpp_unicode_literals</target>
        </trans-unit>
        <trans-unit id="fcfb6a809b1f0636cfdcac8dcaf0a56faf741fe9" translate="yes" xml:space="preserve">
          <source>__cpp_user_defined_literals</source>
          <target state="translated">__cpp_user_defined_literals</target>
        </trans-unit>
        <trans-unit id="793fd52dc655ccacc0d8fa1b3bf368e5266577b4" translate="yes" xml:space="preserve">
          <source>__cpp_variable_templates</source>
          <target state="translated">__cpp_variable_templates</target>
        </trans-unit>
        <trans-unit id="b2c1a1181d35bf405e3ead748a7662168e324024" translate="yes" xml:space="preserve">
          <source>__cpp_variadic_templates</source>
          <target state="translated">__cpp_variadic_templates</target>
        </trans-unit>
        <trans-unit id="423eb61df1fcdbb8fb8c6511db90aa6fb0318eaf" translate="yes" xml:space="preserve">
          <source>__cpp_variadic_using</source>
          <target state="translated">__cpp_variadic_using</target>
        </trans-unit>
        <trans-unit id="d8db95cc58ad2925bc93429910aec8cf2d80ad01" translate="yes" xml:space="preserve">
          <source>__func__</source>
          <target state="translated">__func__</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="d66612ccc3a3c60bbf9be396b2e583b9ad6f732e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../language/dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt; expression</source>
          <target state="translated">一个&lt;a href=&quot;../../language/dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; 的&lt;/a&gt;表达</target>
        </trans-unit>
        <trans-unit id="578b0d09cf884cabb2256541be565e3232f4a2d1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../language/throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; expression</source>
          <target state="translated">一个&lt;a href=&quot;../../language/throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;表达</target>
        </trans-unit>
        <trans-unit id="0c35fd85853bd90c9dea0e943c9e3e345e596a8c" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; that accepts every possible alternative from every variant</source>
          <target state="translated">接受每个变体的所有可能替代方法的&lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f547d6f47fe102ed4af5089aaf331e46cb4bd5e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../language/lambda&quot;&gt;closure&lt;/a&gt; type</source>
          <target state="translated">一个&lt;a href=&quot;../language/lambda&quot;&gt;闭合&lt;/a&gt;型</target>
        </trans-unit>
        <trans-unit id="e0406f8e858cd057dce3f1a1bd186c9b49e3cd51" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;pseudo-destructor call&lt;/a&gt; (if &lt;code&gt;It&lt;/code&gt; is a scalar type)</source>
          <target state="translated">一个&lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;伪析构函数调用&lt;/a&gt;（如果 &lt;code&gt;It&lt;/code&gt; 是一个标量型）</target>
        </trans-unit>
        <trans-unit id="2f2aa4051bfd7ae365b4f4b11cedb58bbfd66b3e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; whose result type is convertible to &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt&amp;gt;::difference_type&lt;/code&gt;</source>
          <target state="translated">一个&lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator，&lt;/a&gt;其结果类型可转换为 &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt&amp;gt;::difference_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f35df8d2006030e7d4d979822b8a81b4761ea9f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of a sequence generated by repeatedly incrementing an initial value</source>
          <target state="translated">一个&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;，该视图包含通过重复递增初始值而生成的序列</target>
        </trans-unit>
        <trans-unit id="f1b66b4d9a0ae57bf6f377005ad0ae6842f473ed" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the first N elements of another &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;组成的另一个所述第一N个元素的&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae981f6c70dcb78f089b85eeb651ce9e721b682b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the sequence obtained from flattening a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;s&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;由来自平坦化获得的序列的&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; 小号&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e20442d4936a5775a6caf427d491901e50216ebf" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of a sequence that applies a transformation function to each element</source>
          <target state="translated">将转换函数应用于每个元素的序列的&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="289a5f74d80c8aa744c90c4ee3868ed8609c9f49" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;一些其他的元素&lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a94750304f2970083f4213aac2cf32daebafda1d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; over the subranges obtained from splitting another &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; using a delimiter</source>
          <target state="translated">一&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;了从分裂的另一个获得的子范围&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;使用的分隔符</target>
        </trans-unit>
        <trans-unit id="3a4653cdeeb9369cc880c44c330b4bacc547ec37" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that consists of the elements of a &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that satisfies a predicate</source>
          <target state="translated">一个由满足谓词的&lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;的元素组成的&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c2fbed5ca96d4b2858696b97f8e59367cd9ca66" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that contains a single element of a specified value</source>
          <target state="translated">一个包含指定值的单个元素的&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c7f3a3db304dcf5be7bc978bb2552c12c8bc06fb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;包含的所有元素&lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af11d84750e4dccfceeeab50c1f40114755c03a1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that iterates over the elements of another bidirectional view in reverse order</source>
          <target state="translated">一个&lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;，超过另一双向视图的以相反的顺序的要素迭代</target>
        </trans-unit>
        <trans-unit id="e8c8ad0f2aa5b2688c79e49a80f74556ff5bb1c3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../types/is_scalar&quot;&gt;scalar type&lt;/a&gt;;</source>
          <target state="translated">一个&lt;a href=&quot;../types/is_scalar&quot;&gt;标量类型&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="c5f1f7ebf1a60286c3263705f1ff2699892ba31a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; that establishes an ordering relation</source>
          <target state="translated">建立排序关系的&lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b54276a912036a81a33307973d33e286dfbef1ac" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;bit_field&quot;&gt;&lt;i&gt;bit field&lt;/i&gt;&lt;/a&gt; type can be converted to &lt;code&gt;int&lt;/code&gt; if it can represent entire value range of the bit field, otherwise to &lt;code&gt;unsigned int&lt;/code&gt; if it can represent entire value range of the bit field, otherwise no integral promotions apply;</source>
          <target state="translated">如果&lt;a href=&quot;bit_field&quot;&gt;&lt;i&gt;位字段&lt;/i&gt;&lt;/a&gt;类型可以表示位字段的整个值范围，则可以将其转换为 &lt;code&gt;int&lt;/code&gt; ;如果可以表示位字段的整个值范围，则可以将其转换为 &lt;code&gt;unsigned int&lt;/code&gt; ，否则不应用整数提升；</target>
        </trans-unit>
        <trans-unit id="04be27008e83afb2d331f92d72c2fab2182c7c06" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; name, such as &lt;code&gt;operator bool&lt;/code&gt;;</source>
          <target state="translated">一个&lt;a href=&quot;cast_operator&quot;&gt;用户定义的转换函数&lt;/a&gt;的名称，如 &lt;code&gt;operator bool&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="842b9bb73f31c7a70a7a8e8933647e7f312f7d30" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;class&quot;&gt;class declaration&lt;/a&gt;. The class name declared becomes a template name.</source>
          <target state="translated">一&lt;a href=&quot;class&quot;&gt;类声明&lt;/a&gt;。声明的类名称将成为模板名称。</target>
        </trans-unit>
        <trans-unit id="58329cef5c48b9dd6d75ade29a0076bc7230f05a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;class#Member_specification&quot;&gt;class member declaration&lt;/a&gt;;</source>
          <target state="translated">一&lt;a href=&quot;class#Member_specification&quot;&gt;类成员声明&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="197dcdb99acb57525f9c2a6fe89a245471fd8142" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;contextually converted constant expression of type &lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;类型的上下文转换常量表达式</target>
        </trans-unit>
        <trans-unit id="b40006546d705539bc635f3175ea4d35431ac2da" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints&quot;&gt;constraint expression&lt;/a&gt; which restricts the template parameters accepted by this function template</source>
          <target state="translated">一个&lt;a href=&quot;constraints&quot;&gt;约束表达式&lt;/a&gt;其限制由该函数模板接受模板参数</target>
        </trans-unit>
        <trans-unit id="dbc4d6e8690db53ad192b32cd88e3433f51c72d3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints&quot;&gt;requires-expression&lt;/a&gt;, such as &lt;code&gt;requires (T i) { typename T::type; }&lt;/code&gt;;</source>
          <target state="translated">一个&lt;a href=&quot;constraints&quot;&gt;require-expression&lt;/a&gt;，例如 &lt;code&gt;requires (T i) { typename T::type; }&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="6a7178c89e852f09b520cb3d8d0a0704888c1d34" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints#Concepts&quot;&gt;concept&lt;/a&gt; name, optionally qualified, optionally followed by a template argument list enclosed in &amp;lt;&amp;gt;</source>
          <target state="translated">一个&lt;a href=&quot;constraints#Concepts&quot;&gt;概念&lt;/a&gt;名称，可以选择使用限定名称，并可以选择后跟&amp;lt;&amp;gt;中的模板参数列表</target>
        </trans-unit>
        <trans-unit id="e54b0edc591fc30ea27121f4b241249a88d6dd05" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a named variable, whose type is the type of the element of the sequence represented by range_expression, or a reference to that type. Often uses the &lt;a href=&quot;auto&quot;&gt;auto specifier&lt;/a&gt; for automatic type deduction</source>
          <target state="translated">命名变量的&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;，其类型是range_expression表示的序列元素的类型，或对该类型的引用。通常将&lt;a href=&quot;auto&quot;&gt;自动说明符&lt;/a&gt;用于自动类型推导</target>
        </trans-unit>
        <trans-unit id="feba1f8215a9e5044f736d79557f6d6af77814ce" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a single variable with a brace-or-equals &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt;. the initializer is evaluated before each iteration, and if the value of the declared variable converts to &lt;code&gt;false&lt;/code&gt;, the loop is exited.</source>
          <target state="translated">一个&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;单个变量与一支柱或-等于&lt;a href=&quot;initialization&quot;&gt;初始值设定&lt;/a&gt;。初始化程序在每次迭代之前进行评估，如果声明的变量的值转换为 &lt;code&gt;false&lt;/code&gt; ，则退出循环。</target>
        </trans-unit>
        <trans-unit id="9b8e7399060c9f5d9013f6aa031f2daeaf247245" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a variable. The declared variable name becomes a template name.</source>
          <target state="translated">变量的&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;。声明的变量名称将成为模板名称。</target>
        </trans-unit>
        <trans-unit id="0d19b02053245fd658744be05acb66f6795dfec5" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a loop counter variable with initializer, but it may declare arbitrary many variables</source>
          <target state="translated">一个&lt;a href=&quot;declarations&quot;&gt;简单的声明&lt;/a&gt;，通常是带有初始化程序的循环计数器变量的声明，但它可以声明任意多个变量</target>
        </trans-unit>
        <trans-unit id="c20d095ecceecc0d92c5b636f980edf3d560c27f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or be a &lt;a href=&quot;structured_binding&quot;&gt;structured binding declaration&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;declarations&quot;&gt;简单的声明&lt;/a&gt;，通常是带有初始化程序的变量声明，但它可以声明任意多个变量，也可以是&lt;a href=&quot;structured_binding&quot;&gt;结构化的绑定声明&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c035c17095b570541b804043bd0d5c99497e6655" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or be a decomposition declaration</source>
          <target state="translated">一个&lt;a href=&quot;declarations&quot;&gt;简单的声明&lt;/a&gt;，通常是带有初始化程序的变量声明，但它可以声明任意多个变量，也可以是分解声明</target>
        </trans-unit>
        <trans-unit id="4b734860e87e75b35551beb9fadebdf9940d0be6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or structured bindings</source>
          <target state="translated">一个&lt;a href=&quot;declarations&quot;&gt;简单的声明&lt;/a&gt;，通常是带有初始化程序的变量声明，但它可以声明任意多个变量或结构化绑定</target>
        </trans-unit>
        <trans-unit id="2201d89e3d55486c60323b0565f06038ff02c6ab" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations#Simple_declaration&quot;&gt;simple declaration&lt;/a&gt; or &lt;a href=&quot;function#Function_definition&quot;&gt;function definition&lt;/a&gt; at namespace scope;</source>
          <target state="translated">在名称空间范围内的&lt;a href=&quot;declarations#Simple_declaration&quot;&gt;简单声明&lt;/a&gt;或&lt;a href=&quot;function#Function_definition&quot;&gt;函数定义&lt;/a&gt;；</target>
        </trans-unit>
        <trans-unit id="c8bcda74ea89e3702ab08c50656a296f15b010fd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;expressions#Literals&quot;&gt;literal&lt;/a&gt; (except for &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;), such as &lt;code&gt;42&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;nullptr&lt;/code&gt;;</source>
          <target state="translated">一个&lt;a href=&quot;expressions#Literals&quot;&gt;文字&lt;/a&gt;（除了&lt;a href=&quot;string_literal&quot;&gt;字符串文字&lt;/a&gt;），如 &lt;code&gt;42&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;nullptr&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="8446974ce0d221e5eb27350acb15252dd76acf23" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt;, e.g. &lt;code&gt;&lt;a href=&quot;../concepts/swappable&quot;&gt;Swappable&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object_v&lt;/a&gt;&amp;lt;Args&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt;, or any parenthesized expression</source>
          <target state="translated">一个&lt;a href=&quot;expressions#Primary_expressions&quot;&gt;一次式&lt;/a&gt;，例如 &lt;code&gt;&lt;a href=&quot;../concepts/swappable&quot;&gt;Swappable&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; ， &lt;code&gt;(&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object_v&lt;/a&gt;&amp;lt;Args&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; ，或任何括号表达式</target>
        </trans-unit>
        <trans-unit id="500e95ea5cc0ecd68e30742d9d61e3323034d850" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt; where the type of at least one parameter uses the placeholder &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; or &lt;code&gt;Concept auto&lt;/code&gt;: the template parameter list will have one invented parameter for each placeholder (see Abbreviated function templates below</source>
          <target state="translated">一种&lt;a href=&quot;function&quot;&gt;函数声明&lt;/a&gt;，其中至少一个参数的类型使用占位符&lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;或 &lt;code&gt;Concept auto&lt;/code&gt; ：模板参数列表将为每个占位符具有一个发明的参数（请参见下面的缩写函数模板）</target>
        </trans-unit>
        <trans-unit id="cf8f5a052390f7a051f82e9f9d21d32ee1c4a82a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;. The function name declared becomes a template name.</source>
          <target state="translated">一个&lt;a href=&quot;function&quot;&gt;函数声明&lt;/a&gt;。声明的函数名称将成为模板名称。</target>
        </trans-unit>
        <trans-unit id="c2f7755c6029f6a2726cac9e6db3c67772cad590" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;trailing return type&lt;/a&gt;,</source>
          <target state="translated">一个&lt;a href=&quot;function&quot;&gt;尾随返回类型&lt;/a&gt;，</target>
        </trans-unit>
        <trans-unit id="7edca23af0f84105b599f5a7b5d639d2bc955bbd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; in a &lt;a href=&quot;class#Member_specification&quot;&gt;class member declaration&lt;/a&gt; (including friend function declarations), outside of default arguments;</source>
          <target state="translated">一个&lt;a href=&quot;function#Parameter_list&quot;&gt;参数声明&lt;/a&gt;在一个&lt;a href=&quot;class#Member_specification&quot;&gt;类的成员声明&lt;/a&gt;（包括朋友函数声明），的默认参数之外;</target>
        </trans-unit>
        <trans-unit id="c118f25111af636da74b78a8eacfb1f5f20cd6c6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; of a &lt;a href=&quot;function&quot;&gt;declarator for a function or function template&lt;/a&gt; whose name is qualified, outside of default arguments;</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt;函数或函数模板&lt;/a&gt;的声明符的&lt;a href=&quot;function#Parameter_list&quot;&gt;参数声明&lt;/a&gt;，该函数或函数模板的名称合格，且不包含默认参数；</target>
        </trans-unit>
        <trans-unit id="f1184f488a359d5c1d1504b481c38dad94714e6b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; of a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; outside of default arguments;</source>
          <target state="translated">一个&lt;a href=&quot;function#Parameter_list&quot;&gt;参数声明&lt;/a&gt;一个的&lt;a href=&quot;lambda&quot;&gt;lambda表达式&lt;/a&gt;的默认参数之外;</target>
        </trans-unit>
        <trans-unit id="642baf6869f125ceaec67c589e398539c6e7f6ed" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; statement</source>
          <target state="translated">一个&lt;a href=&quot;goto&quot;&gt;跳转&lt;/a&gt;语句</target>
        </trans-unit>
        <trans-unit id="c907e534b1c94f336b7e2cf57a58189deb97fe5d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast&quot;&gt;standard conversion&lt;/a&gt;, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;, or &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; to type &lt;code&gt;T*&lt;/code&gt; or &lt;code&gt;T&amp;amp;&lt;/code&gt;, except when converting from the &lt;a href=&quot;../types/null&quot;&gt;null pointer constant&lt;/a&gt; or from a &lt;a href=&quot;pointer#Pointers_to_void&quot;&gt;pointer to void&lt;/a&gt;;</source>
          <target state="translated">一个&lt;a href=&quot;implicit_cast&quot;&gt;标准转换&lt;/a&gt;，&lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast的&lt;/a&gt;，或&lt;a href=&quot;static_cast&quot;&gt;的static_cast&lt;/a&gt;键入 &lt;code&gt;T*&lt;/code&gt; 或 &lt;code&gt;T&amp;amp;&lt;/code&gt; ,除了来自转换时&lt;a href=&quot;../types/null&quot;&gt;空指针常数&lt;/a&gt;或从一个&lt;a href=&quot;pointer#Pointers_to_void&quot;&gt;指针到空隙&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="ff7412a5c700e7e775fdf95f63af3f717686860b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast#Function_pointer_conversions&quot;&gt;function pointer conversion&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;implicit_cast#Function_pointer_conversions&quot;&gt;函数指针转换&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd862ebece74d9a647884bc1f7ae05595e84d3dd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;qualification conversion&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;合格的转换&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78294718f1c4d725f8f92854d2e7408626ebcedd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt;, such as &lt;code&gt;[](int x){ return x * x; }&lt;/code&gt;;</source>
          <target state="translated">一个&lt;a href=&quot;lambda&quot;&gt;lambda表达式&lt;/a&gt;，如 &lt;code&gt;[](int x){ return x * x; }&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="84b39eaf4ad707d4a4dec485e938308dab148b12" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;sequence of names and scope resolution operators &lt;code&gt;::&lt;/code&gt; &lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;name#Qualified_identifiers&quot;&gt;名称和范围解析运算符&lt;/a&gt;的序列 &lt;code&gt;::&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b9cefe53156bc46a61aba49ceb2bcf93ec727d8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; that supports attempted lock acquisition</source>
          <target state="translated">支持尝试获取锁的&lt;a href=&quot;named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2e74295624d6557dcdd2cc01e3b042f422a51a5" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; that establishes an ordering relation</source>
          <target state="translated">建立排序关系的&lt;a href=&quot;named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9fc14a958079406695f087786e7323e37febb5f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/clock&quot;&gt;Clock&lt;/a&gt; that does not throw exceptions</source>
          <target state="translated">不抛出异常的&lt;a href=&quot;named_req/clock&quot;&gt;时钟&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8f9bb45156d6a61bb73c330f242efbcd3e0fcea" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that for inputs with different values has a low probability of giving the same output</source>
          <target state="translated">一个具有不同值的输入的&lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt;给出相同输出的可能性很小</target>
        </trans-unit>
        <trans-unit id="ea59a46b0fa1e2f0e7670029ccdde75669c8d886" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that returns a value convertible to &lt;code&gt;bool&lt;/code&gt; for one argument without modifying it</source>
          <target state="translated">一个&lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt;，它返回一个参数可转换为 &lt;code&gt;bool&lt;/code&gt; 的值，而无需修改它</target>
        </trans-unit>
        <trans-unit id="b54d733aca75c1dec32ecb63027a79406e738ca0" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that returns a value convertible to &lt;code&gt;bool&lt;/code&gt; for two arguments without modifying them</source>
          <target state="translated">一个&lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt;，它返回两个参数的可转换为 &lt;code&gt;bool&lt;/code&gt; 的值，而无需修改它们</target>
        </trans-unit>
        <trans-unit id="60356dec3126ca424603f3524c2c59c0f4d0e0b3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt; that protects against data races and sequentially consistent synchronization</source>
          <target state="translated">可&lt;a href=&quot;named_req/lockable&quot;&gt;锁定&lt;/a&gt;，可防止数据争用和顺序一致的同步</target>
        </trans-unit>
        <trans-unit id="78a14075ec6e560d582c534d1ea3a8368ec01c15" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt; that supports timed lock acquisition</source>
          <target state="translated">支持定时锁获取的&lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2420df90cbe1b6e70248694fed79e630531d3b06" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/mutex&quot;&gt;Mutex&lt;/a&gt; that supports shared ownership semantics</source>
          <target state="translated">支持共享所有权语义的&lt;a href=&quot;named_req/mutex&quot;&gt;互斥&lt;/a&gt;体</target>
        </trans-unit>
        <trans-unit id="79e44acb7900ed6728581d5d8a9042f7e17f14c3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt; that transforms the output of another &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt;，可转换另一个&lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt;的输出</target>
        </trans-unit>
        <trans-unit id="e17ffa05e7a19b50f16c2ab3c2e4a41b726df14f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt; that protects against data races and sequentially consistent synchronization</source>
          <target state="translated">一个&lt;a href=&quot;named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt;，可防止数据争用和顺序一致的同步</target>
        </trans-unit>
        <trans-unit id="782471ed828c26fe873bde60284584c9dc102f92" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; that supports shared ownership semantics</source>
          <target state="translated">支持共享所有权语义的&lt;a href=&quot;named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d0093b4c5c45dc52be9aea4ff3837e330ec42b4" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;pointer&quot;&gt;pointer type&lt;/a&gt; (to object or to function);</source>
          <target state="translated">一个&lt;a href=&quot;pointer&quot;&gt;指针类型&lt;/a&gt;（以对象或功能）;</target>
        </trans-unit>
        <trans-unit id="ae90d6992e65874408f2a555b237871969050472" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;pointer to member type&lt;/a&gt; (to member object or to member function);</source>
          <target state="translated">&lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;指向成员类型&lt;/a&gt;的指针（指向成员对象或成员函数）；</target>
        </trans-unit>
        <trans-unit id="089b5759d49b3f3e3e05a4ed136cf4cb2e556331" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt;, if any name that appears to the left of &lt;code&gt;::&lt;/code&gt; is a</source>
          <target state="translated">一个&lt;a href=&quot;qualified_lookup&quot;&gt;合格的名字&lt;/a&gt;，如果出现在左侧的任何名称 &lt;code&gt;::&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="49c176e338afd9bd3c2793dd3aab24e8628e50cf" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt;, whose qualifier is the</source>
          <target state="translated">一个&lt;a href=&quot;qualified_lookup&quot;&gt;合格的名字&lt;/a&gt;，他的资格赛是</target>
        </trans-unit>
        <trans-unit id="906617abbba3f5b3395186a0beb57b664902cb46" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of a sequence generated by repeatedly incrementing an initial value</source>
          <target state="translated">一个&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;，该视图包含通过重复递增初始值而生成的序列</target>
        </trans-unit>
        <trans-unit id="584a08c6718b46b2d5bafb7362ec47101daa6021" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the first N elements of another &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;组成的另一个所述第一N个元素的&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87aecd3717fd037445fe9653742baf83e68058f8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the sequence obtained from flattening a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;s&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;由来自平坦化获得的序列的&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;的&lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; 小号&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a37c7d31d124ed7013e20399a2b928cc3860b13d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of a sequence that applies a transformation function to each element</source>
          <target state="translated">将转换函数应用于每个元素的序列的&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15d88520977b781a636bb3e5929f30daaf0cc794" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;一些其他的元素&lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a744d52e04d21449948de57a486e1984145b091d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; over the subranges obtained from splitting another &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; using a delimiter</source>
          <target state="translated">一&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;了从分裂的另一个获得的子范围&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;使用的分隔符</target>
        </trans-unit>
        <trans-unit id="ea2a829aa46d29fe3671781db0df1002a16f9f56" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that consists of the elements of a &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that satisfies a predicate</source>
          <target state="translated">一个由满足谓词的&lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;的元素组成的&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3270d31c1a13794c926d9de62c84a1561042e839" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that contains a single element of a specified value</source>
          <target state="translated">一个包含指定值的单个元素的&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ee5c0dac3dcdfb720bfc6c40ed3163b50c59d15" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;包含的所有元素&lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="569c82165b27db13ed5aaf3e2bd4eadc158f3978" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that iterates over the elements of another bidirectional view in reverse order</source>
          <target state="translated">一个&lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;，超过另一双向视图的以相反的顺序的要素迭代</target>
        </trans-unit>
        <trans-unit id="65f096eb23ce29a61ddace2d9bc3762ad47d07e2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;, such as &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt;;</source>
          <target state="translated">一个&lt;a href=&quot;string_literal&quot;&gt;字符串文字&lt;/a&gt;，如 &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="f91dfaeafd98f430989545790f287e35b5f20dc9" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;;</source>
          <target state="translated">一个&lt;a href=&quot;string_literal&quot;&gt;字符串字面量&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="191a5a89aef337a4a629add8645510717aab9bf2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;default argument of a type template parameter&lt;/a&gt;, or</source>
          <target state="translated">&lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;类型模板参数&lt;/a&gt;的默认参数，或者</target>
        </trans-unit>
        <trans-unit id="25def632dd3eeeb127af967f287d3c112d182fe9" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; name followed by its argument list, such as &lt;code&gt;MyTemplate&amp;lt;int&amp;gt;&lt;/code&gt;;</source>
          <target state="translated">一个&lt;a href=&quot;templates&quot;&gt;模板&lt;/a&gt;名称其次是它的参数列表，如 &lt;code&gt;MyTemplate&amp;lt;int&amp;gt;&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="552d64c54cb700af2ff2ba1111b75b5ffde66790" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; where either</source>
          <target state="translated">一个&lt;a href=&quot;templates#template-id&quot;&gt;模板id&lt;/a&gt;情形之一</target>
        </trans-unit>
        <trans-unit id="663fb41f0d766e7269a5347cbd45d461e373d362" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;try_catch&quot;&gt;catch-clause&lt;/a&gt; for an exception of type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;T&amp;amp;&lt;/code&gt;, or &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">一个&lt;a href=&quot;try_catch&quot;&gt;抓子句&lt;/a&gt;为类型的异常 &lt;code&gt;T&lt;/code&gt; ， &lt;code&gt;T&amp;amp;&lt;/code&gt; 或 &lt;code&gt;T*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="208a7da5d29804a28adcf5b9f0314d6ff0dd0293" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;try_catch&quot;&gt;尝试块&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e94d0262c8aa644df44502fbb216fd3ee7762db" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;user_literal&quot;&gt;user-defined literal operator&lt;/a&gt; name, such as &lt;code&gt;operator &quot;&quot; _km&lt;/code&gt;;</source>
          <target state="translated">一个&lt;a href=&quot;user_literal&quot;&gt;用户定义的字面操作者&lt;/a&gt;名称，如 &lt;code&gt;operator &quot;&quot; _km&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="99934e9b58a1babae9be931f9f2fea4fc18fc0ee" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">一个&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;包含的所有元素&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="316d511c8aa53b7526805d4e5457d26523ec3796" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; to insert &lt;code&gt;p&lt;/code&gt; into</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 将 &lt;code&gt;p&lt;/code&gt; 插入</target>
        </trans-unit>
        <trans-unit id="fbd12644c821ad9dd5361ab305ce3eacebcd4452" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; to insert &lt;code&gt;ptr&lt;/code&gt; into</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 插入 &lt;code&gt;ptr&lt;/code&gt; 到</target>
        </trans-unit>
        <trans-unit id="a4b2b6efcf66147f984a4f4c3f1b193be394563b" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;, pointer to a null-terminated character/wide character string, or an input iterator that points to a null-terminated character/wide character sequence. The character type must be one of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, (since C++20)&lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; ，指向以null终止的字符/宽字符串的指针，或者是一个指向以null终止的字符/宽字符序列的输入迭代器。字符类型必须是 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;char8_t&lt;/code&gt; ，（自C ++ 20起） &lt;code&gt;char16_t&lt;/code&gt; ， &lt;code&gt;char32_t&lt;/code&gt; ， &lt;code&gt;wchar_t&lt;/code&gt; 中的一种</target>
        </trans-unit>
        <trans-unit id="6b73bd2673de988b6a6630c49706a06b3e5e3bc7" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; representing the hash value.</source>
          <target state="translated">代表哈希值的 &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d166a98420f3d07a1a5cfa0f15025354bc8ab03" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; object to compare</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; 对象进行比较</target>
        </trans-unit>
        <trans-unit id="d5b6a5305c4cd7829271fc0bef5a5469bcdbe9cb" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; type representing the tick period of the clock, in seconds</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; 类型，代表时钟的滴答周期，以秒为单位</target>
        </trans-unit>
        <trans-unit id="28c282d6688b8d9817fe3654bc3aea6ec9948374" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; object</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; 对象</target>
        </trans-unit>
        <trans-unit id="5c15ad055910b7bab983130d3d0318587f713ea8" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; struct containing the constructor options</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; 结构，其中包含构造函数选项</target>
        </trans-unit>
        <trans-unit id="54930ae4d23e136dcc5b456eec1ed82612b38402" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e940f25cbf8cd2aa56592576ed0c20278acc2bff" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; that will be viewed by this &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">一个 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 将被此 &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 查看</target>
        </trans-unit>
        <trans-unit id="ecdb524f3aba763d3ff8829b8227e31bef82cacf" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;basic_string&lt;/code&gt; used to initialize the buffer</source>
          <target state="translated">用于初始化缓冲区的 &lt;code&gt;basic_string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0e668eabf5840cd34ea3e0f28321b311fe77422" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;duration&lt;/code&gt; to copy from</source>
          <target state="translated">复制的 &lt;code&gt;duration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b0c69e8badd1554c8a8794737ab30e685ebbeb0" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence Y, then A precedes Y in S c) if a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence X</source>
          <target state="translated">一个 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 栅栏Y，然后在c c中，如果一个 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 栅栏X ，则A在Y之前。</target>
        </trans-unit>
        <trans-unit id="f0b51354e700071d41d8e696cc9589f3f0e23e24" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence Y, then X precedes Y in S</source>
          <target state="translated">一个 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; 栅栏Y，然后在S中X在Y之前</target>
        </trans-unit>
        <trans-unit id="9d2d1cf5df9aa21b5f43d6c3730e0127bacfd20a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;mutex&lt;/code&gt; from the time that it successfully calls either &lt;a href=&quot;mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; until it calls &lt;a href=&quot;mutex/unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从成功调用&lt;a href=&quot;mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;到调用&lt;a href=&quot;mutex/unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt;为止的一个 &lt;code&gt;mutex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="863d62328d5f1e3a0af927034efd3cb49a858007" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;recursive_mutex&lt;/code&gt; for a period of time that starts when it successfully calls either &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;. During this period, the thread may make additional calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;. The period of ownership ends when the thread makes a matching number of calls to &lt;a href=&quot;recursive_mutex/unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">一个 &lt;code&gt;recursive_mutex&lt;/code&gt; 的一段时间，从成功调用&lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; 开始&lt;/a&gt;。在此期间，线程可能会另外调用&lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;recursive_mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt;。线程进行匹配次数的&lt;a href=&quot;recursive_mutex/unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt;请求时，所有权期限结束。</target>
        </trans-unit>
        <trans-unit id="60b02f0b0cd6b462a069eb540be8a96dc7f7ee1a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;regex_iterator&lt;/code&gt; to compare to</source>
          <target state="translated">一个 &lt;code&gt;regex_iterator&lt;/code&gt; 来比较</target>
        </trans-unit>
        <trans-unit id="5f914aa0db45d26f593fbd3b3acb0736aa4d7f34" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::chrono::local_info&lt;/code&gt; describing the result of the conversion attempt</source>
          <target state="translated">一个 &lt;code&gt;std::chrono::local_info&lt;/code&gt; 描述尝试转换的结果</target>
        </trans-unit>
        <trans-unit id="e92b7ebf5ac6699b0419aafc5019fd69e5b495d1" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::future&lt;/code&gt; that will transfer state to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">将状态转移到 &lt;code&gt;*this&lt;/code&gt; 的 &lt;code&gt;std::future&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45c38558d576f7077eb936fedf2e6993f71552d0" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::partial_ordering &lt;/code&gt; value to check</source>
          <target state="translated">要检查的 &lt;code&gt;std::partial_ordering &lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="6cb6d8aec9d0d7086c8d7b490355b651816e9f71" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::partial_ordering&lt;/code&gt; value to check</source>
          <target state="translated">要检查的 &lt;code&gt;std::partial_ordering&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="2abc4eda553b7e2119f385f0dd8fe079b5901fc1" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::shared_future&lt;/code&gt; that will transfer state to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">一个 &lt;code&gt;std::shared_future&lt;/code&gt; 将状态转移到 &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea1ec8d4b72649962e567349201f78a7aecef264" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::strong_equality&lt;/code&gt; value to check</source>
          <target state="translated">要检查的 &lt;code&gt;std::strong_equality&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="842ba00de4d8ab8dd4f532e899b87cf7099a8622" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::strong_ordering&lt;/code&gt; value to check</source>
          <target state="translated">要检查的 &lt;code&gt;std::strong_ordering&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="0253836014928024de0859d29625df2f344d46ad" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_equality&lt;/code&gt; value to check</source>
          <target state="translated">一个 &lt;code&gt;std::weak_equality&lt;/code&gt; 值来检查</target>
        </trans-unit>
        <trans-unit id="f76354e64cc6e23de23245adc7499dc00576366f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_ordering &lt;/code&gt; value to check</source>
          <target state="translated">一个 &lt;code&gt;std::weak_ordering &lt;/code&gt; 值来检查</target>
        </trans-unit>
        <trans-unit id="05358986f183ddf4595d8859a958cc712f0ab225" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_ordering&lt;/code&gt; value to check</source>
          <target state="translated">一个 &lt;code&gt;std::weak_ordering&lt;/code&gt; 值来检查</target>
        </trans-unit>
        <trans-unit id="d9610770cf81d239e7a04362e6d0fadfaa64deec" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;sub_match&lt;/code&gt;, &lt;code&gt;basic_string&lt;/code&gt;, pointer to a null-terminated string or a character to compare</source>
          <target state="translated">一个 &lt;code&gt;sub_match&lt;/code&gt; ， &lt;code&gt;basic_string&lt;/code&gt; 的，指针到一个空终止字符串或字符进行比较</target>
        </trans-unit>
        <trans-unit id="63b26ec0d5fac3c3232b5ffc726c7befaaed3d72" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;time_point&lt;/code&gt; to convert from</source>
          <target state="translated">要转换的 &lt;code&gt;time_point&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="816fe47038210aaf21ca1a99d9e95e7a3f42b5cc" translate="yes" xml:space="preserve">
          <source>a FIFO (also known as pipe) file</source>
          <target state="translated">先进先出档案库</target>
        </trans-unit>
        <trans-unit id="54a9c6eed1e0626765604b3dcde6dced86c39ba2" translate="yes" xml:space="preserve">
          <source>a UTF-8 encoded &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt;, a pointer to a null-terminated multibyte string, or an input iterator with char value type that points to a null-terminated multibyte string</source>
          <target state="translated">一个UTF-8编码的 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt; ，一个以null终止的多字节字符串的指针，或者一个char值类型的输入迭代器指向以null终止的多字节字符串</target>
        </trans-unit>
        <trans-unit id="d879d1e4b9050e4ddcaaf4d1177df97586b36972" translate="yes" xml:space="preserve">
          <source>a base class subobject, or</source>
          <target state="translated">基类子对象,或</target>
        </trans-unit>
        <trans-unit id="f4918892ac7e83e823a2320d1ac12b97395fb22e" translate="yes" xml:space="preserve">
          <source>a basic stream output function</source>
          <target state="translated">基本流输出函数</target>
        </trans-unit>
        <trans-unit id="b40f7d626aeddea7dd6317df88183469b83e1e8c" translate="yes" xml:space="preserve">
          <source>a basic_ostream of the same type to swap with</source>
          <target state="translated">同类型的basic_ostream进行交换。</target>
        </trans-unit>
        <trans-unit id="7bf28d638858caf4f712e1c44d5c9646f9188b75" translate="yes" xml:space="preserve">
          <source>a basic_string used as a source used to initialize the regex</source>
          <target state="translated">a basic_string作为源,用于初始化regex。</target>
        </trans-unit>
        <trans-unit id="6e9b8e3d4e8d4b69f9fcb8e7bf96871b00610a3b" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the collate facet category</source>
          <target state="translated">类型 &lt;code&gt;category&lt;/code&gt; 的位掩码值，指示整理构面类别</target>
        </trans-unit>
        <trans-unit id="9f85b8ca8bc6020d25703e2cd3d781082f967763" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the ctype facet category</source>
          <target state="translated">类型 &lt;code&gt;category&lt;/code&gt; 的位掩码值，指示ctype构面类别</target>
        </trans-unit>
        <trans-unit id="a9222a22156a69a4cc22429a74768f81e03c8001" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the messages facet category</source>
          <target state="translated">类型 &lt;code&gt;category&lt;/code&gt; 的位掩码值，指示消息构面类别</target>
        </trans-unit>
        <trans-unit id="952a4bcb614afbf75d9c9379f3e6fad36cbc2407" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the monetary facet category</source>
          <target state="translated">类型 &lt;code&gt;category&lt;/code&gt; 的位掩码值，指示货币方面类别</target>
        </trans-unit>
        <trans-unit id="a321349b7f9b76dc26dc645283a6f6c0d3935161" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the numeric facet category</source>
          <target state="translated">类型 &lt;code&gt;category&lt;/code&gt; 的位掩码值，指示数字构面类别</target>
        </trans-unit>
        <trans-unit id="b2849fb686ecb1e5989a880cd4bb3d2e85d8c6f8" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the time facet category</source>
          <target state="translated">类型 &lt;code&gt;category&lt;/code&gt; 的位掩码值，指示时间构面类别</target>
        </trans-unit>
        <trans-unit id="5378f3a4e98f36da8d1cc7ac9fde2e0f766b8ce0" translate="yes" xml:space="preserve">
          <source>a block special file</source>
          <target state="translated">档案室</target>
        </trans-unit>
        <trans-unit id="31510aaf6cad0411c7217a1f61ae7d5e0d11e988" translate="yes" xml:space="preserve">
          <source>a callable object used to determine equality</source>
          <target state="translated">一个可调用对象,用于确定平等性</target>
        </trans-unit>
        <trans-unit id="16cbd5bc356bd1da4d6938d770e5e05cf23f18f0" translate="yes" xml:space="preserve">
          <source>a callable object used to hash the elements of the string</source>
          <target state="translated">一个可调用对象,用于对字符串中的元素进行哈希处理。</target>
        </trans-unit>
        <trans-unit id="e104c12ef41e3cdab35da94692fcec6545e90e82" translate="yes" xml:space="preserve">
          <source>a callable to initialize the</source>
          <target state="translated">一个可调用的函数来初始化</target>
        </trans-unit>
        <trans-unit id="a43b347761e3e1642f174ca5ec98e18e3c558b21" translate="yes" xml:space="preserve">
          <source>a callable used to initialize &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">用于初始化 &lt;code&gt;*this&lt;/code&gt; 的可调用对象</target>
        </trans-unit>
        <trans-unit id="dc6aead76d9ee30f0a5c5d4684ed174e264c2836" translate="yes" xml:space="preserve">
          <source>a cast expression to lvalue reference type, such as &lt;code&gt;static_cast&amp;lt;int&amp;amp;&amp;gt;(x)&lt;/code&gt;;</source>
          <target state="translated">一个转换为左值引用类型的表达式，例如 &lt;code&gt;static_cast&amp;lt;int&amp;amp;&amp;gt;(x)&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="9115722d18c29f111bc7117bd95ced839664bc51" translate="yes" xml:space="preserve">
          <source>a cast expression to non-reference type, such as &lt;code&gt;static_cast&amp;lt;double&amp;gt;(x)&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;{}&lt;/code&gt;, or &lt;code&gt;(int)42&lt;/code&gt;;</source>
          <target state="translated">转换为非引用类型的表达式，例如 &lt;code&gt;static_cast&amp;lt;double&amp;gt;(x)&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;{}&lt;/code&gt; 或 &lt;code&gt;(int)42&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="e763fd172d6152f43975ef5910f0aa8ba9d50062" translate="yes" xml:space="preserve">
          <source>a cast expression to rvalue reference to function type, such as &lt;code&gt;static_cast&amp;lt;void (&amp;amp;&amp;amp;)(int)&amp;gt;(x)&lt;/code&gt;.</source>
          <target state="translated">一个对函数类型右值引用的 &lt;code&gt;static_cast&amp;lt;void (&amp;amp;&amp;amp;)(int)&amp;gt;(x)&lt;/code&gt; 表达式，例如static_cast &amp;lt;void（&amp;amp;&amp;amp;）（int）&amp;gt;（x）。</target>
        </trans-unit>
        <trans-unit id="be2abbbe2e0dfe771f0371f123450bb9bd07c9bb" translate="yes" xml:space="preserve">
          <source>a cast expression to rvalue reference to object type, such as &lt;code&gt;static_cast&amp;lt;char&amp;amp;&amp;amp;&amp;gt;(x)&lt;/code&gt;;</source>
          <target state="translated">一个对对象类型进行右值引用的 &lt;code&gt;static_cast&amp;lt;char&amp;amp;&amp;amp;&amp;gt;(x)&lt;/code&gt; 表达式，例如static_cast &amp;lt;char &amp;amp;&amp;amp;&amp;gt;（x）；</target>
        </trans-unit>
        <trans-unit id="53484ba10b1e424e0b9496d35157e69373bf554a" translate="yes" xml:space="preserve">
          <source>a character from the source character set minus single-quote (&lt;code&gt;'&lt;/code&gt;), backslash (&lt;code&gt;\&lt;/code&gt;), or the newline character,</source>
          <target state="translated">源字符集中的字符减去单引号（ &lt;code&gt;'&lt;/code&gt; ），反斜杠（ &lt;code&gt;\&lt;/code&gt; ）或换行符，</target>
        </trans-unit>
        <trans-unit id="242427c6b2eafcaf248ee1b9d7c883407593539a" translate="yes" xml:space="preserve">
          <source>a character input stream</source>
          <target state="translated">字符输入流</target>
        </trans-unit>
        <trans-unit id="0efbbee14797deed6a7056276c65b5e154453b0a" translate="yes" xml:space="preserve">
          <source>a character output stream</source>
          <target state="translated">字流</target>
        </trans-unit>
        <trans-unit id="70a6bbc7a457f3e06d375719052224054e262911" translate="yes" xml:space="preserve">
          <source>a character range to use</source>
          <target state="translated">字段</target>
        </trans-unit>
        <trans-unit id="f1cf02ceb7cec86411208ea818ed5141785e1a23" translate="yes" xml:space="preserve">
          <source>a character range to use, represented as &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt;, pointer to a null-terminated multibyte string, or as an input iterator with char value type that points to a null-terminated multibyte string</source>
          <target state="translated">要使用的字符范围，表示为 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt; ，以空值终止的多字节字符串的指针，或作为具有char值类型的输入迭代器，该值指向以空值终止的多字节字符串</target>
        </trans-unit>
        <trans-unit id="1736d8d35a09815a4736564ec0af7bbafefb5389" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the end of the string</source>
          <target state="translated">字符序列或单个字符与字符串末尾进行比较。</target>
        </trans-unit>
        <trans-unit id="eb17e0910a8a3e8109807493a04ca35e79111c97" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the end of the string view</source>
          <target state="translated">字符序列或单个字符与字符串视图的结尾进行比较。</target>
        </trans-unit>
        <trans-unit id="792cac041ed6c9d94e7546b52a466c7057d1833f" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the start of the string</source>
          <target state="translated">字符序列或单个字符与字符串的开始进行比较。</target>
        </trans-unit>
        <trans-unit id="cf6ca109dc96019eacef9105cfc32c6bb8adf9f3" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the start of the string view</source>
          <target state="translated">字符序列或单个字符与字符串视图的开始进行比较。</target>
        </trans-unit>
        <trans-unit id="a36ddc3729dac1840b73df74f47d5b5381de7021" translate="yes" xml:space="preserve">
          <source>a character special file</source>
          <target state="translated">字库</target>
        </trans-unit>
        <trans-unit id="a5250d7e3929a03629a280317471b3d3c146b682" translate="yes" xml:space="preserve">
          <source>a class type (&lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;) that:</source>
          <target state="translated">一个类类型（ &lt;code&gt;class&lt;/code&gt; ， &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="f075c0a2aeaae5daa8fce7ca9d846ae302099ae2" translate="yes" xml:space="preserve">
          <source>a class type that contains allocation information</source>
          <target state="translated">一个包含分配信息的类型</target>
        </trans-unit>
        <trans-unit id="691a4be3772ad8ef069a61765f06c1d8bc2961d8" translate="yes" xml:space="preserve">
          <source>a class/function/variable template</source>
          <target state="translated">类/函数/变量模板</target>
        </trans-unit>
        <trans-unit id="8af3fd16bec574be1984ea9e734c9bf45f25959e" translate="yes" xml:space="preserve">
          <source>a comma-separated list of parameters like in a function declaration, except that default arguments are not allowed and it cannot end with an ellipsis (other than one signifying a pack expansion). These parameters have no storage, linkage or lifetime, and are only used to assist in specifying requirements. These parameters are in scope until the closing &lt;code&gt;} &lt;/code&gt; of the requirement-seq.</source>
          <target state="translated">以逗号分隔的参数列表，类似于函数声明中的参数，不同之处在于不允许使用默认参数，并且不能以省略号结尾（除了表示包扩展的那个）。这些参数没有存储，链接或生存期，仅用于帮助指定要求。这些参数的使用范围直到requirement-seq 的结束 &lt;code&gt;} &lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f11728936e3c6825ff0c40fb8190cad46110b798" translate="yes" xml:space="preserve">
          <source>a comma-separated list of zero or more &lt;a href=&quot;lambda#Lambda_capture&quot;&gt;captures&lt;/a&gt;, optionally beginning with a capture-default.</source>
          <target state="translated">零个或多个&lt;a href=&quot;lambda#Lambda_capture&quot;&gt;捕获&lt;/a&gt;的逗号分隔列表，可以选择以默认捕获开始。</target>
        </trans-unit>
        <trans-unit id="34fd2e1333d218ba0d65569377b79829eed062f3" translate="yes" xml:space="preserve">
          <source>a compatible &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;</source>
          <target state="translated">兼容的&lt;a href=&quot;../node_handle&quot;&gt;节点句柄&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12cf74b9d504b7de17cb8733f3089bb0c746c26c" translate="yes" xml:space="preserve">
          <source>a complex number determined by &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;theta&lt;/code&gt;.</source>
          <target state="translated">由 &lt;code&gt;r&lt;/code&gt; 和 &lt;code&gt;theta&lt;/code&gt; 确定的复数。</target>
        </trans-unit>
        <trans-unit id="832f4c5d564988716ce6fc985261dbaeef18716f" translate="yes" xml:space="preserve">
          <source>a complex number type</source>
          <target state="translated">复数型</target>
        </trans-unit>
        <trans-unit id="87f7888775f37c05d22b86f373fe58cc238751cb" translate="yes" xml:space="preserve">
          <source>a complex or scalar value of matching type (&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;)</source>
          <target state="translated">匹配类型的复杂或标量值（ &lt;code&gt;float&lt;/code&gt; ， &lt;code&gt;double&lt;/code&gt; ， &lt;code&gt;long double&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="b420ae5c7d6bcd895849ec43707c9cd9b5295f2a" translate="yes" xml:space="preserve">
          <source>a compound type constructed from a dependent type</source>
          <target state="translated">从属类型构建的复合类型</target>
        </trans-unit>
        <trans-unit id="3e10ceabf9c0862a21d4c968a88d28cf606e6ae4" translate="yes" xml:space="preserve">
          <source>a concept (&lt;a href=&quot;constraints&quot;&gt;constraints and concepts&lt;/a&gt;) (since C++20)</source>
          <target state="translated">概念（&lt;a href=&quot;constraints&quot;&gt;约束和概念&lt;/a&gt;）（自C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="705840ece91c45959e8d8b85562f78f90621fb91" translate="yes" xml:space="preserve">
          <source>a constant &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; with a &lt;code&gt;value_type&lt;/code&gt; of &lt;code&gt;path&lt;/code&gt;, except that for dereferenceable iterators &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; of type &lt;code&gt;path::iterator&lt;/code&gt; with &lt;code&gt;a == b&lt;/code&gt;, there is no requirement that &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; are bound to the same object</source>
          <target state="translated">一个具有 &lt;code&gt;path&lt;/code&gt; 的 &lt;code&gt;value_type&lt;/code&gt; 的常量&lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;，除了具有 &lt;code&gt;a == b&lt;/code&gt; &lt;code&gt;path::iterator&lt;/code&gt; 类型的可取消引用的迭代器 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 之外，不需要将 &lt;code&gt;*a&lt;/code&gt; 和 &lt;code&gt;*b&lt;/code&gt; 绑定到同一对象</target>
        </trans-unit>
        <trans-unit id="0861d8f96c22cf00ddd38be06d579dc5846fa4bb" translate="yes" xml:space="preserve">
          <source>a constant expression of the same type as the type of condition after conversions and &lt;a href=&quot;implicit_cast&quot;&gt;integral promotions&lt;/a&gt;</source>
          <target state="translated">与转换和&lt;a href=&quot;implicit_cast&quot;&gt;积分提升&lt;/a&gt;后的条件类型相同类型的常量表达式</target>
        </trans-unit>
        <trans-unit id="fa1e013cc131d9284341359f6bccff749d73ab2d" translate="yes" xml:space="preserve">
          <source>a constant of type &lt;code&gt;&lt;a href=&quot;codecvt_mode&quot;&gt;std::codecvt_mode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">类型为 &lt;code&gt;&lt;a href=&quot;codecvt_mode&quot;&gt;std::codecvt_mode&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2092e802512bd4b6672ffecf3059eab3c2dc675a" translate="yes" xml:space="preserve">
          <source>a constant of type &lt;code&gt;size_t&lt;/code&gt; signifying that the &lt;code&gt;span&lt;/code&gt; has dynamic extent</source>
          <target state="translated">类型为 &lt;code&gt;size_t&lt;/code&gt; 的常量，表示 &lt;code&gt;span&lt;/code&gt; 具有动态范围</target>
        </trans-unit>
        <trans-unit id="43883e62b71e2ce20764378f921e1463f7c5e2fb" translate="yes" xml:space="preserve">
          <source>a constructor for a base or member that the implicit definition of the constructor would call is</source>
          <target state="translated">构造函数的隐式定义将调用的基或成员的构造函数是</target>
        </trans-unit>
        <trans-unit id="1e0e47bbea0419696dda53a2c740d527152ed34a" translate="yes" xml:space="preserve">
          <source>a container (such as &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;) of non-recursive &lt;a href=&quot;directory_iterator&quot;&gt;&lt;code&gt;directory_iterator&lt;/code&gt;s&lt;/a&gt; that forms the recursion stack</source>
          <target state="translated">形成递归堆栈的非递归&lt;a href=&quot;directory_iterator&quot;&gt; &lt;code&gt;directory_iterator&lt;/code&gt; &lt;/a&gt;的容器（例如 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="6da0ef251a56bef0d297d95fb6f03dcddc9d4d68" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;begin&lt;/code&gt; method</source>
          <target state="translated">具有 &lt;code&gt;begin&lt;/code&gt; 方法的容器</target>
        </trans-unit>
        <trans-unit id="3ab7db750fffecfbea2fd7f3a1826d7a47ff6dfd" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;data()&lt;/code&gt; method</source>
          <target state="translated">具有 &lt;code&gt;data()&lt;/code&gt; 方法的容器</target>
        </trans-unit>
        <trans-unit id="d42aaf6f8dfa2ceb1302ac9a7aae99e65ad76dd7" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;rbegin&lt;/code&gt; method</source>
          <target state="translated">使用 &lt;code&gt;rbegin&lt;/code&gt; 方法的容器</target>
        </trans-unit>
        <trans-unit id="8a255f3578bec602079f216affbbb6421964db15" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;rend&lt;/code&gt; method</source>
          <target state="translated">带有 &lt;code&gt;rend&lt;/code&gt; 方法的容器</target>
        </trans-unit>
        <trans-unit id="d76e199c3451be874b54d52909a700c365bc58d9" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;size&lt;/code&gt; method</source>
          <target state="translated">带有 &lt;code&gt;size&lt;/code&gt; 方法的容器</target>
        </trans-unit>
        <trans-unit id="5936962ad861e75e91156317d373da013aa2a18b" translate="yes" xml:space="preserve">
          <source>a container with an &lt;code&gt;empty&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;empty&lt;/code&gt; 方法的容器</target>
        </trans-unit>
        <trans-unit id="8eecf2dba113b51a014b2681b5af4fc06cf180a3" translate="yes" xml:space="preserve">
          <source>a container with an &lt;code&gt;end&lt;/code&gt; method</source>
          <target state="translated">具有 &lt;code&gt;end&lt;/code&gt; 方法的容器</target>
        </trans-unit>
        <trans-unit id="32ae34e0c2ff3b97cd9427b79233b671fd97c530" translate="yes" xml:space="preserve">
          <source>a copy of the base() iterator</source>
          <target state="translated">基准()迭代器的一个副本。</target>
        </trans-unit>
        <trans-unit id="7332ce803122087bfbb9401270891b4faedd3f1f" translate="yes" xml:space="preserve">
          <source>a copy of the base() iterator, the name is for exposition only</source>
          <target state="translated">base()迭代器的一个副本,这个名字只是为了说明问题。</target>
        </trans-unit>
        <trans-unit id="311bf83f22bc4bb383f24fd37ba3cb18d0aeb36d" translate="yes" xml:space="preserve">
          <source>a copy of the value returned by &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt; （）返回的值的副本</target>
        </trans-unit>
        <trans-unit id="6f958f7a6a78be01a6805b5c1af1d682eeb8a134" translate="yes" xml:space="preserve">
          <source>a cv-qualified version of a dependent type</source>
          <target state="translated">从属类型的cv限定版本。</target>
        </trans-unit>
        <trans-unit id="fc96c9e2930591a8d0a0e1f5aef8a747ab1ae764" translate="yes" xml:space="preserve">
          <source>a declaration</source>
          <target state="translated">声明</target>
        </trans-unit>
        <trans-unit id="de382bf6f6303f1d66d3ee9fa105e4cb909ae0fb" translate="yes" xml:space="preserve">
          <source>a default member initializer (for default constructor only) is</source>
          <target state="translated">缺省成员初始化器(仅适用于缺省构造函数)是</target>
        </trans-unit>
        <trans-unit id="c35c5385471cf8ca008de727f3a8bb03a39d8fc4" translate="yes" xml:space="preserve">
          <source>a default-constructed &lt;code&gt;path()&lt;/code&gt; followed by</source>
          <target state="translated">默认构造的 &lt;code&gt;path()&lt;/code&gt; 后跟</target>
        </trans-unit>
        <trans-unit id="3720dd36cc49fe927d2449b3b2fe294001d00344" translate="yes" xml:space="preserve">
          <source>a definition of a variable for which &lt;a href=&quot;default_initialization&quot;&gt;no initialization is performed&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;default_initialization&quot;&gt;没有初始化&lt;/a&gt;的变量的定义。</target>
        </trans-unit>
        <trans-unit id="8574bc2dee7611873d6999d1419b5b65057eda6e" translate="yes" xml:space="preserve">
          <source>a definition of a variable of non-literal type</source>
          <target state="translated">非文字型变量的定义。</target>
        </trans-unit>
        <trans-unit id="bf8e57bf98d46c7f4282d67c960acf8da327fef4" translate="yes" xml:space="preserve">
          <source>a definition of a variable of static or thread &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;</source>
          <target state="translated">静态或线程&lt;a href=&quot;storage_duration&quot;&gt;存储持续时间&lt;/a&gt;变量的定义</target>
        </trans-unit>
        <trans-unit id="39cd8bcb29b6ae12a4df802c4fe0c9397f3f8893" translate="yes" xml:space="preserve">
          <source>a deleter to copy from</source>
          <target state="translated">抄袭的删除器</target>
        </trans-unit>
        <trans-unit id="94a71c43d37808b7131ebf1bfafb843815bd7985" translate="yes" xml:space="preserve">
          <source>a deleter to use to destroy the object</source>
          <target state="translated">用来销毁对象的删除器。</target>
        </trans-unit>
        <trans-unit id="24ff51d02f7ddaf5794e2da95d7baf8bf41c271f" translate="yes" xml:space="preserve">
          <source>a deterministic &lt;a href=&quot;named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;, defined by the seed</source>
          <target state="translated">确定性的&lt;a href=&quot;named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;，由种子定义</target>
        </trans-unit>
        <trans-unit id="534eb8b60097429551e576498f52d179c2f4e5dd" translate="yes" xml:space="preserve">
          <source>a directory</source>
          <target state="translated">目录</target>
        </trans-unit>
        <trans-unit id="8bddca722adcb261998df0de3bb3c97a6c748832" translate="yes" xml:space="preserve">
          <source>a directory entry</source>
          <target state="translated">目录</target>
        </trans-unit>
        <trans-unit id="927fd0565fdd62ffef9d7df984e6c6f5ed72f85d" translate="yes" xml:space="preserve">
          <source>a directory_iterator</source>
          <target state="translated">目录迭代器</target>
        </trans-unit>
        <trans-unit id="867723c6d0ee2b6557184f124ed60f12f45d1dd0" translate="yes" xml:space="preserve">
          <source>a discarded-value expression.</source>
          <target state="translated">废弃值表达式。</target>
        </trans-unit>
        <trans-unit id="336c91ab3bd545d36262022c4abcf1ea256c10d5" translate="yes" xml:space="preserve">
          <source>a disjunctive clause subsumes a conjunctive clause if and only if there is an atomic constraint &lt;code&gt;U&lt;/code&gt; in the disjunctive clause and an atomic constraint &lt;code&gt;V&lt;/code&gt; in the conjunctive clause such that &lt;code&gt;U&lt;/code&gt; subsumes &lt;code&gt;V&lt;/code&gt;;</source>
          <target state="translated">当且仅当在析取子句中存在原子约束 &lt;code&gt;U&lt;/code&gt; 且在析取子句中存在原子约束 &lt;code&gt;V&lt;/code&gt; 且 &lt;code&gt;U&lt;/code&gt; 包含 &lt;code&gt;V&lt;/code&gt; 时，析取子句才包含析取子句；</target>
        </trans-unit>
        <trans-unit id="6b5747ff852acba8c48d1a6cb5da34fc9e296730" translate="yes" xml:space="preserve">
          <source>a duration to copy from</source>
          <target state="translated">抄袭的期限</target>
        </trans-unit>
        <trans-unit id="c350a90cf1671cc555d57758875af84ffdbe33a9" translate="yes" xml:space="preserve">
          <source>a family of classes (&lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt;), which may be &lt;a href=&quot;member_template&quot;&gt;nested classes&lt;/a&gt;</source>
          <target state="translated">一类类（&lt;a href=&quot;class_template&quot;&gt;类模板&lt;/a&gt;），可以是&lt;a href=&quot;member_template&quot;&gt;嵌套类&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ac66b538aae3ff5b2eebbb9164d6b15968c2655" translate="yes" xml:space="preserve">
          <source>a family of functions (&lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;), which may be &lt;a href=&quot;member_template&quot;&gt;member functions&lt;/a&gt;</source>
          <target state="translated">一族函数（&lt;a href=&quot;function_template&quot;&gt;函数模板&lt;/a&gt;），可以是&lt;a href=&quot;member_template&quot;&gt;成员函数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b225fab8be27928cedcf387d1202d942115cf6f7" translate="yes" xml:space="preserve">
          <source>a family of variables (&lt;a href=&quot;variable_template&quot;&gt;variable template&lt;/a&gt;) (since C++14)</source>
          <target state="translated">一类变量（&lt;a href=&quot;variable_template&quot;&gt;变量模板&lt;/a&gt;）（自C ++ 14起）</target>
        </trans-unit>
        <trans-unit id="fa031b408b61feecac632070eb11680ef7afef0a" translate="yes" xml:space="preserve">
          <source>a function call expression that calls a function (or a constructor) that is not declared &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;</source>
          <target state="translated">调用未声明为&lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;的函数（或构造函数）的函数调用表达式</target>
        </trans-unit>
        <trans-unit id="1cc0ab25d190ee32f3fbd65c276911c0bf316acb" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is lvalue reference, such as &lt;code&gt;&lt;a href=&quot;../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;(&lt;a href=&quot;../io/cin&quot;&gt;std::cin&lt;/a&gt;, str)&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 1&lt;/code&gt;, &lt;code&gt;str1 = str2&lt;/code&gt;, or &lt;code&gt;++it&lt;/code&gt;;</source>
          <target state="translated">函数调用或重载的运算符表达式，其返回类型为左值引用，例如 &lt;code&gt;&lt;a href=&quot;../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;(&lt;a href=&quot;../io/cin&quot;&gt;std::cin&lt;/a&gt;, str)&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 1&lt;/code&gt; ， &lt;code&gt;str1 = str2&lt;/code&gt; 或 &lt;code&gt;++it&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="fe3271b2a2bdf8654d96145285508cb27eb7fa3c" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is non-reference, such as &lt;code&gt;str.substr(1, 2)&lt;/code&gt;, &lt;code&gt;str1 + str2&lt;/code&gt;, or &lt;code&gt;it++&lt;/code&gt;;</source>
          <target state="translated">函数调用或重载的运算符表达式，其返回类型为非引用，例如 &lt;code&gt;str.substr(1, 2)&lt;/code&gt; ， &lt;code&gt;str1 + str2&lt;/code&gt; 或 &lt;code&gt;it++&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="0aac9ce8ff230dee25d75b3c0b2e89e1a93af6fb" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is rvalue reference to function;</source>
          <target state="translated">一个函数调用或重载操作表达式,其返回类型是函数的rvalue引用。</target>
        </trans-unit>
        <trans-unit id="06b3616b9a0b9e911ad389bfd163627a7c1c34bc" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is rvalue reference to object, such as &lt;code&gt;std::move(x)&lt;/code&gt;;</source>
          <target state="translated">函数调用或重载的运算符表达式，其返回类型是对对象的右值引用，例如 &lt;code&gt;std::move(x)&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="89282f06fce2e206dcc5d91b9a98ea7c21e34204" translate="yes" xml:space="preserve">
          <source>a function call to a &lt;code&gt;constexpr&lt;/code&gt; function which is declared, but not defined</source>
          <target state="translated">对已声明但未定义的 &lt;code&gt;constexpr&lt;/code&gt; 函数的函数调用</target>
        </trans-unit>
        <trans-unit id="10915ad1ef913f2efda469b6ef4db5fda7260bf8" translate="yes" xml:space="preserve">
          <source>a function call to a &lt;code&gt;constexpr&lt;/code&gt; function/constructor template instantiation where the instantiation fails to satisfy &lt;a href=&quot;constexpr&quot;&gt;constexpr function/constructor&lt;/a&gt; requirements.</source>
          <target state="translated">对 &lt;code&gt;constexpr&lt;/code&gt; 函数/构造函数模板实例化的函数调用，其中实例化不能满足&lt;a href=&quot;constexpr&quot;&gt;constexpr函数/构造函数的&lt;/a&gt;要求。</target>
        </trans-unit>
        <trans-unit id="1a1e14620347e6a891947bb343ed08d832b480d5" translate="yes" xml:space="preserve">
          <source>a function object type. The behavior is undefined if its return type is not one of the five comparison category types (strong_equality, weak_equality, strong_ordering, weak_ordering, or partial_ordering)</source>
          <target state="translated">一个函数对象类型。如果它的返回类型不是五个比较类别类型(strong_equality、weak_equality、strong_ordering、weak_ordering或partial_ordering)之一,则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="8d0e3c882e6f573300e1c9692eab26458b8cdc46" translate="yes" xml:space="preserve">
          <source>a function type whose exception specification is value-dependent</source>
          <target state="translated">一个函数类型,它的异常规范是依赖于值的。</target>
        </trans-unit>
        <trans-unit id="e47b118e9260ac46b886dbed4343d2d945bd3192" translate="yes" xml:space="preserve">
          <source>a glvalue</source>
          <target state="translated">a glvalue</target>
        </trans-unit>
        <trans-unit id="7ba358203ed2199073a8967bad6e8c7ab1203303" translate="yes" xml:space="preserve">
          <source>a glvalue (&amp;ldquo;generalized&amp;rdquo; lvalue) is an expression whose evaluation determines the identity of an object, bit-field, or function;</source>
          <target state="translated">glvalue（&amp;ldquo;广义&amp;rdquo; lvalue）是一个表达式，其求值确定对象，位字段或函数的身份；</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
