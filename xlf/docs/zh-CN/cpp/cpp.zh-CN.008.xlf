<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="ebd2ec0b130f71d262d87cd87e080e799f354dca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alignof(&lt;/code&gt;type-id&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;alignof(&lt;/code&gt;type-id&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f44e7b7045981421755d118aa1f74107340a7771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allocator_type::value_type&lt;/code&gt; must be the same as &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;allocator_type::value_type&lt;/code&gt; 必须与 &lt;code&gt;X::value_type&lt;/code&gt; 相同</target>
        </trans-unit>
        <trans-unit id="3532ce805aaa10fb133fe6a09e77355516837e45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;app&lt;/code&gt;, &lt;code&gt;out|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; ， &lt;code&gt;out|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07c827073bf89e714367ae756bf6369538f5f235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt;, suitable argument list, which may be empty</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; ，合适的参数列表，可以为空</target>
        </trans-unit>
        <trans-unit id="37d5e9afff11c7d6f1a32d566e8647f07d8068c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt;: a function parameter pack with the pattern &lt;code&gt;Arg&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; ：具有参数 &lt;code&gt;Arg&amp;amp;&amp;amp;&lt;/code&gt; 的函数参数包</target>
        </trans-unit>
        <trans-unit id="5badce74e4250cbddfbfaee79d4cc54fac1ff9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argument_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;argument_type&lt;/code&gt; （在C ++ 17中已弃用）</target>
        </trans-unit>
        <trans-unit id="2f117061012ddeffdc3050c3b2b1050ec416dac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argument_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;argument_type&lt;/code&gt; （在C ++ 17中已弃用）（在C ++ 20中已删除）</target>
        </trans-unit>
        <trans-unit id="42c2f18252f2ad115d660eb4fe5d1c943f0deaaa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_writable_bytes&lt;/code&gt; only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_const&quot;&gt;std::is_const_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;as_writable_bytes&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;../../types/is_const&quot;&gt;std::is_const_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ,则as_writable_bytes仅参与重载解析。</target>
        </trans-unit>
        <trans-unit id="a33ed179d2cca7162a766f390d4bcea8b632ae99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asm (&lt;/code&gt;string_literal&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;asm (&lt;/code&gt; string_literal &lt;code&gt;)&lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81416574a3bdb5b6e662f9881120a34330414456" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atexit&lt;/code&gt; is thread-safe: calling the function from several threads does not induce a data race.</source>
          <target state="translated">&lt;code&gt;atexit&lt;/code&gt; 是线程安全的：从多个线程调用该函数不会引起数据争用。</target>
        </trans-unit>
        <trans-unit id="82fe65c70980dd8294c7a044920ff6948bb995a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="718753e51ee58fcc3a9b874bbfc25e05ee87099f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement.</source>
          <target state="translated">&lt;code&gt;atomic_cancel&lt;/code&gt;compound-statement.</target>
        </trans-unit>
        <trans-unit id="c4bb431c9a8c27ffbcb57f1e2030ffcdaa682589" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="dc03de8684bde862cdd451c15145d5937d4aa9e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement.</source>
          <target state="translated">&lt;code&gt;atomic_commit&lt;/code&gt;compound-statement.</target>
        </trans-unit>
        <trans-unit id="9917e2226a40c215ff624d65d369e5d18521d70b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="5d7a8f566cfc5ea680fc175590dc8b6fc4e5f7b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement.</source>
          <target state="translated">&lt;code&gt;atomic_noexcept&lt;/code&gt;compound-statement.</target>
        </trans-unit>
        <trans-unit id="84df6b95b4568b36529d65a8fee8565da22271bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomic_thread_fence&lt;/code&gt; imposes stronger synchronization constraints than an atomic store operation with the same &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;. While an atomic store-release operation prevents all preceding writes from moving past the store-release, an &lt;code&gt;atomic_thread_fence&lt;/code&gt; with &lt;code&gt;memory_order_release&lt;/code&gt; ordering prevents all preceding writes from moving past all subsequent stores.</source>
          <target state="translated">&lt;code&gt;atomic_thread_fence&lt;/code&gt; 比具有相同 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; 的原子存储操作施加更强的同步约束。虽然原子存储释放操作可以防止所有先前的写操作移出存储释放，但是具有 &lt;code&gt;memory_order_release&lt;/code&gt; 排序的 &lt;code&gt;atomic_thread_fence&lt;/code&gt; 可以防止所有先前的写操作移过所有后续存储。</target>
        </trans-unit>
        <trans-unit id="d2b8b8d94103c192bc34b9f2294272b3203ef193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;audit&lt;/code&gt; contract level</source>
          <target state="translated">&lt;code&gt;audit&lt;/code&gt; 合同级别</target>
        </trans-unit>
        <trans-unit id="76aee5a355d183a0f5d23e16f44cf76ee2b9d2e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto &amp;amp;&amp;amp; __range =&lt;/code&gt;range_expression&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto &amp;amp;&amp;amp; __range =&lt;/code&gt; range_expression &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9f17e418dc5efb3e325fa889fa484a44b496616" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto p = &lt;a href=&quot;../memory/unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&amp;lt;S&amp;gt;(); p-&amp;gt;bar()&lt;/code&gt; calls &lt;code&gt;p.operator-&amp;gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;auto p = &lt;a href=&quot;../memory/unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&amp;lt;S&amp;gt;(); p-&amp;gt;bar()&lt;/code&gt; 调用 &lt;code&gt;p.operator-&amp;gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="032d85b2fb46f2a33a2e395c59034caf15133db6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="ec4949cdf660704545c46868dec318b7dbf26454" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto&lt;/code&gt; placeholder type specifier</source>
          <target state="translated">&lt;code&gt;auto&lt;/code&gt; 占位符类型说明符</target>
        </trans-unit>
        <trans-unit id="dd355700463adc8e941685a068bf44f8191f5a8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_ptr&lt;/code&gt; is a smart pointer that manages an object obtained via &lt;a href=&quot;../language/new&quot;&gt;new expression&lt;/a&gt; and deletes that object when &lt;code&gt;auto_ptr&lt;/code&gt; itself is destroyed. It may be used to provide exception safety for dynamically-allocated objects, for passing ownership of dynamically-allocated objects into functions and for returning dynamically-allocated objects from functions.</source>
          <target state="translated">&lt;code&gt;auto_ptr&lt;/code&gt; 是一个智能指针，用于管理通过&lt;a href=&quot;../language/new&quot;&gt;新表达式&lt;/a&gt;获得的对象，并在销毁 &lt;code&gt;auto_ptr&lt;/code&gt; 本身时删除该对象。它可用于为动态分配的对象提供异常安全，将动态分配的对象的所有权传递给函数以及从函数返回动态分配的对象。</target>
        </trans-unit>
        <trans-unit id="83ea9a5c7bd8a0003bfe61072b17683f502bbfcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auto_ptr_ref&lt;/code&gt; is an implementation-defined type that holds a reference to &lt;code&gt;auto_ptr&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; is implicitly &lt;a href=&quot;operator_auto_ptr&quot;&gt;convertible to&lt;/a&gt; and &lt;a href=&quot;operator=&quot;&gt;assignable from&lt;/a&gt; this type. The implementation is allowed to provide the template with a different name or implement equivalent functionality in other ways.</source>
          <target state="translated">&lt;code&gt;auto_ptr_ref&lt;/code&gt; 是实现定义的类型，其中包含对 &lt;code&gt;auto_ptr&lt;/code&gt; 的引用。 &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; 可以隐式&lt;a href=&quot;operator_auto_ptr&quot;&gt;转换&lt;/a&gt;为该类型并可以&lt;a href=&quot;operator=&quot;&gt;从&lt;/a&gt;该类型分配。允许实现为模板提供不同的名称或以其他方式实现等效功能。</target>
        </trans-unit>
        <trans-unit id="f1181b079848ad4630e4817e7becf18e0449676f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;available&lt;/code&gt; -- free space available to a non-privileged process (may be equal or less than &lt;code&gt;free&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;available&lt;/code&gt; -非特权进程可用的可用空间（可以等于或小于 &lt;code&gt;free&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="193a702a1ece3e62c51179d1fd50a43ed52b5dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;awaiter.await_suspend(handle)&lt;/code&gt; is called, where handle is the coroutine handle representing the current coroutine. Inside that function, the suspended coroutine state is observable via that handle, and it's this function's responsibility to schedule it to resume on some executor, or to be destroyed (returning false counts as scheduling)</source>
          <target state="translated">&lt;code&gt;awaiter.await_suspend(handle)&lt;/code&gt; ，其中handle是代表当前协程的协程手柄。在该函数内部，可以通过该句柄观察到暂停的协程状态，并且此函数的职责是安排它在某些执行程序上恢复或销毁（返回假计数作为调度）。</target>
        </trans-unit>
        <trans-unit id="d025861833dc33a493957293ac40ae06518ca811" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;axiom&lt;/code&gt; contract level</source>
          <target state="translated">&lt;code&gt;axiom&lt;/code&gt; 合同水平</target>
        </trans-unit>
        <trans-unit id="145025995cddfb0c2c9c5f6b4c119aef67258c74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b == a + (b - a)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b == a + (b - a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca7fddee6b98e45102228f555b713744042ea185" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b.size()&lt;/code&gt; where &lt;code&gt;b&lt;/code&gt; is the largest possible container</source>
          <target state="translated">&lt;code&gt;b.size()&lt;/code&gt; ，其中 &lt;code&gt;b&lt;/code&gt; 是最大可能的容器</target>
        </trans-unit>
        <trans-unit id="ce50e8c6ef19594e1c432b6f85c1a4b90bf3a38d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b1 &amp;amp;&amp;amp; b2&lt;/code&gt;, &lt;code&gt;b1 &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; and &lt;code&gt;bool(b1) &amp;amp;&amp;amp; b2&lt;/code&gt; are all equal to &lt;code&gt;bool(b1) &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; and have the same short-circuit evaluation;</source>
          <target state="translated">&lt;code&gt;b1 &amp;amp;&amp;amp; b2&lt;/code&gt; ， &lt;code&gt;b1 &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; 和 &lt;code&gt;bool(b1) &amp;amp;&amp;amp; b2&lt;/code&gt; 都等于 &lt;code&gt;bool(b1) &amp;amp;&amp;amp; bool(b2)&lt;/code&gt; 并具有相同的短路评估；</target>
        </trans-unit>
        <trans-unit id="d123116bc0f09ca3ad761949ce648847c34c92b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b1 || b2&lt;/code&gt;, &lt;code&gt;b1 || bool(b2)&lt;/code&gt; and &lt;code&gt;bool(b1) || b2&lt;/code&gt; are all equal to &lt;code&gt;bool(b1) || bool(b2)&lt;/code&gt; and have the same short-circuit evaluation;</source>
          <target state="translated">&lt;code&gt;b1 || b2&lt;/code&gt; ， &lt;code&gt;b1 || bool(b2)&lt;/code&gt; 和 &lt;code&gt;bool(b1) || b2&lt;/code&gt; 都等于 &lt;code&gt;bool(b1) || bool(b2)&lt;/code&gt; 并具有相同的短路评估；</target>
        </trans-unit>
        <trans-unit id="6eac658ea175ac6c07451b1a46e798bdf17973ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b1&lt;/code&gt;, &lt;code&gt;b2&lt;/code&gt;, two lvalues of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;b1&lt;/code&gt; ， &lt;code&gt;b2&lt;/code&gt; ，两个类型为 &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;B&amp;gt;&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="6412a702062a0e09604a23adde3b60d786050fcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;, a value of type &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;bool&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="514056c1b49ea5088c99f6942670236289b94c07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt;, an object of type &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; ，类型 &lt;code&gt;B&lt;/code&gt; 的对象</target>
        </trans-unit>
        <trans-unit id="d7b9ab4cd6e6ceb7dce4b20058d3e2f787ff2546" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;back_inserter&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;back_insert_iterator&quot;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt; for the container &lt;code&gt;c&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;back_inserter&lt;/code&gt; 是一个便捷函数模板，它为容器 &lt;code&gt;c&lt;/code&gt; 构造一个 &lt;code&gt;&lt;a href=&quot;back_insert_iterator&quot;&gt;std::back_insert_iterator&lt;/a&gt;&lt;/code&gt; ，其类型从参数的类型推导出。</target>
        </trans-unit>
        <trans-unit id="aef2a40fcb800e3d5daaaf24742ed673ba9aa6ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bad_exception&lt;/code&gt; object to initialize with</source>
          <target state="translated">&lt;code&gt;bad_exception&lt;/code&gt; 对象进行初始化</target>
        </trans-unit>
        <trans-unit id="23fc76c7aa7f5cc34c63b8435077717406faa856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;basic_ios&lt;/code&gt; accessors</source>
          <target state="translated">&lt;code&gt;basic_ios&lt;/code&gt; 访问器</target>
        </trans-unit>
        <trans-unit id="991738fdb1ba79201bd3b5fff575043207e9cd52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin()&lt;/code&gt; returns a &lt;a href=&quot;../../iterator&quot;&gt;mutable&lt;/a&gt; or &lt;a href=&quot;../../iterator&quot;&gt;constant&lt;/a&gt; iterator, depending on the constness of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;begin()&lt;/code&gt; 返回一个&lt;a href=&quot;../../iterator&quot;&gt;可变的&lt;/a&gt;或&lt;a href=&quot;../../iterator&quot;&gt;常量的&lt;/a&gt;迭代器，具体取决于 &lt;code&gt;*this&lt;/code&gt; 的常数。</target>
        </trans-unit>
        <trans-unit id="3b2fabff44652b835a21acf2d98bc9b7da6e6b10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;begin&lt;/code&gt; ， &lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb7fcec2ec181e4e03c55c4a974329ae46c607c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;begin[k] = r2&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;begin[k] = r2&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="f62481721c1ee365dcb7f62b2010bbb186f92805" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;beta(x, y)&lt;/code&gt; equals &lt;code&gt;beta(y, x)&lt;/code&gt;  When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are positive integers, beta(x,y) equals \(\frac{(x-1)!(y-1)!}{(x+y-1)!}\).</source>
          <target state="translated">&lt;code&gt;beta(x, y)&lt;/code&gt; 等于 &lt;code&gt;beta(y, x)&lt;/code&gt; 当 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是正整数时，beta（x，y）等于\（\ frac {（x-1）！（y-1）！} {（x + y-1）！} \）。</target>
        </trans-unit>
        <trans-unit id="604472692ecd3c5f988851b616db9e5f20d83e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bidirectional_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bidirectional_iterator_tag&lt;/code&gt; 对应&lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="125381ef6ab81d128250226bfde14db875a5b559" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_function&lt;/code&gt; does not define &lt;code&gt;operator()&lt;/code&gt;; it is expected that derived classes will define this. &lt;code&gt;binary_function&lt;/code&gt; provides only three types - &lt;code&gt;first_argument_type&lt;/code&gt;, &lt;code&gt;second_argument_type&lt;/code&gt; and &lt;code&gt;result_type&lt;/code&gt; - defined by the template parameters.</source>
          <target state="translated">&lt;code&gt;binary_function&lt;/code&gt; 没有定义 &lt;code&gt;operator()&lt;/code&gt; ; 预期派生类将对此进行定义。 &lt;code&gt;binary_function&lt;/code&gt; 仅提供三种类型 &lt;code&gt;first_argument_type&lt;/code&gt; ， &lt;code&gt;second_argument_type&lt;/code&gt; 和 &lt;code&gt;result_type&lt;/code&gt; -由模板参数定义。</target>
        </trans-unit>
        <trans-unit id="16e551d920ab702201b563e5755c74ae3279f81b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_function&lt;/code&gt; is a base class for creating function objects with two arguments.</source>
          <target state="translated">&lt;code&gt;binary_function&lt;/code&gt; 是用于创建带有两个参数的函数对象的基类。</target>
        </trans-unit>
        <trans-unit id="ef3776fa71d38eff37d16e4c999b4523cedc63cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_function&lt;/code&gt; is deprecated in C++11 and removed in C++17.</source>
          <target state="translated">&lt;code&gt;binary_function&lt;/code&gt; 在C ++ 11中已弃用，在C ++ 17中已删除。</target>
        </trans-unit>
        <trans-unit id="fdf831ffca60a5c8451d6a8a5a4b17a971fdc8d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_negate&lt;/code&gt; is a wrapper function object returning the complement of the binary predicate it holds.</source>
          <target state="translated">&lt;code&gt;binary_negate&lt;/code&gt; 是包装函数对象，返回其持有的二进制谓词的补码。</target>
        </trans-unit>
        <trans-unit id="8013c54114d282ea5e941f7cdfba99882e44212e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_negate&lt;/code&gt; objects are easily constructed with helper function &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;binary_negate&lt;/code&gt; 使用辅助函数 &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; 可以轻松构造binary_negate对象。</target>
        </trans-unit>
        <trans-unit id="b0a58479ad5dd66246e935f29e88258c7a2b6c98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary_op&lt;/code&gt; shall not invalidate iterators (including the end iterators) or subranges, nor modify elements in the ranges [first, last) or [d_first, d_first + (last - first)). Otherwise, the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;binary_op&lt;/code&gt; 不得使迭代器（包括结束迭代器）或子范围无效，也不得修改[first，last）或[d_first，d_first +（last-first））范围内的元素。否则，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="9dc047979d7e3924246308fcb6924a121b70c6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary|app&lt;/code&gt;, &lt;code&gt;binary|out|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary|app&lt;/code&gt; ， &lt;code&gt;binary|out|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f0eed32cfc737c24a7788ccbca87ffd49f8f11f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary|out&lt;/code&gt;, &lt;code&gt;binary|out|trunc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary|out&lt;/code&gt; ， &lt;code&gt;binary|out|trunc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6acb4c2014ee265eae300200f0e5c83e074d4983" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binary|out|in|app&lt;/code&gt;, &lt;code&gt;binary|in|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary|out|in|app&lt;/code&gt; ， &lt;code&gt;binary|in|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b591230d50c861956000b7a76117395374361917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bitset&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;bitset&lt;/code&gt; 满足&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;和&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="7451240076a835cf07a3a852892863076f665623" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool(b1 != b2)&lt;/code&gt;, &lt;code&gt;bool(b1 != bool(b2))&lt;/code&gt;, and &lt;code&gt;bool(bool(b1) != b2)&lt;/code&gt; are all equal to &lt;code&gt;(bool(b1) != bool(b2))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bool(b1 != b2)&lt;/code&gt; ， &lt;code&gt;bool(b1 != bool(b2))&lt;/code&gt; 和 &lt;code&gt;bool(bool(b1) != b2)&lt;/code&gt; 都等于 &lt;code&gt;(bool(b1) != bool(b2))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d5690794fcc294f7e0800d3f91cdc1efa41f6d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool(b1 == b2)&lt;/code&gt;, &lt;code&gt;bool(b1 == bool(b2))&lt;/code&gt;, and &lt;code&gt;bool(bool(b1) == b2)&lt;/code&gt; are all equal to &lt;code&gt;(bool(b1) == bool(b2))&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;bool(b1 == b2)&lt;/code&gt; ， &lt;code&gt;bool(b1 == bool(b2))&lt;/code&gt; 和 &lt;code&gt;bool(bool(b1) == b2)&lt;/code&gt; 都等于 &lt;code&gt;(bool(b1) == bool(b2))&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0ce05b089af758edd37a80b26957774ddd79e3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt; - type, capable of holding one of the two values: &lt;a href=&quot;bool_literal&quot;&gt;&lt;code&gt;true&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;bool_literal&quot;&gt;&lt;code&gt;false&lt;/code&gt;&lt;/a&gt;. The value of &lt;code&gt;sizeof(bool)&lt;/code&gt; is implementation defined and might differ from 1.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 型，能够保存两个值之一：&lt;a href=&quot;bool_literal&quot;&gt; &lt;code&gt;true&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;bool_literal&quot;&gt; &lt;code&gt;false&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;sizeof(bool)&lt;/code&gt; 的值是实现定义的，可能与1不同。</target>
        </trans-unit>
        <trans-unit id="5d6ea2b6beaddc310f73e08e5cebae9d443418c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt; result of the corresponding relational operation.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; 相应关系运算的结果。</target>
        </trans-unit>
        <trans-unit id="6dd8657c98c6f75feace5c8bb8c68d633da923ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, and unscoped enumerations are converted to &lt;code&gt;int&lt;/code&gt; or wider integer types as in &lt;a href=&quot;implicit_cast#Integer_promotion&quot;&gt;integer promotion&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; ， &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;short&lt;/code&gt; 和无作用域枚举将转换为 &lt;code&gt;int&lt;/code&gt; 或更宽的整数类型，如&lt;a href=&quot;implicit_cast#Integer_promotion&quot;&gt;整数提升&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c142d9cd8f4e00ee27b16d8937b7bfc659f09ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bool&lt;/code&gt;, the result is &lt;code&gt;false&lt;/code&gt; if the original value is zero and &lt;code&gt;true&lt;/code&gt; for all other values. For the remaining integral types, the result is the value of the enum if it can be represented by the target type and unspecified otherwise.</source>
          <target state="translated">&lt;code&gt;bool&lt;/code&gt; ，结果是 &lt;code&gt;false&lt;/code&gt; ，如果原来的值是零， &lt;code&gt;true&lt;/code&gt; 为所有其他值。对于其余整数类型，如果可以用目标类型表示，则结果为枚举的值，否则未指定。</target>
        </trans-unit>
        <trans-unit id="1704b5f6c511d5e29b31127118c09864980fcfe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boyer_moore_horspool_searcher&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;boyer_moore_horspool_searcher&lt;/code&gt; 是&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;和&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e95a8719b769a84cb4a89872dd1a2fd9dd057945" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;boyer_moore_searcher&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;boyer_moore_searcher&lt;/code&gt; 是&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;和&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3018cefa81e15a18496ea3ac39a93bdedc72dd92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c, d&lt;/code&gt;, values of type &lt;code&gt;CharT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;c, d&lt;/code&gt; ， &lt;code&gt;CharT&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="6f14da71e36259d43be9260b7cd2f545b82b0aa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; on success except if &lt;code&gt;c&lt;/code&gt; was &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt;, in which case unspecified value other than &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 成功，除非 &lt;code&gt;c&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; ，否则返回 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; 以外的未指定值。</target>
        </trans-unit>
        <trans-unit id="6595e0c469c9ea725dee3becc791202e2a799c0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; on success except if &lt;code&gt;c&lt;/code&gt; was &lt;code&gt;Traits::eof()&lt;/code&gt;, in which case &lt;code&gt;Traits::not_eof(c)&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 成功，除非 &lt;code&gt;c&lt;/code&gt; 是 &lt;code&gt;Traits::eof()&lt;/code&gt; ，在这种情况下，返回 &lt;code&gt;Traits::not_eof(c)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7f9b20f1dc860253fa886fac6fad0c25eb76b95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;, a value of type &lt;code&gt;const CharT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;const CharT&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="e3fb041f39c4cd76a7056dff86c286a069714d0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_str() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size()]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c_str() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; 对于 &lt;code&gt;[0, size()]&lt;/code&gt; 每个 &lt;code&gt;i&lt;/code&gt; ，c_str（）+ i == std :: addressof（operator []（i））。</target>
        </trans-unit>
        <trans-unit id="89aa3cbc65df52ce608a5e7ac02629217ec8ff46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_str()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; perform the same function.</source>
          <target state="translated">&lt;code&gt;c_str()&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; 执行相同的功能。</target>
        </trans-unit>
        <trans-unit id="6201ce88486526a9d5a89edff10f9b5e844bcd6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c_str()[i] == operator[](i)&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;c_str()[i] == operator[](i)&lt;/code&gt; 对于每个 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;[0, size())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="695d6e4e6f82836c536ff6f67b5f20765d596e63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;canonical&lt;/code&gt; has a spurious &lt;code&gt;base&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;canonical&lt;/code&gt; 具有虚假的 &lt;code&gt;base&lt;/code&gt; 参数</target>
        </trans-unit>
        <trans-unit id="e9d778424d09648ae8bb3c55c8adff2c01840148" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;capacity&lt;/code&gt; -- total size of the filesystem, in bytes</source>
          <target state="translated">&lt;code&gt;capacity&lt;/code&gt; -文件系统的总大小，以字节为单位</target>
        </trans-unit>
        <trans-unit id="e0aa74fd60235dd91c5b99d21f5b5e7a5710903c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catalog&lt;/code&gt; was erroneously specified as &lt;code&gt;int&lt;/code&gt; in C++11, this was corrected in &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2028&quot;&gt;LWG issue #2028&lt;/a&gt; and included in C++14.</source>
          <target state="translated">&lt;code&gt;catalog&lt;/code&gt; 在C ++ 11中被错误地指定为 &lt;code&gt;int&lt;/code&gt; ，在&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2028&quot;&gt;LWG＃2028中&lt;/a&gt;已得到纠正，并在C ++ 14中包含。</target>
        </trans-unit>
        <trans-unit id="32b335a992e48a7e39b96c9ecbbec7090251bf77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch (&lt;/code&gt;Tobject&lt;code&gt;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;catch (&lt;/code&gt; Tobject &lt;code&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a76c13a4ced6d8aeca096ef03a660eb7e7fa09b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;...&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="951bcd9d5950fad26037ec8b382fe18ad9f95445" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqabstract-declarator(optional)&lt;code&gt;)&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqabstract-declarator(optional)&lt;code&gt;)&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="2abc29fe0d27d382c9e9d7ae5c97bad94bc7e7bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqdeclarator&lt;code&gt;)&lt;/code&gt;compound-statement</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;attr(optional)type-specifier-seqdeclarator&lt;code&gt;)&lt;/code&gt;compound-statement</target>
        </trans-unit>
        <trans-unit id="265d210565c8bc198c650902495592b14e615308" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cbegin()&lt;/code&gt; always returns a &lt;a href=&quot;../../iterator&quot;&gt;constant&lt;/a&gt; iterator. It is equivalent to &lt;code&gt;const_cast&amp;lt;const basic_string&amp;amp;&amp;gt;(*this).begin()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cbegin()&lt;/code&gt; 始终返回&lt;a href=&quot;../../iterator&quot;&gt;常量&lt;/a&gt;迭代器。它等效于 &lt;code&gt;const_cast&amp;lt;const basic_string&amp;amp;&amp;gt;(*this).begin()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b53fa0f87ce816608c34ff5bb1db059f792f746f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ch&lt;/code&gt; on success, &lt;code&gt;WEOF&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 成功， &lt;code&gt;WEOF&lt;/code&gt; 失败。</target>
        </trans-unit>
        <trans-unit id="5902bdd8082d07b7175e87e8b6552496268cd717" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ch&lt;/code&gt; on success, &lt;code&gt;WEOF&lt;/code&gt; on failure. If an encoding error occurs, &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;EILSEQ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 成功， &lt;code&gt;WEOF&lt;/code&gt; 失败。如果发生编码错误， &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 设置为 &lt;code&gt;EILSEQ&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="116b892a6e17f0b2ba65fcd7677fdb425a911eea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char16_t&lt;/code&gt; - type for UTF-16 character representation, required to be large enough to represent any UTF-16 code unit (16 bits). It has the same size, signedness, and alignment as &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least16_t&lt;/a&gt;&lt;/code&gt;, but is a distinct type.</source>
          <target state="translated">&lt;code&gt;char16_t&lt;/code&gt; -UTF-16字符表示的类型，必须足够大以表示任何UTF-16代码单元（16位）。它具有与 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least16_t&lt;/a&gt;&lt;/code&gt; 相同的大小，符号和对齐方式，但是是不同的类型。</target>
        </trans-unit>
        <trans-unit id="945338457821b46645aa197b8c00ce884b6a5203" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char16_t&lt;/code&gt; or &lt;code&gt;char32_t&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;char16_t&lt;/code&gt; 或 &lt;code&gt;char32_t&lt;/code&gt; （自C ++ 11起）</target>
        </trans-unit>
        <trans-unit id="ad9febd37adb97f5e837608e018649d4d054b2ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char32_t&lt;/code&gt; - type for UTF-32 character representation, required to be large enough to represent any UTF-32 code unit (32 bits). It has the same size, signedness, and alignment as &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least32_t&lt;/a&gt;&lt;/code&gt;, but is a distinct type.</source>
          <target state="translated">&lt;code&gt;char32_t&lt;/code&gt; -UTF-32字符表示的类型，必须足够大以表示任何UTF-32代码单元（32位）。它具有与 &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint_least32_t&lt;/a&gt;&lt;/code&gt; 相同的大小，符号和对齐方式，但是是不同的类型。</target>
        </trans-unit>
        <trans-unit id="2f76727583c7173fe3787d74015da4f9af2fb447" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char8_t&lt;/code&gt; - type for UTF-8 character representation, required to be large enough to represent any UTF-8 code unit (8 bits). It has the same size, signedness, and alignment as &lt;code&gt;unsigned char&lt;/code&gt; (and. therefore, the same size and alignment as &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;signed char&lt;/code&gt;), but is a distinct type.</source>
          <target state="translated">&lt;code&gt;char8_t&lt;/code&gt; -UTF-8字符表示的类型，必须足够大以表示任何UTF-8代码单元（8位）。它具有与 &lt;code&gt;unsigned char&lt;/code&gt; 相同的大小，有符号性和对齐方式（因此，与 &lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;signed char&lt;/code&gt; 相同的大小和对齐方式），但是它是一个不同的类型。</target>
        </trans-unit>
        <trans-unit id="a95fe516a9410a312c1068687b2ef3abb86b13de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char8_t&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;char8_t&lt;/code&gt; （C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="67a29b292971e9727b5bd8ba50bf35dfa62b49ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; - type for character representation which can be most efficiently processed on the target system (has the same representation and alignment as either &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, but is always a distinct type). &lt;a href=&quot;../string/multibyte&quot;&gt;Multibyte characters strings&lt;/a&gt; use this type to represent code units. The character types are large enough to represent any UTF-8 eight-bit code unit(since C++14). The signedness of &lt;code&gt;char&lt;/code&gt; depends on the compiler and the target platform: the defaults for ARM and PowerPC are typically unsigned, the defaults for x86 and x64 are typically signed.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; -字符表示的类型，可以在目标系统上最有效地进行处理（具有与 &lt;code&gt;signed char&lt;/code&gt; 或 &lt;code&gt;unsigned char&lt;/code&gt; 相同的表示和对齐方式，但始终是不同的类型）。&lt;a href=&quot;../string/multibyte&quot;&gt;多字节字符串&lt;/a&gt;使用此类型表示代码单位。字符类型足够大，可以表示任何UTF-8八位代码单元（自C ++ 14起）。 &lt;code&gt;char&lt;/code&gt; 的签名取决于编译器和目标平台：ARM和PowerPC的默认值通常是无符号的，x86和x64的默认值通常是有符号的。</target>
        </trans-unit>
        <trans-unit id="025be35fa02ce9330b9d00a12b219b118b301b0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; can be converted to &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt; depending on the underlying type: &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt; (see above);</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 可被转化为 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;unsigned int&lt;/code&gt; 取决于底层类型： &lt;code&gt;signed char&lt;/code&gt; 或 &lt;code&gt;unsigned char&lt;/code&gt; （见上文）;</target>
        </trans-unit>
        <trans-unit id="47a3a82c4593fa0959ef8cbe7bf50f291eea94cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 或 &lt;code&gt;wchar_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fb8babbd1e77119f20f4cc12d08b49df3573f51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt;).</target>
        </trans-unit>
        <trans-unit id="8902bbe3b62d5a977dd3062a35a69ce055124a21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_traits&amp;lt;char16_t&amp;gt;&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;char_traits&amp;lt;char16_t&amp;gt;&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="d2dc1a15f34d17da88aad9dde6ec3e69635d3345" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_traits&amp;lt;char32_t&amp;gt;&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;char_traits&amp;lt;char32_t&amp;gt;&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="34589ff4f2cb873608e4f3a38668d00d2387c096" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_traits&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;char_traits&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="bd37483306e249adabda089c75cf31326832d4e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chrono&lt;/code&gt; I/O</source>
          <target state="translated">&lt;code&gt;chrono&lt;/code&gt; I / O</target>
        </trans-unit>
        <trans-unit id="1a4855b8a75e7b38866fc680ea79de08951ccd36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cl&lt;/code&gt;, an object of type &lt;code&gt;X::char_class_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cl&lt;/code&gt; ，类型为 &lt;code&gt;X::char_class_type&lt;/code&gt; 的对象</target>
        </trans-unit>
        <trans-unit id="57a18910b3fe4f7ebabccebcdfec1c594102f977" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class-template-name&amp;lt;I&amp;gt;&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;class-template-name&amp;lt;I&amp;gt;&lt;/code&gt;;</target>
        </trans-unit>
        <trans-unit id="447e41573e79eb660fb45e428d9831293a2bb516" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class-template-name&amp;lt;T&amp;gt;&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;class-template-name&amp;lt;T&amp;gt;&lt;/code&gt;;</target>
        </trans-unit>
        <trans-unit id="840262bf641c742885644a8867137b23e642ee04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clear&lt;/code&gt; invalidates all iterators and references. Because it erases all elements, this technically complies with the rules above.</source>
          <target state="translated">&lt;code&gt;clear&lt;/code&gt; 使所有迭代器和引用无效。因为它删除了所有元素，所以从技术上讲，它符合上述规则。</target>
        </trans-unit>
        <trans-unit id="40837755ab7959ccd1e6e1c575733ddfc3d086ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close()&lt;/code&gt; is typically called through the destructor of &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (which, in turn, is typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;close()&lt;/code&gt; 通常是通过 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 的析构函数调用的（反过来，通常由 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 的析构函数调用。</target>
        </trans-unit>
        <trans-unit id="3d9dcf30735aeba307868d3b80bb591d9d12750b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_await&lt;/code&gt;expr</source>
          <target state="translated">&lt;code&gt;co_await&lt;/code&gt;expr</target>
        </trans-unit>
        <trans-unit id="b54d011270f4edc60c88fc86547fc85c84bfc825" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_return expr&lt;/code&gt; where expr has type void</source>
          <target state="translated">&lt;code&gt;co_return expr&lt;/code&gt; ，其中expr为void类型</target>
        </trans-unit>
        <trans-unit id="b6af45614986a085cc196762b62c12a486df7559" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_yield&lt;/code&gt;braced-init-list</source>
          <target state="translated">&lt;code&gt;co_yield&lt;/code&gt;braced-init-list</target>
        </trans-unit>
        <trans-unit id="95154f3d418ab26ed6d327edf5d5ebfec32b9c6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;co_yield&lt;/code&gt;expr</source>
          <target state="translated">&lt;code&gt;co_yield&lt;/code&gt;expr</target>
        </trans-unit>
        <trans-unit id="6faca95322a3b3d33815965dd2f73dd6ccf68e98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;common_type&amp;lt;int, int&amp;gt;::type&lt;/code&gt; is &lt;code&gt;int&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;common_type&amp;lt;int, int&amp;gt;::type&lt;/code&gt; 是 &lt;code&gt;int&amp;amp;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e8493c1deebf8f0e11beacd2cc163a9d752492e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;common_type&lt;/code&gt; is not SFINAE-friendly</source>
          <target state="translated">&lt;code&gt;common_type&lt;/code&gt; 对SFINAE不友好</target>
        </trans-unit>
        <trans-unit id="64efe9a1bf02848912f9333dac7816a88d09c9cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;common_type&lt;/code&gt; specializations are nearly impossible to write</source>
          <target state="translated">&lt;code&gt;common_type&lt;/code&gt; 专业化几乎是不可能写的</target>
        </trans-unit>
        <trans-unit id="554fb3f88c0ecbe59bb9447e2022926cd7b08560" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;comp(lhs.first, rhs.first)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;comp(lhs.first, rhs.first)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f2523d45a894bd83c166d7c2f86f45441c477dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;comp&lt;/code&gt;, an object of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;comp&lt;/code&gt; ， &lt;code&gt;T&lt;/code&gt; 类型的对象</target>
        </trans-unit>
        <trans-unit id="cdf1059c5241ff6172285cce25a7e15b8a2a809d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;complex&lt;/code&gt;&amp;lt;float&amp;gt;&lt;code&gt;complex&lt;/code&gt;&amp;lt;double&amp;gt;&lt;code&gt;complex&lt;/code&gt;&amp;lt;long double&amp;gt;</source>
          <target state="translated">&lt;code&gt;complex&lt;/code&gt; &amp;lt;float&amp;gt; &lt;code&gt;complex&lt;/code&gt; &amp;lt;double&amp;gt; &lt;code&gt;complex&lt;/code&gt; &amp;lt;long double&amp;gt;</target>
        </trans-unit>
        <trans-unit id="26dc5a3ad5b984fe0791f4d98e3a2ae086ecdace" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concept&lt;/code&gt;concept-name&lt;code&gt;=&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;concept&lt;/code&gt;concept-name&lt;code&gt;=&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="297480fbe0c371720393479054cc75c4eb9efe23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;condition_variable&lt;/code&gt; is used in combination with a &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; to facilitate inter-thread communication.</source>
          <target state="translated">&lt;code&gt;condition_variable&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; 结合使用以促进线程间通信。</target>
        </trans-unit>
        <trans-unit id="ce602ea724c696fc4264247e3f5c11195508073e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const T&amp;amp;&lt;/code&gt; otherwise (&lt;code&gt;It&lt;/code&gt; is constant),</source>
          <target state="translated">&lt;code&gt;const T&amp;amp;&lt;/code&gt; 否则（ &lt;code&gt;It&lt;/code&gt; 是常数），</target>
        </trans-unit>
        <trans-unit id="a996f39e93f402c926c96e8454425deb9f7fa668" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const T*&lt;/code&gt; specialization member types</source>
          <target state="translated">&lt;code&gt;const T*&lt;/code&gt; 专业化成员类型</target>
        </trans-unit>
        <trans-unit id="8ee674418aeb67071bc8ac00d898ea7ae954fdb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const char16_t[]&lt;/code&gt; or &lt;code&gt;const char32_t[]&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;const char16_t[]&lt;/code&gt; 或 &lt;code&gt;const char32_t[]&lt;/code&gt; （自C ++ 11起）</target>
        </trans-unit>
        <trans-unit id="66f567ad8c4304d5cdef87608b2a1af88972dada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const char8_t[]&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;const char8_t[]&lt;/code&gt; （自C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="9eed69b60f79e50e3e0cbc5aa8f6736a3226f411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const char[]&lt;/code&gt; or &lt;code&gt;const wchar_t[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const char[]&lt;/code&gt; 或 &lt;code&gt;const wchar_t[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6df32d7fb02903624617eb9d49776e35b4496ecc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int (* volatile S::* const)[20]&lt;/code&gt; and &lt;code&gt;int (* const S::* volatile)[20]&lt;/code&gt; are similar;</source>
          <target state="translated">&lt;code&gt;const int (* volatile S::* const)[20]&lt;/code&gt; 和 &lt;code&gt;int (* const S::* volatile)[20]&lt;/code&gt; 类似；</target>
        </trans-unit>
        <trans-unit id="47f8209f26f85dfd3a4a12e900c44507f02c23a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int (*)(int *)&lt;/code&gt; and &lt;code&gt;int (*)(int *)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;const int (*)(int *)&lt;/code&gt; 和 &lt;code&gt;int (*)(int *)&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="52508689cda680f3e3c998354c4471c1de258e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const int * volatile *&lt;/code&gt; and &lt;code&gt;int * * const&lt;/code&gt; are similar;</source>
          <target state="translated">&lt;code&gt;const int * volatile *&lt;/code&gt; 和 &lt;code&gt;int * * const&lt;/code&gt; 相似；</target>
        </trans-unit>
        <trans-unit id="515e72e3784d234c7642a509460ae78aecf30768" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; &amp;lt; &lt;code&gt;const volatile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; &amp;lt; &lt;code&gt;const volatile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ecbcb74ecd84607917d5d8459726b7ca1500a93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; - defines that the type is</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; -定义类型为</target>
        </trans-unit>
        <trans-unit id="849523fe8ba7e5e307622eb0fcdc78dfb1857ae3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Object of type &lt;code&gt;X::hasher&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 类型 &lt;code&gt;X::hasher&lt;/code&gt; const对象</target>
        </trans-unit>
        <trans-unit id="eb46134c57f52e5a5e9f17f34016e7e0dde21300" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Object of type &lt;code&gt;X::key_equal&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 类型 &lt;code&gt;X::key_equal&lt;/code&gt; const对象</target>
        </trans-unit>
        <trans-unit id="3b2f6157e9d655a9fd9e59e89ed7af589e05200b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; Object of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 类型 &lt;code&gt;X&lt;/code&gt; 的对象</target>
        </trans-unit>
        <trans-unit id="8fd4e9f1b889fc95d587a6ae498ab55f271be55b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; type qualifier</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 类型限定符</target>
        </trans-unit>
        <trans-unit id="86870f391072bb2629fd0ebc05f5cc5f658c6111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; 表达式 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4df3b2f2a6e041b66d00d0f4162026f7c6293554" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;const_cast&lt;/code&gt; 转换</target>
        </trans-unit>
        <trans-unit id="73834da188aa4ff3291884a29d89d96fcef4eee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_cast&lt;/code&gt; makes it possible to form a reference or pointer to non-const type that is actually referring to a &lt;a href=&quot;cv&quot;&gt;const object&lt;/a&gt; or a reference or pointer to non-volatile type that is actually referring to a &lt;a href=&quot;cv&quot;&gt;volatile object&lt;/a&gt;. Modifying a const object through a non-const access path and referring to a volatile object through a non-volatile &lt;a href=&quot;value_category#glvalue&quot;&gt;glvalue&lt;/a&gt; results in undefined behavior.</source>
          <target state="translated">&lt;code&gt;const_cast&lt;/code&gt; 可以形成实际上指向&lt;a href=&quot;cv&quot;&gt;const对象的&lt;/a&gt;非const类型的引用或指针，或者实际上指向&lt;a href=&quot;cv&quot;&gt;volatile对象的&lt;/a&gt;非volatile类型的引用或指针。通过非常量访问路径修改const对象，并通过非易失性&lt;a href=&quot;value_category#glvalue&quot;&gt;glvalue&lt;/a&gt;引用volatile对象会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="1b05714965760fefb084cefcc9d67a2e9e945860" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_iterator&lt;/code&gt; to the character following the last character.</source>
          <target state="translated">&lt;code&gt;const_iterator&lt;/code&gt; 到最后一个字符之后的字符。</target>
        </trans-unit>
        <trans-unit id="ff3530967d52517c00cc586fba76e43e4a0a499f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_iterator&lt;/code&gt; to the first character.</source>
          <target state="translated">&lt;code&gt;const_iterator&lt;/code&gt; 到第一个字符。</target>
        </trans-unit>
        <trans-unit id="7a75a6dc00b537c7e4ccb590a1cf2062b47a7c48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_pointer&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;const_pointer&lt;/code&gt; （在C ++ 17中已弃用）（在C ++ 20中已删除）</target>
        </trans-unit>
        <trans-unit id="db5830dbbab3c9f6d28543e44b265d86291893a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reference&lt;/code&gt; for const a.</source>
          <target state="translated">&lt;code&gt;const_reference&lt;/code&gt; 用于const a。</target>
        </trans-unit>
        <trans-unit id="697d0afbfbbac7bcabba065341cb16898159a75d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reference&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;const_reference&lt;/code&gt; （C ++ 17中已弃用）（C ++ 20中已删除）</target>
        </trans-unit>
        <trans-unit id="f582d6a3965005d8ce7701813243bbd8179302b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reverse_iterator&lt;/code&gt; to the character following the last character.</source>
          <target state="translated">&lt;code&gt;const_reverse_iterator&lt;/code&gt; 到最后一个字符之后的字符。</target>
        </trans-unit>
        <trans-unit id="d40cb8bf749e11876abefa1600db4e84ee627a91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const_reverse_iterator&lt;/code&gt; to the first character.</source>
          <target state="translated">&lt;code&gt;const_reverse_iterator&lt;/code&gt; 到第一个字符。</target>
        </trans-unit>
        <trans-unit id="997295cc2d3b4a33cc70ee37adc5f4933187cd57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;consteval&lt;/code&gt; - specifies that a function is an</source>
          <target state="translated">&lt;code&gt;consteval&lt;/code&gt; -指定一个函数是一个</target>
        </trans-unit>
        <trans-unit id="f174eb524209ad8a24d7788c23ab74fb724c4c41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;consteval&lt;/code&gt;: specifies that the function call operator is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt;. &lt;code&gt;consteval&lt;/code&gt; and &lt;code&gt;constexpr&lt;/code&gt; cannot be used at the same time.</source>
          <target state="translated">&lt;code&gt;consteval&lt;/code&gt; ：指定函数调用运算符为&lt;a href=&quot;consteval&quot;&gt;立即函数&lt;/a&gt;。 &lt;code&gt;consteval&lt;/code&gt; 和 &lt;code&gt;constexpr&lt;/code&gt; 不能同时使用。</target>
        </trans-unit>
        <trans-unit id="60390c6e7c6371a354f2d11599e1853f362f7b67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; - specifies that the value of a variable or function can appear in &lt;a href=&quot;constant_expression&quot;&gt;constant expressions&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; -指定变量或函数的值可以出现在&lt;a href=&quot;constant_expression&quot;&gt;常量表达式中&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfd989462cbbec291a71037d602f200cc2b6115d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; function template returning the greatest common divisor of two integers</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; 函数模板，返回两个整数的最大公约数</target>
        </trans-unit>
        <trans-unit id="66f79f40a4b87ef73a0f44c9587b2f9522b60936" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; function template returning the least common multiple of two integers</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; 函数模板，返回两个整数的最小公倍数</target>
        </trans-unit>
        <trans-unit id="d48f275f501771bc35ea1b933c63b8ca18257d2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; value of type &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;abs(Denom) / gcd(Num, Denom)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; constexpr值等于 &lt;code&gt;abs(Denom) / gcd(Num, Denom)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78223edf07f451eab868f42e4d9bfd12755afd42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt; value of type &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;sign(Num) * sign(Denom) * abs(Num) / gcd(Num, Denom)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; constexpr值等于 &lt;code&gt;sign(Num) * sign(Denom) * abs(Num) / gcd(Num, Denom)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4239f3fafdcb184672789e0caaa9b1ac92caab06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;constexpr&lt;/code&gt;: explicitly specifies that the function call operator is a &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; function. When this specifier is not present, the function call operator will be &lt;code&gt;constexpr&lt;/code&gt; anyway, if it happens to satisfy all constexpr function requirements</source>
          <target state="translated">&lt;code&gt;constexpr&lt;/code&gt; ：明确指定函数调用运算符是&lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;函数。如果此说明符不存在，则函数调用运算符恰好满足所有constexpr函数要求，无论如何，它将是 &lt;code&gt;constexpr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c21b845984d62717a898bcc9bb64709bf51e4868" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;container&lt;/code&gt;(protected member object)</source>
          <target state="translated">&lt;code&gt;container&lt;/code&gt; （受保护的成员对象）</target>
        </trans-unit>
        <trans-unit id="6d86df7b769f8c1634520185d4a68bac68fa2fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;container&lt;/code&gt;(protected)</source>
          <target state="translated">&lt;code&gt;container&lt;/code&gt;(protected)</target>
        </trans-unit>
        <trans-unit id="2ee4f7675766eb987c78ea16c7ca4abc8bedea9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contiguous_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;contiguous_iterator_tag&lt;/code&gt; 对应于&lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99de603392e55955fac05bfba02c1711ee23a25b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copy_options&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type). &lt;code&gt;none&lt;/code&gt; represents the empty bitmask; every other enumerator represents a distinct bitmask element.</source>
          <target state="translated">&lt;code&gt;copy_options&lt;/code&gt; 满足的要求&lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;（这意味着按位运算符 &lt;code&gt;operator&amp;amp;&lt;/code&gt; ， &lt;code&gt;operator|&lt;/code&gt; ， &lt;code&gt;operator^&lt;/code&gt; ， &lt;code&gt;operator~&lt;/code&gt; ， &lt;code&gt;operator&amp;amp;=&lt;/code&gt; ， &lt;code&gt;operator|=&lt;/code&gt; ，和 &lt;code&gt;operator^=&lt;/code&gt; 被用于这种类型定义）。 &lt;code&gt;none&lt;/code&gt; 代表空的位掩码；其他每个枚举器都代表一个不同的位掩码元素。</target>
        </trans-unit>
        <trans-unit id="0e9c49a708a699991cfa76215085b76622684a55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;copyfmt()&lt;/code&gt; may be used to save and restore the state of a stream. Boost provides a more fine-grained &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/io/doc/ios_state.html&quot;&gt;IO state savers&lt;/a&gt; library for the same purpose.</source>
          <target state="translated">&lt;code&gt;copyfmt()&lt;/code&gt; 可用于保存和恢复流的状态。Boost 出于相同目的提供了更细粒度的&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/io/doc/ios_state.html&quot;&gt;IO状态保护程序&lt;/a&gt;库。</target>
        </trans-unit>
        <trans-unit id="67284dc08863291b978ed366654a06f2dfc06c26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count-1&lt;/code&gt; characters have been extracted (in which case &lt;code&gt;setstate(failbit)&lt;/code&gt; is executed).</source>
          <target state="translated">&lt;code&gt;count-1&lt;/code&gt; 已提取count-1个字符（在这种情况下，将执行 &lt;code&gt;setstate(failbit)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="14c1d900f819911905383fbcb787713b7c0b5161" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count-1&lt;/code&gt; characters have been stored</source>
          <target state="translated">&lt;code&gt;count-1&lt;/code&gt; 已存储1个字符</target>
        </trans-unit>
        <trans-unit id="4370421f845ed887052d082daed02d0e18096fda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; characters were extracted and stored</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 字符被提取并存储</target>
        </trans-unit>
        <trans-unit id="574c30c0681bfef17be02cc120d42b90c22648db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; characters were extracted. This test is disabled in the special case when &lt;code&gt;count&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 提取了计数字符。在特殊情况下，当 &lt;code&gt;count&lt;/code&gt; 等于 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max()&lt;/code&gt; &amp;lt; &lt;a href=&quot;../streamsize&quot;&gt;std :: streamsize&lt;/a&gt; &amp;gt; :: max（）时，将禁用此测试</target>
        </trans-unit>
        <trans-unit id="1ac51d4b143d94e6de0cb20876eeda02db8ba0f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;&lt;code&gt; - index&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; &lt;code&gt; - index&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a25961a22949d5108d96f348e53bd2197bde8ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cptr&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_pointer&lt;/code&gt;, obtained by conversion from &lt;code&gt;ptr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cptr&lt;/code&gt; ，它是通过从 &lt;code&gt;ptr&lt;/code&gt; 转换获得的 &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_pointer&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="e8df13a1dc06479e30c994b1d8c70e8b5752fc60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cs&lt;/code&gt;, an object of type &lt;code&gt;const X::string_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cs&lt;/code&gt; ，类型为 &lt;code&gt;const X::string_type&lt;/code&gt; 的对象</target>
        </trans-unit>
        <trans-unit id="762b5aaed1848d4d32f2c16128b1af381c844d8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current&lt;/code&gt;(private)</source>
          <target state="translated">&lt;code&gt;current&lt;/code&gt;(private)</target>
        </trans-unit>
        <trans-unit id="ef5daddd507bab168de9ec7cde201b949b2a2274" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;current&lt;/code&gt;(protected)</source>
          <target state="translated">&lt;code&gt;current&lt;/code&gt;(protected)</target>
        </trans-unit>
        <trans-unit id="165cd74ab0314daa74559a33432202810671ce0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cv-list T&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;cv-list T&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="c0c4671227f8ea9a45bf577b5a7e4b537aeb1997" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cvptr&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_void_pointer&lt;/code&gt;, obtained by conversion from &lt;code&gt;cptr&lt;/code&gt; or from &lt;code&gt;vptr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cvptr&lt;/code&gt; ，类型 &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::const_void_pointer&lt;/code&gt; 的值，是通过从 &lt;code&gt;cptr&lt;/code&gt; 或从 &lt;code&gt;vptr&lt;/code&gt; 转换而获得的</target>
        </trans-unit>
        <trans-unit id="1cd93fe2dba1d9398c3a10408b3a9cc95efd41db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d.count()&lt;/code&gt; is formatted using the rules of &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;&lt;/code&gt;. In particular, if &lt;code&gt;Rep&lt;/code&gt; is a floating-point type, it is always formatted with 6 digits after the decimal point, and the number of significant digits in the resulting string may be zero if &lt;code&gt;d.count()&lt;/code&gt; is small.</source>
          <target state="translated">&lt;code&gt;d.count()&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;&lt;/code&gt; 规则进行格式化。特别是，如果 &lt;code&gt;Rep&lt;/code&gt; 是浮点类型，则始终将其格式化为小数点后6位数字，并且如果 &lt;code&gt;d.count()&lt;/code&gt; 小，则结果字符串中的有效数字位数可能为零。</target>
        </trans-unit>
        <trans-unit id="651f9fdce67570503479d6ae44a4f63b5a121f00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; converted to a duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 转换为 &lt;code&gt;ToDuration&lt;/code&gt; 类型的持续时间。</target>
        </trans-unit>
        <trans-unit id="3556a8cbed18d0c1515390f4058f1738c12097f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded down to a duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 向下舍入为 &lt;code&gt;ToDuration&lt;/code&gt; 类型的持续时间。</target>
        </trans-unit>
        <trans-unit id="a0df75951e723a2a73f0a26e7b0f6523aabc62df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded down to a the next time point using duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 使用 &lt;code&gt;ToDuration&lt;/code&gt; 类型的duration向下舍入到下一个时间点。</target>
        </trans-unit>
        <trans-unit id="91429683e5e5d73122930f863155680438d3cef5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded to nearest time point using duration of type &lt;code&gt;ToDuration&lt;/code&gt;, rounding to even in halfway cases.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 使用 &lt;code&gt;ToDuration&lt;/code&gt; 类型的持续时间四舍五入到最近的时间点，在中途情况下四舍五入为偶数。</target>
        </trans-unit>
        <trans-unit id="ddb5d33a92a03c56ccd48c588ed2837d58e323c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded to the nearest duration of type &lt;code&gt;ToDuration&lt;/code&gt;, rounding to even in halfway cases.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 舍入为 &lt;code&gt;ToDuration&lt;/code&gt; 类型的最近持续时间，在中途情况下舍入为偶数。</target>
        </trans-unit>
        <trans-unit id="16443f163b0e6c80febceec5eec07385daff8273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded up to a duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 舍入为 &lt;code&gt;ToDuration&lt;/code&gt; 类型的持续时间。</target>
        </trans-unit>
        <trans-unit id="ba1cb3758fcce4c43dfa0709d08b3a59b9056177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt; rounded up to a the next time point using duration of type &lt;code&gt;ToDuration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 使用 &lt;code&gt;ToDuration&lt;/code&gt; 类型的duration向上舍入到下一个时间点。</target>
        </trans-unit>
        <trans-unit id="183399524adf86e2819866b426f01c7672820d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;d&lt;/code&gt;, a value of type &lt;code&gt;D&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; ，类型 &lt;code&gt;D&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="e3bb057ec0cff334c09022fc05ef1585e446c51a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dangling&lt;/code&gt; is a placeholder type and an empty class type, used together with the template aliases &lt;a href=&quot;safe_iterator_t&quot;&gt;&lt;code&gt;ranges::safe_iterator_t&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;safe_iterator_t&quot;&gt;&lt;code&gt;ranges::safe_subrange_t&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;dangling&lt;/code&gt; 是一个占位符类型和一个空类类型，与模板别名&lt;a href=&quot;safe_iterator_t&quot;&gt; &lt;code&gt;ranges::safe_iterator_t&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;safe_iterator_t&quot;&gt; &lt;code&gt;ranges::safe_subrange_t&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aeed77864ca001a76bddf2e2e61a40c1bd601eac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size()]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data() + i == &lt;a href=&quot;../../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;(operator[](i))&lt;/code&gt; 每一个 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;[0, size()]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3078b7f1d4c80c1b110d86087c6a9c473662279e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data()[i] == operator[](i)&lt;/code&gt; for every &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, size())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data()[i] == operator[](i)&lt;/code&gt; 对于每个 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;[0, size())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc8c38fa982e5b5987d2045d9f1de50971e21b72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;day&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;day&lt;/code&gt; 是一个&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2c8d8959ca5d98560b564de242b2ff6597d0895e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dd&lt;/code&gt; - 2-digit day of the month from &lt;code&gt;timeptr-&amp;gt;tm_mday&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dd&lt;/code&gt; -从该月的2位数天 &lt;code&gt;timeptr-&amp;gt;tm_mday&lt;/code&gt; 仿佛通过印刷 &lt;code&gt;sprintf&lt;/code&gt; 的使用 &lt;code&gt;%2d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a4e33e259910ef0f388744164686b75a72316f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dd&lt;/code&gt; - the day of the month</source>
          <target state="translated">&lt;code&gt;dd&lt;/code&gt; -每月的一天</target>
        </trans-unit>
        <trans-unit id="44934ee72f5258c4f8a1a82e0459ef6eff3639b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decay-copy(E)&lt;/code&gt; if the decayed type of &lt;code&gt;E&lt;/code&gt; models &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;decay-copy(E)&lt;/code&gt; 如果腐朽型的 &lt;code&gt;E&lt;/code&gt; 模型&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="078d40eeb791c9eab2e7e15d623435c16b5089e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype (&lt;/code&gt;entity&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;decltype (&lt;/code&gt; 实体 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4cef2572a50bbbe02226f827cb2bf71f7ae07148" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;decltype (&lt;/code&gt; 表达式 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d07aaf3ec110725af7032c41e5d6408aa1442075" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype(x)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; denotes a structured binding, names the</source>
          <target state="translated">&lt;code&gt;decltype(x)&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 表示结构化绑定，命名为</target>
        </trans-unit>
        <trans-unit id="f1a653258ed2585cc60d039f08f1fbfbf13b7dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype&lt;/code&gt; is useful when declaring types that are difficult or impossible to declare using standard notation, like lambda-related types or types that depend on template parameters.</source>
          <target state="translated">&lt;code&gt;decltype&lt;/code&gt; 在声明使用标准符号难以或不可能声明的类型（例如与lambda相关的类型或依赖模板参数的类型）时，decltype很有用。</target>
        </trans-unit>
        <trans-unit id="07299d3502543191e52ab8611cc9e0f05b87eaa5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;decltype&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;decltype&lt;/code&gt; 说明符</target>
        </trans-unit>
        <trans-unit id="8084031d231829e0e18c517a74547421c9d48533" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declval&lt;/code&gt; is commonly used in templates where acceptable template parameters may have no constructor in common, but have the same member function whose return type is needed.</source>
          <target state="translated">&lt;code&gt;declval&lt;/code&gt; 通常用于模板中，在这些模板中，可接受的模板参数可能没有共同的构造函数，但具有需要返回类型的相同成员函数。</target>
        </trans-unit>
        <trans-unit id="a6dc6c66ff444f92e9f64dbedde3409bfb1824a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dec|oct|hex&lt;/code&gt;. Useful for masking operations</source>
          <target state="translated">&lt;code&gt;dec|oct|hex&lt;/code&gt; 。对遮罩操作有用</target>
        </trans-unit>
        <trans-unit id="cc2d34009345d5e40053315ffb025faba8832df1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_random_engine&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;default_random_engine&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="fc940c3f86e149b6fb8a0ab49cbd0ccb714b4cb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default_searcher&lt;/code&gt; is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;default_searcher&lt;/code&gt; 是&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;和&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="077c4a7145581b449d92305cc732ff815a9e69ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 表达</target>
        </trans-unit>
        <trans-unit id="9a58ce0460f67f92ccc8361cf11684a665c52292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delete&lt;/code&gt;&lt;code&gt;delete[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt;&lt;code&gt;delete[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ed5aed6aee0f8e724cb90f7e02d46ceb3dd3341" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;desired&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;desired&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="96fc1ef1f4ce59d38242b0f4733b4018c5e91675" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="9c3be877342461a62b3323a91353e1089ee314e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt; - a signed integer type that can be used to identify distance between iterators</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; 一个有符号整数类型，可用于标识迭代器之间的距离</target>
        </trans-unit>
        <trans-unit id="8e8722abed6c9126adc03f7ab6341effd317dc53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt; is not defined in the primary &lt;code&gt;atomic&lt;/code&gt; template or in the partial specializations for &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../memory/weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; 在主 &lt;code&gt;atomic&lt;/code&gt; 模板或 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../memory/weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 的部分专业化中未定义difference_type。</target>
        </trans-unit>
        <trans-unit id="c64a0caf494dd72f874d22b68ca58c859f45ef02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt; is not defined in the primary &lt;code&gt;atomic_ref&lt;/code&gt; template.</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; 未在主定义 &lt;code&gt;atomic_ref&lt;/code&gt; 模板。</target>
        </trans-unit>
        <trans-unit id="605f6727baefcb30f85c08791de23fffeae36f3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;difference_type&lt;/code&gt;, the type denoted by &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::difference_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;difference_type&lt;/code&gt; ，类型表示由 &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::difference_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="674eefb4052cba056071a4c1441d7ae046690b63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;directory_iterator&lt;/code&gt; is a &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; that iterates over the &lt;a href=&quot;directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; elements of a directory (but does not visit the subdirectories). The iteration order is unspecified, except that each directory entry is visited only once. The special pathnames dot and dot-dot are skipped.</source>
          <target state="translated">&lt;code&gt;directory_iterator&lt;/code&gt; 是一个&lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;，它遍历&lt;a href=&quot;directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt;元素（但不访问子目录）。未指定迭代顺序，只是每个目录条目仅被访问一次。特殊路径名点和点点被跳过。</target>
        </trans-unit>
        <trans-unit id="829c4c4ce416288a27de4d058572b018eab9b490" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;directory_options&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type). &lt;code&gt;none&lt;/code&gt; represents the empty bitmask; every other enumerator represents a distinct bitmask element.</source>
          <target state="translated">&lt;code&gt;directory_options&lt;/code&gt; 满足&lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;的要求（这意味着为此类型定义了按位运算符 &lt;code&gt;operator&amp;amp;&lt;/code&gt; ， &lt;code&gt;operator|&lt;/code&gt; ， &lt;code&gt;operator^&lt;/code&gt; ， &lt;code&gt;operator~&lt;/code&gt; ， &lt;code&gt;operator&amp;amp;=&lt;/code&gt; ， &lt;code&gt;operator|=&lt;/code&gt; 和 &lt;code&gt;operator^=&lt;/code&gt; ）。 &lt;code&gt;none&lt;/code&gt; 代表空的位掩码；其他每个枚举器都代表一个不同的位掩码元素。</target>
        </trans-unit>
        <trans-unit id="2e930479c54dd2256429b8c01c0a013c61557767" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;discard_block_engine&lt;/code&gt; is a pseudo-random number generator adaptor that discards a certain amount of data produced by the base engine. From each block of size &lt;code&gt;P&lt;/code&gt; generated by the base engine, the adaptor keeps only &lt;code&gt;R&lt;/code&gt; numbers, discarding the rest.</source>
          <target state="translated">&lt;code&gt;discard_block_engine&lt;/code&gt; 是一个伪随机数生成器适配器，它丢弃基本引擎生成的一定数量的数据。从基本引擎生成的每个大小为 &lt;code&gt;P&lt;/code&gt; 的块中，适配器仅保留 &lt;code&gt;R&lt;/code&gt; 号，其余部分则丢弃。</target>
        </trans-unit>
        <trans-unit id="a7a9857b4458b10f76bad1287594cfca5be13bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double&lt;/code&gt; value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of the return type, the return value is undefined. If no conversion can be performed, &lt;code&gt;0.0&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt; 成功时对应于 &lt;code&gt;str&lt;/code&gt; 内容的double值。如果转换后的值超出返回类型的范围，则返回值是不确定的。如果无法执行转换，则返回 &lt;code&gt;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e64f9f04e39c7e554c344fe1b8a940257bb356a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;double&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;double&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="0afff59ccefd7da74ebc53ac40b22ad894d74b4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;duration&lt;/code&gt; to copy from</source>
          <target state="translated">&lt;code&gt;duration&lt;/code&gt; 复制的持续时间</target>
        </trans-unit>
        <trans-unit id="4281bf65b65452c452d3ec6c674684e06dfd8cbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dynamic_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; 表达式 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8238dbb029f152a176f6c19d54b08e09c4978a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;dynamic_cast&lt;/code&gt; 转换</target>
        </trans-unit>
        <trans-unit id="093e05fc743668e8b3ebc73ef075855f8b635caa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dynamic_cast&lt;/code&gt; or &lt;code&gt;typeid&lt;/code&gt; expressions.</source>
          <target state="translated">&lt;code&gt;dynamic_cast&lt;/code&gt; 或 &lt;code&gt;typeid&lt;/code&gt; 表达式。</target>
        </trans-unit>
        <trans-unit id="2253736d7af1b4fa986169ef0ac6ea784c56ac02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e, f&lt;/code&gt;, values of type &lt;code&gt;X::int_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e, f&lt;/code&gt; ，类型为 &lt;code&gt;X::int_type&lt;/code&gt; 值</target>
        </trans-unit>
        <trans-unit id="78e0ec35ac993e5d463c1502149eaa544cbb4c65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e.get&amp;lt;i&amp;gt;()&lt;/code&gt;, if lookup for the identifier &lt;code&gt;get&lt;/code&gt; in the scope of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; by class member access lookup finds at least one declaration that is a function template whose first template parameter is a non-type parameter</source>
          <target state="translated">&lt;code&gt;e.get&amp;lt;i&amp;gt;()&lt;/code&gt; ，如果通过类成员访问在 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 的范围内查找标识符，则查找 &lt;code&gt;get&lt;/code&gt; 找到至少一个声明，该声明是一个函数模板，其第一个模板参数是非类型参数&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="13cd5e6dd0d5f72fe829b7c9c3af3e1387fde400" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; has an immediate subexpression that is potentially-throwing</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 具有可能被抛出的立即子表达式</target>
        </trans-unit>
        <trans-unit id="198087d50eb4b71b3034a51e4177330cb59ef362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; if &lt;code&gt;X​::​eq_int_type(e, X​::​eof())&lt;/code&gt; is false</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 如果 &lt;code&gt;X​::​eq_int_type(e, X​::​eof())&lt;/code&gt; 是假的</target>
        </trans-unit>
        <trans-unit id="81a63e0f7a1fa5d3862bbf48583450c2410bc4b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; if &lt;code&gt;e&lt;/code&gt; and</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 如果 &lt;code&gt;e&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="e51930a3435e04d0b1af0277065a00be36f910ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; that casts a polymorphic reference type</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 是对多态引用类型进行强制转换的&lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf1fdd68c9dc26bdf66120e899db55f937491e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 是一个&lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d29dcac31c9d9d957b9cab2b7e7b0595348049d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt; expression applied to a dereferenced pointer to a polymorphic type</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 是一个&lt;a href=&quot;typeid&quot;&gt;Typeid&lt;/a&gt;表达式，应用于一个指向多态类型的解除引用的指针</target>
        </trans-unit>
        <trans-unit id="8525600fecd6ad271a9b35fb4310321803537880" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; is a function call to a</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 是对a的函数调用</target>
        </trans-unit>
        <trans-unit id="83682ad848127e8d972825cf60b01a4d1ce26671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; makes an implicit call to a</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; 对a进行隐式调用</target>
        </trans-unit>
        <trans-unit id="ad4ed26807ff3a1be89ef12864b69ad7937db687" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt; | &lt;code&gt;E&lt;/code&gt;exponent-sign(optional)digit-sequence</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; | &lt;code&gt;E&lt;/code&gt; 指数符号（可选）数字序列</target>
        </trans-unit>
        <trans-unit id="bf415de3f3608ad294691f55bcab37fd2e95a1f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; ， &lt;code&gt;E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8f05f2ec9f57075c86ff42ec6032858ca5f430b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;e&lt;/code&gt;, a non-const value of type &lt;code&gt;E&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;e&lt;/code&gt; ，类型 &lt;code&gt;E&lt;/code&gt; 的非常量值</target>
        </trans-unit>
        <trans-unit id="a60fb4aafcf27b03b577305dea2cefe453740828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;element_type&lt;/code&gt; was not updated for array support</source>
          <target state="translated">&lt;code&gt;element_type&lt;/code&gt; 未更新为数组支持</target>
        </trans-unit>
        <trans-unit id="a98ac6d89c7ed950198f31905d6401942c23ed46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt;statement-false</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt;statement-false</target>
        </trans-unit>
        <trans-unit id="7a16baeb5992329a7fbbccf120a1ee402b84130c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;emplace&lt;/code&gt; returned &lt;code&gt;reference&lt;/code&gt;, breaking compatibility with pre-C++17 containers</source>
          <target state="translated">&lt;code&gt;emplace&lt;/code&gt; 返回的 &lt;code&gt;reference&lt;/code&gt; ，破坏了与C ++ 17之前的容器的兼容性</target>
        </trans-unit>
        <trans-unit id="db6a754161971e2f16d66f027bb5654e3ebcb03b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty_view&lt;/code&gt; does not reference any element.</source>
          <target state="translated">&lt;code&gt;empty_view&lt;/code&gt; 不引用任何元素。</target>
        </trans-unit>
        <trans-unit id="f64e8ad0206e4e3d2f71704519756ca7cefcee0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;empty_view&lt;/code&gt; is always empty.</source>
          <target state="translated">&lt;code&gt;empty_view&lt;/code&gt; 始终为空。</target>
        </trans-unit>
        <trans-unit id="8f61ebafa708b9099b0bae824de3758d80065782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enable_shared_from_this&lt;/code&gt; provides the safe alternative to an expression like &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(this)&lt;/code&gt;, which is likely to result in &lt;code&gt;this&lt;/code&gt; being destructed more than once by multiple owners that are unaware of each other (see example below).</source>
          <target state="translated">&lt;code&gt;enable_shared_from_this&lt;/code&gt; 提供了类似于 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(this)&lt;/code&gt; 类的表达式的安全替代方法，这很可能会导致多个彼此不知道的所有者多次破坏 &lt;code&gt;this&lt;/code&gt; 函数（请参见下面的示例）。</target>
        </trans-unit>
        <trans-unit id="7fc22c384dd5d5d6c09837f18ec1281990d0f5b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a69f14aaeaeff8576804f56671474ae6698e5614" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; &lt;code&gt;struct|class&lt;/code&gt; 名称 &lt;code&gt;:&lt;/code&gt; 类型 &lt;code&gt;{&lt;/code&gt; 枚举 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; 枚举 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="589810a338b7c285afc57b48cd8c15059b5cd3d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;; &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8169dce7fb17d2a667303f95f69ac650aef23654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;struct|class&lt;/code&gt;name&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; &lt;code&gt;struct|class&lt;/code&gt; 名 &lt;code&gt;{&lt;/code&gt; 枚举 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; 枚举 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="043981be691aaad7b9a1ca4f78e0ad8575dc953f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;enum-name</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;enum-name</target>
        </trans-unit>
        <trans-unit id="78e25eedb0b1c8ae6d4fd5f14224be78a0b6d564" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;; &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a3de75a82c3a17e225e1e38842fc1d21aac4f9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;:&lt;/code&gt;type&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 名称 &lt;code&gt;:&lt;/code&gt; 类型 &lt;code&gt;{&lt;/code&gt; 枚举 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; 枚举 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76682da4f8719096619c21f6aabdb2802794357" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;name&lt;code&gt;{&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt;enumerator&lt;code&gt;=&lt;/code&gt;constexpr&lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 名称 &lt;code&gt;{&lt;/code&gt; 枚举 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; 枚举 &lt;code&gt;=&lt;/code&gt; constexpr &lt;code&gt;,&lt;/code&gt; ... &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1ac6f2f35c9b33160a889afd00ee4f0971d409f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;equiv(a, b)&lt;/code&gt;, an expression equivalent to &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;equiv(a, b)&lt;/code&gt; ，等于 &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; 的表达式</target>
        </trans-unit>
        <trans-unit id="83d7e0123adf6d55ac6129b2b5f6fb366d57c0f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errno&lt;/code&gt; is a preprocessor macro used for error indication. It expands to a  static(until C++11) thread-local(since C++11) modifiable lvalue of type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;errno&lt;/code&gt; 是用于错误指示的预处理器宏。它扩展为一个 &lt;code&gt;int&lt;/code&gt; 类型的静态（直到C ++ 11）线程本地（自C ++ 11起）可修改的左值。</target>
        </trans-unit>
        <trans-unit id="a1f077484b7276f5bff23fb2d6f374ac5ee833cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;errnum&lt;/code&gt; is usually acquired from the &lt;code&gt;errno&lt;/code&gt; variable, however the function accepts any value of type &lt;code&gt;int&lt;/code&gt;. The contents of the string are locale-specific.</source>
          <target state="translated">&lt;code&gt;errnum&lt;/code&gt; 通常是从 &lt;code&gt;errno&lt;/code&gt; 变量获取的，但是该函数接受 &lt;code&gt;int&lt;/code&gt; 类型的任何值。字符串的内容是特定于语言环境的。</target>
        </trans-unit>
        <trans-unit id="54efe898b5fea0cd8bb94f7f5aa8270dfa1b9f16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error_code&lt;/code&gt; overload marked noexcept but can allocate memory</source>
          <target state="translated">&lt;code&gt;error_code&lt;/code&gt; 重载标记为noexcept，但可以分配内存</target>
        </trans-unit>
        <trans-unit id="27bd9b6f4c75a94e86d00cda519a354a4f72f2b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error_code&lt;/code&gt; overload of &lt;code&gt;create_directories&lt;/code&gt; marked noexcept but can allocate memory</source>
          <target state="translated">&lt;code&gt;error_code&lt;/code&gt; &lt;code&gt;create_directories&lt;/code&gt; 的error_code重载标记为noexcept，但可以分配内存</target>
        </trans-unit>
        <trans-unit id="52cfd267d1fb93da1a4aedefd71b8e743dbda303" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;error_code&lt;/code&gt; overload of &lt;code&gt;remove_all&lt;/code&gt; marked noexcept but can allocate memory</source>
          <target state="translated">&lt;code&gt;error_code&lt;/code&gt; &lt;code&gt;remove_all&lt;/code&gt; 的error_code重载标记为noexcept，但可以分配内存</target>
        </trans-unit>
        <trans-unit id="5c11ebc0c34134b531bb8050773b25db71f2c59f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;explicit (&lt;/code&gt;expression&lt;code&gt;) &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;explicit (&lt;/code&gt; 表达式 &lt;code&gt;) &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af93d7f007d90bd5aca4c45c10991cb3a8b1a37c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;explicit&lt;/code&gt;(optional)template-name&lt;code&gt;( &lt;/code&gt;parameter-declaration-clause&lt;code&gt;)&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;simple-template-id&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; （可选）模板名称 &lt;code&gt;( &lt;/code&gt; parameter-declaration-clause &lt;code&gt;)&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; simple-template-id &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6fdfdc1de971bdf143d06485bfdc02c7e978ef52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;explicit&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;conversion-type-id</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt;&lt;code&gt;operator&lt;/code&gt;conversion-type-id</target>
        </trans-unit>
        <trans-unit id="c3138f3333aae641d3bfc8fedd2f306d422041a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; was an optional modifier which declared the template as</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 是一个可选修饰符，它声明模板为</target>
        </trans-unit>
        <trans-unit id="36220c85ab9a339c91c5e30ceb71a2e4c11f8b6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt; { declaration-seq(optional) }</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; {声明序列（可选）}</target>
        </trans-unit>
        <trans-unit id="8b62da7283d4c3b18d849cfca6b3d95e1ce92809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;header-nameattribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;header-nameattribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="44f4c7ad0f040b74172a809e6d3fb94b2b5dc37b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-nameattribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-nameattribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="1f2bebbcbecabffc8bc29480848d5e366f08c912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-partitionattribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;import&lt;/code&gt;module-partitionattribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="54d67f80550db94cc293c103d3fc4f35bdb0a8e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;module&lt;/code&gt;module-namemodule-partition(optional)attribute-specifier-seq(optional);</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;(optional)&lt;code&gt;module&lt;/code&gt;module-namemodule-partition(optional)attribute-specifier-seq(optional);</target>
        </trans-unit>
        <trans-unit id="9d8980fe83d7975c2646da89d015605fc7f980e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;class-declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;class-declaration</target>
        </trans-unit>
        <trans-unit id="07ebce777588c91477930df782fcb0bca3595580" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;declaration</target>
        </trans-unit>
        <trans-unit id="485ef5eb58313ba3ac975a24caf194cd959679c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;function-declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;parameter-list&lt;code&gt;&amp;gt;&lt;/code&gt;function-declaration</target>
        </trans-unit>
        <trans-unit id="5388f146e02862bb30e5065eb61d15826ff0e267" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export&lt;/code&gt;declaration</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt;declaration</target>
        </trans-unit>
        <trans-unit id="7454445cf39c47030674769c03a1878c2bc9d18a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern &quot;C&quot;&lt;/code&gt; makes it possible to include header files containing declarations of C library functions in a C++ program, but if the same header file is shared with a C program, &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; (which is not allowed in C) must be hidden with an appropriate &lt;a href=&quot;../preprocessor/conditional&quot;&gt;&lt;code&gt; #ifdef&lt;/code&gt;&lt;/a&gt;, typically &lt;a href=&quot;../preprocessor/replace#Predefined_macros&quot;&gt;&lt;code&gt;__cplusplus&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;extern &quot;C&quot;&lt;/code&gt; 使得可以在C ++程序中包含包含C库函数声明的头文件，但是如果同一个头文件与C程序共享，则必须隐藏 &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; （C中不允许）使用适当的&lt;a href=&quot;../preprocessor/conditional&quot;&gt; &lt;code&gt; #ifdef&lt;/code&gt; &lt;/a&gt;，通常是&lt;a href=&quot;../preprocessor/replace#Predefined_macros&quot;&gt; &lt;code&gt;__cplusplus&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="049b4bcce0935dea35ed60c4ae97bc6e867a7fbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="5d9a515d675b4e07c00fbc73882cc1c3629012a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;class|struct&lt;/code&gt;template-name&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&amp;nbsp;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;&lt;code&gt;class|struct&lt;/code&gt;template-name&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&amp;nbsp;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c255b2cff76b9eb52459bd30442e96150366823c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;&amp;lt;&lt;/code&gt;argument-list&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d908e2a396ade66d08b92dca3ffcf19d34c78fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;&lt;code&gt;template&lt;/code&gt;return-typename&lt;code&gt;(&lt;/code&gt;parameter-list&lt;code&gt;)&lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32e0da78131b0ea3faae80e66e7e23d4d6149a24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;string-literal&lt;code&gt;{&lt;/code&gt;declaration-seq(optional)&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;string-literal&lt;code&gt;{&lt;/code&gt;declaration-seq(optional)&lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69209b29e1cf199dca3645be1461d158b2a2cfac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extern&lt;/code&gt;string-literaldeclaration</source>
          <target state="translated">&lt;code&gt;extern&lt;/code&gt;string-literaldeclaration</target>
        </trans-unit>
        <trans-unit id="f78ec137a973c5ec3dc121582762566259b3af91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f F&lt;/code&gt; defines &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f F&lt;/code&gt; 定义 &lt;code&gt;float&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03c25b2fab4161ce3c2fbc787a8d6582f759cce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; ， &lt;code&gt;F&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cad38087acf499649711df7384c393d972c26c38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;, a value of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;const T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; ，类型 &lt;code&gt;T&lt;/code&gt; 或 &lt;code&gt;const T&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="847bf2a4954a4921538a67def8856f447eab86eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt;, an object of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; ，类型 &lt;code&gt;T&lt;/code&gt; 的对象</target>
        </trans-unit>
        <trans-unit id="3e8a397a92f1dba996055e94aedcf5d5313672bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; (the match prefix is empty)</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; （匹配前缀为空）</target>
        </trans-unit>
        <trans-unit id="fc85e8617ab3828a493182ef70f7ed80805532e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; (the match suffix is empty)</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; （匹配后缀为空）</target>
        </trans-unit>
        <trans-unit id="61de516f32c260e7f5fe5a90b1537cd8a9f50ba3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt; or &lt;code&gt;equal&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;nonequivalent&lt;/code&gt; or &lt;code&gt;nonequal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;equivalent&lt;/code&gt; 或 &lt;code&gt;equal&lt;/code&gt; ，和 &lt;code&gt;true&lt;/code&gt; 如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;nonequivalent&lt;/code&gt; 或 &lt;code&gt;nonequal&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08f8613034a79e75a5eb4f9cacdde2bd87f6dad6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt;, and &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;nonequivalent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;equivalent&lt;/code&gt; ，而 &lt;code&gt;true&lt;/code&gt; 如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;nonequivalent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3f984d543664578f98b0890dc56486ff61a964e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;value() == 0&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 如果 &lt;code&gt;value() == 0&lt;/code&gt; 则返回false，否则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12593eb094b85fbe61ac28dd575bb8383436e121" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_clock&lt;/code&gt; meets the &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; requirements.</source>
          <target state="translated">&lt;code&gt;file_clock&lt;/code&gt; 符合&lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;要求。</target>
        </trans-unit>
        <trans-unit id="416ddf4cf02b3239ae22a62374699393ea1dfa24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_clock&lt;/code&gt; provides exactly one of the following two pairs of static member functions:</source>
          <target state="translated">&lt;code&gt;file_clock&lt;/code&gt; 恰好提供以下两对静态成员函数之一：</target>
        </trans-unit>
        <trans-unit id="861ae764ff85f053ef94bbe86ba1da8f51ed8538" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file_type&lt;/code&gt; defines constants that indicate a type of a file or directory a path refers to. The value of the enumerators are distinct.</source>
          <target state="translated">&lt;code&gt;file_type&lt;/code&gt; 定义常量，这些常量指示路径所引用的文件或目录的类型。枚举器的值是不同的。</target>
        </trans-unit>
        <trans-unit id="315f3972bbf217124d728f85cd82f43338739a74" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filename&lt;/code&gt; if &lt;code&gt;filename&lt;/code&gt; was not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;. Otherwise a pointer to an internal static buffer is returned. If no suitable filename can be generated, &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;filename&lt;/code&gt; ，如果 &lt;code&gt;filename&lt;/code&gt; 不是 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 。否则，返回指向内部静态缓冲区的指针。如果无法生成合适的文件名，则返回 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f0a388ea10d5b4afdd683236395d3f162dab456" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter_view&lt;/code&gt; models the concepts &lt;a href=&quot;bidirectionalrange&quot;&gt;&lt;code&gt;BidirectionalRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;forwardrange&quot;&gt;&lt;code&gt;ForwardRange&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;inputrange&quot;&gt;&lt;code&gt;InputRange&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;commonrange&quot;&gt;&lt;code&gt;CommonRange&lt;/code&gt;&lt;/a&gt; when the underlying view &lt;code&gt;V&lt;/code&gt; models respective concepts.</source>
          <target state="translated">&lt;code&gt;filter_view&lt;/code&gt; 当基础视图 &lt;code&gt;V&lt;/code&gt; 为相应的概念&lt;a href=&quot;commonrange&quot;&gt; &lt;code&gt;CommonRange&lt;/code&gt; &lt;/a&gt;时，filter_view对概念&lt;a href=&quot;bidirectionalrange&quot;&gt; &lt;code&gt;BidirectionalRange&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;forwardrange&quot;&gt; &lt;code&gt;ForwardRange&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;inputrange&quot;&gt; &lt;code&gt;InputRange&lt;/code&gt; &lt;/a&gt;和CommonRange进行建模。</target>
        </trans-unit>
        <trans-unit id="f37f86eed243731ca29e87bcda6f57b2623cc211" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;final&lt;/code&gt; is an identifier with a special meaning when used in a member function declaration or class head. In other contexts it is not reserved and may be used to name objects and functions.</source>
          <target state="translated">&lt;code&gt;final&lt;/code&gt; 是在成员函数声明或类头中使用时具有特殊含义的标识符。在其他情况下，它不是保留的，可用于命名对象和功能。</target>
        </trans-unit>
        <trans-unit id="15f3cf2d47658fb9c7978dd6f9d53f3eadb64eb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first + n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first + n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46a34ea218c9e779e94050c713fd1986d0e4aba1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first&lt;/code&gt; may be equal to &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 可以等于 &lt;code&gt;d_first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60a99992dd9908440e59e9e2f9f3db563bb373c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first&lt;/code&gt;, &lt;code&gt;second&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; ， &lt;code&gt;second&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="518c95550251b1dce01e670f8e121ae364e26a6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_argument_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;first_argument_type&lt;/code&gt; （在C ++ 17中已弃用）</target>
        </trans-unit>
        <trans-unit id="a2cf7d2be84b74299c23ec77ba8cdc09ae28eca2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_argument_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;first_argument_type&lt;/code&gt; （在C ++ 17中已弃用）（在C ++ 20中已删除）</target>
        </trans-unit>
        <trans-unit id="4efc34975233ec239fcf6e9b4ab9dc49f949f706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;first_argument_type&lt;/code&gt;(deprecated in c++17)</source>
          <target state="translated">&lt;code&gt;first_argument_type&lt;/code&gt; （在c ++ 17中已弃用）</target>
        </trans-unit>
        <trans-unit id="bf9da79a9b566df73577ccd300df42a8addf6893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; - single precision floating point type. Usually IEEE-754 32 bit floating point type  &lt;code&gt;double&lt;/code&gt; - double precision floating point type. Usually IEEE-754 64 bit floating point type  &lt;code&gt;long double&lt;/code&gt; - extended precision floating point type. Does not necessarily map to types mandated by IEEE-754. Usually 80-bit x87 floating point type on x86 and x86-64 architectures.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; -单精度浮点类型。通常是IEEE-754 32位浮点类型 &lt;code&gt;double&lt;/code&gt; -double precision浮点类型。通常，IEEE-754 64位浮点类型为 &lt;code&gt;long double&lt;/code&gt; -扩展精度浮点类型。不一定映射到IEEE-754要求的类型。通常在x86和x86-64体系结构上使用80位x87浮点类型。</target>
        </trans-unit>
        <trans-unit id="5bc2e8ab17f92697edff68a9e6809baeedd1e915" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;float&lt;/code&gt; arguments are converted to &lt;code&gt;double&lt;/code&gt; as in &lt;a href=&quot;implicit_cast#Floating_point_promotion&quot;&gt;floating-point promotion&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 参数转换为&lt;a href=&quot;implicit_cast#Floating_point_promotion&quot;&gt;浮点升级中的&lt;/a&gt; &lt;code&gt;double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b210fa17e7776b83abe5b8a384f92783f3ce9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;format&lt;/code&gt; outputs a format string, replacing any format specifiers or escape sequences in that string with match data from &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 输出格式字符串，用 &lt;code&gt;*this&lt;/code&gt; 中的匹配数据替换该字符串中的所有格式说明符或转义序列。</target>
        </trans-unit>
        <trans-unit id="a5048c3cbf0c190dd404e79a9563420bf857519e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forward_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;forward_iterator_tag&lt;/code&gt; 对应于&lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bf9be84bda9d166275c01cfadaa207fc4b41fe58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;free&lt;/code&gt; -- free space on the filesystem, in bytes</source>
          <target state="translated">&lt;code&gt;free&lt;/code&gt; -自由空间上的文件系统，以字节为单位</target>
        </trans-unit>
        <trans-unit id="a7afdf1046ea93dac61f053f7d4f8f4ec0b1cf21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;freopen&lt;/code&gt; is the only way to change the narrow/wide orientation of a stream once it has been established by an I/O operation or by &lt;code&gt;std::fwide&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;freopen&lt;/code&gt; 一旦通过I / O操作或通过 &lt;code&gt;std::fwide&lt;/code&gt; 建立流，freopen是更改流的窄/宽方向的唯一方法。</target>
        </trans-unit>
        <trans-unit id="e33960b6ff810b12078cc22f4b31c010c8a5086f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt; 说明符</target>
        </trans-unit>
        <trans-unit id="c14fdb9545dd74cee178f1fad87bbe49e06d83bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;, &lt;code&gt;inline&lt;/code&gt;, &lt;code&gt;virtual&lt;/code&gt;, or nothing (no return type)</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt; ， &lt;code&gt;inline&lt;/code&gt; ， &lt;code&gt;virtual&lt;/code&gt; 或什么都不做（无返回类型）</target>
        </trans-unit>
        <trans-unit id="cedf6954f71bbf3380f7b71ce0985a33d71e392f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;elaborated-class-specifier&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;elaborated-class-specifier&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0d23dd5011162edd99095564a0ee89e9c57636c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;function-declaration</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;function-declaration</target>
        </trans-unit>
        <trans-unit id="0db7504e7cc620e3b7b6ce702f40a98249e2e90c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;function-definition</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;function-definition</target>
        </trans-unit>
        <trans-unit id="520ab55d4d6de951979ebfc33a84a5d921959f87" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;simple-type-specifier&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;simple-type-specifier&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b01fa6400ad6c2440063ed3d0bfd34b0dc273495" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;friend&lt;/code&gt;typename-specifier&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;friend&lt;/code&gt;typename-specifier&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0b512d836d2b7abdabdbdefb44526763ca79643c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;front_inserter&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;front_insert_iterator&quot;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt; for the container &lt;code&gt;c&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;front_inserter&lt;/code&gt; 是一个便捷函数模板，用于为容器 &lt;code&gt;c&lt;/code&gt; 构造一个 &lt;code&gt;&lt;a href=&quot;front_insert_iterator&quot;&gt;std::front_insert_iterator&lt;/a&gt;&lt;/code&gt; ，其类型从参数的类型推导而来。</target>
        </trans-unit>
        <trans-unit id="e04cb834c6dcbe1f873e017d0cfe4f6ed63d0863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g()&lt;/code&gt; has amortized constant complexity.</source>
          <target state="translated">&lt;code&gt;g()&lt;/code&gt; 具有分摊的恒定复杂度。</target>
        </trans-unit>
        <trans-unit id="b6112ef2d798b5d72f641fc2facd4c5152a78700" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g()&lt;/code&gt; is in the range &lt;code&gt;[G::min(), G::max()]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g()&lt;/code&gt; 的范围是 &lt;code&gt;[G::min(), G::max()]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c8d7022caa34fdc4632fa0b0458578ff40e48b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt; is an lvalue in the &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; expression if it is an lvalue in the call expression, and is an rvalue otherwise. Thus &lt;code&gt;std::move(g)(call_args...)&lt;/code&gt; can move the bound arguments into the call, where &lt;code&gt;g(call_args...)&lt;/code&gt; would copy.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 如果在 &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; 表达式中是左值，则g是std :: invoke表达式中的左值，否则为右值。因此 &lt;code&gt;std::move(g)(call_args...)&lt;/code&gt; 可以将绑定的参数移到调用中， &lt;code&gt;g(call_args...)&lt;/code&gt; 将在其中复制。</target>
        </trans-unit>
        <trans-unit id="4edaf06963d1ba18614f939860e2628c44009177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; ， &lt;code&gt;G&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94f5507af9f623e2eec2ff1fa06a25a71e14ad55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt;, &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;, lvalues of a type satisfying &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; ， &lt;code&gt;g1&lt;/code&gt; ， &lt;code&gt;g2&lt;/code&gt; ，满足&lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;类型的左值</target>
        </trans-unit>
        <trans-unit id="34b81a135481f308b7ef8efb863ef7ce2a2b732d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt;, a value of type &lt;code&gt;G&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; ，类型 &lt;code&gt;G&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="411215b54d449f9618e7ef52494cb145feee0a20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="e2074e08c05eeca723858592a445e1f203b9bdd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_future()&lt;/code&gt; has already been called on a promise with the same shared state as &lt;code&gt;*this&lt;/code&gt;. The error category is set to &lt;a href=&quot;../future_errc&quot;&gt;&lt;code&gt;future_already_retrieved&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;get_future()&lt;/code&gt; 已在具有与 &lt;code&gt;*this&lt;/code&gt; 相同共享状态的Promise中调用get_future（）。错误类别设置为&lt;a href=&quot;../future_errc&quot;&gt; &lt;code&gt;future_already_retrieved&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b073fc02d3fb4d433180e83cc3ba037eddccaacd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_future&lt;/code&gt; can be called only once for each &lt;code&gt;packaged_task&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_future&lt;/code&gt; 每个 &lt;code&gt;packaged_task&lt;/code&gt; 只能调用一次get_future。</target>
        </trans-unit>
        <trans-unit id="91b4b348569fe839c9d79a8973645af16f96667a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getline&lt;/code&gt; reads characters from an input stream and places them into a string:</source>
          <target state="translated">&lt;code&gt;getline&lt;/code&gt; 从输入流中读取字符并将其放入字符串中：</target>
        </trans-unit>
        <trans-unit id="ee199872d7cea13b60631d13afd2fba4ed220694" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;goodbit&lt;/code&gt; if &lt;code&gt;sb&lt;/code&gt; is not a null pointer, otherwise &lt;code&gt;badbit&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;goodbit&lt;/code&gt; 如果 &lt;code&gt;sb&lt;/code&gt; 是不是一个空指针，否则 &lt;code&gt;badbit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8937a0902728f0df77cdfa6c9d933e0ec25a812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gps_clock&lt;/code&gt; meets the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements. It does not meet the &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt; requirements unless the implementation can guarantee that &lt;a href=&quot;gps_clock/now&quot;&gt;&lt;code&gt;now()&lt;/code&gt;&lt;/a&gt; does not throw an exception.</source>
          <target state="translated">&lt;code&gt;gps_clock&lt;/code&gt; 满足&lt;a href=&quot;../named_req/clock&quot;&gt;时钟&lt;/a&gt;要求。除非实现可以保证&lt;a href=&quot;gps_clock/now&quot;&gt; &lt;code&gt;now()&lt;/code&gt; &lt;/a&gt;不会引发异常，否则它不满足&lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;要求。</target>
        </trans-unit>
        <trans-unit id="3864519d2183bfb5ce854fe8e1fcb2c7da1679d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gslice_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;gslice_array&lt;/code&gt; 进行初始化</target>
        </trans-unit>
        <trans-unit id="7ec56ed1681f55a9a6dc88025fbe99be66e31868" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h&lt;/code&gt;, a value of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;const T&lt;/code&gt;, whose argument type is &lt;code&gt;Key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h&lt;/code&gt; ，类型 &lt;code&gt;T&lt;/code&gt; 或 &lt;code&gt;const T&lt;/code&gt; 的值，其参数类型为 &lt;code&gt;Key&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="111f616087040965483bbd613b70e0fda243f2e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hash_value&lt;/code&gt; originates from the boost.filesystem library where it was used for interoperability with boost.hash (which &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/doc/html/hash/reference.html#boost.hash_val_idm45507095703056&quot;&gt;calls hash_value&lt;/a&gt; where available).</source>
          <target state="translated">&lt;code&gt;hash_value&lt;/code&gt; 从它被用于与boost.hash互操作性Boost.Filesystem的库起源（其&lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/doc/html/hash/reference.html#boost.hash_val_idm45507095703056&quot;&gt;称之为哈希值&lt;/a&gt;如果有的话）。</target>
        </trans-unit>
        <trans-unit id="27b6941a88dbd576a2a2cc11f8d26dbd015e1a90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt; and &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; 和 &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;复制构造&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7aea8deea0bde7eac532953c4c0d7fd1068b7183" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt; and &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;code&gt;value_type&lt;/code&gt;&lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt; from &lt;code&gt;*i&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; 和 &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;拷贝构造&lt;/a&gt;， &lt;code&gt;value_type&lt;/code&gt; &lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;成 &lt;code&gt;X&lt;/code&gt; 从 &lt;code&gt;*i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba9369c4408e11b73dd0ee3d4ea2c0ba897e8e08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt; and &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; 和 &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cd69adb31cff6805d6e79766c0f05d07992b1b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt;&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt; &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;， &lt;code&gt;key_equal&lt;/code&gt; &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfcb282c32b3cd3e320440a37e082cc3cd592510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hasher&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;hasher&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a1713b6e25c2f4865d58a7c17a5ad31b4f5bb1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hh&lt;/code&gt; - 2-digit hour from &lt;code&gt;timeptr-&amp;gt;tm_hour&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%.2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hh&lt;/code&gt; - 2位数小时从 &lt;code&gt;timeptr-&amp;gt;tm_hour&lt;/code&gt; 仿佛通过印刷 &lt;code&gt;sprintf&lt;/code&gt; 的使用 &lt;code&gt;%.2d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53896df8aca81db5e2f25a4961cb85d988b062dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hh&lt;/code&gt; - hours</source>
          <target state="translated">&lt;code&gt;hh&lt;/code&gt; -小时</target>
        </trans-unit>
        <trans-unit id="671fdc3e4d1f215ae1223caeb16c561628665336" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hours()&lt;/code&gt; returns the integral number of hours &lt;code&gt;since_midnight&lt;/code&gt; is after 00:00:00.</source>
          <target state="translated">&lt;code&gt;hours()&lt;/code&gt; 返回的小时整数 &lt;code&gt;since_midnight&lt;/code&gt; 是00:00:00之后。</target>
        </trans-unit>
        <trans-unit id="c98fc30e60f72693a16df6b71119374088a3b262" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hypot(x, y)&lt;/code&gt;, &lt;code&gt;hypot(y, x)&lt;/code&gt;, and &lt;code&gt;hypot(x, -y)&lt;/code&gt; are equivalent</source>
          <target state="translated">&lt;code&gt;hypot(x, y)&lt;/code&gt; ， &lt;code&gt;hypot(y, x)&lt;/code&gt; 和 &lt;code&gt;hypot(x, -y)&lt;/code&gt; 等价</target>
        </trans-unit>
        <trans-unit id="78d36c3670a120414836e17fbb363e2dd80744e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i == 2&lt;/code&gt; is considered more likely than any other value of &lt;code&gt;i&lt;/code&gt;, but the &lt;code&gt;[[&lt;strong&gt;likely&lt;/strong&gt;]]&lt;/code&gt; has no effect on the &lt;code&gt;i == 1&lt;/code&gt; case even though it falls through the &lt;code&gt;case 2:&lt;/code&gt; label.</source>
          <target state="translated">&lt;code&gt;i == 2&lt;/code&gt; 被认为比 &lt;code&gt;i&lt;/code&gt; 的任何其他值更有可能，但是 &lt;code&gt;[[&lt;strong&gt;likely&lt;/strong&gt;]]&lt;/code&gt; 对 &lt;code&gt;i == 1&lt;/code&gt; 情况没有影响，即使它落入 &lt;code&gt;case 2:&lt;/code&gt; 标签。</target>
        </trans-unit>
        <trans-unit id="b976ac77602b68cce0c449c176cdf386647ac678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt; such that &lt;code&gt;[i, j)&lt;/code&gt; is a valid range and that the iterators refer to elements implicitly convertible to &lt;code&gt;value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; ，&lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt;，使得 &lt;code&gt;[i, j)&lt;/code&gt; 是有效范围，并且迭代器引用隐式转换为 &lt;code&gt;value_type&lt;/code&gt; 的元素</target>
        </trans-unit>
        <trans-unit id="4f6d9764f8087379022430768a7a169413bbe17a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, objects of a container's &lt;code&gt;iterator&lt;/code&gt; type,</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 是容器的 &lt;code&gt;iterator&lt;/code&gt; 类型的对象，</target>
        </trans-unit>
        <trans-unit id="18e96bffb01e60c107a8239648857167f5c74951" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, values of type &lt;code&gt;It&lt;/code&gt; or &lt;code&gt;const It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; ，类型为 &lt;code&gt;It&lt;/code&gt; 或 &lt;code&gt;const It&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="cbf29f78689bf07a8e6132a8f717ff5fdfca186a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, objects of type &lt;code&gt;It&lt;/code&gt; or &lt;code&gt;const It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;It&lt;/code&gt; 或 &lt;code&gt;const It&lt;/code&gt; 类型的对象</target>
        </trans-unit>
        <trans-unit id="18deb471df56ecbe71a4c38845fcc195736a1eb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;j&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03cf4985f5ecbdda5b97e43539f8485780115cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;i&lt;/code&gt;, dereferenceable iterator of type &lt;code&gt;It&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;It&lt;/code&gt; 类型的可取消引用的迭代器</target>
        </trans-unit>
        <trans-unit id="5cc15c2bb86d65f2fb65ca31cce0e3eed25a4e7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ib&lt;/code&gt;,&lt;code&gt;ie&lt;/code&gt; are &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt; with a &lt;code&gt;value_type&lt;/code&gt; of unsigned integer values of at least 32 bits.</source>
          <target state="translated">&lt;code&gt;ib&lt;/code&gt; ， &lt;code&gt;ie&lt;/code&gt; 是&lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterators&lt;/a&gt;与 &lt;code&gt;value_type&lt;/code&gt; 至少32位的无符号整数值的。</target>
        </trans-unit>
        <trans-unit id="7f6694aedba6d7abc5755c6543b84050f1f2d24a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;(static)</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt;(static)</target>
        </trans-unit>
        <trans-unit id="388eaffb6c01131dc19ce798454c600802009327" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt;&lt;code&gt;constexpr&lt;/code&gt;(optional)&lt;code&gt;(&lt;/code&gt;condition&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt;&lt;code&gt;constexpr&lt;/code&gt;(optional)&lt;code&gt;(&lt;/code&gt;condition&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1c4f6e56383e839c77c6f0a8ed70ebc070ed02f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ignore&lt;/code&gt; behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, it extracts characters from the stream and discards them until any one of the following conditions occurs:</source>
          <target state="translated">&lt;code&gt;ignore&lt;/code&gt; 表现为&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;。构造并检查哨兵对象后，它将从流中提取字符并将其丢弃，直到出现以下任何一种情况：</target>
        </trans-unit>
        <trans-unit id="777d6c1fb31ff0cfb09ff85f3f835fca8b105d38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il.begin()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;il.begin()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="2223610ff829ee9123d368c88fde6fef3651fa54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il.end()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;il.end()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="c244beea1817d5ff90b031967df2dc1d6efc2cda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="389b8bf8dc4e62dfa9d6e3312fc5c0f1694b19b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;il&lt;/code&gt;, an object of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;value_type&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;il&lt;/code&gt; ，类型为 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;value_type&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="385ae00297d1ac58a35a032dea056ac29f1cd1c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="0ec3fec471c769b0028e361778d1ff16414c77da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;independent_bits_engine&lt;/code&gt; is a random number engine adaptor that produces random numbers with different number of bits than that of the wrapped engine.</source>
          <target state="translated">&lt;code&gt;independent_bits_engine&lt;/code&gt; 是一个随机数引擎适配器，它产生的随机数的位数与打包引擎的位数不同。</target>
        </trans-unit>
        <trans-unit id="141398579848ffc093d3d4fe6c88adcc411f38a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index&lt;/code&gt; is the user-provided value passed to &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; when registering the function.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 是在注册函数时传递给 &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 的用户提供的值。</target>
        </trans-unit>
        <trans-unit id="8aaca78507992147a73d84775d11c42b2e40f9ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;indirect_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;indirect_array&lt;/code&gt; 进行初始化</target>
        </trans-unit>
        <trans-unit id="da7fbcd8eb53b0869c2ab43c83b782f0fc87e3ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; 说明符</target>
        </trans-unit>
        <trans-unit id="e8b06c80b6a672997e657c88831908a56cf3efd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt;(optional)&lt;code&gt;namespace&lt;/code&gt;attr(optional)&lt;code&gt;{ &lt;/code&gt;namespace-body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; （可选） &lt;code&gt;namespace&lt;/code&gt; attr（可选） &lt;code&gt;{ &lt;/code&gt; namespace-body &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92fcb6106eac2fa99448f0e0e49f6d7d69e513b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt;(optional)&lt;code&gt;namespace&lt;/code&gt;attr(optional)identifier&lt;code&gt;{ &lt;/code&gt;namespace-body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; （可选） &lt;code&gt;namespace&lt;/code&gt; attr（可选）标识符 &lt;code&gt;{ &lt;/code&gt; namespace-body &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cff8c42e8bd2ae405de522be35af9c42f0ef715d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inline&lt;/code&gt;&lt;code&gt;namespace&lt;/code&gt;ns_name { declarations }</source>
          <target state="translated">&lt;code&gt;inline&lt;/code&gt; &lt;code&gt;namespace&lt;/code&gt; ns_name {声明}</target>
        </trans-unit>
        <trans-unit id="116e0fe82c54955cf01a9937cdc1321af775ea37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="3be7a3e01de26a5164dbfd037a805870a7e38ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;input_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;input_iterator_tag&lt;/code&gt; 对应于&lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c74daf231867ea3b60b7c99690e2d6b255ffe413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert_or_assign&lt;/code&gt; returns more information than &lt;code&gt;operator[]&lt;/code&gt; and does not require default-constructibility of the mapped type.</source>
          <target state="translated">&lt;code&gt;insert_or_assign&lt;/code&gt; 返回的信息比 &lt;code&gt;operator[]&lt;/code&gt; ，并且不需要映射类型的默认可构造性。</target>
        </trans-unit>
        <trans-unit id="443968eb686146e29de33ab24e056f1dd0c65e0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;insert_return_type&lt;/code&gt;(since C++17)</source>
          <target state="translated">&lt;code&gt;insert_return_type&lt;/code&gt; （C ++ 17起）</target>
        </trans-unit>
        <trans-unit id="241e9902f59ff439ac42d797096feb5ee566294e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inserter&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;insert_iterator&quot;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt; for the container &lt;code&gt;c&lt;/code&gt; and its iterator &lt;code&gt;i&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;inserter&lt;/code&gt; 是一个方便的功能模板构造一个 &lt;code&gt;&lt;a href=&quot;insert_iterator&quot;&gt;std::insert_iterator&lt;/a&gt;&lt;/code&gt; 用于容器 &lt;code&gt;c&lt;/code&gt; 和其迭代 &lt;code&gt;i&lt;/code&gt; 从参数的类型推断出的类型。</target>
        </trans-unit>
        <trans-unit id="057de6e24b8ab26f37b3b86ecf25cc860351f643" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (* const *)(int *)&lt;/code&gt; and &lt;code&gt;int (* volatile *)(int *)&lt;/code&gt; are similar;</source>
          <target state="translated">&lt;code&gt;int (* const *)(int *)&lt;/code&gt; 和 &lt;code&gt;int (* volatile *)(int *)&lt;/code&gt; 相似；</target>
        </trans-unit>
        <trans-unit id="48ea95fbaba1b0dbd21298dc774cbe17d002f6ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (*)(int * const)&lt;/code&gt; and &lt;code&gt;int (*)(int *)&lt;/code&gt; are similar (they are the same type);</source>
          <target state="translated">&lt;code&gt;int (*)(int * const)&lt;/code&gt; 和 &lt;code&gt;int (*)(int *)&lt;/code&gt; 相似（它们是相同的类型）；</target>
        </trans-unit>
        <trans-unit id="5d15c0772df0971f9687b78820f226ccd72eecc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (*)(int *)&lt;/code&gt; and &lt;code&gt;int (*)(const int *)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;int (*)(int *)&lt;/code&gt; 和 &lt;code&gt;int (*)(const int *)&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="bd850e51b0a74012934879a370718571cb96e6a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int (S::*)() const&lt;/code&gt; and &lt;code&gt;int (S::*)()&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;int (S::*)() const&lt;/code&gt; 和 &lt;code&gt;int (S::*)()&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="4111163b3f8fdbde555a417a0587d2ece9578791" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt; - basic integer type. The keyword &lt;code&gt;int&lt;/code&gt; may be omitted if any of the modifiers listed below are used. If no length modifiers are present, it's guaranteed to have a width of at least 16 bits. However, on 32/64 bit systems it is almost exclusively guaranteed to have width of at least 32 bits (see below).</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; -基本整数类型。如果使用下面列出的任何修饰符，则可以省略关键字 &lt;code&gt;int&lt;/code&gt; 。如果没有长度修饰符，则保证其宽度至少为16位。但是，在32/64位系统上，几乎只能保证其宽度至少为32位（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="51b6196d0c7c2679b2d61ea8fbb53b459dd8cb77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;()&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;()&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d6bb4984004e90cc09875909163eb7f968fca99" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;int&lt;/code&gt;argc&lt;code&gt;,&lt;/code&gt;&lt;code&gt;char&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;argv&lt;code&gt;[]&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt;&lt;code&gt;main&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;int&lt;/code&gt;argc&lt;code&gt;,&lt;/code&gt;&lt;code&gt;char&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;argv&lt;code&gt;[]&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;body&lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f83ac3b4e3ec48699e12339b5892899400cf07fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;intmax_t*&lt;/code&gt; or &lt;code&gt;uintmax_t*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;intmax_t*&lt;/code&gt; 或 &lt;code&gt;uintmax_t*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2ee6087049c4a7176433e4088143e7614fdc603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_state&lt;/code&gt;(deprecated)</source>
          <target state="translated">&lt;code&gt;io_state&lt;/code&gt;(deprecated)</target>
        </trans-unit>
        <trans-unit id="4d7cce0f90e17b616e716122aeac71956f548947" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ios&lt;/code&gt; refers to the stream object for which the callback is invoked: &lt;code&gt;*this&lt;/code&gt; is passed as the argument when callbacks are invoked by &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; member functions.</source>
          <target state="translated">&lt;code&gt;ios&lt;/code&gt; 指为其调用回调的流对象： &lt;code&gt;*this&lt;/code&gt; 当 &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; 成员函数调用回调时，此参数作为参数传递。</target>
        </trans-unit>
        <trans-unit id="0e2d53cf94b70b8cafca6763310cf0eaf11119a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt; (reference to the stream after extraction of consecutive whitespace).</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; （引用连续空格后的流）。</target>
        </trans-unit>
        <trans-unit id="4fedb03004a680c63b22ba8eb8a01ff66fb6f653" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt;, an input stream</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; ，输入流</target>
        </trans-unit>
        <trans-unit id="21c5fea12a20a74cfe31d4cc9a804eba03a5a863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt;, lvalue of a specialization of &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 专业化的左值</target>
        </trans-unit>
        <trans-unit id="41e6679a08145bbcb9389bae0a5f56abbdd4be92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;is&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="1e3a41e68a345159b15102972bec9ae1a1f13e75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_always_equal&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;is_always_equal&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="a2705b3ce1ac51a19c9249b3cf3e6651264796d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_always_equal&lt;/code&gt;(C++17)&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::is_always_equal::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for every allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_always_equal&lt;/code&gt; （C ++ 17） &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::is_always_equal::value&lt;/code&gt; 对于在 &lt;code&gt;OuterAlloc&lt;/code&gt; 和 &lt;code&gt;InnerAlloc...&lt;/code&gt; 每个分配器 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="c2119c35a8f19a347e85544b010ec5ea974fdc00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_always_equal&lt;/code&gt;(since C++17)</source>
          <target state="translated">&lt;code&gt;is_always_equal&lt;/code&gt; （C ++ 17起）</target>
        </trans-unit>
        <trans-unit id="e506b53e2d1fbcb0355850b8a7a5448acee68a81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_modulo&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for signed integer types, unless the implementation defines signed integer overflow to wrap.</source>
          <target state="translated">&lt;code&gt;is_modulo&lt;/code&gt; 对于有符号整数类型，is_modulo为 &lt;code&gt;false&lt;/code&gt; ，除非实现定义要包装的有符号整数溢出。</target>
        </trans-unit>
        <trans-unit id="a8f90c8c322bbe5a2de9888a255af234a56268a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_modulo&lt;/code&gt; was required to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;is_modulo&lt;/code&gt; 必须为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce8a3e2f016914c87bba189cef2b04d0f35ccc04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isdigit&lt;/code&gt; and &lt;code&gt;isxdigit&lt;/code&gt; are the only standard narrow character classification functions that are not affected by the currently installed C locale. although some implementations (e.g. Microsoft in 1252 codepage) may classify additional single-byte characters as digits.</source>
          <target state="translated">&lt;code&gt;isdigit&lt;/code&gt; 和 &lt;code&gt;isxdigit&lt;/code&gt; 是唯一不受当前安装的C语言环境影响的标准窄字符分类功能。尽管某些实现（例如Microsoft的1252代码页）可能会将其他单字节字符分类为数字。</target>
        </trans-unit>
        <trans-unit id="03ca901dd1c3cf178377939122dcac1b084722d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;istrstream&lt;/code&gt; has been deprecated since C++98, &lt;code&gt;&lt;a href=&quot;basic_istringstream&quot;&gt;std::istringstream&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_source&quot;&gt;boost::iostreams::array_source&lt;/a&gt; are the recommended replacements.</source>
          <target state="translated">&lt;code&gt;istrstream&lt;/code&gt; 因为C ++ 98已被弃用， &lt;code&gt;&lt;a href=&quot;basic_istringstream&quot;&gt;std::istringstream&lt;/a&gt;&lt;/code&gt; 和&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_source&quot;&gt;升压::输入输出流:: array_source&lt;/a&gt;是推荐替代</target>
        </trans-unit>
        <trans-unit id="fb5edd0a0de37b0c2018cffd8918604843a5da04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iter&lt;/code&gt;(protected member object)</source>
          <target state="translated">&lt;code&gt;iter&lt;/code&gt; （受保护的成员对象）</target>
        </trans-unit>
        <trans-unit id="2f6228c2bf65ab429079525886977a8a82322066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_category&lt;/code&gt; - the category of the iterator. Must be one of &lt;a href=&quot;iterator_tags&quot;&gt;iterator category tags&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iterator_category&lt;/code&gt; -迭代器的类别。必须是&lt;a href=&quot;iterator_tags&quot;&gt;迭代器类别标签之一&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6c25d10cbb7bd92ac69fb00b2f385e3a959241b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iterator_concept&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;iterator_concept&lt;/code&gt; （自C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="f98ae9387f7361a914c5167c81d08f001775f77c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;k&lt;/code&gt;, a value of type convertible to &lt;code&gt;Key&lt;/code&gt; or &lt;code&gt;const Key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; ，可转换为 &lt;code&gt;Key&lt;/code&gt; 或 &lt;code&gt;const Key&lt;/code&gt; 的类型的值</target>
        </trans-unit>
        <trans-unit id="256f7f56e4f1142fd96bfebe17b16058836d8603" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_compare&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt;; an ordering relation over &lt;code&gt;Key&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;key_compare&lt;/code&gt; 用于 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../container/multiset&quot;&gt;std::multiset&lt;/a&gt;&lt;/code&gt; key_compare ; 在一个排序关系 &lt;code&gt;Key&lt;/code&gt; 针对 &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../container/multimap&quot;&gt;std::multimap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1328b6295690f4839bcaa8688257d852878b7ba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_compare&lt;/code&gt; is &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;key_compare&lt;/code&gt; 是&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c656810f208efe9d951232e34bfa6d6fa554f88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_compare&lt;/code&gt; is &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;code&gt;value_type&lt;/code&gt; is &lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt; from &lt;code&gt;*i&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;key_compare&lt;/code&gt; 是&lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;， &lt;code&gt;value_type&lt;/code&gt; 是&lt;a href=&quot;emplaceconstructible&quot;&gt;EmplaceConstructible，可&lt;/a&gt;从 &lt;code&gt;*i&lt;/code&gt; 转换为 &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e76cf2b2fbf296175b2f81c9c806a60b32c23bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;key_equal&lt;/code&gt;&lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebf5299058b9fd564cac587f10aa739cdc1e5bae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kittens...&lt;/code&gt;, a set of arguments to &lt;code&gt;purr&lt;/code&gt; that meets the requirements for that operation,</source>
          <target state="translated">&lt;code&gt;kittens...&lt;/code&gt; ，满足该操作要求的一组 &lt;code&gt;purr&lt;/code&gt; 参数，</target>
        </trans-unit>
        <trans-unit id="54e81ff78f39fe2d54d46f191d9f15b4b92f3555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;knuth_b&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;knuth_b&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="d84ead23b080bf2969278be7d79c70f8f003d56c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l L&lt;/code&gt; defines &lt;code&gt;long double&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;l L&lt;/code&gt; 定义 &lt;code&gt;long double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a66fbc2abf78618601cc872cf9936b7953fe1e49" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;l&lt;/code&gt; or &lt;code&gt;L&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;l&lt;/code&gt; 或 &lt;code&gt;L&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55c1d39a34f823ca69b882713b76e9b26fde79c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;last_spec&lt;/code&gt; is an empty tag type that is used in conjunction with other calendar types to indicate the last thing in a sequence. Depending on context, it may indicate the last day of a month (as in &lt;code&gt;2018y/February/last&lt;/code&gt;, for last day of February 2018, i.e., 2018-02-28) or the last day of the week in a month (as in &lt;code&gt;2018/February/Sunday[last]&lt;/code&gt;, for last Sunday of February 2018, i.e., 2018-02-25).</source>
          <target state="translated">&lt;code&gt;last_spec&lt;/code&gt; 是一个空标记类型，可与其他日历类型一起使用，以指示序列中的最后一件事。根据上下文，它可能指示一个月的最后一天（如 &lt;code&gt;2018y/February/last&lt;/code&gt; ，表示2018年2月的最后一天，即2018-02-28）或一个月中的一周的最后一天（如 &lt;code&gt;2018/February/Sunday[last]&lt;/code&gt; ，表示2018年2月的最后一个星期日，即2018-02-25）。</target>
        </trans-unit>
        <trans-unit id="54cc2b77e86abe38449e33cfa9dd560a4abe8ab8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;leap&lt;/code&gt; has a defaulted copy constructor and a defaulted copy assignment operator.</source>
          <target state="translated">&lt;code&gt;leap&lt;/code&gt; 具有默认的副本构造函数和默认的副本分配运算符。</target>
        </trans-unit>
        <trans-unit id="8764c6aafcb55d7e707f060f26a7ecfcaec7ee50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left|right|internal&lt;/code&gt;. Useful for masking operations</source>
          <target state="translated">&lt;code&gt;left|right|internal&lt;/code&gt; 。对遮罩操作有用</target>
        </trans-unit>
        <trans-unit id="3774fb54b1cf9a8fe6a2c568734146ef5a21aaa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs.base() - rhs.base()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lhs.base() - rhs.base()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35322d42c0afddc226669dc0d9f53d98ccab2c85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs.empty()&lt;/code&gt; and &lt;code&gt;rhs.empty()&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;lhs.empty()&lt;/code&gt; 和 &lt;code&gt;rhs.empty()&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="9a06433bb3b1a7b9c84fb97951b411c54c2f9743" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs.outer_allocator() == rhs.outer_allocator()&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;lhs.outer_allocator() == rhs.outer_allocator()&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="710766adbf1e5001e6e2a0bf5345bdec2798b4cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equivalent only if they are both empty or share ownership.</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 仅当lhs和 &lt;code&gt;rhs&lt;/code&gt; 为空或共享所有权时，它们才是等效的。</target>
        </trans-unit>
        <trans-unit id="1ef7a535d3323c6880222db1587fa5064e3fc340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; is considered</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 被认为</target>
        </trans-unit>
        <trans-unit id="d74003b8bcf891027bfc27d7536b0e86891ce0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt; is equal to &lt;code&gt;rcopy&lt;/code&gt;, unless &lt;code&gt;rhs&lt;/code&gt; is a non-const xvalue that refers to &lt;code&gt;lcopy&lt;/code&gt; (i.e., the assignment is a self-move-assignment),</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; 等于 &lt;code&gt;rcopy&lt;/code&gt; ，除非 &lt;code&gt;rhs&lt;/code&gt; 是引用 &lt;code&gt;lcopy&lt;/code&gt; 的非常量x值（即，该分配是一个自移动分配），</target>
        </trans-unit>
        <trans-unit id="763ce1b85e689b44ff97faf88affdaed11e7d453" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lhs&lt;/code&gt;, an lvalue that refers to an object &lt;code&gt;lcopy&lt;/code&gt; such that &lt;code&gt;decltype((lhs))&lt;/code&gt; is &lt;code&gt;LHS&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;lhs&lt;/code&gt; ，它是一个引用对象 &lt;code&gt;lcopy&lt;/code&gt; 的左值，使得 &lt;code&gt;decltype((lhs))&lt;/code&gt; 为 &lt;code&gt;LHS&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="2b8c327f19757863cbf19a339d53e0d5afe33fe5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linear_congruential_engine&lt;/code&gt; is a random number engine based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;Linear congruential generator (LCG)&lt;/a&gt;. A LCG has a state that consists of a single integer.</source>
          <target state="translated">&lt;code&gt;linear_congruential_engine&lt;/code&gt; 是基于&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;线性同余生成器（LCG）&lt;/a&gt;的随机数引擎。LCG的状态由单个整数组成。</target>
        </trans-unit>
        <trans-unit id="0b51e9a8d7e26b4195f2b7e94b0a57bcd4109928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;link&lt;/code&gt; is not copyable but does have a defaulted move constructor and a defaulted move assignment operator. However, as users have only &lt;code&gt;const&lt;/code&gt; access to &lt;code&gt;link&lt;/code&gt; objects, these functions cannot be called in user code without invoking &lt;a href=&quot;../language/ub&quot;&gt;undefined behavior&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;link&lt;/code&gt; 不可复制，但具有默认的移动构造函数和默认的移动分配运算符。但是，由于用户仅具有对 &lt;code&gt;link&lt;/code&gt; 对象的 &lt;code&gt;const&lt;/code&gt; 访问权限，因此在不调用&lt;a href=&quot;../language/ub&quot;&gt;未定义行为的&lt;/a&gt;情况下，无法在用户代码中调用这些函数。</target>
        </trans-unit>
        <trans-unit id="a42862b4b4516aed99ecd46ac714cbc76bcd3114" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ll&lt;/code&gt; or &lt;code&gt;LL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ll&lt;/code&gt; 或 &lt;code&gt;LL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3fbd2294c8228b0d41a9477a6b9cd59874805d44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loc&lt;/code&gt;, an object of type &lt;code&gt;X::locale_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;loc&lt;/code&gt; ，一个 &lt;code&gt;X::locale_type&lt;/code&gt; 类型的对象</target>
        </trans-unit>
        <trans-unit id="c8c3052ccaee4a1e8a114c753bca6e29759f1669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock()&lt;/code&gt; is usually not called directly: &lt;code&gt;&lt;a href=&quot;../unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; are used to manage exclusive locking.</source>
          <target state="translated">&lt;code&gt;lock()&lt;/code&gt; 通常不直接调用lock（）： &lt;code&gt;&lt;a href=&quot;../unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; 用于管理互斥锁定。</target>
        </trans-unit>
        <trans-unit id="a075e9526e3f87afdd25b322a41e6af35f3545ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lock_shared()&lt;/code&gt; is usually not called directly: &lt;code&gt;&lt;a href=&quot;../shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; is used to manage shared locking.</source>
          <target state="translated">&lt;code&gt;lock_shared()&lt;/code&gt; 通常不直接调用lock_shared（）： &lt;code&gt;&lt;a href=&quot;../shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; 用于管理共享锁定。</target>
        </trans-unit>
        <trans-unit id="6eed4bda9461a124aae3680bdafdaf2b3b9db713" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long long int&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;long long int&lt;/code&gt; （自C ++ 11起）</target>
        </trans-unit>
        <trans-unit id="631749813cf9be03983337499d431fda1eace348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long long int&lt;/code&gt;(since C++11).</source>
          <target state="translated">&lt;code&gt;long long int&lt;/code&gt; （自C ++ 11起）。</target>
        </trans-unit>
        <trans-unit id="b0dafe31e5994a5ce21867a198e9a54684dbded6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long long&lt;/code&gt; - target type will have width of at least 64 bits.</source>
          <target state="translated">&lt;code&gt;long long&lt;/code&gt; -目标类型的宽度至少为64位。</target>
        </trans-unit>
        <trans-unit id="f620edf133a71d4e25ca283e969ee4c9f3b69ca6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long&lt;/code&gt; - target type will have width of at least 32 bits.</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; -目标类型的宽度至少为32位。</target>
        </trans-unit>
        <trans-unit id="e6106b1d6be411097b6601fe37141ec083d96cae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;long&lt;/code&gt; type modifier</source>
          <target state="translated">&lt;code&gt;long&lt;/code&gt; 型修饰符</target>
        </trans-unit>
        <trans-unit id="6cc7d1a6f4dad505abfccdbfcdd92fac7d853104" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;longjmp&lt;/code&gt; is the mechanism used in C to handle unexpected error conditions where the function cannot return meaningfully. C++ generally uses &lt;a href=&quot;../../language/exceptions&quot;&gt;exception handling&lt;/a&gt; for this purpose.</source>
          <target state="translated">&lt;code&gt;longjmp&lt;/code&gt; 是C语言中用于处理意外错误情况的机制，在错误情况下该函数无法有意义地返回。为此，C ++通常使用&lt;a href=&quot;../../language/exceptions&quot;&gt;异常处理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d25f9f69a8c41a16a4eb7bc6204b6470fddab862" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_move_iterator&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; for the given iterator &lt;code&gt;i&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;make_move_iterator&lt;/code&gt; 是一个便捷函数模板， &lt;code&gt;&lt;a href=&quot;move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; 为给定的迭代器 &lt;code&gt;i&lt;/code&gt; 构造一个std :: move_iterator，其类型由参数的类型推导得出。</target>
        </trans-unit>
        <trans-unit id="67fc72aae3aa997980eef58fc8416c608ee1be9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_reverse_iterator&lt;/code&gt; is a convenience function template that constructs a &lt;code&gt;&lt;a href=&quot;reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; for the given iterator &lt;code&gt;i&lt;/code&gt; with the type deduced from the type of the argument.</source>
          <target state="translated">&lt;code&gt;make_reverse_iterator&lt;/code&gt; 是一个便捷函数模板，它为给定的迭代器 &lt;code&gt;i&lt;/code&gt; 构造一个 &lt;code&gt;&lt;a href=&quot;reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; ，其类型由参数的类型推导得出。</target>
        </trans-unit>
        <trans-unit id="8643df2129d822a941644d9e55fb33513904875c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mask_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;mask_array&lt;/code&gt; 进行初始化</target>
        </trans-unit>
        <trans-unit id="6051a265e3eb5ef540cc9e4026f402307e618b2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;match_flag_type&lt;/code&gt; is a &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; that specifies additional regular expression matching options.</source>
          <target state="translated">&lt;code&gt;match_flag_type&lt;/code&gt; 是一个&lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;，它指定其他正则表达式匹配选项。</target>
        </trans-unit>
        <trans-unit id="f7969f5305d2a0f5cda3cd1317fd7c00542f472b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mersenne_twister_engine&lt;/code&gt; is a random number engine based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_twister&quot;&gt;Mersenne Twister&lt;/a&gt; algorithm. It produces high quality unsigned integer random numbers of type &lt;code&gt;UIntType&lt;/code&gt; on the interval [0, 2w</source>
          <target state="translated">&lt;code&gt;mersenne_twister_engine&lt;/code&gt; 是基于&lt;a href=&quot;https://en.wikipedia.org/wiki/Mersenne_twister&quot;&gt;Mersenne Twister&lt;/a&gt;算法的随机数引擎。它会在间隔[ &lt;code&gt;UIntType&lt;/code&gt; 上生成UIntType类型的高质量无符号整数随机数</target>
        </trans-unit>
        <trans-unit id="03e36b86fc41a84634e577bf6c49cf39d160cc8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;(st.width()), N) - 1&lt;/code&gt; characters are extracted (if &lt;code&gt;st.width()&lt;/code&gt; is greater than zero)</source>
          <target state="translated">&lt;code&gt;min(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;(st.width()), N) - 1&lt;/code&gt; 提取1个字符（如果 &lt;code&gt;st.width()&lt;/code&gt; 大于零）</target>
        </trans-unit>
        <trans-unit id="f69ad950aa6cd383a3875964e57fddaa56fac574" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&lt;/code&gt; is only meaningful for bounded types and for unbounded unsigned types, that is, types that represent an infinite set of negative values have no meaningful minimum.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 仅对有界类型和无界无符号类型有意义，也就是说，表示无限组负值的类型没有有意义的最小值。</target>
        </trans-unit>
        <trans-unit id="11720682258a6e6ea94f82b3b68a01ceca39d154" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minstd_rand0&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;minstd_rand0&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="6cd727f122c0fc301841d5b5bc920fce6c61a502" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minstd_rand&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;minstd_rand&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="44da149f671c50d09ff780ccb663a27eefb6a8a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minutes()&lt;/code&gt; returns the integral number of minutes &lt;code&gt;since_midnight&lt;/code&gt; is after &lt;code&gt;(00:00:00 + hours())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;minutes()&lt;/code&gt; 返回自 &lt;code&gt;since_midnight&lt;/code&gt; 在 &lt;code&gt;(00:00:00 + hours())&lt;/code&gt; 之后的分钟的整数。</target>
        </trans-unit>
        <trans-unit id="2e2341fbef188cb5eeb260f3c23e801a73700139" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mm&lt;/code&gt; - 2-digit minute from &lt;code&gt;timeptr-&amp;gt;tm_min&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%.2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mm&lt;/code&gt; -从 &lt;code&gt;timeptr-&amp;gt;tm_min&lt;/code&gt; 开始的 2位数分钟，就像 &lt;code&gt;sprintf&lt;/code&gt; 使用 &lt;code&gt;%.2d&lt;/code&gt; 打印一样</target>
        </trans-unit>
        <trans-unit id="ad3d933f46f39e052abdb8b71c4dafb32e73d1c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mm&lt;/code&gt; - minutes</source>
          <target state="translated">&lt;code&gt;mm&lt;/code&gt; -分钟</target>
        </trans-unit>
        <trans-unit id="61b2a411b1194735f191e01a2375261d7904aadd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt;; top-level-declaration-seq(optional)</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; ; 顶级声明序列（可选）</target>
        </trans-unit>
        <trans-unit id="8ac208616f1198d65bee4d69b943f7ea1ecde749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; can be constructed with an initial buffer. If there is no initial buffer, or if the buffer is exhausted, additional buffers are obtained from an</source>
          <target state="translated">&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; 可以使用初始缓冲区构造。如果没有初始缓冲区，或者缓冲区已用尽，则从</target>
        </trans-unit>
        <trans-unit id="5aceb6d7c7df1b4d24df89ff70c7e10f8baf1802" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; is not thread-safe.</source>
          <target state="translated">&lt;code&gt;monotonic_buffer_resource&lt;/code&gt; 不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="b52eb1c48377fd49827020c8059087d06d4946e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_indexed().ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_indexed().ok()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47cee466ffd7cdb9de816c8c1fcd46074df71a9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_last().ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month().ok() &amp;amp;&amp;amp; weekday_last().ok()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daa97aa6666c88ba085bd172ef9069a910588a91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month().ok()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;month().ok()&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="c3c964de040a242a94594eda876807048353a201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month&lt;/code&gt; 是一个&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edc5d1e07f39b981842e107954ae7debbb92ead2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_day&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_day&lt;/code&gt; 是&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="721ab309caf01adaf72782284d2873bf3214d819" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_day_last&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_day_last&lt;/code&gt; 是&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="03f5d76987240a4e54cba6e45b0324fc39727c0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_weekday&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_weekday&lt;/code&gt; 是&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a16aa97c2bcf582298bbeecd9cf526963d42306" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;month_weekday_last&lt;/code&gt; is a &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;month_weekday_last&lt;/code&gt; 是&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable &lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b04124853544caec5fe640efce4338b719310311" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;move_if_noexcept&lt;/code&gt; obtains an rvalue reference to its argument if its move constructor does not throw exceptions or if there is no copy constructor (move-only type), otherwise obtains an lvalue reference to its argument. It is typically used to combine move semantics with strong exception guarantee.</source>
          <target state="translated">&lt;code&gt;move_if_noexcept&lt;/code&gt; 的move构造函数未引发异常，或者没有复制构造函数（仅移动类型），则move_if_noexcept获取对其参数的右值引用；否则，获取对其参数的左值引用。它通常用于结合移动语义和强大的异常保证。</target>
        </trans-unit>
        <trans-unit id="dcab2982ae60519dfa11b3b8789ca936b139623b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt19937&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;mt19937&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="7711b5ec07f8028b86083b76a35f48f55d22ef28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mt19937_64&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;mt19937_64&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="6d3eef6ccbd823c22c01d70b739ba0f2bfee3dfd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiline&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;multiline&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="9596b73eb0b017538a63ae7bb20302807cf463a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; - does not affect storage duration or linkage. See &lt;a href=&quot;cv&quot;&gt;const/volatile&lt;/a&gt; for the explanation.</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; -不影响存储时间或链接。有关说明，请参见&lt;a href=&quot;cv&quot;&gt;const / volatile&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ef657e8a1674cf45aa9164d0e015bb5350196c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; - permits modification of the class member declared mutable even if the containing object is declared const.</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; -允许修改声明为可变的类成员，即使包含对象声明为const。</target>
        </trans-unit>
        <trans-unit id="99b6b7266dbef06a872fb4dd7eb9bedc727ccea2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; 说明符</target>
        </trans-unit>
        <trans-unit id="d3224dab8827312710beba51a3e704b17dc0c841" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt; type specifier</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; 类型说明符</target>
        </trans-unit>
        <trans-unit id="4df916efe552ebd362d8e85d53164a72d1c6e74c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutable&lt;/code&gt;: allows body to modify the parameters captured by copy, and to call their non-const member functions</source>
          <target state="translated">&lt;code&gt;mutable&lt;/code&gt; ：允许主体修改通过副本捕获的参数，并调用其非const成员函数</target>
        </trans-unit>
        <trans-unit id="0be5eed25c0bd5a04f1885d02d6e5cbef563aed2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutex&lt;/code&gt; offers exclusive, non-recursive ownership semantics:</source>
          <target state="translated">&lt;code&gt;mutex&lt;/code&gt; 提供排他的，非递归的所有权语义：</target>
        </trans-unit>
        <trans-unit id="83c65f0571699204cd08bdc45cd8a861d113d0c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutex_type&lt;/code&gt;(if &lt;code&gt;sizeof...(MutexTypes)==1&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;mutex_type&lt;/code&gt; （如果 &lt;code&gt;sizeof...(MutexTypes)==1&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e2678c37d2ffbbbaca79109eaaac8e0743f9a1ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n + a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n + a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1df4f23ae577313cfa56d7bed35293c0435e2f57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n, i, j&lt;/code&gt;, values of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n, i, j&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="3f97ee369c6a99450c231306794325ac21356db4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; can be both positive or negative</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 可以是正数或负数</target>
        </trans-unit>
        <trans-unit id="f3865fbe8a147b296b97a18587ebb8451959508c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, a value of type &lt;code&gt;X::size_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; ，类型为 &lt;code&gt;X::size_type&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="b3733ce69ea4fb00b43cf5dd8c6fe20f531dd2bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::size_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; ，类型为 &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::size_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="440dd0a1c40939c6592cd89ff3cbc07504417e0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, an integer of type &lt;code&gt;difference_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; ，类型为 &lt;code&gt;difference_type&lt;/code&gt; 的整数</target>
        </trans-unit>
        <trans-unit id="353801c2154651bb24a1e0cbc3079409fcae6183" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt;, an integral value</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; ，整数值</target>
        </trans-unit>
        <trans-unit id="931550a878f4982e02bd2763b6cf378a1f759168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace A::B::inline C { ... }&lt;/code&gt; is equivalent to &lt;code&gt;namespace A::B { inline namespace C { ... } }&lt;/code&gt;. &lt;code&gt;inline&lt;/code&gt; may appear in front of every namespace name except the first: &lt;code&gt;namespace A::inline B::C {}&lt;/code&gt; is equivalent to &lt;code&gt;namespace A { inline namespace B { namespace C {} } }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;namespace A::B::inline C { ... }&lt;/code&gt; 等效于 &lt;code&gt;namespace A::B { inline namespace C { ... } }&lt;/code&gt; 。 &lt;code&gt;inline&lt;/code&gt; 可能出现在每个名称空间名称的前面，但第一个除外： &lt;code&gt;namespace A::inline B::C {}&lt;/code&gt; 等效于 &lt;code&gt;namespace A { inline namespace B { namespace C {} } }&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5f1a83961f9db377d752c83fd741a490a7b4c57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt; { declarations }</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; {声明}</target>
        </trans-unit>
        <trans-unit id="9622ab87c139ab1b29defe9f2aa9a39bec35b7d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;alias_name = &lt;code&gt;::&lt;/code&gt;ns_name&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; alias_name = &lt;code&gt;::&lt;/code&gt; ns_name &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6d8088f30582e3305ca05a1fa13fddc31666468" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;alias_name = nested_name&lt;code&gt;::&lt;/code&gt;ns_name&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; alias_name = nested_name &lt;code&gt;::&lt;/code&gt; ns_name &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bec759c3dfa6a683cbe5714f88a0000d1d61d31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;alias_name = ns_name&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; alias_name = ns_name &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc800922ab5b9a8debe963270907cd8c2afa96a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;name&lt;code&gt;=&lt;/code&gt;qualified-namespace&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt;name&lt;code&gt;=&lt;/code&gt;qualified-namespace&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6d1118e7b8e29f999ae87d047d0e161a70da230a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;ns_name { declarations }</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; ns_name {声明}</target>
        </trans-unit>
        <trans-unit id="f6ba9baaa556978003350c542bf864cccb3b0cff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt;ns_name&lt;code&gt;::&lt;/code&gt;&lt;code&gt;inline&lt;/code&gt;(since C++20)(optional)name { declarations }</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; ns_name &lt;code&gt;::&lt;/code&gt; &lt;code&gt;inline&lt;/code&gt; （自C ++ 20起）（可选）name {声明}</target>
        </trans-unit>
        <trans-unit id="5dcc4cb18db587b8b2ec5a9937617fe8da19fded" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;native_handle_type&lt;/code&gt;(optional)</source>
          <target state="translated">&lt;code&gt;native_handle_type&lt;/code&gt;(optional)</target>
        </trans-unit>
        <trans-unit id="d168126fb676dc5ba1f8da9c420c3b60cc37638c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new &lt;/code&gt;T</source>
          <target state="translated">&lt;code&gt;new &lt;/code&gt; T</target>
        </trans-unit>
        <trans-unit id="294bdbf6d4e099fa80b89bb6b29ca56b89bcdbe4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new &lt;/code&gt;T&lt;code&gt;(&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;(until C++03).</source>
          <target state="translated">&lt;code&gt;new &lt;/code&gt; T &lt;code&gt;(&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; （直到C ++ 03）。</target>
        </trans-unit>
        <trans-unit id="c507be339e01230b2a2421be72fed9ed3d2ba709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt; expression</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 表达</target>
        </trans-unit>
        <trans-unit id="6a49623f29f5f3dc93f2bc1d8e6afd869037d67a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;&lt;code&gt;new[]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;&lt;code&gt;new[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1f9ab9b83b0ff1cfbec3fa0f2657bc3efa77e4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d30056c5f449d74627c825a4d9dbb67095bac924" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;(&lt;/code&gt;args, ...&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; T &lt;code&gt;(&lt;/code&gt; args，... &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9b9ae2f1a0eabfc0dc5e948662745d5550e3a806" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; T &lt;code&gt;{ &lt;/code&gt; arg1，arg2，... &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="010e3be45f98751f90c9186436cda7920ef235b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt;T&lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a84b23a2f738a119793f5305f7d1d6ee1cb7ed8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_p&lt;/code&gt; ends with dot or with dot-dot</source>
          <target state="translated">&lt;code&gt;new_p&lt;/code&gt; 以点或点-点结尾</target>
        </trans-unit>
        <trans-unit id="dc967e31638fb13dc7b69a3a369bace3b889e413" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_p&lt;/code&gt; names a non-existing directory ending with a directory separator</source>
          <target state="translated">&lt;code&gt;new_p&lt;/code&gt; 命名以目录分隔符结尾的不存在的目录</target>
        </trans-unit>
        <trans-unit id="fbd974c99b0ab7a6248a32ef40aa52756bdbd908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;node_type&lt;/code&gt;(since C++17)</source>
          <target state="translated">&lt;code&gt;node_type&lt;/code&gt; （C ++ 17起）</target>
        </trans-unit>
        <trans-unit id="acc081ae343fc7533936440595e83dc55dd44c03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept(&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;noexcept(&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c24e7cdbea9d139de0946f0b05b56febebba7c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; is an improved version of &lt;a href=&quot;except_spec&quot;&gt;&lt;code&gt;throw()&lt;/code&gt;&lt;/a&gt;, which is deprecated in C++11. Unlike pre-C++17 &lt;a href=&quot;except_spec&quot;&gt;&lt;code&gt;throw()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;noexcept&lt;/code&gt; will not call &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; and may or may not unwind the stack, which potentially allows the compiler to implement &lt;code&gt;noexcept&lt;/code&gt; without the runtime overhead of &lt;a href=&quot;except_spec&quot;&gt;&lt;code&gt;throw()&lt;/code&gt;&lt;/a&gt;. As of C++17, &lt;code&gt;throw()&lt;/code&gt; is redefined to be an exact equivalent of &lt;code&gt;noexcept(true)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; 是&lt;a href=&quot;except_spec&quot;&gt; &lt;code&gt;throw()&lt;/code&gt; &lt;/a&gt;的改进版本，在C ++ 11中已弃用。与C ++ 17之前的&lt;a href=&quot;except_spec&quot;&gt; &lt;code&gt;throw()&lt;/code&gt; 不同&lt;/a&gt;， &lt;code&gt;noexcept&lt;/code&gt; 不会调用 &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 并且可能会展开堆栈，也可能不会展开堆栈，这有可能允许编译器在没有&lt;a href=&quot;except_spec&quot;&gt; &lt;code&gt;throw()&lt;/code&gt; &lt;/a&gt;的运行时开销的情况下实现 &lt;code&gt;noexcept&lt;/code&gt; 。从C ++ 17开始， &lt;code&gt;throw()&lt;/code&gt; 被重新定义为与 &lt;code&gt;noexcept(true)&lt;/code&gt; 完全等效。</target>
        </trans-unit>
        <trans-unit id="015e6404e45474d0f4b21fb1a47ce8c5d654560a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; 运算符</target>
        </trans-unit>
        <trans-unit id="a1b14049eecc97923d6024027c8c2f7ace1fca8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; specifications</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; 规格除外</target>
        </trans-unit>
        <trans-unit id="65ff1fa2e72e419dda4d71ee9e6093765d18540f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noexcept&lt;/code&gt; specifier</source>
          <target state="translated">&lt;code&gt;noexcept&lt;/code&gt; 指定符</target>
        </trans-unit>
        <trans-unit id="e1bbd04e13e487469c0bd8e54d5383313ce5238e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not1&lt;/code&gt; is a helper function to create a function object that returns the complement of the unary predicate function passed. The function object created is of type &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;not1&lt;/code&gt; 是用于创建函数对象的辅助函数，该函数对象返回所传递的一元谓词函数的补码。创建的函数对象的类型为 &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cd72ce45ba072d1b92b5fd8c78ecd167e104d93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not2&lt;/code&gt; is a helper function to create a function object that returns the complement of the binary predicate function passed. The function object created is of type &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;not2&lt;/code&gt; 是用于创建函数对象的辅助函数，该函数对象返回传递的二进制谓词函数的补码。创建的函数对象的类型为 &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="02eeb439232745421d8c2bcc11cb50225d202710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;not_fn&lt;/code&gt; is intended to replace the C++03-era negators &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;not_fn&lt;/code&gt; 用于替换C ++ 03时代的否定符 &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;not2&quot;&gt;std::not2&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0f4dcb3230322b63393ab0b70a62509500a82e0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; provides a mechanism to notify other threads that a given thread has completely finished, including destroying all &lt;a href=&quot;../keyword/thread_local&quot;&gt;thread_local&lt;/a&gt; objects. It operates as follows:</source>
          <target state="translated">&lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; 提供了一种机制，用于通知其他线程给定线程已完全完成，包括销毁所有&lt;a href=&quot;../keyword/thread_local&quot;&gt;thread_local&lt;/a&gt;对象。其操作如下：</target>
        </trans-unit>
        <trans-unit id="b5fef976c2bc54a725b0f87c8ce3dd90052df0e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;np != p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np != p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75c1ce30646d639b7e7202895f501a3da1d7b19a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;np == p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np == p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cef01ebf9a66a13171933809f6193371fdbd2d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nth&lt;/code&gt; may be the end iterator, in this case the function has no effect.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; 可能是结束迭代器，在这种情况下，该功能无效。</target>
        </trans-unit>
        <trans-unit id="e6bd9eb9e2df463fbc055a140631d32dfae3ee6a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nth_element&lt;/code&gt; is a partial sorting algorithm that rearranges elements in &lt;code&gt;[first, last)&lt;/code&gt; such that:</source>
          <target state="translated">&lt;code&gt;nth_element&lt;/code&gt; 是一种局部排序算法，可以重新排列 &lt;code&gt;[first, last)&lt;/code&gt; 元素，使得：</target>
        </trans-unit>
        <trans-unit id="7f47a446144093bb6aef8760b8abc76c6071fd0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o + p&lt;/code&gt; has a type convertible to &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and the result of the conversion is equal to &lt;code&gt;p + o&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;o + p&lt;/code&gt; 具有可转换为 &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; 的类型，转换结果等于 &lt;code&gt;p + o&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2eb351964003cae258c50dfe3a35ac417ec19e69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;o&lt;/code&gt;, a value of some type that is writable to the output iterator (there may be multiple types that are writable, e.g. if &lt;code&gt;operator=&lt;/code&gt; may be a template. There is no notion of &lt;code&gt;value_type&lt;/code&gt; as for the input iterators)</source>
          <target state="translated">&lt;code&gt;o&lt;/code&gt; ，它是可写给输出迭代器的某种类型的值（可能有多个可写类型，例如，如果 &lt;code&gt;operator=&lt;/code&gt; 可能是模板。对于输入迭代器，没有 &lt;code&gt;value_type&lt;/code&gt; 的概念）</target>
        </trans-unit>
        <trans-unit id="7906f5cbf1f50d7b47f9b1710c48448bbf1f85a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ob&lt;/code&gt; is an &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;ob&lt;/code&gt; 是一个&lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="49c9793bb09dc0351d1b52cd8fbd503e82f4dc95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offsetof&lt;/code&gt; cannot be implemented in standard C++ and requires compiler support: &lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/gcc-7_1_0-release/gcc/ginclude/stddef.h#L416-L417&quot;&gt;GCC&lt;/a&gt;, &lt;a href=&quot;https://github.com/llvm-mirror/clang/blob/release_70/lib/Headers/stddef.h#L120&quot;&gt;LLVM&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;offsetof&lt;/code&gt; 无法在标准C ++中实现，并且需要编译器支持：&lt;a href=&quot;https://github.com/gcc-mirror/gcc/blob/gcc-7_1_0-release/gcc/ginclude/stddef.h#L416-L417&quot;&gt;GCC&lt;/a&gt;，&lt;a href=&quot;https://github.com/llvm-mirror/clang/blob/release_70/lib/Headers/stddef.h#L120&quot;&gt;LLVM&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1550d528d81c9513ee291d3d137ea795ea16e22e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offsetof&lt;/code&gt; throws no exceptions; the expression &lt;code&gt;noexcept(offsetof(type, member))&lt;/code&gt; always evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;offsetof&lt;/code&gt; 不会抛出异常；表达式 &lt;code&gt;noexcept(offsetof(type, member))&lt;/code&gt; 始终求值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="10d8e5e2e6c2fc83be27f282f8161832ab2f139d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_p&lt;/code&gt; is a directory which is an ancestor of &lt;code&gt;new_p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;old_p&lt;/code&gt; 是一个目录，它是 &lt;code&gt;new_p&lt;/code&gt; 的祖先</target>
        </trans-unit>
        <trans-unit id="71d44d78011719f149c165478becc563edf2889e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op1&lt;/code&gt; or &lt;code&gt;op2&lt;/code&gt; must not have side effects.</source>
          <target state="translated">&lt;code&gt;op1&lt;/code&gt; 或 &lt;code&gt;op2&lt;/code&gt; 不得有副作用。</target>
        </trans-unit>
        <trans-unit id="adad2a941f6ab3ecdf96f65d8ae11328f5ae81d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op1&lt;/code&gt; or &lt;code&gt;op2&lt;/code&gt; must not invalidate any iterators, including the end iterators, or modify any elements of the range involved.</source>
          <target state="translated">&lt;code&gt;op1&lt;/code&gt; 或 &lt;code&gt;op2&lt;/code&gt; 不得使任何迭代器（包括结束迭代器）无效，或修改所涉及范围的任何元素。</target>
        </trans-unit>
        <trans-unit id="112cde45940f65461c5785534ec8f7c430d7e092" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not have side effects.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 一定不能有副作用。</target>
        </trans-unit>
        <trans-unit id="086dc8f46b9d3654c7787174b89cec865eea90f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not invalidate any iterators, including the end iterators, nor modify any elements of the range involved, and also *last.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 不得使任何迭代器（包括最终迭代器）无效，也不得修改所涉及范围的任何元素，也不得修改* last。</target>
        </trans-unit>
        <trans-unit id="9b5370c2bec0e4b78acfaa61dec8cb748135b0c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not invalidate any iterators, including the end iterators, or modify any elements of the range involved.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 不得使任何迭代器（包括最终迭代器）无效，或修改所涉及范围的任何元素。</target>
        </trans-unit>
        <trans-unit id="495903ba6e724d674ab4a75b0dcf1c8280f57c89" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;op&lt;/code&gt; must not invalidate any iterators, including the end iterators, or modify any elements of the ranges involved.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 不得使任何迭代器（包括最终迭代器）无效，或修改所涉及范围的任何元素。</target>
        </trans-unit>
        <trans-unit id="43436629c08c4505f761868c26d4a01bac6a1d2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open()&lt;/code&gt; is typically called through the constructor or the &lt;code&gt;open()&lt;/code&gt; member function of &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;open()&lt;/code&gt; 典型地通过构造或被叫 &lt;code&gt;open()&lt;/code&gt; 的成员函数 &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7728a14a8b819f8a9d76b6870c043331add54f2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;open_mode&lt;/code&gt;(deprecated)</source>
          <target state="translated">&lt;code&gt;open_mode&lt;/code&gt;(deprecated)</target>
        </trans-unit>
        <trans-unit id="f764e14352e8d6fb26fb5254da595a18b3bfaeb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, when called on the return value of &lt;code&gt;&lt;a href=&quot;../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; ，当在 &lt;code&gt;&lt;a href=&quot;../io/manip/get_money&quot;&gt;std::get_money&lt;/a&gt;&lt;/code&gt; 的返回值上调用时</target>
        </trans-unit>
        <trans-unit id="dca1a1540e1cce4520f29eb1b44ee1c6ca652a14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&amp;lt;&amp;lt; &lt;/code&gt;, when called on the return value of &lt;code&gt;&lt;a href=&quot;../io/manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&amp;lt; &lt;/code&gt; ，当在 &lt;code&gt;&lt;a href=&quot;../io/manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt; 的返回值上调用时</target>
        </trans-unit>
        <trans-unit id="9691a1cc99507551131eb3c4925d3064a98d3083" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&amp;lt;&lt;/code&gt; is a strict weak ordering relation</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&lt;/code&gt; 是严格的弱排序关系</target>
        </trans-unit>
        <trans-unit id="64ed06c8ab9f156add5a77b5c874e04ef517b4db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator*&lt;/code&gt; and &lt;code&gt;operator-&amp;gt;&lt;/code&gt; provide access to the object owned by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator*&lt;/code&gt; 和 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 提供对 &lt;code&gt;*this&lt;/code&gt; 拥有的对象的访问。</target>
        </trans-unit>
        <trans-unit id="9233aa3b7f89164727a126de9342f35da81a913c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator+&lt;/code&gt; and &lt;code&gt;operator-&lt;/code&gt; such that, for an object &lt;code&gt;p&lt;/code&gt; of type (possibly const) &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and an object &lt;code&gt;o&lt;/code&gt; of type (possibly const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator+&lt;/code&gt; 和 &lt;code&gt;operator-&lt;/code&gt; ，对于类型为 &lt;code&gt;p&lt;/code&gt; 的对象（可能是const） &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; 和类型为 &lt;code&gt;o&lt;/code&gt; 的对象o（可能是const） &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ee3af128ed53550cbdd7518cd7ca15a1967ff13" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator+=&lt;/code&gt; and &lt;code&gt;operator-=&lt;/code&gt; which can accept a (possibly const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; and adds/subtracts it from the stored offset, respectively.</source>
          <target state="translated">&lt;code&gt;operator+=&lt;/code&gt; 和 &lt;code&gt;operator-=&lt;/code&gt; 可以接受（可能为const） &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; 并分别从存储的偏移量中添加/减去该值。</target>
        </trans-unit>
        <trans-unit id="7de0e0de71209395ce1649bdf944473e9d832ab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator-&lt;/code&gt; which can subtract two objects of type (possibly const) &lt;code&gt;std::fpos&lt;/code&gt; producing an &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;, such that for two such objects &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;p == q + (p - q)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator-&lt;/code&gt; 可以减去两个类型（可能为const）的 &lt;code&gt;std::fpos&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; ，生成std :: streamoff，这样对于两个这样的对象 &lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;q&lt;/code&gt; ， &lt;code&gt;p == q + (p - q)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67f0f43b79f175c617cfd759b4bd4ed9e48caca2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.&lt;/code&gt; cannot be overloaded, and for &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, in &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, the built-in operator does not introduce any additional function signatures: built-in &lt;code&gt;operator-&amp;gt;&lt;/code&gt; does not apply if there exists an overloaded &lt;code&gt;operator-&amp;gt;&lt;/code&gt; that is a &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;viable function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;operator.&lt;/code&gt; 不能重载，对于 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; ，在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，内置运算符不引入任何其他功能签名：如果存在重载的 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; ，则内置 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; 不适用是一个&lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;可行的函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fbb3ca3c68671c35cfb1ef33d64b5f210f898ea7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;identifier</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;identifier</target>
        </trans-unit>
        <trans-unit id="239e361f041ad35c6ff0532443ae874a6c92e877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;suffix-identifier</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;&quot;&quot;&lt;/code&gt;suffix-identifier</target>
        </trans-unit>
        <trans-unit id="6999a5c6afb70992d316d3b394d63adc44382529" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;delete []&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; &lt;code&gt;delete []&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="31deec09e57eb86531b56b163c9a128d786f83c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80d9c23f95f593132a04ef27cb5eb947186e566a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;new []&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; &lt;code&gt;new []&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec719697fcb83b62494cce9f446b2b5a748a0d6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;&lt;code&gt;new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8fbab894de22dc4b06b8900ff94ce982b3de0a6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;conversion-type-id</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;conversion-type-id</target>
        </trans-unit>
        <trans-unit id="b07d3291d1d4bba2bd2c34bc2cfd3a5561e0e78d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;op</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;op</target>
        </trans-unit>
        <trans-unit id="2909dcdcc0a9cbd2fda55e2078d1128f224c276b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;type</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt;type</target>
        </trans-unit>
        <trans-unit id="c4f0d5823ef995b3af1b29584894a58d6ec4b0d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator&lt;/code&gt;user-defined-string-literal(since C++14)</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; 用户定义的字符串文字（C ++ 14起）</target>
        </trans-unit>
        <trans-unit id="fae38b8e726a3b72cca21c5813ed5594e4001192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator=(X&amp;amp;) = default&lt;/code&gt; was non-trivial</source>
          <target state="translated">&lt;code&gt;operator=(X&amp;amp;) = default&lt;/code&gt; 不平凡</target>
        </trans-unit>
        <trans-unit id="63dc6a1b69fef825c68e024e1e1431dc194dc2e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator!=&lt;/code&gt; that compare two objects of type (possibly const) &lt;code&gt;std::fpos&lt;/code&gt; and returns a value of type convertible to &lt;code&gt;bool&lt;/code&gt;. &lt;code&gt;p != q&lt;/code&gt; is equivalent to &lt;code&gt;!(p == q)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator==&lt;/code&gt; 和 &lt;code&gt;operator!=&lt;/code&gt; 比较两个类型（可能是const） &lt;code&gt;std::fpos&lt;/code&gt; 对象，并返回可转换为 &lt;code&gt;bool&lt;/code&gt; 的类型的值。 &lt;code&gt;p != q&lt;/code&gt; 等于 &lt;code&gt;!(p == q)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39d269f4f1f68438431582408bf841c32f549f02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator==&lt;/code&gt; is an equivalence relation</source>
          <target state="translated">&lt;code&gt;operator==&lt;/code&gt; 是等价关系</target>
        </trans-unit>
        <trans-unit id="3d61c5ee92c0d49653eaa3a52c2d1de7ec7b9420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator==&lt;/code&gt; is defined as defaulted in the definition of &lt;code&gt;T&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;operator==&lt;/code&gt; 在 &lt;code&gt;T&lt;/code&gt; 的定义中将operator ==定义为默认值，并且</target>
        </trans-unit>
        <trans-unit id="e9356a1e78f8cbfe3d2f7bf66376ed1f93958a16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator[]&lt;/code&gt; is non-const because it inserts the key if it doesn't exist. If this behavior is undesirable or if the container is &lt;code&gt;const&lt;/code&gt;, &lt;a href=&quot;at&quot;&gt;&lt;code&gt;at()&lt;/code&gt;&lt;/a&gt; may be used.</source>
          <target state="translated">&lt;code&gt;operator[]&lt;/code&gt; 是非常量的，因为如果不存在，它将插入密钥。如果这种行为是不希望的，或者如果容器是 &lt;code&gt;const&lt;/code&gt; ，则可以使用&lt;a href=&quot;at&quot;&gt; &lt;code&gt;at()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="13f08fb543a60dc58a2ea30fbdbededba9bc375e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator[]&lt;/code&gt; provides access to elements of an array managed by a &lt;code&gt;unique_ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator[]&lt;/code&gt; 提供对由 &lt;code&gt;unique_ptr&lt;/code&gt; 管理的数组元素的访问。</target>
        </trans-unit>
        <trans-unit id="883870465553c6cdc607766b28f6468761a82f6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optional&lt;/code&gt; objects whose states to swap</source>
          <target state="translated">&lt;code&gt;optional&lt;/code&gt; 交换状态的可选对象</target>
        </trans-unit>
        <trans-unit id="4fbf68b51971745343c3ffd40d040a0e3e1a307b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;opts&lt;/code&gt; is required to have only one of &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, or &lt;code&gt;remove&lt;/code&gt; to be set.</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; 只需要设置 &lt;code&gt;replace&lt;/code&gt; ， &lt;code&gt;add&lt;/code&gt; 或 &lt;code&gt;remove&lt;/code&gt; 中的一个即可。</target>
        </trans-unit>
        <trans-unit id="a78e804adbc080203711f861cae5a953da4fc7e7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 必须是 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 。否则，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="7204af3ca4f2aed86069165b606be99f4e2300f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;order&lt;/code&gt; must be one of &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt;. Otherwise the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 必须是 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../memory_order&quot;&gt;std::memory_order_seq_cst&lt;/a&gt;&lt;/code&gt; 。否则，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="73445bbb3ca832810ca8e503535082a01a9eeb93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt; (reference to the stream after insertion of the null character).</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; （插入空字符后对流的引用）。</target>
        </trans-unit>
        <trans-unit id="c6b824d3af2a1cc6b8c2142ae1483bc865ef7340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt; (reference to the stream after manipulation).</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; （对操作后的流的引用）。</target>
        </trans-unit>
        <trans-unit id="032f0b3487a5ca21c992a1f045aefccc97a9be7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;, an output stream</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; ，输出流</target>
        </trans-unit>
        <trans-unit id="52ca514c495ce1aab59e22c682594847bbd20e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;, lvalue of a specialization of &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 专业化的左值</target>
        </trans-unit>
        <trans-unit id="c96784d61f11c38f7f6143a78187f534012c3007" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="8498a31a9efd8e8be6b0e17ecaa089beea7bdd90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ost&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ost&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="9c689bba213fce99939bdec65d89bcde7dda5e0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ostrstream&lt;/code&gt; has been deprecated since C++98, &lt;code&gt;&lt;a href=&quot;basic_ostringstream&quot;&gt;std::ostringstream&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_sink&quot;&gt;boost::iostreams::array_sink&lt;/a&gt; are the recommended replacements.</source>
          <target state="translated">&lt;code&gt;ostrstream&lt;/code&gt; 因为C ++ 98，已弃用 &lt;code&gt;&lt;a href=&quot;basic_ostringstream&quot;&gt;std::ostringstream&lt;/a&gt;&lt;/code&gt; 和&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/iostreams/doc/classes/array.html#array_sink&quot;&gt;升压::输入输出流:: array_sink&lt;/a&gt;是推荐替代</target>
        </trans-unit>
        <trans-unit id="f153dff8fd2252b6cece0cbb71dec8fd509cbd1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;other&lt;/code&gt; is left with no associated file. Note that the base class move assignment swaps all stream state variables (except for &lt;code&gt;rdbuf&lt;/code&gt;) between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 都没有关联的文件。请注意，基类移动分配在 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 之间交换所有流状态变量（ &lt;code&gt;rdbuf&lt;/code&gt; 除外）。</target>
        </trans-unit>
        <trans-unit id="5dfa669a6643570842768d3c8af930a8bded28ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out&lt;/code&gt;, &lt;code&gt;out|trunc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; ， &lt;code&gt;out|trunc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78ed9da4c97b581673150388516e0e2b9bf414f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="a0234f068508744db144a8f4f24cbb727104a0fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;output_iterator_tag&lt;/code&gt; 对应于&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="151a095e9390db143eee3847774c0e9cd2500d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;out|in|app&lt;/code&gt;, &lt;code&gt;in|app&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;out|in|app&lt;/code&gt; ， &lt;code&gt;in|app&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff0efac0feea602422410e8b7256210660023bdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;override&lt;/code&gt; is an identifier with a special meaning when used after member function declarators: it's not a reserved keyword otherwise.</source>
          <target state="translated">&lt;code&gt;override&lt;/code&gt; 当在成员函数声明符后使用时，override是具有特殊含义的标识符：否则，它不是保留关键字。</target>
        </trans-unit>
        <trans-unit id="b37336d8be8522632aaf92f068edcc5fc1306e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p + o&lt;/code&gt; has type &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and stores an offset that is the result of adding &lt;code&gt;o&lt;/code&gt; to the offset of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p + o&lt;/code&gt; 具有 &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; 类型，并存储一个偏移量，该偏移量是将 &lt;code&gt;o&lt;/code&gt; 添加到 &lt;code&gt;p&lt;/code&gt; 的偏移量中得到的结果</target>
        </trans-unit>
        <trans-unit id="6c538706b366113c705286df152d776a2ec6aa9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p - o&lt;/code&gt; has type &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; and stores an offset that is the result of subtracting &lt;code&gt;o&lt;/code&gt; from the offset of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p - o&lt;/code&gt; 具有 &lt;code&gt;fpos&amp;lt;State&amp;gt;&lt;/code&gt; 类型，并存储一个偏移量，该偏移量是从 &lt;code&gt;p&lt;/code&gt; 的偏移量中减去 &lt;code&gt;o&lt;/code&gt; 的结果</target>
        </trans-unit>
        <trans-unit id="59ce2be2c428fc29f56c47bde0b8952f2140fde4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p, q&lt;/code&gt;, values of type &lt;code&gt;const CharT*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p, q&lt;/code&gt; ， &lt;code&gt;const CharT*&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="0bf18dd04ded5880be160a1161b6bb30895803ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;pointer to member of pointer&lt;/a&gt; expression, where &lt;code&gt;mp&lt;/code&gt; is a pointer to data member;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt; ，&lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;指向指针&lt;/a&gt;表达式成员的内置指针，其中 &lt;code&gt;mp&lt;/code&gt; 是指向数据成员的指针；</target>
        </trans-unit>
        <trans-unit id="fd5ab0235afc288a57ad9fbf269861d99aee101e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;pointer to member of pointer&lt;/a&gt; expression, where &lt;code&gt;mp&lt;/code&gt; is a pointer to member function&lt;sup id=&quot;cite_ref-pmfc_2-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;*mp&lt;/code&gt; ，&lt;a href=&quot;operator_member_access#Built-in_pointer-to-member_access_operators&quot;&gt;指向指针&lt;/a&gt;表达式成员的内置指针，其中 &lt;code&gt;mp&lt;/code&gt; 是指向成员函数&lt;sup id=&quot;cite_ref-pmfc_2-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;的指针；</target>
        </trans-unit>
        <trans-unit id="d647ed0e69a621aee58bfb437764f9f6f57a9644" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;m&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member of pointer&lt;/a&gt; expression, except where &lt;code&gt;m&lt;/code&gt; is a member enumerator or a non-static member function;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;m&lt;/code&gt; ，&lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;指针&lt;/a&gt;表达式的内置成员，除非 &lt;code&gt;m&lt;/code&gt; 是成员枚举数或非静态成员函数；</target>
        </trans-unit>
        <trans-unit id="decc8a48f2e43780bffcfc24eccfab7b70d4b019" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p-&amp;gt;m&lt;/code&gt;, the built-in &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member of pointer&lt;/a&gt; expression, where &lt;code&gt;m&lt;/code&gt; is a member enumerator or a non-static member function&lt;sup id=&quot;cite_ref-pmfc_2-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;;</source>
          <target state="translated">&lt;code&gt;p-&amp;gt;m&lt;/code&gt; ，&lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;指针&lt;/a&gt;表达式的内置成员，其中 &lt;code&gt;m&lt;/code&gt; 是成员枚举数或非静态成员函数&lt;sup id=&quot;cite_ref-pmfc_2-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-pmfc-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;；</target>
        </trans-unit>
        <trans-unit id="d91a4e8a8b40a713d9c0c11cc0d6f8157332110a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt;, objects of type &lt;code&gt;X::pointer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p1&lt;/code&gt; 和 &lt;code&gt;p2&lt;/code&gt; ，类型为 &lt;code&gt;X::pointer&lt;/code&gt; 对象</target>
        </trans-unit>
        <trans-unit id="2fdbf1680504d5fe8ef0f07168890765f7a7837e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; must have been returned by a prior call to &lt;code&gt;allocate(bytes, alignment)&lt;/code&gt; on a &lt;code&gt;memory_resource&lt;/code&gt; that compares equal to &lt;code&gt;*this&lt;/code&gt;, and the storage it points to must not yet have been deallocated, otherwise the behavior is undefined.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 必须由先前在比较等于 &lt;code&gt;*this&lt;/code&gt; 的 &lt;code&gt;memory_resource&lt;/code&gt; 上对 &lt;code&gt;allocate(bytes, alignment)&lt;/code&gt; 调用而返回，并且尚未指向其指向的存储，否则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="86c9ed195a73935b9716d0c908fe04050917471f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; | &lt;code&gt;P&lt;/code&gt;exponent-sign(optional)digit-sequence</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; | &lt;code&gt;P&lt;/code&gt; 指数符号（可选）数字序列</target>
        </trans-unit>
        <trans-unit id="d513ab3d55fc832db51ef3c9a24dc140d2150524" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; ， &lt;code&gt;q2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb12774f3eaef9d2fbe7eabc6816979bbcbdac38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, a (possibly const) value of type &lt;code&gt;P&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; ，类型 &lt;code&gt;P&lt;/code&gt; 的（可能是常量）值</target>
        </trans-unit>
        <trans-unit id="06a9dfc8a3226eb094336f1d83bc095f0f4cc3f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, a valid const iterator into &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; ，一个有效的常量迭代到 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dda70b02c1417aebe7356f487e2312107813a9f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt;, a value of type &lt;code&gt;const CharT*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; ， &lt;code&gt;const CharT*&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="bf42ece8a8b704ccc31f7c6d166de57b47e04378" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; constructor supports creation from UTF-8 string when the source is a sequence of &lt;code&gt;char8_t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 当源是 &lt;code&gt;char8_t&lt;/code&gt; 序列时，路径构造函数支持从UTF-8字符串创建。</target>
        </trans-unit>
        <trans-unit id="bfe847d99e91df30f9b2b1c997d690f6c9d3e19f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;perm_options&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type).</source>
          <target state="translated">&lt;code&gt;perm_options&lt;/code&gt; 满足的要求&lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt;（这意味着按位运算符 &lt;code&gt;operator&amp;amp;&lt;/code&gt; ， &lt;code&gt;operator|&lt;/code&gt; ， &lt;code&gt;operator^&lt;/code&gt; ， &lt;code&gt;operator~&lt;/code&gt; ， &lt;code&gt;operator&amp;amp;=&lt;/code&gt; ， &lt;code&gt;operator|=&lt;/code&gt; ，和 &lt;code&gt;operator^=&lt;/code&gt; 被用于这种类型定义）。</target>
        </trans-unit>
        <trans-unit id="7ee26e88b54b4a023e55266a4a3f22951b680147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; - defines a pointer to the type iterated over (&lt;code&gt;value_type&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; -定义一个指向迭代类型的指针（ &lt;code&gt;value_type&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="e79147d00db804701f1432b2de52a0ee8c9866be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; is the same type as &lt;code&gt;element_type*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; 与 &lt;code&gt;element_type*&lt;/code&gt; 类型相同</target>
        </trans-unit>
        <trans-unit id="d4eac86c5a412a3fecf58e540135ae2be1988069" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; is the same type as &lt;code&gt;element_type*&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; is a pointer type &lt;code&gt;V*&lt;/code&gt; such that &lt;code&gt;V(*)[]&lt;/code&gt; is convertible to &lt;code&gt;element_type(*)[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; 的类型与 &lt;code&gt;element_type*&lt;/code&gt; 相同，而 &lt;code&gt;U&lt;/code&gt; 是指针类型 &lt;code&gt;V*&lt;/code&gt; ，因此 &lt;code&gt;V(*)[]&lt;/code&gt; 可转换为 &lt;code&gt;element_type(*)[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7c5d8e68715c162ba85ea985f5b5bb4621395292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt; is the same type as &lt;code&gt;element_type*&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; is some pointer type &lt;code&gt;V*&lt;/code&gt; such that &lt;code&gt;V(*)[]&lt;/code&gt; is implicitly convertible to &lt;code&gt;element_type(*)[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; 与 &lt;code&gt;element_type*&lt;/code&gt; 类型相同，而 &lt;code&gt;U&lt;/code&gt; 是某种指针类型 &lt;code&gt;V*&lt;/code&gt; ，因此 &lt;code&gt;V(*)[]&lt;/code&gt; 可隐式转换为 &lt;code&gt;element_type(*)[]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56f1ebd031796dfa24a0a58f2845dcb2e9561460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pointer&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;pointer&lt;/code&gt; （在C ++ 17中已弃用）（在C ++ 20中已删除）</target>
        </trans-unit>
        <trans-unit id="d1061ab44e5f87ced20028c2ff2ad959879b250d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;polymorphic_allocator&lt;/code&gt; does not propagate on container copy assignment, move assignment, or swap. As a result, move assignment of a &lt;code&gt;polymorphic_allocator&lt;/code&gt;-using container can throw, and swapping two &lt;code&gt;polymorphic_allocator&lt;/code&gt;-using containers whose allocators do not compare equal results in undefined behavior.</source>
          <target state="translated">&lt;code&gt;polymorphic_allocator&lt;/code&gt; 不会在容器副本分配，移动分配或交换上传播。结果，可能会抛出使用 &lt;code&gt;polymorphic_allocator&lt;/code&gt; 的容器的移动分配，并且交换分配器不相等的两个 &lt;code&gt;polymorphic_allocator&lt;/code&gt; 的容器会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="625f99b6248f4d1722f67a9433f27d568b065d23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;polymorphic_allocator&lt;/code&gt;s do not propagate on container copy construction.</source>
          <target state="translated">&lt;code&gt;polymorphic_allocator&lt;/code&gt; 不会在容器副本构造上传播。</target>
        </trans-unit>
        <trans-unit id="f5e918c456b10043e8203133417d79d51c29c66d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pos&lt;/code&gt;, a value of type &lt;code&gt;X::pos_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; ，类型为 &lt;code&gt;X::pos_type&lt;/code&gt; 的值</target>
        </trans-unit>
        <trans-unit id="8cb67828ec4d1356afd884c8cf511326963cfbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pos_type(newoff)&lt;/code&gt; on success, &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure and if pos_type cannot represent the resulting stream position.</source>
          <target state="translated">&lt;code&gt;pos_type(newoff)&lt;/code&gt; 上的成功， &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; 上的故障，并且如果pos_type不能代表所得到的流位置。</target>
        </trans-unit>
        <trans-unit id="6498cc9ae3662e3b03086527cb6accd9d3f42543" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(&amp;plusmn;0, -&amp;infin;)&lt;/code&gt; returns +&amp;infin; and may raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(&amp;plusmn;0, -&amp;infin;)&lt;/code&gt; 返回+&amp;infin;并可能提高 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="042e94e352fb34d331cb6fc5334ea7fed3a2d3fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is negative, finite, and is an even integer or a non-integer, returns +&amp;infin; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt; ，其中 &lt;code&gt;exp&lt;/code&gt; 为负，有限且是偶数或非整数，返回+&amp;infin;并提高 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee4eec21814b8d94f592dabb5cd16ff37f602187" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is positive non-integer or a positive even integer, returns +0</source>
          <target state="translated">&lt;code&gt;pow(&amp;plusmn;0, exp)&lt;/code&gt; （其中 &lt;code&gt;exp&lt;/code&gt; 为正非整数或正偶数），返回+0</target>
        </trans-unit>
        <trans-unit id="4063720964f4e1762c5635e9b59232784a0d4540" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; returns +&amp;infin; for any positive &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; 对于任何正数 &lt;code&gt;exp&lt;/code&gt; 返回+&amp;infin;</target>
        </trans-unit>
        <trans-unit id="56ebf1acd4f1f0c4a5274430626232999a270b35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; returns +0 for any negative &lt;code&gt;exp&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+&amp;infin;, exp)&lt;/code&gt; 对于任何负数 &lt;code&gt;exp&lt;/code&gt; 返回+0</target>
        </trans-unit>
        <trans-unit id="290d8d6e91b01d354bcde6fecd105bc84bb83b5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a negative odd integer, returns +&amp;infin; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+0, exp)&lt;/code&gt; ，其中 &lt;code&gt;exp&lt;/code&gt; 是一个负整数，返回+&amp;infin;并引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3878047bc1ba88caaa0d085bfa6aaec4e2ca959f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a positive odd integer, returns +0</source>
          <target state="translated">&lt;code&gt;pow(+0, exp)&lt;/code&gt; ，其中 &lt;code&gt;exp&lt;/code&gt; 是一个正整数，返回+0</target>
        </trans-unit>
        <trans-unit id="bd1582f9f2bfd41942e34cebc3721377ce599a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(+1, exp)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; for any &lt;code&gt;exp&lt;/code&gt;, even when &lt;code&gt;exp&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(+1, exp)&lt;/code&gt; 对于任何 &lt;code&gt;exp&lt;/code&gt; 都返回 &lt;code&gt;1&lt;/code&gt; ，即使 &lt;code&gt;exp&lt;/code&gt; 为 &lt;code&gt;NaN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc7237a85469de1b40fe31197bdde1ed77eb2948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns +&amp;infin; if &lt;code&gt;exp&lt;/code&gt; is a positive non-integer or even integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; 如果 &lt;code&gt;exp&lt;/code&gt; 是非整数或整数，则pow（-&amp;infin;，exp）返回+&amp;infin;</target>
        </trans-unit>
        <trans-unit id="a734c05c169aa85465d6092079877e0218736515" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns +0 if &lt;code&gt;exp&lt;/code&gt; is a negative non-integer or even integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; 如果 &lt;code&gt;exp&lt;/code&gt; 为负非整数或整数，则pow（-&amp;infin;，exp）返回+0</target>
        </trans-unit>
        <trans-unit id="700ada9b089696d54cc43eebe2567eaa09e43d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns -&amp;infin; if &lt;code&gt;exp&lt;/code&gt; is a positive odd integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; 如果 &lt;code&gt;exp&lt;/code&gt; 是一个正整数，pow（-&amp;infin;，exp）返回-&amp;infin;</target>
        </trans-unit>
        <trans-unit id="3c266a9e25ce2048682bdb2a100bbbf6e740ceb5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; returns -0 if &lt;code&gt;exp&lt;/code&gt; is a negative odd integer</source>
          <target state="translated">&lt;code&gt;pow(-&amp;infin;, exp)&lt;/code&gt; 如果 &lt;code&gt;exp&lt;/code&gt; 为负奇数整数，则pow（-&amp;infin;，exp）返回-0</target>
        </trans-unit>
        <trans-unit id="ef3bb65d06173ef9916b6d047828bd8344e86186" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a negative odd integer, returns -&amp;infin; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(-0, exp)&lt;/code&gt; ，其中 &lt;code&gt;exp&lt;/code&gt; 是一个负整数，返回-&amp;infin;并引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50deaa3867ca4b36a7f84a69f7c8fb4bb898765b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-0, exp)&lt;/code&gt;, where &lt;code&gt;exp&lt;/code&gt; is a positive odd integer, returns -0</source>
          <target state="translated">&lt;code&gt;pow(-0, exp)&lt;/code&gt; ，其中 &lt;code&gt;exp&lt;/code&gt; 是一个正整数，返回-0</target>
        </trans-unit>
        <trans-unit id="447e291f802b84fb27f91b3026e77b14323ccb22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(-1, &amp;plusmn;&amp;infin;)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(-1, &amp;plusmn;&amp;infin;)&lt;/code&gt; 返回 &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c04a0ce7e8f42d74e5388e22f76da75a979a54c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, &amp;plusmn;0)&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; for any &lt;code&gt;base&lt;/code&gt;, even when &lt;code&gt;base&lt;/code&gt; is &lt;code&gt;NaN&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, &amp;plusmn;0)&lt;/code&gt; 对于任何 &lt;code&gt;base&lt;/code&gt; 都返回 &lt;code&gt;1&lt;/code&gt; ，即使 &lt;code&gt;base&lt;/code&gt; 为 &lt;code&gt;NaN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a71fc23b8b5a698d841d4415831f0fa35d4ddef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; returns +&amp;infin; for any &lt;code&gt;|base|&amp;gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; 对于任何 &lt;code&gt;|base|&amp;gt;1&lt;/code&gt; 返回+&amp;infin;</target>
        </trans-unit>
        <trans-unit id="06fde8b1bde3c2c448f1910dc0f1b60dbb034481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; returns +0 for any &lt;code&gt;|base|&amp;lt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, +&amp;infin;)&lt;/code&gt; 对于任何 &lt;code&gt;|base|&amp;lt;1&lt;/code&gt; 返回+0</target>
        </trans-unit>
        <trans-unit id="31af622727a3672337932c35fe9e49310d7fef72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; returns +&amp;infin; for any &lt;code&gt;|base|&amp;lt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; 对于任何 &lt;code&gt;|base|&amp;lt;1&lt;/code&gt; 返回+&amp;infin;</target>
        </trans-unit>
        <trans-unit id="49a620a430e4139058cc89942e34ef8005a0253a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; returns +0 for any &lt;code&gt;|base|&amp;gt;1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pow(base, -&amp;infin;)&lt;/code&gt; 对于任何 &lt;code&gt;|base|&amp;gt;1&lt;/code&gt; 返回+0</target>
        </trans-unit>
        <trans-unit id="1f971d5f39b82653837792e77c6f4888a84edec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(base, exp)&lt;/code&gt; returns &lt;code&gt;NaN&lt;/code&gt; and raises &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;base&lt;/code&gt; is finite and negative and &lt;code&gt;exp&lt;/code&gt; is finite and non-integer.</source>
          <target state="translated">&lt;code&gt;pow(base, exp)&lt;/code&gt; 如果 &lt;code&gt;base&lt;/code&gt; 为负数且 &lt;code&gt;exp&lt;/code&gt; 为有限且非整数，则pow（base，exp）返回 &lt;code&gt;NaN&lt;/code&gt; 并提高 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d7cf028e07dd0eaf95da860c70dd83e851c29f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pow(float, int)&lt;/code&gt; returns &lt;code&gt;float&lt;/code&gt; until C++11 (per overload 4) but returns &lt;code&gt;double&lt;/code&gt; since C++11 (per overload 7).</source>
          <target state="translated">&lt;code&gt;pow(float, int)&lt;/code&gt; 返回 &lt;code&gt;float&lt;/code&gt; 直到C ++ 11（每个重载4），但返回 &lt;code&gt;double&lt;/code&gt; 于C ++ 11（每个重载7）。</target>
        </trans-unit>
        <trans-unit id="1b1fae023fa49e4833b3e21e8841e921d4f06a73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;printf&lt;/code&gt; family of functions should produce the same sequence using &lt;code&gt;%p&lt;/code&gt; format specifier.</source>
          <target state="translated">&lt;code&gt;printf&lt;/code&gt; 函数系列应使用 &lt;code&gt;%p&lt;/code&gt; 格式说明符产生相同的序列。</target>
        </trans-unit>
        <trans-unit id="26d9d6de8db2eb2f8a42e0d3402444909f7380de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt; access specifier</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 访问说明符</target>
        </trans-unit>
        <trans-unit id="d06e845dd87ad90bf1bed9db6304b845f3753b8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</target>
        </trans-unit>
        <trans-unit id="7d06457bc1a108ff2b5a3fb6cacd2d0879f1e659" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;private&lt;/code&gt;base_class</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt;base_class</target>
        </trans-unit>
        <trans-unit id="2be979307e8c4ecb073d5d7f8c2c69f96da8ea58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_copy_assignment&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for at least one allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;propagate_on_container_copy_assignment&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ，至少一个分配器 &lt;code&gt;A&lt;/code&gt; 间 &lt;code&gt;OuterAlloc&lt;/code&gt; 和 &lt;code&gt;InnerAlloc...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a45f9401d8e6380fa755c6da39c0c81ec78bc2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt;(C++14)</source>
          <target state="translated">&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt;(C++14)</target>
        </trans-unit>
        <trans-unit id="62f33439d93f9ada7b8d0a92dc1fa3b75c71b2c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for at least one allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;propagate_on_container_move_assignment&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ，至少一个分配器 &lt;code&gt;A&lt;/code&gt; 间 &lt;code&gt;OuterAlloc&lt;/code&gt; 和 &lt;code&gt;InnerAlloc...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42e23f2cd472fcc8e748a4059324eaa52062ed17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;propagate_on_container_swap&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for at least one allocator &lt;code&gt;A&lt;/code&gt; among &lt;code&gt;OuterAlloc&lt;/code&gt; and &lt;code&gt;InnerAlloc...&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;propagate_on_container_swap&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 如果 &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::propagate_on_container_swap::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ，至少一个分配器 &lt;code&gt;A&lt;/code&gt; 间 &lt;code&gt;OuterAlloc&lt;/code&gt; 和 &lt;code&gt;InnerAlloc...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6e3da20abe20ecf600244767a7228b8ec7219b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt; access specifier</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 访问说明符</target>
        </trans-unit>
        <trans-unit id="0dac7c331aa38c811453a012236db1f4ecc81cc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</target>
        </trans-unit>
        <trans-unit id="bf5ed0fb019fba1b1e4776c0bc6a3b60f1f50260" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protected&lt;/code&gt;base_class</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt;base_class</target>
        </trans-unit>
        <trans-unit id="d543477baebfc303e229d1b12c5465e379252a52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pt - d&lt;/code&gt; behaved erratically for unsigned &lt;code&gt;duration&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;pt - d&lt;/code&gt; 在无符号 &lt;code&gt;duration&lt;/code&gt; s内表现异常</target>
        </trans-unit>
        <trans-unit id="90804637cd522ac07670221ad0bb2db775bb32ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr&lt;/code&gt;, a value of type &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::pointer&lt;/code&gt;, obtained by calling &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::allocate()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt; 是通过调用 &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::allocate()&lt;/code&gt; 获得的 &lt;code&gt;allocator_traits&amp;lt;A&amp;gt;::pointer&lt;/code&gt; 类型的值。</target>
        </trans-unit>
        <trans-unit id="c1816369eba63545ea58a82705ae7b104b2093ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ptr&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="98127c9da9e6d997403382be8dae19cbae7b3ddd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt; access specifier</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt; 访问说明符</target>
        </trans-unit>
        <trans-unit id="c2535c3ba85e352bae5b83bc911fdd83338ce3db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt;&lt;code&gt;:&lt;/code&gt;member-declarations</target>
        </trans-unit>
        <trans-unit id="880ecefc2b9aeb88a42626aa4c5046e1af5b36d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;public&lt;/code&gt;base_class</source>
          <target state="translated">&lt;code&gt;public&lt;/code&gt;base_class</target>
        </trans-unit>
        <trans-unit id="f29797f27b4f5d46325487b01341bb5f6d2c7214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;purr(kittens...)&lt;/code&gt; may be used in a constant expression if &lt;code&gt;kittens...&lt;/code&gt; can be so used, unless &lt;code&gt;purr&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;purr(kittens...)&lt;/code&gt; 可以在常量表达式中使用，如果 &lt;code&gt;kittens...&lt;/code&gt; 可以这样使用，除非 &lt;code&gt;purr&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="e0d0718501a69c7609d845166e16c50475b3cdae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;purr&lt;/code&gt;, an operation on &lt;code&gt;It&lt;/code&gt; that is required to be supported by MeowIterator,</source>
          <target state="translated">&lt;code&gt;purr&lt;/code&gt; ， &lt;code&gt;It&lt;/code&gt; 需要MeowIterator支持的It上的操作，</target>
        </trans-unit>
        <trans-unit id="1c67093ec2487091c75ddf44f1541f90c75dca19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q1&lt;/code&gt; and &lt;code&gt;q2&lt;/code&gt;, two const iterators into &lt;code&gt;a&lt;/code&gt; such that &lt;code&gt;[q1, q2)&lt;/code&gt; is a valid range</source>
          <target state="translated">&lt;code&gt;q1&lt;/code&gt; 和 &lt;code&gt;q2&lt;/code&gt; ，两个常量迭代器转换为 &lt;code&gt;a&lt;/code&gt; ，使得 &lt;code&gt;[q1, q2)&lt;/code&gt; 是有效范围</target>
        </trans-unit>
        <trans-unit id="cfc434c5a3d577e8bcb2b5a651536d299f5787e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q1&lt;/code&gt;, &lt;code&gt;q2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;q1&lt;/code&gt; ， &lt;code&gt;q2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="35578f384495877ae734f3d077fa1b9f3901bccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt; is an object of &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt; is a potentially constant object of &lt;code&gt;S&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; 是的目的 &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;r&lt;/code&gt; 是一个潜在的恒定对象 &lt;code&gt;S&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4ed03c127fd5c9bdd21111ed8901a64761f9ce66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt;, &lt;code&gt;q1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; ， &lt;code&gt;q1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="510143bb4bc0d569aa30b51358da3e4cce321048" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt;, a lvalue of some type satisfying &lt;a href=&quot;seedsequence&quot;&gt;SeedSequence&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; ，满足&lt;a href=&quot;seedsequence&quot;&gt;SeedSequence&lt;/a&gt;的某种类型的左值</target>
        </trans-unit>
        <trans-unit id="8126fdcbc449aa27110d9e7e3285749608d7a2cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;q&lt;/code&gt;, a valid dereferenceable const iterator into &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;q&lt;/code&gt; ，有效可提领常量迭代到 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ef715c08da87f8dbdf20a665776590c211fc002" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; and &lt;code&gt;++r&lt;/code&gt; designate the same iterator object, &lt;code&gt;r&lt;/code&gt; is dereferencable or past-the-end</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 和 &lt;code&gt;++r&lt;/code&gt; 指定相同的迭代器对象， &lt;code&gt;r&lt;/code&gt; 是可取消引用的或末尾的</target>
        </trans-unit>
        <trans-unit id="e4aa33d08f8c0974302181fa64af62a1feb3e5a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="46ead29af315ed03ad8d452c8d919f32e38888f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; is dereferencable</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 是可取的</target>
        </trans-unit>
        <trans-unit id="5d5ac794aec0ac4eeea4af1673a17ee20e884d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt; is incrementable</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; 是可递增的</target>
        </trans-unit>
        <trans-unit id="39f632268f6c7887230654fc3d3825ae396c158b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, a value of type &lt;code&gt;It&amp;amp;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; ， &lt;code&gt;It&amp;amp;&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="956d59ddbfc632ab4ded450c800a2bd4f897f931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;CharT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; ， &lt;code&gt;CharT&lt;/code&gt; 类型的左值</target>
        </trans-unit>
        <trans-unit id="80db8cfc9956eb3c1de4af7a53e262df60a93cab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;It&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; ，类型为 &lt;code&gt;It&lt;/code&gt; 的左值。</target>
        </trans-unit>
        <trans-unit id="d89f7173bffdb7dff443cf98d95ae9c1e5c89f58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;T&lt;/code&gt; obtained by the expression &lt;code&gt;*ptr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; ，由表达式 &lt;code&gt;*ptr&lt;/code&gt; 获得的 &lt;code&gt;T&lt;/code&gt; 类型的左值</target>
        </trans-unit>
        <trans-unit id="349b097a8745964e5528610acb2d276c44b2dfa4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;r&lt;/code&gt;, an lvalue of type &lt;code&gt;X&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;r&lt;/code&gt; ，类型 &lt;code&gt;X&lt;/code&gt; 的左值，</target>
        </trans-unit>
        <trans-unit id="2a20f01e1c4c5aeb82b93359a535bd4702ce8246" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rand()&lt;/code&gt; is not recommended for serious random-number generation needs. It is recommended to use C++11's &lt;a href=&quot;../random&quot;&gt;random number generation&lt;/a&gt; facilities to replace rand().(since C++11).</source>
          <target state="translated">&lt;code&gt;rand()&lt;/code&gt; 对于严重的随机数生成需求，不建议使用rand（）。建议使用C ++ 11的&lt;a href=&quot;../random&quot;&gt;随机数生成&lt;/a&gt;工具来替换rand（）。（自C ++ 11起）。</target>
        </trans-unit>
        <trans-unit id="63092ad067b962bb744290c3b8860b9cad535111" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;random_access_iterator_tag&lt;/code&gt; corresponds to &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;random_access_iterator_tag&lt;/code&gt; 对应于&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dc4b04723ffa3c7143c9033f54c289926dd19cca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranges::begin(E)&lt;/code&gt; and &lt;code&gt;ranges::begin(t)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;ranges::begin(E)&lt;/code&gt; 和 &lt;code&gt;ranges::begin(t)&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="b44969908c2d08c23acc53cd6c178ed7acff3351" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranges::end(E)&lt;/code&gt; and &lt;code&gt;ranges::end(t)&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;ranges::end(E)&lt;/code&gt; 和 &lt;code&gt;ranges::end(t)&lt;/code&gt; 是</target>
        </trans-unit>
        <trans-unit id="800883fa519bd72070c2a1e0287106b2d0d8562f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux24&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux24&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="2d565ea845f27d2bb1fbace67d387f1fca3ecf86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux24_base&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux24_base&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="7d876385690e83f9f74ca8d39f8cb05c887c309e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux48&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux48&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="5910f409e209ee99f841ab8f3183517a83eb6098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ranlux48_base&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;ranlux48_base&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="69601cbb8b00f423e101d5c4b9fa8eafd68af897" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rb&lt;/code&gt;,&lt;code&gt;re&lt;/code&gt; are &lt;a href=&quot;outputiterator&quot;&gt;mutable&lt;/a&gt;&lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt; with a &lt;code&gt;value_type&lt;/code&gt; of unsigned integer values of at least 32 bits.</source>
          <target state="translated">&lt;code&gt;rb&lt;/code&gt; ， &lt;code&gt;re&lt;/code&gt; 是&lt;a href=&quot;outputiterator&quot;&gt;可变&lt;/a&gt;&lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;与 &lt;code&gt;value_type&lt;/code&gt; 至少32位的无符号整数值的。</target>
        </trans-unit>
        <trans-unit id="1f38e682c94bea1b1ea626cf465e65d010cdb40a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rcopy&lt;/code&gt;, a distinct object that is equal to &lt;code&gt;rhs&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;rcopy&lt;/code&gt; ，一个与 &lt;code&gt;rhs&lt;/code&gt; 相等的独特对象，</target>
        </trans-unit>
        <trans-unit id="bfb39847458d7f586b236cc53d450da13c194e64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdbuf()-&amp;gt;sputbackc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; return &lt;code&gt;traits::eof()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rdbuf()-&amp;gt;sputbackc()&lt;/code&gt; 或 &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; 返回 &lt;code&gt;traits::eof()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b663b26438681e782f763683bd9154b1ec2d8361" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rebind&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;rebind&lt;/code&gt; （在C ++ 17中弃用）（在C ++ 20中删除）</target>
        </trans-unit>
        <trans-unit id="0cd838c1a4cc8e60af9a0e537b3692cd18cb8e28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recursive_directory_iterator&lt;/code&gt; is an &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; that iterates over the &lt;a href=&quot;directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; elements of a directory, and, recursively, over the entries of all subdirectories. The iteration order is unspecified, except that each directory entry is visited only once.</source>
          <target state="translated">&lt;code&gt;recursive_directory_iterator&lt;/code&gt; 是一个&lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;，它遍历&lt;a href=&quot;directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt;元素，并递归遍历所有子目录的条目。未指定迭代顺序，只是每个目录条目仅被访问一次。</target>
        </trans-unit>
        <trans-unit id="30dc9f28b8f62cbb2bc8ffe10de818246455e131" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recursive_mutex&lt;/code&gt; offers exclusive, recursive ownership semantics:</source>
          <target state="translated">&lt;code&gt;recursive_mutex&lt;/code&gt; 提供了排他的，递归的所有权语义：</target>
        </trans-unit>
        <trans-unit id="598e7618503b29c6fbb045f594ce4024c5ec9942" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref_&amp;shy;view&lt;/code&gt; is a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. It wraps a reference to that &lt;code&gt;Range&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ref_&amp;shy;view&lt;/code&gt; 是&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;一些其他的元素的&lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;。它包装了对该 &lt;code&gt;Range&lt;/code&gt; 的引用。</target>
        </trans-unit>
        <trans-unit id="2f69b53eb3b26327fb1b3702a93e2c01575ac711" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference,&lt;/code&gt; the type denoted by &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reference,&lt;/code&gt; 由 &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; 表示的类型</target>
        </trans-unit>
        <trans-unit id="60c35e0f46449e1c244042bacc03642577f30615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt; - defines a reference to the type iterated over (&lt;code&gt;value_type&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; -定义对迭代的类型的引用（ &lt;code&gt;value_type&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="abcf815b721ede9c83eedeb75e9115c1eba2b395" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; （C ++ 17中已弃用）（C ++ 20中已删除）</target>
        </trans-unit>
        <trans-unit id="f3666f59f83dac548eb815cb74c9381040b8d908" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt;, convertible to &lt;code&gt;value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; ，可转换为 &lt;code&gt;value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ac3623e8103740b628f9cb099baaddf8ca2ec66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reference&lt;/code&gt;, the type denoted by &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::reference&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reference&lt;/code&gt; ，由 &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::reference&lt;/code&gt; &amp;lt;It&amp;gt; :: reference表示的类型</target>
        </trans-unit>
        <trans-unit id="85eb9faf32144c3d811f6fc0dc7cab7837909b60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refs&lt;/code&gt; is used for resource management: if &lt;code&gt;refs == 0&lt;/code&gt;, the implementation destroys the facet, when the last &lt;code&gt;&lt;a href=&quot;locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; object holding it is destroyed. Otherwise, the object is not destroyed.</source>
          <target state="translated">&lt;code&gt;refs&lt;/code&gt; 用于资源管理：如果 &lt;code&gt;refs == 0&lt;/code&gt; ，则实现将销毁构面，而持有该构面的最后一个 &lt;code&gt;&lt;a href=&quot;locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; 对象将被销毁。否则，对象不会被破坏。</target>
        </trans-unit>
        <trans-unit id="0770f5fc37f5b2939a35296243da85be1cc805d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regex_replace&lt;/code&gt; uses a regular expression to perform substitution on a sequence of characters:</source>
          <target state="translated">&lt;code&gt;regex_replace&lt;/code&gt; 使用正则表达式对字符序列执行替换：</target>
        </trans-unit>
        <trans-unit id="3abfeba8a9c538f0cf69429a4f827b597bda06a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;regex_search&lt;/code&gt; will successfully match any subsequence of the given sequence, whereas &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; will only return &lt;code&gt;true&lt;/code&gt; if the regular expression matches the</source>
          <target state="translated">&lt;code&gt;regex_search&lt;/code&gt; 将成功地匹配给定序列的任何序列，而 &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; 只会返回 &lt;code&gt;true&lt;/code&gt; 如果正则表达式匹配</target>
        </trans-unit>
        <trans-unit id="fd08c8dd3fa527f82569a2f504f2043aa282f84c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;register&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="a4b18bcf26db26f86cb624fc878d8f89231e92b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rehash(0)&lt;/code&gt; may be used to force an unconditional rehash, such as after suspension of automatic rehashing by temporarily increasing &lt;code&gt;max_load_factor()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rehash(0)&lt;/code&gt; 可用于强制无条件重新哈希，例如在通过临时增加 &lt;code&gt;max_load_factor()&lt;/code&gt; 暂停自动重新哈希之后。</target>
        </trans-unit>
        <trans-unit id="d303fc5ae6388cc35f1ecf3e0b09b3ec63f9eb2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reinterpret_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reinterpret_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; 表达式 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14460c574491c661c3edad1c4eaa6d0c1d141919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reinterpret_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;reinterpret_cast&lt;/code&gt; 转换</target>
        </trans-unit>
        <trans-unit id="9fb828870ecbababc828107487f0641b7befa4b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;parameter-list(optional)&lt;code&gt;)&lt;/code&gt;&lt;code&gt;{ &lt;/code&gt;requirement-seq&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; 参数列表（可选） &lt;code&gt;)&lt;/code&gt; &lt;code&gt;{ &lt;/code&gt; 要求序列 &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d54690ec4ac98e1852dca752d039b531cc70949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt;&lt;code&gt;{ &lt;/code&gt;requirement-seq&lt;code&gt;} &lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; &lt;code&gt;{ &lt;/code&gt; require-seq &lt;code&gt;} &lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4effb89389c1532c36384587723fd397983c5c02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt;constraint-expression&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdf531d04698e1e674e0df4bfd21bfed4b6ed6b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reserve()&lt;/code&gt; cannot be used to reduce the capacity of the container; to that end &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; is provided.</source>
          <target state="translated">&lt;code&gt;reserve()&lt;/code&gt; 不能用于减少容器的容量；为此，提供了 &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c317ad0068ea950a562690062c814fdd39b88a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reserve()&lt;/code&gt; does not change the size of the vector.</source>
          <target state="translated">&lt;code&gt;reserve()&lt;/code&gt; 不会更改向量的大小。</target>
        </trans-unit>
        <trans-unit id="36ee631c57d63311fe1e24caeb9fd6f7f45220bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;result_type&lt;/code&gt; （在C ++ 17中已弃用）</target>
        </trans-unit>
        <trans-unit id="9f29033a26d7952123ef1720a8d7e5f132e49d5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;result_type&lt;/code&gt; （在C ++ 17中已弃用）（在C ++ 20中已删除）</target>
        </trans-unit>
        <trans-unit id="ecfcc8cf0eb270aacf613b351daa7c984fd6411a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result_type&lt;/code&gt;(deprecated in c++17)</source>
          <target state="translated">&lt;code&gt;result_type&lt;/code&gt; （在c ++ 17中已弃用）</target>
        </trans-unit>
        <trans-unit id="53205186a9d1b9e609da0735d2a91c945832654c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return { &lt;/code&gt;arg1, arg2, ...&lt;code&gt;}&amp;nbsp;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return { &lt;/code&gt; arg1，arg2，... &lt;code&gt;}&amp;nbsp;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7a0e4ff406666b99cf5b53f8b57040d63d0d362" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;object&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5dfc017bb05e736eb42027876df7331521a9164f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b72d3a462726fd7091404eb215473552ec092f7d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reverse_iterator&lt;/code&gt;; &lt;code&gt;const_reverse_iterator&lt;/code&gt; for constant &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reverse_iterator&lt;/code&gt; ; &lt;code&gt;const_reverse_iterator&lt;/code&gt; 用于常量 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf468550f1171a88fbcc93509e42cbedafa6fdad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs.base() - lhs.base()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs.base() - lhs.base()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97ca0442554e3e00894e57c816c145d8ef910d43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; as determined by the owner-based ordering.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; 由基于所有者的排序确定。</target>
        </trans-unit>
        <trans-unit id="0e60c7bec1515be2c2a36930ced4b3085ed7343d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; if, and only if, &lt;code&gt;rhs&lt;/code&gt; contains a value and &lt;code&gt;lhs&lt;/code&gt; does not.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; ，当且仅当， &lt;code&gt;rhs&lt;/code&gt; 包含一个值和 &lt;code&gt;lhs&lt;/code&gt; 没有。</target>
        </trans-unit>
        <trans-unit id="c174340582093b0d466d6c3647a1351bb9d3ec1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; if, and only if, both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; do not contain a value.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; ，当且仅当，既 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 不包含值。</target>
        </trans-unit>
        <trans-unit id="565957bc63bd899f43c3c7e99a64361f55afc1d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; ，否则为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f801c14939021b1abafe3a8ff39f5b5192b017e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;, an expression such that &lt;code&gt;decltype((rhs))&lt;/code&gt; is &lt;code&gt;RHS&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; ，这样的表达式，例如 &lt;code&gt;decltype((rhs))&lt;/code&gt; 是 &lt;code&gt;RHS&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="06b8452485cd1012fdc37402144dfc5c1fc47e4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;, or to the same time point as &lt;code&gt;rhs&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; ，或在同一时间点的 &lt;code&gt;rhs&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="f75d3402a3e508993184ec535748f1aa5f7fd557" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="ba9ce0fa5cec935b2c8522b016d18d19dd1e12ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rv&lt;/code&gt;, a non-const rvalue of type &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; ，类型为 &lt;code&gt;X::value_type&lt;/code&gt; 的非常量右值</target>
        </trans-unit>
        <trans-unit id="d23ebc7f5ccc22387d2fcae2190fa7ada5611250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rv&lt;/code&gt;, an &lt;a href=&quot;../language/value_category&quot;&gt;rvalue&lt;/a&gt; expression of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; ，类型 &lt;code&gt;T&lt;/code&gt; 的&lt;a href=&quot;../language/value_category&quot;&gt;右值&lt;/a&gt;表达式</target>
        </trans-unit>
        <trans-unit id="03db902365c41636203b9c342c8ba4a53c80e104" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rv&lt;/code&gt;, an rvalue of type &lt;code&gt;T&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;rv&lt;/code&gt; ，类型 &lt;code&gt;T&lt;/code&gt; 的右值，和</target>
        </trans-unit>
        <trans-unit id="184f94c984426654bdbda6329a8491ce29b9b1b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s2&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="86bfb8d2d1f71afee842e4a2ab03f528b4510a70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;, a value of type &lt;code&gt;CharT*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; ， &lt;code&gt;CharT*&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="d0ab2d78e8c406f38df50f0691bde80be6d60c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;, a value of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; ， &lt;code&gt;T&lt;/code&gt; 类型的值</target>
        </trans-unit>
        <trans-unit id="8db70f70831b4c294a499fa786043548a5c6e2cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;, an object of type &lt;code&gt;X::string_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; ，一个 &lt;code&gt;X::string_type&lt;/code&gt; 类型的对象</target>
        </trans-unit>
        <trans-unit id="26ddc407a8dc737f9234973e0a96e43e6529d514" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scientific|fixed&lt;/code&gt;. Useful for masking operations</source>
          <target state="translated">&lt;code&gt;scientific|fixed&lt;/code&gt; 。对遮罩操作有用</target>
        </trans-unit>
        <trans-unit id="3b72e415dad9c30cfbfd7cc356cb8ffee8f09ce7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; or, if &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt;, &lt;code&gt;scoped_allocator_adaptor&amp;lt;OuterAlloc&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;scoped_allocator_adaptor&amp;lt;InnerAllocs...&amp;gt;&lt;/code&gt; 或者，如果 &lt;code&gt;sizeof...(InnerAllocs) == 0&lt;/code&gt; ，则 &lt;code&gt;scoped_allocator_adaptor&amp;lt;OuterAlloc&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb19d02e623ce44c8baceb5958f961c939ef04dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_argument_type&lt;/code&gt;(deprecated in C++17)</source>
          <target state="translated">&lt;code&gt;second_argument_type&lt;/code&gt; （在C ++ 17中已弃用）</target>
        </trans-unit>
        <trans-unit id="083845aa3ea21544c8ba2547aa3c7c77463199ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_argument_type&lt;/code&gt;(deprecated in C++17)(removed in C++20)</source>
          <target state="translated">&lt;code&gt;second_argument_type&lt;/code&gt; （在C ++ 17中已弃用）（在C ++ 20中已删除）</target>
        </trans-unit>
        <trans-unit id="f4d51052d4b9993e738ae3d474d50f444db05ed2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_argument_type&lt;/code&gt;(deprecated in c++17)</source>
          <target state="translated">&lt;code&gt;second_argument_type&lt;/code&gt; （在c ++ 17中已弃用）</target>
        </trans-unit>
        <trans-unit id="af796c30ead3a9fdf671d740087f35fb78179325" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seconds()&lt;/code&gt; returns the integral number of seconds &lt;code&gt;since_midnight&lt;/code&gt; is after &lt;code&gt;(00:00:00 + hours() + minutes())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seconds()&lt;/code&gt; 返回自 &lt;code&gt;since_midnight&lt;/code&gt; 在 &lt;code&gt;(00:00:00 + hours() + minutes())&lt;/code&gt; 之后的秒数的整数。</target>
        </trans-unit>
        <trans-unit id="e84262979b83b06a446439fcf9438a7168d791ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seek_dir&lt;/code&gt;(deprecated)</source>
          <target state="translated">&lt;code&gt;seek_dir&lt;/code&gt;(deprecated)</target>
        </trans-unit>
        <trans-unit id="4ef2fc6bec3d3f6ea251d4cfc5eaea77641e1555" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seekg&lt;/code&gt; behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object,</source>
          <target state="translated">&lt;code&gt;seekg&lt;/code&gt; 的行为与&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction相同&lt;/a&gt;，但不影响 &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; 。构造并检查哨兵对象后，</target>
        </trans-unit>
        <trans-unit id="3859b43d876458b72bdd19fcf82fc23176f8083f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seekoff()&lt;/code&gt; is called by &lt;code&gt;std::basic_streambuf::pubseekoff&lt;/code&gt;, which is called by &lt;code&gt;std::basic_istream::seekg&lt;/code&gt;, &lt;code&gt;std::basic_ostream::seekp&lt;/code&gt;, &lt;code&gt;std::basic_istream::tellg&lt;/code&gt;, and &lt;code&gt;std::basic_ostream::tellp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seekoff()&lt;/code&gt; 由 &lt;code&gt;std::basic_streambuf::pubseekoff&lt;/code&gt; 调用， &lt;code&gt;std::basic_istream::seekg&lt;/code&gt; ， &lt;code&gt;std::basic_ostream::seekp&lt;/code&gt; ， &lt;code&gt;std::basic_istream::tellg&lt;/code&gt; 和 &lt;code&gt;std::basic_ostream::tellp&lt;/code&gt; tellp调用。</target>
        </trans-unit>
        <trans-unit id="57787c098e93d798111197b309a8dfb0121cf24c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;seekpos()&lt;/code&gt; is called by &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;std::basic_streambuf::pubseekpos()&lt;/a&gt;&lt;/code&gt;, which is called by the single-argument versions of &lt;code&gt;&lt;a href=&quot;../basic_istream/seekg&quot;&gt;std::basic_istream::seekg()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream/seekp&quot;&gt;std::basic_ostream::seekp()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;seekpos()&lt;/code&gt; 由 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;std::basic_streambuf::pubseekpos()&lt;/a&gt;&lt;/code&gt; 调用，这由 &lt;code&gt;&lt;a href=&quot;../basic_istream/seekg&quot;&gt;std::basic_istream::seekg()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../basic_ostream/seekp&quot;&gt;std::basic_ostream::seekp()&lt;/a&gt;&lt;/code&gt; 的单参数版本调用。</target>
        </trans-unit>
        <trans-unit id="be1052ab32228a15576834a15d52cfde8554eb29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setbuf()&lt;/code&gt; may be called after opening the file, but before any I/O (may crash otherwise). With a user-provided buffer, reading from file reads largest multiples of 4096 that fit in the buffer.</source>
          <target state="translated">&lt;code&gt;setbuf()&lt;/code&gt; 可以在打开文件之后但在任何I / O之前调用（否则可能会崩溃）。使用用户提供的缓冲区，从文件读取将读取缓冲区中适合的最大4096倍数。</target>
        </trans-unit>
        <trans-unit id="f6144b5565e83fdf200e5745c534734a6d046f07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setbuf()&lt;/code&gt; may be called at any time, even after some I/O took place. Current contents of the buffer, if any, are lost.</source>
          <target state="translated">&lt;code&gt;setbuf()&lt;/code&gt; 即使在发生某些I / O之后，也可以随时调用setbuf（）。缓冲区的当前内容（如果有）会丢失。</target>
        </trans-unit>
        <trans-unit id="323507d89c10daabb8de88ec6a458b1f6bb35383" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setbuf()&lt;/code&gt; may only be called when the &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; is not associated with a file (has no effect otherwise). With a user-provided buffer, reading from file reads &lt;code&gt;n-1&lt;/code&gt; bytes at a time.</source>
          <target state="translated">&lt;code&gt;setbuf()&lt;/code&gt; 仅当 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 未与文件关联时才调用setbuf（）（否则无效）。使用用户提供的缓冲区，从文件读取一次读取 &lt;code&gt;n-1&lt;/code&gt; 个字节。</target>
        </trans-unit>
        <trans-unit id="b741f6475a4db6325d4c2a84af32b33137e4f09c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;share()&lt;/code&gt; requires &lt;code&gt;valid()&lt;/code&gt; to be &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;share()&lt;/code&gt; 要求 &lt;code&gt;valid()&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9b9155015e2be62108cf1293fbf94ee9dcaeb29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;short&lt;/code&gt; - target type will be optimized for space and will have width of at least 16 bits.</source>
          <target state="translated">&lt;code&gt;short&lt;/code&gt; -目标类型将针对空间进行优化，并且宽度至少为16位。</target>
        </trans-unit>
        <trans-unit id="123cd1b0c99105ee84e7c9596d06e3bc090d142a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;short&lt;/code&gt; type modifier</source>
          <target state="translated">&lt;code&gt;short&lt;/code&gt; 型修饰符</target>
        </trans-unit>
        <trans-unit id="00cee6c0e1d6a509e189e8ac023c2419b1eda94d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shuffle_order_engine&lt;/code&gt; is a random number engine adaptor that shuffles the random numbers generated by the base engine. It maintains a table of size &lt;code&gt;K&lt;/code&gt; and delivers a randomly selected number from that table when requested, replacing it with a number generated by the base engine.</source>
          <target state="translated">&lt;code&gt;shuffle_order_engine&lt;/code&gt; 是一个随机数引擎适配器，可对基础引擎生成的随机数进行混洗。它维护一个大小为 &lt;code&gt;K&lt;/code&gt; 的表，并在请求时从该表中提供一个随机选择的数字，并将其替换为基本引擎生成的数字。</target>
        </trans-unit>
        <trans-unit id="91ecdd19dc81d00e8c83ad49e607d64ce37755a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed char*&lt;/code&gt; or &lt;code&gt;unsigned char*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed char*&lt;/code&gt; 或未 &lt;code&gt;unsigned char*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99b1822957ab42790e46e37e8a072c0c142570dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed char&lt;/code&gt; - type for signed character representation.</source>
          <target state="translated">&lt;code&gt;signed char&lt;/code&gt; -签名字符表示的类型。</target>
        </trans-unit>
        <trans-unit id="596da374058fd7f0afbd5bbfcab7831fa9ecc192" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;signed short&lt;/code&gt; can be converted to &lt;code&gt;int&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;signed char&lt;/code&gt; 或带 &lt;code&gt;signed short&lt;/code&gt; 可以转换为 &lt;code&gt;int&lt;/code&gt; ；</target>
        </trans-unit>
        <trans-unit id="97c41131c74026f6e0bd5d8a010afc2374be4c86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed int*&lt;/code&gt; or &lt;code&gt;unsigned int*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed int*&lt;/code&gt; 或 &lt;code&gt;unsigned int*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="390386b58ee200c58393ed79e778468e78146d2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed long long*&lt;/code&gt; or &lt;code&gt;unsigned long long*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed long long*&lt;/code&gt; 或 &lt;code&gt;unsigned long long*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c67607f035def4bfabdfda943eebe4134024166f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed long*&lt;/code&gt; or &lt;code&gt;unsigned long*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed long*&lt;/code&gt; 或 &lt;code&gt;unsigned long*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cb4277f86bbc8fa4d2dcac6e5b0970f2986f4dbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed short*&lt;/code&gt; or &lt;code&gt;unsigned short*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;signed short*&lt;/code&gt; 或 &lt;code&gt;unsigned short*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ebc8f89a2a9e50681b4e5e39d16abf9fa7fa81d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed&lt;/code&gt; - target type will have signed representation (this is the default if omitted)</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; -目标类型将具有带符号的表示形式（如果省略，则为默认值）</target>
        </trans-unit>
        <trans-unit id="fbc6c6b5d94333cdff627e24c708ccae2b37208c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed&lt;/code&gt; type modifier</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; 类型修饰符</target>
        </trans-unit>
        <trans-unit id="7b7aafb7a506ca43395920321487c82e485d5bc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size() == 0&lt;/code&gt; (&lt;code&gt;false&lt;/code&gt; if &lt;code&gt;*this&lt;/code&gt; represents the result of a successful match, &lt;code&gt;true&lt;/code&gt; otherwise).</source>
          <target state="translated">&lt;code&gt;size() == 0&lt;/code&gt; （如果 &lt;code&gt;*this&lt;/code&gt; 表示成功匹配的结果，则为 &lt;code&gt;false&lt;/code&gt; ，否则为 &lt;code&gt;true&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="a0200f935f43d9ea73514596b9949236ec288429" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof(&lt;/code&gt;type&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sizeof(&lt;/code&gt;type&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74f6283da9a908523be109da51f59eccc8b34ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof(char)&lt;/code&gt;, &lt;code&gt;sizeof(char8_t)&lt;/code&gt;, &lt;code&gt;sizeof(signed char)&lt;/code&gt;, and &lt;code&gt;sizeof(unsigned char)&lt;/code&gt; are always equal to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sizeof(char)&lt;/code&gt; ， &lt;code&gt;sizeof(char8_t)&lt;/code&gt; ， &lt;code&gt;sizeof(signed char)&lt;/code&gt; 和 &lt;code&gt;sizeof(unsigned char)&lt;/code&gt; 始终等于 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2d407c4db07ea8eef95042a8a76e72dab2cb554" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof...(&lt;/code&gt;parameter_pack&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sizeof...(&lt;/code&gt;parameter_pack&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7d8295868555deebe8ffb79d642c5c679c33ab6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof...(Types) != 1&lt;/code&gt; or</source>
          <target state="translated">&lt;code&gt;sizeof...(Types) != 1&lt;/code&gt; 或</target>
        </trans-unit>
        <trans-unit id="b2dd33a1c9d816423d275199656286347d3db010" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; and</source>
          <target state="translated">&lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="1cdc29f44e0d0eb9ab54a7720438cfdfe2e6fc57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof&lt;/code&gt; operator</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt; 运算符大小</target>
        </trans-unit>
        <trans-unit id="fdc4b227ac6249bc4fc72287a6944b2440e3ed95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sizeof&lt;/code&gt;expression</source>
          <target state="translated">&lt;code&gt;sizeof&lt;/code&gt;expression</target>
        </trans-unit>
        <trans-unit id="e46af83e16a811405d39a5136eed045dbc6877d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slice_array&lt;/code&gt; to initialize with</source>
          <target state="translated">&lt;code&gt;slice_array&lt;/code&gt; 初始化</target>
        </trans-unit>
        <trans-unit id="b2bcdf452501c9b678e966ff76f6fd25eca36018" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sp&lt;/code&gt; on success or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">&lt;code&gt;sp&lt;/code&gt; 成功，请 &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; sp；如果失败，请执行pos_type（off_type（-1））。</target>
        </trans-unit>
        <trans-unit id="7d41a831635e74183514711ce5e212aa8540f055" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space_info.available&lt;/code&gt; is set to &lt;code&gt;f_bavail*f_frsize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space_info.available&lt;/code&gt; 设置为 &lt;code&gt;f_bavail*f_frsize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec90f237c7368e2b51a082ed93cf39569cde5592" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space_info.capacity&lt;/code&gt; is set as if by &lt;code&gt;f_blocks*f_frsize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space_info.capacity&lt;/code&gt; 通过 &lt;code&gt;f_blocks*f_frsize&lt;/code&gt; 设置space_info.capacity</target>
        </trans-unit>
        <trans-unit id="956d7231f6bf9b016483d7b4a0fed9bae1d5fd31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;space_info.free&lt;/code&gt; is set to &lt;code&gt;f_bfree*f_frsize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;space_info.free&lt;/code&gt; 设置为 &lt;code&gt;f_bfree*f_frsize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8dc60df38163004a901463b4b2e0ee6fa8bba7b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;srand()&lt;/code&gt; is not guaranteed to be thread-safe.</source>
          <target state="translated">&lt;code&gt;srand()&lt;/code&gt; 不能保证srand（）是线程安全的。</target>
        </trans-unit>
        <trans-unit id="8c45e7e857ad07375c7ff6c09de088475818794e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ss&lt;/code&gt; - 2-digit second from &lt;code&gt;timeptr-&amp;gt;tm_sec&lt;/code&gt; as if printed by &lt;code&gt;sprintf&lt;/code&gt; using &lt;code&gt;%.2d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ss&lt;/code&gt; -来自 &lt;code&gt;timeptr-&amp;gt;tm_sec&lt;/code&gt; 的 2位数秒，就好像 &lt;code&gt;sprintf&lt;/code&gt; 使用 &lt;code&gt;%.2d&lt;/code&gt; 打印</target>
        </trans-unit>
        <trans-unit id="4fa4797d7e4e56c30b5cd6e5451aeccf65e0d28b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ss&lt;/code&gt; - seconds</source>
          <target state="translated">&lt;code&gt;ss&lt;/code&gt; -秒</target>
        </trans-unit>
        <trans-unit id="691d79484e20930f6f97b2512b3af59ec6f01b0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;st.width() - 1&lt;/code&gt; characters are extracted (if &lt;code&gt;st.width()&lt;/code&gt; is greater than zero)</source>
          <target state="translated">&lt;code&gt;st.width() - 1&lt;/code&gt; 提取1个字符（如果 &lt;code&gt;st.width()&lt;/code&gt; 大于零）</target>
        </trans-unit>
        <trans-unit id="e6188cc0ce71e5819a7f3d7172eea907c503d273" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;st&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;st&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="6a6533b5d19f97b1c8ec289e396a87c9a7ce3b8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt;, a value of type &lt;code&gt;X::state_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; ，类型 &lt;code&gt;X::state_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="137369e42bcf3ba18490493f75c373a147357d4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; -</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; -</target>
        </trans-unit>
        <trans-unit id="88b6bbcd3ba3cedf0c70220790b608d1076fb3b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt; storage specifier</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; 存储说明符</target>
        </trans-unit>
        <trans-unit id="900dab33d17ef07271e0d9fbf3a2f564ae5ecbde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;T&lt;code&gt;&amp;amp;&lt;/code&gt;ref&lt;code&gt;= constexpr;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; T &lt;code&gt;&amp;amp;&lt;/code&gt; ref &lt;code&gt;= constexpr;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d44865d23521c1a15985e408614ba223370167e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;Tobject&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt;Tobject&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22c0c82bde8082dbd01c5219ee5de28b24f391b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;Tobject&lt;code&gt;= constexpr;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt; Tobject &lt;code&gt;= constexpr;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a8debab36b3f3b8d43751102d5ff3dbd91d63fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;data_member</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt;data_member</target>
        </trans-unit>
        <trans-unit id="76b4ce031d77c4b1820cf9a0abbb850a85584a79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static&lt;/code&gt;member_function</source>
          <target state="translated">&lt;code&gt;static&lt;/code&gt;member_function</target>
        </trans-unit>
        <trans-unit id="0fe5f8cbf46f1af00de7dfab8a7ed4ac4097a5c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57cfcccf24b9f4cbd3374f6385c918f0ff932eb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;,&lt;/code&gt;message&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_assert&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;bool_constexpr&lt;code&gt;,&lt;/code&gt;message&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87e5ec838bed11e196ddefdb9f84a030cef65a17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast &amp;lt;&lt;/code&gt;new_type&lt;code&gt;&amp;gt; (&lt;/code&gt;expression&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_cast &amp;lt;&lt;/code&gt; new_type &lt;code&gt;&amp;gt; (&lt;/code&gt; 表达式 &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a80e989f7fd47ae49da3c00a161119cc065006a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;&lt;/code&gt;T&lt;code&gt;&amp;gt;(&lt;/code&gt;other&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;&lt;/code&gt;T&lt;code&gt;&amp;gt;(&lt;/code&gt;other&lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f748d435919e62b9dbcd85bd69ee07adf73ef2a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt; if encoding error occurs. Nothing is written to &lt;code&gt;*pwc&lt;/code&gt;, the value &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; is stored in &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; and the value of &lt;code&gt;*ps&lt;/code&gt; is left unspecified.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-1)&lt;/code&gt; 如果发生编码错误，则static_cast &amp;lt; std :: size_t &amp;gt;（-1）。没有将任何内容写入 &lt;code&gt;*pwc&lt;/code&gt; ，值 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EILSEQ&lt;/a&gt;&lt;/code&gt; 存储在 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 中，而 &lt;code&gt;*ps&lt;/code&gt; 的值未指定。</target>
        </trans-unit>
        <trans-unit id="bdf0510fccd0959ccde826256af53acac868200e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-2)&lt;/code&gt; if the next &lt;code&gt;n&lt;/code&gt; bytes constitute an incomplete, but so far valid, multibyte character. Nothing is written to &lt;code&gt;*pwc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(-2)&lt;/code&gt; 如果接下来的 &lt;code&gt;n&lt;/code&gt; 个字节构成不完整但到目前为止仍然有效的多字节字符，则static_cast &amp;lt; std :: size_t &amp;gt;（-2）。什么都没有写到 &lt;code&gt;*pwc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3c1bd3ffc2201dd55a94a0eee33a688ba46753ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;T&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="33e6b255bed0b5078515f4b4f2bb5ccdef12194b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;To&amp;gt;(fun())&lt;/code&gt; is equal to &lt;code&gt;[]() -&amp;gt; To { return fun(); }()&lt;/code&gt;, and</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;To&amp;gt;(fun())&lt;/code&gt; 等于 &lt;code&gt;[]() -&amp;gt; To { return fun(); }()&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="b1d0930f989e7a9b27263d94d9d956f9a433ac9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&amp;lt;typename &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference&lt;/a&gt;&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;static_cast&amp;lt;typename &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference&lt;/a&gt;&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a4a2866542a98e87edaceca4b712cfae49435a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&lt;/code&gt; conversion</source>
          <target state="translated">&lt;code&gt;static_cast&lt;/code&gt; 转换</target>
        </trans-unit>
        <trans-unit id="d8feda07a6b401eca5278d4cf8ec524b614fd12c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static_cast&lt;/code&gt; may also be used to disambiguate function overloads by performing a function-to-pointer conversion to specific type, as in.</source>
          <target state="translated">&lt;code&gt;static_cast&lt;/code&gt; 通过执行到特定类型的函数到指针的转换，static_cast也可以用于消除函数重载的歧义，例如。</target>
        </trans-unit>
        <trans-unit id="baa3bbadf4fb980e424c228048633bb156a9aad1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; subsumes &lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;U, T&amp;gt;&lt;/code&gt; and vice versa.</source>
          <target state="translated">&lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; 包含 &lt;code&gt;std::&lt;a href=&quot;same&quot;&gt;Same&lt;/a&gt;&amp;lt;U, T&amp;gt;&lt;/code&gt; ，反之亦然。</target>
        </trans-unit>
        <trans-unit id="ede0befc08584ae7a5fdf3a513d0dcccabc5c6b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::abs&lt;/code&gt; was erroneously required to have overloads for integer types returning &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::abs&lt;/code&gt; 错误地要求std :: abs对返回 &lt;code&gt;double&lt;/code&gt; 的整数类型进行重载</target>
        </trans-unit>
        <trans-unit id="6c54c3bc37b2a8917b0fc03bd885ff743f102d0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::accumulate&lt;/code&gt; performs a left fold. In order to perform a right fold, one must reverse the order of the arguments to the binary operator, and use reverse iterators.</source>
          <target state="translated">&lt;code&gt;std::accumulate&lt;/code&gt; 执行左折。为了进行正确的折叠，必须将参数的顺序颠倒到二进制运算符，并使用反向迭代器。</target>
        </trans-unit>
        <trans-unit id="bcc2ebd66f6f03846c63c93062450ad4cf220759" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::add_pointer&lt;/code&gt; was required to produce</source>
          <target state="translated">&lt;code&gt;std::add_pointer&lt;/code&gt; 才能产生</target>
        </trans-unit>
        <trans-unit id="b1234e7bdd717c6d017d2bb87c22008eb08e0a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::allocator_arg&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;&lt;/code&gt; used to disambiguate, at call site, the overloads of the constructors and member functions of allocator-aware objects, such as &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, (until C++17)and &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::allocator_arg&lt;/code&gt; 是类型的常量 &lt;code&gt;&lt;a href=&quot;allocator_arg_t&quot;&gt;std::allocator_arg_t&lt;/a&gt;&lt;/code&gt; 用来消除，在调用位置，分配器感知对象，如的构造函数和成员函数的重载 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; ，（直到C ++ 17）和 &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b0e63dff632dcb321d0e56a33d6d39b1b98452a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::allocator_arg_t&lt;/code&gt; is an empty class type used to disambiguate the overloads of constructors and member functions of allocator-aware objects, including &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, (until C++17)and &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::allocator_arg_t&lt;/code&gt; 是一个空类类型，用于消除可识别分配器的对象的构造函数和成员函数的重载，包括 &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../thread/packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; ，（直到C ++ 17）和 &lt;code&gt;&lt;a href=&quot;../thread/promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0397b262f2892865e4509d76daa0c90a2aad6b66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::array&lt;/code&gt; is a container that encapsulates fixed size arrays.</source>
          <target state="translated">&lt;code&gt;std::array&lt;/code&gt; 是封装固定大小的数组的容器。</target>
        </trans-unit>
        <trans-unit id="47bb28b8cd6bf39d74e4ee0354a8fde98b200ce8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::array&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt; except that default-constructed array is not empty and that the complexity of swapping is linear, satisfies the requirements of &lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt;,(since C++17) and partially satisfies the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::array&lt;/code&gt; 满足&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;和&lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;的要求，不同之处在于默认构造的数组不为空并且交换的复杂度是线性的，满足&lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt;的要求（自C ++ 17起），并且部分满足&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="76f124fee1f6d404bb5d3c59df3332f4ba0e6997" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atan2(y, x)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../complex/arg&quot;&gt;std::arg&lt;/a&gt;(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::atan2(y, x)&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;../complex/arg&quot;&gt;std::arg&lt;/a&gt;(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbef2b205fea689e577abcebc9dc5b7b84b115b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; was permitted for</source>
          <target state="translated">&lt;code&gt;std::atomic&amp;lt;T&amp;gt;&lt;/code&gt; 被允许用于</target>
        </trans-unit>
        <trans-unit id="bb4b933229da7eb89ef0e1d0dba9aa3137507bc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic&amp;lt;bool&amp;gt;&lt;/code&gt; uses the primary template. It is guaranteed to be a standard layout struct.</source>
          <target state="translated">&lt;code&gt;std::atomic&amp;lt;bool&amp;gt;&lt;/code&gt; 使用主要模板。保证它是一个标准的布局结构。</target>
        </trans-unit>
        <trans-unit id="4c0b05c455392c723841488c17ad3333763a7b15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::atomic&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="4a0803b61a969f4a0731b2365b00b3c8c077e75b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic_flag&lt;/code&gt; is an atomic boolean type. Unlike all specializations of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;, it is guaranteed to be lock-free. Unlike &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;, &lt;code&gt;std::atomic_flag&lt;/code&gt; does not provide load or store operations.</source>
          <target state="translated">&lt;code&gt;std::atomic_flag&lt;/code&gt; 是原子布尔类型。与 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 所有专业不同，它保证是无锁的。与 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::atomic_flag&lt;/code&gt; 不提供加载或存储操作。</target>
        </trans-unit>
        <trans-unit id="38cbf066238967320059f92fe8d8095dc30f0a6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::atomic_ref&lt;/code&gt; is &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::atomic_ref&lt;/code&gt; 是&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8c0bec0c1a6726f4ba3ff1919aef2655cc5d1549" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::back_insert_iterator&lt;/code&gt; is an &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that appends to a container for which it was constructed. The container's &lt;code&gt;push_back()&lt;/code&gt; member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::back_insert_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::back_insert_iterator&lt;/code&gt; 是一个&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;，它附加到为其构造容器中。每当分配迭代器（无论是否取消引用）时，都会调用容器的 &lt;code&gt;push_back()&lt;/code&gt; 成员函数。增加 &lt;code&gt;std::back_insert_iterator&lt;/code&gt; 是没有操作的。</target>
        </trans-unit>
        <trans-unit id="1ccbe9f22a72664a5718095af50ed8534ef901f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_alloc&lt;/code&gt; is the type of the object thrown as exceptions by the &lt;a href=&quot;operator_new&quot;&gt;allocation functions&lt;/a&gt; to report failure to allocate storage.</source>
          <target state="translated">&lt;code&gt;std::bad_alloc&lt;/code&gt; 是&lt;a href=&quot;operator_new&quot;&gt;分配函数&lt;/a&gt;抛出异常以报告分配存储失败的对象的类型。</target>
        </trans-unit>
        <trans-unit id="f894909b251043c10519cdc9419593fbd42c3929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_array_new_length&lt;/code&gt; is the type of the object thrown as exceptions by the &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to report invalid array lengths if.</source>
          <target state="translated">&lt;code&gt;std::bad_array_new_length&lt;/code&gt; 是&lt;a href=&quot;../../language/new&quot;&gt;new表达式&lt;/a&gt;抛出异常以报告无效数组长度的对象的类型。</target>
        </trans-unit>
        <trans-unit id="3cece263d9e71f9d724d7edcfb758b9850990db8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_exception&lt;/code&gt; is the type of the exception thrown by the C++ runtime in the following situations:</source>
          <target state="translated">&lt;code&gt;std::bad_exception&lt;/code&gt; 在以下情况下，std :: bad_exception是C ++运行时引发的异常的类型：</target>
        </trans-unit>
        <trans-unit id="326879d3dd40f1fab9d393072c4d721a39f2e130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_function_call&lt;/code&gt; is the type of the exception thrown by &lt;a href=&quot;function/operator()&quot;&gt; &lt;code&gt;std::function::operator()&lt;/code&gt; &lt;/a&gt; if the function wrapper has no target.</source>
          <target state="translated">&lt;code&gt;std::bad_function_call&lt;/code&gt; 如果函数包装没有目标，则std :: bad_function_call是&lt;a href=&quot;function/operator()&quot;&gt; &lt;code&gt;std::function::operator()&lt;/code&gt; &lt;/a&gt;引发的异常的类型。</target>
        </trans-unit>
        <trans-unit id="f6aa2069b29e331b758f7a814d4a7763e6d6f81f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_variant_access&lt;/code&gt; is the type of the exception thrown in the following situations:</source>
          <target state="translated">&lt;code&gt;std::bad_variant_access&lt;/code&gt; 是在以下情况下引发的异常类型：</target>
        </trans-unit>
        <trans-unit id="36ec4a07aa10ab404e6cd9a170ecee64252fa5a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bad_weak_ptr&lt;/code&gt; is the type of the object thrown as exceptions by the constructors of &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; that take &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; as the argument, when the &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; refers to an already deleted object.</source>
          <target state="translated">&lt;code&gt;std::bad_weak_ptr&lt;/code&gt; 是由 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 的构造函数以 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 作为参数而抛出的对象的类型，当 &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; 引用已删除的对象时。</target>
        </trans-unit>
        <trans-unit id="c6230cfe80f845737eb67452ccf7bbac692f90ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_filebuf&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; whose associated character sequence is a file. Both the input sequence and the output sequence are associated with the same file, and a joint file position is maintained for both operations.</source>
          <target state="translated">&lt;code&gt;std::basic_filebuf&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 其关联字符序列是一个文件。输入序列和输出序列都与同一个文件相关联，并且两个操作都保持联合文件位置。</target>
        </trans-unit>
        <trans-unit id="4fe3a0b10ce1dabce9f14a49bd17e9baca64483c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_osyncstream&lt;/code&gt;, &lt;code&gt;std::basic_syncbuf&lt;/code&gt;, and typedefs</source>
          <target state="translated">&lt;code&gt;std::basic_osyncstream&lt;/code&gt; ， &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 和typedef</target>
        </trans-unit>
        <trans-unit id="3462726fed80b85e9359be5d293b2169b295577d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_string&lt;/code&gt; and &lt;code&gt;std::sub_match&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::basic_string&lt;/code&gt; 和 &lt;code&gt;std::sub_match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34319833fb2ad6fb976269b586a465fcfaea3aaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_string&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;and &lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt;(since C++17).</source>
          <target state="translated">&lt;code&gt;std::basic_string&lt;/code&gt; 满足的要求&lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;，&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;和&lt;a href=&quot;../named_req/contiguouscontainer&quot;&gt;ContiguousContainer&lt;/a&gt;（因为C ++ 17）。</target>
        </trans-unit>
        <trans-unit id="25042ac23a934cf1670e58afd01a08f042989654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_string_view&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::basic_string_view&amp;lt;char8_t&amp;gt;&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="5c74e2a9de4dbc23d6fdac9505857cb54752ed5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_stringbuf&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; whose associated character sequence is a memory-resident sequence of arbitrary characters, which can be initialized from or made available as an instance of &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_stringbuf&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 其关联的字符序列是任意字符在内存中的驻留序列，可以从 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 实例进行初始化或将其用作实例。</target>
        </trans-unit>
        <trans-unit id="e2f68bb275827e707542a32b2132fc70d0be8bf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_syncbuf&lt;/code&gt; is a wrapper for a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; (provided at construction time as a pointer). It accumulates output in its own internal buffer, and atomically transmits its entire contents to the wrapped buffer on destruction and when explicitly requested, so that they appear as a contiguous sequence of characters. It guarantees that there are no data races and no interleaving of characters sent to the wrapped buffer as long as all other outputs made to the same buffer are made through, possibly different, instances of &lt;code&gt;std::basic_syncbuf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::basic_syncbuf&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 的包装器（在构造时作为指针提供）。它在自己的内部缓冲区中累积输出，并在销毁时以及在显式请求时原子地将其全部内容传输到包装的缓冲区，以使它们显示为连续的字符序列。它保证没有数据争用，并且没有发送到包装缓冲区的字符交织，只要对同一缓冲区进行的所有其他输出都是通过 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 实例进行的，则可能不同。</target>
        </trans-unit>
        <trans-unit id="fd83eadd1fc2d1f8db155ac3d34318bc1cf56684" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::basic_syncbuf&lt;/code&gt; objects whose states to swap</source>
          <target state="translated">&lt;code&gt;std::basic_syncbuf&lt;/code&gt; 对象，其状态要交换</target>
        </trans-unit>
        <trans-unit id="97f580905e381c907d981e60e66970e721b2cc85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bernoulli_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::bernoulli_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43c36891564fc4f7245b7b75bc84f9cba02ebeba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bind_front&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; provide support for &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;partial function application&lt;/a&gt;, i.e. binding arguments to functions to produce new functions.</source>
          <target state="translated">&lt;code&gt;std::bind_front&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;functional/bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; 提供对&lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_application&quot;&gt;部分函数应用程序的&lt;/a&gt;支持，即将参数绑定到函数以产生新函数。</target>
        </trans-unit>
        <trans-unit id="23785313d052adc0763e422629822ed2e8e29065" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::binomial_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::binomial_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9224a909447446235fdc4fa450b3009f5990c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::bit_xor&amp;lt;&amp;gt;&lt;/code&gt; is a specialization of &lt;code&gt;std::bit_xor&lt;/code&gt; with parameter and return type deduced.</source>
          <target state="translated">&lt;code&gt;std::bit_xor&amp;lt;&amp;gt;&lt;/code&gt; 是 &lt;code&gt;std::bit_xor&lt;/code&gt; 带有推导的参数和返回类型。</target>
        </trans-unit>
        <trans-unit id="32ab0725b4937789956cd3134e83f4fc6bca42ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::boolalpha&lt;/code&gt; is an I/O manipulator, so it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::boolalpha&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::boolalpha&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::boolalpha&lt;/code&gt; 是一个I / O操作器，所以它可以与一个表达被称为诸如 &lt;code&gt;out &amp;lt;&amp;lt; std::boolalpha&lt;/code&gt; 任何 &lt;code&gt;out&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 或用表达如 &lt;code&gt;in &amp;gt;&amp;gt; std::boolalpha&lt;/code&gt; 对于任何 &lt;code&gt;in&lt;/code&gt; 类型 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97d1b1f997f3c874053645c2d47ec851fbbaffec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::byte&lt;/code&gt; is a distinct type that implements the concept of byte as specified in the C++ language definition.</source>
          <target state="translated">&lt;code&gt;std::byte&lt;/code&gt; 是一种独特的类型，可实现C ++语言定义中指定的字节概念。</target>
        </trans-unit>
        <trans-unit id="e846956a578897f5a7e8147360b6876f9d4a4e1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::calloc&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt;(since C++17), &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::calloc&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;realloc&quot;&gt;std::realloc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt; （C ++ 17起）， &lt;code&gt;&lt;a href=&quot;free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c2b3f8186c4392f51363031a506c5b7fef66d2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::cauchy_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::cauchy_distribution&lt;/code&gt; 满足所有要求&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="22639445336d9d5d493d71fecd2210de50ce3b9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::cbrt(arg)&lt;/code&gt; is not equivalent to &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;(arg, 1.0/3)&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; cannot raise a negative base to a fractional exponent.</source>
          <target state="translated">&lt;code&gt;std::cbrt(arg)&lt;/code&gt; 不等同于 &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;(arg, 1.0/3)&lt;/code&gt; 因为 &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; 不能将负基数提高到分数指数。</target>
        </trans-unit>
        <trans-unit id="d3ec330bf10bf64cd6976f9f6cdbde763a641535" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chi_squared_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chi_squared_distribution&lt;/code&gt; 满足所有要求&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3e8cbc766caa8d1c32abffb171a8a2c76a622ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::clock_time_conversion&lt;/code&gt; is a trait that specifies how to convert a &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; of the &lt;code&gt;Source&lt;/code&gt; clock to that of the &lt;code&gt;Dest&lt;/code&gt; clock. It does so by providing an const-callable &lt;code&gt;operator()&lt;/code&gt; that accepts an argument of type &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Source, Duration&amp;gt;&lt;/code&gt; and returns a &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Dest, OtherDuration&amp;gt;&lt;/code&gt; that represents an equivalent point in time. The duration of the returned time point is computed from the source duration in a manner that varies for each specialization. &lt;code&gt;clock_time_conversion&lt;/code&gt; is normally only used indirectly, via &lt;code&gt;std::chrono::clock_cast&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::clock_time_conversion&lt;/code&gt; 是一种特质指定如何转换 &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 的的 &lt;code&gt;Source&lt;/code&gt; 时钟，该时钟的的 &lt;code&gt;Dest&lt;/code&gt; 时钟。它通过提供一个const-callable &lt;code&gt;operator()&lt;/code&gt; 来接受，该操作符接受类型为 &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Source, Duration&amp;gt;&lt;/code&gt; 的参数，并返回代表等效点的 &lt;code&gt;&lt;a href=&quot;time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&amp;lt;Dest, OtherDuration&amp;gt;&lt;/code&gt; 及时。返回的时间点的持续时间是根据源持续时间以针对每个专业化而变化的方式计算的。 &lt;code&gt;clock_time_conversion&lt;/code&gt; 通常仅通过 &lt;code&gt;std::chrono::clock_cast&lt;/code&gt; 间接使用。</target>
        </trans-unit>
        <trans-unit id="f045d2731dae7d9a2469f88b10eff5dd32f72004" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::days&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::days&lt;/code&gt; （C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="2ea4b95a0683371b2f9ca49e28e41457c8ef2523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::file_clock&lt;/code&gt; is an alias for the clock used for &lt;code&gt;&lt;a href=&quot;../filesystem/file_time_type&quot;&gt;std::filesystem::file_time_type&lt;/a&gt;&lt;/code&gt;. Its epoch is unspecified.</source>
          <target state="translated">&lt;code&gt;std::chrono::file_clock&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../filesystem/file_time_type&quot;&gt;std::filesystem::file_time_type&lt;/a&gt;&lt;/code&gt; 用于std :: filesystem :: file_time_type的时钟的别名。未指定其时代。</target>
        </trans-unit>
        <trans-unit id="e125350fc562e970446db9758feb9b73754284bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::high_resolution_clock&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::high_resolution_clock&lt;/code&gt; &lt;a href=&quot;../named_req/trivialclock&quot;&gt;chrono &lt;/a&gt;:: high_resolution_clock满足TrivialClock的要求。</target>
        </trans-unit>
        <trans-unit id="df728f8be5b4f6a57be6ab7ff93578a6707a0ae0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::last&lt;/code&gt;, for the last day of the month;</source>
          <target state="translated">&lt;code&gt;std::chrono::last&lt;/code&gt; ，表示该月的最后一天；</target>
        </trans-unit>
        <trans-unit id="0127b3d83922034df1531223fe21706512bf36a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::months&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::months&lt;/code&gt; （C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="5d887bf37e598dda8d113c25633ab88f4cb13600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::steady_clock&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::steady_clock&lt;/code&gt; 符合要求&lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="52324f00eaa15e4cdc6c43217ed2771a102427a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::system_clock&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/trivialclock&quot;&gt;TrivialClock&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::chrono::system_clock&lt;/code&gt; &lt;a href=&quot;../named_req/trivialclock&quot;&gt;chrono &lt;/a&gt;:: system_clock满足TrivialClock的要求。</target>
        </trans-unit>
        <trans-unit id="7fc04ed7e313d32198d59c13b4792d1b0b173e71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::weeks&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::weeks&lt;/code&gt; （C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="9ac4f34b32160656cbecc98a1ee4572f732b67f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::years&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::chrono::years&lt;/code&gt; （C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="bfa5e06d771be8d4f6dc7663237bbe9daf5d82bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono::years&lt;/code&gt;- and &lt;code&gt;std::chrono::months&lt;/code&gt;-oriented arithmetic are supported directly. An implicit conversion to &lt;code&gt;std::chrono::sys_days&lt;/code&gt; allows &lt;code&gt;std::chrono::days&lt;/code&gt;-oriented arithmetic to be performed efficiently.</source>
          <target state="translated">&lt;code&gt;std::chrono::years&lt;/code&gt; 直接支持std :: chrono :: years和 &lt;code&gt;std::chrono::months&lt;/code&gt; 算术。隐式转换为 &lt;code&gt;std::chrono::sys_days&lt;/code&gt; 可以有效地执行面向 &lt;code&gt;std::chrono::days&lt;/code&gt; :: chrono :: days的算法。</target>
        </trans-unit>
        <trans-unit id="a5484ab6c0379a27fdb71488f7d15e044a76eb4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::chrono&lt;/code&gt; library</source>
          <target state="translated">&lt;code&gt;std::chrono&lt;/code&gt; 库</target>
        </trans-unit>
        <trans-unit id="4d296ea5863ff7b777d56292c8433e0452f6c6fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates multibyte/wide character conversion rules of a locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::codecvt_byname&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 方面，它封装了在其构造时指定的语言环境的多字节/宽字符转换规则。</target>
        </trans-unit>
        <trans-unit id="b7dd739f104fae21a79d350564d83476981e9e5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_utf16&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates conversion between a UTF-16 encoded byte string and UCS2 or UTF-32 character string (depending on the type of &lt;code&gt;Elem&lt;/code&gt;). This codecvt facet can be used to read and write UTF-16 files in binary mode.</source>
          <target state="translated">&lt;code&gt;std::codecvt_utf16&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 方面，它封装了UTF-16编码的字节字符串与UCS2或UTF-32字符串之间的转换（取决于 &lt;code&gt;Elem&lt;/code&gt; 的类型）。此编解码器构面可用于以二进制模式读取和写入UTF-16文件。</target>
        </trans-unit>
        <trans-unit id="29c174bd3330ba8bf72caa31f7b6b42fa1d9156b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_utf8&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates conversion between a UTF-8 encoded byte string and UCS2 or UTF-32 character string (depending on the type of &lt;code&gt;Elem&lt;/code&gt;). This codecvt facet can be used to read and write UTF-8 files, both text and binary.</source>
          <target state="translated">&lt;code&gt;std::codecvt_utf8&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 方面，它封装了UTF-8编码的字节字符串与UCS2或UTF-32字符串之间的转换（取决于 &lt;code&gt;Elem&lt;/code&gt; 的类型）。此编解码器构面可用于读取和写入文本和二进制UTF-8文件。</target>
        </trans-unit>
        <trans-unit id="f832b9bf45eec9f2f115b12128fe723b4c68cfe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::codecvt_utf8_utf16&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet which encapsulates conversion between a UTF-8 encoded byte string and UTF-16 encoded character string. If &lt;code&gt;Elem&lt;/code&gt; is a 32-bit type, one UTF-16 code unit will be stored in each 32-bit character of the output sequence.</source>
          <target state="translated">&lt;code&gt;std::codecvt_utf8_utf16&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 方面，它封装了UTF-8编码的字节字符串和UTF-16编码的字符串之间的转换。如果 &lt;code&gt;Elem&lt;/code&gt; 是32位类型，则一个UTF-16代码单元将存储在输出序列的每个32位字符中。</target>
        </trans-unit>
        <trans-unit id="a27e5fee138f572ad520ea598cf73bc2e8e68699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::collate_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet which encapsulates locale-specific collation (comparison) and hashing of strings. Just like &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt;, it can be imbued in &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; and applied, by means of &lt;code&gt;std::locale::operator()&lt;/code&gt;, directly to all standard algorithms that expect a string comparison predicate.</source>
          <target state="translated">&lt;code&gt;std::collate_byname&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; 方面，它封装了特定于语言环境的排序规则（比较）和字符串哈希。就像 &lt;code&gt;&lt;a href=&quot;collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; ，它可以嵌入 &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; 并通过 &lt;code&gt;std::locale::operator()&lt;/code&gt; 直接应用于所有期望字符串比较谓词的标准算法。</target>
        </trans-unit>
        <trans-unit id="f0fee92b6a576e7386950be6f1be627eb62f33db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::condition_variable&lt;/code&gt; works only with &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&amp;lt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&amp;gt;&lt;/code&gt;; this restriction allows for maximal efficiency on some platforms. &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; provides a condition variable that works with any &lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; object, such as &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::condition_variable&lt;/code&gt; 仅适用于 &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&amp;lt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&amp;gt;&lt;/code&gt; ; 此限制允许在某些平台上获得最大效率。 &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; 提供了一个可与任何&lt;a href=&quot;../named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt;对象一起使用的条件变量，例如 &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a09cabee8cc7327ea6113cf876758db70326f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::condition_variable_any&lt;/code&gt; can be used with &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; in order to wait on a &lt;code&gt;&lt;a href=&quot;shared_mutex&quot;&gt;std::shared_mutex&lt;/a&gt;&lt;/code&gt; in shared ownership mode.</source>
          <target state="translated">&lt;code&gt;std::condition_variable_any&lt;/code&gt; 可以与 &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; 一起使用，以便在共享所有权模式下等待 &lt;code&gt;&lt;a href=&quot;shared_mutex&quot;&gt;std::shared_mutex&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="da285dc396f63c6f4370c85412e3bf4c8b70288c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::copysign&lt;/code&gt; is the only portable way to manipulate the sign of a NaN value (to examine the sign of a NaN, &lt;code&gt;signbit&lt;/code&gt; may also be used).</source>
          <target state="translated">&lt;code&gt;std::copysign&lt;/code&gt; 是操纵NaN值的符号的唯一可移植方式（要检查NaN的符号，也可以使用 &lt;code&gt;signbit&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="dec4cfaf4dd31be3402d0290d7bcf0c2cda100d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ctype_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet which encapsulates character classification rules of the locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::ctype_byname&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; 构面，它封装在构造时指定的语言环境的字符分类规则。</target>
        </trans-unit>
        <trans-unit id="48d133c7dc05905738abe26c5cc2610f78667ed8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::cv_status&lt;/code&gt; is used by the &lt;code&gt;wait_for&lt;/code&gt; and &lt;code&gt;wait_until&lt;/code&gt; methods of &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::cv_status&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; 的 &lt;code&gt;wait_for&lt;/code&gt; 和 &lt;code&gt;wait_until&lt;/code&gt; 方法使用std :: cv_status。</target>
        </trans-unit>
        <trans-unit id="78c2046db037983cb249ce8d08603b36997f911a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::default_delete&lt;/code&gt; is the default destruction policy used by &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; when no deleter is specified.</source>
          <target state="translated">&lt;code&gt;std::default_delete&lt;/code&gt; 如果未指定删除器，则std :: default_delete是 &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 使用的默认销毁策略。</target>
        </trans-unit>
        <trans-unit id="11ee961a9fe952865469b5b1362eb3a6d1138456" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::defer_lock&lt;/code&gt;, &lt;code&gt;std::try_to_lock&lt;/code&gt; and &lt;code&gt;std::adopt_lock&lt;/code&gt; are instances of empty struct tag types &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::defer_lock_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::try_to_lock_t&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::adopt_lock_t&lt;/a&gt;&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;std::defer_lock&lt;/code&gt; ， &lt;code&gt;std::try_to_lock&lt;/code&gt; 和 &lt;code&gt;std::adopt_lock&lt;/code&gt; 分别是空结构标记类型 &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::defer_lock_t&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::try_to_lock_t&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;lock_tag_t&quot;&gt;std::adopt_lock_t&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ff534366543af0ca822f02d2f5404431b0438911" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::defer_lock_t&lt;/code&gt;, &lt;code&gt;std::try_to_lock_t&lt;/code&gt; and &lt;code&gt;std::adopt_lock_t&lt;/code&gt; are empty struct tag types used to specify locking strategy for &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::scoped_lock&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::defer_lock_t&lt;/code&gt; ， &lt;code&gt;std::try_to_lock_t&lt;/code&gt; 和 &lt;code&gt;std::adopt_lock_t&lt;/code&gt; 是空的结构标签类型，用于为 &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;std::scoped_lock&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; 指定锁定策略。</target>
        </trans-unit>
        <trans-unit id="a5ba3a6548fd85a605db2a04aef9e451efc0f9a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::deque&lt;/code&gt; (double-ended queue) is an indexed sequence container that allows fast insertion and deletion at both its beginning and its end. In addition, insertion and deletion at either end of a deque never invalidates pointers or references to the rest of the elements.</source>
          <target state="translated">&lt;code&gt;std::deque&lt;/code&gt; （双端队列）是一个索引序列容器，允许在其开始和结束时都进行快速插入和删除。此外，在双端队列的任一端插入和删除都不会使指向其余元素的指针或引用无效。</target>
        </trans-unit>
        <trans-unit id="ac7511003a8120ef1ac2ae270a948663e03c1233" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::deque&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::deque&lt;/code&gt; 满足&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;，&lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;，&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;和&lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer的要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd1189e9a91c6fd7c0c352263f9b637a6e4ec29e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::discrete_distribution&lt;/code&gt; produces random integers on the interval &lt;code&gt;[0, n)&lt;/code&gt;, where the probability of each individual integer &lt;code&gt;i&lt;/code&gt; is defined as w</source>
          <target state="translated">&lt;code&gt;std::discrete_distribution&lt;/code&gt; 在间隔 &lt;code&gt;[0, n)&lt;/code&gt; 上生成随机整数，其中每个单独整数 &lt;code&gt;i&lt;/code&gt; 的概率定义为w</target>
        </trans-unit>
        <trans-unit id="73b9063244eaf29698d1ce46baf9783f844ba9e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::discrete_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::discrete_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution的&lt;/a&gt;所有要求。</target>
        </trans-unit>
        <trans-unit id="babc06a10c9c15005fb04a3d088bf1290c70919d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::dynamic_extent&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; that is used to differentiate &lt;a href=&quot;../span&quot;&gt;&lt;code&gt;std::span&lt;/code&gt;&lt;/a&gt; of static and dynamic extent.</source>
          <target state="translated">&lt;code&gt;std::dynamic_extent&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 类型的常量，用于区分静态和动态范围的&lt;a href=&quot;../span&quot;&gt; &lt;code&gt;std::span&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c0c7ae6a02052d574c16ef064424d6bdfd3ac30f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::enable_shared_from_this&lt;/code&gt; allows an object &lt;code&gt;t&lt;/code&gt; that is currently managed by a &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; named &lt;code&gt;pt&lt;/code&gt; to safely generate additional &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; instances &lt;code&gt;pt1, pt2, ...&lt;/code&gt; that all share ownership of &lt;code&gt;t&lt;/code&gt; with &lt;code&gt;pt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::enable_shared_from_this&lt;/code&gt; 允许当前由名为 &lt;code&gt;pt&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 管理的对象 &lt;code&gt;t&lt;/code&gt; 安全地生成其他 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 实例 &lt;code&gt;pt1, pt2, ...&lt;/code&gt; 都与 &lt;code&gt;pt&lt;/code&gt; 共享 &lt;code&gt;t&lt;/code&gt; 的所有权。</target>
        </trans-unit>
        <trans-unit id="9b225dda4f3adfeaed7ea510758b565e3aecef23" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::equal&lt;/code&gt; should not be used to compare the ranges formed by the iterators from &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; because the order in which the elements are stored in those containers may be different even if the two containers store the same elements.</source>
          <target state="translated">&lt;code&gt;std::equal&lt;/code&gt; 不应用于比较由 &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 的迭代器形成的范围，因为元素在这些容器中的存储顺序可能即使两个容器存储相同的元素，它们也将不同。</target>
        </trans-unit>
        <trans-unit id="632f518e0f97f3ba086be4ec5a62bb8100c02856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::error_category&lt;/code&gt; serves as the base class for specific error category types, such as &lt;code&gt;&lt;a href=&quot;system_category&quot;&gt;std::system_category&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/iostream_category&quot;&gt;std::iostream_category&lt;/a&gt;&lt;/code&gt;, etc. Each specific category class defines the &lt;code&gt;error_code&lt;/code&gt; - &lt;code&gt;error_condition&lt;/code&gt; mapping and holds the explanatory strings for all error_conditions. The objects of error category classes are treated as singletons, passed by reference.</source>
          <target state="translated">&lt;code&gt;std::error_category&lt;/code&gt; 用作特定错误类别类型的基类，例如 &lt;code&gt;&lt;a href=&quot;system_category&quot;&gt;std::system_category&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../io/iostream_category&quot;&gt;std::iostream_category&lt;/a&gt;&lt;/code&gt; 等。每个特定类别类都定义了 &lt;code&gt;error_code&lt;/code&gt; - &lt;code&gt;error_condition&lt;/code&gt; 映射，并包含所有error_conditions的解释字符串。错误类别类的对象被视为单例，通过引用传递。</target>
        </trans-unit>
        <trans-unit id="fac9c199fb321fcb496aead48672d7b130b469fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::error_code&lt;/code&gt; is a platform-dependent error code. Each &lt;code&gt;std::error_code&lt;/code&gt; object holds an error code originating from the operating system or some low-level interface and a pointer to an object of type &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;, which corresponds to the said interface. The error code values may be not unique across different error categories.</source>
          <target state="translated">&lt;code&gt;std::error_code&lt;/code&gt; 是与平台有关的错误代码。每个 &lt;code&gt;std::error_code&lt;/code&gt; 对象都包含一个源自操作系统或某个低级接口的错误代码，以及一个指向 &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 类型的对象的指针，该对象对应于所述接口。错误代码值在不同的错误类别中可能不是唯一的。</target>
        </trans-unit>
        <trans-unit id="f695bdc00126c7ac476d86d0fb6b8427fd15538f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::error_condition&lt;/code&gt; is a platform-independent error code. Like &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, it is uniquely identified by an integer value and a &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;, but unlike &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, the value is not platform-dependent.</source>
          <target state="translated">&lt;code&gt;std::error_condition&lt;/code&gt; 是与平台无关的错误代码。与 &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 一样，它由整数值和 &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; 唯一标识，但与 &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; 不同，该值与平台无关。</target>
        </trans-unit>
        <trans-unit id="d8e8654c75557ba66cb78816d2393b7f829e6472" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exception_ptr&lt;/code&gt; is a nullable pointer-like type that manages an exception object which has been thrown and captured with &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;. An instance of &lt;code&gt;std::exception_ptr&lt;/code&gt; may be passed to another function, possibly on another thread, where the exception may be rethrown and handled with a catch clause.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; 是可为空的类指针类型，用于管理已用 &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; 抛出并捕获的异常对象。可以将 &lt;code&gt;std::exception_ptr&lt;/code&gt; 的实例传递到另一个函数，可能在另一个线程上，在该线程中可以使用catch子句将异常重新抛出并进行处理。</target>
        </trans-unit>
        <trans-unit id="14b49292590a444036557cbbbda93f38fff8d1b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exception_ptr&lt;/code&gt; is not implicitly convertible to any arithmetic, enumeration, or pointer type. It is contextually convertible to &lt;code&gt;bool&lt;/code&gt;, and will evaluate to false if it is null, true otherwise.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; 不能隐式转换为任何算术，枚举或指针类型。它在上下文上可以转换为 &lt;code&gt;bool&lt;/code&gt; ，如果为null，则计算结果为false，否则为true。</target>
        </trans-unit>
        <trans-unit id="57641bf827fb4f30125de277f6b3255d2e659787" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exception_ptr&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::exception_ptr&lt;/code&gt; 满足&lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="9855684a30c9ba5dfd239066f3ae8f0d65a98657" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::execution::seq&lt;/code&gt;, &lt;code&gt;std::execution::par&lt;/code&gt;, &lt;code&gt;std::execution::par_unseq&lt;/code&gt;, and &lt;code&gt;std::execution::unseq&lt;/code&gt; are instances of the execution policy types &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::sequenced_policy&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_policy&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_unsequenced_policy&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;std::execution::unsequenced_policy&lt;/code&gt; respectively. They are used to specify the execution policy of parallel algorithms - i.e., the kinds of parallelism allowed.</source>
          <target state="translated">&lt;code&gt;std::execution::seq&lt;/code&gt; ， &lt;code&gt;std::execution::par&lt;/code&gt; ， &lt;code&gt;std::execution::par_unseq&lt;/code&gt; 和 &lt;code&gt;std::execution::unseq&lt;/code&gt; 是执行策略类型 &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::sequenced_policy&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_policy&lt;/a&gt;&lt;/code&gt; 实例execute :: parallel_policy， &lt;code&gt;&lt;a href=&quot;execution_policy_tag_t&quot;&gt;std::execution::parallel_unsequenced_policy&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;std::execution::unsequenced_policy&lt;/code&gt; 。它们用于指定并行算法的执行策略-即允许的并行性类型。</target>
        </trans-unit>
        <trans-unit id="f81f924ab5fb012ab97a4c81941f6da54601b41c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::exponential_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::exponential_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="731f75b5983a917cf59abfe73aa61c1e6683808d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::extreme_value_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::extreme_value_distribution&lt;/code&gt; 满足所有要求&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6b45df502c8abb6d9404ea462f3d01ebde814a38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::fisher_f_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::fisher_f_distribution&lt;/code&gt; 满足所有要求&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4c4072e32a83cf416dd9cce5e53d8848117eccb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::fmod&lt;/code&gt;, but not &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; is useful for doing silent wrapping of floating-point types to unsigned integer types: &lt;code&gt;(0.0 &amp;lt;= (y = std::fmod( &lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0 )) ? y : 65536.0 + y)&lt;/code&gt; is in the range &lt;code&gt;[-0.0 .. 65535.0]&lt;/code&gt;, which corresponds to &lt;code&gt;unsigned short&lt;/code&gt;, but &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;(&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0&lt;/code&gt; is in the range &lt;code&gt;[-32767.0, +32768.0]&lt;/code&gt;, which is outside of the range of &lt;code&gt;signed short&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::fmod&lt;/code&gt; 而不是 &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; 有助于将浮点类型以静默方式包装为无符号整数类型： &lt;code&gt;(0.0 &amp;lt;= (y = std::fmod( &lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0 )) ? y : 65536.0 + y)&lt;/code&gt; 的范围是 &lt;code&gt;[-0.0 .. 65535.0]&lt;/code&gt; ，它对应于 &lt;code&gt;unsigned short&lt;/code&gt; ，但是 &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;(&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;(x), 65536.0&lt;/code&gt; 的范围是 &lt;code&gt;[-32767.0, +32768.0]&lt;/code&gt; ，该值超出有 &lt;code&gt;signed short&lt;/code&gt; 的范围。</target>
        </trans-unit>
        <trans-unit id="cbfadbd0a7ccd1e3ec0ee00d99bda6db1cc5ccdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::forward_list&lt;/code&gt; is a container that supports fast insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is implemented as a singly-linked list and essentially does not have any overhead compared to its implementation in C. Compared to &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; this container provides more space efficient storage when bidirectional iteration is not needed.</source>
          <target state="translated">&lt;code&gt;std::forward_list&lt;/code&gt; 是一个容器，它支持从容器中的任何位置快速插入和删除元素。不支持快速随机访问。它以单链列表的形式实现，与其在C中的实现相比，基本上没有任何开销。与 &lt;code&gt;&lt;a href=&quot;list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; 相比，此容器在不需要双向迭代时提供了更节省空间的存储。</target>
        </trans-unit>
        <trans-unit id="c2ebf9e9e435ee3056ad9fc9787f7844dacc9bd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::forward_list&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; (except for the &lt;code&gt;size&lt;/code&gt; member function and that &lt;code&gt;operator==&lt;/code&gt;'s complexity is always linear), &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::forward_list&lt;/code&gt; 满足&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;的要求（ &lt;code&gt;size&lt;/code&gt; 成员函数除外，并且 &lt;code&gt;operator==&lt;/code&gt; 的复杂度始终是线性的），&lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;和&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7837beae5eb8318478a03816d5fe69264da35bd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::front_insert_iterator&lt;/code&gt; is an &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that prepends elements to a container for which it was constructed. The container's &lt;code&gt;push_front()&lt;/code&gt; member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::front_insert_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::front_insert_iterator&lt;/code&gt; 是一个&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;，可将元素添加到为其构造容器的容器中。每当分配迭代器（无论是否取消引用）时，都会调用容器的 &lt;code&gt;push_front()&lt;/code&gt; 成员函数。增加 &lt;code&gt;std::front_insert_iterator&lt;/code&gt; 是无操作的。</target>
        </trans-unit>
        <trans-unit id="a292140cf981fe03ff447787efd5c8db75cd6be5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt; results in &lt;code&gt;&lt;a href=&quot;bad_function_call&quot;&gt;std::bad_function_call&lt;/a&gt;&lt;/code&gt; exception being thrown.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; 导致引发 &lt;code&gt;&lt;a href=&quot;bad_function_call&quot;&gt;std::bad_function_call&lt;/a&gt;&lt;/code&gt; 异常。</target>
        </trans-unit>
        <trans-unit id="a3ae0891ae968af55946d0eb13471e46bd7151c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;和&lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;的要求。</target>
        </trans-unit>
        <trans-unit id="2c5b3f73ed92b9406389fdf0d10ca68e16404c14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt; to compare</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; 进行比较</target>
        </trans-unit>
        <trans-unit id="a327e115acfa4ae14e0d19493fc8762f3f4abead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt;'s allocator support was poorly specified and inconsistently implemented. Some implementations do not provide overloads (6-10) at all, some provide the overloads but ignore the supplied allocator argument, and some provide the overloads and use the supplied allocator for construction but not when the &lt;code&gt;std::function&lt;/code&gt; is reassigned. As a result, allocator support was removed in C++17.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; 的分配器支持指定不正确且实现不一致。一些实现根本不提供重载（6-10），一些实现提供重载但忽略提供的分配器参数，一些实现提供重载并使用提供的分配器进行构造，但在重新分配 &lt;code&gt;std::function&lt;/code&gt; 时不提供。结果，在C ++ 17中删除了分配器支持。</target>
        </trans-unit>
        <trans-unit id="712d2dee9547b4620e4b013fe8a329852f4ba582" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::function&lt;/code&gt;'s allocator support was poorly specified and inconsistently implemented. Some implementations do not support uses-allocator construction at all, some provide the needed constructor overloads but ignore the supplied allocator argument, and some provide the overloads and use the supplied allocator for construction but not when the &lt;code&gt;std::function&lt;/code&gt; is reassigned. As a result, allocator support was removed in C++17.</source>
          <target state="translated">&lt;code&gt;std::function&lt;/code&gt; 的分配器支持指定不正确且实现不一致。一些实现根本不支持uses-allocator构造，一些实现提供所需的构造函数重载，但忽略提供的allocator参数，一些实现提供重载并使用提供的分配器进行构造，但不重新分配 &lt;code&gt;std::function&lt;/code&gt; 。结果，在C ++ 17中删除了分配器支持。</target>
        </trans-unit>
        <trans-unit id="ef1a78cf97a17ae6134be85fe81b8bc55f188b06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gamma_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::gamma_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="480cc0303c36c42d3e2b99061ea26d10538b0a7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::geometric_distribution&amp;lt;&amp;gt;(p)&lt;/code&gt; is exactly equivalent to &lt;code&gt;&lt;a href=&quot;negative_binomial_distribution&quot;&gt;std::negative_binomial_distribution&lt;/a&gt;&amp;lt;&amp;gt;(1, p)&lt;/code&gt;. It is also the discrete counterpart of &lt;code&gt;&lt;a href=&quot;exponential_distribution&quot;&gt;std::exponential_distribution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::geometric_distribution&amp;lt;&amp;gt;(p)&lt;/code&gt; 与 &lt;code&gt;&lt;a href=&quot;negative_binomial_distribution&quot;&gt;std::negative_binomial_distribution&lt;/a&gt;&amp;lt;&amp;gt;(1, p)&lt;/code&gt; 完全等效。它也是 &lt;code&gt;&lt;a href=&quot;exponential_distribution&quot;&gt;std::exponential_distribution&lt;/a&gt;&lt;/code&gt; 的离散副本。</target>
        </trans-unit>
        <trans-unit id="a875eff720096f08c747f9f90b5860be91e34e17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::geometric_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::geometric_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9c0402cd35d0eb2692fe862c055f0797c10f2179" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gslice&lt;/code&gt; is the selector class that identifies a subset of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; indices defined by a multi-level set of strides and sizes. Objects of type &lt;code&gt;std::gslice&lt;/code&gt; can be used as indices with valarray's &lt;code&gt;operator[]&lt;/code&gt; to select, for example, columns of a multidimensional array represented as a &lt;code&gt;valarray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::gslice&lt;/code&gt; 是选择器类，用于标识由多级步幅和大小集定义的 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 索引的子集。 &lt;code&gt;std::gslice&lt;/code&gt; 类型的对象可以与valarray的 &lt;code&gt;operator[]&lt;/code&gt; 一起用作索引，以选择表示为 &lt;code&gt;valarray&lt;/code&gt; 的多维数组的列。</target>
        </trans-unit>
        <trans-unit id="52dbd11ae18bfb43cb00666d6f58bf0da1cc38ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gslice_array&lt;/code&gt; is a helper template used by &lt;code&gt;&lt;a href=&quot;gslice&quot;&gt;std::gslice&lt;/a&gt;&lt;/code&gt; subscript operator. It has reference semantics to a subset of the array specified by the &lt;code&gt;std::gslice&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;std::gslice_array&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;gslice&quot;&gt;std::gslice&lt;/a&gt;&lt;/code&gt; 下标运算符使用的辅助模板。它具有对 &lt;code&gt;std::gslice&lt;/code&gt; 对象指定的数组子集的引用语义。</target>
        </trans-unit>
        <trans-unit id="a9633ecc1dd7b10e73c946202a0686610bf5c770" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::gslice_array&lt;/code&gt; is a helper template used by &lt;code&gt;std::indirect_array&lt;/code&gt; subscript operator. It has reference semantics to a subset of the array specified by an indirect array (&lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;&lt;/code&gt; object).</source>
          <target state="translated">&lt;code&gt;std::gslice_array&lt;/code&gt; 是 &lt;code&gt;std::indirect_array&lt;/code&gt; 下标运算符使用的帮助模板。它具有对由间接数组（ &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;&lt;/code&gt; 对象）指定的数组子集的引用语义。</target>
        </trans-unit>
        <trans-unit id="95b85e3781209d98618a09001f316b61cd5843df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::hypot(x, y)&lt;/code&gt; is equivalent to &lt;code&gt;std::abs(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::hypot(x, y)&lt;/code&gt; 等同于 &lt;code&gt;std::abs(&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;(x,y))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f0ea701b80954df580c165eadacf5776c180e46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::identity&lt;/code&gt; is a function object type whose &lt;code&gt;operator()&lt;/code&gt; returns its argument unchanged.</source>
          <target state="translated">&lt;code&gt;std::identity&lt;/code&gt; 是一种函数对象类型，其 &lt;code&gt;operator()&lt;/code&gt; 不变地返回其参数。</target>
        </trans-unit>
        <trans-unit id="1c22e521fdbeb5e6776597727367efcea87a9141" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::identity&lt;/code&gt; is the identity function object: it returns its argument unchanged.</source>
          <target state="translated">&lt;code&gt;std::identity&lt;/code&gt; 是身份函数对象：它不变地返回其参数。</target>
        </trans-unit>
        <trans-unit id="0385a1ac553e11d96d8d78b097dd0c676c86b86f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::in_place&lt;/code&gt;, &lt;code&gt;std::in_place_type&lt;/code&gt;, and &lt;code&gt;std::in_place_index&lt;/code&gt; are disambiguation tags that can be passed to the constructors of &lt;code&gt;&lt;a href=&quot;optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;any&quot;&gt;std::any&lt;/a&gt;&lt;/code&gt; to indicate that the contained object should be constructed in-place, and (for the latter two) the type of the object to be constructed.</source>
          <target state="translated">&lt;code&gt;std::in_place&lt;/code&gt; ， &lt;code&gt;std::in_place_type&lt;/code&gt; 和 &lt;code&gt;std::in_place_index&lt;/code&gt; 是消除歧义的标记，可以传递给 &lt;code&gt;&lt;a href=&quot;optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;any&quot;&gt;std::any&lt;/a&gt;&lt;/code&gt; 的构造函数，以指示应构造包含的对象就地，以及（对于后两个而言）要构造的对象的类型。</target>
        </trans-unit>
        <trans-unit id="0168b9b751bd08c3bd1414db013cd45caa3e814d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::incrementable_traits&amp;lt;Iter&amp;gt;::difference_type&lt;/code&gt; if valid, otherwise &lt;code&gt;void&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::incrementable_traits&amp;lt;Iter&amp;gt;::difference_type&lt;/code&gt; 如果有效，否则为 &lt;code&gt;void&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d26bc5cdd9718de74b05d5b78f85e86c1265c0b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::insert_iterator&lt;/code&gt; is a &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that inserts elements into a container for which it was constructed, at the position pointed to by the supplied iterator. The container's &lt;code&gt;insert()&lt;/code&gt; member function is called whenever the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::insert_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::insert_iterator&lt;/code&gt; 是一个&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;，它在所提供的迭代器指向的位置处，将元素插入为其构造容器的容器。每当分配迭代器（无论是否取消引用）时，都会调用容器的 &lt;code&gt;insert()&lt;/code&gt; 成员函数。增加 &lt;code&gt;std::insert_iterator&lt;/code&gt; 是一项禁止操作。</target>
        </trans-unit>
        <trans-unit id="4ed0c5bbe217d673ceb1003957bd5b7d91123fdb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::int&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::int&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e4313d5011c53e518c756a2252c4df9a362a403" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::int_fast&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::int_fast&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="056289e3e32a5cd8ae69529fe2789e844000ec9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::int_least&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::int_least&lt;/code&gt;&lt;b&gt;x&lt;/b&gt;&lt;code&gt;_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5374c575ed2e778888b40082dccbedb38c0e168" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::integral_constant&amp;lt;std::size_t, N&amp;gt;&lt;/code&gt; for some &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::integral_constant&amp;lt;std::size_t, N&amp;gt;&lt;/code&gt; 对于一些 &lt;code&gt;N&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80ce62b2f6c64e9cc1a197075ce8d58710a0e3f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::integral_constant&lt;/code&gt; wraps a static constant of specified type. It is the base class for the C++ type traits.</source>
          <target state="translated">&lt;code&gt;std::integral_constant&lt;/code&gt; 包装指定类型的静态常量。它是C ++类型特征的基类。</target>
        </trans-unit>
        <trans-unit id="6a4b13ca29e2535668fcc8630678687f8e5f495a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ios_base::failure&lt;/code&gt; may be defined either as a member class of &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; or as a synonym (typedef) for another class with equivalent functionality.(since C++17).</source>
          <target state="translated">&lt;code&gt;std::ios_base::failure&lt;/code&gt; 可以定义为 &lt;code&gt;&lt;a href=&quot;../ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; 的成员类，也可以定义为具有等效功能的另一个类的同义词（typedef）（自C ++ 17开始）。</target>
        </trans-unit>
        <trans-unit id="c35cebda19804ec67065696fcf947069ced92a75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_aggregate&lt;/code&gt; type trait</source>
          <target state="translated">&lt;code&gt;std::is_aggregate&lt;/code&gt; 类型特征</target>
        </trans-unit>
        <trans-unit id="17c43791619df5add71d65dae6f070413cd24fb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_base_of&amp;lt;A, B&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; even if &lt;code&gt;A&lt;/code&gt; is a private, protected, or ambiguous base class of &lt;code&gt;B&lt;/code&gt;. In many situations, &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;B*, A*&amp;gt;&lt;/code&gt; is the more appropriate test.</source>
          <target state="translated">&lt;code&gt;std::is_base_of&amp;lt;A, B&amp;gt;::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 即使 &lt;code&gt;A&lt;/code&gt; 是私有的，受保护的，或不明确的基类的 &lt;code&gt;B&lt;/code&gt; 。在许多情况下， &lt;code&gt;&lt;a href=&quot;is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;B*, A*&amp;gt;&lt;/code&gt; 是更合适的测试。</target>
        </trans-unit>
        <trans-unit id="fc232ada3163773b55f91cfd4ebcdc316148abd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_default_constructible&amp;lt;T&amp;gt;&lt;/code&gt; does not test that &lt;code&gt;T x;&lt;/code&gt; would compile; it attempts &lt;a href=&quot;../language/direct_initialization&quot;&gt;direct-initialization&lt;/a&gt; with an empty argument list (see &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&lt;/code&gt;). Thus, &lt;code&gt;std::is_default_constructible_v&amp;lt;const int&amp;gt;&lt;/code&gt; and &lt;code&gt;std::is_default_constructible_v&amp;lt;const int[10]&amp;gt;&lt;/code&gt; are &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::is_default_constructible&amp;lt;T&amp;gt;&lt;/code&gt; 不测试 &lt;code&gt;T x;&lt;/code&gt; 会编译；它尝试使用空的参数列表进行&lt;a href=&quot;../language/direct_initialization&quot;&gt;直接初始化&lt;/a&gt;（请参阅 &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&lt;/code&gt; ）。因此， &lt;code&gt;std::is_default_constructible_v&amp;lt;const int&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::is_default_constructible_v&amp;lt;const int[10]&amp;gt;&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4a7e3513494283e7e309e272990310bfd22e4c1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_empty&amp;lt;T&amp;gt;&lt;/code&gt; and all other type traits are empty classes.</source>
          <target state="translated">&lt;code&gt;std::is_empty&amp;lt;T&amp;gt;&lt;/code&gt; 和所有其他类型特征都是空类。</target>
        </trans-unit>
        <trans-unit id="cd321ebf2f2858e8889f2a97ec260a2a043e7c22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_invocable&lt;/code&gt;, &lt;code&gt;std::invoke_result&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::is_invocable&lt;/code&gt; ， &lt;code&gt;std::invoke_result&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f22e915926826ff5411e65d836e38f3853fb4bee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::is_sorted&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_sorted_until&quot;&gt;std::is_sorted_until&lt;/a&gt;&lt;/code&gt; both return true for empty ranges and ranges of length one.</source>
          <target state="translated">&lt;code&gt;std::is_sorted&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;is_sorted_until&quot;&gt;std::is_sorted_until&lt;/a&gt;&lt;/code&gt; 对于空范围和长度为一的范围均返回true。</target>
        </trans-unit>
        <trans-unit id="76d5f0212c195e3069a6f21f54bdf8d5d6793a50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::isspace(c,is.getloc())&lt;/code&gt; is true for the next character &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;is&lt;/code&gt; (this whitespace character remains in the input stream).</source>
          <target state="translated">&lt;code&gt;std::isspace(c,is.getloc())&lt;/code&gt; 是用于下一个字符真实 &lt;code&gt;c&lt;/code&gt; 在 &lt;code&gt;is&lt;/code&gt; （此空白字符遗体输入流中）。</target>
        </trans-unit>
        <trans-unit id="accacfbe11581a503dba5062106078b5b1e65e10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::istream_iterator&lt;/code&gt; is a single-pass input iterator that reads successive objects of type &lt;code&gt;T&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; object for which it was constructed, by calling the appropriate &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;. The actual read operation is performed when the iterator is incremented, not when it is dereferenced. The first object is read when the iterator is constructed. Dereferencing only returns a copy of the most recently read object.</source>
          <target state="translated">&lt;code&gt;std::istream_iterator&lt;/code&gt; 是单次通过输入迭代器，可通过调用适当的 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 从构造它的 &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 对象中读取类型 &lt;code&gt;T&lt;/code&gt; 的连续对象。实际的读取操作在迭代器增加时执行，而不是在取消引用时执行。构造迭代器时，将读取第一个对象。取消引用仅返回最近读取的对象的副本。</target>
        </trans-unit>
        <trans-unit id="9cbfd53846c23724a1c027d6e2f38dde642ad5df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; has a trivial copy constructor, a constexpr default constructor, and a trivial destructor.</source>
          <target state="translated">&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; 具有一个平凡的副本构造函数，一个constexpr默认构造函数和一个平凡的析构函数。</target>
        </trans-unit>
        <trans-unit id="69bcfd3a6166f9c6c392b5e7165bc3ea05cee29d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; is a single-pass input iterator that reads successive characters from the &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; object for which it was constructed.</source>
          <target state="translated">&lt;code&gt;std::istreambuf_iterator&lt;/code&gt; 是单次通过输入迭代器，可从为其构造对象的 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 对象读取连续字符。</target>
        </trans-unit>
        <trans-unit id="9aa098edcf5248bd33724b3a40884863ecff491f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iswdigit&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt; are the only standard wide character classification functions that are not affected by the currently installed C locale.</source>
          <target state="translated">&lt;code&gt;std::iswdigit&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt; 是唯一不受当前安装的C语言环境影响的标准宽字符分类功能。</target>
        </trans-unit>
        <trans-unit id="7cfa97d219e1324e07edaccefe8988d5dccc17b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator&lt;/code&gt; is the base class provided to simplify definitions of the required types for iterators.</source>
          <target state="translated">&lt;code&gt;std::iterator&lt;/code&gt; 是提供的基类，用于简化迭代器所需类型的定义。</target>
        </trans-unit>
        <trans-unit id="b7042ea0b4cf46ee11c1e2aad8beb6aaeece852a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type*&lt;/code&gt; and &lt;code&gt;std::sub_match&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type*&lt;/code&gt; 和 &lt;code&gt;std::sub_match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b55313b2cef60e74e0c2c5ed04471f86f95bff4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type&lt;/code&gt; and &lt;code&gt;std::sub_match&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type&lt;/code&gt; 和 &lt;code&gt;std::sub_match&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73e0d90f769db9ddd2bc286113fc7c3922356c42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::iterator_traits&lt;/code&gt; is the type trait class that provides uniform interface to the properties of &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; types. This makes it possible to implement algorithms only in terms of iterators.</source>
          <target state="translated">&lt;code&gt;std::iterator_traits&lt;/code&gt; 是类型特征类，它为&lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt;类型的属性提供统一的接口。这使得仅在迭代器方面实现算法成为可能。</target>
        </trans-unit>
        <trans-unit id="62067c7c19b742e9f2f87539809741fc87924de4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::launder&lt;/code&gt; has no effect on its argument. Its return value must be used to access the object. Thus, it's always an error to discard the return value.</source>
          <target state="translated">&lt;code&gt;std::launder&lt;/code&gt; 对其参数无效。它的返回值必须用于访问对象。因此，丢弃返回值始终是错误的。</target>
        </trans-unit>
        <trans-unit id="a6fd8f68c4429333d078e5364ffa87742fef95c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::launder&lt;/code&gt; may be used in a &lt;a href=&quot;../language/constant_expression&quot;&gt;core constant expression&lt;/a&gt; if the value of its argument may be used in a core constant expression.</source>
          <target state="translated">&lt;code&gt;std::launder&lt;/code&gt; 可被用在&lt;a href=&quot;../language/constant_expression&quot;&gt;芯常量表达式&lt;/a&gt;如果可以在芯常数表达式中使用其参数的值。</target>
        </trans-unit>
        <trans-unit id="fc0400f4a420bf2d62df57d158e61abc76eca486" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; allocates nodes of some internal type &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;, using the allocator &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::rebind_alloc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;, which is implemented in terms of &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt; if A is an &lt;code&gt;std::allocator&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; 使用分配器 &lt;code&gt;&lt;a href=&quot;allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::rebind_alloc&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; &amp;lt;A&amp;gt; :: rebind_alloc &amp;lt;Node &amp;lt;T &amp;gt;&amp;gt;分配某种内部类型 &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; 节点，该实现是根据 &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt; 如果A是 &lt;code&gt;std::allocator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66722744970a911306b103b6b3a4bb83fa74da8e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; allocates nodes of some internal type &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt;, using the allocator &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::list&amp;lt;T, A&amp;gt;&lt;/code&gt; 使用分配器 &lt;code&gt;A::rebind&amp;lt;Node&amp;lt;T&amp;gt;&amp;gt;::other&lt;/code&gt; 分配某种内部类型 &lt;code&gt;Node&amp;lt;T&amp;gt;&lt;/code&gt; 节点</target>
        </trans-unit>
        <trans-unit id="c15f65983fc9b680377c222e85dac10cf4ab4144" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&lt;/code&gt; is a container that supports constant time insertion and removal of elements from anywhere in the container. Fast random access is not supported. It is usually implemented as a doubly-linked list. Compared to &lt;code&gt;&lt;a href=&quot;forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; this container provides bidirectional iteration capability while being less space efficient.</source>
          <target state="translated">&lt;code&gt;std::list&lt;/code&gt; 是一个容器，支持从容器中的任何位置恒定时间插入和删除元素。不支持快速随机访问。通常将其实现为双向链接列表。与 &lt;code&gt;&lt;a href=&quot;forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; 相比，此容器提供了双向迭代功能，但空间效率较低。</target>
        </trans-unit>
        <trans-unit id="0b4e21027fec7854716699e00372b2255194f58b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::list&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::list&lt;/code&gt; 满足&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;，&lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;，&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;和&lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer的要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="39480e048d13612808ce9e8bdf46a4d2d1efff1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::locale::facet&lt;/code&gt; is the base class for facets. It provides a common base class so that locales could store pointers to the facets they implement in a single indexed container, and it abstracts support for facet reference counting. Whenever a facet is added to a locale, the locale increments the reference count in the facet (through an implementation-specific mechanism). Whenever a locale is destructed or modified, it decrements the reference count in each facet it no longer implements. Whenever a facet's reference count becomes zero, the locale performs &lt;code&gt;delete static_cast&amp;lt;std::locale::facet*&amp;gt;(f)&lt;/code&gt; where &lt;code&gt;f&lt;/code&gt; is the pointer to the facet.</source>
          <target state="translated">&lt;code&gt;std::locale::facet&lt;/code&gt; 是构面的基类。它提供了一个通用的基类，以便语言环境可以将指向它们实现的方面的指针存储在单个索引容器中，并且它抽象了对方面引用计数的支持。每当将构面添加到语言环境时，该语言环境都会（通过实现特定的机制）增加构面中的引用计数。每当销毁或修改语言环境时，它都会减少不再实现的每个方面中的引用计数。每当构面的引用计数变为零时，语言环境都会执行 &lt;code&gt;delete static_cast&amp;lt;std::locale::facet*&amp;gt;(f)&lt;/code&gt; ，其中 &lt;code&gt;f&lt;/code&gt; 是指向构面的指针。</target>
        </trans-unit>
        <trans-unit id="25f4c47baf2c706d9502a2677329ad5ff357de25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::localeconv&lt;/code&gt; modifies a static object, calling it from different threads without synchronization is undefined behavior.</source>
          <target state="translated">&lt;code&gt;std::localeconv&lt;/code&gt; 修改静态对象，从不同线程中调用它而不进行同步是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="17fcade94977b46d0779598ca948f02a54971ac1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::lognormal_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::lognormal_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution的&lt;/a&gt;所有要求。</target>
        </trans-unit>
        <trans-unit id="36ea267312e8c2f25e5b22940ec75bd0844adcad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::make_shared&lt;/code&gt; uses &lt;code&gt;::new&lt;/code&gt;, so if any special behavior has been set up using a class-specific &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt;, it will differ from &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::make_shared&lt;/code&gt; 使用 &lt;code&gt;::new&lt;/code&gt; ，因此，如果使用特定于类的&lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;设置了任何特殊行为，它将不同于 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b24879d26d53111bc2ca5c76cc8a905a3eaaf320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::map::value_compare&lt;/code&gt; is a function object that compares objects of type &lt;code&gt;std::map::value_type&lt;/code&gt; (key-value pairs) by comparing of the first components of the pairs.</source>
          <target state="translated">&lt;code&gt;std::map::value_compare&lt;/code&gt; 是一个功能对象，它通过比较对象对中 &lt;code&gt;std::map::value_type&lt;/code&gt; （键-值对）类型的对象来对其进行比较。</target>
        </trans-unit>
        <trans-unit id="69b03e94f70798f70251e093522baf56a3c25fde" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::map&lt;/code&gt; is a sorted associative container that contains key-value pairs with unique keys. Keys are sorted by using the comparison function &lt;code&gt;Compare&lt;/code&gt;. Search, removal, and insertion operations have logarithmic complexity. Maps are usually implemented as &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;red-black trees&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::map&lt;/code&gt; 是一个排序的关联容器，其中包含具有唯一键的键值对。键使用比较功能 &lt;code&gt;Compare&lt;/code&gt; 进行排序。搜索，删除和插入操作具有对数复杂性。地图通常以&lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;红黑树的&lt;/a&gt;形式实现。</target>
        </trans-unit>
        <trans-unit id="f9b8c058371534a10bf6f6f1cfb81ee79141b674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::map&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::map&lt;/code&gt; 满足&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;，&lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;，&lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt;和&lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer的要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="84be1b95a94a0df278624077a9bf062e43144c11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mask_array&lt;/code&gt; is a helper template used by the &lt;a href=&quot;operator_at&quot;&gt;valarray subscript operator&lt;/a&gt; with &lt;code&gt;std::valarray&amp;lt;bool&amp;gt;&lt;/code&gt; argument. It has reference semantics and provides access to the subset of the valarray consisting of the elements whose indices correspond to &lt;code&gt;true&lt;/code&gt; values in the &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; mask.</source>
          <target state="translated">&lt;code&gt;std::mask_array&lt;/code&gt; 是&lt;a href=&quot;operator_at&quot;&gt;valarray下标运算符&lt;/a&gt;与 &lt;code&gt;std::valarray&amp;lt;bool&amp;gt;&lt;/code&gt; 参数一起使用的辅助模板。它具有参考语义，并提供对valarray子集的访问，该子集由其索引对应于 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; &amp;lt;bool&amp;gt;掩码中的 &lt;code&gt;true&lt;/code&gt; 值的元素组成。</target>
        </trans-unit>
        <trans-unit id="f1ba44ed66d1e1555c21ea7a3d7af56fb9452ba4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::match_results&lt;/code&gt; meets the requirements of a &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; and of a &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;, except that only copy assignment, move assignment, and operations defined for a constant containers are supported, and that the semantics of comparison functions are different from those required for a container.</source>
          <target state="translated">&lt;code&gt;std::match_results&lt;/code&gt; 满足&lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;和&lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;的要求，除了仅支持为常量容器定义的副本分配，移动分配和操作，并且比较函数的语义与容器所需的语义不同。</target>
        </trans-unit>
        <trans-unit id="486be6c729cd8f9005df324c3f9cee7e87d5dd71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::max_align_t&lt;/code&gt; is a &lt;a href=&quot;../named_req/trivialtype&quot;&gt;trivial&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;standard-layout&lt;/a&gt; type whose &lt;a href=&quot;../language/objects#Alignment&quot;&gt;alignment requirement&lt;/a&gt; is at least as strict (as large) as that of every scalar type.</source>
          <target state="translated">&lt;code&gt;std::max_align_t&lt;/code&gt; 是&lt;a href=&quot;../named_req/trivialtype&quot;&gt;普通的&lt;/a&gt;&lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;标准布局&lt;/a&gt;类型，其&lt;a href=&quot;../language/objects#Alignment&quot;&gt;对齐要求&lt;/a&gt;至少与每种标量类型的对齐要求一样严格（一样大）。</target>
        </trans-unit>
        <trans-unit id="de74cc16225bf11bc2936dc0ea5016c64a73d87a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::max_align_t&lt;/code&gt; is usually synonymous with the largest scalar type, which is &lt;code&gt;long double&lt;/code&gt; on most platforms, and its alignment requirement is either 8 or 16.</source>
          <target state="translated">&lt;code&gt;std::max_align_t&lt;/code&gt; 通常是最大标量类型的同义词，在大多数平台上，它是 &lt;code&gt;long double&lt;/code&gt; ，其对齐要求是8或16。</target>
        </trans-unit>
        <trans-unit id="250616309b32d57f9c4f54607c0d6adeac132d82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mem_fn&lt;/code&gt; returns a call wrapper of unspecified type that has the following members:</source>
          <target state="translated">&lt;code&gt;std::mem_fn&lt;/code&gt; 返回具有以下成员的未指定类型的调用包装：</target>
        </trans-unit>
        <trans-unit id="019539277e675b31ee3787a2ae6f6741a1f927c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::memcpy&lt;/code&gt; is meant to be the fastest library routine for memory-to-memory copy. It is usually more efficient than &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt;, which must scan the data it copies or &lt;code&gt;&lt;a href=&quot;memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;, which must take precautions to handle overlapping inputs.</source>
          <target state="translated">&lt;code&gt;std::memcpy&lt;/code&gt; 旨在成为内存到内存复制的最快库例程。它通常比 &lt;code&gt;&lt;a href=&quot;strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt; 效率更高，后者必须扫描其复制的数据或 &lt;code&gt;&lt;a href=&quot;memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ，后者必须采取预防措施来处理重叠的输入。</target>
        </trans-unit>
        <trans-unit id="2118ff9fcca45263d25b203070d19f43992cc2ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::memory_order&lt;/code&gt; specifies how memory accesses, including regular, non-atomic memory accesses, are to be ordered around an atomic operation. Absent any constraints on a multi-core system, when multiple threads simultaneously read and write to several variables, one thread can observe the values change in an order different from the order another thread wrote them. Indeed, the apparent order of changes can even differ among multiple reader threads. Some similar effects can occur even on uniprocessor systems due to compiler transformations allowed by the memory model.</source>
          <target state="translated">&lt;code&gt;std::memory_order&lt;/code&gt; 指定在原子操作周围如何对存储器访问（包括常规的非原子存储器访问）进行排序。在多核系统上没有任何约束时，当多个线程同时读取和写入几个变量时，一个线程可以观察到值的变化顺序与另一个线程写入它们的顺序不同。实际上，在多个读取器线程之间，变化的表象顺序甚至可以不同。由于内存模型允许的编译器转换，即使在单处理器系统上也可能发生一些类似的影响。</target>
        </trans-unit>
        <trans-unit id="3a7564b150268b029471f79e561f7972a4703c6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::memset&lt;/code&gt; may be optimized away (under the &lt;a href=&quot;../../language/as_if&quot;&gt;as-if&lt;/a&gt; rules) if the object modified by this function is not accessed again for the rest of its lifetime (e.g. &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537&quot;&gt;gcc bug 8537&lt;/a&gt;). For that reason, this function cannot be used to scrub memory (e.g. to fill an array that stored a password with zeroes). Solutions for that include &lt;a href=&quot;../../algorithm/fill&quot;&gt;&lt;code&gt;std::fill&lt;/code&gt;&lt;/a&gt; with volatile pointers, C11 &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/memset.html&quot;&gt;&lt;code&gt;memset_s&lt;/code&gt;&lt;/a&gt;, FreeBSD &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero&quot;&gt;explicit_bzero&lt;/a&gt; or Microsoft &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366877.aspx&quot;&gt;SecureZeroMemory&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::memset&lt;/code&gt; 可被优化掉（在&lt;a href=&quot;../../language/as_if&quot;&gt;AS-如果&lt;/a&gt;规则）如果由该函数修改的对象不是为它的寿命的剩余部分再次访问（例如&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=8537&quot;&gt;GCC错误8537&lt;/a&gt;）。因此，该功能不能用于清理内存（例如，填充存储密码为零的数组）。该解决方案包括&lt;a href=&quot;../../algorithm/fill&quot;&gt; &lt;code&gt;std::fill&lt;/code&gt; &lt;/a&gt;有挥发性的指针，C11 &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/memset.html&quot;&gt; &lt;code&gt;memset_s&lt;/code&gt; &lt;/a&gt;，FreeBSD的&lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=explicit_bzero&quot;&gt;explicit_bzero&lt;/a&gt;或Microsoft &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa366877.aspx&quot;&gt;SecureZeroMemory&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="37d85ef2212e37f34c3209150c0bbbf80edfa8c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::messages_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;messages&quot;&gt;std::messages&lt;/a&gt;&lt;/code&gt; facet which encapsulates retrieval of strings from message catalogs of the locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::messages_byname&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;messages&quot;&gt;std::messages&lt;/a&gt;&lt;/code&gt; 构面，它封装了从构造时指定的语言环境的消息目录中检索字符串。</target>
        </trans-unit>
        <trans-unit id="33c8225db603dfa739b0e05e20477d0f83922789" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::moneypunct_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; facet which encapsulates monetary formatting preferences of a locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::moneypunct_byname&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&lt;/code&gt; 构面，它封装了在其构造时指定的语言环境的货币格式首选项。</target>
        </trans-unit>
        <trans-unit id="efbca6737e4ba6c8e9dd65c08620ae6de6752df0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move(x)&lt;/code&gt; or &lt;code&gt;x&lt;/code&gt;, depending on exception guarantees.</source>
          <target state="translated">&lt;code&gt;std::move(x)&lt;/code&gt; 或 &lt;code&gt;x&lt;/code&gt; ，取决于异常保证。</target>
        </trans-unit>
        <trans-unit id="7de0377c2783e738adfca256a11f333e74b0abef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move&lt;/code&gt; is used to</source>
          <target state="translated">&lt;code&gt;std::move&lt;/code&gt; 用于</target>
        </trans-unit>
        <trans-unit id="57df1e08f7a50f846a44df6e8661f68fa099d33f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::move_iterator&lt;/code&gt; is an iterator adaptor which behaves exactly like the underlying iterator (which must be at least an &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;), except that dereferencing converts the value returned by the underlying iterator into an rvalue. If this iterator is used as an input iterator, the effect is that the values are moved from, rather than copied from.</source>
          <target state="translated">&lt;code&gt;std::move_iterator&lt;/code&gt; 是一个迭代器适配器，其行为与基础迭代器（必须至少为&lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;）完全相同，不同之处在于，取消引用会将基础迭代器返回的值转换为右值。如果将此迭代器用作输入迭代器，则结果是从中移出值，而不是从中复制值。</target>
        </trans-unit>
        <trans-unit id="b9911341852a0dfa39ac8efe01699ab44e9ef543" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multimap::value_compare&lt;/code&gt; is a function object that compares objects of type &lt;code&gt;std::multimap::value_type&lt;/code&gt; (key-value pairs) by comparing of the first components of the pairs.</source>
          <target state="translated">&lt;code&gt;std::multimap::value_compare&lt;/code&gt; 是一个功能对象，通过比较两个 &lt;code&gt;std::multimap::value_type&lt;/code&gt; （键-值对）中的第一个组成部分来比较它们。</target>
        </trans-unit>
        <trans-unit id="96ab8f5decbb67bb55ce6193967b8c257928ef8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multimap&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::multimap&lt;/code&gt; 满足&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;，&lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;，&lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt;和&lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer的要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f752bf59adb24e8616e43fbea77f42838db6858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multiset&lt;/code&gt; is an associative container that contains a sorted set of objects of type Key. Unlike set, multiple keys with equivalent values are allowed. Sorting is done using the key comparison function Compare. Search, insertion, and removal operations have logarithmic complexity.</source>
          <target state="translated">&lt;code&gt;std::multiset&lt;/code&gt; 是一个关联容器，其中包含Key类型的一组排序对象。与set不同，允许具有相等值的多个键。使用键比较功能&amp;ldquo;比较&amp;rdquo;完成排序。搜索，插入和删除操作具有对数复杂性。</target>
        </trans-unit>
        <trans-unit id="086e94514b0cdda6b7633c56cf601a40382a11cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::multiset&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::multiset&lt;/code&gt; 满足&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;，&lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;，&lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt;和&lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer的要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e96493daf69bb9a9ead26df58b81f61e6c62e6ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mutex&lt;/code&gt; is neither copyable nor movable.</source>
          <target state="translated">&lt;code&gt;std::mutex&lt;/code&gt; 既不可复制也不可移动。</target>
        </trans-unit>
        <trans-unit id="05b0d7c6eb2399ec5b7b4c3e31db6b51b12be1c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::mutex&lt;/code&gt; is usually not accessed directly: &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;,  or &lt;code&gt;std::scoped_lock&lt;/code&gt;(since C++17) manage locking in a more exception-safe manner.</source>
          <target state="translated">&lt;code&gt;std::mutex&lt;/code&gt; 通常不直接访问std :: mutex： &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;std::scoped_lock&lt;/code&gt; （自C ++ 17起）以更加异常安全的方式管理锁定。</target>
        </trans-unit>
        <trans-unit id="cc0d7eecfb40eeab627189c04ee7371985b6d0d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::negative_binomial_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::negative_binomial_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="356015a256f665f8a44e6d1e549d4cef107b40ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nested_exception&lt;/code&gt; is a polymorphic mixin class which can capture and store the current exception, making it possible to nest exceptions of arbitrary types within each other.</source>
          <target state="translated">&lt;code&gt;std::nested_exception&lt;/code&gt; 是一个多态混合类，可以捕获和存储当前异常，从而可以将任意类型的异常相互嵌套。</target>
        </trans-unit>
        <trans-unit id="9714f66f30044372b37d250de64fe0d3c1071a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::new_handler&lt;/code&gt; is the function pointer type (pointer to function that takes no arguments and returns void), which is used by the functions &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::new_handler&lt;/code&gt; 是函数指针类型（不带任何参数并返回void的函数指针），由函数 &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a851774dbb169de3b43d1480564d86976d5d760a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::normal_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::normal_distribution&lt;/code&gt; 满足所有要求&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6bbdbd6056802e22d2dfcad3cce3c52c0a59507e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::not1&lt;/code&gt; returns an object of type &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;, constructed with &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::not1&lt;/code&gt; 返回类型为 &lt;code&gt;&lt;a href=&quot;unary_negate&quot;&gt;std::unary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; 的对象，该对象由 &lt;code&gt;pred&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="1e7ef35eea64883819b88f9a89de62f625607241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::not2&lt;/code&gt; returns an object of type &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt;, constructed with &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::not2&lt;/code&gt; 返回类型为 &lt;code&gt;&lt;a href=&quot;binary_negate&quot;&gt;std::binary_negate&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../concepts/predicate&quot;&gt;Predicate&lt;/a&gt;&amp;gt;&lt;/code&gt; 的对象，该对象由 &lt;code&gt;pred&lt;/code&gt; 构造。</target>
        </trans-unit>
        <trans-unit id="f70f4db2af2af44f2a7ba7b47013286ed6c35fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nothrow&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;&lt;/code&gt; used to disambiguate the overloads of throwing and non-throwing &lt;a href=&quot;operator_new&quot;&gt;allocation functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::nothrow&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;&lt;/code&gt; 类型的常数，用于消除抛出和非抛出&lt;a href=&quot;operator_new&quot;&gt;分配函数&lt;/a&gt;的重载。</target>
        </trans-unit>
        <trans-unit id="7cda3e5771a651d7ac8313fe2f3aa00ac56c2106" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nothrow_t&lt;/code&gt; is an empty class type used to disambiguate the overloads of throwing and non-throwing &lt;a href=&quot;operator_new&quot;&gt;allocation functions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::nothrow_t&lt;/code&gt; 是一个空类类型，用于消除抛出和非抛出&lt;a href=&quot;operator_new&quot;&gt;分配函数&lt;/a&gt;的重载。</target>
        </trans-unit>
        <trans-unit id="85ab32f61c86e1fe107572929e50efe8ee81c122" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullopt&lt;/code&gt; is a constant of type &lt;code&gt;&lt;a href=&quot;nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; that is used to indicate &lt;code&gt;optional&lt;/code&gt; type with uninitialized state.</source>
          <target state="translated">&lt;code&gt;std::nullopt&lt;/code&gt; 是类型为 &lt;code&gt;&lt;a href=&quot;nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; ，用于指示具有未初始化状态的 &lt;code&gt;optional&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="02049de6eda615290c2b319f76d165fe688eb7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullopt_t&lt;/code&gt; is an empty class type used to indicate &lt;code&gt;optional&lt;/code&gt; type with uninitialized state. In particular, &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; has a constructor with &lt;code&gt;nullopt_t&lt;/code&gt; as a single argument, which creates an optional that does not contain a value.</source>
          <target state="translated">&lt;code&gt;std::nullopt_t&lt;/code&gt; 是一个空类类型，用于指示具有未初始化状态的 &lt;code&gt;optional&lt;/code&gt; 类型。特别是， &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; 具有一个将 &lt;code&gt;nullopt_t&lt;/code&gt; 作为单个参数的构造函数，该构造函数创建了一个不包含值的可选构造函数。</target>
        </trans-unit>
        <trans-unit id="3f1013d2e1cbbed3314f41f8281dd0590dff1883" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullopt_t&lt;/code&gt; must be a non-aggregate &lt;a href=&quot;../../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt; and cannot have a default constructor or an initializer-list constructor.</source>
          <target state="translated">&lt;code&gt;std::nullopt_t&lt;/code&gt; 必须是非聚合&lt;a href=&quot;../../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;，并且不能具有默认构造函数或初始化列表构造函数。</target>
        </trans-unit>
        <trans-unit id="bfbb1c354a43470e1d88908e8209e04392aa55ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::nullptr_t&lt;/code&gt; is the type of the null pointer literal, &lt;a href=&quot;../language/nullptr&quot;&gt;&lt;code&gt;nullptr&lt;/code&gt;&lt;/a&gt;. It is a distinct type that is not itself a pointer type or a pointer to member type.</source>
          <target state="translated">&lt;code&gt;std::nullptr_t&lt;/code&gt; 是空指针文字&lt;a href=&quot;../language/nullptr&quot;&gt; &lt;code&gt;nullptr&lt;/code&gt; &lt;/a&gt;的类型。它是一个独特的类型，它本身不是指针类型或指向成员类型的指针。</target>
        </trans-unit>
        <trans-unit id="e2e770b2f25bf1be459bc0ab1b7aa9828614268d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::numpunct_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;numpunct&quot;&gt;std::numpunct&lt;/a&gt;&lt;/code&gt; facet which encapsulates numeric punctuation preferences of a locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::numpunct_byname&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;numpunct&quot;&gt;std::numpunct&lt;/a&gt;&lt;/code&gt; 构面，它封装了在其构造时指定的语言环境的数字标点符号首选项。</target>
        </trans-unit>
        <trans-unit id="c2f1976e55e2fa1e62abc4428973a4a9531f2f1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::once_flag&lt;/code&gt; is neither copyable nor movable.</source>
          <target state="translated">&lt;code&gt;std::once_flag&lt;/code&gt; 不可复制，也不能移动。</target>
        </trans-unit>
        <trans-unit id="dc46da909485bc2d93323c2c6ff124bedb3ce7fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ostream_iterator&lt;/code&gt; is a single-pass &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that writes successive objects of type &lt;code&gt;T&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; object for which it was constructed, using &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. Optional delimiter string is written to the output stream after every write operation. The write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::ostream_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::ostream_iterator&lt;/code&gt; 是单次使用的&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;，它使用 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 将类型 &lt;code&gt;T&lt;/code&gt; 的连续对象写入为其构造对象的 &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 对象。每次写操作后，可选的定界符字符串都将写入输出流。当分配迭代器（无论是否取消引用）时，将执行写操作。增加 &lt;code&gt;std::ostream_iterator&lt;/code&gt; 是无操作的。</target>
        </trans-unit>
        <trans-unit id="777e432c8143a3737cc1c5cb394e70c18a51c20c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; is a single-pass &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; that writes successive characters into the &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; object for which it was constructed. The actual write operation is performed when the iterator (whether dereferenced or not) is assigned to. Incrementing the &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; is a no-op.</source>
          <target state="translated">&lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; 是一次通过的&lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;，可将连续字符写入为其构造对象的 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 对象中。实际的写操作是在分配迭代器（无论是否取消引用）时执行的。增加 &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; 是无操作的。</target>
        </trans-unit>
        <trans-unit id="dc1abd29bb8831f4698cdb1094a6ca7e562e49e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pair&lt;/code&gt; is a struct template that provides a way to store two heterogeneous objects as a single unit. A pair is a specific case of a &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; with two elements.</source>
          <target state="translated">&lt;code&gt;std::pair&lt;/code&gt; 是一个结构模板，提供了一种将两个异构对象存储为单个单元的方法。一对是带有两个元素的 &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 的特殊情况。</target>
        </trans-unit>
        <trans-unit id="ea8dd13c2816204756416ea997c79ecf7f5dc04b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is equivalent to &lt;code&gt;b&lt;/code&gt; (&lt;code&gt;-0 &amp;lt;=&amp;gt; +0&lt;/code&gt; is equivalent)</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; 如果 &lt;code&gt;a&lt;/code&gt; 等于 &lt;code&gt;b&lt;/code&gt; （ &lt;code&gt;-0 &amp;lt;=&amp;gt; +0&lt;/code&gt; 等效），则std :: partial_ordering ::: equivalent</target>
        </trans-unit>
        <trans-unit id="371bc87e88fad51bc0750025291273ab879059d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::greater&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is greater than &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::greater&lt;/code&gt; 如果 &lt;code&gt;a&lt;/code&gt; 大于 &lt;code&gt;b&lt;/code&gt; ,则std :: partial_ordering ::更大</target>
        </trans-unit>
        <trans-unit id="c84a2e8316193f31e89963f9aecf5bee5195fb95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::less&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is less than &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::less&lt;/code&gt; 如果 &lt;code&gt;a&lt;/code&gt; 小于 &lt;code&gt;b&lt;/code&gt; ,则std :: partial_ordering :: less</target>
        </trans-unit>
        <trans-unit id="40941de7130d4d5cf67a40eab0dc365768ccaeff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::less&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equal&lt;/code&gt; or &lt;code&gt;equivalent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::less&lt;/code&gt; 如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;less&lt;/code&gt; ， &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; 如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;greater&lt;/code&gt; ， &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; 如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;equal&lt;/code&gt; 或 &lt;code&gt;equivalent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f755b7dc0cfdc44f45a2b4967b0e34b372b2c615" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::less&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt;, &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;greater&lt;/code&gt;, &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::less&lt;/code&gt; ，如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;less&lt;/code&gt; ， &lt;code&gt;std::partial_ordering::greater&lt;/code&gt; ，如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;greater&lt;/code&gt; ， &lt;code&gt;std::partial_ordering::equivalent&lt;/code&gt; 如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;equivalent&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29e17d41a2e0da1646d774fd033ea7297c0c1823" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering::unordered&lt;/code&gt; (&lt;code&gt;NaN &amp;lt;=&amp;gt; anything&lt;/code&gt; is unordered)</source>
          <target state="translated">&lt;code&gt;std::partial_ordering::unordered&lt;/code&gt; （ &lt;code&gt;NaN &amp;lt;=&amp;gt; anything&lt;/code&gt; 都是无序的）</target>
        </trans-unit>
        <trans-unit id="78e4fca92581bdc680ad0458a9583ac6d73d4986" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::partial_ordering&lt;/code&gt; is implicitly-convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, while both &lt;code&gt;std::strong_ordering&lt;/code&gt; and &lt;code&gt;std::weak_ordering&lt;/code&gt; are implicitly-convertible to &lt;code&gt;partial_ordering&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::partial_ordering&lt;/code&gt; 可以隐式转换为 &lt;code&gt;std::weak_equality&lt;/code&gt; ，而 &lt;code&gt;std::strong_ordering&lt;/code&gt; 和 &lt;code&gt;std::weak_ordering&lt;/code&gt; 都可以隐式转换为 &lt;code&gt;partial_ordering&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9adc5c14a63be0c211528ab8475e8423b5ff9b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::path&lt;/code&gt; class and &lt;a href=&quot;filesystem&quot;&gt; supporting functions&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;std::path&lt;/code&gt; 类和&lt;a href=&quot;filesystem&quot;&gt;支持功能&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dea6211e610d9276a290efcf3829502f2aa014dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; produces random floating-point numbers, which are uniformly distributed within each of the several subintervals [b</source>
          <target state="translated">&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; 产生随机浮点数，这些浮点数均匀地分布在几个子区间的每个区间中[b</target>
        </trans-unit>
        <trans-unit id="43981d3cf9fce583c6f001f7d756c2307dfe7dcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::piecewise_constant_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution的&lt;/a&gt;所有要求。</target>
        </trans-unit>
        <trans-unit id="1464d46a8a5b70bd224518f0ebc1bcbe92b2a5ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_construct_t&lt;/code&gt; is an empty struct tag type used to disambiguate between different functions that take two tuple arguments.</source>
          <target state="translated">&lt;code&gt;std::piecewise_construct_t&lt;/code&gt; 是一个空的struct标记类型，用于区分带有两个元组参数的不同函数。</target>
        </trans-unit>
        <trans-unit id="1589591342e4d9b49b177cc62e6708def043ee9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; produces random floating-point numbers, which are distributed according to a linear probability density function within each of the several subintervals [b</source>
          <target state="translated">&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; 产生随机浮点数，这些浮点数根据线性概率密度函数在几个子区间的每个区间内分配[b</target>
        </trans-unit>
        <trans-unit id="6d24b546da04ae6083af433d420f1dfdb16622bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::piecewise_linear_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution的&lt;/a&gt;所有要求。</target>
        </trans-unit>
        <trans-unit id="5263eace8b3cd417f114a0429efd9c8136337a84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="04b0e71ade467ccdc8596cd285211653c3c4181d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char16_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char16_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="94c428b37d8b4967659c14af5dd6202e16b2d9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char32_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char32_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="ac9449917132480eccdf004e14b3b3160c633149" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;char8_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;char8_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="07fb229870f46d1589fd827d7de6d407555b9a2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::basic_string&amp;lt;wchar_t&amp;gt;&lt;/code&gt;(typedef)</source>
          <target state="translated">&lt;code&gt;std::pmr::basic_string&amp;lt;wchar_t&amp;gt;&lt;/code&gt;(typedef)</target>
        </trans-unit>
        <trans-unit id="a6ef8419a0f8f749d4b0898782b436f2688af048" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::cmatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::cmatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="2c1d8a2f1dae6d653b3d33d171a915438c729345" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::pool_options&lt;/code&gt; is a set of constructor options for pool resources including &lt;code&gt;&lt;a href=&quot;synchronized_pool_resource&quot;&gt;std::pmr::synchronized_pool_resource&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;unsynchronized_pool_resource&quot;&gt;std::pmr::unsynchronized_pool_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::pmr::pool_options&lt;/code&gt; 是池资源的一组构造函数选项，包括 &lt;code&gt;&lt;a href=&quot;synchronized_pool_resource&quot;&gt;std::pmr::synchronized_pool_resource&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;unsynchronized_pool_resource&quot;&gt;std::pmr::unsynchronized_pool_resource&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67af5bb43cec2dbc73e627d1f1b17685d821bdca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::smatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::smatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="ef61b23247e7c1bc5b192f4736b9280dc1125a43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::string&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::string&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="2f11f3c27c774ff34d4b096a46d172154a5427d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::u16string&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::u16string&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="fa425397581319f321b29dd377b961ea0133f7bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::u32string&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::u32string&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="b090acc3f6ab9d6b5a4bd4de89335d0125925c67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::u8string&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::pmr::u8string&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="a17934a01dbbcf98ddbb9d5caa50058446ce333c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::wcmatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::wcmatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="61828bbf68f417f4ded0154a94206ec249a946db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::wsmatch&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::wsmatch&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="b2e1399a9d01238f9ffc356412c4548413318ab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pmr::wstring&lt;/code&gt;(C++17)</source>
          <target state="translated">&lt;code&gt;std::pmr::wstring&lt;/code&gt;(C++17)</target>
        </trans-unit>
        <trans-unit id="544a2203d7964b1cf3eb3f59b1daa5161af63173" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pointer_to_binary_function&lt;/code&gt; is a function object that acts as a wrapper around a binary function.</source>
          <target state="translated">&lt;code&gt;std::pointer_to_binary_function&lt;/code&gt; 是一个函数对象，充当二进制函数的包装器。</target>
        </trans-unit>
        <trans-unit id="68456b56f45eef4590adfe58b554b4aee2b82297" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::pointer_to_unary_function&lt;/code&gt; is a function object that acts as a wrapper around a unary function.</source>
          <target state="translated">&lt;code&gt;std::pointer_to_unary_function&lt;/code&gt; 是一个函数对象，充当一元函数的包装器。</target>
        </trans-unit>
        <trans-unit id="6c4a6649cb227401ea0fd4a3eae9fa3c98459c78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::poisson_distribution&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::poisson_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fff6237f139ed8631e6228d9bc6dc7571a699631" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ptrdiff_t&lt;/code&gt; is the signed integer type of the result of subtracting two pointers.</source>
          <target state="translated">&lt;code&gt;std::ptrdiff_t&lt;/code&gt; 是减去两个指针的结果的有符号整数类型。</target>
        </trans-unit>
        <trans-unit id="bc3d3a0faaa081042eac5d79ba2d90b165298d55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ptrdiff_t&lt;/code&gt; is used for &lt;a href=&quot;../language/operator_arithmetic#Additive_operators&quot;&gt;pointer arithmetic&lt;/a&gt; and array indexing, if negative values are possible. Programs that use other types, such as &lt;code&gt;int&lt;/code&gt;, may fail on, e.g. 64-bit systems when the index exceeds &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or if it relies on 32-bit modular arithmetic.</source>
          <target state="translated">&lt;code&gt;std::ptrdiff_t&lt;/code&gt; 如果可能的值为负，则将std :: ptrdiff_t用于&lt;a href=&quot;../language/operator_arithmetic#Additive_operators&quot;&gt;指针算术&lt;/a&gt;和数组索引。当索引超过 &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 或依赖于32位模块化算术时，使用其他类型（例如 &lt;code&gt;int&lt;/code&gt; ）的程序可能会在例如64位系统上失败。</target>
        </trans-unit>
        <trans-unit id="ac06d091aeafa710860b79da85a4289003f2e0d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::random_device&lt;/code&gt; is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.</source>
          <target state="translated">&lt;code&gt;std::random_device&lt;/code&gt; 是一个均匀分布的整数随机数生成器，它生成不确定的随机数。</target>
        </trans-unit>
        <trans-unit id="b78d53dcaf5721417ff464f5dc1b01db5da3e66e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::random_device&lt;/code&gt; may be implemented in terms of an implementation-defined pseudo-random number engine if a non-deterministic source (e.g. a hardware device) is not available to the implementation. In this case each &lt;code&gt;std::random_device&lt;/code&gt; object may generate the same number sequence.</source>
          <target state="translated">&lt;code&gt;std::random_device&lt;/code&gt; 如果不确定性源（例如，硬件设备）不可用于实现，则可以根据实现定义的伪随机数引擎来实现std :: random_device。在这种情况下，每个 &lt;code&gt;std::random_device&lt;/code&gt; 对象都可以生成相同的数字序列。</target>
        </trans-unit>
        <trans-unit id="733d010e28fb65a97f04138cd398414c0b48b706" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the denominator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000&amp;gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; &amp;gt;，如果std :: intmax_t可以表示分母</target>
        </trans-unit>
        <trans-unit id="21491fc755d5ba9791f6cacc8c43d1f42d070141" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000000&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the denominator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1, 1000000000000000000000000&amp;gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; &amp;gt;，如果std :: intmax_t可以表示分母</target>
        </trans-unit>
        <trans-unit id="cef43fbd2779ce1f8654b5f38187591e6ca329ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1000000000000000000000, 1&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the numerator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1000000000000000000000, 1&amp;gt;&lt;/code&gt; ，如果 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 可以表示分子</target>
        </trans-unit>
        <trans-unit id="68ad18182f2c368fdb975c210404ad0c9e06d4c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::ratio&amp;lt;1000000000000000000000000, 1&amp;gt;&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; can represent the numerator</source>
          <target state="translated">&lt;code&gt;std::ratio&amp;lt;1000000000000000000000000, 1&amp;gt;&lt;/code&gt; ，如果 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; 可以表示分子</target>
        </trans-unit>
        <trans-unit id="9c98cc470e8b16991d06d8bc751dbdd401256821" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reference_wrapper&lt;/code&gt; is a class template that wraps a reference in a copyable, assignable object. It is frequently used as a mechanism to store references inside standard containers (like &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;) which cannot normally hold references.</source>
          <target state="translated">&lt;code&gt;std::reference_wrapper&lt;/code&gt; 是一个类模板，它将引用包装在可复制的可分配对象中。它通常用作一种将引用存储在标准容器（如 &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ）中的机制，该容器通常无法保存引用。</target>
        </trans-unit>
        <trans-unit id="af9950592969ef1f447e03a8e3965b2efd182067" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reference_wrapper&lt;/code&gt; is also used to pass objects by reference to &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, the constructor of &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;, or the helper functions &lt;code&gt;&lt;a href=&quot;../pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::reference_wrapper&lt;/code&gt; 还用于通过引用 &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 的构造函数或辅助函数 &lt;code&gt;&lt;a href=&quot;../pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../tuple/make_tuple&quot;&gt;std::make_tuple&lt;/a&gt;&lt;/code&gt; 来传递对象。</target>
        </trans-unit>
        <trans-unit id="22aa124fedb12c1ebec2890071b10e4252dc0665" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reference_wrapper&lt;/code&gt; is guaranteed to be &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::reference_wrapper&lt;/code&gt; 保证是&lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e00c06df8463f4c62b5c854d2d046dfde8ce082d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::regex_iterator&lt;/code&gt; is a read-only iterator that accesses the individual matches of a regular expression within the underlying character sequence. It meets the requirements of a &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, except that for dereferenceable values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; with &lt;code&gt;a == b&lt;/code&gt;, &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; will not be bound to the same object.</source>
          <target state="translated">&lt;code&gt;std::regex_iterator&lt;/code&gt; 是只读的迭代器，用于访问基础字符序列中正则表达式的各个匹配项。它满足了要求&lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;，除了对于可提领值 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 与 &lt;code&gt;a == b&lt;/code&gt; ， &lt;code&gt;*a&lt;/code&gt; 和 &lt;code&gt;*b&lt;/code&gt; 将不被绑定到相同的对象。</target>
        </trans-unit>
        <trans-unit id="ee427776b3ed6eca5825984efc250d1c3eb23dfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::regex_token_iterator&lt;/code&gt; is a read-only &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; that accesses the individual sub-matches of every match of a regular expression within the underlying character sequence. It can also be used to access the parts of the sequence that were not matched by the given regular expression (e.g. as a tokenizer).</source>
          <target state="translated">&lt;code&gt;std::regex_token_iterator&lt;/code&gt; 是只读的&lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;，可访问基础字符序列中正则表达式的每个匹配项的各个子匹配项。它也可以用来访问序列中与给定正则表达式不匹配的部分（例如，作为分词器）。</target>
        </trans-unit>
        <trans-unit id="67f2f3cf0fd664c7dfb87b979c353b536d657206" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::regex_traits::char_class_type&lt;/code&gt;(since C++11)</source>
          <target state="translated">&lt;code&gt;std::regex_traits::char_class_type&lt;/code&gt; （C ++ 11起）</target>
        </trans-unit>
        <trans-unit id="8a7c1a8e462c9be7b58d511576da4998a286bbdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reverse_iterator&lt;/code&gt; does not work with iterators that return a reference to a member object (so-called &quot;stashing iterators&quot;). An example of stashing iterator is &lt;a href=&quot;../filesystem/path#Member_types_and_constants&quot;&gt;&lt;code&gt;std::filesystem::path::iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::reverse_iterator&lt;/code&gt; 不适用于返回对成员对象的引用的迭代器（所谓的&amp;ldquo;隐藏式迭代器&amp;rdquo;）。存放迭代器的一个示例是&lt;a href=&quot;../filesystem/path#Member_types_and_constants&quot;&gt; &lt;code&gt;std::filesystem::path::iterator&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8bc574a36f080c60bc0dcdc67f6fbe182967c6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::reverse_iterator&lt;/code&gt; is an iterator adaptor that reverses the direction of a given iterator. In other words, when provided with a bidirectional iterator, &lt;code&gt;std::reverse_iterator&lt;/code&gt; produces a new iterator that moves from the end to the beginning of the sequence defined by the underlying bidirectional iterator.</source>
          <target state="translated">&lt;code&gt;std::reverse_iterator&lt;/code&gt; 是一个迭代器适配器，可反转给定迭代器的方向。换句话说，当提供了双向迭代器时， &lt;code&gt;std::reverse_iterator&lt;/code&gt; 会生成一个新的迭代器，该迭代器将从底层双向迭代器定义的序列的末尾开始移动。</target>
        </trans-unit>
        <trans-unit id="06e6eb01ef0888fc5786006b255e0262355a35cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::rotate&lt;/code&gt; is a common building block in many algorithms. This example demonstrates insertion sort:</source>
          <target state="translated">&lt;code&gt;std::rotate&lt;/code&gt; 是许多算法中常见的构建块。此示例演示插入排序：</target>
        </trans-unit>
        <trans-unit id="f441eb26d364454c44afbcadef7f5d66d2c48d76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::seed_seq&lt;/code&gt; consumes a sequence of integer-valued data and produces a requested number of unsigned integer values &lt;code&gt;i&lt;/code&gt;, 0 &amp;le; i &amp;lt; 232</source>
          <target state="translated">&lt;code&gt;std::seed_seq&lt;/code&gt; 消耗一系列整数值数据，并生成请求数量的无符号整数值 &lt;code&gt;i&lt;/code&gt; ，0&amp;le;i &amp;lt;232</target>
        </trans-unit>
        <trans-unit id="9c2a99a1055ff146aefbad3ed9afa018825c25dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::seed_seq&lt;/code&gt; meets the requirements of &lt;a href=&quot;../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::seed_seq&lt;/code&gt; 符合要求&lt;a href=&quot;../../named_req/seedsequence&quot;&gt;SeedSequence&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e4c8bb8b1657216775cfa8413677c1cdf341b425" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::set&lt;/code&gt; is an associative container that contains a sorted set of unique objects of type &lt;code&gt;Key&lt;/code&gt;. Sorting is done using the key comparison function &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;. Search, removal, and insertion operations have logarithmic complexity. Sets are usually implemented as &lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;red-black trees&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::set&lt;/code&gt; 是一个关联容器，其中包含一组 &lt;code&gt;Key&lt;/code&gt; 类型的唯一对象的排序集合。使用键比较功能&lt;a href=&quot;../named_req/compare&quot;&gt;Compare进行&lt;/a&gt;排序。搜索，删除和插入操作具有对数复杂性。集通常实现为&lt;a href=&quot;https://en.wikipedia.org/wiki/Red%E2%80%93black_tree&quot;&gt;红黑树&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f2c918ca952dcd23d77f536141c1af09ae7aa661" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::set&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, &lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;, &lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt; and &lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::set&lt;/code&gt; 满足&lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;，&lt;a href=&quot;../named_req/allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;，&lt;a href=&quot;../named_req/associativecontainer&quot;&gt;AssociativeContainer&lt;/a&gt;和&lt;a href=&quot;../named_req/reversiblecontainer&quot;&gt;ReversibleContainer的要求&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cd33c830f9ff0669a2f536be537d8c93a0a03b50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::shared_ptr&lt;/code&gt; is a smart pointer that retains shared ownership of an object through a pointer. Several &lt;code&gt;shared_ptr&lt;/code&gt; objects may own the same object. The object is destroyed and its memory deallocated when either of the following happens:</source>
          <target state="translated">&lt;code&gt;std::shared_ptr&lt;/code&gt; 是一个智能指针，它通过指针保留对象的共享所有权。几个 &lt;code&gt;shared_ptr&lt;/code&gt; 对象可能拥有同一对象。发生以下任一情况时，对象将被销毁并释放其内存：</target>
        </trans-unit>
        <trans-unit id="fabbfc740b8d37fb726de4a43248fcefc33b4a9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::shared_ptr&lt;/code&gt; may be used with an &lt;a href=&quot;../language/incomplete_type&quot;&gt;incomplete type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;. However, the constructor from a raw pointer (&lt;code&gt;template&amp;lt;class Y&amp;gt; shared_ptr(Y*)&lt;/code&gt;) and the &lt;code&gt;template&amp;lt;class Y&amp;gt; void reset(Y*)&lt;/code&gt; member function may only be called with a pointer to a complete type (note that &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; may be constructed from a raw pointer to an incomplete type).</source>
          <target state="translated">&lt;code&gt;std::shared_ptr&lt;/code&gt; 可能与&lt;a href=&quot;../language/incomplete_type&quot;&gt;不完整的类型&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 一起使用。然而，从一个原始指针（的构造 &lt;code&gt;template&amp;lt;class Y&amp;gt; shared_ptr(Y*)&lt;/code&gt; ）和 &lt;code&gt;template&amp;lt;class Y&amp;gt; void reset(Y*)&lt;/code&gt; 成员函数可以仅使用指针调用以一个完整的类型（注意， &lt;code&gt;&lt;a href=&quot;unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 可以由指向不完整类型的原始指针构造）。</target>
        </trans-unit>
        <trans-unit id="03a4c722a55044327e4cfffa724449a4b88da0ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::signal&lt;/code&gt; with the first argument being the number of the signal currently handled (async handler can re-register itself, but not other signals).</source>
          <target state="translated">&lt;code&gt;std::signal&lt;/code&gt; ，第一个参数是当前处理的信号编号（异步处理程序可以重新注册自身，但不能重新注册其他信号）。</target>
        </trans-unit>
        <trans-unit id="c2254b3548faa8b27fc548641136852a0c03336b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::signal&lt;/code&gt; with the first argument being the number of the signal currently handled (signal handler can re-register itself, but not other signals).</source>
          <target state="translated">&lt;code&gt;std::signal&lt;/code&gt; ，第一个参数是当前处理的信号编号（信号处理程序可以重新注册自身，但不能重新注册其他信号）。</target>
        </trans-unit>
        <trans-unit id="ca1e54b99db001a5b4190a0c7f3d8fffb71fc24f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::size_t&lt;/code&gt; can store the maximum size of a theoretically possible object of any type (including array). A type whose size cannot be represented by &lt;code&gt;std::size_t&lt;/code&gt; is ill-formed(since C++14) On many platforms (an exception is systems with segmented addressing) &lt;code&gt;std::size_t&lt;/code&gt; can safely store the value of any non-member pointer, in which case it is synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::uintptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::size_t&lt;/code&gt; 可以存储任何类型（包括数组）的理论上可能存在的对象的最大大小。类型不能由 &lt;code&gt;std::size_t&lt;/code&gt; 表示的类型是错误格式的（因为C ++ 14）在许多平台上（具有分段寻址的系统除外） &lt;code&gt;std::size_t&lt;/code&gt; 可以安全地存储任何非成员指针的值，在这种情况下，它与 &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::uintptr_t&lt;/a&gt;&lt;/code&gt; 同义。</target>
        </trans-unit>
        <trans-unit id="290cfac85ab67a680f302b6463b3fa047ee441eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::size_t&lt;/code&gt; is commonly used for array indexing and loop counting. Programs that use other types, such as &lt;code&gt;unsigned int&lt;/code&gt;, for array indexing may fail on, e.g. 64-bit systems when the index exceeds &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;UINT_MAX&lt;/a&gt;&lt;/code&gt; or if it relies on 32-bit modular arithmetic.</source>
          <target state="translated">&lt;code&gt;std::size_t&lt;/code&gt; 通常用于数组索引和循环计数。使用其他类型（例如 &lt;code&gt;unsigned int&lt;/code&gt; ）进行数组索引的程序可能会在64位系统上失败，例如当索引超过 &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;UINT_MAX&lt;/a&gt;&lt;/code&gt; 或依赖于32位模块化算术时。</target>
        </trans-unit>
        <trans-unit id="056a9dc0cc03d5b2db95e167d1072f198456cc3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::size_t&lt;/code&gt; is the unsigned integer type of the result of the &lt;a href=&quot;../language/sizeof&quot;&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/a&gt; operator as well as the &lt;a href=&quot;../language/sizeof...&quot;&gt;&lt;code&gt;sizeof...&lt;/code&gt;&lt;/a&gt; operator and the &lt;a href=&quot;../language/alignof&quot;&gt;&lt;code&gt;alignof&lt;/code&gt;&lt;/a&gt; operator(since C++11).</source>
          <target state="translated">&lt;code&gt;std::size_t&lt;/code&gt; 是&lt;a href=&quot;../language/sizeof&quot;&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;/a&gt;运算符以及&lt;a href=&quot;../language/sizeof...&quot;&gt; &lt;code&gt;sizeof...&lt;/code&gt; &lt;/a&gt;运算符和&lt;a href=&quot;../language/alignof&quot;&gt; &lt;code&gt;alignof&lt;/code&gt; &lt;/a&gt;运算符的结果的无符号整数类型（自C ++ 11起）。</target>
        </trans-unit>
        <trans-unit id="47242d9af8e0da2cd80e37ba7d69dc7cc3832e0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::slice&lt;/code&gt; is the selector class that identifies a subset of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; similar to &lt;a href=&quot;https://en.wikipedia.org/wiki/BLAS&quot;&gt;BLAS&lt;/a&gt; slice. An object of type &lt;code&gt;std::slice&lt;/code&gt; holds three values: the starting index, the stride, and the total number of values in the subset. Objects of type &lt;code&gt;std::slice&lt;/code&gt; can be used as indexes with valarray's &lt;code&gt;operator[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::slice&lt;/code&gt; 是选择器类，用于标识类似于&lt;a href=&quot;https://en.wikipedia.org/wiki/BLAS&quot;&gt;BLAS&lt;/a&gt; slice 的 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 的子集。类型为 &lt;code&gt;std::slice&lt;/code&gt; 的对象包含三个值：起始索引，步幅和子集中的值总数。 &lt;code&gt;std::slice&lt;/code&gt; 类型的对象可以与valarray的 &lt;code&gt;operator[]&lt;/code&gt; 一起用作索引。</target>
        </trans-unit>
        <trans-unit id="cc6ba21c4316c6b51a3cf612a94f1cb6a3023448" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::slice_array&lt;/code&gt; is a helper template used by &lt;code&gt;&lt;a href=&quot;slice&quot;&gt;std::slice&lt;/a&gt;&lt;/code&gt; subscript operator. It has reference semantics to a subset of the array specified by the &lt;code&gt;std::slice&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;std::slice_array&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;slice&quot;&gt;std::slice&lt;/a&gt;&lt;/code&gt; 下标运算符使用的辅助模板。它具有对 &lt;code&gt;std::slice&lt;/code&gt; 对象指定的数组子集的引用语义。</target>
        </trans-unit>
        <trans-unit id="3c43c4b56b0bcbad2ca7fbcf999df357050cd5ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::span&lt;/code&gt; view</source>
          <target state="translated">&lt;code&gt;std::span&lt;/code&gt; 视图</target>
        </trans-unit>
        <trans-unit id="022aee2c614401246f82162884b2a5730dddc045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::sqrt&lt;/code&gt; is required by the IEEE standard to be exact. The only other operations required to be exact are the &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; and the function &lt;code&gt;&lt;a href=&quot;fma&quot;&gt;std::fma&lt;/a&gt;&lt;/code&gt;. After rounding to the return type (using default rounding mode), the result of &lt;code&gt;std::sqrt&lt;/code&gt; is indistinguishable from the infinitely precise result. In other words, the error is less than 0.5 ulp. Other functions, including &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt;, are not so constrained.</source>
          <target state="translated">&lt;code&gt;std::sqrt&lt;/code&gt; IEEE标准要求std :: sqrt准确。唯一需要精确的其他运算是&lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;算术运算符&lt;/a&gt;和函数 &lt;code&gt;&lt;a href=&quot;fma&quot;&gt;std::fma&lt;/a&gt;&lt;/code&gt; 。四舍五入为返回类型（使用默认的四舍五入模式）后， &lt;code&gt;std::sqrt&lt;/code&gt; 的结果与无限精确的结果无法区分。换句话说，误差小于0.5 ulp。其他功能，包括 &lt;code&gt;&lt;a href=&quot;pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; ，没有那么受限制。</target>
        </trans-unit>
        <trans-unit id="a8d30cec9b43e6f974c8d36ed546411518d333cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::streampos&lt;/code&gt; and &lt;code&gt;std::wstreampos&lt;/code&gt; are required to be the same type because &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;char&amp;gt;::state_type&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;wchar_t&amp;gt;::state_type&lt;/code&gt; are required to both be &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;. C++98 had a self-contradictory statement that they may be different if the implementation supports no shift encoding in narrow-oriented iostreams but supports one or more shift encodings in wide-oriented streams, but that was corrected in C++03.</source>
          <target state="translated">&lt;code&gt;std::streampos&lt;/code&gt; 和 &lt;code&gt;std::wstreampos&lt;/code&gt; 必须为同一类型，因为 &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;char&amp;gt;::state_type&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../string/char_traits&quot;&gt;std::char_traits&lt;/a&gt;&amp;lt;wchar_t&amp;gt;::state_type&lt;/code&gt; 都必须为 &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 。C ++ 98有一个自相矛盾的声明，即如果该实现在面向狭窄的iostream中不支持移位编码，但支持面向宽泛的流中的一个或多个shift编码，则它们可能会有所不同，但是在C ++ 03中已得到纠正。</target>
        </trans-unit>
        <trans-unit id="ff0eafa74a74dee03ea9a69e23b551865010e207" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_equality::equal&lt;/code&gt; if &lt;code&gt;p == q&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::strong_equality::equal&lt;/code&gt; 如果 &lt;code&gt;p == q&lt;/code&gt; 则std :: strong_equality ::等于</target>
        </trans-unit>
        <trans-unit id="88deaa9e64ae8679b6a5d73ef18b59c37a1452b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_equality::equal&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;equivalent&lt;/code&gt; or &lt;code&gt;equal&lt;/code&gt;, &lt;code&gt;std::strong_equality::nonequal&lt;/code&gt; if &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;less&lt;/code&gt; or &lt;code&gt;greater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::strong_equality::equal&lt;/code&gt; 如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;equivalent&lt;/code&gt; 或 &lt;code&gt;equal&lt;/code&gt; ， &lt;code&gt;std::strong_equality::nonequal&lt;/code&gt; 如果 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;less&lt;/code&gt; 或 &lt;code&gt;greater&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b2828c1fd0dac296e742caf4bff22f7533be6f4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_equality::unequal&lt;/code&gt; if &lt;code&gt;p != q&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::strong_equality::unequal&lt;/code&gt; 如果 &lt;code&gt;p != q&lt;/code&gt; 则std :: strong_equality :: unqual</target>
        </trans-unit>
        <trans-unit id="fdce79e381b03cf3c0ed3a09ab095fa0f7f8dd55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_equality&lt;/code&gt; is implicitly-convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, and &lt;code&gt;std::strong_ordering&lt;/code&gt; is implicitly-convertible to &lt;code&gt;strong_equality&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::strong_equality&lt;/code&gt; 可以隐式转换为 &lt;code&gt;std::weak_equality&lt;/code&gt; ，而 &lt;code&gt;std::strong_ordering&lt;/code&gt; 可以隐式转换为 &lt;code&gt;strong_equality&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1bcf62941b855cdd0eac5af9fa875bd46144dbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::equal&lt;/code&gt; if &lt;code&gt;p == q&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::equal&lt;/code&gt; 如果 &lt;code&gt;p == q&lt;/code&gt; 则std :: strong_ordering ::等于</target>
        </trans-unit>
        <trans-unit id="fa83ac2e7a33bc297d6c81b58884fdb954ee3802" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::equal&lt;/code&gt; if both operands are arithmetically equal,</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::equal&lt;/code&gt; 如果两个操作数在算术上相等，则为std :: strong_ordering :: equal，</target>
        </trans-unit>
        <trans-unit id="a181c69bdfa2c3d7090838be67bdd8fbd3d75e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::greater&lt;/code&gt; if &lt;code&gt;p &amp;gt; q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::greater&lt;/code&gt; 如果 &lt;code&gt;p &amp;gt; q&lt;/code&gt; 则std :: strong_ordering ::更大。</target>
        </trans-unit>
        <trans-unit id="71b898ba9d170e3716779c1c92981e7382e24f08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::greater&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::greater&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="94f91bbaa05a1c0e4e86bdd725dfda6ed828496c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::less&lt;/code&gt; if &lt;code&gt;q &amp;gt; p&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::less&lt;/code&gt; 如果 &lt;code&gt;q &amp;gt; p&lt;/code&gt; 则std :: strong_ordering :: less</target>
        </trans-unit>
        <trans-unit id="cd73a567570412ceb0f011855a55d1be0b51206d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering::less&lt;/code&gt; if the first operand is arithmetically less than the second</source>
          <target state="translated">&lt;code&gt;std::strong_ordering::less&lt;/code&gt; 如果第一个操作数在算术上小于第二个操作数，则std :: strong_ordering :: less</target>
        </trans-unit>
        <trans-unit id="a0be3656c320241f0794e9dd6c9a8f164ba69337" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strong_ordering&lt;/code&gt; is the strongest of the five comparison categories: it is not implicitly-convertible from any other category and is implicitly-convertible to the other four.</source>
          <target state="translated">&lt;code&gt;std::strong_ordering&lt;/code&gt; 是五个比较类别中最强的：它不能与任何其他类别隐式转换，也可以隐式转换为其他四个类别。</target>
        </trans-unit>
        <trans-unit id="18a339f4bc94136e209672e86712fa4b5c74a67e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::strstreambuf&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; whose associated character sequence is a character array, which may be constant (e.g. a string literal), modifyable but not dynamic (e.g. a stack-allocated array), or dynamic, in which case the &lt;code&gt;std::strstreambuf&lt;/code&gt; may be allowed to reallocate the array as necessary to accomodate output (e.g. by calling &lt;code&gt;delete[]&lt;/code&gt; and &lt;code&gt;new[]&lt;/code&gt; or user-provided functions).</source>
          <target state="translated">&lt;code&gt;std::strstreambuf&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 其关联的字符序列是一个字符数组，该数组可以是常量（例如，字符串文字），可修改但不能动态（例如，堆栈分配的数组）或动态（在这种情况下，可能允许 &lt;code&gt;std::strstreambuf&lt;/code&gt; 根据需要重新分配数组以容纳输出（例如，通过调用 &lt;code&gt;delete[]&lt;/code&gt; 和 &lt;code&gt;new[]&lt;/code&gt; 或用户提供的函数）。</target>
        </trans-unit>
        <trans-unit id="20b1262a3ef1cef77b3b6dd08e920d63edd3d503" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::student_t_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::student_t_distribution&lt;/code&gt; 满足&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution的&lt;/a&gt;所有要求。</target>
        </trans-unit>
        <trans-unit id="d1a1bd7eb4ef8c03ea4109507696644c4ffb2d1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::sub_match&lt;/code&gt; and &lt;code&gt;std::basic_string&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::sub_match&lt;/code&gt; 和 &lt;code&gt;std::basic_string&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a5b5ab885216f8f5912119ae5ca87c8090e2875" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::sub_match&lt;/code&gt; and &lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::sub_match&lt;/code&gt; 和 &lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff93371d4eb96a58db4fdb372bc81e5853b46bb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::sub_match&lt;/code&gt; and &lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::sub_match&lt;/code&gt; 和 &lt;code&gt;std::iterator_traits&amp;lt;BidirIt&amp;gt;::value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba31ca36a3af295296b1e09f75fa13408fe38921" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::swap&lt;/code&gt; may be &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;specialized in namespace std&lt;/a&gt; for program-defined types, but such specializations are not found by &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt; (the namespace std is not the associated namespace for the program-defined type).</source>
          <target state="translated">&lt;code&gt;std::swap&lt;/code&gt; 可能&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;专用于&lt;/a&gt;程序定义类型的名称空间std，但是&lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt;找不到这种专用（名称空间std不是程序定义类型的关联名称空间）。</target>
        </trans-unit>
        <trans-unit id="3cdfd51faa9c8fac8ac4c8f19556e6aaf7087b9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::system_error&lt;/code&gt; is the type of the exception thrown by various library functions (typically the functions that interface with the OS facilities, e.g. the constructor of &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;) when the exception has an associated &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, which may be reported.</source>
          <target state="translated">&lt;code&gt;std::system_error&lt;/code&gt; 当异常具有关联的 &lt;code&gt;&lt;a href=&quot;error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; ，std :: system_error是由各种库函数（通常是与OS设备交互的函数，例如 &lt;code&gt;&lt;a href=&quot;../thread/thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; 的构造函数）引发的异常的类型。。</target>
        </trans-unit>
        <trans-unit id="9b97e66f36eaf86ebef226240b01fec6a5931292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::terminate()&lt;/code&gt; is called by the C++ runtime when exception handling fails for any of the following reasons:</source>
          <target state="translated">&lt;code&gt;std::terminate()&lt;/code&gt; 由于以下任何原因导致异常处理失败时，C ++运行时将调用std :: terminate（）：</target>
        </trans-unit>
        <trans-unit id="707766d49466f7eb486764ecef0242827a563761" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::terminate()&lt;/code&gt; may also be called directly from the program.</source>
          <target state="translated">&lt;code&gt;std::terminate()&lt;/code&gt; 也可以直接从程序中调用。</target>
        </trans-unit>
        <trans-unit id="967f01400b555a0590b6a06e03c381f0be0d2748" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::terminate_handler&lt;/code&gt; is the function pointer type (pointer to function that takes no arguments and returns void), which is installed and queried by the functions &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;get_terminate&quot;&gt;std::get_terminate&lt;/a&gt;&lt;/code&gt; and called by &lt;code&gt;&lt;a href=&quot;terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::terminate_handler&lt;/code&gt; 是函数指针类型（不带任何参数并返回void的函数指针），由函数 &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;get_terminate&quot;&gt;std::get_terminate&lt;/a&gt;&lt;/code&gt; 安装并查询，并由 &lt;code&gt;&lt;a href=&quot;terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="13cc468c9dc5514d2fac80612f05a11f45487235" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::thread&lt;/code&gt; objects may also be in the state that does not represent any thread (after default construction, move from, &lt;code&gt;&lt;a href=&quot;thread/detach&quot;&gt;detach&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;thread/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;), and a thread of execution may be not associated with any &lt;code&gt;thread&lt;/code&gt; objects (after &lt;code&gt;&lt;a href=&quot;thread/detach&quot;&gt;detach&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;std::thread&lt;/code&gt; 对象也可能处于不表示任何线程的状态（在默认构造之后，from，move， &lt;code&gt;&lt;a href=&quot;thread/detach&quot;&gt;detach&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;thread/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; ），并且执行线程可能未与任何 &lt;code&gt;thread&lt;/code&gt; 对象关联（ &lt;code&gt;&lt;a href=&quot;thread/detach&quot;&gt;detach&lt;/a&gt;&lt;/code&gt; 之后）。</target>
        </trans-unit>
        <trans-unit id="9efd773c6198d21cd58d5624e73cb6260c84320b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::tie&lt;/code&gt; can be used to introduce lexicographical comparison to a struct or to unpack a tuple:</source>
          <target state="translated">&lt;code&gt;std::tie&lt;/code&gt; 可以用于将字典比较引入到结构或拆开元组：</target>
        </trans-unit>
        <trans-unit id="d306d0d73a611a68233912abbfd10d0645a66545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::tie&lt;/code&gt; may be used to unpack a &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; because &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; has a &lt;a href=&quot;operator=&quot;&gt;converting assignment&lt;/a&gt; from pairs:</source>
          <target state="translated">&lt;code&gt;std::tie&lt;/code&gt; 可以用于解包 &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 因为 &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; 具有成对&lt;a href=&quot;operator=&quot;&gt;转换任务&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="afe708861136a7c969234dc59c3e1714fbac45b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::time_get_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; facet which encapsulates time and date parsing rules of the locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::time_get_byname&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; 构面，它封装在构造时指定的语言环境的时间和日期解析规则。</target>
        </trans-unit>
        <trans-unit id="7c370603c900e9e11ba920686444d55c087581b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::time_put_byname&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; facet which encapsulates time and date formatting rules of the locale specified at its construction.</source>
          <target state="translated">&lt;code&gt;std::time_put_byname&lt;/code&gt; 是一个 &lt;code&gt;&lt;a href=&quot;time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; 构面，它封装了在构造时指定的语言环境的时间和日期格式设置规则。</target>
        </trans-unit>
        <trans-unit id="168ace59259188176403e2196b7d0ba75671c5a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::tmpnam&lt;/code&gt; modifies static state and is not required to be thread-safe.</source>
          <target state="translated">&lt;code&gt;std::tmpnam&lt;/code&gt; 修改静态状态，并且不需要是线程安全的。</target>
        </trans-unit>
        <trans-unit id="dedb51abfca7405582b2d0f7f2e6c3a75a98b2f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::to_address&lt;/code&gt; can be used even when &lt;code&gt;p&lt;/code&gt; does not reference storage that has an object constructed in it, in which case &lt;code&gt;&lt;a href=&quot;addressof&quot;&gt;std::addressof&lt;/a&gt;(*p)&lt;/code&gt; cannot be used because there's no valid object for the parameter of &lt;code&gt;&lt;a href=&quot;addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; to bind to.</source>
          <target state="translated">&lt;code&gt;std::to_address&lt;/code&gt; 可以即使当使用 &lt;code&gt;p&lt;/code&gt; 不具有在它构造的目的，在这种情况下，参照存储 &lt;code&gt;&lt;a href=&quot;addressof&quot;&gt;std::addressof&lt;/a&gt;(*p)&lt;/code&gt; 不能使用，因为没有对的参数没有有效的对象 &lt;code&gt;&lt;a href=&quot;addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; 到绑定到。</target>
        </trans-unit>
        <trans-unit id="b46c993ce36788048b268c1696eb73f8b98374f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::to_chars&lt;/code&gt; and &lt;code&gt;std::from_chars&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::to_chars&lt;/code&gt; 和 &lt;code&gt;std::from_chars&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9cd7760eccc84b707a50eaebab892d1d3e5f509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::to_string&lt;/code&gt; relies on the current locale for formatting purposes, and therefore concurrent calls to &lt;code&gt;std::to_string&lt;/code&gt; from multiple threads may result in partial serialization of calls. C++17 provides &lt;a href=&quot;../../utility/to_chars&quot;&gt;&lt;code&gt;std::to_chars&lt;/code&gt;&lt;/a&gt; as a higher-performance locale-independent alternative.</source>
          <target state="translated">&lt;code&gt;std::to_string&lt;/code&gt; 依赖于当前语言环境进行格式化，因此从多个线程并发调用 &lt;code&gt;std::to_string&lt;/code&gt; 可能会导致部分调用序列化。C ++ 17提供&lt;a href=&quot;../../utility/to_chars&quot;&gt; &lt;code&gt;std::to_chars&lt;/code&gt; &lt;/a&gt;作为高性能的独立于语言环境的替代方案。</target>
        </trans-unit>
        <trans-unit id="be1a0d836b90531682a592a8c05709e53004c149" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::transform&lt;/code&gt; applies the given function to a range and stores the result in another range, beginning at &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::transform&lt;/code&gt; 将给定函数应用于一个范围，并将结果存储在另一个范围内，从 &lt;code&gt;d_first&lt;/code&gt; 开始。</target>
        </trans-unit>
        <trans-unit id="c6cd4e102829d3895559858e0d9124b27ca438a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::transform&lt;/code&gt; does not guarantee in-order application of &lt;code&gt;unary_op&lt;/code&gt; or &lt;code&gt;binary_op&lt;/code&gt;. To apply a function to a sequence in-order or to apply a function that modifies the elements of a sequence, use &lt;code&gt;&lt;a href=&quot;for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::transform&lt;/code&gt; 不保证按顺序应用 &lt;code&gt;unary_op&lt;/code&gt; 或 &lt;code&gt;binary_op&lt;/code&gt; 。要将函数按顺序应用于序列或将函数修改序列的元素，请使用 &lt;code&gt;&lt;a href=&quot;for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="369cbe5d59701bacdbac57d4ffbdb1d3005d5fc3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::u16string&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;std::u16string&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="5c664f67d51845abae95b5f4eff5530a5e4e852d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::u32string&lt;/code&gt;(C++11)</source>
          <target state="translated">&lt;code&gt;std::u32string&lt;/code&gt;(C++11)</target>
        </trans-unit>
        <trans-unit id="d018d8459afcf08b3a64d2e43507143d97d66702" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::u8string&lt;/code&gt;(C++20)</source>
          <target state="translated">&lt;code&gt;std::u8string&lt;/code&gt;(C++20)</target>
        </trans-unit>
        <trans-unit id="8db402252e2247e1115923d033d3fdbc01c24ffa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::u8string&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::u8string&lt;/code&gt; （C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="28dc2a65207cfa538de9d0d3c83868d7291c3a71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::u8string_view&lt;/code&gt;(since C++20)</source>
          <target state="translated">&lt;code&gt;std::u8string_view&lt;/code&gt; （C ++ 20起）</target>
        </trans-unit>
        <trans-unit id="fc05d3bc1c5239c2cb1fa3a05f95d7b3bcb6d04a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unexpected()&lt;/code&gt; is called by the C++ runtime when a &lt;a href=&quot;../../language/except_spec&quot;&gt;dynamic exception specification&lt;/a&gt; is violated: an exception is thrown from a function whose exception specification forbids exceptions of this type.</source>
          <target state="translated">&lt;code&gt;std::unexpected()&lt;/code&gt; 违反&lt;a href=&quot;../../language/except_spec&quot;&gt;动态异常规范&lt;/a&gt;时，C ++运行时将调用std :: unexpected（）：从一个函数抛出异常，该函数的异常规范禁止此类异常。</target>
        </trans-unit>
        <trans-unit id="f92d15dc42ce35ff57483e797d7c8f8b1f9636b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unexpected()&lt;/code&gt; may also be called directly from the program.</source>
          <target state="translated">&lt;code&gt;std::unexpected()&lt;/code&gt; 也可以直接从程序中调用。</target>
        </trans-unit>
        <trans-unit id="43b8f5b3528d14822224152dd25f600ede9e7c34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unexpected_handler&lt;/code&gt; is the function pointer type (pointer to function that takes no arguments and returns void), which is installed and queried by the functions &lt;code&gt;&lt;a href=&quot;set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;get_unexpected&quot;&gt;std::get_unexpected&lt;/a&gt;&lt;/code&gt; and called by &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;std::unexpected_handler&lt;/code&gt; 是函数指针类型（不带参数并返回void的函数指针），由函数 &lt;code&gt;&lt;a href=&quot;set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;get_unexpected&quot;&gt;std::get_unexpected&lt;/a&gt;&lt;/code&gt; 安装并查询，并由 &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 调用。</target>
        </trans-unit>
        <trans-unit id="749f7fda0e2e18379142e674b99f477616d0b136" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::uniform_int_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::uniform_int_distribution&lt;/code&gt; 满足所有要求&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c444092291162ae7558c84afd48c45cb9322484f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::uniform_real_distribution&lt;/code&gt; satisfies all requirements of &lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::uniform_real_distribution&lt;/code&gt; 满足所有要求&lt;a href=&quot;../../named_req/randomnumberdistribution&quot;&gt;RandomNumberDistribution&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb35955ee270e54b7c81eaa739704d3de5f1583a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt; is a smart pointer that owns and manages another object through a pointer and disposes of that object when the &lt;code&gt;unique_ptr&lt;/code&gt; goes out of scope.</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; 是一个智能指针，它通过指针拥有和管理另一个对象，并在 &lt;code&gt;unique_ptr&lt;/code&gt; 超出范围时处置该对象。</target>
        </trans-unit>
        <trans-unit id="58e8a960823be282cfdc5e0d6c9be212b22d9797" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt; is commonly used to manage the lifetime of objects, including:</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; 通常用于管理对象的生存期，包括：</target>
        </trans-unit>
        <trans-unit id="e307c436ff83a7f2f77edf798287d471ee601de8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;std::unique_ptr&lt;/code&gt; may be constructed for an &lt;a href=&quot;../language/incomplete_type&quot;&gt;incomplete type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;, such as to facilitate the use as a handle in the &lt;a href=&quot;../language/pimpl&quot;&gt;pImpl idiom&lt;/a&gt;. If the default deleter is used, &lt;code&gt;T&lt;/code&gt; must be complete at the point in code where the deleter is invoked, which happens in the destructor, move assignment operator, and &lt;code&gt;reset&lt;/code&gt; member function of &lt;code&gt;std::unique_ptr&lt;/code&gt;. (Conversely, &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; can't be constructed from a raw pointer to incomplete type, but can be destroyed where &lt;code&gt;T&lt;/code&gt; is incomplete). Note that if &lt;code&gt;T&lt;/code&gt; is a class template specialization, use of &lt;code&gt;unique_ptr&lt;/code&gt; as an operand, e.g. &lt;code&gt;!p&lt;/code&gt; requires &lt;code&gt;T&lt;/code&gt;'s parameters to be complete due to &lt;a href=&quot;../language/adl&quot;&gt;ADL&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::unique_ptr&lt;/code&gt; 可以为&lt;a href=&quot;../language/incomplete_type&quot;&gt;不完整的类型&lt;/a&gt; &lt;code&gt;T&lt;/code&gt; 构造std :: unique_ptr，以便于在&lt;a href=&quot;../language/pimpl&quot;&gt;pImpl习惯用法中&lt;/a&gt;方便地用作句柄。如果使用默认删除器，则 &lt;code&gt;T&lt;/code&gt; 必须在代码中调用删除器的点处完成，该点发生在析构函数，移动赋值运算符和 &lt;code&gt;std::unique_ptr&lt;/code&gt; &lt;code&gt;reset&lt;/code&gt; 成员函数中。 （相反， &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 不能从指向不完整类型的原始指针构造，但是可以在 &lt;code&gt;T&lt;/code&gt; 不完整的地方销毁）。请注意，如果 &lt;code&gt;T&lt;/code&gt; 是一个类模板专门化，请使用 &lt;code&gt;unique_ptr&lt;/code&gt; 作为操作数，例如 &lt;code&gt;!p&lt;/code&gt; 由于&lt;a href=&quot;../language/adl&quot;&gt;ADL，&lt;/a&gt;要求 &lt;code&gt;T&lt;/code&gt; 的参数完整。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
