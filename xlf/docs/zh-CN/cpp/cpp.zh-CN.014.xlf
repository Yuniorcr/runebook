<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="8b3f01687d89feac7cfe2128cd7fb4336c3f52ee" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;(y*&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(x))&lt;/code&gt;.</source>
          <target state="translated">错误和特殊情况的处理就像该操作由 &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;(y*&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;(x))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8eceb47949f152b23fef3272be167f4940d38aa" translate="yes" xml:space="preserve">
          <source>Errors and special cases are handled as if the operation is implemented by &lt;code&gt;&lt;a href=&quot;cosh&quot;&gt;std::cosh&lt;/a&gt;(i*z)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the imaginary unit.</source>
          <target state="translated">错误和特殊情况的处理就像操作是由 &lt;code&gt;&lt;a href=&quot;cosh&quot;&gt;std::cosh&lt;/a&gt;(i*z)&lt;/code&gt; ，其中 &lt;code&gt;i&lt;/code&gt; 是虚数单位。</target>
        </trans-unit>
        <trans-unit id="2ab0e556309413233a2f6554e50dca392be2f614" translate="yes" xml:space="preserve">
          <source>Errors are reported as specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">将按照 &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 中指定的方式报告错误。</target>
        </trans-unit>
        <trans-unit id="7331ffbc406cc972b5f70c046e3dc2cb4171b6f9" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">报告的错误与&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;一致。</target>
        </trans-unit>
        <trans-unit id="ed0e29a499e18c343b1b41bf866f5a04007120ed" translate="yes" xml:space="preserve">
          <source>Errors are reported consistent with &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">报告的错误与 &lt;code&gt;&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; 一致。</target>
        </trans-unit>
        <trans-unit id="5864985afc7c53fae220dc47110ea05595ec5f47" translate="yes" xml:space="preserve">
          <source>Errors may be reported as specified in &lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;.</source>
          <target state="translated">可能会按照&lt;a href=&quot;../math/math_errhandling&quot;&gt;math_errhandling中&lt;/a&gt;指定的方式报告错误。</target>
        </trans-unit>
        <trans-unit id="ee99754a522541dd514fb00437ecaa5173a3680b" translate="yes" xml:space="preserve">
          <source>Errors that arise during exception handling are handled by &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;(until C++17).</source>
          <target state="translated">在异常处理期间出现的错误由 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; （直到C ++ 17）。</target>
        </trans-unit>
        <trans-unit id="b4cfe1f435f06beaae8e7d7c6d43e5dddbe640bb" translate="yes" xml:space="preserve">
          <source>Escape</source>
          <target state="translated">Escape</target>
        </trans-unit>
        <trans-unit id="aa094bf265d4ea86b5f894d7a380cedfb2baed9e" translate="yes" xml:space="preserve">
          <source>Escape sequences</source>
          <target state="translated">逃逸序列</target>
        </trans-unit>
        <trans-unit id="bd56cff3676fe902e346c447da9fdfeeaa8307a3" translate="yes" xml:space="preserve">
          <source>Escape sequences are used to represent certain special characters within &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; and &lt;a href=&quot;character_literal&quot;&gt;character literals&lt;/a&gt;.</source>
          <target state="translated">转义序列用于表示&lt;a href=&quot;string_literal&quot;&gt;字符串文字&lt;/a&gt;和&lt;a href=&quot;character_literal&quot;&gt;字符文字中的&lt;/a&gt;某些特殊字符。</target>
        </trans-unit>
        <trans-unit id="f742a88872219830426d31bbcd98064272e610fb" translate="yes" xml:space="preserve">
          <source>Essentially, &lt;code&gt;E1&lt;/code&gt; is evaluated and discarded in both cases; 2) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;data_members&quot;&gt;non-static data member&lt;/a&gt;:</source>
          <target state="translated">本质上，在两种情况下都对 &lt;code&gt;E1&lt;/code&gt; 进行评估和丢弃；2）如果 &lt;code&gt;E2&lt;/code&gt; 是一个&lt;a href=&quot;data_members&quot;&gt;非静态数据成员&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="cff4774a9f4e9cd8077ee08295f533dd38074331" translate="yes" xml:space="preserve">
          <source>Establishes &lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_weak_ordering&quot;&gt;strict weak ordering&lt;/a&gt; relation with the following properties</source>
          <target state="translated">建立具有以下特性的&lt;a href=&quot;https://en.wikipedia.org/wiki/Strict_weak_ordering&quot;&gt;严格的弱序&lt;/a&gt;关系</target>
        </trans-unit>
        <trans-unit id="852a89d52bfbfe13219c2f99e5bebf530d7e1264" translate="yes" xml:space="preserve">
          <source>Establishes &lt;a href=&quot;memory_order&quot;&gt;memory synchronization ordering&lt;/a&gt; of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, without an associated atomic operation.</source>
          <target state="translated">按照 &lt;code&gt;order&lt;/code&gt; 的指示，建立非原子访问和宽松原子访问的&lt;a href=&quot;memory_order&quot;&gt;内存同步排序&lt;/a&gt;，而没有相关的原子操作。</target>
        </trans-unit>
        <trans-unit id="f3f364090d806d3b0cee66b4e00edd9582f9bb6b" translate="yes" xml:space="preserve">
          <source>Establishes an &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;, that is, it satisfies the following properties:</source>
          <target state="translated">建立&lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;等价关系&lt;/a&gt;，即满足以下性质：</target>
        </trans-unit>
        <trans-unit id="8d058e497d38c36626918d3f0a58443807999d35" translate="yes" xml:space="preserve">
          <source>Establishes an equivalence relation. Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;x.param() == y.param()&lt;/code&gt; and future infinite sequences of values that would be generated by repeated invocations of &lt;code&gt;x(g1)&lt;/code&gt; and &lt;code&gt;y(g2)&lt;/code&gt; would be equal as long as &lt;code&gt;g1 == g2&lt;/code&gt;.</source>
          <target state="translated">建立对等关系。如果 &lt;code&gt;x.param() == y.param()&lt;/code&gt; 且重复调用 &lt;code&gt;x(g1)&lt;/code&gt; 和 &lt;code&gt;y(g2)&lt;/code&gt; 会生成的将来的无限值序列等于 &lt;code&gt;g1 == g2&lt;/code&gt; 则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="224e99f2262d85ee9bdcb40ff75322e28286d665" translate="yes" xml:space="preserve">
          <source>Establishes an exception handler around the body of a function.</source>
          <target state="translated">在函数的主体周围建立一个异常处理程序。</target>
        </trans-unit>
        <trans-unit id="2c8128bfda4d0efc1187706eb75c4af98c699f3e" translate="yes" xml:space="preserve">
          <source>Establishes equivalence relationship with the following properties</source>
          <target state="translated">建立具有以下属性的等价关系。</target>
        </trans-unit>
        <trans-unit id="a0a813deb9e43ef1c13a8996290d00b720e38940" translate="yes" xml:space="preserve">
          <source>Establishes memory synchronization ordering of non-atomic and relaxed atomic accesses, as instructed by &lt;code&gt;order&lt;/code&gt;, between a thread and a signal handler executed on the same thread. This is equivalent to &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt;, except no CPU instructions for memory ordering are issued. Only reordering of the instructions by the compiler is suppressed as &lt;code&gt;order&lt;/code&gt; instructs. For example, a fence with release semantics prevents reads or writes from being moved past subsequent writes and a fence with acquire semantics prevents reads or writes from being moved ahead of preceding reads.</source>
          <target state="translated">按照 &lt;code&gt;order&lt;/code&gt; 的指示，在线程和在同一线程上执行的信号处理程序之间建立非原子访问和宽松原子访问的内存同步排序。这等效于 &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; ，除了没有发出用于内存排序的CPU指令外。只有重新排序的编译器指令被抑制 &lt;code&gt;order&lt;/code&gt; 指示。例如，具有释放语义的篱笆可防止将读取或写入移动到后续写入之后，而具有获取语义的篱笆可防止将读取或写入移动到先前读取之前。</target>
        </trans-unit>
        <trans-unit id="557e271e8a3a0cf9ee786e9ab59e8bf077dde9c7" translate="yes" xml:space="preserve">
          <source>Estimates the number of characters available for input in the associated character sequence. &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; is guaranteed not to return &lt;code&gt;Traits::eof()&lt;/code&gt; or throw an exception until at least that many characters are extracted.</source>
          <target state="translated">估计在相关字符序列中可用于输入的字符数。保证 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 至少在提取到许多字符之前，不返回 &lt;code&gt;Traits::eof()&lt;/code&gt; 或引发异常。</target>
        </trans-unit>
        <trans-unit id="5ad645d0b6cf4e8f2f0f5a5463bf7ca6f9950d22" translate="yes" xml:space="preserve">
          <source>Euclidean norm</source>
          <target state="translated">欧几里得法则</target>
        </trans-unit>
        <trans-unit id="da7594d31984baf99a077013f0aee618827920d2" translate="yes" xml:space="preserve">
          <source>Evaluation order and sequencing</source>
          <target state="translated">评价顺序和排序</target>
        </trans-unit>
        <trans-unit id="f6b2d28039057e6a76561c58410eb4f016c0728f" translate="yes" xml:space="preserve">
          <source>Even before allocator support was removed from &lt;code&gt;std::function&lt;/code&gt; in C++17, these assignment operators use the default allocator rather than the allocator of &lt;code&gt;*this&lt;/code&gt; or the allocator of &lt;code&gt;other&lt;/code&gt; (see &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-closed.html#2386&quot;&gt;LWG #2386&lt;/a&gt;).</source>
          <target state="translated">甚至在从C ++ 17中的 &lt;code&gt;std::function&lt;/code&gt; 删除分配器支持之前，这些分配操作符都使用默认分配器，而不是 &lt;code&gt;*this&lt;/code&gt; 或 &lt;code&gt;other&lt;/code&gt; 分配器（请参阅&lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/lwg-closed.html#2386&quot;&gt;LWG＃2386&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="5bf28a5cb25e295e74fa193c881e4823ae53ebb2" translate="yes" xml:space="preserve">
          <source>Even if &lt;code&gt;ymd.ok()&lt;/code&gt; is true, the resulting &lt;code&gt;year_month_day&lt;/code&gt; may not represent a valid date if &lt;code&gt;ymd.day()&lt;/code&gt; is 29, 30, or 31.</source>
          <target state="translated">即使 &lt;code&gt;ymd.ok()&lt;/code&gt; 为true，如果 &lt;code&gt;ymd.day()&lt;/code&gt; 为29、30或31 ，则所得的 &lt;code&gt;year_month_day&lt;/code&gt; 可能也不表示有效日期。</target>
        </trans-unit>
        <trans-unit id="13f714ec21c59f4555ffdd439f65ba1de4339a70" translate="yes" xml:space="preserve">
          <source>Even if &lt;code&gt;ymwd.ok()&lt;/code&gt; is true, the resulting &lt;code&gt;year_month_weekday&lt;/code&gt; may not represent a valid date if &lt;code&gt;ymwd.index()&lt;/code&gt; is 5.</source>
          <target state="translated">即使 &lt;code&gt;ymwd.ok()&lt;/code&gt; 为true，如果 &lt;code&gt;ymwd.index()&lt;/code&gt; 为5 ，则所得的 &lt;code&gt;year_month_weekday&lt;/code&gt; 可能也不表示有效日期。</target>
        </trans-unit>
        <trans-unit id="d9c13458a40bd815f989f602ad0395796fb458d9" translate="yes" xml:space="preserve">
          <source>Even if notified under lock, overload (1) makes no guarantees about the state of the associated predicate when returning due to timeout.</source>
          <target state="translated">即使在锁的情况下通知,过载(1)也不保证由于超时而返回时相关谓词的状态。</target>
        </trans-unit>
        <trans-unit id="e8a756d7fa529afd7aeb13d1511bd134a3d2cc0c" translate="yes" xml:space="preserve">
          <source>Even if the clock in use is &lt;code&gt;&lt;a href=&quot;../../chrono/steady_clock&quot;&gt;std::chrono::steady_clock&lt;/a&gt;&lt;/code&gt; or another monotonic clock, a system clock adjustment may induce a spurious wakeup.</source>
          <target state="translated">即使使用的时钟是 &lt;code&gt;&lt;a href=&quot;../../chrono/steady_clock&quot;&gt;std::chrono::steady_clock&lt;/a&gt;&lt;/code&gt; 或其他单调时钟，系统时钟调整也可能会导致虚假唤醒。</target>
        </trans-unit>
        <trans-unit id="30fbd007da85ebd7312535e0cc529833d2a4d4fe" translate="yes" xml:space="preserve">
          <source>Even if the name to the left of &lt;code&gt;::&lt;/code&gt; refers to a namespace, the template disambiguator is allowed:</source>
          <target state="translated">即使 &lt;code&gt;::&lt;/code&gt; 左侧的名称引用一个名称空间，也可以使用模板歧义消除器：</target>
        </trans-unit>
        <trans-unit id="82ac5cb6cfab85d924b4733697e77158a0419204" translate="yes" xml:space="preserve">
          <source>Even if the shared variable is atomic, it must be modified under the mutex in order to correctly publish the modification to the waiting thread.</source>
          <target state="translated">即使共享变量是原子的,也必须在mutex下进行修改,才能正确地将修改发布到等待的线程中。</target>
        </trans-unit>
        <trans-unit id="4d9633b8291e518788e5b04c3307f8044e23b7cb" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;%c&lt;/code&gt; expects &lt;code&gt;int&lt;/code&gt; argument, it is safe to pass a &lt;code&gt;char&lt;/code&gt; because of the integer promotion that takes place when a variadic function is called.</source>
          <target state="translated">即使 &lt;code&gt;%c&lt;/code&gt; 期望使用 &lt;code&gt;int&lt;/code&gt; 参数，也可以安全地传递 &lt;code&gt;char&lt;/code&gt; ,因为调用可变参数函数时会发生整数提升。</target>
        </trans-unit>
        <trans-unit id="eef899288103457cb2c6536cbb280b5cca3eb991" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;if&lt;/code&gt; is a &lt;a href=&quot;../../keywords/if&quot;&gt;keyword&lt;/a&gt; in C++, it is a ud-suffix of the &lt;a href=&quot;../../language/user_literal&quot;&gt;literal operator&lt;/a&gt; of the form &lt;code&gt;operator &quot;&quot;if&lt;/code&gt; and in the literal expressions such as &lt;code&gt;1if&lt;/code&gt; or &lt;code&gt;1.0if&lt;/code&gt; because it is not separated by whitespace and is not a standalone token.</source>
          <target state="translated">即使 &lt;code&gt;if&lt;/code&gt; 在C ++中是&lt;a href=&quot;../../keywords/if&quot;&gt;关键字&lt;/a&gt;，它也是形式 &lt;code&gt;operator &quot;&quot;if&lt;/code&gt; 以及诸如 &lt;code&gt;1if&lt;/code&gt; 或 &lt;code&gt;1.0if&lt;/code&gt; 之类的文字表达式中&lt;a href=&quot;../../language/user_literal&quot;&gt;文字运算符&lt;/a&gt;的ud后缀，因为它没有用空格分隔并且不是独立的标记。</target>
        </trans-unit>
        <trans-unit id="205833ef6be0b707c638302ab3b276a23d851ced" translate="yes" xml:space="preserve">
          <source>Even though &lt;code&gt;try&lt;/code&gt; blocks are allowed in constexpr functions, throwing exceptions is still disallowed in a constant expression.</source>
          <target state="translated">即使constexpr函数中允许使用 &lt;code&gt;try&lt;/code&gt; 块，但在常量表达式中仍不允许抛出异常。</target>
        </trans-unit>
        <trans-unit id="beca8aa735200901df75e963c1c548f38fd8410f" translate="yes" xml:space="preserve">
          <source>Even though destructors are not inherited, if a base class declares its destructor &lt;code&gt;virtual&lt;/code&gt;, the derived destructor always overrides it. This makes it possible to delete dynamically allocated objects of polymorphic type through pointers to base.</source>
          <target state="translated">即使不继承析构函数，但如果基类将其析构函数声明为 &lt;code&gt;virtual&lt;/code&gt; ，则派生的析构函数始终会覆盖它。这样就可以通过指向base的指针删除动态分配的多态类型的对象。</target>
        </trans-unit>
        <trans-unit id="fd583cbe0ab59fe4a28f57f7cb504c86fd58cbce" translate="yes" xml:space="preserve">
          <source>Even though names in an unnamed namespace may be declared with external linkage, they are never accessible from other translation units because their namespace name is unique.</source>
          <target state="translated">即使未命名命名空间中的名称可以用外部链接来声明,但由于其命名空间名称是唯一的,因此它们永远无法从其他翻译单元访问。</target>
        </trans-unit>
        <trans-unit id="89f989b918b3efa1509410878202d64feeaad6c7" translate="yes" xml:space="preserve">
          <source>Even though the non-allocating placement new (9,10) cannot be replaced, a function with the same signature may be defined at class scope as described above. In addition, global overloads that look like placement new but take a non-void pointer type as the second argument are allowed, so the code that wants to ensure that the true placement new is called (e.g. &lt;code&gt;&lt;a href=&quot;../allocator/construct&quot;&gt;std::allocator::construct&lt;/a&gt;&lt;/code&gt;), must use &lt;code&gt;::new&lt;/code&gt; and also cast the pointer to &lt;code&gt;void*&lt;/code&gt;.</source>
          <target state="translated">即使不能替换非分配位置new（9,10），也可以如上所述在类范围内定义具有相同签名的函数。另外，允许看起来像placement new的全局重载，但是将非空指针类型作为第二个参数，因此要确保调用真正的new new的代码（例如 &lt;code&gt;&lt;a href=&quot;../allocator/construct&quot;&gt;std::allocator::construct&lt;/a&gt;&lt;/code&gt; ），必须使用 &lt;code&gt;::new&lt;/code&gt; ,并且还将指针转换为 &lt;code&gt;void*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f76a45b89412fbbe4ac41ff04a11f89153e89cd3" translate="yes" xml:space="preserve">
          <source>Even though top-level &lt;a href=&quot;cv&quot;&gt;cv-qualifiers&lt;/a&gt; on the parameters are discarded in function declarations, they modify the type of the parameter as visible in the body of a function:</source>
          <target state="translated">即使参数上的顶级&lt;a href=&quot;cv&quot;&gt;cv限定词&lt;/a&gt;在函数声明中被丢弃，它们也会修改参数的类型，使其在函数主体中可见：</target>
        </trans-unit>
        <trans-unit id="a45dfe469d18cb059aef8c5b79aaf3c568df5677" translate="yes" xml:space="preserve">
          <source>Even when the destructor is called directly (e.g. &lt;code&gt;obj.~Foo();&lt;/code&gt;), the return statement in &lt;code&gt;~Foo()&lt;/code&gt; does not return control to the caller immediately: it calls all those member and base destructors first.</source>
          <target state="translated">（例如，即使在析构函数直接调用 &lt;code&gt;obj.~Foo();&lt;/code&gt; ），在return语句 &lt;code&gt;~Foo()&lt;/code&gt; 不返回控制，立即调用者：它首先调用所有成员和基地的析构函数。</target>
        </trans-unit>
        <trans-unit id="c457cc0cca53f5efaec11bdae6464c7a8f3d1683" translate="yes" xml:space="preserve">
          <source>Even with relaxed memory model, out-of-thin-air values are not allowed to circularly depend on their own computations, for example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">即使使用宽松的内存模型，也不允许空中值循环地依赖于它们自己的计算，例如 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 最初为零，</target>
        </trans-unit>
        <trans-unit id="0d294028b66fc033fb8f8b33345165f1b149cdc7" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;objects&quot;&gt;object&lt;/a&gt; and &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; has a</source>
          <target state="translated">每个&lt;a href=&quot;objects&quot;&gt;对象&lt;/a&gt;和&lt;a href=&quot;reference&quot;&gt;引用&lt;/a&gt;都有一个</target>
        </trans-unit>
        <trans-unit id="1e3d5eff0d465c69879e0e0871021f12c2fae6c2" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; is parametrized by one or more template parameters, indicated in the parameter-list of the template declaration syntax:</source>
          <target state="translated">每个&lt;a href=&quot;templates&quot;&gt;模板&lt;/a&gt;都由一个或多个模板参数设置参数，这些参数在模板声明语法的参数列表中指示：</target>
        </trans-unit>
        <trans-unit id="9a47d9aa16911998ba8cb56b9196661886621057" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;type-id&quot;&gt;object type&lt;/a&gt; has the property called</source>
          <target state="translated">每个&lt;a href=&quot;type-id&quot;&gt;对象类型&lt;/a&gt;都有一个称为</target>
        </trans-unit>
        <trans-unit id="d4c1d197b0b4ce5bf0d47347c3c212d7928dae9a" translate="yes" xml:space="preserve">
          <source>Every call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; freezes the stream to preserve the validity of the pointer it returns. To allow the destructor to deallocate the buffer, &lt;code&gt;freeze(false)&lt;/code&gt; needs to be called explicitly.</source>
          <target state="translated">每次对 &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; 的调用都会冻结流，以保留其返回的指针的有效性。为了允许析构函数释放缓冲区，需要显式调用 &lt;code&gt;freeze(false)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="267f5eca029a0473ad86866143a283d6e67dc0cd" translate="yes" xml:space="preserve">
          <source>Every catch-clause in the function-try-block for a constructor must terminate by throwing an exception. If the control reaches the end of such handler, the current exception is automatically rethrown as if by &lt;code&gt;throw;&lt;/code&gt;. The return statement is not allowed in any catch clause of a constructor's function-try-block.</source>
          <target state="translated">构造函数的function-try-block中的每个子句都必须通过引发异常来终止。如果控件到达此类处理程序的末尾，则将自动 &lt;code&gt;throw;&lt;/code&gt; 当前异常，就像抛出该异常一样；否则，抛出异常。。构造函数的function-try-block的任何catch子句均不允许return语句。</target>
        </trans-unit>
        <trans-unit id="40c918ca9b8fb74eddbf2e3635eb193312898d9a" translate="yes" xml:space="preserve">
          <source>Every character &lt;code&gt;c&lt;/code&gt; obtained in Stage 1, other than the decimal point &lt;code&gt;'.'&lt;/code&gt;, is converted to &lt;code&gt;CharT&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).widen(c)&lt;/code&gt;.</source>
          <target state="translated">在阶段1中获得的每个字符 &lt;code&gt;c&lt;/code&gt; (小数点 &lt;code&gt;'.'&lt;/code&gt; 除外）通过调用 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).widen(c)&lt;/code&gt; &amp;lt; &lt;a href=&quot;../ctype&quot;&gt;std :: ctype&lt;/a&gt; &amp;lt;CharT &amp;gt;&amp;gt;（str.getloc（））。widen（c）将转换为 &lt;code&gt;CharT&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55240b46d1b2c778147a32f69f02140623223676" translate="yes" xml:space="preserve">
          <source>Every copy assignment operator is &lt;a href=&quot;../language/as_operator#Trivial_copy_assignment_operator&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">每个副本分配运算符都很&lt;a href=&quot;../language/as_operator#Trivial_copy_assignment_operator&quot;&gt;简单&lt;/a&gt;或已删除</target>
        </trans-unit>
        <trans-unit id="44ece2209b7a05d39c75b1dcbb965646849a11d9" translate="yes" xml:space="preserve">
          <source>Every copy constructor is &lt;a href=&quot;../language/copy_constructor#Trivial_copy_constructor&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">每个副本构造函数都是&lt;a href=&quot;../language/copy_constructor#Trivial_copy_constructor&quot;&gt;琐碎的&lt;/a&gt;或已删除的</target>
        </trans-unit>
        <trans-unit id="ddca33bae1f5063131bf99b04d54385eb0d2361a" translate="yes" xml:space="preserve">
          <source>Every coroutine must have a return type that satisfies a number of requirements, noted below.</source>
          <target state="translated">每一个coroutine必须有一个满足一系列要求的返回类型,如下所述。</target>
        </trans-unit>
        <trans-unit id="6f0b1e2abf2c7b435c80221dcc61afd569006cf6" translate="yes" xml:space="preserve">
          <source>Every direct base of &lt;code&gt;T&lt;/code&gt; has a trivial default constructor</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 的每个直接基都有一个琐碎的默认构造函数</target>
        </trans-unit>
        <trans-unit id="e4f4a9e39d552d4d3b8434b290840e0cb2a72f79" translate="yes" xml:space="preserve">
          <source>Every expression required to be equality preserving is further required to be</source>
          <target state="translated">每一个被要求保持平等的表达式都被进一步要求是</target>
        </trans-unit>
        <trans-unit id="596cadab563dc077013bb82171b4d411422fe26e" translate="yes" xml:space="preserve">
          <source>Every function in C++ is either</source>
          <target state="translated">在C++中,每个函数要么是</target>
        </trans-unit>
        <trans-unit id="2e5a037bddcba35d74d8f0e90f7f426c42f8bbb7" translate="yes" xml:space="preserve">
          <source>Every function type, every function name with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, and every variable name with &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt;, has a property called</source>
          <target state="translated">每个函数类型，每个具有&lt;a href=&quot;storage_duration&quot;&gt;外部链接的&lt;/a&gt;函数名称以及每个具有&lt;a href=&quot;storage_duration&quot;&gt;外部链接的&lt;/a&gt;变量名称都具有一个称为</target>
        </trans-unit>
        <trans-unit id="9220204e7dd00c7e1b3f8ea123e9b7a6432dc43a" translate="yes" xml:space="preserve">
          <source>Every initializer clause is &lt;a href=&quot;eval_order&quot;&gt;sequenced before&lt;/a&gt; any initializer clause that follows it in the braced-init-list. This is in contrast with the arguments of a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function call expression&lt;/a&gt;, which are &lt;a href=&quot;eval_order&quot;&gt;unsequenced&lt;/a&gt;.</source>
          <target state="translated">每个初始化程序子句在braced-init-list中的后面都有任何初始化程序子句&lt;a href=&quot;eval_order&quot;&gt;之前&lt;/a&gt;。这与一个的参数对比度&lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;函数调用表达式&lt;/a&gt;，其是&lt;a href=&quot;eval_order&quot;&gt;未测序&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e6ec13c0519794ea073e3092993cf4c79e0a531c" translate="yes" xml:space="preserve">
          <source>Every move assignment operator is &lt;a href=&quot;../language/move_operator#Trivial_move_assignment_operator&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">每个移动分配运算符都很&lt;a href=&quot;../language/move_operator#Trivial_move_assignment_operator&quot;&gt;简单&lt;/a&gt;或已删除</target>
        </trans-unit>
        <trans-unit id="be04d7a82c5aad5c68ef07fc699cbbb387d1c3f3" translate="yes" xml:space="preserve">
          <source>Every move constructor is &lt;a href=&quot;../language/move_constructor#Trivial_move_constructor&quot;&gt;trivial&lt;/a&gt; or deleted</source>
          <target state="translated">每个move构造函数都是&lt;a href=&quot;../language/move_constructor#Trivial_move_constructor&quot;&gt;微不足道的&lt;/a&gt;或已删除</target>
        </trans-unit>
        <trans-unit id="cec5230f04de71fff49fd937f9a018fd570d7a46" translate="yes" xml:space="preserve">
          <source>Every name that denotes an entity is introduced into the program by a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;. Every name that denotes a label is introduced into the program either by a &lt;a href=&quot;goto&quot;&gt;goto statement&lt;/a&gt; or by a &lt;a href=&quot;statements#Labels&quot;&gt;labeled statement&lt;/a&gt;. A name used in more than one translation unit may refer to the same or different entities, depending on &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt;.</source>
          <target state="translated">表示实体的每个名称都通过&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;引入程序中。每个表示标签的名称都会通过&lt;a href=&quot;goto&quot;&gt;goto语句&lt;/a&gt;或带&lt;a href=&quot;statements#Labels&quot;&gt;标签的语句&lt;/a&gt;引入程序。取决于&lt;a href=&quot;storage_duration#Linkage&quot;&gt;链接&lt;/a&gt;，一个以上翻译单元中使用的名称可以指相同或不同的实体。</target>
        </trans-unit>
        <trans-unit id="b69a8648e61c5f2cb090d5c8ee69368fecb775bd" translate="yes" xml:space="preserve">
          <source>Every non-static data member of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; must be a direct member of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; or the same base class of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;, and must be well-formed in the context of the structured binding when named as &lt;code&gt;&lt;i&gt;&lt;b&gt;e&lt;/b&gt;&lt;/i&gt;.&lt;i&gt;name&lt;/i&gt;&lt;/code&gt;. &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; may not have an anonymous union member. The number of identifiers must equal the number of non-static data members.</source>
          <target state="translated">的每个非静态数据成员 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 必须是直接成员 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 或相同的基类的 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; ，并且必须很好地形成，在的情况下的结构命名为当结合 &lt;code&gt;&lt;i&gt;&lt;b&gt;e&lt;/b&gt;&lt;/i&gt;.&lt;i&gt;name&lt;/i&gt;&lt;/code&gt; 。 &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; 可能没有匿名工会成员。标识符的数量必须等于非静态数据成员的数量。</target>
        </trans-unit>
        <trans-unit id="b87d3e4870484b5764d76023f3269d280331e5c7" translate="yes" xml:space="preserve">
          <source>Every non-static member of class type has a trivial default constructor</source>
          <target state="translated">类类型的每个非静态成员都有一个微不足道的默认构造函数。</target>
        </trans-unit>
        <trans-unit id="2ce1bf1bc0be1980d77a06eeb4de4b342c337db3" translate="yes" xml:space="preserve">
          <source>Every standard library component that may need to allocate or release storage, from &lt;code&gt;std::string&lt;/code&gt;, &lt;code&gt;std::vector&lt;/code&gt;, and every container except &lt;code&gt;std::array&lt;/code&gt;, to &lt;code&gt;std::shared_ptr&lt;/code&gt; and &lt;code&gt;std::function&lt;/code&gt;, does so through an &lt;strong&gt;Allocator&lt;/strong&gt;: an object of a class type that satisfies the following requirements.</source>
          <target state="translated">从 &lt;code&gt;std::string&lt;/code&gt; ， &lt;code&gt;std::vector&lt;/code&gt; 以及除 &lt;code&gt;std::array&lt;/code&gt; 之外的每个容器到 &lt;code&gt;std::shared_ptr&lt;/code&gt; 和 &lt;code&gt;std::function&lt;/code&gt; 每个容器，可能需要分配或释放存储的每个标准库组件都通过&lt;strong&gt;Allocator&lt;/strong&gt;这样做：满足以下要求的类类型的对象。</target>
        </trans-unit>
        <trans-unit id="2cf1b35b018fe1d430f2ed7ed9345dcf2146ab69" translate="yes" xml:space="preserve">
          <source>Every stream I/O function if an exception is thrown by any member function of the associated stream buffer (e.g. sbumpc(), xsputn(), sgetc(), overflow(), etc)</source>
          <target state="translated">每一个流I/O函数,如果关联的流缓冲区的任何成员函数(例如:sbumpc()、xsputn()、sgetc()、overflow()等)抛出了一个异常</target>
        </trans-unit>
        <trans-unit id="b09575dd9bf238348e1eb74acc65642a4f28513f" translate="yes" xml:space="preserve">
          <source>Every successive character &lt;code&gt;c&lt;/code&gt; from the sequence of CharT's from Stage 3 is output as if by &lt;code&gt;*out++ = c&lt;/code&gt;.</source>
          <target state="translated">来自第3阶段的CharT序列中的每个连续字符 &lt;code&gt;c&lt;/code&gt; 都将被输出，就像 &lt;code&gt;*out++ = c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fa77f47a69b4e10cfca826c1e3a0f4dc9c68af3b" translate="yes" xml:space="preserve">
          <source>Every value of pointer type is one of the following:</source>
          <target state="translated">指针类型的每个值都是下面的一种。</target>
        </trans-unit>
        <trans-unit id="2711daf557af7651a60993264c29beb1d7e39e00" translate="yes" xml:space="preserve">
          <source>Everything about the actual allocation details of bit fields within the class object</source>
          <target state="translated">一切关于类对象内的位字段的实际分配细节。</target>
        </trans-unit>
        <trans-unit id="17a1a39f3910e68bd1f80c1b610bdc32df68bf11" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, equivalence is determined by using the equivalence relation as described on &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">到处标准库使用&lt;a href=&quot;../named_req/compare&quot;&gt;比较&lt;/a&gt;要求，等价通过使用如上所述的等价关系确定的&lt;a href=&quot;../named_req/compare&quot;&gt;比较&lt;/a&gt;。用不精确的术语来说，如果两个对象 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的比较值都不小于另一个，则视为 &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b75c2f9b6cdfbe488daafdef876670cbfaba7ec" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent (not unique) if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">标准库在所有使用&lt;a href=&quot;../named_req/compare&quot;&gt;比较&lt;/a&gt;要求的地方，唯一性都是通过等价关系确定的。用不精确的术语来说，如果两个对象 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的比较值都不小于另一个，则认为它们是等效的（不是唯一的） &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b615d029d5b8025e266ba5a37f8108df4dbd2078" translate="yes" xml:space="preserve">
          <source>Everywhere the standard library uses the &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; requirements, uniqueness is determined by using the equivalence relation. In imprecise terms, two objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equivalent if neither compares less than the other: &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt;.</source>
          <target state="translated">标准库在所有使用&lt;a href=&quot;../named_req/compare&quot;&gt;比较&lt;/a&gt;要求的地方，唯一性都是通过等价关系确定的。用不精确的术语来说，如果两个对象 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的比较值都不小于另一个，则视为 &lt;code&gt;!comp(a, b) &amp;amp;&amp;amp;&amp;nbsp;!comp(b, a)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cae74747ce921ce4dc2761826efeaa22990fc6f" translate="yes" xml:space="preserve">
          <source>Exact</source>
          <target state="translated">Exact</target>
        </trans-unit>
        <trans-unit id="b73dce3ae50ecab687b47c8e8958379cbaf57ff0" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;(last - first) - 1&lt;/code&gt; applications of the binary operation.</source>
          <target state="translated">确切地 &lt;code&gt;(last - first) - 1&lt;/code&gt; 二进制操作的应用程序。</target>
        </trans-unit>
        <trans-unit id="4db39051f1f33d287e9bf44fd101eccfd97335d2" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;(last - first)/2&lt;/code&gt; swaps.</source>
          <target state="translated">恰好 &lt;code&gt;(last - first)/2&lt;/code&gt; 交换。</target>
        </trans-unit>
        <trans-unit id="999c7ba21fe6cfdf477efe576e8b30044ac5b242" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">谓词的完全 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 应用程序。</target>
        </trans-unit>
        <trans-unit id="1fc8a6d486ec5aab15a1c1be51264f79f56fc49b" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; invocations of &lt;code&gt;g()&lt;/code&gt; and assignments.</source>
          <target state="translated">精确地调用 &lt;code&gt;g()&lt;/code&gt; 和赋值的 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="35529081f2f26b1b90fd973935838e5852bc467d" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; assignments, for &lt;code&gt;count &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">精确 &lt;code&gt;count&lt;/code&gt; 分配， &lt;code&gt;count &amp;gt; 0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5a8809cf33804ae021cd515fa06675d07f185d82" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; assignments, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;count&amp;gt;0&lt;/code&gt; ，则精确 &lt;code&gt;count&lt;/code&gt; 分配。</target>
        </trans-unit>
        <trans-unit id="f0e851801f10602f0a4225377722df5cf5583ba1" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;count&lt;/code&gt; invocations of &lt;code&gt;g()&lt;/code&gt; and assignments, for &lt;code&gt;count&amp;gt;0&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;count&amp;gt;0&lt;/code&gt; ，精确 &lt;code&gt;count&lt;/code&gt; &lt;code&gt;g()&lt;/code&gt; 和赋值的调用。</target>
        </trans-unit>
        <trans-unit id="9e8a97940b9961f72ad69126c982a5fb916192e8" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;distance(first, last)&lt;/code&gt; applications of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 的精确 &lt;code&gt;distance(first, last)&lt;/code&gt; 应用程序。</target>
        </trans-unit>
        <trans-unit id="664be72d77dd1a490f0db6001689b115d6a6b71a" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">恰好 &lt;code&gt;last - first&lt;/code&gt; 谓词的第一个应用。</target>
        </trans-unit>
        <trans-unit id="7e7f4d09b4ff46a04df0991518050618d9d2f7b5" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; assignments.</source>
          <target state="translated">恰好是 &lt;code&gt;last - first&lt;/code&gt; 作业。</target>
        </trans-unit>
        <trans-unit id="b25aeebe72d8f421614fa0ad0873495e44259427" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; increments and assignments.</source>
          <target state="translated">恰好在 &lt;code&gt;last - first&lt;/code&gt; 增量和分配。</target>
        </trans-unit>
        <trans-unit id="dd0f4944e44dc9fa8a6fa7891d44439f219ac35c" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last - first&lt;/code&gt; move assignments.</source>
          <target state="translated">恰好是 &lt;code&gt;last - first&lt;/code&gt; 动任务。</target>
        </trans-unit>
        <trans-unit id="64786764c6cc4f57b36277db2d8d6df02d730d57" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; applications of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">究竟 &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; 的应用 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fd8d57c8139bdfd24f5d36db13c1c858637e062" translate="yes" xml:space="preserve">
          <source>Exactly &lt;code&gt;n&lt;/code&gt; applications of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">究竟 &lt;code&gt;n&lt;/code&gt; 应用 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="aabf3a891f0ec18e0d36466fa6f0c9ce5485153e" translate="yes" xml:space="preserve">
          <source>Exactly max(N-1,0) comparisons, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">完全是max（N-1,0）个比较，其中 &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99195733fda66fedc7bf44e9446fa1cb19801072" translate="yes" xml:space="preserve">
          <source>Exactly one of &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt;, &lt;code&gt;bool(a &amp;gt; b)&lt;/code&gt; and &lt;code&gt;bool(a == b)&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">正好一个 &lt;code&gt;bool(a &amp;lt; b)&lt;/code&gt; ， &lt;code&gt;bool(a &amp;gt; b)&lt;/code&gt; 和 &lt;code&gt;bool(a == b)&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="c0a2d0e4e192dcffd92f7c5fc920779a3a46eca3" translate="yes" xml:space="preserve">
          <source>Examines the filesystem object referred to by this directory entry and stores its attributes for retrieval with &lt;a href=&quot;status&quot;&gt;&lt;code&gt;status()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exists&quot;&gt;&lt;code&gt;exists()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;is_regular_file&quot;&gt;&lt;code&gt;is_regular_file()&lt;/code&gt;&lt;/a&gt;, and other status accessors.</source>
          <target state="translated">检查文件系统对象称为由这个目录条目，并且存储其属性进行检索与&lt;a href=&quot;status&quot;&gt; &lt;code&gt;status()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;exists&quot;&gt; &lt;code&gt;exists()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;is_regular_file&quot;&gt; &lt;code&gt;is_regular_file()&lt;/code&gt; &lt;/a&gt;，和其他状态的存取。</target>
        </trans-unit>
        <trans-unit id="d9b9f013ab46e72d63d24bb4f00288b2d9847138" translate="yes" xml:space="preserve">
          <source>Examines the partitioned (as if by &lt;code&gt;&lt;a href=&quot;partition&quot;&gt;std::partition&lt;/a&gt;&lt;/code&gt;) range &lt;code&gt;[first, last)&lt;/code&gt; and locates the end of the first partition, that is, the first element that does not satisfy &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; if all elements satisfy &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">检查分区范围（好像通过 &lt;code&gt;&lt;a href=&quot;partition&quot;&gt;std::partition&lt;/a&gt;&lt;/code&gt; ） &lt;code&gt;[first, last)&lt;/code&gt; 并找到第一个分区的末尾，即不满足 &lt;code&gt;p&lt;/code&gt; 的第一个元素，或者如果所有元素都满足 &lt;code&gt;p&lt;/code&gt; 的情况则为 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcb284168678a0919d196ddf44691afe02c5f4b3" translate="yes" xml:space="preserve">
          <source>Examines the range &lt;code&gt;[first, last)&lt;/code&gt; and finds the largest range beginning at &lt;code&gt;first&lt;/code&gt; in which the elements are sorted in ascending order.</source>
          <target state="translated">检查范围 &lt;code&gt;[first, last)&lt;/code&gt; ，发现在大范围内开始 &lt;code&gt;first&lt;/code&gt; 在该元素按升序排序。</target>
        </trans-unit>
        <trans-unit id="0a9b4d7926393a3c0dd8eb8f3c42a7ab58af6b22" translate="yes" xml:space="preserve">
          <source>Examines the range &lt;code&gt;[first, last)&lt;/code&gt; and finds the largest range beginning at &lt;code&gt;first&lt;/code&gt; which is a</source>
          <target state="translated">检查范围 &lt;code&gt;[first, last)&lt;/code&gt; 并找到从 &lt;code&gt;first&lt;/code&gt; 一个开始的最大范围，即</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="bd9e11c33e704e33e3cee607c8252cdbbcd8a124" translate="yes" xml:space="preserve">
          <source>Example With Custom Comparator</source>
          <target state="translated">例子与自定义比较器</target>
        </trans-unit>
        <trans-unit id="ab4f744b89a1cf5abcd9dceb291ddd3e9f741894" translate="yes" xml:space="preserve">
          <source>Example from &lt;a href=&quot;http://www.gotw.ca/gotw/030.htm&quot;&gt;http://www.gotw.ca/gotw/030.htm&lt;/a&gt;.</source>
          <target state="translated">来自&lt;a href=&quot;http://www.gotw.ca/gotw/030.htm&quot;&gt;http://www.gotw.ca/gotw/030.htm的&lt;/a&gt;示例。</target>
        </trans-unit>
        <trans-unit id="e251b366d1e0802c0331ec415628df8aa911103c" translate="yes" xml:space="preserve">
          <source>Example output on one of the implementations.</source>
          <target state="translated">其中一个实施例的输出。</target>
        </trans-unit>
        <trans-unit id="ea1fb9b04a44f008daf87c7d9f9e133ac9bce209" translate="yes" xml:space="preserve">
          <source>Example using a custom comparison function</source>
          <target state="translated">使用自定义比较函数的例子</target>
        </trans-unit>
        <trans-unit id="db0a68cbf7c526f2a972b13383c59c76ca98c33e" translate="yes" xml:space="preserve">
          <source>Example with vectors :</source>
          <target state="translated">例子与向量 。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="8221a0d43625eba2795f842d5c24c7c9f59b0337" translate="yes" xml:space="preserve">
          <source>Examples of &lt;code&gt;Boolean&lt;/code&gt; types include &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;::reference&lt;/code&gt;. Pointers are not &lt;code&gt;Boolean&lt;/code&gt; types.</source>
          <target state="translated">&lt;code&gt;Boolean&lt;/code&gt; 类型的示例包括 &lt;code&gt;bool&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../types/integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;::reference&lt;/code&gt; 。指针不是 &lt;code&gt;Boolean&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="d1eddcef956b054e171719c037485ba482a76be3" translate="yes" xml:space="preserve">
          <source>Examples of erasure methods are &lt;code&gt;&lt;a href=&quot;container/set/erase&quot;&gt;std::set::erase&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/vector/pop_back&quot;&gt;std::vector::pop_back&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/deque/pop_front&quot;&gt;std::deque::pop_front&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;container/map/clear&quot;&gt;std::map::clear&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">擦除方法的示例为 &lt;code&gt;&lt;a href=&quot;container/set/erase&quot;&gt;std::set::erase&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;container/vector/pop_back&quot;&gt;std::vector::pop_back&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;container/deque/pop_front&quot;&gt;std::deque::pop_front&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;container/map/clear&quot;&gt;std::map::clear&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1fe47fa951fcb6357223febc9d44197fbb268fda" translate="yes" xml:space="preserve">
          <source>Examples of implementation-defined launch policies are the sync policy (execute immediately, within the async call) and the task policy (similar to async, but thread-locals are not cleared).</source>
          <target state="translated">实现定义的启动策略的例子有同步策略(立即执行,在async调用内)和任务策略(类似async,但线程locals不被清除)。</target>
        </trans-unit>
        <trans-unit id="e910df0f6bb9dfed95f71ce88f75479176c518cf" translate="yes" xml:space="preserve">
          <source>Examples of insertion methods are &lt;code&gt;&lt;a href=&quot;container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/map/emplace&quot;&gt;std::map::emplace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;container/deque/push_front&quot;&gt;std::deque::push_front&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">插入方法的示例为 &lt;code&gt;&lt;a href=&quot;container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;container/map/emplace&quot;&gt;std::map::emplace&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;container/vector/push_back&quot;&gt;std::vector::push_back&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;container/deque/push_front&quot;&gt;std::deque::push_front&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="69702eefdd99747ec1287d6c73c6d3f8f05c1292" translate="yes" xml:space="preserve">
          <source>Examples of partial specializations in the standard library include &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, which has a partial specialization for array types.</source>
          <target state="translated">标准库中部分专业化的示例包括 &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; ，它对数组类型具有部分专业化。</target>
        </trans-unit>
        <trans-unit id="a00ca19e4db47060f538e8b506c6503ac18be3b7" translate="yes" xml:space="preserve">
          <source>Except for &lt;code&gt;value_type&lt;/code&gt;, all the member types of &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; are complete types.</source>
          <target state="translated">除了 &lt;code&gt;value_type&lt;/code&gt; 之外， &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; 所有成员类型都是完整类型。</target>
        </trans-unit>
        <trans-unit id="8acd64a7d513ffba5fa93f11be47de7c9fc5c1db" translate="yes" xml:space="preserve">
          <source>Except for default argument, aligned_storage is expressible in terms of alignas:</source>
          <target state="translated">除了默认参数外,aligned_storage是可以用alignas来表示的。</target>
        </trans-unit>
        <trans-unit id="f51732ca4ed72fa4525ab38c97db1146e4d04378" translate="yes" xml:space="preserve">
          <source>Except in the constructors of &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;, negative values of &lt;code&gt;std::streamsize&lt;/code&gt; are never used.</source>
          <target state="translated">除了在构造函数 &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; ，呈负值 &lt;code&gt;std::streamsize&lt;/code&gt; 从不使用。</target>
        </trans-unit>
        <trans-unit id="d587eb69ad8f0449298a08da77269d9ca0f24406" translate="yes" xml:space="preserve">
          <source>Except that if no exception specification is explicitly provided, the exception specification is considered to be one that would be used by the implicitly-declared destructor (see below). In most cases, this is &lt;code&gt;noexcept(true)&lt;/code&gt;. Thus a throwing destructor must be explicitly declared &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">除了没有明确提供异常规范的情况以外，该异常规范被认为是隐式声明的析构函数将使用的规范（请参见下文）。在大多数情况下，这是 &lt;code&gt;noexcept(true)&lt;/code&gt; 。因此，必须将抛​​出的析构函数显式声明为 &lt;code&gt;noexcept(false)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d95da02e76b8dae287531e540c02e16d08b2978" translate="yes" xml:space="preserve">
          <source>Except that names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope, which is also the scope of both statements.</source>
          <target state="translated">除了init-statement(如果init-statement是一个声明)和condition(如果condition是一个声明)声明的名字在同一个范围内,这也是两个声明的范围。</target>
        </trans-unit>
        <trans-unit id="29967c007b524bf4d82e67020addcf8209e607a6" translate="yes" xml:space="preserve">
          <source>Except that names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope, which is also the scope of statement.</source>
          <target state="translated">除了init-statement(如果init-statement是一个声明)和condition(如果condition是一个声明)声明的名字在同一个范围内,也就是声明的范围。</target>
        </trans-unit>
        <trans-unit id="e357f711ee87c54bd0e9332d642407c850fea7c4" translate="yes" xml:space="preserve">
          <source>Except that the calls to &lt;code&gt;decay_copy&lt;/code&gt; are evaluated in the context of the caller, so that any exceptions thrown during evaluation and copying/moving of the arguments are thrown in the current thread, without starting the new thread.</source>
          <target state="translated">除了在调用者的上下文中评估对 &lt;code&gt;decay_copy&lt;/code&gt; 的调用之外，以便在评估和参数的复制/移动过程中引发的所有异常都将在当前线程中引发，而无需启动新线程。</target>
        </trans-unit>
        <trans-unit id="1eeb0a1df8df205ed68a524cbaa8c0fab4fe1d23" translate="yes" xml:space="preserve">
          <source>Except that.</source>
          <target state="translated">除了。</target>
        </trans-unit>
        <trans-unit id="f96eec6bcb0eb29fc403d27737c989d54305c3d2" translate="yes" xml:space="preserve">
          <source>Exception categories</source>
          <target state="translated">例外类别</target>
        </trans-unit>
        <trans-unit id="b4b0dfe7027c1d349ba13a7e79558e44ec341bd8" translate="yes" xml:space="preserve">
          <source>Exception handling</source>
          <target state="translated">异常处理</target>
        </trans-unit>
        <trans-unit id="2c1ebcb87ed425e2ea948b9057321bf79663c920" translate="yes" xml:space="preserve">
          <source>Exception handling provides a way of transferring control and information from some point in the execution of a program to a handler associated with a point previously passed by the execution (in other words, exception handling transfers control up the call stack).</source>
          <target state="translated">异常处理提供了一种将控制和信息从程序执行中的某一点转移到与执行之前传递的某一点相关联的处理程序的方法(换句话说,异常处理将控制权转移到调用栈上)。</target>
        </trans-unit>
        <trans-unit id="484018b13af3fa5985246c3cf1cb9a80f78a4b2e" translate="yes" xml:space="preserve">
          <source>Exception handling utilities</source>
          <target state="translated">异常处理工具</target>
        </trans-unit>
        <trans-unit id="f20b401bcfd0d6316854bd1c5be2e83c76d1de4f" translate="yes" xml:space="preserve">
          <source>Exception objects</source>
          <target state="translated">异常对象</target>
        </trans-unit>
        <trans-unit id="c178e2e0328be43fb7ba635e2d8a88fc566b2eb0" translate="yes" xml:space="preserve">
          <source>Exception of type &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; may be thrown on errors, with the following error codes:</source>
          <target state="translated">错误类型可能引发 &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 类型的异常，并带有以下错误代码：</target>
        </trans-unit>
        <trans-unit id="80d5280e70d86ad891f2b40c8ed78d7da520c6d7" translate="yes" xml:space="preserve">
          <source>Exception safety</source>
          <target state="translated">例外安全</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="860a1ec6dde884258f991928e357d615dac44a1f" translate="yes" xml:space="preserve">
          <source>Exceptions (e.g. &lt;code&gt;&lt;a href=&quot;error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;), assertions (e.g. &lt;code&gt;&lt;a href=&quot;error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">异常（例如 &lt;code&gt;&lt;a href=&quot;error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; ），断言（例如 &lt;code&gt;&lt;a href=&quot;error/assert&quot;&gt;assert&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1c85cdf1b242c92824cb3422445a6b69100c6e06" translate="yes" xml:space="preserve">
          <source>Exceptions of type &lt;code&gt;std::runtime_error&lt;/code&gt; are thrown by the following standard library components: &lt;code&gt;&lt;a href=&quot;../../locale/locale/locale&quot;&gt;std::locale::locale&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../locale/locale/combine&quot;&gt;std::locale::combine&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以下标准库组件引发 &lt;code&gt;std::runtime_error&lt;/code&gt; 类型的异常： &lt;code&gt;&lt;a href=&quot;../../locale/locale/locale&quot;&gt;std::locale::locale&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../locale/locale/combine&quot;&gt;std::locale::combine&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3655d713d676393ce50c4dfe2c15b248f391aaef" translate="yes" xml:space="preserve">
          <source>Exceptions that are thrown from member initializers may be handled by &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;.</source>
          <target state="translated">从成员初始值设定项引发的异常可以由&lt;a href=&quot;function-try-block&quot;&gt;function-try-block处理&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f3ccb3655838c7cc0f05342ca4d518865db28c05" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">交换 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;r&lt;/code&gt; 的内容。</target>
        </trans-unit>
        <trans-unit id="cf0531db840de334e816e5c677f3bd63fcd3dd1a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;</source>
          <target state="translated">交换 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的内容</target>
        </trans-unit>
        <trans-unit id="10d46d6be13fed97bcfc06d63285187114a038e8" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container adaptor with those of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c); swap(comp, other.comp);&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;other&lt;/code&gt; 适配器交换容器适配器的内容。 &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c); swap(comp, other.comp);&lt;/code&gt; &lt;a href=&quot;../../algorithm/swap&quot;&gt;std :: swap&lt;/a&gt;有效调用；swap（c，other.c）; swap（comp，other.comp）;</target>
        </trans-unit>
        <trans-unit id="3e6e9555c788d205a45c120fea2405b48de6ce8a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container adaptor with those of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c);&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;other&lt;/code&gt; 适配器交换容器适配器的内容。 &lt;code&gt;using &lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(c, other.c);&lt;/code&gt; &lt;a href=&quot;../../algorithm/swap&quot;&gt;std :: swap&lt;/a&gt;有效调用；swap（c，other.c）;</target>
        </trans-unit>
        <trans-unit id="49de04ba32b7f84cb9cd03e37185b56ecd9e1b91" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container with those of &lt;code&gt;other&lt;/code&gt;. Does not cause iterators and references to associate with the other container.</source>
          <target state="translated">与 &lt;code&gt;other&lt;/code&gt; 容器的内容交换。不会导致迭代器和引用与另一个容器关联。</target>
        </trans-unit>
        <trans-unit id="cca5e7e3ee4209e3931f1f34eaaecf8cf0a0bc6a" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the container with those of &lt;code&gt;other&lt;/code&gt;. Does not invoke any move, copy, or swap operations on individual elements.</source>
          <target state="translated">与 &lt;code&gt;other&lt;/code&gt; 容器的内容交换。不对单个元素调用任何移动，复制或交换操作。</target>
        </trans-unit>
        <trans-unit id="62bfbc4c539262880741976e01c4f02e7c1e4a00" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the stream buffer with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;other&lt;/code&gt; 交换流缓冲区的内容。</target>
        </trans-unit>
        <trans-unit id="3a6e431a73a626620ce066c3e9d4f31fda3acf08" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the string with those of &lt;code&gt;other&lt;/code&gt;. All iterators and references may be invalidated.</source>
          <target state="translated">与 &lt;code&gt;other&lt;/code&gt; 交换字符串的内容。所有迭代器和引用都可能无效。</target>
        </trans-unit>
        <trans-unit id="a091ec29303367010ecc75278a112bbcdf30230b" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of the sync stream buffer with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;other&lt;/code&gt; 交换同步流缓冲区的内容。</target>
        </trans-unit>
        <trans-unit id="6582eb59d4c7d4d4f55d78fce8cfcf8c22bc4bb7" translate="yes" xml:space="preserve">
          <source>Exchanges the contents of two regular expressions.</source>
          <target state="translated">交换两个正则表达式的内容。</target>
        </trans-unit>
        <trans-unit id="67e3c44b994c5e59c6fd36a93ede7ec7c8983289" translate="yes" xml:space="preserve">
          <source>Exchanges the given values.</source>
          <target state="translated">交换给定值。</target>
        </trans-unit>
        <trans-unit id="a2b38d8b13b6bc9e51339c32d2d13644d36846b9" translate="yes" xml:space="preserve">
          <source>Exchanges the internal states of the lock objects.</source>
          <target state="translated">交换锁对象的内部状态。</target>
        </trans-unit>
        <trans-unit id="7c072815ce7ddc6a4942335ae6ce9574b39ca082" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states and stored tasks of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">交换 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 的共享状态和存储的任务。</target>
        </trans-unit>
        <trans-unit id="8b12f471554dcab6c425a7585115003928398434" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states of two &lt;code&gt;match_results&lt;/code&gt; objects.</source>
          <target state="translated">交换两个 &lt;code&gt;match_results&lt;/code&gt; 对象的共享状态。</target>
        </trans-unit>
        <trans-unit id="59d42fecea425bb592e078023cd032e5a993fe31" translate="yes" xml:space="preserve">
          <source>Exchanges the shared states of two promise objects.</source>
          <target state="translated">交换两个承诺对象的共享状态。</target>
        </trans-unit>
        <trans-unit id="18b676510da12b57d475482111403500d0eaec7b" translate="yes" xml:space="preserve">
          <source>Exchanges the state of &lt;code&gt;lhs&lt;/code&gt; with that of &lt;code&gt;rhs&lt;/code&gt;. Effectively calls &lt;code&gt;lhs.swap(rhs)&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;rhs&lt;/code&gt; 交换 &lt;code&gt;lhs&lt;/code&gt; 的状态。有效地调用 &lt;code&gt;lhs.swap(rhs)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1b9970f1ef14caaf33f01eabd758b36bb1eff60" translate="yes" xml:space="preserve">
          <source>Exchanges the state of the stream with those of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;other&lt;/code&gt; 交换流的状态。</target>
        </trans-unit>
        <trans-unit id="31ddf92acf4cafa84669771e5848a6787348f3e4" translate="yes" xml:space="preserve">
          <source>Exchanges the state with another input/output stream object. Effectively calls &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;::swap(other)&lt;/code&gt;.</source>
          <target state="translated">与另一个输入/输出流对象交换状态。有效地调用 &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;::swap(other)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4b57df173bf97bd6ea27f8a30b30cea7df455a9" translate="yes" xml:space="preserve">
          <source>Exchanges the states of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, except for the associated &lt;code&gt;rdbuf&lt;/code&gt; objects. &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;other.rdbuf()&lt;/code&gt; returns the same values as before the call.</source>
          <target state="translated">交换 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 的状态，但关联的 &lt;code&gt;rdbuf&lt;/code&gt; 对象除外。 &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;other.rdbuf()&lt;/code&gt; 返回与调用之​​前相同的值。</target>
        </trans-unit>
        <trans-unit id="7057d033a604041b5eda100f7d1ff124d6f8a8db" translate="yes" xml:space="preserve">
          <source>Exchanges the stored callable objects of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">交换 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 的存储的可调用对象。</target>
        </trans-unit>
        <trans-unit id="d4dce99c5d1d30eb407da92e2d161ddb796ea801" translate="yes" xml:space="preserve">
          <source>Exchanges the underlying handles of two thread objects.</source>
          <target state="translated">交换两个线程对象的底层句柄。</target>
        </trans-unit>
        <trans-unit id="4bec71ee58c3ce1a623ca2ef092eecb76d6de116" translate="yes" xml:space="preserve">
          <source>Exchanges the values referenced by &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;.</source>
          <target state="translated">交换 &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;u&lt;/code&gt; 引用的值。</target>
        </trans-unit>
        <trans-unit id="9a51b1fd2363fd0ca07531efcb4dd24feaa75b80" translate="yes" xml:space="preserve">
          <source>Exchanges the view with that of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;v&lt;/code&gt; 交换视图。</target>
        </trans-unit>
        <trans-unit id="be6d66875d5906f7cae3a9398d5dbf1c7968e188" translate="yes" xml:space="preserve">
          <source>Exclusive locking</source>
          <target state="translated">独家锁定</target>
        </trans-unit>
        <trans-unit id="7f9696585c07b96ae418afaf36f528ec350cef50" translate="yes" xml:space="preserve">
          <source>Executable file format error</source>
          <target state="translated">可执行文件格式错误</target>
        </trans-unit>
        <trans-unit id="9c973cb9f93e36abf91a1e9c23f91399e854d72a" translate="yes" xml:space="preserve">
          <source>Executes a for loop over a range.</source>
          <target state="translated">在一个范围内执行for循环。</target>
        </trans-unit>
        <trans-unit id="613b116d4f4f58b27e039a622ea9cf3d90eab7e4" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of condition becomes &lt;code&gt;false&lt;/code&gt;. The test takes place before each iteration.</source>
          <target state="translated">重复执行一条语句，直到condition的值变为 &lt;code&gt;false&lt;/code&gt; 为止。该测试在每次迭代之前进行。</target>
        </trans-unit>
        <trans-unit id="fb5a19ea5e56f8a6995eea08fd4658f19b1ba739" translate="yes" xml:space="preserve">
          <source>Executes a statement repeatedly, until the value of expression becomes false. The test takes place after each iteration.</source>
          <target state="translated">反复执行语句,直到表达式的值变成false。每次迭代后都会进行测试。</target>
        </trans-unit>
        <trans-unit id="0c64270896df6b47ed0ab90cdaa2526a36293282" translate="yes" xml:space="preserve">
          <source>Executes init-statement once, then executes statement and iteration_expression repeatedly, until the value of condition becomes false. The test takes place before each iteration.</source>
          <target state="translated">执行一次init-statement,然后反复执行statement和iteration_expression,直到条件值变成false为止。在每次迭代之前,都要进行测试。</target>
        </trans-unit>
        <trans-unit id="64b4397dfd824f8172c44d1c4f9e248b16268c1c" translate="yes" xml:space="preserve">
          <source>Executes the &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; exactly once, even if called concurrently, from several threads.</source>
          <target state="translated">即使从多个线程同时&lt;a href=&quot;../named_req/callable&quot;&gt;调用&lt;/a&gt;，也仅一次执行Callable对象 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5241bfbf176faa293d6e52adf2a2d31791dc7d39" translate="yes" xml:space="preserve">
          <source>Executes the &lt;a href=&quot;statements#Compound_statements&quot;&gt;compound statement&lt;/a&gt; as if under a global lock: all outermost synchronized blocks in the program execute in a single total order. The end of each synchronized block synchronizes with the beginning of the next synchronized block in that order. Synchronized blocks that are nested within other synchronized blocks have no special semantics.</source>
          <target state="translated">就像在全局锁下一样执行&lt;a href=&quot;statements#Compound_statements&quot;&gt;复合语句&lt;/a&gt;：程序中所有最外面的同步块都以单个总顺序执行。每个同步块的末尾与该顺序的下一个同步块的开始同步。嵌套在其他同步块中的同步块没有特殊的语义。</target>
        </trans-unit>
        <trans-unit id="fb88910ec6e8f148a726def306751bb61d10e009" translate="yes" xml:space="preserve">
          <source>Executes the body of the lambda-expression, when invoked. When accessing a variable, accesses its captured copy (for the entities captured by copy), or the original object (for the entities captured by reference). Unless the keyword &lt;code&gt;mutable&lt;/code&gt; was used in the lambda-expression, the function-call operator is const-qualified and the objects that were captured by copy are non-modifiable from inside this &lt;code&gt;operator()&lt;/code&gt;. The function-call operator is never volatile-qualified and never virtual.</source>
          <target state="translated">调用时执行lambda表达式的主体。访问变量时，访问其捕获的副本（对于通过副本捕获的实体）或原始对象（对于通过引用捕获的实体）。除非在lambda-expression中使用了关键字 &lt;code&gt;mutable&lt;/code&gt; ，否则函数调用运算符将​​是const限定的，并且通过copy捕获的对象是无法从该 &lt;code&gt;operator()&lt;/code&gt; 内部进行修改的。函数调用运算符永远都不是volatile限定的，也不是虚拟的。</target>
        </trans-unit>
        <trans-unit id="6d525b71568c2d982f46feb96b332bedcdc6e4a0" translate="yes" xml:space="preserve">
          <source>Execution</source>
          <target state="translated">Execution</target>
        </trans-unit>
        <trans-unit id="de7349273ae9d07fc03da50e188f4f34b7d2aa3e" translate="yes" xml:space="preserve">
          <source>Execution policies</source>
          <target state="translated">执行政策</target>
        </trans-unit>
        <trans-unit id="881673b7fc0425b71c75a900e8dd961e60da16d7" translate="yes" xml:space="preserve">
          <source>Exhausting memory in the pool causes the next allocation request for that pool to allocate an additional chunk of memory from the</source>
          <target state="translated">池中的内存耗尽,会导致该池的下一次分配请求从</target>
        </trans-unit>
        <trans-unit id="4d3a207c682e51fd0f76ac46376bd504dd04bb4b" translate="yes" xml:space="preserve">
          <source>Existing elements of &lt;code&gt;a&lt;/code&gt; are destroyed or assigned to</source>
          <target state="translated">的现有元素 &lt;code&gt;a&lt;/code&gt; 被破坏或者被分配给</target>
        </trans-unit>
        <trans-unit id="28c764ed1d6222630406c5783a2aaab97f66bd88" translate="yes" xml:space="preserve">
          <source>Expanded value</source>
          <target state="translated">扩大的价值</target>
        </trans-unit>
        <trans-unit id="3a28add9450f041df1694bda9dbd7fe1ffe87170" translate="yes" xml:space="preserve">
          <source>Expands to an expression (not necessarily a compile-time constant) of type &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; equal to the number of clock ticks per second, as returned by &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">扩展为 &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; 类型的表达式（不一定是编译时常量），该表达式等于 &lt;code&gt;&lt;a href=&quot;clock&quot;&gt;std::clock()&lt;/a&gt;&lt;/code&gt; 返回的每秒时钟滴答数。</target>
        </trans-unit>
        <trans-unit id="a94ceb9709072dbc8a9721a63225f49eded59877" translate="yes" xml:space="preserve">
          <source>Expands to an expression which can be used to initialize an &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; object that can be initialized from &lt;code&gt;value&lt;/code&gt;. If the atomic object has static storage duration, this initialization is &lt;a href=&quot;../language/constant_initialization&quot;&gt;constant initialization&lt;/a&gt;.</source>
          <target state="translated">扩展为一个表达式，该表达式可用于初始化可以从 &lt;code&gt;value&lt;/code&gt; 初始化的 &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; 对象。如果原子对象具有静态存储持续时间，则此初始化为&lt;a href=&quot;../language/constant_initialization&quot;&gt;常量初始化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="de6a2f8e65def43ce5a852e140e79c980dade60d" translate="yes" xml:space="preserve">
          <source>Expands to an integer constant expression equal to the maximum value returned by the function &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt;. This value is implementation dependent. It's guaranteed that this value is at least &lt;code&gt;32767&lt;/code&gt;.</source>
          <target state="translated">扩展为等于函数 &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; 返回的最大值的整数常量表达式。此值取决于实现。确保该值至少为 &lt;code&gt;32767&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b74a3f6f88cbf8779ab38cebe0c4e5a1aa35bcc5" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">扩展为表示溢出的正 &lt;code&gt;double&lt;/code&gt; 表达式，不一定表示为 &lt;code&gt;float&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5ccabdc1716ee0f1f6ba421bfe7a3cb18e19e27" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;float&lt;/code&gt; expression that indicates overflow</source>
          <target state="translated">扩展为表示溢出的正 &lt;code&gt;float&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="1517f254032c8417e8afa57de1c3cc258d11f6c4" translate="yes" xml:space="preserve">
          <source>Expands to positive &lt;code&gt;long double&lt;/code&gt; expression that indicates overflow, not necessarily representable as a &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt;</source>
          <target state="translated">扩展为表示溢出的正 &lt;code&gt;long double&lt;/code&gt; &lt;code&gt;float&lt;/code&gt; 表达式，不一定表示为float或 &lt;code&gt;double&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc198697dbf6af57511ca5dfb75efa170fb6388d" translate="yes" xml:space="preserve">
          <source>Expansion loci</source>
          <target state="translated">扩张位点</target>
        </trans-unit>
        <trans-unit id="d9e0a488e53cfe7c390afb8b463eb5bb25a7cfba" translate="yes" xml:space="preserve">
          <source>Experimental libraries</source>
          <target state="translated">实验图书馆</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="52641b8a40589b37d9770ba9ee57a29be108ded9" translate="yes" xml:space="preserve">
          <source>Explicit (full) specialization of a member of a partial specialization is declared the same way as an explicit specialization of the primary template.</source>
          <target state="translated">部分特化成员的显式(完全)特化与主模板的显式特化声明方式相同。</target>
        </trans-unit>
        <trans-unit id="dd412ab552031cf5dc3a067286b0057cfec3dfe8" translate="yes" xml:space="preserve">
          <source>Explicit conversion from (possibly const) &lt;code&gt;fpos&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;. The result is the stored offset.</source>
          <target state="translated">从（可能是const） &lt;code&gt;fpos&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; 显式转换。结果是存储的偏移量。</target>
        </trans-unit>
        <trans-unit id="1c63bca80feb759ba98d57e981b658fef25d5cce" translate="yes" xml:space="preserve">
          <source>Explicit instantiation</source>
          <target state="translated">显式实例化</target>
        </trans-unit>
        <trans-unit id="4b142316d64b45cb4860439c17ed8cd8981f0aa9" translate="yes" xml:space="preserve">
          <source>Explicit instantiation can only appear in the enclosing namespace of the template, unless it uses qualified-id:</source>
          <target state="translated">显式实例化只能出现在模板的包围名空间中,除非它使用限定id。</target>
        </trans-unit>
        <trans-unit id="ee1fc799be568941add0e5c7edd28b1bd51ae960" translate="yes" xml:space="preserve">
          <source>Explicit instantiation declarations do not suppress the implicit instantiation of &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt; functions, &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;-declarations, references, and class template specializations. (thus, when the inline function that is a subject of explicit instantiation declaration is ODR-used, it is implicitly instantiated for inlining, but its out-of-line copy is not generated in this TU).</source>
          <target state="translated">显式实例化声明不抑制&lt;a href=&quot;inline&quot;&gt;内联&lt;/a&gt;函数，&lt;a href=&quot;auto&quot;&gt;自动&lt;/a&gt;声明，引用和类模板专门化的隐式实例化。（因此，当使用显式实例化声明的主题的内联函数进行ODR使用时，将对其进行隐式实例化以进行内联，但是在此TU中不会生成其脱机副本）。</target>
        </trans-unit>
        <trans-unit id="572c84d2570e91de98df5fd413b0bd1a4670b56d" translate="yes" xml:space="preserve">
          <source>Explicit instantiation definition of a function template with &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt; is not a use of the arguments, and does not attempt to initialize them:</source>
          <target state="translated">具有&lt;a href=&quot;default_arguments&quot;&gt;默认参数&lt;/a&gt;的函数模板的显式实例化定义不使用参数，也不尝试初始化它们：</target>
        </trans-unit>
        <trans-unit id="0dcc010f6137a4796c623c315a5959bc45a20109" translate="yes" xml:space="preserve">
          <source>Explicit instantiation definitions ignore member access specifiers: parameter types and return types may be private.</source>
          <target state="translated">显式实例化定义忽略成员访问指定器:参数类型和返回类型可以是私有的。</target>
        </trans-unit>
        <trans-unit id="65478c257174b4e3c09ba657cd00b83b6bf1640b" translate="yes" xml:space="preserve">
          <source>Explicit instantiation has no effect if an &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; appeared before for the same set of template arguments.</source>
          <target state="translated">如果对同一组模板参数出现&lt;a href=&quot;template_specialization&quot;&gt;显式专门&lt;/a&gt;化，则显式实例化无效。</target>
        </trans-unit>
        <trans-unit id="d36a0cc2732df089c694dc98284a6d85796f30ad" translate="yes" xml:space="preserve">
          <source>Explicit instantiation of a function template or of a member function of a class template cannot use &lt;code&gt;inline&lt;/code&gt; or &lt;code&gt;constexpr&lt;/code&gt;. If the declaration of the explicit instantiation names an implicitly-declared special member function, the program is ill-formed.</source>
          <target state="translated">函数模板或类模板的成员函数的显式实例不能使用 &lt;code&gt;inline&lt;/code&gt; 或 &lt;code&gt;constexpr&lt;/code&gt; 。如果显式实例的声明命名为隐式声明的特殊成员函数，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="30c811d49cc758004cfc53fc79ee65d4652de860" translate="yes" xml:space="preserve">
          <source>Explicit instantiations, explicit specializations, or partial specializations of concepts are not allowed (the meaning of the original definition of a constraint cannot be changed).</source>
          <target state="translated">不允许对概念进行显式实例化、显式特化或部分特化(不能改变约束的原始定义的含义)。</target>
        </trans-unit>
        <trans-unit id="2e55319f81d1a852746aa5972684208a80ae6770" translate="yes" xml:space="preserve">
          <source>Explicit specialization</source>
          <target state="translated">明确的专门化</target>
        </trans-unit>
        <trans-unit id="593deb78caf931f5a8926f7968637e3804e9bc2d" translate="yes" xml:space="preserve">
          <source>Explicit specialization may be declared in any scope where its primary template may be defined (which may be different from the scope where the primary template is defined; such as with out-of-class specialization of a &lt;a href=&quot;member_template&quot;&gt;member template&lt;/a&gt;) . Explicit specialization has to appear after the non-specialized template declaration.</source>
          <target state="translated">可以在可以定义其主模板的任何范围内声明显式专业化（这可能不同于定义主模板的范围；例如，&lt;a href=&quot;member_template&quot;&gt;成员模板&lt;/a&gt;的类外专业化）。显式专业化必须出现在非专业化模板声明之后。</target>
        </trans-unit>
        <trans-unit id="8870f1f0b78d6b643054caef6f197e66cbb50dc0" translate="yes" xml:space="preserve">
          <source>Explicit specializations of function templates</source>
          <target state="translated">函数模板的明确特殊化</target>
        </trans-unit>
        <trans-unit id="d9b457bfa7e9dfdb8f202a1cfd0b13910b32a1d1" translate="yes" xml:space="preserve">
          <source>Explicit template argument lists may not be specified when calling any of them.</source>
          <target state="translated">当调用任何一个模板参数列表时,不可以指定明确的模板参数列表。</target>
        </trans-unit>
        <trans-unit id="901409defb65997b43ccf96e53d877ad8c4540d5" translate="yes" xml:space="preserve">
          <source>Explicit template arguments</source>
          <target state="translated">明确的模板参数</target>
        </trans-unit>
        <trans-unit id="4431a5f6720c93927b4ab9fdd98f9a2ec4e9c49f" translate="yes" xml:space="preserve">
          <source>Explicit template instantiation</source>
          <target state="translated">明确的模板实例化</target>
        </trans-unit>
        <trans-unit id="0fab44e233e42157cd5dea76fd8cf3c8b9d7adc5" translate="yes" xml:space="preserve">
          <source>Explicit template specialization</source>
          <target state="translated">明确的模板专用化</target>
        </trans-unit>
        <trans-unit id="efc7df6ee447c5edc7f6c07135ad3f5023dea6a8" translate="yes" xml:space="preserve">
          <source>Explicit type conversion</source>
          <target state="translated">明确的类型转换</target>
        </trans-unit>
        <trans-unit id="dd8bfe3fdab8ac97b580b2a4aef0404f178b5ac1" translate="yes" xml:space="preserve">
          <source>Exponential functions</source>
          <target state="translated">指数函数</target>
        </trans-unit>
        <trans-unit id="af9874c4957d8cd8c01ba533edd025cf4c27e381" translate="yes" xml:space="preserve">
          <source>Exposes class &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; as a method of accessing individual bits. In particular, objects of this class are returned by &lt;a href=&quot;vector/operator_at&quot;&gt;&lt;code&gt;operator[]&lt;/code&gt;&lt;/a&gt; by value.</source>
          <target state="translated">公开类 &lt;code&gt;&lt;a href=&quot;vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; 作为访问单个位的方法。特别是，此类的对象由&lt;a href=&quot;vector/operator_at&quot;&gt; &lt;code&gt;operator[]&lt;/code&gt; &lt;/a&gt;按值返回。</target>
        </trans-unit>
        <trans-unit id="386b8e5c19a5d25975c5d960c8d6889b5c0e7456" translate="yes" xml:space="preserve">
          <source>Exposes the type named &lt;code&gt;type&lt;/code&gt;, which is the common type of two &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">公开名为 &lt;code&gt;type&lt;/code&gt; 的类型，这是两个 &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 的常见类型。</target>
        </trans-unit>
        <trans-unit id="81c630945113fb74890dbe59b04840a67c663c1b" translate="yes" xml:space="preserve">
          <source>Exposes the type named &lt;code&gt;type&lt;/code&gt;, which is the common type of two &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">公开名为 &lt;code&gt;type&lt;/code&gt; 的类型，这是两个 &lt;code&gt;&lt;a href=&quot;../time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; 的常见类型。</target>
        </trans-unit>
        <trans-unit id="dde7602ac0e3b525fda01f2a33c67f49539ca405" translate="yes" xml:space="preserve">
          <source>Exposition-only data member holding the sentinel (typically either a number, for a bounded iota view, or an instance of &lt;code&gt;std::unreachable_sentinel_t&lt;/code&gt; for an unbounded iota view.</source>
          <target state="translated">仅用于展示哨兵的数据成员（对于有界的iota视图，通常为数字；对于无界的iota视图，则为 &lt;code&gt;std::unreachable_sentinel_t&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="cf2a2572c2908ed7f54343df2e7969e31bec570b" translate="yes" xml:space="preserve">
          <source>Exposition-only data member holding the sentinel of the underlying &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">仅博览会的数据成员，持有基础&lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;的前哨。</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="41e32832dbe3b76f5e8fc2a5f15b3848cf05e235" translate="yes" xml:space="preserve">
          <source>Expression SFINAE</source>
          <target state="translated">表达式SFINAE</target>
        </trans-unit>
        <trans-unit id="833207cd0a28197ca9f0d233e80f2413b069f412" translate="yes" xml:space="preserve">
          <source>Expression evaluation may produce a result (e.g., evaluation of &lt;code&gt;2+2&lt;/code&gt; produces the result &lt;code&gt;4&lt;/code&gt;) and may generate side-effects (e.g. evaluation of &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; prints the character &lt;code&gt;'4'&lt;/code&gt; on the standard output).</source>
          <target state="translated">表达评估可能会产生结果（例如，对 &lt;code&gt;2+2&lt;/code&gt; 的评估会产生结果 &lt;code&gt;4&lt;/code&gt; ），并且可能会产生副作用（例如 &lt;code&gt;&lt;a href=&quot;../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(&quot;%d&quot;,4)&lt;/code&gt; 评估会在标准字符上打印字符 &lt;code&gt;'4'&lt;/code&gt; 输出）。</target>
        </trans-unit>
        <trans-unit id="0a7a6ba0d7d2af3106edf9d912c2fc5a47512f54" translate="yes" xml:space="preserve">
          <source>Expression statements</source>
          <target state="translated">表达式语句</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="bd7f69f355486bcb0814ab9e5cf3b7318931dffa" translate="yes" xml:space="preserve">
          <source>Extended &lt;code&gt;static_assert&lt;/code&gt;</source>
          <target state="translated">扩展的 &lt;code&gt;static_assert&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85f5fa538ad73dc2c1cf60d6bcfc4288cb6d221b" translate="yes" xml:space="preserve">
          <source>Extending memory management tools</source>
          <target state="translated">扩展内存管理工具</target>
        </trans-unit>
        <trans-unit id="446e27d8fc1178607fbaea2ba6117c2bee0e3166" translate="yes" xml:space="preserve">
          <source>Extending the namespace std</source>
          <target state="translated">扩展命名空间std</target>
        </trans-unit>
        <trans-unit id="e73f93d7fc042bb05945a0bc48fe3f9f81efe46b" translate="yes" xml:space="preserve">
          <source>Extension to &lt;a href=&quot;language/aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;</source>
          <target state="translated">扩展&lt;a href=&quot;language/aggregate_initialization&quot;&gt;聚合初始化&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d6e9863adde877292363ab102515ca7b6ccafb6" translate="yes" xml:space="preserve">
          <source>Extensions for &lt;code&gt;std::future&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;std::future&lt;/code&gt; 扩展</target>
        </trans-unit>
        <trans-unit id="71a1260f76544c68e3425a1c076e5499b0002fbb" translate="yes" xml:space="preserve">
          <source>Extent</source>
          <target state="translated">Extent</target>
        </trans-unit>
        <trans-unit id="f92e601eb8d663033dca3851ad6f1616d1966aa7" translate="yes" xml:space="preserve">
          <source>External links</source>
          <target state="translated">外部链接</target>
        </trans-unit>
        <trans-unit id="a1aea7fedb01b55857a374fd355fdb3f3d76821e" translate="yes" xml:space="preserve">
          <source>Extracting a node invalidates only the iterators to the extracted element, and preserves the relative order of the elements that are not erased. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container.</source>
          <target state="translated">提取一个节点只使提取元素的迭代器无效,并保留未被擦除的元素的相对顺序。提取元素的指针和引用仍然有效,但在元素被节点句柄拥有时不能使用:如果元素被插入容器中,它们就可以使用。</target>
        </trans-unit>
        <trans-unit id="b5485507a535a08d29060699bc1ba26e5fbec017" translate="yes" xml:space="preserve">
          <source>Extracting a node invalidates the iterators to the extracted element. Pointers and references to the extracted element remain valid, but cannot be used while element is owned by a node handle: they become usable if the element is inserted into a container.</source>
          <target state="translated">提取一个节点会使被提取元素的迭代器无效。提取元素的指针和引用仍然有效,但在元素被节点句柄拥有时不能使用:如果元素被插入到一个容器中,它们就可以使用。</target>
        </trans-unit>
        <trans-unit id="b15d94524be33e2064c90d0f8c997adad64d1ab7" translate="yes" xml:space="preserve">
          <source>Extracting a single character that is the last character of the stream does not set &lt;code&gt;eofbit&lt;/code&gt;: this is different from other formatted input functions, such as extracting the last integer with &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, but this behavior matches the behavior of &lt;code&gt;&lt;a href=&quot;../c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&quot;%c&quot;&lt;/code&gt; format specifier.</source>
          <target state="translated">提取作为流的最后一个字符的单个字符不会设置 &lt;code&gt;eofbit&lt;/code&gt; ：这与其他格式化的输入函数不同，例如使用 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 提取最后一个整数，但是此行为将 &lt;code&gt;&lt;a href=&quot;../c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; 的行为与 &lt;code&gt;&quot;%c&quot;&lt;/code&gt; 格式说明符。</target>
        </trans-unit>
        <trans-unit id="77a2197986a0f5813101a331f598cfcb85a220fb" translate="yes" xml:space="preserve">
          <source>Extracts an element from the pair using tuple-like interface.</source>
          <target state="translated">使用类似元组的接口从对中提取一个元素。</target>
        </trans-unit>
        <trans-unit id="ef0ddc3034770dba9709a96861d6340f80bd0470" translate="yes" xml:space="preserve">
          <source>Extracts and discards characters from the input stream until and including &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">从输入流中提取并丢弃字符，直到包括 &lt;code&gt;delim&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="c16944c77e932413c2253839ec882702fb001de1" translate="yes" xml:space="preserve">
          <source>Extracts character or characters from stream.</source>
          <target state="translated">从流中提取一个或多个字符。</target>
        </trans-unit>
        <trans-unit id="a68c11784d768fd75f5143a08580523eaca81d6d" translate="yes" xml:space="preserve">
          <source>Extracts characters from stream until end of line or the specified delimiter &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">从流中提取字符，直到行尾或指定的定界符 &lt;code&gt;delim&lt;/code&gt; 为止。</target>
        </trans-unit>
        <trans-unit id="b0ac0f2a82fe93a443fa08ceb0fe622f9ece3c06" translate="yes" xml:space="preserve">
          <source>Extracts characters from stream.</source>
          <target state="translated">从流中提取字符。</target>
        </trans-unit>
        <trans-unit id="7649df41de72e363648c6e8cac8be1f6dc3a552f" translate="yes" xml:space="preserve">
          <source>Extracts the &lt;code&gt;Ith&lt;/code&gt; element element from the array.</source>
          <target state="translated">从数组中提取 &lt;code&gt;Ith&lt;/code&gt; 元素element。</target>
        </trans-unit>
        <trans-unit id="44b2e430b2cfaf879035a796088aa41b5223f736" translate="yes" xml:space="preserve">
          <source>Extracts the current &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; from a &lt;code&gt;regex_iterator&lt;/code&gt;:</source>
          <target state="translated">从 &lt;code&gt;regex_iterator&lt;/code&gt; 中提取当前的 &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b56e81381fa5a47e6b3ea3eb1d488fda4cab62e7" translate="yes" xml:space="preserve">
          <source>Extracts up to &lt;code&gt;count&lt;/code&gt; immediately available characters from the input stream. The extracted characters are stored into the character array pointed to by &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">从输入流中提取最多可立即 &lt;code&gt;count&lt;/code&gt; 字符。提取的字符存储到 &lt;code&gt;s&lt;/code&gt; 指向的字符数组中。</target>
        </trans-unit>
        <trans-unit id="e72ac13e9cd4d6af9eb70d5cf0e07a1000b3c95a" translate="yes" xml:space="preserve">
          <source>F is sequenced-before X in thread A</source>
          <target state="translated">F在线程A中被排序在X之前。</target>
        </trans-unit>
        <trans-unit id="7baf4c10d15dfb9c6bb605f66aef033fa6c6e2a5" translate="yes" xml:space="preserve">
          <source>FA is sequenced-before X in thread A</source>
          <target state="translated">FA在线程A中的X之前排序</target>
        </trans-unit>
        <trans-unit id="ee8392aac4b3ee280362ef5273dcbf0dce3c5592" translate="yes" xml:space="preserve">
          <source>FEMININE ORDINAL INDICATOR</source>
          <target state="translated">妇科正常指标</target>
        </trans-unit>
        <trans-unit id="c061bc777cddf822c848be8c51b3f6a8a14f19f4" translate="yes" xml:space="preserve">
          <source>FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</source>
          <target state="translated">FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="b1c364462df93e13ffc864f5e34d434d3e0896f1" translate="yes" xml:space="preserve">
          <source>FE_DFL_ENV</source>
          <target state="translated">FE_DFL_ENV</target>
        </trans-unit>
        <trans-unit id="afc46bada59e52921ca04acfa3e557f4d34949db" translate="yes" xml:space="preserve">
          <source>FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</source>
          <target state="translated">FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD</target>
        </trans-unit>
        <trans-unit id="f17f59f8bb1aa4aa1c2a8be48c8b3cc395132a95" translate="yes" xml:space="preserve">
          <source>FE_UNDERFLOW</source>
          <target state="translated">FE_UNDERFLOW</target>
        </trans-unit>
        <trans-unit id="5fc0e01507a5cabdda26a6538ed27cbe059c94c7" translate="yes" xml:space="preserve">
          <source>FE_UPWARD</source>
          <target state="translated">FE_UPWARD</target>
        </trans-unit>
        <trans-unit id="6c8821a037c125e39dc3cb69a201a2174bd7c0f8" translate="yes" xml:space="preserve">
          <source>FILENAME_MAX</source>
          <target state="translated">FILENAME_MAX</target>
        </trans-unit>
        <trans-unit id="ec0e6a828868888b35d7b88c45bc8ec8ded65b4c" translate="yes" xml:space="preserve">
          <source>FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</source>
          <target state="translated">FLT_DECIMAL_DIGDBL_DECIMAL_DIGLDBL_DECIMAL_DIG</target>
        </trans-unit>
        <trans-unit id="7afcf0013539d05e408bc6855b9ff9c33961ba4a" translate="yes" xml:space="preserve">
          <source>FLT_DIGDBL_DIGLDBL_DIG</source>
          <target state="translated">FLT_DIGDBL_DIGLDBL_DIG</target>
        </trans-unit>
        <trans-unit id="fb4b82dd7a09ae0e4cd4ec26fae3ace2a1f492b3" translate="yes" xml:space="preserve">
          <source>FLT_EPSILONDBL_EPSILONLDBL_EPSILON</source>
          <target state="translated">FLT_EPSILONDBL_EPSILONLDBL_EPSILON</target>
        </trans-unit>
        <trans-unit id="19a80ddd685588eb2c01ceaa6c67ca15a9d3cd90" translate="yes" xml:space="preserve">
          <source>FLT_EVAL_METHOD</source>
          <target state="translated">FLT_EVAL_METHOD</target>
        </trans-unit>
        <trans-unit id="27b085fe54adba08fa4a2911aa54c2928531a994" translate="yes" xml:space="preserve">
          <source>FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</source>
          <target state="translated">FLT_HAS_SUBNORMDBL_HAS_SUBNORMLDBL_HAS_SUBNORM</target>
        </trans-unit>
        <trans-unit id="d23e1d93b48a70a6b3008660a10922fc69e91714" translate="yes" xml:space="preserve">
          <source>FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</source>
          <target state="translated">FLT_MANT_DIGDBL_MANT_DIGLDBL_MANT_DIG</target>
        </trans-unit>
        <trans-unit id="14a1a55c6769f2d618f216dd4e1926c937963a81" translate="yes" xml:space="preserve">
          <source>FLT_MAXDBL_MAXLDBL_MAX</source>
          <target state="translated">FLT_MAXDBL_MAXLDBL_MAX</target>
        </trans-unit>
        <trans-unit id="1a43181bc7c68633c0d3a314ceb823229a88ee19" translate="yes" xml:space="preserve">
          <source>FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</source>
          <target state="translated">FLT_MAX_10_EXPDBL_MAX_10_EXPLDBL_MAX_10_EXP</target>
        </trans-unit>
        <trans-unit id="ed2d991f061e360c893c5a713ef996b38ebffdc9" translate="yes" xml:space="preserve">
          <source>FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</source>
          <target state="translated">FLT_MAX_EXPDBL_MAX_EXPLDBL_MAX_EXP</target>
        </trans-unit>
        <trans-unit id="24b8072d7962d75d2c508ff42b7b1b1555e6bb66" translate="yes" xml:space="preserve">
          <source>FLT_MINDBL_MINLDBL_MIN</source>
          <target state="translated">FLT_MINDBL_MINLDBL_MIN</target>
        </trans-unit>
        <trans-unit id="6869500f7b0f9c2b39432ab1b4dcf3e3690ba2a4" translate="yes" xml:space="preserve">
          <source>FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</source>
          <target state="translated">FLT_MIN_10_EXPDBL_MIN_10_EXPLDBL_MIN_10_EXP</target>
        </trans-unit>
        <trans-unit id="d64b48614536e2d9f3fd84e0b2d0f3339ef6dae1" translate="yes" xml:space="preserve">
          <source>FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</source>
          <target state="translated">FLT_MIN_EXPDBL_MIN_EXPLDBL_MIN_EXP</target>
        </trans-unit>
        <trans-unit id="3d8d38284d7c48984126ae4544c8465c506ee097" translate="yes" xml:space="preserve">
          <source>FLT_RADIX</source>
          <target state="translated">FLT_RADIX</target>
        </trans-unit>
        <trans-unit id="234dca4e2a0e92e5608ec0464e330e76723ea1d3" translate="yes" xml:space="preserve">
          <source>FLT_ROUNDS</source>
          <target state="translated">FLT_ROUNDS</target>
        </trans-unit>
        <trans-unit id="7e6cd06ba47da57a942743f790919ca173fb6d20" translate="yes" xml:space="preserve">
          <source>FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</source>
          <target state="translated">FLT_TRUE_MINDBL_TRUE_MINLDBL_TRUE_MIN</target>
        </trans-unit>
        <trans-unit id="60945a4b9de8b69d4d5468fc065e520c99d43f40" translate="yes" xml:space="preserve">
          <source>FOPEN_MAX</source>
          <target state="translated">FOPEN_MAX</target>
        </trans-unit>
        <trans-unit id="052dbc6bd1e79a500f50639c055da0a0bddfcda6" translate="yes" xml:space="preserve">
          <source>FP_NORMAL, FP_SUBNORMAL, FP_ZERO, FP_INFINITE, FP_NAN</source>
          <target state="translated">FP_NORMAL,FP_SUBNORMAL,FP_ZERO,FP_INFINITE,FP_NAN。</target>
        </trans-unit>
        <trans-unit id="4b390f17b3415cc66503253a8e943ae6869cbbbb" translate="yes" xml:space="preserve">
          <source>FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</source>
          <target state="translated">FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN</target>
        </trans-unit>
        <trans-unit id="13ad13aaa89439dd8522b85f083a14ec539c93e9" translate="yes" xml:space="preserve">
          <source>FP_ZERO</source>
          <target state="translated">FP_ZERO</target>
        </trans-unit>
        <trans-unit id="8c6c7c8ebbe0f69f73a317ea017f66dfe215ff4a" translate="yes" xml:space="preserve">
          <source>Facet categories</source>
          <target state="translated">面部类别</target>
        </trans-unit>
        <trans-unit id="041a83e17c0f537ae2ed62d3b2cdf6826e396193" translate="yes" xml:space="preserve">
          <source>Facet category base classes</source>
          <target state="translated">曲面类基础班</target>
        </trans-unit>
        <trans-unit id="b533c7fea0c500ba4ef293884991083e32ec4a68" translate="yes" xml:space="preserve">
          <source>Facets with the same &lt;code&gt;id&lt;/code&gt; belong to the same facet category and replace each other when added to a locale object.</source>
          <target state="translated">具有相同 &lt;code&gt;id&lt;/code&gt; 的构面属于同一构面类别，并且在添加到语言环境对象后会相互替换。</target>
        </trans-unit>
        <trans-unit id="66908b176ccb4f40a6f1a10938d28a50727305a6" translate="yes" xml:space="preserve">
          <source>Factor operations</source>
          <target state="translated">因数业务</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="ce6c5bc258e8bef5e3ae59b1338a20c4748ea8d2" translate="yes" xml:space="preserve">
          <source>Failure to open</source>
          <target state="translated">未能打开</target>
        </trans-unit>
        <trans-unit id="d3051aec047cdd51e6d43d2664a5df396a9877fb" translate="yes" xml:space="preserve">
          <source>Failures to meet the postconditions, such as failing to produce a valid return value object</source>
          <target state="translated">未能满足后置条件,如未能产生有效的返回值对象。</target>
        </trans-unit>
        <trans-unit id="3914bd46dc4687d6b7087f5c008acc618475cc00" translate="yes" xml:space="preserve">
          <source>Failures to meet the preconditions of another function that must be called</source>
          <target state="translated">未能满足另一个必须调用的函数的前提条件。</target>
        </trans-unit>
        <trans-unit id="c29752c93447e11b1a890d7ac78a70435ca5bdb4" translate="yes" xml:space="preserve">
          <source>Fancy pointers</source>
          <target state="translated">花式指针</target>
        </trans-unit>
        <trans-unit id="b494fef582ccfffefb54575ea4e577f7dbaf26c1" translate="yes" xml:space="preserve">
          <source>Fast access but fixed number of elements</source>
          <target state="translated">快速访问,但元素数量固定</target>
        </trans-unit>
        <trans-unit id="24dd69ccc43e1ae6d5f5a742d02f0da0f6b32305" translate="yes" xml:space="preserve">
          <source>Fast access but mostly inefficient insertions/deletions</source>
          <target state="translated">访问速度快,但大多数情况下插入/删除效率不高。</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="0775fb360f01bab977ed5ec997840be1f65f3719" translate="yes" xml:space="preserve">
          <source>Feature testing</source>
          <target state="translated">功能测试</target>
        </trans-unit>
        <trans-unit id="9fe9f4b9291746b85204d55ff6be73414f9570ac" translate="yes" xml:space="preserve">
          <source>Feature testing (C++20)</source>
          <target state="translated">功能测试(C++20)</target>
        </trans-unit>
        <trans-unit id="bc0228c9de8004fdac6db7743fdd23e61859a392" translate="yes" xml:space="preserve">
          <source>Fence-atomic synchronization</source>
          <target state="translated">栅栏-原子同步</target>
        </trans-unit>
        <trans-unit id="c0f00371ddb6eac35be65eb720b3cab89de6182d" translate="yes" xml:space="preserve">
          <source>Fence-fence synchronization</source>
          <target state="translated">栅栏-栅栏同步化</target>
        </trans-unit>
        <trans-unit id="e79120c3392d8a2111f0e85788e61d24a2973100" translate="yes" xml:space="preserve">
          <source>Fence-fence synchronization can be used to add synchronization to a sequence of several relaxed atomic operations, for example.</source>
          <target state="translated">栅栏-栅栏同步可以用来给几个放松的原子操作序列添加同步,例如。</target>
        </trans-unit>
        <trans-unit id="9d413b1e7e21f8acf4d5ba31c56b61a1a190cf03" translate="yes" xml:space="preserve">
          <source>File I/O implementation</source>
          <target state="translated">文件I/O实施</target>
        </trans-unit>
        <trans-unit id="a1369155ac8ee1937c5466bde76ab0bbbcbba45c" translate="yes" xml:space="preserve">
          <source>File access</source>
          <target state="translated">文件访问</target>
        </trans-unit>
        <trans-unit id="ecbca940d8a1676fb3cfcf517eb3d1e3e48574ec" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;b&quot;&lt;/code&gt; can optionally be specified to open a file &lt;a href=&quot;../c#Binary_and_text_modes&quot;&gt;in binary mode&lt;/a&gt;. This flag has no effect on POSIX systems, but on Windows, for example, it disables special handling of &lt;code&gt;'\n'&lt;/code&gt; and &lt;code&gt;'\x1A'&lt;/code&gt;.</source>
          <target state="translated">可以选择指定文件访问模式标记 &lt;code&gt;&quot;b&quot;&lt;/code&gt; &lt;a href=&quot;../c#Binary_and_text_modes&quot;&gt;以二进制模式&lt;/a&gt;打开文件。该标志对POSIX系统无效，但是在Windows上，例如，它禁用对 &lt;code&gt;'\n'&lt;/code&gt; 和 &lt;code&gt;'\x1A'&lt;/code&gt; 特殊处理。</target>
        </trans-unit>
        <trans-unit id="9675879f138420dc849c3b02c7a08a45f1764ce0" translate="yes" xml:space="preserve">
          <source>File access mode flag &lt;code&gt;&quot;x&quot;&lt;/code&gt; can optionally be appended to &quot;w&quot; or &quot;w+&quot; specifiers. This flag forces the function to fail if the file exists, instead of overwriting it. (C++17)</source>
          <target state="translated">文件访问模式标志 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 可以有选择地附加到&amp;ldquo; w&amp;rdquo;或&amp;ldquo; w +&amp;rdquo;说明符。如果文件存在，此标志将强制该函数失败，而不是覆盖它。（C ++ 17）</target>
        </trans-unit>
        <trans-unit id="848538ee54491f003e342600d6426cc1665c1d90" translate="yes" xml:space="preserve">
          <source>File descriptor value too large</source>
          <target state="translated">文件描述符值过大</target>
        </trans-unit>
        <trans-unit id="e4abf36a5ea54ec41cce22ec0fe706639aba0b93" translate="yes" xml:space="preserve">
          <source>File exists</source>
          <target state="translated">文件存在</target>
        </trans-unit>
        <trans-unit id="64fd779c46cf2d931941b36cb1e56f079e1d6e2c" translate="yes" xml:space="preserve">
          <source>File operations</source>
          <target state="translated">文件操作</target>
        </trans-unit>
        <trans-unit id="0b24f6042e86aadda1815101f042d04954349481" translate="yes" xml:space="preserve">
          <source>File owner has execute/search permission</source>
          <target state="translated">文件所有者有执行/搜索权限</target>
        </trans-unit>
        <trans-unit id="1a3e84e64dd01307f0ee39195f923bfa54b5c0c6" translate="yes" xml:space="preserve">
          <source>File owner has read permission</source>
          <target state="translated">文件所有者有阅读权限</target>
        </trans-unit>
        <trans-unit id="00a45fcb3c463f25a9813f51c216665d3293d7ab" translate="yes" xml:space="preserve">
          <source>File owner has read, write, and execute/search permissions</source>
          <target state="translated">文件所有者拥有读、写、执行/搜索权限。</target>
        </trans-unit>
        <trans-unit id="01358bbedd5677b98189c5d53b33f357f182c488" translate="yes" xml:space="preserve">
          <source>File owner has write permission</source>
          <target state="translated">文件所有者有写入权限</target>
        </trans-unit>
        <trans-unit id="1a996ddad7a713856017f5f90fe0498db20bdbda" translate="yes" xml:space="preserve">
          <source>File position indicator on success or &lt;code&gt;-1L&lt;/code&gt; if failure occurs. Also sets &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">文件位置指示成功或 &lt;code&gt;-1L&lt;/code&gt; (如果发生故障）。还会在失败时设置 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a494399ad447f56f41d7522c5db08562d3c24708" translate="yes" xml:space="preserve">
          <source>File positioning</source>
          <target state="translated">文件定位</target>
        </trans-unit>
        <trans-unit id="36cd96e05c782cee5791cf21bde1893978c5c077" translate="yes" xml:space="preserve">
          <source>File scope</source>
          <target state="translated">锉刀扫帚</target>
        </trans-unit>
        <trans-unit id="a0704a4eaa055ab08e3766911e446737f4f2a445" translate="yes" xml:space="preserve">
          <source>File too large</source>
          <target state="translated">文件太大</target>
        </trans-unit>
        <trans-unit id="0205534386e03d869079430b7c0117e9af5229d7" translate="yes" xml:space="preserve">
          <source>File types</source>
          <target state="translated">文件类型</target>
        </trans-unit>
        <trans-unit id="fae255f2995d1f907f01cf7594e8462316da5be7" translate="yes" xml:space="preserve">
          <source>Filename and line information</source>
          <target state="translated">文件名和行信息</target>
        </trans-unit>
        <trans-unit id="5ba8d30ffba45db4e2f3f220829fe902e2fd990f" translate="yes" xml:space="preserve">
          <source>Filename too long</source>
          <target state="translated">文件名太长</target>
        </trans-unit>
        <trans-unit id="092fe85f5c2e62269fa44ec1fcbf190e92f16564" translate="yes" xml:space="preserve">
          <source>Filesystem</source>
          <target state="translated">Filesystem</target>
        </trans-unit>
        <trans-unit id="bbc4c49f164b158dbe825399e8316a41a98039c5" translate="yes" xml:space="preserve">
          <source>Filesystem TS</source>
          <target state="translated">文件系统TS</target>
        </trans-unit>
        <trans-unit id="f6adde9d94ef3f9818beca92c4fb5775d3d08a90" translate="yes" xml:space="preserve">
          <source>Filesystem library</source>
          <target state="translated">文件系统库</target>
        </trans-unit>
        <trans-unit id="d6016e126bb1261237244c868e871626e1164a78" translate="yes" xml:space="preserve">
          <source>Fills [&lt;code&gt;rb&lt;/code&gt;,&lt;code&gt;re&lt;/code&gt;) with 32-bit quantities depending on the initial supplied values and potential previous calls to &lt;code&gt;generate&lt;/code&gt;. If &lt;code&gt;rb == re&lt;/code&gt;, it does nothing.</source>
          <target state="translated">用32位量填充[ &lt;code&gt;rb&lt;/code&gt; ， &lt;code&gt;re&lt;/code&gt; ），具体取决于初始提供的值和先前可能 &lt;code&gt;generate&lt;/code&gt; 调用。如果 &lt;code&gt;rb == re&lt;/code&gt; ，则不执行任何操作。</target>
        </trans-unit>
        <trans-unit id="0477adab8010ca288bf22b1b3deddefba747b42d" translate="yes" xml:space="preserve">
          <source>Fills the range &lt;code&gt;[begin, end)&lt;/code&gt; with unsigned integer values &lt;code&gt;i&lt;/code&gt;, 0 &amp;le; i &amp;lt; 232</source>
          <target state="translated">用无符号整数 &lt;code&gt;i&lt;/code&gt; 填充范围 &lt;code&gt;[begin, end)&lt;/code&gt; ，0&amp;le;i &amp;lt;232</target>
        </trans-unit>
        <trans-unit id="da2860ae65231144c9442af16b999bbb60810f8b" translate="yes" xml:space="preserve">
          <source>Fills the range &lt;code&gt;[first, last)&lt;/code&gt; with sequentially increasing values, starting with &lt;code&gt;value&lt;/code&gt; and repetitively evaluating &lt;code&gt;++value&lt;/code&gt;.</source>
          <target state="translated">填充范围 &lt;code&gt;[first, last)&lt;/code&gt; 与依次增大的值，与开始 &lt;code&gt;value&lt;/code&gt; 和重复评估 &lt;code&gt;++value&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae117132b523ad7bbcabf063e4512b94303ad825" translate="yes" xml:space="preserve">
          <source>Final classes cannot be used as base classes.</source>
          <target state="translated">最终类不能作为基础类使用。</target>
        </trans-unit>
        <trans-unit id="f71bda78a1e6997b4c579d61039ab383458a0b93" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;awaiter.await_resume()&lt;/code&gt; is called, and its result is the result of the whole &lt;code&gt;co_await expr&lt;/code&gt; expression.</source>
          <target state="translated">最后， &lt;code&gt;awaiter.await_resume()&lt;/code&gt; ，其结果是整个 &lt;code&gt;co_await expr&lt;/code&gt; 表达式的结果。</target>
        </trans-unit>
        <trans-unit id="4db4903bd597b61dd8a328899682e291be0a76a1" translate="yes" xml:space="preserve">
          <source>Finally, calls &lt;code&gt;is.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">最后，调用 &lt;code&gt;is.width(0)&lt;/code&gt; 取消 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 的影响（如果有）。</target>
        </trans-unit>
        <trans-unit id="9e4015259c16ae5de63c7894d2c7b391c4ca0b80" translate="yes" xml:space="preserve">
          <source>Finally, calls &lt;code&gt;os.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">最后，调用 &lt;code&gt;os.width(0)&lt;/code&gt; 取消 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 的影响（如果有）。</target>
        </trans-unit>
        <trans-unit id="177dc3f32e13dff30c58fffec60fe61e244cc93e" translate="yes" xml:space="preserve">
          <source>Finally, outputs each character from the resulting sequence as if by calling &lt;code&gt;out.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(out.width(), seq.size())&lt;/code&gt; and &lt;code&gt;out.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">最后，就像调用 &lt;code&gt;out.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; 一样，输出结果序列中的每个字符，其中 &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(out.width(), seq.size())&lt;/code&gt; 和 &lt;code&gt;out.width(0)&lt;/code&gt; 取消 &lt;code&gt;&lt;a href=&quot;setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 的效果（如果有）。</target>
        </trans-unit>
        <trans-unit id="00d858cc8e88f691053b3dcc6137ac4cde6d6ced" translate="yes" xml:space="preserve">
          <source>Finds an element equal to element pointed to by &lt;code&gt;key&lt;/code&gt; in an array pointed to by &lt;code&gt;ptr&lt;/code&gt;. The array contains &lt;code&gt;count&lt;/code&gt; elements of &lt;code&gt;size&lt;/code&gt; bytes each and must be partitioned with respect to the object pointed to by &lt;code&gt;key&lt;/code&gt;, that is, all the elements that compare less than must appear before all the elements that compare equal to, and those must appear before all the elements that compare greater than the key object. A fully sorted array satisfies these requirements. The elements are compared using function pointed to by &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;ptr&lt;/code&gt; 指向的数组中查找与 &lt;code&gt;key&lt;/code&gt; 指向的元素相等的元素。数组包含每个 &lt;code&gt;count&lt;/code&gt; 个字节 &lt;code&gt;size&lt;/code&gt; 计数元素，并且必须相对于 &lt;code&gt;key&lt;/code&gt; 所指向的对象进行分区，也就是说，所有小于的元素必须出现在所有等于的元素之前，并且所有的元素必须等于之前比较大于关键对象的元素。完全排序的数组可以满足这些要求。使用 &lt;code&gt;comp&lt;/code&gt; 指向的函数比较元素。</target>
        </trans-unit>
        <trans-unit id="e9927a1e661f4bfd80aaf31b22f6f41e30e9b227" translate="yes" xml:space="preserve">
          <source>Finds real roots of multiple quadratic equations.</source>
          <target state="translated">求出多次二次方程的实根。</target>
        </trans-unit>
        <trans-unit id="30bcbdf5d9a1fe0bd647e009803f909f56efc575" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to any of the characters in the given character sequence.</source>
          <target state="translated">在给定的字符序列中,找到与任何一个字符相等的第一个字符。</target>
        </trans-unit>
        <trans-unit id="5cdb4e092b97109f8b2048be07ca72c3bde0609f" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to none of the characters in the given character sequence. The search considers only the interval [&lt;code&gt;pos&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;). If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">查找与给定字符序列中所有字符都不相等的第一个字符。搜索仅考虑间隔[ &lt;code&gt;pos&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ）。如果间隔中不存在该字符，则将返回 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24f9fbec876cfd13c75d96d81a6a74110daac9d5" translate="yes" xml:space="preserve">
          <source>Finds the first character equal to one of the characters in the given character sequence. The search considers only the interval [&lt;code&gt;pos&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;). If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">查找与给定字符序列中的一个字符相等的第一个字符。搜索仅考虑间隔[ &lt;code&gt;pos&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; ）。如果间隔中不存在该字符，则将返回 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a02ae1c73392d3f6a41d7039bf6f66883821f319" translate="yes" xml:space="preserve">
          <source>Finds the first character in wide string pointed to by &lt;code&gt;dest&lt;/code&gt;, that is also in wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">发现在宽字符串的第一个字符指向 &lt;code&gt;dest&lt;/code&gt; ，这也是由指向宽字符串 &lt;code&gt;str&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="981d0030e7019507414199bd0e078d7265cd8673" translate="yes" xml:space="preserve">
          <source>Finds the first character not equal to any of the characters in the given character sequence.</source>
          <target state="translated">在给定的字符序列中找到第一个不等于任何字符的字符。</target>
        </trans-unit>
        <trans-unit id="c744c8fe55a01d138ec8c24e1528aec65ec2023a" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the byte string &lt;code&gt;target&lt;/code&gt; in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">在 &lt;code&gt;str&lt;/code&gt; 指向的字节字符串中查找字节字符串 &lt;code&gt;target&lt;/code&gt; 的第一个匹配项。不比较终止的空字符。</target>
        </trans-unit>
        <trans-unit id="822e0508dd7e5034ad40e0d29a486e2402585a0d" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the character &lt;code&gt;static_cast&amp;lt;char&amp;gt;(ch)&lt;/code&gt; in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">查找 &lt;code&gt;str&lt;/code&gt; 指向的字节字符串中字符 &lt;code&gt;static_cast&amp;lt;char&amp;gt;(ch)&lt;/code&gt; 的第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="9388d73210fb9a6adcc18de249cc87e2da6d4106" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;str&lt;/code&gt; 指向的宽字符串中找到宽字符 &lt;code&gt;ch&lt;/code&gt; 的第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="60954d9dde97ea95b47805de626af5f9bb89a11c" translate="yes" xml:space="preserve">
          <source>Finds the first occurrence of the wide string &lt;code&gt;src&lt;/code&gt; in the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The terminating null characters are not compared.</source>
          <target state="translated">在 &lt;code&gt;dest&lt;/code&gt; 指向的宽字符串中找到宽字符串 &lt;code&gt;src&lt;/code&gt; 的第一个匹配项。不比较终止的空字符。</target>
        </trans-unit>
        <trans-unit id="fc71329dcb9337103dd5851e9eb7dfa903cd2767" translate="yes" xml:space="preserve">
          <source>Finds the first substring equal to the given character sequence.</source>
          <target state="translated">查找第一个等于给定字符序列的子串。</target>
        </trans-unit>
        <trans-unit id="73d8f05c9748bf0bddfc6937b1e51af871f089f0" translate="yes" xml:space="preserve">
          <source>Finds the first substring equal to the given character sequence. Search begins at &lt;code&gt;pos&lt;/code&gt;, i.e. the found substring must not begin in a position preceding &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">查找等于给定字符序列的第一个子字符串。搜索从 &lt;code&gt;pos&lt;/code&gt; 开始，即，找到的子字符串不得在 &lt;code&gt;pos&lt;/code&gt; 之前的位置开始。</target>
        </trans-unit>
        <trans-unit id="d519b8e547c2fea611a706cf0f567de8c481f047" translate="yes" xml:space="preserve">
          <source>Finds the greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;[first, last)&lt;/code&gt; 范围内找到最大的元素。</target>
        </trans-unit>
        <trans-unit id="2a0eba935882bc5c40f3eb57edca9ffaa6207e17" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to none of the characters in the given character sequence. The search considers only the interval [0, pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">查找与给定字符序列中所有字符都不相等的最后一个字符。搜索仅考虑间隔[0，pos]。如果间隔中不存在该字符，则将返回 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="031b5bc7f5b52d9b68f531ec16e07add0732f8a9" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to one of characters in the given character sequence. Exact search algorithm is not specified. The search considers only the interval [0; pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">查找与给定字符序列中的一个字符相等的最后一个字符。未指定确切的搜索算法。搜索仅考虑间隔[0; pos]。如果间隔中不存在该字符，则将返回 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="262672fc83487a5e2f2a3a72605026935426490e" translate="yes" xml:space="preserve">
          <source>Finds the last character equal to one of characters in the given character sequence. The exact search algorithm is not specified. The search considers only the interval [0, pos]. If the character is not present in the interval, &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; will be returned.</source>
          <target state="translated">查找与给定字符序列中的一个字符相等的最后一个字符。未指定确切的搜索算法。搜索仅考虑间隔[0，pos]。如果间隔中不存在该字符，则将返回 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2eeb42fd9c4368ca6e261a7eaf0eb9173c9ca19" translate="yes" xml:space="preserve">
          <source>Finds the last character not equal to any of the characters in the given character sequence.</source>
          <target state="translated">在给定的字符序列中找到不等于任何字符的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="c9e927921904e1bd8a7847a95ec12dfc3ed90fd5" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of &lt;code&gt;ch&lt;/code&gt; (after conversion to &lt;code&gt;char&lt;/code&gt;) in the byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;str&lt;/code&gt; 指向的字节字符串中查找 &lt;code&gt;ch&lt;/code&gt; 的最后一次出现（转换为 &lt;code&gt;char&lt;/code&gt; 之后）。终止的空字符被认为是字符串的一部分，如果搜索 &lt;code&gt;'\0'&lt;/code&gt; ，则可以找到它。</target>
        </trans-unit>
        <trans-unit id="abb2c2feff5f0426d0ef85cddeeca9860311e3e9" translate="yes" xml:space="preserve">
          <source>Finds the last occurrence of the wide character &lt;code&gt;ch&lt;/code&gt; in the wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;str&lt;/code&gt; 指向的宽字符串中找到宽字符 &lt;code&gt;ch&lt;/code&gt; 的最后一次出现。</target>
        </trans-unit>
        <trans-unit id="aba2a0477e061745abafbf2e570698649cfbd049" translate="yes" xml:space="preserve">
          <source>Finds the last substring equal to the given character sequence.</source>
          <target state="translated">查找与给定字符序列相等的最后一个子串。</target>
        </trans-unit>
        <trans-unit id="85ecfa172af6c676f0f2b7ede4563bdf54dbd13d" translate="yes" xml:space="preserve">
          <source>Finds the last substring equal to the given character sequence. Search begins at &lt;code&gt;pos&lt;/code&gt;, i.e. the found substring must not begin in a position following &lt;code&gt;pos&lt;/code&gt;. If &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; or any value not smaller than &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;-1 is passed as &lt;code&gt;pos&lt;/code&gt;, whole string will be searched.</source>
          <target state="translated">查找等于给定字符序列的最后一个子字符串。搜索从 &lt;code&gt;pos&lt;/code&gt; 开始，即，找到的子字符串不得在 &lt;code&gt;pos&lt;/code&gt; 之后的位置开始。如果 &lt;code&gt;&lt;a href=&quot;npos&quot;&gt;npos&lt;/a&gt;&lt;/code&gt; 或不小于 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; - 1的任何值作为 &lt;code&gt;pos&lt;/code&gt; 传递，则将搜索整个字符串。</target>
        </trans-unit>
        <trans-unit id="4e96707b2590ca4719626a87f0675c2693cd9371" translate="yes" xml:space="preserve">
          <source>Finds the next token in a null-terminated byte string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated byte string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">在以 &lt;code&gt;str&lt;/code&gt; 指向的以空终止的字节字符串中查找下一个标记。分隔符由 &lt;code&gt;delim&lt;/code&gt; 指向的以空终止的字节字符串标识。</target>
        </trans-unit>
        <trans-unit id="380ef08d0f8e6c7597e5b529abb1fb2b2ba51aa4" translate="yes" xml:space="preserve">
          <source>Finds the next token in a null-terminated wide string pointed to by &lt;code&gt;str&lt;/code&gt;. The separator characters are identified by null-terminated wide string pointed to by &lt;code&gt;delim&lt;/code&gt;.</source>
          <target state="translated">在以 &lt;code&gt;str&lt;/code&gt; 指向的以null终止的宽字符串中查找下一个标记。分隔符由 &lt;code&gt;delim&lt;/code&gt; 指向的以空终止的宽字符串标识。</target>
        </trans-unit>
        <trans-unit id="59f9527a2060df058f520ec4facfb5d116cfb5ab" translate="yes" xml:space="preserve">
          <source>Finds the smallest and greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">查找 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的最小和最大元素。</target>
        </trans-unit>
        <trans-unit id="73f7ebc728f72e9244fbcb71e4bebffbcaa8c095" translate="yes" xml:space="preserve">
          <source>Finds the smallest element in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">查找 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的最小元素。</target>
        </trans-unit>
        <trans-unit id="fb4718767cbeb7ec2a4050ea8b0704c79bba10d8" translate="yes" xml:space="preserve">
          <source>First clears &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">首先清除&lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;eofbit&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c779ca82cc21b768cc6c4bcc4f1d87107bdb7d29" translate="yes" xml:space="preserve">
          <source>First clears &lt;code&gt;eofbit&lt;/code&gt;, then behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, if &lt;code&gt;rdbuf()&lt;/code&gt; is not null, calls &lt;code&gt;rdbuf()-&amp;gt;sputbackc(ch)&lt;/code&gt;, which calls &lt;code&gt;rdbuf()-&amp;gt;pbackfail(ch)&lt;/code&gt; if &lt;code&gt;ch&lt;/code&gt; does not equal the most recently extracted character.</source>
          <target state="translated">首先清除 &lt;code&gt;eofbit&lt;/code&gt; ，然后表现为&lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;。在构造并检查了哨兵对象之后，如果 &lt;code&gt;rdbuf()&lt;/code&gt; 不为null，则调用 &lt;code&gt;rdbuf()-&amp;gt;sputbackc(ch)&lt;/code&gt; ，如果 &lt;code&gt;ch&lt;/code&gt; 不等于最近提取的字符，则调用 &lt;code&gt;rdbuf()-&amp;gt;pbackfail(ch)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13f51e93c18a65140da3cb2cb1dfab78c49243a0" translate="yes" xml:space="preserve">
          <source>First destroys the current contained object (if any) by &lt;code&gt;&lt;a href=&quot;reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt;, then:</source>
          <target state="translated">首先通过 &lt;code&gt;&lt;a href=&quot;reset&quot;&gt;reset()&lt;/a&gt;&lt;/code&gt; 销毁当前包含的对象（如果有），然后：</target>
        </trans-unit>
        <trans-unit id="401e859548baba3ec799317e533e96d7551f1830" translate="yes" xml:space="preserve">
          <source>First version</source>
          <target state="translated">第一版</target>
        </trans-unit>
        <trans-unit id="1654933a6fa4f43716580ffeb045cae1b208fe38" translate="yes" xml:space="preserve">
          <source>First, &lt;a href=&quot;implicit_cast&quot;&gt;Pointer conversions&lt;/a&gt; (pointer to member conversions if the arguments are pointers to members), function pointer conversions,(since C++17) and &lt;a href=&quot;implicit_cast&quot;&gt;qualification conversions&lt;/a&gt; are applied to both operands to obtain the</source>
          <target state="translated">首先，将&lt;a href=&quot;implicit_cast&quot;&gt;指针转换&lt;/a&gt;（如果参数是指向成员的指针，则指向成员的指针转换），函数指针转换（自C ++ 17起）和&lt;a href=&quot;implicit_cast&quot;&gt;限定转换&lt;/a&gt;应用于这两个操作数，以获得</target>
        </trans-unit>
        <trans-unit id="30c242bb4e4e1c97688da86303f8e70ebf723f0f" translate="yes" xml:space="preserve">
          <source>First, allocates or resizes the private storage (dynamic array of &lt;code&gt;long&lt;/code&gt; or another indexable data structure) sufficiently to make &lt;code&gt;index&lt;/code&gt; a valid index, then returns a reference to the &lt;code&gt;long&lt;/code&gt; element of the private storage with the index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">首先，分配或调整大小的私有存储（动态阵列 &lt;code&gt;long&lt;/code&gt; 或另一个可转位数据结构）足够使 &lt;code&gt;index&lt;/code&gt; 有效的索引，然后返回到基准 &lt;code&gt;long&lt;/code&gt; 与所述索引中的私有存储的元素 &lt;code&gt;index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c741d459f4a943d6ccb7e91f1d19877e2b46cf15" translate="yes" xml:space="preserve">
          <source>First, allocates or resizes the private storage (dynamic array of &lt;code&gt;void*&lt;/code&gt; or another indexable data structure) sufficiently to make &lt;code&gt;index&lt;/code&gt; a valid index, then returns a reference to the &lt;code&gt;void*&lt;/code&gt; element of the private storage with the index &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">首先，分配或调整大小的私有存储（动态阵列 &lt;code&gt;void*&lt;/code&gt; 或另一个可转位数据结构）足够使 &lt;code&gt;index&lt;/code&gt; 有效的索引，然后返回到基准 &lt;code&gt;void*&lt;/code&gt; 与索引中的私有存储的元素 &lt;code&gt;index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1a406a5e11adcba583e47ceded69c0a59895e04" translate="yes" xml:space="preserve">
          <source>First, attempts to close the file associated with &lt;code&gt;stream&lt;/code&gt;, ignoring any errors. Then, if &lt;code&gt;filename&lt;/code&gt; is not null, attempts to open the file specified by &lt;code&gt;filename&lt;/code&gt; using &lt;code&gt;mode&lt;/code&gt; as if by &lt;code&gt;fopen&lt;/code&gt;, and associates that file with the file stream pointed to by &lt;code&gt;stream&lt;/code&gt;. If &lt;code&gt;filename&lt;/code&gt; is a null pointer, then the function attempts to reopen the file that is already associated with &lt;code&gt;stream&lt;/code&gt; (it is implementation defined which mode changes are allowed in this case).</source>
          <target state="translated">首先，尝试关闭与 &lt;code&gt;stream&lt;/code&gt; 关联的文件，忽略任何错误。然后，如果 &lt;code&gt;filename&lt;/code&gt; 不为空，试图打开由指定的文件 &lt;code&gt;filename&lt;/code&gt; 使用 &lt;code&gt;mode&lt;/code&gt; 仿佛 &lt;code&gt;fopen&lt;/code&gt; 和同事与该文件的流文件由指向 &lt;code&gt;stream&lt;/code&gt; 。如果 &lt;code&gt;filename&lt;/code&gt; 是一个空指针，则该函数尝试重新打开已经与 &lt;code&gt;stream&lt;/code&gt; 关联的文件（由实现定义，在这种情况下，允许哪种模式更改）。</target>
        </trans-unit>
        <trans-unit id="5badc51c36e2585292a914e3f1823ec376257caf" translate="yes" xml:space="preserve">
          <source>First, before doing anything else, obtains type and permissions of &lt;code&gt;from&lt;/code&gt; by no more than a single call to</source>
          <target state="translated">首先，在执行其他任何操作之前， &lt;code&gt;from&lt;/code&gt; 通过一次调用即可获得的类型和权限</target>
        </trans-unit>
        <trans-unit id="bd0a7f661657d89c37e4c1215e80d0191bb4862d" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt; to transmit all pending output (and delayed flush, if any) to the wrapped stream.</source>
          <target state="translated">首先，调用&lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt;将所有待处理的输出（和延迟的刷新，如果有的话）传输到包装的流。</target>
        </trans-unit>
        <trans-unit id="eab9bd2628b9d318b166ebaf056d0f32c1ae9059" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. If an exception is thrown by the call to &lt;code&gt;emit()&lt;/code&gt;, it is caught and ignored.</source>
          <target state="translated">首先，调用&lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt;。如果对 &lt;code&gt;emit()&lt;/code&gt; 的调用引发了异常，则将捕获并忽略该异常。</target>
        </trans-unit>
        <trans-unit id="daac23b0d5c1b3ef73330f0f556ea905967387b5" translate="yes" xml:space="preserve">
          <source>First, calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;. If an exception is thrown by the call to &lt;code&gt;emit()&lt;/code&gt;, it is caught and ignored. Then, destroys the member &lt;code&gt;std::basic_syncbuf&lt;/code&gt; and the base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; as usual.</source>
          <target state="translated">首先，调用&lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt;。如果对 &lt;code&gt;emit()&lt;/code&gt; 的调用引发了异常，则将捕获并忽略该异常。然后， &lt;code&gt;std::basic_syncbuf&lt;/code&gt; 销毁成员std :: basic_syncbuf和基本 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99f9e198aa798816c58da32cfc0095d286931e68" translate="yes" xml:space="preserve">
          <source>First, clears the error bits in &lt;code&gt;err&lt;/code&gt; by executing &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt;. Then reads characters from the input sequence &lt;code&gt;[beg, end)&lt;/code&gt; that are expected by the &lt;code&gt;&lt;a href=&quot;../time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; format specifier formed by combining &lt;code&gt;'%'&lt;/code&gt;, &lt;code&gt;modifier&lt;/code&gt; (if not &lt;code&gt;'\0'&lt;/code&gt;), and &lt;code&gt;format&lt;/code&gt;. If the characters do not combine to form a valid conversion specifier, sets &lt;code&gt;failbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If the end of the input stream is reached after reading a character, sets &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If the input string was parsed successfully, updates the corresponding fields of &lt;code&gt;*t&lt;/code&gt;.   For complex conversion specifiers, such as &lt;code&gt;'%x'&lt;/code&gt; or &lt;code&gt;'%c'&lt;/code&gt;, or the directives that use the modifiers &lt;code&gt;'E'&lt;/code&gt; and &lt;code&gt;'O'&lt;/code&gt;, the function may fail to determine some of the values to store in &lt;code&gt;*t&lt;/code&gt;. In such case, it sets &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt; and leaves these fields in unspecified state.</source>
          <target state="translated">首先，通过执行 &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std :: ios_base :: goodbit&lt;/a&gt;清除 &lt;code&gt;err&lt;/code&gt; 中的错误位。然后从输入序列 &lt;code&gt;[beg, end)&lt;/code&gt; 读取由 &lt;code&gt;&lt;a href=&quot;../time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; 格式说明符期望的字符，该说明符由 &lt;code&gt;'%'&lt;/code&gt; ， &lt;code&gt;modifier&lt;/code&gt; （如果不是 &lt;code&gt;'\0'&lt;/code&gt; ）和 &lt;code&gt;format&lt;/code&gt; 组合而成。如果字符没有组合在一起形成有效的转换说明符，请在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;failbit&lt;/code&gt; 。如果在读取字符后到达输入流的末尾，请在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;eofbit&lt;/code&gt; 。如果输入字符串已成功解析，请更新 &lt;code&gt;*t&lt;/code&gt; 。对于复杂的转换说明符，例如 &lt;code&gt;'%x'&lt;/code&gt; 或 &lt;code&gt;'%c'&lt;/code&gt; 或使用修饰符 &lt;code&gt;'E'&lt;/code&gt; 和 &lt;code&gt;'O'&lt;/code&gt; 的指令，该函数可能无法确定要存储在 &lt;code&gt;*t&lt;/code&gt; 中的某些值。在这种情况下，它会在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;eofbit&lt;/code&gt; ，并使这些字段保持未指定状态。</target>
        </trans-unit>
        <trans-unit id="761e411f45989f18b8cdc09dfae5d408bc3760bb" translate="yes" xml:space="preserve">
          <source>First, expr is converted to an awaitable as follows:</source>
          <target state="translated">首先,将expr转换为awareitable,如下。</target>
        </trans-unit>
        <trans-unit id="49e86d447ef30f5d8ac55d11082a293ce491a304" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, performs the ISO/IEC/IEEE 60559</source>
          <target state="translated">首先，如果 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则执行ISO / IEC / IEEE 60559</target>
        </trans-unit>
        <trans-unit id="714bfffed5c4d1159d21c2074b0dd5ebd28587dd" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;T&lt;/code&gt; is a class type and the initializer is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; expression whose cv-unqualified type is the same class as &lt;code&gt;T&lt;/code&gt;, the initializer expression itself, rather than a temporary materialized from it, is used to initialize the destination object: see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;</source>
          <target state="translated">首先，如果 &lt;code&gt;T&lt;/code&gt; 是类类型，并且初始化器是&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;表达式，其cv不合格类型与 &lt;code&gt;T&lt;/code&gt; 是同一类，则初始化器表达式本身（而不是从其实例化的）用于初始化目标对象：请参见&lt;a href=&quot;copy_elision&quot;&gt;copy省略&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a19b536bb9ed4bb6c617709d11bbfa515bb05a0" translate="yes" xml:space="preserve">
          <source>First, if &lt;code&gt;root_name() != base.root_name() || is_absolute() != base.is_absolute() || (!has_root_directory() &amp;amp;&amp;amp; base.has_root_directory())&lt;/code&gt;, returns a default-constructed path.</source>
          <target state="translated">首先，如果 &lt;code&gt;root_name() != base.root_name() || is_absolute() != base.is_absolute() || (!has_root_directory() &amp;amp;&amp;amp; base.has_root_directory())&lt;/code&gt; ，返回默认构造的路径。</target>
        </trans-unit>
        <trans-unit id="0af0623ac822520c62720be6f5b81d9ab7f82065" translate="yes" xml:space="preserve">
          <source>First, records that a flush is pending, by updating the appropriate private flag.</source>
          <target state="translated">首先,通过更新相应的私有标志,记录刷新正在进行。</target>
        </trans-unit>
        <trans-unit id="a3dedc18a8aa37448d34180fda53b30fdca03e04" translate="yes" xml:space="preserve">
          <source>First, remembers the currently raised floating-point exceptions, then restores the floating-point environment from the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt;), then raises the floating-point exceptions that were saved.</source>
          <target state="translated">首先，记住当前引发的浮点异常，然后从 &lt;code&gt;envp&lt;/code&gt; 指向的对象（类似于 &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt; ）还原浮点环境，然后引发已保存的浮点异常。</target>
        </trans-unit>
        <trans-unit id="f26f81a265113be2257dfeddeb17e46ef91bc7df" translate="yes" xml:space="preserve">
          <source>First, retrieve the outermost allocator &lt;code&gt;OUTERMOST&lt;/code&gt; by calling &lt;code&gt;this-&amp;gt;outer_allocator()&lt;/code&gt;, and then calling the &lt;code&gt;outer_allocator()&lt;/code&gt; member function recursively on the result of this call until reaching an allocator that has no such member function.</source>
          <target state="translated">首先，通过调用 &lt;code&gt;this-&amp;gt;outer_allocator()&lt;/code&gt; 检索最外面的分配器 &lt;code&gt;OUTERMOST&lt;/code&gt; ，然后根据此调用的结果递归地调用 &lt;code&gt;outer_allocator()&lt;/code&gt; 成员函数，直到到达没有此类成员函数的分配器。</target>
        </trans-unit>
        <trans-unit id="b22ed5216bdf7ab4edb25ec8436348da2427fb87" translate="yes" xml:space="preserve">
          <source>First, saves the current floating-point environment to the object pointed to by &lt;code&gt;envp&lt;/code&gt; (similar to &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fegetenv&lt;/a&gt;&lt;/code&gt;), then clears all floating-point status flags, and then installs the non-stop mode: future floating-point exceptions will not interrupt execution (will not trap), until the floating-point environment is restored by &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">首先，将当前浮点环境保存到 &lt;code&gt;envp&lt;/code&gt; 指向的对象（类似于 &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fegetenv&lt;/a&gt;&lt;/code&gt; ），然后清除所有浮点状态标志，然后安装不间断模式：将来的浮点异常不会中断执行（不会陷阱），直到由 &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;feenv&quot;&gt;std::fesetenv&lt;/a&gt;&lt;/code&gt; 恢复浮点环境为止。</target>
        </trans-unit>
        <trans-unit id="19ae2c760d73ee6a549348974c9ddff8cc5fef2c" translate="yes" xml:space="preserve">
          <source>First, set each element of the output range to the value &lt;code&gt;0x8b8b8b8b&lt;/code&gt;</source>
          <target state="translated">首先，将输出范围的每个元素设置为值 &lt;code&gt;0x8b8b8b8b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37c02899047a91960018379b0f4a7201e2a7714f" translate="yes" xml:space="preserve">
          <source>First, the argument-dependent lookup is not considered if the lookup set produced by usual &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt; contains any of the following:</source>
          <target state="translated">首先，如果通常的&lt;a href=&quot;lookup&quot;&gt;不合格查询&lt;/a&gt;产生的查询集包含以下任何一项，则不考虑与参数相关的查询：</target>
        </trans-unit>
        <trans-unit id="71da67e0b30adfe6e4f96fe9e13991f6f8a033f3" translate="yes" xml:space="preserve">
          <source>Firstly, if this path has an &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension()&lt;/code&gt;&lt;/a&gt;, it is removed from the generic-format view of the pathname.</source>
          <target state="translated">首先，如果此路径具有&lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension()&lt;/code&gt; &lt;/a&gt;，则将其从路径名的通用格式视图中删除。</target>
        </trans-unit>
        <trans-unit id="d24ff9bf0ed02a5411428beac3e4bd1d30fe9f46" translate="yes" xml:space="preserve">
          <source>Five &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;span&lt;/code&gt;.</source>
          <target state="translated">为 &lt;code&gt;span&lt;/code&gt; 提供了五种&lt;a href=&quot;../../language/deduction_guide&quot;&gt;扣除指南&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27e98ae5f197207336755cc33861b5d103faad58" translate="yes" xml:space="preserve">
          <source>Fixed width integer types</source>
          <target state="translated">固定宽度的整数类型</target>
        </trans-unit>
        <trans-unit id="a96f6d996f06dc7144585656dcc077cf300a6377" translate="yes" xml:space="preserve">
          <source>Fixed width integer types (since C++11)</source>
          <target state="translated">固定宽度的整数类型(自C++11起)</target>
        </trans-unit>
        <trans-unit id="0a6c931f357cf026414e375b77b04d8235b7334d" translate="yes" xml:space="preserve">
          <source>Flag type and operations</source>
          <target state="translated">标志类型和操作</target>
        </trans-unit>
        <trans-unit id="27cbb35a9b1b271932f7636ca4faaede088277a2" translate="yes" xml:space="preserve">
          <source>Flips bits, i.e. changes &lt;code&gt;true&lt;/code&gt; values to &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; values to &lt;code&gt;true&lt;/code&gt;. Equivalent to a logical NOT operation on part or all of the bitset.</source>
          <target state="translated">翻转位，即将 &lt;code&gt;true&lt;/code&gt; 值更改为 &lt;code&gt;false&lt;/code&gt; ，将 &lt;code&gt;false&lt;/code&gt; 值更改为 &lt;code&gt;true&lt;/code&gt; 。等效于部分或全部位集中的逻辑&amp;ldquo;非&amp;rdquo;运算。</target>
        </trans-unit>
        <trans-unit id="b5dfec7a1df7a1c20eb6ca15e9bee0c75b291919" translate="yes" xml:space="preserve">
          <source>Floating point literal defines a compile-time constant whose value is specified in the source file.</source>
          <target state="translated">浮点文字定义了一个编译时常量,其值在源文件中指定。</target>
        </trans-unit>
        <trans-unit id="530b771e0a4d9da8f37e390916e11d1da9b65536" translate="yes" xml:space="preserve">
          <source>Floating point manipulation functions</source>
          <target state="translated">浮点操作功能</target>
        </trans-unit>
        <trans-unit id="4cdfaff55d21c2eb1c0a0dbeace3c9c4e378eda8" translate="yes" xml:space="preserve">
          <source>Floating point types</source>
          <target state="translated">浮点类型</target>
        </trans-unit>
        <trans-unit id="931a4d33f9a7670df77e53c7e39d2883c52b8c58" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned and *str_end is set to str.</source>
          <target state="translated">浮点值对应于 &lt;code&gt;str&lt;/code&gt; 成功的内容。如果转换后的值超出相应返回类型的范围，则发生范围错误，并返回 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; 。如果不能进行转换， &lt;code&gt;​0​&lt;/code&gt; 返回和* str_end设置为海峡。</target>
        </trans-unit>
        <trans-unit id="5679c54758fee21d770fd6c545d0c43032628157" translate="yes" xml:space="preserve">
          <source>Floating point value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">浮点值对应于 &lt;code&gt;str&lt;/code&gt; 成功的内容。如果转换后的值超出相应返回类型的范围，则发生范围错误，并返回 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VAL&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALF&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../numeric/math/huge_val&quot;&gt;HUGE_VALL&lt;/a&gt;&lt;/code&gt; 。如果不能进行转换， &lt;code&gt;​0​&lt;/code&gt; 被返回。</target>
        </trans-unit>
        <trans-unit id="d2f57b6272c09794ad846fa25baa135845cf2031" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the &amp;mu; distribution parameter.</source>
          <target state="translated">标识&amp;mu;分布参数的浮点值。</target>
        </trans-unit>
        <trans-unit id="9a1cf11d8c926cc9f1bbac062621307bdc11199f" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the degrees of freedom of the distribution.</source>
          <target state="translated">确定分布自由度的浮点值。</target>
        </trans-unit>
        <trans-unit id="a725365fc9cc7788cab748ff13281e3d748d0017" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the p distribution parameter.</source>
          <target state="translated">浮点值,表示p分布参数。</target>
        </trans-unit>
        <trans-unit id="3bfd050a822b215062fc674739b968774ba30a01" translate="yes" xml:space="preserve">
          <source>Floating point value identifying the rate of events per unit.</source>
          <target state="translated">浮点值,表示每单位的事件发生率。</target>
        </trans-unit>
        <trans-unit id="5c65e500905d168962e036e5e1c8cfd585b5a35a" translate="yes" xml:space="preserve">
          <source>Floating point value in range [0, 1).</source>
          <target state="translated">浮点值,范围[0,1)。</target>
        </trans-unit>
        <trans-unit id="a4edd9f5da9c5bff6fa7351be1698e5f17713a8e" translate="yes" xml:space="preserve">
          <source>Floating&amp;ndash;integral conversions</source>
          <target state="translated">浮点积分转换</target>
        </trans-unit>
        <trans-unit id="fe4d2e99025a6ead51e9b2e632c32efaa3c94a25" translate="yes" xml:space="preserve">
          <source>Floating-point contraction</source>
          <target state="translated">浮点收缩</target>
        </trans-unit>
        <trans-unit id="a694704378ed350bc958fb519c8315b5d52a02b7" translate="yes" xml:space="preserve">
          <source>Floating-point conversions</source>
          <target state="translated">浮点转换</target>
        </trans-unit>
        <trans-unit id="037c72279324a50181c71503f07e7e0083f1c23d" translate="yes" xml:space="preserve">
          <source>Floating-point environment</source>
          <target state="translated">浮点环境</target>
        </trans-unit>
        <trans-unit id="fc13961bdda58d06692a8ad8f8156b2841512415" translate="yes" xml:space="preserve">
          <source>Floating-point expressions may have greater range and precision than indicated by their types, see &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;. Floating-point expressions may also be</source>
          <target state="translated">浮点表达式的范围和精度可能超出其类型指示的范围，请参见 &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; 。浮点表达式也可能是</target>
        </trans-unit>
        <trans-unit id="0e05b4ea4725d83345dcb31354835a769615b781" translate="yes" xml:space="preserve">
          <source>Floating-point promotion</source>
          <target state="translated">浮点促销</target>
        </trans-unit>
        <trans-unit id="f74d231baa71e2a641e3234ad91f55a94e0aa7a0" translate="yes" xml:space="preserve">
          <source>Floating-point types may support &lt;a href=&quot;../types/numeric_limits&quot;&gt;special values&lt;/a&gt;:</source>
          <target state="translated">浮点类型可能支持&lt;a href=&quot;../types/numeric_limits&quot;&gt;特殊值&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="a26e00b84e77b40bea4bb511f8f60ed076daa97b" translate="yes" xml:space="preserve">
          <source>Flowing off the end of a value-returning function (except &lt;code&gt;main&lt;/code&gt;) without a return statement is undefined behavior.</source>
          <target state="translated">在没有返回语句的情况下从值返回函数的末尾流出（ &lt;code&gt;main&lt;/code&gt; 除外）是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="6666b9fcba2b772c274346c92162b6c1a3611ada" translate="yes" xml:space="preserve">
          <source>Flushes the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.flush()&lt;/code&gt;.</source>
          <target state="translated">就像调用 &lt;code&gt;os.flush()&lt;/code&gt; 一样刷新输出序列 &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cdb990f130f6549318c7c3b84780625f76de3f4" translate="yes" xml:space="preserve">
          <source>Flushes the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.flush()&lt;/code&gt;. Then, if &lt;code&gt;os.rdbuf()&lt;/code&gt; actually points to a &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt;&lt;code&gt;buf&lt;/code&gt;, calls &lt;code&gt;buf.emit()&lt;/code&gt;.</source>
          <target state="translated">就像调用 &lt;code&gt;os.flush()&lt;/code&gt; 一样刷新输出序列 &lt;code&gt;os&lt;/code&gt; 。然后，如果 &lt;code&gt;os.rdbuf()&lt;/code&gt; 实际上指向 &lt;code&gt;&lt;a href=&quot;../basic_syncbuf&quot;&gt;std::basic_syncbuf&lt;/a&gt;&amp;lt;CharT, Traits, Allocator&amp;gt;&lt;/code&gt; &amp;lt;CharT，Traits，Allocator&amp;gt; &lt;code&gt;buf&lt;/code&gt; ，则调用 &lt;code&gt;buf.emit()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4727f15c3dadc6abc3267b67039a85b366a9aeb" translate="yes" xml:space="preserve">
          <source>Flushing is performed in the destructor of the &lt;code&gt;&lt;a href=&quot;../basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; object, which calls &lt;code&gt;str.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; if &lt;code&gt;str.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt; == true&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;&lt;a href=&quot;../basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; 对象的析构函数中执行 &lt;code&gt;str.rdbuf()-&amp;gt;pubsync()&lt;/code&gt; 如果 &lt;code&gt;str.flags() &amp;amp; &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt; == true&lt;/code&gt; ，则该对象将调用str.rdbuf（）-&amp;gt; pubsync（）。</target>
        </trans-unit>
        <trans-unit id="dd2e024a054d8c1876c1f1a73eab175647867cec" translate="yes" xml:space="preserve">
          <source>Fold expressions</source>
          <target state="translated">折叠表达式</target>
        </trans-unit>
        <trans-unit id="820f688950b36fa22a06159885b2b0b589f17953" translate="yes" xml:space="preserve">
          <source>Fold-expressions</source>
          <target state="translated">Fold-expressions</target>
        </trans-unit>
        <trans-unit id="73ea87451f9d5e42c6d3450b515bcb3f98250b83" translate="yes" xml:space="preserve">
          <source>Follow rather than skip directory symlinks.</source>
          <target state="translated">遵循而不是跳过目录符号链接。</target>
        </trans-unit>
        <trans-unit id="c9eac869d3c658b081e1a95ca062116b32f0aaa4" translate="yes" xml:space="preserve">
          <source>Follow symlinks (default behavior)</source>
          <target state="translated">遵循符号链接(默认行为</target>
        </trans-unit>
        <trans-unit id="9d728e94fbab96a42d3b4d9a6cb222f5e938822e" translate="yes" xml:space="preserve">
          <source>Following exposition-only concepts are used for several types, but they are not parts of the interface of standard library.</source>
          <target state="translated">以下是一些类型中使用的仅有说明的概念,但它们不是标准库接口的一部分。</target>
        </trans-unit>
        <trans-unit id="6f40e40d82fd8846da49808b0b708490ce0379e1" translate="yes" xml:space="preserve">
          <source>Following member functions are conditionally different from corresponding member functions of &lt;code&gt;&lt;a href=&quot;../utility/optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">以下成员函数在条件上不同于 &lt;code&gt;&lt;a href=&quot;../utility/optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; 相应成员函数。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="2eedcffa258b92b2d623f330307d6610480c73b1" translate="yes" xml:space="preserve">
          <source>For (1), &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">对于（1）， &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 对所有 &lt;code&gt;T_i&lt;/code&gt; 在 &lt;code&gt;Types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27e932e63be3980babb2b5c3e1834eb9ece2f5cb" translate="yes" xml:space="preserve">
          <source>For (1),&lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">对于（1）， &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_copy_assignable&quot;&gt;std::is_copy_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cce1fc39ab817dad0417c749a97b121fa9da8698" translate="yes" xml:space="preserve">
          <source>For (1-3), if the result would be outside the range [0, 255], the actual stored value is unspecified.</source>
          <target state="translated">对于(1-3),如果结果超出了[0,255]的范围,则实际的存储值是不指定的。</target>
        </trans-unit>
        <trans-unit id="80750dcb6fca71c81371e8509ae0e5a32ea184f9" translate="yes" xml:space="preserve">
          <source>For (2), &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">对于（2）， &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;T_i&amp;gt;::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 对所有 &lt;code&gt;T_i&lt;/code&gt; 在 &lt;code&gt;Types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf60873df305a2582da8245d9a95bc5dabb1f1c1" translate="yes" xml:space="preserve">
          <source>For (2),&lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">对于（2）， &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e266ee47c94d97b82af99ef255fd0f260a99d2c" translate="yes" xml:space="preserve">
          <source>For (3), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, const U_i&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all corresponding pairs of types &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt; and &lt;code&gt;U_i&lt;/code&gt; in &lt;code&gt;UTypes&lt;/code&gt;.</source>
          <target state="translated">对于（3）， &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, const U_i&amp;amp;&amp;gt;::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 对类型的所有相应对 &lt;code&gt;T_i&lt;/code&gt; 在 &lt;code&gt;Types&lt;/code&gt; 和 &lt;code&gt;U_i&lt;/code&gt; 在 &lt;code&gt;UTypes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="235c0ae5251a55b5cc4853b6e31b390a6d489d01" translate="yes" xml:space="preserve">
          <source>For (3),&lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">对于（3）， &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;first_type&amp;gt;::value&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_move_assignable&quot;&gt;std::is_move_assignable&lt;/a&gt;&amp;lt;second_type&amp;gt;::value&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c23beb9ab1e1686d723073f239e4dd5ad833ba8" translate="yes" xml:space="preserve">
          <source>For (4), &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, U_i&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all corresponding pairs of types &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types&lt;/code&gt; and &lt;code&gt;U_i&lt;/code&gt; in &lt;code&gt;UTypes&lt;/code&gt;.</source>
          <target state="translated">对于（4）， &lt;code&gt;sizeof...(UTypes) == sizeof...(Types)&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_i&amp;amp;, U_i&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 对类型的所有相应对 &lt;code&gt;T_i&lt;/code&gt; 在 &lt;code&gt;Types&lt;/code&gt; 和 &lt;code&gt;U_i&lt;/code&gt; 在 &lt;code&gt;UTypes&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d612fce9fe1d1b17e3a906128095373ba91170e6" translate="yes" xml:space="preserve">
          <source>For (4),&lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">对于（4）， &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;first_type&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;second_type&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6dc7376755e98b71c2080e8a531379170a9f0d46" translate="yes" xml:space="preserve">
          <source>For (5), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, where &lt;code&gt;T_0&lt;/code&gt; and &lt;code&gt;T_1&lt;/code&gt; are the two types constituting &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">对于（5）， &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; 且 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, const U1&amp;amp;&amp;gt;::value&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; ，其中 &lt;code&gt;T_0&lt;/code&gt; 和 &lt;code&gt;T_1&lt;/code&gt; 是构成 &lt;code&gt;Types&lt;/code&gt; 的两个类型。</target>
        </trans-unit>
        <trans-unit id="94214e5075f274a6f5fa7b33c9435afe45df0332" translate="yes" xml:space="preserve">
          <source>For (6), &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;, where &lt;code&gt;T_0&lt;/code&gt; and &lt;code&gt;T_1&lt;/code&gt; are the two types constituting &lt;code&gt;Types&lt;/code&gt;.</source>
          <target state="translated">对于（6）， &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; 并且 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_0&amp;amp;, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;T_1&amp;amp;, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; ，其中 &lt;code&gt;T_0&lt;/code&gt; 和 &lt;code&gt;T_1&lt;/code&gt; 为这两个类型构成 &lt;code&gt;Types&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="83856baa7fbad81b10e160970bde088c89421d40" translate="yes" xml:space="preserve">
          <source>For 0&amp;le;arg&amp;le;1,</source>
          <target state="translated">对于0&amp;le;arg&amp;le;1，</target>
        </trans-unit>
        <trans-unit id="3bd6dc6d78016b2a3f1c8c074db727a1bd8e2c50" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types, value representation is a part of the object representation, which means that copying the bytes occupied by the object in the storage is sufficient to produce another object with the same value (except if the value is a</source>
          <target state="translated">对于&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;类型，值表示形式是对象表示形式的一部分，这意味着复制该对象在存储区中所占用的字节足以产生具有相同值的另一个对象（除非该值是</target>
        </trans-unit>
        <trans-unit id="a6d068410c3d5d5e1e66f214a4705f1da0744b99" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">对于&lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt;循环，它的作用是：</target>
        </trans-unit>
        <trans-unit id="192dfceddbf339e300daed630beff6523e185814" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; and &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt; loop, it acts as:</source>
          <target state="translated">对于&lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;和&lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;循环，它的作用是：</target>
        </trans-unit>
        <trans-unit id="25d4ebe9fb8814a98da8afb721d4a6bdeed00a0f" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; &amp;gt; and &amp;ge; respectively</source>
          <target state="translated">对于&lt;a href=&quot;operator_comparison&quot;&gt;关系运算符&lt;/a&gt; &amp;gt;和&amp;ge;</target>
        </trans-unit>
        <trans-unit id="c82d883f6eaf9d2b9ddb7fd8e6adaa4e2930e681" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; &amp;lt; and &amp;le; respectively</source>
          <target state="translated">对于&lt;a href=&quot;operator_comparison&quot;&gt;关系运算符&lt;/a&gt; &amp;lt;和&amp;le;</target>
        </trans-unit>
        <trans-unit id="80184e736b13dd44e9e03f7f4a2465c93e2f10ce" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;operator_comparison&quot;&gt;relational operators&lt;/a&gt; = and &amp;ne; respectively</source>
          <target state="translated">对于&lt;a href=&quot;operator_comparison&quot;&gt;关系运算符&lt;/a&gt;，分别为=和&amp;ne;</target>
        </trans-unit>
        <trans-unit id="67db5ac16c817d0aad978db1daa9912c166fac6a" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, it acts as.</source>
          <target state="translated">对于&lt;a href=&quot;while&quot;&gt;while&lt;/a&gt;循环，它充当。</target>
        </trans-unit>
        <trans-unit id="2ceb12570320e8236ce37933edca4d8d71e4edce" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio&quot;&gt;std::micro&lt;/a&gt;&lt;/code&gt;, if the character &amp;micro; (U+00B5) cannot be represented in the encoding used for &lt;code&gt;CharT&lt;/code&gt;, the suffix &quot;&lt;code&gt;us&lt;/code&gt;&quot; is used instead.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;../../numeric/ratio/ratio&quot;&gt;std::micro&lt;/a&gt;&lt;/code&gt; ，如果无法在用于 &lt;code&gt;CharT&lt;/code&gt; 的编码中表示字符&amp;micro;（U + 00B5），则使用后缀&amp;ldquo; &lt;code&gt;us&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="decd50a2a6c24904b14b0159d4b4ee28edc12dd8" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, the elements are bytes (objects of type char), which are not the same as characters if a multibyte encoding such as UTF-8 is used.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; ，元素为字节（char类型的对象），如果使用多字节编码（例如UTF-8），则该字符与字符不同。</target>
        </trans-unit>
        <trans-unit id="4fc81475176c004bf7dd4b13445be6b3d996668a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; the value type is the same as the key type and both &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; are constant iterators. For &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; the value type is &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; 其值类型与键类型相同，并且 &lt;code&gt;iterator&lt;/code&gt; 和 &lt;code&gt;const_iterator&lt;/code&gt; 均为常量迭代器。对于 &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; 其值类型为 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d3533c7dfac4c0a2f11001f27ce7038422be45e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;T*&lt;/code&gt; types, the result may be an undefined address, but the operation otherwise has no undefined behavior. The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is not an object type.</source>
          <target state="translated">对于 &lt;code&gt;T*&lt;/code&gt; 类型，结果可能是未定义的地址，但该操作没有其他未定义的行为。如果 &lt;code&gt;T&lt;/code&gt; 不是对象类型，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="6d8b259c841d7fe56fd4cbc44dbede3d4a2f5d45" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;T*&lt;/code&gt; types, the result may be an undefined address, but the operations otherwise have no undefined behavior. The program is ill-formed if &lt;code&gt;T&lt;/code&gt; is not an object type.</source>
          <target state="translated">对于 &lt;code&gt;T*&lt;/code&gt; 类型，结果可能是未定义的地址，但其他操作则没有未定义的行为。如果 &lt;code&gt;T&lt;/code&gt; 不是对象类型，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="fdab33fa5bc42221e341bfb5aa446019046bda10" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;allocate_shared&lt;/code&gt;, the object (or the individual array elements for (2-5))(since C++20) are destroyed via the expression &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::destroy(a, p)&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;a&lt;/code&gt; is a copy of the allocator passed to &lt;code&gt;allocate_shared&lt;/code&gt;, rebound to the type of the object being destroyed.</source>
          <target state="translated">对于 &lt;code&gt;allocate_shared&lt;/code&gt; ，对象（或（2-5）的单个数组元素）（自C ++ 20起）通过表达式 &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::destroy(a, p)&lt;/code&gt; ，其中 &lt;code&gt;p&lt;/code&gt; 为a指向对象的指针， &lt;code&gt;a&lt;/code&gt; 是传递给 &lt;code&gt;allocate_shared&lt;/code&gt; 的分配器的副本，反弹到被破坏对象的类型。</target>
        </trans-unit>
        <trans-unit id="ffeded1df965bfced36bed8a9a11d97603f70744" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;allocate_shared_default_init&lt;/code&gt;, the object (or individual elements if &lt;code&gt;T&lt;/code&gt; is an array type) will be destroyed by &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;X&lt;/code&gt; is its type.</source>
          <target state="translated">对于 &lt;code&gt;allocate_shared_default_init&lt;/code&gt; ，对象（或单个元素，如果 &lt;code&gt;T&lt;/code&gt; 是数组类型）将被 &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt; 破坏，其中 &lt;code&gt;p&lt;/code&gt; 是指向对象的指针， &lt;code&gt;X&lt;/code&gt; 是对象的类型。</target>
        </trans-unit>
        <trans-unit id="eaf9872d7fc84f0c3657f05544061163d1795a7f" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;k = 0,..., m-1&lt;/code&gt;</source>
          <target state="translated">对于 &lt;code&gt;k = 0,..., m-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a84133a6d81bd30988c564a8a6cf37a9783a4cf" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;k = m,..., m+n-1&lt;/code&gt;,</source>
          <target state="translated">对于 &lt;code&gt;k = m,..., m+n-1&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="3702c14d2d2a72e5ae19407c373383886d03512a" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;operator,&lt;/code&gt;, the unary &lt;code&gt;operator&amp;amp;&lt;/code&gt;, and &lt;code&gt;operator-&amp;gt;&lt;/code&gt;, if there are no viable functions (see below) in the set of candidate functions, then the operator is reinterpreted as a built-in.</source>
          <target state="translated">对于 &lt;code&gt;operator,&lt;/code&gt; 一元运算 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 和 &lt;code&gt;operator-&amp;gt;&lt;/code&gt; ，如果候选函数集中没有可行的函数（请参见下文），则该运算符将重新解释为内置函数。</target>
        </trans-unit>
        <trans-unit id="0d394b44570e5e62b408fa0499880cd8eb0cf013" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::binary_search&lt;/code&gt; to succeed, the range &lt;code&gt;[first, last)&lt;/code&gt; must be at least partially ordered with respect to &lt;code&gt;value&lt;/code&gt;, i.e. it must satisfy all of the following requirements:</source>
          <target state="translated">为了使 &lt;code&gt;std::binary_search&lt;/code&gt; 成功，范围 &lt;code&gt;[first, last)&lt;/code&gt; 必须相对于 &lt;code&gt;value&lt;/code&gt; 至少部分排序，即它必须满足以下所有要求：</target>
        </trans-unit>
        <trans-unit id="82aaf8ae9515fcaa10aa37778070bfaa5e42e07b" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::lrint&lt;/code&gt; and &lt;code&gt;std::llrint&lt;/code&gt; functions:</source>
          <target state="translated">对于 &lt;code&gt;std::lrint&lt;/code&gt; 和 &lt;code&gt;std::llrint&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="386ec7b95ea37fdce144fa4084a418bcda9d46f7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;std::lround&lt;/code&gt; and &lt;code&gt;std::llround&lt;/code&gt; functions:</source>
          <target state="translated">对于 &lt;code&gt;std::lround&lt;/code&gt; 和 &lt;code&gt;std::llround&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="93056bf6dac8be93c20bc17806b06200f88a2398" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined move assignment operator copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">对于 &lt;code&gt;union&lt;/code&gt; 类型，隐式定义的移动分配运算符将复制对象表示形式（如 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ab727ef011ac32b32b71004213c9062e03c40ca6" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow happens if &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; or if &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt;.</source>
          <target state="translated">对于IEEE兼容类型 &lt;code&gt;double&lt;/code&gt; ，如果 &lt;code&gt;0 &amp;lt; x &amp;lt; 1/DBL_MAX&lt;/code&gt; 或 &lt;code&gt;x &amp;gt; 171.7&lt;/code&gt; 就会发生溢出。</target>
        </trans-unit>
        <trans-unit id="308485408ad23c9a6a581efd5af8112d70a5819e" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg, and underflow is guaranteed if arg &amp;lt; -708.4.</source>
          <target state="translated">对于IEEE兼容类型 &lt;code&gt;double&lt;/code&gt; ，如果709.8 &amp;lt;arg，则保证上溢，如果arg &amp;lt;-708.4，则保证下溢。</target>
        </trans-unit>
        <trans-unit id="9ebd607b970e88332eac8b1adf8c8066c0dd8e42" translate="yes" xml:space="preserve">
          <source>For IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, overflow is guaranteed if 709.8 &amp;lt; arg.</source>
          <target state="translated">对于IEEE兼容类型 &lt;code&gt;double&lt;/code&gt; ，如果709.8 &amp;lt;arg，则可以保证溢出。</target>
        </trans-unit>
        <trans-unit id="7abd0d73ae7ceb8182e2cfda7bc62d8a3837d067" translate="yes" xml:space="preserve">
          <source>For POSIX-based operating systems, &lt;code&gt;std::filesystem::absolute(p)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;current_path&quot;&gt;std::filesystem::current_path&lt;/a&gt;() / p&lt;/code&gt;.</source>
          <target state="translated">对于基于POSIX的操作系统， &lt;code&gt;std::filesystem::absolute(p)&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;current_path&quot;&gt;std::filesystem::current_path&lt;/a&gt;() / p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="119d7cdec7ea51fa50da00d5d9417b5384f14791" translate="yes" xml:space="preserve">
          <source>For Windows, &lt;code&gt;absolute&lt;/code&gt; may be implemented as a call to &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx&quot;&gt;GetFullPathNameW&lt;/a&gt;.</source>
          <target state="translated">对于Windows， &lt;code&gt;absolute&lt;/code&gt; 可以实现为对&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364963(v=vs.85).aspx&quot;&gt;GetFullPathNameW&lt;/a&gt;的调用。</target>
        </trans-unit>
        <trans-unit id="c4e888a145f1992272e7918f8fc284c6a7e06ad4" translate="yes" xml:space="preserve">
          <source>For a</source>
          <target state="translated">对于一个</target>
        </trans-unit>
        <trans-unit id="ca411b7633697d58c29db0495dbecc36219406c0" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;dependent_name&quot;&gt;non-dependent name&lt;/a&gt; used in a template definition, unqualified name lookup takes place when the template definition is examined. The binding to the declarations made at that point is not affected by declarations visible at the point of instantiation. For a &lt;a href=&quot;dependent_name&quot;&gt;dependent name&lt;/a&gt; used in a template definition, the lookup is postponed until the template arguments are known, at which time &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; examines function declarations with external linkage(until C++11) that are visible from the template definition context as well as in the template instantiation context, while non-ADL lookup only examines function declarations with external linkage(until C++11) that are visible from the template definition context (in other words, adding a new function declaration after template definition does not make it visible except via ADL). The behavior is undefined if there is a better match with external linkage in the namespaces examined by the ADL lookup, declared in some other translation unit, or if the lookup would have been ambiguous if those translation units were examined. In any case, if a base class depends on a template parameter, its scope is not examined by unqualified name lookup (neither at the point of definition nor at the point of instantiation).</source>
          <target state="translated">对于模板定义中使用的&lt;a href=&quot;dependent_name&quot;&gt;非依赖性名称，&lt;/a&gt;在检查模板定义时会进行不合格的名称查找。在那时进行的声明的绑定不受实例化时可见的声明的影响。对于模板定义中使用的&lt;a href=&quot;dependent_name&quot;&gt;从属名称&lt;/a&gt;，将推迟查找直到知道模板参数为止，此时&lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;使用模板定义上下文以及在模板实例化上下文中可见的具有外部链接的函数声明（直到C ++ 11），而非ADL查找仅检查具有外部链接的函数声明（直到C ++ 11），从模板定义上下文可见（换句话说，在模板定义之后添加新的函数声明不会使它可见，除非通过ADL）。如果在ADL查找所检查的命名空间中与外部链接更好地匹配，以其他翻译单元声明，或者如果检查了这些翻译单元，查找将是模棱两可的，则该行为是不确定的。无论如何，如果基类依赖于模板参数，它的范围不会通过不合格的名称查找来检查（无论是在定义时还是在实例化时）。</target>
        </trans-unit>
        <trans-unit id="883759e78914d4b04a2fe3535a894bcffbf8a177" translate="yes" xml:space="preserve">
          <source>For a &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; of a non-template class, the default arguments are allowed on the out-of-class definition, and are combined with the default arguments provided by the declaration inside the class body. If these out-of-class defaults would turn a member function into a default, copy, or move constructor the program is ill-formed. For member functions of class templates, all defaults must be provided in the initial declaration of the member function.</source>
          <target state="translated">对于非模板类的&lt;a href=&quot;member_functions&quot;&gt;成员函数&lt;/a&gt;，默认参数允许在类外定义中使用，并与类体内声明所提供的默认参数组合。如果这些不合常规的默认值会将成员函数转换为默认值，复制或移动构造函数，则程序格式错误。对于类模板的成员函数，必须在成员函数的初始声明中提供所有默认值。</target>
        </trans-unit>
        <trans-unit id="02ea56864a8e8c007867dec05809cd5a9f98b81f" translate="yes" xml:space="preserve">
          <source>For a container &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.front()&lt;/code&gt; is equivalent to &lt;code&gt;*c.begin()&lt;/code&gt;.</source>
          <target state="translated">对于容器 &lt;code&gt;c&lt;/code&gt; ，表达式 &lt;code&gt;c.front()&lt;/code&gt; 等效于 &lt;code&gt;*c.begin()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c061e2be7835c9d94a21ab627e460ae3f5da4b8d" translate="yes" xml:space="preserve">
          <source>For a container &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;return c.back();&lt;/code&gt; is equivalent to &lt;code&gt;{ auto tmp = c.end(); --tmp; return *tmp; }&lt;/code&gt;</source>
          <target state="translated">对于容器 &lt;code&gt;c&lt;/code&gt; ，表达式 &lt;code&gt;return c.back();&lt;/code&gt; 等效于 &lt;code&gt;{ auto tmp = c.end(); --tmp; return *tmp; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a12f2ebb81a91e44d54c155d3b7a470c7c32d87a" translate="yes" xml:space="preserve">
          <source>For a given &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt; p&lt;/code&gt;, this specialization ensures that.</source>
          <target state="translated">对于给定的 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt; p&lt;/code&gt; ，这种专业化确保了这一点。</target>
        </trans-unit>
        <trans-unit id="61761986c4556882eacd9227f774252dea0c81ea" translate="yes" xml:space="preserve">
          <source>For a name used anywhere in &lt;a href=&quot;class&quot;&gt;class definition&lt;/a&gt;, except inside a member function body, a default argument of a member function, exception specification of a member function, default member initializer, &lt;a href=&quot;attributes/contract&quot;&gt;contract condition&lt;/a&gt;(since C++20), or inside a nested class definition (including names of the bases from which the nested class is derived), the following scopes are searched:</source>
          <target state="translated">对于在&lt;a href=&quot;class&quot;&gt;类定义中&lt;/a&gt;任何地方使用的名称，除了成员函数体内，成员函数的默认自变量，成员函数的异常说明，成员初始化的默认值，&lt;a href=&quot;attributes/contract&quot;&gt;协定条件&lt;/a&gt;（自C ++ 20起）或嵌套类内之外定义（包括派生嵌套类的基础的名称），将搜索以下范围：</target>
        </trans-unit>
        <trans-unit id="a684765457eef405a769182256e4ade4f401bc30" translate="yes" xml:space="preserve">
          <source>For a name used in a &lt;a href=&quot;default_arguments&quot;&gt;default argument&lt;/a&gt; in a function declaration, or name used in the expression part of a &lt;a href=&quot;constructor&quot;&gt;member-initializer&lt;/a&gt; of a constructor, the function parameter names are found first, before the enclosing block, class, or namespace scopes are examined:</source>
          <target state="translated">对于在函数声明中的&lt;a href=&quot;default_arguments&quot;&gt;默认参数&lt;/a&gt;中使用的名称，或在构造函数的&lt;a href=&quot;constructor&quot;&gt;成员初始化程序&lt;/a&gt;的表达式部分中使用的名称，在检查封闭的块，类或名称空间范围之前，首先要找到函数参数名称：</target>
        </trans-unit>
        <trans-unit id="6ae66449c2d64e5e5aa0c8dcee38ad7d218d4918" translate="yes" xml:space="preserve">
          <source>For a name used in a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function definition inside the body of the class that is granting friendship, unqualified name lookup proceeds the same way as for a member function. For a name used in a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function which is defined outside the body of a class, unqualified name lookup proceeds the same way as for a function in a namespace.</source>
          <target state="translated">对于在授予友谊的类的主体内的&lt;a href=&quot;friend&quot;&gt;好友&lt;/a&gt;函数定义中使用的名称，不合格的名称查找与成员函数的处理方式相同。对于在类主体之外定义的&lt;a href=&quot;friend&quot;&gt;好友&lt;/a&gt;函数中使用的名称，非限定名称查找的处理方式与名称空间中的函数相同。</target>
        </trans-unit>
        <trans-unit id="f880effac86bc82db2f16b2948bd47f4311ada8a" translate="yes" xml:space="preserve">
          <source>For a name used in a user-declared namespace outside of any function or class, this namespace is searched before the use of the name, then the namespace enclosing this namespace before the declaration of this namespace, etc until the global namespace is reached.</source>
          <target state="translated">对于在任何函数或类之外的用户声明的命名空间中使用的名称,在使用该名称之前,先搜索这个命名空间,然后在声明这个命名空间之前搜索包围这个命名空间的命名空间,等等,直到到达全局命名空间。</target>
        </trans-unit>
        <trans-unit id="d01e0277c975bcb293141e811447dfa3ec140823" translate="yes" xml:space="preserve">
          <source>For a name used in global (top-level namespace) scope, outside of any function, class, or user-declared namespace, the global scope before the use of the name is examined:</source>
          <target state="translated">对于在全局(顶层命名空间)作用域中使用的名称,在任何函数、类或用户定义的命名空间之外,将检查使用该名称之前的全局作用域。</target>
        </trans-unit>
        <trans-unit id="6751cf91d41edea8f420573f4bb5cfa36ba1c19a" translate="yes" xml:space="preserve">
          <source>For a name used in the catch-clause of a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, lookup proceeds as if for a name used in the very beginning of the outermost block of the function body (in particular, function parameters are visible, but names declared in that outermost block are not).</source>
          <target state="translated">对于在&lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;的catch子句中使用的名称，查找将继续进行，就像在函数主体的最外层块的最开始处使用的名称一样（特别是，函数参数是可见的，但在该最外面的块不是）。</target>
        </trans-unit>
        <trans-unit id="0ecffe6eebcdaa6e0a2a4a2d57d191d6b1fc5d6c" translate="yes" xml:space="preserve">
          <source>For a name used in the declarator of a &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; function declaration that friends a member function from another class, if the name isn't a part of any template argument, the unqualified lookup first examines the entire scope of the member function's class. If not found in that scope (or if the name is a part of a template argument), the lookup continues as if for a member function of the class that is granting friendship.</source>
          <target state="translated">对于在&lt;a href=&quot;friend&quot;&gt;朋友&lt;/a&gt;函数声明的声明程序中使用的名称（该朋友将另一个类的成员函数作为朋友）而言，如果该名称不是任何模板参数的一部分，则不限定条件的查找将首先检查成员函数类的整个范围。如果在该作用域中找不到（或名称是模板参数的一部分），则查找将继续，好像是在授予友谊的类的成员函数一样。</target>
        </trans-unit>
        <trans-unit id="d95608e8a2ef528dbac2bab8b35c1d8f3a28d62b" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a &lt;a href=&quot;static&quot;&gt;static data member&lt;/a&gt;, lookup proceeds the same way as for a name used in the definition of a member function.</source>
          <target state="translated">对于在&lt;a href=&quot;static&quot;&gt;静态数据成员&lt;/a&gt;的定义中使用的名称，查找的方式与在成员函数的定义中使用的名称相同。</target>
        </trans-unit>
        <trans-unit id="f034307944cf4601fdfc2f8a86c32703ec89cf55" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a function, either in its body or as part of default argument, where the function is a member of user-declared or global namespace, the block in which the name is used is searched before the use of the name, then the enclosing block is searched before the start of that block, etc, until reaching the block that is the function body. Then the namespace in which the function is declared is searched until the definition (not necessarily the declaration) of the function that uses the name, then the enclosing namespaces, etc.</source>
          <target state="translated">对于在函数定义中使用的名称,无论是在函数主体中还是作为缺省参数的一部分,如果函数是用户声明的或全局命名空间的成员,那么在使用该名称之前先搜索使用该名称的块,然后在该块开始之前搜索包围的块,等等,直到到达作为函数主体的块。然后再搜索声明该函数的命名空间,直到使用该名称的函数定义(不一定是声明),再搜索包围的命名空间等。</target>
        </trans-unit>
        <trans-unit id="e69fc9e6436e85bd5e71b5f6fffe00b9251f55e4" translate="yes" xml:space="preserve">
          <source>For a name used in the definition of a namespace-member variable outside the namespace, lookup proceeds the same way as for a name used inside the namespace:</source>
          <target state="translated">对于在命名空间以外的命名空间成员变量定义中使用的名称,查找的方式与在命名空间内使用的名称相同。</target>
        </trans-unit>
        <trans-unit id="8362e87a521c085b7be1055bd62a4345efa29ea0" translate="yes" xml:space="preserve">
          <source>For a name used in the initializer part of the &lt;a href=&quot;enum&quot;&gt;enumerator declaration&lt;/a&gt;, previously declared enumerators in the same enumeration are found first, before the unqualified name lookup proceeds to examine the enclosing block, class, or namespace scope.</source>
          <target state="translated">对于在&lt;a href=&quot;enum&quot;&gt;枚举器声明&lt;/a&gt;的初始值设定项部分中使用的名称，在未限定名称查找继续检查封闭的块，类或命名空间范围之前，首先会找到同一枚举中先前声明的枚举器。</target>
        </trans-unit>
        <trans-unit id="6979bced06285133967c5c4b103d3e0247545465" translate="yes" xml:space="preserve">
          <source>For a name used inside a member function body, a default argument of a member function, an exception specification of a member function, a default member initializer, a &lt;a href=&quot;attributes/contract&quot;&gt;contract condition&lt;/a&gt; of a member function(since C++20), or a nested class definition (including names of the bases from which the nested class is derived), the scopes searched are the same as in &lt;a href=&quot;unqualified_lookup#Class_definition&quot;&gt;class definition&lt;/a&gt;, except that the entire scope of the class is considered, not just the part prior to the declaration that uses the name. For nested classes the entire body of the enclosing class is searched.</source>
          <target state="translated">对于在成员函数体内使用的名称，成员函数的默认参数，成员函数的异常说明，默认成员初始化程序，成员函数的&lt;a href=&quot;attributes/contract&quot;&gt;协定条件&lt;/a&gt;（自C ++ 20起）或嵌套类定义（包括从其派生嵌套类的基础的名称），搜索的范围与&lt;a href=&quot;unqualified_lookup#Class_definition&quot;&gt;类定义中&lt;/a&gt;的范围相同，只是要考虑类的整个范围，而不仅仅是声明之前使用该名称的部分。对于嵌套类，将搜索封闭类的整个主体。</target>
        </trans-unit>
        <trans-unit id="5f9f456dc65dd5916b44e6d8b6b804f14836dd56" translate="yes" xml:space="preserve">
          <source>For a non-union aggregate, element for which a designated initializer is not provided are initialized the same as described above for when the number of initializer clauses is less than the number of members (default member initializers where provided, empty list-initialization otherwise):</source>
          <target state="translated">对于一个非union集合,没有提供指定初始化器的元素,当初始化器子句的数量少于成员数量时,初始化方式与上述相同(如果提供了默认的成员初始化器,则为空列表初始化)。</target>
        </trans-unit>
        <trans-unit id="5961fe12a3117fa1b2454e762062290b637aa259" translate="yes" xml:space="preserve">
          <source>For a pair of atomic modifications of M called A and B, B occurs after A in M's modification order if.</source>
          <target state="translated">对于M的一对原子修饰称为A和B,在M的修饰顺序中,B发生在A之后,如果:。</target>
        </trans-unit>
        <trans-unit id="00a88dd4d98c693a356d74c5b2bd02963d1cfab7" translate="yes" xml:space="preserve">
          <source>For a pair of atomic operations on M called A and B, where A writes and B reads M's value, if there are two &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt;s X and Y, and if A is</source>
          <target state="translated">对于M上一对名为A和B的原子操作，其中A写入B读取M的值，如果存在两个 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; s X和Y，并且如果A为</target>
        </trans-unit>
        <trans-unit id="e8a036efd00fe52d195f38f7af9f452d212a3c7c" translate="yes" xml:space="preserve">
          <source>For a regular file &lt;code&gt;p&lt;/code&gt;, returns the size determined as if by reading the &lt;code&gt;st_size&lt;/code&gt; member of the structure obtained by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed).</source>
          <target state="translated">对于常规文件 &lt;code&gt;p&lt;/code&gt; ，返回确定的大小，就好像通过读取POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt;获得的结构的 &lt;code&gt;st_size&lt;/code&gt; 成员（遵循符号链接）一样。</target>
        </trans-unit>
        <trans-unit id="1a9910e8a0a912c3015de0a3b33c5c17808e192d" translate="yes" xml:space="preserve">
          <source>For a reverse iterator &lt;code&gt;r&lt;/code&gt; constructed from an iterator &lt;code&gt;i&lt;/code&gt;, the relationship &lt;code&gt;&amp;amp;*r == &amp;amp;*(i-1)&lt;/code&gt; is always true (as long as &lt;code&gt;r&lt;/code&gt; is dereferenceable); thus a reverse iterator constructed from a one-past-the-end iterator dereferences to the last element in a sequence.</source>
          <target state="translated">对于由迭代器 &lt;code&gt;i&lt;/code&gt; 构造的反向迭代器 &lt;code&gt;r&lt;/code&gt; ，关系 &lt;code&gt;&amp;amp;*r == &amp;amp;*(i-1)&lt;/code&gt; 始终为真（只要 &lt;code&gt;r&lt;/code&gt; 是可取消引用的）；因此，从一端到最后的迭代器构造的反向迭代器将引用序列中的最后一个元素。</target>
        </trans-unit>
        <trans-unit id="ad06b47edb0bcc2d8539e75487122b7c88338360" translate="yes" xml:space="preserve">
          <source>For a span &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.back()&lt;/code&gt; is equivalent to &lt;code&gt;*(c.end()-1)&lt;/code&gt;.</source>
          <target state="translated">对于范围 &lt;code&gt;c&lt;/code&gt; ，表达式 &lt;code&gt;c.back()&lt;/code&gt; 等效于 &lt;code&gt;*(c.end()-1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e1fa034a73d65c807607dcc81680fbdbbcb66bcc" translate="yes" xml:space="preserve">
          <source>For a span &lt;code&gt;c&lt;/code&gt;, the expression &lt;code&gt;c.front()&lt;/code&gt; is equivalent to &lt;code&gt;*c.begin()&lt;/code&gt;.</source>
          <target state="translated">对于范围 &lt;code&gt;c&lt;/code&gt; ，表达式 &lt;code&gt;c.front()&lt;/code&gt; 等效于 &lt;code&gt;*c.begin()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5c154bb2c5d060e3bc21cda45246264cc660e3cf" translate="yes" xml:space="preserve">
          <source>For a standard stream &lt;code&gt;str&lt;/code&gt;, synchronized with the C stream &lt;code&gt;f&lt;/code&gt;, the following pairs of functions have identical effect:</source>
          <target state="translated">对于与C流 &lt;code&gt;f&lt;/code&gt; 同步的标准流 &lt;code&gt;str&lt;/code&gt; ，以下功能对具有相同的作用：</target>
        </trans-unit>
        <trans-unit id="de5683ef87cd469dd98d4cc4a0aed5b17f0dbfb7" translate="yes" xml:space="preserve">
          <source>For a type &lt;code&gt;T&lt;/code&gt;, the default value of &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; is:</source>
          <target state="translated">对于类型 &lt;code&gt;T&lt;/code&gt; ， &lt;code&gt;enable_view&amp;lt;T&amp;gt;&lt;/code&gt; 的默认值为：</target>
        </trans-unit>
        <trans-unit id="a003d5a71c47171b8ec220d6469cdc87d155fcf6" translate="yes" xml:space="preserve">
          <source>For a type &lt;code&gt;TC&lt;/code&gt;:</source>
          <target state="translated">对于 &lt;code&gt;TC&lt;/code&gt; 类型：</target>
        </trans-unit>
        <trans-unit id="28eb0e4e99d6754c04540069cc9b86b6e86b0026" translate="yes" xml:space="preserve">
          <source>For a unary operator &lt;code&gt;@&lt;/code&gt; whose argument has type &lt;code&gt;T1&lt;/code&gt; (after removing cv-qualifications), or binary operator &lt;code&gt;@&lt;/code&gt; whose left operand has type &lt;code&gt;T1&lt;/code&gt; and right operand of type &lt;code&gt;T2&lt;/code&gt; (after removing cv-qualifications), the following sets of candidate functions are prepared:</source>
          <target state="translated">对于其参数的类型为 &lt;code&gt;T1&lt;/code&gt; 的一元运算符 &lt;code&gt;@&lt;/code&gt; （除去cv限定词之后），或对于其左操作数的类型为 &lt;code&gt;T1&lt;/code&gt; 且右操作数为 &lt;code&gt;T2&lt;/code&gt; 的二元运算符 &lt;code&gt;@&lt;/code&gt; （除去cv限定词之后），准备了以下候选函数集：</target>
        </trans-unit>
        <trans-unit id="a0f6b7e105043260b05aaf0d46100e8d47e56be4" translate="yes" xml:space="preserve">
          <source>For a union with bits that participate in the value representations of some members but not the others, compare-and-exchange might always fail because such padding bits have indeterminate values when they do not participate in the value representation of the active member.</source>
          <target state="translated">对于一个具有参与部分成员的值表示而不参与其他成员的值表示的位的联合,比较和交换可能总是失败的,因为这些填充位在不参与活动成员的值表示时具有不确定的值。</target>
        </trans-unit>
        <trans-unit id="1edec90a35f1485dfd1de3cb8edee29c85050704" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;!(a &amp;lt; a)&lt;/code&gt;</source>
          <target state="translated">对于所有 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;!(a &amp;lt; a)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be2f118aaee33f35b4a4d55d4b1363d900dc2269" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;comp(a,a)==false&lt;/code&gt;</source>
          <target state="translated">对于所有 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;comp(a,a)==false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="232a0e7be31828ff9c9e76ce04deca11781e6a26" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;equiv(a,a)==true&lt;/code&gt;</source>
          <target state="translated">对于所有 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;equiv(a,a)==true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dcda67f6f48d3eaf152c442223488264fae5046f" translate="yes" xml:space="preserve">
          <source>For all &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; is equal to &lt;code&gt;X​::​eq_int_type(X​::​to_int_type(c), X​::​to_int_type(d))&lt;/code&gt;</source>
          <target state="translated">对于所有 &lt;code&gt;c&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; ， &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; 等于 &lt;code&gt;X​::​eq_int_type(X​::​to_int_type(c), X​::​to_int_type(d))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2032585f99e27bc2ad7b8385f77f212571492869" translate="yes" xml:space="preserve">
          <source>For all other functions, reaching the end of a catch clause is equivalent to &lt;code&gt;return;&lt;/code&gt; if the function's return type is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">对于所有其他函数，到达catch子句的末尾等效于 &lt;code&gt;return;&lt;/code&gt; 如果函数的返回类型为（可能是cv限定的） &lt;code&gt;void&lt;/code&gt; ，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="da7d72e89e6f7a108ff843546e67ee1b3d8bf96b" translate="yes" xml:space="preserve">
          <source>For all other names (variables, namespaces, classes, etc), name lookup must produce a single declaration in order for the program to compile. Lookup for a name in a scope finds all declarations of that name, with one exception, known as the &quot;struct hack&quot; or &quot;type/non-type hiding&quot;: Within the same scope, some occurrences of a name may refer to a declaration of a class/struct/union/enum that is not a typedef, while all other occurrences of the same name either all refer to the same variable, non-static data member (since C++14), or enumerator, or they all refer to possibly overloaded function or function template names. In this case, there is no error, but the type name is hidden from lookup (the code must use &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; to access it).</source>
          <target state="translated">对于所有其他名称（变量，名称空间，类等），名称查找必须产生单个声明才能编译程序。在范围内查找名称会找到该名称的所有声明，但有一个例外，称为&amp;ldquo;结构hack&amp;rdquo;或&amp;ldquo;类型/非类型隐藏&amp;rdquo;：在同一范围内，名称的某些出现可能引用了声明不是typedef的class / struct / union / enum的引用，而所有其他相同名称的引用都引用相同的变量，非静态数据成员（自C ++ 14起）或枚举器，或者全部请参阅可能重载的函数或函数模板名称。在这种情况下，没有错误，但是在查找中隐藏了类型名称（代码必须使用&lt;a href=&quot;elaborated_type_specifier&quot;&gt;详细的类型说明符&lt;/a&gt;来访问它）。</target>
        </trans-unit>
        <trans-unit id="10db488ddc48847974dabc392b2f321428b2ad60" translate="yes" xml:space="preserve">
          <source>For all other objects (class objects initialized by a trivial default constructor, non-class objects, arrays of those, etc.), lifetime begins when the properly-aligned storage for the object is allocated and ends when the storage is deallocated or reused by another object.</source>
          <target state="translated">对于所有其他对象(由琐碎的默认构造函数初始化的类对象、非类对象、这些对象的数组等),寿命从对象的正确对齐的存储被分配时开始,到存储被deallocated或被另一个对象重新使用时结束。</target>
        </trans-unit>
        <trans-unit id="760abd8226337c152c576ef554b6c75c15801476" translate="yes" xml:space="preserve">
          <source>For all three operators, the usual arithmetic conversions are performed on both operands and determine the type of the result.</source>
          <target state="translated">对于这三个运算符,通常会对两个操作数进行算术转换,并确定结果的类型。</target>
        </trans-unit>
        <trans-unit id="8d67a35b43e5bf5606d1d36920c0574ac4035475" translate="yes" xml:space="preserve">
          <source>For all values of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a == a&lt;/code&gt; yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">对于所有值 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;a == a&lt;/code&gt; 收益率 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd7a423e3b93ec1547e0b8fd506cf138031deb4a" translate="yes" xml:space="preserve">
          <source>For an</source>
          <target state="translated">对于一个</target>
        </trans-unit>
        <trans-unit id="abab0bc9e7d335f8452e190fdf3bbe8302cb65a4" translate="yes" xml:space="preserve">
          <source>For an &lt;a href=&quot;expressions#Operators&quot;&gt;operator&lt;/a&gt; used in expression (e.g., &lt;code&gt;operator+&lt;/code&gt; used in &lt;code&gt;a+b&lt;/code&gt;), the lookup rules are slightly different from the operator used in an explicit function-call expression such as &lt;code&gt;operator+(a,b)&lt;/code&gt;: when parsing an expression, two separate lookups are performed: for the non-member operator overloads and for the member operator overloads (for the operators where both forms are permitted). Those sets are then merged with the built-in operator overloads on equal grounds as described in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;. If explicit function call syntax is used, regular unqualified name lookup is performed:</source>
          <target state="translated">对于在表达式中使用的&lt;a href=&quot;expressions#Operators&quot;&gt;运算符&lt;/a&gt;（例如 &lt;code&gt;a+b&lt;/code&gt; 中使用的 &lt;code&gt;operator+&lt;/code&gt; ），查找规则与在显式函数调用表达式（例如 &lt;code&gt;operator+(a,b)&lt;/code&gt; 使用的运算符略有不同：解析表达式时，两个单独的查找：对非成员运算符重载和对于成员运算符重载（对于允许使用两种形式的运算符）。然后按照&lt;a href=&quot;overload_resolution&quot;&gt;重载决议中&lt;/a&gt;所述，将这些集合与内置运算符重载以相等的理由合并。如果使用显式函数调用语法，则将执行常规的非限定名称查找：</target>
        </trans-unit>
        <trans-unit id="cfdde08423e6892ce026f332e4722775a6fd0ec4" translate="yes" xml:space="preserve">
          <source>For an inline function or inline variable(since C++17), a definition is required in every translation unit where it is</source>
          <target state="translated">对于一个内联函数或内联变量(从C++17开始),在每一个翻译单元中都需要一个定义,在这个翻译单元中,它的定义是</target>
        </trans-unit>
        <trans-unit id="b13c06c8df9fdd2618a4c37f530dfc9ec64faee7" translate="yes" xml:space="preserve">
          <source>For an object &lt;code&gt;m&lt;/code&gt; of Mutex type:</source>
          <target state="translated">对于互斥类型的对象 &lt;code&gt;m&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="10c618faebd2cba6e4ed1d78498e9c737887c436" translate="yes" xml:space="preserve">
          <source>For an object of type &lt;code&gt;T&lt;/code&gt;,</source>
          <target state="translated">对于类型 &lt;code&gt;T&lt;/code&gt; 的对象，</target>
        </trans-unit>
        <trans-unit id="9cbc15bac40798667e2c28ef32d8acd0bfca6527" translate="yes" xml:space="preserve">
          <source>For any &lt;code&gt;year_month_day&lt;/code&gt; object &lt;code&gt;ymd&lt;/code&gt; representing a valid date (&lt;code&gt;ymd.ok() == true&lt;/code&gt;), converting &lt;code&gt;ymd&lt;/code&gt; to &lt;code&gt;sys_days&lt;/code&gt; and back yields the same value.</source>
          <target state="translated">对于表示有效日期的任何 &lt;code&gt;year_month_day&lt;/code&gt; 对象 &lt;code&gt;ymd&lt;/code&gt; （ &lt;code&gt;ymd.ok() == true&lt;/code&gt; ），将 &lt;code&gt;ymd&lt;/code&gt; 转换为 &lt;code&gt;sys_days&lt;/code&gt; 并返回将产生相同的值。</target>
        </trans-unit>
        <trans-unit id="f2a393f7232125085f4da3eb01cb2d41b026b8c4" translate="yes" xml:space="preserve">
          <source>For any object &lt;code&gt;z&lt;/code&gt; of type &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[0]&lt;/code&gt; is the real part of z and &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[1]&lt;/code&gt; is the imaginary part of z.</source>
          <target state="translated">对于类型为 &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; 任何对象 &lt;code&gt;z&lt;/code&gt; ， &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[0]&lt;/code&gt; 是z的实数部分，而 &lt;code&gt;reinterpret_cast&amp;lt;T(&amp;amp;)[2]&amp;gt;(z)[1]&lt;/code&gt; 是z的虚部。</target>
        </trans-unit>
        <trans-unit id="aa002637ab58deab74ffaca3cf03066bd188d114" translate="yes" xml:space="preserve">
          <source>For any object of class or aggregate types if it, or any of its subobjects, is initialized by anything other than the &lt;a href=&quot;default_constructor#Trivial_default_constructor&quot;&gt;trivial default constructor&lt;/a&gt;, lifetime begins when initialization ends.</source>
          <target state="translated">对于任何类或集合类型的对象或其子对象，如果它是由&lt;a href=&quot;default_constructor#Trivial_default_constructor&quot;&gt;琐碎的默认构造函数&lt;/a&gt;初始化的，则生存期始于初始化结束。</target>
        </trans-unit>
        <trans-unit id="cdd8992024517b51f7efb1e98465ebff61447714" translate="yes" xml:space="preserve">
          <source>For any object of class types whose &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;destructor&lt;/a&gt; is not trivial, lifetime ends when the execution of the destructor begins.</source>
          <target state="translated">对于&lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;析构函数&lt;/a&gt;并非无关紧要的任何类类型的对象，生存期在析构函数的执行开始时结束。</target>
        </trans-unit>
        <trans-unit id="fa44da499e47fc6fac2860172008adb9c1ff9a16" translate="yes" xml:space="preserve">
          <source>For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">对于任何其他类型， &lt;code&gt;value&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cefa90cb2c929a28be455e9f8fda7d414ab3948b" translate="yes" xml:space="preserve">
          <source>For any pointer to an element of an array of &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; named &lt;code&gt;p&lt;/code&gt; and any valid array index &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i]&lt;/code&gt; is the real part of the complex number &lt;code&gt;p[i]&lt;/code&gt;, and &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i + 1]&lt;/code&gt; is the imaginary part of the complex number &lt;code&gt;p[i]&lt;/code&gt;</source>
          <target state="translated">对于任何指向名为 &lt;code&gt;p&lt;/code&gt; 的 &lt;code&gt;complex&amp;lt;T&amp;gt;&lt;/code&gt; 数组元素和任何有效数组索引 &lt;code&gt;i&lt;/code&gt; 的指针， &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i]&lt;/code&gt; 是复数 &lt;code&gt;p[i]&lt;/code&gt; 的实部，并且 &lt;code&gt;reinterpret_cast&amp;lt;T*&amp;gt;(p)[2*i + 1]&lt;/code&gt; 是复数 &lt;code&gt;p[i]&lt;/code&gt; 的虚部</target>
        </trans-unit>
        <trans-unit id="33bcdf350e21fefb2826ca912ee3190d4a971dc5" translate="yes" xml:space="preserve">
          <source>For any two values &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; of the type &lt;code&gt;&lt;a href=&quot;../../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt1&amp;gt;::value_type&lt;/code&gt;, if &lt;code&gt;pred(A, B) == true&lt;/code&gt;, then &lt;code&gt;hf(A) == hf(B)&lt;/code&gt; shall be &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;../../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt1&amp;gt;::value_type&lt;/code&gt; &amp;lt;RandomIt1&amp;gt; :: value_type类型的任意两个值 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，如果 &lt;code&gt;pred(A, B) == true&lt;/code&gt; ，则 &lt;code&gt;hf(A) == hf(B)&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6b450ffc7f721529dcdc6d1be9e46c5d50a2a925" translate="yes" xml:space="preserve">
          <source>For any type &lt;code&gt;T&lt;/code&gt; (including incomplete types), other than &lt;a href=&quot;functions&quot;&gt;function type&lt;/a&gt; or &lt;a href=&quot;reference&quot;&gt;reference type&lt;/a&gt;, there are three more distinct types in the C++ type system: const-qualified&lt;code&gt;T&lt;/code&gt;, volatile-qualified&lt;code&gt;T&lt;/code&gt;, and const-volatile-qualified&lt;code&gt;T&lt;/code&gt;.  Note: &lt;a href=&quot;array&quot;&gt;array types&lt;/a&gt; are considered to have the same cv-qualification as their element types.</source>
          <target state="translated">对于任何类型的 &lt;code&gt;T&lt;/code&gt; （包括不完整的类型），比其它&lt;a href=&quot;functions&quot;&gt;功能类型&lt;/a&gt;或&lt;a href=&quot;reference&quot;&gt;引用类型&lt;/a&gt;，有三种更多个不同类型的在C ++类型系统：const限定 &lt;code&gt;T&lt;/code&gt; ，volatile限定 &lt;code&gt;T&lt;/code&gt; ，和const volatile限定 &lt;code&gt;T&lt;/code&gt; 。注意：&lt;a href=&quot;array&quot;&gt;数组类型&lt;/a&gt;被认为与元素类型具有相同的cv限定。</target>
        </trans-unit>
        <trans-unit id="587d19dece0a5e657eee4b9c6dab7110d60627cf" translate="yes" xml:space="preserve">
          <source>For any z, acos(z) = &amp;pi; - acos(-z).</source>
          <target state="translated">对于任何z，acos（z）=&amp;pi;-acos（-z）。</target>
        </trans-unit>
        <trans-unit id="21aee1213fe266997611327508955de0364192e9" translate="yes" xml:space="preserve">
          <source>For any z, atanh(z) =</source>
          <target state="translated">对于任何z,atanh(z)=。</target>
        </trans-unit>
        <trans-unit id="e254b6622c2f4cf79e478657cc199aa0c2eea2e9" translate="yes" xml:space="preserve">
          <source>For append streams (&lt;code&gt;mode &amp;amp; ios_base::ate == true&lt;/code&gt;), &lt;code&gt;pptr() == pbase() + s.size()&lt;/code&gt;, so that subsequent output will be appended to the last character copied from &lt;code&gt;s&lt;/code&gt;(since C++11)</source>
          <target state="translated">对于附加流（ &lt;code&gt;mode &amp;amp; ios_base::ate == true&lt;/code&gt; ）， &lt;code&gt;pptr() == pbase() + s.size()&lt;/code&gt; ，以便后续输出将附加到从 &lt;code&gt;s&lt;/code&gt; 复制的最后一个字符（自C ++ 11起） ）</target>
        </trans-unit>
        <trans-unit id="c24da57cc18573525a82a6c2c1fa0a27b061d0da" translate="yes" xml:space="preserve">
          <source>For arg&amp;gt;1, &amp;Sigma;&amp;infin;</source>
          <target state="translated">对于arg&amp;gt; 1，&amp;Sigma;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="7046cc5d9597c58aa7e54080523a910de0e052c1" translate="yes" xml:space="preserve">
          <source>For arg&amp;lt;0, 2arg</source>
          <target state="translated">对于arg &amp;lt;0，2arg</target>
        </trans-unit>
        <trans-unit id="188be9f862ad64a9a657bafc75642d5f5c9f6a4f" translate="yes" xml:space="preserve">
          <source>For arithmetic types not subject to promotion, the common type may be viewed as the type of the (possibly mixed-mode) arithmetic expression such as &lt;code&gt;T0() + T1() + ... + Tn()&lt;/code&gt;.</source>
          <target state="translated">对于不需要提升的算术类型，可以将普通类型视为（可能是混合模式）算术表达式的类型，例如 &lt;code&gt;T0() + T1() + ... + Tn()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="79dccf2c6a91881692253227b281b3f534531201" translate="yes" xml:space="preserve">
          <source>For arithmetic types, the thousands separator character, obtained from &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt;, is inserted into the sequence according to the grouping rules provided by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;</source>
          <target state="translated">对于算术类型，将从 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt; 获得的千位分隔符根据 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;CharT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt; 提供的分组规则插入到序列中： ：use_facet &amp;lt; &lt;a href=&quot;../numpunct&quot;&gt;std :: numpunct&lt;/a&gt; &amp;lt;CharT &amp;gt;&amp;gt;（str.getloc（））。grouping（）</target>
        </trans-unit>
        <trans-unit id="c01eb08fd12dd04934e4ddc13d646e9cc256574b" translate="yes" xml:space="preserve">
          <source>For auto-returning functions, the parameter &lt;code&gt;P&lt;/code&gt; is obtained as follows: in &lt;code&gt;T&lt;/code&gt;, the declared return type of the function that includes &lt;code&gt;auto&lt;/code&gt;, every occurrence of &lt;code&gt;auto&lt;/code&gt; is replaced with an imaginary type template parameter &lt;code&gt;U&lt;/code&gt;. The argument &lt;code&gt;A&lt;/code&gt; is the expression of the &lt;a href=&quot;return&quot;&gt;return&lt;/a&gt; statement, and if the return statement has no operand, &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;void()&lt;/code&gt;. After deduction of &lt;code&gt;U&lt;/code&gt; from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; following the rules described above, the deduced &lt;code&gt;U&lt;/code&gt; is substituted into &lt;code&gt;T&lt;/code&gt; to get the actual return type:</source>
          <target state="translated">对于自动返回函数，参数 &lt;code&gt;P&lt;/code&gt; 的获取方式如下：在 &lt;code&gt;T&lt;/code&gt; 中，包含 &lt;code&gt;auto&lt;/code&gt; 的函数的声明返回类型，每次 &lt;code&gt;auto&lt;/code&gt; 都将被虚类型模板参数 &lt;code&gt;U&lt;/code&gt; 代替。参数 &lt;code&gt;A&lt;/code&gt; 是&lt;a href=&quot;return&quot;&gt;return&lt;/a&gt;语句的表达式，如果return语句没有操作数，则 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;void()&lt;/code&gt; 。扣除 &lt;code&gt;U&lt;/code&gt; 从 &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 遵循上述的规则，推导的 &lt;code&gt;U&lt;/code&gt; 代入 &lt;code&gt;T&lt;/code&gt; 获取实际返回类型：</target>
        </trans-unit>
        <trans-unit id="21745cae4e72428f50d08dc188de6ed08f485b25" translate="yes" xml:space="preserve">
          <source>For both integer and floating-point types, if &lt;code&gt;showpos&lt;/code&gt; is set, the modifier &lt;code&gt;+&lt;/code&gt; is prepended</source>
          <target state="translated">对于整数和浮点类型，如果设置了 &lt;code&gt;showpos&lt;/code&gt; ，则修饰符 &lt;code&gt;+&lt;/code&gt; 会前置</target>
        </trans-unit>
        <trans-unit id="6e00438cc48aea953c237222b040f934d513cc5a" translate="yes" xml:space="preserve">
          <source>For both overloads, if the iterator type is mutable, &lt;code&gt;f&lt;/code&gt; may modify the elements of the range through the dereferenced iterator. If &lt;code&gt;f&lt;/code&gt; returns a result, the result is ignored.</source>
          <target state="translated">对于这两个重载，如果迭代器类型是可变的，则 &lt;code&gt;f&lt;/code&gt; 可以通过取消引用的迭代器来修改范围的元素。如果 &lt;code&gt;f&lt;/code&gt; 返回结果，则忽略该结果。</target>
        </trans-unit>
        <trans-unit id="d4b87d39492f3a203318f3eec5a45d21ed020f35" translate="yes" xml:space="preserve">
          <source>For both overloads, if the iterator type is mutable, &lt;code&gt;f&lt;/code&gt; may modify the elements of the range through the dereferenced iterator. If &lt;code&gt;f&lt;/code&gt; returns a result, the result is ignored. If &lt;code&gt;n&lt;/code&gt; is less than zero, the behavior is undefined.</source>
          <target state="translated">对于这两个重载，如果迭代器类型是可变的，则 &lt;code&gt;f&lt;/code&gt; 可以通过取消引用的迭代器来修改范围的元素。如果 &lt;code&gt;f&lt;/code&gt; 返回结果，则忽略该结果。如果 &lt;code&gt;n&lt;/code&gt; 小于零，则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="2cbfdeffec6dd0f35e1227e8a499f4b7385ae247" translate="yes" xml:space="preserve">
          <source>For both user-defined or implicitly-defined destructors, after the body of the destructor is executed, the compiler calls the destructors for all non-static non-variant members of the class, in reverse order of declaration, then it calls the destructors of all direct non-virtual base classes in &lt;a href=&quot;constructor#Initialization_order&quot;&gt;reverse order of construction&lt;/a&gt; (which in turn call the destructors of their members and their base classes, etc), and then, if this object is of most-derived class, it calls the destructors of all virtual bases.</source>
          <target state="translated">对于用户定义的或隐式定义的析构函数，在执行析构函数的主体之后，编译器将以声明的相反顺序为该类的所有非静态非变量成员调用析构函数，然后调用的析构函数。所有直接的非虚拟基类&lt;a href=&quot;constructor#Initialization_order&quot;&gt;，其构造顺序相反&lt;/a&gt;（依次调用其成员及其基类的析构函数，等等），然后，如果此对象属于派生类最多的对象，则它将调用所有虚拟基类的析构函数基地。</target>
        </trans-unit>
        <trans-unit id="db34171dc6d92c22aa5da5d7cd5e78cc97249f77" translate="yes" xml:space="preserve">
          <source>For char arrays shorter than &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ptrdiff_t&lt;/code&gt; acts as the signed counterpart of &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;: it can store the size of the array of any type and is, on most platforms, synonymous with &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::intptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于短于 &lt;code&gt;&lt;a href=&quot;climits&quot;&gt;PTRDIFF_MAX&lt;/a&gt;&lt;/code&gt; 的 char数组， &lt;code&gt;std::ptrdiff_t&lt;/code&gt; 充当 &lt;code&gt;&lt;a href=&quot;size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 的带符号副本：它可以存储任何类型的数组的大小，并且在大多数平台上与 &lt;code&gt;&lt;a href=&quot;integer&quot;&gt;std::intptr_t&lt;/a&gt;&lt;/code&gt; 同义。</target>
        </trans-unit>
        <trans-unit id="6f3c75e611a43557be37674fd1cb00bb164eeebf" translate="yes" xml:space="preserve">
          <source>For compatibility with C89, an optional comma may appear before the ellipsis if the parameter list contains at least one parameter:</source>
          <target state="translated">为了与C89兼容,如果参数列表中至少包含一个参数,那么省略号前可以出现一个可选的逗号。</target>
        </trans-unit>
        <trans-unit id="94880bd109360b34fd05f9d76510d26eb3dee88a" translate="yes" xml:space="preserve">
          <source>For constexpr function templates and constexpr member functions of class templates, at least one specialization must satisfy the abovementioned requirements. Other specializations are still considered as constexpr, even though a call to such a function cannot appear in a constant expression.</source>
          <target state="translated">对于constexpr函数模板和类模板的constexpr成员函数,至少有一个特化必须满足上述要求。其他特殊化仍然被认为是constexpr,即使对这种函数的调用不能出现在常量表达式中。</target>
        </trans-unit>
        <trans-unit id="9efcdd76c0a92319514fd74592e33806161ca5b0" translate="yes" xml:space="preserve">
          <source>For control over formatting, use &lt;code&gt;std::chrono::format&lt;/code&gt;.</source>
          <target state="translated">要控制格式，请使用 &lt;code&gt;std::chrono::format&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce61db7d14bb600483458137835d50aed271a6ed" translate="yes" xml:space="preserve">
          <source>For creation of a full date, any of the following three orders are accepted:</source>
          <target state="translated">为了创建一个完整的日期,可以接受以下三个命令中的任何一个。</target>
        </trans-unit>
        <trans-unit id="1e51f626291c443aca3537b45aaca51887d63f76" translate="yes" xml:space="preserve">
          <source>For detailed rules on overload resolution, see &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">有关过载解决方案的详细规则，请参阅&lt;a href=&quot;overload_resolution&quot;&gt;过载解决方案&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3ccd8ef2913234c8ce975d9ef8bd2b1cb54addbe" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;Ti&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;, the corresponding type &lt;code&gt;Vi&lt;/code&gt; in &lt;code&gt;VTypes...&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Ti&amp;gt;::type&lt;/code&gt; unless application of &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; results in &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; for some type &lt;code&gt;X&lt;/code&gt;, in which case the deduced type is &lt;code&gt;X&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">对于每一个 &lt;code&gt;Ti&lt;/code&gt; 在 &lt;code&gt;Types...&lt;/code&gt; 时，相应的类型 &lt;code&gt;Vi&lt;/code&gt; 在 &lt;code&gt;VTypes...&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;Ti&amp;gt;::type&lt;/code&gt; 除非应用 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay&lt;/a&gt;&lt;/code&gt; 在结果中 &lt;code&gt;&lt;a href=&quot;../functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; 针对某些类型的 &lt;code&gt;X&lt;/code&gt; ，在这种情况下，推导类型为 &lt;code&gt;X&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ebdcf0767cd45dcef0e5f166fda3ae1b99a89262" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,j)&lt;/code&gt;, &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; is true</source>
          <target state="translated">对于每个 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;[0,j)&lt;/code&gt; 的， &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; 为真</target>
        </trans-unit>
        <trans-unit id="a48fe3fe8c043eed63afe7b1696e912edb4e26e0" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, performs &lt;code&gt;X​::​assign(s[i], c)&lt;/code&gt;.</source>
          <target state="translated">对于每个 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;[0,n)&lt;/code&gt; ，进行 &lt;code&gt;X​::​assign(s[i], c)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7673ab38c4ed279e12cc192b7a57b5fd910e9b3" translate="yes" xml:space="preserve">
          <source>For each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, performs &lt;code&gt;X​::​assign(s[i], p[i])&lt;/code&gt;</source>
          <target state="translated">对于每个 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;[0,n)&lt;/code&gt; ，进行 &lt;code&gt;X​::​assign(s[i], p[i])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a6ddee35ee106c63cce63cef04db68150835b00" translate="yes" xml:space="preserve">
          <source>For each declarator, the initializer may be one of the following:</source>
          <target state="translated">对于每个声明者来说,初始化器可以是以下之一。</target>
        </trans-unit>
        <trans-unit id="71cdc882df31450c88808b61a9ff32adee6518cf" translate="yes" xml:space="preserve">
          <source>For each distinct base class that is specified &lt;code&gt;virtual&lt;/code&gt;, the most derived object contains only one base class subobject of that type, even if the class appears many times in the inheritance hierarchy (as long as it is inherited &lt;code&gt;virtual&lt;/code&gt; every time).</source>
          <target state="translated">对于每个指定为 &lt;code&gt;virtual&lt;/code&gt; 的不同基类，即使该类在继承层次结构中出现多次（只要每次都继承了 &lt;code&gt;virtual&lt;/code&gt; ），则派生最多的对象仅包含该类型的一个基类子对象。</target>
        </trans-unit>
        <trans-unit id="5bfb358921b4b02768fb8323b116ca9ed3bbe11d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素进行计算</target>
        </trans-unit>
        <trans-unit id="483eec964f0d73c99af70508de57de3007259d4d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc cosine of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的反余弦。</target>
        </trans-unit>
        <trans-unit id="adb75759a95a8aeb64e9736b66397da9bd1d4446" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc sine of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的反正弦值。</target>
        </trans-unit>
        <trans-unit id="ca88cd5ed53414ce6dc3bf89279bd5da6137ef0b" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes arc tangent of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的反正切。</target>
        </trans-unit>
        <trans-unit id="f7b456dfebcb725eca2a813704a2d061981a4d5d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes common (base 10) logarithm of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的公共（以10为底）对数。</target>
        </trans-unit>
        <trans-unit id="604bbd841643b027a383acee66008e7977d1d958" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes cosine of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的余弦值。</target>
        </trans-unit>
        <trans-unit id="6f10323acc53f3b6e728d81bacf3f244188492b8" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic cosine of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的双曲余弦值。</target>
        </trans-unit>
        <trans-unit id="d1e0c67a77c4c9f3880463f9d8f3aa99bf732d31" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic sine of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的双曲正弦值。</target>
        </trans-unit>
        <trans-unit id="fea32eb8ad9df99ec39e088fce28cbee17276c80" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes hyperbolic tangent of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的双曲正切值。</target>
        </trans-unit>
        <trans-unit id="cd3565d6513a55d7d6d649e63d9ef8dc096c132d" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes natural logarithm of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的自然对数。</target>
        </trans-unit>
        <trans-unit id="8613519bb915be734bdb83ddf1139c1436d679c7" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes sine of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的正弦值。</target>
        </trans-unit>
        <trans-unit id="16f2ed1e42028d25247c7e709cdd5ffa277bdfdc" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes tangent of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的正切值。</target>
        </trans-unit>
        <trans-unit id="2e8b5a06d41da5547ea77c34dce52624edf4f443" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;va&lt;/code&gt; computes the square root of the value of the element.</source>
          <target state="translated">对于 &lt;code&gt;va&lt;/code&gt; 中的每个元素，计算元素值的平方根。</target>
        </trans-unit>
        <trans-unit id="de5098d9b31cace81235396b1ac2a117bb05f2f0" translate="yes" xml:space="preserve">
          <source>For each identifier, a variable whose type is &quot;reference to &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&amp;lt;i, E&amp;gt;::type&lt;/code&gt;&quot; is introduced: lvalue reference if its corresponding initializer is an lvalue, rvalue reference otherwise. The initializer for the i-th variable is.</source>
          <target state="translated">对于每个标识符，都会引入一个变量，其类型为&amp;ldquo;对 &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_element&quot;&gt;std::tuple_element&lt;/a&gt;&amp;lt;i, E&amp;gt;::type&lt;/code&gt; 引用&amp;rdquo;：如果其对应的初始化程序为左值，则为左值引用，否则为右值引用。第i个变量的初始化程序是。</target>
        </trans-unit>
        <trans-unit id="e5405c9dfb873a374ff065f865a38e9ad5451317" translate="yes" xml:space="preserve">
          <source>For each non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; in &lt;code&gt;T&lt;/code&gt; or in a base of &lt;code&gt;T&lt;/code&gt; (unless hidden), whose cv-qualifiers is same or greater than &lt;code&gt;T&lt;/code&gt;'s cv-qualifiers, and where the conversion function converts to:</source>
          <target state="translated">对于每一个非显式&lt;a href=&quot;cast_operator&quot;&gt;用户定义的转换函数&lt;/a&gt;在 &lt;code&gt;T&lt;/code&gt; 或在碱 &lt;code&gt;T&lt;/code&gt; （除非隐藏），其CV-限定符是相同或大于 &lt;code&gt;T&lt;/code&gt; 的cv修饰符，其中所述转换函数转换到，并且：</target>
        </trans-unit>
        <trans-unit id="96919b66c472b53a5ced1aa599bee24bc87358ce" translate="yes" xml:space="preserve">
          <source>For each pair of viable function &lt;code&gt;F1&lt;/code&gt; and &lt;code&gt;F2&lt;/code&gt;, the implicit conversion sequences from the &lt;code&gt;i&lt;/code&gt;-th argument to &lt;code&gt;i&lt;/code&gt;-th parameter are ranked to determine which one is better (except the first argument, the</source>
          <target state="translated">对于每一对可行函数的 &lt;code&gt;F1&lt;/code&gt; 和 &lt;code&gt;F2&lt;/code&gt; ，从所述的隐式转换的序列 &lt;code&gt;i&lt;/code&gt; 个参数 &lt;code&gt;i&lt;/code&gt; 个参数进行排名，以确定哪一个更好（除了第一个参数，该</target>
        </trans-unit>
        <trans-unit id="077e83335df9a76882a31f009c6cc740f8436fb9" translate="yes" xml:space="preserve">
          <source>For each such match &lt;code&gt;m&lt;/code&gt;, copies the non-matched subsequence (&lt;a href=&quot;match_results/prefix&quot;&gt;&lt;code&gt;m.prefix()&lt;/code&gt;&lt;/a&gt;) into &lt;code&gt;out&lt;/code&gt; as if by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(m.prefix().first, m.prefix().second, out)&lt;/code&gt; and then replaces the matched subsequence with the formatted replacement string as if by calling &lt;a href=&quot;match_results/format&quot;&gt;&lt;code&gt;out = m.format(out, fmt, flags)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于每个这样的匹配 &lt;code&gt;m&lt;/code&gt; ，将不匹配的子序列（&lt;a href=&quot;match_results/prefix&quot;&gt; &lt;code&gt;m.prefix()&lt;/code&gt; &lt;/a&gt;） &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(m.prefix().first, m.prefix().second, out)&lt;/code&gt; 到 &lt;code&gt;out&lt;/code&gt; 中，就像通过out = std :: copy（m.prefix（）。first，m.prefix（）。second，out）和然后用格式化的替换字符串替换匹配的子序列，就像通过调用&lt;a href=&quot;match_results/format&quot;&gt; &lt;code&gt;out = m.format(out, fmt, flags)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="35a02408e3ec343aa382ddb9f4539b81b6f6a912" translate="yes" xml:space="preserve">
          <source>For each type, non-type, and template parameter, including parameter packs, a unique fictitious type, value, or template is generated and substituted into function type of the template</source>
          <target state="translated">对于每一个类型、非类型和模板参数(包括参数包),都会生成一个唯一的虚构类型、值或模板,并代入模板的函数类型中。</target>
        </trans-unit>
        <trans-unit id="952fe468d5ee316980e589da22eb6018ea32e1cd" translate="yes" xml:space="preserve">
          <source>For equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).</source>
          <target state="translated">对于原来两个范围内的等价元素,第一个范围内的元素(保留原来的顺序)先于第二个范围内的元素(保留原来的顺序)。</target>
        </trans-unit>
        <trans-unit id="f8bf46aa49e5e80eadcaac2f31ab62ee0b13bf20" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;std::atomic&amp;lt;X&amp;gt;&lt;/code&gt; (whether or not specialized), &lt;code&gt;std::atomic&amp;lt;X&amp;gt;::value_type&lt;/code&gt; is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">对于每一个 &lt;code&gt;std::atomic&amp;lt;X&amp;gt;&lt;/code&gt; （不论是否专门）， &lt;code&gt;std::atomic&amp;lt;X&amp;gt;::value_type&lt;/code&gt; 就是 &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57dd021d134106ddd0d180af4fadda643026b891" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;&lt;/code&gt; (whether or not specialized), &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;::value_type&lt;/code&gt; is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">对于每一个 &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;&lt;/code&gt; （不论是否专门） &lt;code&gt;std::atomic_ref&amp;lt;X&amp;gt;::value_type&lt;/code&gt; 就是 &lt;code&gt;X&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e51dc104fca63d5103f9e0cf646aa86197a6c341" translate="yes" xml:space="preserve">
          <source>For every T that is a pointer-to-member type or the type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the following function signature participates in overload resolution:</source>
          <target state="translated">对于每个指向成员类型或类型 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; ，以下函数签名均参与重载解析：</target>
        </trans-unit>
        <trans-unit id="d6a1bb30012f8a1244f1eb8a6420656d9d6e09c6" translate="yes" xml:space="preserve">
          <source>For every conversion specifier other than &lt;code&gt;n&lt;/code&gt;, the longest sequence of input characters which does not exceed any speciﬁed ﬁeld width and which either is exactly what the conversion specifier expects or is a prefix of a sequence it would expect, is what's consumed from the stream. The ﬁrst character, if any, after this consumed sequence remains unread. If the consumed sequence has length zero or if the consumed sequence cannot be converted as specified above, the matching failure occurs unless end-of-ﬁle, an encoding error, or a read error prevented input from the stream, in which case it is an input failure.</source>
          <target state="translated">对于除 &lt;code&gt;n&lt;/code&gt; 以外的每个转换说明符，从流中消耗的最长输入字符序列不超过任何指定的字段宽度，该长度恰好是转换说明符所期望的或者是它所期望的序列的前缀。此消耗序列之后的第一个字符（如果有）保持未读状态。如果使用的序列长度为零，或者无法按照上述指定的顺序转换使用的序列，则除非文件末尾，编码错误或读取错误阻止从流中输入，否则发生匹配失败。输入失败。</target>
        </trans-unit>
        <trans-unit id="90c2546abb31c7caf07bad20c6eabba4b2fe603e" translate="yes" xml:space="preserve">
          <source>For every enumeration or pointer to member type &lt;code&gt;T&lt;/code&gt;, optionally volatile-qualified, the following function signature participates in overload resolution:</source>
          <target state="translated">对于成员类型 &lt;code&gt;T&lt;/code&gt; 的每个枚举或指针，可以选择通过volatile限定，以下函数签名参与重载解析：</target>
        </trans-unit>
        <trans-unit id="88970b9a9ff96606e8a48b4759fd878eb0266d29" translate="yes" xml:space="preserve">
          <source>For every iterator type &lt;code&gt;It&lt;/code&gt;, a typedef &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_category&lt;/code&gt; is available, which is an alias to one of these five(until C++20)six(since C++20) tag types.</source>
          <target state="translated">对于每种Iterator类型 &lt;code&gt;It&lt;/code&gt; ，都可以使用typedef &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_category&lt;/code&gt; ，它是这五个（直到C ++ 20），六个（自C ++ 20起）标记类型之一的别名。</target>
        </trans-unit>
        <trans-unit id="e71c9303eec62288eff7b54439f77781e36bc155" translate="yes" xml:space="preserve">
          <source>For every optionally cv-qualified object type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">对于每个可选的由cv限定的对象类型 &lt;code&gt;T&lt;/code&gt; ，以下函数签名参与重载解析：</target>
        </trans-unit>
        <trans-unit id="96c0842f465784a49ab8d68561798db17053d280" translate="yes" xml:space="preserve">
          <source>For every pair A1 and A2, where A1 is an arithmetic type (optionally volatile-qualified) and A2 is a promoted arithmetic type, the following function signature participates in overload resolution:</source>
          <target state="translated">对于每一对A1和A2,其中A1是一个算术类型(可选择volatile限定),A2是一个提升的算术类型,下面的函数签名参与过载解决。</target>
        </trans-unit>
        <trans-unit id="20e473aa5e7c31193000e4e17752d2e9b84efea5" translate="yes" xml:space="preserve">
          <source>For every pair I1 and I2, where I1 is an integral type (optionally volatile-qualified) and I2 is a promoted integral type, the following function signatures participate in overload resolution:</source>
          <target state="translated">对于每一对I1和I2,其中I1是一个积分类型(可选择易失性限定),I2是一个提升的积分类型,以下函数签名参与过载解决。</target>
        </trans-unit>
        <trans-unit id="fef8c5eb5bd67258e2ec4544fa11f3c0a8bfa352" translate="yes" xml:space="preserve">
          <source>For every pair of promoted arithmetic types L and R and for every type P, where P is a pointer, pointer-to-member, or scoped enumeration type, the following function signatures participate in the overload resolution performed in step 5 of the rules above:</source>
          <target state="translated">对于每一对被推广的算术类型L和R,以及对于每一个类型P(其中P是指针、指针到成员或作用域枚举类型),以下函数签名参与了上述规则的步骤5中执行的过载解析。</target>
        </trans-unit>
        <trans-unit id="d638c80e090b37ee12468ee54f0147dce03100fb" translate="yes" xml:space="preserve">
          <source>For every parameter in params whose type is specified as &lt;code&gt;auto&lt;/code&gt;, an invented template parameter is added to template-params, in order of appearance. The invented template parameter may be a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt; if the corresponding function member of params is a function parameter pack.</source>
          <target state="translated">对于类型指定为 &lt;code&gt;auto&lt;/code&gt; 的 params中的每个参数，按照出现的顺序将发明的模板参数添加到template-params中。如果&lt;a href=&quot;parameter_pack&quot;&gt;参数&lt;/a&gt;的相应功能成员是功能参数包，则本发明的模板参数可以是参数包。</target>
        </trans-unit>
        <trans-unit id="859f56c75df09c6419c76fcbdbe8ae8dbb4f8aed" translate="yes" xml:space="preserve">
          <source>For every type &lt;code&gt;MP&lt;/code&gt; that is a pointer to member object or pointer to member function or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">对于每个指向成员对象或成员函数或 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 的指针的 &lt;code&gt;MP&lt;/code&gt; 类型，以下函数签名均参与重载解析：</target>
        </trans-unit>
        <trans-unit id="5ba25517699790e207bae588adda9d67eb82eb32" translate="yes" xml:space="preserve">
          <source>For every type &lt;code&gt;P&lt;/code&gt; which is either pointer to object or pointer to function or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;(until C++14), the following function signatures participate in overload resolution:</source>
          <target state="translated">对于每个指向对象或函数或 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 类型 &lt;code&gt;P&lt;/code&gt; （直到C ++ 14），以下函数签名参与重载解析：</target>
        </trans-unit>
        <trans-unit id="ee4a3f0b05542f01bd799b3b751f77169b8294dd" translate="yes" xml:space="preserve">
          <source>For every type other than reference and function, the type system supports three additional &lt;a href=&quot;cv&quot;&gt;cv-qualified versions&lt;/a&gt; of that type (&lt;code&gt;const&lt;/code&gt;, &lt;code&gt;volatile&lt;/code&gt;, and &lt;code&gt;const volatile&lt;/code&gt;).</source>
          <target state="translated">对于除了引用和函数以外的每种类型，类型系统都支持该类型的三个附加的&lt;a href=&quot;cv&quot;&gt;cv限定版本&lt;/a&gt;（ &lt;code&gt;const&lt;/code&gt; ， &lt;code&gt;volatile&lt;/code&gt; 和 &lt;code&gt;const volatile&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ba768967270bb243200289babda957e1dccea676" translate="yes" xml:space="preserve">
          <source>For every valid value of &lt;code&gt;char_type&lt;/code&gt;, there must be a unique value of &lt;code&gt;int_type&lt;/code&gt; distinct from &lt;code&gt;eof()&lt;/code&gt;. For example, a common implementation of &lt;code&gt;char_traits&amp;lt;char&amp;gt;::eof()&lt;/code&gt; is &lt;code&gt;return -1&lt;/code&gt;, and a corresponding valid implementation of &lt;code&gt;char_traits&amp;lt;char&amp;gt;::to_int_type(c)&lt;/code&gt; is &lt;code&gt;return (unsigned char)c&lt;/code&gt;.</source>
          <target state="translated">对于 &lt;code&gt;char_type&lt;/code&gt; 的每个有效值，必须有一个与 &lt;code&gt;eof()&lt;/code&gt; 不同的 &lt;code&gt;int_type&lt;/code&gt; 唯一值。例如， &lt;code&gt;char_traits&amp;lt;char&amp;gt;::eof()&lt;/code&gt; 的常见实现是 &lt;code&gt;return -1&lt;/code&gt; ，而 &lt;code&gt;char_traits&amp;lt;char&amp;gt;::to_int_type(c)&lt;/code&gt; 的相应有效实现是 &lt;code&gt;return (unsigned char)c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="220aba5bf092ed62052a3a23de11e863b192c055" translate="yes" xml:space="preserve">
          <source>For every virtual function, there is the</source>
          <target state="translated">对于每个虚拟函数,都有</target>
        </trans-unit>
        <trans-unit id="96405e325a2957f41ae4e0cb514953a5e216ba60" translate="yes" xml:space="preserve">
          <source>For example when the regex flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; is set, then the sequence &lt;code&gt;[a-b]&lt;/code&gt; would match some character &lt;code&gt;c1&lt;/code&gt; if &lt;code&gt;traits.transform(&quot;a&quot;) &amp;lt;= traits.transform(c1) &amp;lt;= traits.transform(&quot;b&quot;)&lt;/code&gt;. Note that this function takes a character sequence as the argument to accomodate to the ranges defined like &lt;code&gt;[&lt;/code&gt;&lt;code&gt;[.ae.]-d]&lt;/code&gt;.</source>
          <target state="translated">例如，当该正则表达式标志 &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; 被设置，则该序列 &lt;code&gt;[a-b]&lt;/code&gt; 将匹配一些字符 &lt;code&gt;c1&lt;/code&gt; 如果 &lt;code&gt;traits.transform(&quot;a&quot;) &amp;lt;= traits.transform(c1) &amp;lt;= traits.transform(&quot;b&quot;)&lt;/code&gt; 。请注意，此函数将字符序列作为参数来适应 &lt;code&gt;[&lt;/code&gt; &lt;code&gt;[.ae.]-d]&lt;/code&gt; 类定义的范围。</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="21afdf58d530130e0cd1ecfb369c10eeeccc97f9" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;int b:3;&lt;/code&gt; may have the range of values &lt;code&gt;0..7&lt;/code&gt; or &lt;code&gt;-4..3&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;int b:3;&lt;/code&gt; 可以具有的值的范围 &lt;code&gt;0..7&lt;/code&gt; 或 &lt;code&gt;-4..3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7d231fa0de4c53b5a41ff143b9ff0bc463fe738" translate="yes" xml:space="preserve">
          <source>For example, a gslice with starting index &lt;code&gt;3&lt;/code&gt;, strides &lt;code&gt;{19,4,1&lt;/code&gt;} and lengths &lt;code&gt;{2,4,3} &lt;/code&gt; generates the following set of indices:</source>
          <target state="translated">例如，起始索引为 &lt;code&gt;3&lt;/code&gt; ，步幅为 &lt;code&gt;{19,4,1&lt;/code&gt; }，长度为 &lt;code&gt;{2,4,3} &lt;/code&gt; 的gslice生成以下索引集：</target>
        </trans-unit>
        <trans-unit id="b98b27a6a16bb9a7bf0282ec3a82d51ac5557fa2" translate="yes" xml:space="preserve">
          <source>For example, given &lt;code&gt;const auto&amp;amp; i = expr;&lt;/code&gt;, the type of &lt;code&gt;i&lt;/code&gt; is exactly the type of the argument &lt;code&gt;u&lt;/code&gt; in an imaginary template &lt;code&gt;template&amp;lt;class U&amp;gt; void f(const U&amp;amp; u)&lt;/code&gt; if the function call &lt;code&gt;f(expr)&lt;/code&gt; was compiled. Therefore, &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; may be deduced either as an lvalue reference or rvalue reference according to the initializer, which is used in range-based for loop.</source>
          <target state="translated">例如，给定 &lt;code&gt;const auto&amp;amp; i = expr;&lt;/code&gt; ，如果编译了函数调用 &lt;code&gt;f(expr)&lt;/code&gt; ,则 &lt;code&gt;i&lt;/code&gt; 的类型恰好是虚构模板 &lt;code&gt;template&amp;lt;class U&amp;gt; void f(const U&amp;amp; u)&lt;/code&gt; 参数 &lt;code&gt;u&lt;/code&gt; 的类型。因此，根据初始化程序，可以将 &lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt; 推导出为左值引用或右值引用，该值在基于范围的for循环中使用。</target>
        </trans-unit>
        <trans-unit id="b64fbd2e8414cb52362895b9416d02f046ec2ac9" translate="yes" xml:space="preserve">
          <source>For example, if a wrapper does not just forward its argument, but calls a member function on the argument, and forwards its result:</source>
          <target state="translated">例如,如果一个包装器不只是转发它的参数,而是在参数上调用一个成员函数,并转发其结果。</target>
        </trans-unit>
        <trans-unit id="3ad08d76cd3366adf2e4002a2a86eba860f92547" translate="yes" xml:space="preserve">
          <source>For example, if used in wrapper such as the following, the template behaves as described below:</source>
          <target state="translated">例如,如果在包装器中使用,如下面的模板,其行为如下所述。</target>
        </trans-unit>
        <trans-unit id="17f92461460ba9421050f5a120102adab4bd7d16" translate="yes" xml:space="preserve">
          <source>For example, in:</source>
          <target state="translated">例如,在。</target>
        </trans-unit>
        <trans-unit id="8f787b27b81522ff7994a2b1d11b99ed11a43f0f" translate="yes" xml:space="preserve">
          <source>For example, on Windows, where &lt;code&gt;\&lt;/code&gt; is the preferred separator, the path &lt;code&gt;foo/bar&lt;/code&gt; will be converted to &lt;code&gt;foo\bar&lt;/code&gt;.</source>
          <target state="translated">例如，在Windows上，其中 &lt;code&gt;\&lt;/code&gt; 是首选分隔符，路径 &lt;code&gt;foo/bar&lt;/code&gt; 将转换为 &lt;code&gt;foo\bar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c80798c74b99761f9f8d6a1d7f496bb6f7e553ba" translate="yes" xml:space="preserve">
          <source>For example, on some platforms, bit fields don't straddle bytes, on others they do</source>
          <target state="translated">例如,在一些平台上,位字段不跨越字节,在另一些平台上则跨越字节</target>
        </trans-unit>
        <trans-unit id="e2df7d9cb75dfece63f96a9945f6d4796b35277d" translate="yes" xml:space="preserve">
          <source>For example, the composite pointer type of &lt;code&gt;void*&lt;/code&gt; and &lt;code&gt;const int*&lt;/code&gt; is &lt;code&gt;const void*&lt;/code&gt;. The composite pointer type of &lt;code&gt;int**&lt;/code&gt; and &lt;code&gt;const int**&lt;/code&gt; is &lt;code&gt;const int* const*&lt;/code&gt;. Note that until C++14, &lt;code&gt;int**&lt;/code&gt; and &lt;code&gt;const int**&lt;/code&gt; could not be compared.</source>
          <target state="translated">例如， &lt;code&gt;void*&lt;/code&gt; 和 &lt;code&gt;const int*&lt;/code&gt; 的复合指针类型为 &lt;code&gt;const void*&lt;/code&gt; 。 &lt;code&gt;int**&lt;/code&gt; 和 &lt;code&gt;const int**&lt;/code&gt; 的复合指针类型为 &lt;code&gt;const int* const*&lt;/code&gt; 。请注意，在C ++ 14之前，无法比较 &lt;code&gt;int**&lt;/code&gt; 和 &lt;code&gt;const int**&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62bb742426a794f8be0f5a25a2d2f7632ae88b7a" translate="yes" xml:space="preserve">
          <source>For example, the following class template does not use the type T in its private members or in the body of push_back.</source>
          <target state="translated">例如,下面的类模板在其私有成员或push_back的主体中不使用T类型。</target>
        </trans-unit>
        <trans-unit id="9c6f9185eeed0381f9dd1d89f296fbc5ee5be5b1" translate="yes" xml:space="preserve">
          <source>For example, to compile &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;;&lt;/code&gt;, the compiler performs:</source>
          <target state="translated">例如，要编译 &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; &lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;;&lt;/code&gt; ，编译器执行：</target>
        </trans-unit>
        <trans-unit id="9d4b3358e1df9f2bea37a27eaa5e14ffa2bc6778" translate="yes" xml:space="preserve">
          <source>For example, with &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; initially zero,</source>
          <target state="translated">例如，如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 最初为零，</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="f2cbbd695a1dfd1a4a615d31b844bf65755121de" translate="yes" xml:space="preserve">
          <source>For floating-point &amp;alpha;, the value obtained is the sum of &amp;alpha; independent exponentially distributed random variables, each of which has a mean of &amp;beta;</source>
          <target state="translated">对于浮点&amp;alpha;，获得的值是&amp;alpha;独立指数分布随机变量的总和，每个变量的平均值为&amp;beta;</target>
        </trans-unit>
        <trans-unit id="37bba3e4eccd73e2ef72c749ab8c25e15efc6e60" translate="yes" xml:space="preserve">
          <source>For floating-point types with denormalization, &lt;code&gt;min&lt;/code&gt; returns the minimum positive normalized value.</source>
          <target state="translated">对于具有非规格化的浮点类型， &lt;code&gt;min&lt;/code&gt; 返回最小的正规格化值。</target>
        </trans-unit>
        <trans-unit id="b593b953b77c2c511c9c9e8acca67b444d03c30c" translate="yes" xml:space="preserve">
          <source>For floating-point types, if &lt;code&gt;showpoint&lt;/code&gt; is set, the modifier &lt;code&gt;#&lt;/code&gt; is prepended.</source>
          <target state="translated">对于浮点类型，如果设置了 &lt;code&gt;showpoint&lt;/code&gt; ，则会在修饰符 &lt;code&gt;#&lt;/code&gt; 之前添加。</target>
        </trans-unit>
        <trans-unit id="52fff2d809b2cb152e5b4a1ad6291720dc27d5c1" translate="yes" xml:space="preserve">
          <source>For floating-point types, the &lt;a href=&quot;../../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; in effect may be different from the calling thread's floating-point environment. The operation need not be conform to the corresponding &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; traits but is encouraged to do so. If the result is not a representable value for its type, the result is unspecified but the operation otherwise has no undefined behavior.</source>
          <target state="translated">对于浮点类型，有效的&lt;a href=&quot;../../numeric/fenv&quot;&gt;浮点环境&lt;/a&gt;可能与调用线程的浮点环境不同。该操作不必符合相应的 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; 特性，但建议这样做。如果结果不是其类型的可表示值，则结果未指定，但操作没有其他未定义的行为。</target>
        </trans-unit>
        <trans-unit id="5ab94c8e0b590e7f556887eaae16aec44908d571" translate="yes" xml:space="preserve">
          <source>For function and function template names, name lookup can associate multiple declarations with the same name, and may obtain additional declarations from &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;. &lt;a href=&quot;function_template&quot;&gt;Template argument deduction&lt;/a&gt; may also apply, and the set of declarations is passed to &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, which selects the declaration that will be used. &lt;a href=&quot;access&quot;&gt;Member access&lt;/a&gt; rules, if applicable, are considered only after name lookup and overload resolution.</source>
          <target state="translated">对于函数和函数模板名称，名称查找可以将多个声明与相同的名称相关联，并且可以从&lt;a href=&quot;adl&quot;&gt;依赖&lt;/a&gt;于参数的lookup中获取其他声明。&lt;a href=&quot;function_template&quot;&gt;模板自变量推导&lt;/a&gt;也可能适用，并将声明集传递给&lt;a href=&quot;overload_resolution&quot;&gt;重载解析&lt;/a&gt;，该重载选择将使用的声明。&lt;a href=&quot;access&quot;&gt;成员访问&lt;/a&gt;规则（如果适用）仅在名称查找和重载解析之后才考虑。</target>
        </trans-unit>
        <trans-unit id="36d9c94cd9c3cc36a9b671f755d250722c29f111" translate="yes" xml:space="preserve">
          <source>For functions, specifies that the return type will be deduced from its return statements.</source>
          <target state="translated">对于函数,指定将从其返回语句中推导出返回类型。</target>
        </trans-unit>
        <trans-unit id="f9d92b090fe79a87f7ef3997de21c665c200fc40" translate="yes" xml:space="preserve">
          <source>For initialization of locals (that is, block scope) static and thread-local variables, see &lt;a href=&quot;storage_duration#Static_local_variables&quot;&gt;static local variables&lt;/a&gt;.</source>
          <target state="translated">有关局部变量（即块作用域）的静态和线程局部变量的初始化，请参见&lt;a href=&quot;storage_duration#Static_local_variables&quot;&gt;静态局部变量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac4327b8179e23975065e9af7bd05ec6be15b5bc" translate="yes" xml:space="preserve">
          <source>For input streams (&lt;code&gt;mode &amp;amp; ios_base::in == true&lt;/code&gt;), &lt;code&gt;eback()&lt;/code&gt; points at the first character, &lt;code&gt;gptr() == eback()&lt;/code&gt;, and &lt;code&gt;egptr() == eback() + s.size()&lt;/code&gt;: the subsequent input will read the first character copied from &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">对于输入流（ &lt;code&gt;mode &amp;amp; ios_base::in == true&lt;/code&gt; ）， &lt;code&gt;eback()&lt;/code&gt; 指向第一个字符， &lt;code&gt;gptr() == eback()&lt;/code&gt; 和 &lt;code&gt;egptr() == eback() + s.size()&lt;/code&gt; ：后续输入将读取从 &lt;code&gt;s&lt;/code&gt; 复制的第一个字符。</target>
        </trans-unit>
        <trans-unit id="ec3905377a1c94d495d985035e68f7411ea9980d" translate="yes" xml:space="preserve">
          <source>For input streams (and for update streams on which the last operation was input), the behavior is undefined.</source>
          <target state="translated">对于输入流(以及最后一个操作是输入的更新流),该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="3263d60841f8b602b9cc58bd2747c0e72fde62e4" translate="yes" xml:space="preserve">
          <source>For integer &lt;code&gt;arg&lt;/code&gt;, the binary logarithm can be interpreted as the zero-based index of the most significant 1 bit in the input.</source>
          <target state="translated">对于整数 &lt;code&gt;arg&lt;/code&gt; ，二进制对数可以解释为输入中最高有效1位的从零开始的索引。</target>
        </trans-unit>
        <trans-unit id="ed5f0c55df7482886d0bbb61dde66b50525bc79d" translate="yes" xml:space="preserve">
          <source>For integer types, if &lt;code&gt;showbase&lt;/code&gt; is set, the modifier &lt;code&gt;#&lt;/code&gt; is prepended.</source>
          <target state="translated">对于整数类型，如果设置了 &lt;code&gt;showbase&lt;/code&gt; ，则会在修饰符 &lt;code&gt;#&lt;/code&gt; 之前加前缀。</target>
        </trans-unit>
        <trans-unit id="cf8479d95c472194fb01daf6a842e55ed66b89af" translate="yes" xml:space="preserve">
          <source>For integer types, length modifier is added to the conversion specification if necessary: &lt;code&gt;h&lt;/code&gt; for &lt;code&gt;short&lt;/code&gt; and &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;l&lt;/code&gt; for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;ll&lt;/code&gt; for &lt;code&gt;long long&lt;/code&gt; and &lt;code&gt;unsigned long long&lt;/code&gt;</source>
          <target state="translated">对于整数类型，如有必要，将长度修饰符添加到转换规范中： &lt;code&gt;h&lt;/code&gt; 表示 &lt;code&gt;short&lt;/code&gt; 和 &lt;code&gt;unsigned short&lt;/code&gt; &lt;code&gt;long&lt;/code&gt; ， &lt;code&gt;l&lt;/code&gt; 表示long和 &lt;code&gt;unsigned long&lt;/code&gt; ， &lt;code&gt;ll&lt;/code&gt; 表示 &lt;code&gt;long long&lt;/code&gt; 和 &lt;code&gt;unsigned long long&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6101d794e56d2d1f4f0a50cfba90d4442ea8210d" translate="yes" xml:space="preserve">
          <source>For integer types, length modifier is added to the conversion specification if necessary: &lt;code&gt;l&lt;/code&gt; for &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;ll&lt;/code&gt; for &lt;code&gt;long long&lt;/code&gt; and &lt;code&gt;unsigned long long&lt;/code&gt;(since C++11).</source>
          <target state="translated">对于整数类型，如有必要，将长度修饰符添加到转换规范中： &lt;code&gt;l&lt;/code&gt; 表示 &lt;code&gt;long&lt;/code&gt; 和 &lt;code&gt;unsigned long&lt;/code&gt; ， &lt;code&gt;ll&lt;/code&gt; 表示 &lt;code&gt;long long&lt;/code&gt; 和 &lt;code&gt;unsigned long long&lt;/code&gt; （自C ++ 11起）。</target>
        </trans-unit>
        <trans-unit id="9635f0a469e86775a961c9f4f06c2d75d2ad2838" translate="yes" xml:space="preserve">
          <source>For integral and arithmetic types, the template argument provided during instantiation must be a &lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of the template parameter's type (so certain implicit conversion applies).</source>
          <target state="translated">对于整数和算术类型，在实例化期间提供的template参数必须是模板参数类型的&lt;a href=&quot;constant_expression&quot;&gt;转换后的常量表达式&lt;/a&gt;（因此适用某些隐式转换）。</target>
        </trans-unit>
        <trans-unit id="888e66ad3cd1de9e2997f82859b81050f3f98936" translate="yes" xml:space="preserve">
          <source>For integral arguments, &lt;a href=&quot;abs&quot;&gt;the integral overloads of &lt;code&gt;std::abs&lt;/code&gt;&lt;/a&gt; are likely better matches. If &lt;code&gt;std::abs&lt;/code&gt; is called with an argument of type &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; cannot be converted to &lt;code&gt;int&lt;/code&gt; by &lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">对于整数参数，&lt;a href=&quot;abs&quot;&gt; &lt;code&gt;std::abs&lt;/code&gt; &lt;/a&gt;的整数重载可能是更好的匹配。如果 &lt;code&gt;std::abs&lt;/code&gt; 被调用类型的参数 &lt;code&gt;X&lt;/code&gt; ，使得 &lt;code&gt;&lt;a href=&quot;../../types/is_unsigned&quot;&gt;std::is_unsigned&lt;/a&gt;&amp;lt;X&amp;gt;::value&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;X&lt;/code&gt; 不能被转换为 &lt;code&gt;int&lt;/code&gt; 由&lt;a href=&quot;../../language/implicit_cast#Integral_promotion&quot;&gt;整数提升&lt;/a&gt;，是形成不良的节目。</target>
        </trans-unit>
        <trans-unit id="1060ee889330db82947214695c2314922ae38003" translate="yes" xml:space="preserve">
          <source>For integral operands, it yields the algebraic quotient.</source>
          <target state="translated">对于积分操作数,它可以得到代数商。</target>
        </trans-unit>
        <trans-unit id="88259ad2a8442b91aaef00f672b4f16ecba02e17" translate="yes" xml:space="preserve">
          <source>For lvalue reference parameters, the argument provided at instantiation cannot be a temporary, an unnamed lvalue, or a named lvalue with no linkage (in other words, the argument must have linkage).</source>
          <target state="translated">对于l值引用参数,实例化时提供的参数不能是临时性的,不能是未命名的l值,也不能是没有链接的命名l值(换句话说,参数必须有链接)。</target>
        </trans-unit>
        <trans-unit id="07ec985082848563aa89c0c13f4926e059b3c9cc" translate="yes" xml:space="preserve">
          <source>For member functions of class &lt;code&gt;X&lt;/code&gt;, the type of the implicit object parameter is affected by cv-qualifications and ref-qualifications of the member function as described in &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;.</source>
          <target state="translated">对于类 &lt;code&gt;X&lt;/code&gt; 的成员函数，隐式对象参数的类型受成员函数中所述的&lt;a href=&quot;member_functions&quot;&gt;成员函数&lt;/a&gt;的cv限定和ref限定影响。</target>
        </trans-unit>
        <trans-unit id="19791e90c11ccaf6d487d6bb230d6565f3784cc4" translate="yes" xml:space="preserve">
          <source>For most &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;std::proj(z)==z&lt;/code&gt;, but all complex infinities, even the numbers where one component is infinite and the other is NaN, become positive real infinity, &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, 0)&lt;/code&gt; or &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, -0)&lt;/code&gt;. The sign of the imaginary (zero) component is the sign of &lt;code&gt;&lt;a href=&quot;imag2&quot;&gt;std::imag&lt;/a&gt;(z)&lt;/code&gt;.</source>
          <target state="translated">对于大多数 &lt;code&gt;z&lt;/code&gt; ， &lt;code&gt;std::proj(z)==z&lt;/code&gt; ，但是所有复杂的无穷大，甚至一个分量为无穷大而另一个为NaN的数字也变为正实无穷大， &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, 0)&lt;/code&gt; 或 &lt;code&gt;(&lt;a href=&quot;../math/infinity&quot;&gt;INFINITY&lt;/a&gt;, -0)&lt;/code&gt; 。虚数（零）的符号是 &lt;code&gt;&lt;a href=&quot;imag2&quot;&gt;std::imag&lt;/a&gt;(z)&lt;/code&gt; 的符号。</target>
        </trans-unit>
        <trans-unit id="dedc12147e0e26b892c9c3c4c65e52f5512feb4a" translate="yes" xml:space="preserve">
          <source>For multi-level pointers, the following restrictions apply: a multilevel pointer &lt;code&gt;P1&lt;/code&gt; which is cv1</source>
          <target state="translated">对于多级指针，以下限制适用：cv1 的多级指针 &lt;code&gt;P1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="376ecc03409163c2995d77d8d27738cf7cb39e45" translate="yes" xml:space="preserve">
          <source>For negative &lt;code&gt;a&lt;/code&gt;, the behavior of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is undefined.</source>
          <target state="translated">对于负 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 的行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="1494de8919bb1c4ea96591e8c652173df74c133c" translate="yes" xml:space="preserve">
          <source>For negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is implementation-defined (in most implementations, this performs arithmetic right shift, so that the result remains negative).</source>
          <target state="translated">对于负 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; 的值是实现定义的（在大多数实现中，这将执行算术右移，因此结果保持为负）。</target>
        </trans-unit>
        <trans-unit id="8d245548c2af614dd2b79e9d581bbfee18630af5" translate="yes" xml:space="preserve">
          <source>For non-&lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; class types, members with the same &lt;a href=&quot;access&quot;&gt;member access&lt;/a&gt; are always allocated so that the members declared later have higher addresses within a class object. Members with different access control are allocated in unspecified order (the compiler may group them together). Alignment requirements may necessitate padding between members, or after the last member of a class.</source>
          <target state="translated">对于非&lt;a href=&quot;union&quot;&gt;联合&lt;/a&gt;类类型，始终分配具有相同&lt;a href=&quot;access&quot;&gt;成员访问权限&lt;/a&gt;的成员，以便稍后声明的成员在类对象中具有更高的地址。具有不同访问控制的成员以未指定的顺序分配（编译器可以将它们分组在一起）。对齐要求可能需要在成员之间或课程的最后一个成员之后进行填充。</target>
        </trans-unit>
        <trans-unit id="9b6b58d70b3d593d4d88872f97e32d333db88729" translate="yes" xml:space="preserve">
          <source>For non-appending output streams, &lt;code&gt;pptr() == pbase()&lt;/code&gt;, so that subsequent output will overwrite the characters copied from &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">对于非附加输出流， &lt;code&gt;pptr() == pbase()&lt;/code&gt; ，以便后续输出将覆盖从 &lt;code&gt;s&lt;/code&gt; 复制的字符。</target>
        </trans-unit>
        <trans-unit id="606fb425d7d848cb68effbf7891839f3901900f6" translate="yes" xml:space="preserve">
          <source>For non-array &lt;code&gt;type&lt;/code&gt;, the single object is constructed in the acquired memory area.</source>
          <target state="translated">对于非数组 &lt;code&gt;type&lt;/code&gt; ，将在获取的内存区域中构造单个对象。</target>
        </trans-unit>
        <trans-unit id="2e50302a0b35323ade517a1a99cf0e861fd9f2ad" translate="yes" xml:space="preserve">
          <source>For non-class types, copy and move assignment are indistinguishable and are referred to as</source>
          <target state="translated">对于非类类型,复制和移动分配是无法区分的,称为</target>
        </trans-unit>
        <trans-unit id="961645d5c1ea45b10c1dab6cd681b33d3b3e7623" translate="yes" xml:space="preserve">
          <source>For non-class types, the right operand is first &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to the cv-unqualified type of the left operand, and then its value is copied into the object identified by left operand.</source>
          <target state="translated">对于非类类型，首先将右操作数&lt;a href=&quot;implicit_cast&quot;&gt;隐式转换&lt;/a&gt;为左操作数的cv不合格类型，然后将其值复制到左操作数标识的对象中。</target>
        </trans-unit>
        <trans-unit id="763322c7964e589eee6959c4585b224d003bfdec" translate="yes" xml:space="preserve">
          <source>For non-polymorphic objects, the interpretation of the value is determined from the expression in which the object is used, and is decided at compile time.</source>
          <target state="translated">对于非多态对象,值的解释由使用该对象的表达式决定,并在编译时决定。</target>
        </trans-unit>
        <trans-unit id="abfd29ae0e4b12baa41dd1f2957ee892d3a0b889" translate="yes" xml:space="preserve">
          <source>For non-template functions, default arguments can be added to a function that was already declared if the function is redeclared in the same scope. At the point of a function call, the defaults are a union of the defaults provided in all visible declarations for the function. A redeclaration cannot introduce a default for an argument for which a default is already visible (even if the value is the same). A re-declaration in an inner scope does not acquire the default arguments from outer scopes.</source>
          <target state="translated">对于非模板函数,如果在同一个作用域中重新声明了一个已经声明的函数,那么默认参数可以被添加到该函数中。在函数调用时,缺省参数是该函数所有可见声明中提供的缺省参数的联合。重新声明不能为一个已经有缺省值的参数引入缺省值(即使值是相同的)。在内部作用域中的重新声明不会从外部作用域中获取缺省参数。</target>
        </trans-unit>
        <trans-unit id="0991570f4540f46325a93449ba04cca879b380b0" translate="yes" xml:space="preserve">
          <source>For non-type template parameter packs whose type uses a placeholder type, the type is independently deduced for each template argument and need not match:</source>
          <target state="translated">对于类型使用占位符类型的非类型模板参数包,每个模板参数的类型是独立推导出来的,不需要匹配。</target>
        </trans-unit>
        <trans-unit id="bd5aba2924605ce9fcbd81eb53c058fae5c7dea4" translate="yes" xml:space="preserve">
          <source>For non-type template parameters, specifies that the type will be deduced from the argument.</source>
          <target state="translated">对于非类型模板参数,指定将从参数中推导出类型。</target>
        </trans-unit>
        <trans-unit id="7514bfabe1453bf3e4fa04b102092e65768ddd6d" translate="yes" xml:space="preserve">
          <source>For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the move assignment operator performs full member-wise move assignment of the object's direct bases and immediate non-static members, in their declaration order, using built-in assignment for the scalars, memberwise move-assignment for arrays, and move assignment operator for class types (called non-virtually).</source>
          <target state="translated">对于非联合类类型（ &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;struct&lt;/code&gt; ），移动赋值运算符对对象的直接基和直接非静态成员按其声明顺序执行成员的完整成员明智的移动赋值，对标量使用内置赋值数组的移动分配，类类的移动分配运算符（非虚拟地）。</target>
        </trans-unit>
        <trans-unit id="268fe4cbc20a4aa0215c7d01242785136c98fb6e" translate="yes" xml:space="preserve">
          <source>For nonempty ranges, exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - 1&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">对于非空范围，正好是 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last) - 1&lt;/code&gt; 相应谓词的1个应用。</target>
        </trans-unit>
        <trans-unit id="f6180b71feea7358927f872628400b8246c94135" translate="yes" xml:space="preserve">
          <source>For nonempty ranges, exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last) -1&lt;/code&gt; applications of the corresponding predicate.</source>
          <target state="translated">对于非空范围，精确地对应谓词的 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last) -1&lt;/code&gt; 应用程序。</target>
        </trans-unit>
        <trans-unit id="6147555f2527654078938dabd88a3dffc2574f9a" translate="yes" xml:space="preserve">
          <source>For objects of non-aggregate class type, a public &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructor&lt;/a&gt; must be defined (either user-defined or implicitly defined) to satisfy DefaultConstructible.</source>
          <target state="translated">对于非聚合类类型的对象，必须定义一个公共&lt;a href=&quot;../language/default_constructor&quot;&gt;默认构造&lt;/a&gt;函数（用户定义或隐式定义）才能满足DefaultConstructible。</target>
        </trans-unit>
        <trans-unit id="5e455249348a9249c3d467d0641b99a240d6d8c9" translate="yes" xml:space="preserve">
          <source>For other contexts where overloaded function names can appear, see &lt;a href=&quot;overloaded_address&quot;&gt;taking the address of an overloaded function&lt;/a&gt;.</source>
          <target state="translated">对于其他可能出现重载函数名称的情况，请参见&lt;a href=&quot;overloaded_address&quot;&gt;获取重载函数的地址&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e2bc8579aeb917ea35ac1bcbad18eb05fd4bdc45" translate="yes" xml:space="preserve">
          <source>For output streams (&lt;code&gt;mode &amp;amp; ios_base::out == true&lt;/code&gt;), &lt;code&gt;pbase()&lt;/code&gt; points at the first character and &lt;code&gt;epptr() &amp;gt;= pbase() + s.size()&lt;/code&gt; (epptr is allowed to point farther so that the following &lt;code&gt;sputc()&lt;/code&gt; wouldn't immediately call &lt;code&gt;overflow()&lt;/code&gt;)</source>
          <target state="translated">对于输出流（ &lt;code&gt;mode &amp;amp; ios_base::out == true&lt;/code&gt; ）， &lt;code&gt;pbase()&lt;/code&gt; 指向第一个字符， &lt;code&gt;epptr() &amp;gt;= pbase() + s.size()&lt;/code&gt; （epptr可以指向更远的位置，以便随后的 &lt;code&gt;sputc()&lt;/code&gt; 不会立即调用 &lt;code&gt;overflow()&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="8f63d9afe770e3006ba3c31bb680ec6934c94657" translate="yes" xml:space="preserve">
          <source>For output streams (and for update streams on which the last operation was output), writes any unwritten data from the &lt;code&gt;stream&lt;/code&gt;'s buffer to the associated output device.</source>
          <target state="translated">对于输出流（以及在其上输出最后一个操作的更新流），将任何未写入的数据从 &lt;code&gt;stream&lt;/code&gt; 的缓冲区写入关联的输出设备。</target>
        </trans-unit>
        <trans-unit id="481575f6bdf13b67deef2e241c2a9a6d1c8d891f" translate="yes" xml:space="preserve">
          <source>For output streams, this typically results in writing the contents of the put area into the associated sequence, i.e. flushing of the output buffer. For input streams, this typically empties the get area and forces a re-read from the associated sequence to pick up recent changes. The default behavior (found, for example, in &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;), is to do nothing.</source>
          <target state="translated">对于输出流，这通常导致将放置区域的内容写入关联的序列，即刷新输出缓冲区。对于输入流，这通常会清空get区域，并从相关序列中强制重新读取以获取最近的更改。默认行为（例如，在 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; ）是什么也不做。</target>
        </trans-unit>
        <trans-unit id="a6ae1e52a83b6ade1ae039896874969c5f21c0bf" translate="yes" xml:space="preserve">
          <source>For overload (5), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, const U&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">对于重载（5）， &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, const U&amp;amp;&amp;gt;&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="75a2c90c2bfc30a317a46c88b8a56739d5f6fa1d" translate="yes" xml:space="preserve">
          <source>For overload (6), &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">对于重载（6）， &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, U&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable_v&lt;/a&gt;&amp;lt;T&amp;amp;, U&amp;gt;&lt;/code&gt; 均为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2780c151ef71bd4320af5b5a8131bcdca9bcbb78" translate="yes" xml:space="preserve">
          <source>For overloads (1,2), if one of the parameters is an rvalue, the reference returned becomes a dangling reference at the end of the full expression that contains the call to &lt;code&gt;minmax&lt;/code&gt;:</source>
          <target state="translated">对于重载（1,2），如果参数之一是右值，则返回的引用在包含对 &lt;code&gt;minmax&lt;/code&gt; 的调用的完整表达式的末尾成为悬空引用：</target>
        </trans-unit>
        <trans-unit id="8382a9060c467fcc4ada14b4b211aabe3aa6d683" translate="yes" xml:space="preserve">
          <source>For overloads (3,5,7,9), The function can be implemented with the return type different from &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt;. In this case, the replacement type has the following properties:</source>
          <target state="translated">对于重载（3,5,7,9），可以使用不同于 &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; 的返回类型来实现该函数。在这种情况下，替换类型具有以下属性：</target>
        </trans-unit>
        <trans-unit id="e863547ad76debf1e954b0555a0ab321eb1a4d01" translate="yes" xml:space="preserve">
          <source>For pointers to functions, the valid arguments are pointers to functions with linkage (or constant expressions that evaluate to null pointer values).</source>
          <target state="translated">对于指向函数的指针,有效的参数是指向有联结关系的函数的指针(或者是评价为空指针值的常量表达式)。</target>
        </trans-unit>
        <trans-unit id="0c14d4f91a6fd67c34187b14315456bf4871a9d3" translate="yes" xml:space="preserve">
          <source>For pointers to member functions and pointers to data members, &lt;code&gt;t1&lt;/code&gt; may be a regular pointer or an object of class type that overloads &lt;code&gt;operator*&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于指向成员函数的指针和指向数据成员的指针， &lt;code&gt;t1&lt;/code&gt; 可以是常规指针或重载 &lt;code&gt;operator*&lt;/code&gt; 的类类型的对象，例如 &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a71d4a336a0c5624e650b25202bdefde98d600fd" translate="yes" xml:space="preserve">
          <source>For pointers to members, the argument has to be a pointer to member expressed as &lt;code&gt;&amp;amp;Class::Member&lt;/code&gt; or a constant expression that evaluates to null pointer or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">对于指向成员的指针，参数必须是指向以 &lt;code&gt;&amp;amp;Class::Member&lt;/code&gt; 表示的成员的指针，或者是计算为空指针或 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 值的常量表达式。</target>
        </trans-unit>
        <trans-unit id="a1d3d2317fc6b323549d75e48efcd87a6d6fa4bd" translate="yes" xml:space="preserve">
          <source>For pointers to objects, the template arguments have to designate the address of a complete object with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; and a &lt;a href=&quot;storage_duration#Linkage&quot;&gt;linkage&lt;/a&gt; (either internal or external), or a constant expression that evaluates to the appropriate null pointer or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">对于指向对象的指针，模板参数必须指定具有静态&lt;a href=&quot;storage_duration&quot;&gt;存储持续时间&lt;/a&gt;和&lt;a href=&quot;storage_duration#Linkage&quot;&gt;链接&lt;/a&gt;（内部或外部）或评估为适当的空指针或 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 值的常量表达式的完整对象的地址。</target>
        </trans-unit>
        <trans-unit id="62b3bed6c74847c88d09ff91b5a9eb3064f5365b" translate="yes" xml:space="preserve">
          <source>For portable directory and file naming, see &lt;a href=&quot;../../filesystem&quot;&gt;C++ filesystem library&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem&lt;/a&gt;.</source>
          <target state="translated">有关可移植目录和文件的命名，请参见&lt;a href=&quot;../../filesystem&quot;&gt;C ++文件系统库&lt;/a&gt;或&lt;a href=&quot;http://www.boost.org/doc/libs/1_56_0/libs/filesystem/doc/index.htm&quot;&gt;boost.filesystem&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb935bbe4c86edf17255328af95f195fe665edf1" translate="yes" xml:space="preserve">
          <source>For portable pathname generation from Unicode strings, see &lt;a href=&quot;u8path&quot;&gt;u8path&lt;/a&gt;.</source>
          <target state="translated">有关从Unicode字符串生成可移植路径名的信息，请参见&lt;a href=&quot;u8path&quot;&gt;u8path&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0dfb375daadbb3e77fbf4f5775a23c9dc598be6b" translate="yes" xml:space="preserve">
          <source>For proper values of &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;, the following properties are true:</source>
          <target state="translated">对于 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;j&lt;/code&gt; 的正确值，以下属性为true：</target>
        </trans-unit>
        <trans-unit id="530c267bd41398cdf37d989d6c0ff07e1066ef3d" translate="yes" xml:space="preserve">
          <source>For prvalue expressions, the dynamic type is always the same as the static type.</source>
          <target state="translated">对于prvalue表达式,动态类型总是与静态类型相同。</target>
        </trans-unit>
        <trans-unit id="adfb2dec7da66f103fd2b9cd71521128041db54d" translate="yes" xml:space="preserve">
          <source>For signed &lt;code&gt;Integral&lt;/code&gt; types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results.</source>
          <target state="translated">对于带符号的 &lt;code&gt;Integral&lt;/code&gt; 类型，算术定义为使用二进制补码表示形式。没有未定义的结果。</target>
        </trans-unit>
        <trans-unit id="ed5e530786bebc7b272d33fe3e9f636b75dcece4" translate="yes" xml:space="preserve">
          <source>For signed and non-negative &lt;code&gt;a&lt;/code&gt;, if a * 2b</source>
          <target state="translated">对于带符号和非负 &lt;code&gt;a&lt;/code&gt; ，如果a * 2b</target>
        </trans-unit>
        <trans-unit id="3af751b6ecf63d4481061bc54946dd23bc4bd1ff" translate="yes" xml:space="preserve">
          <source>For signed and non-negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is a * 2b</source>
          <target state="translated">对于有符号和非负 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 值为a * 2b</target>
        </trans-unit>
        <trans-unit id="8d1075cea1a2a6de71e067eda636b7104a7e1c7b" translate="yes" xml:space="preserve">
          <source>For signed integral types, arithmetic is defined to use two&amp;rsquo;s complement representation. There are no undefined results.</source>
          <target state="translated">对于有符号整数类型，算术定义为使用二进制补码表示。没有未定义的结果。</target>
        </trans-unit>
        <trans-unit id="7df120d1e9011ddd1ce77a96f4b12ae1b34f6af9" translate="yes" xml:space="preserve">
          <source>For some &lt;code&gt;j&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, &lt;code&gt;X​::​lt(p[j], q[j])&lt;/code&gt; is true and</source>
          <target state="translated">对于一些 &lt;code&gt;j&lt;/code&gt; 在 &lt;code&gt;[0,n)&lt;/code&gt; ， &lt;code&gt;X​::​lt(p[j], q[j])&lt;/code&gt; 为真和</target>
        </trans-unit>
        <trans-unit id="81ca343fa42d2babb2e6749bedea9b053e460258" translate="yes" xml:space="preserve">
          <source>For some engines, &quot;fast jump&quot; algorithms are known, which advance the state by many steps (order of millions) without calculating intermediate state transitions, although not necessarily in constant time.</source>
          <target state="translated">对于某些引擎,已知的是 &quot;快速跳转 &quot;算法,这种算法可以将状态提前很多步(百万级),而不需要计算中间的状态转换,尽管不一定是在恒定的时间内。</target>
        </trans-unit>
        <trans-unit id="fd4abd3a725738e4ad1d6b4cf76b4fe8cb02df5a" translate="yes" xml:space="preserve">
          <source>For some of the C standard library headers of the form &lt;code&gt;xxx.h&lt;/code&gt;, the C++ standard library both includes an identically-named header and another header of the form &lt;code&gt;cxxx&lt;/code&gt; (all meaningful &lt;code&gt;cxxx&lt;/code&gt; headers are listed above).</source>
          <target state="translated">对于某些格式为 &lt;code&gt;xxx.h&lt;/code&gt; 的C标准库标头，C ++标准库都包含一个名称相同的标头和格式为 &lt;code&gt;cxxx&lt;/code&gt; 的另一个标头（上面列出了所有有意义的 &lt;code&gt;cxxx&lt;/code&gt; 标头）。</target>
        </trans-unit>
        <trans-unit id="cf567f1a3c60615e84656e20417b1a1de74545ac" translate="yes" xml:space="preserve">
          <source>For some of the signals, the implementation may call &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_IGN&lt;/a&gt;)&lt;/code&gt; at the startup of the program. For the rest, the implementation must call &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">对于某些信号，该实现可以在程序启动时调用 &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_IGN&lt;/a&gt;)&lt;/code&gt; 。对于其余部分，实现必须调用 &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f03372ec69aa391f826e43bea001123512eb679" translate="yes" xml:space="preserve">
          <source>For standard attributes, it will expand to the year and month in which the attribute was added to the working draft (see table below), the presence of vendor-specific attributes is determined by a non-zero value.</source>
          <target state="translated">对于标准属性,将扩展到该属性加入工作稿的年月日(见下表),厂商特定属性的存在由非零值决定。</target>
        </trans-unit>
        <trans-unit id="b56d8ebf643b96a82d52768c03f8db9aa07210bd" translate="yes" xml:space="preserve">
          <source>For templated functions with deduced return types, the return value may be named in a postcondition without additional restrictions (except that the name of the return value is treated as having a &lt;a href=&quot;../dependent_name#Type-dependent_expressions&quot;&gt;dependent type&lt;/a&gt;). For the non-templated functions with deduced return types, naming the return value is prohibited in declarations (but allowed in the definitions):</source>
          <target state="translated">对于具有推论返回类型的模板化函数，可以在没有附加限制的情况下以后置条件命名返回值（除非将返回值的名称视为具有&lt;a href=&quot;../dependent_name#Type-dependent_expressions&quot;&gt;从属类型&lt;/a&gt;）。对于具有推论返回类型的非模板函数，在声明中禁止命名返回值（但在定义中允许）：</target>
        </trans-unit>
        <trans-unit id="6c8bc61f784489c1be269b98b2a834b94911c08f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;A&lt;/code&gt; conversion style</source>
          <target state="translated">对于 &lt;code&gt;A&lt;/code&gt; 转换样式</target>
        </trans-unit>
        <trans-unit id="e2ae91f5c3692945d40532e2d71ac0a4386bf89f" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;E&lt;/code&gt; conversion style</source>
          <target state="translated">对于 &lt;code&gt;E&lt;/code&gt; 转换样式</target>
        </trans-unit>
        <trans-unit id="ebb3f8b2a8fff5b3415e1098f326b2c10a1d27f2" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;G&lt;/code&gt; conversion style conversion with style &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;F&lt;/code&gt; will be performed.</source>
          <target state="translated">对于 &lt;code&gt;G&lt;/code&gt; 转换，将执行样式 &lt;code&gt;E&lt;/code&gt; 或 &lt;code&gt;F&lt;/code&gt; 的转换。</target>
        </trans-unit>
        <trans-unit id="5a1ff43b4f3925bee54ad2942ba18ef8a4606c5a" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;X&lt;/code&gt; conversion letters &lt;code&gt;ABCDEF&lt;/code&gt; are used.</source>
          <target state="translated">对于 &lt;code&gt;X&lt;/code&gt; 转换，使用字母 &lt;code&gt;ABCDEF&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="57890cceddb7efc24f01d52d8cf7f7dcc8bbc9c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;a&lt;/code&gt; conversion style</source>
          <target state="translated">对于 &lt;code&gt;a&lt;/code&gt; 风格转换</target>
        </trans-unit>
        <trans-unit id="ff2ab4c944a5b84fe46520d57012d6c750be1de1" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;char&lt;/code&gt; specialization, &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;lt&lt;/code&gt; are defined identically to the built-in operators &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; for type &lt;code&gt;unsigned char&lt;/code&gt; (</source>
          <target state="translated">对于 &lt;code&gt;char&lt;/code&gt; 专用化， &lt;code&gt;eq&lt;/code&gt; 和 &lt;code&gt;lt&lt;/code&gt; 与 &lt;code&gt;unsigned char&lt;/code&gt; 类型的内置运算符 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 相同地定义（</target>
        </trans-unit>
        <trans-unit id="41f7d301edd4649ecc9cc5e4ae27295bc06e8657" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;e&lt;/code&gt; conversion style</source>
          <target state="translated">对于 &lt;code&gt;e&lt;/code&gt; 转换样式</target>
        </trans-unit>
        <trans-unit id="a793f4315aaf80e04799e8d39a2f905e34a3d0ea" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;g&lt;/code&gt; conversion style conversion with style &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;f&lt;/code&gt; will be performed.</source>
          <target state="translated">对于 &lt;code&gt;g&lt;/code&gt; 转换，将执行样式 &lt;code&gt;e&lt;/code&gt; 或 &lt;code&gt;f&lt;/code&gt; 的转换。</target>
        </trans-unit>
        <trans-unit id="807d09a568c3d3ab555b52969a3cc98de7806c36" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;x&lt;/code&gt; conversion letters &lt;code&gt;abcdef&lt;/code&gt; are used.</source>
          <target state="translated">对于 &lt;code&gt;x&lt;/code&gt; 转换，使用字母 &lt;code&gt;abcdef&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="964c75b68c3b67fa44944f427366e59ff71c8628" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, if |arg| &amp;gt; 710.5, then &lt;code&gt;cosh(arg)&lt;/code&gt; overflows.</source>
          <target state="translated">对于IEEE兼容类型，如果| arg |，则为 &lt;code&gt;double&lt;/code&gt; 。&amp;gt; 710.5，然后 &lt;code&gt;cosh(arg)&lt;/code&gt; 溢出。</target>
        </trans-unit>
        <trans-unit id="dc98bc92461ef84f63213928d7e0dd4bec2a4ac3" translate="yes" xml:space="preserve">
          <source>For the IEEE-compatible type &lt;code&gt;double&lt;/code&gt;, underflow is guaranteed if &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55.</source>
          <target state="translated">对于IEEE兼容类型 &lt;code&gt;double&lt;/code&gt; ，如果 &lt;code&gt;arg&lt;/code&gt; &amp;gt; 26.55 ，则保证下溢。</target>
        </trans-unit>
        <trans-unit id="5139171c7dc4bf39c00774f4969ee9ed5cb06814" translate="yes" xml:space="preserve">
          <source>For the alphabetic components of the default date format (if any), this function is usually case-insensitive.</source>
          <target state="translated">对于默认日期格式的字母成分(如果有的话),这个函数通常不区分大小写。</target>
        </trans-unit>
        <trans-unit id="ca85fb6216b889960979e71b66f45292ecb6fff0" translate="yes" xml:space="preserve">
          <source>For the alphabetic components of the default time format (if any), this function is usually case-insensitive.</source>
          <target state="translated">对于默认时间格式的字母成分(如果有的话),这个函数通常不区分大小写。</target>
        </trans-unit>
        <trans-unit id="3387ca380771e46f30ac460b364c23f3a50ac485" translate="yes" xml:space="preserve">
          <source>For the binary operators (except shifts), if the promoted operands have different types, additional set of implicit conversions is applied, known as</source>
          <target state="translated">对于二进制运算符(除移位外),如果推广的操作数具有不同的类型,则会应用额外的隐式转换集,称为</target>
        </trans-unit>
        <trans-unit id="5834b75a1d37489895cb80d1b1901ebbb10cdea5" translate="yes" xml:space="preserve">
          <source>For the built-in logical AND operator, the result is &lt;code&gt;true&lt;/code&gt; if both operands are &lt;code&gt;true&lt;/code&gt;. Otherwise, the result is &lt;code&gt;false&lt;/code&gt;. This operator is &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;short-circuiting&lt;/a&gt;: if the first operand is &lt;code&gt;false&lt;/code&gt;, the second operand is not evaluated.</source>
          <target state="translated">对于内置的逻辑与操作，结果是 &lt;code&gt;true&lt;/code&gt; ，如果两个操作数是 &lt;code&gt;true&lt;/code&gt; 。否则，结果为 &lt;code&gt;false&lt;/code&gt; 。该运算符正在&lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;短路&lt;/a&gt;：如果第一个操作数为 &lt;code&gt;false&lt;/code&gt; ，则不计算第二个操作数。</target>
        </trans-unit>
        <trans-unit id="4f868d872215ad926f03072ef85906893d1cbc9f" translate="yes" xml:space="preserve">
          <source>For the built-in logical NOT operator, the result is &lt;code&gt;true&lt;/code&gt; if the operand is &lt;code&gt;false&lt;/code&gt;. Otherwise, the result is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">对于内置逻辑NOT运算符，如果操作数为 &lt;code&gt;false&lt;/code&gt; ，则结果为 &lt;code&gt;true&lt;/code&gt; 。否则，结果为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="98a7f937369cdbc13ece1f4624b3c0deaca24c09" translate="yes" xml:space="preserve">
          <source>For the built-in logical OR operator, the result is &lt;code&gt;true&lt;/code&gt; if either the first or the second operand (or both) is &lt;code&gt;true&lt;/code&gt;. This operator is short-circuiting: if the first operand is &lt;code&gt;true&lt;/code&gt;, the second operand is not evaluated.</source>
          <target state="translated">对于内置逻辑OR运算符，其结果是 &lt;code&gt;true&lt;/code&gt; ，如果第一或第二操作数（或两者）是 &lt;code&gt;true&lt;/code&gt; 。该运算符正在短路：如果第一个操作数为 &lt;code&gt;true&lt;/code&gt; ，则不计算第二个操作数。</target>
        </trans-unit>
        <trans-unit id="e1db3901d3c9b8e71a137ee3fd4f6e31711c8ecd" translate="yes" xml:space="preserve">
          <source>For the built-in operator, expression must have arithmetic or unscoped enumeration type. Integral promotion is performed on the operand and determines the type of the result.</source>
          <target state="translated">对于内置运算符,表达式必须具有算术型或无范围枚举型。对操作数进行积分提升,并确定结果的类型。</target>
        </trans-unit>
        <trans-unit id="ed7967925e3d9a903dc61fad15c26826b80985cc" translate="yes" xml:space="preserve">
          <source>For the built-in operator, expression must have arithmetic, unscoped enumeration, or pointer type. Integral promotion is performed on the operand if it has integral or unscoped enumeration type and determines the type of the result.</source>
          <target state="translated">对于内置运算符,表达式必须具有算术型、无范围枚举型或指针型。如果操作数具有积分或无范围枚举类型,则对操作数进行积分提升,并确定结果的类型。</target>
        </trans-unit>
        <trans-unit id="1f4b14dfb9171534a115c48cff5a996c8739f0c3" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must be one of the following:</source>
          <target state="translated">对于内置的运算符,lhs和rhs必须是以下之一。</target>
        </trans-unit>
        <trans-unit id="c2fd6c69985c326b9c90b5457d6125aba9680de4" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must both have arithmetic or unscoped enumeration type.</source>
          <target state="translated">对于内置运算符,lhs和rhs必须同时具有算术或无范围枚举类型。</target>
        </trans-unit>
        <trans-unit id="21aefc527d6a29a300de35c2b1a6e0de364db29e" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs and rhs must both have integral or unscoped enumeration type</source>
          <target state="translated">对于内置运算符,lhs和rhs必须同时具有积分或无范围的枚举类型。</target>
        </trans-unit>
        <trans-unit id="0e1c1ef458021530f026a00ce0e6a1cdf579bce8" translate="yes" xml:space="preserve">
          <source>For the built-in operator, lhs may have any non-const scalar type and rhs must be implicitly convertible to the type of lhs.</source>
          <target state="translated">对于内置运算符,lhs可以有任何非const标量类型,rhs必须隐式转换为lhs的类型。</target>
        </trans-unit>
        <trans-unit id="0fc6e93f0b5ccc41116e96e66ba6cc181fbeaf32" translate="yes" xml:space="preserve">
          <source>For the built-in operators, lhs and rhs must both have integral or unscoped enumeration type. Integral promotions are performed on both operands.</source>
          <target state="translated">对于内置运算符,lhs和rhs必须同时具有积分或无范围枚举类型。两个操作数都要进行积分提升。</target>
        </trans-unit>
        <trans-unit id="8b5909dfd25b823a91c25e0c6ebfb4fe115565d4" translate="yes" xml:space="preserve">
          <source>For the built-in operators, lhs and rhs must both have integral or unscoped enumeration type. Usual arithmetic conversions are performed on both operands and determine the type of the result.</source>
          <target state="translated">对于内置运算符,lhs和rhs必须同时具有积分或无范围枚举类型。通常对两个操作数进行算术转换,并确定结果的类型。</target>
        </trans-unit>
        <trans-unit id="631e90fa71e23701d70b68b196fb2c8886d4ce41" translate="yes" xml:space="preserve">
          <source>For the character sequence &lt;code&gt;[first, last)&lt;/code&gt;, obtains the primary sort key in the imbued locale's collating order, that is, the sort key that is based on the positions of the letters and collation units in the national alphabet, ignoring case, diacritics, variants, etc. If a primary sort key compares less than another primary sort key with &lt;code&gt;operator&amp;lt;&lt;/code&gt;, then the character sequence that produced the first sort key comes before the character sequence that produced the second sort key, in the currently imbued locale's primary collation order.</source>
          <target state="translated">对于字符序列 &lt;code&gt;[first, last)&lt;/code&gt; ，以灌输语言环境的整理顺序获取主要的排序键，即基于国家字母表中字母和排序单位的位置而忽略大小写，变音符号，如果主排序键与 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 比较少于另一个主排序键，则按照当前注入的语言环境的主排序顺序，生成第一个排序键的字符序列在生成第二个排序键的字符序列之前。</target>
        </trans-unit>
        <trans-unit id="e113ddf9e42810bbcd7d53a7fd8437e10332cdc3" translate="yes" xml:space="preserve">
          <source>For the definition of &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&lt;/code&gt;, the following exposition-only concept is defined.</source>
          <target state="translated">对于 &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&lt;/code&gt; 的定义，定义了以下仅博览会的概念。</target>
        </trans-unit>
        <trans-unit id="d1225d08c6a217571442e3f149849eb65e94bce7" translate="yes" xml:space="preserve">
          <source>For the entities that are captured by reference (with the default capture &lt;code&gt;[&amp;amp;]&lt;/code&gt; or when using the character &amp;amp;, e.g. &lt;code&gt;[&amp;amp;a, &amp;amp;b, &amp;amp;c]&lt;/code&gt;), it is unspecified if additional data members are declared in the closure type , but any such additional members must satisfy &lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;(since C++17).</source>
          <target state="translated">对于通过引用（使用默认捕获 &lt;code&gt;[&amp;amp;]&lt;/code&gt; 或使用字符＆，例如 &lt;code&gt;[&amp;amp;a, &amp;amp;b, &amp;amp;c]&lt;/code&gt; ）捕获的实体，未指定是否在闭包类型中声明了其他数据成员，但是任何此类其他成员必须满足&lt;a href=&quot;../named_req/literaltype&quot;&gt;LiteralType&lt;/a&gt;（从C ++ 17开始）。</target>
        </trans-unit>
        <trans-unit id="1a22058978c1262938bcaa97c3c6020766a5ad4e" translate="yes" xml:space="preserve">
          <source>For the first (non-array) form, expression must be a pointer to an object type or a class type &lt;a href=&quot;implicit_cast&quot;&gt;contextually implicitly convertible&lt;/a&gt; to such pointer, and its value must be either</source>
          <target state="translated">对于第一种（非数组）形式，表达式必须是指向对象类型的指针或&lt;a href=&quot;implicit_cast&quot;&gt;上下文隐式可转换&lt;/a&gt;为该指针的类类型，并且其值必须为</target>
        </trans-unit>
        <trans-unit id="299adf2377e7d703f91fcfc6dc32f0216b89eb0d" translate="yes" xml:space="preserve">
          <source>For the first (non-const) version, the behavior is undefined if this character is modified to any value other than &lt;code&gt;CharT()&lt;/code&gt; .</source>
          <target state="translated">对于第一个（非const）版本，如果将此字符修改为 &lt;code&gt;CharT()&lt;/code&gt; 之外的任何其他值，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="90655817fab85d8ac14c5bbb029cd02bf793db95" translate="yes" xml:space="preserve">
          <source>For the last two rows of the table, &lt;code&gt;&lt;i&gt;num&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;den&lt;/i&gt;&lt;/code&gt; in the suffix are &lt;code&gt;Period::type::num&lt;/code&gt; and &lt;code&gt;Period::type::den&lt;/code&gt; formatted as a decimal number with no leading zeroes, respectively.</source>
          <target state="translated">对于表的最后两行，后缀中的 &lt;code&gt;&lt;i&gt;num&lt;/i&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;i&gt;den&lt;/i&gt;&lt;/code&gt; 分别为 &lt;code&gt;Period::type::num&lt;/code&gt; 和 &lt;code&gt;Period::type::den&lt;/code&gt; 格式为十进制数字，没有前导零。</target>
        </trans-unit>
        <trans-unit id="cbb5833c26a713296ad8005d9e28d5fc0bbfe8a6" translate="yes" xml:space="preserve">
          <source>For the name of a class or class template used within the definition of that class or template or derived from one, unqualified name lookup finds the class that's being defined as if the name was introduced by a member declaration (with public member access). For more detail, see &lt;a href=&quot;injected-class-name&quot;&gt;injected-class-name&lt;/a&gt;.</source>
          <target state="translated">对于在该类或模板的定义中使用的或从其派生的类或类模板的名称，不合格的名称查找将查找所定义的类，就好像该名称是由成员声明（具有公共成员访问权）引入的。有关更多详细信息，请参见&lt;a href=&quot;injected-class-name&quot;&gt;jected-class-name&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="43ac5c7c822f021589a3f0df6c74ca1128531b73" translate="yes" xml:space="preserve">
          <source>For the number of elements in the range &lt;code&gt;[first, last)&lt;/code&gt; without any additional criteria, see &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">有关没有任何其他条件的 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的元素数，请参阅 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3eb35ae41318a2300948bfa04a8b59aa4c523fcb" translate="yes" xml:space="preserve">
          <source>For the objects of type &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt; (unless they are oversize &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;), every bit of the object representation is required to participate in the value representation and each possible bit pattern represents a distinct value (no padding, trap bits, or multiple representations allowed).</source>
          <target state="translated">对于 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;signed char&lt;/code&gt; 和 &lt;code&gt;unsigned char&lt;/code&gt; 类型的对象（除非它们是超大的&lt;a href=&quot;bit_field&quot;&gt;bit字段&lt;/a&gt;），要求对象表示的每个位都参与值表示，并且每个可能的位模式都表示一个不同的值（无填充，陷阱位或允许的多种表示形式）。</target>
        </trans-unit>
        <trans-unit id="eda418fc0d7e0da6163efe2b320b70eff6e157ef" translate="yes" xml:space="preserve">
          <source>For the overload with an ExecutionPolicy, there may be a performance cost if ForwardIt's value type is not &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">对于具有ExecutionPolicy的重载，如果ForwardIt的值类型不是&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;，则可能会导致性能损失。</target>
        </trans-unit>
        <trans-unit id="e5b59a3fe5c4c6ada03047f0bc055b7cec5863b8" translate="yes" xml:space="preserve">
          <source>For the overloads with an ExecutionPolicy, there may be a performance cost if &lt;code&gt;ForwardIt1&lt;/code&gt;'s value_type is not &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">对于具有ExecutionPolicy的重载，如果 &lt;code&gt;ForwardIt1&lt;/code&gt; 的value_type不是&lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;，则可能会降低性能。</target>
        </trans-unit>
        <trans-unit id="ca027ab75b905772f5d961e5c587aca010bc2ac6" translate="yes" xml:space="preserve">
          <source>For the overloads with an ExecutionPolicy, there may be a performance cost if the value type of &lt;code&gt;ForwardIterator1&lt;/code&gt; is not both &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">对于具有ExecutionPolicy的重载，如果 &lt;code&gt;ForwardIterator1&lt;/code&gt; 的值类型同时不是&lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;和&lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;，则可能会导致性能损失。</target>
        </trans-unit>
        <trans-unit id="ecf8e99bee770bd19c532d009a039c1a135e9bb1" translate="yes" xml:space="preserve">
          <source>For the purpose of &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, determining the type and value of the &lt;a href=&quot;this&quot;&gt;this pointer&lt;/a&gt; and for accessing non-static class members, the body of the closure type's function call operator is considered in the context of the lambda-expression.</source>
          <target state="translated">为了进行&lt;a href=&quot;lookup&quot;&gt;名称查找&lt;/a&gt;，确定&lt;a href=&quot;this&quot;&gt;this指针&lt;/a&gt;的类型和值以及访问非静态类成员，在lambda-expression的上下文中考虑了闭包类型的函数调用运算符的主体。</target>
        </trans-unit>
        <trans-unit id="65aeedb9e92b2d4cea74d76c9050bb672b686f5f" translate="yes" xml:space="preserve">
          <source>For the purpose of &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt;, if the next inner allocator is &lt;code&gt;A&lt;/code&gt;, any class &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T,A&amp;gt;::value == true&lt;/code&gt; participates in the recursion as if it was a container. Additionally, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; is treated as such a container by specific overloads of &lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;&lt;code&gt;scoped_allocator_adaptor::construct&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">出于 &lt;code&gt;scoped_allocator_adaptor&lt;/code&gt; 的目的，如果下一个内部分配器是 &lt;code&gt;A&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&amp;lt;T,A&amp;gt;::value == true&lt;/code&gt; &amp;lt;T，A&amp;gt; :: value == true的任何类 &lt;code&gt;T&lt;/code&gt; 都像容器一样参与递归。此外，通过&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt; &lt;code&gt;scoped_allocator_adaptor::construct&lt;/code&gt; &lt;/a&gt;特定重载将 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 视为此类容器。</target>
        </trans-unit>
        <trans-unit id="4cae47b4767abaac03c592dbea46b05ec44cfc59" translate="yes" xml:space="preserve">
          <source>For the purpose of this trait, the extent to which an implementation determines that a type cannot meet the &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; requirements is unspecified, except that a minimum &lt;code&gt;T&lt;/code&gt; shall not qualify as a &lt;a href=&quot;../named_req/clock&quot;&gt;Clock&lt;/a&gt; unless it meets all of the following conditions:</source>
          <target state="translated">此特征的目的，在何种程度上的实现确定某个类型不能满足&lt;a href=&quot;../named_req/clock&quot;&gt;时钟&lt;/a&gt;要求是未指定的，所不同的是最小 &lt;code&gt;T&lt;/code&gt; 不得资格作为&lt;a href=&quot;../named_req/clock&quot;&gt;时钟&lt;/a&gt;，除非它满足所有下列条件：</target>
        </trans-unit>
        <trans-unit id="fbf72513b1cc6b7e687b6187fddcae47438a5f71" translate="yes" xml:space="preserve">
          <source>For the purpose of this trait, two arrays have the same value if their elements have the same values, two non-union classes have the same value if their direct subobjects have the same value, and two unions have the same value if they have the same active member and the value of that member are the same.</source>
          <target state="translated">在这个特性中,如果两个数组的元素具有相同的值,则两个数组具有相同的值;如果两个非联合类的直接子对象具有相同的值,则两个非联合类具有相同的值;如果两个联合类具有相同的活动成员,且该成员的值相同,则两个联合类具有相同的值。</target>
        </trans-unit>
        <trans-unit id="73e5a63a0091c86f2d780d4bd7205bd859be1626" translate="yes" xml:space="preserve">
          <source>For the purpose of unqualified name lookup, all declarations from a namespace nominated by a &lt;a href=&quot;namespace&quot;&gt;using directive&lt;/a&gt; appear as if declared in the nearest enclosing namespace which contains, directly or indirectly, both the using-directive and the nominated namespace.</source>
          <target state="translated">出于无限定名称查找的目的，由&lt;a href=&quot;namespace&quot;&gt;using指令&lt;/a&gt;提名的名称空间中的所有声明似乎都在最近的封闭名称空间中声明，该名称空间直接或间接包含using-directive和被提名的名称空间。</target>
        </trans-unit>
        <trans-unit id="be7ff9400561e79a38fa934ba94eb51a08e444ed" translate="yes" xml:space="preserve">
          <source>For the purposes of the description below, a pointer type &lt;code&gt;Y*&lt;/code&gt; is said to be</source>
          <target state="translated">为了以下描述的目的，将指针类型 &lt;code&gt;Y*&lt;/code&gt; 称为</target>
        </trans-unit>
        <trans-unit id="e8841a4885b112152b14a19649fc94d610b058fa" translate="yes" xml:space="preserve">
          <source>For the purposes of this check, the variable definition is never interpreted as a function declaration, and the use of &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; is not considered an &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to &lt;code&gt;T&lt;/code&gt; and any of the types in &lt;code&gt;Args&lt;/code&gt;. Only the validity of the immediate context of the variable definition is considered.</source>
          <target state="translated">为了进行此检查，永远不要将变量定义解释为函数声明，并且将 &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; 的使用不视为&lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;。就像从与 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;Args&lt;/code&gt; 中任何类型都不相关的上下文中进行&lt;a href=&quot;../language/access&quot;&gt;访问检查&lt;/a&gt;一样。仅考虑变量定义的直接上下文的有效性。</target>
        </trans-unit>
        <trans-unit id="0b9a3ac76356afb7c5f4a3ea00f4b7fb14d9e7d4" translate="yes" xml:space="preserve">
          <source>For the rest of overload resolution, the</source>
          <target state="translated">其余的过载解决方案,则是</target>
        </trans-unit>
        <trans-unit id="a71380803d7225c2397b15d7056c647fe014ba63" translate="yes" xml:space="preserve">
          <source>For the sake of exposition, assume that &lt;code&gt;regex_iterator&lt;/code&gt; contains the following members:</source>
          <target state="translated">为了说明起见，假定 &lt;code&gt;regex_iterator&lt;/code&gt; 包含以下成员：</target>
        </trans-unit>
        <trans-unit id="67321d4e15267f4eda7f0452bd90ebdb6e086831" translate="yes" xml:space="preserve">
          <source>For the second (array) form, expression must be a null pointer value or a pointer value previously obtained by an array form of &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;. If expression is anything else, including if it's a pointer obtained by the non-array form of &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;.</source>
          <target state="translated">对于第二种（数组）形式，expression必须是空指针值或以前由&lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;数组形式获得的指针值。如果expression是其他任何东西，包括它是通过&lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;的非数组形式获得的指针，则该行为是&lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a9c4273040bcad4221585f3c35b8ea39b7d5d39a" translate="yes" xml:space="preserve">
          <source>For the situations when three-way comparison is not required, &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; provides the usual &lt;a href=&quot;operator_cmp&quot;&gt;relational operators&lt;/a&gt; (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc).</source>
          <target state="translated">对于不需要三向比较的情况， &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 提供了常用的&lt;a href=&quot;operator_cmp&quot;&gt;关系运算符&lt;/a&gt;（ &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;=&lt;/code&gt; ， &lt;code&gt;==&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; 等）。</target>
        </trans-unit>
        <trans-unit id="6f0ec42ffc782d2dbbdc18b148a303310b9bc1a6" translate="yes" xml:space="preserve">
          <source>For the specializations of &lt;code&gt;&lt;a href=&quot;../fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; that are used in the standard library, &lt;code&gt;State&lt;/code&gt; is always &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">对于标准库中使用的 &lt;code&gt;&lt;a href=&quot;../fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; 专业化， &lt;code&gt;State&lt;/code&gt; 始终为 &lt;code&gt;&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="144964c0df3039e3c71b1f52434a1f307b2a75a0" translate="yes" xml:space="preserve">
          <source>For the static member functions, the</source>
          <target state="translated">对于静态成员函数,</target>
        </trans-unit>
        <trans-unit id="eb5c7ff9cfa9a962ebc4d24b7e58d44592b6e8bd" translate="yes" xml:space="preserve">
          <source>For the types that are both &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; and &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, the C++ standard library makes a distinction between</source>
          <target state="translated">对于&lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;和&lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;两种类型，C ++标准库在</target>
        </trans-unit>
        <trans-unit id="731f2b2536187de6fbaec0afbeb784f1678b4260" translate="yes" xml:space="preserve">
          <source>For the types that are both &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; and LessThanComparable, the C++ standard library makes a distinction between</source>
          <target state="translated">对于同时具有&lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;和LessThanComparable 的类型，C ++标准库在</target>
        </trans-unit>
        <trans-unit id="a44f5a2bb8a05cc20c72fea8758fde71db78f3d3" translate="yes" xml:space="preserve">
          <source>For the types that are both EqualityComparable and &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, the C++ standard library makes a distinction between</source>
          <target state="translated">对于EqualityComparable和&lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;两种类型，C ++标准库在</target>
        </trans-unit>
        <trans-unit id="ea9de19131b3606684b0baafb3d2151f5a32dd40" translate="yes" xml:space="preserve">
          <source>For the use in derived class definitions, see &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;.</source>
          <target state="translated">有关在派生类定义中&lt;a href=&quot;using_declaration&quot;&gt;使用的信息&lt;/a&gt;，请参见using Declaration。</target>
        </trans-unit>
        <trans-unit id="48183fff740905d93ae3026fe871d3be4a4d9ec5" translate="yes" xml:space="preserve">
          <source>For two different parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are not equal, the probability that &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; should be very small, approaching &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_t&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">对于两个不相等的不同参数 &lt;code&gt;k1&lt;/code&gt; 和 &lt;code&gt;k2&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; 的概率应该很小，接近 &lt;code&gt;1.0/&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_t&amp;gt;::max()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc4402b538e707e656178152f7bd8d1b40d16256" translate="yes" xml:space="preserve">
          <source>For two parameters &lt;code&gt;k1&lt;/code&gt; and &lt;code&gt;k2&lt;/code&gt; that are equal, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt;.</source>
          <target state="translated">对于相等的两个参数 &lt;code&gt;k1&lt;/code&gt; 和 &lt;code&gt;k2&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k1) == &lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;Key&amp;gt;()(k2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="94a3ad0257f1ac1480c81596b592db0d4b3511aa" translate="yes" xml:space="preserve">
          <source>For two-digit input values, many implementations use the same parsing rules as the conversion specifier &lt;code&gt;'%y'&lt;/code&gt; as used by &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;get&quot;&gt;std::time_get::get()&lt;/a&gt;&lt;/code&gt;, and the POSIX function &lt;code&gt;strptime()&lt;/code&gt;: two-digit integer is expected, the values in the range [69,99] results in values 1969 to 1999, range [00,68] results in 2000-2068. Four-digit inputs are typically accepted as-is.</source>
          <target state="translated">对于两位数的输入值，许多实现使用与 &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;get&quot;&gt;std::time_get::get()&lt;/a&gt;&lt;/code&gt; 和POSIX函数 &lt;code&gt;strptime()&lt;/code&gt; 所使用的转换说明符 &lt;code&gt;'%y'&lt;/code&gt; 相同的解析规则：预期为数字整数，范围[69,99]中的值将导致值1969至1999，范围[00,68]中的值将导致2000-2068。通常按原样接受四位输入。</target>
        </trans-unit>
        <trans-unit id="642cd801d14b4a66f154da3cc51856b49e293f28" translate="yes" xml:space="preserve">
          <source>For two-way comparisons, &lt;a href=&quot;operator_cmp&quot;&gt;binary operators&lt;/a&gt; may be more suitable.</source>
          <target state="translated">对于双向比较，&lt;a href=&quot;operator_cmp&quot;&gt;二进制运算符&lt;/a&gt;可能更合适。</target>
        </trans-unit>
        <trans-unit id="fe584cd3d04227e8ee6e63e57235b2b1a239458e" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be BasicLockable, the following conditions have to be satisfied for an object &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;L&lt;/code&gt;:</source>
          <target state="translated">为了使类型 &lt;code&gt;L&lt;/code&gt; 为BasicLockable，必须为类型 &lt;code&gt;L&lt;/code&gt; 的对象 &lt;code&gt;m&lt;/code&gt; 满足以下条件：</target>
        </trans-unit>
        <trans-unit id="a492045a60cf54bb3785e73eca1da2d9437cc013" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be Lockable, it must meet the above condition as well as the following:</source>
          <target state="translated">为了使 &lt;code&gt;L&lt;/code&gt; 型可锁定，它必须满足上述条件以及以下条件：</target>
        </trans-unit>
        <trans-unit id="3192f26467193016e7a310e7cb38a3fb281f3879" translate="yes" xml:space="preserve">
          <source>For type &lt;code&gt;L&lt;/code&gt; to be TimedLockable, the following conditions have to be satisfied for an object &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;L&lt;/code&gt;:</source>
          <target state="translated">对于类型 &lt;code&gt;L&lt;/code&gt; 是TimedLockable，以下条件必须被满足的对象 &lt;code&gt;m&lt;/code&gt; 类型的 &lt;code&gt;L&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e5e7522e5abd30c0f3d5e5a223c5721c59cbeef9" translate="yes" xml:space="preserve">
          <source>For unsigned &lt;code&gt;a&lt;/code&gt; and for signed and non-negative &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is the integer part of a/2b</source>
          <target state="translated">对于无符号 &lt;code&gt;a&lt;/code&gt; 以及有符号和非负 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; 的值是a / 2b的整数部分</target>
        </trans-unit>
        <trans-unit id="aebdb0e43e858256601ff6d8a7d5738865f2a1f9" translate="yes" xml:space="preserve">
          <source>For unsigned &lt;code&gt;a&lt;/code&gt;, the value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is the value of a * 2b</source>
          <target state="translated">对于无符号 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; 的值是a * 2b的值</target>
        </trans-unit>
        <trans-unit id="d49c3968569060d907f70256e73011fe41b82ee7" translate="yes" xml:space="preserve">
          <source>For variables and other names introduced by simple declarations, the point of declaration is immediately after that name's &lt;a href=&quot;declarations#Declarators&quot;&gt;declarator&lt;/a&gt; and before its initializer, if any:</source>
          <target state="translated">对于简单声明所引入的变量和其他名称，声明的位置紧靠该名称的&lt;a href=&quot;declarations#Declarators&quot;&gt;声明器之后&lt;/a&gt;以及其初始化器（如果有）之前：</target>
        </trans-unit>
        <trans-unit id="4406791fdc0c802a309313fed6968b3cbed9aba4" translate="yes" xml:space="preserve">
          <source>For variables, specifies that the type of the variable that is being declared will be automatically deduced from its initializer.</source>
          <target state="translated">对于变量来说,指定被声明的变量的类型将从其初始化器中自动推导出来。</target>
        </trans-unit>
        <trans-unit id="5c276069327cb6d9e2ff643e9fb634c6f1cb43de" translate="yes" xml:space="preserve">
          <source>For version (2), the number of arguments must be the same as the number of parameters in macro definition. For versions (3,4), the number of arguments must be more than(until C++20)at least as many as(since C++20) the number of parameters (not counting &lt;code&gt;...&lt;/code&gt;). Otherwise the program is ill-formed. If the identifier is not in functional-notation, i.e. does not have parentheses after itself, it is not replaced at all.</source>
          <target state="translated">对于版本（2），参数数量必须与宏定义中的参数数量相同。对于版本（3,4），自变量的数量必须大于（直到C ++ 20）至少等于（自C ++ 20起）参数数量（不包括 &lt;code&gt;...&lt;/code&gt; ）。否则，程序格式不正确。如果标识符不在功能标记中，即在其后没有括号，则根本不会替换它。</target>
        </trans-unit>
        <trans-unit id="1eb818e764a2afb52d153586d87b0ff7106e9cc9" translate="yes" xml:space="preserve">
          <source>For versions (3,4), replacement-list may contain the token sequence &lt;code&gt;__VA_OPT__ (&lt;/code&gt;content&lt;code&gt;)&lt;/code&gt;, which is replaced by content if &lt;code&gt;__VA_ARGS__&lt;/code&gt; is non-empty, and expands to nothing otherwise.</source>
          <target state="translated">对于版本（3,4），替换列表可能包含令牌序列 &lt;code&gt;__VA_OPT__ (&lt;/code&gt; content &lt;code&gt;)&lt;/code&gt; ，如果 &lt;code&gt;__VA_ARGS__&lt;/code&gt; 为非空，则替换为content ，否则扩展为空。</target>
        </trans-unit>
        <trans-unit id="689abf1f4ab72838db75e84748d7996dea17600f" translate="yes" xml:space="preserve">
          <source>For virtual calls (if the bases are initialized), the same rules apply as the rules for the virtual calls from constructors and destructors: virtual member functions behave as if the dynamic type of &lt;code&gt;*this&lt;/code&gt; is the class that's being constructed (dynamic dispatch does not propagate down the inheritance hierarchy) and virtual calls (but not static calls) to &lt;a href=&quot;abstract_class&quot;&gt;pure virtual&lt;/a&gt; member functions are undefined behavior.</source>
          <target state="translated">对于虚拟调用（如果已初始化基数），则应用与从构造函数和析构函数进行虚拟调用的规则相同的规则：虚拟成员函数的行为就像 &lt;code&gt;*this&lt;/code&gt; 是正在构造的类的动态类型（动态分派不会向下传播继承层次结构），并且对&lt;a href=&quot;abstract_class&quot;&gt;纯虚拟&lt;/a&gt;成员函数的虚拟调用（而非静态调用）是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="0c5f085443078183be6555b610a3066515f2b25f" translate="yes" xml:space="preserve">
          <source>For zero-sized arrays,</source>
          <target state="translated">对于零大小的数组。</target>
        </trans-unit>
        <trans-unit id="0a460a0808dc0afa3b1cab6d45b0c32f450b8082" translate="yes" xml:space="preserve">
          <source>Forcing a copy assignment operator to be generated by the compiler.</source>
          <target state="translated">强制由编译器生成复制赋值运算符。</target>
        </trans-unit>
        <trans-unit id="11ad1e8557a20546e9537fc0a5b3a329b83d8d13" translate="yes" xml:space="preserve">
          <source>Forcing a copy constructor to be generated by the compiler.</source>
          <target state="translated">强制编译器生成一个复制构造函数。</target>
        </trans-unit>
        <trans-unit id="dd180500aac427aa2facdbe0b7cd406cce37ac98" translate="yes" xml:space="preserve">
          <source>Forcing a move assignment operator to be generated by the compiler.</source>
          <target state="translated">强制由编译器生成移动赋值运算符。</target>
        </trans-unit>
        <trans-unit id="b5ea5bcf5fc337ca9689a82c3a3c7580484f1408" translate="yes" xml:space="preserve">
          <source>Forcing a move constructor to be generated by the compiler.</source>
          <target state="translated">强制由编译器生成移动构造函数。</target>
        </trans-unit>
        <trans-unit id="72ef49edf9ca8e31454f8e3e5987fc43ac16422c" translate="yes" xml:space="preserve">
          <source>Form (3) is a special case of elaborated type specifier, usually referred to as</source>
          <target state="translated">形式(3)是详细类型指定器的一种特殊情况,通常称为</target>
        </trans-unit>
        <trans-unit id="3851c6a3b646b09f934a18b67d308cc11979b8c6" translate="yes" xml:space="preserve">
          <source>Formal definition of</source>
          <target state="translated">正式定义</target>
        </trans-unit>
        <trans-unit id="617d00cd751356da85b2e1f1f2eca6aa12a756a0" translate="yes" xml:space="preserve">
          <source>Formal description</source>
          <target state="translated">正式说明</target>
        </trans-unit>
        <trans-unit id="3bfb55cdc85542de2eeac7c01ac22e44b5143662" translate="yes" xml:space="preserve">
          <source>Formally,</source>
          <target state="translated">Formally,</target>
        </trans-unit>
        <trans-unit id="be2c3615928f7aa5bc5a7d980eb4d06a17642a73" translate="yes" xml:space="preserve">
          <source>Formally, &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; is satisfied only if, given any lvalue &lt;code&gt;t&lt;/code&gt; of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and any lvalue &lt;code&gt;u&lt;/code&gt; of type &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;, and let &lt;code&gt;C&lt;/code&gt; be &lt;code&gt;&lt;a href=&quot;../types/common_reference&quot;&gt;std::common_reference_t&lt;/a&gt;&amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;amp;, const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;&amp;gt;&lt;/code&gt; :</source>
          <target state="translated">形式上，仅在给定 &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &lt;a href=&quot;../types/remove_reference&quot;&gt;std :: remove_reference_t&lt;/a&gt; &amp;lt;T&amp;gt;类型的任何左值 &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; &lt;a href=&quot;../types/remove_reference&quot;&gt;std :: remove_reference_t&lt;/a&gt; &amp;lt;U&amp;gt;类型的任何左值 &lt;code&gt;u&lt;/code&gt; 且让 &lt;code&gt;C&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../types/common_reference&quot;&gt;std::common_reference_t&lt;/a&gt;&amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;amp;, const &lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;amp;&amp;gt;&lt;/code&gt; 情况下，才满足 &lt;code&gt;StrictTotallyOrderedWith&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;lt;const &lt;a href=&quot;../types/remove_reference&quot;&gt;std :: remove_reference_t&lt;/a&gt; &amp;lt;T&amp;gt;＆，const &lt;a href=&quot;../types/remove_reference&quot;&gt;std :: remove_reference_t&lt;/a&gt; &amp;lt;U&amp;gt;＆&amp;gt;：</target>
        </trans-unit>
        <trans-unit id="ac3a456d751219d7a66e0d0371e02798d8d5d3ea" translate="yes" xml:space="preserve">
          <source>Formally, a substring &lt;code&gt;str&lt;/code&gt; is said to be</source>
          <target state="translated">形式上，子字符串 &lt;code&gt;str&lt;/code&gt; 据说是</target>
        </trans-unit>
        <trans-unit id="8819ae53d6eeeb966d61dd310165099d50cdc3e7" translate="yes" xml:space="preserve">
          <source>Formally, a template template-parameter &lt;code&gt;P&lt;/code&gt; is at least as specialized as a template template argument &lt;code&gt;A&lt;/code&gt; if, given the following rewrite to two function templates, the function template corresponding to &lt;code&gt;P&lt;/code&gt; is at least as specialized as the function template corresponding to &lt;code&gt;A&lt;/code&gt; according to the partial ordering rules for &lt;a href=&quot;function_template&quot;&gt;function templates&lt;/a&gt;. Given an invented class template &lt;code&gt;X &lt;/code&gt; with the template parameter list of &lt;code&gt;A&lt;/code&gt; (including default arguments):</source>
          <target state="translated">形式上，如果模板，模板参数 &lt;code&gt;P&lt;/code&gt; 至少与模板模板参数 &lt;code&gt;A&lt;/code&gt; 一样专门，如果在以下重写两个函数模板的情况下，与 &lt;code&gt;P&lt;/code&gt; 对应的功能模板至少与与 &lt;code&gt;A&lt;/code&gt; 对应的功能模板一样专业，则根据&lt;a href=&quot;function_template&quot;&gt;功能模板&lt;/a&gt;的部分排序规则。给定一个具有 &lt;code&gt;A&lt;/code&gt; 的模板参数列表（包括默认参数）的发明的类模板 &lt;code&gt;X &lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="117e56a1f0fa17b3f88e2093765a4fbfc78944a1" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of &lt;code&gt;init, *j...&lt;/code&gt; for every &lt;code&gt;j&lt;/code&gt; in [first, first + (i - d_first)) over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">正式地，通过[d_first，d_first +（last-first））中的每个迭代器 &lt;code&gt;i&lt;/code&gt; ，为[first，first +（i-d_first））中的每个 &lt;code&gt;j&lt;/code&gt; 分配 &lt;code&gt;init, *j...&lt;/code&gt; 的广义非交换和的值* j...。 &lt;code&gt;binary_op&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="67dce949f95f6583a76648b394095c1ec1ca39c5" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of the generalized noncommutative sum of &lt;code&gt;init, unary_op(*j)...&lt;/code&gt; for every &lt;code&gt;j&lt;/code&gt; in [first, first + (i - d_first)) over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">正式地，通过[d_first，d_first +（last-first））中的每个迭代器 &lt;code&gt;i&lt;/code&gt; ，为[first，first +（i-d_first &lt;code&gt;init, unary_op(*j)...&lt;/code&gt; 中的每个 &lt;code&gt;j&lt;/code&gt; 分配init的广义非交换和的值unary_op（* j）...））在 &lt;code&gt;binary_op&lt;/code&gt; 上，</target>
        </trans-unit>
        <trans-unit id="95a3ed38da232217c4f6f08f54e48cb7d257ddec" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of.</source>
          <target state="translated">正式地，通过[d_first，d_first +（last-first））中的每个迭代器 &lt;code&gt;i&lt;/code&gt; 赋值。</target>
        </trans-unit>
        <trans-unit id="42355d6a7c2d7676346a2158f0e06426adf8925e" translate="yes" xml:space="preserve">
          <source>Formally, assigns through each iterator &lt;code&gt;i&lt;/code&gt; in [d_first, d_first + (last - first)) the value of:</source>
          <target state="translated">正式地，通过[d_first，d_first +（last-first））中的每个迭代器 &lt;code&gt;i&lt;/code&gt; 分配以下值：</target>
        </trans-unit>
        <trans-unit id="aa803427d4e1d44c6149f49a34143aabb8a952e0" translate="yes" xml:space="preserve">
          <source>Formally, for each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, count)&lt;/code&gt;, performs &lt;code&gt;assign(src[i], dest[i])&lt;/code&gt;.</source>
          <target state="translated">形式上，对于每个 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;[0, count)&lt;/code&gt; ，执行 &lt;code&gt;assign(src[i], dest[i])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="554c2426b4e5c1f78a13a29231a721f516bd1cbf" translate="yes" xml:space="preserve">
          <source>Formally, given an expression &lt;code&gt;E&lt;/code&gt; such that &lt;code&gt;decltype((E))&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; and an lvalue &lt;code&gt;t&lt;/code&gt; that denotes the same object as &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; models &lt;code&gt;__ForwardingRange&lt;/code&gt; only if.</source>
          <target state="translated">形式上，给定一个表达式 &lt;code&gt;E&lt;/code&gt; ，使得 &lt;code&gt;decltype((E))&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; 且一个左值 &lt;code&gt;t&lt;/code&gt; 表示与 &lt;code&gt;E&lt;/code&gt; 相同的对象，仅当 &lt;code&gt;T&lt;/code&gt; 建模 &lt;code&gt;__ForwardingRange&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f43c3db9c814c3ddff2a854cf059e58f985b2721" translate="yes" xml:space="preserve">
          <source>Formally, given an expression &lt;code&gt;E&lt;/code&gt; such that &lt;code&gt;decltype((E))&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; models &lt;code&gt;&lt;a href=&quot;../range/range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; only if.</source>
          <target state="translated">形式上，给定表达式 &lt;code&gt;E&lt;/code&gt; 使得 &lt;code&gt;decltype((E))&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; ，则 &lt;code&gt;T&lt;/code&gt; 仅在以下情况下对 &lt;code&gt;&lt;a href=&quot;../range/range&quot;&gt;Range&lt;/a&gt;&lt;/code&gt; 建模。</target>
        </trans-unit>
        <trans-unit id="067b1a2613c21e1fd48648c5caa1394000d7f227" translate="yes" xml:space="preserve">
          <source>Formally, given.</source>
          <target state="translated">形式上,鉴于。</target>
        </trans-unit>
        <trans-unit id="b90f213e247d65d8f658b379e51068d2511abb68" translate="yes" xml:space="preserve">
          <source>Formally, if &lt;code&gt;E&lt;/code&gt; and &lt;code&gt;F&lt;/code&gt; are expressions, and &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype((E))&amp;gt;&lt;/code&gt;, then.</source>
          <target state="translated">形式上，如果 &lt;code&gt;E&lt;/code&gt; 和 &lt;code&gt;F&lt;/code&gt; 是表达式，并且 &lt;code&gt;T&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;decltype((E))&amp;gt;&lt;/code&gt; ，则。</target>
        </trans-unit>
        <trans-unit id="67f89cac3a2bdd1a32a9d4e925980ecdcd1ff780" translate="yes" xml:space="preserve">
          <source>Formally, returns a value &lt;code&gt;e&lt;/code&gt; such that &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all values &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">形式上，返回一个值 &lt;code&gt;e&lt;/code&gt; ，对于所有值 &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;X::eq_int_type(e, X::to_int_type(c))&lt;/code&gt; 均为 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ba8bfc3113f8f3e8c405a965d6f37d86be2d7991" translate="yes" xml:space="preserve">
          <source>Formally, returns the value &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;X::eq_int_type(c, X::to_int_type(x))&lt;/code&gt; is true, and an unspecified value if no such &lt;code&gt;x&lt;/code&gt; exists.</source>
          <target state="translated">形式上，返回值 &lt;code&gt;x&lt;/code&gt; ，以使 &lt;code&gt;X::eq_int_type(c, X::to_int_type(x))&lt;/code&gt; 为true；如果不存在 &lt;code&gt;x&lt;/code&gt; ，则返回一个未指定的值。</target>
        </trans-unit>
        <trans-unit id="52d033134dacb8018588f4302d9453d80ec19597" translate="yes" xml:space="preserve">
          <source>Formally, the</source>
          <target state="translated">在形式上,</target>
        </trans-unit>
        <trans-unit id="52e0a6f1e0d63a4dd3bc991539c544e18482cfab" translate="yes" xml:space="preserve">
          <source>Formally, the C++ standard makes no guarantee on the accuracy of floating-point operations.</source>
          <target state="translated">从形式上看,C++标准不保证浮点运算的准确性。</target>
        </trans-unit>
        <trans-unit id="95a4b2acf26b1c49aea8abebe466f09b5002e38b" translate="yes" xml:space="preserve">
          <source>Formally, the syntax is.</source>
          <target state="translated">形式上,语法是:</target>
        </trans-unit>
        <trans-unit id="3e6350defe07d4e2839cc6eb5191b1da5190bee4" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the integral part of log</source>
          <target state="translated">从形式上看,无偏指数是对数的积分部分。</target>
        </trans-unit>
        <trans-unit id="91dd56eddc735a099ddc37f2c2b8d705630baadf" translate="yes" xml:space="preserve">
          <source>Formally, the unbiased exponent is the signed integral part of log</source>
          <target state="translated">形式上,无偏指数是对数的有符号积分部分</target>
        </trans-unit>
        <trans-unit id="8179a0c7fe36d2a8a17e5adad38978ddb099049d" translate="yes" xml:space="preserve">
          <source>Formally, to determine which of any two function templates is more specialized, the partial ordering process first transforms one of the two templates as follows:</source>
          <target state="translated">从形式上看,为了确定任意两个函数模板中哪一个更专业,部分排序过程首先将两个模板中的一个进行如下变换。</target>
        </trans-unit>
        <trans-unit id="3636bbcd81222a968d5588186dbdf6c4b0b042e0" translate="yes" xml:space="preserve">
          <source>Formally, to establish more-specialized-than relationship between partial specializations, each is first converted to a fictitious function template as follows:</source>
          <target state="translated">从形式上看,为了建立部分特殊化之间的多专一关系,首先将每个特殊化转换为一个虚构的函数模板,如下所示。</target>
        </trans-unit>
        <trans-unit id="f2967eb9e0cfcedd6a189b6a8d3866a634ebbc35" translate="yes" xml:space="preserve">
          <source>Formally.</source>
          <target state="translated">Formally.</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="9d6e5b21d4a23bd5ccd62830a8a750d8fe1ca459" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; 系列函数的格式常量</target>
        </trans-unit>
        <trans-unit id="2baad9ad4884ebddda05c6c67af479131ae29e6b" translate="yes" xml:space="preserve">
          <source>Format constants for the &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; family of functions</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; 系列函数的格式常量</target>
        </trans-unit>
        <trans-unit id="6b8afd05c64332502d3616cc67779e98de2c7168" translate="yes" xml:space="preserve">
          <source>Format conversions</source>
          <target state="translated">格式转换</target>
        </trans-unit>
        <trans-unit id="7175d023e27abe317865a491022a09c5f080a380" translate="yes" xml:space="preserve">
          <source>Format macro constants</source>
          <target state="translated">格式化宏常数</target>
        </trans-unit>
        <trans-unit id="9316b4e7eba6949a72f828ee21024df921672e3c" translate="yes" xml:space="preserve">
          <source>Format observers</source>
          <target state="translated">格式观察员</target>
        </trans-unit>
        <trans-unit id="f544ee1a7acc5ea325b43ab1bc03f12126274ad5" translate="yes" xml:space="preserve">
          <source>Format string</source>
          <target state="translated">格式字符串</target>
        </trans-unit>
        <trans-unit id="c4bb81b6ba2e3eacfc477a97d7def7d80d2c55be" translate="yes" xml:space="preserve">
          <source>Formats monetary value and writes the result to output stream.</source>
          <target state="translated">格式化货币价值并将结果写入输出流。</target>
        </trans-unit>
        <trans-unit id="7c20d6ad01a878bb9e8639e10169a49131276aca" translate="yes" xml:space="preserve">
          <source>Formats the streamable object &lt;code&gt;s&lt;/code&gt; using the format string &lt;code&gt;fmt&lt;/code&gt; and the locale &lt;code&gt;loc&lt;/code&gt; (if provided).</source>
          <target state="translated">格式化可流传送的对象 &lt;code&gt;s&lt;/code&gt; 使用格式串 &lt;code&gt;fmt&lt;/code&gt; 和区域设置 &lt;code&gt;loc&lt;/code&gt; （如果提供的话）。</target>
        </trans-unit>
        <trans-unit id="8bf1052f7f8c855373309b9742ea3d34a8c56846" translate="yes" xml:space="preserve">
          <source>Formatted input</source>
          <target state="translated">格式化输入</target>
        </trans-unit>
        <trans-unit id="ee59b03a5ff5c727bd5ce0a27fd2bc91e970bc1f" translate="yes" xml:space="preserve">
          <source>Formatted input/output</source>
          <target state="translated">格式化的输入/输出</target>
        </trans-unit>
        <trans-unit id="c7cf7a590d478b0b7b99c49e642af36f47cd56e2" translate="yes" xml:space="preserve">
          <source>Formatted output</source>
          <target state="translated">格式化输出</target>
        </trans-unit>
        <trans-unit id="722101e27f69cbe90326b9ee974bad21c5f7f772" translate="yes" xml:space="preserve">
          <source>Formatted output functions &lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../manip/put_time&quot;&gt;std::put_time&lt;/a&gt;&lt;/code&gt;, if they encounter the end of the output stream before completing output.</source>
          <target state="translated">格式化的输出函数&lt;a href=&quot;../basic_ostream/operator_ltlt&quot;&gt;operator &amp;lt;&amp;lt;&lt;/a&gt;， &lt;code&gt;&lt;a href=&quot;../manip/put_money&quot;&gt;std::put_money&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../manip/put_time&quot;&gt;std::put_time&lt;/a&gt;&lt;/code&gt; ，如果它们在完成输出之前遇到输出流的末尾。</target>
        </trans-unit>
        <trans-unit id="c36735a1b156faf0d8948786e00b3f1ee63bfe64" translate="yes" xml:space="preserve">
          <source>FormattedInputFunction</source>
          <target state="translated">FormattedInputFunction</target>
        </trans-unit>
        <trans-unit id="8ad283919e38bfa7958b6669077f83561656b04b" translate="yes" xml:space="preserve">
          <source>FormattedOutputFunction</source>
          <target state="translated">FormattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="841f832857c780b47f478b4f21d34d8995af64b8" translate="yes" xml:space="preserve">
          <source>Formatting</source>
          <target state="translated">Formatting</target>
        </trans-unit>
        <trans-unit id="4f6565ce2772bffe98b3ba5983af96ce7e5de363" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; literal representing an imaginary number.</source>
          <target state="translated">形成一个代表虚数的 &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="643fc7954cfd8223ed9cf2e31d62065c242ec93d" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing hours.</source>
          <target state="translated">形成一个代表小时的 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="331255970e3e48a89f2154f44ef024e28fb6bd1c" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing microseconds.</source>
          <target state="translated">形成一个代表微秒的 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="8c586fe6bccfd167b2ec9b0341a50e0e2e23b2bd" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing milliseconds.</source>
          <target state="translated">形成一个代表毫秒的 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="aabdc8e30aa11c549d953403622d6b09da7416a8" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing minutes.</source>
          <target state="translated">形成一个代表分钟的 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="b2b858860ebb5672d0b628f2489cbedb92290864" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing nanoseconds.</source>
          <target state="translated">形成一个代表纳秒的 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="d804e0c1b4cad0bfbb3de1fe4b5fa00aa0254978" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; literal representing seconds.</source>
          <target state="translated">形成一个代表秒的 &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; 文字。</target>
        </trans-unit>
        <trans-unit id="1f2764e36e954fe7d39b543d927e58cc08e2ae3b" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the day value stored in &lt;code&gt;d&lt;/code&gt; formatted as a decimal number, with a leading zero if the result would otherwise be a single decimal digit. Inserts that string into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!d.ok()&lt;/code&gt;, inserts the string &lt;code&gt;&quot; is not a valid day&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">形成 &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 由存储在一天值 &lt;code&gt;d&lt;/code&gt; 格式化为一个十进制数，带前导零如果结果本来是单个十进制数字。将该字符串插入 &lt;code&gt;os&lt;/code&gt; 。然后，如果 &lt;code&gt;!d.ok()&lt;/code&gt; ，则将字符串 &lt;code&gt;&quot; is not a valid day&quot;&lt;/code&gt; 插入 &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38eae2fb3ad7f9bb81e8d518abb33df758dc07a9" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt;&lt;code&gt;s&lt;/code&gt; consisting of the year value stored in &lt;code&gt;y&lt;/code&gt; formatted as a decimal number, left-padded with &lt;code&gt;0&lt;/code&gt; to four digits if the result would otherwise be less than four digits. Inserts that string into &lt;code&gt;os&lt;/code&gt;. Then, if &lt;code&gt;!y.ok()&lt;/code&gt;, inserts the string &lt;code&gt;&quot; is not a valid year&quot;&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">形成 &lt;code&gt;std::basic_string&amp;lt;CharT&amp;gt;&lt;/code&gt; &lt;code&gt;s&lt;/code&gt; 由存储在年值的 &lt;code&gt;y&lt;/code&gt; 格式化为一个十进制数，左侧填充 &lt;code&gt;0&lt;/code&gt; 到四位如果结果否则将是少于四个数字。将该字符串插入 &lt;code&gt;os&lt;/code&gt; 。然后，如果 &lt;code&gt;!y.ok()&lt;/code&gt; ，则将字符串 &lt;code&gt;&quot; is not a valid year&quot;&lt;/code&gt; 插入 &lt;code&gt;os&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0d5578517ed64bd2435fafaf294658c0cb1801f2" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::chrono::day&lt;/code&gt; literal representing a day of the month in the calendar.</source>
          <target state="translated">形成一个 &lt;code&gt;std::chrono::day&lt;/code&gt; 文字，表示日历中每月的某一天。</target>
        </trans-unit>
        <trans-unit id="07aea1146bfbc451baff20e77016224dc3f5174b" translate="yes" xml:space="preserve">
          <source>Forms a &lt;code&gt;std::chrono::year&lt;/code&gt; literal representing a year in the proleptic Gregorian calendar.</source>
          <target state="translated">形成一个 &lt;code&gt;std::chrono::year&lt;/code&gt; 文字，表示在公历中的一年。</target>
        </trans-unit>
        <trans-unit id="820c807c48f38eb8ca42664fa731c03b51c0dc19" translate="yes" xml:space="preserve">
          <source>Forms a string literal of the desired type.</source>
          <target state="translated">形成一个所需类型的字符串文字。</target>
        </trans-unit>
        <trans-unit id="985e41dbd82d997c605a0a512d9497c566128eb1" translate="yes" xml:space="preserve">
          <source>Forms a string view of a character literal.</source>
          <target state="translated">形成一个字符文字的字符串视图。</target>
        </trans-unit>
        <trans-unit id="70ef5d692d3abeefce2c77380edc61da30bbd98d" translate="yes" xml:space="preserve">
          <source>Forms can be nested and processed recursively: &lt;code&gt;X&amp;lt;int&amp;gt;(*)(char[6])&lt;/code&gt; is an example of &lt;code&gt;type(*)(T)&lt;/code&gt;, where</source>
          <target state="translated">表单可以嵌套和递归处理： &lt;code&gt;X&amp;lt;int&amp;gt;(*)(char[6])&lt;/code&gt; 是 &lt;code&gt;type(*)(T)&lt;/code&gt; 的示例，其中</target>
        </trans-unit>
        <trans-unit id="96d68418cb661c4b3699c2e8d5be8b57b843889b" translate="yes" xml:space="preserve">
          <source>Forms the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot;&gt;logical conjunction&lt;/a&gt; of the type traits &lt;code&gt;B...&lt;/code&gt;, effectively performing a logical AND on the sequence of traits.</source>
          <target state="translated">形成特征类型 &lt;code&gt;B...&lt;/code&gt; 的&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_conjunction&quot;&gt;逻辑合取&lt;/a&gt;，对特征序列有效执行逻辑与。</target>
        </trans-unit>
        <trans-unit id="abc06d4ed5fe67746f60bf85f949f812a573392b" translate="yes" xml:space="preserve">
          <source>Forms the &lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_disjunction&quot;&gt;logical disjunction&lt;/a&gt; of the type traits &lt;code&gt;B...&lt;/code&gt;, effectively performing a logical OR on the sequence of traits.</source>
          <target state="translated">形成类型特征 &lt;code&gt;B...&lt;/code&gt; 的&lt;a href=&quot;https://en.wikipedia.org/wiki/Logical_disjunction&quot;&gt;逻辑分离&lt;/a&gt;，有效地对特征序列执行逻辑或。</target>
        </trans-unit>
        <trans-unit id="bb06b9b7e348bda3d1bd2e01e574d860866f1b4f" translate="yes" xml:space="preserve">
          <source>Forms the logical negation of the type trait &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">形成类型特征 &lt;code&gt;B&lt;/code&gt; 的逻辑否定。</target>
        </trans-unit>
        <trans-unit id="82ea89ab75987595e45620e5e795108b1b6e0406" translate="yes" xml:space="preserve">
          <source>Forward declaration</source>
          <target state="translated">远期声明</target>
        </trans-unit>
        <trans-unit id="69f690f33d986c3349097e854e0eb9e08b5cc4f9" translate="yes" xml:space="preserve">
          <source>Forward declarations</source>
          <target state="translated">远期声明</target>
        </trans-unit>
        <trans-unit id="a0a5ca500e9440c8915b30c97f259cacfbb1a922" translate="yes" xml:space="preserve">
          <source>Forward iterator to the new end of the range.</source>
          <target state="translated">向前迭代到范围的新末端。</target>
        </trans-unit>
        <trans-unit id="55728db9a1113137c393ce6ac1e01d0996797010" translate="yes" xml:space="preserve">
          <source>Forward progress</source>
          <target state="translated">前期进展</target>
        </trans-unit>
        <trans-unit id="ad2924cf16dd4b5c687b5dd4c3d38f7f20d99988" translate="yes" xml:space="preserve">
          <source>ForwardIterator</source>
          <target state="translated">ForwardIterator</target>
        </trans-unit>
        <trans-unit id="967415c810ff974308b7e163c5a8b2ee4963dfdf" translate="yes" xml:space="preserve">
          <source>ForwardRange</source>
          <target state="translated">ForwardRange</target>
        </trans-unit>
        <trans-unit id="02f29ee395fe54e14061ef2943f36bed0af18091" translate="yes" xml:space="preserve">
          <source>Forwarding references</source>
          <target state="translated">转发参考资料</target>
        </trans-unit>
        <trans-unit id="9cc6112b2b655f82745fcb59748e093ab1fe8817" translate="yes" xml:space="preserve">
          <source>Forwarding references are a special kind of references that preserve the value category of a function argument, making it possible to</source>
          <target state="translated">转发引用是一种特殊的引用,它保留了一个函数参数的值类别,使得它能够</target>
        </trans-unit>
        <trans-unit id="2d1b43ed1d5df75c8cdb7fbed98fd0e15496fb8b" translate="yes" xml:space="preserve">
          <source>Four specializations are provided by the standard library.</source>
          <target state="translated">标准库提供了四个专业。</target>
        </trans-unit>
        <trans-unit id="646942bdd43335fac5c5cb8c90a98c4a1571691d" translate="yes" xml:space="preserve">
          <source>Four standalone (locale-independent) specializations are provided by the standard library:</source>
          <target state="translated">标准库提供了四个独立的(独立于本地的)专门化。</target>
        </trans-unit>
        <trans-unit id="6eb9522d427a2669dd67835d7011efde7feafc8c" translate="yes" xml:space="preserve">
          <source>Fourth version</source>
          <target state="translated">第四版</target>
        </trans-unit>
        <trans-unit id="67c664a3c5100ef6f1199beaf5c8ee1e3784d4ea" translate="yes" xml:space="preserve">
          <source>Free raw memory obtained from allocate_bytes</source>
          <target state="translated">释放从 allocate_bytes 获得的原始内存</target>
        </trans-unit>
        <trans-unit id="66c8be8d1a5492d1eb9655f15bf0380194107efe" translate="yes" xml:space="preserve">
          <source>Frees raw memory obtained by allocate_object</source>
          <target state="translated">释放通过 allocate_object 获得的原始内存。</target>
        </trans-unit>
        <trans-unit id="2715bc5b3d7345dfa8bf763d473dced4c5997198" translate="yes" xml:space="preserve">
          <source>Freestanding and hosted implementations</source>
          <target state="translated">独立和托管实施</target>
        </trans-unit>
        <trans-unit id="755e9516e294b0231da60ee53dcb1cf6956a6f7f" translate="yes" xml:space="preserve">
          <source>Friend declarations cannot refer to partial specializations, but can refer to full specializations:</source>
          <target state="translated">朋友声明不能指部分特化,但可以指完全特化。</target>
        </trans-unit>
        <trans-unit id="78f907cdd8f4e2ead952047583a3ce2951b50c9e" translate="yes" xml:space="preserve">
          <source>Friend function declaration</source>
          <target state="translated">朋友函数声明</target>
        </trans-unit>
        <trans-unit id="74ed844100eed25ad0c1bd3b12ca6cc5919b4157" translate="yes" xml:space="preserve">
          <source>Friend function definition</source>
          <target state="translated">朋友功能定义</target>
        </trans-unit>
        <trans-unit id="cc53f78835350ac24156d967e62ee0b5c8a5687b" translate="yes" xml:space="preserve">
          <source>Friendship is not inherited (your friend's children are not your friends).</source>
          <target state="translated">友谊是不会遗传的(你朋友的孩子不是你的朋友)。</target>
        </trans-unit>
        <trans-unit id="8c8cea4fdc1598ec00b1de75a422605f0af14cee" translate="yes" xml:space="preserve">
          <source>Friendship is not transitive (a friend of your friend is not your friend).</source>
          <target state="translated">友谊不是转折性的(你朋友的朋友不是你的朋友)。</target>
        </trans-unit>
        <trans-unit id="e8b58840737fe83d2eef7b8580aadc5bae0ab4f5" translate="yes" xml:space="preserve">
          <source>Full names</source>
          <target state="translated">全名</target>
        </trans-unit>
        <trans-unit id="0ca544d7457648c14cce40272868cda27ebf4451" translate="yes" xml:space="preserve">
          <source>Function Objects</source>
          <target state="translated">功能对象</target>
        </trans-unit>
        <trans-unit id="f7f0e1bdfa2f3add115b52939d15e6fd3460937e" translate="yes" xml:space="preserve">
          <source>Function adaptors</source>
          <target state="translated">功能适配器</target>
        </trans-unit>
        <trans-unit id="8231e66ed9c1c9e042523416e1ad72237c2d2874" translate="yes" xml:space="preserve">
          <source>Function argument lists</source>
          <target state="translated">函数参数列表</target>
        </trans-unit>
        <trans-unit id="5bfbcebae9458d0af9e37589048c8edd93acdcad" translate="yes" xml:space="preserve">
          <source>Function body</source>
          <target state="translated">职能机构</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">函数调用</target>
        </trans-unit>
        <trans-unit id="61f764306c5b4c873805f4d7503e407f01f0da37" translate="yes" xml:space="preserve">
          <source>Function call expression is similar in syntax to value initialization &lt;code&gt;T()&lt;/code&gt;, to &lt;a href=&quot;explicit_cast&quot;&gt;function-style cast&lt;/a&gt; expression &lt;code&gt;T(A1)&lt;/code&gt;, and to direct initialization of a temporary &lt;code&gt;T(A1, A2, A3, ...)&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the name of a type.</source>
          <target state="translated">函数调用表达式的语法类似于值初始化 &lt;code&gt;T()&lt;/code&gt; ，&lt;a href=&quot;explicit_cast&quot;&gt;函数样式转换&lt;/a&gt;表达式 &lt;code&gt;T(A1)&lt;/code&gt; 以及直接初始化临时 &lt;code&gt;T(A1, A2, A3, ...)&lt;/code&gt; ，其中 &lt;code&gt;T&lt;/code&gt; 是名称类型的。</target>
        </trans-unit>
        <trans-unit id="55cb199824723ac48f856b32fde1674eff49a87b" translate="yes" xml:space="preserve">
          <source>Function call expressions returning &lt;code&gt;void&lt;/code&gt;, cast expressions to &lt;code&gt;void&lt;/code&gt;, and &lt;a href=&quot;throw&quot;&gt;throw-expressions&lt;/a&gt; are classified as prvalue expressions, but they cannot be used to initialize references or as function arguments. They can be used in discarded-value contexts (e.g. on a line of its own, as the left-hand operand of the comma operator, etc.) and in the &lt;code&gt;return&lt;/code&gt; statement in a function returning &lt;code&gt;void&lt;/code&gt;. In addition, throw-expressions may be used as the second and the third operands of the &lt;a href=&quot;operator_other&quot;&gt;conditional operator ?:&lt;/a&gt;.</source>
          <target state="translated">函数调用表达式返回 &lt;code&gt;void&lt;/code&gt; ，投表达式 &lt;code&gt;void&lt;/code&gt; ，并&lt;a href=&quot;throw&quot;&gt;抛出表达式&lt;/a&gt;被列为prvalue表达式，但它们不能被用来初始化引用或函数参数。它们可以在舍弃值上下文中使用（例如，在其自身的一行上，作为逗号运算符的左侧操作数等），以及在返回 &lt;code&gt;void&lt;/code&gt; 的函数的 &lt;code&gt;return&lt;/code&gt; 语句中使用。另外，throw-expressions可以用作&lt;a href=&quot;operator_other&quot;&gt;条件运算符？：&lt;/a&gt;的第二和第三操作数。</target>
        </trans-unit>
        <trans-unit id="25056cd4f19ab3cf2ddbe426ca4f88659c9ecb1f" translate="yes" xml:space="preserve">
          <source>Function call operator</source>
          <target state="translated">函数调用操作员</target>
        </trans-unit>
        <trans-unit id="c89b9bb41c4c13c872e30f5eb0bb250a5c580801" translate="yes" xml:space="preserve">
          <source>Function declaration</source>
          <target state="translated">功能声明</target>
        </trans-unit>
        <trans-unit id="8d84dffd70068ddd1111084e3623daad3386117d" translate="yes" xml:space="preserve">
          <source>Function declarations may appear in any scope. A function declaration at class scope introduces a class member function (unless the friend specifier is used), see &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt; and &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt; for details.</source>
          <target state="translated">函数声明可以出现在任何范围内。类作用域中的函数声明引入了类成员函数（除非使用了friend指定符），有关详细信息，请参见&lt;a href=&quot;member_functions&quot;&gt;成员函数&lt;/a&gt;和&lt;a href=&quot;friend&quot;&gt;friend函数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="01a7dcd826dbbad15679402aaa257c1e8bee4fd2" translate="yes" xml:space="preserve">
          <source>Function declarators can be mixed with other declarators, where decl-specifier-seq allows:</source>
          <target state="translated">在 decl-specifier-seq 允许的情况下,函数声明符可以与其他声明符混合使用。</target>
        </trans-unit>
        <trans-unit id="b5f8af75bc5ad30466ed317152a310aba07e877e" translate="yes" xml:space="preserve">
          <source>Function definition</source>
          <target state="translated">功能定义</target>
        </trans-unit>
        <trans-unit id="8a31e049889b12e1b53d0e991bba8a50561e7a03" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;&lt;a href=&quot;iswspace&quot;&gt;std::iswspace&lt;/a&gt;()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">函数将丢弃所有空白字符（由 &lt;code&gt;&lt;a href=&quot;iswspace&quot;&gt;std::iswspace&lt;/a&gt;()&lt;/code&gt; 确定），直到找到第一个非空白字符为止。然后，需要使用尽可能多的字符来形成有效的浮点表示形式并将其转换为浮点值。有效的浮点值可以是以下之一：</target>
        </trans-unit>
        <trans-unit id="268b166a91a60d5f1a938de3418f1d3678105197" translate="yes" xml:space="preserve">
          <source>Function discards any whitespace characters (as determined by &lt;code&gt;std::isspace()&lt;/code&gt;) until first non-whitespace character is found. Then it takes as many characters as possible to form a valid floating-point representation and converts them to a floating-point value. The valid floating-point value can be one of the following:</source>
          <target state="translated">函数将丢弃所有空白字符（由 &lt;code&gt;std::isspace()&lt;/code&gt; 确定），直到找到第一个非空白字符为止。然后，需要使用尽可能多的字符来形成有效的浮点表示形式并将其转换为浮点值。有效的浮点值可以是以下之一：</target>
        </trans-unit>
        <trans-unit id="56d376c8d143e7051f331c1aba9bc9e6fccbf798" translate="yes" xml:space="preserve">
          <source>Function invocation</source>
          <target state="translated">函数调用</target>
        </trans-unit>
        <trans-unit id="ec031b84374532b3dd5e02a9109e50cae284b830" translate="yes" xml:space="preserve">
          <source>Function macros for integer constants</source>
          <target state="translated">整数常数的函数宏</target>
        </trans-unit>
        <trans-unit id="60be48a55b3f6bfe81f126777640e7116a702836" translate="yes" xml:space="preserve">
          <source>Function macros for minimum-width integer constants</source>
          <target state="translated">最小宽度整数常数的函数宏。</target>
        </trans-unit>
        <trans-unit id="bc8a59f44f5ba9847650733c0cafd473c4eed11f" translate="yes" xml:space="preserve">
          <source>Function not supported</source>
          <target state="translated">不支持该功能</target>
        </trans-unit>
        <trans-unit id="b248eacc8c468b679bd61ad8cb82d22de759fe43" translate="yes" xml:space="preserve">
          <source>Function object for computing remainders of divisions. Implements &lt;code&gt;operator%&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于计算除法余数的函数对象。为类型 &lt;code&gt;T&lt;/code&gt; 实现 &lt;code&gt;operator%&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a4633ecd37c7996641d9e6e60f41f4acaad220fb" translate="yes" xml:space="preserve">
          <source>Function object for performing addition. Effectively calls &lt;code&gt;operator+&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行加法的函数对象。在 &lt;code&gt;T&lt;/code&gt; 类型的两个实例上有效地调用 &lt;code&gt;operator+&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d149129b3c23a795999a21bc625bd934320c5a89" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise AND. Effectively calls &lt;code&gt;operator&amp;amp;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行按位与的函数对象。有效地在类型 &lt;code&gt;T&lt;/code&gt; 上调用 &lt;code&gt;operator&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b599fdda8a6eff8b08fa4dda5e4633fab0dbe0ce" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise NOT. Effectively calls &lt;code&gt;operator~&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行按位NOT的函数对象。有效地调用 &lt;code&gt;T&lt;/code&gt; 类型的 &lt;code&gt;operator~&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="313209366a119d00dc320937bfc0bbb8786800ec" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise OR. Effectively calls &lt;code&gt;operator|&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行按位或的功能对象。有效地致电 &lt;code&gt;operator|&lt;/code&gt; 在类型 &lt;code&gt;T&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="c5887d43f2e0df69b82fff43b54f846c4704fa46" translate="yes" xml:space="preserve">
          <source>Function object for performing bitwise XOR. Effectively calls &lt;code&gt;operator^&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行按位XOR的函数对象。有效地调用 &lt;code&gt;T&lt;/code&gt; 类型的 &lt;code&gt;operator^&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e180b41511a71768ffe2c960f01fb1039a41108e" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Deduces the parameter types of the function call operator from the arguments (but not the return type).</source>
          <target state="translated">用于执行比较的函数对象。从参数中扣除函数调用操作符的参数类型(但不扣除返回类型)。</target>
        </trans-unit>
        <trans-unit id="56f077a1110154764933177a4a8a45a67a0e117f" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialised, invokes &lt;code&gt;operator!=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行比较的功能对象。除非特别说明，否则在类型 &lt;code&gt;T&lt;/code&gt; 上调用 &lt;code&gt;operator!=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d8efff6ca90765aa3a8bc08e4dd6c03c3e58a69" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialised, invokes &lt;code&gt;operator==&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行比较的功能对象。除非特别说明，否则在类型 &lt;code&gt;T&lt;/code&gt; 上调用 &lt;code&gt;operator==&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60aea8fb12e1c43b673c06d961c8619b0f1469c4" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;gt;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行比较的功能对象。除非专门，否则在类型 &lt;code&gt;T&lt;/code&gt; 上调用 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="738acefb6a4d9540bfe0b153875600600ca1005f" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;gt;=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行比较的功能对象。除非专门，否则在类型 &lt;code&gt;T&lt;/code&gt; 上调用 &lt;code&gt;operator&amp;gt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ed4fd907e2e5e744c2b2efa9d9bc109fe8439c7" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;lt;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行比较的功能对象。除非专门，否则在类型 &lt;code&gt;T&lt;/code&gt; 上调用 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86238797ec5cdcf632292c3e4d25c647b5a4693a" translate="yes" xml:space="preserve">
          <source>Function object for performing comparisons. Unless specialized, invokes &lt;code&gt;operator&amp;lt;=&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行比较的功能对象。除非专门，否则在类型 &lt;code&gt;T&lt;/code&gt; 上调用 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fe5410430a56ab0ae8cbfda0c39393d3efaefd1" translate="yes" xml:space="preserve">
          <source>Function object for performing division. Effectively calls &lt;code&gt;operator/&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行除法的功能对象。在两个 &lt;code&gt;T&lt;/code&gt; 类型的实例上有效地调用 &lt;code&gt;operator/&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12de586434654aa1a14b6b2d8a259de90a34392f" translate="yes" xml:space="preserve">
          <source>Function object for performing logical AND (logical conjunction). Effectively calls &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行逻辑与（逻辑与）的功能对象。有效地在类型 &lt;code&gt;T&lt;/code&gt; 上调用 &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1490a0997baca27d81b16387b04a8b28fa19d7e6" translate="yes" xml:space="preserve">
          <source>Function object for performing logical NOT (logical negation). Effectively calls &lt;code&gt;operator!&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行逻辑NOT（逻辑求反）的功能对象。有效地打电话给 &lt;code&gt;operator!&lt;/code&gt; 对于 &lt;code&gt;T&lt;/code&gt; 型。</target>
        </trans-unit>
        <trans-unit id="26fc81b06029a179ee570f03e59c7d8106976333" translate="yes" xml:space="preserve">
          <source>Function object for performing logical OR (logical disjunction). Effectively calls &lt;code&gt;operator||&lt;/code&gt; on type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行逻辑OR（逻辑析取）的功能对象。有效地致电 &lt;code&gt;operator||&lt;/code&gt; 在类型 &lt;code&gt;T&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="863b97dec6e3bad00c70886e69a7afbb1c4e16fb" translate="yes" xml:space="preserve">
          <source>Function object for performing multiplication. Effectively calls &lt;code&gt;operator*&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行乘法的函数对象。在 &lt;code&gt;T&lt;/code&gt; 类型的两个实例上有效地调用 &lt;code&gt;operator*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a134daaeb15195627f59ee24f26ecba80c6eb4fc" translate="yes" xml:space="preserve">
          <source>Function object for performing negation. Effectively calls &lt;code&gt;operator-&lt;/code&gt; on an instance of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行求反的函数对象。在类型 &lt;code&gt;T&lt;/code&gt; 的实例上有效地调用 &lt;code&gt;operator-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6be85bc0166110c97cce13deef82fe7cce65ca9c" translate="yes" xml:space="preserve">
          <source>Function object for performing subtraction. Effectively calls &lt;code&gt;operator-&lt;/code&gt; on two instances of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">用于执行减法的功能对象。在两个类型 &lt;code&gt;T&lt;/code&gt; 的实例上有效地调用 &lt;code&gt;operator-&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05785bcc60d939df6f0a0f7578eb56a67e1b185f" translate="yes" xml:space="preserve">
          <source>Function objects</source>
          <target state="translated">功能对象</target>
        </trans-unit>
        <trans-unit id="b8f9cce63cec2dc22abc32a4cbf9907e736f87ee" translate="yes" xml:space="preserve">
          <source>Function objects, Function invocations, Bind operations and Reference wrappers</source>
          <target state="translated">函数对象、函数调用、绑定操作和引用包装器。</target>
        </trans-unit>
        <trans-unit id="474b3e14aec889f00fbd7fffa4899aaf67c18da3" translate="yes" xml:space="preserve">
          <source>Function overloads vs function specializations</source>
          <target state="translated">函数重载与函数特化</target>
        </trans-unit>
        <trans-unit id="05c625ce62f1567c6464e68f3d0c5ca596683e7c" translate="yes" xml:space="preserve">
          <source>Function parameter list</source>
          <target state="translated">功能参数表</target>
        </trans-unit>
        <trans-unit id="cacf242390ee182c0b5703d0e286b16458b2d6ac" translate="yes" xml:space="preserve">
          <source>Function parameter pack (a form of &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, appears in a function parameter list of a variadic function template).</source>
          <target state="translated">功能参数包（&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;符的一种形式，出现在可变参数模板的功能参数列表中）。</target>
        </trans-unit>
        <trans-unit id="ee2ed22b6c316767fa0eee64138df658812f8372" translate="yes" xml:space="preserve">
          <source>Function parameter scope</source>
          <target state="translated">功能参数范围</target>
        </trans-unit>
        <trans-unit id="16a39e4b6666353c50f59b56d3cce3eb5dbeca02" translate="yes" xml:space="preserve">
          <source>Function parameters are not allowed in default arguments (even if they are not evaluated)(until C++14) except if they are unevaluated(since C++14). Note that parameters that appear earlier in the parameter list are in &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;:</source>
          <target state="translated">除非默认值未赋值（自C ++ 14起），否则默认参数中不允许使用函数参数（即使未对其赋值）（直到C ++ 14）。请注意，出现在参数列表前面的参数在&lt;a href=&quot;scope&quot;&gt;作用域内&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c545df3352143fe60a307ebf941a3169f4b04ba9" translate="yes" xml:space="preserve">
          <source>Function pointer conversions</source>
          <target state="translated">函数指针转换</target>
        </trans-unit>
        <trans-unit id="14644346bcc70a878c3eb265226005a7304bec16" translate="yes" xml:space="preserve">
          <source>Function scope</source>
          <target state="translated">职能范围</target>
        </trans-unit>
        <trans-unit id="d879bbf1375b073db057a0370df0b5d2aaf75d77" translate="yes" xml:space="preserve">
          <source>Function template</source>
          <target state="translated">功能模板</target>
        </trans-unit>
        <trans-unit id="e8ac637a6e8fb2f46175ee490eb2eb83645238b8" translate="yes" xml:space="preserve">
          <source>Function template &lt;code&gt;std::mem_fn&lt;/code&gt; generates wrapper objects for pointers to members, which can store, copy, and invoke a pointer to member. Both references and pointers (including smart pointers) to an object can be used when invoking a &lt;code&gt;std::mem_fn&lt;/code&gt;.</source>
          <target state="translated">函数模板 &lt;code&gt;std::mem_fn&lt;/code&gt; 生成指向成员的指针的包装对象，该对象可以存储，复制和调用指向成员的指针。调用 &lt;code&gt;std::mem_fn&lt;/code&gt; 时，可以使用对象的引用和指针（包括智能指针）。</target>
        </trans-unit>
        <trans-unit id="ba1b466469de4bedf72f07dd5b3b51bc92ecf5e1" translate="yes" xml:space="preserve">
          <source>Function template instantiation</source>
          <target state="translated">函数模板实例化</target>
        </trans-unit>
        <trans-unit id="a76d53230697569d7c028ff1451f97505d469db4" translate="yes" xml:space="preserve">
          <source>Function template overloading</source>
          <target state="translated">函数模板重载</target>
        </trans-unit>
        <trans-unit id="86dd3fddcc75cfa4e063a703f32c8ede28f4c30d" translate="yes" xml:space="preserve">
          <source>Function template parameters are substituted (replaced by template arguments) twice:</source>
          <target state="translated">函数模板参数被替换(被模板参数替换)两次。</target>
        </trans-unit>
        <trans-unit id="6027571a098596d5e87183ff7d586ec483f03343" translate="yes" xml:space="preserve">
          <source>Function template specialization</source>
          <target state="translated">功能模板专业化</target>
        </trans-unit>
        <trans-unit id="c03fc20cda6df9ef92fd64413e95464c0412a4fc" translate="yes" xml:space="preserve">
          <source>Function templates &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;cref&lt;/code&gt; are helper functions that generate an object of type &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt;, using &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; to determine the template argument of the result.</source>
          <target state="translated">函数模板 &lt;code&gt;ref&lt;/code&gt; 和 &lt;code&gt;cref&lt;/code&gt; 是辅助函数，它们使用&lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;模板实&lt;/a&gt; &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; 推导确定结果的模板实参，生成类型为std :: reference_wrapper的对象。</target>
        </trans-unit>
        <trans-unit id="d90c99af4d1617c8e3520279788821d8d6072cea" translate="yes" xml:space="preserve">
          <source>Function templates and non-template functions may be overloaded.</source>
          <target state="translated">函数模板和非模板函数可能会过载。</target>
        </trans-unit>
        <trans-unit id="527a4bc836096e4223cdeb54a2dc838640d3aaaa" translate="yes" xml:space="preserve">
          <source>Function to pointer</source>
          <target state="translated">指针函数</target>
        </trans-unit>
        <trans-unit id="ccff159bf6b5506e0e1b9835119cc9060c666c2b" translate="yes" xml:space="preserve">
          <source>Function wrappers</source>
          <target state="translated">功能包装器</target>
        </trans-unit>
        <trans-unit id="2e3030f5a7f048cef8382d50828336e71bb753d2" translate="yes" xml:space="preserve">
          <source>Function-like macros</source>
          <target state="translated">功能类宏</target>
        </trans-unit>
        <trans-unit id="a542b043e775e7bb5b171b48eca68e3eaf37af10" translate="yes" xml:space="preserve">
          <source>Function-like macros replace each occurrence of defined identifier with replacement-list, additionally taking a number of arguments, which then replace corresponding occurrences of any of the parameters in the replacement-list.</source>
          <target state="translated">类似于函数的宏将定义的标识符的每一次出现都替换成替换列表,另外取一些参数,然后替换替换列表中任何参数的相应出现。</target>
        </trans-unit>
        <trans-unit id="1bc7ec84b7f54258ed54c7cecbe2e69587cb60b9" translate="yes" xml:space="preserve">
          <source>Function-local static objects in all definitions of the same &lt;a href=&quot;inline&quot;&gt;inline function&lt;/a&gt; (which may be implicitly inline) all refer to the same object defined in one translation unit.</source>
          <target state="translated">同一&lt;a href=&quot;inline&quot;&gt;内联函数&lt;/a&gt;（可能是隐式内联）的所有定义中的局部函数静态对象都引用一个翻译单元中定义的同一对象。</target>
        </trans-unit>
        <trans-unit id="fbeb9de485717bfd55eb5b969f4aef0b216aa354" translate="yes" xml:space="preserve">
          <source>Function-local static objects in all function definitions are shared across all translation units (they all refer to the same object defined in one translation unit)</source>
          <target state="translated">所有函数定义中的函数本地静态对象在所有翻译单元中都是共享的(它们都是指一个翻译单元中定义的同一个对象)。</target>
        </trans-unit>
        <trans-unit id="22b482f447a1cfcb8f938c680757e7b627882a11" translate="yes" xml:space="preserve">
          <source>Function-try-block</source>
          <target state="translated">Function-try-block</target>
        </trans-unit>
        <trans-unit id="36dbe687f7a701ccda0c0ab3d3368fc1726070a3" translate="yes" xml:space="preserve">
          <source>Function-try-block does not catch the exceptions thrown by the copy/move constructors and the destructors of the function parameters passed by value: those exceptions are thrown in context of the caller.</source>
          <target state="translated">Function-try-block不捕捉由复制/移动构造函数和由值传递的函数参数的析构函数抛出的异常:这些异常是在调用者的上下文中抛出的。</target>
        </trans-unit>
        <trans-unit id="62fa030d8057f6948ce260fe787ed5a6b93441e6" translate="yes" xml:space="preserve">
          <source>Function-try-block of the top-level function of a thread does not catch the exceptions thrown from the constructors and destructors of &lt;a href=&quot;storage_duration&quot;&gt;thread-local&lt;/a&gt; objects (except for the constructors of function-scoped thread-locals).</source>
          <target state="translated">线程的顶级函数的Function-try-block不能捕获&lt;a href=&quot;storage_duration&quot;&gt;线程局部&lt;/a&gt;对象的构造函数和析构函数抛出的异常（函数范围内的线程局部对象的构造函数除外）。</target>
        </trans-unit>
        <trans-unit id="e6221f912553a22b3b906841565a95ac6fe744e4" translate="yes" xml:space="preserve">
          <source>FunctionObject</source>
          <target state="translated">FunctionObject</target>
        </trans-unit>
        <trans-unit id="c504a5185db1d5f75bfd32087e1e44501fcf47f1" translate="yes" xml:space="preserve">
          <source>Functional cast</source>
          <target state="translated">功能性铸造</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="b4889f5791eb376ad73674ef2d3c06e94b724603" translate="yes" xml:space="preserve">
          <source>Functions and macro constants for signal management</source>
          <target state="translated">用于信号管理的函数和宏常数</target>
        </trans-unit>
        <trans-unit id="a1141ae7da62060d933a86668311750ac59f208e" translate="yes" xml:space="preserve">
          <source>Functions and references to functions are not function object types, but can be used where function object types are expected due to function-to-pointer &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicit conversion&lt;/a&gt;.</source>
          <target state="translated">函数和对函数的引用不是函数对象类型，但是可以在由于函数到指针的&lt;a href=&quot;../language/implicit_cast&quot;&gt;隐式转换&lt;/a&gt;而需要函数对象类型的地方使用。</target>
        </trans-unit>
        <trans-unit id="ab7bbe95387b8d4e9017d700d4c60ae66f3da45c" translate="yes" xml:space="preserve">
          <source>Functions are C++ entities that associate a sequence of &lt;a href=&quot;statements&quot;&gt;statements&lt;/a&gt; (a</source>
          <target state="translated">函数是与&lt;a href=&quot;statements&quot;&gt;语句&lt;/a&gt;序列相关联的C ++实体（a</target>
        </trans-unit>
        <trans-unit id="9a1ebfefe2d4935a5dd163de13ea3976c504e0ea" translate="yes" xml:space="preserve">
          <source>Functions are not objects: there are no arrays of functions and functions cannot be passed by value or returned from other functions. Pointers and references to functions are allowed, and may be used where functions themselves cannot.</source>
          <target state="translated">函数不是对象:没有函数的数组,函数不能通过值传递或从其他函数中返回。允许指向函数的指针和引用,并且可以在函数本身不能使用的地方使用。</target>
        </trans-unit>
        <trans-unit id="e4cd68a9abe69d2fc916398ed73a57ddaba5e3ac" translate="yes" xml:space="preserve">
          <source>Functions differing only in their exception specification cannot be overloaded (just like the return type, exception specification is part of function type, but not part of the function signature)(since C++17).</source>
          <target state="translated">仅在异常规范上有差异的函数不能被重载(就像返回类型一样,异常规范是函数类型的一部分,但不是函数签名的一部分)(自C++17起)。</target>
        </trans-unit>
        <trans-unit id="d805e16a2e1dab2e9501d00d8aa06488d3d1141d" translate="yes" xml:space="preserve">
          <source>Functions in input/output classes returning this type use &lt;code&gt;X::pos_type(X::off_type(-1))&lt;/code&gt; is an invalid value to signal an error</source>
          <target state="translated">返回此类型的输入/输出类中的函数使用 &lt;code&gt;X::pos_type(X::off_type(-1))&lt;/code&gt; 是无效值，表示发生错误</target>
        </trans-unit>
        <trans-unit id="f4f28c856ebb451338613595e08fe5dd22c841b5" translate="yes" xml:space="preserve">
          <source>Functions managing the current thread</source>
          <target state="translated">管理当前线程的功能</target>
        </trans-unit>
        <trans-unit id="d3e493f42a02a1130d7650420222293b27d1128f" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; are called in reverse order of their registration. If an exception tries to propagate out of any of the functions, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. After calling the registered functions, calls &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;std::_Exit&lt;/a&gt;(exit_code)&lt;/code&gt;.</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; 函数以与注册相反的顺序调用。如果异常尝试从任何函数中传播出去，则调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。调用注册的函数后，调用 &lt;code&gt;&lt;a href=&quot;_exit&quot;&gt;std::_Exit&lt;/a&gt;(exit_code)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2271b1375ac754084b518ec111ad83a20a6f3bb3" translate="yes" xml:space="preserve">
          <source>Functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are not called.</source>
          <target state="translated">传递给 &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; 函数不会被调用。</target>
        </trans-unit>
        <trans-unit id="a4c76c24658f2c936074eb17b534063810ef4a85" translate="yes" xml:space="preserve">
          <source>Functions templates cannot be declared &lt;code&gt;virtual&lt;/code&gt;. This applies only to functions that are themselves templates - a regular member function of a class template can be declared virtual.</source>
          <target state="translated">函数模板不能声明为 &lt;code&gt;virtual&lt;/code&gt; 。这仅适用于本身就是模板的函数-类模板的常规成员函数可以声明为虚函数。</target>
        </trans-unit>
        <trans-unit id="987a9735f7910a78415404d390c2c2321b297df5" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in character data</source>
          <target state="translated">确定字符数据类型的函数</target>
        </trans-unit>
        <trans-unit id="56333d40b9d13a5dd6765448f63eb5888129f41c" translate="yes" xml:space="preserve">
          <source>Functions to determine the type contained in wide character data</source>
          <target state="translated">确定宽字符数据中包含的类型的功能。</target>
        </trans-unit>
        <trans-unit id="268aa8a9dc8a94eb9552c1bc422fd7d569604150" translate="yes" xml:space="preserve">
          <source>Fundamental library concepts</source>
          <target state="translated">图书馆的基本概念</target>
        </trans-unit>
        <trans-unit id="9415eca058dab008a0c257d5b5372a414020f727" translate="yes" xml:space="preserve">
          <source>Fundamental types</source>
          <target state="translated">基本类型</target>
        </trans-unit>
        <trans-unit id="f9ccc0fa4eefc3fc4fbd603adf877686e0fcb107" translate="yes" xml:space="preserve">
          <source>Fundamental types defined by the language</source>
          <target state="translated">语言定义的基本类型</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">进一步阅读</target>
        </trans-unit>
        <trans-unit id="90203b2e01951bcae33561da4c2fe607351b5912" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;auto&lt;/code&gt;and type-constraint&lt;code&gt;auto&lt;/code&gt;(since C++20) can appear in:</source>
          <target state="translated">此外， &lt;code&gt;auto&lt;/code&gt; 和type-constraint &lt;code&gt;auto&lt;/code&gt; （自C ++ 20起）可以出现在：</target>
        </trans-unit>
        <trans-unit id="6dc21edb8c36c3f6d406c872d0cb241b792a813e" translate="yes" xml:space="preserve">
          <source>Furthermore.</source>
          <target state="translated">Furthermore.</target>
        </trans-unit>
        <trans-unit id="ef3bf279dd511b3249e9a0fa2ada2e63ca452156" translate="yes" xml:space="preserve">
          <source>Future errors</source>
          <target state="translated">今后的错误</target>
        </trans-unit>
        <trans-unit id="965db80f650641f51dead99c13720e4035c9ef70" translate="yes" xml:space="preserve">
          <source>Futures</source>
          <target state="translated">Futures</target>
        </trans-unit>
        <trans-unit id="4c00eeb89fd7b78411cbeb5ccec11fa4c97f179d" translate="yes" xml:space="preserve">
          <source>GCC 4.6 libstdc++</source>
          <target state="translated">GCC 4.6 libstdc++</target>
        </trans-unit>
        <trans-unit id="8678ed721c5d5bc588ebb7a34742eafcc58d8a66" translate="yes" xml:space="preserve">
          <source>GCC Inline Assembly HOWTO</source>
          <target state="translated">GCC内联装配HOWTO</target>
        </trans-unit>
        <trans-unit id="e28f7b13c864b2544bcffb8944485f05b95aa03f" translate="yes" xml:space="preserve">
          <source>GCC assembly with the attribute:</source>
          <target state="translated">带属性的GCC程序集。</target>
        </trans-unit>
        <trans-unit id="29dc240b146eb494ed0bbceef77ad1534442b61b" translate="yes" xml:space="preserve">
          <source>GCC assembly without the attribute: the entire function is serialized.</source>
          <target state="translated">没有属性的GCC程序集:整个函数被序列化。</target>
        </trans-unit>
        <trans-unit id="607e8f7d61ea73ecc2a3928fe014d54ac981f615" translate="yes" xml:space="preserve">
          <source>GLAGOLITIC CAPITAL LETTER AZU - COMBINING CYRILLIC LETTER IOTIFIED BIG YUS</source>
          <target state="translated">GLAGOLITIC CAPITAL LETTER AZU-COMBINING CYRILLIC LETTER IOTIFIED BIG YUS.</target>
        </trans-unit>
        <trans-unit id="770bd3164fd3f78b840dd2606eee557790bae82f" translate="yes" xml:space="preserve">
          <source>GNU libc function &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/s/hello/manual/libc/Control-Functions.html&quot;&gt;feenableexcept()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates the signal &lt;code&gt;SIGFPE&lt;/code&gt;. If the compiler option &lt;code&gt;-fnon-call-exceptions&lt;/code&gt; was used, the handler for that signal may throw a user-defined C++ exception.</source>
          <target state="translated">GNU libc函数 &lt;code&gt;&lt;a href=&quot;http://www.gnu.org/s/hello/manual/libc/Control-Functions.html&quot;&gt;feenableexcept()&lt;/a&gt;&lt;/code&gt; 启用了对浮点异常的捕获，从而生成信号 &lt;code&gt;SIGFPE&lt;/code&gt; 。如果使用了编译器选项 &lt;code&gt;-fnon-call-exceptions&lt;/code&gt; ，则该信号的处理程序可能会抛出用户定义的C ++异常。</target>
        </trans-unit>
        <trans-unit id="7e7d86fda01350dd97d7deed580504fa4ea12720" translate="yes" xml:space="preserve">
          <source>GNU libstdc++ stores 4 additional members: three cached facets and a flag to indicate that fill was initialized.</source>
          <target state="translated">GNU libstdc++存储了4个额外的成员:3个缓存的面和一个表示填充被初始化的标志。</target>
        </trans-unit>
        <trans-unit id="262e4b5ffc0564ab9152ecabdaf6c1affcaea1bc" translate="yes" xml:space="preserve">
          <source>GOTW issue 47: Uncaught Exceptions</source>
          <target state="translated">GOTW第47期。未发现的例外情况</target>
        </trans-unit>
        <trans-unit id="143075ce23be9b2dbef6368dc5e0e4219829451a" translate="yes" xml:space="preserve">
          <source>Garbage collector support</source>
          <target state="translated">支持垃圾收集器</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="c807e9f8f0554603e2d07bd5ea3e21f358d0409a" translate="yes" xml:space="preserve">
          <source>General purpose utilities: &lt;a href=&quot;utility/program&quot;&gt; program control&lt;/a&gt;, &lt;a href=&quot;memory/c&quot;&gt; dynamic memory allocation&lt;/a&gt;, &lt;a href=&quot;numeric/random&quot;&gt; random numbers&lt;/a&gt;, &lt;a href=&quot;algorithm&quot;&gt; sort and search&lt;/a&gt;</source>
          <target state="translated">通用工具：&lt;a href=&quot;utility/program&quot;&gt;程序控制&lt;/a&gt;，&lt;a href=&quot;memory/c&quot;&gt;动态内存分配&lt;/a&gt;，&lt;a href=&quot;numeric/random&quot;&gt;随机数&lt;/a&gt;，&lt;a href=&quot;algorithm&quot;&gt;排序和搜索&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed31062b543a89f89f4324118c873e8e23d6d8a5" translate="yes" xml:space="preserve">
          <source>General-purpose utilities</source>
          <target state="translated">一般用途的公用事业</target>
        </trans-unit>
        <trans-unit id="5c6d1d670f7f626ac925f247ce54a21001aced36" translate="yes" xml:space="preserve">
          <source>Generalized lambda-capture</source>
          <target state="translated">笼统的lambda-capture</target>
        </trans-unit>
        <trans-unit id="f356c8b2b591cd001b93f307940d89de652b1d90" translate="yes" xml:space="preserve">
          <source>Generalized range-based &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">基于广义范围的 &lt;code&gt;for&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="42544cf1873411d097739bf7d82068c8b915ea3d" translate="yes" xml:space="preserve">
          <source>Generalized sum of &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;*first&lt;/code&gt;, &lt;code&gt;*(first+1)&lt;/code&gt;, ... &lt;code&gt;*(last-1)&lt;/code&gt; over &lt;code&gt;binary_op&lt;/code&gt;,</source>
          <target state="translated">二进制和 &lt;code&gt;init&lt;/code&gt; 和 &lt;code&gt;*first&lt;/code&gt; ， &lt;code&gt;*(first+1)&lt;/code&gt; ，... &lt;code&gt;*(last-1)&lt;/code&gt; 的 &lt;code&gt;binary_op&lt;/code&gt; 和</target>
        </trans-unit>
        <trans-unit id="13dfcc134e2752a1f9a0a0493daeaa583d9e01a7" translate="yes" xml:space="preserve">
          <source>Generally speaking, the pseudo-random number generator should only be seeded once, before any calls to &lt;code&gt;rand()&lt;/code&gt;, at the start of the program. It should not be repeatedly seeded, or reseeded every time you wish to generate a new batch of pseudo-random numbers.</source>
          <target state="translated">一般而言，伪随机数生成器在程序开始时仅应在对 &lt;code&gt;rand()&lt;/code&gt; 的任何调用之前播种一次。每次要生成新一批伪随机数时，都不应重复播种或重新播种。</target>
        </trans-unit>
        <trans-unit id="7ebbc49a3b2f1f41072b44a34d7a54d1bce22da9" translate="yes" xml:space="preserve">
          <source>Generates a non-deterministic uniformly-distributed random value.</source>
          <target state="translated">产生一个非确定的均匀分布的随机值。</target>
        </trans-unit>
        <trans-unit id="974bfaa70e23e754b8c317100b6cf3c9baf7cefa" translate="yes" xml:space="preserve">
          <source>Generates a pseudo-random value. The state of the engine is advanced by one position.</source>
          <target state="translated">生成一个伪随机值。发动机的状态提前一个位置。</target>
        </trans-unit>
        <trans-unit id="69477acbfb73a301833c0442c884476d728e54ee" translate="yes" xml:space="preserve">
          <source>Generates a random floating point number in range [0, 1).</source>
          <target state="translated">生成一个范围为[0,1]的随机浮点数。</target>
        </trans-unit>
        <trans-unit id="e11bac75cd58a1ca2fdf3ef16eb35185ecf226b4" translate="yes" xml:space="preserve">
          <source>Generates a random value. The state of the underlying engine is advanced one or more times.</source>
          <target state="translated">生成一个随机值。底层引擎的状态被提前一次或多次。</target>
        </trans-unit>
        <trans-unit id="045d154a63fd09f9bc95c348dc0baa989ebab1d6" translate="yes" xml:space="preserve">
          <source>Generates random numbers according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;Normal (or Gaussian) random number distribution&lt;/a&gt;. It is defined as:   f(x; &amp;mu;,&amp;sigma;) =</source>
          <target state="translated">根据&lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;正态（或高斯）随机数分布&lt;/a&gt;生成随机数。它定义为：f（x;&amp;mu;，&amp;sigma;）=</target>
        </trans-unit>
        <trans-unit id="74b3ade82ac714c1951306b471876167535085c8" translate="yes" xml:space="preserve">
          <source>Generates random numbers that are distributed according to the associated probability function. The entropy is acquired by calling &lt;code&gt;g.operator()&lt;/code&gt;.</source>
          <target state="translated">生成根据相关的概率函数分布的随机数。通过调用 &lt;code&gt;g.operator()&lt;/code&gt; 获得熵。</target>
        </trans-unit>
        <trans-unit id="8d441fb5f62f87aca029a4bb398180b09920a3f5" translate="yes" xml:space="preserve">
          <source>Generation</source>
          <target state="translated">Generation</target>
        </trans-unit>
        <trans-unit id="742daa97a3eea8220673e99a3db1f627bdf6d93c" translate="yes" xml:space="preserve">
          <source>Generic (polymorphic) lambda expressions</source>
          <target state="translated">通用(多态)lambda表达式。</target>
        </trans-unit>
        <trans-unit id="a3b12ef32437e95ff76df32c3bf2e29d863224ec" translate="yes" xml:space="preserve">
          <source>Generic components may, in addition, offer</source>
          <target state="translated">此外,通用组件还可以提供</target>
        </trans-unit>
        <trans-unit id="d399f4838f649a1dd72fc3c7d1626e48aca6fcc9" translate="yes" xml:space="preserve">
          <source>Generic locking algorithms</source>
          <target state="translated">通用锁定算法</target>
        </trans-unit>
        <trans-unit id="522f4aca708bf0b67f4969ccd2a81f0afbce9777" translate="yes" xml:space="preserve">
          <source>Generic mutex management</source>
          <target state="translated">通用mutex管理</target>
        </trans-unit>
        <trans-unit id="bb5f7091dca0b61fa982fa58c2f04caba2c88133" translate="yes" xml:space="preserve">
          <source>Generic pathname format</source>
          <target state="translated">通用路径名格式</target>
        </trans-unit>
        <trans-unit id="5062b24e22ad40ee77724d279398f1dbf438838e" translate="yes" xml:space="preserve">
          <source>Get area</source>
          <target state="translated">获取面积</target>
        </trans-unit>
        <trans-unit id="f30e54b151b7e1d903f56be15b95cfc3a9e8869c" translate="yes" xml:space="preserve">
          <source>Gets and sets the exception mask of the stream. The exception mask determines the error states on occurrence of which the stream throws exception of type &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;failure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">获取并设置流的异常掩码。异常掩码确定流发生时引发类型 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;failure&lt;/a&gt;&lt;/code&gt; 异常的错误状态。</target>
        </trans-unit>
        <trans-unit id="b970edd37ceef3acb34a7c5e361913bd8492e2aa" translate="yes" xml:space="preserve">
          <source>Gets and sets the underlying string.</source>
          <target state="translated">获取并设置底层字符串。</target>
        </trans-unit>
        <trans-unit id="332452f1980fa4e174e790babca85d5c6e588e9e" translate="yes" xml:space="preserve">
          <source>Gets the default memory resource pointer.</source>
          <target state="translated">获取默认的内存资源指针。</target>
        </trans-unit>
        <trans-unit id="499d742f096a087b00e3a25ac2c61ce6526047bb" translate="yes" xml:space="preserve">
          <source>Getting the result</source>
          <target state="translated">获取结果</target>
        </trans-unit>
        <trans-unit id="a31c54bbb19e0e2599a1d0ad74d19479e5b692ac" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;, performs O(log N) applications of the predicate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">给定 &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; ，执行谓词 &lt;code&gt;p&lt;/code&gt; 的 O（log N）个应用。</target>
        </trans-unit>
        <trans-unit id="2de26a11901d553b8a58d6c3ba8e560899db14ac" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;},</source>
          <target state="translated">给定 &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; }，</target>
        </trans-unit>
        <trans-unit id="201a57a136c12310d1acc1180f1b02b9f2f6f001" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;N = last - first&lt;/code&gt;.</source>
          <target state="translated">给定 &lt;code&gt;N = last - first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3e5ecd385ba57ca31705c6a420eb24ffafacec4" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, dereferenceable iterators of type &lt;code&gt;It&lt;/code&gt;.</source>
          <target state="translated">给定 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; ，可引用类型为 &lt;code&gt;It&lt;/code&gt; 的迭代器。</target>
        </trans-unit>
        <trans-unit id="bd092018ae73c0887d7dc6c9b1bb5a5adc4b89b7" translate="yes" xml:space="preserve">
          <source>Given N = &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt;,</source>
          <target state="translated">给定N = &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="a60f6d48405c975ae0935013623bdd24a66ebef7" translate="yes" xml:space="preserve">
          <source>Given a BinaryPredicate &lt;code&gt;bin_pred&lt;/code&gt; and a pair of iterators &lt;code&gt;iter1&lt;/code&gt; and &lt;code&gt;iter2&lt;/code&gt; or an iterator &lt;code&gt;iter&lt;/code&gt; and a value &lt;code&gt;value&lt;/code&gt;, the expression &lt;code&gt;bin_pred(*iter1, *iter2)&lt;/code&gt; or, respectively, &lt;code&gt;bin_pred(*iter, value)&lt;/code&gt;, must be &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually convertible&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">给定BinaryPredicate &lt;code&gt;bin_pred&lt;/code&gt; 和一对迭代器 &lt;code&gt;iter1&lt;/code&gt; 和 &lt;code&gt;iter2&lt;/code&gt; 或一个迭代器 &lt;code&gt;iter&lt;/code&gt; 和一个值 &lt;code&gt;value&lt;/code&gt; ，则表达式 &lt;code&gt;bin_pred(*iter1, *iter2)&lt;/code&gt; 或 &lt;code&gt;bin_pred(*iter, value)&lt;/code&gt; 必须在&lt;a href=&quot;../language/implicit_cast&quot;&gt;上下文中可转换&lt;/a&gt;为 &lt;code&gt;bool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8aa890934e1378f6d141dac2f7867c119b8ad1fa" translate="yes" xml:space="preserve">
          <source>Given a function parameter &lt;code&gt;P&lt;/code&gt; that depends on one or more type template parameters &lt;code&gt;T&lt;/code&gt;i, template template parameters &lt;code&gt;TT&lt;/code&gt;i, or non-type template parameters &lt;code&gt;I&lt;/code&gt;i, and the corresponding argument &lt;code&gt;A&lt;/code&gt;, deduction takes place if &lt;code&gt;P&lt;/code&gt; has one of the following forms:</source>
          <target state="translated">给定一个取决于一个或多个类型模板参数 &lt;code&gt;T&lt;/code&gt; i，模板模板参数 &lt;code&gt;TT&lt;/code&gt; i或非类型模板参数 &lt;code&gt;I&lt;/code&gt; i 的函数参数 &lt;code&gt;P&lt;/code&gt; 以及对应的自变量 &lt;code&gt;A&lt;/code&gt; ，如果 &lt;code&gt;P&lt;/code&gt; 具有以下形式之一，则进行推导：</target>
        </trans-unit>
        <trans-unit id="849104a88d07876b31798d027eae5e4b5ac7a9c0" translate="yes" xml:space="preserve">
          <source>Given a pointer ptr to a buffer of size space, returns a pointer aligned by the specified alignment for size number of bytes and decreases space argument by the number of bytes used for alignment. The first aligned address is returned.</source>
          <target state="translated">给定一个指向大小为空间的缓冲区的指针ptr,返回一个按指定的对齐方式对齐的大小字节数的指针,并按对齐所用的字节数减少空间参数。返回第一个对齐的地址。</target>
        </trans-unit>
        <trans-unit id="1d1642375a13cf9d00a6f14be269e1b8dfaf5497" translate="yes" xml:space="preserve">
          <source>Given a set of types &lt;code&gt;Args...&lt;/code&gt;, if &lt;code&gt;&lt;a href=&quot;../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...&lt;/code&gt; meet the requirements for arguments to &lt;code&gt;ranges::swap&lt;/code&gt; above, &lt;code&gt;SwapT&lt;/code&gt; will satisfy &lt;code&gt;std::&lt;a href=&quot;../../concepts/invocable&quot;&gt;Invocable&lt;/a&gt;&amp;lt;const SwapT&amp;amp;, Args...&amp;gt;&lt;/code&gt;. Otherwise, no function call operator of &lt;code&gt;SwapT&lt;/code&gt; participates in overload resolution.</source>
          <target state="translated">给定一组类型 &lt;code&gt;Args...&lt;/code&gt; ，如果 &lt;code&gt;&lt;a href=&quot;../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...&lt;/code&gt; 满足上述 &lt;code&gt;ranges::swap&lt;/code&gt; 参数要求，则 &lt;code&gt;SwapT&lt;/code&gt; 将满足 &lt;code&gt;std::&lt;a href=&quot;../../concepts/invocable&quot;&gt;Invocable&lt;/a&gt;&amp;lt;const SwapT&amp;amp;, Args...&amp;gt;&lt;/code&gt; 。否则， &lt;code&gt;SwapT&lt;/code&gt; 的任何函数调用运算符都不会参与重载解析。</target>
        </trans-unit>
        <trans-unit id="cd88ec801294426ab54d23bc136aca37fe96b8e0" translate="yes" xml:space="preserve">
          <source>Given a user-defined &lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator&amp;lt;&lt;/code&gt; for objects of type &lt;code&gt;T&lt;/code&gt;, implements the usual semantics of other comparison operators.</source>
          <target state="translated">给定类型 &lt;code&gt;T&lt;/code&gt; 的对象的用户定义的 &lt;code&gt;operator==&lt;/code&gt; 和 &lt;code&gt;operator&amp;lt;&lt;/code&gt; ，可以实现其他比较运算符的通常语义。</target>
        </trans-unit>
        <trans-unit id="9347968d88bdedbaad63962c44f19bc3e70fd1d7" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;map&lt;/code&gt;:</source>
          <target state="translated">给定一个实例 &lt;code&gt;c&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c587de6b8b3e1339541445cfac7615e9dbb23ca9" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;multimap&lt;/code&gt;:</source>
          <target state="translated">给定一个实例 &lt;code&gt;c&lt;/code&gt; 的 &lt;code&gt;multimap&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a14568942f46c8464d02bc68bb11bb1b20d8f671" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;multiset&lt;/code&gt;:</source>
          <target state="translated">给定一个实例 &lt;code&gt;c&lt;/code&gt; 的 &lt;code&gt;multiset&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="3e2459dd2b814290389adeffd53910165c623ff3" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;set&lt;/code&gt;:</source>
          <target state="translated">给定一个实例 &lt;code&gt;c&lt;/code&gt; 的 &lt;code&gt;set&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="881f1c518159f483a92d230aff08438c975cfc40" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_map&lt;/code&gt;:</source>
          <target state="translated">给定实例 &lt;code&gt;c&lt;/code&gt; 的 &lt;code&gt;unordered_map&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fa31a301eaa86d94083d76755aeb6d15245d1d46" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_multimap&lt;/code&gt;:</source>
          <target state="translated">给定实例 &lt;code&gt;c&lt;/code&gt; 的 &lt;code&gt;unordered_multimap&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f6d85ed3e34fe83d62419c16e466b796d53d7bae" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_multiset&lt;/code&gt;:</source>
          <target state="translated">给定实例 &lt;code&gt;c&lt;/code&gt; 为 &lt;code&gt;unordered_multiset&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a229fa6402280d8d3988d3795c697a501535b4a0" translate="yes" xml:space="preserve">
          <source>Given an instance &lt;code&gt;c&lt;/code&gt; of &lt;code&gt;unordered_set&lt;/code&gt;:</source>
          <target state="translated">给定实例 &lt;code&gt;c&lt;/code&gt; 的 &lt;code&gt;unordered_set&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="585b276223e3efe88a4cec484dd924b01d338788" translate="yes" xml:space="preserve">
          <source>Given an object &lt;code&gt;G&lt;/code&gt; obtained from an earlier call to &lt;code&gt;bind_front(f, args...)&lt;/code&gt;, when a glvalue &lt;code&gt;g&lt;/code&gt; designating &lt;code&gt;G&lt;/code&gt; is invoked in a function call expression &lt;code&gt;g(call_args...)&lt;/code&gt;, an invocation of the stored object takes place, as if by.</source>
          <target state="translated">给定对象 &lt;code&gt;G&lt;/code&gt; 是从先前对 &lt;code&gt;bind_front(f, args...)&lt;/code&gt; 调用中获得的，当在函数调用表达式 &lt;code&gt;g(call_args...)&lt;/code&gt; 调用指定 &lt;code&gt;G&lt;/code&gt; 的glvalue &lt;code&gt;g&lt;/code&gt; 时，就会发生存储对象的调用，好像</target>
        </trans-unit>
        <trans-unit id="a88f34b4e5838dad793cf28d772a20e6a14e6fb1" translate="yes" xml:space="preserve">
          <source>Given an object &lt;code&gt;g&lt;/code&gt; obtained from an earlier call to &lt;code&gt;bind&lt;/code&gt;, when it is invoked in a function call expression &lt;code&gt;g(u1, u2, ... uM)&lt;/code&gt;, an invocation of the stored object takes place, as if by &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V1&amp;gt;(v1), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V2&amp;gt;(v2), ..., &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;VN&amp;gt;(vN))&lt;/code&gt;, where &lt;code&gt;fd&lt;/code&gt; is a value of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; the values and types of the bound arguments &lt;code&gt;v1, v2, ..., vN&lt;/code&gt; are determined as specified below.</source>
          <target state="translated">给定从先前的 &lt;code&gt;bind&lt;/code&gt; 调用获得的对象 &lt;code&gt;g&lt;/code&gt; ，当在函数调用表达式 &lt;code&gt;g(u1, u2, ... uM)&lt;/code&gt; 调用该对象g时，将调用存储的对象，就像通过 &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V1&amp;gt;(v1), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;V2&amp;gt;(v2), ..., &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;VN&amp;gt;(vN))&lt;/code&gt; （ fd，&lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;V1&amp;gt;（v1），&lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;V2&amp;gt;（v2），...，&lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;VN&amp;gt;（vN）），其中 &lt;code&gt;fd&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; 类型的值衰减_t &amp;lt;F&amp;gt;绑定参数 &lt;code&gt;v1, v2, ..., vN&lt;/code&gt; 的值和类型如下确定。</target>
        </trans-unit>
        <trans-unit id="a8337adfa8cf3c8e162bcbe5e0229685e6eb60d8" translate="yes" xml:space="preserve">
          <source>Given the character sequence from the previous steps, if the first character equals &lt;code&gt;ct.widen('-')&lt;/code&gt;, calls &lt;code&gt;mp.neg_format()&lt;/code&gt; to obtain the formatting &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt;, otherwise calls &lt;code&gt;mp.pos_format()&lt;/code&gt;, where &lt;code&gt;mp&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; facet imbued in &lt;code&gt;str.getloc()&lt;/code&gt;.</source>
          <target state="translated">给定前面步骤中的字符序列，如果第一个字符等于 &lt;code&gt;ct.widen('-')&lt;/code&gt; ，则调用 &lt;code&gt;mp.neg_format()&lt;/code&gt; 以获得格式设置 &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; ，否则调用 &lt;code&gt;mp.pos_format()&lt;/code&gt; ，其中 &lt;code&gt;mp&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../moneypunct&quot;&gt;std::moneypunct&lt;/a&gt;&amp;lt;CharT, intl&amp;gt;&lt;/code&gt; ::：moneypunct &amp;lt;CharT，intl&amp;gt;构面 &lt;code&gt;str.getloc()&lt;/code&gt; 到str.getloc（）中。</target>
        </trans-unit>
        <trans-unit id="66236ee54dcad384d354db9941193df8b20deffb" translate="yes" xml:space="preserve">
          <source>Given the set of candidate functions, constructed as described above, the next step of overload resolution is examining arguments and parameters to reduce the set to the set of</source>
          <target state="translated">给定如上所述构建的候选函数集,下一步的过载解析就是检查参数和参数,将该集合还原为的</target>
        </trans-unit>
        <trans-unit id="c0aebd42da085f11a7898d7938dcfcf81f34f4ad" translate="yes" xml:space="preserve">
          <source>Given the starting value s, a list of strides i</source>
          <target state="translated">在给定的起始值s的情况下,一个步长列表i</target>
        </trans-unit>
        <trans-unit id="93321ba8b5317191b60feb65e2cf919f7e2a81f1" translate="yes" xml:space="preserve">
          <source>Given.</source>
          <target state="translated">Given.</target>
        </trans-unit>
        <trans-unit id="c46a97000778eff7a9406aa7dac4bb058a740c4f" translate="yes" xml:space="preserve">
          <source>Gives well-defined results for reference types, void types, array types, and function types.</source>
          <target state="translated">为引用类型、虚空类型、数组类型和函数类型提供定义良好的结果。</target>
        </trans-unit>
        <trans-unit id="6c1092b384c391c235bf0f03a6b067bc9829d4dd" translate="yes" xml:space="preserve">
          <source>Global objects</source>
          <target state="translated">全局对象</target>
        </trans-unit>
        <trans-unit id="8ecf59cbff938c3c09e7ac755a67fc60c8335206" translate="yes" xml:space="preserve">
          <source>Global replacements</source>
          <target state="translated">全球替换</target>
        </trans-unit>
        <trans-unit id="6f85091c78ab312c0eeab087e50a90d21a6d8a82" translate="yes" xml:space="preserve">
          <source>Guaranteed copy elision through simplified &lt;a href=&quot;language/value_category&quot;&gt;value categories&lt;/a&gt;</source>
          <target state="translated">通过简化的&lt;a href=&quot;language/value_category&quot;&gt;值类别&lt;/a&gt;保证复制省略</target>
        </trans-unit>
        <trans-unit id="daf1a29d21388e553e2e351d8eb2ded2e9be0a7c" translate="yes" xml:space="preserve">
          <source>Guides (2-3) are needed because the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; constructors for &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;s are made templates to avoid causing ambiguities in existing code, and those templates do not support class template argument deduction.</source>
          <target state="translated">需要导游（2-3），因为 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 对构造 &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; s的范本来避免现有的代码引起歧义，而且这些模板不支持类模板参数推导。</target>
        </trans-unit>
        <trans-unit id="ab161f039e51e47e91c7fb547b04ada20d53b4a3" translate="yes" xml:space="preserve">
          <source>H. Sutter (1998) &lt;a href=&quot;http://www.gotw.ca/publications/mill02.htm&quot;&gt;&quot;What's In a Class? - The Interface Principle&quot;&lt;/a&gt; in C++ Report, 10(3)</source>
          <target state="translated">H. Sutter（1998）&lt;a href=&quot;http://www.gotw.ca/publications/mill02.htm&quot;&gt;&amp;ldquo;类中有什么？-接口原理&amp;rdquo;&lt;/a&gt;，C ++报告，10（3）</target>
        </trans-unit>
        <trans-unit id="4d2fcf54f70e7b8f49c067c962c20ecc9c2156b7" translate="yes" xml:space="preserve">
          <source>H. Sutter (2000) &quot;Exceptional C++&quot;</source>
          <target state="translated">H.Sutter(2000)&quot;Exceptional C++&quot;</target>
        </trans-unit>
        <trans-unit id="4dba1c99fa72599cb430192c2725ee29e7826d41" translate="yes" xml:space="preserve">
          <source>H. Sutter (2004) &lt;a href=&quot;http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836&quot;&gt;&quot;When and How to Use Exceptions&quot;&lt;/a&gt; in Dr. Dobb's</source>
          <target state="translated">H. Sutter（2004）Dobb博士的&lt;a href=&quot;http://www.drdobbs.com/when-and-how-to-use-exceptions/184401836&quot;&gt;&amp;ldquo;何时以及如何使用异常&amp;rdquo;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3726a2cbec5aa86ee541f35ad869f9d462e3d65" translate="yes" xml:space="preserve">
          <source>H.Sutter, A. Alexandrescu (2004) &quot;C++ Coding Standards&quot; Item 73</source>
          <target state="translated">H.Sutter,A.Alexandrescu(2004)&quot;C++编码标准 &quot;项目73。</target>
        </trans-unit>
        <trans-unit id="3ee760973e367e7fcaab598e6a4779e4ff88cda5" translate="yes" xml:space="preserve">
          <source>H.Sutter, A. Alexandrescu (2004), &quot;C++ Coding Standards&quot;, Item 70</source>
          <target state="translated">H.Sutter,A.Alexandrescu(2004),&quot;C++编码标准&quot;,项目70。</target>
        </trans-unit>
        <trans-unit id="202043e89dc2aeb009dea78fe3ba6aecc90d862d" translate="yes" xml:space="preserve">
          <source>HANGZHOU NUMERAL ONE - HANGUL DOUBLE DOT TONE MARK</source>
          <target state="translated">杭州一号数字-杭州双点音符。</target>
        </trans-unit>
        <trans-unit id="498203d3437361cd8d2965b93c0eb3f8af84971a" translate="yes" xml:space="preserve">
          <source>HUGE_VALF, HUGE_VAL, HUGE_VALL</source>
          <target state="translated">HUGE_VALF,HUGE_VAL,HUGE_VALL。</target>
        </trans-unit>
        <trans-unit id="0ff054331f849fe26ab715fa596bf0d6c1b9b49c" translate="yes" xml:space="preserve">
          <source>HUGE_VALFHUGE_VALHUGE_VALL</source>
          <target state="translated">HUGE_VALFHUGE_VALHUGE_VALL</target>
        </trans-unit>
        <trans-unit id="b38181b2101d3ec22f60111fb7da75e6dc9d72e8" translate="yes" xml:space="preserve">
          <source>HUGE_VALL</source>
          <target state="translated">HUGE_VALL</target>
        </trans-unit>
        <trans-unit id="71eafe8cf5a2cb341c2f05d96f0f6422891ac1dd" translate="yes" xml:space="preserve">
          <source>Handling of exception specification violations (removed in C++17)</source>
          <target state="translated">违反异常规范的处理(在C++17中删除)。</target>
        </trans-unit>
        <trans-unit id="5c4704b5df9665a78c88de802bae877af50465d2" translate="yes" xml:space="preserve">
          <source>Handling of failures in exception handling</source>
          <target state="translated">异常处理中失败的处理</target>
        </trans-unit>
        <trans-unit id="ea1720079c69bfadf4103ddaa2b4cd30fc66377a" translate="yes" xml:space="preserve">
          <source>Handling of variable length argument lists</source>
          <target state="translated">处理可变长度的参数列表</target>
        </trans-unit>
        <trans-unit id="0e8c641cc752e55897602b479a23cc749b022d01" translate="yes" xml:space="preserve">
          <source>Happens-before</source>
          <target state="translated">Happens-before</target>
        </trans-unit>
        <trans-unit id="94332d550f7e901bb03f8bebf16b0fe18a1b3ec5" translate="yes" xml:space="preserve">
          <source>Hard links typically cannot cross filesystem boundaries.</source>
          <target state="translated">硬链接通常不能跨越文件系统的边界。</target>
        </trans-unit>
        <trans-unit id="5c50832940f07dd15684fc07335b91ae9b50c034" translate="yes" xml:space="preserve">
          <source>Hardlinking to directories is typically restricted to the superuser.</source>
          <target state="translated">与目录的硬链接通常只限于超级用户。</target>
        </trans-unit>
        <trans-unit id="b2bd7d3deca1dfde9d0e77745248dd3241e3fb2f" translate="yes" xml:space="preserve">
          <source>Hardware could require that an object to be referenced by an &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; have stricter alignment than other &lt;code&gt;T&lt;/code&gt; objects, and whether operations on an &lt;code&gt;atomic_ref&lt;/code&gt; are lock-free can depend on the alignment of the referenced object.</source>
          <target state="translated">硬件可能会要求 &lt;code&gt;atomic_ref&amp;lt;T&amp;gt;&lt;/code&gt; 所引用的对象比其他 &lt;code&gt;T&lt;/code&gt; 对象具有更严格的对齐方式，对 &lt;code&gt;atomic_ref&lt;/code&gt; 的操作是否为无锁操作取决于所引用对象的对齐方式。</target>
        </trans-unit>
        <trans-unit id="50278ca49d19fb7161c9b6156704c44ac84f382e" translate="yes" xml:space="preserve">
          <source>Has all non-static data members and bit-fields declared in the same class (either all in the derived or all in some base)</source>
          <target state="translated">在同一个类中声明了所有的非静态数据成员和位字段(要么在派生类中,要么在某个基类中)。</target>
        </trans-unit>
        <trans-unit id="132088df73d03b2b991fee16006dc96529cc0d11" translate="yes" xml:space="preserve">
          <source>Has no base classes of the same type as the first non-static data member (see &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;)</source>
          <target state="translated">没有与第一个非静态数据成员相同类型的基类（请参见&lt;a href=&quot;../language/ebo&quot;&gt;空基优化&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="3282080bc3a2066760485abf22d4931cd7cf3786" translate="yes" xml:space="preserve">
          <source>Has no non-static data members of reference type</source>
          <target state="translated">没有参考类型的非静态数据成员</target>
        </trans-unit>
        <trans-unit id="c4b0a2efb77a438bdd71e13e8a4b27ab2c2ef90e" translate="yes" xml:space="preserve">
          <source>Has no two (possibly indirect) base class subobjects of the same type</source>
          <target state="translated">没有两个(可能是间接的)相同类型的基类子对象。</target>
        </trans-unit>
        <trans-unit id="e78a6eedfa1171855e11a7dd558ba1ee29f9b975" translate="yes" xml:space="preserve">
          <source>Has no virtual functions or virtual base classes</source>
          <target state="translated">没有虚拟函数或虚拟基类</target>
        </trans-unit>
        <trans-unit id="07ad7632b84dfe67303c7a8f028a0886800e4870" translate="yes" xml:space="preserve">
          <source>Has one or more &lt;a href=&quot;../language/default_constructor&quot;&gt;default constructors&lt;/a&gt;, all of which are either &lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;trivial&lt;/a&gt; or deleted, and at least one of which is not deleted.</source>
          <target state="translated">具有一个或多个&lt;a href=&quot;../language/default_constructor&quot;&gt;默认构造函数&lt;/a&gt;，所有这些构造函数都是&lt;a href=&quot;../language/default_constructor#Trivial_default_constructor&quot;&gt;微不足道的&lt;/a&gt;或已删除，并且至少有一个未删除。</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="cc87e65725671e76b83dd75a39435552efd495a6" translate="yes" xml:space="preserve">
          <source>Hash functions are only required to produce the same result for the same input within a single execution of a program; this allows salted hashes that prevent collision denial-of-service attacks.</source>
          <target state="translated">哈希函数只需要在一个程序的单次执行中对相同的输入产生相同的结果,这就使得盐化哈希可以防止碰撞拒绝服务攻击。</target>
        </trans-unit>
        <trans-unit id="4cd57ebbbfb5b1908d66fa1e003e1ce14e29637e" translate="yes" xml:space="preserve">
          <source>Hash functions should not throw exceptions.</source>
          <target state="translated">哈希函数不应该抛出异常。</target>
        </trans-unit>
        <trans-unit id="7250b05d4111b3b36a49cda927210c8e3d368f6a" translate="yes" xml:space="preserve">
          <source>Hash policy</source>
          <target state="translated">散列政策</target>
        </trans-unit>
        <trans-unit id="b807d317600ff4b338e846d561ee4e0b84f0360a" translate="yes" xml:space="preserve">
          <source>Hash support</source>
          <target state="translated">支持哈希值</target>
        </trans-unit>
        <trans-unit id="53e49a69fb315c4f51afc9825055d4858a064cdc" translate="yes" xml:space="preserve">
          <source>Hashing</source>
          <target state="translated">Hashing</target>
        </trans-unit>
        <trans-unit id="31341c6f0c7af677ffb8fadcb92038e8ac2b6193" translate="yes" xml:space="preserve">
          <source>Header</source>
          <target state="translated">Header</target>
        </trans-unit>
        <trans-unit id="f123fa3f00736262aa136563dd12c3a430fa1bf8" translate="yes" xml:space="preserve">
          <source>Header name preprocessing tokens are only formed within a &lt;code&gt;#include&lt;/code&gt; directive.</source>
          <target state="translated">标头名称预处理令牌仅在 &lt;code&gt;#include&lt;/code&gt; 指令内形成。</target>
        </trans-unit>
        <trans-unit id="1a9eca02fd1369c5ba18c271ae9822e684c6bc3d" translate="yes" xml:space="preserve">
          <source>Headers required for a</source>
          <target state="translated">所需的标题</target>
        </trans-unit>
        <trans-unit id="8cd5e50ec159eebcf43e109ff007519db94c87f5" translate="yes" xml:space="preserve">
          <source>Heap allocation</source>
          <target state="translated">堆分配</target>
        </trans-unit>
        <trans-unit id="adcf91c671cec8bebaf87ee37c2421ff5ebb56fd" translate="yes" xml:space="preserve">
          <source>Heap operations</source>
          <target state="translated">堆操作</target>
        </trans-unit>
        <trans-unit id="43a1b94a7a6895d855248fbccdd91510cfbd3ac0" translate="yes" xml:space="preserve">
          <source>Helper Classes</source>
          <target state="translated">佣人班</target>
        </trans-unit>
        <trans-unit id="035f96a8918459049a59bec0947605cd2a64fdef" translate="yes" xml:space="preserve">
          <source>Helper classes</source>
          <target state="translated">辅导班</target>
        </trans-unit>
        <trans-unit id="7612db9ee91cb4487af96f647ff4f3cd2038be3a" translate="yes" xml:space="preserve">
          <source>Helper concepts</source>
          <target state="translated">辅助概念</target>
        </trans-unit>
        <trans-unit id="058d2ea713d8ed40ef598fece850d00d28cef415" translate="yes" xml:space="preserve">
          <source>Helper functions &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; are often used to generate &lt;code&gt;std::reference_wrapper&lt;/code&gt; objects.</source>
          <target state="translated">辅助函数 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; 通常用于生成 &lt;code&gt;std::reference_wrapper&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="e9564c40bd71a52a2d2792a274dcd71ecab83247" translate="yes" xml:space="preserve">
          <source>Helper functions to control the format of input and output</source>
          <target state="translated">控制输入和输出格式的辅助功能。</target>
        </trans-unit>
        <trans-unit id="24355834da4c51ce8fa25dadf7ca038baf516e2f" translate="yes" xml:space="preserve">
          <source>Helper objects</source>
          <target state="translated">帮助对象</target>
        </trans-unit>
        <trans-unit id="bbca939563aab0002ed11e9e60251643d9e2435c" translate="yes" xml:space="preserve">
          <source>Helper template</source>
          <target state="translated">助手模板</target>
        </trans-unit>
        <trans-unit id="26e4565205fc729962b9119b4035fad3d08ea499" translate="yes" xml:space="preserve">
          <source>Helper template alias</source>
          <target state="translated">助手模板的别名</target>
        </trans-unit>
        <trans-unit id="62f3bc8fedb9c00e4b9d3da1c58627fb9c932c3e" translate="yes" xml:space="preserve">
          <source>Helper templates</source>
          <target state="translated">辅助模板</target>
        </trans-unit>
        <trans-unit id="58208feff4ae33c36603b46c3dceaa24f222cc8d" translate="yes" xml:space="preserve">
          <source>Helper types</source>
          <target state="translated">助手类型</target>
        </trans-unit>
        <trans-unit id="0b456005f09a660089e455709c3792d427e45f64" translate="yes" xml:space="preserve">
          <source>Helper variable template</source>
          <target state="translated">辅助变量模板</target>
        </trans-unit>
        <trans-unit id="777d2c2c6fac9bb59d841ec60aa0bce62ce73ffb" translate="yes" xml:space="preserve">
          <source>Helper variable templates</source>
          <target state="translated">辅助变量模板</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="7023d54552e06b34cfb338ed903ce5341dc89c1a" translate="yes" xml:space="preserve">
          <source>Here &amp;mu; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;mean&lt;/a&gt; and &amp;sigma; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;standard deviation&lt;/a&gt; (</source>
          <target state="translated">这里的&amp;mu;是&lt;a href=&quot;https://en.wikipedia.org/wiki/Mean&quot;&gt;平均值，&lt;/a&gt;而&amp;sigma;是&lt;a href=&quot;https://en.wikipedia.org/wiki/Standard_deviation&quot;&gt;标准偏差&lt;/a&gt;（</target>
        </trans-unit>
        <trans-unit id="de582de9c63661c059dbbb7442ed40762e356594" translate="yes" xml:space="preserve">
          <source>Here the sequence &lt;code&gt;= 0&lt;/code&gt; is known as pure-specifier, and appears either immediately after the declarator or after the optional virt-specifier (&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;).</source>
          <target state="translated">这里的序列 &lt;code&gt;= 0&lt;/code&gt; 被称为pure-specifier，出现在声明符之后或可选的virt-specifier之后（&lt;a href=&quot;override&quot;&gt;override&lt;/a&gt;或&lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f4d46b65d1ca1962518c48c70d9aa7c8452f90c5" translate="yes" xml:space="preserve">
          <source>Here, &lt;b&gt;insertion&lt;/b&gt; refers to any method which adds one or more elements to the container and &lt;b&gt;erasure&lt;/b&gt; refers to any method which removes one or more elements from the container.</source>
          <target state="translated">在此，&lt;b&gt;插入&lt;/b&gt;是指将一个或多个元素添加到容器的任何方法，&lt;b&gt;擦除&lt;/b&gt;是指从容器中移除一个或多个元素的任何方法。</target>
        </trans-unit>
        <trans-unit id="b19a132f13926967d1824a2efe39a0ee64381eb2" translate="yes" xml:space="preserve">
          <source>Hermite polynomials</source>
          <target state="translated">赫米特多项式</target>
        </trans-unit>
        <trans-unit id="2dc4f9ad06827dbb0f947199ccb4b57ddbc18030" translate="yes" xml:space="preserve">
          <source>Hexadecimal escape sequences have no length limit and terminate at the first character that is not a valid hexadecimal digit. If the value represented by a single hexadecimal escape sequence does not fit the range of values represented by the character type used in this string literal (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, or &lt;code&gt;wchar_t&lt;/code&gt;), the result is unspecified.</source>
          <target state="translated">十六进制转义序列没有长度限制，并且终止于不是有效十六进制数字的第一个字符。如果由单个十六进制转义序列表示的值不适合此字符串文字（ &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;char16_t&lt;/code&gt; ， &lt;code&gt;char32_t&lt;/code&gt; 或 &lt;code&gt;wchar_t&lt;/code&gt; ）中使用的字符类型表示的值的范围，则结果不确定。</target>
        </trans-unit>
        <trans-unit id="29f4576900e04b4bdfd8b4fe7f982605474c3863" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating literals</source>
          <target state="translated">十六进制浮动字数</target>
        </trans-unit>
        <trans-unit id="fcb2d1955da83c672014766fe096b6618bd4cc33" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point formatting ignores the stream precision specification, as required by the specification of &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">十六进制浮点格式会忽略流精度规范，这是 &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; 规范所要求的。</target>
        </trans-unit>
        <trans-unit id="903711dad7d075316de1f7c8c822711821173306" translate="yes" xml:space="preserve">
          <source>Higher level memory management utilities</source>
          <target state="translated">更高级别的内存管理实用程序</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="0201fd3572c6260109888327f99b40b98e8c814b" translate="yes" xml:space="preserve">
          <source>History of C++</source>
          <target state="translated">C++的历史</target>
        </trans-unit>
        <trans-unit id="9c025e64c93f51353b31decb167c0c14635a6990" translate="yes" xml:space="preserve">
          <source>Host is unreachable</source>
          <target state="translated">主机无法连接</target>
        </trans-unit>
        <trans-unit id="96e08c08807a48c02c8a25b2e222a3aa87859604" translate="yes" xml:space="preserve">
          <source>Hour, minute, second</source>
          <target state="translated">时、分、秒</target>
        </trans-unit>
        <trans-unit id="a84d5827435e6eaee2628507f60c486924602e72" translate="yes" xml:space="preserve">
          <source>However if &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; no applications of the predicate are made.</source>
          <target state="translated">但是，如果 &lt;code&gt;ForwardIt1&lt;/code&gt; 和 &lt;code&gt;ForwardIt2&lt;/code&gt; 满足&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;和 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) != &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; 不会对该谓词进行任何应用。</target>
        </trans-unit>
        <trans-unit id="06e6faa2b0497056bfffbc66aaba9ed450e5ff3a" translate="yes" xml:space="preserve">
          <source>However, all C++ compilers use &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;two's complement&lt;/a&gt; representation, and as of C++20, it is the only representation allowed by the standard, with the guaranteed range from -2N-1</source>
          <target state="translated">但是，所有C ++编译器都使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;二进制补码&lt;/a&gt;表示形式，从C ++ 20开始，它是标准所允许的唯一表示形式，保证范围为-2N-1</target>
        </trans-unit>
        <trans-unit id="a5298c4b4732ec5cdb50753f0b7bff99ff4504e8" translate="yes" xml:space="preserve">
          <source>However, base class subobjects are not so constrained, and can be completely optimized out from the object layout:</source>
          <target state="translated">但是,基类子对象就没有这么多约束,完全可以从对象布局中优化出来。</target>
        </trans-unit>
        <trans-unit id="0474028c83ae02e6c1719cbd200f19338eb23c2e" translate="yes" xml:space="preserve">
          <source>However, for non-&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;, the number of iterator increments is O(N).</source>
          <target state="translated">但是，对于非&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;，迭代器增量的数量为O（N）。</target>
        </trans-unit>
        <trans-unit id="a7074ce423985ae2c548c5817d3af2b722ab809a" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;BidirIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">但是，如果 &lt;code&gt;BidirIt&lt;/code&gt; 另外符合要求&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;，复杂性是恒定的。</target>
        </trans-unit>
        <trans-unit id="c130fc889986236f01e7bd0a7491d9e506116625" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; and &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; then no applications of the predicate are made (size mismatch is detected without looking at any elements).</source>
          <target state="translated">但是，如果 &lt;code&gt;InputIt1&lt;/code&gt; 和 &lt;code&gt;InputIt2&lt;/code&gt; 满足要求&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;和 &lt;code&gt;last1 - first1 != last2 - first2&lt;/code&gt; （在不看任何元素检测到大小不匹配），则没有谓词的应用程序制成。</target>
        </trans-unit>
        <trans-unit id="d4de2084e6a7ba7c4a9702f5d91188f9754f96a6" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">但是，如果 &lt;code&gt;InputIt&lt;/code&gt; 另外符合要求&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;，复杂性是恒定的。</target>
        </trans-unit>
        <trans-unit id="923af777ec78d98d0a47fdd5e9f0c732405eb150" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;InputIt&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt; additionally meets the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, complexity is constant.</source>
          <target state="translated">但是，如果 &lt;code&gt;InputIt&lt;/code&gt; 或 &lt;code&gt;ForwardIt&lt;/code&gt; 另外符合要求&lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;，复杂性是恒定的。</target>
        </trans-unit>
        <trans-unit id="789aa7b03048a6d89e55166c2876d111a76287b2" translate="yes" xml:space="preserve">
          <source>However, if deduction succeeds for all parameters that participate in template argument deduction, and all template arguments that aren't deduced are explicitly specified or defaulted, then the remaining function parameters are compared with the corresponding function arguments. For each remaining parameter &lt;code&gt;P&lt;/code&gt; with a type that was non-dependent before substitution of any explicitly-specified template arguments, if the corresponding argument &lt;code&gt;A&lt;/code&gt; cannot be implicitly converted to &lt;code&gt;P&lt;/code&gt;, deduction fails.</source>
          <target state="translated">但是，如果对参与模板参数推导的所有参数的推导成功，并且未指定或默认未推导的所有模板参数，则将其余函数参数与相应的函数参数进行比较。对于每个剩余参数 &lt;code&gt;P&lt;/code&gt; ，其类型在替换任何明确指定的模板参数之前都是非依赖的，如果不能将对应的参数 &lt;code&gt;A&lt;/code&gt; 隐式转换为 &lt;code&gt;P&lt;/code&gt; ，则推导将失败。</target>
        </trans-unit>
        <trans-unit id="d3ec3f026f2aba3bad033eb828adf9c63839692d" translate="yes" xml:space="preserve">
          <source>However, if the declaration uses &lt;a href=&quot;constexpr&quot;&gt;&lt;code&gt;constexpr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;(since C++17) specifier, the member must be declared to have complete type.</source>
          <target state="translated">但是，如果声明使用&lt;a href=&quot;constexpr&quot;&gt; &lt;code&gt;constexpr&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt;（自C ++ 17起）说明符，则必须声明该成员具有完整类型。</target>
        </trans-unit>
        <trans-unit id="9217191a146bae3519a7a8c89cf7f10d4b0ff050" translate="yes" xml:space="preserve">
          <source>However, one implementation (libc++) is known to construct the &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; objects via two separate allocator &lt;code&gt;construct()&lt;/code&gt; calls, as arguably required by the standards as published, rather than emplacing a &lt;code&gt;value_type&lt;/code&gt; object.</source>
          <target state="translated">但是，已知一种实现（libc ++）可以通过两个单独的分配器 &lt;code&gt;construct()&lt;/code&gt; 调用来构造 &lt;code&gt;key_type&lt;/code&gt; 和 &lt;code&gt;mapped_type&lt;/code&gt; 对象，这是已发布的标准所要求的，而不是包含 &lt;code&gt;value_type&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="9b2db98636723bfe7992740aadfd807719cd51f4" translate="yes" xml:space="preserve">
          <source>However, the attributes that appear after the declarator (in the syntax above), apply to the type of the function, not to the function itself.</source>
          <target state="translated">然而,出现在声明者后面的属性(在上面的语法中),适用于函数的类型,而不是函数本身。</target>
        </trans-unit>
        <trans-unit id="dff18122d5fc3679e0217a5ccca9f25c585e46ac" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">双曲余弦是复平面中的一个完整函数，没有分支切口。对于虚分量，它是周期性的，周期为2&amp;pi;i。</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">双曲函数</target>
        </trans-unit>
        <trans-unit id="a05dc25b96449633c73f65c5aa0e18f13e31788b" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine is an entire function in the complex plane and has no branch cuts. It is periodic with respect to the imaginary component, with period 2&amp;pi;i.</source>
          <target state="translated">双曲正弦是复平面中的一个完整函数，没有分支切口。对于虚分量，它是周期性的，周期为2&amp;pi;i。</target>
        </trans-unit>
        <trans-unit id="c6a249eb7c58320fe1bb3e19e6e61f7ae663bb92" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent is an analytical function on the complex plain and has no branch cuts. It is periodic with respect to the imaginary component, with period &amp;pi;i, and has poles of the first order along the imaginary line, at coordinates (0, &amp;pi;(1/2 + n)). However no common floating-point representation is able to represent &amp;pi;/2 exactly, thus there is no value of the argument for which a pole error occurs.</source>
          <target state="translated">双曲正切是复杂平原上的解析函数，没有分支切口。它相对于虚分量具有周期&amp;pi;i是周期性的，并且在坐标（0，&amp;pi;（1/2 + n））处具有沿虚线的一阶极点。但是，没有通用的浮点表示法能够精确地表示&amp;pi;/ 2，因此不存在发生极点误差的参数值。</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="6b58ece8e2eb85355e743b6e1a72cb6eb0c30006" translate="yes" xml:space="preserve">
          <source>I/O Manipulators</source>
          <target state="translated">I/O操纵器</target>
        </trans-unit>
        <trans-unit id="0676b814ab2a9d403059287e94b18b3f3ed5e63c" translate="yes" xml:space="preserve">
          <source>I/O error</source>
          <target state="translated">I/O错误</target>
        </trans-unit>
        <trans-unit id="3fd6cee6dbc10d47db1d5e293da18cd3279cfd34" translate="yes" xml:space="preserve">
          <source>I/O format flags are obtained, as if by</source>
          <target state="translated">获得I/O格式标志,就像通过</target>
        </trans-unit>
        <trans-unit id="00a1147221fe28724b5d852d3cc11debd18ea881" translate="yes" xml:space="preserve">
          <source>IBM XL C/C++ Inline Assembly</source>
          <target state="translated">IBM XL C/C++内联汇编</target>
        </trans-unit>
        <trans-unit id="97e6907b70a51197746c7a59244053494e95092c" translate="yes" xml:space="preserve">
          <source>ICE</source>
          <target state="translated">ICE</target>
        </trans-unit>
        <trans-unit id="2eb6372a578be72d248c4e343e8fc7a5d78b9a77" translate="yes" xml:space="preserve">
          <source>IEC 60559 recommends that &lt;code&gt;from&lt;/code&gt; is returned whenever &lt;code&gt;from==to&lt;/code&gt;. These functions return &lt;code&gt;to&lt;/code&gt; instead, which makes the behavior around zero consistent: &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; returns &lt;code&gt;+0.0&lt;/code&gt; and &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; returns &lt;code&gt;&amp;ndash;0.0&lt;/code&gt;.</source>
          <target state="translated">IEC 60559建议 &lt;code&gt;from&lt;/code&gt; 返回时 &lt;code&gt;from==to&lt;/code&gt; 。这些函数返回 &lt;code&gt;to&lt;/code&gt; 代替，这使得围绕零一致的行为： &lt;code&gt;std::nextafter(-0.0, +0.0)&lt;/code&gt; 返回 &lt;code&gt;+0.0&lt;/code&gt; 和 &lt;code&gt;std::nextafter(+0.0, -0.0)&lt;/code&gt; 的回报 &lt;code&gt;&amp;ndash;0.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7d95a8939f16c4020223847e17e36720cebf2bb9" translate="yes" xml:space="preserve">
          <source>IEEE-754</source>
          <target state="translated">IEEE-754</target>
        </trans-unit>
        <trans-unit id="42d5d0fd7522f477e6c48c8cc234d0d9ab04dea9" translate="yes" xml:space="preserve">
          <source>ILP32</source>
          <target state="translated">ILP32</target>
        </trans-unit>
        <trans-unit id="bb6e7841dba2c83d7f4685d9f749f0a969927ab9" translate="yes" xml:space="preserve">
          <source>INFINITY</source>
          <target state="translated">INFINITY</target>
        </trans-unit>
        <trans-unit id="0c47ba7d876463299943e6f3c404bf80428ff851" translate="yes" xml:space="preserve">
          <source>INT8_CINT16_CINT32_CINT64_C</source>
          <target state="translated">INT8_CINT16_CINT32_CINT64_C</target>
        </trans-unit>
        <trans-unit id="9ea288f9428eb0424cc8044a5b63c8eac0420d9a" translate="yes" xml:space="preserve">
          <source>INT8_MAXINT16_MAXINT32_MAXINT64_MAX</source>
          <target state="translated">INT8_MAXINT16_MAXINT32_MAXINT64_MAX</target>
        </trans-unit>
        <trans-unit id="bc5a628cd596773389eaaf98a83bf94ceac150f9" translate="yes" xml:space="preserve">
          <source>INT8_MININT16_MININT32_MININT64_MIN</source>
          <target state="translated">INT8_MININT16_MININT32_MININT64_MIN</target>
        </trans-unit>
        <trans-unit id="f9102afc9b1d8d90bfec23471f9597ad0cf050e9" translate="yes" xml:space="preserve">
          <source>INTMAX_C</source>
          <target state="translated">INTMAX_C</target>
        </trans-unit>
        <trans-unit id="aefed58e7c3b20f7462bf747350723518bd7f3f5" translate="yes" xml:space="preserve">
          <source>INTMAX_MAX</source>
          <target state="translated">INTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="a349d125102eeb5388d505c737ca6ccb840fc470" translate="yes" xml:space="preserve">
          <source>INTMAX_MIN</source>
          <target state="translated">INTMAX_MIN</target>
        </trans-unit>
        <trans-unit id="a8b82d9c693483b9795a47d286279f7fe077830a" translate="yes" xml:space="preserve">
          <source>INTPTR_MAX</source>
          <target state="translated">INTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="ea1e73a8ba1358e9d441c380ac5a64aadd6313f9" translate="yes" xml:space="preserve">
          <source>INTPTR_MIN</source>
          <target state="translated">INTPTR_MIN</target>
        </trans-unit>
        <trans-unit id="cb3002d9d4b8d1bb4ad6b3fb3f8ee0eb1cd9e1b9" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</source>
          <target state="translated">INT_FAST8_MAXINT_FAST16_MAXINT_FAST32_MAXINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="5c002bd42be6d97da6ee9fd6a8de846f49b7760c" translate="yes" xml:space="preserve">
          <source>INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</source>
          <target state="translated">INT_FAST8_MININT_FAST16_MININT_FAST32_MININT_FAST64_MIN</target>
        </trans-unit>
        <trans-unit id="81b4c2799073b036b71feb59eff38c668d0be8e4" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</source>
          <target state="translated">INT_LEAST8_MAXINT_LEAST16_MAXINT_LEAST32_MAXINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="303ab3b780f2f436597e803172a659d338cb695a" translate="yes" xml:space="preserve">
          <source>INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</source>
          <target state="translated">INT_LEAST8_MININT_LEAST16_MININT_LEAST32_MININT_LEAST64_MIN</target>
        </trans-unit>
        <trans-unit id="47a57f6b8f5e7dac870d669f2d10489423c2c097" translate="yes" xml:space="preserve">
          <source>INVERTED UNDERTIE</source>
          <target state="translated">倒立的内衣</target>
        </trans-unit>
        <trans-unit id="6f332e7bc9fb4c964cc115b4bb4e0c9c81b651a9" translate="yes" xml:space="preserve">
          <source>INVOKE</source>
          <target state="translated">INVOKE</target>
        </trans-unit>
        <trans-unit id="bfa0e3fd8d2d6bf8a03a66ca3906291682906b88" translate="yes" xml:space="preserve">
          <source>INVOKE&amp;lt;R&amp;gt;(f, t1, t2, ..., tN)</source>
          <target state="translated">调用&amp;lt;R&amp;gt;（f，t1，t2，...，tN）</target>
        </trans-unit>
        <trans-unit id="381dd7d678830c863bcf610275aa82caf553b63a" translate="yes" xml:space="preserve">
          <source>INVOKE(f, t1, t2, ..., tN)</source>
          <target state="translated">INVOKE(f,t1,t2,...,tN)</target>
        </trans-unit>
        <trans-unit id="b7d04a533ba2785a0158159ad98ad6ef6b754b06" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX control characters as Unicode characters U+0000..U+001F, U+007F..U+009F, U+2028, and U+2029 (Unicode classes Cc, Zl, and Zp).</source>
          <target state="translated">ISO 30112将POSIX控制字符定义为U+0000...U+001F、U+007F...U+009F、U+2028和U+2029(Unicode类Cc、Zl和Zp)。</target>
        </trans-unit>
        <trans-unit id="fff375c325eb5a33dd2e39fc8434af17d533adb3" translate="yes" xml:space="preserve">
          <source>ISO 30112 defines POSIX space characters as Unicode characters U+0009..U+000D, U+0020, U+1680, U+180E, U+2000..U+2006, U+2008..U+200A, U+2028, U+2029, U+205F, and U+3000.</source>
          <target state="translated">ISO 30112定义POSIX空间字符为U+0009...U+000D、U+0020、U+1680、U+180E、U+2000...U+2006、U+2008...U+200A、U+2028、U+2029、U+205F和U+3000等Unicode字符。</target>
        </trans-unit>
        <trans-unit id="83c8d536c17446dc8d23f11cf08547ab6f0ceaef" translate="yes" xml:space="preserve">
          <source>ISO 8601 week-based year</source>
          <target state="translated">ISO 8601以星期为单位的年份</target>
        </trans-unit>
        <trans-unit id="660c1f28ee4e6a1155a4515d1d3d38f625034fe8" translate="yes" xml:space="preserve">
          <source>ISO C language standard requires that C compilers support the following three pragmas, and some C++ compiler vendors support them, to varying degrees, in their C++ frontends:</source>
          <target state="translated">ISO C语言标准要求C编译器支持以下三种语法,一些C++编译器厂商在其C++前端中不同程度地支持这些语法。</target>
        </trans-unit>
        <trans-unit id="f0de3ffcac31393cdc320a257a71c6856ecd9b41" translate="yes" xml:space="preserve">
          <source>Identical to the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;Container::emplace_back&lt;/code&gt; 的复杂性相同。</target>
        </trans-unit>
        <trans-unit id="7c1a745105ff9b6c357cf50bdd91090ffef6ae55" translate="yes" xml:space="preserve">
          <source>Identifier removed</source>
          <target state="translated">标识符已删除</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
