<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="7e427ab8b4862191565a1a29a01d981f9c08b30f" translate="yes" xml:space="preserve">
          <source>Increment and decrement</source>
          <target state="translated">递增和递减</target>
        </trans-unit>
        <trans-unit id="cfe414b6ddcaa8292d016a5a3592ec3f7ea7fada" translate="yes" xml:space="preserve">
          <source>Increment and decrement operators are overloaded for many standard library types. In particular, every &lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt; overloads operator++ and every &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; overloads operator--, even if those operators are no-ops for the particular iterator.</source>
          <target state="translated">对于许多标准库类型，递增和递减运算符是重载的。特别是，每个&lt;a href=&quot;../named_req/iterator&quot;&gt;LegacyIterator&lt;/a&gt;重载operator ++，每个&lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;重载operator--，即使这些运算符对于特定的迭代器而言都是无操作的。</target>
        </trans-unit>
        <trans-unit id="f17d70be0f16733c0dc8c67eabfb624d43b60216" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators</source>
          <target state="translated">增/减运算符</target>
        </trans-unit>
        <trans-unit id="cc787748953bd4e94e67cc95ac787d4d3cfb9a68" translate="yes" xml:space="preserve">
          <source>Increment/decrement operators increment or decrement the value of the object.</source>
          <target state="translated">增/减运算符增加或减少对象的值。</target>
        </trans-unit>
        <trans-unit id="0f9b5e452f10a6b34da1fb48e02ee30bd5033db1" translate="yes" xml:space="preserve">
          <source>Incrementable</source>
          <target state="translated">Incrementable</target>
        </trans-unit>
        <trans-unit id="cc5ea811af56aeeaf46a0c9737e89031c9af2a17" translate="yes" xml:space="preserve">
          <source>Increments given iterator &lt;code&gt;it&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; elements.</source>
          <target state="translated">鉴于增量迭代 &lt;code&gt;it&lt;/code&gt; 由 &lt;code&gt;n&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="e3348f80bc84ba16802159a506f193e84a80b03d" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator.</source>
          <target state="translated">递增或递减迭代器。</target>
        </trans-unit>
        <trans-unit id="84c43591c7009c31f153f3e91418e222e8d0fdab" translate="yes" xml:space="preserve">
          <source>Increments or decrements the iterator. Inverse operations are applied to the underlying operator because of the reverse order.</source>
          <target state="translated">增加或减少迭代器。因为顺序相反,所以对底层运算符进行了逆运算。</target>
        </trans-unit>
        <trans-unit id="39764a20978ad7b2e0a6b9bd65f20bac9b65b929" translate="yes" xml:space="preserve">
          <source>Increments or decrements the number of ticks for this duration.</source>
          <target state="translated">增加或减少该持续时间的滴答次数。</target>
        </trans-unit>
        <trans-unit id="910224cadb5c448e8d25dd0213abaae95c58e5ea" translate="yes" xml:space="preserve">
          <source>Index into the array pointed to by the stored pointer.</source>
          <target state="translated">存储指针指向的数组的索引。</target>
        </trans-unit>
        <trans-unit id="9d3b08115f1b71f8141facbb6d5edfd271773b19" translate="yes" xml:space="preserve">
          <source>Indicated by a trailing &lt;code&gt;...&lt;/code&gt;(other than one introducing a pack expansion)(since C++11) following the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="translated">由&lt;a href=&quot;function&quot;&gt;函数声明&lt;/a&gt;的参数列表后面的尾随 &lt;code&gt;...&lt;/code&gt; （不包括引入包扩展的一个）（自C ++ 11起）表示。</target>
        </trans-unit>
        <trans-unit id="d49ada4a4f9e6394d6c031cdd3db87968627070f" translate="yes" xml:space="preserve">
          <source>Indicated by using the following syntax for a parameter in the parameter-list of a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;.</source>
          <target state="translated">通过对&lt;a href=&quot;function&quot;&gt;函数声明&lt;/a&gt;的parameter-list中的参数使用以下语法来表示。</target>
        </trans-unit>
        <trans-unit id="1712d2e8f937518e01b0931bd205206ed1a8017a" translate="yes" xml:space="preserve">
          <source>Indicates if the match results are ready (valid) or not.</source>
          <target state="translated">表示匹配结果是否已准备好(有效)。</target>
        </trans-unit>
        <trans-unit id="05d56af25aa45704ec160c601a10df5e1c115f08" translate="yes" xml:space="preserve">
          <source>Indicates if this match was successful</source>
          <target state="translated">表示本次匹配是否成功。</target>
        </trans-unit>
        <trans-unit id="fb13d85a03c61cb1a77aee405db444e1e7dd0d1e" translate="yes" xml:space="preserve">
          <source>Indicates that dependency chain in release-consume &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.</source>
          <target state="translated">指示release-consume &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; 中的依赖项链传入和传出函数，这使编译器可以跳过不必要的内存围栏指令。</target>
        </trans-unit>
        <trans-unit id="b1eef975978a88d290550921db3dd4b23de6ed3c" translate="yes" xml:space="preserve">
          <source>Indicates that the fall through from the previous case label is intentional and should not be diagnosed by a compiler that warns on fallthrough.</source>
          <target state="translated">表示从前面的案例标签中掉过是故意的,不应该被编译器诊断为掉过警告。</target>
        </trans-unit>
        <trans-unit id="07a894f6f65f599ff826de67eb639e25aa960be1" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;.</source>
          <target state="translated">指示应优化函数定义以从&lt;a href=&quot;../transactional_memory&quot;&gt;同步语句&lt;/a&gt;调用。</target>
        </trans-unit>
        <trans-unit id="404bc23b0c3c1dc2dde1e96665adb2a133cb2f1a" translate="yes" xml:space="preserve">
          <source>Indicates that the function definition should be optimized for invocation from a &lt;a href=&quot;../transactional_memory&quot;&gt;synchronized statement&lt;/a&gt;. In particular, it avoids serializing synchronized blocks that make a call to a function that is transaction-safe for the majority of calls, but not for all calls.</source>
          <target state="translated">指示应优化函数定义以从&lt;a href=&quot;../transactional_memory&quot;&gt;同步语句&lt;/a&gt;调用。特别是，它避免了对同步块进行序列化，这些块对大多数调用而不是所有调用都具有事务安全性的函数进行调用。</target>
        </trans-unit>
        <trans-unit id="3763a0ac1424ab7603605b2e6e73c73516778f16" translate="yes" xml:space="preserve">
          <source>Indicates that the function does not return.</source>
          <target state="translated">表示该函数不返回。</target>
        </trans-unit>
        <trans-unit id="aadf5ff318f6e9ff51544f26ee3de70c127e4ff5" translate="yes" xml:space="preserve">
          <source>Indicates that the name or entity declared with this attribute is &lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;deprecated&lt;/a&gt;, that is, the use is allowed, but discouraged for some reason.</source>
          <target state="translated">指示&lt;a href=&quot;https://en.wikipedia.org/wiki/Deprecation&quot;&gt;不赞成&lt;/a&gt;使用此属性声明的名称或实体，即，允许使用，但由于某些原因不鼓励使用。</target>
        </trans-unit>
        <trans-unit id="eb1d4e9c5ff0d33dedb5c76e1e3e0a72c774ec1e" translate="yes" xml:space="preserve">
          <source>Indicates that the use of the name or entity declared with this attribute is allowed, but discouraged for some reason. Compilers typically issue warnings on such uses. The string-literal, if specified, is usually included in the warnings.</source>
          <target state="translated">表示允许使用用该属性声明的名称或实体,但出于某种原因不鼓励使用。编译器通常会对这种使用发出警告。如果指定了字符串,通常会被列入警告中。</target>
        </trans-unit>
        <trans-unit id="1b877dccdb68430deec81ae5c7d0c2899c1a04b6" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class.</source>
          <target state="translated">表示该数据成员不需要有一个不同于其类中所有其他非静态数据成员的地址。</target>
        </trans-unit>
        <trans-unit id="6a97cea227e92a547c1dd0162d3c17f7d0180b0c" translate="yes" xml:space="preserve">
          <source>Indicates that this data member need not have an address distinct from all other non-static data members of its class. This means that if the member has an empty type (e.g. stateless Allocator), the compiler may optimise it to occupy no space, just like if it were an &lt;a href=&quot;../ebo&quot;&gt;empty base&lt;/a&gt;. If the member is not empty, any tail padding in it may be also reused to store other data members.</source>
          <target state="translated">指示此数据成员不必具有与该类的所有其他非静态数据成员不同的地址。这意味着，如果成员具有空类型（例如，无状态的分配器），则编译器可以对其进行优化以使其不占用任何空间，就像它是一个&lt;a href=&quot;../ebo&quot;&gt;空的base一样&lt;/a&gt;。如果成员不为空，则其中的任何尾部填充也可以重新用于存储其他数据成员。</target>
        </trans-unit>
        <trans-unit id="7e16e5df080d66d35fd0fc9ce14ca2cddaaf531e" translate="yes" xml:space="preserve">
          <source>Indicates the endianness of all &lt;a href=&quot;../language/type-id&quot;&gt;scalar types&lt;/a&gt;:</source>
          <target state="translated">指示所有&lt;a href=&quot;../language/type-id&quot;&gt;标量类型&lt;/a&gt;的字节序：</target>
        </trans-unit>
        <trans-unit id="b7ced8b89669e17290208433d069c305c4668cd4" translate="yes" xml:space="preserve">
          <source>Indirect access</source>
          <target state="translated">间接进入</target>
        </trans-unit>
        <trans-unit id="945f4467f9e3980b9bc435c192be55e1cdba33ac" translate="yes" xml:space="preserve">
          <source>Indirect callable concepts</source>
          <target state="translated">间接可调用的概念</target>
        </trans-unit>
        <trans-unit id="615d0df84a8bde5c3b3b45942556ad9ee41f5c88" translate="yes" xml:space="preserve">
          <source>IndirectRelation</source>
          <target state="translated">IndirectRelation</target>
        </trans-unit>
        <trans-unit id="a517704fa906449a7f15a8ece89573834bd716d4" translate="yes" xml:space="preserve">
          <source>IndirectStrictWeakOrder</source>
          <target state="translated">IndirectStrictWeakOrder</target>
        </trans-unit>
        <trans-unit id="4fd88b3054ecad93f1a95a527c3891631b31f23d" translate="yes" xml:space="preserve">
          <source>IndirectUnaryInvocableIndirectRegularUnaryInvocable</source>
          <target state="translated">IndirectUnaryInvocableIndirectRegularUnaryInvocable</target>
        </trans-unit>
        <trans-unit id="d4d035f7c30e113629f27edd40bf70e82d6284b2" translate="yes" xml:space="preserve">
          <source>IndirectUnaryPredicate</source>
          <target state="translated">IndirectUnaryPredicate</target>
        </trans-unit>
        <trans-unit id="1ba4d5bf8c849bf8c04b9c6e21cc8e1df44157c8" translate="yes" xml:space="preserve">
          <source>Indirection through a pointer that became invalid in this manner and passing it to a deallocation function (double-delete) is undefined behavior. Any other use is implementation-defined.</source>
          <target state="translated">通过一个以这种方式变得无效的指针进行定向,并将其传递给deallocation函数(双删除)是未定义的行为。任何其他用途都是实现定义的。</target>
        </trans-unit>
        <trans-unit id="fc6c8e1f0dc3858c691ccb1300793e524ab1874b" translate="yes" xml:space="preserve">
          <source>Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has implementation-defined behavior.</source>
          <target state="translated">通过无效指针值进行定向和将无效指针值传递给deallocation函数具有未定义的行为。任何其他使用无效指针值的行为都是由实现定义的。</target>
        </trans-unit>
        <trans-unit id="caa250f6b40fd31e6e435ad3ec42b55df8c15198" translate="yes" xml:space="preserve">
          <source>IndirectlyComparable</source>
          <target state="translated">IndirectlyComparable</target>
        </trans-unit>
        <trans-unit id="79246d49d2de7bde0e84161dfa390e35ead80dbb" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyable</source>
          <target state="translated">IndirectlyCopyable</target>
        </trans-unit>
        <trans-unit id="c1b4de1846b6ae50bbf1bb567d1c5423353b3f7c" translate="yes" xml:space="preserve">
          <source>IndirectlyCopyableStorable</source>
          <target state="translated">IndirectlyCopyableStorable</target>
        </trans-unit>
        <trans-unit id="4f10a919177009406f024b0a5f8b598cade73a1d" translate="yes" xml:space="preserve">
          <source>IndirectlyMovable</source>
          <target state="translated">IndirectlyMovable</target>
        </trans-unit>
        <trans-unit id="be4b7238e8cf0d8749bb2f509a225195d878018a" translate="yes" xml:space="preserve">
          <source>IndirectlyMovableStorable</source>
          <target state="translated">IndirectlyMovableStorable</target>
        </trans-unit>
        <trans-unit id="1fb085c0bd571e7f0dafcbf700d51d838a32da50" translate="yes" xml:space="preserve">
          <source>IndirectlySwappable</source>
          <target state="translated">IndirectlySwappable</target>
        </trans-unit>
        <trans-unit id="b5f6e97cd4faf7045970097d59a8c5be90de03ff" translate="yes" xml:space="preserve">
          <source>Inexact result</source>
          <target state="translated">不精确的结果</target>
        </trans-unit>
        <trans-unit id="98df9b88a5e801dd458f9dea0b5eb524b074282a" translate="yes" xml:space="preserve">
          <source>Infinite loop without side-effects</source>
          <target state="translated">无限循环,无副作用</target>
        </trans-unit>
        <trans-unit id="8f1b65e86ba58e7d09ad5b638567441248d44fd1" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts a subset of the types that B accepts&quot;.</source>
          <target state="translated">非正式的 &quot;A比B更专业 &quot;是指 &quot;A接受B接受的类型的子集&quot;。</target>
        </trans-unit>
        <trans-unit id="8e26416412a250dc41f16163d325bfe0d9375649" translate="yes" xml:space="preserve">
          <source>Informally &quot;A is more specialized than B&quot; means &quot;A accepts fewer types than B&quot;.</source>
          <target state="translated">非正式的 &quot;A比B更专业 &quot;是指 &quot;A接受的类型比B少&quot;。</target>
        </trans-unit>
        <trans-unit id="837818b163877df19b00b59309303eba5812d227" translate="yes" xml:space="preserve">
          <source>Informally, an object is odr-used if its value is read (unless it is a compile time constant) or written, its address is taken, or a reference is bound to it; a reference is odr-used if it is used and its referent is not known at compile time; and a function is odr-used if a function call to it is made or its address is taken. If an object, a reference or a function is odr-used, its definition must exist somewhere in the program; a violation of that is usually a link-time error.</source>
          <target state="translated">在非正式的情况下,如果一个对象的值被读取(除非它是一个编译时的常量)或写入,它的地址被取走,或者一个引用被绑定到它上面,那么这个对象就是odr-used;如果一个引用被使用,而它的引用者在编译时不知道,那么这个引用就是odr-used;如果一个函数被调用,或者它的地址被取走,那么这个函数就是odr-used。如果一个对象、一个引用或一个函数被odr-used,它的定义必须存在于程序中的某个地方;违反这一点通常是一个链接时错误。</target>
        </trans-unit>
        <trans-unit id="c6ae6b7147966f4caadf3becb3a298c96ec40912" translate="yes" xml:space="preserve">
          <source>Informally, two types are</source>
          <target state="translated">非正式的,有两种类型</target>
        </trans-unit>
        <trans-unit id="37bbacc3d1827431eb0e90015863e8cd1f6d09b3" translate="yes" xml:space="preserve">
          <source>Informs the compiler that the dependency tree started by an &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; atomic load operation does not extend past the return value of &lt;code&gt;std::kill_dependency&lt;/code&gt;; that is, the argument does not carry a dependency into the return value.</source>
          <target state="translated">通知编译器以 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; 原子加载操作开始的依赖树未超过 &lt;code&gt;std::kill_dependency&lt;/code&gt; 的返回值；也就是说，该参数不将依赖项包含在返回值中。</target>
        </trans-unit>
        <trans-unit id="e9f0d94767eeb4fdf66bcb63f83f831a24817f3f" translate="yes" xml:space="preserve">
          <source>Informs the garbage collector or leak detector that the specified memory region (&lt;code&gt;n&lt;/code&gt; bytes beginning at the byte pointed to by &lt;code&gt;p&lt;/code&gt;) contains no traceable pointers. If any part of the region is within an allocated object, the entire region must be contained in the same object.</source>
          <target state="translated">通知垃圾收集器或泄漏检测器指定的内存区域（从 &lt;code&gt;p&lt;/code&gt; 指向的字节开始的 &lt;code&gt;n&lt;/code&gt; 个字节）不包含可跟踪的指针。如果区域的任何部分在分配的对象内，则整个区域必须包含在同一对象中。</target>
        </trans-unit>
        <trans-unit id="6b00d875f974811886ac196dcb915203f177f6a1" translate="yes" xml:space="preserve">
          <source>Informs the implementation that the object &lt;code&gt;ptr&lt;/code&gt; points to is aligned to at least &lt;code&gt;N&lt;/code&gt;. The implementation may use this information to generate more efficient code, but it might only make this assumption if the object is accessed via the return value of &lt;code&gt;assume_aligned&lt;/code&gt;.</source>
          <target state="translated">通知实现，对象 &lt;code&gt;ptr&lt;/code&gt; 指向的对象至少与 &lt;code&gt;N&lt;/code&gt; 对齐。实现可以利用这些信息来生成更高效的代码，但它可能只是做这样的假设，如果对象是通过返回值访问 &lt;code&gt;assume_aligned&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="24e63953e4f041a3bb4ac3148f230860861e7ff3" translate="yes" xml:space="preserve">
          <source>Inheritance diagram.</source>
          <target state="translated">继承图。</target>
        </trans-unit>
        <trans-unit id="43a9b1d67674ea8718fc711a00f7bb00fbb4c4df" translate="yes" xml:space="preserve">
          <source>Inherited copy and move constructors are not included in the list of candidate functions when constructing a derived class object.</source>
          <target state="translated">在构造派生类对象时,继承的复制和移动构造函数不包含在候选函数列表中。</target>
        </trans-unit>
        <trans-unit id="8f06971d5187bb5c21be32f180285afdb914b12b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../../../types/integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f30304d5307d8a19e13fb3ed0a2bac9d82e0a424" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../../error/exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01fe97cbbb0941b6f2a72d6bcbf5bf30c49dc7b1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179a5175974c4d0f1231cb42168b0c03c785293b" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../../error/system_error&quot;&gt;std :: system_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a80e3d34750b628e39956fcaf30d5d8a1ed24f4" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../../types/integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc3357171bb4abff2c5bcfa928f18def082a907c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../error/exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="30b72f9cdb58e5970783c671d3934c33faeb1623" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/logic_error/logic_error&quot;&gt; std::logic_error&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../error/logic_error/logic_error&quot;&gt;std :: logic_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="957863018da5b123ab6f6ee5e33f1ffffd93019e" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../error/runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4810ddaa7ee3800c8518272cbd3eab0a576e08e1" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../error/system_error&quot;&gt; std::system_error&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../error/system_error&quot;&gt;std :: system_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f42576c785a3be8154970999da87190cb9371f9" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1ff5d17ac32734b6c4b40b6f4b8d2dbbce7f1b33" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../types/integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../types/integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64a89d3879a72da7c6ee665cb1868939227a129a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;../utility/pair&quot;&gt; std::pair&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;../utility/pair&quot;&gt;std :: pair&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad227e6a5a2991b9ae2118d21b1ded53643ffeb6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;bad_alloc&quot;&gt; std::bad_alloc&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;bad_alloc&quot;&gt;std :: bad_alloc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0640747e62ff14ba1b29b108a996ca8f524d1b5a" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ios&quot;&gt; std::basic_ios&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;basic_ios&quot;&gt;std :: basic_ios&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="de0c89b89174954a9f92de2b010f4eba6cf65be6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_istream&quot;&gt; std::basic_istream&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;basic_istream&quot;&gt;std :: basic_istream&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5294336a5cb08c884f1c1c77c83e45be59fa6ba0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_ostream&quot;&gt; std::basic_ostream&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;basic_ostream&quot;&gt;std :: basic_ostream&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9055f46788224b7f31bcf6f24250ff5d47695175" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;basic_streambuf&quot;&gt; std::basic_streambuf&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;basic_streambuf&quot;&gt;std :: basic_streambuf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="538de0fbed9b76df7a6ab5144cdd294244e05923" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt&quot;&gt; std::codecvt&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;codecvt&quot;&gt;std :: codecvt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="691ededb623378951567ffd0bfa980099fbe3761" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;codecvt_base&quot;&gt; std::codecvt_base&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;codecvt_base&quot;&gt;std :: codecvt_base&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55051117752349a92484d2d68e1536f7ba751ac6" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;collate&quot;&gt; std::collate&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;collate&quot;&gt;std :: collat​​e&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="646bf27bfd425c0266f785460d8846b085490446" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;exception&quot;&gt; std::exception&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;exception&quot;&gt;std :: exception&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b1e16a440f913fb0c212304822e1171df74e082" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;integral_constant&quot;&gt; std::integral_constant&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;integral_constant&quot;&gt;std :: integral_constant&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d307388b240b50355fd55953eea3dcf640dd433" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;ios_base&quot;&gt; std::ios_base&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;ios_base&quot;&gt;std :: ios_base&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e507c076782fb8eb8b54d375f2f956f7369f545d" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;messages&quot;&gt; std::messages&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;messages&quot;&gt;std :: messages&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f67af012ab32d51632e38d03380caedc6cb1fd11" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;money_base&quot;&gt;std::money_base&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;money_base&quot;&gt;std :: money_base&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88842694e8b959006d435b6cad10e7a20f4f86fe" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;moneypunct&quot;&gt; std::moneypunct&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;moneypunct&quot;&gt;std :: moneypunct&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d17a29ada80f7d12d7692d7e6aaa8521d515613" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;numpunct&quot;&gt; std::numpunct&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;numpunct&quot;&gt;std :: numpunct&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96f6c2f33d9e5a486e8905be371715ec2d5e0e4c" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;runtime_error/runtime_error&quot;&gt; std::runtime_error&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;runtime_error/runtime_error&quot;&gt;std :: runtime_error&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7efc4c44fcbc8224af5b604f6ea179f896007df5" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_get&quot;&gt; std::time_get&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;time_get&quot;&gt;std :: time_get&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fda6ad022c33ce0f5b1400e8f343ad50076eeb0" translate="yes" xml:space="preserve">
          <source>Inherited from &lt;a href=&quot;time_put&quot;&gt; std::time_put&lt;/a&gt;</source>
          <target state="translated">继承自&lt;a href=&quot;time_put&quot;&gt;std :: time_put&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e7135edcc0660dff5ef07a7531f5a314d1a14345" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;CharT&amp;gt;</source>
          <target state="translated">继承自std :: ctype &amp;lt;CharT&amp;gt;</target>
        </trans-unit>
        <trans-unit id="96606dedfe0d1180adfbb7cf5dc6b000d690eeaa" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype&amp;lt;char&amp;gt;</source>
          <target state="translated">继承自std :: ctype &amp;lt;char&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6835bd4de94e4c8ff9fa81f21f0a45e937163c89" translate="yes" xml:space="preserve">
          <source>Inherited from std::ctype_base</source>
          <target state="translated">继承自std::ctype_base。</target>
        </trans-unit>
        <trans-unit id="2a9684185e4ab4b7acc08548b265978c0ac9b665" translate="yes" xml:space="preserve">
          <source>Inherited from std::messages_base</source>
          <target state="translated">继承于std::messages_base。</target>
        </trans-unit>
        <trans-unit id="ec11a5942722961cf6c8bf90cef0c0ab7cbfd804" translate="yes" xml:space="preserve">
          <source>Inherited from std::time_base</source>
          <target state="translated">继承自std::time_base。</target>
        </trans-unit>
        <trans-unit id="a162155e80acef2e40d64da7fae4b6cef737ccc3" translate="yes" xml:space="preserve">
          <source>Inheriting constructors</source>
          <target state="translated">继承构造函数</target>
        </trans-unit>
        <trans-unit id="ed212d227256484af63b60ae12f72487723786d7" translate="yes" xml:space="preserve">
          <source>Inheriting from empty base classes usually does not increase the size of a class due to &lt;a href=&quot;../language/ebo&quot;&gt;empty base optimization&lt;/a&gt;.</source>
          <target state="translated">由于&lt;a href=&quot;../language/ebo&quot;&gt;空基优化，&lt;/a&gt;从空基类继承通常不会增加类的大小。</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="f6e1e46e4baf5716e3220f3484c1af85b95e71c8" translate="yes" xml:space="preserve">
          <source>Initialization by constructor</source>
          <target state="translated">由构造者初始化</target>
        </trans-unit>
        <trans-unit id="d0105ebd75116f796a8152546a960d90f6068ea4" translate="yes" xml:space="preserve">
          <source>Initialization of &lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;function-local statics&lt;/a&gt; is guaranteed to occur only once even when called from multiple threads, and may be more efficient than the equivalent code using &lt;code&gt;std::call_once&lt;/code&gt;.</source>
          <target state="translated">即使从多个线程调用时，也保证&lt;a href=&quot;../language/storage_duration#Static_local_variables&quot;&gt;函数局部静态变量的&lt;/a&gt;初始化仅发生一次，并且可能比使用 &lt;code&gt;std::call_once&lt;/code&gt; 的等效代码更有效。</target>
        </trans-unit>
        <trans-unit id="d91f501eae2c832f1b0b7e4d4973d0855f66060e" translate="yes" xml:space="preserve">
          <source>Initialization order</source>
          <target state="translated">初始化顺序</target>
        </trans-unit>
        <trans-unit id="49fb3cd233b01d2f3fca6d231ff8868b279e8d64" translate="yes" xml:space="preserve">
          <source>Initialization to all bits zero does not guarantee that a floating-point or a pointer would be initialized to 0.0 and the null pointer value, respectively (although that is true on all common platforms).</source>
          <target state="translated">初始化为所有位为零并不能保证浮点或指针分别被初始化为0.0和空指针值(尽管在所有通用平台上都是如此)。</target>
        </trans-unit>
        <trans-unit id="6ea9d5c7645589c136d59cd57df44af49ce9783f" translate="yes" xml:space="preserve">
          <source>Initialization with a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; that contains embedded &lt;code&gt;'\0'&lt;/code&gt; characters uses the overload (5), which stops at the first null character. This can be avoided by specifying a different constructor or by using &lt;a href=&quot;operator_q__q_s&quot;&gt;&lt;code&gt;operator&quot;&quot;s&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">使用包含嵌入式 &lt;code&gt;'\0'&lt;/code&gt; 的&lt;a href=&quot;../../language/string_literal&quot;&gt;字符串文字进行&lt;/a&gt;初始化字符使用重载（5），该重载在第一个空字符处停止。通过指定其他构造函数或使用&lt;a href=&quot;operator_q__q_s&quot;&gt; &lt;code&gt;operator&quot;&quot;s&lt;/code&gt; &lt;/a&gt;可以避免这种情况：</target>
        </trans-unit>
        <trans-unit id="a8b6090f523a6604aaf83ad226d272f3e664763f" translate="yes" xml:space="preserve">
          <source>Initializer lists</source>
          <target state="translated">初始化器列表</target>
        </trans-unit>
        <trans-unit id="5205b0ca0f0fefcfe68c33103c2c9c1ce338c249" translate="yes" xml:space="preserve">
          <source>Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a &lt;code&gt;std::initializer_list&lt;/code&gt; does not copy the underlying objects.</source>
          <target state="translated">初始化程序列表可以实现为一对指针或指针和长度。复制 &lt;code&gt;std::initializer_list&lt;/code&gt; 不会复制基础对象。</target>
        </trans-unit>
        <trans-unit id="4cd615dbf08a4b7ea3976db14aee644d6937efce" translate="yes" xml:space="preserve">
          <source>Initializes an aggregate from braced-init-list.</source>
          <target state="translated">从 braced-init-list初始化一个集合。</target>
        </trans-unit>
        <trans-unit id="44dcbda2c857e660e975019d6dd123883526dd75" translate="yes" xml:space="preserve">
          <source>Initializes an object from another object.</source>
          <target state="translated">从另一个对象初始化一个对象。</target>
        </trans-unit>
        <trans-unit id="0d3ed04db9734c04b00626e83cd3a554c91216b4" translate="yes" xml:space="preserve">
          <source>Initializes an object from braced-init-list.</source>
          <target state="translated">从 braced-init-list初始化一个对象。</target>
        </trans-unit>
        <trans-unit id="b28ee811ef30d6e7a7f950db96ff44c9ab341ca0" translate="yes" xml:space="preserve">
          <source>Initializes an object from explicit set of constructor arguments.</source>
          <target state="translated">从显式构造函数参数集初始化一个对象。</target>
        </trans-unit>
        <trans-unit id="3612fbe04b3d4f902d2d49989872e1c625ef8e37" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;bound_&lt;/code&gt; with &lt;code&gt;bound&lt;/code&gt;.</source>
          <target state="translated">初始化仅博览会的数据成员 &lt;code&gt;bound_&lt;/code&gt; 使用 &lt;code&gt;bound&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e582f41fbe9142faa1edac6dc025f737e0f1efef" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;current_&lt;/code&gt; with &lt;code&gt;current&lt;/code&gt; and exposition-only data members &lt;code&gt;parent_&lt;/code&gt; with &lt;code&gt;addressof(parent)&lt;/code&gt;.</source>
          <target state="translated">仅初始化论述数据成员 &lt;code&gt;current_&lt;/code&gt; 与 &lt;code&gt;current&lt;/code&gt; 和阐述仅数据成员 &lt;code&gt;parent_&lt;/code&gt; 与 &lt;code&gt;addressof(parent)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="687eeb5c76107cbf76d277e107912b3a093ddbf0" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;end_&lt;/code&gt; with &lt;code&gt;parent&lt;/code&gt;.</source>
          <target state="translated">用 &lt;code&gt;parent&lt;/code&gt; 初始化仅博览会的数据成员 &lt;code&gt;end_&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45a2d2edd8a0c33265b1f7964c619dbe931e75f5" translate="yes" xml:space="preserve">
          <source>Initializes exposition-only data member &lt;code&gt;value_&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;. This value will be returned by operator* and incremented by operator++</source>
          <target state="translated">使用 &lt;code&gt;value&lt;/code&gt; 初始化仅 &lt;code&gt;value_&lt;/code&gt; 数据成员value_。此值将由operator *返回，并由operator ++递增</target>
        </trans-unit>
        <trans-unit id="3ed19383d0a866bf81dc2a8bf40d1563412b85cf" translate="yes" xml:space="preserve">
          <source>Initializes the</source>
          <target state="translated">初始化</target>
        </trans-unit>
        <trans-unit id="a8d332dbed9d2af60e29bd52e5cde6a80c7ad53b" translate="yes" xml:space="preserve">
          <source>Initializes the default-constructed atomic object &lt;code&gt;obj&lt;/code&gt; with the value &lt;code&gt;desired&lt;/code&gt;. The function is not atomic: concurrent access from another thread, even through an atomic operation, is a data race.</source>
          <target state="translated">使用 &lt;code&gt;desired&lt;/code&gt; 的值初始化默认构造的原子对象 &lt;code&gt;obj&lt;/code&gt; 。该函数不是原子的：即使通过原子操作从另一个线程进行的并发访问也是数据竞争。</target>
        </trans-unit>
        <trans-unit id="e49e9f39572d1033a19aeb243a49b9e378d309f2" translate="yes" xml:space="preserve">
          <source>Initializes the internal instance of the comparator to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">将比较器的内部实例初始化为 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a51259c3c84f8a09271df7eb1d4694a4b3224cee" translate="yes" xml:space="preserve">
          <source>Initializes the iterator to point to the same value as &lt;code&gt;it&lt;/code&gt; points.</source>
          <target state="translated">初始化迭代器指向相同的值， &lt;code&gt;it&lt;/code&gt; 指向。</target>
        </trans-unit>
        <trans-unit id="398735e9fedddd7f0aacad1eb358f7b46a4ac840" translate="yes" xml:space="preserve">
          <source>Injected class name</source>
          <target state="translated">注入的类名</target>
        </trans-unit>
        <trans-unit id="7bb9ce0cdba5a821d492b917cf5fb720a0f90bd9" translate="yes" xml:space="preserve">
          <source>Inline assembly</source>
          <target state="translated">在线装配</target>
        </trans-unit>
        <trans-unit id="4f9c73f65355a3ed7fedd216f2992cf3deebb61c" translate="yes" xml:space="preserve">
          <source>Inline assembly for Itanium-based HP-UX</source>
          <target state="translated">用于基于Itanium的HP-UX的在线装配。</target>
        </trans-unit>
        <trans-unit id="e51e51dc5c1aa8a193565e7fce22f1c142ed7d5c" translate="yes" xml:space="preserve">
          <source>Inline const variables at namespace scope have &lt;a href=&quot;storage_duration&quot;&gt;external linkage&lt;/a&gt; by default (unlike the non-inline non-volatile const-qualified variables).</source>
          <target state="translated">默认情况下，名称空间范围内的内联const变量具有&lt;a href=&quot;storage_duration&quot;&gt;外部链接&lt;/a&gt;（与非内联非易失性const限定变量不同）。</target>
        </trans-unit>
        <trans-unit id="49bfb486d3b3c3cb304f4493385555eb5b8a098a" translate="yes" xml:space="preserve">
          <source>Inline namespaces</source>
          <target state="translated">内联命名空间</target>
        </trans-unit>
        <trans-unit id="00b64c52a93228b3beba41ea40e5bd41acc77e53" translate="yes" xml:space="preserve">
          <source>Inline variables</source>
          <target state="translated">内联变量</target>
        </trans-unit>
        <trans-unit id="7be4e5da3a5437427b26df1ed281ec5d61782f49" translate="yes" xml:space="preserve">
          <source>Inline variables eliminate the main obstacle to packaging C++ code as header-only libraries.</source>
          <target state="translated">内联变量消除了将C++代码打包成只用头的库的主要障碍。</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="c05e081250483115acb3291c729e966cb6237c5d" translate="yes" xml:space="preserve">
          <source>Input/Output</source>
          <target state="translated">Input/Output</target>
        </trans-unit>
        <trans-unit id="249f397392db7fe682a1d1ecc1a52c8e40ceb983" translate="yes" xml:space="preserve">
          <source>Input/output</source>
          <target state="translated">Input/output</target>
        </trans-unit>
        <trans-unit id="cb5679ee6b70828884e48e829adaa69eeff5975a" translate="yes" xml:space="preserve">
          <source>Input/output library</source>
          <target state="translated">输入/输出库</target>
        </trans-unit>
        <trans-unit id="23a1c2b90e7720bee1275126fc61ab157f7fb4f4" translate="yes" xml:space="preserve">
          <source>Input/output manipulators</source>
          <target state="translated">输入/输出操纵器</target>
        </trans-unit>
        <trans-unit id="2dd11dbfca0e0084817673f0057830adc2def0af" translate="yes" xml:space="preserve">
          <source>InputIterator</source>
          <target state="translated">InputIterator</target>
        </trans-unit>
        <trans-unit id="5ce3b480664c159e1d12685b429698048d6ea3d0" translate="yes" xml:space="preserve">
          <source>InputRange</source>
          <target state="translated">InputRange</target>
        </trans-unit>
        <trans-unit id="2626e21603d8fe73a7e6ad428ec1925d9f5ce790" translate="yes" xml:space="preserve">
          <source>Insert an object of type &lt;code&gt;T&lt;/code&gt;, constructed with &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;p&lt;/code&gt; 之前插入类型为 &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)&lt;/code&gt; &amp;lt;Args&amp;gt;（args）的 &lt;code&gt;T&lt;/code&gt; 型对象</target>
        </trans-unit>
        <trans-unit id="bd0f39cfbd64e0b854da8b25dafdd19e3e5f4946" translate="yes" xml:space="preserve">
          <source>Insertion caused rehash</source>
          <target state="translated">插入造成翻版</target>
        </trans-unit>
        <trans-unit id="dd68ac29c94054b522d28e6c6323109f3d58ed57" translate="yes" xml:space="preserve">
          <source>Insertion changed capacity</source>
          <target state="translated">插入式改变容量</target>
        </trans-unit>
        <trans-unit id="90792df8b1ed4fcb7ea818e84aee0085187c66dc" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements - linear O(n)</source>
          <target state="translated">插入或移除元素----线性O(n)</target>
        </trans-unit>
        <trans-unit id="8dd87d390aed8473e28b99fc188dddac51d8f873" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements - linear in the distance to the end of the vector O(n)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f7998ac9050fd1635baf4429d529d9a7bb0521" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements at the end - amortized constant O(1)</source>
          <target state="translated">末尾插入或去除要素----摊销常数O(1)</target>
        </trans-unit>
        <trans-unit id="89dc0ff756b3d85bb1be7c9942ebc7011ccf494e" translate="yes" xml:space="preserve">
          <source>Insertion or removal of elements at the end or beginning - constant O(1)</source>
          <target state="translated">在结尾或开头插入或删除要素----常数O(1)</target>
        </trans-unit>
        <trans-unit id="40dbe6b4bec47b9cf461b0137ff76c424defca97" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;n&lt;/code&gt; copies of &lt;code&gt;t&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;p&lt;/code&gt; 之前插入 &lt;code&gt;t&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 个副本</target>
        </trans-unit>
        <trans-unit id="c32005ed652dab6de9fb37a37722957c3e2724e8" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into the associated stream, then inserts the delimiter, if one was specified at construction time.</source>
          <target state="translated">插入 &lt;code&gt;value&lt;/code&gt; 到相关联的流，然后插入分隔符，如果已在构造时指定。</target>
        </trans-unit>
        <trans-unit id="459fe20a1ffd7a6cd82618f9958505d8f6d74257" translate="yes" xml:space="preserve">
          <source>Inserts a character or a character string.</source>
          <target state="translated">插入一个字符或一个字符串。</target>
        </trans-unit>
        <trans-unit id="1292e82dd313319fd90a6127a6a0b0fa41ee3b4b" translate="yes" xml:space="preserve">
          <source>Inserts a copy of &lt;code&gt;rv&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;, possibly using move semantics</source>
          <target state="translated">在 &lt;code&gt;p&lt;/code&gt; 之前插入 &lt;code&gt;rv&lt;/code&gt; 的副本，可能使用move语义</target>
        </trans-unit>
        <trans-unit id="080a7d3105b387ca72b759dd0ac8cbe8daf7bece" translate="yes" xml:space="preserve">
          <source>Inserts a copy of &lt;code&gt;t&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;p&lt;/code&gt; 之前插入 &lt;code&gt;t&lt;/code&gt; 的副本</target>
        </trans-unit>
        <trans-unit id="dddeb94b4972c7384daa43582f102c411ce2464e" translate="yes" xml:space="preserve">
          <source>Inserts a new element into a position after the specified position in the container. The element is constructed in-place, i.e. no copy or move operations are performed. The constructor of the element is called with exactly the same arguments, as supplied to the function.</source>
          <target state="translated">在容器中指定位置后插入一个新元素。元素是在原地构建的,即不执行复制或移动操作。元素的构造函数被调用,其参数与提供给函数的参数完全相同。</target>
        </trans-unit>
        <trans-unit id="ca770757036e4fe2be6c21dfdc40521b78bb495b" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container as close as possible to the position just before &lt;code&gt;hint&lt;/code&gt;. The element is constructed in-place, i.e. no copy or move operations are performed.</source>
          <target state="translated">将新元素插入容器中，并尽可能靠近之前的位置 &lt;code&gt;hint&lt;/code&gt; 。元素是就地构建的，即不执行复制或移动操作。</target>
        </trans-unit>
        <trans-unit id="0c894839e77e9ab81555b68a4eab970743f5cf11" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container constructed in-place with the given &lt;code&gt;args&lt;/code&gt; .</source>
          <target state="translated">将新元素插入到使用给定 &lt;code&gt;args&lt;/code&gt; 就地构造的容器中。</target>
        </trans-unit>
        <trans-unit id="2ebf2c045edb5580cda64f0fcb67ffe1f644265e" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container constructed in-place with the given &lt;code&gt;args&lt;/code&gt; if there is no element with the key in the container.</source>
          <target state="translated">将新元素插入到使用给定 &lt;code&gt;args&lt;/code&gt; 就地构造的容器中没有带键的元素，则将的容器中。</target>
        </trans-unit>
        <trans-unit id="764a3843820016f0a301fc81d7090ba832667367" translate="yes" xml:space="preserve">
          <source>Inserts a new element into the container directly before &lt;code&gt;pos&lt;/code&gt;. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at a location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">将一个新元素直接插入 &lt;code&gt;pos&lt;/code&gt; 之前的容器中。元素是通过 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; ，通常使用placement-new在容器提供的位置就地构造元素。参数 &lt;code&gt;args...&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; &amp;lt;Args&amp;gt;（args）...转发给构造函数。。</target>
        </trans-unit>
        <trans-unit id="9cf81cb318be0807a9f9dfa69a27e14ef4b04921" translate="yes" xml:space="preserve">
          <source>Inserts a new element to the beginning of the container. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">在容器的开头插入一个新元素。该元素是通过 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; ，通常使用placement-new在容器提供的位置就地构造该元素。参数 &lt;code&gt;args...&lt;/code&gt; 作为 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; 转发给构造函数。</target>
        </trans-unit>
        <trans-unit id="de2a91ea3a0922ba9fd2c6820a52603ceaf2bfd4" translate="yes" xml:space="preserve">
          <source>Inserts a new element to the container as close as possible to the position just before &lt;code&gt;hint&lt;/code&gt;. The element is constructed in-place, i.e. no copy or move operations are performed.</source>
          <target state="translated">将新元素插入到容器中，并使其尽可能靠近 &lt;code&gt;hint&lt;/code&gt; 之前的位置。元素是就地构建的，即不执行复制或移动操作。</target>
        </trans-unit>
        <trans-unit id="d62b4192e275e6e5464e704bf2f2c06f78857362" translate="yes" xml:space="preserve">
          <source>Inserts a new element to the container, using &lt;code&gt;hint&lt;/code&gt; as a suggestion where the element should go. The element is constructed in-place, i.e. no copy or move operations are performed.</source>
          <target state="translated">将一个新元素插入容器，并使用 &lt;code&gt;hint&lt;/code&gt; 作为建议将该元素放置在何处。元素是就地构建的，即不执行复制或移动操作。</target>
        </trans-unit>
        <trans-unit id="06b953e63c9c91232d7dddd7cd152b54414e60b1" translate="yes" xml:space="preserve">
          <source>Inserts a newline character into the output sequence &lt;code&gt;os&lt;/code&gt; and flushes it as if by calling &lt;code&gt;os.put(os.widen('\n'))&lt;/code&gt; followed by &lt;code&gt;os.flush()&lt;/code&gt;.</source>
          <target state="translated">在输出序列 &lt;code&gt;os&lt;/code&gt; 中插入换行符，并通过调用 &lt;code&gt;os.put(os.widen('\n'))&lt;/code&gt; 和 &lt;code&gt;os.flush()&lt;/code&gt; 对其进行刷新。</target>
        </trans-unit>
        <trans-unit id="5f4e0eed677f446544f8308f60d7118157395fd2" translate="yes" xml:space="preserve">
          <source>Inserts a null character into the output sequence &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.put(CharT())&lt;/code&gt;.</source>
          <target state="translated">将空字符插入输出序列 &lt;code&gt;os&lt;/code&gt; 中，就像通过调用 &lt;code&gt;os.put(CharT())&lt;/code&gt; 一样。</target>
        </trans-unit>
        <trans-unit id="3be6541a3cdc8be869ffb1e36075af35ad2d9e5f" translate="yes" xml:space="preserve">
          <source>Inserts a textual representation of &lt;code&gt;d&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;. The behavior is undefined if &lt;code&gt;CharT&lt;/code&gt; is neither &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;wchar_t&lt;/code&gt;, or if &lt;code&gt;Rep&lt;/code&gt; is neither a floating-point type nor a integral type with conversion rank equal to or greater than &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;d&lt;/code&gt; 的文本表示形式插入 &lt;code&gt;os&lt;/code&gt; 。如果 &lt;code&gt;CharT&lt;/code&gt; 既不是 &lt;code&gt;char&lt;/code&gt; 也不是 &lt;code&gt;wchar_t&lt;/code&gt; ，或者 &lt;code&gt;Rep&lt;/code&gt; 既不是浮点类型也不是转换等级等于或大于 &lt;code&gt;short&lt;/code&gt; 的整数类型，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="3b309639bb23b684cc4e6d27b3891dbc4686b983" translate="yes" xml:space="preserve">
          <source>Inserts a textual representation of &lt;code&gt;r&lt;/code&gt; into &lt;code&gt;os&lt;/code&gt;. The exact format is unspecified.</source>
          <target state="translated">将 &lt;code&gt;r&lt;/code&gt; 的文本表示形式插入 &lt;code&gt;os&lt;/code&gt; 。未指定确切的格式。</target>
        </trans-unit>
        <trans-unit id="16b3b45d0513a34bfe5cb9a485fed3fcd636a919" translate="yes" xml:space="preserve">
          <source>Inserts characters into the string.</source>
          <target state="translated">在字符串中插入字符。</target>
        </trans-unit>
        <trans-unit id="0b8fe07029996680c6a7a04171ab4c8c1f427b51" translate="yes" xml:space="preserve">
          <source>Inserts copies of elements in &lt;code&gt;[i, j)&lt;/code&gt; before &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">在 &lt;code&gt;p&lt;/code&gt; 之前的 &lt;code&gt;[i, j)&lt;/code&gt; 插入元素的副本</target>
        </trans-unit>
        <trans-unit id="4f550772dfe95225e7aadcf101fd0fcec8c748a7" translate="yes" xml:space="preserve">
          <source>Inserts data into the stream.</source>
          <target state="translated">将数据插入到流中。</target>
        </trans-unit>
        <trans-unit id="eba77933a2e344cf988fd3ca6a623ff9d2ff92d0" translate="yes" xml:space="preserve">
          <source>Inserts element(s) into the container, if the container doesn't already contain an element with an equivalent key.</source>
          <target state="translated">如果容器中还没有含有等价键的元素,则将元素插入到容器中。</target>
        </trans-unit>
        <trans-unit id="ccd9e30db577ad68c0e1422c4c4a79f885e3e582" translate="yes" xml:space="preserve">
          <source>Inserts element(s) into the container.</source>
          <target state="translated">在容器中插入元素。</target>
        </trans-unit>
        <trans-unit id="1a4eb8d141fa15817e7fa53f7d0ceee266ac871a" translate="yes" xml:space="preserve">
          <source>Inserts elements after the specified position in the container.</source>
          <target state="translated">在容器的指定位置后插入元素。</target>
        </trans-unit>
        <trans-unit id="8ad0a7fe7ffe735c0e8d1f3247c2284b472ecf85" translate="yes" xml:space="preserve">
          <source>Inserts elements at the specified location in the container.</source>
          <target state="translated">在容器的指定位置插入元素。</target>
        </trans-unit>
        <trans-unit id="e3538cf079d871f7078cd6d2626f91c5fe3217d1" translate="yes" xml:space="preserve">
          <source>Inserts or extracts a bitset from a character stream.</source>
          <target state="translated">从字符流中插入或提取一个位组。</target>
        </trans-unit>
        <trans-unit id="436cbc44494163237fbc2dae7c0dbecac89e17a0" translate="yes" xml:space="preserve">
          <source>Inserts the element at the position &lt;code&gt;last-1&lt;/code&gt; into the</source>
          <target state="translated">将元素在 &lt;code&gt;last-1&lt;/code&gt; 位置插入</target>
        </trans-unit>
        <trans-unit id="de7c44cdab798ba02a3b54672adb89734e298e3e" translate="yes" xml:space="preserve">
          <source>Inserts the given value &lt;code&gt;value&lt;/code&gt; to the container.</source>
          <target state="translated">插入给定值 &lt;code&gt;value&lt;/code&gt; 的容器。</target>
        </trans-unit>
        <trans-unit id="da42294637fdcfd28f56598c14c33d9cc2c56bd5" translate="yes" xml:space="preserve">
          <source>Inserts the value of the pointer managed by &lt;code&gt;p&lt;/code&gt; into the output stream &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">将由 &lt;code&gt;p&lt;/code&gt; 管理的指针的值插入到输出流 &lt;code&gt;os&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="27f20e401e741fb3278e97286227b847ff4a5a37" translate="yes" xml:space="preserve">
          <source>Inserts the value of the pointer stored in ptr into the output stream os.</source>
          <target state="translated">将存储在ptr中的指针值插入到输出流os中。</target>
        </trans-unit>
        <trans-unit id="cc4361d50be18c5e552170a7006899011cb13d66" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;../language/constraints&quot;&gt; requirements&lt;/a&gt; for type requirements (since C++20)</source>
          <target state="translated">内部的&lt;a href=&quot;../language/constraints&quot;&gt;规定&lt;/a&gt;类型的要求（因为C ++ 20）</target>
        </trans-unit>
        <trans-unit id="600f1274eac8f378c8f16ed6ad8ee46ff4edfb74" translate="yes" xml:space="preserve">
          <source>Inside a class definition, the keyword &lt;a href=&quot;../keywords/static&quot;&gt;&lt;code&gt;static&lt;/code&gt;&lt;/a&gt; declares members that are not bound to class instances.</source>
          <target state="translated">在类定义中，关键字&lt;a href=&quot;../keywords/static&quot;&gt; &lt;code&gt;static&lt;/code&gt; &lt;/a&gt;声明未绑定到类实例的成员。</target>
        </trans-unit>
        <trans-unit id="03675817cd2b928d6905ad0345e0c7efd3baeea5" translate="yes" xml:space="preserve">
          <source>Inside a declaration or a definition of a template, &lt;code&gt;typename&lt;/code&gt; can be used to declare that a &lt;a href=&quot;../language/dependent_name&quot;&gt;dependent qualified name&lt;/a&gt; is a type.</source>
          <target state="translated">在模板的声明或定义中， &lt;code&gt;typename&lt;/code&gt; 可用于声明&lt;a href=&quot;../language/dependent_name&quot;&gt;从属限定名称&lt;/a&gt;为类型。</target>
        </trans-unit>
        <trans-unit id="c75e28d40b1ee1647f206ce29f91a72118f77dcb" translate="yes" xml:space="preserve">
          <source>Inside a declaration or a definition of a template,(until C++11)&lt;code&gt;typename&lt;/code&gt; can be used before a non-dependent qualified type name. It has no effect in this case.</source>
          <target state="translated">在模板的声明或定义中，（直到C ++ 11） &lt;code&gt;typename&lt;/code&gt; 可以在非依赖性限定类型名称之前使用。在这种情况下不起作用。</target>
        </trans-unit>
        <trans-unit id="6cd46b31dc66a09cb27a8b94558ff90367369cb8" translate="yes" xml:space="preserve">
          <source>Inside a template definition, &lt;code&gt;template&lt;/code&gt; can be used to declare that a &lt;a href=&quot;../language/dependent_name&quot;&gt;dependent name&lt;/a&gt; is a template.</source>
          <target state="translated">在模板定义中， &lt;code&gt;template&lt;/code&gt; 可用于声明&lt;a href=&quot;../language/dependent_name&quot;&gt;从属名称&lt;/a&gt;是模板。</target>
        </trans-unit>
        <trans-unit id="350b4808c73cf8468a6f363916c30c4a397b3dc5" translate="yes" xml:space="preserve">
          <source>Inside class definition</source>
          <target state="translated">内类定义</target>
        </trans-unit>
        <trans-unit id="6b5698bf0daa42ff37c1cd0dca09d5b7656e92d2" translate="yes" xml:space="preserve">
          <source>Inside the definition of a &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; (both &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt; and &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;), the meaning of some constructs may differ from one instantiation to another. In particular, types and expressions may depend on types of type template parameters and values of non-type template parameters.</source>
          <target state="translated">在&lt;a href=&quot;templates&quot;&gt;模板&lt;/a&gt;（&lt;a href=&quot;class_template&quot;&gt;类模板&lt;/a&gt;和&lt;a href=&quot;function_template&quot;&gt;函数模板&lt;/a&gt;）的定义内部，某些构造的含义可能因一个实例而异。特别地，类型和表达式可以取决于类型模板参数的类型和非类型模板参数的值。</target>
        </trans-unit>
        <trans-unit id="29bb12e4f618840806749020bc50cf4a005ce46d" translate="yes" xml:space="preserve">
          <source>Inspects the declared type of an entity or the type and value category of an expression.</source>
          <target state="translated">检查实体的声明类型或表达式的类型和值类别。</target>
        </trans-unit>
        <trans-unit id="55e8d92a13e25eb28d03d82349c3f32ae5b1856b" translate="yes" xml:space="preserve">
          <source>Instances of this class may also hold the special distinct value that does not represent any thread. Once a thread has finished, the value of &lt;code&gt;std::thread::id&lt;/code&gt; may be reused by another thread.</source>
          <target state="translated">此类的实例还可以包含不代表任何线程的特殊特殊值。线程完成后，另一个线程可能会重用 &lt;code&gt;std::thread::id&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="0323fe82517b3deef4dcc33c2202e8572f5af700" translate="yes" xml:space="preserve">
          <source>Instead of being defined by specific types, each category of iterator is defined by the operations that can be performed on it. This definition means that any type that supports the necessary operations can be used as an iterator -- for example, a pointer supports all of the operations required by &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, so a pointer can be used anywhere a &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; is expected.</source>
          <target state="translated">不是由特定类型定义，而是由迭代器的每个类别由可以对其执行的操作来定义。该定义是指任何类型的载体上的必要的操作可以被用作迭代-例如，一个指针支持所有所要求的操作的&lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;，因此指针可用于任何位置&lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;预期。</target>
        </trans-unit>
        <trans-unit id="b12082e6b05d3b9bc176ff98ba66b29e9e0b12fe" translate="yes" xml:space="preserve">
          <source>Instead of creating copies of files, create hardlinks that resolve to the same files as the originals</source>
          <target state="translated">与其创建文件的副本,不如创建解析到与原文件相同的硬链接。</target>
        </trans-unit>
        <trans-unit id="78afece0e04a5cf908cc483529a4871648680f1b" translate="yes" xml:space="preserve">
          <source>Instead of creating copies of files, create symlinks pointing to the originals. Note: the source path must be an absolute path unless the destination path is in the current directory.</source>
          <target state="translated">不要创建文件的副本,而是创建指向原文件的符号链接。注意:源路径必须是绝对路径,除非目标路径在当前目录中。</target>
        </trans-unit>
        <trans-unit id="cfaebf91cdac75d382847870cf98c644ae8839f0" translate="yes" xml:space="preserve">
          <source>Instead of using the overload (2) together with new, it is often a better idea to use &lt;code&gt;&lt;a href=&quot;make_unique&quot;&gt;std::make_unique&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">与其将重载（2）与new一起使用，不如使用 &lt;code&gt;&lt;a href=&quot;make_unique&quot;&gt;std::make_unique&amp;lt;T&amp;gt;&lt;/a&gt;&lt;/code&gt; 更好。</target>
        </trans-unit>
        <trans-unit id="15df2d5892f1c21a31c35b32a3d847ba47bdff20" translate="yes" xml:space="preserve">
          <source>Instructs the regular expression engine to make matching faster, with the potential cost of making construction slower. For example, this might mean converting a non-deterministic FSA to a deterministic FSA.</source>
          <target state="translated">指示正则表达式引擎使匹配速度更快,但潜在的代价是使构建速度更慢。例如,这可能意味着将非确定性的 FSA 转换为确定性的 FSA。</target>
        </trans-unit>
        <trans-unit id="d29911b1bd2caeb5ec80c99646811291a26cf594" translate="yes" xml:space="preserve">
          <source>IntType</source>
          <target state="translated">IntType</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">整数类型</target>
        </trans-unit>
        <trans-unit id="d19f3662fc5d3aa69996dfa0c88356fda0d60fc4" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">成功时对应于 &lt;code&gt;str&lt;/code&gt; 内容的整数值。如果转换后的值超出相应返回类型的范围，则发生范围错误，并返回 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; 。如果不能进行转换， &lt;code&gt;​0​&lt;/code&gt; 被返回。</target>
        </trans-unit>
        <trans-unit id="1da9ae4426444f430bd1d7493a5b5250c7cfec29" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; is returned. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">成功时对应于 &lt;code&gt;str&lt;/code&gt; 内容的整数值。如果转换后的值超出相应返回类型的范围，则发生范围错误，并返回 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULONG_MAX&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;ULLONG_MAX&lt;/a&gt;&lt;/code&gt; 。如果不能进行转换， &lt;code&gt;​0​&lt;/code&gt; 被返回。</target>
        </trans-unit>
        <trans-unit id="52e4539e8037f8f852f5856d00606b776679d442" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, range error occurs and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">成功时对应于 &lt;code&gt;str&lt;/code&gt; 内容的整数值。如果转换后的值落在对应的返回类型的范围时，发生错误的范围和 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; ，或 &lt;code&gt;​0​&lt;/code&gt; 则返回，如合适的。如果不能进行转换， &lt;code&gt;​0​&lt;/code&gt; 被返回。</target>
        </trans-unit>
        <trans-unit id="21098bb738833ee0f4f792151a59d559da8ec6b0" translate="yes" xml:space="preserve">
          <source>Integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; on success. If the converted value falls out of range of corresponding return type, the return value is undefined. If no conversion can be performed, &lt;code&gt;​0​&lt;/code&gt; is returned.</source>
          <target state="translated">成功时对应于 &lt;code&gt;str&lt;/code&gt; 内容的整数值。如果转换后的值超出相应返回类型的范围，则返回值不确定。如果不能进行转换， &lt;code&gt;​0​&lt;/code&gt; 被返回。</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="b825f7aa91a4416d2a86fdbf6d9049ea6b2d615d" translate="yes" xml:space="preserve">
          <source>Integral constant expression</source>
          <target state="translated">整数常数表达式</target>
        </trans-unit>
        <trans-unit id="1f4e6183969d6ec80ad6d2f378b3a85f029c653b" translate="yes" xml:space="preserve">
          <source>Integral conversions</source>
          <target state="translated">整体转换</target>
        </trans-unit>
        <trans-unit id="320e2752aea495aec73f84035d1bb6ef868679ad" translate="yes" xml:space="preserve">
          <source>Integral promotion</source>
          <target state="translated">整体提升</target>
        </trans-unit>
        <trans-unit id="270f2235f730fd6efca2aa9d17f0dc702810f771" translate="yes" xml:space="preserve">
          <source>Intel C++ Inline Assembly</source>
          <target state="translated">Intel C++Inline Assembly</target>
        </trans-unit>
        <trans-unit id="48e94a1cde254c1213e9904ae2fa6aec7a82e049" translate="yes" xml:space="preserve">
          <source>Inter-thread happens-before</source>
          <target state="translated">线程间发生在</target>
        </trans-unit>
        <trans-unit id="fbefd7a4bdb4b3775050f8fe665496f4fc106f7d" translate="yes" xml:space="preserve">
          <source>Inter-thread synchronization and memory ordering determine how</source>
          <target state="translated">线程间的同步和内存顺序决定了如何</target>
        </trans-unit>
        <trans-unit id="e341892f1cc87078f7d5e926c1138ccb82e90235" translate="yes" xml:space="preserve">
          <source>Internal Compiler Error</source>
          <target state="translated">内部编译器错误</target>
        </trans-unit>
        <trans-unit id="8db0e387b648322ee87a237498c06354600d50c6" translate="yes" xml:space="preserve">
          <source>Internal extensible array</source>
          <target state="translated">内部可扩展阵列</target>
        </trans-unit>
        <trans-unit id="3eec2f184115efd5c87c5ee6ebf0d6b3a9c071ab" translate="yes" xml:space="preserve">
          <source>Internally, a locale object is implemented as-if it is a reference-counted pointer to an array (indexed by &lt;code&gt;&lt;a href=&quot;locale/id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt;) of reference-counted pointers to facets: copying a locale only copies one pointer and increments several reference counts. To maintain the standard C++ library thread safety guarantees (operations on different objects are always thread-safe), both the locale reference count and each facet reference count are updated in thread-safe manner, similar to &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在内部，一个语言环境对象的实现方式如下：-如果它是一个指向引用构面的数组的引用计数指针（由 &lt;code&gt;&lt;a href=&quot;locale/id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; 索引）：复制语言环境仅复制一个指针并增加多个引用计数。为了保持标准的C ++库线程安全性保证（对不同对象的操作始终是线程安全的），类似于 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; ，区域设置引用计数和每个构面引用计数都以线程安全的方式进行更新。</target>
        </trans-unit>
        <trans-unit id="9dac1e92729539ac11d8cad38e7bddd13ef84d39" translate="yes" xml:space="preserve">
          <source>Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">在内部，该字符在即将被写入之前会转换为 &lt;code&gt;unsigned char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a300aede5a38ab0ed12e3cbf6171db92a06f041" translate="yes" xml:space="preserve">
          <source>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its key. This allows fast access to individual elements, since once the hash is computed, it refers to the exact bucket the element is placed into.</source>
          <target state="translated">在内部,元素并没有按照任何特定的顺序进行排序,而是被组织到桶中。一个元素被放入哪个桶,完全取决于它的键的哈希值。这允许快速访问单个元素,因为一旦哈希值被计算出来,它就会指向该元素被放入的确切桶。</target>
        </trans-unit>
        <trans-unit id="8e3d09a97f93ab12396f4f53a23484c5868af0eb" translate="yes" xml:space="preserve">
          <source>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once a hash is computed, it refers to the exact bucket the element is placed into.</source>
          <target state="translated">在内部,元素并没有按照任何特定的顺序排序,而是被组织到桶中。一个元素被放入哪个桶完全取决于其值的哈希值。这允许快速访问单个元素,因为一旦哈希值被计算出来,它就会指向该元素被放入的确切桶。</target>
        </trans-unit>
        <trans-unit id="1d351577d1e15db8313b9f13fd0274b045e4b3f2" translate="yes" xml:space="preserve">
          <source>Internally, the elements are not sorted in any particular order, but organized into buckets. Which bucket an element is placed into depends entirely on the hash of its value. This allows fast access to individual elements, since once hash is computed, it refers to the exact bucket the element is placed into.</source>
          <target state="translated">在内部,元素并没有按照任何特定的顺序排序,而是被组织到桶中。一个元素被放入哪个桶完全取决于其值的哈希值。这允许快速访问单个元素,因为一旦哈希值被计算出来,它就会指向该元素被放入的确切桶。</target>
        </trans-unit>
        <trans-unit id="4000ac517f025eca6a922c089403bb09186f8d96" translate="yes" xml:space="preserve">
          <source>International monetary numeric formatting parameters</source>
          <target state="translated">国际货币数字格式参数</target>
        </trans-unit>
        <trans-unit id="a8ae931d734dc08b103a3cda5b6a5d402a381387" translate="yes" xml:space="preserve">
          <source>Interpolation operations</source>
          <target state="translated">内插操作</target>
        </trans-unit>
        <trans-unit id="0f1ee1e93c2e9e3ff3649d6745a31dd59c9090f7" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">解释 &lt;code&gt;str&lt;/code&gt; 指向的字节字符串中的浮点值。</target>
        </trans-unit>
        <trans-unit id="c521564a7a070d90bbed7e76e298ba2e2b938b7a" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">解释字符串 &lt;code&gt;str&lt;/code&gt; 中的浮点值。</target>
        </trans-unit>
        <trans-unit id="bc48cbadb6a84efbed23317d93156122ffd8c740" translate="yes" xml:space="preserve">
          <source>Interprets a floating point value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">解释 &lt;code&gt;str&lt;/code&gt; 指向的宽字符串中的浮点值。</target>
        </trans-unit>
        <trans-unit id="ad9f4a5a657fd23f774f0701ca42e9ed82c97178" translate="yes" xml:space="preserve">
          <source>Interprets a signed integer value in the string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">解释字符串 &lt;code&gt;str&lt;/code&gt; 中的带符号整数值。</target>
        </trans-unit>
        <trans-unit id="9a608036eb59f94001912ca3733a0c15c944b183" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="translated">解释 &lt;code&gt;nptr&lt;/code&gt; 指向的字节字符串中的整数值。</target>
        </trans-unit>
        <trans-unit id="566cf8ed0ac571b4f2aa3ca75d488875487baeb4" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">解释 &lt;code&gt;str&lt;/code&gt; 指向的字节字符串中的整数值。</target>
        </trans-unit>
        <trans-unit id="cc2bd5d023e90da3e1640fc0f66845e22f6c8508" translate="yes" xml:space="preserve">
          <source>Interprets an integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">解释 &lt;code&gt;str&lt;/code&gt; 指向的宽字符串中的整数值。</target>
        </trans-unit>
        <trans-unit id="042a224facaad3cdf57ba7458290bd20ddbab9ab" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a byte string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">解释 &lt;code&gt;str&lt;/code&gt; 指向的字节字符串中的无符号整数值。</target>
        </trans-unit>
        <trans-unit id="65b433c8b60cb3b8c5443581467dc0f6ae5b6523" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;nptr&lt;/code&gt;.</source>
          <target state="translated">解释 &lt;code&gt;nptr&lt;/code&gt; 指向的宽字符串中的无符号整数值。</target>
        </trans-unit>
        <trans-unit id="148c33b3cec53bcad46f4795046e389f68465431" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in a wide string pointed to by &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">解释 &lt;code&gt;str&lt;/code&gt; 指向的宽字符串中的无符号整数值。</target>
        </trans-unit>
        <trans-unit id="aabb8c7d3ca13ab71a2338fd76d6fca5fd94220c" translate="yes" xml:space="preserve">
          <source>Interprets an unsigned integer value in the string &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">解释字符串 &lt;code&gt;str&lt;/code&gt; 中的无符号整数值。</target>
        </trans-unit>
        <trans-unit id="9aa738055f64e3e6394c5784c7988113147a1c1a" translate="yes" xml:space="preserve">
          <source>Interrupted function</source>
          <target state="translated">中断功能</target>
        </trans-unit>
        <trans-unit id="dded3e7aba46e073c03bff678699e36b51e2c4a9" translate="yes" xml:space="preserve">
          <source>Introduces a name that is defined elsewhere into the declarative region where this using-declaration appears.</source>
          <target state="translated">将一个在其他地方定义的名称引入到这个使用声明出现的声明区域。</target>
        </trans-unit>
        <trans-unit id="d63eba892386df3bd9064d08a9292099f5ee5b9f" translate="yes" xml:space="preserve">
          <source>Introduces implementation-defined attributes for types, objects, code, etc.  &lt;code&gt;[[&lt;/code&gt;</source>
          <target state="translated">为类型，对象，代码等引入实现定义的属性。 &lt;code&gt;[[&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45ff4427a9f1fb0c18cbcdf6b26d6a2d22f2df2f" translate="yes" xml:space="preserve">
          <source>Invalid argument</source>
          <target state="translated">无效参数</target>
        </trans-unit>
        <trans-unit id="1383c7b39080e5234bcaae9c303e96b402357694" translate="yes" xml:space="preserve">
          <source>Invalid non-zero alignments, such as &lt;code&gt;alignas(3)&lt;/code&gt; are ill-formed.</source>
          <target state="translated">无效的非零比对，例如 &lt;code&gt;alignas(3)&lt;/code&gt; 格式错误。</target>
        </trans-unit>
        <trans-unit id="86c96ba7411037b346432868bfdb3e867290952c" translate="yes" xml:space="preserve">
          <source>Invalid scalar</source>
          <target state="translated">无效标量</target>
        </trans-unit>
        <trans-unit id="b6b99ba962e359de15e0e27fd677ea67331c95bc" translate="yes" xml:space="preserve">
          <source>Invalid seek</source>
          <target state="translated">无效搜索</target>
        </trans-unit>
        <trans-unit id="41fc9b91f0fee77d14d8c449a0016aae8b1ef082" translate="yes" xml:space="preserve">
          <source>Invalidated</source>
          <target state="translated">Invalidated</target>
        </trans-unit>
        <trans-unit id="5184a57889a8a3581992c2997ad61b14585f2ce0" translate="yes" xml:space="preserve">
          <source>Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterator remains valid.</source>
          <target state="translated">无效任何指向包含元素的引用、指针或迭代器。任何过去的迭代器仍然有效。</target>
        </trans-unit>
        <trans-unit id="7c48efeaf38e5bc872433889acf9dca25ee7978e" translate="yes" xml:space="preserve">
          <source>Invalidates any references, pointers, or iterators referring to contained elements. Any past-the-end iterators are also invalidated.</source>
          <target state="translated">无效任何指向包含元素的引用、指针或迭代器。任何过去的迭代器也无效。</target>
        </trans-unit>
        <trans-unit id="84523b9994334aa4168c1ce7715701ecd8e7c500" translate="yes" xml:space="preserve">
          <source>Invalidates any references, pointers, or iterators referring to contained elements. May also invalidate past-the-end iterators.</source>
          <target state="translated">无效任何指向包含元素的引用、指针或迭代器。也可能使过去的迭代器无效。</target>
        </trans-unit>
        <trans-unit id="900eb067daacf1fc2f277185d1c086ea7646a1aa" translate="yes" xml:space="preserve">
          <source>Invalidates iterators and references at or after the point of the erase, including the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator.</source>
          <target state="translated">在擦除点或擦除点之后使迭代器和引用无效，包括 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 迭代器。</target>
        </trans-unit>
        <trans-unit id="57cfa38621b674967383a26be5a5ea85e99b30e4" translate="yes" xml:space="preserve">
          <source>Invalidation notes</source>
          <target state="translated">无效说明</target>
        </trans-unit>
        <trans-unit id="4b1ed8b8c1a0fe2800fdf2738e1f7cc4d2d7cef2" translate="yes" xml:space="preserve">
          <source>Inverse cosine (or arc cosine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.  The mathematical definition of the principal value of arc cosine is acos z =</source>
          <target state="translated">反余弦（或反余弦）是一个多值函数，需要在复平面上切出一个分支。分支切口通常位于实轴的线段（-&amp;infin;，-1）和（1，&amp;infin;）处。反余弦值的数学定义是acos z =</target>
        </trans-unit>
        <trans-unit id="92db73712a1ea6cdea29021a66a4e0d10b6b003b" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segment (-&amp;infin;,+1) of the real axis.</source>
          <target state="translated">反双曲余弦是一个多值函数，需要在复平面上切一个分支。分支切口通常位于实轴的线段（-&amp;infin;，+ 1）处。</target>
        </trans-unit>
        <trans-unit id="3ff0648a78636309b1cc12a67a5c7841a27e8966" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-</source>
          <target state="translated">反双曲正弦是一个多值函数,需要在复数平面上做一个分支切割。传统上,分支的切点是放在线段(-)处。</target>
        </trans-unit>
        <trans-unit id="60cf8f72dc186c6f4b4743734e8e8ed4cb1bd30a" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segmentd (-&amp;infin;,-1] and [+1,+&amp;infin;) of the real axis.  The mathematical definition of the principal value of the inverse hyperbolic tangent is atanh z =</source>
          <target state="translated">反双曲正切是一个多值函数，需要在复平面上切出一个分支。分支切口通常位于实轴的分割线（-&amp;infin;，-1]和[+ 1，+&amp;infin;）处。反双曲正切值的数学定义是atanh z =</target>
        </trans-unit>
        <trans-unit id="ff28b3449f26b28c2a2ed73fffb64ba03b0e2959" translate="yes" xml:space="preserve">
          <source>Inverse sine (or arc sine) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;,-1) and (1,&amp;infin;) of the real axis.</source>
          <target state="translated">反正弦（或反正弦）是一个多值函数，需要在复平面上切出一个分支。分支切口通常位于实轴的线段（-&amp;infin;，-1）和（1，&amp;infin;）处。</target>
        </trans-unit>
        <trans-unit id="8a394149a1f48f15fcf530168253dbecfeb4322f" translate="yes" xml:space="preserve">
          <source>Inverse tangent (or arc tangent) is a multivalued function and requires a branch cut on the complex plane. The branch cut is conventionally placed at the line segments (-&amp;infin;i,-i) and (+i,+&amp;infin;i) of the imaginary axis.  The mathematical definition of the principal value of inverse tangent is atan z = -</source>
          <target state="translated">反正切（或反正切）是一个多值函数，需要在复杂平面上切出一个分支。分支切口通常位于假想轴的线段（-&amp;infin;i，-i）和（+ i，+&amp;infin;i）处。反正切主值的数学定义是atan z =-</target>
        </trans-unit>
        <trans-unit id="e22b4961b86c756eeda2aa9b446c8173116dbbc7" translate="yes" xml:space="preserve">
          <source>Inverts the referenced bit.</source>
          <target state="translated">反转被引用的位。</target>
        </trans-unit>
        <trans-unit id="08fcf3f000c798d1019b77985f2565bd9131f8e3" translate="yes" xml:space="preserve">
          <source>InvocableRegularInvocable</source>
          <target state="translated">InvocableRegularInvocable</target>
        </trans-unit>
        <trans-unit id="d4f9cb47dbcc2422f0bd9a0424a0965a711f4fe4" translate="yes" xml:space="preserve">
          <source>Invoke the &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; with the parameters &lt;code&gt;args&lt;/code&gt;. As by &lt;code&gt;INVOKE(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;.</source>
          <target state="translated">使用参数 &lt;code&gt;args&lt;/code&gt; 调用&lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;对象 &lt;code&gt;f&lt;/code&gt; 。如 &lt;code&gt;INVOKE(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f), &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; &lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;F&amp;gt;（f），&lt;a href=&quot;../forward&quot;&gt;std :: forward&lt;/a&gt; &amp;lt;Args&amp;gt;（args）...）。</target>
        </trans-unit>
        <trans-unit id="43a887b06ff69b20968832ea3de0f894899ed0b1" translate="yes" xml:space="preserve">
          <source>Invoke the &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; object &lt;code&gt;f&lt;/code&gt; with a tuple of arguments.</source>
          <target state="translated">用一个参数元组调用&lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;对象 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0f26292e2434ecd2054e3f89ad01624a3592aac" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;b.seed()&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;b.seed()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="533e38b5b781a7cf4c13a2c009ad69bee4e181ab" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;b.seed(q)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;b.seed(q)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8de535373bc28162e3e7e5c533ad8d22bcee959" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;b.seed(s)&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;b.seed(s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43efae5b116e5f3d09b4e59697f462efb6558f1d" translate="yes" xml:space="preserve">
          <source>Invokes implementation-defined behaviour if not &lt;code&gt;&lt;a href=&quot;../io/streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; is used as the traits template parameter in input/output classes.</source>
          <target state="translated">调用实现定义的行为，如果不是 &lt;code&gt;&lt;a href=&quot;../io/streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; 当 &lt;code&gt;X&lt;/code&gt; 被用作输入/输出类的特征模板参数。</target>
        </trans-unit>
        <trans-unit id="fed12ee3ef79fc236fc9bb3fd94d2fb99592217c" translate="yes" xml:space="preserve">
          <source>Invokes implementation-defined behaviour if this type is not &lt;code&gt;&lt;a href=&quot;../io/fpos&quot;&gt;std::streampos&lt;/a&gt;&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; is used as the traits template parameter in input/output classes</source>
          <target state="translated">如果在输入/输出类中将 &lt;code&gt;X&lt;/code&gt; 用作特征模板参数时，如果此类型不是 &lt;code&gt;&lt;a href=&quot;../io/fpos&quot;&gt;std::streampos&lt;/a&gt;&lt;/code&gt; ，则调用实现定义的行为</target>
        </trans-unit>
        <trans-unit id="10839e4e143f807b60e96a2d95d532d052d717e3" translate="yes" xml:space="preserve">
          <source>Invokes the stored callable function target with the parameters &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">使用参数 &lt;code&gt;args&lt;/code&gt; 调用存储的可调用函数目标。</target>
        </trans-unit>
        <trans-unit id="b3c06b4bbdf7388ea26ca66d81ec0d37bcc14b0f" translate="yes" xml:space="preserve">
          <source>Invoking over Incomplete Types</source>
          <target state="translated">在不完全类型上调用</target>
        </trans-unit>
        <trans-unit id="d82b06adf1a876d702b6a3905d8d56b51827e40e" translate="yes" xml:space="preserve">
          <source>Is a directory</source>
          <target state="translated">是一个目录</target>
        </trans-unit>
        <trans-unit id="3dfd81af531e4d3b7128a14d5c41e637a26dc974" translate="yes" xml:space="preserve">
          <source>It can also be called using member function call syntax:</source>
          <target state="translated">也可以使用成员函数调用语法来调用。</target>
        </trans-unit>
        <trans-unit id="09e1f9f748059f808777769884d3dc5b93769167" translate="yes" xml:space="preserve">
          <source>It can also be used to detect validity of an expression:</source>
          <target state="translated">它也可以用来检测表达式的有效性。</target>
        </trans-unit>
        <trans-unit id="3ee5198972c83e32aa4a5a28496aa84dc1d7e5c4" translate="yes" xml:space="preserve">
          <source>It can be used to specify additional constraints in terms of local parameters. The constraint-expression must be satisfied by the substituted template arguments, if any. Substitution of template arguments into a nested requirement causes substitution into the constraint-expression only to the extent needed to determine whether the constraint-expression is satisfied.</source>
          <target state="translated">它可以用来指定局部参数的附加约束。如果有的话,约束表达式必须被替换的模板参数所满足。将模板参数替换到嵌套需求中会导致替换到约束表达式中,但仅限于确定约束表达式是否满足所需的范围。</target>
        </trans-unit>
        <trans-unit id="619583a1fc7588b9b8e425ca17f621a35be87edb" translate="yes" xml:space="preserve">
          <source>It can be used with a named variable:</source>
          <target state="translated">它可以和一个命名变量一起使用。</target>
        </trans-unit>
        <trans-unit id="dc95ed9cfcbc19e43b1a73cbe3345e11d2c4b4b0" translate="yes" xml:space="preserve">
          <source>It can be used within a function template's &lt;a href=&quot;noexcept_spec&quot;&gt; noexcept specifier&lt;/a&gt; to declare that the function will throw exceptions for some types but not others.</source>
          <target state="translated">可以在函数模板的&lt;a href=&quot;noexcept_spec&quot;&gt;noexcept说明符中&lt;/a&gt;使用它来声明该函数将为某些类型引发异常，而对其他类型则不。</target>
        </trans-unit>
        <trans-unit id="1095ba2835f4490f22e5cd2104e56ec80a11aef2" translate="yes" xml:space="preserve">
          <source>It consists of a collection of</source>
          <target state="translated">它包括一系列的</target>
        </trans-unit>
        <trans-unit id="a6dfca72e61bb66f5282dc9be56b501edd0e1c20" translate="yes" xml:space="preserve">
          <source>It consists of a count of ticks of type &lt;code&gt;Rep&lt;/code&gt; and a tick period, where the tick period is a compile-time rational constant representing the number of seconds from one tick to the next.</source>
          <target state="translated">它由 &lt;code&gt;Rep&lt;/code&gt; 类型的滴答计数和一个滴答周期组成，滴答周期是一个编译时有理常数，表示从一个滴答到下一个滴答的秒数。</target>
        </trans-unit>
        <trans-unit id="8fe8176ea54439a7ccb802fb9944ca38d007f40a" translate="yes" xml:space="preserve">
          <source>It has the same &lt;a href=&quot;access&quot;&gt;access&lt;/a&gt; as the corresponding base constructor. It is &lt;code&gt;constexpr&lt;/code&gt; if the user-defined constructor would have satisfied &lt;code&gt;constexpr&lt;/code&gt; constructor requirements. It is deleted if the corresponding base constructor is deleted or if a defaulted default constructor would be deleted (except that the construction of the base whose constructor is being inherited doesn't count). An inheriting constructor cannot be explicitly instantiated or explicitly specialized.</source>
          <target state="translated">它具有与相应基本构造函数相同的&lt;a href=&quot;access&quot;&gt;访问权限&lt;/a&gt;。如果用户定义的构造函数满足 &lt;code&gt;constexpr&lt;/code&gt; 构造函数要求，则为 &lt;code&gt;constexpr&lt;/code&gt; 。如果删除了相应的基本构造函数或将删除默认的默认构造函数，则将其删除（除非继承其构造函数的基本构造不计算在内）。继承的构造函数无法显式实例化或显式专门化。</target>
        </trans-unit>
        <trans-unit id="0ac2d8ef890218e1971697be578d263616be6031" translate="yes" xml:space="preserve">
          <source>It indicates that a the function definition should be optimized for invocation from a &lt;code&gt;synchronized&lt;/code&gt; statement. In particular, it avoids serializing synchronized blocks that make a call to a function that is transaction-safe for the majority of calls, but not for all calls (e.g. hash table insertion that may have to rehash, allocator that may have to request a new block, a simple function that may rarely log).</source>
          <target state="translated">它指示应优化函数定义以从 &lt;code&gt;synchronized&lt;/code&gt; 语句调用。特别是，它避免了对同步的块进行序列化，这些块对大多数调用而不是对所有调用都具有事务安全性的函数进行调用（例如，可能需要重新哈希的哈希表插入，可能不得不请求新的分配器）块，一个可能很少记录的简单函数）。</target>
        </trans-unit>
        <trans-unit id="31f0bb20de8e96b8260678ddcc2cec2269507d64" translate="yes" xml:space="preserve">
          <source>It is a non-binding request to reduce &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;. It depends on the implementation if the request is fulfilled.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 减小为 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 是非绑定请求。是否满足请求取决于实现。</target>
        </trans-unit>
        <trans-unit id="2d5740434b4376cbb133c18052ef3ec7113f5eaf" translate="yes" xml:space="preserve">
          <source>It is a non-binding request to reduce &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt;. It depends on the implementation whether the request is fulfilled.</source>
          <target state="translated">将 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 减小为 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 是非绑定请求。是否满足请求取决于实现。</target>
        </trans-unit>
        <trans-unit id="4b00903590e8f552a1ace12bc5841762223d788d" translate="yes" xml:space="preserve">
          <source>It is a non-binding request to reduce the memory usage without changing the size of the sequence. It depends on the implementation whether the request is fulfilled.</source>
          <target state="translated">这是一个非约束性的请求,目的是在不改变序列大小的情况下减少内存使用量。是否满足该请求取决于实施。</target>
        </trans-unit>
        <trans-unit id="d97fe75aaa98f7e001c2ef2b3b758e21ceb5c984" translate="yes" xml:space="preserve">
          <source>It is allowed for the same declaration to be found more than once:</source>
          <target state="translated">允许同一声明被发现一次以上。</target>
        </trans-unit>
        <trans-unit id="7acda9ca39c15e684583b5939db44164abbca690" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;code&gt;p&lt;/code&gt; does not refer to a symbolic link.</source>
          <target state="translated">如果 &lt;code&gt;p&lt;/code&gt; 不引用符号链接，则会出现错误。</target>
        </trans-unit>
        <trans-unit id="4ac6d6c59239a9e9a0945510352b875d15d0c303" translate="yes" xml:space="preserve">
          <source>It is equivalent to.</source>
          <target state="translated">它相当于:</target>
        </trans-unit>
        <trans-unit id="dd397495d30164a47687cc68d3ee3debb8de228e" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether &lt;code&gt;rand()&lt;/code&gt; is thread-safe.</source>
          <target state="translated">&lt;code&gt;rand()&lt;/code&gt; 是否是线程安全的，由实现定义。</target>
        </trans-unit>
        <trans-unit id="84efe53047a466556350dca48b226733f419c2a9" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether any &lt;a href=&quot;../language/objects#Alignment&quot;&gt;extended alignment&lt;/a&gt; is supported.</source>
          <target state="translated">是否支持任何&lt;a href=&quot;../language/objects#Alignment&quot;&gt;扩展对齐&lt;/a&gt;由实现定义。</target>
        </trans-unit>
        <trans-unit id="f3b9b360dbecc9ae1960b9e40b3f44904781af81" translate="yes" xml:space="preserve">
          <source>It is implementation-defined whether dynamic initialization happens-before the first statement of the main function (for statics) or the initial function of the thread (for thread-locals), or deferred to happen after.</source>
          <target state="translated">动态初始化是在主函数(对于静态)或线程的初始函数(对于线程-locals)的第一条语句之前发生,还是推迟到之后发生,这是由实现定义的。</target>
        </trans-unit>
        <trans-unit id="61a3a1813d80165d2df5ab50673ad21ec5aecc5a" translate="yes" xml:space="preserve">
          <source>It is implementation-defined which scalar types satisfy this trait, but unsigned(until C++20) integer types that do not use padding bits are guaranteed to have unique object representations.</source>
          <target state="translated">哪些标量类型满足这个特性是由实现定义的,但是不使用填充位的无符号(直到C++20)整数类型可以保证有唯一的对象表示。</target>
        </trans-unit>
        <trans-unit id="f452c9b19e8125eb753da2303a095249683e2189" translate="yes" xml:space="preserve">
          <source>It is important to remember this rule while ordering the header files of a translation unit. For more examples of the interplay between function overloads and function specializations, expand below:</source>
          <target state="translated">在对翻译单元的头文件进行排序时,记住这个规则是很重要的。关于函数重载和函数特殊化之间相互作用的更多例子,请在下面展开。</target>
        </trans-unit>
        <trans-unit id="84f7f9e6e1a9d37badb5dd8311ca6a0bc6dbdb31" translate="yes" xml:space="preserve">
          <source>It is intended that &lt;code&gt;Copyable&amp;lt;T&amp;gt;&lt;/code&gt; also requires &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;gt;&lt;/code&gt; (assignment from const rvalue) and &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;amp;&amp;gt;&lt;/code&gt; (assignment from non-const lvalue) to be satisfied.</source>
          <target state="translated">预期 &lt;code&gt;Copyable&amp;lt;T&amp;gt;&lt;/code&gt; 还需要满足 &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;gt;&lt;/code&gt; （从const rvalue赋值）和 &lt;code&gt;std::&lt;a href=&quot;assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, T&amp;amp;&amp;gt;&lt;/code&gt; （从非const lvalue赋值）。</target>
        </trans-unit>
        <trans-unit id="e89c6edc67ab990f4dbf2f94411a54a2785ae48a" translate="yes" xml:space="preserve">
          <source>It is legal to pass a pointer to a &lt;code&gt;va_list&lt;/code&gt; object to another function and then use that object after the function returns.</source>
          <target state="translated">将指向 &lt;code&gt;va_list&lt;/code&gt; 对象的指针传递给另一个函数是合法的，然后在该函数返回后使用该对象。</target>
        </trans-unit>
        <trans-unit id="600fa81257e98fe2222f530f6041ece9a9c792cf" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that immediately after setting the write time, the value returned by (1) is the same as what was passed as the argument to (2) because the file system's time may be more granular than &lt;code&gt;file_time_type&lt;/code&gt;.</source>
          <target state="translated">由于文件系统的时间可能比 &lt;code&gt;file_time_type&lt;/code&gt; 更精细，因此不能保证在设置写入时间后，（1）返回的值与作为（2）参数传递的值相同。</target>
        </trans-unit>
        <trans-unit id="19e7f91c42b80c040f054b6d4d2717f7558a91ea" translate="yes" xml:space="preserve">
          <source>It is not possible to change the precedence, grouping, or number of operands of operators.</source>
          <target state="translated">不能改变操作符的优先级、分组或操作数。</target>
        </trans-unit>
        <trans-unit id="d6f058ae02644804095fa603da188cdda6b78a90" translate="yes" xml:space="preserve">
          <source>It is not possible to query the current output format.</source>
          <target state="translated">无法查询当前的输出格式。</target>
        </trans-unit>
        <trans-unit id="ab4860699c3e4136650eba42ced4751e96f60a0f" translate="yes" xml:space="preserve">
          <source>It is not user-provided (meaning, it is implicitly-defined or defaulted);</source>
          <target state="translated">它不是用户提供的(意味着,它是隐式定义或默认的)。</target>
        </trans-unit>
        <trans-unit id="97be44c3bf3295b1767f75794d7dfeb5ea6fcc99" translate="yes" xml:space="preserve">
          <source>It is only safe to invoke the destructor if all threads have been notified. It is not required that they have exited their respective wait functions: some threads may still be waiting to reacquire the associated lock, or may be waiting to be scheduled to run after reacquiring it.</source>
          <target state="translated">只有在所有线程都得到通知的情况下,调用destructor才是安全的。并不要求它们已经退出了各自的等待函数:有些线程可能还在等待重新获取相关的锁,或者可能在等待重新获取锁后安排运行。</target>
        </trans-unit>
        <trans-unit id="e70768e4115e7101bd5fd956648b5b4a1a7b7407" translate="yes" xml:space="preserve">
          <source>It is permitted to call &lt;code&gt;shared_from_this&lt;/code&gt; only on a previously shared object, i.e. on an object managed by &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; (in particular, &lt;code&gt;shared_from_this&lt;/code&gt; cannot be called during construction of &lt;code&gt;*this&lt;/code&gt;).</source>
          <target state="translated">只允许在先前共享的对象上调用 &lt;code&gt;shared_from_this&lt;/code&gt; ，即在 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 管理的对象上（特别是，在 &lt;code&gt;*this&lt;/code&gt; 的构造过程中不能调用 &lt;code&gt;shared_from_this&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e237c9465035935c40984d4ba69fc9854677f449" translate="yes" xml:space="preserve">
          <source>It is permitted to call &lt;code&gt;shared_from_this&lt;/code&gt; only on a previously shared object, i.e. on an object managed by &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. Otherwise the behavior is undefined(until C++17)&lt;code&gt;&lt;a href=&quot;bad_weak_ptr&quot;&gt;std::bad_weak_ptr&lt;/a&gt;&lt;/code&gt; is thrown (by the shared_ptr constructor from a default-constructed &lt;code&gt;weak_this&lt;/code&gt;)(since C++17).</source>
          <target state="translated">只允许在以前共享的对象（即 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; &amp;lt;T&amp;gt;管理的对象）上调用 &lt;code&gt;shared_from_this&lt;/code&gt; 。否则，该行为是不确定的（直到C ++ 17 &lt;code&gt;weak_this&lt;/code&gt; ）（从C ++ 17开始）抛出 &lt;code&gt;&lt;a href=&quot;bad_weak_ptr&quot;&gt;std::bad_weak_ptr&lt;/a&gt;&lt;/code&gt; （由shared_ptr构造函数从默认构造的weak_this中抛出）。</target>
        </trans-unit>
        <trans-unit id="87374d898360b164d7d485ca958f9b4f6331b966" translate="yes" xml:space="preserve">
          <source>It is permitted to form references to references through type manipulations in templates or typedefs, in which case the</source>
          <target state="translated">允许通过模板或类型定义中的类型操作形成对引用的引用,在这种情况下。</target>
        </trans-unit>
        <trans-unit id="c212dba4876364523e05a1fc0269ee84b6e501a5" translate="yes" xml:space="preserve">
          <source>It is possible to construct &lt;code&gt;std::gslice&lt;/code&gt; objects that select some indices more than once: if the above example used the strides &lt;code&gt;{1,1,1} &lt;/code&gt;, the indices would have been &lt;code&gt;{3, 4, 5, 4, 5, 6, ...} &lt;/code&gt;. Such gslices may only be used as arguments to the const version of &lt;code&gt;std::valarray::operator[]&lt;/code&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">有可能构造 &lt;code&gt;std::gslice&lt;/code&gt; 该选择一些指数不止一次对象：如果上述例子中使用的步幅 &lt;code&gt;{1,1,1} &lt;/code&gt; ，指数将是 &lt;code&gt;{3, 4, 5, 4, 5, 6, ...} &lt;/code&gt; 。这样的gslice只能用作 &lt;code&gt;std::valarray::operator[]&lt;/code&gt; 的const版本的参数，否则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="4ede96757c156e593ca1e3cea610558948eb5cc8" translate="yes" xml:space="preserve">
          <source>It is possible to execute &lt;code&gt;delete this;&lt;/code&gt;, if the program can guarantee that the object was allocated by &lt;code&gt;new&lt;/code&gt;, however, this renders every pointer to the deallocated object invalid, including the &lt;code&gt;this&lt;/code&gt; pointer itself: after &lt;code&gt;delete this;&lt;/code&gt; returns, such member function cannot refer to a member of a class (since this involves an implicit dereference of &lt;code&gt;this&lt;/code&gt;) and no other member function may be called. This is used, for example, in the member function of the control block of &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; responsible for decrementing the reference count, when the last reference to the managed object goes out of scope.</source>
          <target state="translated">可以执行 &lt;code&gt;delete this;&lt;/code&gt; ，如果该程序可以保证该对象被分配 &lt;code&gt;new&lt;/code&gt; ，但是，这使得每个指针解除了分配的对象无效，包括 &lt;code&gt;this&lt;/code&gt; 指针本身：后 &lt;code&gt;delete this;&lt;/code&gt; 返回时，该成员函数不能指一类的成员（因为这涉及的隐含解引用 &lt;code&gt;this&lt;/code&gt; ）和没有其他成员函数可被调用。例如，当对托管对象的最后一个引用超出范围时，该变量将用于 &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 控制块的成员函数中，该函数负责减少引用计数。</target>
        </trans-unit>
        <trans-unit id="4f49e2aea7f63f794694b0764f8e62bb0888805b" translate="yes" xml:space="preserve">
          <source>It is safe, and in fact, preferable in generic code, to use deduction to forwarding reference, &lt;code&gt;for (auto&amp;amp;&amp;amp; var : sequence)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for (auto&amp;amp;&amp;amp; var : sequence)&lt;/code&gt; ，使用推论转发参考是安全的，实际上，在通用代码中更可取。</target>
        </trans-unit>
        <trans-unit id="6f58e92744c1e3c6d83adcd0474626686db527bd" translate="yes" xml:space="preserve">
          <source>It is said that a converting constructor specifies an implicit conversion from the types of its arguments (if any) to the type of its class. Note that non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; also specifies an implicit conversion.</source>
          <target state="translated">据说转换构造函数会指定从其参数类型（如果有）到其类类型的隐式转换。请注意，非显式&lt;a href=&quot;cast_operator&quot;&gt;用户定义的转换函数&lt;/a&gt;还指定了隐式转换。</target>
        </trans-unit>
        <trans-unit id="edfaaadef05ca0b8cdce0f012fc27fee94079175" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to ensure that &lt;code&gt;std::string_view&lt;/code&gt; does not outlive the pointed-to character array:</source>
          <target state="translated">确保 &lt;code&gt;std::string_view&lt;/code&gt; 不超过指向的字符数组是程序员的责任：</target>
        </trans-unit>
        <trans-unit id="a4d949d7d8bd7c5ac1b3559c799fce0b606f5cea" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to ensure that the &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object passed to the iterator's constructor outlives the iterator. Because the iterator stores a &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; which stores a pointer to the regex, incrementing the iterator after the regex was destroyed results in undefined behavior.</source>
          <target state="translated">确保传递给迭代器的构造函数的 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 对象的寿命超过迭代器是程序员的责任。因为迭代器存储了一个 &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; ，它存储了指向正则表达式的指针，所以在销毁正则表达式后增加迭代器会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="5d0ef4a8a26d0c98d105421ede3ede0ed4125959" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to ensure that the &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object passed to the iterator's constructor outlives the iterator. Because the iterator stores a pointer to the regex, incrementing the iterator after the regex was destroyed accesses a dangling pointer.</source>
          <target state="translated">确保传递给迭代器的构造函数的 &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; 对象的寿命超过迭代器是程序员的责任。因为迭代器存储了指向正则表达式的指针，所以在破坏正则表达式后增加迭代器将访问悬空指针。</target>
        </trans-unit>
        <trans-unit id="8ae84d20cf6f06aca28cb06cdba2bd625fad38b1" translate="yes" xml:space="preserve">
          <source>It is undefined behavior to reuse storage that is or was occupied by a const complete object of static, thread-local, or automatic storage duration because such objects may be stored in read-only memory.</source>
          <target state="translated">重用被静态的、线程本地的或自动存储持续时间的const complete对象所占用或曾经占用的存储是未定义的行为,因为这种对象可能存储在只读存储器中。</target>
        </trans-unit>
        <trans-unit id="48d04478371a33f8869a2e04a1a90a78036dbfec" translate="yes" xml:space="preserve">
          <source>It is unspecified how the implementation makes these adjustments. This means that a compiler may call an implementation-specific search function, in which case a user-defined specialization of &lt;code&gt;regex_search&lt;/code&gt; will not be called.</source>
          <target state="translated">尚不确定实现如何进行这些调整。这意味着编译器可以调用特定于实现的搜索功能，在这种情况下，将不会调用用户定义的 &lt;code&gt;regex_search&lt;/code&gt; 专业化。</target>
        </trans-unit>
        <trans-unit id="f7589f89a7b5d81e1f9bfdc1b0ceb532d0fc8435" translate="yes" xml:space="preserve">
          <source>It is unspecified when the past-the-end iterator is invalidated.</source>
          <target state="translated">当过去的结束迭代器无效时,它是不明确的。</target>
        </trans-unit>
        <trans-unit id="326b1cd1f8d02d7684396bd886d2e1c17251cc10" translate="yes" xml:space="preserve">
          <source>It is unspecified whether &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; is actually included when the standard library functions perform the swap, so the user-provided &lt;code&gt;swap()&lt;/code&gt; should not expect it to be included.</source>
          <target state="translated">未指定标准库函数执行交换时是否真正包含 &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; ，因此用户提供的 &lt;code&gt;swap()&lt;/code&gt; 不应期望包含它。</target>
        </trans-unit>
        <trans-unit id="c08baf030a373796ca075a1cddf067e089df15bb" translate="yes" xml:space="preserve">
          <source>It is unspecified whether library versions of &lt;code&gt;operator new&lt;/code&gt; make any calls to &lt;code&gt;&lt;a href=&quot;../c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;or &lt;code&gt;&lt;a href=&quot;../c/aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt;(since C++17).</source>
          <target state="translated">未指定 &lt;code&gt;operator new&lt;/code&gt; 的库版本是否对 &lt;code&gt;&lt;a href=&quot;../c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../c/aligned_alloc&quot;&gt;std::aligned_alloc&lt;/a&gt;&lt;/code&gt; 进行任何调用（自C ++ 17起）。</target>
        </trans-unit>
        <trans-unit id="a4ad188c2e57b182fa5e3f165eb2ba5d04005026" translate="yes" xml:space="preserve">
          <source>It is unspecified whether the destructor for the object referred to by &lt;code&gt;typeid&lt;/code&gt; is executed at the end of the program.</source>
          <target state="translated">未指定在程序结束时是否执行由 &lt;code&gt;typeid&lt;/code&gt; 引用的对象的析构函数。</target>
        </trans-unit>
        <trans-unit id="ba80c2d544e0bc888b885567b5eaf901bde4dfd1" translate="yes" xml:space="preserve">
          <source>It is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined copy assignment operator (same applies to &lt;a href=&quot;move_operator&quot;&gt;move assignment&lt;/a&gt;).</source>
          <target state="translated">尚不确定是否可以通过隐式定义的副本赋值运算符对继承基中可通过多个路径访问的虚拟基类子对象进行多次分配（与&lt;a href=&quot;move_operator&quot;&gt;移动赋值&lt;/a&gt;相同）。</target>
        </trans-unit>
        <trans-unit id="95593cbb778289249ae714a71b756ce2cf19a0ff" translate="yes" xml:space="preserve">
          <source>It is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined move assignment operator (same applies to &lt;a href=&quot;as_operator&quot;&gt;copy assignment&lt;/a&gt;).</source>
          <target state="translated">尚不确定是否可以通过隐式定义的移动赋值运算符多次（通过&lt;a href=&quot;as_operator&quot;&gt;复制赋值&lt;/a&gt;）对可通过继承晶格中多个路径访问的虚拟基类子对象进行多次分配。</target>
        </trans-unit>
        <trans-unit id="923b1d52d8265df676c6882541dea0ee1c7e5835" translate="yes" xml:space="preserve">
          <source>It is unspecified whether virtual base subobjects are compared more than once.</source>
          <target state="translated">虚基子对象是否不止一次比较,没有说明。</target>
        </trans-unit>
        <trans-unit id="b0253dc9c61d1b681c7e56bf36a208e187bd7459" translate="yes" xml:space="preserve">
          <source>It is up to the program to ensure that the alignment assumption actually holds. A call to &lt;code&gt;assume_aligned&lt;/code&gt; does not cause the compiler to verify or enforce this.</source>
          <target state="translated">程序要确保对齐假设确实成立。调用 &lt;code&gt;assume_aligned&lt;/code&gt; 不会导致编译器验证或强制执行此操作。</target>
        </trans-unit>
        <trans-unit id="c454768f7ee08c8dd39602a9d383338c66d1c6a9" translate="yes" xml:space="preserve">
          <source>It is used to represent offsets from stream positions (values of type &lt;code&gt;&lt;a href=&quot;fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt;). A &lt;code&gt;std::streamoff&lt;/code&gt; value of &lt;code&gt;-1&lt;/code&gt; is also used to represent error conditions by some of the I/O library functions.</source>
          <target state="translated">它用于表示与流位置的偏移量（类型为 &lt;code&gt;&lt;a href=&quot;fpos&quot;&gt;std::fpos&lt;/a&gt;&lt;/code&gt; 值）。甲 &lt;code&gt;std::streamoff&lt;/code&gt; 的值 &lt;code&gt;-1&lt;/code&gt; 也被某些I / O库函数来表示的错误条件。</target>
        </trans-unit>
        <trans-unit id="dc825523729ab0100d6865928993fc1eba1d20c0" translate="yes" xml:space="preserve">
          <source>It may be thrown by the member functions of &lt;code&gt;&lt;a href=&quot;../../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;, by &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stod&lt;/a&gt;&lt;/code&gt; families of functions, and by the bounds-checked member access functions (e.g. &lt;code&gt;&lt;a href=&quot;../../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../container/map/at&quot;&gt;std::map::at&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">它可能由 &lt;code&gt;&lt;a href=&quot;../../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; 的成员函数， &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stod&lt;/a&gt;&lt;/code&gt; 函数家族以及经过边界检查的成员访问函数（例如 &lt;code&gt;&lt;a href=&quot;../../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; :）抛出。at和 &lt;code&gt;&lt;a href=&quot;../../container/map/at&quot;&gt;std::map::at&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="e6c4c0849336c6395a555e7802361736a0a0c377" translate="yes" xml:space="preserve">
          <source>It may not be monotonic: on most systems, the system time can be adjusted at any moment. It is the only C++ clock that has the ability to map its time points to C-style time, and, therefore, to be displayed(until C++20).</source>
          <target state="translated">它可能不是单调的:在大多数系统上,系统时间可以随时调整。它是唯一一个能够将其时间点映射到C式时间的C++时钟,因此,可以显示(直到C++20)。</target>
        </trans-unit>
        <trans-unit id="4ff81608e3ae9cd2b8502e188922f1126aed8496" translate="yes" xml:space="preserve">
          <source>It must have a &lt;code&gt;constexpr&lt;/code&gt; constructor that takes some implementation-defined literal type.</source>
          <target state="translated">它必须具有采用某种实现定义的文字类型的 &lt;code&gt;constexpr&lt;/code&gt; 构造函数。</target>
        </trans-unit>
        <trans-unit id="a342065b388bf8640367f4a9dd97692d21114f7f" translate="yes" xml:space="preserve">
          <source>It owns the allocated memory and frees it on destruction, even if &lt;code&gt;deallocate&lt;/code&gt; has not been called for some of the allocated blocks.</source>
          <target state="translated">它拥有分配的内存并在销毁时将其释放，即使尚未为某些分配的块调用 &lt;code&gt;deallocate&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="747d8a8f672f5ac61ae339d4eb41b3ce9338913c" translate="yes" xml:space="preserve">
          <source>It provides a way to seed a large number of random number engines or to seed a generator that requires a lot of entropy, given a small seed or a poorly distributed initial seed sequence.</source>
          <target state="translated">它提供了一种方法,在给定一个小的种子或分布较差的初始种子序列的情况下,为大量的随机数引擎或需要大量熵的发生器提供种子。</target>
        </trans-unit>
        <trans-unit id="85a990d0ad9f04a8b78c0432369377fa53e60519" translate="yes" xml:space="preserve">
          <source>It provides the guarantee that all output made to the same final destination buffer (std::cout in the examples above) will be free of data races and will not be interleaved or garbled in any way, as long as every write to the that final destination buffer is made through (possibly different) instances of &lt;code&gt;std::basic_osyncstream&lt;/code&gt;.</source>
          <target state="translated">它提供了保证，对同一个最终目标缓冲区（上述示例中的std :: cout）进行的所有输出都不会出现数据争用，并且不会以任何方式被交错或出现乱码，只要每次写入那个最终变量目标缓冲区是通过 &lt;code&gt;std::basic_osyncstream&lt;/code&gt; 实例（可能是不同的）创建的。</target>
        </trans-unit>
        <trans-unit id="0cdae659e4031c70f43c202403b0e9b266332015" translate="yes" xml:space="preserve">
          <source>It returns the iterator itself, which makes it possible to use code such as &lt;code&gt;*iter = value&lt;/code&gt; to output (insert) the value into the underlying container.</source>
          <target state="translated">它返回迭代器本身，这使得可以使用 &lt;code&gt;*iter = value&lt;/code&gt; 代码将值输出（插入）到基础容器中。</target>
        </trans-unit>
        <trans-unit id="4e71ff091467aa53e4a20b3c8e2eb730c31146dd" translate="yes" xml:space="preserve">
          <source>It returns the iterator itself, which makes it possible to use code such as &lt;code&gt;*iter = value&lt;/code&gt; to output (insert) the value into the underlying stream.</source>
          <target state="translated">它返回迭代器本身，这使得可以使用 &lt;code&gt;*iter = value&lt;/code&gt; 代码将值输出（插入）到基础流中。</target>
        </trans-unit>
        <trans-unit id="3bcdb39cfdb013b01f34aa6003e5bc508f218b9f" translate="yes" xml:space="preserve">
          <source>It's unspecified if these functions zero out the fields in &lt;code&gt;*t&lt;/code&gt; that they do not set directly: portable programs should initialize every field to zero before calling &lt;code&gt;get()&lt;/code&gt;.</source>
          <target state="translated">这些函数是否将未直接设置的 &lt;code&gt;*t&lt;/code&gt; 中的字段清零（尚未确定）：可移植程序应在调用 &lt;code&gt;get()&lt;/code&gt; 之前将每个字段初始化为零。</target>
        </trans-unit>
        <trans-unit id="091b8d78ec3176b66348479ab0a7eba113756aa7" translate="yes" xml:space="preserve">
          <source>Iter</source>
          <target state="translated">Iter</target>
        </trans-unit>
        <trans-unit id="eaad30c6c7239ee4988afc79198142d6357df99b" translate="yes" xml:space="preserve">
          <source>Iteration statements</source>
          <target state="translated">迭代语句</target>
        </trans-unit>
        <trans-unit id="3e6a261991d848c9d7f1a6f775a1646474ac0d8e" translate="yes" xml:space="preserve">
          <source>Iteration statements repeatedly execute some code.</source>
          <target state="translated">迭代语句反复执行一些代码。</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="4dee12b442c04cdb4820f91dbc5c57a6bfcea0f2" translate="yes" xml:space="preserve">
          <source>Iterator adaptors</source>
          <target state="translated">迭代器适配器</target>
        </trans-unit>
        <trans-unit id="4d118461fd53be5789511318e9a62fde653cd961" translate="yes" xml:space="preserve">
          <source>Iterator associated types</source>
          <target state="translated">迭代器关联类型</target>
        </trans-unit>
        <trans-unit id="7dfb7f0ff3c8f35daf7e4c6ffdf06bc0e90e799b" translate="yes" xml:space="preserve">
          <source>Iterator categories</source>
          <target state="translated">迭代器类别</target>
        </trans-unit>
        <trans-unit id="4f31e7d075beed31a4d019c7620a3efff3cce0c6" translate="yes" xml:space="preserve">
          <source>Iterator category</source>
          <target state="translated">迭代器类</target>
        </trans-unit>
        <trans-unit id="45c0e163119730d64e4e88a9e88e486c24564923" translate="yes" xml:space="preserve">
          <source>Iterator category tags carry information that can be used to select the most efficient algorithms for the specific requirement set that is implied by the category.</source>
          <target state="translated">迭代器类别标签携带的信息可用于为该类别所隐含的特定需求集选择最有效的算法。</target>
        </trans-unit>
        <trans-unit id="1f22a4cac482679567538d501753a8d2f46eb0e0" translate="yes" xml:space="preserve">
          <source>Iterator concepts</source>
          <target state="translated">迭代器概念</target>
        </trans-unit>
        <trans-unit id="740d1be15d7c47c82fc9496173a7a69a59de33d0" translate="yes" xml:space="preserve">
          <source>Iterator customization points</source>
          <target state="translated">迭代器定制点</target>
        </trans-unit>
        <trans-unit id="e2f44595e956bf36ac4508978a8443a14cf70b6e" translate="yes" xml:space="preserve">
          <source>Iterator following the last removed element. If the iterator &lt;code&gt;pos&lt;/code&gt; refers to the last element, the &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; iterator is returned.</source>
          <target state="translated">最后删除的元素之后的迭代器。如果迭代器 &lt;code&gt;pos&lt;/code&gt; 指向最后一个元素，则返回 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 迭代器。</target>
        </trans-unit>
        <trans-unit id="0451248583f78c974b012649cf5f233b3518219f" translate="yes" xml:space="preserve">
          <source>Iterator in the destination range, pointing at the last element moved.</source>
          <target state="translated">在目标范围内的迭代器,指向最后一个移动的元素。</target>
        </trans-unit>
        <trans-unit id="40bd84a12b0a1ba291337eb5470a260a83e5f5e0" translate="yes" xml:space="preserve">
          <source>Iterator in the destination range, pointing past the last element copied if &lt;code&gt;count&amp;gt;0&lt;/code&gt; or &lt;code&gt;result&lt;/code&gt; otherwise.</source>
          <target state="translated">如果迭代器在目标范围内，指向过去的最后一个元素复制 &lt;code&gt;count&amp;gt;0&lt;/code&gt; 或 &lt;code&gt;result&lt;/code&gt; 其它。</target>
        </trans-unit>
        <trans-unit id="ca76fdc86a85ddcf65acd3db20c917b98cafb8cc" translate="yes" xml:space="preserve">
          <source>Iterator invalidation</source>
          <target state="translated">迭代器无效</target>
        </trans-unit>
        <trans-unit id="281878789a9bcc6f2d63b03ac4ff75d8b3e62807" translate="yes" xml:space="preserve">
          <source>Iterator library</source>
          <target state="translated">迭代器库</target>
        </trans-unit>
        <trans-unit id="03896d2a57195b9fd730686c9c0802a354747640" translate="yes" xml:space="preserve">
          <source>Iterator one past the last element assigned if &lt;code&gt;count &amp;gt; 0&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; otherwise.</source>
          <target state="translated">如果 &lt;code&gt;count &amp;gt; 0&lt;/code&gt; ，则迭代最后一个分配的元素，否则返回 &lt;code&gt;first&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="daf74fe0d4457d50bd01e94a09fc1b13a7e9ff50" translate="yes" xml:space="preserve">
          <source>Iterator one past the last element assigned if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; otherwise.</source>
          <target state="translated">迭代器一个过去的最后一个元素分配如果 &lt;code&gt;count&amp;gt;0&lt;/code&gt; ， &lt;code&gt;first&lt;/code&gt; 否则。</target>
        </trans-unit>
        <trans-unit id="2663ac3786b007e1d7f5bd8a7c0213e70730b1d7" translate="yes" xml:space="preserve">
          <source>Iterator operations</source>
          <target state="translated">迭代器操作</target>
        </trans-unit>
        <trans-unit id="f4dd65c96326a21c8c14e8530698df94d1156bd2" translate="yes" xml:space="preserve">
          <source>Iterator operations (e.g. incrementing an iterator) read, but do not modify the underlying container, and may be executed concurrently with operations on other iterators on the same container, with the const member functions, or reads from the elements. Container operations that invalidate any iterators modify the container and cannot be executed concurrently with any operations on existing iterators even if those iterators are not invalidated.</source>
          <target state="translated">迭代器操作(例如递增迭代器)读取但不修改底层容器,可以与对同一容器上的其他迭代器的操作、const成员函数或从元素中读取的操作同时执行。使任何迭代器无效的容器操作会修改容器,并且不能与对现有迭代器的任何操作同时执行,即使这些迭代器没有被无效。</target>
        </trans-unit>
        <trans-unit id="d40f4ce641e0ed75eeba005dc0c9d3144fe2cd68" translate="yes" xml:space="preserve">
          <source>Iterator past the end of the constructed range.</source>
          <target state="translated">迭代器经过构造范围的末端。</target>
        </trans-unit>
        <trans-unit id="13fa518a2303933b7f035ca34918a1466f897682" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was parsed successfully.</source>
          <target state="translated">迭代器指向成功解析的 &lt;code&gt;[beg, end)&lt;/code&gt; 中最后一个字符之后的一个。</target>
        </trans-unit>
        <trans-unit id="8307d2d53c29a25c0e984348242a9471e3ee81a1" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid date.</source>
          <target state="translated">迭代器指向 &lt;code&gt;[beg, end)&lt;/code&gt; 中最后一个字符之后的一个，该字符被视为有效日期的一部分。</target>
        </trans-unit>
        <trans-unit id="f64d4fa39c12455a17caddb09b8107c7a4df881a" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid month name.</source>
          <target state="translated">迭代器指向 &lt;code&gt;[beg, end)&lt;/code&gt; 中最后一个字符之后的一个，该字符被识别为有效月份名称的一部分。</target>
        </trans-unit>
        <trans-unit id="31e9b344102f3edc337a21ee322aadf820b9757e" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid weekname.</source>
          <target state="translated">迭代器指向 &lt;code&gt;[beg, end)&lt;/code&gt; 中最后一个字符之后的一个，该字符被识别为有效星期名称的一部分。</target>
        </trans-unit>
        <trans-unit id="31207a4529bcf9380d04c9069cc1655551460207" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character in &lt;code&gt;[beg, end)&lt;/code&gt; that was recognized as a part of a valid year.</source>
          <target state="translated">指向 &lt;code&gt;[beg, end)&lt;/code&gt; 中最后一个字符的迭代器，该字符被认为是有效年份的一部分。</target>
        </trans-unit>
        <trans-unit id="7f09da5861ec2d1af9b0e94d0a6f97c745163842" translate="yes" xml:space="preserve">
          <source>Iterator pointing one past the last character that was produced .</source>
          <target state="translated">迭代器指向一个过去产生的最后一个字符。</target>
        </trans-unit>
        <trans-unit id="2cbfd446fa55ac919f1565a7433ab297897ff7cd" translate="yes" xml:space="preserve">
          <source>Iterator pointing to the emplaced element.</source>
          <target state="translated">指向被安置元素的迭代器。</target>
        </trans-unit>
        <trans-unit id="3f31d65a0a3b3c0a3916fdb12c528f4639b09cbb" translate="yes" xml:space="preserve">
          <source>Iterator pointing to the first element that is</source>
          <target state="translated">迭代器指向的第一个元素是</target>
        </trans-unit>
        <trans-unit id="be0840eb05b1b352b3e742ca7bea27adaa5d7b17" translate="yes" xml:space="preserve">
          <source>Iterator pointing to the first element that is not</source>
          <target state="translated">迭代器指向的第一个元素不是</target>
        </trans-unit>
        <trans-unit id="e185fa2c4bb3e71229767b9d27a937494c54ba69" translate="yes" xml:space="preserve">
          <source>Iterator primitives</source>
          <target state="translated">迭代器基元</target>
        </trans-unit>
        <trans-unit id="10484316b5b2a8004d6321237a6c2d261f03e5f9" translate="yes" xml:space="preserve">
          <source>Iterator tags</source>
          <target state="translated">迭代器标签</target>
        </trans-unit>
        <trans-unit id="ae607ca99d952a6e9f09c84027726aaa7bfec65b" translate="yes" xml:space="preserve">
          <source>Iterator to an element with key equivalent to &lt;code&gt;key&lt;/code&gt;. If no such element is found, past-the-end (see &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;) iterator is returned.</source>
          <target state="translated">迭代到键等于 &lt;code&gt;key&lt;/code&gt; 的元素。如果找不到这样的元素，则返回过去的结束（请参阅 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; ）迭代器。</target>
        </trans-unit>
        <trans-unit id="9278ea56b5788d570f426ec7cbcb9a565e893cd1" translate="yes" xml:space="preserve">
          <source>Iterator to one past the last element of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">迭代到 &lt;code&gt;a&lt;/code&gt; 的最后一个元素</target>
        </trans-unit>
        <trans-unit id="b813a67f31fb479727b79b93d1bb1438b02ec92e" translate="yes" xml:space="preserve">
          <source>Iterator to one past the last value in the numeric array.</source>
          <target state="translated">迭代器到数字数组中最后一个值的过去。</target>
        </trans-unit>
        <trans-unit id="b07ec936a0496c6833779c2921debff842152dd7" translate="yes" xml:space="preserve">
          <source>Iterator to the beginning of last occurrence of the sequence &lt;code&gt;[s_first, s_last)&lt;/code&gt; in range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">迭代到范围 &lt;code&gt;[first, last)&lt;/code&gt; 序列 &lt;code&gt;[s_first, s_last)&lt;/code&gt; 的最后一次出现的开始。</target>
        </trans-unit>
        <trans-unit id="cea2fc59b7d3bb9197c3cb893d4095461e65324e" translate="yes" xml:space="preserve">
          <source>Iterator to the beginning of the found sequence in the range &lt;code&gt;[first, last)&lt;/code&gt;. If no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">迭代到 &lt;code&gt;[first, last)&lt;/code&gt; 范围内找到的序列的开头。如果找不到这样的序列，则返回 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b99865a2f5ee2de11db467c05b05ecda3a38125e" translate="yes" xml:space="preserve">
          <source>Iterator to the element before the first element.</source>
          <target state="translated">迭代到第一个元素之前的元素。</target>
        </trans-unit>
        <trans-unit id="aacd4e93e79a35d8d4d88a56fccd361ca76b515c" translate="yes" xml:space="preserve">
          <source>Iterator to the element following the last element.</source>
          <target state="translated">迭代到最后一个元素之后的元素。</target>
        </trans-unit>
        <trans-unit id="d47c96b870ac902b9cfccfbc43f02d3063565e47" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element copied.</source>
          <target state="translated">迭代器到最后一个元素复制后的元素。</target>
        </trans-unit>
        <trans-unit id="96509680368807f6fc1a0194dd4883b178732836" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element exchanged in the range beginning with &lt;code&gt;first2&lt;/code&gt;.</source>
          <target state="translated">迭代到从 &lt;code&gt;first2&lt;/code&gt; 开始的范围中交换的最后一个元素之后的元素。</target>
        </trans-unit>
        <trans-unit id="7a39ffa9063e11b7b654f129a912184da2ac6267" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element moved.</source>
          <target state="translated">迭代到最后一个元素过去的元素。</target>
        </trans-unit>
        <trans-unit id="1b5d7dd5569e766929089fcefe6c58bc9d731aa5" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last element written.</source>
          <target state="translated">迭代器到最后写入的元素。</target>
        </trans-unit>
        <trans-unit id="6bea32d087ab585bed1f7fe96375cf86af1211fa" translate="yes" xml:space="preserve">
          <source>Iterator to the element past the last sub-match.</source>
          <target state="translated">迭代器到元素过去的最后一个子匹配。</target>
        </trans-unit>
        <trans-unit id="60a6218c749d504f60e9f3fa5bf31fa53f0671ac" translate="yes" xml:space="preserve">
          <source>Iterator to the first element in the range &lt;code&gt;[first, last)&lt;/code&gt; that is equal to an element from the range &lt;code&gt;[s_first; s_last)&lt;/code&gt;. If no such element is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">迭代范围为 &lt;code&gt;[first, last)&lt;/code&gt; 一个元素，该元素等于范围为 &lt;code&gt;[s_first; s_last)&lt;/code&gt; 的元素。s_last）。如果找不到这样的元素，则返回 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="744169b8a1b971b02107d9fd30c4e5ed51e12ef8" translate="yes" xml:space="preserve">
          <source>Iterator to the first element of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">迭代器的第一元件 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5fdfe83ec17cb438ffef8507e749f160d782415" translate="yes" xml:space="preserve">
          <source>Iterator to the first element of the second group.</source>
          <target state="translated">迭代到第二组的第一个元素。</target>
        </trans-unit>
        <trans-unit id="1cbe4199bf321f6884c70afda2be99aff476ac84" translate="yes" xml:space="preserve">
          <source>Iterator to the first element satisfying the condition or &lt;code&gt;last&lt;/code&gt; if no such element is found.</source>
          <target state="translated">迭代到第一个满足条件的元素，如果没有找到则返回 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4b75fadcd5e3ebde98aa445d8daad03877fd6a8" translate="yes" xml:space="preserve">
          <source>Iterator to the first element.</source>
          <target state="translated">迭代到第一个元素。</target>
        </trans-unit>
        <trans-unit id="55aa966d43052a99cbd2f2b66a9a360393c342eb" translate="yes" xml:space="preserve">
          <source>Iterator to the first sub-match.</source>
          <target state="translated">迭代器到第一个子匹配。</target>
        </trans-unit>
        <trans-unit id="5580fefb10d0046c754d643bd5733ccca8b1345e" translate="yes" xml:space="preserve">
          <source>Iterator to the first value in the numeric array.</source>
          <target state="translated">数字数组中第一个值的迭代器。</target>
        </trans-unit>
        <trans-unit id="ea592c537962f37901180bcbeecea954bf89d9fa" translate="yes" xml:space="preserve">
          <source>Iterator to the greatest element in the range &lt;code&gt;[first, last)&lt;/code&gt;. If several elements in the range are equivalent to the greatest element, returns the iterator to the first such element. Returns &lt;code&gt;last&lt;/code&gt; if the range is empty.</source>
          <target state="translated">迭代到 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的最大元素。如果范围中的几个元素等于最大元素，则将迭代器返回到第一个此类元素。如果范围为空，则返回 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cab09d343a65548dadf0705016f36b2bc1aec5ff" translate="yes" xml:space="preserve">
          <source>Iterator to the smallest element in the range &lt;code&gt;[first, last)&lt;/code&gt;. If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns &lt;code&gt;last&lt;/code&gt; if the range is empty.</source>
          <target state="translated">迭代到 &lt;code&gt;[first, last)&lt;/code&gt; 范围内的最小元素。如果范围中的几个元素等于最小的元素，则将迭代器返回到第一个此类元素。如果范围为空，则返回 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="162032b2b677de764fe8e5f27091a7c4e6a44150" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. If the element is the last element in the container, the past-the-end iterator is also invalidated. Other references and iterators are not affected.</source>
          <target state="translated">迭代器和对被擦除元素的引用都无效。如果该元素是容器中的最后一个元素,那么过去结束的迭代器也无效。其他引用和迭代器不受影响。</target>
        </trans-unit>
        <trans-unit id="e582a97f0f7104a2e13358f17facd4235fcb6d40" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. It is unspecified whether the past-the-end iterator is invalidated if the element is the last element in the container. Other references and iterators are not affected.</source>
          <target state="translated">迭代器和对被擦除元素的引用无效。如果该元素是容器中的最后一个元素,则过去-结束迭代器是否无效,这一点没有说明。其他引用和迭代器不受影响。</target>
        </trans-unit>
        <trans-unit id="4c5b6d9e93629888dbe6bf92a0305e9d1ac53f56" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. It is unspecified whether the past-the-end iterator is invalidated. Other references and iterators are not affected.</source>
          <target state="translated">迭代器和对被擦除元素的引用无效。过去结束的迭代器是否无效还未明确。其他引用和迭代器不受影响。</target>
        </trans-unit>
        <trans-unit id="420aea18856c45985924dcd36529cee071e75fd3" translate="yes" xml:space="preserve">
          <source>Iterators and references to the erased element are invalidated. The past-the-end iterator is also invalidated. Other references and iterators are not affected.</source>
          <target state="translated">迭代器和对被擦除元素的引用都是无效的。过去结束的迭代器也无效。其他引用和迭代器不受影响。</target>
        </trans-unit>
        <trans-unit id="f88e8afffd84ac565f746527f36f9909c4f45150" translate="yes" xml:space="preserve">
          <source>Iterators are not dereferenceable if.</source>
          <target state="translated">如果以下情况,迭代器不能被取消引用:</target>
        </trans-unit>
        <trans-unit id="05eeb7b671baac73a3dc80180a6545670e55373f" translate="yes" xml:space="preserve">
          <source>Iterators for which the behavior of the expression &lt;code&gt;*i&lt;/code&gt; is defined are called</source>
          <target state="translated">定义了表达式 &lt;code&gt;*i&lt;/code&gt; 行为的迭代器称为</target>
        </trans-unit>
        <trans-unit id="6d7e7b94342bc88f5dc26254b6ed839ec8bfb385" translate="yes" xml:space="preserve">
          <source>Iterators library</source>
          <target state="translated">迭代器库</target>
        </trans-unit>
        <trans-unit id="7987698c6d69adbd970dfb91d269e601291f3c2e" translate="yes" xml:space="preserve">
          <source>Iterators that fall into one of the above categories and also meet the requirements of &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; are called contiguous iterators.</source>
          <target state="translated">属于上述类别之一并且还满足&lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;要求的迭代器称为连续迭代器。</target>
        </trans-unit>
        <trans-unit id="c0510377d9129680624a5c7430c75a54b51eeddb" translate="yes" xml:space="preserve">
          <source>Iterators that fall into one of the above categories and also meet the requirements of &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; are called mutable iterators.</source>
          <target state="translated">属于上述类别之一并且还满足&lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;要求的迭代器称为可变迭代器。</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="273fff5103ab0399a739b1cec1bc3d252efc223f" translate="yes" xml:space="preserve">
          <source>JAPANESE INDUSTRIAL STANDARD SYMBOL - IDEOGRAPHIC NUMBER ZERO</source>
          <target state="translated">日本工业标准符号-IDEOGRAPHIC数字ZERO</target>
        </trans-unit>
        <trans-unit id="6c943af0faee20a16a4d1c5eaf93012533909700" translate="yes" xml:space="preserve">
          <source>Jacobi amplitude (a value of floating-point or integral type, measured in radians)</source>
          <target state="translated">雅各比振幅</target>
        </trans-unit>
        <trans-unit id="bdfb777e0387993e2e3d113ac36512201456491d" translate="yes" xml:space="preserve">
          <source>Jump statements</source>
          <target state="translated">跳跃声明</target>
        </trans-unit>
        <trans-unit id="bb520de1f12d4fa9ce54eeee10e58e891322ab58" translate="yes" xml:space="preserve">
          <source>Jump statements unconditionally transfer flow control.</source>
          <target state="translated">跳转语句无条件转移流控。</target>
        </trans-unit>
        <trans-unit id="dcbf88c31714264b514798a7ba1a0f7ac134056f" translate="yes" xml:space="preserve">
          <source>Just as with a traditional loop, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used to exit the loop early and a &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used to restart the loop with the next element.</source>
          <target state="translated">与传统循环一样，可以使用&lt;a href=&quot;break&quot;&gt;break语句&lt;/a&gt;提前退出循环，并可以使用&lt;a href=&quot;continue&quot;&gt;continue语句&lt;/a&gt;从下一个元素重新开始循环。</target>
        </trans-unit>
        <trans-unit id="36d6db48eace81a33b705adbb64b285f0559048e" translate="yes" xml:space="preserve">
          <source>Just before becoming the end-of-sequence iterator, a &lt;code&gt;std::regex_token_iterator&lt;/code&gt; may become a</source>
          <target state="translated">在成为序列结束迭代器之前， &lt;code&gt;std::regex_token_iterator&lt;/code&gt; 可能会成为</target>
        </trans-unit>
        <trans-unit id="c59dd0c7462928fa236b7f578176acd87d90eab2" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::packaged_task&lt;/code&gt; is a polymorphic, allocator-aware container: the stored callable target may be allocated on heap or with a provided allocator.</source>
          <target state="translated">就像 &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;std::packaged_task&lt;/code&gt; 是一个多态的，可识别分配器的容器：可以在堆上或使用提供的分配器分配存储的可调用目标。</target>
        </trans-unit>
        <trans-unit id="31d4b9f30362c85a4f4a427bba244a69e9b807a9" translate="yes" xml:space="preserve">
          <source>Just like in &lt;a href=&quot;classes&quot;&gt;struct&lt;/a&gt; declaration, the default member access in a union is &lt;a href=&quot;access&quot;&gt;public&lt;/a&gt;.</source>
          <target state="translated">就像在&lt;a href=&quot;classes&quot;&gt;struct&lt;/a&gt;声明中一样，联合中的默认成员访问权限是&lt;a href=&quot;access&quot;&gt;public&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="74e2c21175f1eb09564bc31283c20889926ace69" translate="yes" xml:space="preserve">
          <source>Just like with members of primary templates, they only need to be defined if used in the program.</source>
          <target state="translated">就像初级模板的成员一样,只有在程序中使用时才需要定义它们。</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="0f2005c51f34f60847d9627b7dadf8093b2d0c22" translate="yes" xml:space="preserve">
          <source>K), GNSUM(op, a</source>
          <target state="translated">K),GNSUM(op,a)</target>
        </trans-unit>
        <trans-unit id="237e3ecc9a063e55a6f9fd6d2f03d4b8adf12c9a" translate="yes" xml:space="preserve">
          <source>K), GSUM(op, b</source>
          <target state="translated">K),GSUM(OP,b</target>
        </trans-unit>
        <trans-unit id="7e6d3d8f6e5c6078631d54fbfd4b0dea03e2e179" translate="yes" xml:space="preserve">
          <source>Keep the existing file, without reporting an error.</source>
          <target state="translated">保留现有文件,不报错。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="6f7fcc18225d37208291e381d4c7a5f47bd1ba73" translate="yes" xml:space="preserve">
          <source>LANGUAGE TAG (U+E0001) - VARIATION SELECTOR-256 (U+E01EF)</source>
          <target state="translated">语言标签(U+E0001)-变化选择器-256 (U+E01EF)</target>
        </trans-unit>
        <trans-unit id="503ecf5371128a4d54cb093dfb32e39ad03cc18f" translate="yes" xml:space="preserve">
          <source>LATIN CAPITAL LETTER A WITH GRAVE - LATIN CAPITAL LETTER O WITH DIAERESIS</source>
          <target state="translated">拉丁文大写字母A与坟墓-拉丁文大写字母O与DIAERESIS。</target>
        </trans-unit>
        <trans-unit id="cb668f2f6c1dafcf47fe99fa01b751c3e0263d0b" translate="yes" xml:space="preserve">
          <source>LATIN CAPITAL LETTER O WITH STROKE - LATIN SMALL LETTER O WITH DIAERESIS</source>
          <target state="translated">LATIN CAPITAL LETTER O WITH STROKE-LATIN SMALL LETTER O WITH DIAERESIS(拉丁字母O)。</target>
        </trans-unit>
        <trans-unit id="b2be5f99f56a223f3c293b996a761c0efa14627e" translate="yes" xml:space="preserve">
          <source>LATIN SMALL LETTER O WITH STROKE - CANADIAN SYLLABICS BLACKFOOT W</source>
          <target state="translated">拉脱维亚语小字O加条纹-CANADIAN SYLLABICS BLACKFOOT W。</target>
        </trans-unit>
        <trans-unit id="b4da84710b41fc09dd78f93b82fe6010bab5fd27" translate="yes" xml:space="preserve">
          <source>LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME</source>
          <target state="translated">LC_ALLLC_COLLATELC_CTYPELC_MONETARYLC_NUMERICLC_TIME</target>
        </trans-unit>
        <trans-unit id="823feb18075201a2009bf899a2b4bee49397d8df" translate="yes" xml:space="preserve">
          <source>LC_TIME</source>
          <target state="translated">LC_TIME</target>
        </trans-unit>
        <trans-unit id="3fd1097fbc5a624096c5064ce332869e38dcdca6" translate="yes" xml:space="preserve">
          <source>LEFT-TO-RIGHT EMBEDDING - RIGHT-TO-LEFT OVERRIDE</source>
          <target state="translated">从左到右嵌入-从右到左覆盖</target>
        </trans-unit>
        <trans-unit id="0ada04f560eef4501438475ec6acb0a8112461d2" translate="yes" xml:space="preserve">
          <source>LINEAR B SYLLABLE B008 A - CHEESE WEDGE (U+1F9C0)</source>
          <target state="translated">LINEAR B SYLLABLE B008 A-CHEESE WEDGE (U+1F9C0)</target>
        </trans-unit>
        <trans-unit id="65a740810ab447ffb984bd6fdf5448611bcca5d2" translate="yes" xml:space="preserve">
          <source>LLP64</source>
          <target state="translated">LLP64</target>
        </trans-unit>
        <trans-unit id="7ec33462cf14446f400924757e3fbb4271e0e95e" translate="yes" xml:space="preserve">
          <source>LLVM libc++ stores 1 less member: it maintains the rdbuf pointer as a void* member of ios_base.</source>
          <target state="translated">LLVM libc++少存储了1个成员:它把rdbuf指针维护成ios_base的void*成员。</target>
        </trans-unit>
        <trans-unit id="bee2cfeb49f65a60be1386935bbd919b5ec97964" translate="yes" xml:space="preserve">
          <source>LP32</source>
          <target state="translated">LP32</target>
        </trans-unit>
        <trans-unit id="6cb8b2a9a5c6dacaca21f4343040021510d35c97" translate="yes" xml:space="preserve">
          <source>LP64</source>
          <target state="translated">LP64</target>
        </trans-unit>
        <trans-unit id="886ea7c4764552dcb2bbbe1db0b81daf2c0b4980" translate="yes" xml:space="preserve">
          <source>LWG 103</source>
          <target state="translated">LWG 103</target>
        </trans-unit>
        <trans-unit id="9de8fb82db7ea881cdd4818eeacc5cb88103d780" translate="yes" xml:space="preserve">
          <source>LWG 2021</source>
          <target state="translated">LWG 2021</target>
        </trans-unit>
        <trans-unit id="706cd71dbc70f54b74c9e4ca12893e72483f65ac" translate="yes" xml:space="preserve">
          <source>LWG 2048</source>
          <target state="translated">LWG 2048</target>
        </trans-unit>
        <trans-unit id="389f244b561a8b2e450ab0c1b620aab9c04f7844" translate="yes" xml:space="preserve">
          <source>LWG 2063</source>
          <target state="translated">LWG 2063</target>
        </trans-unit>
        <trans-unit id="31dc00d2b0f8ffb9c931311abf894031771bb886" translate="yes" xml:space="preserve">
          <source>LWG 2067</source>
          <target state="translated">LWG 2067</target>
        </trans-unit>
        <trans-unit id="deb8bac4bda6e7ac7927ac3f217096d074e4651c" translate="yes" xml:space="preserve">
          <source>LWG 2101</source>
          <target state="translated">LWG 2101</target>
        </trans-unit>
        <trans-unit id="96c382be88841f29be2b8476fd6eff0e02b692b5" translate="yes" xml:space="preserve">
          <source>LWG 2111</source>
          <target state="translated">LWG 2111</target>
        </trans-unit>
        <trans-unit id="d6e902d68f062e389836f2f573f3f247e27c9102" translate="yes" xml:space="preserve">
          <source>LWG 2141</source>
          <target state="translated">LWG 2141</target>
        </trans-unit>
        <trans-unit id="723eb1c8bcf878531e1514ce67bc69259241d3c4" translate="yes" xml:space="preserve">
          <source>LWG 2193</source>
          <target state="translated">LWG 2193</target>
        </trans-unit>
        <trans-unit id="810962e6457ba64d5c3482fefe25972a3420fcff" translate="yes" xml:space="preserve">
          <source>LWG 2231</source>
          <target state="translated">LWG 2231</target>
        </trans-unit>
        <trans-unit id="07b5419b2eca5506d8ab14a0d772cee5a0b24141" translate="yes" xml:space="preserve">
          <source>LWG 2316</source>
          <target state="translated">LWG 2316</target>
        </trans-unit>
        <trans-unit id="234d204a978e35929b3a3e894af0d8b867af1065" translate="yes" xml:space="preserve">
          <source>LWG 2377</source>
          <target state="translated">LWG 2377</target>
        </trans-unit>
        <trans-unit id="0de14022bde80593834d413238d25e72ecbcc411" translate="yes" xml:space="preserve">
          <source>LWG 2396</source>
          <target state="translated">LWG 2396</target>
        </trans-unit>
        <trans-unit id="98c9816aa981f67350096307bddd08234109379b" translate="yes" xml:space="preserve">
          <source>LWG 2408</source>
          <target state="translated">LWG 2408</target>
        </trans-unit>
        <trans-unit id="88897052b0b54ca7be3e73d84b0b00921d9e552c" translate="yes" xml:space="preserve">
          <source>LWG 2420</source>
          <target state="translated">LWG 2420</target>
        </trans-unit>
        <trans-unit id="4df86d5ce11e282b81c2bbb5175527f98652fcef" translate="yes" xml:space="preserve">
          <source>LWG 2422</source>
          <target state="translated">LWG 2422</target>
        </trans-unit>
        <trans-unit id="84b18947260bfe1f0a5996d405140bb230ae0767" translate="yes" xml:space="preserve">
          <source>LWG 2441</source>
          <target state="translated">LWG 2441</target>
        </trans-unit>
        <trans-unit id="cbfcae2a308f80ed1c6f7b0aa1df94fb40aaf739" translate="yes" xml:space="preserve">
          <source>LWG 2442</source>
          <target state="translated">LWG 2442</target>
        </trans-unit>
        <trans-unit id="39d7d59672fbad6538e7af83c470ceced5e98772" translate="yes" xml:space="preserve">
          <source>LWG 2444</source>
          <target state="translated">LWG 2444</target>
        </trans-unit>
        <trans-unit id="64c015ca6fb365162de4d9802c96ff79810e3eba" translate="yes" xml:space="preserve">
          <source>LWG 2456</source>
          <target state="translated">LWG 2456</target>
        </trans-unit>
        <trans-unit id="479bc2ddf5e751a671056d086c6f5edd270c71fa" translate="yes" xml:space="preserve">
          <source>LWG 2458</source>
          <target state="translated">LWG 2458</target>
        </trans-unit>
        <trans-unit id="1edc38665e8899d906240e69ba2477977706ba89" translate="yes" xml:space="preserve">
          <source>LWG 2459</source>
          <target state="translated">LWG 2459</target>
        </trans-unit>
        <trans-unit id="6be2a0368db7a8aa977aee824cc855ad8d6cb8b3" translate="yes" xml:space="preserve">
          <source>LWG 2460</source>
          <target state="translated">LWG 2460</target>
        </trans-unit>
        <trans-unit id="40c67758d05b4454663ae12087f93b2294a7887e" translate="yes" xml:space="preserve">
          <source>LWG 2485</source>
          <target state="translated">LWG 2485</target>
        </trans-unit>
        <trans-unit id="ef5117f94807e8fa3fd3d6d510e7ee4f699f4b23" translate="yes" xml:space="preserve">
          <source>LWG 2510</source>
          <target state="translated">LWG 2510</target>
        </trans-unit>
        <trans-unit id="5f130db76eea1dbe14493e67e4a16dbe505a9e2e" translate="yes" xml:space="preserve">
          <source>LWG 2550</source>
          <target state="translated">LWG 2550</target>
        </trans-unit>
        <trans-unit id="ca02fd1a836a738f855f4be277ea46227c2c6ff3" translate="yes" xml:space="preserve">
          <source>LWG 2554</source>
          <target state="translated">LWG 2554</target>
        </trans-unit>
        <trans-unit id="41e9bbe3caae10f06305c082750ab7abc56ee095" translate="yes" xml:space="preserve">
          <source>LWG 2556</source>
          <target state="translated">LWG 2556</target>
        </trans-unit>
        <trans-unit id="a7fa4024fcd73ba7048d1081eb12cb834158b7ab" translate="yes" xml:space="preserve">
          <source>LWG 2597</source>
          <target state="translated">LWG 2597</target>
        </trans-unit>
        <trans-unit id="f677e3426681f881a680fe99e83000652b32a988" translate="yes" xml:space="preserve">
          <source>LWG 2682</source>
          <target state="translated">LWG 2682</target>
        </trans-unit>
        <trans-unit id="81d82ea92f45eea83f18af5577cc2d919bfe90d4" translate="yes" xml:space="preserve">
          <source>LWG 270</source>
          <target state="translated">LWG 270</target>
        </trans-unit>
        <trans-unit id="8e573b1dfb07e6658a7360ffdc338e9b3f93b49f" translate="yes" xml:space="preserve">
          <source>LWG 2735</source>
          <target state="translated">LWG 2735</target>
        </trans-unit>
        <trans-unit id="227dbdd98899cadd424a56e2f7d7d6a78f38856f" translate="yes" xml:space="preserve">
          <source>LWG 2739</source>
          <target state="translated">LWG 2739</target>
        </trans-unit>
        <trans-unit id="9eb33f94aa6faf46b0eb2f66260ee186604d4a50" translate="yes" xml:space="preserve">
          <source>LWG 2782</source>
          <target state="translated">LWG 2782</target>
        </trans-unit>
        <trans-unit id="d920e722f9f2beb6d3d46c97d699d7aca6281fdd" translate="yes" xml:space="preserve">
          <source>LWG 2783</source>
          <target state="translated">LWG 2783</target>
        </trans-unit>
        <trans-unit id="63dbc60824b85913f49c89b16c9025b3daf3402a" translate="yes" xml:space="preserve">
          <source>LWG 2843</source>
          <target state="translated">LWG 2843</target>
        </trans-unit>
        <trans-unit id="fdaad41a94231184e89d21323eb4df5beb258d0e" translate="yes" xml:space="preserve">
          <source>LWG 2870</source>
          <target state="translated">LWG 2870</target>
        </trans-unit>
        <trans-unit id="63de5c8018c8f07659e2254629b4ebfecbdf0e68" translate="yes" xml:space="preserve">
          <source>LWG 2901</source>
          <target state="translated">LWG 2901</target>
        </trans-unit>
        <trans-unit id="65a38639ef5dfa6b953951bf416dbef1b06d2565" translate="yes" xml:space="preserve">
          <source>LWG 2935</source>
          <target state="translated">LWG 2935</target>
        </trans-unit>
        <trans-unit id="8df8d07f79de7eff959bd46fc88293ce52ce6252" translate="yes" xml:space="preserve">
          <source>LWG 2936</source>
          <target state="translated">LWG 2936</target>
        </trans-unit>
        <trans-unit id="6af1a8a4fbc321bb616e82f22c084066312fc066" translate="yes" xml:space="preserve">
          <source>LWG 2937</source>
          <target state="translated">LWG 2937</target>
        </trans-unit>
        <trans-unit id="620d7168575a023def1c823681197877ef6db868" translate="yes" xml:space="preserve">
          <source>LWG 2942</source>
          <target state="translated">LWG 2942</target>
        </trans-unit>
        <trans-unit id="6ec364c67d40cf80dd78cca2c8063943882a4782" translate="yes" xml:space="preserve">
          <source>LWG 2945</source>
          <target state="translated">LWG 2945</target>
        </trans-unit>
        <trans-unit id="584b1cd1ca53e0a10c9c53d113a6c1b03f94da27" translate="yes" xml:space="preserve">
          <source>LWG 2946</source>
          <target state="translated">LWG 2946</target>
        </trans-unit>
        <trans-unit id="2092ab29c8ec4efb56008c5dbf84dd1a89910f85" translate="yes" xml:space="preserve">
          <source>LWG 2955</source>
          <target state="translated">LWG 2955</target>
        </trans-unit>
        <trans-unit id="db6b4c474d2b187cadd86c637f7b9a707deded5a" translate="yes" xml:space="preserve">
          <source>LWG 2956</source>
          <target state="translated">LWG 2956</target>
        </trans-unit>
        <trans-unit id="6651b628d955dbc375211fd9965b95e7828c0930" translate="yes" xml:space="preserve">
          <source>LWG 2969</source>
          <target state="translated">LWG 2969</target>
        </trans-unit>
        <trans-unit id="f25beb31bbd789f502c7039a906832b4193e490b" translate="yes" xml:space="preserve">
          <source>LWG 2974</source>
          <target state="translated">LWG 2974</target>
        </trans-unit>
        <trans-unit id="03b6470838ea079e5b35bdd7f4c0a4324f5be97c" translate="yes" xml:space="preserve">
          <source>LWG 2975</source>
          <target state="translated">LWG 2975</target>
        </trans-unit>
        <trans-unit id="00b1711427feb1cdc052a19c3dd5ba1f5d784d54" translate="yes" xml:space="preserve">
          <source>LWG 2979</source>
          <target state="translated">LWG 2979</target>
        </trans-unit>
        <trans-unit id="03245fa5249a80c9e88d330bdbed3d5b0efd3c1a" translate="yes" xml:space="preserve">
          <source>LWG 2980</source>
          <target state="translated">LWG 2980</target>
        </trans-unit>
        <trans-unit id="8e27ede83edeebcb833e56711cf9e85bad9f6a81" translate="yes" xml:space="preserve">
          <source>LWG 2981</source>
          <target state="translated">LWG 2981</target>
        </trans-unit>
        <trans-unit id="3094306bb363791eae0c331ba69cdfa31cd03bd2" translate="yes" xml:space="preserve">
          <source>LWG 2989</source>
          <target state="translated">LWG 2989</target>
        </trans-unit>
        <trans-unit id="b88afb71ca72f3a5b4d7ca39bd5f6d7740d1ca6c" translate="yes" xml:space="preserve">
          <source>LWG 2993</source>
          <target state="translated">LWG 2993</target>
        </trans-unit>
        <trans-unit id="d940e3b0bc4c6c07c3b76d624ad35c4b1995863f" translate="yes" xml:space="preserve">
          <source>LWG 3000</source>
          <target state="translated">LWG 3000</target>
        </trans-unit>
        <trans-unit id="4efd58af92ed99b44892eea2a6474d567bd785e3" translate="yes" xml:space="preserve">
          <source>LWG 3001</source>
          <target state="translated">LWG 3001</target>
        </trans-unit>
        <trans-unit id="1061d475efae99eb0cd73389f5cc7edb38d2b547" translate="yes" xml:space="preserve">
          <source>LWG 3012</source>
          <target state="translated">LWG 3012</target>
        </trans-unit>
        <trans-unit id="0007b14636a9f8886845093dd4fceab33f240906" translate="yes" xml:space="preserve">
          <source>LWG 3013</source>
          <target state="translated">LWG 3013</target>
        </trans-unit>
        <trans-unit id="66844fe2413d66059e9dfcdf2de2b069f47bdc1a" translate="yes" xml:space="preserve">
          <source>LWG 3014</source>
          <target state="translated">LWG 3014</target>
        </trans-unit>
        <trans-unit id="c6e63f6d84c4a00806bd3c82b03223958cc3e8ef" translate="yes" xml:space="preserve">
          <source>LWG 3024</source>
          <target state="translated">LWG 3024</target>
        </trans-unit>
        <trans-unit id="d4a638b7c5508bb67a4aa7d1d18ad719debb7ef5" translate="yes" xml:space="preserve">
          <source>LWG 3025</source>
          <target state="translated">LWG 3025</target>
        </trans-unit>
        <trans-unit id="633b0245721ec6f09845623cc66b7d4cd4a42726" translate="yes" xml:space="preserve">
          <source>LWG 3065</source>
          <target state="translated">LWG 3065</target>
        </trans-unit>
        <trans-unit id="172b1343747b38d1683b7b9b0e7208f82799b40e" translate="yes" xml:space="preserve">
          <source>LWG 3074</source>
          <target state="translated">LWG 3074</target>
        </trans-unit>
        <trans-unit id="fec86e1855b1d157821d7f496304297f01df2663" translate="yes" xml:space="preserve">
          <source>LWG 3075</source>
          <target state="translated">LWG 3075</target>
        </trans-unit>
        <trans-unit id="ad4916674d38c8cbc53c0d10cb3a10d32caa2e0f" translate="yes" xml:space="preserve">
          <source>LWG 3076</source>
          <target state="translated">LWG 3076</target>
        </trans-unit>
        <trans-unit id="3e2a83c594fad4b9e122e8313412c496da714783" translate="yes" xml:space="preserve">
          <source>LWG 3096</source>
          <target state="translated">LWG 3096</target>
        </trans-unit>
        <trans-unit id="b8a6836406e247baec45da221ee2d125a3cbeda4" translate="yes" xml:space="preserve">
          <source>L_tmpnam</source>
          <target state="translated">L_tmpnam</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="ef93e00ee616b79b01a6a513b42f7bef6875e5e6" translate="yes" xml:space="preserve">
          <source>Labels (&lt;a href=&quot;goto&quot;&gt;goto targets&lt;/a&gt;, &lt;code&gt;case&lt;/code&gt; labels, and &lt;code&gt;default:&lt;/code&gt;) appearing in a substatement of a constexpr if can only be referenced (by &lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt; or &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;) in the same substatement.</source>
          <target state="translated">如果只能在同一子&lt;a href=&quot;goto&quot;&gt;语句中&lt;/a&gt;引用（通过&lt;a href=&quot;switch&quot;&gt;switch&lt;/a&gt;或goto来引用），则在constexpr的子&lt;a href=&quot;goto&quot;&gt;语句中&lt;/a&gt;出现的标签（goto目标， &lt;code&gt;case&lt;/code&gt; 标签和 &lt;code&gt;default:&lt;/code&gt; ：）。</target>
        </trans-unit>
        <trans-unit id="4192545e02bafef39c99c48279c9d025ce9cc37d" translate="yes" xml:space="preserve">
          <source>Laguerre polynomials</source>
          <target state="translated">多项式拉格尔</target>
        </trans-unit>
        <trans-unit id="a7a791f6abd60dc5a353ea53ddfb3ee7c9745d37" translate="yes" xml:space="preserve">
          <source>Lambda capture</source>
          <target state="translated">捕获Lambda</target>
        </trans-unit>
        <trans-unit id="1d382614f838c28eb61834675bae6d432fff0445" translate="yes" xml:space="preserve">
          <source>Lambda capture of *this by value as [=,*this]</source>
          <target state="translated">以[=,*this]为值对*this进行Lambda捕获。</target>
        </trans-unit>
        <trans-unit id="7bd97cf3e71e6cfe2f11b11baf163207e4fee010" translate="yes" xml:space="preserve">
          <source>Lambda captures</source>
          <target state="translated">Lambda捕获</target>
        </trans-unit>
        <trans-unit id="ad760081fe95ad36f1148cf3a82266f36a17d08b" translate="yes" xml:space="preserve">
          <source>Lambda expressions</source>
          <target state="translated">Lambda表达式</target>
        </trans-unit>
        <trans-unit id="29608c2c063008f0167b6a128fd16e27d0f6f38e" translate="yes" xml:space="preserve">
          <source>Lambda expressions (since C++11)</source>
          <target state="translated">Lambda表达式(自C++11起</target>
        </trans-unit>
        <trans-unit id="b7d5884df6b1a928d6d7c3491a4a743a3e414bb2" translate="yes" xml:space="preserve">
          <source>Lambda-expressions are not allowed in &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;unevaluated expressions&lt;/a&gt;, &lt;a href=&quot;template_parameters&quot;&gt;template arguments&lt;/a&gt;, &lt;a href=&quot;type_alias&quot;&gt;alias declarations&lt;/a&gt;, &lt;a href=&quot;typedef&quot;&gt;typedef declarations&lt;/a&gt;, and anywhere in a function (or function template) declaration except the function body and the function's &lt;a href=&quot;default_arguments&quot;&gt;default arguments&lt;/a&gt;.</source>
          <target state="translated">未经&lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;评估的表达式&lt;/a&gt;，&lt;a href=&quot;template_parameters&quot;&gt;模板参数&lt;/a&gt;，&lt;a href=&quot;type_alias&quot;&gt;别名声明&lt;/a&gt;，&lt;a href=&quot;typedef&quot;&gt;typedef声明&lt;/a&gt;以及函数（或函数模板）声明中的任何地方（函数主体和函数的&lt;a href=&quot;default_arguments&quot;&gt;默认参数&lt;/a&gt;除外）都不允许使用Lambda表达式。</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="677b369051c8d8b22e38c70e8f452a88713342b3" translate="yes" xml:space="preserve">
          <source>Language feature-testing macros</source>
          <target state="translated">语言功能测试宏</target>
        </trans-unit>
        <trans-unit id="2c4c5fa97a894aab5c689757f00ca2ff05f31ca9" translate="yes" xml:space="preserve">
          <source>Language features</source>
          <target state="translated">语言特点</target>
        </trans-unit>
        <trans-unit id="9ca65a6a550090403c1994a3813c60f37d61983a" translate="yes" xml:space="preserve">
          <source>Language linkage</source>
          <target state="translated">语文联系</target>
        </trans-unit>
        <trans-unit id="b4444821bc7114c255e706d9193016c8234ee05f" translate="yes" xml:space="preserve">
          <source>Language specifications can only appear in &lt;a href=&quot;scope#Namespace_scope&quot;&gt;namespace scope&lt;/a&gt;.</source>
          <target state="translated">语言规范只能出现在&lt;a href=&quot;scope#Namespace_scope&quot;&gt;名称空间范围内&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e794492ee652fe942ec624908ae4ef64d0ff8202" translate="yes" xml:space="preserve">
          <source>Language support</source>
          <target state="translated">语言支持</target>
        </trans-unit>
        <trans-unit id="cc8615e79210c7c7a5e9fe165da74603db62e518" translate="yes" xml:space="preserve">
          <source>Language support libraries provide classes and functions that interact closely with language features and support common language idioms.</source>
          <target state="translated">语言支持库提供了与语言特征密切交互的类和函数,并支持常见的语言习惯。</target>
        </trans-unit>
        <trans-unit id="972ad8d8a50397ba8c02433ed8f048eeb4074b85" translate="yes" xml:space="preserve">
          <source>Layout</source>
          <target state="translated">Layout</target>
        </trans-unit>
        <trans-unit id="5c7c4bf8885640694e2c9d84d334b33834362e92" translate="yes" xml:space="preserve">
          <source>Leap seconds are not inserted into GPS. Thus, every time a leap second is inserted into UTC, UTC falls another second behind GPS. As of December 2017, UTC is 18 seconds behind GPS, reflecting the 18 leap seconds inserted between 1980 and 2017. Thus, 2018-01-01 00:00:00 UTC is equivalent to 2018-01-01 00:00:18 GPS. GPS is a constant 19 seconds behind &lt;a href=&quot;tai_clock&quot;&gt;TAI&lt;/a&gt;.</source>
          <target state="translated">seconds秒未插入GPS。因此，每将a秒插入UTC，UTC就会落后GPS一秒钟。截至2017年12月，UTC落后GPS 18秒钟，反映了1980年至2017年之间插入的18 leap秒。因此，2018-01-01 00:00:00 UTC相当于2018-01-01 00:00:18 GPS 。GPS始终比&lt;a href=&quot;tai_clock&quot;&gt;TAI&lt;/a&gt;落后19秒。</target>
        </trans-unit>
        <trans-unit id="611855b599edd2fe82347140d615a27b9df0aac3" translate="yes" xml:space="preserve">
          <source>Leap seconds are not inserted into TAI. Thus, every time a leap second is inserted into UTC, UTC falls another second behind TAI. As of December 2017, UTC is 37 seconds behind TAI, reflecting the 10-second initial offset and the 27 leap seconds inserted between 1958 and 2017. Thus, 2018-01-01 00:00:00 UTC is equivalent to 2018-01-01 00:00:37 TAI.</source>
          <target state="translated">闰秒不会被插入到TAI中。因此,每当闰秒被插入世界协调时,世界协调时就会比TAI晚一秒。截至2017年12月,UTC比TAI晚37秒,反映了10秒的初始偏移和1958年至2017年之间插入的27个闰秒。因此,2018-01-01 00:00:00 UTC相当于2018-01-01 00:00:37 TAI。</target>
        </trans-unit>
        <trans-unit id="bf56ec55d59d151077b04a3c3b2a260fcafe6e19" translate="yes" xml:space="preserve">
          <source>Leaves the &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; of the vector unchanged (note: the standard's restriction on the changes to capacity is in the specification of &lt;code&gt;vector::reserve&lt;/code&gt;, see &lt;a href=&quot;http://stackoverflow.com/a/18467916&quot;&gt;[1]&lt;/a&gt;).</source>
          <target state="translated">叶的 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 的矢量不变的（注：该标准的限制上的变化，以容量在本说明书 &lt;code&gt;vector::reserve&lt;/code&gt; ，见&lt;a href=&quot;http://stackoverflow.com/a/18467916&quot;&gt;[1] &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="86e0813490cdee81f22682268815667b06f5c776" translate="yes" xml:space="preserve">
          <source>Leaves the &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; of the vector unchanged (note: the standard's restriction on the changes to capacity is in the specification of &lt;code&gt;vector::reserve&lt;/code&gt;, see &lt;a href=&quot;https://stackoverflow.com/a/18467916&quot;&gt;[1]&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741a41d00730604d24e69761626a739d511f27fa" translate="yes" xml:space="preserve">
          <source>Leaving a synchronized block by any means (reaching the end, executing goto, break, continue, or return, or throwing an exception) exits the block and synchronizes-with the next block in the single total order if the exited block was an outer block. The behavior is undefined if &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; is used to exit a synchronized block.</source>
          <target state="translated">以任何方式离开同步块（到达末尾，执行goto，break，继续或返回或引发异常）将退出该块并与下一个块进行同步-如果退出的块是外部块，则以单个总顺序进行同步。如果使用 &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 退出同步块，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="31d6213c56c41b4cc125420dcc2b33093d12c123" translate="yes" xml:space="preserve">
          <source>Leaving an atomic block by any means other than exception (reaching the end, goto, break, continue, return) commits the transaction. The behavior is undefined if &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; is used to exit an atomic block.</source>
          <target state="translated">除了异常（到达末尾，转到，中断，继续，返回）以外，通过任何其他方式离开原子块都将提交事务。如果使用 &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; 退出原子块，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="bdffb77ae44e48c63c181cf7541184b7bfe75b59" translate="yes" xml:space="preserve">
          <source>Left-to-right</source>
          <target state="translated">Left-to-right</target>
        </trans-unit>
        <trans-unit id="f644f1aaae2b85733ad956d52e9d411a359c5caf" translate="yes" xml:space="preserve">
          <source>LegacyBidirectionalIterator</source>
          <target state="translated">LegacyBidirectionalIterator</target>
        </trans-unit>
        <trans-unit id="c4a5b29b136f2ede2a2531477e7bb3c2ca5abf2b" translate="yes" xml:space="preserve">
          <source>LegacyBidirectionalIterator is a LegacyBidirectionalIterator that additionally satisfies the &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; requirements.</source>
          <target state="translated">LegacyBidirectionalIterator是一个LegacyBidirectionalIterator，它另外满足&lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator的&lt;/a&gt;要求。</target>
        </trans-unit>
        <trans-unit id="c0fa292844214f93eb7bc4d960957ba473ff303f" translate="yes" xml:space="preserve">
          <source>LegacyContiguousIterator</source>
          <target state="translated">LegacyContiguousIterator</target>
        </trans-unit>
        <trans-unit id="abba9ce1b1082ec030ac0427b7a1d0e517041d2c" translate="yes" xml:space="preserve">
          <source>LegacyForwardIterator</source>
          <target state="translated">LegacyForwardIterator</target>
        </trans-unit>
        <trans-unit id="096905dbdfa46128b8feb9520f8a815491bb23e6" translate="yes" xml:space="preserve">
          <source>LegacyForwardIterator is a LegacyForwardIterator that additionally satisfies the &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; requirements.</source>
          <target state="translated">LegacyForwardIterator是一个LegacyForwardIterator，它另外满足&lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator的&lt;/a&gt;要求。</target>
        </trans-unit>
        <trans-unit id="9bdad701a59fe021a9f0ea8f1e2907f8e0e60476" translate="yes" xml:space="preserve">
          <source>LegacyInputIterator</source>
          <target state="translated">LegacyInputIterator</target>
        </trans-unit>
        <trans-unit id="585fe456965ba38488a01543309716171330d718" translate="yes" xml:space="preserve">
          <source>LegacyIterator</source>
          <target state="translated">LegacyIterator</target>
        </trans-unit>
        <trans-unit id="3cdb555f844cd2dc50f1ef7c5652c1f890df1f87" translate="yes" xml:space="preserve">
          <source>LegacyIterator is the base set of requirements used by other iterator types: &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, and &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;. Iterators can be thought of as an abstraction of pointers.</source>
          <target state="translated">LegacyIterator是其他迭代器类型使用的基本要求集：&lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;，&lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;，&lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;，&lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;和&lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;。可以将迭代器视为指针的抽象。</target>
        </trans-unit>
        <trans-unit id="6e768ef221583d1c5e44ef0573554b7ccf685e09" translate="yes" xml:space="preserve">
          <source>LegacyOutputIterator</source>
          <target state="translated">LegacyOutputIterator</target>
        </trans-unit>
        <trans-unit id="8fa47f5539d2203c38a39fce4c4b0ef195c146d3" translate="yes" xml:space="preserve">
          <source>LegacyRandomAccessIterator</source>
          <target state="translated">LegacyRandomAccessIterator</target>
        </trans-unit>
        <trans-unit id="742f0b2803ca04b5223bb318425b08421d148103" translate="yes" xml:space="preserve">
          <source>LegacyRandomAccessIterator is a LegacyRandomAccessIterator that additionally satisfies the &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; requirements.</source>
          <target state="translated">LegacyRandomAccessIterator是一个LegacyRandomAccessIterator，它另外满足&lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator的&lt;/a&gt;要求。</target>
        </trans-unit>
        <trans-unit id="5846955db6bef539707c3590c701613c5f0cf50f" translate="yes" xml:space="preserve">
          <source>Legend</source>
          <target state="translated">Legend</target>
        </trans-unit>
        <trans-unit id="5d59dd3a73ef773d7095755185b08a856862f59c" translate="yes" xml:space="preserve">
          <source>Legendre polynomials</source>
          <target state="translated">多项式图例</target>
        </trans-unit>
        <trans-unit id="7906417f7e9cebe12726504e25b8c0b72bf1f772" translate="yes" xml:space="preserve">
          <source>LessThanComparable</source>
          <target state="translated">LessThanComparable</target>
        </trans-unit>
        <trans-unit id="274ae48acc8830f71730c0873d33a6285228a9de" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;CMP(x,y)&lt;/code&gt; be &lt;code&gt;1&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt;, &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt;, and &lt;code&gt;0&lt;/code&gt; otherwise. For any &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt;, the product of &lt;code&gt;CMP(lerp(a, b, t2), lerp(a, b, t1))&lt;/code&gt;, &lt;code&gt;CMP(t2, t1)&lt;/code&gt;, and &lt;code&gt;CMP(b, a)&lt;/code&gt; is non-negative. (That is, &lt;code&gt;lerp&lt;/code&gt; is monotonic.).</source>
          <target state="translated">如果 &lt;code&gt;x &amp;gt; y&lt;/code&gt; 则使 &lt;code&gt;CMP(x,y)&lt;/code&gt; 为 &lt;code&gt;1&lt;/code&gt; ，如果 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 则为 &lt;code&gt;-1&lt;/code&gt; ，否则为 &lt;code&gt;0&lt;/code&gt; 。对于任何 &lt;code&gt;t1&lt;/code&gt; 和 &lt;code&gt;t2&lt;/code&gt; ， &lt;code&gt;CMP(lerp(a, b, t2), lerp(a, b, t1))&lt;/code&gt; ， &lt;code&gt;CMP(t2, t1)&lt;/code&gt; 和 &lt;code&gt;CMP(b, a)&lt;/code&gt; 乘积都是非负的。（也就是说， &lt;code&gt;lerp&lt;/code&gt; 是单调的。）。</target>
        </trans-unit>
        <trans-unit id="12941d0eb9ed4aeacc52d5f00426e066fee74e7d" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;P&lt;/code&gt; equal the precision if nonzero, &lt;code&gt;6&lt;/code&gt; if the precision is not specified, or &lt;code&gt;1&lt;/code&gt; if the precision is &lt;code&gt;​0​&lt;/code&gt;. Then, if a conversion with style &lt;code&gt;E&lt;/code&gt; would have an exponent of &lt;code&gt;X&lt;/code&gt;:</source>
          <target state="translated">令 &lt;code&gt;P&lt;/code&gt; 等于如果非零，精度 &lt;code&gt;6&lt;/code&gt; 如果精度没有指定，或 &lt;code&gt;1&lt;/code&gt; ，如果精度为 &lt;code&gt;​0​&lt;/code&gt; 。然后，如果样式 &lt;code&gt;E&lt;/code&gt; 的转换的指数为 &lt;code&gt;X&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1d96618afd4263ec0d73d199a2618f5e147e9e73" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;U&lt;/code&gt; be &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">令 &lt;code&gt;U&lt;/code&gt; 为 &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32d8483331780e895e2e6534b1cf368ac9e20d64" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;Y&lt;/code&gt; be &lt;code&gt;typename &lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type&lt;/code&gt;, then the resulting &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;'s stored pointer will be obtained by evaluating, respectively:</source>
          <target state="translated">假设 &lt;code&gt;Y&lt;/code&gt; 为 &lt;code&gt;typename &lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;::element_type&lt;/code&gt; ，则将分别通过求值获得结果 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 的存储指针：</target>
        </trans-unit>
        <trans-unit id="7bf1f858e1bdfaa71eed61b027d72a6d348da6cc" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;fn&lt;/code&gt; be the call wrapper returned by a call to &lt;code&gt;std::mem_fn&lt;/code&gt; with a pointer to member &lt;code&gt;pm&lt;/code&gt;. Then the expression &lt;code&gt;fn(t, a2, ..., aN)&lt;/code&gt; is equivalent to &lt;code&gt;INVOKE(pm, t, a2, ..., aN)&lt;/code&gt;, where</source>
          <target state="translated">令 &lt;code&gt;fn&lt;/code&gt; 为对 &lt;code&gt;std::mem_fn&lt;/code&gt; 的调用返回的调用包装，并带有指向成员 &lt;code&gt;pm&lt;/code&gt; 的指针。那么表达式 &lt;code&gt;fn(t, a2, ..., aN)&lt;/code&gt; 等价于 &lt;code&gt;INVOKE(pm, t, a2, ..., aN)&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="4affff119284bd8c17502a7b4ba9cddc4335375c" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;since_midnight&lt;/code&gt; be the stored duration:</source>
          <target state="translated">假设 &lt;code&gt;since_midnight&lt;/code&gt; 为存储的持续时间：</target>
        </trans-unit>
        <trans-unit id="81727cefad0e4f620e16d3a8ef618ac5d109ea3a" translate="yes" xml:space="preserve">
          <source>Let's consider now those cases employing argument-dependent lookup (i.e., we use the more common call format &lt;code&gt;f(t)&lt;/code&gt;).</source>
          <target state="translated">现在让我们考虑采用依赖于参数的查询的情况（即，我们使用更常见的调用格式 &lt;code&gt;f(t)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="41a116dfc9200f26422a8e9d5e49911e4bc90a0d" translate="yes" xml:space="preserve">
          <source>Letters in the integer literals are case-insensitive: &lt;code&gt;0xDeAdBeEfU&lt;/code&gt; and &lt;code&gt;0XdeadBEEFu&lt;/code&gt; represent the same number (one exception is the long-long-suffix, which is either &lt;code&gt;ll&lt;/code&gt; or &lt;code&gt;LL&lt;/code&gt;, never &lt;code&gt;lL&lt;/code&gt; or &lt;code&gt;Ll&lt;/code&gt;).</source>
          <target state="translated">整数文字中的字母不区分大小写： &lt;code&gt;0xDeAdBeEfU&lt;/code&gt; 和 &lt;code&gt;0XdeadBEEFu&lt;/code&gt; 代表相同的数字（一个长后缀后缀是 &lt;code&gt;ll&lt;/code&gt; 或 &lt;code&gt;LL&lt;/code&gt; ，从不为 &lt;code&gt;lL&lt;/code&gt; 或 &lt;code&gt;Ll&lt;/code&gt; 只是一个例外）。</target>
        </trans-unit>
        <trans-unit id="4e3f5ccac8e611393a344b1488ebf8b88e0bab4b" translate="yes" xml:space="preserve">
          <source>Lexicographical comparison is a operation with the following properties:</source>
          <target state="translated">词法比较是一种具有以下性质的操作。</target>
        </trans-unit>
        <trans-unit id="7273c76d82ab971497c1735a342d6d033382649f" translate="yes" xml:space="preserve">
          <source>Lexicographically compares two ranges &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;[first2, last2)&lt;/code&gt; using three-way comparison and produces a result of the strongest applicable comparison category type.</source>
          <target state="translated">Lexicographically 使用三向比较比较两个范围 &lt;code&gt;[first1, last1)&lt;/code&gt; 和 &lt;code&gt;[first2, last2)&lt;/code&gt; 并产生最强的适用比较类别类型的结果。</target>
        </trans-unit>
        <trans-unit id="67a093b5f3afa1ec9d50b3d089465752e5b76f7f" translate="yes" xml:space="preserve">
          <source>Library Fundamentals TS</source>
          <target state="translated">图书馆基础知识TS</target>
        </trans-unit>
        <trans-unit id="6b5e123be926567d010847ac064936336ad593ea" translate="yes" xml:space="preserve">
          <source>Library Fundamentals TS v2</source>
          <target state="translated">图书馆基础知识TS v2</target>
        </trans-unit>
        <trans-unit id="e2667d1d4071efd5b07b3f89a3f29b6be4e37f9e" translate="yes" xml:space="preserve">
          <source>Library feature-test macros</source>
          <target state="translated">图书馆功能测试宏</target>
        </trans-unit>
        <trans-unit id="d181f5a9fb0d9e7127fc14e913193f77a0078f2d" translate="yes" xml:space="preserve">
          <source>Library feature-test macros (C++20)</source>
          <target state="translated">库功能测试宏(C++20)</target>
        </trans-unit>
        <trans-unit id="1ca30982b1bbf9fa6a34598686144ccd0b751409" translate="yes" xml:space="preserve">
          <source>Library features</source>
          <target state="translated">图书馆的特点</target>
        </trans-unit>
        <trans-unit id="09e12a24dc663d40201c5b3eab12424fb6edc742" translate="yes" xml:space="preserve">
          <source>Library support</source>
          <target state="translated">图书馆支助</target>
        </trans-unit>
        <trans-unit id="08957d8442d6c53a0376743b1046564066c5beb9" translate="yes" xml:space="preserve">
          <source>Library types</source>
          <target state="translated">图书馆类型</target>
        </trans-unit>
        <trans-unit id="541a37e25273e2d6d7d8ea77a193f781a3f90323" translate="yes" xml:space="preserve">
          <source>Library-wide</source>
          <target state="translated">Library-wide</target>
        </trans-unit>
        <trans-unit id="e791557e003ef45d34d52d1fde8fc7381122402d" translate="yes" xml:space="preserve">
          <source>Library-wide definitions</source>
          <target state="translated">全图书馆的定义</target>
        </trans-unit>
        <trans-unit id="8d05a85e0ee31a873e2f15997f3ffa7b057cefff" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.</source>
          <target state="translated">根据知识共享署名-相同方式共享许可协议(Creative Commons Attribution-ShareAlike Unported License v3.0)授权。</target>
        </trans-unit>
        <trans-unit id="8d33f31baff91c27917dcfcd7222cc394cee13fd" translate="yes" xml:space="preserve">
          <source>Lifetime</source>
          <target state="translated">Lifetime</target>
        </trans-unit>
        <trans-unit id="fcab1aea1859e79acfdb16f5548fc5e8f346103c" translate="yes" xml:space="preserve">
          <source>Lifetime management overhead: pImpl (as well as OO factory) place the implementation object on the heap, which imposes significant runtime overhead at construction and destruction. This may be partially offset by custom allocators, since allocation size for pImpl (but not OO factory) is known at compile time.</source>
          <target state="translated">终身管理开销:pImpl(以及 OO factory)将实现对象放在堆上,这在构建和销毁时带来了巨大的运行时开销。这可能会被自定义分配器部分抵消,因为pImpl(但不是OO工厂)的分配大小在编译时是已知的。</target>
        </trans-unit>
        <trans-unit id="ce83a9e6e299b9deac4e3b17e7674a70743eba46" translate="yes" xml:space="preserve">
          <source>Lifetime of a &lt;a href=&quot;reference&quot;&gt;reference&lt;/a&gt; is exactly its storage duration.</source>
          <target state="translated">&lt;a href=&quot;reference&quot;&gt;引用的&lt;/a&gt;生存期恰好是其存储持续时间。</target>
        </trans-unit>
        <trans-unit id="aa1c59351fb4e3a194ae9298bc34b5f343ca9a77" translate="yes" xml:space="preserve">
          <source>Lifetime of a member of a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; begins when that member is made active</source>
          <target state="translated">&lt;a href=&quot;union&quot;&gt;工会&lt;/a&gt;成员的生命周期始于该成员被激活</target>
        </trans-unit>
        <trans-unit id="bfaa411f86a50808036a50484d4f059e87177ec8" translate="yes" xml:space="preserve">
          <source>Lifetime of a temporary</source>
          <target state="translated">暂时的寿命</target>
        </trans-unit>
        <trans-unit id="b06c7b4fe84d7d3832ffd284a1596b4ff15c6d2b" translate="yes" xml:space="preserve">
          <source>Lifetime of an object is equal to or is nested within the lifetime of its storage, see &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;.</source>
          <target state="translated">对象的生存期等于或嵌套在其存储的生存&lt;a href=&quot;storage_duration&quot;&gt;期内&lt;/a&gt;，请参见存储期限。</target>
        </trans-unit>
        <trans-unit id="51e3b5d26b2a87dc97df037e11067c891e623490" translate="yes" xml:space="preserve">
          <source>Lifetimes of member objects and base subobjects begin and end following &lt;a href=&quot;constructor#Initialization_order&quot;&gt;class initialization order&lt;/a&gt;.</source>
          <target state="translated">成员对象和基础子对象的生存期按照&lt;a href=&quot;constructor#Initialization_order&quot;&gt;类初始化顺序&lt;/a&gt;开始和结束。</target>
        </trans-unit>
        <trans-unit id="1332053b53e77535f34952c3e92e4a52a83ed6ef" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt;, this function typically performs only one allocation, and places both the &lt;code&gt;T&lt;/code&gt; object and the control block in the allocated memory block (the standard recommends but does not require this, all known implementations do this). A copy of &lt;code&gt;alloc&lt;/code&gt; is stored as part of the control block so that it can be used to deallocate it once both shared and weak reference counts reach zero.</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; 一样，此函数通常仅执行一次分配，并将 &lt;code&gt;T&lt;/code&gt; 对象和控制块都放置在已分配的内存块中（标准建议但不要求这样做，所有已知的实现都这样做）。的一个副本 &lt;code&gt;alloc&lt;/code&gt; 被存储作为控制块的一部分，以便它可以被用来释放它一旦共享和弱引用计数达到零。</target>
        </trans-unit>
        <trans-unit id="fb0723405e133e81ce558a6f85e371f734d41854" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, a typical implementation of &lt;code&gt;weak_ptr&lt;/code&gt; stores two pointers:</source>
          <target state="translated">像 &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; 一样， &lt;code&gt;weak_ptr&lt;/code&gt; 的典型实现存储两个指针：</target>
        </trans-unit>
        <trans-unit id="70ffb5a0c307ec17f33f7f7369b3ef25ef794da7" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;unsigned char&lt;/code&gt;, it can be used to access raw memory occupied by other objects (&lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;), but unlike those types, it is not a character type and is not an arithmetic type. A byte is only a collection of bits, and the only operators defined for it are the bitwise ones.</source>
          <target state="translated">与 &lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;unsigned char&lt;/code&gt; 一样，它可以用于访问其他对象（&lt;a href=&quot;../language/objects&quot;&gt;对象表示&lt;/a&gt;）占用的原始内存，但是与那些类型不同，它不是字符类型，也不是算术类型。字节只是位的集合，为其定义的唯一运算符是按位运算符。</target>
        </trans-unit>
        <trans-unit id="a0e7b4ff05a45ce92b546002d8fc2f4e84c6ea38" translate="yes" xml:space="preserve">
          <source>Like a hard link, a symbolic link allows a file to have multiple logical names. The presence of a hard link guarantees the existence of a file, even after the original name has been removed. A symbolic link provides no such assurance; in fact, the file named by the &lt;code&gt;target&lt;/code&gt; argument need not exist when the link is created. A symbolic link can cross file system boundaries.</source>
          <target state="translated">像硬链接一样，符号链接允许文件具有多个逻辑名称。硬链接的存在保证了文件的存在，即使在删除原始名称之后也是如此。符号链接不提供此类保证；实际上，创建链接时， &lt;code&gt;target&lt;/code&gt; 参数命名的文件不必存在。符号链接可以跨越文件系统边界。</target>
        </trans-unit>
        <trans-unit id="8cc2c9ed197596f0e8ca54e8df4a5e29bc4bbde4" translate="yes" xml:space="preserve">
          <source>Like a reference, a structured binding is an alias to an existing object. Unlike a reference, the type of a structured binding does not have to be a reference type.</source>
          <target state="translated">与引用一样,结构化绑定是现有对象的别名。与引用不同,结构化绑定的类型不一定是引用类型。</target>
        </trans-unit>
        <trans-unit id="067a7fb7f8bc363ab9405d15f7f42f52d531593e" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isalnum&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样，如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于 &lt;code&gt;EOF&lt;/code&gt; ，则 &lt;code&gt;std::isalnum&lt;/code&gt; 的行为是不确定的。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f83c5788970238d8dce9e165785dcf50fdef59c" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isalpha&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与其他所有功能一样 &lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;，如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于 &lt;code&gt;EOF&lt;/code&gt; ，则 &lt;code&gt;std::isalpha&lt;/code&gt; 的行为是不确定的。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="02650958be1dd2146a9becd39224244d381efde4" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isblank&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">像&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他功能一样，如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于 &lt;code&gt;EOF&lt;/code&gt; ，则 &lt;code&gt;std::isblank&lt;/code&gt; 的行为是不确定的。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="0340210c2f7ce33d0ebf0f6392410ac886edccce" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::iscntrl&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">像&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他功能一样， &lt;code&gt;std::iscntrl&lt;/code&gt; 如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于 &lt;code&gt;EOF&lt;/code&gt; std :: iscntrl是不确定的。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="2dd464fdeabb59a1a5f506eb7ecd2b3abdac9a22" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isdigit&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">像&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样， &lt;code&gt;std::isdigit&lt;/code&gt; 的行为如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于 &lt;code&gt;EOF&lt;/code&gt; 是不确定的。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7dda039594fc889284a6c61532474b72fdbd1f81" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isgraph&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样，如果参数的值不能表示为 &lt;code&gt;std::isgraph&lt;/code&gt; ，则其行为是不确定的 &lt;code&gt;unsigned char&lt;/code&gt; 也不能等于 &lt;code&gt;EOF&lt;/code&gt; 。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e6241819c2a6db7cd413177f3e7eb9b7229e9f1f" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::islower&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样，如果参数的值不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; ，则 &lt;code&gt;std::islower&lt;/code&gt; 的行为是不确定的也不等于 &lt;code&gt;EOF&lt;/code&gt; 。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7ccc47ed9fcd07aec0dbec6222f54d9803cf130c" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isprint&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样，如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于，则 &lt;code&gt;std::isprint&lt;/code&gt; 的行为是不确定的 &lt;code&gt;EOF&lt;/code&gt; 。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="411696ff296361e95ad61309fa87bc8c79319127" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::ispunct&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样，如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于，则 &lt;code&gt;std::ispunct&lt;/code&gt; 的行为是不确定的 &lt;code&gt;EOF&lt;/code&gt; 。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a2bc2b3471f087c8466e836925f03b3603558f3f" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isspace&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样，如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于 &lt;code&gt;EOF&lt;/code&gt; ，则 &lt;code&gt;std::isspace&lt;/code&gt; 的行为是不确定的。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="395c220484621ffd75d1964f6130a00ce4ddab49" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isupper&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样，如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于 &lt;code&gt;EOF&lt;/code&gt; ，则 &lt;code&gt;std::isupper&lt;/code&gt; 的行为是不确定的。为了安全地将这些函数与纯 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cb2c7e80bd4929826427f19fc7c64d9e9ff5d018" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::isxdigit&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样，如果自变量的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于 &lt;code&gt;EOF&lt;/code&gt; ，则 &lt;code&gt;std::isxdigit&lt;/code&gt; 的行为是不确定的。为了安全地使用这些功能 &lt;code&gt;char&lt;/code&gt; （或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ff408cea9c029c8dab319c58cbd0c36f0d4045fe" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::tolower&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样，如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于 &lt;code&gt;EOF&lt;/code&gt; ，则 &lt;code&gt;std::tolower&lt;/code&gt; 的行为是不确定的。使用纯 &lt;code&gt;char&lt;/code&gt; 安全使用这些功能（或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c3e68c1eaec4b4e283489b5c67ab059adf32011f" translate="yes" xml:space="preserve">
          <source>Like all other functions from &lt;a href=&quot;../../header/cctype&quot;&gt;&lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt;&lt;/a&gt;, the behavior of &lt;code&gt;std::toupper&lt;/code&gt; is undefined if the argument's value is neither representable as &lt;code&gt;unsigned char&lt;/code&gt; nor equal to &lt;code&gt;EOF&lt;/code&gt;. To use these functions safely with plain &lt;code&gt;char&lt;/code&gt;s (or &lt;code&gt;signed char&lt;/code&gt;s), the argument should first be converted to &lt;code&gt;unsigned char&lt;/code&gt;:</source>
          <target state="translated">与&lt;a href=&quot;../../header/cctype&quot;&gt; &lt;code&gt;&amp;lt;cctype&amp;gt;&lt;/code&gt; 中的&lt;/a&gt;所有其他函数一样，如果参数的值既不能表示为 &lt;code&gt;unsigned char&lt;/code&gt; 也不等于 &lt;code&gt;EOF&lt;/code&gt; ，则 &lt;code&gt;std::toupper&lt;/code&gt; 的行为是不确定的。使用纯 &lt;code&gt;char&lt;/code&gt; 安全使用这些功能（或带 &lt;code&gt;signed char&lt;/code&gt; ）一起使用，应首先将参数转换为 &lt;code&gt;unsigned char&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="277019aab45ab5f935fb6e92f8f5746e4c25daa8" translate="yes" xml:space="preserve">
          <source>Like any template declaration, an alias template can only be declared at class scope or namespace scope.</source>
          <target state="translated">像任何模板声明一样,别名模板只能在类作用域或命名空间作用域声明。</target>
        </trans-unit>
        <trans-unit id="ca47c4b0c6ddc7644bfef7979156876bc8446bd5" translate="yes" xml:space="preserve">
          <source>Like class prvalues, array prvalues convert to xvalues by &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; when evaluated.</source>
          <target state="translated">与类prvalue一样，在评估时，数组prvalue会通过&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;临时实现而&lt;/a&gt;转换为xvalue 。</target>
        </trans-unit>
        <trans-unit id="0347742fa713e18c4beb5d442719947cba761472" translate="yes" xml:space="preserve">
          <source>Like language references, constness is shallow for &lt;code&gt;atomic_ref&lt;/code&gt; - it is possible to modify the referenced value through a &lt;code&gt;const&lt;/code&gt;&lt;code&gt;atomic_ref&lt;/code&gt; object.</source>
          <target state="translated">像语言参考一样， &lt;code&gt;atomic_ref&lt;/code&gt; 对于atomic_ref来说也很浅-可以通过以下方式修改参考值： &lt;code&gt;const&lt;/code&gt; &lt;code&gt;atomic_ref&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="7a2c18bbb70b4975f8de70e1d0f45d8ebbaac4a9" translate="yes" xml:space="preserve">
          <source>Like other classes, class templates have an injected-class-name. The injected-class-name can be used as a template-name or a type-name.</source>
          <target state="translated">像其他类一样,类模板有一个注入的类名。注入的类名可以作为模板名或类型名使用。</target>
        </trans-unit>
        <trans-unit id="7a6e90ef50926b9b7275d89708dfc849a157f540" translate="yes" xml:space="preserve">
          <source>Like other members, injected-class-names are inherited. In the presence of private or protected inheritance, the injected-class-name of an indirect base class might end up being inaccessible in a derived class.</source>
          <target state="translated">和其他成员一样,注入的类名也是继承的。在存在私有或保护继承的情况下,间接基类的注入类名可能最终在派生类中无法访问。</target>
        </trans-unit>
        <trans-unit id="f6f1d175f286f2d5f07aef906a2e3bc134ab3f16" translate="yes" xml:space="preserve">
          <source>Like other streambuf classes, &lt;code&gt;std::basic_syncbuf&lt;/code&gt; is normally only accessed through the corresponding stream, &lt;a href=&quot;basic_osyncstream&quot;&gt;&lt;code&gt;std::osyncstream&lt;/code&gt;&lt;/a&gt;, not directly.</source>
          <target state="translated">与其他streambuf类一样，通常只能通过相应的流访问 &lt;code&gt;std::basic_syncbuf&lt;/code&gt; ，&lt;a href=&quot;basic_osyncstream&quot;&gt; &lt;code&gt;std::osyncstream&lt;/code&gt; &lt;/a&gt;，不直接。</target>
        </trans-unit>
        <trans-unit id="bd2d3509f0729065894ca6384a10fe999c819fe7" translate="yes" xml:space="preserve">
          <source>Likewise, function-try-block of the &lt;a href=&quot;main_function&quot;&gt;main() function&lt;/a&gt; does not catch the exceptions thrown from the constructors and destructors of &lt;a href=&quot;storage_duration&quot;&gt;static&lt;/a&gt; objects (except for the constructors of function-local statics).</source>
          <target state="translated">同样，&lt;a href=&quot;main_function&quot;&gt;main（）函数的&lt;/a&gt; function-try-block不会捕获&lt;a href=&quot;storage_duration&quot;&gt;静态&lt;/a&gt;对象的构造函数和析构函数抛出的异常（函数局部静态函数的构造函数除外）。</target>
        </trans-unit>
        <trans-unit id="ab6af34df8147c6b3a0969fea41e698ff89bc410" translate="yes" xml:space="preserve">
          <source>Likewise, the 16-digit string &lt;code&gt;9007199254740993&lt;/code&gt; does not survive text-&amp;gt;double-&amp;gt;text roundtrip, becoming &lt;code&gt;9007199254740992&lt;/code&gt;: the 64-bit IEEE 754 type double guarantees this roundtrip only for 15 decimal digits.</source>
          <target state="translated">同样，16位数字字符串 &lt;code&gt;9007199254740993&lt;/code&gt; 不能在text-&amp;gt; double-&amp;gt; text往返过程中下来，成为 &lt;code&gt;9007199254740992&lt;/code&gt; ：64位IEEE 754类型的double只能保证15位十进制数字的往返。</target>
        </trans-unit>
        <trans-unit id="28d080135c0996528be81f65c40eb528ec429cbe" translate="yes" xml:space="preserve">
          <source>Likewise, the inequality operator is typically implemented in terms of &lt;code&gt;operator==&lt;/code&gt;:</source>
          <target state="translated">同样，不等式运算符通常根据以下方面实现 &lt;code&gt;operator==&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9d8bc984a49e87697786db72d2563a91679f73c6" translate="yes" xml:space="preserve">
          <source>Limits of floating point types</source>
          <target state="translated">浮点类型的限制</target>
        </trans-unit>
        <trans-unit id="68c715c0e0c866487981ad26eed257940f23ee03" translate="yes" xml:space="preserve">
          <source>Limits of integer types</source>
          <target state="translated">整数类型的限制</target>
        </trans-unit>
        <trans-unit id="15ff631ff253c68efadbbe156b2dbda674f664c6" translate="yes" xml:space="preserve">
          <source>Limits of other integer types</source>
          <target state="translated">其他整数类型的限制</target>
        </trans-unit>
        <trans-unit id="af502f2b37eea07ed9083c7daf40f34553f6fccd" translate="yes" xml:space="preserve">
          <source>Linear</source>
          <target state="translated">Linear</target>
        </trans-unit>
        <trans-unit id="d663d9eccd3592374d465e1969446c41d66c8a96" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt;.</source>
          <target state="translated">线性输入 &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first,last)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5ee30c8aafcff81625dfef38a2177634d49c1eed" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">线性输入 &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dd2f30444814df4f83cd7413476e4b0fd89443cb" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">线性输入 &lt;code&gt;n&lt;/code&gt; 中的。</target>
        </trans-unit>
        <trans-unit id="b7bbb05054f896c8a5f8b773dacbef4017beeded" translate="yes" xml:space="preserve">
          <source>Linear in &lt;code&gt;rcount&lt;/code&gt;.</source>
          <target state="translated">线性输入 &lt;code&gt;rcount&lt;/code&gt; 中的。</target>
        </trans-unit>
        <trans-unit id="1a961c5a00bbaee66696314d28a309bcc73bf9a0" translate="yes" xml:space="preserve">
          <source>Linear in size of the container.</source>
          <target state="translated">容器的线性尺寸;</target>
        </trans-unit>
        <trans-unit id="47e94bceda1e4178a1dbb6f4ff6dcd1259ef8d37" translate="yes" xml:space="preserve">
          <source>Linear in the difference between the current size and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">当前大小与 &lt;code&gt;count&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0ba0eb11bb040b4fe1f3679f71ea7620138693f" translate="yes" xml:space="preserve">
          <source>Linear in the difference between the current size and &lt;code&gt;count&lt;/code&gt;. Additional complexity possible due to list traversal to reach the first element to erase/the end position to insert.</source>
          <target state="translated">当前大小与 &lt;code&gt;count&lt;/code&gt; 。由于列表遍历会到达要擦除的第一个元素/要插入的结束位置，因此可能会带来额外的复杂性。</target>
        </trans-unit>
        <trans-unit id="baaef666d55118a41c333430f0a97ec79990b1cb" translate="yes" xml:space="preserve">
          <source>Linear in the difference between the current size and &lt;code&gt;count&lt;/code&gt;. Additional complexity possible due to reallocation if capacity is less than &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">当前大小和 &lt;code&gt;count&lt;/code&gt; 之间的线性差异。如果容量不足，则由于重新分配而可能导致额外的复杂性 &lt;code&gt;count&lt;/code&gt; ,。</target>
        </trans-unit>
        <trans-unit id="61fc9e3129ac082fe227ebd6080874ba58bf854d" translate="yes" xml:space="preserve">
          <source>Linear in the distance between &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;last&lt;/code&gt; 之间的距离是线性的。</target>
        </trans-unit>
        <trans-unit id="5120f8d10505c4347d98aef0265d53cc5b14811e" translate="yes" xml:space="preserve">
          <source>Linear in the distance between &lt;code&gt;pos&lt;/code&gt; and end of the container.</source>
          <target state="translated">线性中之间的距离 &lt;code&gt;pos&lt;/code&gt; 和容器的端部。</target>
        </trans-unit>
        <trans-unit id="e00c01e410d339ff063543b8db6c55336a7eb35e" translate="yes" xml:space="preserve">
          <source>Linear in the length of the underlying character sequence.</source>
          <target state="translated">以基础字符序列的长度为线性。</target>
        </trans-unit>
        <trans-unit id="daef509e105270395b1f8ee55aa3597f2d32c098" translate="yes" xml:space="preserve">
          <source>Linear in the lesser of the distances between &lt;code&gt;pos&lt;/code&gt; and either of the ends of the container.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 与容器两端之间的距离较小者为线性。</target>
        </trans-unit>
        <trans-unit id="f9e42220f12301a5a104063cb40d7e22a40f20c0" translate="yes" xml:space="preserve">
          <source>Linear in the number of sub-matches.</source>
          <target state="translated">以次级匹配的数量为线性。</target>
        </trans-unit>
        <trans-unit id="c5ddd8aed976c4d32ca29544bac6a99205868cfe" translate="yes" xml:space="preserve">
          <source>Linear in the size of the bucket &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">铲斗尺寸为线性 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="320de548d4905427a59ae55bf65f8ed7ea812394" translate="yes" xml:space="preserve">
          <source>Linear in the size of the container adaptor.</source>
          <target state="translated">容器适配器的尺寸为线性。</target>
        </trans-unit>
        <trans-unit id="58a053e51fd6f7ec6e1969382ddb0c636fee3c4d" translate="yes" xml:space="preserve">
          <source>Linear in the size of the container, i.e., the number of elements.</source>
          <target state="translated">容器的大小,即元素的数量,是线性的。</target>
        </trans-unit>
        <trans-unit id="9e42d6edd168f206c67991730a76dd86d7fd13ac" translate="yes" xml:space="preserve">
          <source>Linear in the size of the container.</source>
          <target state="translated">容器的尺寸是线性的;</target>
        </trans-unit>
        <trans-unit id="d098f3f0fdf3fe294ef9db9875c8f3ba39748928" translate="yes" xml:space="preserve">
          <source>Linear in the size of the numeric array.</source>
          <target state="translated">数字数组的大小是线性的。</target>
        </trans-unit>
        <trans-unit id="39f6b3d4e54ae45f608cfae2731dfa12f1a130f4" translate="yes" xml:space="preserve">
          <source>Linear in the size of the string</source>
          <target state="translated">字符串的线性大小</target>
        </trans-unit>
        <trans-unit id="d34b2255c2e995e02e21a14b3a4851ac5882aba2" translate="yes" xml:space="preserve">
          <source>Linear in the size of the string, although existing implementations operate in constant time.</source>
          <target state="translated">字符串的大小是线性的,尽管现有的实现是在恒定的时间内运行的。</target>
        </trans-unit>
        <trans-unit id="2f4742601a668a97966b78c0c256da0091787c9f" translate="yes" xml:space="preserve">
          <source>Linear in the size of the string.</source>
          <target state="translated">字符串的大小是线性的。</target>
        </trans-unit>
        <trans-unit id="d504b6d983be80c3da82ac77491361a106de8dd6" translate="yes" xml:space="preserve">
          <source>Linear in the size of the strings.</source>
          <target state="translated">字符串的大小是线性的。</target>
        </trans-unit>
        <trans-unit id="c67c2146b42dc18f8ac7602e8c37c39d0d1a88f4" translate="yes" xml:space="preserve">
          <source>Linear in the size of the views.</source>
          <target state="translated">线性的意见大小。</target>
        </trans-unit>
        <trans-unit id="353a3b1efc1c504f1131664f1c9da4bb8225908a" translate="yes" xml:space="preserve">
          <source>Linear interpolation</source>
          <target state="translated">线性插值</target>
        </trans-unit>
        <trans-unit id="2eb90c9fc96f9c707142bd2df66bbb959c695585" translate="yes" xml:space="preserve">
          <source>Linear.</source>
          <target state="translated">Linear.</target>
        </trans-unit>
        <trans-unit id="bd2f979972802ff1d01a873d1a8e13284150ffe8" translate="yes" xml:space="preserve">
          <source>Linear: the number of calls to the destructor of T is the same as the number of elements erased, the assignment operator of T is called the number of times equal to the number of elements in the vector after the erased elements.</source>
          <target state="translated">线性:对T的析构器的调用次数与被擦除的元素数相同,对T的赋值运算符的调用次数等于被擦除元素后的向量中的元素数。</target>
        </trans-unit>
        <trans-unit id="4ee1b770c5760a0a6cf5b30f78ae338fd8baa73a" translate="yes" xml:space="preserve">
          <source>Linear: the number of calls to the destructor of T is the same as the number of elements erased, the number of calls to the assignment operator of T is no more than the lesser of the number of elements before the erased elements and the number of elements after the erased elements.</source>
          <target state="translated">线性:调用T的析构器的次数与被擦除的元素数相同,调用T的赋值运算符的次数不超过被擦除元素前的元素数和被擦除元素后的元素数中的较小者。</target>
        </trans-unit>
        <trans-unit id="8f51211d5882b7b1d7f5bacb8c562304994eec22" translate="yes" xml:space="preserve">
          <source>Link has been severed</source>
          <target state="translated">链接已被切断</target>
        </trans-unit>
        <trans-unit id="b27dc31140950c016978fcb4c144b7b2d3cbc47c" translate="yes" xml:space="preserve">
          <source>Linkage</source>
          <target state="translated">Linkage</target>
        </trans-unit>
        <trans-unit id="55ecf80e85b7d19bbe4096b1255534070ebf5b46" translate="yes" xml:space="preserve">
          <source>Linkage specification</source>
          <target state="translated">联动规格</target>
        </trans-unit>
        <trans-unit id="44da027a7d61f0dfd1784a90d378229ab9cfb71e" translate="yes" xml:space="preserve">
          <source>List initialization is performed in the following situations:</source>
          <target state="translated">列表初始化是在以下情况下进行的。</target>
        </trans-unit>
        <trans-unit id="7094bd5e681efcce9038e6d995bf2d060fc85079" translate="yes" xml:space="preserve">
          <source>List operations</source>
          <target state="translated">列表操作</target>
        </trans-unit>
        <trans-unit id="00863cc84a92ec056c8a5802850de22482d7a20f" translate="yes" xml:space="preserve">
          <source>List-initialization</source>
          <target state="translated">List-initialization</target>
        </trans-unit>
        <trans-unit id="54a3b43bb92df32d485a7093803f903e36c579fd" translate="yes" xml:space="preserve">
          <source>Lists the exceptions that a function might directly or indirectly throw.</source>
          <target state="translated">列出一个函数可能直接或间接抛出的异常。</target>
        </trans-unit>
        <trans-unit id="88f0bff43cf350627f446597dc555fcbb10deccb" translate="yes" xml:space="preserve">
          <source>Literal constant expression</source>
          <target state="translated">字面常数表达式</target>
        </trans-unit>
        <trans-unit id="a7c8f6e22e4cf98d224c691373983e8bb4a14cd5" translate="yes" xml:space="preserve">
          <source>Literal operators</source>
          <target state="translated">字面运算符</target>
        </trans-unit>
        <trans-unit id="793829f43d6401d24000acee9b0edc1896c5c837" translate="yes" xml:space="preserve">
          <source>Literal type that extends string literals:</source>
          <target state="translated">字符类型,扩展了字符串字符。</target>
        </trans-unit>
        <trans-unit id="2304c62e8f7798124c1dc52b057e7762191e4112" translate="yes" xml:space="preserve">
          <source>LiteralType</source>
          <target state="translated">LiteralType</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="b85acf10db8d6b17de3526edb467be756ff163a4" translate="yes" xml:space="preserve">
          <source>Literals are the tokens of a C++ program that represent constant values embedded in the source code.</source>
          <target state="translated">字符是C++程序的标记,代表嵌入源代码中的常量值。</target>
        </trans-unit>
        <trans-unit id="207b5847d31f577b34ce5944ce67366ee6a9f77d" translate="yes" xml:space="preserve">
          <source>Loads the data from locations, defined by &lt;code&gt;vlist&lt;/code&gt;,, converts them to wide string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">从由 &lt;code&gt;vlist&lt;/code&gt; 定义的位置加载数据，将其转换为等效的宽字符串，并将结果写入各种接收器。</target>
        </trans-unit>
        <trans-unit id="306845665660271f5edceb9cf305119d107a9b6d" translate="yes" xml:space="preserve">
          <source>Loads the data from the given locations, converts them to character string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">从给定的位置加载数据,将其转换为字符串等价物,并将结果写入各种汇。</target>
        </trans-unit>
        <trans-unit id="b98547f12140b861f02fc92da40524e3b426e7b6" translate="yes" xml:space="preserve">
          <source>Loads the data from the given locations, converts them to wide string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">从给定位置加载数据,将其转换为宽字符串等价物,并将结果写入各种汇。</target>
        </trans-unit>
        <trans-unit id="7bea89bc2ce48c930dc7395bbdbef3f7216a1506" translate="yes" xml:space="preserve">
          <source>Loads the data from the locations, defined by &lt;code&gt;vlist&lt;/code&gt;, converts them to character string equivalents and writes the results to a variety of sinks.</source>
          <target state="translated">从由 &lt;code&gt;vlist&lt;/code&gt; 定义的位置加载数据，将它们转换为等效的字符串，然后将结果写入各种接收器。</target>
        </trans-unit>
        <trans-unit id="3efe7e57b877b99e83abee299be618072a6caad5" translate="yes" xml:space="preserve">
          <source>Loads the execution context &lt;code&gt;env&lt;/code&gt; saved by a previous call to &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt;. This function does not return. Control is transferred to the call site of the macro &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; that set up &lt;code&gt;env&lt;/code&gt;. That &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; then returns the value, passed as the &lt;code&gt;status&lt;/code&gt;.</source>
          <target state="translated">加载先前调用 &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 保存的执行上下文 &lt;code&gt;env&lt;/code&gt; 。此函数不返回。控制权转移到设置 &lt;code&gt;env&lt;/code&gt; 的宏 &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 的调用站点。然后，该 &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 返回作为 &lt;code&gt;status&lt;/code&gt; 传递的值。</target>
        </trans-unit>
        <trans-unit id="f3f3766d936a084f7885a89b74bff964f93af54b" translate="yes" xml:space="preserve">
          <source>Local classes</source>
          <target state="translated">本地课程</target>
        </trans-unit>
        <trans-unit id="4aae5a412706d04afcfacf152e9fb5c7502dd7b9" translate="yes" xml:space="preserve">
          <source>Local classes cannot define &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt; inside the class definition</source>
          <target state="translated">本地类不能在类定义中定义&lt;a href=&quot;friend&quot;&gt;朋友功能&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="537fd817534a9d16da0662978fafc67944474038" translate="yes" xml:space="preserve">
          <source>Local classes cannot have &lt;a href=&quot;friend#Template_friends&quot;&gt;friend templates&lt;/a&gt;</source>
          <target state="translated">本地课程不能有&lt;a href=&quot;friend#Template_friends&quot;&gt;朋友模板&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25934a3163283e7417a8ccb81533f8c6db7c89fa" translate="yes" xml:space="preserve">
          <source>Local classes other than &lt;a href=&quot;lambda&quot;&gt;closure types&lt;/a&gt;(since C++14) cannot have member templates</source>
          <target state="translated">除&lt;a href=&quot;lambda&quot;&gt;闭包类型&lt;/a&gt;（自C ++ 14）以来的本地类不能具有成员模板</target>
        </trans-unit>
        <trans-unit id="0b64c37e179f49fcbc2cadc0fb2d42cd79c4fdd9" translate="yes" xml:space="preserve">
          <source>Local monetary numeric formatting parameters</source>
          <target state="translated">本地货币数字格式参数</target>
        </trans-unit>
        <trans-unit id="9ac34b8bf1cd18f9b339db9b7d7bfbe70142b73d" translate="yes" xml:space="preserve">
          <source>Local variables are not allowed in default arguments  unless used in unevaluated context(since C++14):</source>
          <target state="translated">除非在未评估的上下文中使用,否则在默认参数中不允许使用局部变量(自C++14起)。</target>
        </trans-unit>
        <trans-unit id="8970f0e691a0a23a47517698017c997507efd496" translate="yes" xml:space="preserve">
          <source>Locale</source>
          <target state="translated">Locale</target>
        </trans-unit>
        <trans-unit id="6c3524ddb4dbd6e55cdddfdad87f91e490674af0" translate="yes" xml:space="preserve">
          <source>Locale-independent unicode conversion facets</source>
          <target state="translated">独立于本地的unicode转换方面。</target>
        </trans-unit>
        <trans-unit id="9e57020d7e664c3bc1f3a56095434c59ad016632" translate="yes" xml:space="preserve">
          <source>Locale-specific facet categories</source>
          <target state="translated">局部特定的方面类别</target>
        </trans-unit>
        <trans-unit id="a222060e32289bf6910ac4a07a10733be500bd99" translate="yes" xml:space="preserve">
          <source>Locales</source>
          <target state="translated">Locales</target>
        </trans-unit>
        <trans-unit id="3a0f6d00aea8688a68e6b8a0597983687499bda4" translate="yes" xml:space="preserve">
          <source>Locales and facets</source>
          <target state="translated">地区和方面</target>
        </trans-unit>
        <trans-unit id="d2ba11823ed33de4da4e31b0eebe19082e18127d" translate="yes" xml:space="preserve">
          <source>Localization library</source>
          <target state="translated">本地化库</target>
        </trans-unit>
        <trans-unit id="c07f512f68e601c83a418f3dad591a2645430943" translate="yes" xml:space="preserve">
          <source>Localization utilities</source>
          <target state="translated">本地化工具</target>
        </trans-unit>
        <trans-unit id="dc8dbeb23836a69ebeafc222497183282817c913" translate="yes" xml:space="preserve">
          <source>Localizations</source>
          <target state="translated">Localizations</target>
        </trans-unit>
        <trans-unit id="d71da9d4cb1a804d59d89b1825a9880a0942d7ab" translate="yes" xml:space="preserve">
          <source>Locates the first character in the character array &lt;code&gt;[beg, end)&lt;/code&gt; that does not satisfy the classification mask &lt;code&gt;m&lt;/code&gt;, that is, the first character &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt; would return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在字符数组 &lt;code&gt;[beg, end)&lt;/code&gt; 中找到不满足分类掩码 &lt;code&gt;m&lt;/code&gt; 的第一个字符，即，第一个字符 &lt;code&gt;c&lt;/code&gt; 使得 &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt; 返回 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="357cdcce80e8002095e52999c10401e1457183fd" translate="yes" xml:space="preserve">
          <source>Locates the first character in the character array &lt;code&gt;[beg, end)&lt;/code&gt; that satisfies the classification mask &lt;code&gt;m&lt;/code&gt;, that is, the first character &lt;code&gt;c&lt;/code&gt; such that &lt;code&gt;table()[(unsigned char) c] &amp;amp; m&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">在满足分类掩码 &lt;code&gt;m&lt;/code&gt; 的字符数组 &lt;code&gt;[beg, end)&lt;/code&gt; 中找到第一个字符，即，第一个字符 &lt;code&gt;c&lt;/code&gt; 使得 &lt;code&gt;table()[(unsigned char) c] &amp;amp; m&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="31e9f816605eb9508f673fc28eb1f9b42210f44e" translate="yes" xml:space="preserve">
          <source>Locates the first occurrence of wide character &lt;code&gt;ch&lt;/code&gt; in the initial &lt;code&gt;count&lt;/code&gt; wide characters of the wide character array pointed to by &lt;code&gt;ptr&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;ptr&lt;/code&gt; 指向的宽字符数组的初始 &lt;code&gt;count&lt;/code&gt; 宽字符中找到宽字符 &lt;code&gt;ch&lt;/code&gt; 的第一次出现。</target>
        </trans-unit>
        <trans-unit id="14fbab694e4672e756dc11003aa78ae825a8fc71" translate="yes" xml:space="preserve">
          <source>Lock freedom</source>
          <target state="translated">锁定自由</target>
        </trans-unit>
        <trans-unit id="ee78ba28c676d3bfd6bbd0d0ac4dc1adaedada08" translate="yes" xml:space="preserve">
          <source>Lockable</source>
          <target state="translated">Lockable</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="89301c33d91c56fca51d422389610ec0003774ae" translate="yes" xml:space="preserve">
          <source>Locks the associated mutex in shared mode. Effectively calls &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt;.</source>
          <target state="translated">将关联的互斥锁锁定为共享模式。有效地调用 &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e4c226b5fbb2b899205fcb0ab7e1977150757b6" translate="yes" xml:space="preserve">
          <source>Locks the associated mutex. Effectively calls &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt;.</source>
          <target state="translated">锁定关联的互斥锁。有效地调用 &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bdeef0016a6ddc17439dd3082bbe560063b4040e" translate="yes" xml:space="preserve">
          <source>Locks the given &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; objects &lt;code&gt;lock1&lt;/code&gt;, &lt;code&gt;lock2&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt;, &lt;code&gt;lockn&lt;/code&gt; using a deadlock avoidance algorithm to avoid deadlock.</source>
          <target state="translated">锁定&lt;a href=&quot;../named_req/lockable&quot;&gt;可锁定&lt;/a&gt;对象 &lt;code&gt;lock1&lt;/code&gt; ， &lt;code&gt;lock2&lt;/code&gt; ， &lt;code&gt;...&lt;/code&gt; ， &lt;code&gt;lockn&lt;/code&gt; 使用死锁避免算法，以避免死锁。</target>
        </trans-unit>
        <trans-unit id="07953af6eaa80da971053dc23bda5d5c2a2e5a5c" translate="yes" xml:space="preserve">
          <source>Locks the mutex. If another thread has already locked the mutex, a call to &lt;code&gt;lock&lt;/code&gt; will block execution until the lock is acquired.</source>
          <target state="translated">锁定互斥锁。如果另一个线程已经锁定了互斥锁，则对 &lt;code&gt;lock&lt;/code&gt; 的调用将阻止执行，直到获得该锁为止。</target>
        </trans-unit>
        <trans-unit id="9b108190806dbf643b285b25368b99531689061b" translate="yes" xml:space="preserve">
          <source>Logarithmic in the size of the container in general, but amortized constant if the new element is inserted just before &lt;code&gt;hint&lt;/code&gt;.</source>
          <target state="translated">通常是容器大小的对数，但是如果将新元素恰好在 &lt;code&gt;hint&lt;/code&gt; 之前插入，则为摊销常数。</target>
        </trans-unit>
        <trans-unit id="e9067460d73ae825ba6714018f7615492aa47865" translate="yes" xml:space="preserve">
          <source>Logarithmic in the size of the container plus linear in the number of the elements found.</source>
          <target state="translated">容器大小的对数加上找到的元素数量的线性。</target>
        </trans-unit>
        <trans-unit id="5e5188bc43c4d9b70c9cf627bba80326dacae4d7" translate="yes" xml:space="preserve">
          <source>Logarithmic in the size of the container.</source>
          <target state="translated">容器尺寸的对数。</target>
        </trans-unit>
        <trans-unit id="73b7130da3c78f3712cf8aced2ce52c3b3bb17f4" translate="yes" xml:space="preserve">
          <source>Logarithmic number of comparisons plus the complexity of &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">比较的对数加上 &lt;code&gt;Container::emplace_back&lt;/code&gt; 的复杂度。</target>
        </trans-unit>
        <trans-unit id="58b1b6caf7fe5a42c100cf12c95e7a3c6866c24d" translate="yes" xml:space="preserve">
          <source>Logarithmic number of comparisons plus the complexity of &lt;code&gt;Container::pop_back&lt;/code&gt;.</source>
          <target state="translated">比较的对数加上 &lt;code&gt;Container::pop_back&lt;/code&gt; 的复杂度。</target>
        </trans-unit>
        <trans-unit id="1c3cf65301fe13dbcf804ac556fa2da47b162343" translate="yes" xml:space="preserve">
          <source>Logarithmic number of comparisons plus the complexity of &lt;code&gt;Container::push_back&lt;/code&gt;.</source>
          <target state="translated">比较的对数加上 &lt;code&gt;Container::push_back&lt;/code&gt; 的复杂度。</target>
        </trans-unit>
        <trans-unit id="c5d5c5fb2a8798e4f962780fba63386de96b07b6" translate="yes" xml:space="preserve">
          <source>Logical AND</source>
          <target state="translated">逻辑和</target>
        </trans-unit>
        <trans-unit id="e9b0aefdf7ed2c67abbfc572bbc5743979450674" translate="yes" xml:space="preserve">
          <source>Logical OR</source>
          <target state="translated">逻辑OR</target>
        </trans-unit>
        <trans-unit id="ab411408fbd29ad68b53700b2e7826c03e6703f0" translate="yes" xml:space="preserve">
          <source>Logical operations</source>
          <target state="translated">逻辑运算</target>
        </trans-unit>
        <trans-unit id="4654c9b2b818a080fc48b5bd5a47f40691d6eb0d" translate="yes" xml:space="preserve">
          <source>Logical operator type traits</source>
          <target state="translated">逻辑运算符类型特征</target>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="translated">逻辑运算符</target>
        </trans-unit>
        <trans-unit id="7015ab4fc4ea24735dbe884238cc1b54bf915eca" translate="yes" xml:space="preserve">
          <source>Lookup</source>
          <target state="translated">Lookup</target>
        </trans-unit>
        <trans-unit id="9df7d9cefaf31feb4f6b24d79bad8d071fcb03de" translate="yes" xml:space="preserve">
          <source>Lookup rules</source>
          <target state="translated">查询规则</target>
        </trans-unit>
        <trans-unit id="cab4a2117d8f9c8117e26920652c300561edd076" translate="yes" xml:space="preserve">
          <source>Low level memory management</source>
          <target state="translated">低级内存管理</target>
        </trans-unit>
        <trans-unit id="bd3740e01fb4f11441f7e643cef68b3881c9e618" translate="yes" xml:space="preserve">
          <source>Low-level memory management utilities</source>
          <target state="translated">低级内存管理实用程序</target>
        </trans-unit>
        <trans-unit id="3769a18de297ff08768c9476ca9be5fa9f7cb3ea" translate="yes" xml:space="preserve">
          <source>Lowercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no lowercase version is listed in the current C locale.</source>
          <target state="translated">&lt;code&gt;ch&lt;/code&gt; 的小写版本或未修改的 &lt;code&gt;ch&lt;/code&gt; (如果当前C语言环境中未列出小写版本）。</target>
        </trans-unit>
        <trans-unit id="befc5b417a1ee8ed446b10341ff5e771b51fffbc" translate="yes" xml:space="preserve">
          <source>Lvalue and rvalue references</source>
          <target state="translated">L值和r值参考</target>
        </trans-unit>
        <trans-unit id="3327811a28b6dc92897c7bd726a6ee4cb5edaa0f" translate="yes" xml:space="preserve">
          <source>Lvalue references</source>
          <target state="translated">L值参考</target>
        </trans-unit>
        <trans-unit id="a213708ed1a0d723b5b6a805c274cf9bff5d1146" translate="yes" xml:space="preserve">
          <source>Lvalue references can be used to alias an existing object (optionally with different cv-qualification):</source>
          <target state="translated">L-value引用可以用来别名一个现有的对象(可以选择使用不同的cv-限定)。</target>
        </trans-unit>
        <trans-unit id="08f35d31d723fb0a56bd4bcfd14b0053b8eb609f" translate="yes" xml:space="preserve">
          <source>Lvalue to rvalue conversion</source>
          <target state="translated">L值到r值的转换</target>
        </trans-unit>
        <trans-unit id="43e928199e03709bb299f1077cb46f632464d9e4" translate="yes" xml:space="preserve">
          <source>Lvalue to rvalue conversion (e.g. function call to a function that takes a value).</source>
          <target state="translated">L值到r值的转换(例如,函数调用到一个取值的函数)。</target>
        </trans-unit>
        <trans-unit id="41bc669bb535a7e446d5f35250e723d4b222463a" translate="yes" xml:space="preserve">
          <source>M, ..., a</source>
          <target state="translated">M,...,a</target>
        </trans-unit>
        <trans-unit id="5de4e334f963f744c52ad0d25e83c8a8e959ae90" translate="yes" xml:space="preserve">
          <source>M, ..., b</source>
          <target state="translated">M,...,b</target>
        </trans-unit>
        <trans-unit id="a06f1b8f093c7cc11caa03599d07adbc807edfe6" translate="yes" xml:space="preserve">
          <source>MACRON</source>
          <target state="translated">MACRON</target>
        </trans-unit>
        <trans-unit id="850947f3d010de98ad370f2f73bc49ca69c2b7c5" translate="yes" xml:space="preserve">
          <source>MATH_ERRNO</source>
          <target state="translated">MATH_ERRNO</target>
        </trans-unit>
        <trans-unit id="74b7d4ceae8b4d3f14a2b48ce0dd4a45027ad623" translate="yes" xml:space="preserve">
          <source>MATH_ERRNO, MATH_ERREXCEPT, math_errhandling</source>
          <target state="translated">MATH_ERRNO,MATH_ERREXCEPT,math_errhandling等。</target>
        </trans-unit>
        <trans-unit id="0b26b4988457eebaa5d41abd9af85e69645b9b63" translate="yes" xml:space="preserve">
          <source>MB_CUR_MAX</source>
          <target state="translated">MB_CUR_MAX</target>
        </trans-unit>
        <trans-unit id="6bfcb6f4e22f270971b8066d4c18f2a3c153409a" translate="yes" xml:space="preserve">
          <source>MB_LEN_MAX</source>
          <target state="translated">MB_LEN_MAX</target>
        </trans-unit>
        <trans-unit id="a3de7ac6ae1a36761d2bb7db4fb097d2d59a0d43" translate="yes" xml:space="preserve">
          <source>MIDDLE DOT - MASCULINE ORDINAL INDICATOR</source>
          <target state="translated">中间点--阳性的正常指标。</target>
        </trans-unit>
        <trans-unit id="0beb871a186f42594bcfbcc8916c8146ec93832e" translate="yes" xml:space="preserve">
          <source>MOESI protocol</source>
          <target state="translated">MOESI协议</target>
        </trans-unit>
        <trans-unit id="1240ae02c583b36398d148ddc49074ea0ee43ffd" translate="yes" xml:space="preserve">
          <source>MSVC function &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/e9b52ceh.aspx&quot;&gt;_control87()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates a hardware exception, which can be converted to C++ exceptions with &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/5z4bw5h5.aspx&quot;&gt;_set_se_translator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">MSVC函数 &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/e9b52ceh.aspx&quot;&gt;_control87()&lt;/a&gt;&lt;/code&gt; 启用了对浮点异常的陷阱，从而生成了硬件异常，可以使用 &lt;code&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/5z4bw5h5.aspx&quot;&gt;_set_se_translator&lt;/a&gt;&lt;/code&gt; 将其转换为C ++异常。</target>
        </trans-unit>
        <trans-unit id="2d7ac97eaf33ec3cf9c03bd404689cfd6e8e46fe" translate="yes" xml:space="preserve">
          <source>MSVC function &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/e9b52ceh.aspx&quot;&gt;_control87()&lt;/a&gt;&lt;/code&gt; enables trapping of the floating-point exceptions, which generates a hardware exception, which can be converted to C++ exceptions with &lt;code&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/5z4bw5h5.aspx&quot;&gt;_set_se_translator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d6fc761949b6e88739a8a2fe091585d2e12ec1" translate="yes" xml:space="preserve">
          <source>Macro (and function) that saves (and jumps) to an execution context</source>
          <target state="translated">保存(和跳转)到执行上下文的宏(和函数)。</target>
        </trans-unit>
        <trans-unit id="54b23dc205b8e1437102e969e0df1e0a65dc7096" translate="yes" xml:space="preserve">
          <source>Macro Constants</source>
          <target state="translated">宏观常数</target>
        </trans-unit>
        <trans-unit id="fc1086b9f1dd6c6f26d36bd306a911dfb2aafce8" translate="yes" xml:space="preserve">
          <source>Macro constants</source>
          <target state="translated">宏观常数</target>
        </trans-unit>
        <trans-unit id="2f38b57c7b725c5c9e818e78c55ee7bbba8563a8" translate="yes" xml:space="preserve">
          <source>Macro containing the last error number</source>
          <target state="translated">包含最后一个错误编号的宏</target>
        </trans-unit>
        <trans-unit id="5b3a11a44726526a8271fd69a51140ab465210aa" translate="yes" xml:space="preserve">
          <source>Macro name</source>
          <target state="translated">宏观名称</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="f314f8acf113225093359e0691186dc638458d3f" translate="yes" xml:space="preserve">
          <source>Macros for data types</source>
          <target state="translated">数据类型的宏</target>
        </trans-unit>
        <trans-unit id="ac71fe79e397b89328648d619d9408673bd60d02" translate="yes" xml:space="preserve">
          <source>Main classes</source>
          <target state="translated">主要班级</target>
        </trans-unit>
        <trans-unit id="e4ac70ee360a262794e6e975e302e13279210903" translate="yes" xml:space="preserve">
          <source>Main function</source>
          <target state="translated">主要功能</target>
        </trans-unit>
        <trans-unit id="99859e4cd4b9cce2f83ab42dc587698a3602b044" translate="yes" xml:space="preserve">
          <source>Maintenance overhead</source>
          <target state="translated">维护费用</target>
        </trans-unit>
        <trans-unit id="b74e5fa51321d77a94a62fd68d1ad7b564b98a8d" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;language/noexcept_spec&quot;&gt;exception specifications&lt;/a&gt; be part of the type system</source>
          <target state="translated">使&lt;a href=&quot;language/noexcept_spec&quot;&gt;异常规范&lt;/a&gt;成为类型系统的一部分</target>
        </trans-unit>
        <trans-unit id="6c08c5931ae98077d74c2fcd13d3f199daa1d289" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;f&lt;/code&gt; the new global &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; and returns the previously installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;f&lt;/code&gt; 为新的全局 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; 并返回先前安装的 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="65917fbeb3c6129587b44cf1b845bea5476e82d9" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;f&lt;/code&gt; the new global terminate handler function and returns the previously installed &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">使 &lt;code&gt;f&lt;/code&gt; 为新的全局终止处理程序函数，并返回先前安装的 &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b87d9c9486d3bcd72b7d0fe8b4ab7ceb6d812eec" translate="yes" xml:space="preserve">
          <source>Makes &lt;code&gt;new_p&lt;/code&gt; the new global new-handler function and returns the previously installed new-handler.</source>
          <target state="translated">使 &lt;code&gt;new_p&lt;/code&gt; 成为新的全局new-handler函数，并返回以前安装的new-handler。</target>
        </trans-unit>
        <trans-unit id="ec8c940401a44da0f32dd9b030215fd134a7013f" translate="yes" xml:space="preserve">
          <source>Makes the most recently extracted character available again.</source>
          <target state="translated">使最近提取的字符再次可用。</target>
        </trans-unit>
        <trans-unit id="96fe058e3a49999026b621bd5db51a5c913b4002" translate="yes" xml:space="preserve">
          <source>Making &lt;code&gt;&lt;a href=&quot;memory/owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; more flexible (&lt;a href=&quot;memory/owner_less_void&quot;&gt;&lt;code&gt;std::owner_less&amp;lt;void&amp;gt;&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">使 &lt;code&gt;&lt;a href=&quot;memory/owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; 更灵活（&lt;a href=&quot;memory/owner_less_void&quot;&gt; &lt;code&gt;std::owner_less&amp;lt;void&amp;gt;&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="0c16d51463aefe216e81a0bd813cbff2e451ca3d" translate="yes" xml:space="preserve">
          <source>Making a virtual call to a pure virtual function from a constructor or the destructor of the abstract class is undefined behavior (regardless of whether it has a definition or not).</source>
          <target state="translated">从抽象类的构造函数或析构函数对纯虚拟函数进行虚拟调用是未定义的行为(不管它是否有定义)。</target>
        </trans-unit>
        <trans-unit id="6b8f8ae2577f5b38158790bbc573b214aa51aaaa" translate="yes" xml:space="preserve">
          <source>Making non-modifying sequence operations more robust (two-range overloads for &lt;code&gt;&lt;a href=&quot;algorithm/mismatch&quot;&gt;std::mismatch&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;algorithm/is_permutation&quot;&gt;std::is_permutation&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">使非修改序列操作更健壮（ &lt;code&gt;&lt;a href=&quot;algorithm/mismatch&quot;&gt;std::mismatch&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;algorithm/equal&quot;&gt;std::equal&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;algorithm/is_permutation&quot;&gt;std::is_permutation&lt;/a&gt;&lt;/code&gt; 两个范围的重载）</target>
        </trans-unit>
        <trans-unit id="093902494fcace52d152c76c43c81becca401b50" translate="yes" xml:space="preserve">
          <source>Manages format flags.</source>
          <target state="translated">管理格式标志。</target>
        </trans-unit>
        <trans-unit id="9b66e0ff5e969314f7b51fc9d7ca3a9cf4a3c17f" translate="yes" xml:space="preserve">
          <source>Manages the associated distribution parameter set.</source>
          <target state="translated">管理相关的分布参数集。</target>
        </trans-unit>
        <trans-unit id="f62964b0cba3090f15f7c7c169b11e039cc6021f" translate="yes" xml:space="preserve">
          <source>Manages the associated stream buffer.</source>
          <target state="translated">管理相关的流缓冲区。</target>
        </trans-unit>
        <trans-unit id="aa5c32a8e138595d4766f2b368480e3dea10b879" translate="yes" xml:space="preserve">
          <source>Manages the contents of the underlying string object.</source>
          <target state="translated">管理底层字符串对象的内容。</target>
        </trans-unit>
        <trans-unit id="57d385100206298ef30b732a8a74a273e12fee69" translate="yes" xml:space="preserve">
          <source>Manages the file position state.</source>
          <target state="translated">管理文件位置状态。</target>
        </trans-unit>
        <trans-unit id="4b0c6baba7868d541df5a1d3ef12c5d69bb016de" translate="yes" xml:space="preserve">
          <source>Manages the fill character used to pad the output conversions to the specified field width.</source>
          <target state="translated">管理用于将输出转换填充到指定字段宽度的填充字符。</target>
        </trans-unit>
        <trans-unit id="fc74e82d452fdfbe907a8fe1326c0b7d7df02587" translate="yes" xml:space="preserve">
          <source>Manages the floating-point rounding direction.</source>
          <target state="translated">管理浮点进位方向。</target>
        </trans-unit>
        <trans-unit id="0e6eaddb68bc270047cd5aa7f3b44d9637620333" translate="yes" xml:space="preserve">
          <source>Manages the maximum load factor (number of elements per bucket). The container automatically increases the number of buckets if the load factor exceeds this threshold.</source>
          <target state="translated">管理最大负载因子(每个桶的元素数量)。如果负载因子超过此阈值,容器会自动增加桶的数量。</target>
        </trans-unit>
        <trans-unit id="daa55aac6e6edc66679c2eb334f89dce6b539bde" translate="yes" xml:space="preserve">
          <source>Manages the minimum number of characters to generate on certain output operations and the maximum number of characters to generate on certain input operations.</source>
          <target state="translated">管理某些输出操作产生的最小字符数和某些输入操作产生的最大字符数。</target>
        </trans-unit>
        <trans-unit id="9111786b8ae1322461661a6b8d566d1d3675a5ed" translate="yes" xml:space="preserve">
          <source>Manages the precision (i.e. how many digits are generated) of floating point output performed by &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">管理 &lt;code&gt;&lt;a href=&quot;../../locale/num_put/put&quot;&gt;std::num_put::do_put&lt;/a&gt;&lt;/code&gt; 执行的浮点输出的精度（即生成的位数）。</target>
        </trans-unit>
        <trans-unit id="887d2a92b7896a60b0850785e37481b9b04bbad8" translate="yes" xml:space="preserve">
          <source>Manages the status of the floating-point environment.</source>
          <target state="translated">管理浮点环境的状态。</target>
        </trans-unit>
        <trans-unit id="25d259883659a20164c7acf68339bc48d8362b03" translate="yes" xml:space="preserve">
          <source>Manages the tied stream. A tied stream is an output stream which is synchronized with the sequence controlled by the stream buffer (&lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt;), that is, &lt;code&gt;flush()&lt;/code&gt; is called on the tied stream before any input/output operation on &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">管理绑定的流。绑定流是与流缓冲区（ &lt;code&gt;&lt;a href=&quot;rdbuf&quot;&gt;rdbuf()&lt;/a&gt;&lt;/code&gt; ）控制的序列同步的输出流，即在 &lt;code&gt;*this&lt;/code&gt; 上进行任何输入/输出操作之前，在绑定流上调用 &lt;code&gt;flush()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e42c0bcf36c095bb9efb82dcb299ae099631d5a9" translate="yes" xml:space="preserve">
          <source>Manipulators</source>
          <target state="translated">Manipulators</target>
        </trans-unit>
        <trans-unit id="aa5986c6a9620c6b6e1856b7e2e600fe262ff7db" translate="yes" xml:space="preserve">
          <source>Manipulators are helper functions that make it possible to control input/output streams using &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; or &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">操纵器是辅助函数，可以使用 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 或 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 来控制输入/输出流。</target>
        </trans-unit>
        <trans-unit id="0ce8863df9e71406305b90f9ea018e8bb9b2e809" translate="yes" xml:space="preserve">
          <source>Many classes in the standard library overload &lt;code&gt;operator()&lt;/code&gt; to be used as function objects.</source>
          <target state="translated">标准库中的许多类都将 &lt;code&gt;operator()&lt;/code&gt; 用作函数对象。</target>
        </trans-unit>
        <trans-unit id="0edc88ddffd739223885d2fe9cd8f80ed597ff78" translate="yes" xml:space="preserve">
          <source>Many compilers also implement the non-standard &lt;a href=&quot;impl&quot;&gt;&lt;code&gt;pragma&lt;/code&gt;&lt;/a&gt;&lt;code&gt;#pragma once&lt;/code&gt; with similar effects: it disables processing of a file if the same file (where file identity is determined in OS-specific way) has already been included.</source>
          <target state="translated">许多编译器还一次实现了非标准的&lt;a href=&quot;impl&quot;&gt; &lt;code&gt;pragma&lt;/code&gt; &lt;/a&gt; &lt;code&gt;#pragma once&lt;/code&gt; 具有类似的效果：如果已经包含相同的文件（其中文件标识是通过特定于OS的方式确定的），它将禁用文件的处理。</target>
        </trans-unit>
        <trans-unit id="6f405e95e132707ef26ac64e6bc3fe82236e30e2" translate="yes" xml:space="preserve">
          <source>Many compilers issue &quot;strict aliasing&quot; warnings in such cases, even though technically such constructs run afoul of something other than the paragraph commonly known as the &quot;strict aliasing rule&quot;.</source>
          <target state="translated">许多编译器在这种情况下会发出 &quot;严格的别名 &quot;警告,尽管从技术上讲,这种结构违反了通常称为 &quot;严格的别名规则 &quot;的段落以外的其他内容。</target>
        </trans-unit>
        <trans-unit id="e9f40adecaac3afe40b8b2e36b992f8de08d6cdf" translate="yes" xml:space="preserve">
          <source>Many implementations also provide &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total ordering&lt;/a&gt; of pointers of random origin, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">许多实现还提供了随机起源的指针的&lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;严格总排序&lt;/a&gt;，例如，如果它们被实现为连续虚拟地址空间内的地址。不需要的那些实现（例如，并非指针的所有位都是存储器地址的一部分，必须将其忽略以进行比较，或者需要额外的计算，否则指针和整数不是一对一的关系）。 &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; 专业化，用于具有该保证的指针。这样就可以将随机起源的所有指针用作标准关联容器（例如 &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6df4f43ab58f853f38804bd87ed02d4813b8bfca" translate="yes" xml:space="preserve">
          <source>Many implementations do not update the get area in &lt;code&gt;seekpos()&lt;/code&gt;, delegating to &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; that is called by the next &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">许多实现不更新 &lt;code&gt;seekpos()&lt;/code&gt; 中的get区域，而是委托给 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 一个 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetc&quot;&gt;sgetc()&lt;/a&gt;&lt;/code&gt; 调用的underflow（）。</target>
        </trans-unit>
        <trans-unit id="f68fed89e22619f36d034e4ae6b5e591f90adb28" translate="yes" xml:space="preserve">
          <source>Many low-level OS APIs for directory traversal retrieve file attributes along with the next directory entry. The constructors and the non-const member functions of &lt;code&gt;directory_iterator&lt;/code&gt; store these attributes, if any, in the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; without calling &lt;a href=&quot;refresh&quot;&gt;&lt;code&gt;directory_entry::refresh&lt;/code&gt;&lt;/a&gt;, which makes it possible to examine the attributes of the directory entries as they are being iterated over, without making additional system calls.</source>
          <target state="translated">许多用于目录遍历的低级OS API会检索文件属性以及下一个目录条目。 &lt;code&gt;directory_iterator&lt;/code&gt; 的构造函数和非const成员函数将这些属性（如果有的话）存储在指向的&lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; 中,&lt;/a&gt;而无需调用&lt;a href=&quot;refresh&quot;&gt; &lt;code&gt;directory_entry::refresh&lt;/code&gt; &lt;/a&gt;，这使得可以在遍历目录条目的属性时对其进行检查，无需进行其他系统调用。</target>
        </trans-unit>
        <trans-unit id="039f47ebbed9ac7270772eb78d294ff20051a865" translate="yes" xml:space="preserve">
          <source>Many low-level OS APIs for directory traversal retrieve file attributes along with the next directory entry. The constructors and the non-const member functions of &lt;code&gt;directory_iterator&lt;/code&gt; store these attributes, if any, in the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; without calling &lt;strong&gt;&lt;code&gt;directory_entry::refresh&lt;/code&gt;&lt;/strong&gt;, which makes it possible to examine the attributes of the directory entries as they are being iterated over, without making additional system calls.</source>
          <target state="translated">许多用于目录遍历的低级OS API会检索文件属性以及下一个目录条目。 &lt;code&gt;directory_iterator&lt;/code&gt; 的构造函数和非const成员函数将这些属性（如果有的话）存储在指向的&lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; 中,&lt;/a&gt;而无需调用&lt;strong&gt; &lt;code&gt;directory_entry::refresh&lt;/code&gt; &lt;/strong&gt;，这使得可以在遍历目录条目的属性时对其进行检查，无需进行其他系统调用。</target>
        </trans-unit>
        <trans-unit id="3ed89c2f28cb830995daa3a7b4042d44d35eeacb" translate="yes" xml:space="preserve">
          <source>Many low-level OS APIs for directory traversal retrieve file attributes along with the next directory entry. The constructors and the non-const member functions of &lt;code&gt;directory_iterator&lt;/code&gt; store these attributes, if any, in the pointed-to &lt;a href=&quot;directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; without calling &lt;a href=&quot;directory_entry/refresh&quot;&gt;&lt;code&gt;directory_entry::refresh&lt;/code&gt;&lt;/a&gt;, which makes it possible to examine the attributes of the directory entries as they are being iterated over, without making additional system calls.</source>
          <target state="translated">许多用于目录遍历的低级OS API会检索文件属性以及下一个目录条目。 &lt;code&gt;directory_iterator&lt;/code&gt; 的构造函数和非const成员函数将这些属性（如果有的话）存储在指向的&lt;a href=&quot;directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; 中,&lt;/a&gt;而无需调用&lt;a href=&quot;directory_entry/refresh&quot;&gt; &lt;code&gt;directory_entry::refresh&lt;/code&gt; &lt;/a&gt;，这使得可以在遍历目录条目的属性时对其进行检查，无需进行其他系统调用。</target>
        </trans-unit>
        <trans-unit id="e5aebdb8c7063bd86b2ac2bb9180c0f2ca620fad" translate="yes" xml:space="preserve">
          <source>Many standard library functions (for example, many algorithms) expect their arguments to satisfy Swappable, which means that any time the standard library performs a swap, it uses the equivalent of &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(t, u);&lt;/code&gt;.</source>
          <target state="translated">许多标准库函数（例如，许多算法）都希望其参数满足Swappable的要求，这意味着，每当标准库执行交换时，它都使用与 &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(t, u);&lt;/code&gt; 等效的方法；swap（t，u）; 。</target>
        </trans-unit>
        <trans-unit id="5121f00841245e1a12c2ae4fef43200d5c0249fe" translate="yes" xml:space="preserve">
          <source>Many standard library functions expect their arguments to satisfy ValueSwappable, which means that any time the standard library performs a swap, it uses the equivalent of &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(*iter1, *iter2);&lt;/code&gt;.</source>
          <target state="translated">许多标准库函数期望其参数满足ValueSwappable，这意味着标准库每次执行交换时，都使用与 &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;; swap(*iter1, *iter2);&lt;/code&gt; 等效的方法；swap（* iter1，* iter2）; 。</target>
        </trans-unit>
        <trans-unit id="afe6902aeefe49078fe8050bd00528c238507028" translate="yes" xml:space="preserve">
          <source>Maps the wide character &lt;code&gt;wc&lt;/code&gt; using the current C locale's LC_CTYPE mapping category identified by &lt;code&gt;desc&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;desc&lt;/code&gt; 标识的当前C语言环境的LC_CTYPE映射类别映射宽字符 &lt;code&gt;wc&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4077ecc006514db344c55f8c4fad2c745c0130ce" translate="yes" xml:space="preserve">
          <source>Marks a declaration, a group of declarations, or another module as exported by the current module.</source>
          <target state="translated">将一个声明、一组声明或另一个模块标记为当前模块导出的声明。</target>
        </trans-unit>
        <trans-unit id="b756154598ee707bf908cd000d9935386991975f" translate="yes" xml:space="preserve">
          <source>Matches a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">与文字 &lt;code&gt;%&lt;/code&gt; 字符匹配。</target>
        </trans-unit>
        <trans-unit id="72f947b49a5a8e988f9298c168a0e3f58111d4e5" translate="yes" xml:space="preserve">
          <source>Matches one whitespace character.</source>
          <target state="translated">匹配一个空格字符。</target>
        </trans-unit>
        <trans-unit id="fcfacbcdbc0dc12100a2ddcea744584b78974f4f" translate="yes" xml:space="preserve">
          <source>Matches zero or one whitespace character.</source>
          <target state="translated">匹配零或一个空格字符。</target>
        </trans-unit>
        <trans-unit id="a188c6effe4bde401e7ad28544fc6e87a9daffac" translate="yes" xml:space="preserve">
          <source>Matching of &lt;a href=&quot;language/template_parameters#Template_template_arguments&quot;&gt;template template-arguments&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;language/template_parameters#Template_template_arguments&quot;&gt;模板模板参数的&lt;/a&gt;匹配</target>
        </trans-unit>
        <trans-unit id="20eb57cf8e0dada9d1ba105b859145de9af95dd7" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic cosine is cosh z =</source>
          <target state="translated">双曲余弦的数学定义是:cosh z=。</target>
        </trans-unit>
        <trans-unit id="26750d755fd0345482bcbffe431aa399db954d60" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic sine is sinh z =</source>
          <target state="translated">双曲正弦的数学定义是:sinh z=。</target>
        </trans-unit>
        <trans-unit id="e84aec3fc0130942848a9f7d933b06ea09b78dbd" translate="yes" xml:space="preserve">
          <source>Mathematical definition of hyperbolic tangent is tanh z =</source>
          <target state="translated">双曲正切的数学定义是tanh z =。</target>
        </trans-unit>
        <trans-unit id="cdb41af16e4d375b018b261d1a2817a89b9975b7" translate="yes" xml:space="preserve">
          <source>Mathematical functions and types</source>
          <target state="translated">数学函数和类型</target>
        </trans-unit>
        <trans-unit id="e69584469298924788f58d14e045618717167ab1" translate="yes" xml:space="preserve">
          <source>Mathematical special functions</source>
          <target state="translated">数学特殊函数</target>
        </trans-unit>
        <trans-unit id="86c50200efef0be47369777679929f798cf2e81a" translate="yes" xml:space="preserve">
          <source>Mathematical special functions for C++17</source>
          <target state="translated">C++17的数学特殊函数</target>
        </trans-unit>
        <trans-unit id="5d307dd0d56fc9ce2efcd46807c5cc26c88385c1" translate="yes" xml:space="preserve">
          <source>Mathematics argument out of domain of function</source>
          <target state="translated">函数域外的数学参数</target>
        </trans-unit>
        <trans-unit id="f8777efcd5a7cb7cda3c0f39eeda95994a1a15e9" translate="yes" xml:space="preserve">
          <source>Maxcode</source>
          <target state="translated">Maxcode</target>
        </trans-unit>
        <trans-unit id="d3dc367122aa7293e5afbfae55b89a3439308677" translate="yes" xml:space="preserve">
          <source>Maximum number of buckets.</source>
          <target state="translated">桶的最大数量。</target>
        </trans-unit>
        <trans-unit id="149a459f54b376ce18459ec98c8686438b039d4d" translate="yes" xml:space="preserve">
          <source>Maximum number of characters.</source>
          <target state="translated">最大字符数。</target>
        </trans-unit>
        <trans-unit id="40479cd9e5c70abfcec7f229a5343100ee1e982b" translate="yes" xml:space="preserve">
          <source>Maximum number of elements.</source>
          <target state="translated">元素的最大数量:</target>
        </trans-unit>
        <trans-unit id="74c9f71fbcac6b3790990dc6749cb13cfcb51bec" translate="yes" xml:space="preserve">
          <source>Maximum number of submatches.</source>
          <target state="translated">最大的子项数。</target>
        </trans-unit>
        <trans-unit id="c386253a5eac67332c4d54f0c89f27e31946d1fa" translate="yes" xml:space="preserve">
          <source>May also throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if additional memory required for internal data structures cannot be allocated.</source>
          <target state="translated">如果无法分配内部数据结构所需的其他内存，则可能还会抛出 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b12ceeda37fe6a0712324b0b075665414e87d72" translate="yes" xml:space="preserve">
          <source>May appear in the declaration of a non-static &lt;a href=&quot;data_members&quot;&gt;class members&lt;/a&gt; of non-reference non-const type:</source>
          <target state="translated">可能出现在非引用非const类型的非静态&lt;a href=&quot;data_members&quot;&gt;类成员&lt;/a&gt;的声明中：</target>
        </trans-unit>
        <trans-unit id="b266289267f1b69728db3ede6cf1835744b3fe8f" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://gcc.godbolt.org/z/6itUO1&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">可以编译为（&lt;a href=&quot;https://gcc.godbolt.org/z/6itUO1&quot;&gt;demo&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6c7f6ea88007fac3556846ed6f0bd902e3dfa12f" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://godbolt.org/z/QYZvsl&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">可以编译为（&lt;a href=&quot;https://godbolt.org/z/QYZvsl&quot;&gt;demo&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="70f7c1e91932b1a70687c4ebae101b3db1ba5098" translate="yes" xml:space="preserve">
          <source>May be compiled as (&lt;a href=&quot;https://godbolt.org/z/e2bC84&quot;&gt;demo&lt;/a&gt;).</source>
          <target state="translated">可以编译为（&lt;a href=&quot;https://godbolt.org/z/e2bC84&quot;&gt;demo&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="17b2c58fc2da61849ab101eba953459e4980b963" translate="yes" xml:space="preserve">
          <source>May only be applied to a &lt;a href=&quot;../statements#Expression_statements&quot;&gt;null statement&lt;/a&gt; to create a</source>
          <target state="translated">只能应用于&lt;a href=&quot;../statements#Expression_statements&quot;&gt;null语句&lt;/a&gt;以创建</target>
        </trans-unit>
        <trans-unit id="5b24b967e2517fdf19db9e1d07428b9424c7e88d" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;, may also propagate exceptions thrown by &lt;a href=&quot;../unique_lock/lock&quot;&gt;&lt;code&gt;lock.lock()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../unique_lock/unlock&quot;&gt;&lt;code&gt;lock.unlock()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">可能抛出 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; ，也可能传播&lt;a href=&quot;../unique_lock/lock&quot;&gt; &lt;code&gt;lock.lock()&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../unique_lock/unlock&quot;&gt; &lt;code&gt;lock.unlock()&lt;/code&gt; &lt;/a&gt;抛出的异常。</target>
        </trans-unit>
        <trans-unit id="82f82cbc23b684cfee57e315e7faddcf81a5e024" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;, may also propagate exceptions thrown by &lt;code&gt;lock.lock()&lt;/code&gt; or &lt;code&gt;lock.unlock()&lt;/code&gt;.</source>
          <target state="translated">可能抛出 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; ，也可能传播 &lt;code&gt;lock.lock()&lt;/code&gt; 或 &lt;code&gt;lock.unlock()&lt;/code&gt; 抛出的异常。</target>
        </trans-unit>
        <trans-unit id="2c170df4323127a54ff75977e5aea172641a66b1" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if an exception is thrown during output.</source>
          <target state="translated">如果在输出过程中引发异常，则可能引发 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9537e9cfb9ff89dce06742cc44b6f80d289fe969" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; on stream errors.</source>
          <target state="translated">可能在流错误上引发 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="74e16b22a77e8236ce676f4f2f124c10d8901a2b" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; constructor.</source>
          <target state="translated">可能从 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 构造函数中抛出 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cab3d4a6660b25cecf735f777424ba412487e934" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; from the &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::wstring&lt;/a&gt;&lt;/code&gt; constructor.</source>
          <target state="translated">可能从 &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::wstring&lt;/a&gt;&lt;/code&gt; 构造函数中抛出 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="962f83e06ea50e04d31c9f8437b97c5191adb569" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; from the the &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; constructor.</source>
          <target state="translated">可能从 &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 构造函数中抛出 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f18fce82e50be7509279d8759683168fd690cfd" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory allocation fails.</source>
          <target state="translated">如果内存分配失败，则可能抛出 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb0efb1fe6c128b1e051773ebaffa4603c205e9c" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可能会抛出 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3ba6e5262639e253495b627007f9b05da37e203d" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;exceptions()&amp;amp;badbit!=0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;exceptions()&amp;amp;badbit!=0&lt;/code&gt; ,可能抛出 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1533fcb442ebdf84b8b8136c017750a808b170e" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; in case of failure, if &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt; ，则在 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 的情况下可能引发std :: ios_base :: failure。</target>
        </trans-unit>
        <trans-unit id="aaa5c6b529feaa58739bd67ba50e2fb2001b4fb7" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可能会抛出 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88e82c73c9f5acd5341c52abeb46b516d79c0a4c" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if the system cannot allocate memory required to track reachable objects.</source>
          <target state="translated">如果系统无法分配跟踪可达对象所需的内存，则可能抛出 &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="50334b4e66ee014f5ce48f4fae49d65f13d9afac" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, the functions have no effect. If an exception is thrown during the construction of the array, already-initialized elements are destroyed in reverse order.(since C++20).</source>
          <target state="translated">可能抛出 &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;T&lt;/code&gt; 的构造函数抛出的任何异常。如果引发异常，则这些功能无效。如果在构造数组的过程中引发异常，则已初始化的元素将以相反的顺序销毁。（从C ++ 20开始）。</target>
        </trans-unit>
        <trans-unit id="fdfbbb46059a0d2dcd9098fe9a358cdc6c64a4b0" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, this function has no effect.</source>
          <target state="translated">可能抛出 &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;T&lt;/code&gt; 的构造函数抛出的任何异常。如果引发异常，则此功能无效。</target>
        </trans-unit>
        <trans-unit id="3490986d7e9db538d6473a2861a95a9c29b566de" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; when setting the badbit.</source>
          <target state="translated">设置Badbit时可能会引发 &lt;code&gt;&lt;a href=&quot;failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="55d3334b217863c436b19298f8ac48b6aa3046e7" translate="yes" xml:space="preserve">
          <source>May throw &lt;code&gt;&lt;a href=&quot;regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; to indicate an &lt;a href=&quot;error_type&quot;&gt;error condition&lt;/a&gt;.</source>
          <target state="translated">可能抛出 &lt;code&gt;&lt;a href=&quot;regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; 以指示&lt;a href=&quot;error_type&quot;&gt;错误情况&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a2aac967544933ac46c56aad850b11b876e778a6" translate="yes" xml:space="preserve">
          <source>May throw any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;, typically including &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可能抛出 &lt;code&gt;T&lt;/code&gt; 的构造函数引发的任何异常，通常包括 &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="295aca95b34c6da649adb7e8f83289b1503b3665" translate="yes" xml:space="preserve">
          <source>May throw any exceptions thrown by &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::allocate()&lt;/code&gt;, such as &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">可能抛出 &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;Allocator&amp;gt;::allocate()&lt;/code&gt; 抛出的任何异常，例如 &lt;code&gt;&lt;a href=&quot;../../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d89ff13f4c0ab3dc3033aad665ca0c8a7d4a1d6" translate="yes" xml:space="preserve">
          <source>May throw any exceptions thrown by the call to &lt;code&gt;allocate_object&lt;/code&gt; or the constructor of &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">可能引发对 &lt;code&gt;allocate_object&lt;/code&gt; 或 &lt;code&gt;U&lt;/code&gt; 的构造函数的调用引发的任何异常。</target>
        </trans-unit>
        <trans-unit id="cdf7c3ace6d1c50a2a552ed9dfc67f2851b5de5c" translate="yes" xml:space="preserve">
          <source>May throw any exceptions thrown by the call to &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt;.</source>
          <target state="translated">可能引发对 &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt; 的调用引发的任何异常。</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="014505538b8bc36d85ed833b2d3a182aea673970" translate="yes" xml:space="preserve">
          <source>Meaningless C headers</source>
          <target state="translated">毫无意义的C字头</target>
        </trans-unit>
        <trans-unit id="6853c98a6f4358bbfed1b3b9c81d308649299b0f" translate="yes" xml:space="preserve">
          <source>Member</source>
          <target state="translated">Member</target>
        </trans-unit>
        <trans-unit id="d880b0db33396f09e94ad458e37bf499710140d0" translate="yes" xml:space="preserve">
          <source>Member access</source>
          <target state="translated">成员访问</target>
        </trans-unit>
        <trans-unit id="b14800487e886a905875d25619be005b0bb88353" translate="yes" xml:space="preserve">
          <source>Member access does not affect visibility: names of private and privately-inherited members are visible and considered by overload resolution, implicit conversions to inaccessible base classes are still considered, etc. Member access check is the last step after any given language construct is interpreted. The intent of this rule is that replacing any &lt;code&gt;private&lt;/code&gt; with &lt;code&gt;public&lt;/code&gt; never alters the behavior of the program.</source>
          <target state="translated">成员访问不会影响可见性：私有和私有继承成员的名称是可见的，并通过重载解析加以考虑，仍然考虑对不可访问的基类的隐式转换，等等。成员访问检查是解释任何给定语言构造之后的最后一步。该规则的目的是用 &lt;code&gt;public&lt;/code&gt; 替代任何 &lt;code&gt;private&lt;/code&gt; 不会改变程序的行为。</target>
        </trans-unit>
        <trans-unit id="cf9ba14f65379b3cac2135b4415ee8ccd2ae4dbf" translate="yes" xml:space="preserve">
          <source>Member access operators</source>
          <target state="translated">成员访问运营商</target>
        </trans-unit>
        <trans-unit id="0dbd252428ccbd0d975da572dc34df0626898460" translate="yes" xml:space="preserve">
          <source>Member alias templates</source>
          <target state="translated">成员别名模板</target>
        </trans-unit>
        <trans-unit id="c618f84bc8f235803205b6351cb60f5fe7b25f6f" translate="yes" xml:space="preserve">
          <source>Member classes</source>
          <target state="translated">成员班级</target>
        </trans-unit>
        <trans-unit id="53b558837f61bee946a0dd1ce0e5906eb1fbb225" translate="yes" xml:space="preserve">
          <source>Member constant</source>
          <target state="translated">成员常数</target>
        </trans-unit>
        <trans-unit id="11178f71158bbe4d9b5ae241f21a139cf3506414" translate="yes" xml:space="preserve">
          <source>Member constants</source>
          <target state="translated">成员常数</target>
        </trans-unit>
        <trans-unit id="14511f9334df9fc1bdabba7170aa8468f6d02cfd" translate="yes" xml:space="preserve">
          <source>Member function</source>
          <target state="translated">成员职能</target>
        </trans-unit>
        <trans-unit id="e7d2a79cda830630ecf28efb73b93f5d64c726ea" translate="yes" xml:space="preserve">
          <source>Member function &lt;code&gt;operator()&lt;/code&gt;</source>
          <target state="translated">成员函数 &lt;code&gt;operator()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d34638b7646acd7bec35ca244b9f93a8a851424" translate="yes" xml:space="preserve">
          <source>Member function definition</source>
          <target state="translated">成员功能定义</target>
        </trans-unit>
        <trans-unit id="08497771fff890fda9af78587c591fe51ef91e55" translate="yes" xml:space="preserve">
          <source>Member function table</source>
          <target state="translated">成员功能表</target>
        </trans-unit>
        <trans-unit id="55bb0b5562e8411fcb96bbac022a9f6ac7ea4d1b" translate="yes" xml:space="preserve">
          <source>Member function templates</source>
          <target state="translated">成员函数模板</target>
        </trans-unit>
        <trans-unit id="b217f7514e4e69fd38aa7c54a821e91e41f619c3" translate="yes" xml:space="preserve">
          <source>Member functions</source>
          <target state="translated">成员职能</target>
        </trans-unit>
        <trans-unit id="980cb8724fcd1049e2076cf5101d5771adc84b3d" translate="yes" xml:space="preserve">
          <source>Member functions (including virtual member functions) can be called from member initializers, but the behavior is undefined if not all direct bases are initialized at that point.</source>
          <target state="translated">成员函数(包括虚拟成员函数)可以从成员初始化器中调用,但如果此时不是所有的直接基础都被初始化,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="de7182652ce370c94f7c684b95c200a783818dee" translate="yes" xml:space="preserve">
          <source>Member functions of a local class have no linkage</source>
          <target state="translated">本地类的成员函数没有关联性</target>
        </trans-unit>
        <trans-unit id="d5d511dbaf6e4bdbdd2335cea43d07a07ffcc20d" translate="yes" xml:space="preserve">
          <source>Member functions of a local class have to be defined entirely inside the class body</source>
          <target state="translated">本地类的成员函数必须完全定义在类体内部</target>
        </trans-unit>
        <trans-unit id="0656eb615cbde62fa5517f8cf8a8d9f0cd48715c" translate="yes" xml:space="preserve">
          <source>Member initialization</source>
          <target state="translated">成员初始化</target>
        </trans-unit>
        <trans-unit id="0b96269b9ecb978e0c0b9cfaf7fa59a36ac1af38" translate="yes" xml:space="preserve">
          <source>Member initializers and aggregates</source>
          <target state="translated">成员初始化器和集合体</target>
        </trans-unit>
        <trans-unit id="19bedac337c4148b66c642456a9ebdfc9f5a6c88" translate="yes" xml:space="preserve">
          <source>Member lifetime</source>
          <target state="translated">会员终身制</target>
        </trans-unit>
        <trans-unit id="d2fbdd7c0d6a0fe8e113aa296a28047ef253149d" translate="yes" xml:space="preserve">
          <source>Member name</source>
          <target state="translated">成员姓名</target>
        </trans-unit>
        <trans-unit id="74fa726e3f14b875e371e46176a78863344d0e2a" translate="yes" xml:space="preserve">
          <source>Member name lookup</source>
          <target state="translated">会员名称查询</target>
        </trans-unit>
        <trans-unit id="fde74c71ca6b1383761e00548de51dddc150302d" translate="yes" xml:space="preserve">
          <source>Member object</source>
          <target state="translated">成员对象</target>
        </trans-unit>
        <trans-unit id="d4037494affff8e1187b4614057e3d3856936fa0" translate="yes" xml:space="preserve">
          <source>Member objects</source>
          <target state="translated">成员对象</target>
        </trans-unit>
        <trans-unit id="7c1c4577121db570224d4e6d1b453b5fee33ebf0" translate="yes" xml:space="preserve">
          <source>Member of a class template outside of template</source>
          <target state="translated">模板外的类模板成员</target>
        </trans-unit>
        <trans-unit id="fcf850420e837ff3777a4510c350a70dc493bb17" translate="yes" xml:space="preserve">
          <source>Member of object</source>
          <target state="translated">对象的成员</target>
        </trans-unit>
        <trans-unit id="4300f5098631ebd1c4cf89699b5b4370fc4f18ee" translate="yes" xml:space="preserve">
          <source>Member or a member template may be nested within many enclosing class templates. In an explicit specialization for such a member, there's a &lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt; for every enclosing class template that is explicitly specialized.</source>
          <target state="translated">成员或成员模板可以嵌套在许多封闭的类模板中。在针对此类成员的显式专门化中，每个显式专门化的封闭类模板都有 &lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2fae0c7a45f97c1ebd785be8d844ad4e439ae3c" translate="yes" xml:space="preserve">
          <source>Member specification</source>
          <target state="translated">成员规格</target>
        </trans-unit>
        <trans-unit id="87b9dbba6959e8f157ca46a3351b964abfdee42b" translate="yes" xml:space="preserve">
          <source>Member templates</source>
          <target state="translated">成员模板</target>
        </trans-unit>
        <trans-unit id="d7ae56afa08fe3824c2cd242b7909d3e66c1ecc3" translate="yes" xml:space="preserve">
          <source>Member type</source>
          <target state="translated">成员类型</target>
        </trans-unit>
        <trans-unit id="55c0692816e400cc9f1e8bcd75e4a14f74352890" translate="yes" xml:space="preserve">
          <source>Member type &lt;code&gt;result_type&lt;/code&gt;</source>
          <target state="translated">成员类型 &lt;code&gt;result_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22c15de225ed427b7d10b0a6ea94574676a92b6e" translate="yes" xml:space="preserve">
          <source>Member types</source>
          <target state="translated">成员类型</target>
        </trans-unit>
        <trans-unit id="2a9c2afdee2bf076807c340c63de865c0262cc04" translate="yes" xml:space="preserve">
          <source>Member types and constants</source>
          <target state="translated">成员类型和常量</target>
        </trans-unit>
        <trans-unit id="8e74c7d99d2202da874a715a8b5fbfbc2b8cb4db" translate="yes" xml:space="preserve">
          <source>Member variable templates</source>
          <target state="translated">成员变量模板</target>
        </trans-unit>
        <trans-unit id="1cb449c1126609b4b41e1d87f65f0d7cd19b49b9" translate="yes" xml:space="preserve">
          <source>Members</source>
          <target state="translated">Members</target>
        </trans-unit>
        <trans-unit id="84f16231bc3f47eb66803d5355786879bfe2e29d" translate="yes" xml:space="preserve">
          <source>Members identical to std::optional</source>
          <target state="translated">与std::option相同的成员</target>
        </trans-unit>
        <trans-unit id="8441142a0e7debda365fc2602acee6048f15bbbe" translate="yes" xml:space="preserve">
          <source>Members of &lt;a href=&quot;union&quot;&gt;anonymous unions&lt;/a&gt; cannot be captured.</source>
          <target state="translated">无法捕获&lt;a href=&quot;union&quot;&gt;匿名工会的&lt;/a&gt;成员。</target>
        </trans-unit>
        <trans-unit id="02c67b9d74374d2cbad42e0e00560d1e26c88740" translate="yes" xml:space="preserve">
          <source>Members of an anonymous union are injected in the enclosing scope (and must not conflict with other names declared there).</source>
          <target state="translated">匿名联盟的成员会被注入到外层作用域中(并且不能与在那里声明的其他名称冲突)。</target>
        </trans-unit>
        <trans-unit id="b8b5ab3d00ea4a372f20b27f763c84738411ec47" translate="yes" xml:space="preserve">
          <source>Members of an inline namespace are treated as if they are members of the enclosing namespace in many situations (listed below). This property is transitive: if a namespace N contains an inline namespace M, which in turn contains an inline namespace O, then the members of O can be used as though they were members of M or N.</source>
          <target state="translated">在许多情况下,内联命名空间的成员被当作是外层命名空间的成员来对待(如下文所列)。这个属性是转折性的:如果一个命名空间N包含一个内联命名空间M,而M又包含一个内联命名空间O,那么O的成员可以被当作M或N的成员来使用。</target>
        </trans-unit>
        <trans-unit id="8586c2e60536f02fc22562f8abc3249a46b2b677" translate="yes" xml:space="preserve">
          <source>Members of array type cannot deduce their size from member initializers:</source>
          <target state="translated">数组类型的成员不能从成员初始化器推断其大小。</target>
        </trans-unit>
        <trans-unit id="7ab44845744014b08b5a156f5657ab462609baf4" translate="yes" xml:space="preserve">
          <source>Members of partial specializations</source>
          <target state="translated">部分专业的成员</target>
        </trans-unit>
        <trans-unit id="208131f2e00ae33985ce221300cd22605d845623" translate="yes" xml:space="preserve">
          <source>Members of partial specializations are not related to the members of the primary template.</source>
          <target state="translated">部分专业化的成员与主模板的成员没有关系。</target>
        </trans-unit>
        <trans-unit id="856df469166bb63fb5a5f500f0b2fd7e30149e12" translate="yes" xml:space="preserve">
          <source>Members of specializations</source>
          <target state="translated">专业成员</target>
        </trans-unit>
        <trans-unit id="177c4eb396c6113e03b1ec47971bf87273b4f749" translate="yes" xml:space="preserve">
          <source>Members of the current instantiation may be both dependent and non-dependent.</source>
          <target state="translated">当前实例的成员既可以是依赖性的,也可以是非依赖性的。</target>
        </trans-unit>
        <trans-unit id="9e686f3fba635d862001096dc688423be262661a" translate="yes" xml:space="preserve">
          <source>Members of unknown specialization are always dependent, and are looked up and bound at the point of instantiation as all dependent names (see above).</source>
          <target state="translated">未知特化的成员总是依附的,在实例化时,作为所有依附名被查找和绑定(见上文)。</target>
        </trans-unit>
        <trans-unit id="b61b70edbe3a97caa2ecb5ac100b7aca209a1cba" translate="yes" xml:space="preserve">
          <source>Memory allocation</source>
          <target state="translated">内存分配</target>
        </trans-unit>
        <trans-unit id="c839b2598611d3f060e76b276a742153340abc1c" translate="yes" xml:space="preserve">
          <source>Memory is released back to the upstream resource even if &lt;code&gt;deallocate&lt;/code&gt; has not been called for some of the allocated blocks.</source>
          <target state="translated">即使未为某些已分配的块调用 &lt;code&gt;deallocate&lt;/code&gt; 也会将内存释放回上游资源。</target>
        </trans-unit>
        <trans-unit id="bdea69651115220379a7626fdc86765943dcd523" translate="yes" xml:space="preserve">
          <source>Memory leaks</source>
          <target state="translated">记忆泄漏</target>
        </trans-unit>
        <trans-unit id="f8b9af79a08c4c809a8587ce76e5d96c65e611a2" translate="yes" xml:space="preserve">
          <source>Memory location</source>
          <target state="translated">存储器位置</target>
        </trans-unit>
        <trans-unit id="1c5536b98ab016fe61807564b4a34c80211a7613" translate="yes" xml:space="preserve">
          <source>Memory management</source>
          <target state="translated">内存管理</target>
        </trans-unit>
        <trans-unit id="ab97ff6f2dba5d3f1cd5aeb9b43d517c7ff39baa" translate="yes" xml:space="preserve">
          <source>Memory model</source>
          <target state="translated">记忆模型</target>
        </trans-unit>
        <trans-unit id="9c23e8bd787dd8370f724a94edc52271e09548bc" translate="yes" xml:space="preserve">
          <source>Memory model and data races</source>
          <target state="translated">内存模型和数据竞赛</target>
        </trans-unit>
        <trans-unit id="6b03cc66f3ec38d27d0315d16067b31e093e9aea" translate="yes" xml:space="preserve">
          <source>Memory order</source>
          <target state="translated">记忆顺序</target>
        </trans-unit>
        <trans-unit id="650d40654b9659dd0612cce810ff5fea98b79081" translate="yes" xml:space="preserve">
          <source>Memory resources</source>
          <target state="translated">内存资源</target>
        </trans-unit>
        <trans-unit id="4203c5ba750ba970dd9f023b43c81a0fd337c099" translate="yes" xml:space="preserve">
          <source>Memory resources implement memory allocation strategies that can be used by &lt;code&gt;&lt;a href=&quot;memory/polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">内存资源实现了可由 &lt;code&gt;&lt;a href=&quot;memory/polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt; 使用的内存分配策略。</target>
        </trans-unit>
        <trans-unit id="a26524a9138484663e1a18b861e087f36fe4484a" translate="yes" xml:space="preserve">
          <source>Memory synchronization ordering</source>
          <target state="translated">内存同步排序</target>
        </trans-unit>
        <trans-unit id="813e99320a4c03b9ad6cec6f1e925a0b781749db" translate="yes" xml:space="preserve">
          <source>Mergeable</source>
          <target state="translated">Mergeable</target>
        </trans-unit>
        <trans-unit id="e8960ff445c6c6fffe8acbabe2366e4cbf4abc97" translate="yes" xml:space="preserve">
          <source>Merges two consecutive sorted ranges &lt;code&gt;[first, middle)&lt;/code&gt; and &lt;code&gt;[middle, last)&lt;/code&gt; into one sorted range &lt;code&gt;[first, last)&lt;/code&gt;. For equivalent elements in the original two ranges, the elements from the first range (preserving their original order) precede the elements from the second range (preserving their original order).</source>
          <target state="translated">将两个连续的排序范围 &lt;code&gt;[first, middle)&lt;/code&gt; 和 &lt;code&gt;[middle, last)&lt;/code&gt; 合并为一个排序范围 &lt;code&gt;[first, last)&lt;/code&gt; 。对于原始两个范围中的等效元素，第一个范围中的元素（保留其原始顺序）在第二个范围中的元素（保留其原始顺序）之前。</target>
        </trans-unit>
        <trans-unit id="348e4e60780310e575bfb01a962f7cd5abae550b" translate="yes" xml:space="preserve">
          <source>Merges two sorted lists into one. The lists should be sorted into ascending order.</source>
          <target state="translated">将两个排序的列表合并为一个。列表应按升序排列。</target>
        </trans-unit>
        <trans-unit id="62e4dd6599b3076f4c7e24d143d22cfe633e9e61" translate="yes" xml:space="preserve">
          <source>Merges two sorted ranges &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;[first2, last2)&lt;/code&gt; into one sorted range beginning at &lt;code&gt;d_first&lt;/code&gt;.</source>
          <target state="translated">将两个排序范围 &lt;code&gt;[first1, last1)&lt;/code&gt; 和 &lt;code&gt;[first2, last2)&lt;/code&gt; 合并到一个以 &lt;code&gt;d_first&lt;/code&gt; 开始的排序范围。</target>
        </trans-unit>
        <trans-unit id="be990907531784c554a9a73c087e598fb1ce6368" translate="yes" xml:space="preserve">
          <source>Message too large</source>
          <target state="translated">信息太大</target>
        </trans-unit>
        <trans-unit id="461fdb47a2520c8a10c99484faf4d44d448c8df5" translate="yes" xml:space="preserve">
          <source>Metafunctions and detection idiom</source>
          <target state="translated">元功能与检测成语</target>
        </trans-unit>
        <trans-unit id="07195d88dee403459dfced037630ce1c768e14de" translate="yes" xml:space="preserve">
          <source>Metaprogramming and type traits</source>
          <target state="translated">元编程和类型特征</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="932b125ec81f14231f7250288b48b92b461a8de5" translate="yes" xml:space="preserve">
          <source>Methods and operators</source>
          <target state="translated">方法和操作者</target>
        </trans-unit>
        <trans-unit id="67dd111ccc6d0d86efc4c55e49ca364b9cb96922" translate="yes" xml:space="preserve">
          <source>Microsoft Visual Studio stores just those three members.</source>
          <target state="translated">Microsoft Visual Studio存储的只是这三个成员。</target>
        </trans-unit>
        <trans-unit id="47dddb5186287e21994356577aa0866b4c1d8ea3" translate="yes" xml:space="preserve">
          <source>Microsoft also extends the specification of fflush by defining its effects on an input stream: in Visual Studio 2013 and prior, it &lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9yky46tz(v=vs.120)&quot;&gt;discarded the input buffer&lt;/a&gt;, in Visual Studio 2015 and newer, it &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot;&gt;has no effect, buffers are retained&lt;/a&gt;.</source>
          <target state="translated">微软还通过定义fflush对输入流的影响来扩展fflush的规范：在Visual Studio 2013 及更高版本中，它&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/visualstudio/visual-studio-2013/9yky46tz(v=vs.120)&quot;&gt;丢弃了输入缓冲区&lt;/a&gt;，在Visual Studio 2015及更高版本中，它&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/9yky46tz.aspx&quot;&gt;没有效果，保留了缓冲区&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b1e6ca7ba44f07ef77ced3289ef9027ae3985768" translate="yes" xml:space="preserve">
          <source>Minimal incomplete type support for standard containers</source>
          <target state="translated">对标准容器的最小不完全类型支持</target>
        </trans-unit>
        <trans-unit id="039230108efa19823a7b4883634eb496fa5690f9" translate="yes" xml:space="preserve">
          <source>Minimum/maximum operations</source>
          <target state="translated">最低/最高业务量</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="9f352649528dbc4b941a3c142ba8ef1c7ced2ff5" translate="yes" xml:space="preserve">
          <source>Miscellaneous algorithms and math</source>
          <target state="translated">杂项算法和数学</target>
        </trans-unit>
        <trans-unit id="7d1b5fe97a66d6423d5658882ed141e544353f5f" translate="yes" xml:space="preserve">
          <source>Miscellaneous transformations</source>
          <target state="translated">杂项转换</target>
        </trans-unit>
        <trans-unit id="acace02a8a5c263c4d1a277ad3914f44e1003ded" translate="yes" xml:space="preserve">
          <source>Miscellanous</source>
          <target state="translated">Miscellanous</target>
        </trans-unit>
        <trans-unit id="b2168739b0a770dbc449ab787b7f9985648b3334" translate="yes" xml:space="preserve">
          <source>Mixed categories</source>
          <target state="translated">混合类别</target>
        </trans-unit>
        <trans-unit id="781cc7f1a888cc264c3daec6aa247cc3fa4f8d16" translate="yes" xml:space="preserve">
          <source>Mixing &lt;code&gt;auto&lt;/code&gt; variables and functions in one declaration, as in &lt;code&gt;auto f() -&amp;gt; int, i = 0;&lt;/code&gt; is not allowed.</source>
          <target state="translated">在一个声明中混合 &lt;code&gt;auto&lt;/code&gt; 变量和函数，如 &lt;code&gt;auto f() -&amp;gt; int, i = 0;&lt;/code&gt; 不被允许。</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="c8d28082b4fc6c7b86480f164e10796d9ee93fa2" translate="yes" xml:space="preserve">
          <source>Modification of the element denoted by this iterator is permitted, but results in undefined behavior if the resulting value does not satisfy the filter's predicate.</source>
          <target state="translated">允许修改这个迭代器所表示的元素,但如果结果的值不满足过滤器的谓词,则会导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="fde60483a8643008b46b560bb3120711a8d791b9" translate="yes" xml:space="preserve">
          <source>Modification order</source>
          <target state="translated">修改令</target>
        </trans-unit>
        <trans-unit id="f7d91c2034d3989f0f9d751cdc240eeaa5a1f0bd" translate="yes" xml:space="preserve">
          <source>Modified first or last element</source>
          <target state="translated">修改后的第一个或最后一个元素</target>
        </trans-unit>
        <trans-unit id="5ae95629e2c8d41b6f08c30afaaf87f67a8aeb67" translate="yes" xml:space="preserve">
          <source>Modified middle only</source>
          <target state="translated">仅有修改后的中间部分</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="4ab3cf9c369166302907228f36238db8a9f5670f" translate="yes" xml:space="preserve">
          <source>Modifies the default formatting for floating-point input/output.</source>
          <target state="translated">修改浮点输入/输出的默认格式。</target>
        </trans-unit>
        <trans-unit id="15f0dab11aac15b6b8ac3cdd786afb259b8c6d63" translate="yes" xml:space="preserve">
          <source>Modifies the default numeric base for integer I/O.</source>
          <target state="translated">修改整数I/O的默认数基。</target>
        </trans-unit>
        <trans-unit id="e948b2b964fb2481f64aff925d09ed89d0d5aac5" translate="yes" xml:space="preserve">
          <source>Modifies the default positioning of the fill characters. &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; apply to any output, &lt;code&gt;internal&lt;/code&gt; applies to integer, floating-point, and monetary output. Has no effect on input.</source>
          <target state="translated">修改填充字符的默认位置。 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 适用于任何输出， &lt;code&gt;internal&lt;/code&gt; 适用于整数，浮点和货币输出。对输入没有影响。</target>
        </trans-unit>
        <trans-unit id="4f0803b14853f0ca1c462262bd06651312d6fd2a" translate="yes" xml:space="preserve">
          <source>Modifies the integer type. Can be mixed in any order. Only one of each group can be present in type name.</source>
          <target state="translated">修改整数类型。可以以任何顺序混合。类型名中每组只能有一个。</target>
        </trans-unit>
        <trans-unit id="d554ea1e6c13dd8a9b9dcc293f7edfd4d7e0bab2" translate="yes" xml:space="preserve">
          <source>Modifies the point in time &lt;code&gt;*this&lt;/code&gt; represents by one tick of the &lt;code&gt;duration&lt;/code&gt;.</source>
          <target state="translated">修改时间点 &lt;code&gt;*this&lt;/code&gt; 表示 &lt;code&gt;duration&lt;/code&gt; 一勾。</target>
        </trans-unit>
        <trans-unit id="ac257bedb96e8a5ed9f2d761616b185ecd321a9f" translate="yes" xml:space="preserve">
          <source>Modifies the time point &lt;code&gt;*this&lt;/code&gt; represents by the duration &lt;code&gt;dy&lt;/code&gt; or &lt;code&gt;dm&lt;/code&gt;.</source>
          <target state="translated">修改时间点 &lt;code&gt;*this&lt;/code&gt; 由持续时间 &lt;code&gt;dy&lt;/code&gt; 或 &lt;code&gt;dm&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="0109c0f778cd7e5d5f58cdb0bef696d2ed4bfbeb" translate="yes" xml:space="preserve">
          <source>Modifies the time point by the given duration.</source>
          <target state="translated">按给定的持续时间修改时间点。</target>
        </trans-unit>
        <trans-unit id="b99643bd9f016aabf23ffef5df0d85745e624465" translate="yes" xml:space="preserve">
          <source>Modifying sequence operations</source>
          <target state="translated">修改序列操作</target>
        </trans-unit>
        <trans-unit id="2b3cc44d73da07886ee8baef1ee867321f0ada02" translate="yes" xml:space="preserve">
          <source>Modifying the object references through the returned pointer is undefined behavior.</source>
          <target state="translated">通过返回的指针修改对象引用是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="ebfc8aea76355cffda7dc26e5f6ffed8b15e2998" translate="yes" xml:space="preserve">
          <source>Modifying the string returned by &lt;code&gt;getenv&lt;/code&gt; invokes undefined behavior.</source>
          <target state="translated">修改 &lt;code&gt;getenv&lt;/code&gt; 返回的字符串会调用未定义的行为。</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="5c27456bde155168271b9f0d0a03593e3d004434" translate="yes" xml:space="preserve">
          <source>Modules (since C++20)</source>
          <target state="translated">模块(从C++20开始)</target>
        </trans-unit>
        <trans-unit id="87aa2b5a478fd2bc39c2606c02ad3374b1b33a57" translate="yes" xml:space="preserve">
          <source>Modules are orthogonal to &lt;a href=&quot;namespace&quot;&gt;namespaces&lt;/a&gt;.</source>
          <target state="translated">模块与&lt;a href=&quot;namespace&quot;&gt;名称空间&lt;/a&gt;正交。</target>
        </trans-unit>
        <trans-unit id="15b644db7c27b8824e56787512daf5e002e08b35" translate="yes" xml:space="preserve">
          <source>Modules help divide large amounts of code into logical parts.</source>
          <target state="translated">模块有助于将大量的代码划分为逻辑部分。</target>
        </trans-unit>
        <trans-unit id="ba486ce8a0bc9ff868847c4d17e3966a68af4067" translate="yes" xml:space="preserve">
          <source>Monetary numeric formatting parameters</source>
          <target state="translated">货币数字格式参数</target>
        </trans-unit>
        <trans-unit id="082bc378cd60e17a38d99898b21955299c5b60c8" translate="yes" xml:space="preserve">
          <source>Month</source>
          <target state="translated">Month</target>
        </trans-unit>
        <trans-unit id="8a88993f3238117d849d456cb7e4e84ee89d728a" translate="yes" xml:space="preserve">
          <source>Month, day, year (american) order</source>
          <target state="translated">月、日、年(美式)订单</target>
        </trans-unit>
        <trans-unit id="d08db9b01ebe6924d7a1bf996c9b0ed0b4fab126" translate="yes" xml:space="preserve">
          <source>More formally, &lt;code&gt;nth_element&lt;/code&gt; partially sorts the range &lt;code&gt;[first, last)&lt;/code&gt; in ascending order so that the condition &lt;code&gt;!(*j &amp;lt; *i)&lt;/code&gt; (for (1-2), or &lt;code&gt;comp(*j, *i) == false&lt;/code&gt; for (3-4)) is met for any &lt;code&gt;i&lt;/code&gt; in the range &lt;code&gt;[first, nth)&lt;/code&gt; and for any &lt;code&gt;j&lt;/code&gt; in the range &lt;code&gt;[nth, last)&lt;/code&gt;. The element placed in the &lt;code&gt;nth&lt;/code&gt; position is exactly the element that would occur in this position if the range was fully sorted.</source>
          <target state="translated">更正式地讲， &lt;code&gt;nth_element&lt;/code&gt; 对范围 &lt;code&gt;[first, last)&lt;/code&gt; 进行升序排序，以便条件 &lt;code&gt;!(*j &amp;lt; *i)&lt;/code&gt; （对于（1-2），或者 &lt;code&gt;comp(*j, *i) == false&lt;/code&gt; 对于（ 3-4））被满足任何 &lt;code&gt;i&lt;/code&gt; 在范围 &lt;code&gt;[first, nth)&lt;/code&gt; 和任何 &lt;code&gt;j&lt;/code&gt; 在范围 &lt;code&gt;[nth, last)&lt;/code&gt; 。如果范围已完全排序，则位于 &lt;code&gt;nth&lt;/code&gt; 位置的元素正是在该位置出现的元素。</target>
        </trans-unit>
        <trans-unit id="8ad85aba1e03e90f4ea308da91cb434da83f1201" translate="yes" xml:space="preserve">
          <source>More generally, a declaration that appears in any namespace scope and introduces a name using an unqualified identifier always introduces a member into the namespace it's in and not to any other namespace. The exceptions are explicit instantiations and explicit specializations of a primary template that is defined in an inline namespace: because they do not introduce a new name, they may use unqualified-id in an enclosing namespace.</source>
          <target state="translated">更一般地说,出现在任何命名空间作用域中并使用非限定标识符引入名称的声明,总是将一个成员引入它所在的命名空间,而不是引入任何其他命名空间。例外的情况是在内联命名空间中定义的主模板的显式实例化和显式特殊化:因为它们没有引入一个新的名称,所以它们可以在包围的命名空间中使用非限定标识符。</target>
        </trans-unit>
        <trans-unit id="aced5c6bdae8930320b0a84e8806de43ea20de7e" translate="yes" xml:space="preserve">
          <source>More importantly, when a function has both rvalue reference and lvalue reference &lt;a href=&quot;overload_resolution&quot;&gt;overloads&lt;/a&gt;, the rvalue reference overload binds to rvalues (including both prvalues and xvalues), while the lvalue reference overload binds to lvalues:</source>
          <target state="translated">更重要的是，当一个函数同时具有右值引用和左值引用&lt;a href=&quot;overload_resolution&quot;&gt;重载时&lt;/a&gt;，右值引用重载绑定到右值（包括prvalue和xvalues），而左值引用重载绑定到左值：</target>
        </trans-unit>
        <trans-unit id="042cb75d428b075638d2d6b2981b93fb7100eec4" translate="yes" xml:space="preserve">
          <source>More precisely,</source>
          <target state="translated">更准确地说:</target>
        </trans-unit>
        <trans-unit id="12d2d8c92f9d4fd32f5f1106d05e584341d60749" translate="yes" xml:space="preserve">
          <source>More precisely, if &lt;code&gt;T&lt;/code&gt; is an object type, then &lt;code&gt;CopyConstructible&amp;lt;T&amp;gt;&lt;/code&gt; is satisfied only if given.</source>
          <target state="translated">更准确地说，如果 &lt;code&gt;T&lt;/code&gt; 是对象类型，则仅在给定条件下才满足 &lt;code&gt;CopyConstructible&amp;lt;T&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="390ebcb02784fc921ce7255ea43ab7b5c0c22766" translate="yes" xml:space="preserve">
          <source>More precisely, if &lt;code&gt;T&lt;/code&gt; is an object type, then &lt;code&gt;MoveConstructible&amp;lt;T&amp;gt;&lt;/code&gt; is satisfied only if given.</source>
          <target state="translated">更准确地说，如果 &lt;code&gt;T&lt;/code&gt; 是对象类型，则仅在给定 &lt;code&gt;MoveConstructible&amp;lt;T&amp;gt;&lt;/code&gt; 情况下才满足。</target>
        </trans-unit>
        <trans-unit id="abf4cfe7b468de981e652ab471007fe1cf184911" translate="yes" xml:space="preserve">
          <source>Moreover, if a class is</source>
          <target state="translated">此外,如果一个类是</target>
        </trans-unit>
        <trans-unit id="155edc9b15c11dc21e1b4548edbad4e1215c059f" translate="yes" xml:space="preserve">
          <source>Moreover, the specialization has to be more specialized than the primary template.</source>
          <target state="translated">而且,专业性要比主模板更专业。</target>
        </trans-unit>
        <trans-unit id="efb9a37b6f75f2498f990faf5ad9f0869a407c15" translate="yes" xml:space="preserve">
          <source>Most algorithms have overloads that accept execution policies. The standard library algorithms support several &lt;a href=&quot;algorithm/execution_policy_tag_t&quot;&gt;execution policies&lt;/a&gt;, and the library provides corresponding execution policy types and objects. Users may select an execution policy statically by invoking a parallel algorithm with an &lt;a href=&quot;algorithm/execution_policy_tag&quot;&gt;execution policy object&lt;/a&gt; of the corresponding type.</source>
          <target state="translated">大多数算法都有接受执行策略的重载。标准库算法支持几种&lt;a href=&quot;algorithm/execution_policy_tag_t&quot;&gt;执行策略&lt;/a&gt;，并且库提供了相应的执行策略类型和对象。用户可以通过调用具有相应类型的&lt;a href=&quot;algorithm/execution_policy_tag&quot;&gt;执行策略对象&lt;/a&gt;的并行算法来静态选择执行策略。</target>
        </trans-unit>
        <trans-unit id="cc6a96c2bf79396b900217be397fde454fb98507" translate="yes" xml:space="preserve">
          <source>Most concepts in the standard library impose both syntactic and semantic requirements. In general, only the syntactic requirements can be checked by the compiler. If a semantic requirement is not met at the point of use, the program is ill-formed, no diagnostic required.</source>
          <target state="translated">标准库中的大多数概念都提出了句法和语义的要求。一般情况下,编译器只能检查语法要求。如果在使用时不符合语义要求,则程序不合格,不需要诊断。</target>
        </trans-unit>
        <trans-unit id="781816a1d277bbc9eb1433baedd102171fdafd77" translate="yes" xml:space="preserve">
          <source>Most containers have at least several member functions in common, and share functionalities. Which container is the best for the particular application depends not only on the offered functionality, but also on its efficiency for different workloads.</source>
          <target state="translated">大多数容器至少有几个共同的成员功能,并且共享功能。哪种容器最适合特定的应用,不仅取决于所提供的功能,还取决于它对不同工作负载的效率。</target>
        </trans-unit>
        <trans-unit id="e62a8c15144afd6bef7aa39651c138fe6e1aae25" translate="yes" xml:space="preserve">
          <source>Most multibyte character encodings use single-byte codes to represent the characters from the ASCII character set. This function may be used to convert such characters to &lt;code&gt;wchar_t&lt;/code&gt;.</source>
          <target state="translated">大多数多字节字符编码使用单字节代码表示ASCII字符集中的字符。此函数可用于将此类字符转换为 &lt;code&gt;wchar_t&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c598cbf439c8837b1ca206b16302fc6a8e671f8" translate="yes" xml:space="preserve">
          <source>Most of the classes are templated, so they can be adapted to any basic character type. Separate typedefs are provided for the most common basic character types (&lt;code&gt;char&lt;/code&gt; and &lt;code&gt;wchar_t&lt;/code&gt;). The classes are organized into the following hierarchy:</source>
          <target state="translated">大多数类都是模板化的，因此它们可以适应任何基本字符类型。为最常见的基本字符类型（ &lt;code&gt;char&lt;/code&gt; 和 &lt;code&gt;wchar_t&lt;/code&gt; ）提供了单独的typedef 。这些类分为以下层次结构：</target>
        </trans-unit>
        <trans-unit id="096ace82e91d90831e1c4645b3d45c6185c05537" translate="yes" xml:space="preserve">
          <source>Most statements in a typical C++ program are expression statements, such as assignments or function calls.</source>
          <target state="translated">在典型的C++程序中,大多数语句都是表达式语句,如赋值或函数调用。</target>
        </trans-unit>
        <trans-unit id="a2333535991c67ef2e86e131a8535fb756804d7f" translate="yes" xml:space="preserve">
          <source>Movable</source>
          <target state="translated">Movable</target>
        </trans-unit>
        <trans-unit id="0a9ed9691d6eeb1d4822ae73e0c5eadefaad241c" translate="yes" xml:space="preserve">
          <source>Move assignment operator</source>
          <target state="translated">移动分配操作员</target>
        </trans-unit>
        <trans-unit id="47bc76102bfdfe08b85837682799b53a220e67af" translate="yes" xml:space="preserve">
          <source>Move assignment operator. Replaces the contents with those of &lt;code&gt;other&lt;/code&gt; using move semantics.</source>
          <target state="translated">移动分配运算符。使用移动语义将内容替换为 &lt;code&gt;other&lt;/code&gt; 内容。</target>
        </trans-unit>
        <trans-unit id="9faeffa8862f7a244a0700c0596d5af7fc217adc" translate="yes" xml:space="preserve">
          <source>Move assignment operators typically &quot;steal&quot; the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.), rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, move-assigning from a &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or from a &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; may result in the argument being left empty. This is not, however, a guarantee. A move assignment is less, not more restrictively defined than ordinary assignment; where ordinary assignment must leave two copies of data at completion, move assignment is required to leave only one.</source>
          <target state="translated">移动分配运算符通常会&amp;ldquo;窃取&amp;rdquo;参数所拥有的资源（例如，指向动态分配的对象的指针，文件描述符，TCP套接字，I / O流，运行线程等），而不是对其进行复制并留下参数处于某些有效但不确定的状态。例如，从 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 或从 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 移动分配可能导致自变量为空。但是，这不是保证。与普通分配相比，移动分配的定义要少，但没有更多限制。普通分配必须在完成时保留两个数据副本，而移动分配只需要保留一个数据副本。</target>
        </trans-unit>
        <trans-unit id="389a7c6fdc797b8f1865d27d1759a2d438b0f975" translate="yes" xml:space="preserve">
          <source>Move assigns the file stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">移动受让人文件流 &lt;code&gt;other&lt;/code&gt; ，以 &lt;code&gt;*this&lt;/code&gt; ，有效地移动，分配两个 &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; 基类和相关 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24f428bf7dd6f1e0c847ba71b49720a8f401e750" translate="yes" xml:space="preserve">
          <source>Move assigns the file stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">移动受让人文件流 &lt;code&gt;other&lt;/code&gt; ，以 &lt;code&gt;*this&lt;/code&gt; ，有效地移动，分配两个 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 基类和相关 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="16356f1d24da83c00f7fba21a216c445c97ce389" translate="yes" xml:space="preserve">
          <source>Move assigns the file stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">移动受让人文件流 &lt;code&gt;other&lt;/code&gt; ，以 &lt;code&gt;*this&lt;/code&gt; ，有效地移动，分配两个 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 基类和相关 &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33ed75bd9ae7d7e710f7cb59e2701e5a3f320cb2" translate="yes" xml:space="preserve">
          <source>Move assigns the string stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move将 &lt;code&gt;other&lt;/code&gt; 字符串流分配给 &lt;code&gt;*this&lt;/code&gt; ，从而有效地对 &lt;code&gt;&lt;a href=&quot;../basic_iostream&quot;&gt;std::basic_iostream&lt;/a&gt;&lt;/code&gt; 基类和关联的 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 移动分配。</target>
        </trans-unit>
        <trans-unit id="8b304cb7e35b160ac11b6e6da6fcb29cbf8bd2ea" translate="yes" xml:space="preserve">
          <source>Move assigns the string stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move将 &lt;code&gt;other&lt;/code&gt; 字符串流分配给 &lt;code&gt;*this&lt;/code&gt; ，从而有效地移动分配了 &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; 基类和关联的 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49accf919a08e0856fd5c2205f087017e46e4554" translate="yes" xml:space="preserve">
          <source>Move assigns the string stream &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;, effectively move-assigning both the &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; base class and the associated &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Move将 &lt;code&gt;other&lt;/code&gt; 字符串流分配给 &lt;code&gt;*this&lt;/code&gt; ，从而有效地对 &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; 基类和关联的 &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; 移动分配。</target>
        </trans-unit>
        <trans-unit id="f3459363ce95b7b8d213432c0b3912511b7bb422" translate="yes" xml:space="preserve">
          <source>Move constructor</source>
          <target state="translated">移动构造函数</target>
        </trans-unit>
        <trans-unit id="dabcb34f032395075663b5ab1b4ca93fa1b421af" translate="yes" xml:space="preserve">
          <source>Move constructor of &lt;code&gt;A&lt;/code&gt; must not throw exceptions</source>
          <target state="translated">移动 &lt;code&gt;A&lt;/code&gt; 的构造函数不得引发异常</target>
        </trans-unit>
        <trans-unit id="76c87719ef4631d051ec31847319db90f2a38c3c" translate="yes" xml:space="preserve">
          <source>Move constructors</source>
          <target state="translated">移动构造器</target>
        </trans-unit>
        <trans-unit id="2a326707754a17c67859bb0d4a68df79e51ee6cb" translate="yes" xml:space="preserve">
          <source>Move constructors are usually noexcept, since otherwise they are unusable in any code that provides strong exception guarantee.</source>
          <target state="translated">Move构造函数通常是noexcept,因为否则它们在任何提供强异常保证的代码中都无法使用。</target>
        </trans-unit>
        <trans-unit id="81267231da879e100dbc03825b8c3e0a2957c4a3" translate="yes" xml:space="preserve">
          <source>Move constructors obtain their instances of allocators by move-constructing from the allocator belonging to the old container.</source>
          <target state="translated">移动构造器通过从属于旧容器的分配器中移动构造获得它们的分配器实例。</target>
        </trans-unit>
        <trans-unit id="137fb2f17f31808cc157fa054ef5ad4347edeebc" translate="yes" xml:space="preserve">
          <source>Move constructors typically &quot;steal&quot; the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.) rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, moving from a &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or from a &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; may result in the argument being left empty. However, this behavior should not be relied upon. For some types, such as &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, the moved-from state is fully specified.</source>
          <target state="translated">移动构造函数通常&amp;ldquo;窃取&amp;rdquo;参数所拥有的资源（例如，指向动态分配对象的指针，文件描述符，TCP套接字，I / O流，运行线程等），而不是对其进行复制，而将参数保留在一些有效但不确定的状态。例如，从 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; 或从 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 可能导致参数保留为空。但是，不应依赖此行为。对于某些类型，例如 &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; ，完全指定了from-from状态。</target>
        </trans-unit>
        <trans-unit id="a87e8b5e582f2bbe391df33ee67064ce26cb64b8" translate="yes" xml:space="preserve">
          <source>Move semantics make it possible to safely transfer resource ownership between objects, across scopes, and in and out of threads, while maintaining resource safety.</source>
          <target state="translated">Move语义使得在维护资源安全的同时,可以在对象之间、跨作用域、线程内外安全地转移资源所有权。</target>
        </trans-unit>
        <trans-unit id="539161ece173c055968a1a1de35756020b668502" translate="yes" xml:space="preserve">
          <source>Move-assignment will replace the allocator only if &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">仅当 &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_move_assignment::value&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时,移动分配才会替换分配器</target>
        </trans-unit>
        <trans-unit id="2a2b02d69358e93089fbaa89a49b928011b4e236" translate="yes" xml:space="preserve">
          <source>Move-assigns a synchronized output stream:</source>
          <target state="translated">移动-指定一个同步的输出流。</target>
        </trans-unit>
        <trans-unit id="729a0dfe5f81eedccb7e27b2fac2b5add97556cb" translate="yes" xml:space="preserve">
          <source>MoveAssignable</source>
          <target state="translated">MoveAssignable</target>
        </trans-unit>
        <trans-unit id="502c9efbaad373888b5ccbb225e0b2b8dcc695c1" translate="yes" xml:space="preserve">
          <source>MoveConstructible</source>
          <target state="translated">MoveConstructible</target>
        </trans-unit>
        <trans-unit id="47b28d1ca8cc2963e3c114ddac02f3738d7266e5" translate="yes" xml:space="preserve">
          <source>MoveInsertable</source>
          <target state="translated">MoveInsertable</target>
        </trans-unit>
        <trans-unit id="0cba8c550dfeac021edea6a142972a2b3c4254ac" translate="yes" xml:space="preserve">
          <source>Moves elements from another &lt;code&gt;forward_list&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">将元素从另一个 &lt;code&gt;forward_list&lt;/code&gt; 移到 &lt;code&gt;*this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f642e2f2760b86f5ae81c771704418f0a85fea71" translate="yes" xml:space="preserve">
          <source>Moves or renames the filesystem object identified by &lt;code&gt;old_p&lt;/code&gt; to &lt;code&gt;new_p&lt;/code&gt; as if by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html&quot;&gt;rename&lt;/a&gt;:</source>
          <target state="translated">将由 &lt;code&gt;old_p&lt;/code&gt; 标识的文件系统对象移动或重命名为 &lt;code&gt;new_p&lt;/code&gt; ，就像通过POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html&quot;&gt;重命名&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f8c4f952db4952b742d95751551e39d3d9452537" translate="yes" xml:space="preserve">
          <source>Moves or renames the filesystem object identified by &lt;code&gt;old_p&lt;/code&gt; to &lt;code&gt;new_p&lt;/code&gt; as if by the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/rename.html&quot;&gt;rename&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78f6470d9b55060017967677bfa10f722a11ccd6" translate="yes" xml:space="preserve">
          <source>Moves the elements from the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range ending at &lt;code&gt;d_last&lt;/code&gt;. The elements are moved in reverse order (the last element is moved first), but their relative order is preserved.</source>
          <target state="translated">将元素从 &lt;code&gt;[first, last)&lt;/code&gt; 范围移动到另一个以 &lt;code&gt;d_last&lt;/code&gt; 结尾的范围。元素以相反的顺序移动（最后一个元素首先移动），但是保留了它们的相对顺序。</target>
        </trans-unit>
        <trans-unit id="502b5aeda54563820fc7b31c565eaaa6bcbf6e12" translate="yes" xml:space="preserve">
          <source>Moves the end of the view back by &lt;code&gt;n&lt;/code&gt; characters.</source>
          <target state="translated">将视图的末尾移动 &lt;code&gt;n&lt;/code&gt; 个字符。</target>
        </trans-unit>
        <trans-unit id="e55336fdb98f11cedfd0e48efbdbb786db1d30e0" translate="yes" xml:space="preserve">
          <source>Moves the file position indicator to the beginning of the given file stream.</source>
          <target state="translated">将文件位置指示器移动到给定文件流的开头。</target>
        </trans-unit>
        <trans-unit id="2fd746e8e68c6c51da4d2e5d3dd279e473ac3ff3" translate="yes" xml:space="preserve">
          <source>Moves the iterator one level up in the directory hierarchy. Invalidates all copies of the previous value of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">将迭代器在目录层次结构中上移一级。使 &lt;code&gt;*this&lt;/code&gt; 先前值的所有副本无效。</target>
        </trans-unit>
        <trans-unit id="725b5a475515852bdc56678fa33e316b36e459ef" translate="yes" xml:space="preserve">
          <source>Moves the start of the view forward by &lt;code&gt;n&lt;/code&gt; characters.</source>
          <target state="translated">将视图的开始向前移动 &lt;code&gt;n&lt;/code&gt; 个字符。</target>
        </trans-unit>
        <trans-unit id="7135dfbadfa84a70be0103c96edea84447561b3b" translate="yes" xml:space="preserve">
          <source>Multibyte/wide character conversion</source>
          <target state="translated">多字节/宽字符转换</target>
        </trans-unit>
        <trans-unit id="737f5043d52ad9a5bf99e386e8ced8ff5c737ec0" translate="yes" xml:space="preserve">
          <source>Multibyte/wide character conversions</source>
          <target state="translated">多字节/宽字符转换</target>
        </trans-unit>
        <trans-unit id="b816bfbe5973e3f1a932359a517a19fd4cc2d3aa" translate="yes" xml:space="preserve">
          <source>Multicharacter literals were inherited by C from the B programming language. Although not specified by the C or C++ standard, compilers implement multicharacter literals as specified in B: the values of each char in the literal initialize successive bytes of the resulting integer, in big-endian zero-padded right-adjusted order, e.g. the value of &lt;code&gt;'\1'&lt;/code&gt; is &lt;code&gt;0x00000001&lt;/code&gt; and the value of &lt;code&gt;'\1\2\3\4'&lt;/code&gt; is &lt;code&gt;0x01020304&lt;/code&gt;.</source>
          <target state="translated">C从B编程语言继承了多字符文字。尽管C或C ++标准未指定，但是编译器实现B中指定的多字符文字：文字中每个char的值以大尾数零填充右移顺序（例如，值）初始化所得整数的连续字节。的 &lt;code&gt;'\1'&lt;/code&gt; 是 &lt;code&gt;0x00000001&lt;/code&gt; 和的值 &lt;code&gt;'\1\2\3\4'&lt;/code&gt; 就是 &lt;code&gt;0x01020304&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="00762e90f2d0e1fc656e0809cb403c7716fbb355" translate="yes" xml:space="preserve">
          <source>Multidimensional arrays</source>
          <target state="translated">多维数组</target>
        </trans-unit>
        <trans-unit id="cf133c71b3c2efeaae5de6091eefa30415ff9388" translate="yes" xml:space="preserve">
          <source>Multimap is an associative container that contains a sorted list of key-value pairs, while permitting multiple entries with the same key. Sorting is done according to the comparison function &lt;code&gt;Compare&lt;/code&gt;, applied to the keys. Search, insertion, and removal operations have logarithmic complexity.</source>
          <target state="translated">Multimap是一个关联容器，其中包含键-值对的排序列表，同时允许具有相同键的多个条目。根据应用于键的比较功能 &lt;code&gt;Compare&lt;/code&gt; 进行排序。搜索，插入和删除操作具有对数复杂性。</target>
        </trans-unit>
        <trans-unit id="d93c4759f084c66474a537bb4779321a39600e76" translate="yes" xml:space="preserve">
          <source>Multipass guarantee</source>
          <target state="translated">多通道保证</target>
        </trans-unit>
        <trans-unit id="8b79533d9d6f933b934e06befaa830db21925807" translate="yes" xml:space="preserve">
          <source>Multiple adjacent bit fields are usually packed together (although this behavior is implementation-defined):</source>
          <target state="translated">多个相邻的位字段通常被打包在一起(尽管这种行为是由实现定义的)。</target>
        </trans-unit>
        <trans-unit id="8aba9a4022dc2b5b9217a1e0bae22b4f22da6f84" translate="yes" xml:space="preserve">
          <source>Multiple copy elisions may be chained to eliminate multiple copies.</source>
          <target state="translated">多个副本的洗练可以用链子来消除多个副本。</target>
        </trans-unit>
        <trans-unit id="ba8252d9e78468463f91fd69124355d767e70b19" translate="yes" xml:space="preserve">
          <source>Multiple functions in the same scope may have the same name, as long as their parameter lists and, for member functions, cv/ref qualifications are different. This is known as &lt;a href=&quot;overload_resolution&quot;&gt;function overloading&lt;/a&gt;. Function declarations that differ only in the return type and the noexcept specification(since C++17) cannot be overloaded.</source>
          <target state="translated">同一范围内的多个函数可以具有相同的名称，只要它们的参数列表和成员函数的cv / ref限定条件不同即可。这称为&lt;a href=&quot;overload_resolution&quot;&gt;函数重载&lt;/a&gt;。只能重载返回类型和noexcept规范（因为C ++ 17）不同的函数声明。</target>
        </trans-unit>
        <trans-unit id="19da41d50ad4d265081c36d7f4e65700ca15e75b" translate="yes" xml:space="preserve">
          <source>Multiple namespace blocks with the same name are allowed. All declarations within those blocks are declared in the named scope.</source>
          <target state="translated">允许使用相同名称的多个命名空间块。这些块中的所有声明都在命名的作用域中声明。</target>
        </trans-unit>
        <trans-unit id="0ad5548e15a3586c8d471050a4ce94a8e1a22844" translate="yes" xml:space="preserve">
          <source>Multiple overloads of &lt;code&gt;f()&lt;/code&gt; declared before the</source>
          <target state="translated">&lt;code&gt;f()&lt;/code&gt; 之前声明的多个重载</target>
        </trans-unit>
        <trans-unit id="7732a546fbb87f09193f1be1a7646b62b57f3a87" translate="yes" xml:space="preserve">
          <source>Multiple threads may use &lt;code&gt;fetch_sub&lt;/code&gt; to concurrently process an indexed container.</source>
          <target state="translated">多个线程可以使用 &lt;code&gt;fetch_sub&lt;/code&gt; 并发处理索引容器。</target>
        </trans-unit>
        <trans-unit id="98b77f5ad932fcd3f371127c2c40dc5f446e3196" translate="yes" xml:space="preserve">
          <source>Multiplication of the largest subnormal number by the number one machine epsilon greater than 1.0 gives the tiny value 0x0.fffffffffffff8p-1022 before rounding, but normal value 1p-1022 after rounding. The implementation used to execute this test (IBM Power7) detects tinyness before rounding.</source>
          <target state="translated">将最大的次正常数乘以大于1.0的一号机epsilon,四舍五入前得到微小值0x0.ffffffffffff8p-1022,但四舍五入后得到正常值1p-1022。用于执行这个测试的实现(IBM Power7)在四舍五入前就能检测到微小值。</target>
        </trans-unit>
        <trans-unit id="3385a32109aa5346add0ca1e71e6f6b9c5a102b4" translate="yes" xml:space="preserve">
          <source>Multiplication, division, and remainder</source>
          <target state="translated">乘法、除法和余数</target>
        </trans-unit>
        <trans-unit id="2e1863d77d06e578e88a57a55375c7c7a23d1f8f" translate="yes" xml:space="preserve">
          <source>Multiplicative operators</source>
          <target state="translated">乘法运算符</target>
        </trans-unit>
        <trans-unit id="4ababc1f5e400d86b62ba5912633f6b986ca9b90" translate="yes" xml:space="preserve">
          <source>Must return a &lt;code&gt;Type&amp;amp;&lt;/code&gt;, and afterwards, &lt;code&gt;p&lt;/code&gt; is equivalent to &lt;code&gt;nullptr&lt;/code&gt;</source>
          <target state="translated">必须返回 &lt;code&gt;Type&amp;amp;&lt;/code&gt; ，然后， &lt;code&gt;p&lt;/code&gt; 等于 &lt;code&gt;nullptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b01214e920406c4416e08d1f978fb4406baa93f9" translate="yes" xml:space="preserve">
          <source>Must return a value that is contextually convertible to bool.</source>
          <target state="translated">必须返回一个上下文可转换为bool的值。</target>
        </trans-unit>
        <trans-unit id="8d217e2a97fe63fa480adebe696bb142ffa30b17" translate="yes" xml:space="preserve">
          <source>Mutable is used to specify that the member does not affect the externally visible state of the class (as often used for mutexes, memo caches, lazy evaluation, and access instrumentation).</source>
          <target state="translated">Mutable用于指定该成员不影响类的外部可见状态(如常用于mutexes、memo缓存、懒惰评估和访问工具)。</target>
        </trans-unit>
        <trans-unit id="bd2b0f087b02e413546a53c4f93f4cdf1581cc30" translate="yes" xml:space="preserve">
          <source>Mutex</source>
          <target state="translated">Mutex</target>
        </trans-unit>
        <trans-unit id="bcf81f2350a4ddaf862acb054f396be56471328b" translate="yes" xml:space="preserve">
          <source>Mutex, the sole type in &lt;code&gt;MutexTypes...&lt;/code&gt;</source>
          <target state="translated">Mutex， &lt;code&gt;MutexTypes...&lt;/code&gt; 的唯一类型...</target>
        </trans-unit>
        <trans-unit id="623593159179e7d5bbf03c1ec57146a2c9e50ba8" translate="yes" xml:space="preserve">
          <source>MutexTypes</source>
          <target state="translated">MutexTypes</target>
        </trans-unit>
        <trans-unit id="bd89464f515bc7c1945f885ef807721ee91c256b" translate="yes" xml:space="preserve">
          <source>Mutual exclusion</source>
          <target state="translated">相互排斥</target>
        </trans-unit>
        <trans-unit id="07e8ae8c3cca7c116c9e3ce24998de394a271a66" translate="yes" xml:space="preserve">
          <source>Mutual exclusion algorithms prevent multiple threads from simultaneously accessing shared resources. This prevents data races and provides support for synchronization between threads.</source>
          <target state="translated">互斥算法可以防止多个线程同时访问共享资源。这样可以防止数据竞赛,并为线程之间的同步提供支持。</target>
        </trans-unit>
        <trans-unit id="353bddf63f102523e0e94e44ec2f4291ad09b7ae" translate="yes" xml:space="preserve">
          <source>Mutual exclusion locks, such as &lt;code&gt;&lt;a href=&quot;../thread/mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; or &lt;a href=&quot;atomic_flag&quot;&gt;atomic spinlock&lt;/a&gt;, are an example of release-acquire synchronization: when the lock is released by thread A and acquired by thread B, everything that took place in the critical section (before the release) in the context of thread A has to be visible to thread B (after the acquire) which is executing the same critical section.</source>
          <target state="translated">互斥锁，例如 &lt;code&gt;&lt;a href=&quot;../thread/mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; 或&lt;a href=&quot;atomic_flag&quot;&gt;atomic spinlock&lt;/a&gt;，是释放获取同步的一个示例：当锁由线程A释放并由线程B获取时，所有在关键部分（释放之前）发生的事情。在执行相同关键部分的线程B（在获取之后）必须对线程A上下文可见。</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="ba50285183f637f345b41123255cc7bf40eee6e3" translate="yes" xml:space="preserve">
          <source>N applications of &lt;code&gt;operator/=(path(&quot;..&quot;))&lt;/code&gt;, followed by</source>
          <target state="translated">N个应用 &lt;code&gt;operator/=(path(&quot;..&quot;))&lt;/code&gt; ，后跟</target>
        </trans-unit>
        <trans-unit id="55893568e7cbf1b7a6b29a66a2452f93270c34d9" translate="yes" xml:space="preserve">
          <source>N may be any permutation of a1, ..., aN and</source>
          <target state="translated">N可以是a1,...,aN的任意组合,并且</target>
        </trans-unit>
        <trans-unit id="1250d9586efc9d80cc6c7239aa2177dcff4d7295" translate="yes" xml:space="preserve">
          <source>N op I))))</source>
          <target state="translated">N在I)))</target>
        </trans-unit>
        <trans-unit id="7f15122e3dfe9680a6663ac72323d5f09c66970e" translate="yes" xml:space="preserve">
          <source>N&amp;minus;1 op (E</source>
          <target state="translated">N-1 op（E</target>
        </trans-unit>
        <trans-unit id="8613cc7937238f206e33227381780a70bc3d7fb9" translate="yes" xml:space="preserve">
          <source>N)</source>
          <target state="translated">N)</target>
        </trans-unit>
        <trans-unit id="8b19c15f1ccf07bf3626b4a8b2548d375ec3fa3f" translate="yes" xml:space="preserve">
          <source>N) is defined as follows:</source>
          <target state="translated">N)定义如下:</target>
        </trans-unit>
        <trans-unit id="a100c474d11fd67b64c08abc7f23a4a2f4cc1e66" translate="yes" xml:space="preserve">
          <source>N)) for any K where 1 &amp;lt; K+1 = M &amp;le; N</source>
          <target state="translated">N））对于1 &amp;lt;K + 1 = M&amp;le;N的任何K</target>
        </trans-unit>
        <trans-unit id="77952d1fe50f676e5e862f5a754bb0d05488449e" translate="yes" xml:space="preserve">
          <source>N)) where</source>
          <target state="translated">N))其中</target>
        </trans-unit>
        <trans-unit id="d983d30d3a24dc6620175e14187869fa136530fc" translate="yes" xml:space="preserve">
          <source>N)))</source>
          <target state="translated">N)))</target>
        </trans-unit>
        <trans-unit id="31329860809c98077449f6ad92ec9504b89cb28b" translate="yes" xml:space="preserve">
          <source>N*log(size()+N)), where N is &lt;code&gt;source.size()&lt;/code&gt;.</source>
          <target state="translated">N * log（size（）+ N）），其中N是 &lt;code&gt;source.size()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c264d85396033becba7559b9702cd4354a3b890f" translate="yes" xml:space="preserve">
          <source>N-1 op E</source>
          <target state="translated">关于E的N-1</target>
        </trans-unit>
        <trans-unit id="39b94b742092e3ba7ac4ebd9524bb1c81f255b00" translate="yes" xml:space="preserve">
          <source>N3922</source>
          <target state="translated">N3922</target>
        </trans-unit>
        <trans-unit id="3978b69456fb978edbba4310d37fe1c6ecb893f4" translate="yes" xml:space="preserve">
          <source>N4387</source>
          <target state="translated">N4387</target>
        </trans-unit>
        <trans-unit id="c44f384c13dc675d729b43652997307ca17e8a2b" translate="yes" xml:space="preserve">
          <source>N&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">N&lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d82a19a46f2f7da0f84cb56740a41e0148eda5c1" translate="yes" xml:space="preserve">
          <source>NAN</source>
          <target state="translated">NAN</target>
        </trans-unit>
        <trans-unit id="f0d1c3c27252776cf6fab5b297dd84293196ad68" translate="yes" xml:space="preserve">
          <source>NRVO</source>
          <target state="translated">NRVO</target>
        </trans-unit>
        <trans-unit id="3ad6166ad6b1dfdf3797d9216ac661a1daea38f8" translate="yes" xml:space="preserve">
          <source>NRVO was mandatory in constant expressions</source>
          <target state="translated">NRVO在常量表达中是强制性的</target>
        </trans-unit>
        <trans-unit id="065e03753f6454aa1d90a1883ea3bf51044f5c10" translate="yes" xml:space="preserve">
          <source>NTTP</source>
          <target state="translated">NTTP</target>
        </trans-unit>
        <trans-unit id="85476691293312e0eddef863daabeefe9aa5acfc" translate="yes" xml:space="preserve">
          <source>NUL-terminated.</source>
          <target state="translated">NUL-terminated.</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="7929777f461a9c2e7071443c14f9e07d070abdd6" translate="yes" xml:space="preserve">
          <source>NaN values never compare equal to themselves or to other NaN values. Copying a NaN is not required, by IEEE-754, to preserve its bit representation (sign and &lt;a href=&quot;nan.2&quot;&gt;payload&lt;/a&gt;), though most implementation do.</source>
          <target state="translated">NaN值永远不会等于自己或其他NaN值。IEEE-754不需要复制NaN来保留其位表示（sign和&lt;a href=&quot;nan.2&quot;&gt;有效负载&lt;/a&gt;），尽管大多数实现都需要这样做。</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="e11bc388c83c1b8b82ae73a235837ab0ef1b8869" translate="yes" xml:space="preserve">
          <source>Name lookup</source>
          <target state="translated">姓名查询</target>
        </trans-unit>
        <trans-unit id="b6bc7d50b342a34806ee88ab2690eb319c435c81" translate="yes" xml:space="preserve">
          <source>Name lookup and binding are different for</source>
          <target state="translated">名称查询和绑定是不同的</target>
        </trans-unit>
        <trans-unit id="480387aa2ed9cd405fb53a80e0ad8ef0f482feba" translate="yes" xml:space="preserve">
          <source>Name lookup is the procedure by which a &lt;a href=&quot;name&quot;&gt;name&lt;/a&gt;, when encountered in a program, is associated with the &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; that introduced it.</source>
          <target state="translated">名称查找是通过它的程序&lt;a href=&quot;name&quot;&gt;名&lt;/a&gt;，程序中遇到时，与相关的&lt;a href=&quot;declarations&quot;&gt;声明&lt;/a&gt;介绍了它。</target>
        </trans-unit>
        <trans-unit id="5ca9e948abdb518c09be2641fab9cc9d573e48a4" translate="yes" xml:space="preserve">
          <source>Name lookup rules make it impractical to declare operators in global or user-defined namespace that operate on types from the std namespace, e.g. a custom &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;operator+&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; or for &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; (unless the element types of the vector/pair are user-defined types, which would add their namespace to ADL). Such operators would not be looked up from template instantiations, such as the standard library algorithms. See &lt;a href=&quot;dependent_name&quot;&gt;dependent names&lt;/a&gt; for further details.</source>
          <target state="translated">名称查找规则使得在全局或用户定义的名称空间中声明对std名称空间的类型进行操作的运算符是不切实际的，例如对于 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; 的自定义 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;operator+&lt;/code&gt; （除非元素的类型为向量/对是用户定义的类型，会将其名称空间添加到ADL中。不会从模板实例（例如标准库算法）中查找此类运算符。有关更多详细信息，请参见&lt;a href=&quot;dependent_name&quot;&gt;从属名称&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3013f39113916e6419f8088ed3c67869df636b9d" translate="yes" xml:space="preserve">
          <source>Named Return Value Optimization</source>
          <target state="translated">名义回报价值优化</target>
        </trans-unit>
        <trans-unit id="f44438b5a472bd21faa49423e23b1eb88ebdfc5f" translate="yes" xml:space="preserve">
          <source>Named requirements</source>
          <target state="translated">已命名的需求</target>
        </trans-unit>
        <trans-unit id="5d20b518c977a68ada4a25be86f69791473df0e8" translate="yes" xml:space="preserve">
          <source>Named sets of such requirements are called</source>
          <target state="translated">这种要求的命名集称为</target>
        </trans-unit>
        <trans-unit id="3feb744677b698e301be638132eacb767a8d61ef" translate="yes" xml:space="preserve">
          <source>Named sockets are UNIX domain sockets constructed with &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;socket&lt;/a&gt; and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html&quot;&gt;bind&lt;/a&gt; POSIX APIs, which may be used for advanced interprocess communication. In particular, they may be used to transport open file descriptors from one running process to another.</source>
          <target state="translated">命名套接字是使用&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;套接字&lt;/a&gt;和&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html&quot;&gt;绑定&lt;/a&gt; POSIX API 构造的UNIX域套接字，可用于高级进程间通信。特别是，它们可以用于将打开的文件描述符从一个正在运行的进程传输到另一个进程。</target>
        </trans-unit>
        <trans-unit id="a97e72293967c371e645dc4966907494004b6512" translate="yes" xml:space="preserve">
          <source>Named sockets are UNIX domain sockets constructed with &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html&quot;&gt;socket&lt;/a&gt; and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html&quot;&gt;bind&lt;/a&gt; POSIX APIs, which may be used for advanced interprocess communication. In particular, they may be used to transport open file descriptors from one running process to another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7c08c3ab75f37e2da656c1aab228f5f3a793b1" translate="yes" xml:space="preserve">
          <source>Names</source>
          <target state="translated">Names</target>
        </trans-unit>
        <trans-unit id="c9b864b84da76323cdde2ab3f20373514e5220f1" translate="yes" xml:space="preserve">
          <source>Names and identifiers</source>
          <target state="translated">名称和识别符</target>
        </trans-unit>
        <trans-unit id="5dba54e935821f929da3325c377d095d8e0b34ed" translate="yes" xml:space="preserve">
          <source>Names at the top-level namespace scope (file scope in C) that are &lt;code&gt;const&lt;/code&gt; and not &lt;code&gt;extern&lt;/code&gt; have external linkage in C, but internal linkage in C++.</source>
          <target state="translated">顶级名称空间范围（C中的文件范围）中的 &lt;code&gt;const&lt;/code&gt; 而不是 &lt;code&gt;extern&lt;/code&gt; 的名称在C中具有外部链接，但在C ++中具有内部链接。</target>
        </trans-unit>
        <trans-unit id="3063d4cd8cda973d2c9e30f2ca7be83f7c01f92d" translate="yes" xml:space="preserve">
          <source>Names encountered in a program are associated with the declarations that introduced them using &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;. Each name is only valid within a part of the program called its &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;. Some names have &lt;a href=&quot;storage_duration&quot;&gt;linkage&lt;/a&gt; which makes them refer to the same entities when they appear in different scopes or translation units.</source>
          <target state="translated">程序中遇到的名称与使用&lt;a href=&quot;lookup&quot;&gt;名称查找&lt;/a&gt;引入它们的声明相关联。每个名称仅在程序的一部分（称为&lt;a href=&quot;scope&quot;&gt;作用域）内有效&lt;/a&gt;。有些名称具有&lt;a href=&quot;storage_duration&quot;&gt;链接&lt;/a&gt;，当它们出现在不同的作用域或翻译单位中时，它们使它们引用相同的实体。</target>
        </trans-unit>
        <trans-unit id="8a9aa2bab33fd05a2da5d335efe4a2e09b164f3c" translate="yes" xml:space="preserve">
          <source>Names introduced by &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; declarations within a non-local class X become members of the innermost enclosing namespace of X, but they do not become visible to ordinary &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; (neither &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; nor &lt;a href=&quot;qualified_lookup&quot;&gt;qualified&lt;/a&gt;) unless a matching declaration is provided at namespace scope, either before or after the class definition. Such name may be found through &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; which considers both namespaces and classes.</source>
          <target state="translated">非本地类X中的&lt;a href=&quot;friend&quot;&gt;朋友&lt;/a&gt;声明所引入的名称成为X的最内层封闭名称空间的成员，但对于普通&lt;a href=&quot;lookup&quot;&gt;名称查找&lt;/a&gt;（无论是&lt;a href=&quot;unqualified_lookup&quot;&gt;unqual&lt;/a&gt;还是&lt;a href=&quot;qualified_lookup&quot;&gt;qualified&lt;/a&gt;），它们都不会变为可见，除非在名称空间范围内提供了匹配的声明，否则或在类定义之后。可以通过同时考虑名称空间和类的&lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;找到该名称。</target>
        </trans-unit>
        <trans-unit id="c1935b005dc184ad84620c13afec466318085ca9" translate="yes" xml:space="preserve">
          <source>Names introduced into a namespace scope by a using-declaration can be used just like any other names, including qualified lookup from other scopes:</source>
          <target state="translated">通过使用声明引入到命名空间作用域的名称可以像使用其他名称一样,包括从其他作用域的限定查找。</target>
        </trans-unit>
        <trans-unit id="abc354041c1ad60236f2a24daaf11e19bd038ee8" translate="yes" xml:space="preserve">
          <source>Names of &lt;a href=&quot;../language/reference&quot;&gt;rvalue reference&lt;/a&gt; variables are &lt;a href=&quot;../language/value_category&quot;&gt;lvalues&lt;/a&gt; and have to be converted to &lt;a href=&quot;../language/value_category&quot;&gt;xvalues&lt;/a&gt; to be bound to the function overloads that accept rvalue reference parameters, which is why &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt; and &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt; typically use &lt;code&gt;std::move&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;../language/reference&quot;&gt;rvalue引用&lt;/a&gt;变量的名称为&lt;a href=&quot;../language/value_category&quot;&gt;lvalues&lt;/a&gt;，必须转换为&lt;a href=&quot;../language/value_category&quot;&gt;xvalues&lt;/a&gt;才能绑定到接受rvalue引用参数的函数重载，这就是为什么&lt;a href=&quot;../language/move_constructor&quot;&gt;move构造函数&lt;/a&gt;和&lt;a href=&quot;../language/move_operator&quot;&gt;move赋值运算符&lt;/a&gt;通常使用 &lt;code&gt;std::move&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="db1e5452b458ffc1ce5b7de086a71fa73749c0e6" translate="yes" xml:space="preserve">
          <source>Names of &lt;code&gt;thread_local&lt;/code&gt; variables with internal or external linkage referred from different scopes may refer to the same or to different instances depending on whether the code is executing in the same or in different threads.</source>
          <target state="translated">具有不同范围的内部或外部链接的 &lt;code&gt;thread_local&lt;/code&gt; 变量的名称可以引用相同或不同的实例，具体取决于代码是在同一线程中执行还是在不同线程中执行。</target>
        </trans-unit>
        <trans-unit id="e8dae2c410db83e5bd98bf3a1359488efbedbb6b" translate="yes" xml:space="preserve">
          <source>Names of any class members can only be used in four contexts:</source>
          <target state="translated">任何类成员的名称只能在四种情况下使用。</target>
        </trans-unit>
        <trans-unit id="b43957c55d7ffebeb7c1698dd30daec7bfa5f9cc" translate="yes" xml:space="preserve">
          <source>Names that appear in expression-list or brace-init-list are evaluated in scope of the constructor:</source>
          <target state="translated">出现在expression-list或brace-init-list中的名称会在构造函数的范围内被评估。</target>
        </trans-unit>
        <trans-unit id="68a7b15b97ad42eb5d4cb110e1e2208e8db49ff3" translate="yes" xml:space="preserve">
          <source>Namespace &lt;code&gt;std::regex_constants&lt;/code&gt;</source>
          <target state="translated">命名空间 &lt;code&gt;std::regex_constants&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69aee25fb2b7251f96c077bac9928b36b2f0092d" translate="yes" xml:space="preserve">
          <source>Namespace alias</source>
          <target state="translated">命名空间别名</target>
        </trans-unit>
        <trans-unit id="15feeecb0e0bd445b4ec4c17a571fe55224d4791" translate="yes" xml:space="preserve">
          <source>Namespace aliases</source>
          <target state="translated">命名空间别名</target>
        </trans-unit>
        <trans-unit id="9d3514105c3b51acfe33dab56a9ad9112ffd5783" translate="yes" xml:space="preserve">
          <source>Namespace aliases allow the programmer to define an alternate name for a namespace.</source>
          <target state="translated">命名空间别名允许程序员为一个命名空间定义一个备用名称。</target>
        </trans-unit>
        <trans-unit id="e8ea1a0aa60760b378411518c66664dc0aebf042" translate="yes" xml:space="preserve">
          <source>Namespace declaration</source>
          <target state="translated">命名空间声明</target>
        </trans-unit>
        <trans-unit id="1a0de11ba24e7fe94cf87f5c813cc5958139da55" translate="yes" xml:space="preserve">
          <source>Namespace definition</source>
          <target state="translated">命名空间定义</target>
        </trans-unit>
        <trans-unit id="7abe5aadb217584bf97533759728f989dd4a7122" translate="yes" xml:space="preserve">
          <source>Namespace definitions are only allowed at namespace scope, including the global scope.</source>
          <target state="translated">命名空间定义只允许在命名空间范围,包括全局范围。</target>
        </trans-unit>
        <trans-unit id="b2fb3696d13cbe0ff41f03594167b5ebd95c58c5" translate="yes" xml:space="preserve">
          <source>Namespace members</source>
          <target state="translated">命名空间成员</target>
        </trans-unit>
        <trans-unit id="6ef4650b141111ec251678ed3bf718413e6ab572" translate="yes" xml:space="preserve">
          <source>Namespace scope</source>
          <target state="translated">命名空间范围</target>
        </trans-unit>
        <trans-unit id="98cc70f9e7340456a64ac9fdf7b1eede2f30a8e3" translate="yes" xml:space="preserve">
          <source>Namespace-scope anonymous unions must be declared static unless they appear in an unnamed namespace.</source>
          <target state="translated">命名空间范围的匿名联合必须被声明为静态的,除非它们出现在未命名的命名空间中。</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6ade31b5444def27ab30c5c64abc17a78b593fc9" translate="yes" xml:space="preserve">
          <source>Namespaces provide a method for preventing name conflicts in large projects.</source>
          <target state="translated">命名空间提供了一种防止大型项目中名称冲突的方法。</target>
        </trans-unit>
        <trans-unit id="8655490bdfd99b50e55540721bde65050a10ca66" translate="yes" xml:space="preserve">
          <source>Narrow and wide orientation</source>
          <target state="translated">窄方向和宽方向</target>
        </trans-unit>
        <trans-unit id="d6f5cbdcb5ba2c44829f73b263418c7c018a552d" translate="yes" xml:space="preserve">
          <source>Narrow character</source>
          <target state="translated">窄字符</target>
        </trans-unit>
        <trans-unit id="00612e7ff2b16d807e5421756762dc8ce833f708" translate="yes" xml:space="preserve">
          <source>Narrow/multibyte character</source>
          <target state="translated">窄/多字节字符</target>
        </trans-unit>
        <trans-unit id="02ec8760336fb09c698a2687c11d370174266ee2" translate="yes" xml:space="preserve">
          <source>Narrowing conversions</source>
          <target state="translated">缩小转换范围</target>
        </trans-unit>
        <trans-unit id="aa2311a58a83585cb18d67d0ab7bfd5d14fb5130" translate="yes" xml:space="preserve">
          <source>Narrowing is always successful and is always reversible (by calling &lt;code&gt;&lt;a href=&quot;widen&quot;&gt;widen()&lt;/a&gt;&lt;/code&gt;) for all characters from the basic source character set (latin letters, digits, and punctuations required to write a C++ program).</source>
          <target state="translated">对于基本源字符集中的所有字符（编写C ++程序所需的拉丁字母，数字和标点符号），缩小总是成功的并且总是可逆的（通过调用 &lt;code&gt;&lt;a href=&quot;widen&quot;&gt;widen()&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d58074e0c552f383bd0ec261612a709f3413f4a1" translate="yes" xml:space="preserve">
          <source>Narrowing of any digit character guarantees that if the result is subtracted from the character literal &lt;code&gt;'0'&lt;/code&gt;, the difference equals the digit value of the original character.</source>
          <target state="translated">缩小任何数字字符可确保如果从字符文字 &lt;code&gt;'0'&lt;/code&gt; 中减去结果，则差值等于原始字符的数字值。</target>
        </trans-unit>
        <trans-unit id="8dbe486ad6ba7275ed9b6d093c1f795836a5e22a" translate="yes" xml:space="preserve">
          <source>Narrowing, if successful, preserves all character classification categories known to &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果成功，则缩小将保留 &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt; 已知的所有字符分类类别。</target>
        </trans-unit>
        <trans-unit id="6a4742e8a9730fb2d9ea65a3e7a57cdd49ba4360" translate="yes" xml:space="preserve">
          <source>Narrows a wide character &lt;code&gt;c&lt;/code&gt; if its multibyte character equivalent in the initial shift state is a single byte.</source>
          <target state="translated">如果在初始移位状态下等效于多字节字符的单个字节是一个宽字符 &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e856674ce1f8ad1d8b857f019d9b05cec7538227" translate="yes" xml:space="preserve">
          <source>Native handle</source>
          <target state="translated">本地手柄</target>
        </trans-unit>
        <trans-unit id="db030e0b7158dfda8f21b860c6287b6a5341fd7b" translate="yes" xml:space="preserve">
          <source>Native pathname format</source>
          <target state="translated">本地路径名格式</target>
        </trans-unit>
        <trans-unit id="ca5b116732b30e4ee615a6e0c70fc845595ecbca" translate="yes" xml:space="preserve">
          <source>Nearest integer floating point operations</source>
          <target state="translated">最接近的整数浮点运算</target>
        </trans-unit>
        <trans-unit id="dfaab505f47d58982ff129c9d7d12a74d6eb3cc8" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;lhs&lt;/code&gt; appears before &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="translated">如果 &lt;code&gt;lhs&lt;/code&gt; 以字典顺序出现在 &lt;code&gt;rhs&lt;/code&gt; 之前，则为负值。</target>
        </trans-unit>
        <trans-unit id="87491531316873a8136087161a4d5513bf956b22" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">如果 &lt;code&gt;lhs&lt;/code&gt; 是负值</target>
        </trans-unit>
        <trans-unit id="273543511f403081caee3e55984dd6ca3f79876b" translate="yes" xml:space="preserve">
          <source>Negative value if &lt;code&gt;s1&lt;/code&gt; is</source>
          <target state="translated">如果 &lt;code&gt;s1&lt;/code&gt; 为负值</target>
        </trans-unit>
        <trans-unit id="ceca0034b729fc521079379a02d62ac4de8dc88a" translate="yes" xml:space="preserve">
          <source>Negative value if the first differing byte (reinterpreted as &lt;code&gt;unsigned char&lt;/code&gt;) in &lt;code&gt;lhs&lt;/code&gt; is less than the corresponding byte in &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;lhs&lt;/code&gt; 中的第一个不同字节（重新解释为 &lt;code&gt;unsigned char&lt;/code&gt; ）小于 &lt;code&gt;rhs&lt;/code&gt; 中的相应字节，则为负值。</target>
        </trans-unit>
        <trans-unit id="282e0a77a7206269a1ec03af267a85cf22416793" translate="yes" xml:space="preserve">
          <source>Negative value if the value of the first differing wide character in &lt;code&gt;lhs&lt;/code&gt; is less than the value of the corresponding wide character in &lt;code&gt;rhs&lt;/code&gt;: &lt;code&gt;lhs&lt;/code&gt; precedes &lt;code&gt;rhs&lt;/code&gt; in lexicographical order.</source>
          <target state="translated">负值，如果在所述第一不同宽字符的值 &lt;code&gt;lhs&lt;/code&gt; 小于在相应的宽字符的值 &lt;code&gt;rhs&lt;/code&gt; ： &lt;code&gt;lhs&lt;/code&gt; 先于 &lt;code&gt;rhs&lt;/code&gt; 在词典顺序。</target>
        </trans-unit>
        <trans-unit id="f8dce9bcbeee998252a5f32963f3424cf3f7e0d3" translate="yes" xml:space="preserve">
          <source>Negators</source>
          <target state="translated">Negators</target>
        </trans-unit>
        <trans-unit id="f7a7b461a2da4ad85b1265cf9c4d04f21c5ffddb" translate="yes" xml:space="preserve">
          <source>Nested allocator class</source>
          <target state="translated">嵌套分配器类</target>
        </trans-unit>
        <trans-unit id="25e8c5172b7e5d7b584594533302eddfd95e8bc0" translate="yes" xml:space="preserve">
          <source>Nested class declarations obey &lt;a href=&quot;access&quot;&gt;member access&lt;/a&gt; specifiers, a private member class cannot be named outside the scope of the enclosing class, although objects of that class may be manipulated:</source>
          <target state="translated">嵌套类声明遵循&lt;a href=&quot;access&quot;&gt;成员访问&lt;/a&gt;说明符，尽管可以操纵该类的对象，但不能在封闭类的范围之外命名私有成员类：</target>
        </trans-unit>
        <trans-unit id="65046fcf73f5e6ac3773f70ea1badbd965d975c0" translate="yes" xml:space="preserve">
          <source>Nested classes</source>
          <target state="translated">嵌套类</target>
        </trans-unit>
        <trans-unit id="1b5839fbae7339935c12e6b4b66fd2e922b275ad" translate="yes" xml:space="preserve">
          <source>Nested classes can be forward-declared and later defined, either within the same enclosing class body, or outside of it:</source>
          <target state="translated">嵌套类可以是前向声明的,也可以是后向定义的,既可以在同一个包围类体中,也可以在包围类体之外。</target>
        </trans-unit>
        <trans-unit id="64808f48e8bd759c2c2b1d7832534e1bd54d3712" translate="yes" xml:space="preserve">
          <source>Nested requirements</source>
          <target state="translated">嵌套要求</target>
        </trans-unit>
        <trans-unit id="ea849e260b8735345217e4f53f113c9fcde5b394" translate="yes" xml:space="preserve">
          <source>Network is down</source>
          <target state="translated">网络瘫痪</target>
        </trans-unit>
        <trans-unit id="72752d57c3c282cc523b7154bbf54840e4683a46" translate="yes" xml:space="preserve">
          <source>Network unreachable</source>
          <target state="translated">网络无法连接</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="3c4e963fe5e99296e8a4ab9dc3cfa9311f0e21c6" translate="yes" xml:space="preserve">
          <source>New operators such as &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;amp;|&lt;/code&gt; cannot be created.</source>
          <target state="translated">新的运算符，例如 &lt;code&gt;**&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;amp;|&lt;/code&gt; 无法创建。</target>
        </trans-unit>
        <trans-unit id="ede4611858dc430c3ea6396ebc14993ab64f79d1" translate="yes" xml:space="preserve">
          <source>New-expressions are allowed to elide or combine allocations made through replaceable allocation functions. In case of elision, the storage may be provided by the compiler without making the call to an allocation function (this also permits optimizing out unused new-expression). In case of combining, the allocation made by a new-expression E1 may be extended to provide additional storage for another new-expression E2 if all of the following is true:</source>
          <target state="translated">新表达式可以省略或合并通过可替换分配函数进行的分配。在省略的情况下,编译器可以在不调用分配函数的情况下提供存储空间(这也允许优化掉未使用的新表达式)。在合并的情况下,一个新表达式E1所做的分配可以扩展到为另一个新表达式E2提供额外的存储,如果以下所有条件为真。</target>
        </trans-unit>
        <trans-unit id="493d0f0040b36ea8241324dced2e890dfb4b6119" translate="yes" xml:space="preserve">
          <source>Newer &quot;Minimum standard&quot;, recommended by Park, Miller, and Stockmeyer in 1993.</source>
          <target state="translated">较新的 &quot;最低标准&quot;,由Park、Miller和Stockmeyer于1993年推荐。</target>
        </trans-unit>
        <trans-unit id="79ac146d5b7ee7fd72cce1790f7da1b8a2f032a2" translate="yes" xml:space="preserve">
          <source>Newlines are kept, and it's unspecified whether non-newline whitespace sequences may be collapsed into single space characters.</source>
          <target state="translated">保留新行,非新行的空格序列是否可以折叠成单个空格字符还未明确。</target>
        </trans-unit>
        <trans-unit id="de67bdd002151bf79b109ea669e76942392196e1" translate="yes" xml:space="preserve">
          <source>Niebloids</source>
          <target state="translated">Niebloids</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="f130b9c617343f8c039eb502e65e2bfe55e02212" translate="yes" xml:space="preserve">
          <source>No STREAM resources</source>
          <target state="translated">没有STREAM资源</target>
        </trans-unit>
        <trans-unit id="7dd7bd839e3806d4920233a25bbd072dba9f30a1" translate="yes" xml:space="preserve">
          <source>No additional synchronization guarantees other than what's already provided by shared state.</source>
          <target state="translated">除了共享状态已经提供的,没有额外的同步保证。</target>
        </trans-unit>
        <trans-unit id="6bcc62e49c9ca3ab05ca96f0f3e27fde373feffa" translate="yes" xml:space="preserve">
          <source>No bounds checking is performed: the behavior is undefined if &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">不执行边界检查：如果 &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt; 则行为不确定。</target>
        </trans-unit>
        <trans-unit id="e792e65ee8a80fd8989ad1b66325f180ccd8b365" translate="yes" xml:space="preserve">
          <source>No buffer space available</source>
          <target state="translated">没有可用的缓冲空间</target>
        </trans-unit>
        <trans-unit id="099e11888438840a8566c983d5b1e6de2dad8524" translate="yes" xml:space="preserve">
          <source>No child processes</source>
          <target state="translated">没有子程序</target>
        </trans-unit>
        <trans-unit id="8959031a2aef1c7c15f7657b554e13b4559478e9" translate="yes" xml:space="preserve">
          <source>No destructors for automatic objects are called. If replacing of &lt;code&gt;std::longjmp&lt;/code&gt; with &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;catch&lt;/code&gt; would execute a non-trivial destructor for any automatic object, the behavior of such &lt;code&gt;std::longjmp&lt;/code&gt; is undefined.</source>
          <target state="translated">没有调用自动对象的析构函数。如果更换 &lt;code&gt;std::longjmp&lt;/code&gt; 用 &lt;code&gt;throw&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 的与 &lt;code&gt;catch&lt;/code&gt; 将执行一个不平凡的析构函数任何自动对象，这样的行为 &lt;code&gt;std::longjmp&lt;/code&gt; 不确定。</target>
        </trans-unit>
        <trans-unit id="b7ad248d7445e862eb6d5aac0fef62ca217cfdbf" translate="yes" xml:space="preserve">
          <source>No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">没有元素被复制或移动，仅容器节点的内部指针被指向。指向已传输元素的所有指针和引用均保持有效，但现在引用 &lt;code&gt;*this&lt;/code&gt; ，而不引用 &lt;code&gt;source&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9ae4f5756c09ebfc4d7b62cc8ca55e5eb9ed890" translate="yes" xml:space="preserve">
          <source>No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;. Iterators referring to the transferred elements and all iterators referring to &lt;code&gt;*this&lt;/code&gt; are invalidated.</source>
          <target state="translated">没有元素被复制或移动，仅容器节点的内部指针被指向。指向已传输元素的所有指针和引用均保持有效，但现在引用 &lt;code&gt;*this&lt;/code&gt; ，而不引用 &lt;code&gt;source&lt;/code&gt; 。引用传输元素的迭代器和引用 &lt;code&gt;*this&lt;/code&gt; 的所有迭代器均无效。</target>
        </trans-unit>
        <trans-unit id="cc3224dd2db8f1be53245ed8d7053751754bb987" translate="yes" xml:space="preserve">
          <source>No elements are copied or moved, only the internal pointers of the list nodes are re-pointed. The behavior is undefined if: &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;. No iterators or references become invalidated, the iterators to moved elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">没有元素被复制或移动，只有列表节点的内部指针被重新指向。如果满足以下 &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; 则该行为未定义：get_allocator（）！= other.get_allocator（）。没有迭代器或引用变为无效，移动元素的迭代器保持有效，但现在引用 &lt;code&gt;*this&lt;/code&gt; ，而不引用 &lt;code&gt;other&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a446797facd648759f6798d6324eb89c747b63a0" translate="yes" xml:space="preserve">
          <source>No elements are copied. &lt;code&gt;pos&lt;/code&gt; must be either a deferenceable valid iterator into &lt;code&gt;*this&lt;/code&gt; or the &lt;code&gt;&lt;a href=&quot;before_begin&quot;&gt;before_begin()&lt;/a&gt;&lt;/code&gt; iterator (in particular, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; is not a valid argument for &lt;code&gt;pos&lt;/code&gt;). The behavior is undefined if &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;. No iterators or references become invalidated, the iterators to the moved elements now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">没有元素被复制。 &lt;code&gt;pos&lt;/code&gt; 必须是 &lt;code&gt;*this&lt;/code&gt; 的一个可 &lt;code&gt;&lt;a href=&quot;before_begin&quot;&gt;before_begin()&lt;/a&gt;&lt;/code&gt; 有效迭代器，或者必须是before_begin（）迭代器（特别是 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 不是 &lt;code&gt;pos&lt;/code&gt; 的有效参数）。如果 &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; 则该行为是不确定的。没有迭代器或引用变为无效，已移动元素的迭代器现在引用 &lt;code&gt;*this&lt;/code&gt; ，而不是 &lt;code&gt;other&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="978b5fdcd4067d166cd18666eaf43106a672a214" translate="yes" xml:space="preserve">
          <source>No elements are copied. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The function does nothing if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;. If &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt;, the behavior is undefined. No iterators or references become invalidated, except that the iterators of moved elements now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;other&lt;/code&gt;. The first version uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the elements, the second version uses the given comparison function &lt;code&gt;comp&lt;/code&gt;.</source>
          <target state="translated">没有元素被复制。操作后， &lt;code&gt;other&lt;/code&gt; 容器变空。如果 &lt;code&gt;other&lt;/code&gt; 与 &lt;code&gt;*this&lt;/code&gt; 指向同一对象，则该函数不执行任何操作。如果 &lt;code&gt;get_allocator() != other.get_allocator()&lt;/code&gt; ，则行为未定义。没有迭代器或引用变为无效，除了移动的元素的迭代器现在引用 &lt;code&gt;*this&lt;/code&gt; 而不是 &lt;code&gt;other&lt;/code&gt; 。第一个版本使用 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 来比较元素，第二个版本使用给定的比较函数 &lt;code&gt;comp&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
