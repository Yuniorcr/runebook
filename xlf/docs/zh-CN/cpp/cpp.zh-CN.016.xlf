<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="e58f6c458633d11255df6ec72e17d6e0e307082c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复数反正切值，该值在沿着虚轴无界的条带范围内以及[-&amp;pi;/ 2; +&amp;pi;/ 2]沿实轴。</target>
        </trans-unit>
        <trans-unit id="50a8713f4c4c617bedaa7a390ea195b3329dac1c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的双曲余弦值。</target>
        </trans-unit>
        <trans-unit id="a8e6619163d1ca9fedc0a2bfd79d4c047fbeb277" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的双曲正弦值。</target>
        </trans-unit>
        <trans-unit id="0204a9004641a330efb33cc1c10a2eb5fe8c95c2" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复双曲正切值。</target>
        </trans-unit>
        <trans-unit id="b37be6aaeb963e74d379aaa690fc0222ec1a8842" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the absolute value (also known as norm, modulus, or magnitude) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的绝对值（也称为范数，模量或大小）。</target>
        </trans-unit>
        <trans-unit id="f7f248bc9527b22f78b886ecb63cf4c8a2bd9c60" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the fractional part of &lt;code&gt;x&lt;/code&gt; with the same sign as &lt;code&gt;x&lt;/code&gt;. The integral part is put into the value pointed to by &lt;code&gt;iptr&lt;/code&gt;.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;x&lt;/code&gt; 的小数部分，其符号与 &lt;code&gt;x&lt;/code&gt; 相同。整数部分放入 &lt;code&gt;iptr&lt;/code&gt; 指向的值中。</target>
        </trans-unit>
        <trans-unit id="dcbbfc79f2b5b688deb79fcd4d7c358c461e6459" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the phase angle of &lt;code&gt;z&lt;/code&gt; in the interval [&amp;minus;&amp;pi;; &amp;pi;].</source>
          <target state="translated">如果没有出现错误，则返回的相位角 &lt;code&gt;z&lt;/code&gt; 在间隔[-&amp;pi;; &amp;pi;]。</target>
        </trans-unit>
        <trans-unit id="af3231d18a9dbafc82193c163f7f7ec4e37b28f7" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the square root of &lt;code&gt;z&lt;/code&gt;, in the range of the right half-plane, including the imaginary axis ([0; +&amp;infin;) along the real axis and (&amp;minus;&amp;infin;; +&amp;infin;) along the imaginary axis.).</source>
          <target state="translated">如果没有错误发生，则在右半平面的范围内返回 &lt;code&gt;z&lt;/code&gt; 的平方根，包括沿实轴的虚轴（[0; +&amp;infin;）和沿虚轴的（-&amp;infin;; +&amp;infin;）。 ）。</target>
        </trans-unit>
        <trans-unit id="c2564a63d94a5759bfc1f7f8a35fbdfcf9b9d071" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical Bessel function of the first kind of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is j</source>
          <target state="translated">如果没有错误发生，则返回第一种 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的球贝塞尔函数的值，即j</target>
        </trans-unit>
        <trans-unit id="4739e7b0751e1897ecdce821941cd1dfb83af3ac" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical Bessel function of the second kind (spherical Neumann function) of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is n</source>
          <target state="translated">如果没有错误，则返回 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的第二种球形贝塞尔函数（球形诺伊曼函数）的值，即n</target>
        </trans-unit>
        <trans-unit id="63cd03ce841bb8c36f4907b2d91c123b017f259e" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical associated Legendre function (that is, spherical harmonic with ϕ = 0) of &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;&amp;theta;&lt;/code&gt;, where the spherical harmonic function is defined as Ym</source>
          <target state="translated">如果没有错误发生，则返回与球相关的Legendre函数（即Legend = 0 的球谐函数）的 &lt;code&gt;l&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;&amp;theta;&lt;/code&gt; 的值，其中球谐函数定义为Ym</target>
        </trans-unit>
        <trans-unit id="ee22b5df48ca25af069416a0b6aead9e8cfe0766" translate="yes" xml:space="preserve">
          <source>If no errors occur, square root of &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg), is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;arg&lt;/code&gt; （&amp;radic;arg）的平方根。</target>
        </trans-unit>
        <trans-unit id="d6cd26c82284031b354355d1565d22e205fe8e3d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc cosine of &lt;code&gt;arg&lt;/code&gt; (arccos(arg)) in the range [0 , &amp;pi;], is returned.</source>
          <target state="translated">如果没有错误发生，则返回范围为[0，&amp;pi;] 的 &lt;code&gt;arg&lt;/code&gt; 的反余弦（arccos（arg））。</target>
        </trans-unit>
        <trans-unit id="039d32b1f2e5bfee4ca5736c63a4206e5274388e" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc sine of &lt;code&gt;arg&lt;/code&gt; (arcsin(arg)) in the range [-</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; （arcsin（arg））的反正弦在[-</target>
        </trans-unit>
        <trans-unit id="b32613c8b978beac62c696ce2bd93a54bd237edb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;arg&lt;/code&gt; (arctan(arg)) in the range [-</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; （arctan（arg））的反正切在[-</target>
        </trans-unit>
        <trans-unit id="c938da3a42fe0590b15c6f8539ff408d3a3b97dd" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (arctan(</source>
          <target state="translated">如果没有错误，则 &lt;code&gt;y/x&lt;/code&gt; 的反正切（arctan（</target>
        </trans-unit>
        <trans-unit id="9d5986c54dce11e1cd1599414757016de12c5f01" translate="yes" xml:space="preserve">
          <source>If no errors occur, the base-</source>
          <target state="translated">如果没有发生错误,则基线</target>
        </trans-unit>
        <trans-unit id="be331ea28ae7c2d7b9acf97860d316fce4b87723" translate="yes" xml:space="preserve">
          <source>If no errors occur, the common (base-</source>
          <target state="translated">如果没有发生错误,则常见的(基站)。</target>
        </trans-unit>
        <trans-unit id="135f7aa5f1c2d4f79725bd744a0dd782f41f3bfa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip of nonnegative values along the real axis and in the interval [&amp;minus;i&amp;pi;; +i&amp;pi;] along the imaginary axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复弧双曲余弦值，该值在沿实轴的非负值的半条带范围内，且在[-i&amp;pi;; +i&amp;pi;]沿虚轴。</target>
        </trans-unit>
        <trans-unit id="05909577ff3329b64c179e57f5f18c51d7427016" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复弧双曲正弦值，该值在沿实轴数学上无界的条带范围内，且在[-i&amp;pi;/ 2; +i&amp;pi;/ 2]沿虚轴。</target>
        </trans-unit>
        <trans-unit id="5e1faa126d0291e9222a13afce04bd8eb0c0cbd7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复弧双曲正切值，该值在沿实轴数学上无界的半条带范围内，且在[-i&amp;pi;/ 2; +i&amp;pi;/ 2]沿虚轴。</target>
        </trans-unit>
        <trans-unit id="b951e541cea44c28eafdd9c54b7c32c1392530f6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的余弦。</target>
        </trans-unit>
        <trans-unit id="e0170daad51b40b50ab797fcf5f22cc95ede3feb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex natural logarithm of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip in the interval [&amp;minus;i&amp;pi;, +i&amp;pi;] along the imaginary axis and mathematically unbounded along the real axis.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复数自然对数，该数在带的范围内，沿着虚轴在[-i&amp;pi;，+i&amp;pi;]区间内，并且在数学上沿实轴无界。</target>
        </trans-unit>
        <trans-unit id="e80a11cce80b4f8332e379e29bcd184e31b6ff47" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex power xy</source>
          <target state="translated">如果没有发生错误,则复数幂 xy</target>
        </trans-unit>
        <trans-unit id="c05f2e2cc1ed459bdf96a06ef8dbc33e20915e79" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复正弦。</target>
        </trans-unit>
        <trans-unit id="8f171b9589d9359bfb44bdfa881b4ee93ea77d0c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;z&lt;/code&gt; 的复数切线。</target>
        </trans-unit>
        <trans-unit id="35bd7abdcb7f0220128fd880299baf801952dc19" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cosine of &lt;code&gt;arg&lt;/code&gt; (cos(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; 的余弦（cos（arg））在[-1; +1]，返回。</target>
        </trans-unit>
        <trans-unit id="ff16f514ad4d462d31d6524ed4ea84f4f6bcb390" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cubic root of &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg), is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;arg&lt;/code&gt; （3&amp;radic;arg）的立方根。</target>
        </trans-unit>
        <trans-unit id="1e33cd84b874596d38519b6f05a2e60c9accef6b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the floating point value with the magnitude of &lt;code&gt;x&lt;/code&gt; and the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有错误发生，则返回具有 &lt;code&gt;x&lt;/code&gt; 的大小和 &lt;code&gt;y&lt;/code&gt; 的符号的浮点值。</target>
        </trans-unit>
        <trans-unit id="29635dc5075be505f22d8b338419ce3b116238e5" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh(arg), or</source>
          <target state="translated">如果没有发生错误，的双曲余弦 &lt;code&gt;arg&lt;/code&gt; （COSH（ARG），或</target>
        </trans-unit>
        <trans-unit id="084419061d5d22eb194084f72eb3bc99faee2d80" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh(arg), or</source>
          <target state="translated">如果没有发生错误，的双曲正弦 &lt;code&gt;arg&lt;/code&gt; （双曲正弦（ARG），或</target>
        </trans-unit>
        <trans-unit id="fde1a5cab1da9385208df6463481d983b8d198b8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh(arg), or</source>
          <target state="translated">如果没有错误发生， &lt;code&gt;arg&lt;/code&gt; （tanh（arg），或</target>
        </trans-unit>
        <trans-unit id="3870fee396c73bbc1aab8cee4f9a85c1179be025" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh-1</source>
          <target state="translated">如果没有错误发生，则为 &lt;code&gt;arg&lt;/code&gt; 的反双曲余弦（cosh-1</target>
        </trans-unit>
        <trans-unit id="c5db26fbae61f4e34cf5287ffaa5a9d47e53259d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh-1</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; 的反双曲正弦（sinh-1</target>
        </trans-unit>
        <trans-unit id="f93099d7063e1d7a83038ac66c3c5233ba5f6ece" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh-1</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; （tanh-1）的反双曲正切值</target>
        </trans-unit>
        <trans-unit id="d4744dace8417a9d2afa9a3795c780e70495855c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the largest integer value not greater than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lfloor;arg&amp;rfloor;, is returned.</source>
          <target state="translated">如果没有错误发生，则返回不大于 &lt;code&gt;arg&lt;/code&gt; 的最大整数值arg。</target>
        </trans-unit>
        <trans-unit id="3007ffc0d3f619ed4878713babc6bf385e75ed5b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the natural (base-</source>
          <target state="translated">如果没有发生错误,则自然(基数)。</target>
        </trans-unit>
        <trans-unit id="c09a1dd12c5becd1a78d62ef2eba3711b8030fb7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value not greater in magnitude than &lt;code&gt;arg&lt;/code&gt; (in other words, &lt;code&gt;arg&lt;/code&gt; rounded towards zero) is returned.</source>
          <target state="translated">如果没有错误发生，则返回幅度不大于 &lt;code&gt;arg&lt;/code&gt; 的最接近的整数值（换句话说， &lt;code&gt;arg&lt;/code&gt; 朝零舍入）。</target>
        </trans-unit>
        <trans-unit id="f769b27b09219929833064428bef0734a24648aa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">如果没有错误发生，则根据&lt;a href=&quot;../fenv/fe_round&quot;&gt;当前的舍入模式&lt;/a&gt;，返回最接近 &lt;code&gt;arg&lt;/code&gt; 的整数值。</target>
        </trans-unit>
        <trans-unit id="a0256d4c5a80036d6bc9fdb716345ed55c66ea11" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, rounding halfway cases away from zero, is returned.</source>
          <target state="translated">如果没有错误发生，则返回最接近 &lt;code&gt;arg&lt;/code&gt; 的整数值（舍入为零的一半）。</target>
        </trans-unit>
        <trans-unit id="2dcc36013b109d5eaf27751a51321acffdd6a03d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the next representable value of &lt;code&gt;from&lt;/code&gt; in the direction of &lt;code&gt;to&lt;/code&gt;. is returned. If &lt;code&gt;from&lt;/code&gt; equals &lt;code&gt;to&lt;/code&gt;, then &lt;code&gt;to&lt;/code&gt; is returned.</source>
          <target state="translated">如果没有发生错误，下一个可表示值 &lt;code&gt;from&lt;/code&gt; 在方向 &lt;code&gt;to&lt;/code&gt; 。返回。如果 &lt;code&gt;from&lt;/code&gt; 等于 &lt;code&gt;to&lt;/code&gt; ，则返回 &lt;code&gt;to&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0a7b391baa86594c7d0448266a28acb2668a4e8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the sine of &lt;code&gt;arg&lt;/code&gt; (sin(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; 的正弦（sin（arg））在[-1; +1]，返回。</target>
        </trans-unit>
        <trans-unit id="3fa7223cf61583336068c9d91991b4f9bedf8c7c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the smallest integer value not less than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lceil;arg&amp;rceil;, is returned.</source>
          <target state="translated">如果没有错误发生，则返回不小于 &lt;code&gt;arg&lt;/code&gt; 的最小整数值arg。</target>
        </trans-unit>
        <trans-unit id="941693082c1c679c39e6797e593c1a748bca9744" translate="yes" xml:space="preserve">
          <source>If no errors occur, the tangent of &lt;code&gt;arg&lt;/code&gt; (tan(arg)) is returned.</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;arg&lt;/code&gt; （tan（arg））的切线。</target>
        </trans-unit>
        <trans-unit id="8e15bc85bb52009c88f5c69e56b9a2471d950454" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed floating-point value.</source>
          <target state="translated">如果没有错误发生，则将 &lt;code&gt;arg&lt;/code&gt; 的无偏指数作为带符号浮点值返回。</target>
        </trans-unit>
        <trans-unit id="026d1df8b0b132c32fe387fe762cb8d1ea884358" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed int value.</source>
          <target state="translated">如果没有错误发生， &lt;code&gt;arg&lt;/code&gt; 有符号的int值形式返回arg的无偏指数。</target>
        </trans-unit>
        <trans-unit id="52dc1f3518fb2bced2d18acc2522443fc278caf6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is \(\mathsf{\Gamma}(arg) = \int_0^\infty t^{arg-1} e^{-t} \mathsf{d}t\)&amp;int;&amp;infin;</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; 的伽马函数值即\（\ mathsf {\ Gamma}（arg）= \ int_0 ^ \ infty t ^ {arg-1} e ^ {-t} \ mathsf {d } t \）&amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="17f4ff9a3637589c23bfc0b873e96c8630ea5296" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the logarithm of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is log</source>
          <target state="translated">如果没有错误发生，则为 &lt;code&gt;arg&lt;/code&gt; 的伽马函数的对数值，即log</target>
        </trans-unit>
        <trans-unit id="753b72c485945c6afd5db2fbcdff840651420e76" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the Riemann zeta function of &lt;code&gt;arg&lt;/code&gt;, &amp;zeta;(arg), defined for the entire real axis:</source>
          <target state="translated">如果没有错误发生，则为整个实轴定义的 &lt;code&gt;arg&lt;/code&gt; 的黎曼zeta函数的值&amp;zeta;（arg）：</target>
        </trans-unit>
        <trans-unit id="6801efcde3e466144a59b2e13c721de60eb9a8db" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the associated Laguerre polynomial of &lt;code&gt;x&lt;/code&gt;, that is \((-1)^m \: \frac{ \mathsf{d} ^ m}{ \mathsf{d}x ^ m} \, \mathsf{L}_{n+m}(x)\)(-1)m</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;x&lt;/code&gt; 的关联Laguerre多项式的值即\（（-1）^ m \：\ frac {\ mathsf {d} ^ m} {\ mathsf {d} x ^ m} \，\ mathsf {L} _ {n + m}（x）\）（-1）m</target>
        </trans-unit>
        <trans-unit id="b70f9e16b11c8009277ec11b877f36771c9cba33" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the associated Legendre polynomial \(\mathsf{P}_n^m\)Pm</source>
          <target state="translated">如果没有发生错误,则相关的Legendre多项式的值 ⑴(mathsf{P}_n^m/)Pm。</target>
        </trans-unit>
        <trans-unit id="238d4638a6406e5670a8756021c43a9a89528ae6" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the beta function of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, that is &amp;int;1</source>
          <target state="translated">如果没有错误，则 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的beta函数的值为&amp;int;1</target>
        </trans-unit>
        <trans-unit id="7f29a8300bf4d8be194d411485092bca1cff89a5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complementary error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">如果没有错误发生，则为 &lt;code&gt;arg&lt;/code&gt; 的互补错误函数的值，即</target>
        </trans-unit>
        <trans-unit id="df9c117eae172dac4ec6d5b52cce8a077d21f8a8" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the first kind of &lt;code&gt;k&lt;/code&gt;, that is &lt;code&gt;ellint_1(k,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">如果没有错误发生，则返回第一种 &lt;code&gt;k&lt;/code&gt; 的完整椭圆积分的值，即 &lt;code&gt;ellint_1(k,&amp;pi;/2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9cbeea440564c0733c80ec0f91528453bf57997d" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the second kind of &lt;code&gt;k&lt;/code&gt;, that is &lt;code&gt;ellint_2(k,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">如果没有错误发生，则返回第二种 &lt;code&gt;k&lt;/code&gt; 的完整椭圆积分的值，即 &lt;code&gt;ellint_2(k,&amp;pi;/2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="66c1ee451279e40e8fca9ad9ed4b42f5978e872c" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the third kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;nu;&lt;/code&gt;, that is &lt;code&gt;std::ellint_3(k,&amp;nu;,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">如果没有错误发生，则返回第三种 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;&amp;nu;&lt;/code&gt; 的完全椭圆积分的值，即 &lt;code&gt;std::ellint_3(k,&amp;nu;,&amp;pi;/2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a66e2b26fcc8bbc9cd86fdf7747135c750049f9c" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the cylindrical Bessel function of the first kind of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is J</source>
          <target state="translated">如果没有错误发生，则第一类 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的圆柱贝塞尔函数的值即J</target>
        </trans-unit>
        <trans-unit id="543182535183bd8bc0773d95ac751d4302a6fe06" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the cylindrical Neumann function (Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, is returned, that is N</source>
          <target state="translated">如果没有错误发生，则返回圆柱型Neumann函数（第二种贝塞尔函数）的 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的值，即N</target>
        </trans-unit>
        <trans-unit id="0658bf24f8b1dde223e35183fc409335d58b1a45" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">如果没有错误发生，则为 &lt;code&gt;arg&lt;/code&gt; 的错误函数的值，即</target>
        </trans-unit>
        <trans-unit id="9df1996268d06781fa476369becefdaadd629195" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the exponential integral of &lt;code&gt;arg&lt;/code&gt;, that is -&amp;int;&amp;infin;</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;arg&lt;/code&gt; 的指数积分的值即-&amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="12d4162f2889063b6a7da39429e27d5af98a2241" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the first kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">如果没有错误发生，则第一种 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;&amp;phi;&lt;/code&gt; 的不完整椭圆积分的值即&amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="f2687108220b1e44fef928c06fa5038f1e9ca385" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the second kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">如果没有错误发生，则第二种 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;&amp;phi;&lt;/code&gt; 的不完整椭圆积分的值即&amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="7ebd0beae76ba7f9e7e5a8530d1366439fe50ddc" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the third kind of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;&amp;nu;&lt;/code&gt;, and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">如果没有错误发生，则第三种 &lt;code&gt;k&lt;/code&gt; ， &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;&amp;phi;&lt;/code&gt; 的不完整椭圆积分的值，即&amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="47bf302c79b395741bf53556a6be82fa3fd028e9" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the irregular modified cylindrical Bessel function (modified Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, is returned, that is K</source>
          <target state="translated">如果没有错误发生，则返回 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的不规则修正圆柱Bessel函数（第二种修正Bessel函数）的值，即K</target>
        </trans-unit>
        <trans-unit id="aea1c8d887f4647bdb33eced1d1223c98eae241d" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the nonassociated Laguerre polynomial of &lt;code&gt;x&lt;/code&gt;, that is</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;x&lt;/code&gt; 的非关联Laguerre多项式的值，即</target>
        </trans-unit>
        <trans-unit id="6f5b17abebff553421278dbae1b01fcc098edc8f" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the order-&lt;code&gt;n&lt;/code&gt; unassociated Legendre polynomial of &lt;code&gt;x&lt;/code&gt;, that is \(\mathsf{P}_n(x) = \frac{1}{2^n n!} \frac{\mathsf{d}^n}{\mathsf{d}x^n} (x^2-1)^n \)</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;n&lt;/code&gt; 次未关联勒让德多项式的值，即\（\ mathsf {P} _n（x）= \ frac {1} {2 ^ nn！} \ frac {\ mathsf {d} ^ n} {\ mathsf {d} x ^ n}（x ^ 2-1）^ n \）</target>
        </trans-unit>
        <trans-unit id="5fe63011566ab90404ecbc2fc30a86fbf404e9b5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the order-&lt;code&gt;n&lt;/code&gt;Hermite polynomial of &lt;code&gt;x&lt;/code&gt;, that is (-1)n</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;x&lt;/code&gt; 的 Hermite多项式的值 &lt;code&gt;n&lt;/code&gt; ，即（-1）n</target>
        </trans-unit>
        <trans-unit id="521caff23698b2c47666d0e91701aa665925f3de" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the regular modified cylindrical Bessel function of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is I</source>
          <target state="translated">如果没有错误发生，则 &lt;code&gt;&amp;nu;&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 的正则修正圆柱贝塞尔函数的值即I</target>
        </trans-unit>
        <trans-unit id="031ce73d89df4a56cec229b26ace78aed68d756e" translate="yes" xml:space="preserve">
          <source>If no exception was thrown during input, sets the number of extracted characters (gcount) in the input stream.</source>
          <target state="translated">如果在输入过程中没有发生异常,则设置输入流中提取的字符数(gcount)。</target>
        </trans-unit>
        <trans-unit id="4c799e4f486ea142e7186bf650ea8a5b122a9d32" translate="yes" xml:space="preserve">
          <source>If no exception was thrown, returns &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">如果未引发异常，则返回 &lt;code&gt;*this&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d67368bbb57de9e88e241a4a9a8276ff5bf9165e" translate="yes" xml:space="preserve">
          <source>If no exception was thrown, returns the value specified by the function.</source>
          <target state="translated">如果没有发生异常,返回函数指定的值。</target>
        </trans-unit>
        <trans-unit id="1f75f70449c5d517f16e8db38a32eb7a472a99d1" translate="yes" xml:space="preserve">
          <source>If no initializer is provided, the rules of &lt;a href=&quot;default_initialization&quot;&gt;default initialization&lt;/a&gt; apply.</source>
          <target state="translated">如果未提供初始化程序，则适用&lt;a href=&quot;default_initialization&quot;&gt;默认初始化&lt;/a&gt;规则。</target>
        </trans-unit>
        <trans-unit id="51774f7adc99f180db60612981a5526941d80108" translate="yes" xml:space="preserve">
          <source>If no matches are found after all catch-clauses were examined, the exception propagation continues to the containing try-block, as described in &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;. If there are no containing try-blocks left, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is executed (in this case, it is implementation-defined whether any stack unwinding occurs at all: throwing an uncaught exception is permitted to terminate the program without invoking any destructors).</source>
          <target state="translated">如果在检查了所有捕获子句之后未找到匹配项，则异常传播将继续进行到包含try块，如&lt;a href=&quot;throw&quot;&gt;throw-expression中所述&lt;/a&gt;。如果没有剩余的try块，则执行 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; （在这种情况下，由实现定义，是否发生任何堆栈展开：允许抛出未捕获的异常来终止程序而无需调用任何析构函数）。</target>
        </trans-unit>
        <trans-unit id="85ed69b90bb670ce03358daa2e3280ab8a0acaef" translate="yes" xml:space="preserve">
          <source>If no memory could be allocated, or allocated storage is not enough to store a single element of type &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;first&lt;/code&gt; element of the result is a null pointer and the &lt;code&gt;second&lt;/code&gt; element is zero.</source>
          <target state="translated">如果无法分配内存，或者分配的存储空间不足以存储类型 &lt;code&gt;T&lt;/code&gt; 的单个元素，则结果的 &lt;code&gt;first&lt;/code&gt; 元素为空指针， &lt;code&gt;second&lt;/code&gt; 元素为零。</target>
        </trans-unit>
        <trans-unit id="9d359f89a70fe560ca132223fbd242fa45ae36ac" translate="yes" xml:space="preserve">
          <source>If no mismatches are found when the comparison reaches &lt;code&gt;last1&lt;/code&gt; or &lt;code&gt;last2&lt;/code&gt;, whichever happens first, the pair holds the end iterator and the corresponding iterator from the other range.</source>
          <target state="translated">如果在比较达到 &lt;code&gt;last1&lt;/code&gt; 或 &lt;code&gt;last2&lt;/code&gt; 时（以较早发生者为准）未找到不匹配项，则该对将保留结束迭代器和另一个范围中的相应迭代器。</target>
        </trans-unit>
        <trans-unit id="5a80ff055cfd93f4382626d501c63e2d0233080f" translate="yes" xml:space="preserve">
          <source>If no mismatches are found when the comparison reaches &lt;code&gt;last1&lt;/code&gt;, the pair holds &lt;code&gt;last1&lt;/code&gt; and the corresponding iterator from the second range. The behavior is undefined if the second range is shorter than the first range.</source>
          <target state="translated">如果在比较达到 &lt;code&gt;last1&lt;/code&gt; 时未找到不匹配项，则该对将保留 &lt;code&gt;last1&lt;/code&gt; 和第二个范围中的相应迭代器。如果第二个范围比第一个范围短，则行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="781fedf1bc7025a615d3c4ed7f1b4d2a7b74af04" translate="yes" xml:space="preserve">
          <source>If no preferred functions are found, the non-preferred ones are considered in the next step.</source>
          <target state="translated">如果没有找到首选函数,则在下一步考虑非首选函数。</target>
        </trans-unit>
        <trans-unit id="212c7248247dc34425f2118c2a6054de49eb5fd9" translate="yes" xml:space="preserve">
          <source>If no such character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and the future calls to &lt;code&gt;strtok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">如果找不到这样的字符，则 &lt;code&gt;str&lt;/code&gt; 只有一个令牌，将来对 &lt;code&gt;strtok&lt;/code&gt; 的调用将返回空指针</target>
        </trans-unit>
        <trans-unit id="e0e3f85b21f0603ccfad7c7630e2e6165f6efad1" translate="yes" xml:space="preserve">
          <source>If no such character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">如果找不到这样的字符，则 &lt;code&gt;str&lt;/code&gt; 中根本没有令牌，并且该函数返回空指针。</target>
        </trans-unit>
        <trans-unit id="32d0b18e53a062a7ffa1ce497fbf816f66e2daa5" translate="yes" xml:space="preserve">
          <source>If no such elements are found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到此类元素，则返回 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ef5b0f78fdffa741da1e2a6130af0d51d257860" translate="yes" xml:space="preserve">
          <source>If no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">如果找不到这样的序列，则返回 &lt;code&gt;last&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95318ca2ad225ff32e9ddd27aadd58f11c7c9bf8" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;std::wcstok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">如果找不到这样的宽字符，则 &lt;code&gt;str&lt;/code&gt; 只有一个令牌，将来对 &lt;code&gt;std::wcstok&lt;/code&gt; 调用将返回空指针</target>
        </trans-unit>
        <trans-unit id="d9fb4aef6036de9d69cd4d033e352d979c405074" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">如果找不到这样的宽字符，则 &lt;code&gt;str&lt;/code&gt; 中根本没有令牌，并且该函数返回空指针。</target>
        </trans-unit>
        <trans-unit id="40ac478406fa04d277853c0748ded82cd0ccce6d" translate="yes" xml:space="preserve">
          <source>If no user-declared constructors of any kind are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a default constructor as an &lt;code&gt;inline public&lt;/code&gt; member of its class.</source>
          <target state="translated">如果没有为类类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供任何用户声明的构造函数，则编译器将始终将默认构造函数声明为其类的 &lt;code&gt;inline public&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="7ad4343e0140e81303cc7ccdcdc20abcd1b3af02" translate="yes" xml:space="preserve">
          <source>If no user-declared destructor is provided for a &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a destructor as an &lt;code&gt;inline public&lt;/code&gt; member of its class.</source>
          <target state="translated">如果没有为&lt;a href=&quot;class&quot;&gt;类类型&lt;/a&gt;（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供用户声明的析构函数，则编译器将始终将析构函数声明为其类的 &lt;code&gt;inline public&lt;/code&gt; 成员。</target>
        </trans-unit>
        <trans-unit id="bb4a43dac5ef9eabbbba755dc09ed6605a9c36f6" translate="yes" xml:space="preserve">
          <source>If no user-defined constructors are present and the implicitly-declared default constructor is not trivial, the user may still inhibit the automatic generation of an implicitly-defined default constructor by the compiler with the keyword &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">如果不存在用户定义的构造函数，并且隐式声明的默认构造函数并不简单，则用户仍可以禁止编译器使用关键字 &lt;code&gt;delete&lt;/code&gt; 来自动生成隐式定义的默认构造函数。</target>
        </trans-unit>
        <trans-unit id="94c428bc493bfd4bf3cb4c40be6d006d6ae9320b" translate="yes" xml:space="preserve">
          <source>If no user-defined copy assignment operators are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare one as an inline public member of the class. This implicitly-declared copy assignment operator has the form &lt;code&gt;T&amp;amp; T::operator=(const T&amp;amp;)&lt;/code&gt; if all of the following is true:</source>
          <target state="translated">如果没有为类类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供用户定义的副本分配运算符，则编译器将始终将其中一个声明为该类的内联公共成员。如果满足以下所有条件，则此隐式声明的副本分配运算符的形式为 &lt;code&gt;T&amp;amp; T::operator=(const T&amp;amp;)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="851c19dced47a32ee3f0fdfb9f639786302ce9fb" translate="yes" xml:space="preserve">
          <source>If no user-defined copy constructors are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a copy constructor as a non-&lt;a href=&quot;explicit&quot;&gt;explicit&lt;/a&gt;&lt;code&gt;inline public&lt;/code&gt; member of its class. This implicitly-declared copy constructor has the form &lt;code&gt;T::T(const T&amp;amp;)&lt;/code&gt; if all of the following are true:</source>
          <target state="translated">如果没有为类类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供用户定义的副本构造函数，则编译器将始终将副本构造函数声明为其类的非&lt;a href=&quot;explicit&quot;&gt;显式&lt;/a&gt; &lt;code&gt;inline public&lt;/code&gt; 成员。如果满足以下所有条件，则此隐式声明的副本构造函数的形式为 &lt;code&gt;T::T(const T&amp;amp;)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b4fd8cb3d9cb59c45a27ed26df217a6fe2527317" translate="yes" xml:space="preserve">
          <source>If no user-defined move assignment operators are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), and all of the following is true:</source>
          <target state="translated">如果没有为类类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供用户定义的移动分配运算符，并且以下所有条件均成立：</target>
        </trans-unit>
        <trans-unit id="d13ec6ee9e77a6e3545912f76a282bde870c425b" translate="yes" xml:space="preserve">
          <source>If no user-defined move constructors are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), and all of the following is true:</source>
          <target state="translated">如果没有为类类型（ &lt;code&gt;struct&lt;/code&gt; ， &lt;code&gt;class&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）提供用户定义的move构造函数，则以下所有条件均成立：</target>
        </trans-unit>
        <trans-unit id="12fccd1db64bc403607d3dd62463e20e8242d5d4" translate="yes" xml:space="preserve">
          <source>If non-default allocators are intended to be supported for the allocation of the implementation object, any of the usual allocator awareness patterns may be utilized, including allocator template parameter defaulting to &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; and constructor argument of type &lt;a href=&quot;../memory/memory_resource&quot;&gt;&lt;code&gt;std::pmr::memory_resource*&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果打算为实现对象的分配支持非默认分配器，则可以使用任何通常的分配器感知模式，包括默认为 &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; 分配器模板参数和类型为&lt;a href=&quot;../memory/memory_resource&quot;&gt; &lt;code&gt;std::pmr::memory_resource*&lt;/code&gt; &lt;/a&gt;构造函数参数。memory_resource *。</target>
        </trans-unit>
        <trans-unit id="9e7a52425c4552c258484ec30442892b69acfcad" translate="yes" xml:space="preserve">
          <source>If not empty, destroys the contained object.</source>
          <target state="translated">如果不为空,则销毁包含的对象。</target>
        </trans-unit>
        <trans-unit id="46f7a7c5951af943707abba8135020cebc9f7870" translate="yes" xml:space="preserve">
          <source>If object is a non-bit-field rvalue or a function lvalue, and its type is either &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, equally or less cv-qualified, then the reference is bound to the value of the initializer expression or to its base subobject (after &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializing a temporary&lt;/a&gt; if necessary)(since C++17).</source>
          <target state="translated">如果object是非位字段右值或函数左值，并且其类型是 &lt;code&gt;T&lt;/code&gt; 或从 &lt;code&gt;T&lt;/code&gt; 派生（等于或小于cv限定），则该引用将绑定到初始化程序表达式的值或其基本子对象（在必要时&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;实现临时文件&lt;/a&gt;）（自C ++ 17起）。</target>
        </trans-unit>
        <trans-unit id="a3d00b46e93a04f762ceacf129a7d8e708f9cdae" translate="yes" xml:space="preserve">
          <source>If object is an lvalue expression, and its type is &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, and is equally or less cv-qualified, then the reference is bound to the object identified by the lvalue or to its base class subobject.</source>
          <target state="translated">如果object是一个左值表达式，并且其类型是 &lt;code&gt;T&lt;/code&gt; 或从 &lt;code&gt;T&lt;/code&gt; 派生，并且具有相等或更少的cv限定，则该引用将绑定到由左值标识的对象或其基类子对象。</target>
        </trans-unit>
        <trans-unit id="aa22f5451003f7660daffd02d5df19ccf7abfc20" translate="yes" xml:space="preserve">
          <source>If one evaluation modifies a memory location, and the other reads or modifies the same memory location, and if at least one of the evaluations is not an atomic operation, the behavior of the program is undefined (the program has a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) unless there exists a</source>
          <target state="translated">如果一个评估修改了一个内存位置，另一个评估读取或修改了相同的存储位置，并且如果至少一个评估不是原子操作，则除非定义了该行为，否则该程序的行为是不确定的（该程序具有&lt;a href=&quot;../language/memory_model&quot;&gt;数据争用&lt;/a&gt;）。存在一个</target>
        </trans-unit>
        <trans-unit id="e3ee4df0d28305af8190dfed503a69842ecdea1b" translate="yes" xml:space="preserve">
          <source>If one of the operands is of type &lt;code&gt;bool&lt;/code&gt; and the other is not, the program is ill-formed.</source>
          <target state="translated">如果其中一个操作数的类型为 &lt;code&gt;bool&lt;/code&gt; ，而另一个则不是，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="2677ad2fee54206928d1289296944052d7155f2a" translate="yes" xml:space="preserve">
          <source>If one of the strings has an encoding prefix and the other doesn't, the one that doesn't will be considered to have the same encoding prefix as the other.</source>
          <target state="translated">如果其中一个字符串有编码前缀而另一个没有,那么没有编码前缀的那个字符串将被认为与另一个字符串有相同的编码前缀。</target>
        </trans-unit>
        <trans-unit id="5394cec101ec494404d07198530eec4ab37c59ad" translate="yes" xml:space="preserve">
          <source>If one of the two arguments is NaN, the value of the other argument is returned</source>
          <target state="translated">如果两个参数中的一个是NaN,则返回另一个参数的值。</target>
        </trans-unit>
        <trans-unit id="41700bbfc9368c2b5358e57134ccfd94d1f553f5" translate="yes" xml:space="preserve">
          <source>If one range is a prefix of another, the shorter range is lexicographically</source>
          <target state="translated">如果一个范围是另一个范围的前缀,较短的范围在词法上是</target>
        </trans-unit>
        <trans-unit id="dcc36215317b874404f96885cfc95439d29a3922" translate="yes" xml:space="preserve">
          <source>If only one function is left, that function is selected.</source>
          <target state="translated">如果只剩下一个函数,则选择该函数。</target>
        </trans-unit>
        <trans-unit id="58314a8e7e0dda6a0f7693f28a3be7368beb7517" translate="yes" xml:space="preserve">
          <source>If only one of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contains a value (let's call this object &lt;code&gt;in&lt;/code&gt; and the other &lt;code&gt;un&lt;/code&gt;), the contained value of &lt;code&gt;un&lt;/code&gt; is &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; from &lt;code&gt;std::move(*in)&lt;/code&gt;, followed by destruction of the contained value of &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;in-&amp;gt;T::~T()&lt;/code&gt;. After this call, &lt;code&gt;in&lt;/code&gt; does not contain a value; &lt;code&gt;un&lt;/code&gt; contains a value.</source>
          <target state="translated">如果只有一个 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 包含一个值（我们称之为对象 &lt;code&gt;in&lt;/code&gt; 与其他 &lt;code&gt;un&lt;/code&gt; ）中，所包含的价值 &lt;code&gt;un&lt;/code&gt; 是&lt;a href=&quot;../../language/direct_initialization&quot;&gt;直接初始化&lt;/a&gt;从 &lt;code&gt;std::move(*in)&lt;/code&gt; ，随后是所包含的价值的毁灭 &lt;code&gt;in&lt;/code&gt; 仿佛通过 &lt;code&gt;in-&amp;gt;T::~T()&lt;/code&gt; 。调用之后， &lt;code&gt;in&lt;/code&gt; 中不包含值； &lt;code&gt;un&lt;/code&gt; 包含一个值。</target>
        </trans-unit>
        <trans-unit id="38fac4f8f19905bafe2c9ea62d2092290cb1aaea" translate="yes" xml:space="preserve">
          <source>If only one of the two function templates being compared is a member function , and that function template is a non-static member of some class &lt;code&gt;A&lt;/code&gt;, a new first parameter is inserted into its parameter list, whose type is &lt;code&gt;cv A&amp;amp;&amp;amp;&lt;/code&gt; if the member function template is &amp;amp;&amp;amp;-qualified and &lt;code&gt;cv A&amp;amp;&lt;/code&gt; otherwise (cv is the cv-qualification of the member function template) -- this helps the ordering of operators, which are looked up both as member and as non-member functions:</source>
          <target state="translated">如果要比较的两个函数模板中只有一个是成员函数，并且该函数模板是某个 &lt;code&gt;A&lt;/code&gt; 类的非静态成员，则将新的第一个参数插入其参数列表，如果该成员函数的类型为 &lt;code&gt;cv A&amp;amp;&amp;amp;&lt;/code&gt; 模板是&amp;amp;&amp;amp;-qualified和 &lt;code&gt;cv A&amp;amp;&lt;/code&gt; 否则（cv是成员函数模板的cv-qualification）-这有助于对运算符进行排序，这些运算符既可以作为成员函数也可以作为非成员函数进行查找：</target>
        </trans-unit>
        <trans-unit id="ec7712843cd5f938f1aba16750b9a0671c8585bc" translate="yes" xml:space="preserve">
          <source>If other is an rvalue expression, &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt; will be selected by overload resolution and called during copy-initialization. There is no such term as move-initialization.</source>
          <target state="translated">如果other是右值表达式，则将通过重载分辨率选择&lt;a href=&quot;move_constructor&quot;&gt;move构造函数&lt;/a&gt;，并在复制初始化期间调用它。没有诸如移动初始化之类的术语。</target>
        </trans-unit>
        <trans-unit id="9ddc5ecaabd07bdd4041442caa75864db6c6d691" translate="yes" xml:space="preserve">
          <source>If overflow occurs, the behavior is undefined.</source>
          <target state="translated">如果发生溢出,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="750847988fad756b2797b04ab539da8a7a039e9f" translate="yes" xml:space="preserve">
          <source>If overload resolution selects an inherited constructor, it is accessible if it would be accessible when used to construct an object of the corresponding base class: the accessibility of the using-declaration that introduced it is ignored.</source>
          <target state="translated">如果重载解析选择了一个继承的构造函数,那么当它被用于构造相应基类的对象时,它是可访问的:忽略引入它的使用声明的可访问性。</target>
        </trans-unit>
        <trans-unit id="210ca7809f61451a624d2c6beec2bcb2c768f5c6" translate="yes" xml:space="preserve">
          <source>If overload resolution selects one of the inherited constructors when initializing an object of such derived class, then the &lt;code&gt;Base&lt;/code&gt; subobject from which the constructor was inherited is initialized using the inherited constructor, and all other bases and members of &lt;code&gt;Derived&lt;/code&gt; are initialized as if by the defaulted default constructor (default member initializers are used if provided, otherwise default initialization takes place). The entire initialization is treated as a single function call: initialization of the parameters of the inherited constructor is sequenced-before initialization of any base or member of the derived object.</source>
          <target state="translated">如果重载解析在初始化此类派生类的对象时选择了继承的构造函数之一，则使用继承的构造函数初始化从其继承构造函数的 &lt;code&gt;Base&lt;/code&gt; 子对象，并像默认情况下一样初始化所有其他 &lt;code&gt;Derived&lt;/code&gt; 的基和成员。默认构造函数（如果提供，则使用默认成员初始化器，否则将进行默认初始化）。整个初始化被视为单个函数调用：在初始化派生对象的任何基或成员之前，将对继承的构造函数的参数进行初始化。</target>
        </trans-unit>
        <trans-unit id="569b041ed62609471e4536cb80335e9cadb562bd" translate="yes" xml:space="preserve">
          <source>If possible, constructs an object of type &lt;code&gt;T&lt;/code&gt; in allocated uninitialized storage pointed to by &lt;code&gt;p&lt;/code&gt;, by calling.</source>
          <target state="translated">如果可能，通过调用在 &lt;code&gt;p&lt;/code&gt; 指向的分配的未初始化存储中构造 &lt;code&gt;T&lt;/code&gt; 类型的对象。</target>
        </trans-unit>
        <trans-unit id="7bd19a7c8b0277a43bb96d2aa204eaa9e1df26a8" translate="yes" xml:space="preserve">
          <source>If possible, obtains the copy-constructed version of the allocator &lt;code&gt;a&lt;/code&gt;, by calling &lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt;. If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;select_on_container_copy_construction()&lt;/code&gt;, then returns &lt;code&gt;a&lt;/code&gt;, unmodified.</source>
          <target state="translated">如果可能，通过调用 &lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt; 获得分配器 &lt;code&gt;a&lt;/code&gt; 的副本构造版本。如果以上操作不可能（例如 &lt;code&gt;a&lt;/code&gt; 没有成员函数 &lt;code&gt;select_on_container_copy_construction()&lt;/code&gt; )，则返回 &lt;code&gt;a&lt;/code&gt; ，未修改。</target>
        </trans-unit>
        <trans-unit id="c2bb51f991f1f844a514dcdb161773a64461aa00" translate="yes" xml:space="preserve">
          <source>If possible, obtains the maximum theoretically possible allocation size from the allocator &lt;code&gt;a&lt;/code&gt;, by calling.</source>
          <target state="translated">如果可能，通过调用从分配器 &lt;code&gt;a&lt;/code&gt; 获得理论上可能的最大分配大小。</target>
        </trans-unit>
        <trans-unit id="e98d09928ca05eb652c54751fcdfc483c6a1ba29" translate="yes" xml:space="preserve">
          <source>If present, the &lt;code&gt;hash&lt;/code&gt; parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking &lt;code&gt;&lt;a href=&quot;hash_function&quot;&gt;hash_function()&lt;/a&gt;&lt;/code&gt; on the key passed do not produce the same value as &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">如果存在，则 &lt;code&gt;hash&lt;/code&gt; 参数可以用于传递预先计算的散列值作为优化。如果在传递的键上调用 &lt;code&gt;&lt;a href=&quot;hash_function&quot;&gt;hash_function()&lt;/a&gt;&lt;/code&gt; 不会产生与 &lt;code&gt;hash&lt;/code&gt; 相同的值，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="b615c53ecc545ad86db4eb50538fd76266abf064" translate="yes" xml:space="preserve">
          <source>If present, the &lt;code&gt;hash&lt;/code&gt; parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking &lt;code&gt;hash_function()&lt;/code&gt; on the key passed do not produce the same value as &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">如果存在，则 &lt;code&gt;hash&lt;/code&gt; 参数可以用于传递预先计算的散列值作为优化。如果在传递的键上调用 &lt;code&gt;hash_function()&lt;/code&gt; 不会产生与 &lt;code&gt;hash&lt;/code&gt; 相同的值，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="d0ad3998a5ac30264cf943a5c000f09e6f5af44e" translate="yes" xml:space="preserve">
          <source>If prior to the call &lt;code&gt;*this&lt;/code&gt; has an associated mutex and has acquired ownership of it, the mutex is unlocked.</source>
          <target state="translated">如果在呼叫之前 &lt;code&gt;*this&lt;/code&gt; 具有关联的互斥锁并已获得其所有权，则该互斥锁将被解锁。</target>
        </trans-unit>
        <trans-unit id="5bdd482f92ba03cbf032a677ef80f876bd9e89d4" translate="yes" xml:space="preserve">
          <source>If putback position was available, returns the character that the next pointer is now pointing at, converted to &lt;code&gt;int_type&lt;/code&gt; with &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;. The next single-character input from this streambuf will return this character.</source>
          <target state="translated">如果有回退位置，则返回下一个指针现在指向的字符，并通过 &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; 转换为 &lt;code&gt;int_type&lt;/code&gt; 。此streambuf中的下一个单字符输入将返回此字符。</target>
        </trans-unit>
        <trans-unit id="3eb692c025338041e4eed4f9319cfb04b675d552" translate="yes" xml:space="preserve">
          <source>If putback position was not available, returns what &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; returns, which is &lt;code&gt;Traits::eof()&lt;/code&gt; on failure.</source>
          <target state="translated">如果没有回 &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; 位置，则返回pbackfail（）返回的值，失败时返回 &lt;code&gt;Traits::eof()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd77c426f218dbc4996392b11cbf4a9df041bd55" translate="yes" xml:space="preserve">
          <source>If range_expression is an expression of a class type &lt;code&gt;C&lt;/code&gt; that has both a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt; (regardless of the type or accessibility of such member), then</source>
          <target state="translated">如果range_expression是类类型 &lt;code&gt;C&lt;/code&gt; 的表达式，同时具有名为 &lt;code&gt;begin&lt;/code&gt; 的成员和名为 &lt;code&gt;end&lt;/code&gt; 的成员（无论该成员的类型或可访问性如何），则</target>
        </trans-unit>
        <trans-unit id="a31a47abbcbe52c11cb5aabb738ee006961c36bf" translate="yes" xml:space="preserve">
          <source>If range_expression is an expression of array type, then</source>
          <target state="translated">如果range_expression是一个数组类型的表达式,那么</target>
        </trans-unit>
        <trans-unit id="8998880636aec0b41e1f3aa9bb5068fe2d087a45" translate="yes" xml:space="preserve">
          <source>If range_expression returns a temporary, its lifetime is extended until the end of the loop, as indicated by binding to the forwarding reference &lt;b&gt;&lt;code&gt;__range&lt;/code&gt;&lt;/b&gt;, but beware that the lifetime of any temporary within range_expression</source>
          <target state="translated">如果range_expression返回一个临时变量，则其生存期会延长到循环结束，如绑定到转发参考&lt;b&gt; &lt;code&gt;__range&lt;/code&gt; 所示&lt;/b&gt;，但要注意&lt;b&gt;range_expression&lt;/b&gt;中任何临时变量的生存期</target>
        </trans-unit>
        <trans-unit id="831b1dfec868a21157a075677fd82a9bf6d69aa8" translate="yes" xml:space="preserve">
          <source>If rdbuf() is a null pointer, does nothing.</source>
          <target state="translated">如果rdbuf()是一个空指针,则不做任何操作。</target>
        </trans-unit>
        <trans-unit id="1b1e7d795c25e0720f46207c35f854b7bc6a7349" translate="yes" xml:space="preserve">
          <source>If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.</source>
          <target state="translated">如果发生重配,所有迭代器,包括过去的结束迭代器,以及所有对元素的引用都无效。如果没有发生重分配,则没有迭代器或引用无效。</target>
        </trans-unit>
        <trans-unit id="b5722a09effa0795d91444af4d2753abca8a7e18" translate="yes" xml:space="preserve">
          <source>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="translated">如果由于插入而发生了重新哈希处理，则所有迭代器均无效。否则，迭代器不会受到影响。引用没有无效。仅当新的元素数量大于 &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; 时,才会进行哈希处理。</target>
        </trans-unit>
        <trans-unit id="b48960c4455b015acecf76682b1d33d5044e8f1b" translate="yes" xml:space="preserve">
          <source>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.(since C++17).</source>
          <target state="translated">如果由于插入而发生了重新哈希处理，则所有迭代器均无效。否则，迭代器不会受到影响。引用没有无效。仅当新的元素数量大于 &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; 时,才会进行哈希处理。如果插入成功，则将其保留在节点句柄中时获得的指向该元素的指针和引用无效，并且在提取该元素之前获得的指向该元素的指针和引用变为有效。（从C ++ 17开始）。</target>
        </trans-unit>
        <trans-unit id="e5803322a669884d371a27e94b8e3347c4a1e0b8" translate="yes" xml:space="preserve">
          <source>If removing references and cv-qualifiers from &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;P'&amp;gt;&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;list_initialization&quot;&gt;braced-init-list&lt;/a&gt;, then deduction is performed for every element of the initializer list, taking &lt;code&gt;P'&lt;/code&gt; as the parameter and the list element &lt;code&gt;A'&lt;/code&gt; as the argument:</source>
          <target state="translated">如果从 &lt;code&gt;P&lt;/code&gt; 删除引用和cv限定词给出 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;P'&amp;gt;&lt;/code&gt; 并且 &lt;code&gt;A&lt;/code&gt; 是&lt;a href=&quot;list_initialization&quot;&gt;bracing-init-list&lt;/a&gt;，则对初始化列表的每个元素进行推导，以 &lt;code&gt;P'&lt;/code&gt; 作为参数，并使用list元素 &lt;code&gt;A'&lt;/code&gt; 作为参数：</target>
        </trans-unit>
        <trans-unit id="4023bf4d1f43d575e2d6327b1416c5ed7d9cb751" translate="yes" xml:space="preserve">
          <source>If removing references and cv-qualifiers from &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;P'&lt;/code&gt;[&lt;code&gt;N&lt;/code&gt;], and &lt;code&gt;A&lt;/code&gt; is a non-empty braced-init-list, then deduction is performed as above, except if &lt;code&gt;N&lt;/code&gt; is a non-type template parameter, it is deduced from the length of the initializer list:</source>
          <target state="translated">如果从 &lt;code&gt;P&lt;/code&gt; 删除引用和cv限定词得到 &lt;code&gt;P'&lt;/code&gt; [ &lt;code&gt;N&lt;/code&gt; ]，并且 &lt;code&gt;A&lt;/code&gt; 是非空的括号初始列表，则按上述方法进行推导，除非 &lt;code&gt;N&lt;/code&gt; 是非类型的模板参数，否则推导从初始化列表的长度开始：</target>
        </trans-unit>
        <trans-unit id="3e746f9c695cdf56415555b25b2b13ebeeb30b4c" translate="yes" xml:space="preserve">
          <source>If searching for an empty string (&lt;code&gt;str.size()&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, or &lt;code&gt;Traits::length(s)&lt;/code&gt; is zero) returns &lt;code&gt;pos&lt;/code&gt; (the empty string is found immediately) unless &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; (including the case where &lt;code&gt;pos == npos&lt;/code&gt;), in which case returns &lt;code&gt;size()&lt;/code&gt;.</source>
          <target state="translated">如果搜索空字符串（ &lt;code&gt;str.size()&lt;/code&gt; ， &lt;code&gt;count&lt;/code&gt; 或 &lt;code&gt;Traits::length(s)&lt;/code&gt; 为零），则返回 &lt;code&gt;pos&lt;/code&gt; （立即找到空字符串），除非 &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; （包括 &lt;code&gt;pos == npos&lt;/code&gt; 的情况）npos），则返回 &lt;code&gt;size()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8032ef45e981f5ae9ab731c15293224cc1be4894" translate="yes" xml:space="preserve">
          <source>If side-effect A is visible with respect to the value computation B, then the longest contiguous subset of the side-effects to M, in</source>
          <target state="translated">如果侧效应A相对于值计算B可见,那么侧效应对M的最长连续子集,在</target>
        </trans-unit>
        <trans-unit id="a813fcc7c976b042560912c3cfabd51324dc8cdf" translate="yes" xml:space="preserve">
          <source>If some &lt;a href=&quot;value_category&quot;&gt;glvalue expression&lt;/a&gt; refers to a &lt;a href=&quot;objects&quot;&gt;polymorphic object&lt;/a&gt;, the type of its most derived object is known as the dynamic type.</source>
          <target state="translated">如果某个&lt;a href=&quot;value_category&quot;&gt;glvalue表达式&lt;/a&gt;引用了一个&lt;a href=&quot;objects&quot;&gt;多态对象&lt;/a&gt;，则其最派生对象的类型称为动态类型。</target>
        </trans-unit>
        <trans-unit id="eee5be8ef339e31668583c5122cb3ea37abcf9da" translate="yes" xml:space="preserve">
          <source>If some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;std::abs(m-n)&lt;/code&gt; times. If &lt;code&gt;m&amp;gt;n&lt;/code&gt;, then the last &lt;code&gt;m-n&lt;/code&gt; of those elements are copied from &lt;code&gt;[first1,last1)&lt;/code&gt;, otherwise the last &lt;code&gt;n-m&lt;/code&gt; elements are copied from &lt;code&gt;[first2,last2)&lt;/code&gt;. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">如果某些元件是发现 &lt;code&gt;m&lt;/code&gt; 倍 &lt;code&gt;[first1, last1)&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 在倍 &lt;code&gt;[first2, last2)&lt;/code&gt; ，它会被复制到 &lt;code&gt;d_first&lt;/code&gt; 准确 &lt;code&gt;std::abs(m-n)&lt;/code&gt; 次。如果 &lt;code&gt;m&amp;gt;n&lt;/code&gt; ，则从 &lt;code&gt;[first1,last1)&lt;/code&gt; 复制这些元素的最后 &lt;code&gt;m-n&lt;/code&gt; ，否则从 &lt;code&gt;[first2,last2)&lt;/code&gt; 复制最后 &lt;code&gt;n-m&lt;/code&gt; 元素。结果范围不能与任何一个输入范围重叠。</target>
        </trans-unit>
        <trans-unit id="caf2cbf83a05e60a4bb97a0592549e75d93ad63b" translate="yes" xml:space="preserve">
          <source>If some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, then all &lt;code&gt;m&lt;/code&gt; elements will be copied from &lt;code&gt;[first1, last1)&lt;/code&gt; to &lt;code&gt;d_first&lt;/code&gt;, preserving order, and then exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n-m, 0)&lt;/code&gt; elements will be copied from &lt;code&gt;[first2, last2)&lt;/code&gt; to &lt;code&gt;d_first&lt;/code&gt;, also preserving order.</source>
          <target state="translated">如果某些元件是发现 &lt;code&gt;m&lt;/code&gt; 在倍 &lt;code&gt;[first1, last1)&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 倍 &lt;code&gt;[first2, last2)&lt;/code&gt; ，则所有 &lt;code&gt;m&lt;/code&gt; 的元素将被从复制 &lt;code&gt;[first1, last1)&lt;/code&gt; 到 &lt;code&gt;d_first&lt;/code&gt; ，维护订单，然后恰好 &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n-m, 0)&lt;/code&gt; 元素将从 &lt;code&gt;[first2, last2)&lt;/code&gt; 复制到 &lt;code&gt;d_first&lt;/code&gt; ，同时保留顺序。</target>
        </trans-unit>
        <trans-unit id="67873cc8d634e461cb815d4a8417a686c3237eb4" translate="yes" xml:space="preserve">
          <source>If some member function &lt;code&gt;vf&lt;/code&gt; is declared as &lt;code&gt;virtual&lt;/code&gt; in a class &lt;code&gt;Base&lt;/code&gt;, and some class &lt;code&gt;Derived&lt;/code&gt;, which is derived, directly or indirectly, from &lt;code&gt;Base&lt;/code&gt;, has a declaration for member function with the same.</source>
          <target state="translated">如果在 &lt;code&gt;Base&lt;/code&gt; 类中将某个成员函数 &lt;code&gt;vf&lt;/code&gt; 声明为 &lt;code&gt;virtual&lt;/code&gt; 函数，而直接或间接从 &lt;code&gt;Base&lt;/code&gt; &lt;code&gt;Derived&lt;/code&gt; 某个类Derived对成员函数声明了相同的函数。</target>
        </trans-unit>
        <trans-unit id="e561cbd21051ae04ee69688d91773e4d66564214" translate="yes" xml:space="preserve">
          <source>If some of the arguments that are supplied in the call to &lt;code&gt;g()&lt;/code&gt; are not matched by any placeholders stored in &lt;code&gt;g&lt;/code&gt;, the unused arguments are evaluated and discarded.</source>
          <target state="translated">如果某些被在调用提供的参数 &lt;code&gt;g()&lt;/code&gt; 不被存储在任何占位符匹配 &lt;code&gt;g&lt;/code&gt; ，未使用的参数进行评估，并丢弃。</target>
        </trans-unit>
        <trans-unit id="c16f0b9646e0495cf7360c2d57ef97bff686bc4e" translate="yes" xml:space="preserve">
          <source>If some user-declared constructors are present, the user may still force the automatic generation of a default constructor by the compiler that would be implicitly-declared otherwise with the keyword &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果存在一些用户声明的构造函数，则用户仍可以强制编译器自动生成默认构造函数，否则将使用关键字 &lt;code&gt;default&lt;/code&gt; 隐式声明默认构造函数。</target>
        </trans-unit>
        <trans-unit id="81f7a3f627cd87e8bf750cf042cc3a980725dec5" translate="yes" xml:space="preserve">
          <source>If some user-defined constructors are present, the user may still force the automatic generation of a default constructor by the compiler that would be implicitly-declared otherwise with the keyword &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">如果存在一些用户定义的构造函数，则用户仍可以强制编译器自动生成默认构造函数，否则将使用关键字 &lt;code&gt;default&lt;/code&gt; 隐式声明该默认构造函数。</target>
        </trans-unit>
        <trans-unit id="4f89b2e39dc991aa70988548f099b5134242e0c1" translate="yes" xml:space="preserve">
          <source>If statement is a single statement (not a compound statement), the scope of variables declared in it is limited to the while loop as if it was a compound statement, in other words,</source>
          <target state="translated">如果语句是一条单语句(不是复合语句),那么在其中声明的变量范围仅限于while循环,就像它是一条复合语句一样,换句话说。</target>
        </trans-unit>
        <trans-unit id="de8e6184779d6e772f3df1e2bc68eaa83374bf85" translate="yes" xml:space="preserve">
          <source>If statement-true is entered by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; or &lt;code&gt;longjmp&lt;/code&gt;, statement_false is not executed.</source>
          <target state="translated">如果&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;或 &lt;code&gt;longjmp&lt;/code&gt; 输入了statement-true ，则不会执行statement_false。</target>
        </trans-unit>
        <trans-unit id="5e2cbc4d6a00d3a75286c31bf804d8bad59194eb" translate="yes" xml:space="preserve">
          <source>If statement_true or statement_false is not a compound statement, it is treated as if it were:</source>
          <target state="translated">如果statement_true或statement_false不是复合语句,则视同复合语句。</target>
        </trans-unit>
        <trans-unit id="834b8d6940f6e20e10043e602b81088e525449aa" translate="yes" xml:space="preserve">
          <source>If successful, an integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="translated">如果成功，则返回对应于 &lt;code&gt;str&lt;/code&gt; 内容的整数值。</target>
        </trans-unit>
        <trans-unit id="25bfeb839d8f5173b50bb285122b4cc54720321c" translate="yes" xml:space="preserve">
          <source>If successful, returns a pointer to the object that controls the opened file stream, with both eof and error bits cleared. The stream is fully buffered unless filename refers to an interactive device.</source>
          <target state="translated">如果成功,返回一个指向控制打开的文件流的对象的指针,同时清除eof和错误位。除非文件名是指交互式设备,否则流是完全缓冲的。</target>
        </trans-unit>
        <trans-unit id="5632ad995e8027aefc150ef8436b23c84c4578ae" translate="yes" xml:space="preserve">
          <source>If successful, returns the IEEE floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">如果成功，则返回除法 &lt;code&gt;x/y&lt;/code&gt; 的IEEE浮点余数，如上所述。</target>
        </trans-unit>
        <trans-unit id="7ba7ac810951fe3d89eb854fd7520e591880a573" translate="yes" xml:space="preserve">
          <source>If successful, returns the absolute value of &lt;code&gt;arg&lt;/code&gt; (&lt;code&gt;|arg|&lt;/code&gt;). The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;arg&lt;/code&gt; （ &lt;code&gt;|arg|&lt;/code&gt; ）的绝对值。返回的值是准确的，并且不依赖于任何舍入模式。</target>
        </trans-unit>
        <trans-unit id="a595b23fd21a8f04c669747846486d0e27d71af0" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">如果成功，则返回除法 &lt;code&gt;x/y&lt;/code&gt; 的浮点余数，如上所述。</target>
        </trans-unit>
        <trans-unit id="03e429269f7181e14b033dacb9e7bf8c7396151a" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt;, and stores, in &lt;code&gt;*quo&lt;/code&gt;, the sign and at least three of the least significant bits of &lt;code&gt;x/y&lt;/code&gt; (formally, stores a value whose sign is the sign of &lt;code&gt;x/y&lt;/code&gt; and whose magnitude is congruent modulo 2n</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; 定义的 &lt;code&gt;x/y&lt;/code&gt; 除法的浮点余数，并将符号和 &lt;code&gt;x/y&lt;/code&gt; 的至少三个最低有效位存储在 &lt;code&gt;*quo&lt;/code&gt; 中（形式上，存储a其符号为 &lt;code&gt;x/y&lt;/code&gt; 的符号且幅度为2n模的全等值</target>
        </trans-unit>
        <trans-unit id="ea98bbdcb76a97fab4ef9d6ca9c32eecbe479081" translate="yes" xml:space="preserve">
          <source>If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">如果成功,返回两个浮点值中较大的一个。返回的值是精确的,不依赖于任何四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="9423b4432f6a645ec2473ed82b459b6686deb60f" translate="yes" xml:space="preserve">
          <source>If successful, returns the positive difference between x and y.</source>
          <target state="translated">如果成功,返回x和y的正差。</target>
        </trans-unit>
        <trans-unit id="46138f9b406992b59d0f9492f2e64a28cf85480b" translate="yes" xml:space="preserve">
          <source>If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">如果成功,返回两个浮点值中的较小值。返回的值是精确的,不依赖于任何四舍五入模式。</target>
        </trans-unit>
        <trans-unit id="5ca1e3a726f6c442c2b326f76a16b023bb9441ee" translate="yes" xml:space="preserve">
          <source>If successful, returns the value of &lt;code&gt;(x*y) + z&lt;/code&gt; as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).</source>
          <target state="translated">如果成功，则返回 &lt;code&gt;(x*y) + z&lt;/code&gt; 的值，就好像计算为无穷精度，并四舍五入一次以适合结果类型（或者，作为单个三元浮点运算来计算）。</target>
        </trans-unit>
        <trans-unit id="44139e51119b7719b4d6c2c45a98ecd6bcfaac63" translate="yes" xml:space="preserve">
          <source>If such a specialization has a member named &lt;code&gt;type&lt;/code&gt;, it must be a public and unambiguous member type that names a cv-unqualified non-reference type to which both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are explicitly convertible. Additionally, &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; and &lt;code&gt;std::common_type&amp;lt;T2, T1&amp;gt;::type&lt;/code&gt; must denote the same type.</source>
          <target state="translated">如果这样的专门化具有名为 &lt;code&gt;type&lt;/code&gt; 的成员，则它必须是公开且明确的成员类型，该成员类型命名cv不合格的非引用类型， &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; 都可以明确转换为该类型。此外， &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; 和 &lt;code&gt;std::common_type&amp;lt;T2, T1&amp;gt;::type&lt;/code&gt; 必须表示相同的类型。</target>
        </trans-unit>
        <trans-unit id="3a37148d1443f4a7f83a98b72097fe4c825195aa" translate="yes" xml:space="preserve">
          <source>If such a specialization has a member named &lt;code&gt;type&lt;/code&gt;, it must be a public and unambiguous member type that names a type to which both &lt;code&gt;TQual&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;UQual&amp;lt;U&amp;gt;&lt;/code&gt; are convertible. Additionally, &lt;code&gt;std::basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;::type&lt;/code&gt; and &lt;code&gt;std::basic_common_reference&amp;lt;U, T, UQual, TQual&amp;gt;::type&lt;/code&gt; must denote the same type.</source>
          <target state="translated">如果这样的专门化具有名为 &lt;code&gt;type&lt;/code&gt; 的成员，则它必须是公开且明确的成员类型，该成员类型必须命名 &lt;code&gt;TQual&amp;lt;T&amp;gt;&lt;/code&gt; 和 &lt;code&gt;UQual&amp;lt;U&amp;gt;&lt;/code&gt; 都可以转换为的类型。此外， &lt;code&gt;std::basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;::type&lt;/code&gt; 和 &lt;code&gt;std::basic_common_reference&amp;lt;U, T, UQual, TQual&amp;gt;::type&lt;/code&gt; 必须表示相同的类型。</target>
        </trans-unit>
        <trans-unit id="a948028c1758b5531024e3fe8732225a9c5cc129" translate="yes" xml:space="preserve">
          <source>If such character was found, is it the</source>
          <target state="translated">如果发现这样的字符,是不是</target>
        </trans-unit>
        <trans-unit id="18c5e1768b43942789912ab8899675cb0c8b4274" translate="yes" xml:space="preserve">
          <source>If such character was found, it is</source>
          <target state="translated">如果发现这样的字符,它是</target>
        </trans-unit>
        <trans-unit id="1e5aef218cb47cb6d5be701f51f4abca139d0794" translate="yes" xml:space="preserve">
          <source>If such function has multiple return statements, the deduction is performed for each return statement. All the resulting types must be the same and become the actual return type.</source>
          <target state="translated">如果该函数有多条返回语句,则对每条返回语句进行扣减。所有产生的类型必须相同,成为实际的返回类型。</target>
        </trans-unit>
        <trans-unit id="0ef2cb48d46014bbb2de04ceea1ca8d25cb98355" translate="yes" xml:space="preserve">
          <source>If such function has no return statement, &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;void()&lt;/code&gt; when deducing.</source>
          <target state="translated">如果此类函数没有return语句，则推论时 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;void()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="781a8af57a4e00c05cd18f270856d6e17bfee700" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is</source>
          <target state="translated">如果发现这种广泛的特征,那就是</target>
        </trans-unit>
        <trans-unit id="cc7116ca6f31d674f4a72c2589a0d09f652f8823" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is the</source>
          <target state="translated">如果发现这种广泛的特征,那就是。</target>
        </trans-unit>
        <trans-unit id="6016d8ecaf1d3d66d2fab0578528efd9598d22d7" translate="yes" xml:space="preserve">
          <source>If that invocation returns normally (such call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">如果该调用正常返回（对 &lt;code&gt;call_once&lt;/code&gt; 的此类调用称为</target>
        </trans-unit>
        <trans-unit id="d62acf7636b44fe974a0dd1f118413c4d750777d" translate="yes" xml:space="preserve">
          <source>If that invocation throws an exception, it is propagated to the caller of &lt;code&gt;call_once&lt;/code&gt;, and the flag is not flipped so that another call will be attempted (such call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">如果该调用引发异常，则将其传播到 &lt;code&gt;call_once&lt;/code&gt; 的调用方，并且不会翻转该标志，因此将尝试另一个调用（对 &lt;code&gt;call_once&lt;/code&gt; 的调用称为</target>
        </trans-unit>
        <trans-unit id="80a16c9b65c48e0464ea5d60a9c92f28adf5f633" translate="yes" xml:space="preserve">
          <source>If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused, however the lifetime of the array itself does not end (its storage is not considered to have been reused).</source>
          <target state="translated">如果数组的这一部分之前为另一个对象提供了存储,那么这个对象的寿命就结束了,因为它的存储被重复使用了,但是数组本身的寿命并没有结束(它的存储不被认为是被重复使用)。</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">如果</target>
        </trans-unit>
        <trans-unit id="345e55abff70a548ca370acdb8ec63c08545a970" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; component of the generic-format path contains a period (&lt;code&gt;.&lt;/code&gt;), and is not one of the special filesystem elements dot or dot-dot, then the</source>
          <target state="translated">如果通用格式路径的&lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt;组件包含句点（ &lt;code&gt;.&lt;/code&gt; ），并且不是特殊的文件系统元素点或点点之一，则</target>
        </trans-unit>
        <trans-unit id="ba0ee99ef431871bed3ba20ad26dd7f7656ca3aa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object was obtained from &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; or the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt;, the value of &lt;code&gt;tm_isdst&lt;/code&gt; is indeterminate, and needs to be set explicitly before calling &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; 从获取对象 &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; 或POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt;，价值 &lt;code&gt;tm_isdst&lt;/code&gt; 的是不确定的，需要调用之前明确地设置 &lt;code&gt;mktime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae98e330385c2faeed50f85315fe9af8967b33f7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object was obtained from &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; or the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt;, the value of &lt;code&gt;tm_isdst&lt;/code&gt; is indeterminate, and needs to be set explicitly before calling &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ffd5bdb618a15dacdd93c1f4888f75a24f4a33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; type defines a class-level replacement, it will be used, otherwise global &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; will be used.</source>
          <target state="translated">如果 &lt;code&gt;Promise&lt;/code&gt; 类型定义了类级别的替换，则将使用它，否则将使用全局 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="73ae41564f6a1c376265c280e35f0cabc8e5e1b5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; type defines a placement form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; that takes additional parameters, and they match an argument list where the first argument is the size requested (of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) and the rest are the coroutine function arguments, those arguments will be passed to &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; (this makes it possible to use &lt;a href=&quot;../memory/uses_allocator#Uses-allocator_construction&quot;&gt;leading-allocator-convention&lt;/a&gt; for coroutines).</source>
          <target state="translated">如果 &lt;code&gt;Promise&lt;/code&gt; 类型定义了一个 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; 的放置形式，该放置形式采用其他参数，并且它们与参数列表匹配，其中第一个参数是请求的大小（类型为 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ），其余为协程函数参数，则这些参数将被传递给 &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; （这使得对协程使用&lt;a href=&quot;../memory/uses_allocator#Uses-allocator_construction&quot;&gt;Leading-allocator-Convention&lt;/a&gt;成为可能）。</target>
        </trans-unit>
        <trans-unit id="478337dee1f38e04706d749bfe79388ccef331de" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;directory_iterator&lt;/code&gt; reports an error or is advanced past the last directory entry, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.</source>
          <target state="translated">如果 &lt;code&gt;directory_iterator&lt;/code&gt; 报告错误或超过了最后一个目录条目，则它等于默认构造的迭代器，也称为结束迭代器。两个末端迭代器始终相等，对末端迭代器进行解引用或递增是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="b8e4d93257a92c723d2b683f90d9e06102fd5b29" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;local_time&lt;/code&gt; is ambiguous, then &lt;code&gt;result == local_info::ambiguous&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that ends just after the &lt;code&gt;local_time&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is filled with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that starts just before the &lt;code&gt;local_time&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;local_time&lt;/code&gt; 是模糊的，然后 &lt;code&gt;result == local_info::ambiguous&lt;/code&gt; ， &lt;code&gt;first&lt;/code&gt; 与填写 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; 是刚刚结束后 &lt;code&gt;local_time&lt;/code&gt; 和 &lt;code&gt;second&lt;/code&gt; 充满 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; 启动就在 &lt;code&gt;local_time&lt;/code&gt; 之前。</target>
        </trans-unit>
        <trans-unit id="be3a36bf5edab54949d33d3601ee2498da9859cd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;local_time&lt;/code&gt; is nonexistent, then &lt;code&gt;result == local_info::nonexistent&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that ends just prior to the &lt;code&gt;local_time&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that begins just after the &lt;code&gt;local_time&lt;/code&gt;.</source>
          <target state="translated">如果不存在 &lt;code&gt;local_time&lt;/code&gt; ，则 &lt;code&gt;result == local_info::nonexistent&lt;/code&gt; ， &lt;code&gt;first&lt;/code&gt; 填充为 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; ，而该std :: chrono :: sys_info在 &lt;code&gt;local_time&lt;/code&gt; 之前结束， &lt;code&gt;second&lt;/code&gt; 填充为 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; 从 &lt;code&gt;local_time&lt;/code&gt; 之后开始。</target>
        </trans-unit>
        <trans-unit id="aba2a61809646633728f0c300cb4a04fd0fdd0e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nptr&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;enptr&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;nptr&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;endptr&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;nptr&lt;/code&gt; 为空或不具有预期格式，则不执行任何转换，并且（如果 &lt;code&gt;enptr&lt;/code&gt; 不为 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ） &lt;code&gt;nptr&lt;/code&gt; 的值存储在 &lt;code&gt;endptr&lt;/code&gt; 指向的对象中。</target>
        </trans-unit>
        <trans-unit id="ebdf7be468a8d6d0434b13fed187af1e31121791" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;recursive_directory_iterator&lt;/code&gt; reports an error or is advanced past the last directory entry of the top-level directory, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.</source>
          <target state="translated">如果 &lt;code&gt;recursive_directory_iterator&lt;/code&gt; 报告错误或超出了顶级目录的最后一个目录条目，则它将等于默认构造的迭代器，也称为结束迭代器。两个末端迭代器始终相等，对末端迭代器进行解引用或递增是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="5651c6461cabc5494e66b0b82def60eb3e607dc1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;std::future&lt;/code&gt; obtained from &lt;code&gt;std::async&lt;/code&gt; is not moved from or bound to a reference, the destructor of the &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; will block at the end of the full expression until the asynchronous operation completes, essentially making code such as the following synchronous:</source>
          <target state="translated">如果从 &lt;code&gt;std::async&lt;/code&gt; 获得的 &lt;code&gt;std::future&lt;/code&gt; 没有从引用中移出或绑定到引用，则 &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; 的析构函数将在完整表达式的末尾阻塞，直到异步操作完成为止，这实际上使代码如以下同步：</target>
        </trans-unit>
        <trans-unit id="f1881ec1b9072afac208ff470251f98ed10178f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;str&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;str_end&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;str&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;str_end&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;str&lt;/code&gt; 为空或不具有预期形式，则不执行任何转换，并且（如果 &lt;code&gt;str_end&lt;/code&gt; 不为 &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ）将 &lt;code&gt;str&lt;/code&gt; 的值存储在 &lt;code&gt;str_end&lt;/code&gt; 指向的对象中。</target>
        </trans-unit>
        <trans-unit id="e50fd41c5ef8a59127cf972f021ae16ba8532f47" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in binary mode, the new position is exactly &lt;code&gt;offset&lt;/code&gt; bytes measured from the beginning of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;, from the current file position if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt;, and from the end of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;. Binary streams are not required to support &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;, in particular if additional null bytes are output.</source>
          <target state="translated">如果 &lt;code&gt;stream&lt;/code&gt; 是二进制模式打开时，新的位置被精确地 &lt;code&gt;offset&lt;/code&gt; 从文件的开始时测量，如果字节 &lt;code&gt;origin&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; ，从当前文件位置是否 &lt;code&gt;origin&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt; ，并从该文件的结束时，如果 &lt;code&gt;origin&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; 。不需要二进制流来支持 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; ，尤其是在输出其他空字节的情况下。</target>
        </trans-unit>
        <trans-unit id="37a2ed3c9a259690f19d7262a85bdeef29cb181d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in text mode, the only supported values for &lt;code&gt;offset&lt;/code&gt; are zero (which works with any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; on a stream associated with the same file (which only works with &lt;code&gt;origin&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">如果以文本模式打开 &lt;code&gt;stream&lt;/code&gt; ，则仅支持 &lt;code&gt;offset&lt;/code&gt; 的值为零（该值对任何 &lt;code&gt;origin&lt;/code&gt; 都适用），并且是在与同一文件相关联的流上先前调用 &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; 返回的值（仅与 &lt;code&gt;origin&lt;/code&gt; 的 &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="892724969fe6221e78fcbe5fd94b682363cb5949" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is wide-oriented, the restrictions of both text and binary streams apply (result of &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).</source>
          <target state="translated">如果 &lt;code&gt;stream&lt;/code&gt; 是面向宽的，则文本流和二进制流都受限制（SEEK_SET允许 &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; 结果，SEEK_SET和SEEK_CUR允许零偏移，但SEEK_END不允许）。</target>
        </trans-unit>
        <trans-unit id="d0b614dfebe10969c88ebb875d7426f7d8ef68bd" translate="yes" xml:space="preserve">
          <source>If the OS uses a</source>
          <target state="translated">如果操作系统使用的是</target>
        </trans-unit>
        <trans-unit id="78c8e20ea6a30edcc63fb9e62dc035eb0fe67dd3" translate="yes" xml:space="preserve">
          <source>If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;construct()&lt;/code&gt;,), then calls placement-new as.</source>
          <target state="translated">如果上述操作不可行（例如， &lt;code&gt;a&lt;/code&gt; 没有成员函数 &lt;code&gt;construct()&lt;/code&gt; ），则调用asplace-new。</target>
        </trans-unit>
        <trans-unit id="08776426179650f866b4d0470c65442caf416cce" translate="yes" xml:space="preserve">
          <source>If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;max_size()&lt;/code&gt;), then returns &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max()&lt;/code&gt;(until C++17)&lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt;(since C++17).</source>
          <target state="translated">如果上述操作不可行（例如 &lt;code&gt;a&lt;/code&gt; 没有成员函数 &lt;code&gt;max_size()&lt;/code&gt; ），则返回 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max()&lt;/code&gt; （直到C ++ 17） &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt; （自C ++ 17开始）。</target>
        </trans-unit>
        <trans-unit id="aac3be73f3bb8e2fda1848ee16dfee9b40b5d6a7" translate="yes" xml:space="preserve">
          <source>If the aggregate initialization uses copy-(until C++14)list-initialization syntax (&lt;code&gt;T a = {args..}&lt;/code&gt;or &lt;code&gt;T a {args..}&lt;/code&gt;(since C++14)), the braces around the nested initializer lists may be elided (omitted), in which case as many initializer clauses as necessary are used to initialize every member or element of the corresponding subaggregate, and the subsequent initializer clauses are used to initialize the following members of the object. However, if the object has a sub-aggregate without any members (an empty struct, or a struct holding only static members), brace elision is not allowed, and an empty nested list &lt;code&gt;{} &lt;/code&gt; must be used.</source>
          <target state="translated">如果聚合初始化使用copy-（直到C ++ 14）列表初始化语法（ &lt;code&gt;T a = {args..}&lt;/code&gt; 或 &lt;code&gt;T a {args..}&lt;/code&gt; （自C ++ 14起）），则嵌套初始化程序周围的花括号可能会省略（忽略）列表，在这种情况下，将使用尽可能多的初始化程序子句来初始化相应子聚合的每个成员或元素，而随后的初始化程序子句将用于初始化对象的以下成员。但是，如果对象具有不包含任何成员的子聚合（一个空结构，或仅包含静态成员的结构），则不允许大括号省略，并且必须使用空的嵌套列表 &lt;code&gt;{} &lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e0399c949000296ee9ae66ca9aac394f1a2f1f9c" translate="yes" xml:space="preserve">
          <source>If the aggregate that is initialized with a designated initializer clause has an anonymous union member, the corresponding designated initializer must name one of the members of that anonymous union.</source>
          <target state="translated">如果用指定初始化子句初始化的集合有一个匿名联合体成员,那么相应的指定初始化子句必须命名该匿名联合体的一个成员。</target>
        </trans-unit>
        <trans-unit id="594b9ef516bc13e866ad5205b086e5efba4a2ca2" translate="yes" xml:space="preserve">
          <source>If the algorithm fails to allocate memory, &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">如果算法无法分配内存，则会抛出 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1bbf4fee39cb9b1e1b2e31f5aa92d3790c46ca1d" translate="yes" xml:space="preserve">
          <source>If the algorithm fails to allocate memory, &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">如果算法无法分配内存，则会抛出 &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c2e9382364758d1ba08276bed3a0538d258c6220" translate="yes" xml:space="preserve">
          <source>If the allocation function returns a null pointer, which is possible if the non-throwing overload was selected, e.g. with &lt;code&gt;new(&lt;a href=&quot;../memory/new/nothrow&quot;&gt;std::nothrow&lt;/a&gt;) T;&lt;/code&gt;, then the new-expression returns immediately, it does not attempt to initialize an object or to call a deallocation function. If the standard placement allocation function returns a null pointer, which is possible if the user passes a null pointer as the argument, the behavior is undefined.(since C++17).</source>
          <target state="translated">如果分配函数返回空指针，则在选择非抛出重载的情况下（例如，使用 &lt;code&gt;new(&lt;a href=&quot;../memory/new/nothrow&quot;&gt;std::nothrow&lt;/a&gt;) T;&lt;/code&gt; ，则new-expression立即返回，它不会尝试初始化对象或调用释放函数。如果标准的布局分配函数返回空指针（如果用户将空指针作为参数传递，则可能发生），则该行为未定义。（自C ++ 17开始）。</target>
        </trans-unit>
        <trans-unit id="a90b4223ec8c5c3e6da2dcd84075a2e4a1b01cc8" translate="yes" xml:space="preserve">
          <source>If the allocator will</source>
          <target state="translated">如果分配器将</target>
        </trans-unit>
        <trans-unit id="61e2b91fec3faec7fc75d4eceab84254e8c8a972" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;A&lt;/code&gt; of the transformed template-1 can be used to deduce the corresponding parameter &lt;code&gt;P&lt;/code&gt; of template-2, but not vice versa, then this &lt;code&gt;A&lt;/code&gt; is more specialized than &lt;code&gt;P&lt;/code&gt; with regards to the type(s) that are deduced by this P/A pair.</source>
          <target state="translated">如果可以使用转换后的模板1 的参数 &lt;code&gt;A&lt;/code&gt; 来推导模板2 的对应参数 &lt;code&gt;P&lt;/code&gt; ，反之则不行，则该 &lt;code&gt;A&lt;/code&gt; 比 &lt;code&gt;P&lt;/code&gt; 推导的类型上 P P / A对。</target>
        </trans-unit>
        <trans-unit id="2619199639dd0dfe77e10f7ea0d17382af754c82" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, &amp;plusmn;1 is returned</source>
          <target state="translated">如果参数为&amp;plusmn;&amp;infin;，则返回&amp;plusmn;1</target>
        </trans-unit>
        <trans-unit id="a9eeedbf12ee3261a62193ec2f7bf409d740fd6e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">如果参数为&amp;plusmn;&amp;infin;，则返回+&amp;infin;</target>
        </trans-unit>
        <trans-unit id="bc0e32230b86eab8904c3236eac37ff6f8e3e5b9" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">如果参数为&amp;plusmn;&amp;infin;，则返回+&amp;infin;。</target>
        </trans-unit>
        <trans-unit id="70915638207ef43ec09152008a5ac4da1c3e101e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果参数为&amp;plusmn;0，则返回&amp;plusmn;&amp;infin;并引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4bcd3cf56514ebcbadf81a91fe745d514dda05b5" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;0 is returned</source>
          <target state="translated">如果参数为&amp;plusmn;0，则返回&amp;plusmn;0</target>
        </trans-unit>
        <trans-unit id="79c9397babcc1b0c97ddd36d4f6dacccb4dbab7b" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果参数为&amp;plusmn;0，则返回+&amp;infin;并引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97d561db29f01535350a0e816707f41c9ebbceeb" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +0 is returned</source>
          <target state="translated">如果参数为&amp;plusmn;0，则返回+0</target>
        </trans-unit>
        <trans-unit id="6f44ff73ce4a7042130e83bc24af8060e5fe2b98" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned</source>
          <target state="translated">如果参数为&amp;plusmn;0，则返回-&amp;infin;</target>
        </trans-unit>
        <trans-unit id="310b79d192c0fa5a1ce6ca3877e2deb499d9d5f3" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">如果参数为&amp;plusmn;0，则返回-&amp;infin;并引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e20d184a4efd311faacd5da72518930f348cac5a" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, 1 is returned</source>
          <target state="translated">如果参数为&amp;plusmn;0，则返回1</target>
        </trans-unit>
        <trans-unit id="d3f53d74b0dca3908c99b1e364989b3591808e1e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned unmodified</source>
          <target state="translated">如果参数为&amp;plusmn;0，则返回原样</target>
        </trans-unit>
        <trans-unit id="ccd73690fa7a557641f2fe90d1fb0da76c7573ad" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">如果参数为&amp;plusmn;0，则返回原样</target>
        </trans-unit>
        <trans-unit id="666ec3240c22502f1099c8da74484f25ff980d70" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;1, a pole error occurs.</source>
          <target state="translated">如果参数为&amp;plusmn;1，则发生极点误差。</target>
        </trans-unit>
        <trans-unit id="16671d13b546303a8dbbbb41028ae78cbf067eb9" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin; or &amp;plusmn;0, it is returned, unmodified.</source>
          <target state="translated">如果参数为+&amp;infin;或&amp;plusmn;0，则返回原样。</target>
        </trans-unit>
        <trans-unit id="54b0607c64e592ab2e8d7944a7583de099ef78bc" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">如果参数为+&amp;infin;，则返回+&amp;infin;</target>
        </trans-unit>
        <trans-unit id="aa21d5b0bb57bf219f506cda16da2521284b89b4" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">如果参数为+&amp;infin;，则返回+&amp;infin;。</target>
        </trans-unit>
        <trans-unit id="540557a8bd62a5b0f36f5bd102aec659ebb950db" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;pi;/2 is returned</source>
          <target state="translated">如果参数为+&amp;infin;，则返回+&amp;pi;/ 2</target>
        </trans-unit>
        <trans-unit id="7199243658fb47291089c2b185fa5cf8110be042" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +0 is returned</source>
          <target state="translated">如果参数为+&amp;infin;，则返回+0</target>
        </trans-unit>
        <trans-unit id="f4be25ee19a8f2e9c79ffae1bfa98e41cff590c7" translate="yes" xml:space="preserve">
          <source>If the argument is +1, the value &lt;code&gt;+0&lt;/code&gt; is returned.</source>
          <target state="translated">如果参数为+1，则返回值 &lt;code&gt;+0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="09765a27421db439d2ceef1decf36c6c5400ca31" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, +0 is returned</source>
          <target state="translated">如果参数为-&amp;infin;，则返回+0</target>
        </trans-unit>
        <trans-unit id="ab67da2ac08a598b0aeee9a84a5ea4203889b128" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -&amp;pi;/2 is returned</source>
          <target state="translated">如果参数为-&amp;infin;，则返回-&amp;pi;/ 2</target>
        </trans-unit>
        <trans-unit id="c52a07d7a9cd046aa4f61618e846c887cf3ca1d0" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -1 is returned</source>
          <target state="translated">如果参数为-&amp;infin;，则返回-1</target>
        </trans-unit>
        <trans-unit id="3cb7272c20346f5eded435e9a2ce5990a13f544b" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, 2 is returned</source>
          <target state="translated">如果参数为-&amp;infin;，则返回2</target>
        </trans-unit>
        <trans-unit id="7b59bb47bb4f9b237288770872fa9592f179ad22" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果参数是-&amp;infin;，返回NaN和 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="2728e75a63954aabe83e882896db0bf09fd9c3f9" translate="yes" xml:space="preserve">
          <source>If the argument is -1, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">如果参数为-1，则返回-&amp;infin;并引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dad9f0dbcbb32af831ea87c9b1abd3643a5b7b20" translate="yes" xml:space="preserve">
          <source>If the argument is 1, +0 is returned</source>
          <target state="translated">如果参数为1,则返回+0。</target>
        </trans-unit>
        <trans-unit id="290ee1b584ad39adb2720da091bea3742f568b9f" translate="yes" xml:space="preserve">
          <source>If the argument is 2, +0 is returned</source>
          <target state="translated">如果参数为2,则返回+0。</target>
        </trans-unit>
        <trans-unit id="9f6074320a813a4e58ce3f8235a3e40354fe9d12" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned</source>
          <target state="translated">如果参数是NaN,则返回NaN。</target>
        </trans-unit>
        <trans-unit id="ccc4c1fc3fbbb948e5c992719dc5c43cdd7d9790" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="translated">如果参数是NaN,则返回NaN,并且不报告域名错误。</target>
        </trans-unit>
        <trans-unit id="663f54eba211611128011b5b2bd091f463b1a1cc" translate="yes" xml:space="preserve">
          <source>If the argument is a designated initializer list, a conversion is only possible if the parameter has an aggregate type that can be initialized from that initializer list according to the rules for &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, in which case the implicit conversion sequence is a user-defined conversion sequence whose second standard conversion sequence is an identity conversion.</source>
          <target state="translated">如果参数是指定的初始值设定项列表，则仅当参数具有可根据&lt;a href=&quot;aggregate_initialization&quot;&gt;聚合初始化&lt;/a&gt;规则从该初始值设定项列表初始化的聚合类型时，才可以进行转换，在这种情况下，隐式转换序列是用户定义的转换第二标准转换序列是同一性转换的序列。</target>
        </trans-unit>
        <trans-unit id="f630be49c2abd923603f430a83802a576f8d8a5b" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果参数为负整数，则返回+&amp;infin;并引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3cb5a23f7100fda931d00bdcf1949dd71d061ad" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果参数是负整数，则返回NaN且 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="20646ae3669e13c85917f45de5026134f970fd91" translate="yes" xml:space="preserve">
          <source>If the argument is less than -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and NaN is returned.</source>
          <target state="translated">如果参数小于-0，则引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 并返回NaN。</target>
        </trans-unit>
        <trans-unit id="d60f1479d7ad633bb20dc263baae8366ce50fe47" translate="yes" xml:space="preserve">
          <source>If the argument is less than -1, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">如果参数小于-1，则返回NaN并 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82e61b5e3d8efb3126389ca46e457ed7c53253b6" translate="yes" xml:space="preserve">
          <source>If the argument is less than 1, a domain error occurs.</source>
          <target state="translated">如果参数小于1,就会发生域错误。</target>
        </trans-unit>
        <trans-unit id="8ca2273cafe3374e2295b541c384fca2773d84f3" translate="yes" xml:space="preserve">
          <source>If the argument is negative, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">如果参数为负，则返回NaN并 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ce877c1c558f9ec930d2aac72c101f35a2f7812" translate="yes" xml:space="preserve">
          <source>If the argument is not on the interval [-1, +1], a range error occurs.</source>
          <target state="translated">如果参数不在区间[-1,+1]上,则发生范围错误。</target>
        </trans-unit>
        <trans-unit id="a3c3924a950cbead03e34404522a3031242c5c81" translate="yes" xml:space="preserve">
          <source>If the arguments are temporaries, &lt;code&gt;forward_as_tuple&lt;/code&gt; does not extend their lifetime; they have to be used before the end of the full expression.</source>
          <target state="translated">如果参数是临时的，那么 &lt;code&gt;forward_as_tuple&lt;/code&gt; 不会延长其生存期；必须在完整表达式的结尾之前使用它们。</target>
        </trans-unit>
        <trans-unit id="2199aba2bc9bf0df1d73b9c3777d78213c53216a" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that &lt;code&gt;comp&lt;/code&gt; would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</source>
          <target state="translated">如果数组包含几个 &lt;code&gt;comp&lt;/code&gt; 表示与搜索到的元素相等的元素，则未指定函数将返回结果的元素。</target>
        </trans-unit>
        <trans-unit id="f51494a87d2300af12e0330eba96c74b86cb7986" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open() == false&lt;/code&gt;), returns &lt;code&gt;Traits::eof()&lt;/code&gt; before doing anything.</source>
          <target state="translated">如果关联文件未打开（ &lt;code&gt;is_open() == false&lt;/code&gt; ），则在执行任何操作之前返回 &lt;code&gt;Traits::eof()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b7bafed16d966c0cf1207175d019010ae108d6c1" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;), fails immediately.</source>
          <target state="translated">如果关联文件未打开（ &lt;code&gt;is_open()==false&lt;/code&gt; ），则立即失败。</target>
        </trans-unit>
        <trans-unit id="ae52be96052bf801f3b8098ab2013b04fe3a4a04" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;, fails immediately.</source>
          <target state="translated">如果关联文件未打开（ &lt;code&gt;is_open()==false&lt;/code&gt; ，则立即失败。</target>
        </trans-unit>
        <trans-unit id="7cac4bee56cffefb9d5f96aafb66ad2424beb17d" translate="yes" xml:space="preserve">
          <source>If the associated file was already open, returns a null pointer right away.</source>
          <target state="translated">如果关联的文件已经打开,则立即返回一个空指针。</target>
        </trans-unit>
        <trans-unit id="707b71cd5415cf8d8476c290727e5a9c8c18e35f" translate="yes" xml:space="preserve">
          <source>If the associated mutex is already locked by this &lt;code&gt;shared_lock&lt;/code&gt; (that is, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果关联的互斥锁已被此 &lt;code&gt;shared_lock&lt;/code&gt; 锁定（即，&lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt;返回 &lt;code&gt;true&lt;/code&gt; ），则错误代码为 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8b1ad230edb75da7998e440c34314fa12ebb13f" translate="yes" xml:space="preserve">
          <source>If the body of a lambda &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; an entity captured by copy, the member of the closure type is accessed. If it is not odr-using the entity, the access is to the original object:</source>
          <target state="translated">如果lambda &lt;a href=&quot;definition#ODR-use&quot;&gt;odr&lt;/a&gt;的主体使用通过副本捕获的实体，则访问闭包类型的成员。如果不使用实体，则访问原始对象：</target>
        </trans-unit>
        <trans-unit id="efb071bf7d785901c94b7543fe7ce5432fcfa86c" translate="yes" xml:space="preserve">
          <source>If the braced-init-list is empty and &lt;code&gt;T&lt;/code&gt; is a class type with a default constructor, &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt; is performed.</source>
          <target state="translated">如果braced-init-list为空并且 &lt;code&gt;T&lt;/code&gt; 是具有默认构造函数的类类型，则&lt;a href=&quot;value_initialization&quot;&gt;值初始化&lt;/a&gt;执行。</target>
        </trans-unit>
        <trans-unit id="1719a9715867ad8b0bc520fba8f212e17cc25ebe" translate="yes" xml:space="preserve">
          <source>If the buffer uses dynamic allocation, sets the frozen status of the stream to &lt;code&gt;freezefl&lt;/code&gt;.</source>
          <target state="translated">如果缓冲区使用动态分配，则将流的冻结状态设置为 &lt;code&gt;freezefl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1b15e0ac114ac6cf1d11c46237069b5057df384" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;(pos_type)-1&lt;/code&gt;, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="translated">如果调用返回 &lt;code&gt;(pos_type)-1&lt;/code&gt; ，则执行 &lt;code&gt;setstate(failbit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d455f5da56a971dee921cba17f2bcf47c19cb43f" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;false&lt;/code&gt;, the iterator sets &lt;code&gt;*this&lt;/code&gt; to the end-of-sequence iterator, the function returns.</source>
          <target state="translated">如果调用返回 &lt;code&gt;false&lt;/code&gt; ，则迭代器将 &lt;code&gt;*this&lt;/code&gt; 设置为序列结束迭代器，函数将返回。</target>
        </trans-unit>
        <trans-unit id="e503214a190894ba07737d97130f4f4e57a0952d" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;true&lt;/code&gt;, the function returns.</source>
          <target state="translated">如果调用返回 &lt;code&gt;true&lt;/code&gt; ，则函数返回。</target>
        </trans-unit>
        <trans-unit id="5756be4be986d9060f28be2990144a451f23bebb" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; returns &lt;code&gt;Traits::eof&lt;/code&gt;, sets the failed() flag to true.</source>
          <target state="translated">如果对 &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; 的调用返回 &lt;code&gt;Traits::eof&lt;/code&gt; ，则将failed（）标志设置为true。</target>
        </trans-unit>
        <trans-unit id="4aae1dcba7a08d934d0a653ad0c0ff27019c75f7" translate="yes" xml:space="preserve">
          <source>If the capture-default is &lt;code&gt;&amp;amp;&lt;/code&gt;, subsequent simple captures must not begin with &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">如果capture-default默认值为 &lt;code&gt;&amp;amp;&lt;/code&gt; ，则随后的简单捕获不能以 &lt;code&gt;&amp;amp;&lt;/code&gt; 开头。</target>
        </trans-unit>
        <trans-unit id="0277bab17cc429663b1ace6d465fb1f995414d4e" translate="yes" xml:space="preserve">
          <source>If the capture-default is &lt;code&gt;=&lt;/code&gt;, subsequent simple captures must begin with &lt;code&gt;&amp;amp;&lt;/code&gt; or be &lt;code&gt;*this&lt;/code&gt;(since C++17)or &lt;code&gt;this&lt;/code&gt;(since C++20).</source>
          <target state="translated">如果capture-default为 &lt;code&gt;=&lt;/code&gt; ，则后续的简单捕获必须以 &lt;code&gt;&amp;amp;&lt;/code&gt; 开头，或者为 &lt;code&gt;*this&lt;/code&gt; （C ++ 17起）或 &lt;code&gt;this&lt;/code&gt; （C ++ 20起）。</target>
        </trans-unit>
        <trans-unit id="de84be00a72fc5e9e1aaa148e3a8f5aade0e83e5" translate="yes" xml:space="preserve">
          <source>If the cast is successful, &lt;code&gt;dynamic_cast&lt;/code&gt; returns a value of type &lt;code&gt;new_type&lt;/code&gt;. If the cast fails and &lt;code&gt;new_type&lt;/code&gt; is a pointer type, it returns a null pointer of that type. If the cast fails and &lt;code&gt;new_type&lt;/code&gt; is a reference type, it throws an exception that matches a handler of type &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果转换成功，则 &lt;code&gt;dynamic_cast&lt;/code&gt; 返回类型为 &lt;code&gt;new_type&lt;/code&gt; 的值。如果 &lt;code&gt;new_type&lt;/code&gt; 失败并且new_type是指针类型，则它将返回该类型的空指针。如果 &lt;code&gt;new_type&lt;/code&gt; 失败并且new_type是引用类型，则它将引发与 &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt; 类型的处理程序匹配的异常。</target>
        </trans-unit>
        <trans-unit id="8d0ba473a6711055af0221180f781e98850fbb86" translate="yes" xml:space="preserve">
          <source>If the character matches one of &lt;code&gt;&quot;0123456789abcdefxABCDEFX+-&quot;&lt;/code&gt;, widened to the locale's char_type as if by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).widen()&lt;/code&gt;, it is converted to the corresponding &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">如果字符与 &lt;code&gt;&quot;0123456789abcdefxABCDEFX+-&quot;&lt;/code&gt; 之一匹配，就好像通过 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).widen()&lt;/code&gt; 扩展到语言环境的char_type一样，它将转换为相应的字符 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1c4cec9fd9552b11fc88dfc3cdd3888d0078a93" translate="yes" xml:space="preserve">
          <source>If the character matches the decimal point separator (&lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).decimal_point())&lt;/code&gt;), it is replaced by &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="translated">如果字符与小数点分隔符匹配（ &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).decimal_point())&lt;/code&gt; ），则将其替换为 &lt;code&gt;'.'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4175453721d5f90ed16f3adae9fd0acf7beb27c3" translate="yes" xml:space="preserve">
          <source>If the character matches the thousands separator (&lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt;) and the thousands separation is in use at all &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping().length() != 0&lt;/code&gt;, then if the decimal point &lt;code&gt;'.'&lt;/code&gt; has not yet been accumulated, the position of the character is remembered, but the character is otherwise ignored. If the decimal point has already been accumulated, the character is discarded and Stage 2 terminates.</source>
          <target state="translated">如果字符与千位分隔符匹配（ &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt; ），并且所有 &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping().length() != 0&lt;/code&gt; 都使用千位分隔符numpunct &amp;lt;charT &amp;gt;&amp;gt;（str.getloc（））。grouping（）。length（）！= 0，如果小数点为 &lt;code&gt;'.'&lt;/code&gt; 尚未累积，会记住角色的位置，但否则会忽略角色。如果小数点已经累积，则该字符将被丢弃，并且阶段2终止。</target>
        </trans-unit>
        <trans-unit id="e6c7076c1a1240513d559610a53ddb63ba3eb6f5" translate="yes" xml:space="preserve">
          <source>If the character sequence &lt;code&gt;[first, last)&lt;/code&gt; represents the name of a valid character class in the currently imbued locale (that is, the string between &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; in regular expressions), returns the implementation-defined value representing this character class. Otherwise, returns zero.</source>
          <target state="translated">如果字符序列 &lt;code&gt;[first, last)&lt;/code&gt; 表示当前插入的语言环境中有效字符类的名称（即，正则表达式中 &lt;code&gt;[:&lt;/code&gt; 和 &lt;code&gt;:]&lt;/code&gt; 之间的字符串），则返回表示此字符类的实现定义的值。否则，返回零。</target>
        </trans-unit>
        <trans-unit id="a2ef46a67a9512caa78f86cb2680b53275117ae5" translate="yes" xml:space="preserve">
          <source>If the character sequence &lt;code&gt;[first, last)&lt;/code&gt; represents the name of a valid collating element in the currently imbued locale, returns the name of that collating element. Otherwise, returns an empty string.</source>
          <target state="translated">如果字符序列 &lt;code&gt;[first, last)&lt;/code&gt; 表示当前插入的语言环境中有效的整理元素的名称，则返回该整理元素的名称。否则，返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="4fe55081ac62dc0b587a9cbf52fa55cd3bee4000" translate="yes" xml:space="preserve">
          <source>If the closure object's &lt;code&gt;operator()&lt;/code&gt; has a non-throwing exception specification, then the pointer returned by this function has the type pointer to noexcept function.</source>
          <target state="translated">如果闭包对象的 &lt;code&gt;operator()&lt;/code&gt; 具有非抛出异常规范，则此函数返回的指针的类型指针将指向noexcept函数。</target>
        </trans-unit>
        <trans-unit id="745715b691af433f45a6d1bda05f6b64c4819109" translate="yes" xml:space="preserve">
          <source>If the compiler issues warnings on unused entities, that warning is suppressed for any entity declared maybe_unused.</source>
          <target state="translated">如果编译器对未使用的实体发出警告,那么对于任何被声明为maybe_unused的实体,该警告将被抑制。</target>
        </trans-unit>
        <trans-unit id="c8a49a5236b04e3615bd1cc238ec4430854742fb" translate="yes" xml:space="preserve">
          <source>If the condition yields &lt;code&gt;true&lt;/code&gt; after conversion to &lt;code&gt;bool&lt;/code&gt;, statement-true is executed.</source>
          <target state="translated">如果条件转换为 &lt;code&gt;bool&lt;/code&gt; 后得出 &lt;code&gt;true&lt;/code&gt; ，则执行statement-true。</target>
        </trans-unit>
        <trans-unit id="229091fed99fdddbb18485bc60172db01d5f6825" translate="yes" xml:space="preserve">
          <source>If the conditions listed above are not met, a valid pointer to the new object may still be obtained by applying the pointer optimization barrier &lt;a href=&quot;../utility/launder&quot;&gt;&lt;code&gt;std::launder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果不满足上面列出的条件，则仍可以通过应用指针优化障碍&lt;a href=&quot;../utility/launder&quot;&gt; &lt;code&gt;std::launder&lt;/code&gt; &lt;/a&gt;获得指向新对象的有效指针。</target>
        </trans-unit>
        <trans-unit id="2221877dc5bedfe8cd4e7aed36ecca467cec7440" translate="yes" xml:space="preserve">
          <source>If the constructor was inherited from multiple base class subobjects of type B, the program is ill-formed, similar to multiply-inherited non-static member functions:</source>
          <target state="translated">如果构造函数是从B类型的多个基类子对象中继承过来的,那么程序就会出现问题,类似于多继承的非静态成员函数。</target>
        </trans-unit>
        <trans-unit id="ec7e0506f8686074df12634f2b0dcdc66508f971" translate="yes" xml:space="preserve">
          <source>If the container is empty, the returned iterator will be equal to &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果容器为空，则返回的迭代器将等于 &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4be0a9674e89e888ef7897d1c0bff106b4bd693d" translate="yes" xml:space="preserve">
          <source>If the conversion fails with &lt;code&gt;&lt;a href=&quot;../../locale/codecvt_base&quot;&gt;std::codecvt_base::error&lt;/a&gt;&lt;/code&gt;, returns &lt;code&gt;Traits::eof()&lt;/code&gt; without attempting any output.</source>
          <target state="translated">如果转换失败并显示 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt_base&quot;&gt;std::codecvt_base::error&lt;/a&gt;&lt;/code&gt; ，则返回 &lt;code&gt;Traits::eof()&lt;/code&gt; 而不尝试任何输出。</target>
        </trans-unit>
        <trans-unit id="60a697aa95e320d7d6b93da3ee60c2df0a966a8e" translate="yes" xml:space="preserve">
          <source>If the conversion function fails to convert the entire field, the value &lt;code&gt;​0​&lt;/code&gt; is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">如果转换函数失败到整个字段转换，将值 &lt;code&gt;​0​&lt;/code&gt; 被存储在 &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4027272e7c52f77712bdb3b653471483e93cc10" translate="yes" xml:space="preserve">
          <source>If the conversion function results in a negative value too large to fit in the type of &lt;code&gt;v&lt;/code&gt;, the most negative representable value is stored in &lt;code&gt;v&lt;/code&gt;, or zero for unsigned integer types.(until C++17)</source>
          <target state="translated">如果转换函数导致负值太大而无法适合 &lt;code&gt;v&lt;/code&gt; 的类型，则最大负值可表示的值存储在 &lt;code&gt;v&lt;/code&gt; 中，对于无符号整数类型，其值为零（直到C ++ 17）。</target>
        </trans-unit>
        <trans-unit id="fb166b2ef44fa2af14cb9e58cf13d66806179e94" translate="yes" xml:space="preserve">
          <source>If the conversion function results in a positive value too large to fit in the type of &lt;code&gt;v&lt;/code&gt;, the most positive representable value is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">如果转换函数导致正值太大而无法适合 &lt;code&gt;v&lt;/code&gt; 的类型，则最正的可表示值存储在 &lt;code&gt;v&lt;/code&gt; 中</target>
        </trans-unit>
        <trans-unit id="d2eaadc84330d90ea23a53f900d957f39efcabf8" translate="yes" xml:space="preserve">
          <source>If the conversion is successful, the &lt;code&gt;time&lt;/code&gt; object is modified. All fields of &lt;code&gt;time&lt;/code&gt; are updated to fit their proper ranges. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; and &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; are recalculated using information available in other fields.</source>
          <target state="translated">如果转换成功，则修改 &lt;code&gt;time&lt;/code&gt; 对象。所有 &lt;code&gt;time&lt;/code&gt; 字段都会更新为适合其适当范围。使用其他字段中可用的信息重新计算 &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; 和 &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c8c7ea2a20a700c8ab515cd57db8ff2477c02ff7" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果转换后的值超出相应返回类型的范围，则会发生范围错误（将 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 设置为 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ），并返回 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6192b4cbcd6b133ff7698ce09fce768219ba252e" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate.</source>
          <target state="translated">如果转换后的值落在对应的返回类型的范围时，发生错误的范围（设定 &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; 到 &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ）和 &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;​0​&lt;/code&gt; 则返回，如合适的。</target>
        </trans-unit>
        <trans-unit id="fa940cdd0f1bc4912d7a80a9acf3e3f2a1974390" translate="yes" xml:space="preserve">
          <source>If the coroutine ends with an uncaught exception, it performs the following:</source>
          <target state="translated">如果coroutine以一个未捕获的异常结束,它将执行以下操作。</target>
        </trans-unit>
        <trans-unit id="12ad0f51863289a6c7c5da2f479d5e058f364975" translate="yes" xml:space="preserve">
          <source>If the coroutine is a non-static member function, such as &lt;code&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const;&lt;/code&gt;, its &lt;code&gt;Promise&lt;/code&gt; type is &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt;.</source>
          <target state="translated">如果协程是非静态成员函数，例如 &lt;code&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const;&lt;/code&gt; ，其 &lt;code&gt;Promise&lt;/code&gt; 类型为 &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7dc7e439c27949bc04c73f28d03c64e858d4848d" translate="yes" xml:space="preserve">
          <source>If the coroutine is defined as &lt;code&gt;task&amp;lt;float&amp;gt; foo(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt; x, bool flag);&lt;/code&gt;, then its &lt;code&gt;Promise&lt;/code&gt; type is &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt;.</source>
          <target state="translated">如果协程定义为 &lt;code&gt;task&amp;lt;float&amp;gt; foo(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt; x, bool flag);&lt;/code&gt; ，则其 &lt;code&gt;Promise&lt;/code&gt; 类型为 &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8ed628c0c3ef9224600ee8ab10e072d7456f4358" translate="yes" xml:space="preserve">
          <source>If the coroutine was suspended in the co_await expression, and is later resumed, the resume point is immediately before the call to &lt;code&gt;awaiter.await_resume()&lt;/code&gt;.</source>
          <target state="translated">如果协程在co_await表达式中挂起并随后恢复，则恢复点位于对 &lt;code&gt;awaiter.await_resume()&lt;/code&gt; 的调用之前。</target>
        </trans-unit>
        <trans-unit id="779db0a2dceed4ce10fd8dad1f3fd5a2aa365ff9" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">如果正确的结果大于 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 或小于 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; ，则引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c1e25624b3fd048578a45e9a3c4ec61bc91d80f" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, a domain error or a range error may occur.</source>
          <target state="translated">如果正确的结果大于 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 或小于 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; ，则可能会发生域错误或范围错误。</target>
        </trans-unit>
        <trans-unit id="df721ce87be91a1d2a0670fee727bda1f6488296" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, the return value is unspecified.</source>
          <target state="translated">如果正确的结果大于 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; 或小于 &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; ，则返回值不确定。</target>
        </trans-unit>
        <trans-unit id="e57a705dd469f19d6863e23a81d83613f10c1c86" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt;, this function rounds to even in halfway cases (like &lt;code&gt;rint&lt;/code&gt;, but unlike &lt;code&gt;round&lt;/code&gt;).</source>
          <target state="translated">如果当前舍入模式为 &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt; ，则此函数在中途情况下也舍入为偶数（例如 &lt;code&gt;rint&lt;/code&gt; ，但与 &lt;code&gt;round&lt;/code&gt; 不同）。</target>
        </trans-unit>
        <trans-unit id="e2333eb5beb6ae4621087ed67aea4b57771b1571" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is...</source>
          <target state="translated">如果当前的四舍五入模式是...。</target>
        </trans-unit>
        <trans-unit id="896aca99d0b416d865962f92c6c37d2f798c20b2" translate="yes" xml:space="preserve">
          <source>If the current size is greater than &lt;code&gt;count&lt;/code&gt;, the container is reduced to its first &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">如果当前大小大于 &lt;code&gt;count&lt;/code&gt; ，则容器将减少到其第一个 &lt;code&gt;count&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="1c6fbeaf9e8910c2d4ff6f11b1e18360cddb4c17" translate="yes" xml:space="preserve">
          <source>If the current size is greater than &lt;code&gt;count&lt;/code&gt;, the string is reduced to its first &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">如果当前大小大于 &lt;code&gt;count&lt;/code&gt; ，则字符串将减少到其第一个 &lt;code&gt;count&lt;/code&gt; 元素。</target>
        </trans-unit>
        <trans-unit id="8f352e4005a3a9b34a2f768d15d84aa23ea90cd3" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;,</source>
          <target state="translated">如果当前大小小于 &lt;code&gt;count&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="6f72d059786307ab4c08950a1fc590bdfbacc9a7" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;, additional characters are appended.</source>
          <target state="translated">如果当前大小小于 &lt;code&gt;count&lt;/code&gt; ，则会附加其他字符。</target>
        </trans-unit>
        <trans-unit id="c289d28a9c0b1ae0f12bb49e019b21510591df99" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;, additional elements are appended and initialized with copies of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">如果当前大小小于 &lt;code&gt;count&lt;/code&gt; ，则会附加附加元素并使用 &lt;code&gt;value&lt;/code&gt; 的副本进行初始化。</target>
        </trans-unit>
        <trans-unit id="442e11214c1977140f19902972be104365029434" translate="yes" xml:space="preserve">
          <source>If the deallocation functions that were found are class-specific, size-unaware class-specific deallocation function (without a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) is preferred over size-aware class-specific deallocation function (with a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">如果找到的解除分配函数是特定于类的，则优先于大小感知的特定类的解除分配函数（不带 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 类型的参数），而不是感知大小的特定类的解除分配函数（具有 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 类型的参数： ：size_t）</target>
        </trans-unit>
        <trans-unit id="81a5d52aae1f78fba956c41a28dfa8ef8191aab3" translate="yes" xml:space="preserve">
          <source>If the declared return type is &lt;code&gt;auto&lt;/code&gt;, then the actual return type is &lt;a href=&quot;../utility/compare/common_comparison_category&quot;&gt;&lt;code&gt;std::common_comparison_category_t&amp;lt;Ms&amp;gt;&lt;/code&gt;&lt;/a&gt; where Ms is the list (possibly empty) of the types of base and member subobject and member array elements to be compared. This makes it easier to write cases where the return type non-trivially depends on the members, such as:</source>
          <target state="translated">如果声明的返回类型为 &lt;code&gt;auto&lt;/code&gt; ，则实际的返回类型为&lt;a href=&quot;../utility/compare/common_comparison_category&quot;&gt; &lt;code&gt;std::common_comparison_category_t&amp;lt;Ms&amp;gt;&lt;/code&gt; &lt;/a&gt;，其中Ms是要比较的基本和成员子对象以及成员数组元素的类型的列表（可能为空）。这使得编写返回类型非平凡地依赖于成员的情况更加容易，例如：</target>
        </trans-unit>
        <trans-unit id="a11e45a27e5f79c83df818f9c033db03c1a75a8a" translate="yes" xml:space="preserve">
          <source>If the default is specified for a template parameter of a primary class template , primary variable template, (since C++14)or alias template, each subsequent template parameter must have a default argument, except the very last one may be a template parameter pack. In a function template, there are no restrictions on the parameters that follow a default, and a parameter pack may be followed by more type parameters only if they have defaults or can be deduced from the function arguments.</source>
          <target state="translated">如果一个主类模板、主变量模板(自C++14起)或别名模板的模板参数指定了默认值,那么除了最后一个模板参数包可以是一个模板参数包外,后面的每个模板参数都必须有一个默认参数。在函数模板中,对默认后的参数没有限制,只有当一个参数包有默认或可以从函数参数中推导出更多的类型参数时,后面才可能有更多的类型参数。</target>
        </trans-unit>
        <trans-unit id="15dd06f6865462c19c491fa71c0e722074bd75af" translate="yes" xml:space="preserve">
          <source>If the definition of any object results in an object of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; or &lt;a href=&quot;abstract_class&quot;&gt;abstract class type&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">如果任何对象的定义导致对象的&lt;a href=&quot;incomplete_type&quot;&gt;类型不完整&lt;/a&gt;或&lt;a href=&quot;abstract_class&quot;&gt;抽象类类型不正确&lt;/a&gt;，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="6627083d86de96fac39a9639172b8e5cae7776e7" translate="yes" xml:space="preserve">
          <source>If the destination type is &lt;code&gt;bool&lt;/code&gt;, this is a boolean conversion (see below).</source>
          <target state="translated">如果目标类型为 &lt;code&gt;bool&lt;/code&gt; ，则这是布尔转换（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="bcab72b198f459511f9abd66295e0e372205290d" translate="yes" xml:space="preserve">
          <source>If the destination type is signed, the value does not change if the source integer can be represented in the destination type. Otherwise the result is implementation-defined(until C++20)the unique value of the destination type equal to the source value modulo 2n</source>
          <target state="translated">如果目标类型是有符号的,如果源整数可以在目标类型中表示,那么这个值就不会改变,否则,结果是实现定义的(直到C++20),目标类型的唯一值等于源值的模数2n。否则,结果是实现定义的(直到C++20)目标类型的唯一值等于源值的模数2n。</target>
        </trans-unit>
        <trans-unit id="926b449ff74682e6ecadc43082826a46200dfffc" translate="yes" xml:space="preserve">
          <source>If the destination type is unsigned, the resulting value is the smallest unsigned value equal to the source value &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt; modulo&lt;/a&gt; 2n</source>
          <target state="translated">如果目标类型是无符号的，则结果值是等于源值&lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;模&lt;/a&gt; 2n 的最小无符号值</target>
        </trans-unit>
        <trans-unit id="4a5a2a7675f65b9135eddde36e34f905978fe4fb" translate="yes" xml:space="preserve">
          <source>If the directory structure contains cycles, the end iterator may be unreachable.</source>
          <target state="translated">如果目录结构中包含循环,则结束迭代器可能无法到达。</target>
        </trans-unit>
        <trans-unit id="3337548ef4310df502c47a0607ce0d45303b5ba5" translate="yes" xml:space="preserve">
          <source>If the elements in the two ranges are equal, returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果两个范围中的元素相等，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1870c25fe91ccb4fdf9e04186e90172ccaa106e8" translate="yes" xml:space="preserve">
          <source>If the else part of the if statement is present and condition yields &lt;code&gt;false&lt;/code&gt; after conversion to &lt;code&gt;bool&lt;/code&gt;, statement-false is executed.</source>
          <target state="translated">如果if语句的else部分存在且转换为 &lt;code&gt;bool&lt;/code&gt; 后条件产生 &lt;code&gt;false&lt;/code&gt; ，则执行statement-false。</target>
        </trans-unit>
        <trans-unit id="f2f9989909780caf1535a25076ad27e3ad5b20b0" translate="yes" xml:space="preserve">
          <source>If the enclosing class declaration is, in turn, a class template, when a member template is defined outside of the class body, it takes two sets of template parameters: one for the enclosing class, and another one for itself:</source>
          <target state="translated">如果包围类的声明又是一个类模板,当在类体外定义一个成员模板时,它需要两套模板参数:一套是包围类的,另一套是自己的。</target>
        </trans-unit>
        <trans-unit id="fa860288a207ce4de20ba1818eb37f1d240c59f9" translate="yes" xml:space="preserve">
          <source>If the encoding is state-dependent (&lt;code&gt;encoding() == -1&lt;/code&gt;), then more than &lt;code&gt;max_length()&lt;/code&gt; external characters may be consumed to produce one internal character.</source>
          <target state="translated">如果编码是与状态有关的（ &lt;code&gt;encoding() == -1&lt;/code&gt; ），则可能要消耗多个 &lt;code&gt;max_length()&lt;/code&gt; 个外部字符来产生一个内部字符。</target>
        </trans-unit>
        <trans-unit id="63c81f2ab01c02567fbf73ffd81b990b4f235586" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid date is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">如果在读取有效日期之前到达了结束迭代器，则该函数在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; 。如果遇到解析错误，该函数在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8aae18db76ff682a209b370fc6276ae620d78597" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid month name is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">如果在读取有效的月份名称之前到达了结束迭代器，则该函数在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; 。如果遇到解析错误，则该函数在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eed2547c74a6a3a462c75d24c54d56132c1d3935" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid value is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">如果在读取有效值之前到达了结束迭代器，则该函数在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; 。如果遇到解析错误，则该函数在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9920cfb6a997d965d21f9be654bb51f5b8757867" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid weekday name is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">如果在读取有效的工作日名称之前到达了结束迭代器，则该函数在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; 。如果遇到解析错误，则该函数在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56f8aef93d36921723ad214ce365f4585fbe9195" translate="yes" xml:space="preserve">
          <source>If the entity named by the (unqualified) identifier is a local entity, and would result in an intervening &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; capturing it by copy if it were named outside of an unevaluated operand in the declarative region in which the identifier appears, then the type of the expression is the type of a &lt;a href=&quot;operator_member_access&quot;&gt;class member access expression&lt;/a&gt; naming the non-static data member that would be declared for such a capture in the closure object of the innermost such intervening lambda expression.</source>
          <target state="translated">如果以（非限定）标识符命名的实体是本地实体，并且如果该&lt;a href=&quot;lambda&quot;&gt;lambda表达式&lt;/a&gt;是在标识符所在的声明性区域中的未求值操作数之外命名的，则将导致中间的lambda表达式通过副本捕获它，则类型为该表达式是命名非静态数据成员的&lt;a href=&quot;operator_member_access&quot;&gt;类成员访问表达式&lt;/a&gt;的类型，该非静态数据成员将被声明为在最内部的中间lambda表达式的闭包对象中进行此类捕获。</target>
        </trans-unit>
        <trans-unit id="dfdabf4aff6dc82f3c877f50307cf3a860280ed1" translate="yes" xml:space="preserve">
          <source>If the entity named is a &lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;template parameter object&lt;/a&gt; for a template parameter of type &lt;code&gt;T&lt;/code&gt;, the type of the expression is &lt;code&gt;const T&lt;/code&gt;.</source>
          <target state="translated">如果所述实体是一个&lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;模板参数对象&lt;/a&gt;类型的模板参数 &lt;code&gt;T&lt;/code&gt; ，表达式的类型是 &lt;code&gt;const T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d94c16d2093f565827acd0baa83270e850862eaa" translate="yes" xml:space="preserve">
          <source>If the exception is thrown from a constructor that is invoked by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, the matching &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; is called, if available.</source>
          <target state="translated">如果异常是由&lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;调用的构造方法抛出的，则调用匹配的&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;释放函数&lt;/a&gt;（如果有）。</target>
        </trans-unit>
        <trans-unit id="7c77baa68d29932853f92768b1f24a64502a012b" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as shortcut.</source>
          <target state="translated">如果需要在循环主体的末尾继续执行循环，&lt;a href=&quot;continue&quot;&gt;则&lt;/a&gt;可以将continue语句用作快捷方式。</target>
        </trans-unit>
        <trans-unit id="f8c4f280148d62bcff94e6cfcf459f791d957459" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, a &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as shortcut.</source>
          <target state="translated">如果需要在循环主体的末尾继续执行循环，则可以将&lt;a href=&quot;continue&quot;&gt;continue语句&lt;/a&gt;用作快捷方式。</target>
        </trans-unit>
        <trans-unit id="94e3914e819b4e9c6f38a7c7d3a8f66bfec35d72" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="translated">如果循环的执行需要在某个时刻终止，则可以将&lt;a href=&quot;break&quot;&gt;break语句&lt;/a&gt;用作终止语句。</target>
        </trans-unit>
        <trans-unit id="2cd72081fe396e16bec08079f951e2582fddd18b" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="translated">如果循环的执行需要在某个时刻终止，则可以使用&lt;a href=&quot;break&quot;&gt;break语句&lt;/a&gt;作为终止语句。</target>
        </trans-unit>
        <trans-unit id="a63e54974439d0c04ddba7efece25f14eb6ccc71" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, Source&amp;gt;{}(t)&lt;/code&gt; is well-formed, returns the result of that expression.</source>
          <target state="translated">如果表达式 &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, Source&amp;gt;{}(t)&lt;/code&gt; 的格式正确，则返回该表达式的结果。</target>
        </trans-unit>
        <trans-unit id="5c56737809ca6e1f51c00db974474519c25494a7" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;E&lt;/code&gt; has the form &lt;code&gt;PA-&amp;gt;B&lt;/code&gt; or &lt;code&gt;A.B&lt;/code&gt; (where A has class type cv T), then &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; as a member function of &lt;code&gt;T&lt;/code&gt;. The function declarations found by that lookup are the candidate functions. The argument list for the purpose of overload resolution has the implied object argument of type cv T.</source>
          <target state="translated">如果表达式 &lt;code&gt;E&lt;/code&gt; 具有形式 &lt;code&gt;PA-&amp;gt;B&lt;/code&gt; 或 &lt;code&gt;A.B&lt;/code&gt; （其中A具有类类型CV T），然后 &lt;code&gt;B&lt;/code&gt; 被&lt;a href=&quot;lookup&quot;&gt;查找&lt;/a&gt;作为成员函数 &lt;code&gt;T&lt;/code&gt; 。通过该查找找到的函数声明是候选函数。用于重载解析的参数列表具有cv T类型的隐式对象参数。</target>
        </trans-unit>
        <trans-unit id="a23e92522ea5793ad90d37f08a288000d14cacdf" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;E&lt;/code&gt; is a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt;, the name is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; following normal rules for function calls (which may involve &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;). The function declarations found by this lookup are (due to the way lookup works) either:</source>
          <target state="translated">如果表达式 &lt;code&gt;E&lt;/code&gt; 是&lt;a href=&quot;expressions#Primary_expressions&quot;&gt;主表达式&lt;/a&gt;，则按照正常的函数调用规则（可能涉及&lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;）&lt;a href=&quot;lookup&quot;&gt;查找&lt;/a&gt;名称。通过该查找找到的函数声明（由于查找的方式）为：</target>
        </trans-unit>
        <trans-unit id="69f0efd4d241778b0ab12aa15f7c0cba8b51c323" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::partial_ordering&lt;/code&gt;, returns that result.</source>
          <target state="translated">如果表达式 &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; 格式正确，并且其结果可转换为 &lt;code&gt;std::partial_ordering&lt;/code&gt; ，则返回该结果。</target>
        </trans-unit>
        <trans-unit id="a3ce312862a56044d6ce5fd6d18b3cc810505779" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::strong_equality&lt;/code&gt;, returns that result.</source>
          <target state="translated">如果表达式 &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; 格式正确，并且其结果可转换为 &lt;code&gt;std::strong_equality&lt;/code&gt; ，则返回该结果。</target>
        </trans-unit>
        <trans-unit id="2791850e6413d1fb089fa268221ec13c44284426" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, returns that result.</source>
          <target state="translated">如果表达式 &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; 格式正确，并且其结果可转换为 &lt;code&gt;std::weak_equality&lt;/code&gt; ，则返回该结果。</target>
        </trans-unit>
        <trans-unit id="6562c1886aa8be17523dc870268a8b013d14d9d0" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::weak_ordering&lt;/code&gt;, returns that result.</source>
          <target state="translated">如果表达式 &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; 格式正确，并且其结果可转换为 &lt;code&gt;std::weak_ordering&lt;/code&gt; ，则返回该结果。</target>
        </trans-unit>
        <trans-unit id="82d3a34faff20e40c4069465ee795568784e5d84" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed, returns its result</source>
          <target state="translated">如果表达式 &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; 格式正确，则返回其结果</target>
        </trans-unit>
        <trans-unit id="a8ccf3f902bab3475c2f0d81bd04eb2a781e9731" translate="yes" xml:space="preserve">
          <source>If the expression above is a prvalue, the awaiter object is a temporary &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from it. Otherwise, if the expression above is an glvalue, the awaiter object is the object to which it refers.</source>
          <target state="translated">如果上述表达式是一个prvalue，所述awaiter对象是临时&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;物化&lt;/a&gt;从它。否则，如果上面的表达式是glvalue，则waiter对象就是它所引用的对象。</target>
        </trans-unit>
        <trans-unit id="84b2a486468566117d378873877349b38e54a1e0" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise.</source>
          <target state="translated">如果表达式的值为非零,则包含受控代码块,否则跳过。</target>
        </trans-unit>
        <trans-unit id="f8f246002c66268584002c4ed48b13695ad83d46" translate="yes" xml:space="preserve">
          <source>If the expression is a non-void prvalue (after any lvalue-to-rvalue conversion that might have taken place), &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; occurs.</source>
          <target state="translated">如果表达式是非无效的prvalue（在可能发生的任何从左值到右值的转换之后），则会发生&lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;临时实现&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7329a5c8ff286b9d0a4e59efe0069989f5cd5e91" translate="yes" xml:space="preserve">
          <source>If the expression used as init or as pack has an operator with precedence below cast at the top level, it can be parenthesized:</source>
          <target state="translated">如果作为init或pack使用的表达式有一个运算符,其优先级低于顶层的cast,可以用括号表示。</target>
        </trans-unit>
        <trans-unit id="a2b1b61632e47d98b991cfabb43ddaa1fc1c9b3b" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end of file condition, additionally sets the</source>
          <target state="translated">如果失败是由文件结束条件引起的,另外设置了</target>
        </trans-unit>
        <trans-unit id="90c9cca36bdb9f6f7d9748c18430b538e7979538" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end-of-file condition, additionally sets the</source>
          <target state="translated">如果失败是由文件结束的条件引起的,另外设置了</target>
        </trans-unit>
        <trans-unit id="994d9bf8337b9cacbb5385430d81add1cb5bd997" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by some other error, sets the</source>
          <target state="translated">如果故障是由其他错误引起的,则设置为&quot;--------------------------------------------------------------------------------&quot;。</target>
        </trans-unit>
        <trans-unit id="40e036169518dee5621368e67a2b9be1ab5fb193" translate="yes" xml:space="preserve">
          <source>If the file is currently open by the current or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name, although the file system space is not reclaimed even if this was the last hardlink to the file until the last running process closes the file, Windows does not allow the file to be deleted).</source>
          <target state="translated">如果文件当前被当前进程或其他进程打开,这个函数的行为是由实现定义的(特别是POSIX系统解除了文件名的链接,不过在最后一个运行的进程关闭文件之前,即使这是文件的最后一次硬链接,文件系统空间也不会被回收,Windows不允许删除文件)。</target>
        </trans-unit>
        <trans-unit id="f8a3927438032bc9c246a1d6cab93f5a9e333a4a" translate="yes" xml:space="preserve">
          <source>If the file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;, this function returns &lt;code&gt;Traits::eof()&lt;/code&gt; immediately.</source>
          <target state="translated">如果文件未打开（ &lt;code&gt;is_open()==false&lt;/code&gt; ，则此函数立即返回 &lt;code&gt;Traits::eof()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0aabb532f13e04a1724903ba0225e1eed159600" translate="yes" xml:space="preserve">
          <source>If the file is open for reading, updates the get area if necessary.</source>
          <target state="translated">如果文件已打开阅读,必要时更新获取区域。</target>
        </trans-unit>
        <trans-unit id="b7298526d7f2b5594b5589a131851e279edeaa84" translate="yes" xml:space="preserve">
          <source>If the file is open for writing, first writes the put area and any unshift sequences required by the currently imbued locale, using &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果该文件处于打开状态以供写入，则首先使用 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 写入放置区域和当前导入的语言环境所需的任何取消移位序列。</target>
        </trans-unit>
        <trans-unit id="e6046f5bcc7e057f2daa45b27fc1473dbcccb2e9" translate="yes" xml:space="preserve">
          <source>If the file size is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::file_size(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::file_size(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">如果该 &lt;code&gt;directory_entry&lt;/code&gt; 缓存了文件大小，则返回缓存的值。否则，分别返回 &lt;code&gt;std::filesystem::file_size(path())&lt;/code&gt; 或 &lt;code&gt;std::filesystem::file_size(path(), ec)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc2139afc05136a3d64cc794796b08e516434f34" translate="yes" xml:space="preserve">
          <source>If the filename is one of the special filesystem components dot or dot-dot, or if it has no periods, the function returns the entire &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果文件名是特殊的文件系统组件点或点号之一，或者没有句点，则该函数返回整个&lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="06579240cba49b57e27dc71348315d2cf9aab0ac" translate="yes" xml:space="preserve">
          <source>If the final overrider of a &lt;code&gt;transaction_safe_dynamic&lt;/code&gt; function is not declared &lt;code&gt;transaction_safe&lt;/code&gt;, calling it in an atomic block is undefined behavior.</source>
          <target state="translated">如果未声明 &lt;code&gt;transaction_safe_dynamic&lt;/code&gt; 函数的最终重写器 &lt;code&gt;transaction_safe&lt;/code&gt; ，则在原子块中调用它是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="7d41e6a07f9e559a56f8b06959d59178f0f1531d" translate="yes" xml:space="preserve">
          <source>If the first character in the filename is a period, that period is ignored (a filename like &quot;.profile&quot; is not treated as an extension).</source>
          <target state="translated">如果文件名中的第一个字符是句号,该句号将被忽略(像&quot;.profile &quot;这样的文件名不会被视为扩展名)。</target>
        </trans-unit>
        <trans-unit id="6020291574132d5834e014d6c7f58d404fb0a67b" translate="yes" xml:space="preserve">
          <source>If the first character of the set is &lt;code&gt;^&lt;/code&gt;, then all characters not in the set are matched. If the set begins with &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;^]&lt;/code&gt; then the &lt;code&gt;]&lt;/code&gt; character is also included into the set. It is implementation-defined whether the character &lt;code&gt;-&lt;/code&gt; in the non-initial position in the scanset may be indicating a range, as in &lt;code&gt;[0-9]&lt;/code&gt;. If width specifier is used, matches only up to</source>
          <target state="translated">如果集合中的第一个字符是 &lt;code&gt;^&lt;/code&gt; ，则匹配集合中所有未包含的字符。如果集合以 &lt;code&gt;]&lt;/code&gt; 或 &lt;code&gt;^]&lt;/code&gt; 开头，则[ &lt;code&gt;]&lt;/code&gt; 字符也将包含在集合中。它是实现定义是否字符 &lt;code&gt;-&lt;/code&gt; 在扫描集所述非初始位置可以是指示一个范围，如在 &lt;code&gt;[0-9]&lt;/code&gt; 。如果使用了宽度说明符，则最多只能匹配</target>
        </trans-unit>
        <trans-unit id="87a6fda77086306a8c7bdf456c9e29f296b5945d" translate="yes" xml:space="preserve">
          <source>If the first character of the string returned by &lt;code&gt;mp.positive_sign()&lt;/code&gt; or &lt;code&gt;mp.negative_sign()&lt;/code&gt; is found in the &lt;code&gt;money_base::sign&lt;/code&gt; position of the formatting pattern, it is consumed, and the rest of the characters in that string are expected and consumed after all other components of the monetary value. If both &lt;code&gt;mp.positive_sign()&lt;/code&gt; and &lt;code&gt;mp.negative_sign()&lt;/code&gt; are non-empty, the sign is required and must match the first character of one of these strings. If one of theses strings is empty, the sign is optional (and if it is absent, the sign of the result corresponds to the string that was empty). If both strings are empty, or have the same first character, the result is given the positive sign. If the output parameter is a string (&lt;code&gt;digits&lt;/code&gt;) and the result is negative, the value &lt;code&gt;ct.widen('-')&lt;/code&gt; is stored as the first character of the result.</source>
          <target state="translated">如果在格式设置模式的 &lt;code&gt;money_base::sign&lt;/code&gt; 位置找到 &lt;code&gt;mp.positive_sign()&lt;/code&gt; 或 &lt;code&gt;mp.negative_sign()&lt;/code&gt; 返回的字符串的第一个字符，则该字符串将被消耗，并且该字符串中的其余字符将被预期在货币价值的所有其他组成部分之后消费。如果 &lt;code&gt;mp.positive_sign()&lt;/code&gt; 和 &lt;code&gt;mp.negative_sign()&lt;/code&gt; 如果为非空，则必须使用符号，并且必须与这些字符串之一的第一个字符匹配。如果这些字符串之一为空，则符号为可选（如果不存在，则结果的符号对应于为空的字符串）。如果两个字符串均为空或具有相同的第一个字符，则结果将带有正号。如果输出参数是字符串（ &lt;code&gt;digits&lt;/code&gt; ）并且结果为负数，则值 &lt;code&gt;ct.widen('-')&lt;/code&gt; 将存储为结果的第一个字符。</target>
        </trans-unit>
        <trans-unit id="6d83faa70c2aba93e1941e43de6bbfe2385cd57c" translate="yes" xml:space="preserve">
          <source>If the flag has static &lt;a href=&quot;../language/storage_duration#Storage_duration&quot;&gt;storage duration&lt;/a&gt;, this &lt;a href=&quot;../language/initialization#Static_initialization&quot;&gt;initialization is static&lt;/a&gt;.</source>
          <target state="translated">如果该标志具有静态&lt;a href=&quot;../language/storage_duration#Storage_duration&quot;&gt;存储持续时间&lt;/a&gt;，则此&lt;a href=&quot;../language/initialization#Static_initialization&quot;&gt;初始化为static&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0aca185ec9eaa4817332d6d1708fa168e08a203c" translate="yes" xml:space="preserve">
          <source>If the floating literal begins with the character sequence &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the floating literal is a</source>
          <target state="translated">如果浮动文字以字符序列 &lt;code&gt;0x&lt;/code&gt; 或 &lt;code&gt;0X&lt;/code&gt; 开头，则浮动文字为</target>
        </trans-unit>
        <trans-unit id="1fc39f622f213adb1f2c8d85a8aa6d829ea3b127" translate="yes" xml:space="preserve">
          <source>If the format specifier &lt;code&gt;%Z&lt;/code&gt; is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*abbrev&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null. If the format specifier &lt;code&gt;%z&lt;/code&gt; or a modified variant is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*offset&lt;/code&gt; if &lt;code&gt;offset&lt;/code&gt; is not null, and the parsed offset will be subtracted from the parsed timestamp before the difference is assigned to &lt;code&gt;tp&lt;/code&gt;.</source>
          <target state="translated">如果使用格式说明符 &lt;code&gt;%Z&lt;/code&gt; 并成功解析，则如果 &lt;code&gt;abbrev&lt;/code&gt; 不为null ，则将解析后的值分配给 &lt;code&gt;*abbrev&lt;/code&gt; 。如果使用格式说明符 &lt;code&gt;%z&lt;/code&gt; 或修改的变体并成功进行了解析，则如果 &lt;code&gt;offset&lt;/code&gt; 不为null ，则将解析后的值分配给 &lt;code&gt;*offset&lt;/code&gt; ，并且在将差值分配给 &lt;code&gt;tp&lt;/code&gt; 之前，将从解析的时间戳中减去解析后的偏移量。</target>
        </trans-unit>
        <trans-unit id="e503e2359ab45b0919fcc779613a87ba2c630429" translate="yes" xml:space="preserve">
          <source>If the format specifier &lt;code&gt;%Z&lt;/code&gt; is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*abbrev&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null. If the format specifier &lt;code&gt;%z&lt;/code&gt; or a modified variant is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*offset&lt;/code&gt; if &lt;code&gt;offset&lt;/code&gt; is not null.</source>
          <target state="translated">如果使用格式说明符 &lt;code&gt;%Z&lt;/code&gt; 并成功解析，则如果 &lt;code&gt;abbrev&lt;/code&gt; 不为null ，则将解析后的值分配给 &lt;code&gt;*abbrev&lt;/code&gt; 。如果使用格式说明符 &lt;code&gt;%z&lt;/code&gt; 或修改的变体并成功解析，则如果 &lt;code&gt;offset&lt;/code&gt; 不为null ，则将解析后的值分配给 &lt;code&gt;*offset&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ce235bdf9bf338e07e75bb2fe881d619ae23200" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;Derived::f&lt;/code&gt; overrides a function &lt;code&gt;Base::f&lt;/code&gt;, their return types must either be the same or be</source>
          <target state="translated">如果函数 &lt;code&gt;Derived::f&lt;/code&gt; 覆盖函数 &lt;code&gt;Base::f&lt;/code&gt; ，则它们的返回类型必须相同或相同。</target>
        </trans-unit>
        <trans-unit id="857c1e56c78b3e56396b067396f56e801e6dd2c3" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">如果专业化 &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; 的函数调用运算符调用一个比较指针的内置运算符，即使内置 &lt;code&gt;operator&amp;gt;&lt;/code&gt; 不会产生严格的总顺序。此严格的总顺序在专业化 &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; 是一致的，并且还与部分顺序一致由相应的内置运算符强加。</target>
        </trans-unit>
        <trans-unit id="efb23e76ae6241c0d68a489477442012c4a6ba54" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">如果专业化 &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; 的函数调用操作符调用一个比较指针的内置操作符，则即使内置 &lt;code&gt;operator&amp;gt;=&lt;/code&gt; 也不产生严格的总顺序。此严格的总顺序在专业化 &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; 是一致的，并且还与部分顺序一致由相应的内置运算符强加。</target>
        </trans-unit>
        <trans-unit id="7d4d6d78f770aad39153c1ff4080cd8ea8e3ca96" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">如果专门化 &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; 的函数调用运算符调用一个比较指针的内置运算符，则即使内置 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 没有，它也会产生严格的总顺序。此严格的总顺序在专业化 &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; 是一致的，并且还与部分顺序一致由相应的内置运算符强加。</target>
        </trans-unit>
        <trans-unit id="40559e5060a6bc4c31508f6386e2b42c2555e25e" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">如果专业化 &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; 的函数调用运算符调用一个比较指针的内置运算符，则即使内置 &lt;code&gt;operator&amp;lt;=&lt;/code&gt; 也不产生严格的总顺序。此严格的总顺序在专业化 &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; ， &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; 是一致的，并且还与部分顺序一致由相应的内置运算符强加。</target>
        </trans-unit>
        <trans-unit id="6d049b3d36607639d24052288370b34cd4ee531e" translate="yes" xml:space="preserve">
          <source>If the function extracts no characters (e.g. if &lt;code&gt;count &amp;lt; 1&lt;/code&gt;), &lt;code&gt;setstate(failbit)&lt;/code&gt; is executed.</source>
          <target state="translated">如果函数未提取任何字符（例如，如果 &lt;code&gt;count &amp;lt; 1&lt;/code&gt; ），则执行 &lt;code&gt;setstate(failbit)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f3778a28625a42b16a2c98400bf20b26542a73dd" translate="yes" xml:space="preserve">
          <source>If the function is called when no exception is being handled, an empty &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果在不处理任何异常的情况下调用了该函数，则返回一个空的 &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="251005437285fe4170728bd7ef6498ade0a544a1" translate="yes" xml:space="preserve">
          <source>If the function is overloaded, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; takes place first, and the program is only ill-formed if the deleted function was selected.</source>
          <target state="translated">如果函数过载，则首先进行&lt;a href=&quot;overload_resolution&quot;&gt;过载解析&lt;/a&gt;，并且仅在选择了已删除的函数的情况下程序才会格式错误。</target>
        </trans-unit>
        <trans-unit id="0813887879f4315c7f626d21875c1875367fd78d" translate="yes" xml:space="preserve">
          <source>If the function name names a function template, then, first, &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; is done, and if it succeeds, it produces a single template specialization which is added to the set of overloads to consider. All functions whose associated &lt;a href=&quot;constraints&quot;&gt;constraints&lt;/a&gt; are not satisfied are dropped from the set.(since C++20) If more than one function from the set matches the target, and at least one function is non-template, the template specializations are eliminated from consideration. For any pair of non-template functions where one is &lt;a href=&quot;constraints&quot;&gt;more constrained&lt;/a&gt; than another, the less constrained function is dropped from the set(since C++20). If all remaining candidates are template specializations, &lt;a href=&quot;partial_specialization&quot;&gt;less specialized&lt;/a&gt; ones are removed if more specialized are available. If more than one candidate remains after the removals, the program is ill-formed.</source>
          <target state="translated">如果函数名称为函数模板命名，则首先完成&lt;a href=&quot;template_argument_deduction&quot;&gt;模板参数推导&lt;/a&gt;，如果成功，它将产生单个模板特化，并将其添加到要考虑的重载集合中。从集合中删除所有不满足其关联&lt;a href=&quot;constraints&quot;&gt;约束的&lt;/a&gt;函数。（自C ++ 20起）如果集合中有多个函数与目标匹配，并且至少有一个函数不是模板，则将模板专长排除在考虑范围之外。对于任意一对非模板函数，其中一个&lt;a href=&quot;constraints&quot;&gt;约束&lt;/a&gt;比另一个约束更大，则从集合中删除约束较少的函数（因为C ++ 20）。如果所有剩余的候选人都是模板专长，则&lt;a href=&quot;partial_specialization&quot;&gt;不太专一&lt;/a&gt;如果可以使用更专业的工具，则将其删除。如果在撤职后剩下一个以上的候选人，则该计划的格式不正确。</target>
        </trans-unit>
        <trans-unit id="22b71c40978885e6386333f0b2f28d4de5c561ce" translate="yes" xml:space="preserve">
          <source>If the function selected by overload resolution does not exchange the values referenced by &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">如果通过重载分辨率选择的函数未交换 &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;u&lt;/code&gt; 引用的值，则程序格式错误；无需诊断。</target>
        </trans-unit>
        <trans-unit id="93d41cd28845eed34b17adb4d10684f1b1c26d1d" translate="yes" xml:space="preserve">
          <source>If the function that called &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; has exited, the behavior is undefined (in other words, only long jumps up the call stack are allowed).</source>
          <target state="translated">如果调用 &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; 的函数已经退出，则行为是不确定的（换句话说，只允许在调用堆栈上进行长跳转）。</target>
        </trans-unit>
        <trans-unit id="532af6d794823602f1906bb8fd26e75deeabc0c7" translate="yes" xml:space="preserve">
          <source>If the function throws an exception of the type not listed in its exception specification, the function &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is called. The default function calls &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;, but it may be replaced by a user-provided function (via &lt;code&gt;&lt;a href=&quot;../error/exception/set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt;) which may call &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; or throw an exception. If the exception thrown from &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is accepted by the exception specification, stack unwinding continues as usual. If it isn't, but &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is allowed by the exception specification, &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is thrown. Otherwise, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">如果该函数抛出其异常规范中未列出的类型的异常，则将调用函数 &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 。默认函数调用 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; ，但是它可以由用户提供的函数（通过 &lt;code&gt;&lt;a href=&quot;../error/exception/set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt; ）代替，该函数可以调用 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 或引发异常。如果异常规范接受了从 &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; 引发的异常，则堆栈展开将照常继续。如果不是，而是 &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 由异常规范允许的， &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 被抛出。否则，将调用 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4bb1179760bc730c31b7e350c9e316f8b5d5256" translate="yes" xml:space="preserve">
          <source>If the function-try-block is on a delegating constructor, which called a non-delegating constructor that completed successfully, but then the body of the delegating constructor throws, the destructor of this object will be completed before any catch clauses of the function-try-block are entered.</source>
          <target state="translated">如果函数-try-block在一个委托构造器上,该构造器调用了一个非委托构造器,该构造器成功完成了,但随后委托构造器的主体抛出了,那么在进入函数-try-block的任何捕捉子句之前,该对象的析构器将完成。</target>
        </trans-unit>
        <trans-unit id="7500ebfb29c88826fb63f492df6d76905a9569c0" translate="yes" xml:space="preserve">
          <source>If the get area is empty, calls &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; to determine the number of bytes available in the associated character sequence. In this case, the value returned is the number of bytes that can be extracted from the buffer while it's guaranteed that &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; would not return &lt;code&gt;Traits::eof&lt;/code&gt;.</source>
          <target state="translated">如果get区域为空，则调用 &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; 以确定关联字符序列中可用的字节数。在这种情况下，返回的值是可以从缓冲区提取的字节数，同时确保 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 不会返回 &lt;code&gt;Traits::eof&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b3eec597fe44d789a14bb34434aa90dd5be188a" translate="yes" xml:space="preserve">
          <source>If the implementation cannot parallelize or vectorize (e.g. due to lack of resources), all standard execution policies can fall back to sequential execution.</source>
          <target state="translated">如果执行不能并行化或矢量化(例如由于资源不足),所有标准执行策略都可以回落到顺序执行。</target>
        </trans-unit>
        <trans-unit id="1d83c11796c2c1e3f318ffcc89e81bbd5f8b11e8" translate="yes" xml:space="preserve">
          <source>If the implementation does not support floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to a positive value that is guaranteed to overflow a &lt;code&gt;float&lt;/code&gt; at compile time, and the use of this macro generates a compiler warning.</source>
          <target state="translated">如果实现不支持浮点无穷大，则宏 &lt;code&gt;INFINITY&lt;/code&gt; 会扩展为一个正值，保证在编译时会溢出 &lt;code&gt;float&lt;/code&gt; ，并且使用此宏会生成编译器警告。</target>
        </trans-unit>
        <trans-unit id="c2a825970a15face4ff4ecff0110e20adedc7e9c" translate="yes" xml:space="preserve">
          <source>If the implementation of this function requires a call to &lt;code&gt;new&lt;/code&gt; and the call fails, the returned pointer will hold a reference to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果此函数的实现需要对 &lt;code&gt;new&lt;/code&gt; 的调用而调用失败，则返回的指针将保存对 &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; 实例的引用。</target>
        </trans-unit>
        <trans-unit id="026f63aebd84e1c965f7e8366d68af982aae2ce8" translate="yes" xml:space="preserve">
          <source>If the implementation of this function requires copying the captured exception object and its copy constructor throws an exception, the returned pointer will hold a reference to the exception thrown. If the copy constructor of the thrown exception object also throws, the returned pointer may hold a reference to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; to break the endless loop.</source>
          <target state="translated">如果此函数的实现需要复制捕获的异常对象，并且其副本构造函数引发异常，则返回的指针将保存对引发的异常的引用。如果抛出的异常对象的副本构造函数也抛出，则返回的指针可能包含对 &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; 实例的引用，以打破无限循环。</target>
        </trans-unit>
        <trans-unit id="19ffe219703efe6527e00547f4a8cca5d22a9042" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),</source>
          <target state="translated">如果实现支持IEEE浮点算术(IEC 60559)。</target>
        </trans-unit>
        <trans-unit id="288c402c66673ce9a5009971c355fc8223b75acd" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;std::rint&lt;/code&gt; function:</source>
          <target state="translated">如果实现支持IEEE浮点算法（IEC 60559），则对于 &lt;code&gt;std::rint&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="0958ac9ba873e345e2bdc636b948c447e2e03547" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;std::round&lt;/code&gt; function:</source>
          <target state="translated">如果实现支持IEEE浮点算法（IEC 60559），则对于 &lt;code&gt;std::round&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="c7685e11635ec992c012cd0e03140bd9ce1479a3" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559), &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; is required to be non-zero.</source>
          <target state="translated">如果实现支持IEEE浮点算术（IEC 60559），则 &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; 必须为非零值。</target>
        </trans-unit>
        <trans-unit id="452d571ea8f52d84cf9e46de2bbbf6be56c3970a" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic,</source>
          <target state="translated">如果实现支持IEEE浮点算术。</target>
        </trans-unit>
        <trans-unit id="7392bc849012f8a7b52172fc01358b19f1c644b0" translate="yes" xml:space="preserve">
          <source>If the implementation supports floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to positive or unsigned infinity.</source>
          <target state="translated">如果实现支持浮点无穷大，则宏 &lt;code&gt;INFINITY&lt;/code&gt; 会扩展为 &lt;code&gt;float&lt;/code&gt; 类型的常量表达式，其计算结果为正无穷大。</target>
        </trans-unit>
        <trans-unit id="5ccfe7e9c2a2ea14c1997c4a20a1b44aba2730f7" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared copy assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined copy assignment copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the operator performs member-wise copy assignment of the object's bases and non-static members, in their initialization order, using built-in assignment for the scalars and copy assignment operator for class types.</source>
          <target state="translated">如果隐式声明的副本赋值运算符既不删除也不琐碎，则在&lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used的情况下&lt;/a&gt;由编译器定义（即，生成并编译函数体）。对于 &lt;code&gt;union&lt;/code&gt; 类型，隐式定义的副本分配会复制对象表示形式（如 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ）。对于非联合类类型（ &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;struct&lt;/code&gt; ），运算符使用标量的内置赋值和类类型的复制赋值运算符，按其初始化顺序对对象的基和非静态成员执行成员的逐份拷贝赋值。</target>
        </trans-unit>
        <trans-unit id="d8ae3f1b05db376bf2d23b1574a42628e3a6ef11" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared copy constructor is not deleted, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined copy constructor copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the constructor performs full member-wise copy of the object's bases and non-static members, in their initialization order, using direct initialization. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated copy constructor is &lt;code&gt;constexpr&lt;/code&gt;.(since C++11).</source>
          <target state="translated">如果未删除隐式声明的副本构造函数，则如果&lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used，&lt;/a&gt;则由编译器定义（即生成并编译函数体）。对于 &lt;code&gt;union&lt;/code&gt; 类型，隐式定义的副本构造函数将复制对象表示形式（如 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ）。对于非联合类类型（ &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;struct&lt;/code&gt; ），构造函数使用直接初始化按其初始化顺序对对象的基础和非静态成员执行完整的成员级复制。如果这满足&lt;a href=&quot;constexpr&quot;&gt;constexpr构造函数&lt;/a&gt;的要求，则生成的副本构造函数为 &lt;code&gt;constexpr&lt;/code&gt; （从C ++ 11开始）。</target>
        </trans-unit>
        <trans-unit id="30e62786983413b04a43c6ccf7b6769db6b9db27" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared default constructor is not defined as deleted, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, and it has exactly the same effect as a user-defined constructor with empty body and empty initializer list. That is, it calls the default constructors of the bases and of the non-static members of this class. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated constructor is &lt;code&gt;constexpr&lt;/code&gt;.(since C++11).</source>
          <target state="translated">如果未将隐式声明的默认构造函数定义为Delete，则在&lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used的情况下&lt;/a&gt;由编译器对其进行定义（即，生成并编译函数体），并且其效果与具有以下内容的用户定义构造函数完全相同：空的主体和空的初始化列表。也就是说，它调用此类的基类和非静态成员的默认构造函数。如果这满足&lt;a href=&quot;constexpr&quot;&gt;constexpr构造函数&lt;/a&gt;的要求，则生成的构造函数为 &lt;code&gt;constexpr&lt;/code&gt; （从C ++ 11开始）。</target>
        </trans-unit>
        <trans-unit id="c350045eebab9392561937d25bdc83283a8bc2b6" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared move assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;.</source>
          <target state="translated">如果隐式声明的移动赋值运算符既不删除也不琐碎，则在&lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used的情况下&lt;/a&gt;由编译器定义（即，生成并编译函数体）。</target>
        </trans-unit>
        <trans-unit id="ceab06f5631ee2653c87921d9ff9e756382351b1" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared move constructor is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined move constructor copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the move constructor performs full member-wise move of the object's bases and non-static members, in their initialization order, using direct initialization with an &lt;a href=&quot;value_category#xvalue&quot;&gt;xvalue&lt;/a&gt; argument. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated move constructor is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">如果隐式声明的move构造函数既不删除也不琐碎，则在&lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used的情况下&lt;/a&gt;由编译器定义（即，生成并编译函数体）。对于 &lt;code&gt;union&lt;/code&gt; 类型，隐式定义的move构造函数将复制对象表示形式（如 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ）。对于非联合类类型（ &lt;code&gt;class&lt;/code&gt; 和 &lt;code&gt;struct&lt;/code&gt; ），move构造函数使用带有&lt;a href=&quot;value_category#xvalue&quot;&gt;xvalue&lt;/a&gt;参数的直接初始化，以其初始化顺序对对象的基础和非静态成员执行完整的成员移动。如果这满足&lt;a href=&quot;constexpr&quot;&gt;constexpr构造函数&lt;/a&gt;的要求，则生成的move构造函数为 &lt;code&gt;constexpr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b006776f232a7b6fc30d9aed9df44514f27ef73" translate="yes" xml:space="preserve">
          <source>If the initialization &lt;a href=&quot;throw&quot;&gt;throws an exception&lt;/a&gt;, the variable is not considered to be initialized, and initialization will be attempted again the next time control passes through the declaration.</source>
          <target state="translated">如果初始化&lt;a href=&quot;throw&quot;&gt;引发异常&lt;/a&gt;，则该变量不被视为已初始化，并且下次控件通过声明时将再次尝试初始化。</target>
        </trans-unit>
        <trans-unit id="70a7998feab60665e9807c4931559d1fd72d7fb4" translate="yes" xml:space="preserve">
          <source>If the initialization of a non-inline variable(since C++17) is deferred to happen after the first statement of main/thread function, it happens before the first &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of any variable with static/thread storage duration defined in the same translation unit as the variable to be initialized. If no variable or function is odr-used from a given translation unit, the non-local variables defined in that translation unit may never be initialized (this models the behavior of an on-demand dynamic library). However, as long as anything from a translation unit is odr-used, all non-local variables whose initialization or destruction has side effects will be initialized even if they are not used in the program.</source>
          <target state="translated">如果将非内联变量的初始化（自C ++ 17起）推迟在main / thread函数的第一条语句之后进行，则它会在第一次&lt;a href=&quot;definition#ODR-use&quot;&gt;使用odd&lt;/a&gt;定义的静态/线程存储持续时间的变量之前发生与要初始化的变量相同的转换单元。如果没有从给定的翻译单元中使用任何变量或函数，则该翻译单元中定义的非局部变量可能永远不会初始化（这将模拟按需动态库的行为）。但是，只要使用了翻译单元中的任何内容，所有初始化或破坏了副作用的非局部变量都将被初始化，即使它们未在程序中使用。</target>
        </trans-unit>
        <trans-unit id="3f6bf015004432f99da972ebcadb65c84565ae76" translate="yes" xml:space="preserve">
          <source>If the initialization of a non-local variable with static or thread storage duration exits via an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">如果通过异常退出具有静态或线程存储持续时间的非局部变量的初始化，则将调用 &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1b11a1c3896d9b7ae4903a89c0351942d3a51b04" translate="yes" xml:space="preserve">
          <source>If the initialization of an inline variable is deferred, it happens before the first &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of that specific variable.</source>
          <target state="translated">如果推迟了内联变量的初始化，则它会在首次&lt;a href=&quot;definition#ODR-use&quot;&gt;使用&lt;/a&gt;该特定变量之前进行初始化。</target>
        </trans-unit>
        <trans-unit id="126551b23f54c215a6bae6f1387512974293e25e" translate="yes" xml:space="preserve">
          <source>If the initialization recursively enters the block in which the variable is being initialized, the behavior is undefined.</source>
          <target state="translated">如果初始化递归进入变量被初始化的区块,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="b698184c8fc9c6ca4e1b58ee7ce5abecef65b881" translate="yes" xml:space="preserve">
          <source>If the initializer (range_expression) is a braced-init-list, __range is deduced to be &lt;code&gt;std::initializer_list&amp;lt;&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">如果初始化程序（range_expression）是一个括号初始化列表，则将__range推导为 &lt;code&gt;std::initializer_list&amp;lt;&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f9de00dbbb1064006866fc50c910f17dedcc3df" translate="yes" xml:space="preserve">
          <source>If the initializer clause is a nested braced-init-list (which is not an expression), the corresponding array element/class member/public base(since C++17) is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt; from that clause: aggregate initialization is recursive.</source>
          <target state="translated">如果初始化器子句是嵌套的括号初始化列表（不是表达式），则从该子句对&lt;a href=&quot;list_initialization&quot;&gt;列表&lt;/a&gt;元素/类成员/公共基数（从C ++ 17开始）进行初始化：聚合初始化是递归的。</target>
        </trans-unit>
        <trans-unit id="263c85b919faedf2707a9f0cb930d424e5361608" translate="yes" xml:space="preserve">
          <source>If the initializer clause is an expression, implicit conversions are allowed as per copy-initialization, except, for &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; form, narrowing conversions are prohibited(since C++11).</source>
          <target state="translated">如果initializer子句是一个表达式，则按复制初始化允许进行隐式转换，但对于&lt;a href=&quot;list_initialization&quot;&gt;列表初始化&lt;/a&gt;形式，禁止缩小转换（自C ++ 11起）。</target>
        </trans-unit>
        <trans-unit id="9e522fac274022ad05f5205f4ec4d76c0dff7b8d" translate="yes" xml:space="preserve">
          <source>If the initializer is a braced-init-list &lt;code&gt;{&lt;/code&gt;arg1, arg2, ...&lt;code&gt;} &lt;/code&gt;, rules of &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt; are followed.</source>
          <target state="translated">如果初始化程序是braced-init-list &lt;code&gt;{&lt;/code&gt; arg1，arg2，... &lt;code&gt;} &lt;/code&gt; ，则遵循&lt;a href=&quot;list_initialization&quot;&gt;列表初始化&lt;/a&gt;规则。</target>
        </trans-unit>
        <trans-unit id="17a801942e1f9c93f9b22088a58723039bdb9b3e" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty and &lt;code&gt;T&lt;/code&gt; has a default constructor, phase 1 is skipped.</source>
          <target state="translated">如果初始化列表为空，并且 &lt;code&gt;T&lt;/code&gt; 具有默认构造函数，则将跳过阶段1。</target>
        </trans-unit>
        <trans-unit id="3e6d2d2dc08cc044669732b9dbb39c02db128762" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty, the values of &lt;a href=&quot;begin&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified, but will be identical.</source>
          <target state="translated">如果初始化列表为空，则未指定&lt;a href=&quot;begin&quot;&gt; &lt;code&gt;begin()&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;end()&lt;/code&gt; 的值，但它们是相同的。</target>
        </trans-unit>
        <trans-unit id="e4201a6a146ed0efc5a6cfe2c7d212a524559429" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty, the values of &lt;code&gt;begin()&lt;/code&gt; and &lt;a href=&quot;end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified, but will be identical.</source>
          <target state="translated">如果初始化列表为空，则未指定 &lt;code&gt;begin()&lt;/code&gt; 和&lt;a href=&quot;end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt;的值，但它们是相同的。</target>
        </trans-unit>
        <trans-unit id="d6346069140ef89aa4a40fbb67316690947509e3" translate="yes" xml:space="preserve">
          <source>If the input has been parsed into preprocessing tokens up to a given character, the next preprocessing token is generally taken to be the longest sequence of characters that could constitute a preprocessing token, even if that would cause subsequent analysis to fail. This is commonly known as</source>
          <target state="translated">如果输入已经被解析成最多给定字符的预处理令牌,那么下一个预处理令牌一般被认为是可能构成预处理令牌的最长字符序列,即使这会导致后续分析失败。这通常被称为</target>
        </trans-unit>
        <trans-unit id="15db5ceb85ecf11c1bb40aa49fe97037e6943c70" translate="yes" xml:space="preserve">
          <source>If the input iterator &lt;code&gt;beg&lt;/code&gt; becomes equal to &lt;code&gt;end&lt;/code&gt; before the parsing was completed, sets both &lt;code&gt;failbit&lt;/code&gt; and &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If parsing fails for another reason, sets the &lt;code&gt;failbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. Either way, does not modify the output parameter ((&lt;code&gt;units&lt;/code&gt; or &lt;code&gt;digits&lt;/code&gt;) on error.</source>
          <target state="translated">如果在解析完成之前输入的迭代器 &lt;code&gt;beg&lt;/code&gt; 等于 &lt;code&gt;end&lt;/code&gt; ，则在 &lt;code&gt;err&lt;/code&gt; 中设置 &lt;code&gt;failbit&lt;/code&gt; 和 &lt;code&gt;eofbit&lt;/code&gt; 。如果由于其他原因解析失败，请在 &lt;code&gt;err&lt;/code&gt; 中设置故障 &lt;code&gt;failbit&lt;/code&gt; 。无论哪种方式，都不会在出错时修改输出参数（（ &lt;code&gt;units&lt;/code&gt; 或 &lt;code&gt;digits&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="32e7c4b65d1f3ec9ebd0ad90287093fbb310dbce" translate="yes" xml:space="preserve">
          <source>If the input sequence has a read position available (&lt;code&gt;gptr() &amp;lt; egptr()&lt;/code&gt;, returns &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt;.</source>
          <target state="translated">如果输入序列具有可用的读取位置（ &lt;code&gt;gptr() &amp;lt; egptr()&lt;/code&gt; ，则返回 &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45b2d15e0da710723c3cf60d16eb11250968276f" translate="yes" xml:space="preserve">
          <source>If the input sequence read position is not available, returns &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt;. Otherwise returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;.</source>
          <target state="translated">如果输入序列读取位置不可用，则返回 &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; 。否则返回 &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f43632fd3506c566c7659b87242e4ba36c845b6" translate="yes" xml:space="preserve">
          <source>If the input sequence read position is not available, returns &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;. Otherwise returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;.</source>
          <target state="translated">如果输入序列读取位置不可用，则返回 &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; 。否则返回 &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a9116078f703a37d13100bfaf8b9930ee23b4bdb" translate="yes" xml:space="preserve">
          <source>If the insertion failed because the element already exists, returns an iterator to the already existing element with the equivalent key.</source>
          <target state="translated">如果因为元素已经存在而导致插入失败,则返回一个具有等价键的迭代器到已经存在的元素。</target>
        </trans-unit>
        <trans-unit id="a9fe612f9ce2e8b253c5cf483a66190457dfe15b" translate="yes" xml:space="preserve">
          <source>If the iterator holds a zero-length match and &lt;code&gt;start == end&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to end-of-sequence iterator and the function returns.</source>
          <target state="translated">如果迭代器保持零长度匹配并且 &lt;code&gt;start == end&lt;/code&gt; ，则将 &lt;code&gt;*this&lt;/code&gt; 设置为序列结束迭代器，然后函数返回。</target>
        </trans-unit>
        <trans-unit id="00ebb2aeeb1edae6ae85a26d3e1931e1626d24a9" translate="yes" xml:space="preserve">
          <source>If the lambda definition uses an explicit template parameter list, that template parameter list is used with &lt;code&gt;operator()&lt;/code&gt;. For every parameter in params whose type is specified as &lt;code&gt;auto&lt;/code&gt;, an additional invented template parameter is appended to the end of that template parameter list:</source>
          <target state="translated">如果lambda定义使用显式模板参数列表，则该模板参数列表将与 &lt;code&gt;operator()&lt;/code&gt; 一起使用。对于类型指定为 &lt;code&gt;auto&lt;/code&gt; 的 params中的每个参数，一个附加的发明模板参数将附加到该模板参数列表的末尾：</target>
        </trans-unit>
        <trans-unit id="c2e82d8a32eeab86a4c1f4f5bce0d91e5af9b994" translate="yes" xml:space="preserve">
          <source>If the lambda-expression captures anything by copy (either implicitly with capture clause &lt;code&gt;[=]&lt;/code&gt; or explicitly with a capture that does not include the character &amp;amp;, e.g. &lt;code&gt;[a, b, c]&lt;/code&gt;), the closure type includes unnamed non-static data members, declared in unspecified order, that hold copies of all entities that were so captured.</source>
          <target state="translated">如果lambda-expression通过副本捕获任何内容（使用capture子句 &lt;code&gt;[=]&lt;/code&gt; 隐式捕获或使用不包含字符＆的捕获显式捕获，例如 &lt;code&gt;[a, b, c]&lt;/code&gt; ），则闭包类型包括未命名的非静态数据以未指定顺序声明的成员，其中包含如此捕获的所有实体的副本。</target>
        </trans-unit>
        <trans-unit id="fd29e44a99211fd550448d9553f6ae1ad92b1445" translate="yes" xml:space="preserve">
          <source>If the last modification time is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::last_write_time(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::last_write_time(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">如果上次修改时间缓存在该 &lt;code&gt;directory_entry&lt;/code&gt; 中，则返回缓存的值。否则，分别返回 &lt;code&gt;std::filesystem::last_write_time(path())&lt;/code&gt; 或 &lt;code&gt;std::filesystem::last_write_time(path(), ec)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b9eab5ed5a441c8e5830c92fe0f6282d0707a87" translate="yes" xml:space="preserve">
          <source>If the left and the right operands identify overlapping objects, the behavior is undefined (unless the overlap is exact and the type is the same).</source>
          <target state="translated">如果左操作数和右操作数识别出重叠的对象,那么行为是未定义的(除非重叠是精确的,而且类型是相同的)。</target>
        </trans-unit>
        <trans-unit id="fa424ec54e9e85e6bf53212ac1a5db2c477f5b29" translate="yes" xml:space="preserve">
          <source>If the length specifier &lt;code&gt;l&lt;/code&gt; is not used, the conversion specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;[&lt;/code&gt; perform wide-to-multibyte character conversion as if by calling &lt;a href=&quot;../../string/multibyte/wcrtomb&quot;&gt;&lt;code&gt;wcrtomb()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="translated">如果长度说明符 &lt;code&gt;l&lt;/code&gt; 未使用的，转换说明 &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;s&lt;/code&gt; ，并 &lt;code&gt;[&lt;/code&gt; 通过调用执行宽到多字节字符转换仿佛&lt;a href=&quot;../../string/multibyte/wcrtomb&quot;&gt; &lt;code&gt;wcrtomb()&lt;/code&gt; &lt;/a&gt;用&lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt; &lt;code&gt;mbstate_t&lt;/code&gt; &lt;/a&gt;初始化为零对象的第一字符被转换之前。</target>
        </trans-unit>
        <trans-unit id="4854bc47bd09d34dbcbd17a9720f9b303f9e3fb1" translate="yes" xml:space="preserve">
          <source>If the literal operator is a template, it must have an empty parameter list and can have only one template parameter, which must be a non-type template parameter pack with element type &lt;code&gt;char&lt;/code&gt; (in which case it is known as a</source>
          <target state="translated">如果文字运算符是模板，则它必须有一个空的参数列表，并且只能有一个模板参数，该参数必须是元素类型为 &lt;code&gt;char&lt;/code&gt; 的非类型模板参数包（在这种情况下，它称为a</target>
        </trans-unit>
        <trans-unit id="fa1825d8cb36d3fdb7a1cdb0411663647de38a09" translate="yes" xml:space="preserve">
          <source>If the lock is &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; may provide better performance.</source>
          <target state="translated">如果锁定为 &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; 可能会提供更好的性能。</target>
        </trans-unit>
        <trans-unit id="2072cff7e155c80603cea5b9b2279dd4d08fd38c" translate="yes" xml:space="preserve">
          <source>If the lookup of a member of current instantiation gives a different result between the point of instantiation and the point of definition, the lookup is ambiguous. Note however that when a member name is used, it is not automatically converted to a class member access expression, only explicit member access expressions indicate members of current instantiation:</source>
          <target state="translated">如果对当前实例化的成员的查找,在实例化点和定义点之间给出了不同的结果,那么这个查找就是模糊的。但要注意的是,当使用成员名时,不会自动转换为类成员访问表达式,只有显式成员访问表达式才表示当前实例化的成员。</target>
        </trans-unit>
        <trans-unit id="01f377ce674649640d133ed5cc78ca704a3b02f5" translate="yes" xml:space="preserve">
          <source>If the lookup of the left hand side name comes up with a class/struct or union name, the name on the right hand side of &lt;code&gt;::&lt;/code&gt; is looked up in the scope of that class (and so may find a declaration of a member of that class or of its base), with the following exceptions.</source>
          <target state="translated">如果左侧名的查找来了一个类/结构或联合的名称，在右侧的名字 &lt;code&gt;::&lt;/code&gt; 在该类的范围抬头（因此可能会发现成员的声明该类或其基类），但以下情况除外。</target>
        </trans-unit>
        <trans-unit id="d37b88b9ada3dd332af605d1fd3e5a8cf0eb71e3" translate="yes" xml:space="preserve">
          <source>If the lookup of the left-hand side name comes up with an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; (either scoped or unscoped), the lookup of the right-hand side must result in an enumerator that belongs that enumeration, otherwise the program is ill-formed.</source>
          <target state="translated">如果对左侧名称的查找带有&lt;a href=&quot;enum&quot;&gt;枚举&lt;/a&gt;（范围内的或未限定范围的），则右侧的查找必须产生属于该枚举的枚举器，否则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="1c84f7f76196e3d1858123032bdb6f7a708a9edc" translate="yes" xml:space="preserve">
          <source>If the main function is defined with a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, the exceptions thrown by the destructors of static objects (which are destroyed by the implied &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;) are not caught by it.</source>
          <target state="translated">如果main函数是使用&lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;定义的，则静态对象的析构函数抛出的异常（由隐式 &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; 销毁）不会捕获该异常。</target>
        </trans-unit>
        <trans-unit id="3e06f91c09b7d51a80ad502bd1ebea399586e472" translate="yes" xml:space="preserve">
          <source>If the match does not exist:</source>
          <target state="translated">如果匹配不存在。</target>
        </trans-unit>
        <trans-unit id="7e82db05b3b86f89f14289a124a974cfc8812bd1" translate="yes" xml:space="preserve">
          <source>If the match exists:</source>
          <target state="translated">如果匹配存在。</target>
        </trans-unit>
        <trans-unit id="4183569bf1256905bbaf650046e97c16dae9e0cc" translate="yes" xml:space="preserve">
          <source>If the meaning of a</source>
          <target state="translated">如果一个</target>
        </trans-unit>
        <trans-unit id="e85a366ebfca22ae74e5b65314e65c8d7039ce9f" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unary minus&lt;/a&gt; in the result type, which applies unsigned integer wraparound rules.</source>
          <target state="translated">如果减号是输入序列的一部分，则从数字序列计算出的数值将被否定，就好像结果类型中的&lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;一元减号一样&lt;/a&gt;，这将应用无符号整数环绕规则。</target>
        </trans-unit>
        <trans-unit id="9ec415c505d275361f5e319da3ba14be0e8e4bd1" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unary minus&lt;/a&gt; in the result type.</source>
          <target state="translated">如果减号是输入序列的一部分，则从数字序列计算出的数值将被否定，就好像结果类型中的&lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;一元减号一样&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5755fdc9594791908fc98437469bea77cb6e1fd5" translate="yes" xml:space="preserve">
          <source>If the most recent match was not a zero-length match, the operator sets &lt;code&gt;flags&lt;/code&gt; to &lt;code&gt;flags | regex_constants::match_prev_avail&lt;/code&gt; and invokes the following:</source>
          <target state="translated">如果最近的匹配不是零长度匹配，则运算符将 &lt;code&gt;flags&lt;/code&gt; 设置为 &lt;code&gt;flags | regex_constants::match_prev_avail&lt;/code&gt; 并调用以下命令：</target>
        </trans-unit>
        <trans-unit id="d96faf371e54d959541ad721b9a13b1a3685ad32" translate="yes" xml:space="preserve">
          <source>If the most recently called function, out of &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;seekpos()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt;, was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, then calls &lt;code&gt;std::codecvt::unshift()&lt;/code&gt;, perhaps multiple times, to determine the unshift sequence according to the imbued locale, and writes that sequence to file with &lt;code&gt;overflow(Traits::eof())&lt;/code&gt;.</source>
          <target state="translated">如果在 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;seekpos()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; 中，最近调用的函数是 &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; ，则可能多次调用 &lt;code&gt;std::codecvt::unshift()&lt;/code&gt; 来确定根据注入的语言环境取消移位序列，并使用 &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; 将该序列写入文件。</target>
        </trans-unit>
        <trans-unit id="90491130497fa2fc6497b24640b7ae73bc68aa73" translate="yes" xml:space="preserve">
          <source>If the multibyte character encoding is state-dependent (&lt;a href=&quot;../../locale/codecvt/encoding&quot;&gt;&lt;code&gt;codecvt::encoding()&lt;/code&gt;&lt;/a&gt; returned &lt;code&gt;-1&lt;/code&gt;) or variable-length (&lt;code&gt;codecvt::encoding()&lt;/code&gt; returned &lt;code&gt;​0​&lt;/code&gt;) and the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;​0​&lt;/code&gt;, fails immediately: this function cannot determine the number of bytes that correspond to &lt;code&gt;off&lt;/code&gt; characters.</source>
          <target state="translated">如果多字节字符编码是状态依赖（&lt;a href=&quot;../../locale/codecvt/encoding&quot;&gt; &lt;code&gt;codecvt::encoding()&lt;/code&gt; &lt;/a&gt;返回 &lt;code&gt;-1&lt;/code&gt; ）或可变长度（ &lt;code&gt;codecvt::encoding()&lt;/code&gt; 返回 &lt;code&gt;​0​&lt;/code&gt; ），并且偏移 &lt;code&gt;off&lt;/code&gt; 不是 &lt;code&gt;​0​&lt;/code&gt; ，立即失败：此函数无法确定与 &lt;code&gt;off&lt;/code&gt; 字符相对应的字节数。</target>
        </trans-unit>
        <trans-unit id="312e4e4f74f5b82f6bd25b87461c9b4fbde989e6" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc16&lt;/code&gt; will write out the additional char16_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;*s&lt;/code&gt; 中的多字节字符对应于multi-char16_t序列（例如UTF-16中的代理对），则在首次调用此函数后，将更新 &lt;code&gt;*ps&lt;/code&gt; ，以使下一次对 &lt;code&gt;mbrtoc16&lt;/code&gt; 的调用将写入排除掉额外的char16_t，而不考虑 &lt;code&gt;*s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcb6afe2a5acb943ad2fdd6f475921c6ce71ebf8" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next calls to &lt;code&gt;mbrtoc32&lt;/code&gt; will write out the additional char32_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;*s&lt;/code&gt; 中的多字节字符对应于multi-char32_t序列（对于UTF-32则不可能），则在第一次调用此函数后，将更新 &lt;code&gt;*ps&lt;/code&gt; ，以使下一次对 &lt;code&gt;mbrtoc32&lt;/code&gt; 的调用将写出额外的char32_t，而不考虑 &lt;code&gt;*s&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="baf70aa7bd1cf40829d0398b1fa87e9dc92941f8" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked by this &lt;code&gt;std::unique_lock&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果互斥锁已被此 &lt;code&gt;std::unique_lock&lt;/code&gt; 锁定，则 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 的错误代码为 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26a0b8cab69da9fd4564dd153dc7e72537daded3" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked by this &lt;code&gt;unique_lock&lt;/code&gt; (in other words, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; is true), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果互斥锁已被此 &lt;code&gt;unique_lock&lt;/code&gt; 锁定（换句话说，&lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt;为true），则 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 的错误代码为 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="554e21c6a83788b53dc332bdeec20b2bc45e361b" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果互斥锁已被锁定，则 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 的错误代码为 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5f5c7e5fb56183cbccedca22001e62c7b4f9e65" translate="yes" xml:space="preserve">
          <source>If the name appears immediately to the right of the scope resolution operator &lt;code&gt;::&lt;/code&gt; or possibly after &lt;code&gt;::&lt;/code&gt; followed by the disambiguating keyword &lt;code&gt;template&lt;/code&gt;, see.</source>
          <target state="translated">如果名称立即显示在范围解析运算符 &lt;code&gt;::&lt;/code&gt; 的右侧，或者可能在 &lt;code&gt;::&lt;/code&gt; 之后紧随其后的是不含歧义的关键字 &lt;code&gt;template&lt;/code&gt; ，请参见。</target>
        </trans-unit>
        <trans-unit id="12c49bf8d3ab86a8d2eba4533e6f3ce9e54beb97" translate="yes" xml:space="preserve">
          <source>If the name lookup does not find a previously declared type name, the elaborated-type-specifier is introduced by &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; (i.e. not by &lt;code&gt;enum&lt;/code&gt;), and class-name is an unqualified identifier, then the elaborated-type-specifier is a class declaration of the class-name.</source>
          <target state="translated">如果名称查找未找到先前声明的类型名称，则通过 &lt;code&gt;class&lt;/code&gt; ， &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; （即不是通过 &lt;code&gt;enum&lt;/code&gt; ）引入elaborated-type-specifier ，并且class-name是不合格的标识符，则elaborated-type-说明符是类名称的类声明。</target>
        </trans-unit>
        <trans-unit id="680aaf5d39f0524608d21769dd7093d5030e0ccf" translate="yes" xml:space="preserve">
          <source>If the name of the class itself appears as class-or-identifier in the member initializer list, then the list must consist of that one member initializer only; such constructor is known as the</source>
          <target state="translated">如果类本身的名称以类或标识符的形式出现在成员初始化器列表中,那么列表中必须只包含这一个成员初始化器;这样的构造函数被称为是</target>
        </trans-unit>
        <trans-unit id="b15648eb5df5f87645e8346a354b1f3da3971a94" translate="yes" xml:space="preserve">
          <source>If the name on the left of &lt;code&gt;::&lt;/code&gt; refers to a namespace or if there is nothing on the left of &lt;code&gt;::&lt;/code&gt; (in which case it refers to the global namespace), the name that appears on the right hand side of &lt;code&gt;::&lt;/code&gt; is looked up in the scope of that namespace, except that.</source>
          <target state="translated">如果 &lt;code&gt;::&lt;/code&gt; 左侧的名称是指名称空间，或者 &lt;code&gt;::&lt;/code&gt; 左侧没有任何内容（在这种情况下，它是指全局名称空间），则将查找 &lt;code&gt;::&lt;/code&gt; 右侧显示的名称。除了那个名称空间之外。</target>
        </trans-unit>
        <trans-unit id="351414d67b6211a3be33d9c5a18059ec3fe49dc4" translate="yes" xml:space="preserve">
          <source>If the name refers to a &lt;a href=&quot;typedef&quot;&gt;typedef name&lt;/a&gt;, a &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt;, a &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;template type parameter&lt;/a&gt;, or an &lt;a href=&quot;type_alias&quot;&gt;alias template specialization&lt;/a&gt;, the program is ill-formed, otherwise the elaborated type specifier introduces the name into the declaration the same way a &lt;a href=&quot;declarations#Specifiers&quot;&gt;simple type specifier&lt;/a&gt; introduces its type-name.</source>
          <target state="translated">如果名称引用&lt;a href=&quot;typedef&quot;&gt;typedef名称&lt;/a&gt;，&lt;a href=&quot;type_alias&quot;&gt;类型别名&lt;/a&gt;，&lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;模板类型参数&lt;/a&gt;或&lt;a href=&quot;type_alias&quot;&gt;别名模板特殊化&lt;/a&gt;，则程序格式错误，否则精心设计的类型说明符将名称引入声明中，就像&lt;a href=&quot;declarations#Specifiers&quot;&gt;简单类型说明符&lt;/a&gt;引入的方式一样它的类型名称。</target>
        </trans-unit>
        <trans-unit id="7bf4ac13d848aeaa14204e7424d717fa7118c92d" translate="yes" xml:space="preserve">
          <source>If the names of two parameter packs appear in the same pattern, they are expanded simultaneously, and they must have the same length:</source>
          <target state="translated">如果两个参数包的名称出现在相同的模式中,它们会同时展开,而且它们的长度必须相同。</target>
        </trans-unit>
        <trans-unit id="a2b281f14bc994fec6ff8448c81b41b3e5d1e437" translate="yes" xml:space="preserve">
          <source>If the nearest enclosing function declarator is not the declarator of a function definition, its potential scope ends at the end of that function declarator.</source>
          <target state="translated">如果最近的包围函数声明符不是函数定义的声明符,那么它的潜在作用域就结束于该函数声明符的末端。</target>
        </trans-unit>
        <trans-unit id="b5670784086b76d24bb1fae4d2445942134f26af" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.</source>
          <target state="translated">如果新的 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 大于 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; 则所有迭代器和引用（包括过去的迭代器）均无效。否则，只有过去的迭代器是无效的。</target>
        </trans-unit>
        <trans-unit id="cf94debed8cd7dc4895c7d2f2f99ed8c3d0eef6f" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</source>
          <target state="translated">如果新的 &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; 大于 &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; ，则所有迭代器和引用均无效。否则，只有插入点之前的迭代器和引用保持有效。过去的迭代器也无效。</target>
        </trans-unit>
        <trans-unit id="7ea2ea05865b3c53570d6c768a8336b0fce606d3" translate="yes" xml:space="preserve">
          <source>If the new size is bigger than the old one : all iterators are invalidated</source>
          <target state="translated">如果新的尺寸大于旧的尺寸:所有的迭代都无效。</target>
        </trans-unit>
        <trans-unit id="92c6212e4fbc62d508c776cafe31778487d050cd" translate="yes" xml:space="preserve">
          <source>If the new size is smaller than the old one : only erased elements and the past-the-end iterator</source>
          <target state="translated">如果新的尺寸小于旧的尺寸:只有被擦除的元素和过去的迭代器。</target>
        </trans-unit>
        <trans-unit id="b4edb10d6256f62d87a1b6332196a1e63e973276" translate="yes" xml:space="preserve">
          <source>If the next character begins a sequence of characters that could be the prefix and initial double quote of a &lt;a href=&quot;string_literal&quot;&gt;raw string literal&lt;/a&gt;, the next preprocessing token shall be a raw string literal. The literal consists of the shortest sequence of characters that matches the raw-string pattern.</source>
          <target state="translated">如果下一个字符以字符序列开头，这些字符序列可以是&lt;a href=&quot;string_literal&quot;&gt;原始字符串文字&lt;/a&gt;的前缀和初始双引号，则下一个预处理令牌应为原始字符串文字。文字包含与原始字符串模式匹配的最短字符序列。</target>
        </trans-unit>
        <trans-unit id="d33bd7b55fb01fe98f2f3acadf5f6a08379b3852" translate="yes" xml:space="preserve">
          <source>If the next pointer for the put area (&lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::streambuf::pptr()&lt;/a&gt;&lt;/code&gt;) is a null pointer, returns zero.</source>
          <target state="translated">如果放置区域的下一个指针（ &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::streambuf::pptr()&lt;/a&gt;&lt;/code&gt; ）为空指针，则返回零。</target>
        </trans-unit>
        <trans-unit id="f2a3a5f033565b87ab609d62fb110b1186e8e3e4" translate="yes" xml:space="preserve">
          <source>If the next pointer is greater than the beginning pointer in a get area, a</source>
          <target state="translated">如果在get区域中,下一个指针大于起始指针,那么一个</target>
        </trans-unit>
        <trans-unit id="c38cc8ddc7ddabb28e42f0dfb6f798c707698933" translate="yes" xml:space="preserve">
          <source>If the next pointer is less than the end pointer in the get area, a</source>
          <target state="translated">如果下一个指针小于get区域的结束指针,则会出现一个</target>
        </trans-unit>
        <trans-unit id="c4b8d1b94f24bba646631c4092b8de8ae27a04b9" translate="yes" xml:space="preserve">
          <source>If the next pointer is less than the end pointer in the put area, a</source>
          <target state="translated">如果下一个指针小于put区域的结束指针,则会出现一个</target>
        </trans-unit>
        <trans-unit id="9a69438e54d280f6f9ab5d647f4340372fb34e64" translate="yes" xml:space="preserve">
          <source>If the next three characters are &lt;code&gt;&amp;lt;::&lt;/code&gt; and the subsequent character is neither &lt;code&gt;:&lt;/code&gt; nor &lt;code&gt;&amp;gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; is treated as a preprocessing token by itself (and not as the first character of the &lt;a href=&quot;operator_alternative&quot;&gt;alternative token&lt;/a&gt;&lt;code&gt;&amp;lt;:&lt;/code&gt;).</source>
          <target state="translated">如果接下来的三个字符是 &lt;code&gt;&amp;lt;::&lt;/code&gt; ，后一个字符既不是 &lt;code&gt;:&lt;/code&gt; 也不是 &lt;code&gt;&amp;gt;&lt;/code&gt; ，则 &lt;code&gt;&amp;lt;&lt;/code&gt; 本身将被视为预处理令牌（而不是&lt;a href=&quot;operator_alternative&quot;&gt;替代令牌&lt;/a&gt; &lt;code&gt;&amp;lt;:&lt;/code&gt; 的第一个字符）。</target>
        </trans-unit>
        <trans-unit id="af14e08b4fe197ba9df3e02d9b9e83c72cf7dc83" translate="yes" xml:space="preserve">
          <source>If the number of characters generated for the specified format is less than the value returned by &lt;code&gt;str.width()&lt;/code&gt;, then copies of &lt;code&gt;fill&lt;/code&gt; are inserted to bring the total length of the output sequence to exactly &lt;code&gt;str.width()&lt;/code&gt;, as follows:</source>
          <target state="translated">如果为指定格式生成的字符数少于 &lt;code&gt;str.width()&lt;/code&gt; 返回的值，则将插入 &lt;code&gt;fill&lt;/code&gt; 副本，以将输出序列的总长度精确地 &lt;code&gt;str.width()&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="f0d99c831c2d187591fcd3895e3191880ca06c5c" translate="yes" xml:space="preserve">
          <source>If the number of hard links is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::hard_link_count(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::hard_link_count(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">如果在该 &lt;code&gt;directory_entry&lt;/code&gt; 中缓存了硬链接数，则返回缓存的值。否则，分别返回 &lt;code&gt;std::filesystem::hard_link_count(path())&lt;/code&gt; 或 &lt;code&gt;std::filesystem::hard_link_count(path(), ec)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b99a05a29894a68183df39a196889aa25aa975f9" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses exceeds the number of members and bases(since C++17) to initialize, the program is ill-formed.</source>
          <target state="translated">如果初始化子句的数量超过了要初始化的成员和基数(自C++17以来),则程序是错误的。</target>
        </trans-unit>
        <trans-unit id="b81ad8faee1ff23ba51f5fbba00473611ac8e7b6" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses is less than the number of members and bases(since C++17) or initializer list is completely empty, the remaining members and bases(since C++17) are initialized by their &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;, if provided in the class definition, and otherwise(since C++14) by empty lists, in accordance with the usual &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; rules (which performs value-initialization for non-class types and non-aggregate classes with default constructors, and aggregate initialization for aggregates). If a member of a reference type is one of these remaining members, the program is ill-formed.</source>
          <target state="translated">如果初始化程序子句的数量少于成员和基数（自C ++ 17起）的数量，或者初始化器列表完全为空，则其余成员和基数（自C ++ 17起）由其&lt;a href=&quot;data_members#Member_initialization&quot;&gt;默认成员初始化器初始化&lt;/a&gt;，如果在类定义中提供，否则（自C ++ 14起）由空列表提供，遵循通常的&lt;a href=&quot;list_initialization&quot;&gt;列表初始化&lt;/a&gt;规则（该规则对具有默认构造函数的非类类型和非聚合类执行值初始化，以及聚合初始化聚合）。如果引用类型的成员是这些其余成员之一，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="bb0f41458b43834e51177c5651bbd7795714a125" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses is less than the number of members or initializer list is completely empty, the remaining members are &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;. If a member of a reference type is one of these remaining members, the program is ill-formed.</source>
          <target state="translated">如果初始化程序子句的数量少于成员数量，或者初始化程序列表完全为空，则其余成员将被&lt;a href=&quot;value_initialization&quot;&gt;值初始化&lt;/a&gt;。如果引用类型的成员是这些其余成员之一，则程序格式错误。</target>
        </trans-unit>
        <trans-unit id="b0ce7ffb5fd666d693981b8165606cef96184b92" translate="yes" xml:space="preserve">
          <source>If the number of variants is larger than 1, the invocation of the callable object has no complexity requirements.</source>
          <target state="translated">如果变体数量大于1,则对可调用对象的调用没有复杂性要求。</target>
        </trans-unit>
        <trans-unit id="30a909a72a6ffc780941652c5f3605de8c85f27e" translate="yes" xml:space="preserve">
          <source>If the object being deleted has incomplete class type at the point of deletion, and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</source>
          <target state="translated">如果被删除的对象在删除时具有不完整的类类型,而完整的类有一个非平凡的析构函数或deallocation函数,则该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="94419747850ceda4ef56a69f80c16b2a13fb641e" translate="yes" xml:space="preserve">
          <source>If the object contains a value and the type &lt;code&gt;T&lt;/code&gt; is not trivially destructible (see &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible&lt;/a&gt;&lt;/code&gt;), destroys the contained value by calling its destructor, as if by &lt;code&gt;value().T::~T()&lt;/code&gt;.</source>
          <target state="translated">如果对象包含一个值并且类型 &lt;code&gt;T&lt;/code&gt; 不可 &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible&lt;/a&gt;&lt;/code&gt; （请参见std :: is_trivially_destructible），则通过调用其析构函数销毁所包含的值，就像通过 &lt;code&gt;value().T::~T()&lt;/code&gt; 〜T（）一样。</target>
        </trans-unit>
        <trans-unit id="ec70e1f18459a8290a0f4bd35e232554ccfd607b" translate="yes" xml:space="preserve">
          <source>If the object is an array of unknown size, and the supplied brace-enclosed initializer list has &lt;code&gt;n&lt;/code&gt; clauses, the size of the array is &lt;code&gt;n&lt;/code&gt;. (Note that the object in this case cannot be a non-static data member: a member must have complete type.)</source>
          <target state="translated">如果对象是未知大小的数组，并且提供的用括号括起来的初始化程序列表包含 &lt;code&gt;n&lt;/code&gt; 个子句，则数组的大小为 &lt;code&gt;n&lt;/code&gt; 。（请注意，在这种情况下，对象不能是非静态数据成员：成员必须具有完整的类型。）</target>
        </trans-unit>
        <trans-unit id="dc925382d2c313f9d5510edd341c98dae666642c" translate="yes" xml:space="preserve">
          <source>If the object pointed to by &lt;code&gt;ptr&lt;/code&gt; is already owned, the function results in undefined behavior.</source>
          <target state="translated">如果 &lt;code&gt;ptr&lt;/code&gt; 指向的对象已经拥有，则该函数将导致未定义的行为。</target>
        </trans-unit>
        <trans-unit id="6178c7826636249aa31114e15b28fd10b4ae9c38" translate="yes" xml:space="preserve">
          <source>If the object to which the glvalue refers contains an indeterminate value (such as obtained by &lt;a href=&quot;default_initialization&quot;&gt;default initializing&lt;/a&gt; a non-class automatic variable), the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;.</source>
          <target state="translated">如果glvalue引用的对象包含不确定的值（例如&lt;a href=&quot;default_initialization&quot;&gt;默认情况下&lt;/a&gt;通过初始化非类自动变量获得的值），则该行为是&lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="854c163308d68bcd5f11e6e68fac53ee79ca0fa5" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memcpy&lt;/code&gt; is not specified and &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="translated">如果对象&lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;可能重叠&lt;/a&gt;或不可&lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;，则不会指定 &lt;code&gt;memcpy&lt;/code&gt; 的行为，并且&lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;可能未定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e24e2140fc5eb50908480c6b3a23eb41b37cf132" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memcpy&lt;/code&gt; is not specified and &lt;a href=&quot;https://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ec58c2abf0222a29b0c8fffc8a48f853af4796" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memmove&lt;/code&gt; is not specified and &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="translated">如果对象&lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;可能重叠&lt;/a&gt;或不可&lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;，则不会指定 &lt;code&gt;memmove&lt;/code&gt; 的行为，并且&lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;可能未定义&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="547b06003f53e07b23459e9de5e95b459a9ac7c1" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memmove&lt;/code&gt; is not specified and &lt;a href=&quot;https://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af231aef821c421dada8c16256fc78ace43c4fd5" translate="yes" xml:space="preserve">
          <source>If the objects are not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">如果对象不是&lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="7439cc88d3247f96faa2170d824e55add0c21fea" translate="yes" xml:space="preserve">
          <source>If the objects overlap, the behavior is undefined.</source>
          <target state="translated">如果对象重叠,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="cfd990fe5c8c1f9320d43b19453f94b1906d5b8d" translate="yes" xml:space="preserve">
          <source>If the old locale's encoding is state-dependent and file is not positioned at the beginning, then the new locale must have the same &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet as the one previously imbued.</source>
          <target state="translated">如果旧的语言环境的编码与状态有关，并且文件未放在开头，则新的语言环境必须具有与先前 &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; 的相同的std :: codecvt构面。</target>
        </trans-unit>
        <trans-unit id="7518873ec88dce6433b77a202724dd872b5facce" translate="yes" xml:space="preserve">
          <source>If the old pointer was non-empty, deletes the previously managed object &lt;code&gt;if(old_ptr) get_deleter()(old_ptr)&lt;/code&gt;.</source>
          <target state="translated">如果旧指针为非空，则删除先前管理的对象 &lt;code&gt;if(old_ptr) get_deleter()(old_ptr)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4dd6552f73dd69bf5933722a03efee57f0b98bea" translate="yes" xml:space="preserve">
          <source>If the open operation succeeds and &lt;code&gt;openmode &amp;amp; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt; != 0&lt;/code&gt; (the &lt;code&gt;ate&lt;/code&gt; bit is set), repositions the file position to the end of file, as if by calling &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;)&lt;/code&gt;, where &lt;code&gt;file&lt;/code&gt; is the pointer returned by calling &lt;code&gt;fopen&lt;/code&gt;. If the repositioning fails, calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; and returns a null pointer to indicate failure.</source>
          <target state="translated">如果打开操作成功并且 &lt;code&gt;openmode &amp;amp; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt; != 0&lt;/code&gt; （设置了 &lt;code&gt;ate&lt;/code&gt; 位），则将文件位置重新定位到文件末尾，就像通过调用 &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;)&lt;/code&gt; ，其中 &lt;code&gt;file&lt;/code&gt; 是调用 &lt;code&gt;fopen&lt;/code&gt; 返回的指针。如果重新定位失败，则调用 &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; 并返回一个空指针以指示失败。</target>
        </trans-unit>
        <trans-unit id="1df990f7386ff3f2cc16de12a9e72eb727c483f2" translate="yes" xml:space="preserve">
          <source>If the operand is not &lt;code&gt;bool&lt;/code&gt;, it is converted to &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;implicit_cast&quot;&gt;contextual conversion to bool&lt;/a&gt;: it is only well-formed if the declaration &lt;code&gt;bool t(arg)&lt;/code&gt; is well-formed, for some invented temporary &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">如果操作数不是 &lt;code&gt;bool&lt;/code&gt; ，则使用&lt;a href=&quot;implicit_cast&quot;&gt;上下文转换&lt;/a&gt;为 &lt;code&gt;bool&lt;/code&gt; 来将其转换为bool：对于某些发明的临时 &lt;code&gt;t&lt;/code&gt; ，只有声明 &lt;code&gt;bool t(arg)&lt;/code&gt; 格式正确时，格式才正确。</target>
        </trans-unit>
        <trans-unit id="910435839383d33c5dc2d8d4ba19e0ed1ca648ae" translate="yes" xml:space="preserve">
          <source>If the operand is the name of an overloaded function, the address may be taken only if the overload can be resolved due to context. See &lt;a href=&quot;overloaded_address&quot;&gt;Address of an overloaded function&lt;/a&gt; for details.</source>
          <target state="translated">如果操作数是重载函数的名称，则仅当可以根据上下文解决重载时，才可以使用该地址。有关详细信息，请参见&lt;a href=&quot;overloaded_address&quot;&gt;重载函数的地址&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="edcca376b9017a314c5ce3c74e8c8cd913ab1436" translate="yes" xml:space="preserve">
          <source>If the operand of the post-increment operator is of type &lt;code&gt;bool&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt;(deprecated).(until C++17).</source>
          <target state="translated">如果后递增运算符的操作数的类型为 &lt;code&gt;bool&lt;/code&gt; ，则将其设置为 &lt;code&gt;true&lt;/code&gt; （不建议使用）。（直到C ++ 17）。</target>
        </trans-unit>
        <trans-unit id="6058f3bacdd6399a42fe9ae2e370059cb00c4139" translate="yes" xml:space="preserve">
          <source>If the operand of the pre-increment operator is of type &lt;code&gt;bool&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt;(deprecated).(until C++17).</source>
          <target state="translated">如果pre-increment运算符的操作数是 &lt;code&gt;bool&lt;/code&gt; 类型，则将其设置为 &lt;code&gt;true&lt;/code&gt; （不建议使用）。（直到C ++ 17）。</target>
        </trans-unit>
        <trans-unit id="6c5fbbf8cf6f23e69c16207aea6b5866059dd114" translate="yes" xml:space="preserve">
          <source>If the operand passed to an arithmetic operator is integral or unscoped enumeration type, then before any other action (but after lvalue-to-rvalue conversion, if applicable), the operand undergoes &lt;a href=&quot;implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;. If an operand has array or function type, array-to-pointer and function-to-pointer conversions are applied.</source>
          <target state="translated">如果传递给算术运算符的操作数是整数或无作用域枚举类型，则在执行任何其他操作之前（但在从左值到右值转换之后，如果适用），该操作数将经历&lt;a href=&quot;implicit_cast#Integral_promotion&quot;&gt;整数提升&lt;/a&gt;。如果操作数具有数组或函数类型，则将应用数组到指针和函数到指针的转换。</target>
        </trans-unit>
        <trans-unit id="b2856e7c84ee7bcd9c7d54aff911eeecd1a576e8" translate="yes" xml:space="preserve">
          <source>If the operand to &lt;code&gt;typeid&lt;/code&gt; is a class type or a reference to a class type, then that class type must not be an &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;.</source>
          <target state="translated">如果对 &lt;code&gt;typeid&lt;/code&gt; 的操作数是类类型或对类类型的引用，则该类类型一定不能是&lt;a href=&quot;incomplete_type&quot;&gt;不完整的类型&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a6f60e09ec075130d1f28f4c735c3e62c6710a29" translate="yes" xml:space="preserve">
          <source>If the operands has arithmetic or enumeration type (scoped or unscoped),</source>
          <target state="translated">如果操作数有算术型或枚举型(有范围或无范围)。</target>
        </trans-unit>
        <trans-unit id="0f10e3bc67559ed7f0001e6e7e37e3c27f4624c6" translate="yes" xml:space="preserve">
          <source>If the operation would result in &lt;code&gt;size() &amp;gt; max_size()&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果该操作导致 &lt;code&gt;size() &amp;gt; max_size()&lt;/code&gt; ，则抛出 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b217f2aa9381c149a3dabe0b7cf0fe6551f65c06" translate="yes" xml:space="preserve">
          <source>If the options argument was not supplied, returns &lt;code&gt;options::none&lt;/code&gt;.</source>
          <target state="translated">如果未提供options参数，则返回 &lt;code&gt;options::none&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b113388f82173776cc247c5cef46e3268d0b48fb" translate="yes" xml:space="preserve">
          <source>If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.</source>
          <target state="translated">如果流的方向已经决定了(通过执行输出或通过先前对fwide的调用),这个函数什么也不做。</target>
        </trans-unit>
        <trans-unit id="1de522a1c1fdc728580e466d8485c9d4aecac535" translate="yes" xml:space="preserve">
          <source>If the original pointer is pointing to a base class subobject within an object of some polymorphic type, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; may be used to obtain a &lt;code&gt;void*&lt;/code&gt; that is pointing at the complete object of the most derived type.</source>
          <target state="translated">如果原始指针指向某种多态类型的对象内的基类子对象，则可以使用&lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;获得指向最派生类型的完整对象的 &lt;code&gt;void*&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="990f3e3a0b5d27b439c43881744b60db8d8b4e06" translate="yes" xml:space="preserve">
          <source>If the output could not be generated, sets &lt;code&gt;failbit&lt;/code&gt;, If exceptions on failbit are enabled in this stream's exception mask, throws &lt;a href=&quot;../io/ios_base/failure&quot;&gt;&lt;code&gt;ios_base::failure&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果无法生成输出，则设置 &lt;code&gt;failbit&lt;/code&gt; ，如果在此流的异常掩码中启用了failbit的异常，则抛出&lt;a href=&quot;../io/ios_base/failure&quot;&gt; &lt;code&gt;ios_base::failure&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36e1dfece2770bc2927fb6c9f13e3ae6d4aa3615" translate="yes" xml:space="preserve">
          <source>If the output fails for any reason, sets &lt;code&gt;badbit&lt;/code&gt;.</source>
          <target state="translated">如果输出由于任何原因而失败，请设置 &lt;code&gt;badbit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b185a676601b8249554276be7b4af45b951241d" translate="yes" xml:space="preserve">
          <source>If the output sequence write position is not available (the buffer is full), then calls &lt;code&gt;overflow(ch)&lt;/code&gt;.</source>
          <target state="translated">如果输出序列写位置不可用（缓冲区已满），则调用 &lt;code&gt;overflow(ch)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ddd7375e8e8b7ed3f1d22a6f4f461c76fda6d26" translate="yes" xml:space="preserve">
          <source>If the overload resolution selects a built-in candidate, the &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequence&lt;/a&gt; from an operand of class type is not allowed to have a second standard conversion sequence: the user-defined conversion function must give the expected operand type directly:</source>
          <target state="translated">如果重载解决方案选择一个内置的候选对象，则不允许来自类类型操作数的&lt;a href=&quot;implicit_cast&quot;&gt;用户定义的转换序列&lt;/a&gt;具有第二个标准转换序列：用户定义的转换函数必须直接给出期望的操作数类型：</target>
        </trans-unit>
        <trans-unit id="0339e3bc8e944d80de0d65db76ef29721018ee48" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;icase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the character class ignores character case, e.g. the regex &lt;code&gt;[:lower:]&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; generates a call to &lt;code&gt;regex_traits&amp;lt;&amp;gt;::lookup_classname()&lt;/code&gt; with &lt;code&gt;[first, last)&lt;/code&gt; indicating the string &lt;code&gt;&quot;lower&quot;&lt;/code&gt; and &lt;code&gt;icase == true&lt;/code&gt;. This call returns the same bitmask as the call generated by the regex &lt;code&gt;[:alpha:]&lt;/code&gt; with &lt;code&gt;icase == false&lt;/code&gt;.</source>
          <target state="translated">如果参数 &lt;code&gt;icase&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则字符类将忽略字符大小写，例如，带有 &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; &lt;code&gt;regex_traits&amp;lt;&amp;gt;::lookup_classname()&lt;/code&gt; 的regex &lt;code&gt;[:lower:]&lt;/code&gt; 会生成对regex_traits &amp;lt;&amp;gt; :: lookup_classname（）的调用，其中 &lt;code&gt;[first, last)&lt;/code&gt; 表示字符串 &lt;code&gt;&quot;lower&quot;&lt;/code&gt; 和 &lt;code&gt;icase == true&lt;/code&gt; 。该调用返回与 &lt;code&gt;icase == false&lt;/code&gt; 的正则表达式 &lt;code&gt;[:alpha:]&lt;/code&gt; 生成的调用相同的位掩码。</target>
        </trans-unit>
        <trans-unit id="71a8649df3ecbbada92cdc80a78f0174dc434084" translate="yes" xml:space="preserve">
          <source>If the parameter of the catch-clause is a reference type, any changes made to it are reflected in the exception object, and can be observed by another handler if the exception is rethrown with &lt;code&gt;throw;&lt;/code&gt;. If the parameter is not a reference, any changes made to it are are local and its lifetime ends when the handler exits.</source>
          <target state="translated">如果catch子句的参数是引用类型，则对其所做的任何更改都会反映在异常对象中，并且如果使用 &lt;code&gt;throw;&lt;/code&gt; 异常，则另一个处理程序可以观察到该更改。。如果该参数不是引用，则对该参数所做的任何更改都是本地的，并且其寿命将在处理程序退出时结束。</target>
        </trans-unit>
        <trans-unit id="6dad0498ed0cf6b6b98d4eaaf808c912c3d3152c" translate="yes" xml:space="preserve">
          <source>If the parameter type is &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt;, and there is an non-narrowing implicit conversion from every element of the initializer list to &lt;code&gt;X&lt;/code&gt;, the implicit conversion sequence for the purpose of overload resolution is the worst conversion necessary. If the braced-init-list is empty, the conversion sequence is the identity conversion.</source>
          <target state="translated">如果参数类型为 &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; ，并且从初始值设定项列表的每个元素到 &lt;code&gt;X&lt;/code&gt; 的隐式转换都是不狭窄的，那么出于重载解析的目的，隐式转换序列是最糟糕的转换。如果braced-init-list为空，则转换顺序为身份转换。</target>
        </trans-unit>
        <trans-unit id="18426061d489bcb10c6138a5612f8728895a21a5" translate="yes" xml:space="preserve">
          <source>If the parameter type is some aggregate &lt;code&gt;X&lt;/code&gt; and the initializer list consists of exactly one element of same or derived class (possibly cv-qualified), the implicit conversion sequence is the one required to convert the element to the parameter type.</source>
          <target state="translated">如果参数类型是某个聚合 &lt;code&gt;X&lt;/code&gt; ，并且初始化程序列表仅由相同或派生类的一个元素组成（可能是cv限定），则隐式转换序列是将元素转换为参数类型所需的序列。</target>
        </trans-unit>
        <trans-unit id="d845ac35c60a3d6398352b7893d2603e6b328c05" translate="yes" xml:space="preserve">
          <source>If the parent directory is outside directory hierarchy that is iterated on (i.e. &lt;code&gt;depth() == 0&lt;/code&gt;), sets &lt;code&gt;*this&lt;/code&gt; to an end directory iterator.</source>
          <target state="translated">如果父目录位于要对其进行迭代的目录层次结构之外（即 &lt;code&gt;depth() == 0&lt;/code&gt; ），则将 &lt;code&gt;*this&lt;/code&gt; 设置为最终目录迭代器。</target>
        </trans-unit>
        <trans-unit id="8f12e10b26c51070735d7546640510f221a4a717" translate="yes" xml:space="preserve">
          <source>If the parsing succeeds, does not change &lt;code&gt;err&lt;/code&gt;, and stores the result in &lt;code&gt;units&lt;/code&gt; or &lt;code&gt;digits&lt;/code&gt;.</source>
          <target state="translated">如果解析成功，则不会改变 &lt;code&gt;err&lt;/code&gt; ，并将结果存储为 &lt;code&gt;units&lt;/code&gt; 或 &lt;code&gt;digits&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="704ea65740c7ae23e0fe2ae321dd1d4cee11f634" translate="yes" xml:space="preserve">
          <source>If the part of the regular expression that matched is just an &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript#Assertions&quot;&gt;assertion&lt;/a&gt; (&lt;code&gt;^&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;), the match stored in the iterator is a zero-length match, that is, &lt;code&gt;match[0].first == match[0].second&lt;/code&gt;.</source>
          <target state="translated">如果正则表达式中匹配的部分只是一个&lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript#Assertions&quot;&gt;断言&lt;/a&gt;（ &lt;code&gt;^&lt;/code&gt; ， &lt;code&gt;$&lt;/code&gt; ， &lt;code&gt;\b&lt;/code&gt; ， &lt;code&gt;\B&lt;/code&gt; ），则存储在迭代器中的匹配为零长度匹配，即 &lt;code&gt;match[0].first == match[0].second&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a2ebed057a709d5166451a5bb4fdfc9d04cff29d" translate="yes" xml:space="preserve">
          <source>If the path &lt;code&gt;p&lt;/code&gt; refers to a symbolic link, returns a new path object which refers to the target of that symbolic link.</source>
          <target state="translated">如果路径 &lt;code&gt;p&lt;/code&gt; 引用符号链接，则返回一个新的路径对象，该对象引用该符号链接的目标。</target>
        </trans-unit>
        <trans-unit id="a5a2ee3308db767e5626b5d282347713ca3b32db" translate="yes" xml:space="preserve">
          <source>If the pathname is either &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, or if &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; does not contain the &lt;code&gt;.&lt;/code&gt; character, then empty path is returned.</source>
          <target state="translated">如果路径名是 &lt;code&gt;.&lt;/code&gt; 或 &lt;code&gt;..&lt;/code&gt; ，或者&lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt;不包含 &lt;code&gt;.&lt;/code&gt; 字符，然后返回空路径。</target>
        </trans-unit>
        <trans-unit id="422fd574496432a86171fe46fb0d9e0b579301d4" translate="yes" xml:space="preserve">
          <source>If the pattern ([pat_first, pat_last)) is empty, returns &lt;code&gt;make_pair(first, first)&lt;/code&gt;.</source>
          <target state="translated">如果模式（[pat_first，pat_last））为空，则返回 &lt;code&gt;make_pair(first, first)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="70f9539cc95e6db66dffafbd8aa72c5758b90e7b" translate="yes" xml:space="preserve">
          <source>If the pattern was matched, but the parsed value is not in the range representable by the type of &lt;code&gt;value&lt;/code&gt;, returns value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ec&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; points at the first character not matching the pattern. &lt;code&gt;value&lt;/code&gt; is unmodified.</source>
          <target state="translated">如果匹配了模式，但是解析的值不在value类型可表示的范围内，则返回 &lt;code&gt;from_chars_result&lt;/code&gt; 类型的 &lt;code&gt;value&lt;/code&gt; ，以使 &lt;code&gt;ec&lt;/code&gt; 等于 &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; 并且 &lt;code&gt;ptr&lt;/code&gt; 指向与模式不匹配的第一个字符。 &lt;code&gt;value&lt;/code&gt; 未修改。</target>
        </trans-unit>
        <trans-unit id="0a87d6d2f05d467c7b59a0780f341a0df12fb06a" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is &lt;code&gt;auto&lt;/code&gt;or type-constraint&lt;code&gt;auto&lt;/code&gt;(since C++20), the variable type is deduced from the initializer using the rules for &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; from a function call (see &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;template argument deduction#Other contexts&lt;/a&gt; for details).</source>
          <target state="translated">如果占位符类型说明符是 &lt;code&gt;auto&lt;/code&gt; 或type-constraint &lt;code&gt;auto&lt;/code&gt; （自C ++ 20起），则使用从函数调用中进行&lt;a href=&quot;template_argument_deduction&quot;&gt;模板参数推导&lt;/a&gt;的规则从初始化程序推导变量类型（有关详细信息，请参见&lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;模板参数推导#Other上下文&lt;/a&gt;）。 。</target>
        </trans-unit>
        <trans-unit id="2276b641f558192e6893ac9cc30b93561ac6a1e7" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is &lt;code&gt;decltype(auto)&lt;/code&gt;or type-constraint&lt;code&gt;decltype(auto)&lt;/code&gt;(since C++20), the deduced type is &lt;code&gt;decltype(e)&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the initializer.</source>
          <target state="translated">如果占位符类型说明符为 &lt;code&gt;decltype(auto)&lt;/code&gt; 或类型约束 &lt;code&gt;decltype(auto)&lt;/code&gt; （从C ++ 20开始），则推导的类型为 &lt;code&gt;decltype(e)&lt;/code&gt; ，其中 &lt;code&gt;e&lt;/code&gt; 是初始值设定项。</target>
        </trans-unit>
        <trans-unit id="ac0eb770b354dc56dd2f5ee40b48df9887d2f9d4" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is used to declare multiple variables, the deduced types must match. For example, the declaration &lt;code&gt;auto i = 0, d = 0.0;&lt;/code&gt; is ill-formed, while the declaration &lt;code&gt;auto i = 0, *p = &amp;amp;i;&lt;/code&gt; is well-formed and the &lt;code&gt;auto&lt;/code&gt; is deduced as &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">如果使用占位符类型说明符声明多个变量，则推导的类型必须匹配。例如，声明 &lt;code&gt;auto i = 0, d = 0.0;&lt;/code&gt; 格式错误，而声明 &lt;code&gt;auto i = 0, *p = &amp;amp;i;&lt;/code&gt; 格式正确，并且将 &lt;code&gt;auto&lt;/code&gt; 推导为 &lt;code&gt;int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="05226f11d77b34f54e805ec7153e749dfb3f47a5" translate="yes" xml:space="preserve">
          <source>If the platform uses mixed endian, &lt;code&gt;std::endian::native&lt;/code&gt; does not equal either &lt;code&gt;std::endian::big&lt;/code&gt; nor &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="translated">如果平台使用混合字节序，则 &lt;code&gt;std::endian::native&lt;/code&gt; 不等于 &lt;code&gt;std::endian::big&lt;/code&gt; 也不等于 &lt;code&gt;std::endian::little&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d037e01ff534df66a9b8a862a8773089ded879" translate="yes" xml:space="preserve">
          <source>If the pointer (either &lt;code&gt;gptr&lt;/code&gt; or &lt;code&gt;pptr&lt;/code&gt; or both) is repositioned, it is done as follows:</source>
          <target state="translated">如果重新定位了指针（ &lt;code&gt;gptr&lt;/code&gt; 或 &lt;code&gt;pptr&lt;/code&gt; 或两者都定位），请按照以下步骤操作：</target>
        </trans-unit>
        <trans-unit id="28cec222b90e62fa53ecba18ed8db910c7df5ecd" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points to the &lt;code&gt;i&lt;/code&gt;th element of an array, and the pointer &lt;code&gt;Q&lt;/code&gt; points at the &lt;code&gt;j&lt;/code&gt;th element of the same array, the expression &lt;code&gt;P-Q&lt;/code&gt; has the value &lt;code&gt;i-j&lt;/code&gt;, if the value fits in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;. Both operands must point to the elements of the same array (or one past the end), otherwise the behavior is undefined. If the result does not fit in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">如果指针 &lt;code&gt;P&lt;/code&gt; 指向数组的第 &lt;code&gt;i&lt;/code&gt; 个元素，并且指针 &lt;code&gt;Q&lt;/code&gt; 指向同一数组的第 &lt;code&gt;j&lt;/code&gt; 个元素，则表达式 &lt;code&gt;P-Q&lt;/code&gt; 的值为 &lt;code&gt;i-j&lt;/code&gt; ，如果该值适合 &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt; 。两个操作数都必须指向同一数组的元素（或末尾的一个），否则行为是不确定的。如果结果不适合 &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt; ，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="2c3af6cf6b2fece3bf06d95f3b15704d049a2a68" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points to the &lt;code&gt;i&lt;/code&gt;th element of an array, then the expressions &lt;code&gt;P+n&lt;/code&gt;, &lt;code&gt;n+P&lt;/code&gt;, and &lt;code&gt;P-n&lt;/code&gt; are pointers of the same type that point to the &lt;code&gt;i+n&lt;/code&gt;th, &lt;code&gt;i+n&lt;/code&gt;th, and &lt;code&gt;i-n&lt;/code&gt;th element of the same array, respectively. The result of pointer addition may also be a one-past-the-end pointer (that is, pointer &lt;code&gt;P&lt;/code&gt; such that the expression &lt;code&gt;P-1&lt;/code&gt; points to the last element of the array). Any other situations (that is, attempts to generate a pointer that isn't pointing at an element of the same array or one past the end) invoke undefined behavior.</source>
          <target state="translated">如果指针 &lt;code&gt;P&lt;/code&gt; 指向 &lt;code&gt;i&lt;/code&gt; 的数组的第i个元素，则表达式 &lt;code&gt;P+n&lt;/code&gt; ， &lt;code&gt;n+P&lt;/code&gt; ，和 &lt;code&gt;P-n&lt;/code&gt; 是相同类型的指针该点到 &lt;code&gt;i+n&lt;/code&gt; 个， &lt;code&gt;i+n&lt;/code&gt; th，并且 &lt;code&gt;i-n&lt;/code&gt; 第同一数组的元素。指针添加的结果也可以是一个过去时的指针（即，使表达式 &lt;code&gt;P-1&lt;/code&gt; 指向数组的最后一个元素的指针 &lt;code&gt;P&lt;/code&gt; ）。任何其他情况（即尝试生成未指向同一数组的元素或未指向末尾的元素的指针）都会调用未定义的行为。</target>
        </trans-unit>
        <trans-unit id="0ca8d499f0d01575fddc904d502c2ba50ea7a28f" translate="yes" xml:space="preserve">
          <source>If the pointer is advanced and then &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; is called to flush the put area to the associated character sequence, the effect is that extra &lt;code&gt;count&lt;/code&gt; characters with undefined values are output.</source>
          <target state="translated">如果指针是前进的，然后调用 &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; 以将放置区域刷新到关联的字符序列，则结果是将输出带有未定义值的额外 &lt;code&gt;count&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="e450bd3f7a3a2237b2e10ff661bc465b1471234b" translate="yes" xml:space="preserve">
          <source>If the pointers stored in &lt;code&gt;pword&lt;/code&gt; require management, &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; may be used to install handlers that execute deep copy or deallocation as needed.</source>
          <target state="translated">如果存储在 &lt;code&gt;pword&lt;/code&gt; 中的指针需要管理，则 &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; 可用于安装根据需要执行深度复制或释放的处理程序。</target>
        </trans-unit>
        <trans-unit id="16ee378b87cd08352666411c9cd09d7998ae045a" translate="yes" xml:space="preserve">
          <source>If the pool selected for a block of size &lt;code&gt;bytes&lt;/code&gt; is unable to satisfy the request from its internal data structures, calls &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource to obtain memory.</source>
          <target state="translated">如果为一个大小 &lt;code&gt;bytes&lt;/code&gt; 的块选择的池无法满足其内部数据结构的请求，请在上游内存资源上调用 &lt;code&gt;allocate()&lt;/code&gt; 以获取内存。</target>
        </trans-unit>
        <trans-unit id="9eafb34d20e4bdd821ef599345cd0d19bc68a4ab" translate="yes" xml:space="preserve">
          <source>If the precision of the input cannot be exactly represented with seconds, then the format is a decimal floating point number with a fixed format and a precision matching that of the precision of the input (or to a microseconds precision if the conversion to floating point decimal seconds cannot be made within 18 fractional digits). The character for the decimal point is localized according to the locale.</source>
          <target state="translated">如果输入的精度不能准确地用秒来表示,那么格式就是一个固定格式的十进制浮点数,其精度与输入的精度相匹配(如果在18个小数点内不能转换为浮点十进制秒,则转换为微秒精度)。小数点的字符是根据地域的不同而进行本地化的。</target>
        </trans-unit>
        <trans-unit id="556a0df3f2ed8a7cac546a84886519ac3ebeac8f" translate="yes" xml:space="preserve">
          <source>If the previous stage does not produce a match, all constructors of &lt;code&gt;T&lt;/code&gt; participate in &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;overload resolution&lt;/a&gt; against the set of arguments that consists of the elements of the braced-init-list, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all).</source>
          <target state="translated">如果前一个阶段不产生匹配，则 &lt;code&gt;T&lt;/code&gt; 的所有构造函数都将针对由braced-init-list元素组成的参数集参与&lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;重载解析&lt;/a&gt;，并限制仅允许非窄转换。如果此阶段生成一个显式构造函数作为复制列表初始化的最佳匹配，则编译将失败（请注意，在简单的复制初始化中，根本不考虑显式构造函数）。</target>
        </trans-unit>
        <trans-unit id="7cc06dc92cb043df323fc3aa474cf3ba56bb3c97" translate="yes" xml:space="preserve">
          <source>If the primary member template is explicitly (fully) specialized for a given (implicit) specialization of the enclosing class template, the partial specializations of the member template are ignored for this specialization of the enclosing class template.</source>
          <target state="translated">如果主成员模板对于包围类模板的给定(隐含)特化是显式(完全)特化的,那么对于包围类模板的这种特化,成员模板的部分特化将被忽略。</target>
        </trans-unit>
        <trans-unit id="adfd306bbffa0b23164cbb3f7616b73a92779a42" translate="yes" xml:space="preserve">
          <source>If the primary template has a exception specification that isn't &lt;code&gt;noexcept(false)&lt;/code&gt;, the explicit specializations must have a compatible exception specification.</source>
          <target state="translated">如果主模板的异常规范不是 &lt;code&gt;noexcept(false)&lt;/code&gt; ，则显式专业化必须具有兼容的异常规范。</target>
        </trans-unit>
        <trans-unit id="a27f2e5bb1066b5ba8ecb5c6e80fdaaed8988b08" translate="yes" xml:space="preserve">
          <source>If the program closes the file, e.g. by executing &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;std::fclose&lt;/a&gt;&lt;/code&gt;, the file is automatically deleted.</source>
          <target state="translated">如果程序关闭文件（例如，通过执行 &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;std::fclose&lt;/a&gt;&lt;/code&gt; ，则会自动删除文件。</target>
        </trans-unit>
        <trans-unit id="f054e6c94ddb2b1d1ab37e865dadbaa42672443f" translate="yes" xml:space="preserve">
          <source>If the program terminates abnormally, it is implementation-defined if these temporary files are deleted.</source>
          <target state="translated">如果程序异常终止,这些临时文件是否被删除是由实施定义的。</target>
        </trans-unit>
        <trans-unit id="2165d06ea6d2bb20531c9f3d3cebc5362167aa09" translate="yes" xml:space="preserve">
          <source>If the program terminates normally (by calling &lt;code&gt;&lt;a href=&quot;../../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;, returning from &lt;code&gt;main&lt;/code&gt;, etc), all files that were opened by calling &lt;code&gt;std::tmpfile&lt;/code&gt; are also automatically deleted.</source>
          <target state="translated">如果程序正常终止（通过调用 &lt;code&gt;&lt;a href=&quot;../../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; ，从 &lt;code&gt;main&lt;/code&gt; 返回等），则通过调用 &lt;code&gt;std::tmpfile&lt;/code&gt; 打开的所有文件也会被自动删除。</target>
        </trans-unit>
        <trans-unit id="c4563d58386ce90b83da2edbf6c91576f3250457" translate="yes" xml:space="preserve">
          <source>If the put area becomes full (&lt;code&gt;pptr() == epptr()&lt;/code&gt;), this function may call &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, or achieve the effect of calling &lt;code&gt;overflow()&lt;/code&gt; by some other, unspecified, means.</source>
          <target state="translated">如果放置区域已满（ &lt;code&gt;pptr() == epptr()&lt;/code&gt; ），则此函数可能会调用 &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; ，或通过其他未指定的方式达到调用 &lt;code&gt;overflow()&lt;/code&gt; 的效果。</target>
        </trans-unit>
        <trans-unit id="4470c9cf96cf0b0427223088eda48f753afa8e5d" translate="yes" xml:space="preserve">
          <source>If the range is empty, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="translated">如果范围为空，则返回未经修改的 &lt;code&gt;init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a1fccb7fec68247b6a1b2dd1f263989d79d91a2" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is greater than or equal to the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果比率 &lt;code&gt;R1&lt;/code&gt; 大于或等于比率 &lt;code&gt;R2&lt;/code&gt; ，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1a7f289660496e50704c8e12b0a1a4ded1768f65" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is greater than than the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果比率 &lt;code&gt;R1&lt;/code&gt; 大于比率 &lt;code&gt;R2&lt;/code&gt; ，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="486dc284a8aec5600eb2ce6107311df95fa15c27" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is less than or equal to the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果比率 &lt;code&gt;R1&lt;/code&gt; 小于或等于比率 &lt;code&gt;R2&lt;/code&gt; ，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c44d3b0dc212e8ac325d4b33e901580daa7a83e" translate="yes" xml:space="preserve">
          <source>If the ratio R1 is less than the ratio R2, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果比率R1小于比率R2，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="402f8a7cc133b62e154ebba1457929bfddbc3bf0" translate="yes" xml:space="preserve">
          <source>If the ratios R1 and R2 are equal, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果比率R1和R2相等，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86470dd50c07d87d87cc6afc10ca67f451b58476" translate="yes" xml:space="preserve">
          <source>If the ratios R1 and R2 are not equal, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">如果比率R1和R2不相等，则提供等于 &lt;code&gt;true&lt;/code&gt; 的成员常 &lt;code&gt;value&lt;/code&gt; 。否则， &lt;code&gt;value&lt;/code&gt; 是 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e6ef67dfe973705134074e186274b6c8db214065" translate="yes" xml:space="preserve">
          <source>If the referred-to object was destroyed (e.g. by explicit destructor call), but the storage was not deallocated, a reference to the out-of-lifetime object may be used in limited ways, and may become valid if the object is recreated in the same storage (see &lt;a href=&quot;lifetime#Access_outside_of_lifetime&quot;&gt;Access outside of lifetime&lt;/a&gt; for details).</source>
          <target state="translated">如果所引用的对象被破坏（例如，通过显式析构函数调用），但未释放存储，则对寿命终止对象的引用可能会以有限的方式使用，并且如果在相同的存储（有关详细信息，请参阅&lt;a href=&quot;lifetime#Access_outside_of_lifetime&quot;&gt;生存期之外的访问&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="32e827308169dc81e7dc50577c7dd9c26262ce2a" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a maximum-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">如果持续时间的表示形式 &lt;code&gt;rep&lt;/code&gt; 需要一些其他实现来返回最大长度的持续时间，则可以专门使用 &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; 返回所需的值。</target>
        </trans-unit>
        <trans-unit id="cf898146c6c3c24b40b13c45caea3516ac8e0db7" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a minimum-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">如果持续时间的表示形式 &lt;code&gt;rep&lt;/code&gt; 需要一些其他实现来返回最小长度的持续时间，则可以专门使用 &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; 返回所需的值。</target>
        </trans-unit>
        <trans-unit id="216bb9502dac2c6f6a263c7893d238bdae801fdf" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a zero-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">如果持续时间的表示形式 &lt;code&gt;rep&lt;/code&gt; 需要一些其他实现来返回零长度的持续时间，则可以专门使用 &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; 返回所需的值。</target>
        </trans-unit>
        <trans-unit id="79081ea2c3cd338bf77b76285c9d2307dabb3758" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;std::lrint&lt;/code&gt; or &lt;code&gt;std::llrint&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">如果 &lt;code&gt;std::lrint&lt;/code&gt; 或 &lt;code&gt;std::llrint&lt;/code&gt; 的结果超出了返回类型可表示的范围，则可能发生域错误或范围错误。</target>
        </trans-unit>
        <trans-unit id="587dd46cd3feba4cdcd09248f53d64715a053010" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;std::lround&lt;/code&gt; or &lt;code&gt;std::llround&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">如果 &lt;code&gt;std::lround&lt;/code&gt; 或 &lt;code&gt;std::llround&lt;/code&gt; 的结果超出了返回类型可表示的范围，则可能会发生域错误或范围错误。</target>
        </trans-unit>
        <trans-unit id="f9143780183f7e4a1182584068e608842bda530b" translate="yes" xml:space="preserve">
          <source>If the result of the conversion is unique, then &lt;code&gt;result == local_info::unique&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the correct &lt;code&gt;std::chrono::sys_info&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is zero-initialized.</source>
          <target state="translated">如果转换的结果是唯一的，则 &lt;code&gt;result == local_info::unique&lt;/code&gt; ， &lt;code&gt;first&lt;/code&gt; 填充正确的 &lt;code&gt;std::chrono::sys_info&lt;/code&gt; ， &lt;code&gt;second&lt;/code&gt; 填充零初始化。</target>
        </trans-unit>
        <trans-unit id="8eeeae32aeed1e098fc91dd8bd921c86fb200e23" translate="yes" xml:space="preserve">
          <source>If the result of the rounding is outside the range of the return type, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">如果舍入的结果超出了返回类型的范围，则引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 并返回实现定义的值</target>
        </trans-unit>
        <trans-unit id="40b9661e308f2792d26e6a4e9185df30cab4c8f8" translate="yes" xml:space="preserve">
          <source>If the result would be outside the range [-32767, 32767], the actual stored value is unspecified.</source>
          <target state="translated">如果结果在[-32767,32767]范围之外,则实际的存储值是未指定的。</target>
        </trans-unit>
        <trans-unit id="12704794f475153a5a68233a95befd2418ed3109" translate="yes" xml:space="preserve">
          <source>If the result would be outside the range [0, 255], the actual stored value is unspecified.</source>
          <target state="translated">如果结果在[0,255]范围之外,则实际的存储值是未指定的。</target>
        </trans-unit>
        <trans-unit id="9b8913f174ebaea61408caa1ef433d1587bd6ffe" translate="yes" xml:space="preserve">
          <source>If the resulting pointer type is a function pointer, a pointer to member, or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; returns a prvalue of type &lt;a href=&quot;../utility/compare/strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果结果指针类型是函数指针，成员指针或 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; ，则 &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; 返回&lt;a href=&quot;../utility/compare/strong_equality&quot;&gt; &lt;code&gt;std::strong_equality&lt;/code&gt; &lt;/a&gt;类型的prvalue ：</target>
        </trans-unit>
        <trans-unit id="2e78c0f7505a15522acda3776ce4ce10a21d82dd" translate="yes" xml:space="preserve">
          <source>If the resulting pointer type is an object pointer type, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; returns a prvalue of type &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;strong_ordering&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">如果结果指针类型是对象指针类型，则 &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; 返回类型为&lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt; &lt;code&gt;strong_ordering&lt;/code&gt; &lt;/a&gt;的prvalue ：</target>
        </trans-unit>
        <trans-unit id="dbda3e4805d43967af0a89706ef34251ae9306d8" translate="yes" xml:space="preserve">
          <source>If the resulting year value for (1-3) is outside the range [-32767,32767], the actual value stored is unspecified.</source>
          <target state="translated">如果(1-3)的结果年值在[-32767,32767]范围之外,则存储的实际值为未指定。</target>
        </trans-unit>
        <trans-unit id="d76cd29ea50833e8ec64892b7a35746e9aff8b17" translate="yes" xml:space="preserve">
          <source>If the return statement uses a brace-init-list, deduction is not allowed:</source>
          <target state="translated">如果返回报表使用brace-init-list,则不允许扣除。</target>
        </trans-unit>
        <trans-unit id="fa7a732c5f6541d73e515269ccd1d1ceb3b46448" translate="yes" xml:space="preserve">
          <source>If the return type is &lt;code&gt;decltype(auto)&lt;/code&gt;, the return type is as what would be obtained if the expression used in the return statement were wrapped in &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt;.</source>
          <target state="translated">如果返回类型为 &lt;code&gt;decltype(auto)&lt;/code&gt; ，则返回类型与将return语句中使用的表达式包装在&lt;a href=&quot;decltype&quot;&gt;decltype中时所获得的类型相同&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d28a3f66a7fff0e2a4e0c4769a914c3fc6299edf" translate="yes" xml:space="preserve">
          <source>If the return type of the function template is a placeholder (&lt;code&gt;auto&lt;/code&gt; or &lt;code&gt;decltype(auto)&lt;/code&gt;), that return type is a non-deduced context and is determined from the instantiation.</source>
          <target state="translated">如果功能模板的返回类型是占位符（ &lt;code&gt;auto&lt;/code&gt; 或 &lt;code&gt;decltype(auto)&lt;/code&gt; ），则该返回类型是非推导上下文，并且由实例确定。</target>
        </trans-unit>
        <trans-unit id="55096951d03276844009d4ac6ef2f86a40234649" translate="yes" xml:space="preserve">
          <source>If the returned value is &lt;code&gt;0&lt;/code&gt;, it will have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">如果返回值为 &lt;code&gt;0&lt;/code&gt; ，则它将与 &lt;code&gt;x&lt;/code&gt; 具有相同的符号。</target>
        </trans-unit>
        <trans-unit id="6acd7cb12ab8e3d0ef11d24ea68011a7873b5dae" translate="yes" xml:space="preserve">
          <source>If the rewrite produces an invalid type, then &lt;code&gt;P&lt;/code&gt; is not at least as specialized as &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">如果重写产生无效的类型，则 &lt;code&gt;P&lt;/code&gt; 至少不像 &lt;code&gt;A&lt;/code&gt; 那样专业。</target>
        </trans-unit>
        <trans-unit id="4014e2bbf13db27364d7162d5b480ce0991f7037" translate="yes" xml:space="preserve">
          <source>If the right hand side of &lt;code&gt;::&lt;/code&gt; names the same class as the left hand side, the name designates the &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; of that class. Such qualified name can only be used in a declaration of a constructor and in the &lt;a href=&quot;using_declaration&quot;&gt;using-declaration&lt;/a&gt; for an &lt;a href=&quot;using_declaration#Inheriting_constructors&quot;&gt;inheriting constructor&lt;/a&gt;. In those lookups where function names are ignored (that is, when looking up a name on the left of &lt;code&gt;::&lt;/code&gt;, when looking up a name in &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;, or &lt;a href=&quot;derived_class&quot;&gt;base specifier&lt;/a&gt;), the same syntax resolves to the injected-class-name:</source>
          <target state="translated">如果 &lt;code&gt;::&lt;/code&gt; 的右侧与左侧命名相同的类，则该名称指定该类的&lt;a href=&quot;constructor&quot;&gt;构造函数&lt;/a&gt;。这样的限定名称只能在构造函数的声明中以及在&lt;a href=&quot;using_declaration#Inheriting_constructors&quot;&gt;继承构造函数&lt;/a&gt;的using- &lt;a href=&quot;using_declaration&quot;&gt;声明&lt;/a&gt;中使用。在那些忽略函数名称的查找中（即，在 &lt;code&gt;::&lt;/code&gt; 左侧查找名称时，在&lt;a href=&quot;elaborated_type_specifier&quot;&gt;详细的类型说明符&lt;/a&gt;或&lt;a href=&quot;derived_class&quot;&gt;基本说明符中&lt;/a&gt;查找名称时），相同的语法会解析为注入的类名：</target>
        </trans-unit>
        <trans-unit id="cf85d17881197f4ecbe7cccfb07809892b92473d" translate="yes" xml:space="preserve">
          <source>If the right operand is a</source>
          <target state="translated">如果右边操作数是一个</target>
        </trans-unit>
        <trans-unit id="3c25a1f1f190f7079576b9f6ac4b83bbb5951e6a" translate="yes" xml:space="preserve">
          <source>If the same function is registered multiple times, it is called multiple times.</source>
          <target state="translated">如果同一个函数被多次注册,就会被多次调用。</target>
        </trans-unit>
        <trans-unit id="6456596730ba60e84aee4ac147873b048b5c59b5" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined, except that if floating-point division is taking place and the type supports IEEE floating-point arithmetic (see &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt;), then:</source>
          <target state="translated">如果第二个操作数为零，则该行为是不确定的，除非发生浮点除法并且该类型支持IEEE浮点算术（请参阅 &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt; ），然后：</target>
        </trans-unit>
        <trans-unit id="04f0455691936b497fbaebef44e9588dc509eb29" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception, no input takes place</source>
          <target state="translated">如果哨兵返回 &lt;code&gt;false&lt;/code&gt; 或哨兵的构造函数抛出异常，则不会发生任何输入</target>
        </trans-unit>
        <trans-unit id="39a91a877963ed9b5a894be3943380a70d626e6f" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception, no output takes place</source>
          <target state="translated">如果哨兵返回 &lt;code&gt;false&lt;/code&gt; 或哨兵的构造函数抛出异常，则不会发生任何输出</target>
        </trans-unit>
        <trans-unit id="bb9f6b8db596d35efa0c018a14df69e7f6bbfaa1" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception:</source>
          <target state="translated">如果哨兵返回 &lt;code&gt;false&lt;/code&gt; 或哨兵的构造函数抛出异常：</target>
        </trans-unit>
        <trans-unit id="1a7affbf0e55ba9d44864cd1959e23685822e021" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;true&lt;/code&gt;, attempts to perform the desired output by inserting the characters into the output stream as if by calling &lt;code&gt;rdbuf()-&amp;gt;sputc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;xsputn()&lt;/code&gt;. Additionally, &lt;code&gt;rdbuf()-&amp;gt;overflow()&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;sync()&lt;/code&gt; may be called, but no other virtual member function of &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果哨兵返回 &lt;code&gt;true&lt;/code&gt; ，则尝试通过将字符插入输出流来执行所需的输出，就像通过调用 &lt;code&gt;rdbuf()-&amp;gt;sputc()&lt;/code&gt; 或 &lt;code&gt;rdbuf()-&amp;gt;xsputn()&lt;/code&gt; 一样。另外，可以调用 &lt;code&gt;rdbuf()-&amp;gt;overflow()&lt;/code&gt; 和 &lt;code&gt;rdbuf()-&amp;gt;sync()&lt;/code&gt; ，但不能调用 &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; 其他虚拟成员函数。</target>
        </trans-unit>
        <trans-unit id="d65656ed9a96ce6e5067eef9a37718da9bc64cf6" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;true&lt;/code&gt;, performs the input as if by calling &lt;code&gt;rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="translated">如果哨兵返回 &lt;code&gt;true&lt;/code&gt; ，则就像通过调用 &lt;code&gt;rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; 或 &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt; 一样执行输入。</target>
        </trans-unit>
        <trans-unit id="70cc476a7cece12b6a2caeadf0dc66668c3d640a" translate="yes" xml:space="preserve">
          <source>If the set of potential exceptions is the set of all types, the implicit exception specification is &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">如果潜在异常的集合是所有类型的集合，则隐式异常规范为 &lt;code&gt;noexcept(false)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fd5f4d3d66499f24cbe8e9106c8eff484bfafb9" translate="yes" xml:space="preserve">
          <source>If the signal handler is called NOT as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (asynchronous signal), the behavior is undefined if.</source>
          <target state="translated">如果由于 &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; （异步信号）而导致信号处理程序未调用，则if行为不确定。</target>
        </trans-unit>
        <trans-unit id="671f3a813ef40ad3c5384400961c74b31b5b1d3a" translate="yes" xml:space="preserve">
          <source>If the signal handler is called as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronous signal), the behavior is undefined if the signal handler calls &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果由于 &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; （同步信号）而调用信号处理程序，则如果信号处理程序调用 &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; ，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="6be8eefa6fa1b67c6f58f6b59c61b09644913654" translate="yes" xml:space="preserve">
          <source>If the single-argument overload (17,18) is not provided, but the size-aware overload taking &lt;code&gt;std::size_t&lt;/code&gt; as the second parameter (21,22) is provided, the size-aware form is called for normal deallocation, and the C++ runtime passes the size of the object to be deallocated as the second argument. If both forms are defined, the size-unaware version is called.</source>
          <target state="translated">如果未提供单参数重载（17,18），但是提供了以 &lt;code&gt;std::size_t&lt;/code&gt; 作为第二个参数（21,22）的大小感知重载，则将大小感知形式用于常规释放，并且C ++运行时将要释放的对象的大小作为第二个参数传递。如果同时定义了两种形式，则会调用无尺寸版本。</target>
        </trans-unit>
        <trans-unit id="c2d39c7de53ad27f42a0268ca018c937a1d8ffae" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is known at compile time, &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; may be used, which offers a richer set of member functions. In addition, &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; exists as an alternative to &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">如果在编译时知道位集的大小，则可以使用 &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; ，它提供了更丰富的成员函数集。另外，存在&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost :: dynamic_bitset&lt;/a&gt;来替代 &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed773f93c49e31ff381db822c35aae7976a70854" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is known at compile time, &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; may be used, which offers a richer set of member functions. In addition, &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; exists as an alternative to &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ec4da197f7dc487044d683f9f3f0534aa5677b" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is not known at compile time, &lt;a href=&quot;../container/vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; may be used.</source>
          <target state="translated">如果在编译时未知位集的大小，则可以使用&lt;a href=&quot;../container/vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;&lt;/a&gt;或&lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost :: dynamic_bitset&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="8dc178e702b3a81eeca77425a15664711aa51357" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is not known at compile time, &lt;a href=&quot;../container/vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; or &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1cf7f64b041e9b0a91851335d5ade685bd49da" translate="yes" xml:space="preserve">
          <source>If the size requested is larger than what the largest pool can handle, memory is allocated by calling &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource.</source>
          <target state="translated">如果请求的大小大于最大池可以处理的大小，则通过在上游内存资源上调用 &lt;code&gt;allocate()&lt;/code&gt; 来分配内存。</target>
        </trans-unit>
        <trans-unit id="b62ea5d0b3c38b6b4f7a4e5580107ff3cf6239e4" translate="yes" xml:space="preserve">
          <source>If the source and destination ranges (that is, &lt;code&gt;[first, last)&lt;/code&gt; and &lt;code&gt;[d_first, d_first+(last-first))&lt;/code&gt; respectively) overlap, the behavior is undefined.</source>
          <target state="translated">如果源和目标范围（分别是 &lt;code&gt;[first, last)&lt;/code&gt; 和 &lt;code&gt;[d_first, d_first+(last-first))&lt;/code&gt; ）重叠），则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="81c139c2b88224c56ebf4f7944ce062c13ebe2bf" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char16_t&lt;/code&gt;, conversion from UTF-16 to native filesystem encoding is used.</source>
          <target state="translated">如果源字符类型为 &lt;code&gt;char16_t&lt;/code&gt; ，则使用从UTF-16到本机文件系统编码的转换。</target>
        </trans-unit>
        <trans-unit id="913c2f0506e7ab797a84a2f6e825328ef3b20217" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char32_t&lt;/code&gt;, conversion from UTF-32 to native filesystem encoding is used.</source>
          <target state="translated">如果源字符类型为 &lt;code&gt;char32_t&lt;/code&gt; ，则使用从UTF-32到本机文件系统编码的转换。</target>
        </trans-unit>
        <trans-unit id="694b72bdebad2e7991d3953383227294208921f6" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char8_t&lt;/code&gt;, conversion from UTF-8 to native filesystem encoding is used.</source>
          <target state="translated">如果源字符类型为 &lt;code&gt;char8_t&lt;/code&gt; ，则使用从UTF-8到本机文件系统编码的转换。</target>
        </trans-unit>
        <trans-unit id="96a70ab7daabf750d23aa93b01ed20ad4c4a1d50" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char&lt;/code&gt;, the encoding of the source is assumed to be the native narrow encoding (so no conversion takes place on POSIX systems)</source>
          <target state="translated">如果源字符类型为 &lt;code&gt;char&lt;/code&gt; ，则假定源的编码为本机窄编码（因此在POSIX系统上不进行转换）</target>
        </trans-unit>
        <trans-unit id="4f00894176b3c2149f96504f78763e6045b2b289" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;wchar_t&lt;/code&gt;, the input is assumed to be the native wide encoding (so no conversion takes places on Windows)</source>
          <target state="translated">如果源字符类型为 &lt;code&gt;wchar_t&lt;/code&gt; ，则假定输入为本地宽编码（因此在Windows上不会进行转换）</target>
        </trans-unit>
        <trans-unit id="c129bdb54be16ce791f2a9877c6536a222b2a628" translate="yes" xml:space="preserve">
          <source>If the source type is &lt;code&gt;bool&lt;/code&gt;, the value &lt;code&gt;false&lt;/code&gt; is converted to zero and the value &lt;code&gt;true&lt;/code&gt; is converted to the value one of the destination type (note that if the destination type is &lt;code&gt;int&lt;/code&gt;, this is an integer promotion, not an integer conversion).</source>
          <target state="translated">如果源类型为 &lt;code&gt;bool&lt;/code&gt; ，则将 &lt;code&gt;false&lt;/code&gt; 值转换为零，将 &lt;code&gt;true&lt;/code&gt; 值转换为目标类型的值之一（请注意，如果目标类型为 &lt;code&gt;int&lt;/code&gt; ，则这是整数提升，而不是整数转换）。</target>
        </trans-unit>
        <trans-unit id="bab9d6ec8e3d2f1fd684bd9854d45b7e92934c4f" translate="yes" xml:space="preserve">
          <source>If the source value can be represented exactly in the destination type, it does not change.</source>
          <target state="translated">如果源值可以在目的类型中准确地表示,则不会改变。</target>
        </trans-unit>
        <trans-unit id="efb29c4d220f173d5c3f3bd33b9dfc2ebc5dd7b6" translate="yes" xml:space="preserve">
          <source>If the source value is between two representable values of the destination type, the result is one of those two values (it is implementation-defined which one, although if IEEE arithmetic is supported, rounding defaults &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;to nearest&lt;/a&gt;).</source>
          <target state="translated">如果源值在目标类型的两个可表示的值之间，则结果是这两个值之一（由实现定义，其中一个值，尽管如果支持IEEE算术，则四舍五入默认&lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;为Nearest&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="31b86def2b9a34fa38b7b256145666db6c5bf517" translate="yes" xml:space="preserve">
          <source>If the span is empty, the returned iterator will be equal to &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="translated">如果span为空，则返回的迭代器将等于 &lt;code&gt;end()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b682c7de7ba329b4fb255e71c3dba81aec002eb" translate="yes" xml:space="preserve">
          <source>If the specified size of the bit field is greater than the size of its type, the value is limited by the type: a &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint8_t&lt;/a&gt; b : 1000;&lt;/code&gt; would still hold values between 0 and 255. the extra bits become unused padding.</source>
          <target state="translated">如果指定的位字段大小大于其类型的大小，则该值受以下类型的限制：a &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint8_t&lt;/a&gt; b : 1000;&lt;/code&gt; 仍将保留0到255之间的值。多余的位将变为未使用的填充。</target>
        </trans-unit>
        <trans-unit id="0cd8d8e47fd2f7d673121bf212de39492d391631" translate="yes" xml:space="preserve">
          <source>If the static type of the object that is being deleted differs from its dynamic type (such as when deleting a &lt;a href=&quot;../../language/objects&quot;&gt;polymorphic&lt;/a&gt; object through a pointer to base), and if the destructor in the static type is virtual, the single object form of delete begins lookup of the deallocation function's name starting from the point of definition of the final overrider of its virtual destructor. Regardless of which deallocation function would be executed at run time, the statically visible version of operator delete must be accessible in order to compile. In other cases, when deleting an array through a pointer to base, or when deleting through pointer to base with non-virtual destructor, the behavior is undefined.</source>
          <target state="translated">如果要删除的对象的静态类型不同于其动态类型（例如，通过指向基数的指针删除&lt;a href=&quot;../../language/objects&quot;&gt;多态&lt;/a&gt;对象时），并且如果静态类型中的析构函数是虚拟的，则删除的单个对象形式开始查找从其虚拟析构函数的最终替代程序的定义点开始，重新分配函数的名称。无论在运行时执行哪个释放函数，都必须可以访问操作员删除的静态可见版本才能进行编译。在其他情况下，当通过指向基数的指针删除数组时，或者通过使用非虚拟析构函数的基数指针删除数组时，行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="1a0ccecdae65148cf1c548284599ec7fc29e7a26" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; (for example, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; was used in the initial call to &lt;code&gt;bind&lt;/code&gt;), then the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;arg.get()&lt;/code&gt; and the type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;T&amp;amp;&lt;/code&gt;: the stored argument is passed by reference into the invoked function object.</source>
          <target state="translated">如果存储的参数 &lt;code&gt;arg&lt;/code&gt; 的类型为 &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; （例如，在初始 &lt;code&gt;bind&lt;/code&gt; 使用 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; ），则上述 &lt;code&gt;std::invoke&lt;/code&gt; 调用中的参数 &lt;code&gt;vn&lt;/code&gt; 是 &lt;code&gt;arg.get()&lt;/code&gt; 并且在同一调用中类型 &lt;code&gt;Vn&lt;/code&gt; 是 &lt;code&gt;T&amp;amp;&lt;/code&gt; ：存储的参数通过引用传递到调用的函数对象中。</target>
        </trans-unit>
        <trans-unit id="acee41d0611ce916e2778b1cfd039971f9e77287" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;is_bind_expression&quot;&gt;std::is_bind_expression&lt;/a&gt;&amp;lt;T&amp;gt;::value == true&lt;/code&gt; (for example, another &lt;code&gt;bind&lt;/code&gt; expression was passed directly into the initial call to &lt;code&gt;bind&lt;/code&gt;), then &lt;code&gt;bind&lt;/code&gt; performs function composition: instead of passing the function object that the bind subexpression would return, the subexpression is invoked eagerly, and its return value is passed to the outer invokable object. If the bind subexpression has any placeholder arguments, they are shared with the outer bind (picked out of &lt;code&gt;u1, u2, ...&lt;/code&gt;). Specifically, the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;arg(std::forward&amp;lt;Uj&amp;gt;(uj)...)&lt;/code&gt; and the type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;&lt;a href=&quot;../../types/result_of&quot;&gt;std::result_of_t&lt;/a&gt;&amp;lt;T cv &amp;amp;(Uj&amp;amp;&amp;amp;...)&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt; (cv qualification is the same as that of &lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">如果所存储的参数 &lt;code&gt;arg&lt;/code&gt; 的类型为 &lt;code&gt;T&lt;/code&gt; 针对 &lt;code&gt;&lt;a href=&quot;is_bind_expression&quot;&gt;std::is_bind_expression&lt;/a&gt;&amp;lt;T&amp;gt;::value == true&lt;/code&gt; （例如，另一个 &lt;code&gt;bind&lt;/code&gt; 表达直接通入到初始呼叫 &lt;code&gt;bind&lt;/code&gt; ），然后 &lt;code&gt;bind&lt;/code&gt; 执行功能的组合物：代替传递bind子表达式将返回的函数对象，该子表达式将被急切地调用，并将其返回值传递给外部可调用对象。如果bind子表达式具有任何占位符参数，则它们与外部绑定共享（从 &lt;code&gt;u1, u2, ...&lt;/code&gt; 挑选）。具体而言，参数 &lt;code&gt;vn&lt;/code&gt; 中 &lt;code&gt;std::invoke&lt;/code&gt; 呼叫以上是 &lt;code&gt;arg(std::forward&amp;lt;Uj&amp;gt;(uj)...)&lt;/code&gt; 并且同一调用中的 &lt;code&gt;Vn&lt;/code&gt; 类型为 &lt;code&gt;&lt;a href=&quot;../../types/result_of&quot;&gt;std::result_of_t&lt;/a&gt;&amp;lt;T cv &amp;amp;(Uj&amp;amp;&amp;amp;...)&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt; （cv限定与 &lt;code&gt;g&lt;/code&gt; 相同）。</target>
        </trans-unit>
        <trans-unit id="dc4a284d335b2d5c1ce7e8244468b32d33179179" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt;, for which &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;T&amp;gt;::value != 0&lt;/code&gt; (meaning, a placeholder such as &lt;code&gt;std::placeholders::_1, _2, _3, ...&lt;/code&gt; was used as the argument to the initial call to &lt;code&gt;bind&lt;/code&gt;), then the argument indicated by the placeholder (&lt;code&gt;u1&lt;/code&gt; for &lt;code&gt;_1&lt;/code&gt;, &lt;code&gt;u2&lt;/code&gt; for &lt;code&gt;_2&lt;/code&gt;, etc) is passed to the invokable object: the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Uj&amp;gt;(uj)&lt;/code&gt; and the corresponding type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;Uj&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">如果存储的参数 &lt;code&gt;arg&lt;/code&gt; 的类型为 &lt;code&gt;T&lt;/code&gt; ，则 &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;T&amp;gt;::value != 0&lt;/code&gt; （意味着，将 &lt;code&gt;std::placeholders::_1, _2, _3, ...&lt;/code&gt; 等占位符用作的参数到初始呼叫 &lt;code&gt;bind&lt;/code&gt; ），则该参数表示由占位符（ &lt;code&gt;u1&lt;/code&gt; 为 &lt;code&gt;_1&lt;/code&gt; ， &lt;code&gt;u2&lt;/code&gt; 为 &lt;code&gt;_2&lt;/code&gt; 等）被传递到可调用对象：参数 &lt;code&gt;vn&lt;/code&gt; 中 &lt;code&gt;std::invoke&lt;/code&gt; 呼叫上方 &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Uj&amp;gt;(uj)&lt;/code&gt; 并且同一调用中的对应类型 &lt;code&gt;Vn&lt;/code&gt; 是 &lt;code&gt;Uj&amp;amp;&amp;amp;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5073b898afe983835e7576b31a4b2a5ed1384e70" translate="yes" xml:space="preserve">
          <source>If the stored reference is &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;, &lt;code&gt;std::reference_wrapper&lt;/code&gt; is callable with the same arguments.</source>
          <target state="translated">如果存储的引用是&lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;，则可以使用相同的参数调用 &lt;code&gt;std::reference_wrapper&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="721f1a0ff5ac2a85a4aec48dc758c5efa06cf129" translate="yes" xml:space="preserve">
          <source>If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.</source>
          <target state="translated">如果流是以二进制模式打开的,那么这个函数得到的值就是从文件开始的字节数。</target>
        </trans-unit>
        <trans-unit id="1be01e06d2b7863dcf18bfbfbb7a62e4aff8f3b7" translate="yes" xml:space="preserve">
          <source>If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果流以文本模式打开，则此函数返回的值是未指定的，仅作为 &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt; 的输入有意义。</target>
        </trans-unit>
        <trans-unit id="dcf9d7178da0219ad2eb8a851abb68eb2713f063" translate="yes" xml:space="preserve">
          <source>If the stream is using a dynamically-allocated array for output, disables (&lt;code&gt;flag == true&lt;/code&gt;) or enables (&lt;code&gt;flag == false&lt;/code&gt;) automatic allocation/deallocation of the buffer. Effectively calls &lt;code&gt;rdbuf()-&amp;gt;freeze(flag)&lt;/code&gt;.</source>
          <target state="translated">如果流使用动态分配的数组进行输出，请禁用（ &lt;code&gt;flag == true&lt;/code&gt; ）或启用（ &lt;code&gt;flag == false&lt;/code&gt; ）缓冲区的自动分配/取消分配。有效地调用 &lt;code&gt;rdbuf()-&amp;gt;freeze(flag)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e3a1404f13d35c564c59b09dcb07b726f75ab0a7" translate="yes" xml:space="preserve">
          <source>If the strictest (largest) &lt;code&gt;alignas&lt;/code&gt; on a declaration is weaker than the alignment it would have without any &lt;code&gt;alignas&lt;/code&gt; specifiers (that is, weaker than its natural alignment or weaker than &lt;code&gt;alignas&lt;/code&gt; on another declaration of the same object or type), the program is ill-formed:</source>
          <target state="translated">如果声明中最严格（最大）的 &lt;code&gt;alignas&lt;/code&gt; 弱于没有任何 &lt;code&gt;alignas&lt;/code&gt; 指示符的对齐方式（即，比其自然对齐方式弱或比 &lt;code&gt;alignas&lt;/code&gt; 弱同一对象或类型的另一个声明的），则程序形式：</target>
        </trans-unit>
        <trans-unit id="b376b7c229a7bc07ebacea949f846a78b0d1782c" translate="yes" xml:space="preserve">
          <source>If the strings overlap, the behavior is undefined.</source>
          <target state="translated">如果字符串重叠,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="7d57980d6c4db7f5a88e476c28a7345cd0ee1e03" translate="yes" xml:space="preserve">
          <source>If the synchronization is turned off, the C++ standard streams are allowed to buffer their I/O independently, which may be considerably faster in some cases.</source>
          <target state="translated">如果关闭同步,则允许C++标准流独立地缓冲它们的I/O,这在某些情况下可能会快得多。</target>
        </trans-unit>
        <trans-unit id="9a8cb52b7220965fcee67fc72cd6b2b899d9bdff" translate="yes" xml:space="preserve">
          <source>If the target sequence is uniquely matched, &lt;code&gt;v&lt;/code&gt; is set to the corresponding &lt;code&gt;bool&lt;/code&gt; value. Otherwise &lt;code&gt;false&lt;/code&gt; is stored in &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;. If unique match could not be found before the input ended (&lt;code&gt;in==end&lt;/code&gt;), &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed.</source>
          <target state="translated">如果目标序列唯一匹配，则将 &lt;code&gt;v&lt;/code&gt; 设置为相应的 &lt;code&gt;bool&lt;/code&gt; 值。否则，将 &lt;code&gt;false&lt;/code&gt; 存储在 &lt;code&gt;v&lt;/code&gt; 中,并将 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 分配给 &lt;code&gt;err&lt;/code&gt; 。如果在输入结束（ &lt;code&gt;in==end&lt;/code&gt; ）之前找不到唯一匹配项，则执行 &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f1289b6bdc776c1418acfec4d954c523b4601b0f" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type referred to by &lt;code&gt;T&lt;/code&gt; with its topmost cv-qualifiers removed. Otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; with its topmost cv-qualifiers removed.</source>
          <target state="translated">如果类型 &lt;code&gt;T&lt;/code&gt; 是引用类型，提供了构件的typedef &lt;code&gt;type&lt;/code&gt; 这是类型提及的由 &lt;code&gt;T&lt;/code&gt; 除去其最高CV-限定符。否则 &lt;code&gt;type&lt;/code&gt; 为 &lt;code&gt;T&lt;/code&gt; 并删除其最上面的cv限定词。</target>
        </trans-unit>
        <trans-unit id="bc4e534b1c21d223bb95673e8d15e125bb5d8892" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type referred to by &lt;code&gt;T&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果类型 &lt;code&gt;T&lt;/code&gt; 是引用类型，提供了构件的typedef &lt;code&gt;type&lt;/code&gt; 是类型由称为 &lt;code&gt;T&lt;/code&gt; 。否则 &lt;code&gt;type&lt;/code&gt; 是 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="568c9a7735dfb6e7c3f7facf46f864c936b3998f" translate="yes" xml:space="preserve">
          <source>If the type is complete and if, for the delete[] only, the operand is a pointer to a class type with a non-trivial destructor or a (possibly multi-dimensional) array thereof, the global size-aware global function (with a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) is selected</source>
          <target state="translated">如果类型是完整的，并且仅对于delete []，操作数是指向具有非平凡的析构函数或其（可能是多维）数组的类类型，全局大小感知全局函数（带有类型为 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; 的参数选择</target>
        </trans-unit>
        <trans-unit id="d45b643bd174051aee94549a2f03f3ff00e0a987" translate="yes" xml:space="preserve">
          <source>If the type is reference type, the operator returns the alignment of</source>
          <target state="translated">如果类型是引用类型,则运算符返回</target>
        </trans-unit>
        <trans-unit id="e61370f729d3fc61feda284c6f51bb8eac974871" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型为 &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb07f1de8954ef59a83dcf953df4f4e9416e15a0" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;boolalpha!=0&lt;/code&gt;, the following replaces stages 2 and 3:</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型为 &lt;code&gt;bool&lt;/code&gt; 并且 &lt;code&gt;boolalpha!=0&lt;/code&gt; ，则以下内容替换阶段2和3：</target>
        </trans-unit>
        <trans-unit id="9a11f0db514f9cdeffd237282d9ed24955a00f05" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;boolalpha==0&lt;/code&gt;, proceeds as if the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long&lt;/code&gt;, except for the value to be stored in &lt;code&gt;v&lt;/code&gt; in stage 3.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型为 &lt;code&gt;bool&lt;/code&gt; 且 &lt;code&gt;boolalpha==0&lt;/code&gt; ，则继续进行，就好像 &lt;code&gt;v&lt;/code&gt; 的类型为 &lt;code&gt;long&lt;/code&gt; 一样，除了要在阶段3中存储在 &lt;code&gt;v&lt;/code&gt; 中的值。</target>
        </trans-unit>
        <trans-unit id="5c85042e7deeed4301f664d1dc468bbb3d06b939" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and boolalpha is not set, then if the value to be stored is &lt;code&gt;​0​&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; is stored, if the value to be stored is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is stored, for any other value &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; is stored.</source>
          <target state="translated">如果类型 &lt;code&gt;v&lt;/code&gt; 是 &lt;code&gt;bool&lt;/code&gt; 和boolalpha未设置，那么，如果要被存储的值是 &lt;code&gt;​0​&lt;/code&gt; ， &lt;code&gt;false&lt;/code&gt; 被存储时，如果要被存储的值是 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;true&lt;/code&gt; 被存储在任何其他值 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 被分配给 &lt;code&gt;err&lt;/code&gt; ,并存储 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7476d41e2a67317c3bb5251d97663d77eeb1e42c" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;double&lt;/code&gt;, will use conversion specifier &lt;code&gt;%lg&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型为 &lt;code&gt;double&lt;/code&gt; ，则将使用转换说明符 &lt;code&gt;%lg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfdf59b17079b062cc1b92411ee58243a516a33f" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型为 &lt;code&gt;float&lt;/code&gt; ，则将使用转换说明符 &lt;code&gt;%g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4567caa0edddb2a88680b490c4e2737935cdcbd5" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long double&lt;/code&gt;, the length modifier &lt;code&gt;L&lt;/code&gt; is added to the conversion specifier.</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型为 &lt;code&gt;long double&lt;/code&gt; ，则长度修饰符 &lt;code&gt;L&lt;/code&gt; 添加到转换说明符中。</target>
        </trans-unit>
        <trans-unit id="0474c288e1ccdf560a85090121492766095a9be3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long double&lt;/code&gt;, will use conversion specifier &lt;code&gt;%Lg&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型为 &lt;code&gt;long double&lt;/code&gt; ，则将使用转换说明符 &lt;code&gt;%Lg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00d6a72b02646eead810c617c23ae522ca753e6d" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;void*&lt;/code&gt;, will use conversion specifier &lt;code&gt;%p&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型为 &lt;code&gt;void*&lt;/code&gt; ，则将使用转换说明符 &lt;code&gt;%p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29e503ca84cb15f39173a1562dbbbb2beffa737a" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is a floating-point type, the the first applicable choice of the following is selected:</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型是浮点类型，则选择以下第一个适用的选择：</target>
        </trans-unit>
        <trans-unit id="af8313560c731302bab034bb408aa878436ea837" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is an integer type, the the first applicable choice of the following five is selected:</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型是整数类型，则选择以下五个中的第一个适用选择：</target>
        </trans-unit>
        <trans-unit id="c3a7ea4c84d1d685474ebd89637a92007ea3ea02" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is an integer type, the the first applicable choice of the following is selected:</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型是整数类型，则选择以下第一个适用的选择：</target>
        </trans-unit>
        <trans-unit id="78f0474ec6b14c626c7efaff5801d926c1f92941" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is signed, will use conversion specifier &lt;code&gt;%d&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型是带符号的，将使用转换说明符 &lt;code&gt;%d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4990261c39b3a34d0f827b213b2a6345d9b18783" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is unsigned, will use conversion specifier &lt;code&gt;%u&lt;/code&gt;</source>
          <target state="translated">如果 &lt;code&gt;v&lt;/code&gt; 的类型是无符号的，将使用转换说明符 &lt;code&gt;%u&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51577fdf94f044af450cebe5474487f90f5669ab" translate="yes" xml:space="preserve">
          <source>If the type of the next argument in &lt;code&gt;ap&lt;/code&gt; (after promotions) is not compatible with &lt;code&gt;T&lt;/code&gt;, the behavior is undefined, unless:</source>
          <target state="translated">如果 &lt;code&gt;ap&lt;/code&gt; 中的下一个参数的类型（在升级后）与 &lt;code&gt;T&lt;/code&gt; 不兼容，则该行为是不确定的，除非：</target>
        </trans-unit>
        <trans-unit id="37ea6657641f330790f7fa714b3234e4d4d737e5" translate="yes" xml:space="preserve">
          <source>If the type's alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, alignment-aware deallocation functions (with a parameter of type &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) are preferred. For other types, the alignment-unaware deallocation functions (without a parameter of type &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) are preferred.</source>
          <target state="translated">如果类型的对齐要求超过 &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; ，则首选可识别对齐的释放函数（参数类型为 &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; ）。对于其他类型，首选没有对齐的对齐功能（不带 &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; 类型的参数）。</target>
        </trans-unit>
        <trans-unit id="9e2d47f6d426a3f84b185a211656e8cd6bd7698e" translate="yes" xml:space="preserve">
          <source>If the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; is copied into such an array, and then the resulting content is copied back into &lt;code&gt;obj1&lt;/code&gt;, &lt;code&gt;obj1&lt;/code&gt; will hold its original value. If the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; are copied into &lt;code&gt;obj2&lt;/code&gt;, &lt;code&gt;obj2&lt;/code&gt; will hold &lt;code&gt;obj1&lt;/code&gt;'s value.</source>
          <target state="translated">如果将 &lt;code&gt;obj1&lt;/code&gt; 的基础字节复制到这样的数组中，然后将所得内容复制回 &lt;code&gt;obj1&lt;/code&gt; ，则 &lt;code&gt;obj1&lt;/code&gt; 将保留其原始值。如果将 &lt;code&gt;obj1&lt;/code&gt; 的基础字节复制到 &lt;code&gt;obj2&lt;/code&gt; 中，则 &lt;code&gt;obj2&lt;/code&gt; 将保存 &lt;code&gt;obj1&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="1c532a0885cdbf73cb10a896503a4564c8a0bf0b" translate="yes" xml:space="preserve">
          <source>If the underlying type is fixed, the result is the same as the &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration and then to the enumeration type.</source>
          <target state="translated">如果基础类型是固定的，则结果与&lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;将&lt;/a&gt;原始值先转换为枚举的基础类型然后转换为枚举类型相同。</target>
        </trans-unit>
        <trans-unit id="53c5be902373ad8ba2b8c3eceeaae48131069091" translate="yes" xml:space="preserve">
          <source>If the underlying type is not fixed, the result is unspecified(until C++17)undefined behavior(since C++17) if the value of expression is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration).</source>
          <target state="translated">如果底层类型不固定,如果表达式的值超出了范围(范围是指足够大的、可以容纳目标枚举的所有枚举器的最小位域的所有可能的值),那么结果就是未指定(直到C++17)未定义的行为(自C++17起)。</target>
        </trans-unit>
        <trans-unit id="9584e81563cc79a87482512943d106e7c6f35aeb" translate="yes" xml:space="preserve">
          <source>If the user defined function returns when handling &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; or any other implementation-defined signal specifying a computational exception, the behavior is undefined.</source>
          <target state="translated">如果用户定义的函数在处理 &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; 或指定计算异常的任何其他实现定义的信号时返回，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="758bb6908f51c11c8477acd6f36292722e9b2a25" translate="yes" xml:space="preserve">
          <source>If the user-defined signal handling strategy is not set using &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked.</source>
          <target state="translated">如果尚未使用 &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; 设置用户定义的信号处理策略，则实现定义是忽略信号还是调用默认处理程序。</target>
        </trans-unit>
        <trans-unit id="ad569346ec44ef60f084b9ce61fd4164c7c32f63" translate="yes" xml:space="preserve">
          <source>If the usual deduction from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; (as described above) fails, the following alternatives are additionally considered:</source>
          <target state="translated">如果从 &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 进行的常规推导失败（如上所述），则将另外考虑以下替代方法：</target>
        </trans-unit>
        <trans-unit id="222dded9de677b2df12bcb544421882e3b919712" translate="yes" xml:space="preserve">
          <source>If the usual deduction from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; fails, the following alternatives are additionally considered:</source>
          <target state="translated">如果从 &lt;code&gt;P&lt;/code&gt; 和 &lt;code&gt;A&lt;/code&gt; 的常规推导失败，则另外考虑以下替代方法：</target>
        </trans-unit>
        <trans-unit id="2044c8cb072e19726cdc9c11e14101e5b7aa5788" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;​0​&lt;/code&gt; is added or subtracted from a pointer, the result is the pointer, unchanged. If two pointers point at the same object or are both one past the end of the same array, or both are null pointers, then the result of subtraction is equal to &lt;code&gt;(&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;)0&lt;/code&gt;.</source>
          <target state="translated">如果该值为 &lt;code&gt;​0​&lt;/code&gt; 被添加或从一个指针中减去，其结果是指针，持平。如果两个指针指向同一对象，或者两个指针都指向同一数组的末尾，或者两个指针均为空指针，则相减的结果等于 &lt;code&gt;(&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;)0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29e60c2f6520b56b9cab3b22f7509b4a9255b562" translate="yes" xml:space="preserve">
          <source>If the value in the first dimension is erroneous for any of these reasons,</source>
          <target state="translated">如果第一个维度的数值因上述任何原因出现错误。</target>
        </trans-unit>
        <trans-unit id="030063b706611cf1e8e06a4ae59ec7618b58db95" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;ch&lt;/code&gt; is neither representable as a &lt;code&gt;wchar_t&lt;/code&gt; nor equal to the value of the macro &lt;code&gt;WEOF&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;ch&lt;/code&gt; 的值既不能表示为 &lt;code&gt;wchar_t&lt;/code&gt; 也不能等于宏 &lt;code&gt;WEOF&lt;/code&gt; 的值，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="248a5c7e458d6f5d84a843bb9bad9a695797de69" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;wc&lt;/code&gt; is neither representable as a &lt;code&gt;wchar_t&lt;/code&gt; nor equal to the value of the macro &lt;code&gt;WEOF&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">如果 &lt;code&gt;wc&lt;/code&gt; 的值既不能表示为 &lt;code&gt;wchar_t&lt;/code&gt; 也不能等于宏 &lt;code&gt;WEOF&lt;/code&gt; 的值，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="95ab164f16af6b727b63cdf344a7e218377e5641" translate="yes" xml:space="preserve">
          <source>If the value of base is &lt;code&gt;​0​&lt;/code&gt;, the numeric base is auto-detected: if the prefix is &lt;code&gt;0&lt;/code&gt;, the base is octal, if the prefix is &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the base is hexadecimal, otherwise the base is decimal.</source>
          <target state="translated">如果碱的值是 &lt;code&gt;​0​&lt;/code&gt; 时，数字基是自动检测：如果前缀是 &lt;code&gt;0&lt;/code&gt; ，碱为八进制，如果前缀 &lt;code&gt;0x&lt;/code&gt; 或 &lt;code&gt;0X&lt;/code&gt; ，碱是十六进制的，否则该碱是小数。</target>
        </trans-unit>
        <trans-unit id="70a9c765b78740ba6c067e64a0ddbb7ae2ac6060" translate="yes" xml:space="preserve">
          <source>If the value of the integer literal is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as &lt;code&gt;__int128&lt;/code&gt;) the literal may be given the extended integer type -- otherwise the program is ill-formed.</source>
          <target state="translated">如果整数文字的值太大而不能适合后缀/基数组合所允许的任何类型，并且编译器支持扩展的整数类型（例如 &lt;code&gt;__int128&lt;/code&gt; ），则可以为文字提供扩展的整数类型-否则程序为格式错误。</target>
        </trans-unit>
        <trans-unit id="e8c33ee241a255a63ad79ee3a3348d39830a7425" translate="yes" xml:space="preserve">
          <source>If the value to be stored in &lt;code&gt;*exp&lt;/code&gt; is outside the range of &lt;code&gt;int&lt;/code&gt;, the behavior is unspecified.</source>
          <target state="translated">如果要存储在 &lt;code&gt;*exp&lt;/code&gt; 中的值在 &lt;code&gt;int&lt;/code&gt; 范围之外，则行为未指定。</target>
        </trans-unit>
        <trans-unit id="e2f54be830759cbe8fb68d644557c982f45181ea" translate="yes" xml:space="preserve">
          <source>If the value type is known to be a built-in type, the const variant should return by value.</source>
          <target state="translated">如果已知值类型是内置类型,则const variant应按值返回。</target>
        </trans-unit>
        <trans-unit id="90307671f8933d3e9e5abc11ed1d390a29f7fef2" translate="yes" xml:space="preserve">
          <source>If the variant is &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;, returns &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;.</source>
          <target state="translated">如果变体&lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;，退货&lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fa561126aaa10ae89524de188dae5e165b1fdb67" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, none.</source>
          <target state="translated">如果矢量改变了容量,则全部改变。如果没有,则全无。</target>
        </trans-unit>
        <trans-unit id="4d3428e86be4da734a232d16973b7cf3b93b4058" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, only end().</source>
          <target state="translated">如果向量改变了容量,则全部改变。如果没有,只有end()。</target>
        </trans-unit>
        <trans-unit id="72ef803ef1a355b795f9869f64ff81133821942a" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, only those after the insertion point.</source>
          <target state="translated">如果向量改变了容量,则全部改变。如果没有,只有插入点之后的那些。</target>
        </trans-unit>
        <trans-unit id="eb75958a443f6e86954852258d39617127eed64b" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">如果产生的宽字符为空字符，则转换状态 &lt;code&gt;*ps&lt;/code&gt; 表示初始移位状态。</target>
        </trans-unit>
        <trans-unit id="24382f133af9ec92a179262afb80b489903f3a55" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state stored in &lt;code&gt;*ps&lt;/code&gt; is the initial shift state.</source>
          <target state="translated">如果产生的宽字符为空字符，则存储在 &lt;code&gt;*ps&lt;/code&gt; 中的转换状态为初始移位状态。</target>
        </trans-unit>
        <trans-unit id="0c78b539f6ef73fa78a596278e160b79dda2072b" translate="yes" xml:space="preserve">
          <source>If there are multiple declarations with different lexical orders (e.g. a function template declared with trailing return type, to be substituted after a parameter, and redeclared with ordinary return type that would be substituted before the parameter), then the program is ill-formed; no diagnostic required.</source>
          <target state="translated">如果有多个不同词序的声明(比如一个函数模板声明的是尾部返回类型,要在参数后面替换,而重新声明的是普通返回类型,要在参数前面替换),那么这个程序就是不正规的;不需要诊断。</target>
        </trans-unit>
        <trans-unit id="d2b18351965a2fe087972c4fc08282cc6ca24208" translate="yes" xml:space="preserve">
          <source>If there are multiple overloads of the function or operator being called, after the implicit conversion sequence is built from &lt;code&gt;T1&lt;/code&gt; to each available &lt;code&gt;T2&lt;/code&gt;, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; rules decide which overload is compiled.</source>
          <target state="translated">如果调用的函数或运算符有多个重载，则在从 &lt;code&gt;T1&lt;/code&gt; 到每个可用 &lt;code&gt;T2&lt;/code&gt; 构造隐式转换序列之后，&lt;a href=&quot;overload_resolution&quot;&gt;重载解析&lt;/a&gt;规则将决定编译哪个重载。</target>
        </trans-unit>
        <trans-unit id="a5a33472c5c80216c585ac1f3e2bb1b8d2b913cd" translate="yes" xml:space="preserve">
          <source>If there are multiple parameters, each &lt;code&gt;P&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt; pair is deduced separately and the deduced template arguments are then combined. If deduction fails or is ambiguous for any &lt;code&gt;P&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt; pair or if different pairs yield different deduced template arguments, or if any template argument remains neither deduced nor explicitly specified, compilation fails.</source>
          <target state="translated">如果有多个参数，则分别推导每个 &lt;code&gt;P&lt;/code&gt; / &lt;code&gt;A&lt;/code&gt; 对，然后组合推导的模板参数。如果推导失败或对于任何 &lt;code&gt;P&lt;/code&gt; / &lt;code&gt;A&lt;/code&gt; 对来说都是模棱两可的，或者如果不同的对产生不同的推导模板参数，或者如果既未推导也未明确指定任何模板参数，则编译将失败。</target>
        </trans-unit>
        <trans-unit id="08ff4d812abea495b9856132aa9d1453e7f49ba6" translate="yes" xml:space="preserve">
          <source>If there are multiple return statements, they must all deduce to the same type.</source>
          <target state="translated">如果有多个返回报表,必须全部推导为同一类型。</target>
        </trans-unit>
        <trans-unit id="56e2a9dcbebace2c5e7ec9081f6a581a3eccd3f0" translate="yes" xml:space="preserve">
          <source>If there are no elements</source>
          <target state="translated">如果没有元素</target>
        </trans-unit>
        <trans-unit id="2be453c0735328c6008b2c9ff54809c970ae7dd0" translate="yes" xml:space="preserve">
          <source>If there are no elements, the behavior is undefined.</source>
          <target state="translated">如果没有元素,则行为未定义。</target>
        </trans-unit>
        <trans-unit id="60124398219caa2545336ef3688db0d123bcef47" translate="yes" xml:space="preserve">
          <source>If there are no matches, copies the entire sequence into &lt;code&gt;out&lt;/code&gt; as-is, by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(first, last, out)&lt;/code&gt;</source>
          <target state="translated">如果没有匹配项，则将整个序列按原样复制到 &lt;code&gt;out&lt;/code&gt; 中，方法是 &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(first, last, out)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="430a0a9ceb3976f6b074269c72597aae319e083f" translate="yes" xml:space="preserve">
          <source>If there are no more entries left in the currently iterated directory, the iteration is resumed over the parent directory. The process is repeated if the parent directory has no sibling entries that can to be iterated on. If the parent of the directory hierarchy that has been recursively iterated on is reached (there are no candidate entries at &lt;code&gt;depth() == 0)&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to an end iterator.</source>
          <target state="translated">如果当前迭代的目录中没有其他条目，则在父目录上继续迭代。如果父目录没有可重复访问的同级条目，则重复此过程。如果到达已递归迭代的目录层次结构的父级（ &lt;code&gt;depth() == 0)&lt;/code&gt; 处没有候选条目），则将 &lt;code&gt;*this&lt;/code&gt; 设置为结束迭代器。</target>
        </trans-unit>
        <trans-unit id="786c19346a6501f7f519d77c25d16a5bd6120203" translate="yes" xml:space="preserve">
          <source>If there is no associated mutex or the mutex is not locked, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果没有关联的互斥锁或互斥锁未锁定，则错误代码为 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd20e611e7f59595531f451ca3dfeabb2921c4e5" translate="yes" xml:space="preserve">
          <source>If there is no associated mutex, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">如果没有关联的互斥锁，则 &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 的错误代码为 &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d214d3c80c859a6e49e6fef5913cd6a8474d164" translate="yes" xml:space="preserve">
          <source>If there is no corresponding call to &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt;, or if &lt;code&gt;va_end&lt;/code&gt; is not called before a function that calls &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; returns, the behavior is undefined.</source>
          <target state="translated">如果没有对 &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; 的相应调用，或者在调用 &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; 的函数返回之前未调用 &lt;code&gt;va_end&lt;/code&gt; ，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="82e2ba4ed8370caec8cb2a4375b819fec9dd1a0f" translate="yes" xml:space="preserve">
          <source>If there is no pattern match, returns a value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ptr&lt;/code&gt; equals &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;ec&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;value&lt;/code&gt; is unmodified.</source>
          <target state="translated">如果没有模式匹配，则返回类型的值 &lt;code&gt;from_chars_result&lt;/code&gt; 以使 &lt;code&gt;ptr&lt;/code&gt; 等于 &lt;code&gt;first&lt;/code&gt; ， &lt;code&gt;ec&lt;/code&gt; 等于 &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; 。 &lt;code&gt;value&lt;/code&gt; 未修改。</target>
        </trans-unit>
        <trans-unit id="bb2824bbf3f97be3e717eef3b6756fb7dd5b0ccf" translate="yes" xml:space="preserve">
          <source>If there is no return statement or if the argument of the return statement is a void expression, the declared return type must be either &lt;code&gt;decltype(auto)&lt;/code&gt;, in which case the deduced return type is &lt;code&gt;void&lt;/code&gt;, or (possibly cv-qualified) &lt;code&gt;auto&lt;/code&gt; , in which case the deduced return type is then (identically cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">如果没有return语句，或者return语句的参数为void表达式，则声明的返回类型必须为 &lt;code&gt;decltype(auto)&lt;/code&gt; ，在这种情况下，推导的返回类型为 &lt;code&gt;void&lt;/code&gt; ，或者（可能是cv限定的） &lt;code&gt;auto&lt;/code&gt; ，在这种情况下，推论的返回类型将变为（等同于cv限定） &lt;code&gt;void&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9786fb90520614ec4de44d4ccd5a94337ce70dc0" translate="yes" xml:space="preserve">
          <source>If there is no value of type &lt;code&gt;To&lt;/code&gt; corresponding to the value representation produced, the behavior is undefined. If there are multiple such values, which value is produced is unspecified.</source>
          <target state="translated">如果没有类型 &lt;code&gt;To&lt;/code&gt; 的值对应于所生成的值表示形式，则该行为是不确定的。如果存在多个这样的值，则未指定产生哪个值。</target>
        </trans-unit>
        <trans-unit id="08e7e744ae0e0c5037802c6defe497d81baa4ef8" translate="yes" xml:space="preserve">
          <source>If there is not enough memory, the old memory block is not freed and null pointer is returned.</source>
          <target state="translated">如果内存不足,则不释放旧内存块,返回null指针。</target>
        </trans-unit>
        <trans-unit id="75b29d8574fca6602e9dfcd68f07686982e86cb2" translate="yes" xml:space="preserve">
          <source>If there is nothing on the left hand side of the &lt;code&gt;::&lt;/code&gt;, the lookup considers only declarations made in the global namespace scope (or introduced into the global namespace by a &lt;a href=&quot;namespace&quot;&gt;using declaration&lt;/a&gt;). This makes it possible to refer to such names even if they were hidden by a local declaration:</source>
          <target state="translated">如果 &lt;code&gt;::&lt;/code&gt; 的左侧没有任何内容，则查找仅考虑在全局名称空间范围内做出的声明（或通过&lt;a href=&quot;namespace&quot;&gt;using声明&lt;/a&gt;引入全局名称空间中的声明）。这样就可以引用这样的名称，即使它们被本地声明隐藏了：</target>
        </trans-unit>
        <trans-unit id="a39354352c3a36abb4078e05bc0601edf6cd7f44" translate="yes" xml:space="preserve">
          <source>If there was a &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; operation X</source>
          <target state="translated">如果有一个 &lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; 操作X</target>
        </trans-unit>
        <trans-unit id="ad371531997ade6500f19cfb02b883b25ff79f63" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postcondition (&lt;code&gt;lock.owns_lock()==true&lt;/code&gt; and &lt;code&gt;lock.mutex()&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">如果这些功能不能满足后置条件（ &lt;code&gt;lock.owns_lock()==true&lt;/code&gt; 且 &lt;code&gt;lock.mutex()&lt;/code&gt; 被调用线程锁定），则调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。例如，如果重新锁定互斥锁引发异常，则可能会发生这种情况，</target>
        </trans-unit>
        <trans-unit id="8b7c68c75d237fbfbeeafab70e579d60f492f831" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postcondition (&lt;code&gt;lock&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">如果这些函数不能满足后置条件（ &lt;code&gt;lock&lt;/code&gt; 被调用线程锁定），则调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。例如，如果重新锁定互斥锁引发异常，则可能会发生这种情况，</target>
        </trans-unit>
        <trans-unit id="e64ebeb583017ab34a1b336b3949d0e606ed7464" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postconditions (&lt;code&gt;lock.owns_lock()==true&lt;/code&gt; and &lt;code&gt;lock.mutex()&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">如果这些函数不满足后置条件（ &lt;code&gt;lock.owns_lock()==true&lt;/code&gt; 和 &lt;code&gt;lock.mutex()&lt;/code&gt; 被调用线程锁定），则调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。例如，如果重新锁定互斥锁引发异常，则可能会发生这种情况，</target>
        </trans-unit>
        <trans-unit id="80d1cce971ef81ebeb27b3f75282ca12f479c4a3" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postconditions (&lt;code&gt;lock&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">如果这些功能不能满足后置条件（ &lt;code&gt;lock&lt;/code&gt; 被调用线程锁定），则调用 &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。例如，如果重新锁定互斥锁引发异常，则可能会发生这种情况，</target>
        </trans-unit>
        <trans-unit id="3d778c344c068708c3e9722504ddb91a10967713" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;codecvt&lt;/code&gt; facet does not define a conversion, no characters are converted. &lt;code&gt;to_next&lt;/code&gt; is set to be equal to &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; is unchanged, and &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">如果此 &lt;code&gt;codecvt&lt;/code&gt; 构面未定义转换，则不会转换任何字符。 &lt;code&gt;to_next&lt;/code&gt; 被设定为等于 &lt;code&gt;to&lt;/code&gt; ， &lt;code&gt;state&lt;/code&gt; 不变，并且 &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="aacf8a59ed2ae04fea1befba59a2f4989fe43a0b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;wstring_convert&lt;/code&gt; object was constructed without a user-supplied byte-error string, throws &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; on conversion failure.</source>
          <target state="translated">如果这个 &lt;code&gt;wstring_convert&lt;/code&gt; 构造对象时没有提供用户提供的字节错误字符串，则转换失败时将引发 &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cbcd6f179051e3d4d790103a0692450f238f91b6" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;wstring_convert&lt;/code&gt; object was constructed without a user-supplied wide-error string, throws &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; on conversion failure.</source>
          <target state="translated">如果这个 &lt;code&gt;wstring_convert&lt;/code&gt; 构造对象时没有提供用户提供的宽错误字符串，则转换失败时将引发 &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6ba9b5bd88a92b215f9d46a302f511d4c0d3235" translate="yes" xml:space="preserve">
          <source>If this function is called after I/O has occurred on the standard stream, the behavior is implementation-defined: implementations range from no effect to destroying the read buffer.</source>
          <target state="translated">如果这个函数在标准流上的I/O发生后被调用,那么行为是由实现定义的:实现范围从没有影响到销毁读缓冲区。</target>
        </trans-unit>
        <trans-unit id="7ab8ebc954b0557ea6a9a5ccedd0ab0cb9a2ceb2" translate="yes" xml:space="preserve">
          <source>If this function is called twice on the same &lt;code&gt;obj&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">如果在同一 &lt;code&gt;obj&lt;/code&gt; 上两次调用此函数，则行为未定义。</target>
        </trans-unit>
        <trans-unit id="5b1e8e769c369fe401942d10347ef2341bebc1e8" translate="yes" xml:space="preserve">
          <source>If transfer of control enters the scope of any automatic variables (e.g. by jumping forward over a declaration statement), the program is ill-formed (cannot be compiled), unless all variables whose scope is entered have.</source>
          <target state="translated">如果控制权的转移进入了任何自动变量的范围(例如通过跳转到声明语句上),则程序是不完善的(不能编译),除非所有进入范围的变量都有。</target>
        </trans-unit>
        <trans-unit id="9007006fca17d8a04caf552baacfbe914165d918" translate="yes" xml:space="preserve">
          <source>If transfer of control exits the scope of any automatic variables (e.g. by jumping backwards to a point before the declarations of such variables or by jumping forward out of a compound statement where the variables are scoped), the destructors are called for all variables whose scope was exited, in the order opposite to the order of their construction.</source>
          <target state="translated">如果控制权的转移退出了任何自动变量的作用域(例如,通过向后跳转到这些变量声明之前的某个点,或者通过向前跳转出变量作用域的复合语句),则会对所有作用域被退出的变量调用解构器,顺序与它们的构造顺序相反。</target>
        </trans-unit>
        <trans-unit id="96de619385ef72541fd42f53b710eb1ba726dc0a" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Key&lt;/code&gt;s are equal according to &lt;code&gt;Pred&lt;/code&gt;, &lt;code&gt;Hash&lt;/code&gt; must return the same value for both keys.</source>
          <target state="translated">如果根据 &lt;code&gt;Pred&lt;/code&gt; 两个 &lt;code&gt;Key&lt;/code&gt; 相等，，则 &lt;code&gt;Hash&lt;/code&gt; 必须为两个密钥返回相同的值。</target>
        </trans-unit>
        <trans-unit id="21514f17271611919ab5d31d97737af032553cf0" translate="yes" xml:space="preserve">
          <source>If two conversion sequences are indistinguishable because they have the same rank, the following additional rules apply:</source>
          <target state="translated">如果两个转换序列因为等级相同而无法区分,则适用以下附加规则。</target>
        </trans-unit>
        <trans-unit id="236b56e175db6d0402c006ec6f6fe29bfcd434e0" translate="yes" xml:space="preserve">
          <source>If two or more overloads accept different pointer types, an overload for &lt;code&gt;std::nullptr_t&lt;/code&gt; is necessary to accept a null pointer argument.</source>
          <target state="translated">如果两个或多个重载接受不同的指针类型，则为 &lt;code&gt;std::nullptr_t&lt;/code&gt; 则必须接受std :: nullptr_t才能接受空指针参数。</target>
        </trans-unit>
        <trans-unit id="1df13f76013467c8d1808876f2f6ad361b81ec46" translate="yes" xml:space="preserve">
          <source>If two pointers are not specified to compare greater or compare equal, the result of the comparison is unspecified. The result may be nondeterministic, and need not be consistent even for multiple evaluations of the same expression with the same operands in the same execution of the program:</source>
          <target state="translated">如果没有指定两个指针来比较大于或比较等于,比较的结果是不确定的。结果可能是不确定的,即使在程序的同一执行中对同一操作数的同一表达式进行多次评估,结果也不一定是一致的。</target>
        </trans-unit>
        <trans-unit id="54c474a432a885a9d80c638012c2da37dcdf5a0e" translate="yes" xml:space="preserve">
          <source>If two ranges have equivalent elements and are of the same length, then the ranges are lexicographically</source>
          <target state="translated">如果两个范围的元素相等,并且长度相同,那么这些范围在词法上就是</target>
        </trans-unit>
        <trans-unit id="dea9e99a4902829c785e86953d9771a67436d749" translate="yes" xml:space="preserve">
          <source>If two thread identifiers compare equal, they have identical textual representations; if they do not compare equal, their representations are distinct.</source>
          <target state="translated">如果两个线程标识符比较相等,则它们的文字表述是相同的;如果它们不比较相等,则它们的表述是不同的。</target>
        </trans-unit>
        <trans-unit id="44df2c42d0c8b0977cc12b1567332b861f35e2c9" translate="yes" xml:space="preserve">
          <source>If two union members are standard-layout types, it's well-defined to examine their common subsequence on any compiler.</source>
          <target state="translated">如果两个联合成员是标准布局类型,那么在任何编译器上检查它们的共同子序列都是很好的定义。</target>
        </trans-unit>
        <trans-unit id="905593757752d3cb5b8a000e5d6df93d8badb63b" translate="yes" xml:space="preserve">
          <source>If two using-declarations inherit the constructor with the same signature (from two direct base classes), the program is ill-formed.</source>
          <target state="translated">如果两个使用声明继承了具有相同签名的构造函数(来自两个直接的基类),那么程序就是不合格的。</target>
        </trans-unit>
        <trans-unit id="b3ee41429cd3e4ea61f8eae244494a1cc4dbc646" translate="yes" xml:space="preserve">
          <source>If type is an array type, an array of objects is initialized.</source>
          <target state="translated">如果type是数组类型,则初始化对象数组。</target>
        </trans-unit>
        <trans-unit id="dfd366835c89e7a8dac1ada14ac3a1a2f256aa18" translate="yes" xml:space="preserve">
          <source>If type-constraint is &lt;code&gt;Concept&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt;, then the constraint expression &lt;code&gt;Concept&amp;lt;T, A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; must be valid and return &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">如果类型约束是 &lt;code&gt;Concept&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; 那么约束表达 &lt;code&gt;Concept&amp;lt;T, A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; 必须是有效和返回 &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="37e1efeb1f04dd65befd738a35a8fbab85af47d5" translate="yes" xml:space="preserve">
          <source>If type-constraint is present, let &lt;code&gt;T&lt;/code&gt; be the type deduced for the placeholder, &lt;code&gt;T&lt;/code&gt; must satisfy the immediately-declared constraint of type-constraint. That is,</source>
          <target state="translated">如果存在类型约束，则让 &lt;code&gt;T&lt;/code&gt; 为为占位符推导的类型， &lt;code&gt;T&lt;/code&gt; 必须满足立即声明的类型约束的约束。那是，</target>
        </trans-unit>
        <trans-unit id="60c6cdefb849b977d1ac7bc22c41f84525eb69b1" translate="yes" xml:space="preserve">
          <source>If value-initialization in overload (1) is undesirable, for example, if the elements are of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="translated">如果不希望在重载（1）中进行值初始化，例如，如果元素为非类类型并且不需要归零，则可以通过提供一个 &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;自定义的Allocator :: construct&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="471d29d119a51d5505a44bc2b58788054e85e209" translate="yes" xml:space="preserve">
          <source>If value-initialization in overload (1) is undesirable, for example, if the elements are of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;https://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f66ab74451a3db452059ec3845f07a89e06bbf3" translate="yes" xml:space="preserve">
          <source>If wc is the null wide character &lt;code&gt;L'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">如果wc是空宽字符 &lt;code&gt;L'\0'&lt;/code&gt; ，则存储一个空字节，其后是恢复初始移位状态所需的任何移位序列，并且转换状态参数 &lt;code&gt;*ps&lt;/code&gt; 被更新以表示初始移位状态。</target>
        </trans-unit>
        <trans-unit id="32c015539aa6def36ac45f02ee69383d444c9a17" translate="yes" xml:space="preserve">
          <source>If width specifier is used, matches up to</source>
          <target state="translated">如果使用了宽度指定器,则最多匹配到...。</target>
        </trans-unit>
        <trans-unit id="80643aeb5f10297c8773a32774b36761e19c9f6e" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">如果x为零且y为无穷大，或者x为无穷大且y为零且z为NaN，则返回NaN并可能引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="217b0f1a492e46dd9c7d22b89fac1d204972e19f" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果x为零，y为无穷大，或者如果x为无穷大且y为0，z是不是一个NaN，则返回NaN且 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="46f35d1f1e835536b48c1d1451cead305f826b6a" translate="yes" xml:space="preserve">
          <source>If x or y are NaN, NaN is returned</source>
          <target state="translated">如果x或y是NaN,则返回NaN。</target>
        </trans-unit>
        <trans-unit id="448389c4ec48e9adff6b8542b1d7d5e0005baf1b" translate="yes" xml:space="preserve">
          <source>If x*y is an exact infinity and z is an infinity with the opposite sign, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">如果X * Y是一种精确无穷大，并且z是具有相反符号的无穷大，则返回NaN且 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; 升高</target>
        </trans-unit>
        <trans-unit id="3bdeffa5a91b0032e30c68e073ce8335607fac7a" translate="yes" xml:space="preserve">
          <source>If you do not have C++11, an equivalent to &lt;code&gt;std::find_if_not&lt;/code&gt; is to use &lt;code&gt;std::find_if&lt;/code&gt; with the negated predicate.</source>
          <target state="translated">如果您没有C ++ 11，则使用与 &lt;code&gt;std::find_if_not&lt;/code&gt; 等效的方法 &lt;code&gt;std::find_if&lt;/code&gt; 与否定谓词一起使用。</target>
        </trans-unit>
        <trans-unit id="dee1d062b9bd3ef2ac4463366425592d8bf6079d" translate="yes" xml:space="preserve">
          <source>If z is NaN, and x*y aren't 0*Inf or Inf*0, then NaN is returned (without FE_INVALID)</source>
          <target state="translated">如果z是NaN,并且x*y不是0*Inf或Inf*0,则返回NaN(不含FE_INVALID)</target>
        </trans-unit>
        <trans-unit id="fede8b50b6882e5d3ce2a02e4778a6b33e6bfd1e" translate="yes" xml:space="preserve">
          <source>If |arg| &amp;gt; 1, a domain error occurs and NaN is returned.</source>
          <target state="translated">如果| arg | &amp;gt; 1，发生域错误，并返回NaN。</target>
        </trans-unit>
        <trans-unit id="19ae8a036da573c60fcd648999f547940ac705f3" translate="yes" xml:space="preserve">
          <source>If |k|&amp;gt;1, a domain error may occur</source>
          <target state="translated">如果| k |&amp;gt; 1，则可能会发生域错误</target>
        </trans-unit>
        <trans-unit id="f54d83c12cb912afe24330261b82ab51323c3c37" translate="yes" xml:space="preserve">
          <source>If |x| &amp;gt; 1, a domain error may occur</source>
          <target state="translated">如果| x | &amp;gt; 1，可能会发生域错误</target>
        </trans-unit>
        <trans-unit id="124d00d6f3d9dc4a6bd589c99e1ea07d87b1c00a" translate="yes" xml:space="preserve">
          <source>If, after a using-directive was used to nominate some namespace, the namespace is extended and additional members and/or using-directives are added to it, those additional members and the additional namespaces are visible through the using-directive (in contrast with using-declaration).</source>
          <target state="translated">如果在使用指令指定某个命名空间后,命名空间被扩展,并在其中添加了额外的成员和/或使用指令,那么这些额外的成员和额外的命名空间通过使用指令可见(与使用声明相反)。</target>
        </trans-unit>
        <trans-unit id="f18ec98606b2fb57c51cf2d2b42ed110712ce687" translate="yes" xml:space="preserve">
          <source>If, after considering all pairs of overloaded templates, there is one that is unambiguously more specialized than all others, that template's specialization is selected, otherwise compilation fails.</source>
          <target state="translated">如果在考虑了所有的过载模板对后,有一个模板明确地比其他所有模板更专业化,则选择该模板的专业化,否则编译失败。</target>
        </trans-unit>
        <trans-unit id="18db54187de2ad0a31a7c5e4bdded4c034fc402d" translate="yes" xml:space="preserve">
          <source>If, after construction, the member &lt;code&gt;regex_iterator&lt;/code&gt; is not an end-of-sequence iterator, sets the member pointer to the address of the current &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在构造之后，成员 &lt;code&gt;regex_iterator&lt;/code&gt; 不是序列结束迭代器，则将成员指针设置为当前 &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; 的地址。</target>
        </trans-unit>
        <trans-unit id="24d2b4c0d32e555ffdf12e4f24627c557a463748" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">如果从 &lt;code&gt;src&lt;/code&gt; 复制终止的空字符之后，未达到 &lt;code&gt;count&lt;/code&gt; ，则将其他空字符写入 &lt;code&gt;dest&lt;/code&gt; ,直到写入了总数的 &lt;code&gt;count&lt;/code&gt; 字符为止。</target>
        </trans-unit>
        <trans-unit id="d6321b986a2eb461234e0b8b628d35dcf35b6aeb" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null wide character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null wide characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">如果从 &lt;code&gt;src&lt;/code&gt; 复制了终止的null宽字符之后，未达到 &lt;code&gt;count&lt;/code&gt; ，则将其他null宽字符写入 &lt;code&gt;dest&lt;/code&gt; ,直到写入了 &lt;code&gt;count&lt;/code&gt; 个字符的总数。</target>
        </trans-unit>
        <trans-unit id="2b833da015ca09bbc003a6a35757746d54b28eaa" translate="yes" xml:space="preserve">
          <source>If, after overload resolution, the order of declaration of the aggregate's members does not match for the selected overload, the initialization of the parameter will be ill-formed.</source>
          <target state="translated">如果在过载解析后,集合体成员的声明顺序与选择的过载不一致,则参数的初始化将是不合格的。</target>
        </trans-unit>
        <trans-unit id="4344e13bb6aa8857aeb8da90f2cfb52094846e93" translate="yes" xml:space="preserve">
          <source>If, after the using-declaration was used to take a member from a namespace, the namespace is extended and additional declarations for the same name are introduced, those additional declarations do not become visible through the using-declaration (in contrast with using-directive). One exception is when a using-declaration names a class template: partial specializations introduced later are effectively visible, because their &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt; proceeds through the primary template.</source>
          <target state="translated">如果在使用using声明从命名空间中获取成员之后，如果扩展了命名空间并引入了相同名称的其他声明，则这些其他声明不会通过using声明可见（与using指令相反） ）。一个例外是当using声明为类模板命名时：后面介绍的部分专业化实际上是可见的，因为它们的&lt;a href=&quot;lookup&quot;&gt;查找是&lt;/a&gt;通过主模板进行的。</target>
        </trans-unit>
        <trans-unit id="dbce6be800bfbd414094242237e485ad6d751c14" translate="yes" xml:space="preserve">
          <source>If, by the time &lt;code&gt;call_once&lt;/code&gt; is called, &lt;code&gt;flag&lt;/code&gt; indicates that &lt;code&gt;f&lt;/code&gt; was already called, &lt;code&gt;call_once&lt;/code&gt; returns right away (such a call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">如果在调用 &lt;code&gt;call_once&lt;/code&gt; 时 &lt;code&gt;flag&lt;/code&gt; 表明 &lt;code&gt;f&lt;/code&gt; 已经被调用，则 &lt;code&gt;call_once&lt;/code&gt; 立即返回（这样对 &lt;code&gt;call_once&lt;/code&gt; 的调用称为</target>
        </trans-unit>
        <trans-unit id="515903e5cd9a30bdc013b27094038c879ea5e3ca" translate="yes" xml:space="preserve">
          <source>If, instead of a function body, the special syntax &lt;code&gt;= delete&amp;nbsp;;&lt;/code&gt; is used, the function is defined as</source>
          <target state="translated">如果特殊语法 &lt;code&gt;= delete&amp;nbsp;;&lt;/code&gt; 而不是函数正文；使用时，功能定义为</target>
        </trans-unit>
        <trans-unit id="1fcb027646c98dda89397bc3d304d3c40f2112ab" translate="yes" xml:space="preserve">
          <source>If, prior to this call, &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">如果在此调用之前， &lt;code&gt;*this&lt;/code&gt; 具有关联的互斥锁（（ &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; 返回一个非空指针）并且已经获得了它的所有权（ &lt;code&gt;owns()&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ），则可以通过调用 &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; 来解锁该互斥锁。</target>
        </trans-unit>
        <trans-unit id="cddfcce1d6482355377933166f2bf61ba8023df9" translate="yes" xml:space="preserve">
          <source>If, when this instance of &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; was constructed, a custom classification table was provided and the second argument to the constructor (the boolean &lt;code&gt;del&lt;/code&gt;) was &lt;code&gt;true&lt;/code&gt;, then this destructor executes &lt;code&gt;delete[] table()&lt;/code&gt;.</source>
          <target state="translated">如果在构造此 &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 实例时，提供了一个自定义分类表，并且构造函数的第二个参数（boolean &lt;code&gt;del&lt;/code&gt; ）为 &lt;code&gt;true&lt;/code&gt; ，则此析构函数将执行 &lt;code&gt;delete[] table()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abf34976945e39546eb65c898c5e72a940d36da7" translate="yes" xml:space="preserve">
          <source>Ignore symlinks</source>
          <target state="translated">忽略符号链接</target>
        </trans-unit>
        <trans-unit id="3c9993c27a919660753159130e530c6cef6861a2" translate="yes" xml:space="preserve">
          <source>Ill-formed expression used in a template parameter type</source>
          <target state="translated">模板参数类型中使用的表达式格式不正确。</target>
        </trans-unit>
        <trans-unit id="e25011561bbd556c89b469f62fed950e3e750d2a" translate="yes" xml:space="preserve">
          <source>Ill-formed expression used in the function type</source>
          <target state="translated">在函数类型中使用了形式错误的表达式。</target>
        </trans-unit>
        <trans-unit id="e769494ea641bd01735c8978b12dae80bc631fc2" translate="yes" xml:space="preserve">
          <source>Illegal byte sequence</source>
          <target state="translated">不合法的字节序列</target>
        </trans-unit>
        <trans-unit id="d87c7055340deb568caf4674b187c44939256ef2" translate="yes" xml:space="preserve">
          <source>Illustrates the difference in the matching algorithm between ECMAScript and POSIX regular expressions.</source>
          <target state="translated">说明ECMAScript和POSIX正则表达式在匹配算法上的区别。</target>
        </trans-unit>
        <trans-unit id="13da76356b1fa19b7292603df60cd8183deacc7b" translate="yes" xml:space="preserve">
          <source>Imbues &lt;code&gt;u&lt;/code&gt; with the locale &lt;code&gt;loc&lt;/code&gt;</source>
          <target state="translated">灌输 &lt;code&gt;u&lt;/code&gt; 与区域 &lt;code&gt;loc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="1bec87acbedb55cac0fd8887b67c78afe18b54a1" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior control</source>
          <target state="translated">实施定义的行为控制</target>
        </trans-unit>
        <trans-unit id="dd1e3f977c02056ea472998c02c487e2316720f9" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior is controlled by &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="translated">实现定义的行为由 &lt;code&gt;#pragma&lt;/code&gt; 指令控制。</target>
        </trans-unit>
        <trans-unit id="baec7f3938747fde7fd91e8cd29d528dd3ee3a7c" translate="yes" xml:space="preserve">
          <source>Implementation defined class type. The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="translated">实现定义的类类型。名称 &lt;code&gt;proxy&lt;/code&gt; 仅用于说明。</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">实施说明</target>
        </trans-unit>
        <trans-unit id="ac4df666d0cf4b162038d0ca49842cbe67665bba" translate="yes" xml:space="preserve">
          <source>Implementation properties</source>
          <target state="translated">执行属性</target>
        </trans-unit>
        <trans-unit id="618e4b612934a7109a06661620d8dd64653307f6" translate="yes" xml:space="preserve">
          <source>Implementation test to check if setbuf() is supported on a dynamic strstream (output obtained with Sun Studio).</source>
          <target state="translated">实现测试检查是否支持动态strstream的setbuf()(用Sun Studio获得的输出)。</target>
        </trans-unit>
        <trans-unit id="4ba79c92bcb0daad8f101d0490ccc2e884002f26" translate="yes" xml:space="preserve">
          <source>Implementation-defined meaning, but POSIX XSI specifies that when set on a directory, only file owners may delete files even if the directory is writeable to others (used with &lt;code&gt;/tmp&lt;/code&gt;)</source>
          <target state="translated">实现定义的含义，但是POSIX XSI指定在目录上设置时，即使目录是可写给其他人的，也只有文件所有者可以删除文件（与 &lt;code&gt;/tmp&lt;/code&gt; 一起使用）</target>
        </trans-unit>
        <trans-unit id="c4dfef564acdd2d91911e7e70e08d38d4e85e505" translate="yes" xml:space="preserve">
          <source>Implementation-defined native handle object.</source>
          <target state="translated">实现定义的本地手柄对象。</target>
        </trans-unit>
        <trans-unit id="5df371b6c82001fdb73bd4a012e00b058a54aeba" translate="yes" xml:space="preserve">
          <source>Implementation-defined pathname format, auto-detected where possible</source>
          <target state="translated">实施定义的路径名格式,可能时自动检测。</target>
        </trans-unit>
        <trans-unit id="667c8eda998c1c080db13b731500db6f8a8c9f3c" translate="yes" xml:space="preserve">
          <source>Implementation-defined value. If &lt;code&gt;command&lt;/code&gt; is a null pointer, returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">实现定义的值。如果 &lt;code&gt;command&lt;/code&gt; 是空指针，则仅当命令处理器存在时才返回非零值。</target>
        </trans-unit>
        <trans-unit id="2b90c22fbd261737448cc728280b9e1a0b2564f9" translate="yes" xml:space="preserve">
          <source>Implementation-defined.</source>
          <target state="translated">Implementation-defined.</target>
        </trans-unit>
        <trans-unit id="fc59b9097e566566bcbc34003e0d601ccd5cbd0c" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to avoid dynamic allocations for small objects, but such an optimization may only be applied to types for which &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_nothrow_move_constructible&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">鼓励实现避免对小对象进行动态分配，但是这种优化只能应用于 &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_nothrow_move_constructible&lt;/a&gt;&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 的类型。</target>
        </trans-unit>
        <trans-unit id="3d4e582a58851ee6c4bb6dc2e172c7707251917f" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to declare the placeholders as if by &lt;code&gt;inline constexpr /*unspecified*/ _1;&lt;/code&gt;, although declaring them by &lt;code&gt;extern /*unspecified*/ _1;&lt;/code&gt; is still allowed by the standard.</source>
          <target state="translated">鼓励实现将占位符声明为 &lt;code&gt;inline constexpr /*unspecified*/ _1;&lt;/code&gt; ，尽管通过 &lt;code&gt;extern /*unspecified*/ _1;&lt;/code&gt; 声明了它们；仍被标准允许。</target>
        </trans-unit>
        <trans-unit id="fc2283d4e61c94c8b4cf57a3cc3008b1c58fed08" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to not consider &lt;code&gt;p&lt;/code&gt; not existing to be an error.</source>
          <target state="translated">鼓励实现不要将 &lt;code&gt;p&lt;/code&gt; 不存在视为错误。</target>
        </trans-unit>
        <trans-unit id="4cdbff21c557331fbffdc58f3ae0f283ef89f728" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to not provide any programmatic way to query, set, or modify the build level or to set or modify the violation handler.</source>
          <target state="translated">鼓励实现者不提供任何程序化的方式来查询、设置或修改构建级别,或设置或修改违规处理程序。</target>
        </trans-unit>
        <trans-unit id="0fc00335f1f76568cf7bc5d27173b1a48e4839fb" translate="yes" xml:space="preserve">
          <source>Implementations are not permitted to declare library functions as &lt;code&gt;constexpr&lt;/code&gt; unless the standard says the function is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">实现不允许以申报库函数 &lt;code&gt;constexpr&lt;/code&gt; 除非标准说的功能 &lt;code&gt;constexpr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cac6f663736c0881de57437359b44434cf63f3b6" translate="yes" xml:space="preserve">
          <source>Implementations may provide specializations of &lt;code&gt;std::numeric_limits&lt;/code&gt; for implementation-specific types: e.g. GCC provides &lt;code&gt;std::numeric_limits&amp;lt;__int128&amp;gt;&lt;/code&gt;. Non-standard libraries may &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;add specializations&lt;/a&gt; for library-provided types, e.g. &lt;a href=&quot;http://openexr.com/&quot;&gt;OpenEXR&lt;/a&gt; provides &lt;code&gt;std::numeric_limits&amp;lt;half&amp;gt;&lt;/code&gt; for a 16-bit floating-point type.</source>
          <target state="translated">实施方式可以提供的特化 &lt;code&gt;std::numeric_limits&lt;/code&gt; 为实现特定的类型：例如GCC提供 &lt;code&gt;std::numeric_limits&amp;lt;__int128&amp;gt;&lt;/code&gt; 。非标准库可能会&lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;增加&lt;/a&gt;库提供的类型的专业化，例如&lt;a href=&quot;http://openexr.com/&quot;&gt;OpenEXR&lt;/a&gt;为16位浮点类型提供 &lt;code&gt;std::numeric_limits&amp;lt;half&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e11e78a73a7bdbeba97a62a3332a0fcaea58d4d7" translate="yes" xml:space="preserve">
          <source>Implementations that do not support C++17, but support &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;ISO 29124:2010&lt;/a&gt;, provide this function if &lt;code&gt;__STDCPP_MATH_SPEC_FUNCS__&lt;/code&gt; is defined by the implementation to a value at least 201003L and if the user defines &lt;code&gt;__STDCPP_WANT_MATH_SPEC_FUNCS__&lt;/code&gt; before including any standard library headers.</source>
          <target state="translated">如果实现将 &lt;code&gt;__STDCPP_MATH_SPEC_FUNCS__&lt;/code&gt; 定义为至少201003L的值，并且用户在包含任何标准库头之前定义了 &lt;code&gt;__STDCPP_WANT_MATH_SPEC_FUNCS__&lt;/code&gt; ，则不支持C ++ 17但支持&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;ISO 29124：2010&lt;/a&gt;的实现将提供此功能。</target>
        </trans-unit>
        <trans-unit id="70e8f87cf29af9772a694ae2cede769b63d6dda0" translate="yes" xml:space="preserve">
          <source>Implementations that do not support ISO 29124:2010 but support TR 19768:2007 (TR1), provide this function in the header &lt;code&gt;tr1/cmath&lt;/code&gt; and namespace &lt;code&gt;std::tr1&lt;/code&gt;.</source>
          <target state="translated">不支持ISO 29124：2010但支持TR 19768：2007（TR1）的实现在标头 &lt;code&gt;tr1/cmath&lt;/code&gt; 和名称空间 &lt;code&gt;std::tr1&lt;/code&gt; 提供此功能。</target>
        </trans-unit>
        <trans-unit id="773665687bef6caf01efcdb3d35a7cb85d3b76c9" translate="yes" xml:space="preserve">
          <source>Implementations usually guarantee precision of less than 1 ulp (units in the last place): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;, &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt;, &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;.</source>
          <target state="translated">实现通常保证精度小于1 ulp（最后一个单位）：&lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;，&lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt;，&lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6a1e74b0c42f643746739d370decb51f6b1090af" translate="yes" xml:space="preserve">
          <source>Implementations usually guarantee precision of less than 1 ulp (units in the last place): &lt;a href=&quot;https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;, &lt;a href=&quot;https://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt;, &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1270f12ce6696248d9babe2729d237c7e58364" translate="yes" xml:space="preserve">
          <source>Implements the analogs of the unary arithmetic operators for complex numbers.</source>
          <target state="translated">实现复数的单数算术运算符的类比。</target>
        </trans-unit>
        <trans-unit id="ecc1f13a5483ad5061a47e46d970f730cb42f7e5" translate="yes" xml:space="preserve">
          <source>Implements the binary operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.</source>
          <target state="translated">实现复数算术和复数/标量混合算术的二进制运算。标量参数被视为复数,实数部分等于参数,虚数部分设为零。</target>
        </trans-unit>
        <trans-unit id="c4afda3b855163af9d0d3b6360d184e0bdc5cd94" translate="yes" xml:space="preserve">
          <source>Implements the compound assignment operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.</source>
          <target state="translated">为复数算术和复数/标量混合算术实现复数赋值运算符。标量参数作为复数处理,实数部分等于参数,虚数部分设为零。</target>
        </trans-unit>
        <trans-unit id="7b890ec344a13c8ecc3220d297694526da2518e7" translate="yes" xml:space="preserve">
          <source>Implements unary plus and unary minus for the durations.</source>
          <target state="translated">实现单利加和单利减的持续时间。</target>
        </trans-unit>
        <trans-unit id="978783100f08201e0e5529544f86d4a285682f97" translate="yes" xml:space="preserve">
          <source>Implicit conversion sequence consists of the following, in this order:</source>
          <target state="translated">隐式转换序列按以下顺序组成:</target>
        </trans-unit>
        <trans-unit id="1429b69e907debf636007c5f2b2aa8f332893f57" translate="yes" xml:space="preserve">
          <source>Implicit conversion sequence in list-initialization</source>
          <target state="translated">列表初始化中的隐式转换序列。</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">隐性转换</target>
        </trans-unit>
        <trans-unit id="46354cbf9b435d43405dcf0d28126a074735a10d" translate="yes" xml:space="preserve">
          <source>Implicit conversions are performed whenever an expression of some type &lt;code&gt;T1&lt;/code&gt; is used in context that does not accept that type, but accepts some other type &lt;code&gt;T2&lt;/code&gt;; in particular:</source>
          <target state="translated">每当在上下文中使用某种 &lt;code&gt;T1&lt;/code&gt; 类型的表达式但不接受该类型但接受某种其他 &lt;code&gt;T2&lt;/code&gt; 类型的表达式时，都会执行隐式转换。特别是：</target>
        </trans-unit>
        <trans-unit id="c7e1233543f67ff6021074ff2ae9773f138a2071" translate="yes" xml:space="preserve">
          <source>Implicit conversions between two durations normally depends on the tick period of the durations. However, implicit conversions can happen regardless of tick period if &lt;code&gt;std::chrono::treat_as_floating_point&amp;lt;Rep&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">两个持续时间之间的隐式转换通常取决于持续时间的滴答周期。但是，如果 &lt;code&gt;std::chrono::treat_as_floating_point&amp;lt;Rep&amp;gt;::value == true&lt;/code&gt; 则不管滴答周期如何，都可能发生隐式转换。</target>
        </trans-unit>
        <trans-unit id="cff2a76253e4ae1d3384d748888091cc614f0787" translate="yes" xml:space="preserve">
          <source>Implicit expression variations</source>
          <target state="translated">隐性表达变化</target>
        </trans-unit>
        <trans-unit id="6deeab06530145f211662ed2cb9cf74741af72c3" translate="yes" xml:space="preserve">
          <source>Implicit instantiation</source>
          <target state="translated">隐式实例</target>
        </trans-unit>
        <trans-unit id="46c4cf71d06da185f299f0f266b516eb714362c2" translate="yes" xml:space="preserve">
          <source>Implicitly declared copy assignment operator</source>
          <target state="translated">隐式声明的复制分配操作符</target>
        </trans-unit>
        <trans-unit id="f3b3376d1419db08d028d5d3e6c6df0f0035aa37" translate="yes" xml:space="preserve">
          <source>Implicitly declared destructor</source>
          <target state="translated">隐式声明的析构器</target>
        </trans-unit>
        <trans-unit id="0562f19403fee4205b21d8bb018af2a9b080047c" translate="yes" xml:space="preserve">
          <source>Implicitly-declared and user-defined non-explicit &lt;a href=&quot;copy_constructor&quot;&gt;copy constructors&lt;/a&gt; and &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt; are converting constructors.</source>
          <target state="translated">隐式声明和用户定义的非显式&lt;a href=&quot;copy_constructor&quot;&gt;副本构造函数&lt;/a&gt;和&lt;a href=&quot;move_constructor&quot;&gt;move构造函数&lt;/a&gt;正在转换构造函数。</target>
        </trans-unit>
        <trans-unit id="29a6f3e1205f66c508c2094943ddce2c63b0df90" translate="yes" xml:space="preserve">
          <source>Implicitly-declared copy assignment operator</source>
          <target state="translated">隐式声明的复制赋值操作符。</target>
        </trans-unit>
        <trans-unit id="a6d4013875adefe27157f85be3bba73a81597a9f" translate="yes" xml:space="preserve">
          <source>Implicitly-declared copy constructor</source>
          <target state="translated">隐式声明的复制构造函数。</target>
        </trans-unit>
        <trans-unit id="88095a2668d811c3785a1fa8299728b3a2949e56" translate="yes" xml:space="preserve">
          <source>Implicitly-declared default constructor</source>
          <target state="translated">隐式声明的默认构造函数。</target>
        </trans-unit>
        <trans-unit id="58d35239637c6ad0d309cc3ac73e345488ae6f80" translate="yes" xml:space="preserve">
          <source>Implicitly-declared destructor</source>
          <target state="translated">隐式声明的析构器</target>
        </trans-unit>
        <trans-unit id="a122664f9fa35a0ead17f50a517e4e30c5f78e62" translate="yes" xml:space="preserve">
          <source>Implicitly-declared move assignment operator</source>
          <target state="translated">隐式声明的移动分配操作符。</target>
        </trans-unit>
        <trans-unit id="2c98bb0a4aaf09d346ed78f5a0b9b9a10f6c45be" translate="yes" xml:space="preserve">
          <source>Implicitly-declared move constructor</source>
          <target state="translated">隐式声明的移动构造函数。</target>
        </trans-unit>
        <trans-unit id="2deeed834989276fef215f6f2897d39d3740f2f0" translate="yes" xml:space="preserve">
          <source>Implicitly-defined copy assignment operator</source>
          <target state="translated">隐式定义的复制分配操作符</target>
        </trans-unit>
        <trans-unit id="d011d88c050a6f60568345047d29ebc388337773" translate="yes" xml:space="preserve">
          <source>Implicitly-defined copy constructor</source>
          <target state="translated">隐式定义的复制构造函数</target>
        </trans-unit>
        <trans-unit id="fa97e996fd2560cf2c05804b139c35767f0e76e5" translate="yes" xml:space="preserve">
          <source>Implicitly-defined default constructor</source>
          <target state="translated">隐式定义的默认构造函数</target>
        </trans-unit>
        <trans-unit id="061bd07a1bb1a33b801c708770977b87d559dec3" translate="yes" xml:space="preserve">
          <source>Implicitly-defined destructor</source>
          <target state="translated">隐式定义的析构器</target>
        </trans-unit>
        <trans-unit id="2904db3125ebf0c63383992eb2b2968ba47ba5e2" translate="yes" xml:space="preserve">
          <source>Implicitly-defined member functions</source>
          <target state="translated">隐式定义的成员函数</target>
        </trans-unit>
        <trans-unit id="e45913a1e2322cc7a36b3505067db026e25257da" translate="yes" xml:space="preserve">
          <source>Implicitly-defined move assignment operator</source>
          <target state="translated">隐式定义的移动分配运算符</target>
        </trans-unit>
        <trans-unit id="4ebcbcc97e562ec198f2e53e43d491b81d9344ee" translate="yes" xml:space="preserve">
          <source>Implicitly-defined move constructor</source>
          <target state="translated">隐式定义的移动构造函数</target>
        </trans-unit>
        <trans-unit id="2f48272a7bcd8ca888d2cfc92fd1bc8b4d291257" translate="yes" xml:space="preserve">
          <source>Implicitly-generated deduction guides</source>
          <target state="translated">隐性产生的扣款指南</target>
        </trans-unit>
        <trans-unit id="27328a2eb2f15815a68b1653d19575045b8cf992" translate="yes" xml:space="preserve">
          <source>In 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647.</source>
          <target state="translated">在2的补码系统中,最负值的绝对值超出了范围,例如对于32位的2的补码类型int,INT_MIN是-2147483648,但将结果2147483648大于INT_MAX,即2147483647。</target>
        </trans-unit>
        <trans-unit id="b5fd98f8c63f3d298c51c647d77132a000415d4f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;, when a namespace is added to the set of associated namespaces, its inline namespaces are added as well, and if an inline namespace is added to the list of associated namespaces, its enclosing namespace is added as well.</source>
          <target state="translated">在&lt;a href=&quot;adl&quot;&gt;依赖&lt;/a&gt;于参数的查找中，当将名称空间添加到关联的名称空间集合中时，还会添加其内联名称空间，并且如果将内联名称空间添加到关联名称空间列表中，则还将添加其封闭名称空间。</target>
        </trans-unit>
        <trans-unit id="9fd1e0ac5e63fbea64f332e88d4780d848f55564" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; and &lt;a href=&quot;constant_initialization&quot;&gt;constant initialization&lt;/a&gt;, return value optimization (RVO) is guaranteed, however, named return value optimization (NRVO) is forbidden (note: this is specified by post-C++14 defect report CWG 2022 and reversed by defect report CWG 2278):</source>
          <target state="translated">在&lt;a href=&quot;constant_expression&quot;&gt;常量表达式&lt;/a&gt;和&lt;a href=&quot;constant_initialization&quot;&gt;常量初始化中&lt;/a&gt;，可以保证返回值优化（RVO），但是，禁止命名返回值优化（NRVO）（请注意：这由C ++ 14后的缺陷报告CWG 2022指定，而由缺陷报告CWG撤消） 2278）：</target>
        </trans-unit>
        <trans-unit id="4438658486a8aa1c2ccb17440e6244e19bb12c43" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;coroutines&quot;&gt;coroutines&lt;/a&gt;, copy/move of the parameter into coroutine state may be elided where this does not change the behavior of the program other than by omitting the calls to the parameter's constructor and destructor. This can take place if the parameter is never referenced after a suspension point or when the entire coroutine state was never heap-allocated in the first place.</source>
          <target state="translated">在&lt;a href=&quot;coroutines&quot;&gt;协程中&lt;/a&gt;，除非省略对参数的构造函数和析构函数的调用，否则不会将参数复制/移动到协程状态，这不会改变程序的行为。如果在挂起点之后从未引用过该参数，或者当整个协程状态从未被堆分配时，就可能发生这种情况。</target>
        </trans-unit>
        <trans-unit id="752b262a5dc8786ae6cab7940e196fea49ff6ccb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;fold&quot;&gt;fold-expressions&lt;/a&gt;, the pattern is the entire subexpression that does not contain an unexpanded parameter pack.</source>
          <target state="translated">在&lt;a href=&quot;fold&quot;&gt;fold-expressions中&lt;/a&gt;，模式是不包含未扩展参数包的整个子表达式。</target>
        </trans-unit>
        <trans-unit id="2242cd439921fc4c92bc135cffe3759d57213422" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;, the argument is a braced-init-list, which isn't an expression, so the implicit conversion sequence into the parameter type for the purpose of overload resolution is decided by the following special rules:</source>
          <target state="translated">在&lt;a href=&quot;list_initialization&quot;&gt;列表初始化中&lt;/a&gt;，该参数是一个括号初始化列表，它不是表达式，因此出于以下目的，为重载解析而隐式转换为参数类型的顺序由以下特殊规则决定：</target>
        </trans-unit>
        <trans-unit id="1cc4dbef738efa286661d780a703351be8b0b7f1" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Best_viable_function&quot;&gt;overload resolution&lt;/a&gt;, partial ordering takes precedence over whether a function template is generated from a guide: if the function template generated from the constructor is more specialized than the one generated from the deduction guide, the one generated from the constructor is chosen. Because the copy deduction candidate is typically more specialized than a wrapping constructor, this rule means that copying is generally preferred over wrapping.</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Best_viable_function&quot;&gt;重载解析中&lt;/a&gt;，部分排序优先于是否从指南生成功能模板：如果从构造函数生成的功能模板比从演绎指南生成的功能模板更专业，则选择从构造函数生成的功能模板。因为减少复制的候选对象通常比包装构造函数更专业，所以此规则意味着复制通常比包装优先。</target>
        </trans-unit>
        <trans-unit id="4809c5e41e7473cccbc72a4bb155bdc02191303e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every combination of types &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, where class type &lt;code&gt;B&lt;/code&gt; is either the same class as &lt;code&gt;D&lt;/code&gt; or an unambiguous and accessible base class of &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;R&lt;/code&gt; is either an object or function type, the following function signature participates in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的操作符重载解析&lt;/a&gt;，对于类型的每个组合 &lt;code&gt;D&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; ，其中类类型 &lt;code&gt;B&lt;/code&gt; 或者是同一类 &lt;code&gt;D&lt;/code&gt; 或一个明确的和可访问的基类的 &lt;code&gt;D&lt;/code&gt; ，和 &lt;code&gt;R&lt;/code&gt; 或者是一个对象或功能类型，以下函数签名参与了重载解析：</target>
        </trans-unit>
        <trans-unit id="624c4590775fbf40a4b7d04856d19fc9508c5fa6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every object type &lt;code&gt;T&lt;/code&gt; (possibly cv-qualified), the following function signature participates in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于每个对象类型 &lt;code&gt;T&lt;/code&gt; （可能是cv限定），以下函数签名参与重载解析：</target>
        </trans-unit>
        <trans-unit id="307ea5bb116870783914632b4b12d175efc040fc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every optionally volatile-qualified arithmetic type &lt;code&gt;A&lt;/code&gt; other than &lt;code&gt;bool&lt;/code&gt;, and for every optionally volatile-qualified pointer &lt;code&gt;P&lt;/code&gt; to optionally cv-qualified object type, the following function signatures participate in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的操作符重载解析&lt;/a&gt;，对于每一个任选volatile限定算术型 &lt;code&gt;A&lt;/code&gt; 比其他 &lt;code&gt;bool&lt;/code&gt; ，并为每任选volatile限定指针 &lt;code&gt;P&lt;/code&gt; 到任选CV-合格对象类型，下面的函数签名参与重载分辨率：</target>
        </trans-unit>
        <trans-unit id="5990cf25ac820a864a2b308a05c41a666871b396" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair A1 and A2, where A1 is an arithmetic type (optionally volatile-qualified) and A2 is a promoted arithmetic type, the following function signatures participate in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于每对A1和A2，其中A1是算术类型（可选为volatile限定），而A2是提升的算术类型，以下函数签名参与重载解析：</target>
        </trans-unit>
        <trans-unit id="8d3869a5bce1a140062b4b7e7874a7e2f0b63bc7" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; and for every object type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于每对提升的算术类型 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt; 对以及对于每个对象类型 &lt;code&gt;T&lt;/code&gt; ，以下函数签名均参与重载解析：</target>
        </trans-unit>
        <trans-unit id="b24752ca21e578d5ccc2e9cc894a56665fc96230" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, including enumeration types, the following function signatures participate in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于每对提升的算术类型 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt; （包括枚举类型），以下函数签名均参与重载解析：</target>
        </trans-unit>
        <trans-unit id="fd26ab1ed7c9b56dae3b9425960ee35cb9730a3f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;LA&lt;/code&gt; and &lt;code&gt;RA&lt;/code&gt; and for every pair of promoted integral types &lt;code&gt;LI&lt;/code&gt; and &lt;code&gt;RI&lt;/code&gt; the following function signatures participate in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于每对提升的算术类型 &lt;code&gt;LA&lt;/code&gt; 和 &lt;code&gt;RA&lt;/code&gt; 以及每对提升的整数类型 &lt;code&gt;LI&lt;/code&gt; 和 &lt;code&gt;RI&lt;/code&gt; ，以下函数签名都将参与重载解析：</target>
        </trans-unit>
        <trans-unit id="f476dbd74c2f442c1c2e2829bce88b4a88341d7d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted integral types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; the following function signatures participate in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于每对提升的整数类型 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt; ，以下函数签名都将参与重载解析：</target>
        </trans-unit>
        <trans-unit id="eb835b282c835e4cba40899b90f1b4b1b4026a72" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted integral types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于每对提升的整数类型 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt; ，以下函数签名均参与重载解析：</target>
        </trans-unit>
        <trans-unit id="c4a93fe8e1bc45c860bc0b892d8c877cf026beb8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every promoted arithmetic type &lt;code&gt;A&lt;/code&gt; and for every type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于每个提升的算术类型 &lt;code&gt;A&lt;/code&gt; 和每个类型 &lt;code&gt;T&lt;/code&gt; ，以下函数签名均参与重载解析：</target>
        </trans-unit>
        <trans-unit id="fb2d8e1a38d1a77a396a0e77f09d5580ac4be3ba" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every type &lt;code&gt;T&lt;/code&gt; that is either object type (possibly cv-qualified) or function type (not const- or ref-qualified), the following function signature participates in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于对象类型（可能是cv限定）或函数类型（非const-或ref限定）的每个类型 &lt;code&gt;T&lt;/code&gt; ，以下函数签名参与重载解析：</target>
        </trans-unit>
        <trans-unit id="401b7699fa1e8e938b279018437f1606b4040a67" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于每种类型 &lt;code&gt;T&lt;/code&gt; ，以下函数签名均参与重载解析：</target>
        </trans-unit>
        <trans-unit id="0c2aad84e7da44f63319332803f4b852d30346b4" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for pointer or enumeration type &lt;code&gt;T&lt;/code&gt;, the following function signature participates in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，对于指针或枚举类型 &lt;code&gt;T&lt;/code&gt; ，以下函数签名参与重载解析：</target>
        </trans-unit>
        <trans-unit id="5cea19a589fd752a8bdd766f6cd3803387a4d265" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, the following built-in function signatures participate in overload resolution:</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，以下内置函数签名参与了重载解析：</target>
        </trans-unit>
        <trans-unit id="ee813279dc64b0e3db6b8e7e767214afb0a3c85c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, this operator does not introduce any additional function signatures: built-in address-of operator does not apply if there exists an overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt; that is a &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;viable function&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;针对用户定义的运算符的重载解析中&lt;/a&gt;，该运算符不引入任何其他功能签名：如果存在一个&lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;可行&lt;/a&gt;的重载 &lt;code&gt;operator&amp;amp;&lt;/code&gt; ，则内置地址运算符不适用。</target>
        </trans-unit>
        <trans-unit id="dd138803f2292cc51a5e2969a85f684f859f9f88" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;, ellipsis may appear in the list of declarators, this is useful when deriving from a parameter pack:</source>
          <target state="translated">在&lt;a href=&quot;using_declaration&quot;&gt;使用声明时&lt;/a&gt;，省略号可能出现在声明符列表中，这在从参数包派生时非常有用：</target>
        </trans-unit>
        <trans-unit id="c58f1f0803bbe584686a6a997ca2d9633a806b36" translate="yes" xml:space="preserve">
          <source>In C prior to C99 (but not in C++), unsuffixed decimal values that do not fit in &lt;code&gt;long int&lt;/code&gt; are allowed to have the type &lt;code&gt;unsigned long int&lt;/code&gt;.</source>
          <target state="translated">在C99之前的C中（但在C ++中不是），不允许将不带后缀的十进制值放入 &lt;code&gt;long int&lt;/code&gt; 中，其类型为 &lt;code&gt;unsigned long int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11a679b4f1f70ac38a1af627d070d394e3b260d2" translate="yes" xml:space="preserve">
          <source>In C++, unlike C, variables cannot be declared &lt;code&gt;register&lt;/code&gt;.</source>
          <target state="translated">在C ++中，与C不同，不能将变量声明为 &lt;code&gt;register&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9036e8af52064611d82c261ee7c4ae9a4cdd7015" translate="yes" xml:space="preserve">
          <source>In C++11 and C++14 it is valid to construct a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">在C ++ 11和C ++ 14中，从 &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; &amp;lt;T []&amp;gt;构造 &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 是有效的：</target>
        </trans-unit>
        <trans-unit id="d7851c45dc812ab508d940b1e3b960f585dcd4c8" translate="yes" xml:space="preserve">
          <source>In C++11, &lt;code&gt;broken_promise&lt;/code&gt; was specified to equal zero despite &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; using zero to mean &quot;no error&quot;. This was fixed in C++14.</source>
          <target state="translated">在C ++ 11中，尽管 &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; 使用零表示&amp;ldquo;无错误&amp;rdquo; ，但 &lt;code&gt;broken_promise&lt;/code&gt; 被指定为等于零。这在C ++ 14中已修复。</target>
        </trans-unit>
        <trans-unit id="c2a0733225045f42e4ffac4f7cced1fd8bd01edc" translate="yes" xml:space="preserve">
          <source>In C++11, expressions that:</source>
          <target state="translated">在C++11中,表达式,。</target>
        </trans-unit>
        <trans-unit id="8a471ce8454b0c44c542d11c1ba3841025440979" translate="yes" xml:space="preserve">
          <source>In C++11, these constants were specified with redundant keyword &lt;code&gt;static&lt;/code&gt;, which was removed by C++14 via &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053&quot;&gt;LWG issue 2053&lt;/a&gt;.</source>
          <target state="translated">在C ++ 11中，这些常量由冗余关键字 &lt;code&gt;static&lt;/code&gt; 指定，C ++ 14通过&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053&quot;&gt;LWG issue 2053&lt;/a&gt;将其删除。</target>
        </trans-unit>
        <trans-unit id="984160a3e04fdf728c84931473e5065db87d2de8" translate="yes" xml:space="preserve">
          <source>In C++17, &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt; was made mandatory in some situations, and that required separation of prvalue expressions from the temporary objects initialized by them, resulting in the system we have today. Note that, in contrast with the C++11 scheme, prvalues are no longer moved from.</source>
          <target state="translated">在C ++ 17中，在某些情况下必须强制执行&lt;a href=&quot;copy_elision&quot;&gt;复制省略&lt;/a&gt;，这要求将prvalue表达式与它们所初始化的临时对象分开，从而形成了当今的系统。请注意，与C ++ 11方案相比，不再将prvalue移出。</target>
        </trans-unit>
        <trans-unit id="4f1bbad23b5985f92e8fd5da90bac9e6e27f0dfa" translate="yes" xml:space="preserve">
          <source>In C++98 prior to C++03 (which introduced value initialization), the expression &lt;code&gt;new T()&lt;/code&gt; was classified as default initialization and specified zero-initialization.</source>
          <target state="translated">在C ++ 03之前的C ++ 98（引入了值初始化）中，表达式 &lt;code&gt;new T()&lt;/code&gt; 被分类为默认初始化和指定的零初始化。</target>
        </trans-unit>
        <trans-unit id="9476240519883d62813958bad1862fa3943959d8" translate="yes" xml:space="preserve">
          <source>In C++98/C++03, if an error occurs, &lt;code&gt;v&lt;/code&gt; is left unchanged. In C++11, it is set to a value as described above.</source>
          <target state="translated">在C ++ 98 / C ++ 03中，如果发生错误，则 &lt;code&gt;v&lt;/code&gt; 保持不变。在C ++ 11中，如上所述将其设置为一个值。</target>
        </trans-unit>
        <trans-unit id="5a00b4bd83d09e5862a084a0513a75ec121bbf2e" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;putc()&lt;/code&gt; may be implemented as a macro, which is disallowed in C++. Therefore calls to &lt;code&gt;std::fputc()&lt;/code&gt; and &lt;code&gt;std::putc()&lt;/code&gt; always have the same effect.</source>
          <target state="translated">在C中， &lt;code&gt;putc()&lt;/code&gt; 可以实现为宏，而在C ++中是不允许的。因此，对 &lt;code&gt;std::fputc()&lt;/code&gt; 和 &lt;code&gt;std::putc()&lt;/code&gt; 调用始终具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="cf9734438af23c6dfb132972af4a721d26ce5a2e" translate="yes" xml:space="preserve">
          <source>In C, character array of size one less than the size of the string literal may be initialized from a string literal; the resulting array is not null-terminated. This is not allowed in C++.</source>
          <target state="translated">在C语言中,大小小于字符串文字大小的字符数组可以从一个字符串文字初始化;所产生的数组不以空结束。这在C++中是不允许的。</target>
        </trans-unit>
        <trans-unit id="38e0a2f5a0dd182661a588f644d0e761c91db444" translate="yes" xml:space="preserve">
          <source>In C, character constants such as &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; have type &lt;code&gt;int&lt;/code&gt;, rather than &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">在C语言中，字符常量（例如 &lt;code&gt;'a'&lt;/code&gt; 或 &lt;code&gt;'\n'&lt;/code&gt; 类型为 &lt;code&gt;int&lt;/code&gt; ，而不是 &lt;code&gt;char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c022ffe44f1e1cb8c1253d8ca27c1f6f5d7901e9" translate="yes" xml:space="preserve">
          <source>In C, inline functions do not have to be declared inline in every translation unit (at most one may be non-inline or extern inline), the function definitions do not have to be identical (but the behavior of the program must not depend on which one is called), and the function-local statics are distinct between different definitions of the same function.</source>
          <target state="translated">在C语言中,内联函数不必在每个翻译单元中都声明为内联函数(最多可以是非内联函数或外联函数),函数定义不必完全相同(但程序的行为必须不取决于调用哪一个),同一函数的不同定义之间的函数局部静态是不同的。</target>
        </trans-unit>
        <trans-unit id="c2835e1b41b93ce6d5849cf55c8cf7a0e81c4f48" translate="yes" xml:space="preserve">
          <source>In C, string literals are of type &lt;code&gt;char[]&lt;/code&gt;, and can be assigned directly to a (non-const) &lt;code&gt;char*&lt;/code&gt;. C++03 allowed it as well (but deprecated it, as literals are &lt;code&gt;const&lt;/code&gt; in C++). C++11 no longer allows such assignments without a cast.</source>
          <target state="translated">在C中，字符串文字的类型为 &lt;code&gt;char[]&lt;/code&gt; ，可以直接分配给（非const） &lt;code&gt;char*&lt;/code&gt; 。C ++ 03也允许它（但已弃用，因为文字在C ++中是 &lt;code&gt;const&lt;/code&gt; ）。C ++ 11不再允许此类转换而无需强制转换。</target>
        </trans-unit>
        <trans-unit id="2ab9e9edb5ce53cff5c0a794854dbeaa98df7eba" translate="yes" xml:space="preserve">
          <source>In C, the address of a &lt;code&gt;register&lt;/code&gt; variable cannot be taken, but in C++, a variable declared &lt;code&gt;register&lt;/code&gt; is semantically indistinguishable from a variable declared without any storage class specifiers.</source>
          <target state="translated">在C语言中，不能获取 &lt;code&gt;register&lt;/code&gt; 变量的地址，但在C ++语言中，声明为 &lt;code&gt;register&lt;/code&gt; 的变量与没有任何存储类说明符的声明变量在语义上没有区别。</target>
        </trans-unit>
        <trans-unit id="c82c0f1785717e06dc6cfec64c1ec49afdff6848" translate="yes" xml:space="preserve">
          <source>In C, the macro &lt;code&gt;NULL&lt;/code&gt; may have the type &lt;code&gt;void*&lt;/code&gt;, but that is not allowed in C++.</source>
          <target state="translated">在C中，宏 &lt;code&gt;NULL&lt;/code&gt; 的类型可能为 &lt;code&gt;void*&lt;/code&gt; ，但是在C ++中是不允许的。</target>
        </trans-unit>
        <trans-unit id="f0bfb9c61efe498d3321fdcd4f4cc72588b7c2a9" translate="yes" xml:space="preserve">
          <source>In C, the ternary conditional operator has higher precedence than assignment operators. Therefore, the expression &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt;, which is parsed in C++ as &lt;code&gt;e = ((a &amp;lt; d) ? (a++) : (a = d))&lt;/code&gt;, will fail to compile in C due to grammatical or semantic constraints in C. See the corresponding C page for details.</source>
          <target state="translated">在C语言中，三元条件运算符的优先级高于赋值运算符。因此，表达式 &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; ，在C ++中被解析为 &lt;code&gt;e = ((a &amp;lt; d) ? (a++) : (a = d))&lt;/code&gt; ，由于C中的语法或语义约束，将无法在C中编译。请参见C页了解详细信息。</target>
        </trans-unit>
        <trans-unit id="c59c494dc7b28d6f1ae3f3e1fba28d7c33f040e5" translate="yes" xml:space="preserve">
          <source>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="translated">在IS0 8601中,每周从周一开始,每年的第一周必须满足以下要求。</target>
        </trans-unit>
        <trans-unit id="c2409d0ab324438044b126d5eaae356ad25d17dc" translate="yes" xml:space="preserve">
          <source>In ISO 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="translated">在ISO 8601中,周从星期一开始,一年的第一周必须满足以下要求。</target>
        </trans-unit>
        <trans-unit id="3f2df198c19b4d3aee57fa1d2f0a4c70b3d8c1de" translate="yes" xml:space="preserve">
          <source>In a</source>
          <target state="translated">在一个</target>
        </trans-unit>
        <trans-unit id="0c962fc44a425f14d1e80539f2eadaa9d9481b53" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../language/templates&quot;&gt; template declaration&lt;/a&gt;, &lt;code&gt;class&lt;/code&gt; can be used to introduce &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt; type template parameters&lt;/a&gt; and &lt;a href=&quot;../language/template_parameters#Template_template_parameter&quot;&gt; template template parameters&lt;/a&gt;</source>
          <target state="translated">在&lt;a href=&quot;../language/templates&quot;&gt;模板声明中&lt;/a&gt;， &lt;code&gt;class&lt;/code&gt; 可用于引入&lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;类型模板参数&lt;/a&gt;和&lt;a href=&quot;../language/template_parameters#Template_template_parameter&quot;&gt;模板模板参数&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b62c4f9f476c687ff843ca517e75f7940028ba13" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../language/templates&quot;&gt; template declaration&lt;/a&gt;, &lt;code&gt;typename&lt;/code&gt; can be used as an alternative to &lt;a href=&quot;class&quot;&gt; class&lt;/a&gt; to declare &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;type template parameters&lt;/a&gt;and template template parameters(since C++17).</source>
          <target state="translated">在&lt;a href=&quot;../language/templates&quot;&gt;模板声明中&lt;/a&gt;， &lt;code&gt;typename&lt;/code&gt; 可以用作&lt;a href=&quot;class&quot;&gt;类&lt;/a&gt;的替代方法，以声明&lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;类型模板参数&lt;/a&gt;和模板模板参数（自C ++ 17开始）。</target>
        </trans-unit>
        <trans-unit id="6c62102a69b04462fa302dbc2df4626b43048568" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; declaration, it appears either immediately after the capture list, or immediately after the (keyword &lt;code&gt;mutable&lt;/code&gt; (if one is used).</source>
          <target state="translated">在&lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt;声明中，它要么立即出现在捕获列表之后，要么立即出现在（ &lt;code&gt;mutable&lt;/code&gt; 关键字（如果使用了关键字）之后）。</target>
        </trans-unit>
        <trans-unit id="e1d855aa75c086efbd816d762abc1c86bd8016f1" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, when the operand is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the function return type:</source>
          <target state="translated">在&lt;a href=&quot;return&quot;&gt;return语句中&lt;/a&gt;，当操作数是与函数返回类型相同的类类型（忽略&lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;）的&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;时：</target>
        </trans-unit>
        <trans-unit id="177a6daaadac5e744a3c9483ebb25b9c5956b8d4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and which is of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the function return type. This variant of copy elision is known as NRVO, &quot;named return value optimization&quot;.</source>
          <target state="translated">在&lt;a href=&quot;return&quot;&gt;return语句中&lt;/a&gt;，当操作数是具有自动存储持续时间的非易失性对象的名称时，该对象不是函数参数或catch子句参数，并且具有与（&lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;）相同的类类型函数返回类型。复制省略的这种变体称为NRVO，&amp;ldquo;命名为返回值优化&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="fde11b27cc6006e08d96a8f3a53a33443f577fd4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and whose scope does not extend past the innermost try-block (if there is a try-block).</source>
          <target state="translated">在&lt;a href=&quot;throw&quot;&gt;throw-expression中&lt;/a&gt;，当操作数是具有自动存储持续时间的非易失性对象的名称时，它不是函数参数或catch子句参数，并且其作用域不超出最里面的try块（如果有一个尝试块）。</target>
        </trans-unit>
        <trans-unit id="601aeec487cb6099c489a8b16b96b24dfb6cd755" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;try_catch&quot;&gt;catch clause&lt;/a&gt;, when the argument is of the same type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the exception object thrown, the copy of the exception object is omitted and the body of the catch clause accesses the exception object directly, as if caught by reference (there cannot be a move from the exception object because it is always an lvalue). This is disabled if such copy elision would change the observable behavior of the program for any reason other than skipping the copy constructor and the destructor of the catch clause argument (for example, if the catch clause argument is modified, and the exception object is rethrown with &lt;code&gt;throw&lt;/code&gt;).</source>
          <target state="translated">在&lt;a href=&quot;try_catch&quot;&gt;catch子句中&lt;/a&gt;，当参数的类型与抛出的异常对象的类型相同（忽略&lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;）时，将忽略异常对象的副本，并且catch子句的主体直接访问异常对象，就像被catch捕获一样引用（不能从异常对象移动，因为它始终是左值）。如果这样的复制省略会由于除跳过catch子句参数的复制构造函数和析构函数以外的任何原因改变程序的可观察行为，则将禁用此功能（例如，如果catch子句参数已修改，并且异常对象被重新抛出）与 &lt;code&gt;throw&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="556d00127671f5f34cb70b7e4bc4f78905db67ff" translate="yes" xml:space="preserve">
          <source>In a base-specifier of a &lt;a href=&quot;derived_class&quot;&gt;derived class&lt;/a&gt; declaration, define the accessibility of inherited members of the subsequent base class.</source>
          <target state="translated">在&lt;a href=&quot;derived_class&quot;&gt;派生类&lt;/a&gt;声明的基本说明符中，定义后续基类的继承成员的可访问性。</target>
        </trans-unit>
        <trans-unit id="02b565401cf5d5664e816543f1fd59c4e0eec827" translate="yes" xml:space="preserve">
          <source>In a class scope, the name of the current class is treated as if it were a public member name; this is called</source>
          <target state="translated">在类的作用域中,当前类的名称被当作公共成员的名称来处理,这被称为</target>
        </trans-unit>
        <trans-unit id="dd0fdaa3d2c6bc7e7e1f68aa336ca282ee91f5ee" translate="yes" xml:space="preserve">
          <source>In a class template, the injected-class-name can be used either as a template name that refers to the current template, or as a class name that refers to the current instantiation.</source>
          <target state="translated">在类模板中,注入的类名既可以作为指当前模板的模板名,也可以作为指当前实例的类名。</target>
        </trans-unit>
        <trans-unit id="44fa3b441a0dd74cd09577454cd3ff350af83aaa" translate="yes" xml:space="preserve">
          <source>In a comma expression &lt;code&gt;E1, E2&lt;/code&gt;, the expression &lt;code&gt;E1&lt;/code&gt; is evaluated, its result is &lt;a href=&quot;expressions#Discarded-value_expressions&quot;&gt;discarded&lt;/a&gt; (although if it has class type, it won't be destroyed &lt;a href=&quot;lifetime#Temporary_object_lifetime&quot;&gt;until the end of the containing full expression&lt;/a&gt;), and its side effects are completed before evaluation of the expression &lt;code&gt;E2&lt;/code&gt; begins (note that a user-defined &lt;code&gt;operator,&lt;/code&gt; cannot guarantee sequencing)(until C++17).</source>
          <target state="translated">在逗号表达式 &lt;code&gt;E1, E2&lt;/code&gt; ，对表达式 &lt;code&gt;E1&lt;/code&gt; 进行求值，将其结果&lt;a href=&quot;expressions#Discarded-value_expressions&quot;&gt;丢弃&lt;/a&gt;（尽管如果具有类类型，则&lt;a href=&quot;lifetime#Temporary_object_lifetime&quot;&gt;直到包含完整表达式的末尾&lt;/a&gt;才会销毁它），并且其副作用在求值前已完成 &lt;code&gt;E2&lt;/code&gt; 的表达式开始（请注意，用户定义的 &lt;code&gt;operator,&lt;/code&gt; 不能保证排序）（直到C ++ 17）。</target>
        </trans-unit>
        <trans-unit id="6d39978f8296a8c3b0b3811afba0c562703be315" translate="yes" xml:space="preserve">
          <source>In a constexpr if statement, the value of condition must be a &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;contextually converted constant expression of type &lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. If the value is &lt;code&gt;true&lt;/code&gt;, then statement-false is discarded (if present), otherwise, statement-true is discarded.</source>
          <target state="translated">在constexpr if语句中，condition的值必须是&lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;类型为 &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;的上下文转换常量表达式。如果值为 &lt;code&gt;true&lt;/code&gt; ，则丢弃statement-false（如果存在），否则，丢弃statement-true。</target>
        </trans-unit>
        <trans-unit id="ffa4404e890de02936df9088f71b377c51dc866e" translate="yes" xml:space="preserve">
          <source>In a declaration or a definition of a template, including alias template, a name that is not a member of the</source>
          <target state="translated">在模板的声明或定义中,包括别名模板,一个不属于模板的名称。</target>
        </trans-unit>
        <trans-unit id="0d44582f7d0710a8597f720797b494b72912bece" translate="yes" xml:space="preserve">
          <source>In a function declaration, after a parameter with a default argument, all subsequent parameters must.</source>
          <target state="translated">在函数声明中,在一个带有缺省参数的参数之后,所有后续参数都必须。</target>
        </trans-unit>
        <trans-unit id="29bba75b946ab8a0a1465e021f70b5a3cf77b940" translate="yes" xml:space="preserve">
          <source>In a function parameter list, if an ellipsis appears in a parameter declaration (whether it names a function parameter pack (as in, Args&lt;code&gt;...&lt;/code&gt;args) or not) the parameter declaration is the pattern:</source>
          <target state="translated">在函数参数列表中，如果在参数声明中出现省略号（无论是否命名为函数参数包（如Args &lt;code&gt;...&lt;/code&gt; args）），则参数声明为模式：</target>
        </trans-unit>
        <trans-unit id="ff38e5d5bc4cb779e7363c8977789202cfec1e6e" translate="yes" xml:space="preserve">
          <source>In a function returning &lt;code&gt;void&lt;/code&gt;, the return statement with expression can be used, if the expression type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">在返回 &lt;code&gt;void&lt;/code&gt; 的函数中，如果表达式类型为 &lt;code&gt;void&lt;/code&gt; ，则可以使用带有expression的return语句。</target>
        </trans-unit>
        <trans-unit id="e9aa7f5d4e2a651b7a8c4283d212b044b1deb7ca" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;a href=&quot;mutex&quot;&gt;&lt;code&gt;mutex&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;timed_mutex&lt;/code&gt; offers exclusive, non-recursive ownership semantics. In addition, &lt;code&gt;timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">以类似于&lt;a href=&quot;mutex&quot;&gt; &lt;code&gt;mutex&lt;/code&gt; &lt;/a&gt;的方式， &lt;code&gt;timed_mutex&lt;/code&gt; 提供了排他的，非递归的所有权语义。另外， &lt;code&gt;timed_mutex&lt;/code&gt; 提供了尝试通过&lt;a href=&quot;timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until()&lt;/code&gt; &lt;/a&gt;方法超时声明对 &lt;code&gt;timed_mutex&lt;/code&gt; 所有权的功能。</target>
        </trans-unit>
        <trans-unit id="a105c84562cad718ddfbcbaeae2b0d01a57bb6a5" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;a href=&quot;timed_mutex&quot;&gt;&lt;code&gt;timed_mutex&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;shared_timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;shared_timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;shared_timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_shared_for&quot;&gt;&lt;code&gt;try_lock_shared_for()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_shared_until&quot;&gt;&lt;code&gt;try_lock_shared_until()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">以类似于&lt;a href=&quot;timed_mutex&quot;&gt; &lt;code&gt;timed_mutex&lt;/code&gt; &lt;/a&gt;的方式， &lt;code&gt;shared_timed_mutex&lt;/code&gt; 提供了尝试通过&lt;a href=&quot;shared_timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;shared_timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;shared_timed_mutex/try_lock_shared_for&quot;&gt; &lt;code&gt;try_lock_shared_for()&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;shared_timed_mutex/try_lock_shared_until&quot;&gt; &lt;code&gt;try_lock_shared_until()&lt;/code&gt; &lt;/a&gt;方法以超时声明对 &lt;code&gt;shared_timed_mutex&lt;/code&gt; 所有权的能力。</target>
        </trans-unit>
        <trans-unit id="73ef1571fcba32d6299f7cfb10f71f4b33622399" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;code&gt;&lt;a href=&quot;recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; provides exclusive, recursive ownership semantics. In addition, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;recursive_timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;recursive_timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recursive_timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">以类似于 &lt;code&gt;&lt;a href=&quot;recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;recursive_timed_mutex&lt;/code&gt; 提供了排他的，递归的所有权语义。此外， &lt;code&gt;recursive_timed_mutex&lt;/code&gt; 提供了尝试通过&lt;a href=&quot;recursive_timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;recursive_timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until&lt;/code&gt; &lt;/a&gt;方法声明超时的 &lt;code&gt;recursive_timed_mutex&lt;/code&gt; 所有权的功能。</target>
        </trans-unit>
        <trans-unit id="6849ef8c2becfa3fc06c88b17ac43d2f4c411e40" translate="yes" xml:space="preserve">
          <source>In a member function declaration or definition, &lt;code&gt;override&lt;/code&gt; ensures that the function is virtual and is overriding a virtual function from a base class. The program is ill-formed (a compile-time error is generated) if this is not true.</source>
          <target state="translated">在成员函数声明或定义中， &lt;code&gt;override&lt;/code&gt; 可确保函数是虚拟的，并且正在从基类中重写虚拟函数。如果不正确，则程序格式不正确（生成编译时错误）。</target>
        </trans-unit>
        <trans-unit id="e4f5d5b55ed5d6a1476b0d473859397b31a64db5" translate="yes" xml:space="preserve">
          <source>In a member-specification of a &lt;a href=&quot;class&quot;&gt;class/struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, define the accessibility of subsequent members.</source>
          <target state="translated">在&lt;a href=&quot;class&quot;&gt;类/结构&lt;/a&gt;或&lt;a href=&quot;union&quot;&gt;联合&lt;/a&gt;的成员规范中，定义后续成员的可访问性。</target>
        </trans-unit>
        <trans-unit id="94c1a387b407acb6d65fdcd502fe4af3873221a8" translate="yes" xml:space="preserve">
          <source>In a primary class template, the template parameter pack must be the final parameter in the template parameter list. In a function template, the template parameter pack may appear earlier in the list provided that all following parameters can be deduced from the function arguments, or have default arguments:</source>
          <target state="translated">在主类模板中,模板参数包必须是模板参数列表中的最后一个参数。在函数模板中,模板参数包可以出现在列表的前面,前提是所有下面的参数都可以从函数参数中推导出来,或者有默认参数。</target>
        </trans-unit>
        <trans-unit id="1d0f0e8e5fc7ee584cfdd9cc8db60b33727fe5d0" translate="yes" xml:space="preserve">
          <source>In a qualified name &lt;code&gt;C::D&lt;/code&gt;, if.</source>
          <target state="translated">在限定名 &lt;code&gt;C::D&lt;/code&gt; ，如果。</target>
        </trans-unit>
        <trans-unit id="72a217ab1ac4987acb0fd819dc67e7faf17facb8" translate="yes" xml:space="preserve">
          <source>In a return statement or a throw-expression, if the compiler cannot perform copy elision but the conditions for copy elision are met or would be met, except that the source is a function parameter, the compiler will attempt to use the move constructor even if the object is designated by an lvalue; see &lt;a href=&quot;return#Notes&quot;&gt;return statement&lt;/a&gt; for details.</source>
          <target state="translated">在return语句或throw-expression中，如果编译器无法执行复制省略，但满足或将要满足复制删除的条件，但源是函数参数除外，则即使发生以下情况，编译器仍将尝试使用move构造函数：该对象由左值指定；有关详细信息，请参见&lt;a href=&quot;return#Notes&quot;&gt;return语句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb9d44c1145d9374305ce7d0683c7666a1a8faf1" translate="yes" xml:space="preserve">
          <source>In a standard-layout union with an active member of non-union class type &lt;code&gt;T1&lt;/code&gt;, it is permitted to read a non-static data member &lt;code&gt;m&lt;/code&gt; of another union member of non-union class type &lt;code&gt;T2&lt;/code&gt; provided &lt;code&gt;m&lt;/code&gt; is part of the common initial sequence of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; (except that reading a volatile member through non-volatile glvalue is undefined).</source>
          <target state="translated">在具有非工会类类型 &lt;code&gt;T1&lt;/code&gt; 的活动成员的标准版式联合中，如果 &lt;code&gt;m&lt;/code&gt; 是公用初始序列的一部分，则允许读取另一个非工会类类型 &lt;code&gt;T2&lt;/code&gt; 的工会成员的非静态数据成员 &lt;code&gt;m&lt;/code&gt; 。的 &lt;code&gt;T1&lt;/code&gt; 和 &lt;code&gt;T2&lt;/code&gt; （不同之处在于通过读取非易失性glvalue挥发性构件未定义）。</target>
        </trans-unit>
        <trans-unit id="57d94135b1f4411284cd0b70dd280cd47ea7b667" translate="yes" xml:space="preserve">
          <source>In a typical implementation, &lt;code&gt;std::shared_ptr&lt;/code&gt; holds only two pointers:</source>
          <target state="translated">在典型的实现中， &lt;code&gt;std::shared_ptr&lt;/code&gt; 仅包含两个指针：</target>
        </trans-unit>
        <trans-unit id="302df27cb656ad4b16b22d1abb7ca751d6dcd20f" translate="yes" xml:space="preserve">
          <source>In a typical implementation, the only data members of &lt;code&gt;std::ostream_iterator&lt;/code&gt; are a pointer to the associated &lt;code&gt;std::basic_ostream&lt;/code&gt; and a pointer to the first character in the delimiter string.</source>
          <target state="translated">在典型的实现中， &lt;code&gt;std::ostream_iterator&lt;/code&gt; 的唯一数据成员是指向关联的 &lt;code&gt;std::basic_ostream&lt;/code&gt; 的指针和指向定界符字符串中第一个字符的指针。</target>
        </trans-unit>
        <trans-unit id="28d88a36238effdebec563fabaf3d6addb51154c" translate="yes" xml:space="preserve">
          <source>In a typical implementation, the only data members of &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; are a pointer to the associated &lt;code&gt;std::basic_streambuf&lt;/code&gt; and a boolean flag indicating if the the end of file condition has been reached.</source>
          <target state="translated">在典型的实现中， &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; 的唯一数据成员是指向关联的 &lt;code&gt;std::basic_streambuf&lt;/code&gt; 的指针和一个布尔标志，用于指示是否已达到文件结尾条件。</target>
        </trans-unit>
        <trans-unit id="cf627f59eb9ce680a79832f3ab2b75fd54c9e5dc" translate="yes" xml:space="preserve">
          <source>In a valid C++ program, every thread eventually does one of the following:</source>
          <target state="translated">在一个有效的C++程序中,每个线程最终都会做以下事情之一。</target>
        </trans-unit>
        <trans-unit id="5fae65e7ec13a45d7642866607e117019083d5bd" translate="yes" xml:space="preserve">
          <source>In addition to being available via inclusion of the &amp;lt;tuple&amp;gt; header, the templates (3-5) are available when either of the headers &amp;lt;array&amp;gt; or &amp;lt;utility&amp;gt; are included.</source>
          <target state="translated">除了可以通过包含&amp;lt;tuple&amp;gt;头而可用之外，当包含头&amp;lt;array&amp;gt;或&amp;lt;utility&amp;gt;中的任何一个时，模板（3-5）都可用。</target>
        </trans-unit>
        <trans-unit id="15c8d22eeeed9e3926980c7851a1d6015cd58fda" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::begin&lt;/code&gt; and &lt;code&gt;std::cbegin&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">除了包含在 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; 中之外，如果包含以下任何标头，还可以保证 &lt;code&gt;std::begin&lt;/code&gt; 和 &lt;code&gt;std::cbegin&lt;/code&gt; 变得可用： &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; （C ++ 20起）， &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; （C ++ 17起）， &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="338a7c84c19f8a1e820335032a79e38ce0602216" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::data&lt;/code&gt; is guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">除了包含在 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; 中之外，如果包含以下任何标头，还可以保证 &lt;code&gt;std::data&lt;/code&gt; 变得可用： &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; （自C ++ 20起）， &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f8ecedc3305486dab3dbe344b85d3d2b73a9d8eb" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::empty&lt;/code&gt; is guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">除了包含在 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; 中之外，如果包含以下任何标头，还可以保证 &lt;code&gt;std::empty&lt;/code&gt; 变得可用： &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; （自C ++ 20起）， &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9360d86ce66685d75aa6a0b3e3f9a322ab2b75da" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::end&lt;/code&gt; and &lt;code&gt;std::cend&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">除了包含在 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; 中之外，如果包含以下任何标头，还可以保证 &lt;code&gt;std::end&lt;/code&gt; 和 &lt;code&gt;std::cend&lt;/code&gt; 变得可用： &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; （C ++ 20起）， &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; （C ++ 17起）， &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4a73cea37076402c9805971389b5c85fd80eb64" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::rbegin&lt;/code&gt; and &lt;code&gt;std::crbegin&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">除了包含在 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; 中之外，如果包含以下任何标头，还可以保证 &lt;code&gt;std::rbegin&lt;/code&gt; 和 &lt;code&gt;std::crbegin&lt;/code&gt; 可用： &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; （C ++ 20起）， &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; （C ++ 17起）， &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="80150b5d7065d7588ce5758ee13c5f0c81f3d9cb" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::rend&lt;/code&gt; and &lt;code&gt;std::crend&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">除了包含在 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; 中之外，如果包含以下任何标头，还可以保证 &lt;code&gt;std::rend&lt;/code&gt; 和 &lt;code&gt;std::crend&lt;/code&gt; 变得可用： &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; （C ++ 20起）， &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; （C ++ 17起）， &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ece481ac1f67deffb145ed3b4d4e6b31704b49ce" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::size&lt;/code&gt; and &lt;code&gt;std::ssize&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">除了包含在 &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; 中之外，如果包含以下任何标头，还可以保证 &lt;code&gt;std::size&lt;/code&gt; 和 &lt;code&gt;std::ssize&lt;/code&gt; 变得可用： &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; （C ++ 20起）， &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; ， &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a875ba5ef1aeb5e5a529dc3dc7727bb4112f85b1" translate="yes" xml:space="preserve">
          <source>In addition to changing the file position indicator, &lt;code&gt;fseek&lt;/code&gt; undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file status, if applicable.</source>
          <target state="translated">除了更改文件位置指示符之外， &lt;code&gt;fseek&lt;/code&gt; 还撤消 &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; 的影响并清除文件结束状态（如果适用）。</target>
        </trans-unit>
        <trans-unit id="cf1188534c30ece32fd46ec4ab40935b4238d277" translate="yes" xml:space="preserve">
          <source>In addition to keywords, there are</source>
          <target state="translated">除了关键词,还有</target>
        </trans-unit>
        <trans-unit id="271348d0f95843d6de9b4a3bea7c7a4b2fb93975" translate="yes" xml:space="preserve">
          <source>In addition to sophisticated locale-dependent parsers and formatters provided by the &lt;a href=&quot;io&quot;&gt;C++ I/O&lt;/a&gt; library, the &lt;a href=&quot;io/c&quot;&gt;C I/O&lt;/a&gt; library, &lt;a href=&quot;string/basic_string#Numeric_conversions&quot;&gt;C++ string converters&lt;/a&gt;, and &lt;a href=&quot;string/byte#Conversions_to_numeric_formats&quot;&gt;C string converters&lt;/a&gt;, the header &lt;a href=&quot;header/charconv&quot;&gt;&lt;code&gt;&amp;lt;charconv&amp;gt;&lt;/code&gt;&lt;/a&gt; provides light-weight, locale-independent, non-allocating, non-throwing, ASCII-only parsers and formatters for arithmetic types.</source>
          <target state="translated">除了&lt;a href=&quot;io&quot;&gt;C ++ I / O&lt;/a&gt;库，&lt;a href=&quot;io/c&quot;&gt;CI / O&lt;/a&gt;库，&lt;a href=&quot;string/basic_string#Numeric_conversions&quot;&gt;C ++字符串转换器&lt;/a&gt;和&lt;a href=&quot;string/byte#Conversions_to_numeric_formats&quot;&gt;C字符串转换器&lt;/a&gt;提供的复杂的与语言环境相关的解析器和格式化程序外，标头&lt;a href=&quot;header/charconv&quot;&gt; &lt;code&gt;&amp;lt;charconv&amp;gt;&lt;/code&gt; &lt;/a&gt;还提供轻量级的，与语言环境无关的，非为算术类型分配非抛出的纯ASCII解析器和格式化程序。</target>
        </trans-unit>
        <trans-unit id="792f40a7aa00c160ead2eca530fe86663d38f9ab" translate="yes" xml:space="preserve">
          <source>In addition to the above, the composite pointer type between pointer to function and pointer to noexcept function (as long as the function type is the same) is pointer to function.</source>
          <target state="translated">除上述情况外,指向函数的指针和指向noexcept函数的指针之间的复合指针类型(只要函数类型相同)就是指向函数的指针。</target>
        </trans-unit>
        <trans-unit id="ae9ffad79cce78b91bc762e83fe3fface28c2158" translate="yes" xml:space="preserve">
          <source>In addition to the above, the standard library provides specializations for all (scoped and unscoped) enumeration types. These may be (but are not required to be) implemented as &lt;code&gt;std::hash&amp;lt;&lt;a href=&quot;../types/underlying_type&quot;&gt;std::underlying_type&lt;/a&gt;&amp;lt;Enum&amp;gt;::type&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">除上述内容外，标准库还为所有（作用域和非作用域）枚举类型提供了专门化功能。这些可以（但不是必须）实现为 &lt;code&gt;std::hash&amp;lt;&lt;a href=&quot;../types/underlying_type&quot;&gt;std::underlying_type&lt;/a&gt;&amp;lt;Enum&amp;gt;::type&amp;gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0d12b27afe84f919d4cf85c2c720f51dd78c7c47" translate="yes" xml:space="preserve">
          <source>In addition to the engines and distributions described above, the functions and constants from the C random library are also available though not recommended:</source>
          <target state="translated">除了上面介绍的引擎和分布,C随机库中的函数和常量也可以使用,不过不推荐使用。</target>
        </trans-unit>
        <trans-unit id="d7885497c8e90724cd51455d17a67e9d4213e9e7" translate="yes" xml:space="preserve">
          <source>In addition to the use in collation, the implementation-specific format of the transformed string is known to &lt;a href=&quot;../../regex/regex_traits/transform_primary&quot;&gt;std::regex_traits&amp;lt;&amp;gt;::transform_primary&lt;/a&gt;, which is able to extract the equivalence class information.</source>
          <target state="translated">除了在整理中使用外，&lt;a href=&quot;../../regex/regex_traits/transform_primary&quot;&gt;std :: regex_traits &amp;lt;&amp;gt; :: transform_primary&lt;/a&gt;还知道转换后的字符串的实现特定格式，该格式能够提取等效类信息。</target>
        </trans-unit>
        <trans-unit id="a698de81532c150ff1ad39e8d086bac28e3d07da" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;bit_field&quot;&gt;bit field declarations&lt;/a&gt; are allowed.</source>
          <target state="translated">另外，允许&lt;a href=&quot;bit_field&quot;&gt;位字段声明&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4b8e054656c974f48dccf563843687d3cffa39b2" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; can be value-initialized to clear state with the expression &lt;code&gt;&lt;a href=&quot;../atomic_flag_init&quot;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt;. For an atomic_flag with static &lt;a href=&quot;../../language/storage_duration#Storage_duration&quot;&gt;storage duration&lt;/a&gt;, this guarantees &lt;a href=&quot;../../language/initialization#Static_initialization&quot;&gt;static initialization&lt;/a&gt;: the flag can be used in constructors of static objects.</source>
          <target state="translated">另外，可以使用表达式 &lt;code&gt;&lt;a href=&quot;../atomic_flag_init&quot;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt; 来对 &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; 进行值初始化以清除状态。对于具有静态&lt;a href=&quot;../../language/storage_duration#Storage_duration&quot;&gt;存储持续时间&lt;/a&gt;的atomic_flag ，这保证了&lt;a href=&quot;../../language/initialization#Static_initialization&quot;&gt;静态初始化&lt;/a&gt;：该标记可在静态对象的构造函数中使用。</target>
        </trans-unit>
        <trans-unit id="7f193d95fb5f81fb5974342efbdfb55ebd6bb874" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;std::cerr.tie()&lt;/code&gt; returns &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; (same for &lt;code&gt;wcerr&lt;/code&gt; and &lt;code&gt;wcout&lt;/code&gt;), meaning that any output operation on &lt;code&gt;std::cerr&lt;/code&gt; first executes &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; (via &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt;'s constructor) (since C++11).</source>
          <target state="translated">另外， &lt;code&gt;std::cerr.tie()&lt;/code&gt; 返回 &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; （与 &lt;code&gt;wcerr&lt;/code&gt; 和 &lt;code&gt;wcout&lt;/code&gt; 相同），这意味着 &lt;code&gt;std::cerr&lt;/code&gt; 上的任何输出操作都首先执行 &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; （通过 &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; ::: basic_ostream :: sentry的构造函数）（自C ++ 11起）。</target>
        </trans-unit>
        <trans-unit id="fa95bff2b2f1d155be7f57dab28372be4d7eb068" translate="yes" xml:space="preserve">
          <source>In addition, C-style cast notation is allowed to cast from, to, and between pointers to incomplete class type. If both expression and new_type are pointers to incomplete class types, it's unspecified whether static_cast or reinterpret_cast gets selected.</source>
          <target state="translated">此外,C-style cast符号允许从、到、以及在指向不完整类类型的指针之间进行投射。如果表达式和new_type都是指向不完整类类型的指针,那么是选择static_cast还是reinterpret_cast就没有说明了。</target>
        </trans-unit>
        <trans-unit id="ce46012134e55d98fb6c46e02b9a75f51edf17ba" translate="yes" xml:space="preserve">
          <source>In addition, a typical implementation holds a data member of type &lt;code&gt;&lt;a href=&quot;ios_base/openmode&quot;&gt;std::ios_base::openmode&lt;/a&gt;&lt;/code&gt; to indicate the status of the stream (input-only, output-only, input/output, at-end, etc).</source>
          <target state="translated">另外，典型的实现包含类型为 &lt;code&gt;&lt;a href=&quot;ios_base/openmode&quot;&gt;std::ios_base::openmode&lt;/a&gt;&lt;/code&gt; 的数据成员，以指示流的状态（仅输入，仅输出，输入/输出，结尾等）。</target>
        </trans-unit>
        <trans-unit id="f488b539106ae565b1a7adaef610b9d6be03b1fa" translate="yes" xml:space="preserve">
          <source>In addition, a value-initialized object of the type must produce a null value of that type. This null value shall only be equivalent to itself. Default initialization of the type may have an indeterminate value.</source>
          <target state="translated">此外,该类型的值初始化对象必须产生该类型的空值。这个空值只能与自身等价。该类型的默认初始化可以有一个不确定的值。</target>
        </trans-unit>
        <trans-unit id="7a8db860cf41b64de062e0a8128719f25222688f" translate="yes" xml:space="preserve">
          <source>In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">另外，对原子对象的访问可以建立线程间同步，并按 &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; 顺序对非原子内存访问进行排序。</target>
        </trans-unit>
        <trans-unit id="15638d0e65e84f9a793f46e162b9a6f8ac56803a" translate="yes" xml:space="preserve">
          <source>In addition, all names declared in &lt;a href=&quot;namespace&quot;&gt;unnamed namespace&lt;/a&gt; or a namespace within an unnamed namespace, even ones explicitly declared &lt;code&gt;extern&lt;/code&gt;, have internal linkage.</source>
          <target state="translated">另外，在&lt;a href=&quot;namespace&quot;&gt;未命名空间&lt;/a&gt;或未命名空间中的所有名称中声明的所有名称，甚至是显式声明的 &lt;code&gt;extern&lt;/code&gt; ，都具有内部链接。</target>
        </trans-unit>
        <trans-unit id="49487efebaebbb07ca06e7cb34f9dc3b236bdf9b" translate="yes" xml:space="preserve">
          <source>In addition, evaluation of that expression is not allowed to call non-const member functions of the dereferenced iterators.</source>
          <target state="translated">此外,该表达式的评估不允许调用dereferenced迭代器的非const成员函数。</target>
        </trans-unit>
        <trans-unit id="ff0e19edf9941c628d63cc46fd91d50b5ee3522e" translate="yes" xml:space="preserve">
          <source>In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these four specializations.</source>
          <target state="translated">此外,在C++程序中构造的每一个locale对象都实现了它自己的(特定于本地的)这四个特殊化版本。</target>
        </trans-unit>
        <trans-unit id="34a1ac7c8b7c33c94bfab7f6061398698b960b4f" translate="yes" xml:space="preserve">
          <source>In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these specializations.</source>
          <target state="translated">此外,在C++程序中构造的每一个locale对象都实现了它自己的(特定于本地的)这些特殊化版本。</target>
        </trans-unit>
        <trans-unit id="d46580f66bb3168b2878f24c3024ecea21ce496c" translate="yes" xml:space="preserve">
          <source>In addition, for each class template &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; declared in this header, &lt;code&gt;std::&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;std::w&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; are declared as a synonym of &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; respectively.</source>
          <target state="translated">此外，对于在此标头中声明的每个类模板 &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; ，都将 &lt;code&gt;std::&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; 和 &lt;code&gt;std::w&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; 声明为 &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;char&amp;gt;&lt;/code&gt; 和 &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; 的同义词分别。</target>
        </trans-unit>
        <trans-unit id="5d1d9f9e3417a73b82b4272cc321a2469fc45949" translate="yes" xml:space="preserve">
          <source>In addition, if the lvalue is of volatile-qualified class type, a volatile copy-constructor is required to initialize the resulting rvalue temporary.</source>
          <target state="translated">此外,如果lvalue是volatile限定类类型,则需要一个volatile copy-constructor来初始化产生的rvalue临时。</target>
        </trans-unit>
        <trans-unit id="9ce4f9734cf334aa096d562134cd27bb864fe82d" translate="yes" xml:space="preserve">
          <source>In addition, implementations are allowed to:</source>
          <target state="translated">此外,允许实施。</target>
        </trans-unit>
        <trans-unit id="6fca944845bc26e72a63f6ee2aaf3fc85bb418c7" translate="yes" xml:space="preserve">
          <source>In addition, it's undefined behavior to #define or #undef names identical to &lt;a href=&quot;../keywords&quot;&gt;keywords&lt;/a&gt;. If at least one standard library header is included, it's undefined behavior to #define or #undef identifiers identical to names declared in any standard library header.</source>
          <target state="translated">另外，#define或#undef与&lt;a href=&quot;../keywords&quot;&gt;关键字&lt;/a&gt;相同的名称是未定义的行为。如果至少包含一个标准库头，则与任何标准库头中声明的名称相同的#define或#undef标识符是未定义的行为。</target>
        </trans-unit>
        <trans-unit id="9d2f44e82fedbe71cbece0ffe227d0a0158a8b14" translate="yes" xml:space="preserve">
          <source>In addition, many &lt;a href=&quot;../types&quot;&gt;type traits&lt;/a&gt; are implemented using SFINAE.</source>
          <target state="translated">另外，许多&lt;a href=&quot;../types&quot;&gt;类型特征&lt;/a&gt;是使用SFINAE实现的。</target>
        </trans-unit>
        <trans-unit id="e92c1e872be57b036dbc2507bb5706e7b76dcd09" translate="yes" xml:space="preserve">
          <source>In addition, member and non-member functions are provided to support the following operations:</source>
          <target state="translated">此外,还提供了成员和非成员职能,以支持以下业务:</target>
        </trans-unit>
        <trans-unit id="89093684fff07258cc05ff168ca489272759c61f" translate="yes" xml:space="preserve">
          <source>In addition, so-called</source>
          <target state="translated">此外,所谓的</target>
        </trans-unit>
        <trans-unit id="29000479e98fa4979896c6eb46f598587861c215" translate="yes" xml:space="preserve">
          <source>In addition, synchronized C++ streams are guaranteed to be thread-safe (individual characters output from multiple threads may interleave, but no data races occur).</source>
          <target state="translated">此外,同步的C++流保证了线程安全(多个线程输出的单个字符可能会交错,但不会发生数据竞赛)。</target>
        </trans-unit>
        <trans-unit id="5fea8ea2966b10c7537944404433308f3b7b4ff6" translate="yes" xml:space="preserve">
          <source>In addition, the following standard library facilities accept any Callable type (not just &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;).</source>
          <target state="translated">另外，以下标准库工具接受任何Callable类型（而不仅仅是&lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6c22d022938dfbf51f3ef71122c0c58581f4ff83" translate="yes" xml:space="preserve">
          <source>In addition, the implicit conversion in copy-initialization must produce &lt;code&gt;T&lt;/code&gt; directly from the initializer, while, e.g. direct-initialization expects an implicit conversion from the initializer to an argument of &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="translated">另外，复制初始化中的隐式转换必须直接从初始值设定项产生 &lt;code&gt;T&lt;/code&gt; ，而例如直接初始化期望从初始值设定项到 &lt;code&gt;T&lt;/code&gt; 的构造函数的参数的隐式转换。</target>
        </trans-unit>
        <trans-unit id="92a67045a12eca5e07b1c4404b9093c3441f456c" translate="yes" xml:space="preserve">
          <source>In addition, the standard exception types &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../overflow_error/overflow_error&quot;&gt;std::overflow_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../underflow_error/underflow_error&quot;&gt;std::underflow_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../regex/regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;std::runtime_error&lt;/code&gt;.</source>
          <target state="translated">另外，标准异常类型 &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../overflow_error/overflow_error&quot;&gt;std::overflow_error&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../underflow_error/underflow_error&quot;&gt;std::underflow_error&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;../../regex/regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; 派生自 &lt;code&gt;std::runtime_error&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46ca753eadbc6e64c330f063c04cf76079373fe6" translate="yes" xml:space="preserve">
          <source>In addition, the standard library offers several RAII wrappers to manage user-provided resources:</source>
          <target state="translated">此外,标准库还提供了几个RAII包装器来管理用户提供的资源。</target>
        </trans-unit>
        <trans-unit id="891107f99b45712dab34dbd0d5adc64b629b07b9" translate="yes" xml:space="preserve">
          <source>In addition, two function templates are</source>
          <target state="translated">此外,两个函数模板是</target>
        </trans-unit>
        <trans-unit id="ff24fd16f36ec6c36c829ad13c5fdc98ceb02332" translate="yes" xml:space="preserve">
          <source>In addition, unparenthesized type is greedy: it will include every token that can be a part of a declarator:</source>
          <target state="translated">此外,无括号类型是贪婪的:它将包括每一个可以成为声明符一部分的标记。</target>
        </trans-unit>
        <trans-unit id="33a1d90854c6b62d20682a431d3deb3e352e1570" translate="yes" xml:space="preserve">
          <source>In addition, volatile accesses are not atomic (concurrent read and write is a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).</source>
          <target state="translated">另外，易失性访问不是原子的（并发读写是&lt;a href=&quot;../language/memory_model&quot;&gt;数据竞争&lt;/a&gt;），并且不对内存进行排序（非易失性存储器访问可以在易失性访问周围自由地重新排序）。</target>
        </trans-unit>
        <trans-unit id="3cb2abcf8bbfd3a7bfabbd1249bd200fcbc8e347" translate="yes" xml:space="preserve">
          <source>In addition, within the namespace &lt;code&gt;std::chrono&lt;/code&gt;, the directive &lt;code&gt;using namespace literals::chrono_literals;&lt;/code&gt; is provided by the standard library, so that if a programmer uses &lt;code&gt;using namespace std::chrono;&lt;/code&gt; to gain access to the classes in the chrono library, the corresponding literal operators become visible as well.</source>
          <target state="translated">另外，在名称空间 &lt;code&gt;std::chrono&lt;/code&gt; &lt;code&gt;using namespace literals::chrono_literals;&lt;/code&gt; 的指令。由标准库提供，因此，如果程序员 &lt;code&gt;using namespace std::chrono;&lt;/code&gt; 为了访问chrono库中的类，相应的文字运算符也将变得可见。</target>
        </trans-unit>
        <trans-unit id="208c76a1040cc2d170e334de617b92960c4a9549" translate="yes" xml:space="preserve">
          <source>In all cases in which the call to &lt;code&gt;regex_search&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;match.prefix().first&lt;/code&gt; will be equal to the previous value of &lt;code&gt;match[0].second&lt;/code&gt; and for each index</source>
          <target state="translated">在对 &lt;code&gt;regex_search&lt;/code&gt; 的调用返回 &lt;code&gt;true&lt;/code&gt; 的所有情况下， &lt;code&gt;match.prefix().first&lt;/code&gt; 将等于 &lt;code&gt;match[0].second&lt;/code&gt; 的先前值，并且对于每个索引</target>
        </trans-unit>
        <trans-unit id="b3e3fd9de0235c44f06b8f45f6682e2f71d0e99c" translate="yes" xml:space="preserve">
          <source>In all cases the deleter is initialized from &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;decltype(d)&amp;gt;(d)&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，删除器都是从 &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;decltype(d)&amp;gt;(d)&lt;/code&gt; 初始化的。</target>
        </trans-unit>
        <trans-unit id="702fc4c8ea20caf42025f3c5b2479929ca73939e" translate="yes" xml:space="preserve">
          <source>In all cases, a constructor selected to copy or move an object is odr-used even if &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt; takes place.</source>
          <target state="translated">在所有情况下，即使进行&lt;a href=&quot;copy_elision&quot;&gt;复制省略，&lt;/a&gt;也会选择使用用于复制或移动对象的构造函数。</target>
        </trans-unit>
        <trans-unit id="448921a2325557aed9e228f8da4e834b6e28cdeb" translate="yes" xml:space="preserve">
          <source>In all cases, attr is an optional sequence of &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;. When appearing immediately after the identifier, it applies to the object being declared.</source>
          <target state="translated">在所有情况下，attr是可选的&lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt;序列。在标识符后立即出现时，它适用于要声明的对象。</target>
        </trans-unit>
        <trans-unit id="83161a84bc1a7a51d78f0506c4b7ea19c215e3d3" translate="yes" xml:space="preserve">
          <source>In all cases, cv-qualifiers are ignored by typeid (that is, &lt;code&gt;typeid(const T) == typeid(T)&lt;/code&gt;).</source>
          <target state="translated">在所有情况下，typeid都会忽略cv限定词（即 &lt;code&gt;typeid(const T) == typeid(T)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="10f7d85b749093104c6f7b42f1410b3aa41a5078" translate="yes" xml:space="preserve">
          <source>In all cases, equality is checked by calling &lt;a href=&quot;../char_traits/cmp&quot;&gt;&lt;code&gt;Traits::eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在所有情况下，均通过调用&lt;a href=&quot;../char_traits/cmp&quot;&gt; &lt;code&gt;Traits::eq&lt;/code&gt; &lt;/a&gt;来检查是否相等。</target>
        </trans-unit>
        <trans-unit id="e78e8c07f5b30e31f34be5630e807f2679203b79" translate="yes" xml:space="preserve">
          <source>In all cases, equality is checked by calling &lt;a href=&quot;../char_traits/cmp&quot;&gt;Traits::eq&lt;/a&gt;.</source>
          <target state="translated">在所有情况下，均通过调用&lt;a href=&quot;../char_traits/cmp&quot;&gt;Traits :: eq&lt;/a&gt;来检查是否相等。</target>
        </trans-unit>
        <trans-unit id="42ce3a010af7213a4ee16fafe2f69cd257e4ea24" translate="yes" xml:space="preserve">
          <source>In all cases, for the built-in operators, lhs and rhs must have either.</source>
          <target state="translated">在所有情况下,对于内置的运算符,lhs和rhs必须有其中之一。</target>
        </trans-unit>
        <trans-unit id="773f0f51c30de4ead22498372e4d412e3f3708c1" translate="yes" xml:space="preserve">
          <source>In all cases, if &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the standard library deallocation functions do nothing. If the pointer passed to the standard library deallocation function was not obtained from the corresponding standard library allocation function, the behavior is undefined.</source>
          <target state="translated">在所有情况下，如果 &lt;code&gt;ptr&lt;/code&gt; 是空指针，则标准库释放函数将不执行任何操作。如果没有从相应的标准库分配函数获得传递给标准库释放函数的指针，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="013ee203d2185f13defcfecaa9d4ae3f3d4ae52b" translate="yes" xml:space="preserve">
          <source>In all cases, if the empty pair of braces &lt;code&gt;{} &lt;/code&gt; is used and &lt;code&gt;T&lt;/code&gt; is an</source>
          <target state="translated">在所有情况下，如果使用一对空括号 &lt;code&gt;{} &lt;/code&gt; ，并且 &lt;code&gt;T&lt;/code&gt; 为</target>
        </trans-unit>
        <trans-unit id="9dfb4259d8b5e6ee928f73bc11c3685d70ea5622" translate="yes" xml:space="preserve">
          <source>In all cases, it is the stored pointer (the one returned by &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a shared_ptr created using the aliasing constructor.</source>
          <target state="translated">在所有情况下，都是比较存储的指针（由 &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; 返回的指针），而不是托管的指针（当use_count变为零时传递给删除程序的指针）。在使用别名构造函数创建的shared_ptr中，两个指针可能有所不同。</target>
        </trans-unit>
        <trans-unit id="f050a06aeea57760c69721a08f3162ee7c38913e" translate="yes" xml:space="preserve">
          <source>In all cases, the conversion begins in initial shift state, unless non-initial starting state was provided to this &lt;code&gt;wstring_convert&lt;/code&gt; constructor. The number of characters converted and the final value of the conversion state are remembered and can be accessed with &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;converted&quot;&gt;converted()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，除非向此 &lt;code&gt;wstring_convert&lt;/code&gt; 构造函数提供了非初始启动状态，否则转换均以初始移位状态开始。记住转换的字符数和转换状态的最终值，可以使用 &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;converted&quot;&gt;converted()&lt;/a&gt;&lt;/code&gt; 进行访问。</target>
        </trans-unit>
        <trans-unit id="89b8bdb3cdd26cc5757a5fc307bf6e8cbadfa071" translate="yes" xml:space="preserve">
          <source>In all cases, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;size() + ins_count &amp;gt; max_size()&lt;/code&gt; where &lt;code&gt;ins_count&lt;/code&gt; is the number of characters that will be inserted and may throw any exceptions thrown by &lt;code&gt;Allocator::allocate&lt;/code&gt;.</source>
          <target state="translated">在所有情况下，如果 &lt;code&gt;size() + ins_count &amp;gt; max_size()&lt;/code&gt; 则抛出 &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; ，其中 &lt;code&gt;ins_count&lt;/code&gt; 是将要插入的字符数，并且可能抛出 &lt;code&gt;Allocator::allocate&lt;/code&gt; 抛出的任何异常。</target>
        </trans-unit>
        <trans-unit id="a6bec4825b469bd22420b217d83b3fa4ef3c1c3f" translate="yes" xml:space="preserve">
          <source>In all other cases the result is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">在所有其他情况下，结果都是 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0ee8040c05c6072650b3fc884f5719734c12fb2" translate="yes" xml:space="preserve">
          <source>In all other cases, neither template is more specialized than the other with regards to the type(s) deduced by this P/A pair.</source>
          <target state="translated">在所有其他情况下,就这对P/A推断的类型而言,两个模板都不比另一个更专业。</target>
        </trans-unit>
        <trans-unit id="e58e6d192ec64176fdc1379f81dba51aa0d986c8" translate="yes" xml:space="preserve">
          <source>In all other cases, the result is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">在所有其他情况下，结果都是准确的（永远不会引发 &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; ），&lt;a href=&quot;../fenv/fe_round&quot;&gt;并且当前舍入模式将&lt;/a&gt;被忽略</target>
        </trans-unit>
        <trans-unit id="725c5378c2d25e77fa8739dfffb5cdbf3d501bf2" translate="yes" xml:space="preserve">
          <source>In all these contexts, the function selected from the overload set is the function whose type matches the pointer to function, reference to function, or pointer to member function type that is expected by</source>
          <target state="translated">在所有这些上下文中,从重载集中选择的函数是其类型与指向函数的指针、指向函数的引用或指向成员函数类型的指针相匹配的函数,这些函数是由</target>
        </trans-unit>
        <trans-unit id="42e33142558dfcb4a52d9857fc0366f3d6fbcb3d" translate="yes" xml:space="preserve">
          <source>In an inline function,</source>
          <target state="translated">在一个内联函数中。</target>
        </trans-unit>
        <trans-unit id="e54ee587ae8370595daaa17b48b214c6cedbda36" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;std::terminate&lt;/code&gt; calls the currently installed &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt;. The default &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">无论如何， &lt;code&gt;std::terminate&lt;/code&gt; 调用当前安装的 &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; 。默认的 &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3dd5c3a82e6a3c58b090861766b926905a15762" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;str.width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">无论如何，都将调用 &lt;code&gt;str.width(0)&lt;/code&gt; 来取消 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 的影响。</target>
        </trans-unit>
        <trans-unit id="6c3348754a124fedffbdcc31ba4b5c403932481c" translate="yes" xml:space="preserve">
          <source>In any case, an additional fictional function template derived as above from a hypothetical constructor &lt;code&gt;C(C)&lt;/code&gt; is added, called the copy deduction candidate.</source>
          <target state="translated">在任何情况下，都将添加一个从假设的构造函数 &lt;code&gt;C(C)&lt;/code&gt; 上面导出的附加虚构函数模板，称为复制推论候选。</target>
        </trans-unit>
        <trans-unit id="fa4b872de2f5ce03a3a38ccff298fd27acc8cd7f" translate="yes" xml:space="preserve">
          <source>In any case, container operations (as well as algorithms, or any other C++ standard library functions) may be parallelized internally as long as this does not change the user-visible results (e.g. &lt;code&gt;&lt;a href=&quot;algorithm/transform&quot;&gt;std::transform&lt;/a&gt;&lt;/code&gt; may be parallelized, but not &lt;code&gt;&lt;a href=&quot;algorithm/for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; which is specified to visit each element of a sequence in order)</source>
          <target state="translated">在任何情况下，容器操作（以及算法或任何其他C ++标准库函数）都可以在内部进行并行化，只要这不会更改用户可见的结果（例如， &lt;code&gt;&lt;a href=&quot;algorithm/transform&quot;&gt;std::transform&lt;/a&gt;&lt;/code&gt; 可以并行化，而 &lt;code&gt;&lt;a href=&quot;algorithm/for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; ，它被指定为按顺序访问序列的每个元素）</target>
        </trans-unit>
        <trans-unit id="2da0390056e4062badb9f03f93f263c86a863ecf" translate="yes" xml:space="preserve">
          <source>In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, it then stores a null character &lt;code&gt;CharT()&lt;/code&gt; into the next successive location of the array and updates &lt;code&gt;gcount()&lt;/code&gt;.</source>
          <target state="translated">无论如何，如果 &lt;code&gt;count&amp;gt;0&lt;/code&gt; ，则它将空字符 &lt;code&gt;CharT()&lt;/code&gt; 存储到数组的下一个连续位置，并更新 &lt;code&gt;gcount()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4df2d850754842c746a077f1d7414c07173a5713" translate="yes" xml:space="preserve">
          <source>In any case, if U is an incomplete type, the program is ill-formed.</source>
          <target state="translated">在任何情况下,如果U是一个不完整的类型,则程序是不完整的。</target>
        </trans-unit>
        <trans-unit id="ea9753e092b975406e86e9a75ca8490421b85d80" translate="yes" xml:space="preserve">
          <source>In any case, if an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="translated">在任何情况下,如果因为任何原因抛出异常,这个函数都没有效果(强异常保证)。</target>
        </trans-unit>
        <trans-unit id="6ea5742f9037c3ece834bf38253ccb990e6ae335" translate="yes" xml:space="preserve">
          <source>In any case, if an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="translated">在任何情况下,如果因为任何原因抛出异常,这个函数都没有任何效果(强异常保证)。</target>
        </trans-unit>
        <trans-unit id="5ad29af16c7a4b0eae9f716a384a3fe434c038e3" translate="yes" xml:space="preserve">
          <source>In any case, if any part of a type name is non-deduced, the entire type name is non-deduced context. However, compound types can include both deduced and non-deduced type names. For example, in &lt;code&gt;A&amp;lt;T&amp;gt;::B&amp;lt;T2&amp;gt;&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; is non-deduced because of rule #1 (nested name specifier), and &lt;code&gt;T2&lt;/code&gt; is non-deduced because it is part of the same type name, but in &lt;code&gt;void(*f)(typename A&amp;lt;T&amp;gt;::B, A&amp;lt;T&amp;gt;)&lt;/code&gt;, the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;A&amp;lt;T&amp;gt;::B&lt;/code&gt; is non-deduced (because of the same rule), while the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is deduced.</source>
          <target state="translated">在任何情况下，如果类型名称的任何部分都未推导，则整个类型名称都是未推论的上下文。但是，复合类型可以同时包括推导类型名称和非推导类型名称。例如，在 &lt;code&gt;A&amp;lt;T&amp;gt;::B&amp;lt;T2&amp;gt;&lt;/code&gt; ， &lt;code&gt;T&lt;/code&gt; 是非推导因为规则＃1（嵌套名指定），以及 &lt;code&gt;T2&lt;/code&gt; 是非推断，因为它是同一类型的名称的一部分，但在 &lt;code&gt;void(*f)(typename A&amp;lt;T&amp;gt;::B, A&amp;lt;T&amp;gt;)&lt;/code&gt; 时， &lt;code&gt;T&lt;/code&gt; 在 &lt;code&gt;A&amp;lt;T&amp;gt;::B&lt;/code&gt; 是非推导出（因为相同的规则的），而 &lt;code&gt;T&lt;/code&gt; 在 &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; 被推论。</target>
        </trans-unit>
        <trans-unit id="bac936a68f34bcde27ef8af2c5541d05870721a4" translate="yes" xml:space="preserve">
          <source>In any case, if the conversion function fails &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;</source>
          <target state="translated">无论如何，如果转换功能失败，则将 &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; 分配给 &lt;code&gt;err&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f692dd6979a28b812ff55210b84b6db94eddba7d" translate="yes" xml:space="preserve">
          <source>In any case, if the pointed-to type is different from the array element type, disregarding cv qualifications, at every level if the elements are themselves pointers, the behavior of pointer arithmetic is undefined. In particular, pointer arithmetic with pointer to base, which is pointing at an element of an array of derived objects is undefined.</source>
          <target state="translated">在任何情况下,如果point-to类型与数组元素类型不同,不考虑cv限定,在每个级别上如果元素本身是指针,指针运算的行为是未定义的。特别是,指针算子与指针到基的指针算子,是指向派生对象数组元素的,是未定义的。</target>
        </trans-unit>
        <trans-unit id="a6713811e3c955566cd61aabae4ba44639991bc9" translate="yes" xml:space="preserve">
          <source>In any case, if the value of the right operand is negative or is greater or equal to the number of bits in the promoted left operand, the behavior is undefined.</source>
          <target state="translated">在任何情况下,如果右操作数的值为负值,或者大于或等于被推广的左操作数的位数,则该行为是未定义的。</target>
        </trans-unit>
        <trans-unit id="e408e1ffc24f4902a539b882cf7a3ebb2a011be7" translate="yes" xml:space="preserve">
          <source>In any case, sets the &lt;code&gt;gcount()&lt;/code&gt; counter to zero.</source>
          <target state="translated">无论如何，请将 &lt;code&gt;gcount()&lt;/code&gt; 计数器设置为零。</target>
        </trans-unit>
        <trans-unit id="3d278d5d6ccb754380b757eb2f8bd5786624cf05" translate="yes" xml:space="preserve">
          <source>In any case, the argument list for the purpose of overload resolution is the argument list of the function call expression preceded by the implied object argument &lt;code&gt;E&lt;/code&gt; (when matching against the surrogate function, the user-defined conversion will automatically convert the implied object argument to the first argument of the surrogate function).</source>
          <target state="translated">在任何情况下，用于重载解析的参数列表都是函数调用表达式的参数列表，其后是隐含对象参数 &lt;code&gt;E&lt;/code&gt; （当与替代函数匹配时，用户定义的转换将自动将隐含对象参数转换为代理函数的第一个参数）。</target>
        </trans-unit>
        <trans-unit id="ba7e54962dc6ba91c1893f539a5af9b0dd3bcd03" translate="yes" xml:space="preserve">
          <source>In any case, the call to &lt;code&gt;std::async&lt;/code&gt;</source>
          <target state="translated">无论如何，对 &lt;code&gt;std::async&lt;/code&gt; 的调用</target>
        </trans-unit>
        <trans-unit id="ac7f68c6ecc54f2511911cdf7e14078e65684035" translate="yes" xml:space="preserve">
          <source>In any case, the check is made whether the &lt;code&gt;char&lt;/code&gt; obtained from the previous steps is allowed in the input field that would be parsed by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; given the conversion specifier selected in Stage 1. If it is allowed, it is accumulated in a temporary buffer and Stage 2 repeats. If it is not allowed, Stage 2 terminates.</source>
          <target state="translated">在任何情况下，都将检查在步骤1中选择了转换说明符的情况下，是否允许在前面的步骤中获得的 &lt;code&gt;char&lt;/code&gt; 由 &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; 解析的输入字段中。如果允许，则将其累积在临时缓冲区和第2阶段重复。如果不允许，则阶段2终止。</target>
        </trans-unit>
        <trans-unit id="7239f4c6ede432f98a1ba74015ef9a8efc5ff852" translate="yes" xml:space="preserve">
          <source>In any case, the path class behaves as if it stores a pathname in the native format and automatically converts to generic format as needed (each member function specifies which format it interprets the path as).</source>
          <target state="translated">在任何情况下,路径类的行为就像它以本地格式存储路径名一样,并在需要时自动转换为通用格式(每个成员函数都指定了它将路径解释为哪种格式)。</target>
        </trans-unit>
        <trans-unit id="d3d5f9fb69cc2220358beed9110dba0f5144fa1f" translate="yes" xml:space="preserve">
          <source>In any case, the result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="translated">无论如何，结果都是 &lt;code&gt;bool&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="bdbc8735ab228c93f4f0db0b86729ff991ed9876" translate="yes" xml:space="preserve">
          <source>In any case, the resulting value is one of at most two floating-point values closest to the value of the string matching the pattern, after rounding according to &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">无论如何，在根据 &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt; 进行四舍五入后，结果值是最接近与模式匹配的字符串的值的最多两个浮点值之一。</target>
        </trans-unit>
        <trans-unit id="c407d2239a1860dec731b410278172d7d1e7af2e" translate="yes" xml:space="preserve">
          <source>In any case, updates the private member variable that is accessed by &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">无论如何，都更新 &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; 访问的私有成员变量。</target>
        </trans-unit>
        <trans-unit id="fd58a7b2537b4b1d9769b336c69ed0405e2bf357" translate="yes" xml:space="preserve">
          <source>In any event, whether terminating by exception or returning, the sentry's destructor is called before leaving this function.</source>
          <target state="translated">在任何情况下,无论是通过异常终止还是返回,在离开这个函数之前,都会调用哨兵的破坏函数。</target>
        </trans-unit>
        <trans-unit id="9d70a008be456375cc51641818d2f498b0e8cfe0" translate="yes" xml:space="preserve">
          <source>In both cases, virt-specifier-seq, if used, is either &lt;code&gt;override&lt;/code&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;, or &lt;code&gt;final override&lt;/code&gt; or &lt;code&gt;override final&lt;/code&gt;.</source>
          <target state="translated">在这两种情况下，virt-specifier-seq（如果使用）都是 &lt;code&gt;override&lt;/code&gt; 或&lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;，或者是 &lt;code&gt;final override&lt;/code&gt; 或 &lt;code&gt;override final&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7735a0f86f64131cc2baeb3f9d91024df4a0f2ac" translate="yes" xml:space="preserve">
          <source>In brief, a class that defines &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; automatically gets compiler-generated operators ==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, and &amp;gt;=. A class can define &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; as defaulted, in which case the compiler will also generate the code for that operator.</source>
          <target state="translated">简而言之，定义 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 的类会自动获取编译器生成的运算符==，！=，&amp;lt;，&amp;lt;=，&amp;gt;和&amp;gt; =。一个类可以将 &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; 定义为默认值，在这种情况下，编译器还将为该运算符生成代码。</target>
        </trans-unit>
        <trans-unit id="b4aca348b75aa570f1a0831d21e79e759aa35c7a" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between a variable declaration using the direct-initialization syntax (1) (with round parentheses) and a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;, the compiler always chooses function declaration. This disambiguation rule is sometimes counter-intuitive and has been called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Most_vexing_parse&quot;&gt;most vexing parse&lt;/a&gt;.</source>
          <target state="translated">如果使用直接初始化语法（1）（带有圆括号）的&lt;a href=&quot;function&quot;&gt;变量声明&lt;/a&gt;与函数声明之间存在歧义，则编译器始终选择函数声明。这种消除歧义的规则有时是违反直觉的，被称为&lt;a href=&quot;https://en.wikipedia.org/wiki/Most_vexing_parse&quot;&gt;最令人烦恼的解析&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="901202dfb183bd5273740fd75a6cb4999a9adde4" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between a variable declaration using the direct-initialization syntax and a function declaration, the compiler always chooses function declaration; see &lt;a href=&quot;direct_initialization#Notes&quot;&gt;direct-initialization&lt;/a&gt;.</source>
          <target state="translated">如果使用直接初始化语法的变量声明和函数声明之间存在歧义，编译器将始终选择函数声明；否则，编译器将始终选择函数声明。请参阅&lt;a href=&quot;direct_initialization#Notes&quot;&gt;直接初始化&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="584cb1daba5fb668ec776aaad71f0f0a1e678a65" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between the size of the bit field and the default member initializer, the longest sequence of tokens that forms a valid size is chosen:</source>
          <target state="translated">如果位字段的大小与默认成员初始化器之间存在歧义,则选择形成有效大小的最长的令牌序列。</target>
        </trans-unit>
        <trans-unit id="c60f89be5e6a24d3e9af482fb30cc5225a2b9c40" translate="yes" xml:space="preserve">
          <source>In class definition</source>
          <target state="translated">在类定义中</target>
        </trans-unit>
        <trans-unit id="0ed480b0f5f767a36b4cca750fd3df5eb7dea2c0" translate="yes" xml:space="preserve">
          <source>In class template</source>
          <target state="translated">在类模板中</target>
        </trans-unit>
        <trans-unit id="88cf7e36aa40464925cb0cdb822a38f9a11a2e03" translate="yes" xml:space="preserve">
          <source>In class templates, &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;dependent_name&quot;&gt;dependent expression&lt;/a&gt;, and explicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; may be used to force another expression to become dependent.</source>
          <target state="translated">在类模板中， &lt;code&gt;this&lt;/code&gt; 是一个&lt;a href=&quot;dependent_name&quot;&gt;从属表达式&lt;/a&gt;，显式 &lt;code&gt;this-&amp;gt;&lt;/code&gt; 可用于强制另一个表达式成为从属表达式。</target>
        </trans-unit>
        <trans-unit id="9bb902edc779601077555fd4ba8ae150af319a7a" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;std::fmod()&lt;/a&gt;&lt;/code&gt;, the returned value is not guaranteed to have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;std::fmod()&lt;/a&gt;&lt;/code&gt; ，返回值不能保证与 &lt;code&gt;x&lt;/code&gt; 具有相同的符号。</target>
        </trans-unit>
        <trans-unit id="29e6d4a4833ba899fe54d6d48cb6237bf996c237" translate="yes" xml:space="preserve">
          <source>In copy-list-initialization, if phase 2 selects an explicit constructor, the initialization is ill-formed (as opposed to all over copy-initializations where explicit constructors are not even considered).</source>
          <target state="translated">在复制-列表-初始化中,如果第2阶段选择了一个显式构造函数,初始化就会不健全(与全盘复制-初始化相比,显式构造函数根本不考虑)。</target>
        </trans-unit>
        <trans-unit id="0f662aa9e7fe6829be9755a0bb2464c6d5830c0c" translate="yes" xml:space="preserve">
          <source>In declarations</source>
          <target state="translated">在声明中</target>
        </trans-unit>
        <trans-unit id="6cfdd0eb8f38950930fcb84521ccaa8ab0f3a576" translate="yes" xml:space="preserve">
          <source>In declarations, attributes may appear both before the whole declaration and directly after the name of the entity that is declared, in which case they are combined. In most other situations, attributes apply to the directly preceding entity.</source>
          <target state="translated">在声明中,属性既可以出现在整个声明之前,也可以直接出现在被声明的实体名称之后,在这种情况下,它们会被合并。在大多数其他情况下,属性适用于直接在前的实体。</target>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="translated">详细来说</target>
        </trans-unit>
        <trans-unit id="9ea333fa04508f8dc9aec394ed0e05cc9396345e" translate="yes" xml:space="preserve">
          <source>In detail, the common comparison type of a list of n types T0...Tn-1 is defined as follows:</source>
          <target state="translated">详细来说,n个类型的列表T0...Tn-1的常用比较类型定义如下。</target>
        </trans-unit>
        <trans-unit id="0c0bc79ad40602f6280764ba3e86b0386a7085c2" translate="yes" xml:space="preserve">
          <source>In detail:</source>
          <target state="translated">详细来说:</target>
        </trans-unit>
        <trans-unit id="c02c2129e19b776dcabd51f1ec40f2e879325a96" translate="yes" xml:space="preserve">
          <source>In direct-list-initialization (but not in copy-list-initalization), when deducing the meaning of the &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; from a braced-init-list, the braced-init-list must contain only one element, and the type of auto will be the type of that element:</source>
          <target state="translated">在直接列表初始化中（但不是在复制列表初始化中），当从大括号初始列表中推断出&lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt;的含义时，大括号初始列表必须仅包含一个元素，并且auto的类型将是该元素的类型：</target>
        </trans-unit>
        <trans-unit id="c32c9ac9a30d2bf4ad4aaca0daac65dbd6f4dbc0" translate="yes" xml:space="preserve">
          <source>In each case</source>
          <target state="translated">在每种情况下</target>
        </trans-unit>
        <trans-unit id="8ff5c44b9f8d73aec0aa66262a809a1b948e7c53" translate="yes" xml:space="preserve">
          <source>In each case, the object (or individual elements if &lt;code&gt;T&lt;/code&gt; is an array type)(since C++20) will be destroyed by &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;X&lt;/code&gt; is its type.</source>
          <target state="translated">在每种情况下，对象（如果 &lt;code&gt;T&lt;/code&gt; 是数组类型，则为单个元素）（自C ++ 20起）将被 &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt; 破坏，其中 &lt;code&gt;p&lt;/code&gt; 是指向对象的指针， &lt;code&gt;X&lt;/code&gt; 是其类型。</target>
        </trans-unit>
        <trans-unit id="a0acff1fbd7c81794afc6d04ed614676c2d1a5ea" translate="yes" xml:space="preserve">
          <source>In each context, the name of an overloaded function may be preceded by address-of operator &lt;code&gt;&amp;amp;&lt;/code&gt; and may be enclosed in a redundant set of parentheses.</source>
          <target state="translated">在每种情况下，重载函数的名称都可以在运算符 &lt;code&gt;&amp;amp;&lt;/code&gt; 之前，并且可以将其括在冗余的括号中。</target>
        </trans-unit>
        <trans-unit id="580d311d2c3830913522a71b0ee0845b37f593cf" translate="yes" xml:space="preserve">
          <source>In either case, &lt;code&gt;std::unexpected&lt;/code&gt; calls the currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;. The default &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">无论哪种情况， &lt;code&gt;std::unexpected&lt;/code&gt; 调用当前安装的 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; 。默认的 &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; 调用 &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6513d1fe43b0727e95c4ecbedbc97f1ff6159779" translate="yes" xml:space="preserve">
          <source>In either case, an additional null character value &lt;code&gt;CharT()&lt;/code&gt; is stored at the end of the output. If no characters were extracted, sets &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/a&gt; (the null character is still written, to the first position in the output). Finally, calls &lt;code&gt;st.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.  3).</source>
          <target state="translated">在任何一种情况下，附加的空字符值 &lt;code&gt;CharT()&lt;/code&gt; 都存储在输出的末尾。如果未提取任何字符，则设置&lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;failbit&lt;/code&gt; &lt;/a&gt;（仍将空字符写入输出中的第一个位置）。最后，调用 &lt;code&gt;st.width(0)&lt;/code&gt; 取消 &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 的影响（如果有）。3）。</target>
        </trans-unit>
        <trans-unit id="8164d479fcc12457fe047a38c7a34d5e26adfd63" translate="yes" xml:space="preserve">
          <source>In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed (rebalancing may occur, as with &lt;code&gt;&lt;a href=&quot;erase&quot;&gt;erase()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">在这两种情况下，都不会复制或移动任何元素，仅会指向容器节点的内部指针（可能会发生重新平衡，就像使用 &lt;code&gt;&lt;a href=&quot;erase&quot;&gt;erase()&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3eb50cbaf3e01225bd1ecea1bf00b9412ffb6b4a" translate="yes" xml:space="preserve">
          <source>In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed.</source>
          <target state="translated">在这两种情况下,都不会复制或移动任何元素,只是重新指定容器节点的内部指针。</target>
        </trans-unit>
        <trans-unit id="c657cee6a5de51a9466de54eb7a34b06cf204249" translate="yes" xml:space="preserve">
          <source>In either case, stores the number of characters extracted in the member variable accessed by subsequent calls to &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;sb&lt;/code&gt; is a null pointer or if no characters were inserted into &lt;code&gt;sb&lt;/code&gt;, calls &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if enabled).</source>
          <target state="translated">无论哪种情况，都存储在成员变量中提取的字符数，该成员变量可通过随后对 &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; 的调用来访问。如果 &lt;code&gt;sb&lt;/code&gt; 是空指针，或者没有字符插入 &lt;code&gt;sb&lt;/code&gt; ，则调用 &lt;code&gt;setstate(failbit)&lt;/code&gt; （如果启用，则可能引发 &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f958e451ccea1b7f622427f43a20430e7db91448" translate="yes" xml:space="preserve">
          <source>In existing implementations, the number of weak pointers is incremented (&lt;a href=&quot;https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p&quot;&gt;[2]&lt;/a&gt;) if there is a shared pointer to the same control block.</source>
          <target state="translated">在现有的实现中，如果存在指向同一控制块的共享指针，则弱指针的数量会增加（&lt;a href=&quot;https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected&quot;&gt;[1]&lt;/a&gt;，&lt;a href=&quot;https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p&quot;&gt;[2]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1241f4b4a5871614c0b0e937d887dd31b0d585a9" translate="yes" xml:space="preserve">
          <source>In expressions</source>
          <target state="translated">在表达式中</target>
        </trans-unit>
        <trans-unit id="db2370d3e7ba69273bdb62a10e047b42c0843bf1" translate="yes" xml:space="preserve">
          <source>In function-like macros, a &lt;code&gt;#&lt;/code&gt; operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called &quot;stringification&quot;. If the result of stringification is not a valid string literal, the behavior is undefined.</source>
          <target state="translated">在类似函数的宏中，替换列表中的标识符之前的 &lt;code&gt;#&lt;/code&gt; 运算符通过参数替换运行该标识符并将结果括在引号中，从而有效地创建了字符串文字。另外，预处理器添加反斜杠以转义嵌入的字符串文字（如果有）周围的引号，并在必要时对字符串内的反斜杠加倍。删除所有前导和尾随空格，并将文本中间的任何空格序列（但不包括在嵌入的字符串文字中）折叠为一个空格。此操作称为&amp;ldquo;字符串化&amp;rdquo;。如果字符串化的结果不是有效的字符串文字，则该行为未定义。</target>
        </trans-unit>
        <trans-unit id="1a66e73cddda4a347472a74c2bcb63aabea7fcb6" translate="yes" xml:space="preserve">
          <source>In general, for any trivially copyable type &lt;code&gt;T&lt;/code&gt; and an object &lt;code&gt;obj1&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;, the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; can be copied (e.g. by means of &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;) into an array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt; or &lt;a href=&quot;byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt; or into &lt;code&gt;obj2&lt;/code&gt;, a distinct object of &lt;code&gt;T&lt;/code&gt;. Neither &lt;code&gt;obj1&lt;/code&gt; nor &lt;code&gt;obj2&lt;/code&gt; may be a potentially-overlapping subobject.</source>
          <target state="translated">通常，对于任何能够复制平凡类型 &lt;code&gt;T&lt;/code&gt; 和对象 &lt;code&gt;obj1&lt;/code&gt; 的 &lt;code&gt;T&lt;/code&gt; ，的下层字节 &lt;code&gt;obj1&lt;/code&gt; 可以被复制（例如借助于 &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ）转换成的阵列 &lt;code&gt;char&lt;/code&gt; ， &lt;code&gt;unsigned char&lt;/code&gt; 或&lt;a href=&quot;byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;obj2&lt;/code&gt; （ &lt;code&gt;T&lt;/code&gt; 的不同对象）。既不 &lt;code&gt;obj1&lt;/code&gt; 也不 &lt;code&gt;obj2&lt;/code&gt; 可以是潜在地重叠的子对象。</target>
        </trans-unit>
        <trans-unit id="38fcfe4d6a87e17a455c75a9b0e425f272558b3d" translate="yes" xml:space="preserve">
          <source>In general, implicit conversion from one multi-level pointer to another follows the rules described in &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;qualification conversions&lt;/a&gt; and in &lt;a href=&quot;operator_comparison#Pointer_comparison_operators&quot;&gt;pointer comparison operators&lt;/a&gt;.</source>
          <target state="translated">通常，从一个多级指针到另一级的隐式转换遵循&lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;资格转换&lt;/a&gt;和&lt;a href=&quot;operator_comparison#Pointer_comparison_operators&quot;&gt;指针比较运算符中&lt;/a&gt;描述的规则。</target>
        </trans-unit>
        <trans-unit id="81b4dfcd41b67e7e484427a572743c0af786423b" translate="yes" xml:space="preserve">
          <source>In general, the candidate function whose parameters match the arguments most closely is the one that is called.</source>
          <target state="translated">一般来说,参数与参数最匹配的候选函数才会被调用。</target>
        </trans-unit>
        <trans-unit id="1c76635c26067171ee4fb88a5e53efe29ca5200a" translate="yes" xml:space="preserve">
          <source>In general, the lifetime of a temporary cannot be further extended by &quot;passing it on&quot;: a second reference, initialized from the reference to which the temporary was bound, does not affect its lifetime.</source>
          <target state="translated">一般来说,临时性的寿命不能通过 &quot;传递 &quot;来进一步延长:从临时性被绑定的引用中初始化的第二个引用不会影响其寿命。</target>
        </trans-unit>
        <trans-unit id="3b068778e762f7be532eacfc3e630095231dc1ab" translate="yes" xml:space="preserve">
          <source>In generic contexts, the destructor call syntax can be used with an object of non-class type; this is known as pseudo-destructor call: see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;.</source>
          <target state="translated">在一般情况下，析构函数调用语法可以与非类类型的对象一起使用。这称为伪析构函数调用：请参阅&lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;成员访问运算符&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0e96e30536ed7d7370721a29eb0a3baf8e9861d0" translate="yes" xml:space="preserve">
          <source>In locales other than &lt;code&gt;&quot;C&quot;&lt;/code&gt;, an alphabetic character is a character for which &lt;code&gt;std::isupper()&lt;/code&gt; or &lt;code&gt;std::islower()&lt;/code&gt; returns non-zero or any other character considered alphabetic by the locale. In any case, &lt;code&gt;std::iscntrl()&lt;/code&gt;, &lt;code&gt;std::isdigit()&lt;/code&gt;, &lt;code&gt;std::ispunct()&lt;/code&gt; and &lt;code&gt;std::isspace()&lt;/code&gt; will return zero for this character.</source>
          <target state="translated">在除 &lt;code&gt;&quot;C&quot;&lt;/code&gt; 之外的语言环境中，字母字符是 &lt;code&gt;std::isupper()&lt;/code&gt; 或 &lt;code&gt;std::islower()&lt;/code&gt; 返回非零或该语言环境视为字母的任何其他字符。无论如何， &lt;code&gt;std::iscntrl()&lt;/code&gt; ， &lt;code&gt;std::isdigit()&lt;/code&gt; ， &lt;code&gt;std::ispunct()&lt;/code&gt; 和 &lt;code&gt;std::isspace()&lt;/code&gt; 都会为该字符返回零。</target>
        </trans-unit>
        <trans-unit id="2c7ad051625c76a00388473f47c41ae5d264a453" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">在许多实现中， &lt;code&gt;is_nothrow_constructible&lt;/code&gt; 还检查析构函数是否抛出异常，因为它实际上是 &lt;code&gt;noexcept(T(arg))&lt;/code&gt; 。同样适用于 &lt;code&gt;is_trivially_constructible&lt;/code&gt; ，在这些实现中，它还要求析构函数是微不足道的：&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC错误51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG问题2116&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99de1bf720237b75f07b5ab247c8e8bd64241fc2" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33323ec4f069d0c0b878342b0a8185699b19819e" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">在许多实现中， &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; 也检查析构函数是否抛出异常，因为它实际上是 &lt;code&gt;noexcept(T(arg))&lt;/code&gt; 。同样适用于 &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt; ，在这些实现中，它还要求析构函数是微不足道的：&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC错误51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG问题2116&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ae21e32d43a5b8a2c5c70ffceb70d5fb04307666" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accf831c87b14d37d2cc6eafd0090b844f5f9b51" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T())&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_default_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">在许多实现中， &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; 也检查析构函数是否抛出，因为它实际上是 &lt;code&gt;noexcept(T())&lt;/code&gt; 。同样适用于 &lt;code&gt;is_trivially_default_constructible&lt;/code&gt; ，在这些实现中，它还要求析构函数是微不足道的：&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC错误51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG问题2116&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="438ba1a0beef26968ab6a2cc4d97b48f26dcb853" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T())&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_default_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d90dd0a15587a98cbedbb69df63e111504c94d0" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_move_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">在许多实现中， &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; 也检查析构函数是否抛出，因为它实际上是 &lt;code&gt;noexcept(T(arg))&lt;/code&gt; 。同样适用于 &lt;code&gt;is_trivially_move_constructible&lt;/code&gt; ，在这些实现中，它还要求析构函数是微不足道的：&lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC错误51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG问题2116&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bbc7a800f8051280b4337f76efed7cbb0d60440e" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_move_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f61cbb399593cd96a01d7c1e70f3b86ca51dd80" translate="yes" xml:space="preserve">
          <source>In many implementations, standard output is line-buffered, and writing &lt;code&gt;'\n'&lt;/code&gt; causes a flush anyway, unless &lt;code&gt;std::ios::sync_with_stdio(false)&lt;/code&gt; was executed. In those situations, unnecessary &lt;code&gt;endl&lt;/code&gt; only degrades the performance of file output, not standard output.</source>
          <target state="translated">在许多实现中，标准输出是行缓冲的，并且除非执行 &lt;code&gt;std::ios::sync_with_stdio(false)&lt;/code&gt; ，否则写 &lt;code&gt;'\n'&lt;/code&gt; 都会导致刷新。在这些情况下，不必要的 &lt;code&gt;endl&lt;/code&gt; 只会降低文件输出的性能，而不会降低标准输出的性能。</target>
        </trans-unit>
        <trans-unit id="b5cc9d63c613364dc5793e8e7ac9b68a692864f4" translate="yes" xml:space="preserve">
          <source>In many situations, copy constructors are optimized out even if they would produce observable side-effects, see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">在许多情况下，即使复制构造函数会产生可观察到的副作用，也会对其进行优化，请参见&lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="361bbab390512b139df616a956291652c3a5e8eb" translate="yes" xml:space="preserve">
          <source>In most implementations, this function updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">在大多数实现中，此函数在处理字符串时会更新类型为 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 的全局静态对象，并且不能由两个线程同时调用，在这种情况下应使用 &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49690d1d0c037eea359d8320b2de46145cef5181" translate="yes" xml:space="preserve">
          <source>In most implementations, this function updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">在大多数实现中，此函数在处理字符串时会更新类型为 &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; 的全局静态对象，并且不能由两个线程同时调用，在这种情况下应使用 &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="88d76a48f8f96c35da8c08d45a4e62de40b811d7" translate="yes" xml:space="preserve">
          <source>In most implementations, this returns &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt;.</source>
          <target state="translated">在大多数实现中，这将返回 &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dfeb8ee21790e4ab7902716cd854784402ed77a" translate="yes" xml:space="preserve">
          <source>In multithreaded environment, the value returned by use_count is approximate (typical implementations use a &lt;a href=&quot;../../atomic/memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt; load).</source>
          <target state="translated">在多线程环境中，use_count返回的值是近似值（典型的实现使用&lt;a href=&quot;../../atomic/memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt;负载）。</target>
        </trans-unit>
        <trans-unit id="b0b00c8c047435001bd2de135f45ca01beaae4c1" translate="yes" xml:space="preserve">
          <source>In namespace and block scope</source>
          <target state="translated">在命名空间和块范围内</target>
        </trans-unit>
        <trans-unit id="20891e1e3bb66c9419f1d516300d8501998694a6" translate="yes" xml:space="preserve">
          <source>In old or nonconforming compilers, using the &lt;a href=&quot;../language/operator_alternative&quot;&gt;alternative operator representations&lt;/a&gt; may still require including this header.</source>
          <target state="translated">在旧的或不合格的编译器中，使用&lt;a href=&quot;../language/operator_alternative&quot;&gt;替代运算符表示&lt;/a&gt;可能仍需要包括此标头。</target>
        </trans-unit>
        <trans-unit id="976a60901e43304c76c9540f3f429a8d9f4c6a87" translate="yes" xml:space="preserve">
          <source>In order for a template to be instantiated, every template parameter (type, non-type, or template) must be replaced by a corresponding template argument. For &lt;a href=&quot;class_template&quot;&gt;class templates&lt;/a&gt;, the arguments are either explicitly provided, &lt;a href=&quot;deduction_guide&quot;&gt;deduced from the initializer&lt;/a&gt;, (since C++17) or defaulted. For &lt;a href=&quot;function_template&quot;&gt;function templates&lt;/a&gt;, the arguments are explicitly provided, &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced from the context&lt;/a&gt;, or defaulted.</source>
          <target state="translated">为了实例化模板，必须用相应的模板参数替换每个模板参数（类型，非类型或模板）。对于&lt;a href=&quot;class_template&quot;&gt;类模板&lt;/a&gt;，参数是显式提供的（从C ++ 17起），&lt;a href=&quot;deduction_guide&quot;&gt;从初始值设定项推导出&lt;/a&gt;，或者是默认值。对于&lt;a href=&quot;function_template&quot;&gt;功能模板&lt;/a&gt;，参数是显式提供的，&lt;a href=&quot;template_argument_deduction&quot;&gt;从上下文推导出的&lt;/a&gt;或默认的。</target>
        </trans-unit>
        <trans-unit id="2d740db339a5645df895be9040440821225a705c" translate="yes" xml:space="preserve">
          <source>In order for an exception to be caught, the throw-expression has to be inside a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt; or inside a function called from a try-block, and there has to be a &lt;a href=&quot;try_catch&quot;&gt;catch clause&lt;/a&gt; that matches the type of the exception object.</source>
          <target state="translated">为了捕获异常，throw-expression必须位于&lt;a href=&quot;try_catch&quot;&gt;try块内&lt;/a&gt;或从try块调用的函数内，并且必须具有与异常对象的类型匹配的&lt;a href=&quot;try_catch&quot;&gt;catch子句&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7a11d6633f27612217d043955d8513b0eaf805c" translate="yes" xml:space="preserve">
          <source>In order to compile a function call, the compiler must first perform &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, which, for functions, may involve &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;, and for function templates may be followed by &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;. If these steps produce more than one</source>
          <target state="translated">为了编译函数调用，编译器必须首先执行&lt;a href=&quot;lookup&quot;&gt;名称查找&lt;/a&gt;，对于函数而言，名称查找可能涉及&lt;a href=&quot;adl&quot;&gt;依赖于参数的查找&lt;/a&gt;，而对于函数模板，可能要遵循&lt;a href=&quot;template_argument_deduction&quot;&gt;模板参数推导&lt;/a&gt;。如果这些步骤产生多个</target>
        </trans-unit>
        <trans-unit id="c439dee89b66538a41331ba7addd781be9e95710" translate="yes" xml:space="preserve">
          <source>In order to examine all matches within the target sequence, &lt;code&gt;std::regex_search&lt;/code&gt; may be called in a loop, restarting each time from &lt;code&gt;m[0].second&lt;/code&gt; of the previous call. &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; offers an easy interface to this iteration.</source>
          <target state="translated">为了检查目标序列内的所有匹配，可以循环调用 &lt;code&gt;std::regex_search&lt;/code&gt; ，每次从上一次调用的 &lt;code&gt;m[0].second&lt;/code&gt; 重新开始。 &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; 提供了此迭代的简单接口。</target>
        </trans-unit>
        <trans-unit id="93e5fcbc9e67b4e1b987a567473422ebf0dee92c" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt;, every template argument must be known, but not every template argument has to be specified. In the following contexts the compiler will deduce the missing template arguments from the type of the initializer:</source>
          <target state="translated">为了实例化&lt;a href=&quot;class_template&quot;&gt;类模板&lt;/a&gt;，必须知道每个模板参数，但不必指定每个模板参数。在以下情况下，编译器将从初始化程序的类型中推断出缺少的模板参数：</target>
        </trans-unit>
        <trans-unit id="9bf61b9c2f6c8ed792b21ac9dd2327e234ccbf15" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted, when an address of a function template is taken, and in some &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;other contexts&lt;/a&gt;:</source>
          <target state="translated">为了实例化&lt;a href=&quot;function_template&quot;&gt;功能模板&lt;/a&gt;，必须知道每个模板参数，但不必指定每个模板参数。如果可能，编译器将从函数参数中推断出缺少的模板参数。在尝试调用函数，采用函数模板的地址以及&lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;其他&lt;/a&gt;一些情况下，会发生这种情况：</target>
        </trans-unit>
        <trans-unit id="8076ca3c217ff4a7a98ccc16264bf0332155e2a1" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;strong&gt;function template&lt;/strong&gt;, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted and when an address of a function template is taken.</source>
          <target state="translated">为了实例化&lt;strong&gt;功能模板&lt;/strong&gt;，必须知道每个模板参数，但不必指定每个模板参数。如果可能，编译器将从函数参数中推断出缺少的模板参数。当尝试调用函数以及获取函数模板的地址时，会发生这种情况。</target>
        </trans-unit>
        <trans-unit id="ed244da1aecd793a261081beab12c67de2da00bb" translate="yes" xml:space="preserve">
          <source>In order to satisfy alignment requirements of all non-static members of a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt;,</source>
          <target state="translated">为了满足&lt;a href=&quot;class&quot;&gt;类别&lt;/a&gt;中所有非静态成员的对齐要求，</target>
        </trans-unit>
        <trans-unit id="2dce1c16904fec9d3889052abdb4ab00a4c0f330" translate="yes" xml:space="preserve">
          <source>In order to satisfy the requirements of array-oriented access, an implementation is constrained to store the real and imaginary components of a &lt;code&gt;std::complex&lt;/code&gt; specialization in separate and adjacent memory locations. Possible declarations for its non-static data members include:</source>
          <target state="translated">为了满足面向数组访问的要求，必须限制一种实现，以便将 &lt;code&gt;std::complex&lt;/code&gt; 专业化的实部和虚部存储在单独的和相邻的内存位置中。其非静态数据成员的可能声明包括：</target>
        </trans-unit>
        <trans-unit id="d223a004acbe8c2ee4258ddff41fb5bd9c563a88" translate="yes" xml:space="preserve">
          <source>In order to wait in a shared mutex in shared ownership mode, &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; can be used (&lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; requires &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and so can only wait in unique ownership mode).</source>
          <target state="translated">为了在共享所有权模式共享互斥等待， &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; 可用于（ &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; 需要 &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; 等只能在唯一的所有权模式等待）。</target>
        </trans-unit>
        <trans-unit id="a0570d7fb641b108923426180a7da145cd589a42" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;std::bind_front(f, bound_args...)(call_args...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(f, bound_args..., call_args....)&lt;/code&gt;.</source>
          <target state="translated">换句话说， &lt;code&gt;std::bind_front(f, bound_args...)(call_args...)&lt;/code&gt; 等同于 &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(f, bound_args..., call_args....)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9c4cf6f1de09d5243e6d12c4b6e447d38d42628" translate="yes" xml:space="preserve">
          <source>In other words, after replacing the type (e.g. an iterator type) in a well-formed non-aggregate initialization with &lt;code&gt;dangling&lt;/code&gt;, the resulting initialization is also well-formed.</source>
          <target state="translated">换句话说，在将良好格式的非聚合初始化中的类型（例如，迭代器类型）替换为 &lt;code&gt;dangling&lt;/code&gt; ，所得的初始化也将格式良好。</target>
        </trans-unit>
        <trans-unit id="2fdcde52c9613f8d9965c24cc761c64f7f29bbf9" translate="yes" xml:space="preserve">
          <source>In other words, if an algorithm takes a Predicate &lt;code&gt;pred&lt;/code&gt; and an iterator &lt;code&gt;first&lt;/code&gt;, it should be able to test the object of the type pointed to by the iterator &lt;code&gt;first&lt;/code&gt; using the given predicate via a construct like &lt;code&gt;if(pred(*first)) {...}&lt;/code&gt;.</source>
          <target state="translated">换句话说，如果一个算法需要一个谓语 &lt;code&gt;pred&lt;/code&gt; 和一个迭代 &lt;code&gt;first&lt;/code&gt; ，它应该是能测试的类型的对象由迭代指向 &lt;code&gt;first&lt;/code&gt; 经由构建体使用给定的谓词等 &lt;code&gt;if(pred(*first)) {...}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="491de468bd659078aefdfec90cf19da2bcde4cae" translate="yes" xml:space="preserve">
          <source>In other words, the conversion to the common reference type must preserve equality.</source>
          <target state="translated">换句话说,转换到通用引用类型必须保持平等。</target>
        </trans-unit>
        <trans-unit id="1515a939c60d7a0551eb77267cda9623a3ec082e" translate="yes" xml:space="preserve">
          <source>In other words, the conversion to the common type must preserve equality.</source>
          <target state="translated">换句话说,向普通类型的转换必须保持平等。</target>
        </trans-unit>
        <trans-unit id="e7bf915fd2c7af366ac00ae6abbc509a778d1910" translate="yes" xml:space="preserve">
          <source>In other words, the summation operations may be performed in arbitrary order, and the behavior is nondeterministic if &lt;code&gt;binary_op&lt;/code&gt; is not associative.</source>
          <target state="translated">换句话说，求和运算可以按任意顺序执行，并且如果 &lt;code&gt;binary_op&lt;/code&gt; 不具有关联性，则该行为是不确定的。</target>
        </trans-unit>
        <trans-unit id="a80c785731fa7946b71b60f0a1b2f2901be26657" translate="yes" xml:space="preserve">
          <source>In overload (1), if &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">在重载（1）中，如果 &lt;code&gt;T&lt;/code&gt; 的move构造函数不是 &lt;code&gt;noexcept&lt;/code&gt; ,并且T不可&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;复制&lt;/a&gt;到 &lt;code&gt;*this&lt;/code&gt; ，则vector将使用抛出的move构造函数。如果抛出，则放弃担保，并且影响未指定。</target>
        </trans-unit>
        <trans-unit id="da0255ac708e972224b54cc46137f223d8fcb17c" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;std::move&lt;/code&gt; produces an &lt;a href=&quot;../language/value_category&quot;&gt;xvalue expression&lt;/a&gt; that identifies its argument &lt;code&gt;t&lt;/code&gt;. It is exactly equivalent to a static_cast to an rvalue reference type.</source>
          <target state="translated">特别是， &lt;code&gt;std::move&lt;/code&gt; 生成一个&lt;a href=&quot;../language/value_category&quot;&gt;xvalue表达式&lt;/a&gt;，该表达式标识其参数 &lt;code&gt;t&lt;/code&gt; 。它完全等效于static_cast到右值引用类型。</target>
        </trans-unit>
        <trans-unit id="bc5f562f16c7f3516fd8ac3ab2d0a32811211b88" translate="yes" xml:space="preserve">
          <source>In particular, all hard links for the same file or directory are equivalent, and a symlink and its target on the same file system are equivalent.</source>
          <target state="translated">特别是,同一文件或目录的所有硬链接都是等价的,同一文件系统上的符号链接及其目标是等价的。</target>
        </trans-unit>
        <trans-unit id="6c9eea59b15650f810d84d6038841dd320cdfa3e" translate="yes" xml:space="preserve">
          <source>In particular, for negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt;, the formatting may appear as &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while for negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; it would appear as &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="translated">特别是，对于 &lt;code&gt;&quot;-&quot;&lt;/code&gt; negative_sign ，格式可能显示为 &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; ，而对于 &lt;code&gt;&quot;()&quot;&lt;/code&gt; negative_sign，格式可能显示为 &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9805358780c9313bdf8b46c3d77f45f54ffa9c0" translate="yes" xml:space="preserve">
          <source>In particular, like all rvalues, xvalues bind to rvalue references, and like all glvalues, xvalues may be &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, and non-class xvalues may be &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;.</source>
          <target state="translated">特别是，像所有rvalues一样，xvalues绑定到rvalue引用，并且像所有glvalues一样，xvalues可以是&lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;多态的&lt;/a&gt;，而非类xvalues可以是&lt;a href=&quot;cv&quot;&gt;cv限定的&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3440815d0cff772e37f45dd6a4e47c1dc0bf363e" translate="yes" xml:space="preserve">
          <source>In particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="translated">特别是不可复制的参数和数组到指针的转换。</target>
        </trans-unit>
        <trans-unit id="25d069cd55a0e3cbff6493480ec850fae36c0fdc" translate="yes" xml:space="preserve">
          <source>In particular, this implies that string literals, addresses of array elements, and addresses of non-static members cannot be used as template arguments to instantiate templates whose corresponding non-type template parameters are pointers to objects.</source>
          <target state="translated">特别是,这意味着字符串字元、数组元素的地址和非静态成员的地址不能作为模板参数来实例化模板,其对应的非类型模板参数是指向对象的指针。</target>
        </trans-unit>
        <trans-unit id="16b8d6ec9c39d406c45bf8c3a95070cf38451515" translate="yes" xml:space="preserve">
          <source>In particular, this implies that the failures of constructors (see also &lt;a href=&quot;raii&quot;&gt;RAII&lt;/a&gt;) and most operators should be reported by throwing exceptions.</source>
          <target state="translated">特别是，这意味着应通过抛出异常来报告构造函数（也请参阅&lt;a href=&quot;raii&quot;&gt;RAII&lt;/a&gt;）和大多数运算符的失败。</target>
        </trans-unit>
        <trans-unit id="6bd64e741fcbffe364b20bed2e39dc776e83f8c6" translate="yes" xml:space="preserve">
          <source>In particular, this implies that.</source>
          <target state="translated">具体而言,这意味着:</target>
        </trans-unit>
        <trans-unit id="7778e57383bfe144db5dc5276001e50344a7eb81" translate="yes" xml:space="preserve">
          <source>In practice, constant initialization is performed at compile time, and pre-calculated object representations are stored as part of the program image (e.g. in the &lt;code&gt;.data&lt;/code&gt; section). If a variable is both &lt;code&gt;const&lt;/code&gt; and constant-initialized, its object representation may be stored in a read-only section of the program image (e.g. the &lt;code&gt;.rodata&lt;/code&gt; section).</source>
          <target state="translated">实际上，在编译时执行常量初始化，并将预先计算的对象表示形式存储为程序映像的一部分（例如，在 &lt;code&gt;.data&lt;/code&gt; 节中）。如果变量既是 &lt;code&gt;const&lt;/code&gt; 又是常量初始化的，则其对象表示形式可以存储在程序映像的 &lt;code&gt;.rodata&lt;/code&gt; 节（例如.rodata节）中。</target>
        </trans-unit>
        <trans-unit id="c5f7e6132c24b431ab05a1b29a68ed1255266ac7" translate="yes" xml:space="preserve">
          <source>In practice, implementations of &lt;code&gt;std::copy&lt;/code&gt; avoid multiple assignments and use bulk copy functions such as &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; if the value type is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;.</source>
          <target state="translated">实际上，如果值类型为&lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;，则 &lt;code&gt;std::copy&lt;/code&gt; 实现应避免多次分配，并使用批量复制功能，例如 &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4166dd075003042b54540673bbf26b17c11851e9" translate="yes" xml:space="preserve">
          <source>In practice, they may be implemented as function objects, or with special compiler extensions.</source>
          <target state="translated">在实践中,它们可以作为函数对象来实现,或者使用特殊的编译器扩展。</target>
        </trans-unit>
        <trans-unit id="66affe68d971b057413c1675fbe61348d2fbb2ee" translate="yes" xml:space="preserve">
          <source>In practice, this means that the synchronized C++ streams are unbuffered, and each I/O operation on a C++ stream is immediately applied to the corresponding C stream's buffer. This makes it possible to freely mix C++ and C I/O.</source>
          <target state="translated">实际上,这意味着同步的C++流是没有缓冲区的,对C++流的每一个I/O操作都会立即应用到相应的C流的缓冲区。这就使得C++和C I/O的自由混合成为可能。</target>
        </trans-unit>
        <trans-unit id="a9d5344404c3cda159f179c91a199091db72dee1" translate="yes" xml:space="preserve">
          <source>In simple cases, both pImpl and factory method break compile-time dependency between the implementation and the users of the class interface. Factory method creates a hidden dependency on the vtable, and so reordering, adding, or removing virtual member functions breaks the ABI. The pImpl approach has no hidden dependencies, however if the implementation class is a class template specialization, the compilation firewall benefit is lost: the users of the interface must observe the entire template definition in order to instantiate the correct specialization. A common design approach in this case is to refactor the implementation in a way that avoids parametrization, this is another use case for the C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rt-scary&quot;&gt;T.61 Do not over-parametrize members&lt;/a&gt; and &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface&quot;&gt;T.84 Use a non-template core implementation to provide an ABI-stable interface&lt;/a&gt;.</source>
          <target state="translated">在简单的情况下，pImpl和factory方法都破坏了实现与类接口用户之间的编译时依赖性。工厂方法在vtable上创建了隐藏的依赖关系，因此重新排序，添加或删除虚拟成员函数会破坏ABI。 pImpl方法没有隐藏的依赖关系，但是，如果实现类是类模板专业化，则将失去编译防火墙的好处：接口的用户必须遵守整个模板定义才能实例化正确的专业化。在这种情况下，一个常用的设计方法是重构以避免参数化的方式实现，这是另一种使用情况的C ++核心准则&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rt-scary&quot;&gt;T.61不要过度参数多态成员&lt;/a&gt;和&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface&quot;&gt;T.84使用非模板核心实现来提供ABI稳定的接口&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e257383e8a791be56a7795dcfa164d94b6cff0ea" translate="yes" xml:space="preserve">
          <source>In some contexts, only type names can validly appear. In these contexts, a dependent qualified name is assumed to name a type and no &lt;code&gt;typename&lt;/code&gt; is required:</source>
          <target state="translated">在某些情况下，只有类型名称可以有效显示。在这些情况下，假定使用从属限定名称来命名类型，并且不需要 &lt;code&gt;typename&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b4f0ab4a86013d411969196467703372e7da8ad4" translate="yes" xml:space="preserve">
          <source>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as &quot;shift sequences&quot;. Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are the 7-bit JIS, BOCU-1 and &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;.</source>
          <target state="translated">在某些多字节编码中，任何给定的多字节字符序列都可以根据先前的字节序列（称为&amp;ldquo;移位序列&amp;rdquo;）表示不同的字符。这种编码称为状态相关的：需要了解当前换档状态才能解释每个字符。 NTMBS仅在开始和结束于初始移位状态时才有效：如果使用了移位序列，则在终止的空字符之前必须存在相应的解除移位序列。这种编码的示例是7位JIS，BOCU-1和&lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1ce53c84d0931440c6f3fc451cf445803c97d375" translate="yes" xml:space="preserve">
          <source>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as &quot;shift sequences&quot;. Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are the 7-bit JIS, BOCU-1 and &lt;a href=&quot;https://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621567d318323c5c0c22b8501fb1f3c5e2acd90e" translate="yes" xml:space="preserve">
          <source>In such a nested declaration, some of the levels may remain unspecialized (except that it can't specialize a class member template if its enclosing class is unspecialized). For each of those levels, the declaration needs &lt;code&gt;template&amp;lt;arguments&amp;gt;&lt;/code&gt;, because such specializations are themselves templates:</source>
          <target state="translated">在这样的嵌套声明中，某些级别可能保持未专业化（除非如果其封闭的类是未专业化的，则它不能专门化类成员模板）。对于每个级别，声明都需要 &lt;code&gt;template&amp;lt;arguments&amp;gt;&lt;/code&gt; ，因为这样的专业化本身就是模板：</target>
        </trans-unit>
        <trans-unit id="816350383b2c1e072a6ac4d701ae17bc019c55f8" translate="yes" xml:space="preserve">
          <source>In the C programming language, at least one named parameter must appear before the ellipsis parameter, so &lt;code&gt;printz(...);&lt;/code&gt; is not valid. In C++, this form is allowed even though the arguments passed to such function are not accessible, and is commonly used as the fallback overload in &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;, exploiting the lowest priority of the ellipsis conversion in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">在C编程语言中，至少一个命名参数必须出现在省略号参数之前，因此 &lt;code&gt;printz(...);&lt;/code&gt; 无效。在C ++中，即使传递给该函数的参数是不可访问的，也允许这种形式，并且通常在&lt;a href=&quot;sfinae&quot;&gt;SFINAE中&lt;/a&gt;用作后备重载，在&lt;a href=&quot;overload_resolution&quot;&gt;重载分辨率中&lt;/a&gt;利用省略号转换的最低优先级。</target>
        </trans-unit>
        <trans-unit id="b7448b8bb4cfc9ef5b6d6148816f9abc314f332d" translate="yes" xml:space="preserve">
          <source>In the C programming language, the &lt;code&gt;goto&lt;/code&gt; statement has fewer restrictions and can enter the scope of any variable other than variable-length array or variably-modified pointer.</source>
          <target state="translated">在C编程语言中， &lt;code&gt;goto&lt;/code&gt; 语句具有较少的限制，并且可以输入除可变长度数组或可变修改指针之外的任何变量的范围。</target>
        </trans-unit>
        <trans-unit id="11df4d5daefca94681eb0c6608609ae515a3f4d3" translate="yes" xml:space="preserve">
          <source>In the C programming language, the width of a bit field cannot exceed the width of the underlying type.</source>
          <target state="translated">在C语言编程中,位字段的宽度不能超过底层类型的宽度。</target>
        </trans-unit>
        <trans-unit id="bfc682244d852627ff0d041c2287a081b50d47c4" translate="yes" xml:space="preserve">
          <source>In the above example, if non-ADL lookup for operator&amp;lt;&amp;lt; were allowed from the instantiation context, the instantiation of &lt;code&gt;E::writeObject&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; would have two different definitions: one using &lt;code&gt;P1::operator&amp;lt;&amp;lt;&lt;/code&gt; and one using &lt;code&gt;P2::operator&amp;lt;&amp;lt;&lt;/code&gt;. Such ODR violation may not be detected by the linker, leading to one or the other being used in both instances.</source>
          <target state="translated">在上面的示例中，如果从实例上下文中允许对operator &amp;lt;&amp;lt;的非ADL查找，则 &lt;code&gt;E::writeObject&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; 的实例将具有两个不同的定义：一个使用 &lt;code&gt;P1::operator&amp;lt;&amp;lt;&lt;/code&gt; ，另一个使用 &lt;code&gt;P2::operator&amp;lt;&amp;lt;&lt;/code&gt; 。链接器可能未检测到此类ODR违规，从而导致在两种情况下都使用一个或另一个。</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">在上述。</target>
        </trans-unit>
        <trans-unit id="f761fd1f890c95288965ab17065f5bc7b6d6b538" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;Alloc&lt;/code&gt; is a type that satisfies &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;or is a pointer type convertible to &lt;code&gt;std::experimental::pmr::memory_resource*&lt;/code&gt;(library fundamentals TS).</source>
          <target state="translated">在上面， &lt;code&gt;Alloc&lt;/code&gt; 是满足&lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;的类型，或者是可转换为 &lt;code&gt;std::experimental::pmr::memory_resource*&lt;/code&gt; （库基础知识TS）的指针类型。</target>
        </trans-unit>
        <trans-unit id="4cc61cf6708e3ef42bac60b85582a7b7be2f3f6f" translate="yes" xml:space="preserve">
          <source>In the body of a cv-qualified function, the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer is cv-qualified, e.g. in a &lt;code&gt;const&lt;/code&gt; member function, only other const member functions may be called normally. (A non-const member function may still be called if &lt;a href=&quot;const_cast&quot;&gt;const_cast&lt;/a&gt; is applied or through an access path that does not involve &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt;.).</source>
          <target state="translated">在cv限定函数的主体中，&lt;a href=&quot;this&quot;&gt;this&lt;/a&gt;指针是cv限定的，例如，在 &lt;code&gt;const&lt;/code&gt; 成员函数中，通常只能调用其他const成员函数。（如果应用&lt;a href=&quot;const_cast&quot;&gt;const_cast&lt;/a&gt;或通过不涉及&lt;a href=&quot;this&quot;&gt;此&lt;/a&gt;函数的访问路径，仍可以调用非const成员函数。）。</target>
        </trans-unit>
        <trans-unit id="893e73a07f97db13bb810fec92b5bc2d9c3779e6" translate="yes" xml:space="preserve">
          <source>In the body of the loop, the following steps take place:</source>
          <target state="translated">在循环的主体中,发生了以下步骤。</target>
        </trans-unit>
        <trans-unit id="905f50bd3c725e6724b6b75435c36c4e71558664" translate="yes" xml:space="preserve">
          <source>In the body of the template declaration, the name of a type parameter is a typedef-name which aliases the type supplied when the template is instantiated.</source>
          <target state="translated">在模板声明的主体中,类型参数的名称是一个 typedef-name,它是模板实例化时提供的类型的别名。</target>
        </trans-unit>
        <trans-unit id="7218fc3a4992cbcd0152232cad3f51efabb5d84f" translate="yes" xml:space="preserve">
          <source>In the body of the template declaration, the name of this parameter is a template-name (and needs arguments to be instantiated).</source>
          <target state="translated">在模板声明的主体中,这个参数的名称是template-name(需要参数来实例化)。</target>
        </trans-unit>
        <trans-unit id="900936499efddab53cef702850868c269921a8b7" translate="yes" xml:space="preserve">
          <source>In the case of equality, as determined by &lt;code&gt;operator==&lt;/code&gt;, only lexical representations are compared. Therefore, &lt;code&gt;path(&quot;a&quot;) == path(&quot;b&quot;)&lt;/code&gt; is never &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">在相等的情况下，如 &lt;code&gt;operator==&lt;/code&gt; 所确定，仅比较词汇表示形式。因此， &lt;code&gt;path(&quot;a&quot;) == path(&quot;b&quot;)&lt;/code&gt; 永远不会为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ea417255bb9a3e4e66840a148e5a0eeb99a4a75" translate="yes" xml:space="preserve">
          <source>In the case of equivalence, as determined by &lt;a href=&quot;../equivalent&quot;&gt;&lt;code&gt;equivalent()&lt;/code&gt;&lt;/a&gt;, it is checked whether two paths</source>
          <target state="translated">在等价情况下，由&lt;a href=&quot;../equivalent&quot;&gt; &lt;code&gt;equivalent()&lt;/code&gt; &lt;/a&gt;确定，检查是否有两条路径</target>
        </trans-unit>
        <trans-unit id="0918c8dba94ff6fd94b2510e1844c87eba4fa8bc" translate="yes" xml:space="preserve">
          <source>In the case of thrown exception, the states of the contained values of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are determined by the exception safety guarantees of &lt;code&gt;swap&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;'s move constructor, whichever is called. For both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, if the object contained a value, it is left containing a value, and the other way round.</source>
          <target state="translated">在引发异常的情况下， &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; 的包含值的状态由 &lt;code&gt;T&lt;/code&gt; 类型或 &lt;code&gt;T&lt;/code&gt; 的move构造函数 &lt;code&gt;swap&lt;/code&gt; 的异常安全保证确定，无论哪种调用。对于 &lt;code&gt;*this&lt;/code&gt; 和 &lt;code&gt;other&lt;/code&gt; ，如果对象包含值，则将其保留为值，反之亦然。</target>
        </trans-unit>
        <trans-unit id="74253cd795fea072a07aa9a7e78a4232e8101c59" translate="yes" xml:space="preserve">
          <source>In the cases (1,2), virt-specifier-seq, if used, is either &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;code&gt;final&lt;/code&gt;, or &lt;code&gt;final override&lt;/code&gt; or &lt;code&gt;override final&lt;/code&gt;. In the case (3), the only allowed value of class-virt-specifier, if used, is &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">在情况（1,2）中，virt-specifier-seq（如果使用）是&lt;a href=&quot;override&quot;&gt;覆盖&lt;/a&gt;或 &lt;code&gt;final&lt;/code&gt; ，或者是 &lt;code&gt;final override&lt;/code&gt; 或 &lt;code&gt;override final&lt;/code&gt; 。在情况（3）中，如果使用class-virt-specifier，则允许的唯一值是 &lt;code&gt;final&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64cdd0ab070b191de582e146726ae3b52445aff7" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt;, a &lt;code&gt;bool&lt;/code&gt; object may be initialized from a prvalue of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, including &lt;code&gt;nullptr&lt;/code&gt;. The resulting value is &lt;code&gt;false&lt;/code&gt;. However, this is not considered to be an implicit conversion.</source>
          <target state="translated">在&lt;a href=&quot;direct_initialization&quot;&gt;直接初始化&lt;/a&gt;的上下文中，可以从类型为 &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; 的prvalue初始化 &lt;code&gt;bool&lt;/code&gt; 对象，包括 &lt;code&gt;nullptr&lt;/code&gt; 。结果值为 &lt;code&gt;false&lt;/code&gt; 。但是，这不被视为隐式转换。</target>
        </trans-unit>
        <trans-unit id="c2371f6402972bc45972f3f09d5d022fcbd00df0" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; are replaced with respective uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;.</source>
          <target state="translated">在默认的&amp;ldquo; C&amp;rdquo;语言环境中，以下小写字母 &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; 分别替换为大写字母 &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f82450bef11bed620bb59a03e863ef7afabcdad8" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; are replaced with respective lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;.</source>
          <target state="translated">在默认的&amp;ldquo; C&amp;rdquo;语言环境中，以下大写字母 &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; 分别替换为小写字母 &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="27d01f4ee118275f671ea1fc69da0b10c876ae4d" translate="yes" xml:space="preserve">
          <source>In the definition above,</source>
          <target state="translated">在上述定义中:</target>
        </trans-unit>
        <trans-unit id="b73a608fd45fbdf0b5c22a44851fbc673377e55d" translate="yes" xml:space="preserve">
          <source>In the definition of a constructor of a class,</source>
          <target state="translated">在类的构造函数的定义中。</target>
        </trans-unit>
        <trans-unit id="92eaf109eca502313374c00968739b34523e2380" translate="yes" xml:space="preserve">
          <source>In the definitions above,</source>
          <target state="translated">在上述定义中。</target>
        </trans-unit>
        <trans-unit id="817086841623d69755c18cd1a550bd17dbc9cec2" translate="yes" xml:space="preserve">
          <source>In the end, calls &lt;code&gt;str.width(0)&lt;/code&gt; to cancel the effects of any &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">最后，调用 &lt;code&gt;str.width(0)&lt;/code&gt; 取消任何 &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c655d96839ca7780fa82778f8220c935df02845d" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;E1.*E2&lt;/code&gt;:</source>
          <target state="translated">在表达式 &lt;code&gt;E1.*E2&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7b082767dd5ca682cdbd1f19496a9ffb37833f35" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;E1.E2&lt;/code&gt;:</source>
          <target state="translated">在表达式 &lt;code&gt;E1.E2&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="9db07dd430b24754012846b56b013710f95fae18" translate="yes" xml:space="preserve">
          <source>In the expression above, the identifier &lt;code&gt;swap&lt;/code&gt; is looked up in the same manner as the one used by the C++17 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; trait.</source>
          <target state="translated">在上面的表达式中，标识符 &lt;code&gt;swap&lt;/code&gt; 的查找方式与C ++ 17 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; 特征使用的方式相同。</target>
        </trans-unit>
        <trans-unit id="4e914c03795fc0434d207252646fcc5c2fbb853f" translate="yes" xml:space="preserve">
          <source>In the following cases the expression specifying the first dimension is erroneous:</source>
          <target state="translated">在以下情况下,指定第一个维度的表达方式是错误的。</target>
        </trans-unit>
        <trans-unit id="bb90da930e22170c110ed69983a4cd8c89699138" translate="yes" xml:space="preserve">
          <source>In the following cases, the injected-class-name is treated as a template-name of the class template itself:</source>
          <target state="translated">在以下情况下,注入的类名被视为类模板本身的模板名。</target>
        </trans-unit>
        <trans-unit id="6f57e7c031dc103138aa47aafe5169cd4d0818a3" translate="yes" xml:space="preserve">
          <source>In the following cases, the types, templates, and non-type values that are used to compose &lt;code&gt;P&lt;/code&gt; do not participate in template argument deduction, but instead</source>
          <target state="translated">在以下情况下，用于组成 &lt;code&gt;P&lt;/code&gt; 的类型，模板和非类型值不参与模板参数推导，而是</target>
        </trans-unit>
        <trans-unit id="18a089e2076eb0c963948461ded82840d2c5491f" translate="yes" xml:space="preserve">
          <source>In the following contexts ADL-only lookup (that is, lookup in associated namespaces only) takes place:</source>
          <target state="translated">在以下情况下,只进行ADL查询(即只在关联的名字空间中进行查询)。</target>
        </trans-unit>
        <trans-unit id="1e7e564013cddb0a744a7b7d9845915473666e88" translate="yes" xml:space="preserve">
          <source>In the following contexts, a context-specific type &lt;code&gt;T&lt;/code&gt; is expected, and the expression &lt;code&gt;e&lt;/code&gt; of class type &lt;code&gt;E&lt;/code&gt; is only allowed if &lt;code&gt;E&lt;/code&gt; has a single non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; to an allowable type(until C++14)there is exactly one type &lt;code&gt;T&lt;/code&gt; among the allowable types such that &lt;code&gt;E&lt;/code&gt; has non-explicit conversion functions whose return types are (possibly cv-qualified) &lt;code&gt;T&lt;/code&gt; or reference to (possibly cv-qualified) &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;e&lt;/code&gt; is implicitly convertible to &lt;code&gt;T&lt;/code&gt;(since C++14). Such expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">在以下上下文中，应使用特定于上下文的类型 &lt;code&gt;T&lt;/code&gt; ，并且仅当 &lt;code&gt;E&lt;/code&gt; 具有单个非明确的&lt;a href=&quot;cast_operator&quot;&gt;用户定义的转换&lt;/a&gt;为允许类型的用户定义转换函数（直到C ++ 14）时，才允许使用类类型 &lt;code&gt;E&lt;/code&gt; 的表达式 &lt;code&gt;e&lt;/code&gt; 恰好是允许的类型中的 &lt;code&gt;T&lt;/code&gt; 类型，因此 &lt;code&gt;E&lt;/code&gt; 具有非显式的转换函数，其返回类型为（可能是cv限定） &lt;code&gt;T&lt;/code&gt; 或引用（可能是cv限定） &lt;code&gt;T&lt;/code&gt; ，并且 &lt;code&gt;e&lt;/code&gt; 可以隐式转换为 &lt;code&gt;T&lt;/code&gt; （因为C ++ 14）。这种表达式 &lt;code&gt;e&lt;/code&gt; 据说是</target>
        </trans-unit>
        <trans-unit id="e9d454a482529bf2ee5e3a62d016e12659bf0446" translate="yes" xml:space="preserve">
          <source>In the following contexts, the type &lt;code&gt;bool&lt;/code&gt; is expected and the implicit conversion is performed if the declaration &lt;code&gt;bool t(e);&lt;/code&gt; is well-formed (that is, an explicit conversion function such as &lt;code&gt;explicit T::operator bool() const;&lt;/code&gt; is considered). Such expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">在以下上下文中，类型 &lt;code&gt;bool&lt;/code&gt; 预计，如果隐式转换进行声明 &lt;code&gt;bool t(e);&lt;/code&gt; 格式正确（即考虑使用显式转换函数，例如 &lt;code&gt;explicit T::operator bool() const;&lt;/code&gt; ）。这种表达式 &lt;code&gt;e&lt;/code&gt; 据说是</target>
        </trans-unit>
        <trans-unit id="e8e08b92d2240f4a88c69d4e69a8df8c00816b49" translate="yes" xml:space="preserve">
          <source>In the following examples, the fictitious arguments will be called U1, U2.</source>
          <target state="translated">在下面的例子中,将虚构的参数称为U1、U2。</target>
        </trans-unit>
        <trans-unit id="2ebb63b824c4cdb079972404f91cbe60baeddcf6" translate="yes" xml:space="preserve">
          <source>In the implementation used to execute this example, overflow() over-allocates the put area to 512 bytes: a call to str() would only return the four initialized bytes, but the next 508 calls to sputc() would not require new calls to overflow().</source>
          <target state="translated">在用于执行这个例子的实现中,overflow()将put区域超额分配到512个字节:对str()的调用只会返回四个初始化的字节,但接下来对sputc()的508次调用不需要对overflow()进行新的调用。</target>
        </trans-unit>
        <trans-unit id="f8c299b36b8a4498bc3547746db843fd4f953399" translate="yes" xml:space="preserve">
          <source>In the initialization of a variable, when the initializer expression is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the variable type:</source>
          <target state="translated">在变量的初始化中，当初始化器表达式是与变量类型相同的类类型（忽略&lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;）的&lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt;时：</target>
        </trans-unit>
        <trans-unit id="27c642266c0731a2e8f833d8f0a3ec3946651726" translate="yes" xml:space="preserve">
          <source>In the initialization of an object, when the source object is a nameless temporary and is of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the target object. When the nameless temporary is the operand of a return statement, this variant of copy elision is known as RVO, &quot;return value optimization&quot;.</source>
          <target state="translated">在对象的初始化中，当源对象是一个无名的临时对象并且与目标对象具有相同的类类型（忽略&lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;）时。当无名临时变量是return语句的操作数时，复制省略的这种变体称为RVO，即&amp;ldquo;返回值优化&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="5c373829034265c5b0e2556da1a4e7ca6ed3781b" translate="yes" xml:space="preserve">
          <source>In the integer and floating-point digit sequences, optional separators &lt;code&gt;'&lt;/code&gt; are allowed between any two digits and are ignored</source>
          <target state="translated">在整数和浮点数字序列中，任意两个数字之间都允许使用可选的分隔符 &lt;code&gt;'&lt;/code&gt; ，并且忽略</target>
        </trans-unit>
        <trans-unit id="1597dcf21e743f45fe04b66865d76eb95469ddd2" translate="yes" xml:space="preserve">
          <source>In the published C++11 and C++14 standards, this function was specified to require &lt;code&gt;mapped_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; and &lt;code&gt;key_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;. This specification was defective and was fixed by &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;LWG issue 2469&lt;/a&gt;, and the description above incorporates the resolution of that issue.</source>
          <target state="translated">在已发布的C ++ 11和C ++ 14标准中，此函数被指定为要求 &lt;code&gt;mapped_type&lt;/code&gt; 为&lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt;， &lt;code&gt;key_type&lt;/code&gt; 为&lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt;或&lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;到 &lt;code&gt;*this&lt;/code&gt; 。该规范是有缺陷的，已由&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;LWG问题2469&lt;/a&gt;修复，并且上面的描述结合了该问题的解决方案。</target>
        </trans-unit>
        <trans-unit id="27a6c22d4c82c1acd2252a8c6e5b33af7b1999a8" translate="yes" xml:space="preserve">
          <source>In the published C++11 and C++14 standards, this function was specified to require &lt;code&gt;mapped_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; and &lt;code&gt;key_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;. This specification was defective and was fixed by &lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;LWG issue 2469&lt;/a&gt;, and the description above incorporates the resolution of that issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984b95b188d8b6ed51c0929b5bbcca151d81d732" translate="yes" xml:space="preserve">
          <source>In the second form of if statement (the one including else), if statement-true is also an if statement then that inner if statement must contain an else part as well (in other words, in nested if-statements, the else is associated with the closest if that doesn't have an else).</source>
          <target state="translated">在第二种形式的if语句(包括else)中,如果statement-true也是一个if语句,那么这个内部的if语句也必须包含else部分(换句话说,在嵌套的if语句中,else与最接近的没有else的if相关联)。</target>
        </trans-unit>
        <trans-unit id="b7c2588aa39c2094ccbf6764f2545ff5d48d7081" translate="yes" xml:space="preserve">
          <source>In the unary-binary overload (3,6), &lt;code&gt;unary_op&lt;/code&gt; is not applied to &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">在一元二进制重载（3,6）中， &lt;code&gt;unary_op&lt;/code&gt; 不适用于 &lt;code&gt;init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f46af473d10885afbc17d62f3973969b56f43750" translate="yes" xml:space="preserve">
          <source>In these initializer expressions, &lt;code&gt;e&lt;/code&gt; is an lvalue if the type of the entity &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is an lvalue reference (this only happens if the ref-operator is &lt;code&gt;&amp;amp;&lt;/code&gt; or if it is &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and the initializer expression is an lvalue) and an xvalue otherwise (this effectively performs a kind of perfect forwarding), &lt;code&gt;i&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; prvalue, and &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; is always interpreted as a template parameter list.</source>
          <target state="translated">在这些初始化器表达式中，如果实体 &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; 的类型是左值引用（仅在ref运算符为 &lt;code&gt;&amp;amp;&lt;/code&gt; 或为 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 并且初始化器表达式为左值时， &lt;code&gt;e&lt;/code&gt; 才是左值），否则为xvalue有效执行一种完美的转发）， &lt;code&gt;i&lt;/code&gt; 是 &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; prvalue，并且 &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; 始终被解释为模板参数列表。&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="5edaaa50a68b7de4d405f0db9e2d071386701607" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; F in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after Y.</source>
          <target state="translated">在这种情况下，将在线程A中&lt;a href=&quot;memory_order&quot;&gt;在&lt;/a&gt; F 之前排序的所有非原子和弛豫原子存储都&lt;a href=&quot;memory_order&quot;&gt;发生，&lt;/a&gt;而在Y之后，来自线程B中相同位置的所有非原子和弛豫原子负载将发生。</target>
        </trans-unit>
        <trans-unit id="0a4cf3adc0dea1f1e86d6ff23d2e32a0caa67f56" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; FA in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after FB.</source>
          <target state="translated">在这种情况下，将在线程A中&lt;a href=&quot;memory_order&quot;&gt;在&lt;/a&gt; FA 之前在 FA 之前排序的所有非原子和弛豫原子存储区，而在FB之后，在线程B中从相同位置进行的所有非原子和弛豫原子加载&lt;a href=&quot;memory_order&quot;&gt;之前，&lt;/a&gt;都将发生。</target>
        </trans-unit>
        <trans-unit id="8725b52d3c1fdf65bcce6d3f222c3cb193f19490" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; X in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after F.</source>
          <target state="translated">在这种情况下，将在线程A中&lt;a href=&quot;memory_order&quot;&gt;在&lt;/a&gt; X 之前的所有非原子和弛豫原子存储&lt;a href=&quot;memory_order&quot;&gt;发生，&lt;/a&gt;而在线程F之后，在线程B中来自相同位置的所有非原子和弛豫原子负载将发生。</target>
        </trans-unit>
        <trans-unit id="c0eb534d99bfe7cabd6fc507165a3b864a58be3c" translate="yes" xml:space="preserve">
          <source>In this case, the keyword</source>
          <target state="translated">在这种情况下,关键词</target>
        </trans-unit>
        <trans-unit id="353019d63051611e784bf71d2adc4b77fb808f2b" translate="yes" xml:space="preserve">
          <source>In this case, the member of any specialization of A becomes a friend. This does not involve instantiating the primary template A: the only requirements are that the deduction of the template parameters of A from that specialization succeeds, and that substitution of the deduced template arguments into the friend declaration produces a declaration that would be a valid redeclaration of the member of the specialization:</source>
          <target state="translated">在这种情况下,A的任何特化的成员都会成为朋友。这并不涉及实例化主模板A:唯一的要求是A的模板参数从该特殊化中的推导成功,并且将推导出的模板参数替换到友声明中,产生的声明将是该特殊化成员的有效重新声明。</target>
        </trans-unit>
        <trans-unit id="216570cc099d91d9e8fcba19ae0d75946676ed16" translate="yes" xml:space="preserve">
          <source>In this case, the target constructor is selected by overload resolution and executed first, then the control returns to the delegating constructor and its body is executed.</source>
          <target state="translated">在这种情况下,通过重载解析选择目标构造函数并先执行,然后控件返回委托构造函数,其主体被执行。</target>
        </trans-unit>
        <trans-unit id="06f9e15b2ae9be584dce74848cf7b7f2676331fc" translate="yes" xml:space="preserve">
          <source>In this example, initial allocation of the underlying array was for 16 bytes.</source>
          <target state="translated">在本例中,底层数组的初始分配为16个字节。</target>
        </trans-unit>
        <trans-unit id="330c586d17d06314846a2d3fffc6301809c539ee" translate="yes" xml:space="preserve">
          <source>In this example, two values that compare equal under this comparison (which is case-insensitive on the member &lt;code&gt;name&lt;/code&gt; can be distinguished by functions that are case-sensitive:</source>
          <target state="translated">在此示例中，在此比较下比较相等的两个值（在成员 &lt;code&gt;name&lt;/code&gt; 上不区分大小写的值可以通过区分大小写的函数来区分：</target>
        </trans-unit>
        <trans-unit id="ff5a35c9480e5a35d467f9e8b2a4ffafdc16c703" translate="yes" xml:space="preserve">
          <source>In those situations where copy assignment cannot benefit from resource reuse (it does not manage a heap-allocated array and does not have a (possibly transitive) member that does, such as a member &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;), there is a popular convenient shorthand: the copy-and-swap assignment operator, which takes its parameter by value (thus working as both copy- and move-assignment depending on the value category of the argument), swaps with the parameter, and lets the destructor clean it up.</source>
          <target state="translated">在那些拷贝分配无法从资源重用中受益的情况下（它不管理堆分配的数组，并且没有（可能是可传递的）成员，例如 &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; 或 &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; ），是一种流行的方便快捷方式：复制和交换赋值运算符，它按值获取其参数（因此根据参数的值类别同时用作复制和移动赋值），与该参数交换，并让析构函数将其清理干净。</target>
        </trans-unit>
        <trans-unit id="44d42e4e7cdc63f569100975fee76f3a07f480d3" translate="yes" xml:space="preserve">
          <source>In typical usage, &lt;code&gt;count&lt;/code&gt; is the size of the destination array.</source>
          <target state="translated">在典型用法中， &lt;code&gt;count&lt;/code&gt; 是目标数组的大小。</target>
        </trans-unit>
        <trans-unit id="4027a85dd787fe56399bbb11ac7adf2fe0eee28f" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error. &lt;code&gt;eof()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fail&quot;&gt;fail()&lt;/a&gt;&lt;/code&gt; can then be used to distinguish between different error conditions.</source>
          <target state="translated">在典型用法中，输入流处理会在发生任何错误时停止。然后可以使用 &lt;code&gt;eof()&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;fail&quot;&gt;fail()&lt;/a&gt;&lt;/code&gt; 来区分不同的错误情况。</target>
        </trans-unit>
        <trans-unit id="1c6002149b8d6c5a43ae8ee73b0dbdfdf5535c0c" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error; &lt;code&gt;feof&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; are then used to distinguish between different error conditions.</source>
          <target state="translated">在典型用法中，输入流处理会在发生任何错误时停止；然后使用 &lt;code&gt;feof&lt;/code&gt; 和 &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; 区分不同的错误情况。</target>
        </trans-unit>
        <trans-unit id="21e3e82b3a013fa09de3345372c2bcda63c11cf0" translate="yes" xml:space="preserve">
          <source>In typical use cases, this function is the last thing called by a detached thread.</source>
          <target state="translated">在典型的使用情况下,这个函数是一个分离的线程最后调用的东西。</target>
        </trans-unit>
        <trans-unit id="7790a0c7a8cccc64f38d56e2325db218d5c6811d" translate="yes" xml:space="preserve">
          <source>Inappropriate I/O control operation</source>
          <target state="translated">不恰当的I/O控制操作</target>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="8705867aeef60bcf6e033673dc025bf70ea7c829" translate="yes" xml:space="preserve">
          <source>Includes January 4</source>
          <target state="translated">包括1月4日</target>
        </trans-unit>
        <trans-unit id="ea5fdcf7120862d98b9dd3dd4a179e2277f2b2e6" translate="yes" xml:space="preserve">
          <source>Includes e.g. &lt;a href=&quot;memory/new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;memory/new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;memory/new/set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">包括例如&lt;a href=&quot;memory/new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;memory/new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;&lt;a href=&quot;memory/new/set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bbc9d5a2379fe53e6888d69ff2cfd239b49d1c65" translate="yes" xml:space="preserve">
          <source>Includes e.g. &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory/c/free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">包括例如 &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; ， &lt;code&gt;&lt;a href=&quot;memory/c/free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1e25648908297ca3a4ff1a029bba15e376074f7a" translate="yes" xml:space="preserve">
          <source>Includes first Thursday of the year</source>
          <target state="translated">包括每年的第一个星期四</target>
        </trans-unit>
        <trans-unit id="2effbb73909ece6a25dcb3109ac70345242cea64" translate="yes" xml:space="preserve">
          <source>Includes other source file into current source file at the line immediately after the directive.</source>
          <target state="translated">将其他源文件包含到当前源文件中,在指令后的一行。</target>
        </trans-unit>
        <trans-unit id="28d47aeec93ecafec39966de5877d68ae0fa0071" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; behaves as if it defines a static storage duration object of type &lt;code&gt;&lt;a href=&quot;../io/ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt;, whose constructor initializes the standard stream objects if it is the first &lt;code&gt;std::ios_base::Init&lt;/code&gt; object to be constructed, and whose destructor flushes those objects (except for &lt;code&gt;cin&lt;/code&gt; and &lt;code&gt;wcin&lt;/code&gt;) if it is the last &lt;code&gt;std::ios_base::Init&lt;/code&gt; object to be destroyed.</source>
          <target state="translated">包含 &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; 的行为就像定义了一个 &lt;code&gt;&lt;a href=&quot;../io/ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; 类型的静态存储持续时间对象一样，如果它是要构造的第一个 &lt;code&gt;std::ios_base::Init&lt;/code&gt; 对象，则其构造函数将初始化标准流对象。如果销毁对象是最后一个销毁的 &lt;code&gt;std::ios_base::Init&lt;/code&gt; 对象，则析构函数将刷新这些对象（ &lt;code&gt;cin&lt;/code&gt; 和 &lt;code&gt;wcin&lt;/code&gt; 除外）。</target>
        </trans-unit>
        <trans-unit id="5cd1c15a802ac17b19b885143fcfe2ec21636c5b" translate="yes" xml:space="preserve">
          <source>Including &lt;strong&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/strong&gt; also defines all &lt;a href=&quot;../feature_test#Library_features&quot;&gt;library feature-testing macros&lt;/a&gt;.</source>
          <target state="translated">包括&lt;strong&gt; &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; &lt;/strong&gt;也定义了所有&lt;a href=&quot;../feature_test#Library_features&quot;&gt;库功能测试宏&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1221ac54217af05f258b4f8aa9f00478c543372d" translate="yes" xml:space="preserve">
          <source>Incomparable values are..</source>
          <target state="translated">无与伦比的价值是。</target>
        </trans-unit>
        <trans-unit id="1ab3146cdd793eb63530b9c56d89f5648c4b83e9" translate="yes" xml:space="preserve">
          <source>Incomplete type</source>
          <target state="translated">不完整类型</target>
        </trans-unit>
        <trans-unit id="38e49d07d428f67ddcca69cc70a81d4cae36a937" translate="yes" xml:space="preserve">
          <source>Increase the capacity of the vector to a value that's greater or equal to &lt;code&gt;new_cap&lt;/code&gt;. If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, otherwise the method does nothing.</source>
          <target state="translated">将向量的容量增加到大于或等于 &lt;code&gt;new_cap&lt;/code&gt; 的值。如果 &lt;code&gt;new_cap&lt;/code&gt; 大于当前的Capacity &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; ，则分配新的存储，否则该方法不执行任何操作。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
