<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="633c320407bd275302d618eed24d78f3e652466b" translate="yes" xml:space="preserve">
          <source>Compute the Cholesky factorization of a dense symmetric positive definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Cholesky&lt;/code&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;code&gt;StridedMatrix&lt;/code&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;Cholesky&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt;&lt;code&gt;logdet&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt;&lt;code&gt;isposdef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">计算稠密对称正定矩阵 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;Cholesky&lt;/code&gt; 分解，然后返回Cholesky分解。矩阵 &lt;code&gt;A&lt;/code&gt; 可以是&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; 或&lt;em&gt;完全&lt;/em&gt;对称或Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt; 。可以从分解因子 &lt;code&gt;F&lt;/code&gt; 中获得 &lt;code&gt;F.L&lt;/code&gt; 和 &lt;code&gt;F.U&lt;/code&gt; 从而得出三角形的Cholesky因子。以下功能可用于 &lt;code&gt;Cholesky&lt;/code&gt; 对象：&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;\&lt;/code&gt; ， &lt;code&gt;inv&lt;/code&gt; ，&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#LinearAlgebra.logdet&quot;&gt; &lt;code&gt;logdet&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#LinearAlgebra.isposdef&quot;&gt; &lt;code&gt;isposdef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="bb3253df25b3b67c97f210c72aa2a93261e457fb" translate="yes" xml:space="preserve">
          <source>Compute the Hessenberg decomposition of &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Hessenberg&lt;/code&gt; object. If &lt;code&gt;F&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; (of type &lt;code&gt;LinearAlgebra.HessenbergQ&lt;/code&gt;) and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt; (of type &lt;a href=&quot;#LinearAlgebra.UpperHessenberg&quot;&gt;&lt;code&gt;UpperHessenberg&lt;/code&gt;&lt;/a&gt;), either of which may be converted to a regular matrix with &lt;code&gt;Matrix(F.H)&lt;/code&gt; or &lt;code&gt;Matrix(F.Q)&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的Hessenberg分解并返回 &lt;code&gt;Hessenberg&lt;/code&gt; 对象。如果 &lt;code&gt;F&lt;/code&gt; 是因式分解对象，酉矩阵可与被访问 &lt;code&gt;F.Q&lt;/code&gt; （类型的 &lt;code&gt;LinearAlgebra.HessenbergQ&lt;/code&gt; ），并与海森伯格矩阵 &lt;code&gt;F.H&lt;/code&gt; （类型的&lt;a href=&quot;#LinearAlgebra.UpperHessenberg&quot;&gt; &lt;code&gt;UpperHessenberg&lt;/code&gt; &lt;/a&gt;），其中任一个可被转换成具有规则矩阵 &lt;code&gt;Matrix(F.H)&lt;/code&gt; 或 &lt;code&gt;Matrix(F.Q)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37b962efd94ea393def73078100fff01edd4aab9" translate="yes" xml:space="preserve">
          <source>Compute the Hessenberg decomposition of &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;Hessenberg&lt;/code&gt; object. If &lt;code&gt;F&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt;. When &lt;code&gt;Q&lt;/code&gt; is extracted, the resulting type is the &lt;code&gt;HessenbergQ&lt;/code&gt; object, and may be converted to a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的Hessenberg分解并返回一个 &lt;code&gt;Hessenberg&lt;/code&gt; 对象。如果 &lt;code&gt;F&lt;/code&gt; 是分解对象，则可以使用 &lt;code&gt;F.Q&lt;/code&gt; 访问the矩阵，使用 &lt;code&gt;F.H&lt;/code&gt; 访问Hessenberg矩阵。当 &lt;code&gt;Q&lt;/code&gt; 被提取，将得到的类型是 &lt;code&gt;HessenbergQ&lt;/code&gt; 对象，并且可以被转换为常规矩阵&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt;（或 &lt;code&gt;Array(_)&lt;/code&gt; 的简称）。</target>
        </trans-unit>
        <trans-unit id="832c7202e91f697ee6939cc6a25570d7f86be4c5" translate="yes" xml:space="preserve">
          <source>Compute the LQ decomposition of &lt;code&gt;A&lt;/code&gt;. The decomposition's lower triangular component can be obtained from the &lt;a href=&quot;#LinearAlgebra.LQ&quot;&gt;&lt;code&gt;LQ&lt;/code&gt;&lt;/a&gt; object &lt;code&gt;S&lt;/code&gt; via &lt;code&gt;S.L&lt;/code&gt;, and the orthogonal/unitary component via &lt;code&gt;S.Q&lt;/code&gt;, such that &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的LQ分解。分解的下三角分量可以通过 &lt;code&gt;S.L&lt;/code&gt; 从&lt;a href=&quot;#LinearAlgebra.LQ&quot;&gt; &lt;code&gt;LQ&lt;/code&gt; &lt;/a&gt;对象 &lt;code&gt;S&lt;/code&gt; 获得，通过 &lt;code&gt;S.Q&lt;/code&gt; 从正交//分量获得，从而 &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8d47c5b4fc5ee4331387245803c6326b23b1e354" translate="yes" xml:space="preserve">
          <source>Compute the LQ decomposition of &lt;code&gt;A&lt;/code&gt;. The decomposition's lower triangular component can be obtained from the &lt;code&gt;LQ&lt;/code&gt; object &lt;code&gt;S&lt;/code&gt; via &lt;code&gt;S.L&lt;/code&gt;, and the orthogonal/unitary component via &lt;code&gt;S.Q&lt;/code&gt;, such that &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的LQ分解。分解的下三角分量可以通过 &lt;code&gt;S.L&lt;/code&gt; 从 &lt;code&gt;LQ&lt;/code&gt; 对象 &lt;code&gt;S&lt;/code&gt; 获得，通过 &lt;code&gt;S.Q&lt;/code&gt; 从正交/ unit分量获得，从而 &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="df93c4e3f01a5d5d8938330edf6e69bce8f5f23a" translate="yes" xml:space="preserve">
          <source>Compute the LQ factorization of &lt;code&gt;A&lt;/code&gt;, using the input matrix as a workspace. See also &lt;a href=&quot;#LinearAlgebra.lq&quot;&gt;&lt;code&gt;lq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用输入矩阵作为工作区，计算 &lt;code&gt;A&lt;/code&gt; 的LQ因式分解。另请参见&lt;a href=&quot;#LinearAlgebra.lq&quot;&gt; &lt;code&gt;lq&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f143c0b1e17ec33b003d5d465ed585f1a6c5eeb5" translate="yes" xml:space="preserve">
          <source>Compute the LU factorization of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的LU分解。</target>
        </trans-unit>
        <trans-unit id="f3d2a0b8ede301b8c788fe8d3b8a2900d96315da" translate="yes" xml:space="preserve">
          <source>Compute the LU factorization of a banded matrix &lt;code&gt;AB&lt;/code&gt;. &lt;code&gt;kl&lt;/code&gt; is the first subdiagonal containing a nonzero band, &lt;code&gt;ku&lt;/code&gt; is the last superdiagonal containing one, and &lt;code&gt;m&lt;/code&gt; is the first dimension of the matrix &lt;code&gt;AB&lt;/code&gt;. Returns the LU factorization in-place and &lt;code&gt;ipiv&lt;/code&gt;, the vector of pivots used.</source>
          <target state="translated">计算带状矩阵 &lt;code&gt;AB&lt;/code&gt; 的LU分解。 &lt;code&gt;kl&lt;/code&gt; 是包含非零带的第一个子对角线， &lt;code&gt;ku&lt;/code&gt; 是包含一个非零带的最后一个对角线， &lt;code&gt;m&lt;/code&gt; 是矩阵 &lt;code&gt;AB&lt;/code&gt; 的第一维。返回就地LU分解和 &lt;code&gt;ipiv&lt;/code&gt; （使用的枢轴向量）。</target>
        </trans-unit>
        <trans-unit id="4e85ab4b85e63bda3524cd40490290f9c652abef" translate="yes" xml:space="preserve">
          <source>Compute the Pearson correlation between the vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">计算向量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 之间的皮尔逊相关性。</target>
        </trans-unit>
        <trans-unit id="0c66f895734c2d381a6e7359b9abed2937fd17e4" translate="yes" xml:space="preserve">
          <source>Compute the Pearson correlation between the vectors or matrices &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">计算沿向量 &lt;code&gt;dims&lt;/code&gt; 的向量或矩阵 &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; 之间的Pearson相关性。</target>
        </trans-unit>
        <trans-unit id="74013bf59e1c48e3434f51156a8cd876c94ec658" translate="yes" xml:space="preserve">
          <source>Compute the Pearson correlation matrix of the matrix &lt;code&gt;X&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">计算沿维度 &lt;code&gt;dims&lt;/code&gt; 的矩阵 &lt;code&gt;X&lt;/code&gt; 的Pearson相关矩阵。</target>
        </trans-unit>
        <trans-unit id="eb5aaf9c337f0702d2fe48faff921d16afde5b19" translate="yes" xml:space="preserve">
          <source>Compute the QR factorization of the matrix &lt;code&gt;A&lt;/code&gt;: an orthogonal (or unitary if &lt;code&gt;A&lt;/code&gt; is complex-valued) matrix &lt;code&gt;Q&lt;/code&gt;, and an upper triangular matrix &lt;code&gt;R&lt;/code&gt; such that</source>
          <target state="translated">计算矩阵 &lt;code&gt;A&lt;/code&gt; 的QR分解：正交（如果 &lt;code&gt;A&lt;/code&gt; 为复数，则为unit）矩阵 &lt;code&gt;Q&lt;/code&gt; 和上三角矩阵 &lt;code&gt;R&lt;/code&gt; ，使得</target>
        </trans-unit>
        <trans-unit id="9f4fb449517dd4a253bcd016046b2c39cd6be49f" translate="yes" xml:space="preserve">
          <source>Compute the amount of memory, in bytes, used by all unique objects reachable from the argument.</source>
          <target state="translated">计算从参数中可以到达的所有唯一对象所使用的内存量,以字节为单位。</target>
        </trans-unit>
        <trans-unit id="ef14f4c033588439c9734666e7f662db33797d38" translate="yes" xml:space="preserve">
          <source>Compute the base 10 exponential of &lt;code&gt;x&lt;/code&gt;, in other words $10^x$.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的基数10的指数，即$ 10 ^ x $。</target>
        </trans-unit>
        <trans-unit id="5996a7911dbb75d459bb57880857b6c285fdb533" translate="yes" xml:space="preserve">
          <source>Compute the base 2 exponential of &lt;code&gt;x&lt;/code&gt;, in other words $2^x$.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的以2为底的指数，即$ 2 ^ x $。</target>
        </trans-unit>
        <trans-unit id="794534f25f9e8868116d7dccbee753ad76971472" translate="yes" xml:space="preserve">
          <source>Compute the base &lt;code&gt;b&lt;/code&gt; logarithm of &lt;code&gt;x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的底 &lt;code&gt;b&lt;/code&gt; 对数。为负的&lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;参数抛出&lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c05a16a74adde544da95df4e78617f63f96f27db" translate="yes" xml:space="preserve">
          <source>Compute the blocked &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;T&lt;/code&gt; contains upper triangular block reflectors which parameterize the elementary reflectors of the factorization. The first dimension of &lt;code&gt;T&lt;/code&gt; sets the block size and it must be between 1 and &lt;code&gt;n&lt;/code&gt;. The second dimension of &lt;code&gt;T&lt;/code&gt; must equal the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的阻塞 &lt;code&gt;QR&lt;/code&gt; 分解， &lt;code&gt;A = QR&lt;/code&gt; 。 &lt;code&gt;T&lt;/code&gt; 包含上三角块反射器，这些反射器参数化分解的基本反射器。 &lt;code&gt;T&lt;/code&gt; 的第一维设置块大小，并且必须在1到 &lt;code&gt;n&lt;/code&gt; 之间。 &lt;code&gt;T&lt;/code&gt; 的第二维必须等于 &lt;code&gt;A&lt;/code&gt; 的最小维。</target>
        </trans-unit>
        <trans-unit id="9b0cbb0565d1b4a03a96f69b70d2c66787700aa8" translate="yes" xml:space="preserve">
          <source>Compute the blocked &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = QR&lt;/code&gt;. &lt;code&gt;nb&lt;/code&gt; sets the block size and it must be between 1 and &lt;code&gt;n&lt;/code&gt;, the second dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的阻塞 &lt;code&gt;QR&lt;/code&gt; 分解， &lt;code&gt;A = QR&lt;/code&gt; 。 &lt;code&gt;nb&lt;/code&gt; 设置块大小，并且必须在1和 &lt;code&gt;n&lt;/code&gt; 之间（ &lt;code&gt;A&lt;/code&gt; 的第二维）。</target>
        </trans-unit>
        <trans-unit id="64fc87785de1b25c447a6d57734a1583aa8fc760" translate="yes" xml:space="preserve">
          <source>Compute the complex conjugate of a complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">计算复数 &lt;code&gt;z&lt;/code&gt; 的复共轭。</target>
        </trans-unit>
        <trans-unit id="d952ac0269ec6a898fc99a4c73f9f0fa2cddbcd5" translate="yes" xml:space="preserve">
          <source>Compute the cosecant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的余割值，其中 &lt;code&gt;x&lt;/code&gt; 以度为单位。</target>
        </trans-unit>
        <trans-unit id="cd18d2a4efe3c5ddd8da80eadb7eb93b647e38fb" translate="yes" xml:space="preserve">
          <source>Compute the cosecant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的余割，其中 &lt;code&gt;x&lt;/code&gt; 以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="7c34352434165644e17d3d3c3017b1efac79a034" translate="yes" xml:space="preserve">
          <source>Compute the cotangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的余切，其中 &lt;code&gt;x&lt;/code&gt; 以度为单位。</target>
        </trans-unit>
        <trans-unit id="51e33b4564608050a8442490630344d272d7cb6a" translate="yes" xml:space="preserve">
          <source>Compute the cotangent of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的余切，其中 &lt;code&gt;x&lt;/code&gt; 以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="ced199cab7b78dc4018b6d349c2fddeae611b20a" translate="yes" xml:space="preserve">
          <source>Compute the covariance between the vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), computes $\frac{1}{n-1}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$ where $*$ denotes the complex conjugate and &lt;code&gt;n = length(x) = length(y)&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, computes $\frac{1}{n}\sum_{i=1}^n (x_i-\bar x) (y_i-\bar y)^*$.</source>
          <target state="translated">计算向量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 之间的协方差。如果 &lt;code&gt;corrected&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; （默认值），则计算$ \ frac {1} {n-1} \ sum_ {i = 1} ^ n（x_i- \ bar x）（y_i- \ bar y）^ * $其中$ * $表示复共轭， &lt;code&gt;n = length(x) = length(y)&lt;/code&gt; 。如果 &lt;code&gt;corrected&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则计算$ \ frac {1} {n} \ sum_ {i = 1} ^ n（x_i- \ bar x）（y_i- \ bar y）^ * $。</target>
        </trans-unit>
        <trans-unit id="2c939998715a4bc32623fd5d4a50f59b83b9bf7e" translate="yes" xml:space="preserve">
          <source>Compute the covariance between the vectors or matrices &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default) then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n = size(X, dims) = size(Y, dims)&lt;/code&gt;.</source>
          <target state="translated">计算矢量或矩阵 &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; 沿维度 &lt;code&gt;dims&lt;/code&gt; 的协方差。如果 &lt;code&gt;corrected&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; （默认值），则将以 &lt;code&gt;n-1&lt;/code&gt; 缩放该总和，而如果 &lt;code&gt;corrected&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则以 &lt;code&gt;n&lt;/code&gt; 缩放该总和，其中 &lt;code&gt;n = size(X, dims) = size(Y, dims)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c149665bdfebe0f49b37ac0ad2f4069a8c615ef5" translate="yes" xml:space="preserve">
          <source>Compute the covariance matrix of the matrix &lt;code&gt;X&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default) then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n = size(X, dims)&lt;/code&gt;.</source>
          <target state="translated">计算沿维度 &lt;code&gt;dims&lt;/code&gt; 的矩阵 &lt;code&gt;X&lt;/code&gt; 的协方差矩阵。如果 &lt;code&gt;corrected&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; （默认值），则将总和缩放为 &lt;code&gt;n-1&lt;/code&gt; ，而如果 &lt;code&gt;corrected&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则将缩放总和为 &lt;code&gt;n&lt;/code&gt; ，其中 &lt;code&gt;n = size(X, dims)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="410468f3561472f97b5b13876570709e80fe55b0" translate="yes" xml:space="preserve">
          <source>Compute the cross product of two 3-vectors.</source>
          <target state="translated">计算两个3向量的交积。</target>
        </trans-unit>
        <trans-unit id="50f5c17779b906283ea9fd2a34268ff40e2ded97" translate="yes" xml:space="preserve">
          <source>Compute the dot product between two vectors. For complex vectors, the first vector is conjugated.</source>
          <target state="translated">计算两个向量之间的点积。对于复数向量,第一个向量是共轭的。</target>
        </trans-unit>
        <trans-unit id="98027b7e04b6a89188be633c36e298c811c2a981" translate="yes" xml:space="preserve">
          <source>Compute the dot product between two vectors. For complex vectors, the first vector is conjugated. When the vectors have equal lengths, calling &lt;code&gt;dot&lt;/code&gt; is semantically equivalent to &lt;code&gt;sum(dot(vx,vy) for (vx,vy) in zip(x, y))&lt;/code&gt;.</source>
          <target state="translated">计算两个向量之间的点积。对于复数向量，第一个向量是共轭的。当向量的长度相等时，调用 &lt;code&gt;dot&lt;/code&gt; 在语义上等效 &lt;code&gt;sum(dot(vx,vy) for (vx,vy) in zip(x, y))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9c700743247c39eb6f20b3363175a4f35bc60b4" translate="yes" xml:space="preserve">
          <source>Compute the element type &lt;code&gt;R&lt;/code&gt; of the result matrix as &lt;code&gt;promote_op(op, argument_types...)&lt;/code&gt;, where &lt;code&gt;argument_types&lt;/code&gt; is computed from &lt;code&gt;eltype&lt;/code&gt; applied to each input array.</source>
          <target state="translated">将结果矩阵的元素类型 &lt;code&gt;R&lt;/code&gt; 计算为 &lt;code&gt;promote_op(op, argument_types...)&lt;/code&gt; ，其中 &lt;code&gt;argument_types&lt;/code&gt; 是根据应用于每个输入数组的 &lt;code&gt;eltype&lt;/code&gt; 计算的。</target>
        </trans-unit>
        <trans-unit id="a5e99cc7945246d96ba9d45a1ee951b06e431e6d" translate="yes" xml:space="preserve">
          <source>Compute the generalized SVD of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, returning a &lt;code&gt;GeneralizedSVD&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt; such that &lt;code&gt;[A;B] = [F.U * F.D1; F.V * F.D2] * F.R0 * F.Q'&lt;/code&gt;</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的广义SVD ，返回一个 &lt;code&gt;GeneralizedSVD&lt;/code&gt; 分解对象 &lt;code&gt;F&lt;/code&gt; ，使得 &lt;code&gt;[A;B] = [F.U * F.D1; F.V * F.D2] * F.R0 * F.Q'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eac1c8c9c47e0c367d8a880554c5ea2773fbaa1d" translate="yes" xml:space="preserve">
          <source>Compute the generalized SVD of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, returning a &lt;code&gt;GeneralizedSVD&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt;, such that &lt;code&gt;A = F.U*F.D1*F.R0*F.Q'&lt;/code&gt; and &lt;code&gt;B = F.V*F.D2*F.R0*F.Q'&lt;/code&gt;.</source>
          <target state="translated">计算的广义SVD &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ，返回一个 &lt;code&gt;GeneralizedSVD&lt;/code&gt; 因式分解对象 &lt;code&gt;F&lt;/code&gt; ，使得 &lt;code&gt;A = F.U*F.D1*F.R0*F.Q'&lt;/code&gt; 和 &lt;code&gt;B = F.V*F.D2*F.R0*F.Q'&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2376ee0de00bcc15fd5a97c34b5145b4bf2e681" translate="yes" xml:space="preserve">
          <source>Compute the hyperbolic cosecant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的双曲余割值。</target>
        </trans-unit>
        <trans-unit id="9455f097ec080dbde6000f4b95c5aceb54405acc" translate="yes" xml:space="preserve">
          <source>Compute the hyperbolic cotangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的双曲余切。</target>
        </trans-unit>
        <trans-unit id="7ee2c83b64cf586a8d935df80877c1c53e0f63b8" translate="yes" xml:space="preserve">
          <source>Compute the hyperbolic secant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的双曲正割。</target>
        </trans-unit>
        <trans-unit id="c63e0fdffcada240fd739cc4ae974531cb4e6771" translate="yes" xml:space="preserve">
          <source>Compute the hypotenuse $\sqrt{\sum x_i^2}$ avoiding overflow and underflow.</source>
          <target state="translated">计算下位数$sqrt{sum x_i^2}$,避免溢出和漏出。</target>
        </trans-unit>
        <trans-unit id="064403ddc739fce0bb7520a4d1a9cfee6aa44aa6" translate="yes" xml:space="preserve">
          <source>Compute the hypotenuse $\sqrt{\sum |x_i|^2}$ avoiding overflow and underflow.</source>
          <target state="translated">计算下位$sqrt{sum |x_i|^2}$避免溢出和不足。</target>
        </trans-unit>
        <trans-unit id="a98476342e9a32121a3857c0c73120ddc38a7b27" translate="yes" xml:space="preserve">
          <source>Compute the hypotenuse $\sqrt{x^2+y^2}$ avoiding overflow and underflow.</source>
          <target state="translated">计算下式$sqrt{x^2+y^2}$避免溢出和不足。</target>
        </trans-unit>
        <trans-unit id="6fa5e00480bf665715babd0683ebbea6a30f06ab" translate="yes" xml:space="preserve">
          <source>Compute the hypotenuse $\sqrt{|x|^2+|y|^2}$ avoiding overflow and underflow.</source>
          <target state="translated">计算hypotenuse $sqrt{|x|^2+|y|^2}$避免溢出和不足。</target>
        </trans-unit>
        <trans-unit id="633ceda325459007865758a0c25ca9ff5d40d330" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosecant of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反余割，其中输出以度为单位。</target>
        </trans-unit>
        <trans-unit id="61c956ce405ed17444d2a843c6e0034449650e02" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosecant of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反余割，其中输出以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="b165af691a25cf7a4fe5189a3bdc95cf5605956a" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosine of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反余弦值，其中输出以度为单位。</target>
        </trans-unit>
        <trans-unit id="624b23e348273fc6630a3591e94b2278279c23b8" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosine of &lt;code&gt;x&lt;/code&gt;, where the output is in radians</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反余弦值，其中输出以弧度为单位</target>
        </trans-unit>
        <trans-unit id="6fc169a99667ef032612c7df05b276f67e73ab85" translate="yes" xml:space="preserve">
          <source>Compute the inverse cotangent of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反余切，其中输出以度为单位。</target>
        </trans-unit>
        <trans-unit id="cb2d41805a6658a7aa65e9db45a5f7a00e95b62d" translate="yes" xml:space="preserve">
          <source>Compute the inverse cotangent of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反余切值，其中输出以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="56d719cec6115d223ee7db48c9f3e019d2461e57" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic cosecant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反双曲余割值。</target>
        </trans-unit>
        <trans-unit id="807f8ee5256662d4c4cbc7f7b897c32dc8916b59" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic cosine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反双曲余弦值。</target>
        </trans-unit>
        <trans-unit id="7ae3e0a4e6d92870c3f1d2c212c4b9c31c707de7" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic cotangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反双曲余切。</target>
        </trans-unit>
        <trans-unit id="24d6944fdad3a15f1f900ff184e7c611309535a4" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_4&quot;&gt;[AH16_4]&lt;/a&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的反双曲矩阵余弦。有关用于计算此函数的理论和对数公式，请参见&lt;a href=&quot;#footnote-AH16_4&quot;&gt;[AH16_4]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4219876898544bb4f1d59746a8e545f1892d5a15" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_4&quot; id=&quot;citeref-AH16_4&quot;&gt;[AH16_4]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的反双曲矩阵余弦值。有关用于计算此函数的理论和对数公式，请参见&lt;sup&gt;&lt;a href=&quot;#footnote-AH16_4&quot; id=&quot;citeref-AH16_4&quot;&gt;[AH16_4]&lt;/a&gt;&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="86cfc43a5a6c82e16a0bd6ad0cee64c1039344e2" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_5&quot;&gt;[AH16_5]&lt;/a&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的反双曲矩阵正弦。有关用于计算此函数的理论和对数公式，请参见&lt;a href=&quot;#footnote-AH16_5&quot;&gt;[AH16_5]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5d69bf2784fba7079c9cbc6215616dcb27bb6831" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_5&quot; id=&quot;citeref-AH16_5&quot;&gt;[AH16_5]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的反双曲矩阵正弦。有关用于计算此函数的理论和对数公式，请参见&lt;sup&gt;&lt;a href=&quot;#footnote-AH16_5&quot; id=&quot;citeref-AH16_5&quot;&gt;[AH16_5]&lt;/a&gt;&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="1eaeedca65b3a8c87db844333fb8c7c021c9424a" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_6&quot;&gt;[AH16_6]&lt;/a&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的反双曲矩阵切线。有关用于计算此函数的理论和对数公式，请参见&lt;a href=&quot;#footnote-AH16_6&quot;&gt;[AH16_6]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ac58e60f5d54bf8f91bdf125d9d491d07c8ca13f" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_6&quot; id=&quot;citeref-AH16_6&quot;&gt;[AH16_6]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的反双曲矩阵切线。有关用于计算此函数的理论和对数公式，请参见&lt;sup&gt;&lt;a href=&quot;#footnote-AH16_6&quot; id=&quot;citeref-AH16_6&quot;&gt;[AH16_6]&lt;/a&gt;&lt;/sup&gt;。</target>
        </trans-unit>
        <trans-unit id="139740116ef333d8f7864bd3d0441f3f0ed81cae" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic secant of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反双曲正割。</target>
        </trans-unit>
        <trans-unit id="b5e848138576f12626bbb3a4e1203f85a4ca3a1b" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic sine of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反双曲正弦值。</target>
        </trans-unit>
        <trans-unit id="680c3b04c05aca283c4622eb58afd6457ddd9b27" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic tangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反双曲正切值。</target>
        </trans-unit>
        <trans-unit id="7c3a4c0cd5ecc1b9593ac0007373302db1fa6ec3" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix cosecant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的逆矩阵余割。</target>
        </trans-unit>
        <trans-unit id="d3c09cfcbaeb41a964e5eeda8044692db13c2de8" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的逆矩阵余弦。</target>
        </trans-unit>
        <trans-unit id="554fe6fb73f3b08cce5a611c6a50f4a680bb3671" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix cotangent of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的逆矩阵余切。</target>
        </trans-unit>
        <trans-unit id="0dd96c344ce6aeba2faf61b21fc85774face313f" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix hyperbolic cosecant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算的逆矩阵双曲余割 &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="13b94345110fabe0d3fb8e21298e94148893c47e" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix hyperbolic cotangent of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算的逆矩阵双曲余切 &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47dc0db5a1205ee0f8a515dc40cd98df08f88bcc" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix hyperbolic secant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算的逆矩阵双曲正割 &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0b63a7a4eb8f986033eb32a665b6e261954bb34" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix secant of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的逆矩阵割线。</target>
        </trans-unit>
        <trans-unit id="c5c87fce98f598dba189efeff4428b7d6efd962b" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的逆矩阵正弦。</target>
        </trans-unit>
        <trans-unit id="82438e829448e338f5716124a7ced92061d94948" translate="yes" xml:space="preserve">
          <source>Compute the inverse matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的逆矩阵切线。</target>
        </trans-unit>
        <trans-unit id="f8fcadcd9398201528e6c6c31d135192b6517aa0" translate="yes" xml:space="preserve">
          <source>Compute the inverse secant of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反割线，其中输出以度为单位。</target>
        </trans-unit>
        <trans-unit id="3181cd6c2abdb611f89e0ecf6a62739daf49359f" translate="yes" xml:space="preserve">
          <source>Compute the inverse secant of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反正割，其输出以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="40ba1792c624de0cb1dfc33c8587d7b068c312b3" translate="yes" xml:space="preserve">
          <source>Compute the inverse sine of &lt;code&gt;x&lt;/code&gt;, where the output is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反正弦值，其中输出以度为单位。</target>
        </trans-unit>
        <trans-unit id="2c89d82e75f63a6879bfb124e5439e8f554c18b2" translate="yes" xml:space="preserve">
          <source>Compute the inverse sine of &lt;code&gt;x&lt;/code&gt;, where the output is in radians.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的反正弦，其中输出以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="dea1f25c8cdb21558fa421f817fc4803838604fc" translate="yes" xml:space="preserve">
          <source>Compute the inverse tangent of &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;y/x&lt;/code&gt;, respectively, where the output is in degrees.</source>
          <target state="translated">分别计算 &lt;code&gt;y&lt;/code&gt; 或 &lt;code&gt;y/x&lt;/code&gt; 的反正切，其中输出以度为单位。</target>
        </trans-unit>
        <trans-unit id="84e255dd37fccaa6c9024b56e1a156bcddadf711" translate="yes" xml:space="preserve">
          <source>Compute the inverse tangent of &lt;code&gt;y&lt;/code&gt; or &lt;code&gt;y/x&lt;/code&gt;, respectively.</source>
          <target state="translated">分别计算 &lt;code&gt;y&lt;/code&gt; 或 &lt;code&gt;y/x&lt;/code&gt; 的反正切。</target>
        </trans-unit>
        <trans-unit id="a437409e4208929c05cf3a26d531c19399ac90c7" translate="yes" xml:space="preserve">
          <source>Compute the logarithm of &lt;code&gt;x&lt;/code&gt; to base 10. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 的对数计算为以10为底。将&lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt;用作负的&lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;参数。</target>
        </trans-unit>
        <trans-unit id="307aa19b57a1c93393b9992c4bb9222fbeb6d69a" translate="yes" xml:space="preserve">
          <source>Compute the logarithm of &lt;code&gt;x&lt;/code&gt; to base 2. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 的对数计算为以2为底。将&lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt;用作负的&lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;参数。</target>
        </trans-unit>
        <trans-unit id="357c0e09927961e89f5147d19aac01380699c99b" translate="yes" xml:space="preserve">
          <source>Compute the matrix cosecant of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵余割。</target>
        </trans-unit>
        <trans-unit id="8e5fa0eb0776b403f81e8ca8ffdd49ca084bc0cf" translate="yes" xml:space="preserve">
          <source>Compute the matrix cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵余弦。</target>
        </trans-unit>
        <trans-unit id="4a3d2174cd407b931afd89c4da677e682e83eb75" translate="yes" xml:space="preserve">
          <source>Compute the matrix cotangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵余切。</target>
        </trans-unit>
        <trans-unit id="a0d7c646de45ee9b8c08cbdbcbbbe4ae72a7e16e" translate="yes" xml:space="preserve">
          <source>Compute the matrix exponential of &lt;code&gt;A&lt;/code&gt;, defined by</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的矩阵指数，由</target>
        </trans-unit>
        <trans-unit id="1fd954e6ff4d674cda87b743aa2b1233b9a2eb54" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic cosecant of square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵双曲余割。</target>
        </trans-unit>
        <trans-unit id="38b827146b68bcb3a9319674be38c266cf7e7f83" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵双曲余弦值。</target>
        </trans-unit>
        <trans-unit id="110c3b9acb774724db674308a4bcde13d16b14d6" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic cotangent of square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵双曲余切。</target>
        </trans-unit>
        <trans-unit id="6d0510bcda1371513244fd5ba762aa98507b53bb" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic secant of square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵双曲正割。</target>
        </trans-unit>
        <trans-unit id="69f5be6dce72711b7e92f9794c37163a41bcaec9" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic sine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵双曲正弦值。</target>
        </trans-unit>
        <trans-unit id="68030614e2cc86a2f04214ee54bc242637c1d83e" translate="yes" xml:space="preserve">
          <source>Compute the matrix hyperbolic tangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵双曲正切。</target>
        </trans-unit>
        <trans-unit id="a49ce1d636974c76079f6e75f270fb5680236ccd" translate="yes" xml:space="preserve">
          <source>Compute the matrix secant of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵正割。</target>
        </trans-unit>
        <trans-unit id="8537b2719b34f9b953a571d36d5cd503fc126fb6" translate="yes" xml:space="preserve">
          <source>Compute the matrix sine and cosine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵正弦和余弦。</target>
        </trans-unit>
        <trans-unit id="c790b1bd7335f67a22b7547277d010ba0a9f3b0b" translate="yes" xml:space="preserve">
          <source>Compute the matrix sine of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵正弦。</target>
        </trans-unit>
        <trans-unit id="778966213f7c95c7b1093b4b2daad349ac3b974d" translate="yes" xml:space="preserve">
          <source>Compute the matrix tangent of a square matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算平方矩阵 &lt;code&gt;A&lt;/code&gt; 的矩阵切线。</target>
        </trans-unit>
        <trans-unit id="9eb474e2115ce973af39e55c69108d56b7159747" translate="yes" xml:space="preserve">
          <source>Compute the maximum value of &lt;code&gt;A&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;r&lt;/code&gt; 的单调维度上 &lt;code&gt;A&lt;/code&gt; 的最大值，并将结果写入 &lt;code&gt;r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="812480b7cd3cf22547511e3adad6b33995a9beff" translate="yes" xml:space="preserve">
          <source>Compute the maximum value of an array over the given dimensions. See also the &lt;a href=&quot;../math/index#Base.max&quot;&gt;&lt;code&gt;max(a,b)&lt;/code&gt;&lt;/a&gt; function to take the maximum of two or more arguments, which can be applied elementwise to arrays via &lt;code&gt;max.(a,b)&lt;/code&gt;.</source>
          <target state="translated">计算给定维度上数组的最大值。另请参见&lt;a href=&quot;../math/index#Base.max&quot;&gt; &lt;code&gt;max(a,b)&lt;/code&gt; &lt;/a&gt;函数以采用两个或多个参数中的最大值，可以通过 &lt;code&gt;max.(a,b)&lt;/code&gt; 将其逐个应用于数组。</target>
        </trans-unit>
        <trans-unit id="9a9b9b399a0d3918c3f6e362f2833628ccc71a99" translate="yes" xml:space="preserve">
          <source>Compute the mean of &lt;code&gt;v&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;r&lt;/code&gt; 的单调维上计算 &lt;code&gt;v&lt;/code&gt; 的平均值，并将结果写入 &lt;code&gt;r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="11000a28bead3ac6f75bf9a14466e14072624576" translate="yes" xml:space="preserve">
          <source>Compute the mean of all elements in a collection.</source>
          <target state="translated">计算一个集合中所有元素的平均值。</target>
        </trans-unit>
        <trans-unit id="99f6794cd06dba199884516b785bda4fd78aa2a1" translate="yes" xml:space="preserve">
          <source>Compute the mean of an array over the given dimensions.</source>
          <target state="translated">计算一个数组在给定维度上的平均值。</target>
        </trans-unit>
        <trans-unit id="f41aac2dc5d7c7dc8f7a1f9ae372c9c476523577" translate="yes" xml:space="preserve">
          <source>Compute the median of all elements in a collection. For an even number of elements no exact median element exists, so the result is equivalent to calculating mean of two median elements.</source>
          <target state="translated">计算一个集合中所有元素的中位数。对于偶数元素,不存在精确的中位数元素,所以结果相当于计算两个中位数元素的平均值。</target>
        </trans-unit>
        <trans-unit id="47aa9c53937737d70bd22425272809e6211e7bf6" translate="yes" xml:space="preserve">
          <source>Compute the median of an array along the given dimensions.</source>
          <target state="translated">沿着给定的维度计算一个数组的中位数。</target>
        </trans-unit>
        <trans-unit id="2c99652c33628269108c328437953d38055c5886" translate="yes" xml:space="preserve">
          <source>Compute the middle of a range, which consists of computing the mean of its extrema. Since a range is sorted, the mean is performed with the first and last element.</source>
          <target state="translated">计算一个范围的中间值,包括计算其极值的平均值。由于一个范围是排序的,所以平均数是以第一个和最后一个元素来计算的。</target>
        </trans-unit>
        <trans-unit id="f52205089fbf6d58facb1bdb9b160b88b107a323" translate="yes" xml:space="preserve">
          <source>Compute the middle of a scalar value, which is equivalent to &lt;code&gt;x&lt;/code&gt; itself, but of the type of &lt;code&gt;middle(x, x)&lt;/code&gt; for consistency.</source>
          <target state="translated">计算一个标量值的中间值，该值等于 &lt;code&gt;x&lt;/code&gt; 本身，但是为保持一致性而使用 &lt;code&gt;middle(x, x)&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="acf08f804a346435085af253987f1d511b1a7d4c" translate="yes" xml:space="preserve">
          <source>Compute the middle of an array &lt;code&gt;a&lt;/code&gt;, which consists of finding its extrema and then computing their mean.</source>
          <target state="translated">计算数组 &lt;code&gt;a&lt;/code&gt; 的中间，包括找到其极值，然后计算其均值。</target>
        </trans-unit>
        <trans-unit id="f0245cd1be7817ce631eac5c33e8ccdf05cebd05" translate="yes" xml:space="preserve">
          <source>Compute the middle of two reals &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, which is equivalent in both value and type to computing their mean (&lt;code&gt;(x + y) / 2&lt;/code&gt;).</source>
          <target state="translated">计算两个实数 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的中间值，这两个值和类型均等于计算它们的均值（ &lt;code&gt;(x + y) / 2&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="949e7136a76fe46a6048f43ad9bc9f806861c7ea" translate="yes" xml:space="preserve">
          <source>Compute the minimum and maximum elements of an array over the given dimensions.</source>
          <target state="translated">计算一个数组中给定维度的最小和最大元素。</target>
        </trans-unit>
        <trans-unit id="0d93ec1caffd4ccc7c3361a7c270c2d973854682" translate="yes" xml:space="preserve">
          <source>Compute the minimum and maximum of &lt;code&gt;f&lt;/code&gt; applied to each element in the given dimensions of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算在给定的 &lt;code&gt;A&lt;/code&gt; 维度中应用于每个元素的 &lt;code&gt;f&lt;/code&gt; 的最小值和最大值。</target>
        </trans-unit>
        <trans-unit id="82e7ee5156f49d8db2d03ced16867f73d00a142d" translate="yes" xml:space="preserve">
          <source>Compute the minimum value of &lt;code&gt;A&lt;/code&gt; over the singleton dimensions of &lt;code&gt;r&lt;/code&gt;, and write results to &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;r&lt;/code&gt; 的单调维上 &lt;code&gt;A&lt;/code&gt; 的最小值，并将结果写入 &lt;code&gt;r&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed6b522c97de9bddde22add7ab86b59b7c15f878" translate="yes" xml:space="preserve">
          <source>Compute the minimum value of an array over the given dimensions. See also the &lt;a href=&quot;../math/index#Base.min&quot;&gt;&lt;code&gt;min(a,b)&lt;/code&gt;&lt;/a&gt; function to take the minimum of two or more arguments, which can be applied elementwise to arrays via &lt;code&gt;min.(a,b)&lt;/code&gt;.</source>
          <target state="translated">计算给定维度上数组的最小值。另请参见&lt;a href=&quot;../math/index#Base.min&quot;&gt; &lt;code&gt;min(a,b)&lt;/code&gt; &lt;/a&gt;函数以采用两个或多个参数中的最小值，可以通过 &lt;code&gt;min.(a,b)&lt;/code&gt; 将其逐个应用于数组。</target>
        </trans-unit>
        <trans-unit id="fc7ac1e0e474d1b1a9d181c27f50c39ecd473625" translate="yes" xml:space="preserve">
          <source>Compute the natural base exponential of &lt;code&gt;x&lt;/code&gt;, in other words $e^x$.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的自然基指数，即$ e ^ x $。</target>
        </trans-unit>
        <trans-unit id="ff348abb57d70ef01b2fee18c2e56b5e9c90ef5b" translate="yes" xml:space="preserve">
          <source>Compute the natural logarithm of &lt;code&gt;x&lt;/code&gt;. Throws &lt;a href=&quot;../base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; for negative &lt;a href=&quot;../numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; arguments. Use complex negative arguments to obtain complex results.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的自然对数。为负的&lt;a href=&quot;../numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;参数抛出&lt;a href=&quot;../base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt;。使用复杂的否定参数可获得复杂的结果。</target>
        </trans-unit>
        <trans-unit id="d39d60a66827c670830ca96a819f42207f21a2dd" translate="yes" xml:space="preserve">
          <source>Compute the number of digits in integer &lt;code&gt;n&lt;/code&gt; written in base &lt;code&gt;base&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; must not be in &lt;code&gt;[-1, 0, 1]&lt;/code&gt;), optionally padded with zeros to a specified size (the result will never be less than &lt;code&gt;pad&lt;/code&gt;).</source>
          <target state="translated">计算以base为 &lt;code&gt;base&lt;/code&gt; 整数 &lt;code&gt;n&lt;/code&gt; 的位数（ &lt;code&gt;base&lt;/code&gt; 不能为 &lt;code&gt;[-1, 0, 1]&lt;/code&gt; ），可以选择用零填充到指定的大小（结果永远不会小于 &lt;code&gt;pad&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cdf0b4d7ddc06f4032604ad606ae2fa5da2f3e57" translate="yes" xml:space="preserve">
          <source>Compute the operator norm (or matrix norm) induced by the vector &lt;code&gt;p&lt;/code&gt;-norm, where valid values of &lt;code&gt;p&lt;/code&gt; are &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;Inf&lt;/code&gt;. (Note that for sparse matrices, &lt;code&gt;p=2&lt;/code&gt; is currently not implemented.) Use &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; to compute the Frobenius norm.</source>
          <target state="translated">计算由矢量引起的算子范数（或矩阵范数） &lt;code&gt;p&lt;/code&gt; 范数，其中的有效值 &lt;code&gt;p&lt;/code&gt; 是 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; ，或 &lt;code&gt;Inf&lt;/code&gt; 文件。（请注意，对于稀疏矩阵，当前未实现 &lt;code&gt;p=2&lt;/code&gt; 。）使用&lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt;来计算Frobenius范数。</target>
        </trans-unit>
        <trans-unit id="875c419b65242063b15574011e9a9ebe51310e17" translate="yes" xml:space="preserve">
          <source>Compute the phase angle in radians of a complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">计算复数 &lt;code&gt;z&lt;/code&gt; 的弧度相位角。</target>
        </trans-unit>
        <trans-unit id="f2bfc336c71f0f166834e6af3305ab8164da5ce4" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;LU&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = LU&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的枢轴 &lt;code&gt;LU&lt;/code&gt; 分解， &lt;code&gt;A = LU&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b0d34ac6dfa1e6722e524c60e67afe891d8e958d" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3.</source>
          <target state="translated">使用BLAS级别3 计算 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;AP = QR&lt;/code&gt; 的旋转 &lt;code&gt;QR&lt;/code&gt; 分解。</target>
        </trans-unit>
        <trans-unit id="f61896259e546ab5dfa4229a9ef0511c5d923d39" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3. &lt;code&gt;P&lt;/code&gt; is a pivoting matrix, represented by &lt;code&gt;jpvt&lt;/code&gt;. &lt;code&gt;jpvt&lt;/code&gt; must have length greater than or equal to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;(m x n)&lt;/code&gt; matrix.</source>
          <target state="translated">计算转动 &lt;code&gt;QR&lt;/code&gt; 的因式分解 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;AP = QR&lt;/code&gt; 使用BLAS级别3 &lt;code&gt;P&lt;/code&gt; 是枢转矩阵，由下式表示 &lt;code&gt;jpvt&lt;/code&gt; 。如果 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;(m x n)&lt;/code&gt; 矩阵，则 &lt;code&gt;jpvt&lt;/code&gt; 的长度必须大于或等于 &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67444724cffb3267e5fd7af13f87a5b4b21f933f" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3. &lt;code&gt;P&lt;/code&gt; is a pivoting matrix, represented by &lt;code&gt;jpvt&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; stores the elementary reflectors. &lt;code&gt;jpvt&lt;/code&gt; must have length length greater than or equal to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;(m x n)&lt;/code&gt; matrix. &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算转动 &lt;code&gt;QR&lt;/code&gt; 的因式分解 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;AP = QR&lt;/code&gt; 使用BLAS级别3 &lt;code&gt;P&lt;/code&gt; 是枢转矩阵，由下式表示 &lt;code&gt;jpvt&lt;/code&gt; 。 &lt;code&gt;tau&lt;/code&gt; 存储基本反射器。如果 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;(m x n)&lt;/code&gt; 矩阵，则 &lt;code&gt;jpvt&lt;/code&gt; 的长度长度必须大于或等于 &lt;code&gt;n&lt;/code&gt; 。 &lt;code&gt;tau&lt;/code&gt; 的长度必须大于或等于 &lt;code&gt;A&lt;/code&gt; 的最小尺寸。</target>
        </trans-unit>
        <trans-unit id="c597ab7f1b620fda0abef71fc126c9801e72086f" translate="yes" xml:space="preserve">
          <source>Compute the pivoted &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;AP = QR&lt;/code&gt; using BLAS level 3. &lt;code&gt;P&lt;/code&gt; is a pivoting matrix, represented by &lt;code&gt;jpvt&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; stores the elementary reflectors. The arguments &lt;code&gt;jpvt&lt;/code&gt; and &lt;code&gt;tau&lt;/code&gt; are optional and allow for passing preallocated arrays. When passed, &lt;code&gt;jpvt&lt;/code&gt; must have length greater than or equal to &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;A&lt;/code&gt; is an &lt;code&gt;(m x n)&lt;/code&gt; matrix and &lt;code&gt;tau&lt;/code&gt; must have length greater than or equal to the smallest dimension of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">计算转动 &lt;code&gt;QR&lt;/code&gt; 的因式分解 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;AP = QR&lt;/code&gt; 使用BLAS级别3 &lt;code&gt;P&lt;/code&gt; 是枢转矩阵，由下式表示 &lt;code&gt;jpvt&lt;/code&gt; 。 &lt;code&gt;tau&lt;/code&gt; 存储基本反射器。参数 &lt;code&gt;jpvt&lt;/code&gt; 和 &lt;code&gt;tau&lt;/code&gt; 是可选的，并允许传递预分配的数组。通过时，如果 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;(m x n)&lt;/code&gt; 矩阵，则 &lt;code&gt;jpvt&lt;/code&gt; 的长度必须大于或等于 &lt;code&gt;n&lt;/code&gt; ，而 &lt;code&gt;tau&lt;/code&gt; 的长度必须大于或等于 &lt;code&gt;A&lt;/code&gt; 的最小尺寸。</target>
        </trans-unit>
        <trans-unit id="3be9574f6c1b531ee6e117bea8e3a59d235a7898" translate="yes" xml:space="preserve">
          <source>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;a href=&quot;#LinearAlgebra.CholeskyPivoted&quot;&gt;&lt;code&gt;CholeskyPivoted&lt;/code&gt;&lt;/a&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt;&lt;code&gt;StridedMatrix&lt;/code&gt;&lt;/a&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;CholeskyPivoted&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#LinearAlgebra.rank&quot;&gt;&lt;code&gt;rank&lt;/code&gt;&lt;/a&gt;. The argument &lt;code&gt;tol&lt;/code&gt; determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</source>
          <target state="translated">计算稠密对称正半定矩阵 &lt;code&gt;A&lt;/code&gt; 的枢轴Cholesky分解，并返回&lt;a href=&quot;#LinearAlgebra.CholeskyPivoted&quot;&gt; &lt;code&gt;CholeskyPivoted&lt;/code&gt; &lt;/a&gt;分解。矩阵 &lt;code&gt;A&lt;/code&gt; 可以是&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/arrays/index#Base.StridedMatrix&quot;&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; &lt;/a&gt;或&lt;em&gt;完全&lt;/em&gt;对称或Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt; 。可以从分解系数 &lt;code&gt;F&lt;/code&gt; 中获得 &lt;code&gt;F.L&lt;/code&gt; 和 &lt;code&gt;F.U&lt;/code&gt; 从而得到三角Cholesky系数。以下功能可用于 &lt;code&gt;CholeskyPivoted&lt;/code&gt; 对象：&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;\&lt;/code&gt; ， &lt;code&gt;inv&lt;/code&gt; ，&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#LinearAlgebra.rank&quot;&gt; &lt;code&gt;rank&lt;/code&gt; &lt;/a&gt;。参数 &lt;code&gt;tol&lt;/code&gt; 确定确定等级的容差。对于负值，公差是机器精度。</target>
        </trans-unit>
        <trans-unit id="9ff2d7fc77ed33a91ba59f92eb332d8bf62ed2de" translate="yes" xml:space="preserve">
          <source>Compute the pivoted Cholesky factorization of a dense symmetric positive semi-definite matrix &lt;code&gt;A&lt;/code&gt; and return a &lt;code&gt;CholeskyPivoted&lt;/code&gt; factorization. The matrix &lt;code&gt;A&lt;/code&gt; can either be a &lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt;&lt;code&gt;StridedMatrix&lt;/code&gt; or a &lt;em&gt;perfectly&lt;/em&gt; symmetric or Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt;. The triangular Cholesky factor can be obtained from the factorization &lt;code&gt;F&lt;/code&gt; with: &lt;code&gt;F.L&lt;/code&gt; and &lt;code&gt;F.U&lt;/code&gt;. The following functions are available for &lt;code&gt;CholeskyPivoted&lt;/code&gt; objects: &lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;inv&lt;/code&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#LinearAlgebra.rank&quot;&gt;&lt;code&gt;rank&lt;/code&gt;&lt;/a&gt;. The argument &lt;code&gt;tol&lt;/code&gt; determines the tolerance for determining the rank. For negative values, the tolerance is the machine precision.</source>
          <target state="translated">计算稠密对称正半定矩阵 &lt;code&gt;A&lt;/code&gt; 的枢轴Cholesky分解，并返回 &lt;code&gt;CholeskyPivoted&lt;/code&gt; 分解。矩阵 &lt;code&gt;A&lt;/code&gt; 可以是&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt; &lt;code&gt;Symmetric&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt; &lt;code&gt;Hermitian&lt;/code&gt; &lt;/a&gt; &lt;code&gt;StridedMatrix&lt;/code&gt; 或&lt;em&gt;完全&lt;/em&gt;对称或Hermitian &lt;code&gt;StridedMatrix&lt;/code&gt; 。可以从分解因子 &lt;code&gt;F&lt;/code&gt; 中获得 &lt;code&gt;F.L&lt;/code&gt; 和 &lt;code&gt;F.U&lt;/code&gt; 从而得出三角形的Cholesky因子。以下功能可用于 &lt;code&gt;CholeskyPivoted&lt;/code&gt; 对象：&lt;a href=&quot;../../base/arrays/index#Base.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;\&lt;/code&gt; ， &lt;code&gt;inv&lt;/code&gt; ，&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#LinearAlgebra.rank&quot;&gt; &lt;code&gt;rank&lt;/code&gt; &lt;/a&gt;。参数 &lt;code&gt;tol&lt;/code&gt; 确定确定等级的容差。对于负值，公差是机器精度。</target>
        </trans-unit>
        <trans-unit id="b64ceade01dfafb5bfec886e80d298d8030e7599" translate="yes" xml:space="preserve">
          <source>Compute the quantile(s) of a collection &lt;code&gt;itr&lt;/code&gt; at a specified probability or vector or tuple of probabilities &lt;code&gt;p&lt;/code&gt; on the interval [0,1]. The keyword argument &lt;code&gt;sorted&lt;/code&gt; indicates whether &lt;code&gt;itr&lt;/code&gt; can be assumed to be sorted.</source>
          <target state="translated">计算集合的分位数（S） &lt;code&gt;itr&lt;/code&gt; 在指定的概率或载体或概率的元组 &lt;code&gt;p&lt;/code&gt; 在区间[0,1]。关键字参数 &lt;code&gt;sorted&lt;/code&gt; 指示是否可以假定 &lt;code&gt;itr&lt;/code&gt; 被排序。</target>
        </trans-unit>
        <trans-unit id="eb2c3240f4729969dc3c9a6a7351fdcf66f680d9" translate="yes" xml:space="preserve">
          <source>Compute the quantile(s) of a vector &lt;code&gt;v&lt;/code&gt; at a specified probability or vector or tuple of probabilities &lt;code&gt;p&lt;/code&gt; on the interval [0,1]. If &lt;code&gt;p&lt;/code&gt; is a vector, an optional output array &lt;code&gt;q&lt;/code&gt; may also be specified. (If not provided, a new output array is created.) The keyword argument &lt;code&gt;sorted&lt;/code&gt; indicates whether &lt;code&gt;v&lt;/code&gt; can be assumed to be sorted; if &lt;code&gt;false&lt;/code&gt; (the default), then the elements of &lt;code&gt;v&lt;/code&gt; will be partially sorted in-place.</source>
          <target state="translated">计算矢量的位数（S） &lt;code&gt;v&lt;/code&gt; 在规定的概率或载体或概率的元组 &lt;code&gt;p&lt;/code&gt; 在区间[0,1]。如果 &lt;code&gt;p&lt;/code&gt; 是一个向量，则还可以指定一个可选的输出数组 &lt;code&gt;q&lt;/code&gt; 。 （如果未提供，则创建一个新的输出数组。）关键字参数 &lt;code&gt;sorted&lt;/code&gt; 指示是否可以假定 &lt;code&gt;v&lt;/code&gt; 被排序；如果为 &lt;code&gt;false&lt;/code&gt; （默认值），则 &lt;code&gt;v&lt;/code&gt; 的元素将部分就地排序。</target>
        </trans-unit>
        <trans-unit id="1bb368cffdd0709c3136c6eb4be4a7856720c163" translate="yes" xml:space="preserve">
          <source>Compute the rank of a matrix by counting how many singular values of &lt;code&gt;A&lt;/code&gt; have magnitude greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is &lt;code&gt;A&lt;/code&gt;'s largest singular value. &lt;code&gt;atol&lt;/code&gt; and &lt;code&gt;rtol&lt;/code&gt; are the absolute and relative tolerances, respectively. The default relative tolerance is &lt;code&gt;n*ϵ&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the size of the smallest dimension of &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;ϵ&lt;/code&gt; is the &lt;a href=&quot;../dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the element type of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">通过计算 &lt;code&gt;A&lt;/code&gt; 的奇异值的大小大于 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; 大小来计算矩阵的秩，其中 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 是 &lt;code&gt;A&lt;/code&gt; 的最大奇异值。 &lt;code&gt;atol&lt;/code&gt; 和 &lt;code&gt;rtol&lt;/code&gt; 分别是绝对公差和相对公差。默认相对公差是 &lt;code&gt;n*ϵ&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是的最小尺寸的大小 &lt;code&gt;A&lt;/code&gt; ，和 &lt;code&gt;ϵ&lt;/code&gt; 是&lt;a href=&quot;../dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;的元素类型的 &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dc3f685504afbf8552c15cce21aef6fd26ceffd0" translate="yes" xml:space="preserve">
          <source>Compute the remainder of &lt;code&gt;x&lt;/code&gt; after integer division by &lt;code&gt;2&amp;pi;&lt;/code&gt;, with the quotient rounded according to the rounding mode &lt;code&gt;r&lt;/code&gt;. In other words, the quantity</source>
          <target state="translated">计算整数除以 &lt;code&gt;2&amp;pi;&lt;/code&gt; 后的 &lt;code&gt;x&lt;/code&gt; 的余数，商根据舍入模式 &lt;code&gt;r&lt;/code&gt; 舍入。换句话说，数量</target>
        </trans-unit>
        <trans-unit id="95bc53629637126df14c31c62a968cf7ac84be97" translate="yes" xml:space="preserve">
          <source>Compute the sample standard deviation of collection &lt;code&gt;itr&lt;/code&gt;, with known mean(s) &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">用已知均值 &lt;code&gt;m&lt;/code&gt; 计算收集 &lt;code&gt;itr&lt;/code&gt; 的样本标准偏差。</target>
        </trans-unit>
        <trans-unit id="fa7acbca757d81bef6a91c9c0935f098eab6b4f2" translate="yes" xml:space="preserve">
          <source>Compute the sample standard deviation of collection &lt;code&gt;itr&lt;/code&gt;, with known mean(s) &lt;code&gt;mean&lt;/code&gt;.</source>
          <target state="translated">计算集合的样本标准偏差 &lt;code&gt;itr&lt;/code&gt; ，与已知的平均值（S） &lt;code&gt;mean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2013d0ec88dc549aea8806964d8579f321782fa9" translate="yes" xml:space="preserve">
          <source>Compute the sample standard deviation of collection &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">计算集合的样本标准差 &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e6293fe931efad035e3dce11f90fbf4d514cf36" translate="yes" xml:space="preserve">
          <source>Compute the sample variance of collection &lt;code&gt;itr&lt;/code&gt;, with known mean(s) &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">用已知均值 &lt;code&gt;m&lt;/code&gt; 计算集合 &lt;code&gt;itr&lt;/code&gt; 的样本方差。</target>
        </trans-unit>
        <trans-unit id="80514eb7c2c8ed67bdfdc0c57c67b78f896d8aff" translate="yes" xml:space="preserve">
          <source>Compute the sample variance of collection &lt;code&gt;itr&lt;/code&gt;, with known mean(s) &lt;code&gt;mean&lt;/code&gt;.</source>
          <target state="translated">计算采集的样本方差 &lt;code&gt;itr&lt;/code&gt; ，与已知的平均值（S） &lt;code&gt;mean&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7ad72bb7d52a6f023ffd8fa5902e661aa205b2ef" translate="yes" xml:space="preserve">
          <source>Compute the sample variance of collection &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">计算集合 &lt;code&gt;itr&lt;/code&gt; 的样本方差。</target>
        </trans-unit>
        <trans-unit id="d52f9b298abf8ef3482717a4fb7d6eb7739d6697" translate="yes" xml:space="preserve">
          <source>Compute the secant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in degrees.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的割线，其中 &lt;code&gt;x&lt;/code&gt; 以度为单位。</target>
        </trans-unit>
        <trans-unit id="56e3ce8cc803e620031d7e7d69e643ba6f727c31" translate="yes" xml:space="preserve">
          <source>Compute the secant of &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; is in radians.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 的割线，其中 &lt;code&gt;x&lt;/code&gt; 以弧度为单位。</target>
        </trans-unit>
        <trans-unit id="2d6fc0ea82100c7979c18fab715864258d67fcaf" translate="yes" xml:space="preserve">
          <source>Compute the singular value decomposition (SVD) of &lt;code&gt;A&lt;/code&gt; and return an &lt;code&gt;SVD&lt;/code&gt; object.</source>
          <target state="translated">计算的奇异值分解（SVD） &lt;code&gt;A&lt;/code&gt; ，并返回一个 &lt;code&gt;SVD&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="18a494aebbe2cd9c9cce0054d7ab6b3d0c0ca78c" translate="yes" xml:space="preserve">
          <source>Compute the variance of the vector &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default) then the sum is scaled with &lt;code&gt;n-1&lt;/code&gt;, whereas the sum is scaled with &lt;code&gt;n&lt;/code&gt; if &lt;code&gt;corrected&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;n = length(x)&lt;/code&gt;.</source>
          <target state="translated">计算向量 &lt;code&gt;x&lt;/code&gt; 的方差。如果 &lt;code&gt;corrected&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; （默认值），则将以 &lt;code&gt;n-1&lt;/code&gt; 缩放总和，而如果 &lt;code&gt;corrected&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则以 &lt;code&gt;n&lt;/code&gt; 缩放总和，其中 &lt;code&gt;n = length(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="76f4235dabe6a4763d3b8a0de229f70ac1e52a88" translate="yes" xml:space="preserve">
          <source>Compute-bound, non-memory-allocating tasks can prevent garbage collection from running in other threads that are allocating memory. In these cases it may be necessary to insert a manual call to &lt;code&gt;GC.safepoint()&lt;/code&gt; to allow GC to run. This limitation will be removed in the future.</source>
          <target state="translated">绑定计算的非内存分配任务可以防止垃圾回收在分配内存的其他线程中运行。在这些情况下，可能有必要插入对 &lt;code&gt;GC.safepoint()&lt;/code&gt; 的手动调用以允许GC运行。以后将取消此限制。</target>
        </trans-unit>
        <trans-unit id="196dea2d8876d4f497fbf30018e3df07bf112e07" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;LQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;gelqf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">计算 &lt;code&gt;side = L&lt;/code&gt; &lt;code&gt;Q * C&lt;/code&gt; （ &lt;code&gt;trans = N&lt;/code&gt; ）， &lt;code&gt;transpose(Q) * C&lt;/code&gt; （ &lt;code&gt;trans = T&lt;/code&gt; ）， &lt;code&gt;adjoint(Q) * C&lt;/code&gt; （ &lt;code&gt;trans = C&lt;/code&gt; ）或使用 &lt;code&gt;Q&lt;/code&gt; 计算 &lt;code&gt;side = R&lt;/code&gt; 的等效右侧乘法从使用 &lt;code&gt;gelqf!&lt;/code&gt; 计算的 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;LQ&lt;/code&gt; 分解中得到！。 &lt;code&gt;C&lt;/code&gt; 被覆盖。</target>
        </trans-unit>
        <trans-unit id="330b5ac4ec8258723cd692371fc2e6df49989d5c" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;QL&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;geqlf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">计算 &lt;code&gt;side = L&lt;/code&gt; &lt;code&gt;Q * C&lt;/code&gt; （ &lt;code&gt;trans = N&lt;/code&gt; ）， &lt;code&gt;transpose(Q) * C&lt;/code&gt; （ &lt;code&gt;trans = T&lt;/code&gt; ）， &lt;code&gt;adjoint(Q) * C&lt;/code&gt; （ &lt;code&gt;trans = C&lt;/code&gt; ）或使用 &lt;code&gt;Q&lt;/code&gt; 计算 &lt;code&gt;side = R&lt;/code&gt; 的等效右侧乘法从使用 &lt;code&gt;geqlf!&lt;/code&gt; 计算的 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;QL&lt;/code&gt; 因式分解！。 &lt;code&gt;C&lt;/code&gt; 被覆盖。</target>
        </trans-unit>
        <trans-unit id="23c10a1f9dd38caaf076a8b1a4a078298190e02c" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;geqrf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">计算 &lt;code&gt;side = L&lt;/code&gt; &lt;code&gt;Q * C&lt;/code&gt; （ &lt;code&gt;trans = N&lt;/code&gt; ）， &lt;code&gt;transpose(Q) * C&lt;/code&gt; （ &lt;code&gt;trans = T&lt;/code&gt; ）， &lt;code&gt;adjoint(Q) * C&lt;/code&gt; （ &lt;code&gt;trans = C&lt;/code&gt; ）或使用 &lt;code&gt;Q&lt;/code&gt; 计算 &lt;code&gt;side = R&lt;/code&gt; 的等效右侧乘法从使用 &lt;code&gt;geqrf!&lt;/code&gt; 计算的 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;QR&lt;/code&gt; 因式分解！。 &lt;code&gt;C&lt;/code&gt; 被覆盖。</target>
        </trans-unit>
        <trans-unit id="c1e711025c5d1686044686723b7e4084534f7793" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;geqrt!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">计算 &lt;code&gt;side = L&lt;/code&gt; &lt;code&gt;Q * C&lt;/code&gt; （ &lt;code&gt;trans = N&lt;/code&gt; ）， &lt;code&gt;transpose(Q) * C&lt;/code&gt; （ &lt;code&gt;trans = T&lt;/code&gt; ）， &lt;code&gt;adjoint(Q) * C&lt;/code&gt; （ &lt;code&gt;trans = C&lt;/code&gt; ）或使用 &lt;code&gt;Q&lt;/code&gt; 计算 &lt;code&gt;side = R&lt;/code&gt; 的等效右侧乘法从使用 &lt;code&gt;geqrt!&lt;/code&gt; 计算的 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;QR&lt;/code&gt; 因式分解！。 &lt;code&gt;C&lt;/code&gt; 被覆盖。</target>
        </trans-unit>
        <trans-unit id="3eae30893a76f76ba0b80fe1f33ca60ccd4a1a80" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;Q * C&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(Q) * C&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(Q) * C&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt; or the equivalent right-sided multiplication for &lt;code&gt;side = R&lt;/code&gt; using &lt;code&gt;Q&lt;/code&gt; from a &lt;code&gt;RQ&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt; computed using &lt;code&gt;gerqf!&lt;/code&gt;. &lt;code&gt;C&lt;/code&gt; is overwritten.</source>
          <target state="translated">计算 &lt;code&gt;side = L&lt;/code&gt; &lt;code&gt;Q * C&lt;/code&gt; （ &lt;code&gt;trans = N&lt;/code&gt; ）， &lt;code&gt;transpose(Q) * C&lt;/code&gt; （ &lt;code&gt;trans = T&lt;/code&gt; ）， &lt;code&gt;adjoint(Q) * C&lt;/code&gt; （ &lt;code&gt;trans = C&lt;/code&gt; ）或使用 &lt;code&gt;Q&lt;/code&gt; 计算 &lt;code&gt;side = R&lt;/code&gt; 的等效右侧乘法来自使用 &lt;code&gt;gerqf!&lt;/code&gt; 计算的 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;RQ&lt;/code&gt; 因式分解！。 &lt;code&gt;C&lt;/code&gt; 被覆盖。</target>
        </trans-unit>
        <trans-unit id="15574eb06b260c277bf93ed3b4e329832dc2d2b0" translate="yes" xml:space="preserve">
          <source>Computes &lt;code&gt;x*y+z&lt;/code&gt; without rounding the intermediate result &lt;code&gt;x*y&lt;/code&gt;. On some systems this is significantly more expensive than &lt;code&gt;x*y+z&lt;/code&gt;. &lt;code&gt;fma&lt;/code&gt; is used to improve accuracy in certain algorithms. See &lt;a href=&quot;#Base.muladd&quot;&gt;&lt;code&gt;muladd&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">计算 &lt;code&gt;x*y+z&lt;/code&gt; 而不舍入中间结果 &lt;code&gt;x*y&lt;/code&gt; 。在某些系统上，这比 &lt;code&gt;x*y+z&lt;/code&gt; 昂贵得多。 &lt;code&gt;fma&lt;/code&gt; 用于提高某些算法的准确性。参见&lt;a href=&quot;#Base.muladd&quot;&gt; &lt;code&gt;muladd&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d85408fc3f46bcd68209a106a2a685b34165a916" translate="yes" xml:space="preserve">
          <source>Computes a basis for the nullspace of &lt;code&gt;M&lt;/code&gt; by including the singular vectors of &lt;code&gt;M&lt;/code&gt; whose singular values have magnitudes greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt;, where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is &lt;code&gt;M&lt;/code&gt;'s largest singular value.</source>
          <target state="translated">计算用于的零空间的基础 &lt;code&gt;M&lt;/code&gt; 通过包括奇异向量 &lt;code&gt;M&lt;/code&gt; 其奇异值具有幅值大于 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; ，其中 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 是 &lt;code&gt;M&lt;/code&gt; 的最大奇异值。</target>
        </trans-unit>
        <trans-unit id="f8d2bf90fe337bc19a74db83f3cf8ee951ffa605" translate="yes" xml:space="preserve">
          <source>Computes a basis for the nullspace of &lt;code&gt;M&lt;/code&gt; by including the singular vectors of A whose singular have magnitude are greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt;, where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is &lt;code&gt;M&lt;/code&gt;'s largest singularvalue.</source>
          <target state="translated">通过包含A的奇异向量（其大小大于 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; 计算 &lt;code&gt;M&lt;/code&gt; 的零空间的基础，其中 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 是 &lt;code&gt;M&lt;/code&gt; 的最大奇异值。</target>
        </trans-unit>
        <trans-unit id="d36744afe997ffcda5697a0694557892f6eb5206" translate="yes" xml:space="preserve">
          <source>Computes the (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) pivoted Cholesky decomposition of positive-definite matrix &lt;code&gt;A&lt;/code&gt; with a user-set tolerance &lt;code&gt;tol&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Cholesky decomposition.</source>
          <target state="translated">计算具有用户设置的公差 &lt;code&gt;tol&lt;/code&gt; 的正定矩阵 &lt;code&gt;A&lt;/code&gt; 的枢轴Cholesky分解（如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则为上限； &lt;code&gt;uplo = L&lt;/code&gt; ，则为下限）。 &lt;code&gt;A&lt;/code&gt; 被其Cholesky分解覆盖。</target>
        </trans-unit>
        <trans-unit id="fd36c39296e253cc9d8a070bacaf4f4bf9b57780" translate="yes" xml:space="preserve">
          <source>Computes the Bunch-Kaufman factorization of a Hermitian matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored.</source>
          <target state="translated">计算Hermitian矩阵 &lt;code&gt;A&lt;/code&gt; 的Bunch-Kaufman分解。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则存储 &lt;code&gt;A&lt;/code&gt; 的上半部分。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则存储下半部分。</target>
        </trans-unit>
        <trans-unit id="22428da5be587cdee5b6c05cffa201cf9861cc3c" translate="yes" xml:space="preserve">
          <source>Computes the Bunch-Kaufman factorization of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored.</source>
          <target state="translated">计算对称矩阵 &lt;code&gt;A&lt;/code&gt; 的Bunch-Kaufman分解。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则存储 &lt;code&gt;A&lt;/code&gt; 的上半部分。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则存储下半部分。</target>
        </trans-unit>
        <trans-unit id="f19c7e8b3174b328131e9e17030c6148cf8f127e" translate="yes" xml:space="preserve">
          <source>Computes the Cholesky (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) decomposition of positive-definite matrix &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten and returned with an info code.</source>
          <target state="translated">计算正定矩阵 &lt;code&gt;A&lt;/code&gt; 的Cholesky（如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则为高；如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则为低）分解。 &lt;code&gt;A&lt;/code&gt; 被覆盖并返回信息代码。</target>
        </trans-unit>
        <trans-unit id="0cafabd44437dbd8e485ca59504c069c025da1ad" translate="yes" xml:space="preserve">
          <source>Computes the Generalized Schur (or QZ) factorization of the matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. The (quasi) triangular Schur factors can be obtained from the &lt;code&gt;Schur&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt; with &lt;code&gt;F.S&lt;/code&gt; and &lt;code&gt;F.T&lt;/code&gt;, the left unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.left&lt;/code&gt; or &lt;code&gt;F.Q&lt;/code&gt; and the right unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.right&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; and &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt;. The generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; can be obtained with &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">计算矩阵 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的广义Schur（或QZ）分解。三角形的舒尔因素可以从获得的（准） &lt;code&gt;Schur&lt;/code&gt; 对象 &lt;code&gt;F&lt;/code&gt; 与 &lt;code&gt;F.S&lt;/code&gt; 和 &lt;code&gt;F.T&lt;/code&gt; ，左酉/正交舒尔载体可以与获得 &lt;code&gt;F.left&lt;/code&gt; 或 &lt;code&gt;F.Q&lt;/code&gt; 和右整体式/正交舒尔载体可以与获得 &lt;code&gt;F.right&lt;/code&gt; 或 &lt;code&gt;F.Z&lt;/code&gt; 这样 &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; 和 &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt; 。 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的广义特征值可通过 &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="3efb8aa207d5af77f49688b04559bb67415cf85e" translate="yes" xml:space="preserve">
          <source>Computes the Givens rotation &lt;code&gt;G&lt;/code&gt; and scalar &lt;code&gt;r&lt;/code&gt; such that for any vector &lt;code&gt;x&lt;/code&gt; where</source>
          <target state="translated">计算给定旋转 &lt;code&gt;G&lt;/code&gt; 和标量 &lt;code&gt;r&lt;/code&gt; ，以便对于任何向量 &lt;code&gt;x&lt;/code&gt; ，其中</target>
        </trans-unit>
        <trans-unit id="3b7b86c4db1c49294f9afcc1c05c3a761727f9b0" translate="yes" xml:space="preserve">
          <source>Computes the Givens rotation &lt;code&gt;G&lt;/code&gt; and scalar &lt;code&gt;r&lt;/code&gt; such that the result of the multiplication</source>
          <target state="translated">计算给定旋转 &lt;code&gt;G&lt;/code&gt; 和标量 &lt;code&gt;r&lt;/code&gt; ，以使乘法结果</target>
        </trans-unit>
        <trans-unit id="db4721bd00c3c65fe61a8b0bdb9fd8f8985ae6ed" translate="yes" xml:space="preserve">
          <source>Computes the LDLt factorization of a positive-definite tridiagonal matrix with &lt;code&gt;D&lt;/code&gt; as diagonal and &lt;code&gt;E&lt;/code&gt; as off-diagonal. &lt;code&gt;D&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt; are overwritten and returned.</source>
          <target state="translated">计算正定三对角矩阵的LDLt分解，其中 &lt;code&gt;D&lt;/code&gt; 为对角线， &lt;code&gt;E&lt;/code&gt; 为非对角线。 &lt;code&gt;D&lt;/code&gt; 和 &lt;code&gt;E&lt;/code&gt; 被覆盖并返回。</target>
        </trans-unit>
        <trans-unit id="915ececcc0f410ce7a63643c0b6e374861bcd250" translate="yes" xml:space="preserve">
          <source>Computes the Moore-Penrose pseudoinverse.</source>
          <target state="translated">计算摩尔-彭罗斯伪逆。</target>
        </trans-unit>
        <trans-unit id="6055e64119c4c7498a33b99f97eb16c43da95186" translate="yes" xml:space="preserve">
          <source>Computes the Schur factorization of the matrix &lt;code&gt;A&lt;/code&gt;. The (quasi) triangular Schur factor can be obtained from the &lt;code&gt;Schur&lt;/code&gt; object &lt;code&gt;F&lt;/code&gt; with either &lt;code&gt;F.Schur&lt;/code&gt; or &lt;code&gt;F.T&lt;/code&gt; and the orthogonal/unitary Schur vectors can be obtained with &lt;code&gt;F.vectors&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt;. The eigenvalues of &lt;code&gt;A&lt;/code&gt; can be obtained with &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">计算矩阵 &lt;code&gt;A&lt;/code&gt; 的Schur分解。可以使用 &lt;code&gt;F.Schur&lt;/code&gt; 或 &lt;code&gt;F.T&lt;/code&gt; 从 &lt;code&gt;Schur&lt;/code&gt; 对象 &lt;code&gt;F&lt;/code&gt; 获得（准）三角Schur因子，并且可以使用 &lt;code&gt;F.vectors&lt;/code&gt; 或 &lt;code&gt;F.Z&lt;/code&gt; 获得正交/单位Schur矢量，使得 &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt; 。 &lt;code&gt;A&lt;/code&gt; 的特征值可以通过 &lt;code&gt;F.values&lt;/code&gt; 获得。</target>
        </trans-unit>
        <trans-unit id="be77495485da8e82a774262ef640c248f097d559" translate="yes" xml:space="preserve">
          <source>Computes the eigensystem for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev&lt;/code&gt; as off-diagonal. If &lt;code&gt;job = N&lt;/code&gt; only the eigenvalues are found and returned in &lt;code&gt;dv&lt;/code&gt;. If &lt;code&gt;job = V&lt;/code&gt; then the eigenvectors are also found and returned in &lt;code&gt;Zmat&lt;/code&gt;.</source>
          <target state="translated">计算对称三对角矩阵的本征系统，其中 &lt;code&gt;dv&lt;/code&gt; 为对角线， &lt;code&gt;ev&lt;/code&gt; 为非对角线。如果 &lt;code&gt;job = N&lt;/code&gt; 仅找到特征值并在 &lt;code&gt;dv&lt;/code&gt; 中返回。如果 &lt;code&gt;job = V&lt;/code&gt; 则特征向量也会在 &lt;code&gt;Zmat&lt;/code&gt; 中找到并返回。</target>
        </trans-unit>
        <trans-unit id="d55bd3d8ada3bc88d1bea445d75e91aceef15776" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalue decomposition of &lt;code&gt;A&lt;/code&gt;, returning an &lt;a href=&quot;#LinearAlgebra.Eigen&quot;&gt;&lt;code&gt;Eigen&lt;/code&gt;&lt;/a&gt; factorization object &lt;code&gt;F&lt;/code&gt; which contains the eigenvalues in &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors in the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的特征值分解，返回&lt;a href=&quot;#LinearAlgebra.Eigen&quot;&gt; &lt;code&gt;Eigen&lt;/code&gt; &lt;/a&gt;分解对象 &lt;code&gt;F&lt;/code&gt; ，该对象包含 &lt;code&gt;F.values&lt;/code&gt; 中的特征值和矩阵 &lt;code&gt;F.vectors&lt;/code&gt; 列中的特征向量。（第 &lt;code&gt;k&lt;/code&gt; 个特征向量可以从切片 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="c0c2d756bd2ee3d8520442f71f1acb8461142c55" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalue decomposition of &lt;code&gt;A&lt;/code&gt;, returning an &lt;code&gt;Eigen&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt; which contains the eigenvalues in &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors in the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 的特征值分解，返回 &lt;code&gt;Eigen&lt;/code&gt; 分解对象 &lt;code&gt;F&lt;/code&gt; ，该对象包含 &lt;code&gt;F.values&lt;/code&gt; 中的特征值和矩阵 &lt;code&gt;F.vectors&lt;/code&gt; 列中的特征向量。（第 &lt;code&gt;k&lt;/code&gt; 个特征向量可以从切片 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="56ef3f44145e5cbb1d7b50f00f2bd9fcc16d97eb" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalues (&lt;code&gt;jobvs = N&lt;/code&gt;) or the eigenvalues and Schur vectors (&lt;code&gt;jobvs = V&lt;/code&gt;) of matrix &lt;code&gt;A&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Schur form.</source>
          <target state="translated">计算矩阵 &lt;code&gt;A&lt;/code&gt; 的特征值（ &lt;code&gt;jobvs = N&lt;/code&gt; ）或特征值和Schur向量（ &lt;code&gt;jobvs = V&lt;/code&gt; ）。 &lt;code&gt;A&lt;/code&gt; 被其Schur格式覆盖。</target>
        </trans-unit>
        <trans-unit id="5a3a0443d72fdbb0792684407d1da11dd17bf077" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev&lt;/code&gt; as off-diagonal. If &lt;code&gt;range = A&lt;/code&gt;, all the eigenvalues are found. If &lt;code&gt;range = V&lt;/code&gt;, the eigenvalues in the half-open interval &lt;code&gt;(vl, vu]&lt;/code&gt; are found. If &lt;code&gt;range = I&lt;/code&gt;, the eigenvalues with indices between &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;iu&lt;/code&gt; are found. The eigenvalues are returned in &lt;code&gt;w&lt;/code&gt; and the eigenvectors in &lt;code&gt;Z&lt;/code&gt;.</source>
          <target state="translated">计算对称三对角矩阵的特征值（ &lt;code&gt;jobz = N&lt;/code&gt; ）或特征值和特征向量（ &lt;code&gt;jobz = V&lt;/code&gt; ），其中 &lt;code&gt;dv&lt;/code&gt; 为对角线， &lt;code&gt;ev&lt;/code&gt; 为非对角线。如果 &lt;code&gt;range = A&lt;/code&gt; ，则找到所有特征值。如果 &lt;code&gt;range = V&lt;/code&gt; ，则找到半开区间 &lt;code&gt;(vl, vu]&lt;/code&gt; 中的特征值；如果 &lt;code&gt;range = I&lt;/code&gt; ，则找到索引在 &lt;code&gt;il&lt;/code&gt; 和 &lt;code&gt;iu&lt;/code&gt; 之间的特征值；特征值在 &lt;code&gt;w&lt;/code&gt; 中返回，特征向量在 &lt;code&gt;Z&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="702fe6d75fff16642d7459ba596ae090bfec93a0" translate="yes" xml:space="preserve">
          <source>Computes the eigenvalues for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev&lt;/code&gt; as off-diagonal. If &lt;code&gt;range = A&lt;/code&gt;, all the eigenvalues are found. If &lt;code&gt;range = V&lt;/code&gt;, the eigenvalues in the half-open interval &lt;code&gt;(vl, vu]&lt;/code&gt; are found. If &lt;code&gt;range = I&lt;/code&gt;, the eigenvalues with indices between &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;iu&lt;/code&gt; are found. If &lt;code&gt;order = B&lt;/code&gt;, eigvalues are ordered within a block. If &lt;code&gt;order = E&lt;/code&gt;, they are ordered across all the blocks. &lt;code&gt;abstol&lt;/code&gt; can be set as a tolerance for convergence.</source>
          <target state="translated">计算对称三对角矩阵的特征值，其中 &lt;code&gt;dv&lt;/code&gt; 为对角线， &lt;code&gt;ev&lt;/code&gt; 为非对角线。如果 &lt;code&gt;range = A&lt;/code&gt; ，则找到所有特征值。如果 &lt;code&gt;range = V&lt;/code&gt; ，则找到半开区间 &lt;code&gt;(vl, vu]&lt;/code&gt; 中的特征值；如果 &lt;code&gt;range = I&lt;/code&gt; ，则找到索引在 &lt;code&gt;il&lt;/code&gt; 和 &lt;code&gt;iu&lt;/code&gt; 之间的特征值；如果 &lt;code&gt;order = B&lt;/code&gt; ，则eigvalues在一个块内排序。 &lt;code&gt;order = E&lt;/code&gt; ，它们在所有块中有序排列，可以将 &lt;code&gt;abstol&lt;/code&gt; 设置为收敛容差。</target>
        </trans-unit>
        <trans-unit id="2774f3063f2166a20accf4c30f58fa05930aee13" translate="yes" xml:space="preserve">
          <source>Computes the eigenvectors for a symmetric tridiagonal matrix with &lt;code&gt;dv&lt;/code&gt; as diagonal and &lt;code&gt;ev_in&lt;/code&gt; as off-diagonal. &lt;code&gt;w_in&lt;/code&gt; specifies the input eigenvalues for which to find corresponding eigenvectors. &lt;code&gt;iblock_in&lt;/code&gt; specifies the submatrices corresponding to the eigenvalues in &lt;code&gt;w_in&lt;/code&gt;. &lt;code&gt;isplit_in&lt;/code&gt; specifies the splitting points between the submatrix blocks.</source>
          <target state="translated">计算以 &lt;code&gt;dv&lt;/code&gt; 为对角线且 &lt;code&gt;ev_in&lt;/code&gt; 为非对角线的对称三对角矩阵的特征向量。 &lt;code&gt;w_in&lt;/code&gt; 指定要为其找到对应特征向量的输入特征值。 &lt;code&gt;iblock_in&lt;/code&gt; 指定对应于在特征值子矩阵 &lt;code&gt;w_in&lt;/code&gt; 。 &lt;code&gt;isplit_in&lt;/code&gt; 指定子矩阵块之间的分割点。</target>
        </trans-unit>
        <trans-unit id="9279d5825ee8c8627fd1fe8e8ebf71ef81d80096" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalue decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, returning a &lt;a href=&quot;#LinearAlgebra.GeneralizedEigen&quot;&gt;&lt;code&gt;GeneralizedEigen&lt;/code&gt;&lt;/a&gt; factorization object &lt;code&gt;F&lt;/code&gt; which contains the generalized eigenvalues in &lt;code&gt;F.values&lt;/code&gt; and the generalized eigenvectors in the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th generalized eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的广义特征值分解，返回一个&lt;a href=&quot;#LinearAlgebra.GeneralizedEigen&quot;&gt; &lt;code&gt;GeneralizedEigen&lt;/code&gt; &lt;/a&gt;分解对象 &lt;code&gt;F&lt;/code&gt; ，该对象包含 &lt;code&gt;F.values&lt;/code&gt; 中的广义特征值和矩阵 &lt;code&gt;F.vectors&lt;/code&gt; 列中的广义特征向量。 （第 &lt;code&gt;k&lt;/code&gt; 个广义特征向量可从切片 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="22cb9800f1213961f1d9d7750f55ad1f1358c888" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalue decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, returning a &lt;code&gt;GeneralizedEigen&lt;/code&gt; factorization object &lt;code&gt;F&lt;/code&gt; which contains the generalized eigenvalues in &lt;code&gt;F.values&lt;/code&gt; and the generalized eigenvectors in the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th generalized eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的广义特征值分解，返回一个 &lt;code&gt;GeneralizedEigen&lt;/code&gt; 分解对象 &lt;code&gt;F&lt;/code&gt; ，该对象包含 &lt;code&gt;F.values&lt;/code&gt; 中的广义特征值和矩阵 &lt;code&gt;F.vectors&lt;/code&gt; 列中的广义特征向量。（第 &lt;code&gt;k&lt;/code&gt; 个广义特征向量可从切片 &lt;code&gt;F.vectors[:, k]&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="02b33b45277ccf1798c5db9f681b4fbc2af0b721" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的广义特征值。</target>
        </trans-unit>
        <trans-unit id="30705de9147ff967461851722fa377560561d2ce" translate="yes" xml:space="preserve">
          <source>Computes the generalized eigenvalues, generalized Schur form, left Schur vectors (&lt;code&gt;jobsvl = V&lt;/code&gt;), or right Schur vectors (&lt;code&gt;jobvsr = V&lt;/code&gt;) of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的广义特征值，广义Schur形式，左Schur向量（ &lt;code&gt;jobsvl = V&lt;/code&gt; ）或右Schur向量（ &lt;code&gt;jobvsr = V&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7d9d5c41f59e436c6611c2108f610d3d4369c1d3" translate="yes" xml:space="preserve">
          <source>Computes the greatest common (positive) divisor of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; and their B&amp;eacute;zout coefficients, i.e. the integer coefficients &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; that satisfy $ux+vy = d = gcd(x,y)$. $gcdx(x,y)$ returns $(d,u,v)$.</source>
          <target state="translated">计算 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的最大公约数（正）和它们的B&amp;eacute;zout系数，即满足$ ux + vy = d = gcd（x，y）$ 的整数系数 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 。$ gcdx（x，y）$返回$（d，u，v）$。</target>
        </trans-unit>
        <trans-unit id="d356d77cd7680b87bc3b49a0e273970ad7f27896" translate="yes" xml:space="preserve">
          <source>Computes the inverse of &lt;code&gt;A&lt;/code&gt;, using its &lt;code&gt;LU&lt;/code&gt; factorization found by &lt;code&gt;getrf!&lt;/code&gt;. &lt;code&gt;ipiv&lt;/code&gt; is the pivot information output and &lt;code&gt;A&lt;/code&gt; contains the &lt;code&gt;LU&lt;/code&gt; factorization of &lt;code&gt;getrf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten with its inverse.</source>
          <target state="translated">使用 &lt;code&gt;getrf!&lt;/code&gt; 发现的 &lt;code&gt;LU&lt;/code&gt; 分解来计算 &lt;code&gt;A&lt;/code&gt; 的逆。。 &lt;code&gt;ipiv&lt;/code&gt; 是关键信息输出， &lt;code&gt;A&lt;/code&gt; 包含 &lt;code&gt;getrf!&lt;/code&gt; 的 &lt;code&gt;LU&lt;/code&gt; 分解！。 &lt;code&gt;A&lt;/code&gt; 被其反函数覆盖。</target>
        </trans-unit>
        <trans-unit id="cb2e1de5980a4a4f0fbdf482a5ea64f2c959a899" translate="yes" xml:space="preserve">
          <source>Computes the inverse of a Hermitian matrix &lt;code&gt;A&lt;/code&gt; using the results of &lt;code&gt;sytrf!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;A&lt;/code&gt; is overwritten by its inverse.</source>
          <target state="translated">使用 &lt;code&gt;sytrf!&lt;/code&gt; 的结果计算Hermitian矩阵 &lt;code&gt;A&lt;/code&gt; 的逆！。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则存储 &lt;code&gt;A&lt;/code&gt; 的上半部分。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则存储下半部分。 &lt;code&gt;A&lt;/code&gt; 被其逆覆盖。</target>
        </trans-unit>
        <trans-unit id="39d4577d522bd768286b7114ac09a7dc67a68d58" translate="yes" xml:space="preserve">
          <source>Computes the inverse of a symmetric matrix &lt;code&gt;A&lt;/code&gt; using the results of &lt;code&gt;sytrf!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;A&lt;/code&gt; is overwritten by its inverse.</source>
          <target state="translated">使用 &lt;code&gt;sytrf!&lt;/code&gt; 的结果计算对称矩阵 &lt;code&gt;A&lt;/code&gt; 的逆。。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则存储 &lt;code&gt;A&lt;/code&gt; 的上半部分。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则存储下半部分。 &lt;code&gt;A&lt;/code&gt; 被其逆覆盖。</target>
        </trans-unit>
        <trans-unit id="aa616fdc7bbc88179bfd3ddbbcdba42b387701e0" translate="yes" xml:space="preserve">
          <source>Computes the inverse of positive-definite matrix &lt;code&gt;A&lt;/code&gt; after calling &lt;code&gt;potrf!&lt;/code&gt; to find its (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) Cholesky decomposition.</source>
          <target state="translated">调用 &lt;code&gt;potrf!&lt;/code&gt; 之后计算正定矩阵 &lt;code&gt;A&lt;/code&gt; 的逆！找到它（如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则较高；如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则较低）Cholesky分解。</target>
        </trans-unit>
        <trans-unit id="d0e374af8acff15741567ccb37ae6e22ca3d3352" translate="yes" xml:space="preserve">
          <source>Computes the least norm solution of &lt;code&gt;A * X = B&lt;/code&gt; by finding the &lt;code&gt;SVD&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, then dividing-and-conquering the problem. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;. Singular values below &lt;code&gt;rcond&lt;/code&gt; will be treated as zero. Returns the solution in &lt;code&gt;B&lt;/code&gt; and the effective rank of &lt;code&gt;A&lt;/code&gt; in &lt;code&gt;rnk&lt;/code&gt;.</source>
          <target state="translated">通过找到 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;SVD&lt;/code&gt; 分解来计算 &lt;code&gt;A * X = B&lt;/code&gt; 的最小范数解，然后对该问题进行分治。 &lt;code&gt;B&lt;/code&gt; 被解决方案 &lt;code&gt;X&lt;/code&gt; 覆盖。低于 &lt;code&gt;rcond&lt;/code&gt; 的奇异值将被视为零。返回在溶液 &lt;code&gt;B&lt;/code&gt; 和的有效秩 &lt;code&gt;A&lt;/code&gt; 在 &lt;code&gt;rnk&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9772f2cb554e6714e2d0249e5923646b5c83167" translate="yes" xml:space="preserve">
          <source>Computes the least norm solution of &lt;code&gt;A * X = B&lt;/code&gt; by finding the full &lt;code&gt;QR&lt;/code&gt; factorization of &lt;code&gt;A&lt;/code&gt;, then dividing-and-conquering the problem. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;. Singular values below &lt;code&gt;rcond&lt;/code&gt; will be treated as zero. Returns the solution in &lt;code&gt;B&lt;/code&gt; and the effective rank of &lt;code&gt;A&lt;/code&gt; in &lt;code&gt;rnk&lt;/code&gt;.</source>
          <target state="translated">通过找到 &lt;code&gt;A&lt;/code&gt; 的完全 &lt;code&gt;QR&lt;/code&gt; 分解，然后对问题进行分而治之，计算 &lt;code&gt;A * X = B&lt;/code&gt; 的最小范数解。 &lt;code&gt;B&lt;/code&gt; 被解决方案 &lt;code&gt;X&lt;/code&gt; 覆盖。低于 &lt;code&gt;rcond&lt;/code&gt; 的奇异值将被视为零。返回在溶液 &lt;code&gt;B&lt;/code&gt; 和的有效秩 &lt;code&gt;A&lt;/code&gt; 在 &lt;code&gt;rnk&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce03bad87638dae01e4efdac4ef134e0c01c10b0" translate="yes" xml:space="preserve">
          <source>Computes the singular value decomposition of a bidiagonal matrix with &lt;code&gt;d&lt;/code&gt; on the diagonal and &lt;code&gt;e_&lt;/code&gt; on the off-diagonal using a divide and conqueq method. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the superdiagonal. If &lt;code&gt;uplo = L&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the subdiagonal. If &lt;code&gt;compq = N&lt;/code&gt;, only the singular values are found. If &lt;code&gt;compq = I&lt;/code&gt;, the singular values and vectors are found. If &lt;code&gt;compq = P&lt;/code&gt;, the singular values and vectors are found in compact form. Only works for real types.</source>
          <target state="translated">使用分而治之方法计算对角矩阵的奇异值分解，其中对角线上的 &lt;code&gt;d&lt;/code&gt; 为非对角线上的 &lt;code&gt;e_&lt;/code&gt; 。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则 &lt;code&gt;e_&lt;/code&gt; 是超对角线。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则 &lt;code&gt;e_&lt;/code&gt; 是对角线。如果 &lt;code&gt;compq = N&lt;/code&gt; ，则仅找到奇异值。如果 &lt;code&gt;compq = I&lt;/code&gt; ，则找到奇异值和向量。如果 &lt;code&gt;compq = P&lt;/code&gt; ，则以紧凑形式找到奇异值和向量。仅适用于实型。</target>
        </trans-unit>
        <trans-unit id="ec9c09340ab1167b34372c3c45f1effd39014b33" translate="yes" xml:space="preserve">
          <source>Computes the singular value decomposition of a bidiagonal matrix with &lt;code&gt;d&lt;/code&gt; on the diagonal and &lt;code&gt;e_&lt;/code&gt; on the off-diagonal. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the superdiagonal. If &lt;code&gt;uplo = L&lt;/code&gt;, &lt;code&gt;e_&lt;/code&gt; is the subdiagonal. Can optionally also compute the product &lt;code&gt;Q' * C&lt;/code&gt;.</source>
          <target state="translated">计算对角矩阵的奇异值分解，其中对角线上的 &lt;code&gt;d&lt;/code&gt; 为非对角线上的 &lt;code&gt;e_&lt;/code&gt; 。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则 &lt;code&gt;e_&lt;/code&gt; 是超对角线。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则 &lt;code&gt;e_&lt;/code&gt; 是对角线。还可选择性地计算乘积 &lt;code&gt;Q' * C&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f21ee8aaad12edc3062dd893487ac52ed7206a6" translate="yes" xml:space="preserve">
          <source>Computes the solution &lt;code&gt;X&lt;/code&gt; to the Sylvester equation &lt;code&gt;AX + XB + C = 0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have compatible dimensions and &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; have no eigenvalues with equal real part.</source>
          <target state="translated">将解决方案 &lt;code&gt;X&lt;/code&gt; 计算为Sylvester方程 &lt;code&gt;AX + XB + C = 0&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; 和 &lt;code&gt;C&lt;/code&gt; 具有兼容的尺寸，而 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;-B&lt;/code&gt; 没有具有相等实部的特征值。</target>
        </trans-unit>
        <trans-unit id="aaf728832835285f8685228605bcbec78d5e39bc" translate="yes" xml:space="preserve">
          <source>Computes the solution &lt;code&gt;X&lt;/code&gt; to the continuous Lyapunov equation &lt;code&gt;AX + XA' + C = 0&lt;/code&gt;, where no eigenvalue of &lt;code&gt;A&lt;/code&gt; has a zero real part and no two eigenvalues are negative complex conjugates of each other.</source>
          <target state="translated">将解决方案 &lt;code&gt;X&lt;/code&gt; 计算为连续Lyapunov方程 &lt;code&gt;AX + XA' + C = 0&lt;/code&gt; ，其中 &lt;code&gt;A&lt;/code&gt; 的特征值没有零实部，并且两个特征值都不是负复共轭。</target>
        </trans-unit>
        <trans-unit id="b754a424f062565c184ac8efa998e5bfaa6f23dc" translate="yes" xml:space="preserve">
          <source>Computing cluster</source>
          <target state="translated">计算集群</target>
        </trans-unit>
        <trans-unit id="2c4004422e3488a7fb54c4996a6f7cb083bc8c9e" translate="yes" xml:space="preserve">
          <source>Concatenate along dimension 1.</source>
          <target state="translated">沿着第1个维度进行连接。</target>
        </trans-unit>
        <trans-unit id="4629919e0ba100f50a2a2e401ed196f708cfd82e" translate="yes" xml:space="preserve">
          <source>Concatenate along dimension 2.</source>
          <target state="translated">沿着维度2进行连接。</target>
        </trans-unit>
        <trans-unit id="4d2f3e92e73a292cd5fe025535fd3fdcc9177e92" translate="yes" xml:space="preserve">
          <source>Concatenate matrices block-diagonally. Currently only implemented for sparse matrices.</source>
          <target state="translated">矩阵块对角线连接。目前只对稀疏矩阵实现。</target>
        </trans-unit>
        <trans-unit id="1a6633f51709c6fbebf8bdadf15bf67930efc876" translate="yes" xml:space="preserve">
          <source>Concatenate strings and/or characters, producing a &lt;a href=&quot;#Core.String-Tuple%7BAbstractString%7D&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. This is equivalent to calling the &lt;a href=&quot;#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; function on the arguments. Concatenation of built-in string types always produces a value of type &lt;code&gt;String&lt;/code&gt; but other string types may choose to return a string of a different type as appropriate.</source>
          <target state="translated">连接字符串和/或字符，生成&lt;a href=&quot;#Core.String-Tuple%7BAbstractString%7D&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt;。这等效于在参数上调用&lt;a href=&quot;#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;函数。内置字符串类型的串联始终会产生 &lt;code&gt;String&lt;/code&gt; 类型的值，但是其他字符串类型可能会选择返回适当类型的其他字符串。</target>
        </trans-unit>
        <trans-unit id="ce48b2ddcd6d1f0f5ea8babe3eb4d74d6a5100eb" translate="yes" xml:space="preserve">
          <source>Concatenate the input arrays along the specified dimensions in the iterable &lt;code&gt;dims&lt;/code&gt;. For dimensions not in &lt;code&gt;dims&lt;/code&gt;, all input arrays should have the same size, which will also be the size of the output array along that dimension. For dimensions in &lt;code&gt;dims&lt;/code&gt;, the size of the output array is the sum of the sizes of the input arrays along that dimension. If &lt;code&gt;dims&lt;/code&gt; is a single number, the different arrays are tightly stacked along that dimension. If &lt;code&gt;dims&lt;/code&gt; is an iterable containing several dimensions, this allows one to construct block diagonal matrices and their higher-dimensional analogues by simultaneously increasing several dimensions for every new input array and putting zero blocks elsewhere. For example, &lt;code&gt;cat(matrices...; dims=(1,2))&lt;/code&gt; builds a block diagonal matrix, i.e. a block matrix with &lt;code&gt;matrices[1]&lt;/code&gt;, &lt;code&gt;matrices[2]&lt;/code&gt;, ... as diagonal blocks and matching zero blocks away from the diagonal.</source>
          <target state="translated">将输入数组沿指定的维数串联在可迭代的 &lt;code&gt;dims&lt;/code&gt; 。对于非 &lt;code&gt;dims&lt;/code&gt; 尺寸，所有输入数组应具有相同的大小，这也将是沿该尺寸的输出数组的大小。对于 &lt;code&gt;dims&lt;/code&gt; 的尺寸，输出数组的大小是沿该尺寸的输入数组的大小之和。如果 &lt;code&gt;dims&lt;/code&gt; 是一个数字，则沿该维度紧密堆叠不同的数组。如果 &lt;code&gt;dims&lt;/code&gt; 是一个包含多个维度的可迭代对象，则可以通过同时为每个新输入数组增加几个维度并将零个块放在其他位置来构造块对角矩阵及其更高维的类似物。例如， &lt;code&gt;cat(matrices...; dims=(1,2))&lt;/code&gt; 建立一个块对角矩阵，即具有matrix &lt;code&gt;matrices[1]&lt;/code&gt; ， &lt;code&gt;matrices[2]&lt;/code&gt; ，...作为对角块并匹配距对角线零块的块矩阵。</target>
        </trans-unit>
        <trans-unit id="eec037fd21cdbe752cf956ee1da877b809e27461" translate="yes" xml:space="preserve">
          <source>Concatenation</source>
          <target state="translated">Concatenation</target>
        </trans-unit>
        <trans-unit id="e57bdd9a9f868f0fe536fc4a82988aa7ab5eb4ce" translate="yes" xml:space="preserve">
          <source>Concatenation and permutation</source>
          <target state="translated">连词和换词</target>
        </trans-unit>
        <trans-unit id="410d5f3b6433c7572682965906a75036cfaaf8dc" translate="yes" xml:space="preserve">
          <source>Concatenation syntax can similarly be prefixed with a type to specify the element type of the result.</source>
          <target state="translated">并列语法同样可以用类型作为前缀来指定结果的元素类型。</target>
        </trans-unit>
        <trans-unit id="4a0a67dece6f1d14e99beeba39e9ccd30856c117" translate="yes" xml:space="preserve">
          <source>Conceptually, a string is a &lt;em&gt;partial function&lt;/em&gt; from indices to characters: for some index values, no character value is returned, and instead an exception is thrown. This allows for efficient indexing into strings by the byte index of an encoded representation rather than by a character index, which cannot be implemented both efficiently and simply for variable-width encodings of Unicode strings.</source>
          <target state="translated">从概念上讲，字符串是从索引到字符的&lt;em&gt;部分函数&lt;/em&gt;：对于某些索引值，不返回任何字符值，而是引发异常。这允许通过编码表示形式的字节索引而不是字符索引有效地索引字符串，而这对于Unicode字符串的可变宽度编码既不能有效实现，也不能简单地实现。</target>
        </trans-unit>
        <trans-unit id="cbea4d31c59c78035ac57d6aea6a10af5718acc3" translate="yes" xml:space="preserve">
          <source>Concerning 1), a &lt;code&gt;rand&lt;/code&gt; method may happen to work automatically, but it's not officially supported and may break without warnings in a subsequent release.</source>
          <target state="translated">关于1）， &lt;code&gt;rand&lt;/code&gt; 方法可能会自动运行，但没有正式支持，并且可能在后续发行版中发出警告而中断。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="28d538a9ac44a88ceec5d9363eb9b5a0f1c92100" translate="yes" xml:space="preserve">
          <source>Concrete &lt;code&gt;Point&lt;/code&gt; types with different values of &lt;code&gt;T&lt;/code&gt; are never subtypes of each other:</source>
          <target state="translated">具有不同 &lt;code&gt;T&lt;/code&gt; 值的具体 &lt;code&gt;Point&lt;/code&gt; 类型永远不会是彼此的子类型：</target>
        </trans-unit>
        <trans-unit id="ac02f0743c4d1b96a2deef06f8e3cd49006763ce" translate="yes" xml:space="preserve">
          <source>Concrete number types</source>
          <target state="translated">具体数字类型</target>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="cf7bc3804abc264beaaad97d32ab5bc9d2653568" translate="yes" xml:space="preserve">
          <source>Condition number of the matrix &lt;code&gt;M&lt;/code&gt;, computed using the operator &lt;code&gt;p&lt;/code&gt;-norm. Valid values for &lt;code&gt;p&lt;/code&gt; are &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; (default), or &lt;code&gt;Inf&lt;/code&gt;.</source>
          <target state="translated">使用算子 &lt;code&gt;p&lt;/code&gt; -norm 计算的矩阵 &lt;code&gt;M&lt;/code&gt; 的条件数。为有效值 &lt;code&gt;p&lt;/code&gt; 是 &lt;code&gt;1&lt;/code&gt; ， &lt;code&gt;2&lt;/code&gt; （默认值），或 &lt;code&gt;Inf&lt;/code&gt; 文件。</target>
        </trans-unit>
        <trans-unit id="d01a0100c352f7c2f05bca55a82a8a86c8c531a6" translate="yes" xml:space="preserve">
          <source>Conditional Evaluation</source>
          <target state="translated">有条件的评价</target>
        </trans-unit>
        <trans-unit id="6b7fdfcad9d0149a68420bc1fb6ae6bcfa3f3e5a" translate="yes" xml:space="preserve">
          <source>Conditional evaluation allows portions of code to be evaluated or not evaluated depending on the value of a boolean expression. Here is the anatomy of the &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt; conditional syntax:</source>
          <target state="translated">条件评估允许根据布尔表达式的值评估或不评估部分代码。这是 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; 条件语法的剖析：</target>
        </trans-unit>
        <trans-unit id="e69f11134ba674beba00ec75d3e8520e70308ab6" translate="yes" xml:space="preserve">
          <source>Confetti Ball</source>
          <target state="translated">彩纸球</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="94f090695baa8f06a3ff8b47aa0ba0fa159cbae9" translate="yes" xml:space="preserve">
          <source>Configure a private writable depot using &lt;code&gt;pushfirst!(DEPOT_PATH, private_path)&lt;/code&gt; where &lt;code&gt;private_path&lt;/code&gt; is a path unique to this &lt;code&gt;julia&lt;/code&gt; process. This can also be done by setting environment variable &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; to &lt;code&gt;$private_path:$HOME/.julia&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;pushfirst!(DEPOT_PATH, private_path)&lt;/code&gt; 配置私有可写仓库，其中 &lt;code&gt;private_path&lt;/code&gt; 是该 &lt;code&gt;julia&lt;/code&gt; 进程唯一的路径。这也可以通过将环境变量 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 设置为 &lt;code&gt;$private_path:$HOME/.julia&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f11771dca2097f06e32650070e9cd19a4232960b" translate="yes" xml:space="preserve">
          <source>Configure the &lt;code&gt;delay&lt;/code&gt; between backtraces (measured in seconds), and the number &lt;code&gt;n&lt;/code&gt; of instruction pointers that may be stored. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Default settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order &lt;code&gt;(n, delay)&lt;/code&gt;.</source>
          <target state="translated">配置回溯之间的 &lt;code&gt;delay&lt;/code&gt; （以秒为单位），以及可能存储的指令指针的数量 &lt;code&gt;n&lt;/code&gt; 。每个指令指针都对应一行代码。回溯通常由一长串指令指针组成。可以通过不带任何参数调用此函数来获得默认设置，并且可以使用关键字或按顺序 &lt;code&gt;(n, delay)&lt;/code&gt; 独立设置每个默认设置。</target>
        </trans-unit>
        <trans-unit id="673a17c8ab08ef073f65d1d78eccb52e6d24ac72" translate="yes" xml:space="preserve">
          <source>Confounded Face</source>
          <target state="translated">糊涂脸</target>
        </trans-unit>
        <trans-unit id="dd9a3041d63a9bbabd149d1fe0496e16f5dc48c5" translate="yes" xml:space="preserve">
          <source>Confused Face</source>
          <target state="translated">糊涂脸</target>
        </trans-unit>
        <trans-unit id="eef1f855d92024dcbe93e39074e6eedcb5b887b2" translate="yes" xml:space="preserve">
          <source>Congruent With Dot Above</source>
          <target state="translated">与上面的点重合</target>
        </trans-unit>
        <trans-unit id="8d07e70d148195b15a902e326b6c8a5a632e9d80" translate="yes" xml:space="preserve">
          <source>Conical Taper</source>
          <target state="translated">锥度</target>
        </trans-unit>
        <trans-unit id="53cbbaf8dc8947fbf7f4e2c26b471f06d61fc371" translate="yes" xml:space="preserve">
          <source>Conjugate transpose array &lt;code&gt;src&lt;/code&gt; and store the result in the preallocated array &lt;code&gt;dest&lt;/code&gt;, which should have a size corresponding to &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt;. No in-place transposition is supported and unexpected results will happen if &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; have overlapping memory regions.</source>
          <target state="translated">共轭转置数组 &lt;code&gt;src&lt;/code&gt; 并将结果存储在预分配的数组 &lt;code&gt;dest&lt;/code&gt; 中，该数组的大小应对应于 &lt;code&gt;(size(src,2),size(src,1))&lt;/code&gt; 。不支持就地换位，如果 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;dest&lt;/code&gt; 具有重叠的内存区域，则会发生意外结果。</target>
        </trans-unit>
        <trans-unit id="a876d1109ed8e346f72690afb5f2db1f614132b6" translate="yes" xml:space="preserve">
          <source>Connect to the host &lt;code&gt;host&lt;/code&gt; on port &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">在端口 &lt;code&gt;port&lt;/code&gt; 上连接到主机 &lt;code&gt;host&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9004fa442291bfc2131d993b2837ea1204a6abf6" translate="yes" xml:space="preserve">
          <source>Connect to the named pipe / UNIX domain socket at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;path&lt;/code&gt; 连接到命名管道/ UNIX域套接字。</target>
        </trans-unit>
        <trans-unit id="7a431044d47389f7d8d41344d53c0bcbadc8fbb0" translate="yes" xml:space="preserve">
          <source>Connections between workers (using the in-built TCP/IP transport) is established in the following manner:</source>
          <target state="translated">工作者之间的连接(使用内置的TCP/IP传输)按以下方式建立。</target>
        </trans-unit>
        <trans-unit id="e713951b7382d19065c79a76c4ed128f1bd12fce" translate="yes" xml:space="preserve">
          <source>Consequently these can be useful for writing algorithms that work in arbitrary dimensions.</source>
          <target state="translated">因此,这些可以用于编写工作在任意维度的算法。</target>
        </trans-unit>
        <trans-unit id="6047fa413edddcfaf57a7f9b7f453ad4dba512df" translate="yes" xml:space="preserve">
          <source>Consequently, this child function gets 3 counts, even though the parent only gets one. The &quot;tree&quot; representation makes this much clearer, and for this reason (among others) is probably the most useful way to view the results.</source>
          <target state="translated">因此,这个子函数得到了3个计数,尽管父函数只得到一个。树状 &quot;表示法使这一点更加清晰,并且由于这个原因(以及其他原因),这可能是查看结果的最有用的方式。</target>
        </trans-unit>
        <trans-unit id="3eea8fbc0a3e336128fa5eb5ae85da5b38074305" translate="yes" xml:space="preserve">
          <source>Consequently, you are more likely to need to modify &lt;code&gt;delay&lt;/code&gt;, expressed in seconds, which sets the amount of time that Julia gets between snapshots to perform the requested computations. A very long-running job might not need frequent backtraces. The default setting is &lt;code&gt;delay = 0.001&lt;/code&gt;. Of course, you can decrease the delay as well as increase it; however, the overhead of profiling grows once the delay becomes similar to the amount of time needed to take a backtrace (~30 microseconds on the author's laptop).</source>
          <target state="translated">因此，您更有可能需要修改 &lt;code&gt;delay&lt;/code&gt; （以秒为单位），它设置了Julia在两次快照之间执行请求的计算所花费的时间。一项长期运行的工作可能不需要频繁回溯。默认设置为 &lt;code&gt;delay = 0.001&lt;/code&gt; 。当然，您可以减少延迟，也可以增加延迟。但是，一旦延迟变得与进行回溯（在作者的笔记本电脑上约30微秒）所需的时间相似，分析的开销就会增加。</target>
        </trans-unit>
        <trans-unit id="0d0b9ea156f51f38c626060e2a890817b373f8db" translate="yes" xml:space="preserve">
          <source>Consider a discrete distribution, where numbers &lt;code&gt;1:n&lt;/code&gt; are drawn with given probabilities that sum to one. When many values are needed from this distribution, the fastest method is using an &lt;a href=&quot;https://en.wikipedia.org/wiki/Alias_method&quot;&gt;alias table&lt;/a&gt;. We don't provide the algorithm for building such a table here, but suppose it is available in &lt;code&gt;make_alias_table(probabilities)&lt;/code&gt; instead, and &lt;code&gt;draw_number(rng, alias_table)&lt;/code&gt; can be used to draw a random number from it.</source>
          <target state="translated">考虑一个离散分布，其中以给定的概率相加得出数字 &lt;code&gt;1:n&lt;/code&gt; 。当需要从此分布中获取许多值时，最快的方法是使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Alias_method&quot;&gt;别名表&lt;/a&gt;。我们在这里没有提供用于构建此类表的算法，但是假设它可以在 &lt;code&gt;make_alias_table(probabilities)&lt;/code&gt; 中使用，而 &lt;code&gt;draw_number(rng, alias_table)&lt;/code&gt; 可以用于从中提取随机数。</target>
        </trans-unit>
        <trans-unit id="ad2b5b66bbff4ce303aefd6b3469a1ca820858f7" translate="yes" xml:space="preserve">
          <source>Consider a function which logs a warning, and several debug messages:</source>
          <target state="translated">考虑一个函数,它可以记录一个警告和一些调试信息。</target>
        </trans-unit>
        <trans-unit id="b41c44bc4a6bcb6e5de4d96d38a9a8675a1f8d16" translate="yes" xml:space="preserve">
          <source>Consider a simple example using channels for inter-task communication. We start 4 tasks to process data from a single &lt;code&gt;jobs&lt;/code&gt; channel. Jobs, identified by an id (&lt;code&gt;job_id&lt;/code&gt;), are written to the channel. Each task in this simulation reads a &lt;code&gt;job_id&lt;/code&gt;, waits for a random amount of time and writes back a tuple of &lt;code&gt;job_id&lt;/code&gt; and the simulated time to the results channel. Finally all the &lt;code&gt;results&lt;/code&gt; are printed out.</source>
          <target state="translated">考虑一个使用通道进行任务间通信的简单示例。我们启动4个任务来处理来自单个 &lt;code&gt;jobs&lt;/code&gt; 通道的数据。由ID（ &lt;code&gt;job_id&lt;/code&gt; ）标识的作业将写入通道。此模拟中的每个任务都读取一个 &lt;code&gt;job_id&lt;/code&gt; ，等待随机的时间，然后将一个元组 &lt;code&gt;job_id&lt;/code&gt; 和模拟的时间写回到结果通道。最后，所有 &lt;code&gt;results&lt;/code&gt; 都将打印出来。</target>
        </trans-unit>
        <trans-unit id="eb7131848d45ace01b38d4617e6d98b8e79ccee7" translate="yes" xml:space="preserve">
          <source>Consider the following contrived example. Imagine we wanted to write a function that accepts a &lt;a href=&quot;../../base/arrays/index#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; and returns a square &lt;a href=&quot;../../base/arrays/index#Base.Matrix&quot;&gt;&lt;code&gt;Matrix&lt;/code&gt;&lt;/a&gt; with either the rows or the columns filled with copies of the input vector. Assume that it is not important whether rows or columns are filled with these copies (perhaps the rest of the code can be easily adapted accordingly). We could conceivably do this in at least four ways (in addition to the recommended call to the built-in &lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">考虑下面的人为例子。想象一下，我们想编写一个函数，该函数接受一个&lt;a href=&quot;../../base/arrays/index#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt;并返回一个正方形&lt;a href=&quot;../../base/arrays/index#Base.Matrix&quot;&gt; &lt;code&gt;Matrix&lt;/code&gt; &lt;/a&gt;，其中行或列填充有输入向量的副本。假设用这些副本填充行或列并不重要（也许可以轻松地相应地修改其余代码）。可以想象，至少可以通过四种方式来做到这一点（除了推荐的对内置&lt;a href=&quot;../../base/arrays/index#Base.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt;调用）：</target>
        </trans-unit>
        <trans-unit id="aea7505a758167e8e584f36010a94eb7238c397b" translate="yes" xml:space="preserve">
          <source>Consider the following example that defines an inner function:</source>
          <target state="translated">考虑以下定义一个内部函数的例子。</target>
        </trans-unit>
        <trans-unit id="1cf37589ccf59f2442553bb8984c73cb434ce446" translate="yes" xml:space="preserve">
          <source>Consider the following two examples. The first one returns the exception object inline, the second a 0 in place of any exception:</source>
          <target state="translated">考虑以下两个例子。第一个例子是内联返回异常对象,第二个例子是用0代替任何异常。</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">请考虑以下几点:</target>
        </trans-unit>
        <trans-unit id="0c895d2fdc1a30ac558dfcb63c363445e0e645e1" translate="yes" xml:space="preserve">
          <source>Consider the printed output from the following:</source>
          <target state="translated">请考虑以下的打印输出。</target>
        </trans-unit>
        <trans-unit id="b8e04b708ae9ae6b8c54714632e7d8df9880585c" translate="yes" xml:space="preserve">
          <source>Consider this toy script which simply calls each subprocess, instantiate its rank and when the master process is reached, performs the ranks' sum</source>
          <target state="translated">考虑一下这个玩具脚本,它简单地调用每个子进程,实例化它的等级,当达到主进程时,执行等级之和。</target>
        </trans-unit>
        <trans-unit id="da61269d791580f869cabd4bd9de4046eac9f72f" translate="yes" xml:space="preserve">
          <source>Consider using &lt;code&gt;!ismutable(v)&lt;/code&gt; instead, as &lt;code&gt;isimmutable(v)&lt;/code&gt; will be replaced by &lt;code&gt;!ismutable(v)&lt;/code&gt; in a future release. (Since Julia 1.5)</source>
          <target state="translated">考虑使用 &lt;code&gt;!ismutable(v)&lt;/code&gt; 代替，如 &lt;code&gt;isimmutable(v)&lt;/code&gt; 将被替换 &lt;code&gt;!ismutable(v)&lt;/code&gt; 在将来的版本。（自Julia 1.5起）</target>
        </trans-unit>
        <trans-unit id="85eb0a345158a422b527393dc1bc1495a2bd3a98" translate="yes" xml:space="preserve">
          <source>Consider using views for slices</source>
          <target state="translated">考虑将视图用于切片</target>
        </trans-unit>
        <trans-unit id="14ed4bf7ae010ff51a59d1ab1db2ea68d0dd0dd0" translate="yes" xml:space="preserve">
          <source>Considered alone, this may seem relatively trivial; &lt;code&gt;CartesianIndex&lt;/code&gt; simply gathers multiple integers together into one object that represents a single multidimensional index. When combined with other indexing forms and iterators that yield &lt;code&gt;CartesianIndex&lt;/code&gt;es, however, this can produce very elegant and efficient code. See &lt;a href=&quot;#Iteration&quot;&gt;Iteration&lt;/a&gt; below, and for some more advanced examples, see &lt;a href=&quot;https://julialang.org/blog/2016/02/iteration&quot;&gt;this blog post on multidimensional algorithms and iteration&lt;/a&gt;.</source>
          <target state="translated">单独考虑，这似乎比较琐碎。 &lt;code&gt;CartesianIndex&lt;/code&gt; 只是将多个整数一起收集到一个对象中，该对象表示一个多维索引。但是，当与产生 &lt;code&gt;CartesianIndex&lt;/code&gt; es的其他索引形式和迭代器结合使用时，这会产生非常优雅和高效的代码。请参阅下面的&lt;a href=&quot;#Iteration&quot;&gt;迭代&lt;/a&gt;，以及更多高级示例，请参阅&lt;a href=&quot;https://julialang.org/blog/2016/02/iteration&quot;&gt;此博客文章有关多维算法和迭代的内容&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ec4162d71dc6c558c88cb225144c9bcd26084f48" translate="yes" xml:space="preserve">
          <source>Considered alone, this may seem relatively trivial; &lt;code&gt;CartesianIndex&lt;/code&gt; simply gathers multiple integers together into one object that represents a single multidimensional index. When combined with other indexing forms and iterators that yield &lt;code&gt;CartesianIndex&lt;/code&gt;es, however, this can produce very elegant and efficient code. See &lt;a href=&quot;#Iteration-1&quot;&gt;Iteration&lt;/a&gt; below, and for some more advanced examples, see &lt;a href=&quot;https://julialang.org/blog/2016/02/iteration&quot;&gt;this blog post on multidimensional algorithms and iteration&lt;/a&gt;.</source>
          <target state="translated">单独考虑，这似乎比较琐碎。 &lt;code&gt;CartesianIndex&lt;/code&gt; 只是将多个整数一起收集到一个对象中，该对象表示一个多维索引。但是，当与产生 &lt;code&gt;CartesianIndex&lt;/code&gt; es的其他索引形式和迭代器结合使用时，这会产生非常优雅和高效的代码。请参阅下面的&lt;a href=&quot;#Iteration-1&quot;&gt;迭代&lt;/a&gt;，以及更多高级示例，请参阅&lt;a href=&quot;https://julialang.org/blog/2016/02/iteration&quot;&gt;此博客文章有关多维算法和迭代的内容&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="90dc44bf4503df06cc88bdeed11978534d89fa68" translate="yes" xml:space="preserve">
          <source>Consistent serialization:</source>
          <target state="translated">一致的序列化。</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="f20797a3b29239e673a22d9f965a161574684bb4" translate="yes" xml:space="preserve">
          <source>Constants involving most Julia objects that are not produced by &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; do not need to be placed in &lt;code&gt;__init__&lt;/code&gt;: their definitions can be precompiled and loaded from the cached module image. This includes complicated heap-allocated objects like arrays. However, any routine that returns a raw pointer value must be called at runtime for precompilation to work (&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr&lt;/code&gt;&lt;/a&gt; objects will turn into null pointers unless they are hidden inside an &lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt;&lt;code&gt;isbits&lt;/code&gt;&lt;/a&gt; object). This includes the return values of the Julia functions &lt;code&gt;cfunction&lt;/code&gt; and &lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt;&lt;code&gt;pointer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">涉及大多数不是由&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;生成的Julia对象的常量不需要放在 &lt;code&gt;__init__&lt;/code&gt; 中：可以预编译它们的定义并从缓存的模块映像中加载它们。这包括复杂的堆分配对象，例如数组。但是，必须在运行时调用任何返回原始指针值的例程以进行预编译才能工作（&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr&lt;/code&gt; &lt;/a&gt;对象将变为空指针，除非它们隐藏在&lt;a href=&quot;../../base/base/index#Base.isbits&quot;&gt; &lt;code&gt;isbits&lt;/code&gt; &lt;/a&gt;对象内）。这包括Julia函数 &lt;code&gt;cfunction&lt;/code&gt; 和&lt;a href=&quot;../../base/c/index#Base.pointer&quot;&gt; &lt;code&gt;pointer&lt;/code&gt; &lt;/a&gt;的返回值。</target>
        </trans-unit>
        <trans-unit id="f3dbbafc2bcd268f72cf3af03b54be6b51a2334b" translate="yes" xml:space="preserve">
          <source>Construct</source>
          <target state="translated">Construct</target>
        </trans-unit>
        <trans-unit id="f97e2d9c4b65aa73bfe3ea4abacc7c7c96df97c2" translate="yes" xml:space="preserve">
          <source>Construct &lt;a href=&quot;../arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; from two &lt;code&gt;CartesianIndex&lt;/code&gt;.</source>
          <target state="translated">构建&lt;a href=&quot;../arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt;从两个 &lt;code&gt;CartesianIndex&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="193781393b9a991b412b9666ff3363d59256fb37" translate="yes" xml:space="preserve">
          <source>Construct a 1-d array of the specified type. This is usually called with the syntax &lt;code&gt;Type[]&lt;/code&gt;. Element values can be specified using &lt;code&gt;Type[a,b,c,...]&lt;/code&gt;.</source>
          <target state="translated">构造指定类型的一维数组。通常使用语法 &lt;code&gt;Type[]&lt;/code&gt; 来调用它。可以使用 &lt;code&gt;Type[a,b,c,...]&lt;/code&gt; 指定元素值。</target>
        </trans-unit>
        <trans-unit id="822ae5747d235413c4d6b4787626679a1b185a0e" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; generated by the given iterable object. The shape is inferred from the &lt;code&gt;itr&lt;/code&gt; object.</source>
          <target state="translated">构造一个由给定的可迭代对象生成的&lt;a href=&quot;#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt;。从 &lt;code&gt;itr&lt;/code&gt; 对象推断出形状。</target>
        </trans-unit>
        <trans-unit id="b8d781f22b5f31f1ad3ff32a6a5b759f677769b6" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Matrix&quot;&gt;&lt;code&gt;Matrix{T}&lt;/code&gt;&lt;/a&gt; of size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt;, initialized with &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">构造一个大小为 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 的&lt;a href=&quot;#Base.Matrix&quot;&gt; &lt;code&gt;Matrix{T}&lt;/code&gt; &lt;/a&gt;，并使用&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;条目进行初始化。元素类型 &lt;code&gt;T&lt;/code&gt; 必须能够保留这些值，即 &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2c66efe8a7c37a7a479116847647815fc94a32d" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Matrix&quot;&gt;&lt;code&gt;Matrix{T}&lt;/code&gt;&lt;/a&gt; of size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt;, initialized with &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">构造大小为 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 的&lt;a href=&quot;#Base.Matrix&quot;&gt; &lt;code&gt;Matrix{T}&lt;/code&gt; &lt;/a&gt;，不进行&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;初始化。元素类型 &lt;code&gt;T&lt;/code&gt; 必须能够保留这些值，即 &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="271b0e3ba477679c21eb060d4bf61dcf1916b610" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; of the values generated by the given iterable object, or an empty set. Should be used instead of &lt;a href=&quot;#Base.BitSet&quot;&gt;&lt;code&gt;BitSet&lt;/code&gt;&lt;/a&gt; for sparse integer sets, or for sets of arbitrary objects.</source>
          <target state="translated">构造一个&lt;a href=&quot;#Base.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt;由给定迭代的对象，或一个空集生成的值的。对于稀疏整数集或任意对象集，应使用&lt;a href=&quot;#Base.BitSet&quot;&gt; &lt;code&gt;BitSet&lt;/code&gt; &lt;/a&gt;代替BitSet。</target>
        </trans-unit>
        <trans-unit id="6ed69370b1f85dc30500cbd3df9bf2409de8527b" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector{T}&lt;/code&gt;&lt;/a&gt; of length &lt;code&gt;m&lt;/code&gt;, initialized with &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">构造长度为 &lt;code&gt;m&lt;/code&gt; 的&lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector{T}&lt;/code&gt; &lt;/a&gt;，并使用&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;条目进行初始化。元素类型 &lt;code&gt;T&lt;/code&gt; 必须能够保留这些值，即 &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8cfe5534e0cb4dceb12e8df87c966d7782ee710b" translate="yes" xml:space="preserve">
          <source>Construct a &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector{T}&lt;/code&gt;&lt;/a&gt; of length &lt;code&gt;m&lt;/code&gt;, initialized with &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">构造一个长度为 &lt;code&gt;m&lt;/code&gt; 的&lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector{T}&lt;/code&gt; &lt;/a&gt;，不使用&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;条目进行初始化。元素类型 &lt;code&gt;T&lt;/code&gt; 必须能够保留这些值，即 &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc422a0b0965db4d8a6477be563e87c89e3c1e29" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Bidiagonal&lt;/code&gt; matrix from the main diagonal of &lt;code&gt;A&lt;/code&gt; and its first super- (if &lt;code&gt;uplo=:U&lt;/code&gt;) or sub-diagonal (if &lt;code&gt;uplo=:L&lt;/code&gt;).</source>
          <target state="translated">从 &lt;code&gt;A&lt;/code&gt; 的主对角线及其第一个超对角线（如果 &lt;code&gt;uplo=:U&lt;/code&gt; ）或次对角线（如果 &lt;code&gt;uplo=:L&lt;/code&gt; ）构造一个 &lt;code&gt;Bidiagonal&lt;/code&gt; 对角矩阵。</target>
        </trans-unit>
        <trans-unit id="1b2e58bf227bdb08afbbc5fd16b8dde5aee9225c" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;CompoundPeriod&lt;/code&gt; from a &lt;code&gt;Vector&lt;/code&gt; of &lt;code&gt;Period&lt;/code&gt;s. All &lt;code&gt;Period&lt;/code&gt;s of the same type will be added together.</source>
          <target state="translated">构建一个 &lt;code&gt;CompoundPeriod&lt;/code&gt; 从 &lt;code&gt;Vector&lt;/code&gt; 的 &lt;code&gt;Period&lt;/code&gt; 秒。相同类型的所有 &lt;code&gt;Period&lt;/code&gt; 将被加在一起。</target>
        </trans-unit>
        <trans-unit id="4b09b541e4ed1f0aba3333bcba37da80754811dc" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Date&lt;/code&gt; by parsing the &lt;code&gt;d&lt;/code&gt; date string following the pattern given in the &lt;code&gt;format&lt;/code&gt; string.</source>
          <target state="translated">通过按照 &lt;code&gt;format&lt;/code&gt; 字符串中指定的模式分析 &lt;code&gt;d&lt;/code&gt; 日期字符串来构造 &lt;code&gt;Date&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af2403a6b54b9170043e5f46c873bd44e2c86e65" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Date&lt;/code&gt; type by &lt;code&gt;Period&lt;/code&gt; type parts. Arguments may be in any order. &lt;code&gt;Date&lt;/code&gt; parts not provided will default to the value of &lt;code&gt;Dates.default(period)&lt;/code&gt;.</source>
          <target state="translated">按 &lt;code&gt;Period&lt;/code&gt; 类型部分构造 &lt;code&gt;Date&lt;/code&gt; 类型。参数可以是任何顺序。未提供的 &lt;code&gt;Date&lt;/code&gt; 部分将默认为 &lt;code&gt;Dates.default(period)&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="f444be57b1a99cc75b882799b5ad5c2d4dfae5e1" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Date&lt;/code&gt; type by parts. Arguments must be convertible to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按部分构造一个 &lt;code&gt;Date&lt;/code&gt; 类型。参数必须可转换为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c67c8fc150a64df871383e42ca74e3f64cce0b21" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; by parsing the &lt;code&gt;dt&lt;/code&gt; date time string following the pattern given in the &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object. Similar to &lt;code&gt;DateTime(::AbstractString, ::AbstractString)&lt;/code&gt; but more efficient when repeatedly parsing similarly formatted date time strings with a pre-created &lt;code&gt;DateFormat&lt;/code&gt; object.</source>
          <target state="translated">通过按照&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt;对象中给定的模式解析 &lt;code&gt;dt&lt;/code&gt; 日期时间字符串来构造 &lt;code&gt;DateTime&lt;/code&gt; 。与 &lt;code&gt;DateTime(::AbstractString, ::AbstractString)&lt;/code&gt; 相似，但在使用预先创建的 &lt;code&gt;DateFormat&lt;/code&gt; 对象重复解析格式相似的日期时间字符串时，效率更高。</target>
        </trans-unit>
        <trans-unit id="aea78ff467ecef7879256770936c29566865c81d" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; by parsing the &lt;code&gt;dt&lt;/code&gt; date time string following the pattern given in the &lt;code&gt;format&lt;/code&gt; string.</source>
          <target state="translated">按照 &lt;code&gt;format&lt;/code&gt; 字符串中给出的模式，通过解析 &lt;code&gt;dt&lt;/code&gt; 日期时间字符串来构造 &lt;code&gt;DateTime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e93eb9f3900c323d0aafcfa89df6646124b6b543" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; type by &lt;code&gt;Period&lt;/code&gt; type parts. Arguments may be in any order. DateTime parts not provided will default to the value of &lt;code&gt;Dates.default(period)&lt;/code&gt;.</source>
          <target state="translated">通过 &lt;code&gt;Period&lt;/code&gt; 类型的部件构造 &lt;code&gt;DateTime&lt;/code&gt; 类型。参数可以是任何顺序。未提供的DateTime部分将默认为 &lt;code&gt;Dates.default(period)&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="383850982e161143cb3f8464b59c38e89b3a5646" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;DateTime&lt;/code&gt; type by parts. Arguments must be convertible to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按部分构造 &lt;code&gt;DateTime&lt;/code&gt; 类型。参数必须可转换为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="775f3a88f10d84f3621ead39c164700c56bb2844" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Day&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用给定的 &lt;code&gt;v&lt;/code&gt; 值构造 &lt;code&gt;Day&lt;/code&gt; 对象。输入必须可以无损地转换为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40609c2c820790d0a3c1eb68f785ce1c82714463" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;GitBlame&lt;/code&gt; object for the file at &lt;code&gt;path&lt;/code&gt;, using change information gleaned from the history of &lt;code&gt;repo&lt;/code&gt;. The &lt;code&gt;GitBlame&lt;/code&gt; object records who changed which chunks of the file when, and how. &lt;code&gt;options&lt;/code&gt; controls how to separate the contents of the file and which commits to probe - see &lt;a href=&quot;#LibGit2.BlameOptions&quot;&gt;&lt;code&gt;BlameOptions&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">使用从 &lt;code&gt;repo&lt;/code&gt; 历史中收集的更改信息，为 &lt;code&gt;path&lt;/code&gt; 处的文件构造一个 &lt;code&gt;GitBlame&lt;/code&gt; 对象。该 &lt;code&gt;GitBlame&lt;/code&gt; 对象记录谁改变了文件时，如何哪个块。 &lt;code&gt;options&lt;/code&gt; 控制如何分隔文件的内容以及提交探针的内容- 有关更多信息，请参见&lt;a href=&quot;#LibGit2.BlameOptions&quot;&gt; &lt;code&gt;BlameOptions&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cfac8ee20a7a93b71932d5ea24ca6e9446304d80" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Hermitian&lt;/code&gt; view of the upper (if &lt;code&gt;uplo = :U&lt;/code&gt;) or lower (if &lt;code&gt;uplo = :L&lt;/code&gt;) triangle of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">构造矩阵 &lt;code&gt;A&lt;/code&gt; 的上三角（如果 &lt;code&gt;uplo = :U&lt;/code&gt; ）或下三角（如果 &lt;code&gt;uplo = :L&lt;/code&gt; ）的 &lt;code&gt;Hermitian&lt;/code&gt; 视图。</target>
        </trans-unit>
        <trans-unit id="53aa9b9ef1c879e549044ea23efdf5498813a414" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;LowerTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">构造矩阵 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;LowerTriangular&lt;/code&gt; 视图。</target>
        </trans-unit>
        <trans-unit id="a2be7157682b3e7c1d399140f4ed110f2601b93e" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Month&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用给定的 &lt;code&gt;v&lt;/code&gt; 值构造一个 &lt;code&gt;Month&lt;/code&gt; 对象。输入必须可以无损地转换为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6e17e322b24ea8482c083700759e1a4aa7fc99ff" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Pair&lt;/code&gt; object with type &lt;code&gt;Pair{typeof(x), typeof(y)}&lt;/code&gt;. The elements are stored in the fields &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They can also be accessed via iteration (but a &lt;code&gt;Pair&lt;/code&gt; is treated as a single &quot;scalar&quot; for broadcasting operations).</source>
          <target state="translated">构造一个类型为 &lt;code&gt;Pair{typeof(x), typeof(y)}&lt;/code&gt; 的 &lt;code&gt;Pair&lt;/code&gt; 对象。元素存储在 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;second&lt;/code&gt; 字段中。也可以通过迭代来访问它们（但对于广播操作， &lt;code&gt;Pair&lt;/code&gt; 被视为单个&amp;ldquo;标量&amp;rdquo;）。</target>
        </trans-unit>
        <trans-unit id="5ee95a95477044367d4547393ce2e04832e8eaee" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Pair&lt;/code&gt; object with type &lt;code&gt;Pair{typeof(x), typeof(y)}&lt;/code&gt;. The elements are stored in the fields &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;. They can also be accessed via iteration.</source>
          <target state="translated">构造一个类型为 &lt;code&gt;Pair{typeof(x), typeof(y)}&lt;/code&gt; 的 &lt;code&gt;Pair&lt;/code&gt; 对象。元素存储在 &lt;code&gt;first&lt;/code&gt; 和 &lt;code&gt;second&lt;/code&gt; 字段中。也可以通过迭代访问它们。</target>
        </trans-unit>
        <trans-unit id="e945148a5d12b75c7c3ce9201b6e5d5ca81cafce" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Period&lt;/code&gt; type with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用给定的 &lt;code&gt;v&lt;/code&gt; 值构造一个 &lt;code&gt;Period&lt;/code&gt; 类型。输入必须可以无损地转换为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="36f2454002107f0f60d937848f0e4956684fd113" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;SharedArray&lt;/code&gt; backed by the file &lt;code&gt;filename&lt;/code&gt;, with element type &lt;code&gt;T&lt;/code&gt; (must be a bits type) and size &lt;code&gt;dims&lt;/code&gt;, across the processes specified by &lt;code&gt;pids&lt;/code&gt; - all of which have to be on the same host. This file is mmapped into the host memory, with the following consequences:</source>
          <target state="translated">在 &lt;code&gt;SharedArray&lt;/code&gt; 指定的进程中构造一个由文件 &lt;code&gt;filename&lt;/code&gt; 支持的，元素类型为 &lt;code&gt;T&lt;/code&gt; （必须为位类型），大小为 &lt;code&gt;dims&lt;/code&gt; 的 &lt;code&gt;pids&lt;/code&gt; 所有这些进程必须位于同一主机上。该文件被映射到主机内存中，具有以下后果：</target>
        </trans-unit>
        <trans-unit id="30559885baa00f426d3195c8bac3dc6b30de76a2" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;SharedArray&lt;/code&gt; of a bits type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;dims&lt;/code&gt; across the processes specified by &lt;code&gt;pids&lt;/code&gt; - all of which have to be on the same host. If &lt;code&gt;N&lt;/code&gt; is specified by calling &lt;code&gt;SharedArray{T,N}(dims)&lt;/code&gt;, then &lt;code&gt;N&lt;/code&gt; must match the length of &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">构建 &lt;code&gt;SharedArray&lt;/code&gt; 一个比特的键入 &lt;code&gt;T&lt;/code&gt; 和尺寸 &lt;code&gt;dims&lt;/code&gt; 横跨由指定的过程 &lt;code&gt;pids&lt;/code&gt; -所有这些都必须在同一主机上。如果 &lt;code&gt;N&lt;/code&gt; 通过调用指定 &lt;code&gt;SharedArray{T,N}(dims)&lt;/code&gt; ，然后 &lt;code&gt;N&lt;/code&gt; 必须的长度匹配 &lt;code&gt;dims&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bad6ab2e9afc35f90c2261027da0cbb9fa911828" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Symmetric&lt;/code&gt; view of the upper (if &lt;code&gt;uplo = :U&lt;/code&gt;) or lower (if &lt;code&gt;uplo = :L&lt;/code&gt;) triangle of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">构造矩阵 &lt;code&gt;A&lt;/code&gt; 的上三角（如果 &lt;code&gt;uplo = :U&lt;/code&gt; ）或下三角（如果 &lt;code&gt;uplo = :L&lt;/code&gt; ）的 &lt;code&gt;Symmetric&lt;/code&gt; 视图。</target>
        </trans-unit>
        <trans-unit id="512b84d9393d18f32c44b67c1ceac4788e65f773" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Time&lt;/code&gt; type by &lt;code&gt;Period&lt;/code&gt; type parts. Arguments may be in any order. &lt;code&gt;Time&lt;/code&gt; parts not provided will default to the value of &lt;code&gt;Dates.default(period)&lt;/code&gt;.</source>
          <target state="translated">按 &lt;code&gt;Period&lt;/code&gt; 类型部分构造 &lt;code&gt;Time&lt;/code&gt; 类型。参数可以是任何顺序。未提供的 &lt;code&gt;Time&lt;/code&gt; 部分将默认为 &lt;code&gt;Dates.default(period)&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="57a83629f577977e6138536698bfa2b11168ae04" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Time&lt;/code&gt; type by parts. Arguments must be convertible to &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">按部分构造一个 &lt;code&gt;Time&lt;/code&gt; 类型。参数必须可转换为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e1fa0f5c37012652505e3cdf521c5117c6215fe1" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;UnitLowerTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;. Such a view has the &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; on its diagonal.</source>
          <target state="translated">构造矩阵 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;UnitLowerTriangular&lt;/code&gt; 视图。这样的视图具有&lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt;所述的&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;A&lt;/code&gt; 在其对角线上。</target>
        </trans-unit>
        <trans-unit id="dbf534772f21c312ceb366d56988564faadc9083" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Week&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用给定的 &lt;code&gt;v&lt;/code&gt; 值构造 &lt;code&gt;Week&lt;/code&gt; 对象。输入必须可以无损地转换为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="a5bdc0f4ba0074541be92fccdc87cc517c888054" translate="yes" xml:space="preserve">
          <source>Construct a &lt;code&gt;Year&lt;/code&gt; object with the given &lt;code&gt;v&lt;/code&gt; value. Input must be losslessly convertible to an &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用给定的 &lt;code&gt;v&lt;/code&gt; 值构造 &lt;code&gt;Year&lt;/code&gt; 对象。输入必须可以无损地转换为&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="be0daf784d16844ae921191b30baa069213224e7" translate="yes" xml:space="preserve">
          <source>Construct a date formatting object that can be used for parsing date strings or formatting a date object as a string. The following character codes can be used to construct the &lt;code&gt;format&lt;/code&gt; string:</source>
          <target state="translated">构造一个日期格式化对象，该对象可用于解析日期字符串或将日期对象格式化为字符串。以下字符代码可用于构造 &lt;code&gt;format&lt;/code&gt; 字符串：</target>
        </trans-unit>
        <trans-unit id="4cd437ecc9656e44160fa4c4fc658708ac1ef9c1" translate="yes" xml:space="preserve">
          <source>Construct a git hash object from the given string, returning a &lt;code&gt;GitShortHash&lt;/code&gt; if the string is shorter than 40 hexadecimal digits, otherwise a &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">从给定的字符串构造一个git hash对象，如果该字符串小于40个十六进制数字，则返回 &lt;code&gt;GitShortHash&lt;/code&gt; ，否则 &lt;code&gt;GitHash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="95915c31d29fdf119affd21fc1204ab467ac45da" translate="yes" xml:space="preserve">
          <source>Construct a matrix from &lt;code&gt;Pair&lt;/code&gt;s of diagonals and vectors. Vector &lt;code&gt;kv.second&lt;/code&gt; will be placed on the &lt;code&gt;kv.first&lt;/code&gt; diagonal. By default the matrix is square and its size is inferred from &lt;code&gt;kv&lt;/code&gt;, but a non-square size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; (padded with zeros as needed) can be specified by passing &lt;code&gt;m,n&lt;/code&gt; as the first arguments.</source>
          <target state="translated">根据对角线和向量 &lt;code&gt;Pair&lt;/code&gt; 构造一个矩阵。向量 &lt;code&gt;kv.second&lt;/code&gt; 将放置在 &lt;code&gt;kv.first&lt;/code&gt; 对角线上。默认情况下，矩阵是正方形，并且其大小是从 &lt;code&gt;kv&lt;/code&gt; 推断出来的，但是可以通过将 &lt;code&gt;m,n&lt;/code&gt; 作为第一个参数来指定非正方形大小 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; （根据需要用零填充）。</target>
        </trans-unit>
        <trans-unit id="ea8e23701feccd63e17e0b0029ede99044fa274d" translate="yes" xml:space="preserve">
          <source>Construct a matrix from the diagonal of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;A&lt;/code&gt; 的对角线构造一个矩阵。</target>
        </trans-unit>
        <trans-unit id="90f773e3d113876b6deb8a09e0f5de33ba790fb7" translate="yes" xml:space="preserve">
          <source>Construct a matrix with &lt;code&gt;V&lt;/code&gt; as its diagonal.</source>
          <target state="translated">构造一个以 &lt;code&gt;V&lt;/code&gt; 为对角线的矩阵。</target>
        </trans-unit>
        <trans-unit id="25f4b3c401d1f835673ca7161bdff8b451269e90" translate="yes" xml:space="preserve">
          <source>Construct a matrix with elements of the vector as diagonal elements. By default (if &lt;code&gt;size=nothing&lt;/code&gt;), the matrix is square and its size is given by &lt;code&gt;length(v)&lt;/code&gt;, but a non-square size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; can be specified by passing &lt;code&gt;m,n&lt;/code&gt; as the first arguments.</source>
          <target state="translated">用向量的元素作为对角元素构造一个矩阵。默认情况下（如果 &lt;code&gt;size=nothing&lt;/code&gt; ），矩阵是正方形，并且其大小由 &lt;code&gt;length(v)&lt;/code&gt; 给出，但是可以通过将 &lt;code&gt;m,n&lt;/code&gt; 作为第一个参数来指定非正方形大小 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f217bb0e7b35012b29fdda1729b0fa09e13438ab" translate="yes" xml:space="preserve">
          <source>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. If the same key is present in another collection, the value for that key will be the value it has in the last collection listed.</source>
          <target state="translated">从给定的集合中构建一个合并的集合。如果有必要,所产生的集合的类型将被提升以适应合并集合的类型。如果相同的键存在于另一个集合中,那么该键的值将是它在最后一个集合中的值。</target>
        </trans-unit>
        <trans-unit id="f1617b1cc87aa299b6833917b0e46a1a4940ff17" translate="yes" xml:space="preserve">
          <source>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function.</source>
          <target state="translated">从给定的集合中构建一个合并的集合。如果有必要,产生的集合的类型将被提升以适应合并集合的类型。具有相同键的值将使用组合函数进行合并。</target>
        </trans-unit>
        <trans-unit id="f2de24e56968962e72117fcb0066f859df18b8a7" translate="yes" xml:space="preserve">
          <source>Construct a merged collection from the given collections. If necessary, the types of the resulting collection will be promoted to accommodate the types of the merged collections. Values with the same key will be combined using the combiner function. The curried form &lt;code&gt;mergewith(combine)&lt;/code&gt; returns the function &lt;code&gt;(args...) -&amp;gt; mergewith(combine, args...)&lt;/code&gt;.</source>
          <target state="translated">从给定的集合构造一个合并的集合。如有必要，将提升结果集合的类型以适应合并的集合的类型。具有相同键的值将使用合并器功能合并。咖喱形式 &lt;code&gt;mergewith(combine)&lt;/code&gt; 返回函数 &lt;code&gt;(args...) -&amp;gt; mergewith(combine, args...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60ada712a6bba4831ea5117dcc593947b90a8eea" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;code&gt;Cmd&lt;/code&gt; object, representing an external program and arguments, from &lt;code&gt;cmd&lt;/code&gt;, while changing the settings of the optional keyword arguments:</source>
          <target state="translated">从 &lt;code&gt;cmd&lt;/code&gt; 构造一个新的 &lt;code&gt;Cmd&lt;/code&gt; 对象，表示一个外部程序和参数，同时更改可选关键字参数的设置：</target>
        </trans-unit>
        <trans-unit id="921bc3f38441b69eaebf923e14b05b0ead5fb49a" translate="yes" xml:space="preserve">
          <source>Construct a new named tuple by merging two or more existing ones, in a left-associative manner. Merging proceeds left-to-right, between pairs of named tuples, and so the order of fields present in both the leftmost and rightmost named tuples take the same position as they are found in the leftmost named tuple. However, values are taken from matching fields in the rightmost named tuple that contains that field. Fields present in only the rightmost named tuple of a pair are appended at the end. A fallback is implemented for when only a single named tuple is supplied, with signature &lt;code&gt;merge(a::NamedTuple)&lt;/code&gt;.</source>
          <target state="translated">通过以左关联方式合并两个或多个现有元组来构造新的命名元组。合并在成对的命名元组之间从左到右进行，因此，在最左边和最右边的命名元组中都存在的字段顺序与在最左边的命名元组中发现的字段的位置相同。但是，值是从包含该字段的最右边命名元组中的匹配字段获取的。仅在一对中最右边的命名元组中存在的字段会附加在末尾。当仅提供一个带有签名 &lt;code&gt;merge(a::NamedTuple)&lt;/code&gt; 命名元组时，实现后备。</target>
        </trans-unit>
        <trans-unit id="f725dfe7fd6faac9e03009cc2d94bc9428b364fc" translate="yes" xml:space="preserve">
          <source>Construct a random cyclic permutation of length &lt;code&gt;n&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;. The element type of the result is the same as the type of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">构造长度为 &lt;code&gt;n&lt;/code&gt; 的随机循环置换。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定一个随机数生成器，请参阅&lt;a href=&quot;#Random-Numbers&quot;&gt;随机数&lt;/a&gt;。结果的元素类型与 &lt;code&gt;n&lt;/code&gt; 的类型相同。</target>
        </trans-unit>
        <trans-unit id="773ddde3a7d5f56b43450f9427ef414e19220724" translate="yes" xml:space="preserve">
          <source>Construct a random cyclic permutation of length &lt;code&gt;n&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;. The element type of the result is the same as the type of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">构造长度为 &lt;code&gt;n&lt;/code&gt; 的随机循环置换。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定随机数生成器，请参阅&lt;a href=&quot;#Random-Numbers-1&quot;&gt;随机数&lt;/a&gt;。结果的元素类型与 &lt;code&gt;n&lt;/code&gt; 的类型相同。</target>
        </trans-unit>
        <trans-unit id="31d98d8e00b2cfb014e115f27e9ff8e8b2a46deb" translate="yes" xml:space="preserve">
          <source>Construct a random permutation of length &lt;code&gt;n&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator (see &lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;). The element type of the result is the same as the type of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">构造长度为 &lt;code&gt;n&lt;/code&gt; 的随机排列。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定一个随机数生成器（请参阅&lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;）。结果的元素类型与 &lt;code&gt;n&lt;/code&gt; 的类型相同。</target>
        </trans-unit>
        <trans-unit id="ed600dca9287d8a479f0f2758806c12b876aecb6" translate="yes" xml:space="preserve">
          <source>Construct a random permutation of length &lt;code&gt;n&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator (see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;). The element type of the result is the same as the type of &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">构造长度为 &lt;code&gt;n&lt;/code&gt; 的随机排列。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定一个随机数生成器（请参见&lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;）。结果的元素类型与 &lt;code&gt;n&lt;/code&gt; 的类型相同。</target>
        </trans-unit>
        <trans-unit id="077c36b5cddb72a8d1da7fef475e2f40e5395bad" translate="yes" xml:space="preserve">
          <source>Construct a regex, such as &lt;code&gt;r&quot;^[a-z]*$&quot;&lt;/code&gt;, without interpolation and unescaping (except for quotation mark &lt;code&gt;&quot;&lt;/code&gt; which still has to be escaped). The regex also accepts one or more flags, listed after the ending quote, to change its behaviour:</source>
          <target state="translated">构造一个正则表达式，例如 &lt;code&gt;r&quot;^[a-z]*$&quot;&lt;/code&gt; ，不进行内插和转义（引号 &lt;code&gt;&quot;&lt;/code&gt; 仍然必须转义）。该正则表达式还接受一个或多个标志，该标志在结束引号之后列出，以更改其行为：</target>
        </trans-unit>
        <trans-unit id="33aad8a62d61bbba4ad329f651211ce2a482be36" translate="yes" xml:space="preserve">
          <source>Construct a sorted set of &lt;code&gt;Int&lt;/code&gt;s generated by the given iterable object, or an empty set. Implemented as a bit string, and therefore designed for dense integer sets. If the set will be sparse (for example, holding a few very large integers), use &lt;a href=&quot;#Base.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">构造由给定的可迭代对象生成的有序 &lt;code&gt;Int&lt;/code&gt; 集合或一个空集合。实现为位字符串，因此设计用于密集整数集。如果集合将是稀疏的（例如，容纳一些非常大的整数），请改用&lt;a href=&quot;#Base.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb009dfa7962bbabb609c96c629280a0c8d96255" translate="yes" xml:space="preserve">
          <source>Construct a sparse diagonal matrix from &lt;code&gt;Pair&lt;/code&gt;s of vectors and diagonals. Each vector &lt;code&gt;kv.second&lt;/code&gt; will be placed on the &lt;code&gt;kv.first&lt;/code&gt; diagonal. By default (if &lt;code&gt;size=nothing&lt;/code&gt;), the matrix is square and its size is inferred from &lt;code&gt;kv&lt;/code&gt;, but a non-square size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt; (padded with zeros as needed) can be specified by passing &lt;code&gt;m,n&lt;/code&gt; as the first arguments.</source>
          <target state="translated">从向量和对角线 &lt;code&gt;Pair&lt;/code&gt; 构造一个稀疏对角矩阵。每个向量 &lt;code&gt;kv.second&lt;/code&gt; 将放置在 &lt;code&gt;kv.first&lt;/code&gt; 对角线上。默认情况下（如果 &lt;code&gt;size=nothing&lt;/code&gt; ），矩阵是正方形，并且其大小是从 &lt;code&gt;kv&lt;/code&gt; 推断出来的，但是可以通过将 &lt;code&gt;m,n&lt;/code&gt; 作为第一个参数来指定非正方形大小 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; （根据需要用零填充）。</target>
        </trans-unit>
        <trans-unit id="45a1f7d88f46e1a876aecb1dc4b732278ee01769" translate="yes" xml:space="preserve">
          <source>Construct a square matrix from &lt;code&gt;Pair&lt;/code&gt;s of diagonals and vectors. Vector &lt;code&gt;kv.second&lt;/code&gt; will be placed on the &lt;code&gt;kv.first&lt;/code&gt; diagonal. &lt;code&gt;diagm&lt;/code&gt; constructs a full matrix; if you want storage-efficient versions with fast arithmetic, see &lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.Bidiagonal&quot;&gt;&lt;code&gt;Bidiagonal&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt;&lt;code&gt;Tridiagonal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从对角线和向量的 &lt;code&gt;Pair&lt;/code&gt; 构造方阵。向量 &lt;code&gt;kv.second&lt;/code&gt; 将放置在 &lt;code&gt;kv.first&lt;/code&gt; 对角线上。 &lt;code&gt;diagm&lt;/code&gt; 构造一个完整的矩阵；如果你想存储效率的版本，速算，看&lt;a href=&quot;#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#LinearAlgebra.Bidiagonal&quot;&gt; &lt;code&gt;Bidiagonal&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt; &lt;code&gt;Tridiagonal&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt; &lt;code&gt;SymTridiagonal&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="105188658b5054b3326fe1e162af42e4805232a3" translate="yes" xml:space="preserve">
          <source>Construct a square matrix with elements of the vector as diagonal elements.</source>
          <target state="translated">构造一个以向量元素为对角线元素的方阵。</target>
        </trans-unit>
        <trans-unit id="e83aca212f69ccb433491a23b4580555779709aa" translate="yes" xml:space="preserve">
          <source>Construct a square sparse diagonal matrix from &lt;code&gt;Pair&lt;/code&gt;s of vectors and diagonals. Vector &lt;code&gt;kv.second&lt;/code&gt; will be placed on the &lt;code&gt;kv.first&lt;/code&gt; diagonal.</source>
          <target state="translated">从向量和对角线 &lt;code&gt;Pair&lt;/code&gt; 构造一个正方形稀疏对角矩阵。向量 &lt;code&gt;kv.second&lt;/code&gt; 将放置在 &lt;code&gt;kv.first&lt;/code&gt; 对角线上。</target>
        </trans-unit>
        <trans-unit id="21bfe811706d6b39e27bb5e54824e3f9c00060be" translate="yes" xml:space="preserve">
          <source>Construct a string by using a &lt;code&gt;TimeType&lt;/code&gt; object and applying the provided &lt;code&gt;format&lt;/code&gt;. The following character codes can be used to construct the &lt;code&gt;format&lt;/code&gt; string:</source>
          <target state="translated">通过使用 &lt;code&gt;TimeType&lt;/code&gt; 对象并应用提供的 &lt;code&gt;format&lt;/code&gt; 来构造字符串。以下字符代码可用于构造 &lt;code&gt;format&lt;/code&gt; 字符串：</target>
        </trans-unit>
        <trans-unit id="e78af3110399316b26ade3d45b60e10fc708bcd9" translate="yes" xml:space="preserve">
          <source>Construct a substitution string, used for regular expression substitutions. Within the string, sequences of the form &lt;code&gt;\N&lt;/code&gt; refer to the Nth capture group in the regex, and &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; refers to a named capture group with name &lt;code&gt;groupname&lt;/code&gt;.</source>
          <target state="translated">构造一个替换字符串，用于正则表达式替换。在字符串中，格式为 &lt;code&gt;\N&lt;/code&gt; 序列表示正则表达式中的第N个捕获组，而 &lt;code&gt;\g&amp;lt;groupname&amp;gt;&lt;/code&gt; 名称为 &lt;code&gt;groupname&lt;/code&gt; 的命名捕获组。</target>
        </trans-unit>
        <trans-unit id="7001fcde7ea51c36ac1824a5a8b0eedf713beed4" translate="yes" xml:space="preserve">
          <source>Construct a symmetric tridiagonal matrix from the diagonal (&lt;code&gt;dv&lt;/code&gt;) and first sub/super-diagonal (&lt;code&gt;ev&lt;/code&gt;), respectively. The result is of type &lt;code&gt;SymTridiagonal&lt;/code&gt; and provides efficient specialized eigensolvers, but may be converted into a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="translated">分别从对角线（ &lt;code&gt;dv&lt;/code&gt; ）和第一个子/超对角线（ &lt;code&gt;ev&lt;/code&gt; ）构造对称的对角线矩阵。结果为 &lt;code&gt;SymTridiagonal&lt;/code&gt; 类型，可提供有效的专业特征求解器，但可以使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt;（或 &lt;code&gt;Array(_)&lt;/code&gt; 为Array（_））转换为规则矩阵。</target>
        </trans-unit>
        <trans-unit id="d8d5353fe58ad31b1de6c2b618a70ed090651651" translate="yes" xml:space="preserve">
          <source>Construct a symmetric tridiagonal matrix from the diagonal and first sub/super-diagonal, of the symmetric matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">从对称矩阵 &lt;code&gt;A&lt;/code&gt; 的对角线和第一个子/超对角线构造对称三对角矩阵。</target>
        </trans-unit>
        <trans-unit id="a36cd1d4860652164376c75ff58e72c65814cf23" translate="yes" xml:space="preserve">
          <source>Construct a symmetric tridiagonal matrix from the diagonal and first superdiagonal of the symmetric matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">从对称矩阵 &lt;code&gt;A&lt;/code&gt; 的对角线和第一个超对角线构造对称三对角矩阵。</target>
        </trans-unit>
        <trans-unit id="5e812abbcd333112ef665b3c50ab166d997a74f3" translate="yes" xml:space="preserve">
          <source>Construct a tridiagonal matrix from the first sub-diagonal, diagonal and first super-diagonal of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">从矩阵 &lt;code&gt;A&lt;/code&gt; 的第一个对角，对角和第一个超对角线构造一个三对角矩阵。</target>
        </trans-unit>
        <trans-unit id="747e5433f9793862323a449007017950fdbe1544" translate="yes" xml:space="preserve">
          <source>Construct a tridiagonal matrix from the first subdiagonal, diagonal, and first superdiagonal, respectively. The result is of type &lt;code&gt;Tridiagonal&lt;/code&gt; and provides efficient specialized linear solvers, but may be converted into a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short). The lengths of &lt;code&gt;dl&lt;/code&gt; and &lt;code&gt;du&lt;/code&gt; must be one less than the length of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">分别从第一个对角线，对角线和第一个超对角线构造一个三对角矩阵。结果为 &lt;code&gt;Tridiagonal&lt;/code&gt; 类型，可提供有效的专用线性求解器，但可以使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt;（或 &lt;code&gt;Array(_)&lt;/code&gt; 为Array（_））转换为规则矩阵。 &lt;code&gt;dl&lt;/code&gt; 和 &lt;code&gt;du&lt;/code&gt; 的长度必须比 &lt;code&gt;d&lt;/code&gt; 的长度小一。</target>
        </trans-unit>
        <trans-unit id="3a45735b554554297a7fc87a9bba1a725ba384be" translate="yes" xml:space="preserve">
          <source>Construct a tuple of the given objects.</source>
          <target state="translated">构造一个给定对象的元组。</target>
        </trans-unit>
        <trans-unit id="7fdc191ace6e9b509ad7d0b0a2b4eead7c650e5d" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;N&lt;/code&gt;-dimensional &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing elements of type &lt;code&gt;T&lt;/code&gt;, initialized with &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">构造一个 &lt;code&gt;N&lt;/code&gt; 维&lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;其中包含类型 &lt;code&gt;T&lt;/code&gt; 的元素，并使用&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;条目对其进行初始化。元素类型 &lt;code&gt;T&lt;/code&gt; 必须能够保留这些值，即 &lt;code&gt;Missing &amp;lt;: T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a8ff556a297608632796b72ff2cb3c8e84dd2779" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;N&lt;/code&gt;-dimensional &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing elements of type &lt;code&gt;T&lt;/code&gt;, initialized with &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; entries. Element type &lt;code&gt;T&lt;/code&gt; must be able to hold these values, i.e. &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt;.</source>
          <target state="translated">构造一个 &lt;code&gt;N&lt;/code&gt; 维&lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;其中包含类型 &lt;code&gt;T&lt;/code&gt; 的元素，并且&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;使用任何条目进行初始化。元素类型 &lt;code&gt;T&lt;/code&gt; 必须能够保留这些值，即 &lt;code&gt;Nothing &amp;lt;: T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae459e01fcce313d45a189e6a321f000a9d4614d" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;UnitUpperTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;. Such a view has the &lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; of the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; on its diagonal.</source>
          <target state="translated">构造矩阵 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;UnitUpperTriangular&lt;/code&gt; 视图。这样的视图具有&lt;a href=&quot;../../base/numbers/index#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt;所述的&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;A&lt;/code&gt; 在其对角线上。</target>
        </trans-unit>
        <trans-unit id="6a808b8435d8d2d16766a046ee8b6a2eb6d7ebc5" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;UpperHessenberg&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;. Entries of &lt;code&gt;A&lt;/code&gt; below the first subdiagonal are ignored.</source>
          <target state="translated">构造矩阵 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;UpperHessenberg&lt;/code&gt; 视图。在第一个对角线以下的 &lt;code&gt;A&lt;/code&gt; 条目将被忽略。</target>
        </trans-unit>
        <trans-unit id="0e5eea89cf2afaf3f4aa193305385c8f999189b8" translate="yes" xml:space="preserve">
          <source>Construct an &lt;code&gt;UpperTriangular&lt;/code&gt; view of the matrix &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">构造矩阵 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;UpperTriangular&lt;/code&gt; 视图。</target>
        </trans-unit>
        <trans-unit id="efa7a80292bce29eaa41f35b63dbae9f5d8943a7" translate="yes" xml:space="preserve">
          <source>Construct an array by repeating array &lt;code&gt;A&lt;/code&gt; a given number of times in each dimension, specified by &lt;code&gt;counts&lt;/code&gt;.</source>
          <target state="translated">通过在每个维度中将array &lt;code&gt;A&lt;/code&gt; 重复给定次数（由 &lt;code&gt;counts&lt;/code&gt; 指定）来构造一个数组。</target>
        </trans-unit>
        <trans-unit id="dabd5c0da772665da5c4fb23a09786030dae44d8" translate="yes" xml:space="preserve">
          <source>Construct an array by repeating the entries of &lt;code&gt;A&lt;/code&gt;. The i-th element of &lt;code&gt;inner&lt;/code&gt; specifies the number of times that the individual entries of the i-th dimension of &lt;code&gt;A&lt;/code&gt; should be repeated. The i-th element of &lt;code&gt;outer&lt;/code&gt; specifies the number of times that a slice along the i-th dimension of &lt;code&gt;A&lt;/code&gt; should be repeated. If &lt;code&gt;inner&lt;/code&gt; or &lt;code&gt;outer&lt;/code&gt; are omitted, no repetition is performed.</source>
          <target state="translated">通过重复 &lt;code&gt;A&lt;/code&gt; 的条目构造一个数组。 &lt;code&gt;inner&lt;/code&gt; 的第i个元素指定应重复 &lt;code&gt;A&lt;/code&gt; 的第i个维度的各个条目的次数。的第i个元素 &lt;code&gt;outer&lt;/code&gt; 指定沿的第i维片的次数 &lt;code&gt;A&lt;/code&gt; 应该重复。如果省略 &lt;code&gt;inner&lt;/code&gt; 或 &lt;code&gt;outer&lt;/code&gt; ，则不重复。</target>
        </trans-unit>
        <trans-unit id="35fd888bce1ff7aeaee21a4d838a36c377edec0b" translate="yes" xml:space="preserve">
          <source>Construct an undef &lt;a href=&quot;#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; with the given dimensions. Behaves identically to the &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; constructor. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">构造一个具有给定尺寸的undef &lt;a href=&quot;#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt;。行为与&lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;构造函数相同。参见&lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="54d87d0575b0e006fe5cc260cc0529044e72ab09" translate="yes" xml:space="preserve">
          <source>Construct an uninitialized &lt;a href=&quot;#Base.Matrix&quot;&gt;&lt;code&gt;Matrix{T}&lt;/code&gt;&lt;/a&gt; of size &lt;code&gt;m&lt;/code&gt;&amp;times;&lt;code&gt;n&lt;/code&gt;. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">构造大小为 &lt;code&gt;m&lt;/code&gt; &amp;times; &lt;code&gt;n&lt;/code&gt; 的未初始化&lt;a href=&quot;#Base.Matrix&quot;&gt; &lt;code&gt;Matrix{T}&lt;/code&gt; &lt;/a&gt;。参见&lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7eb6c96e45dddc926f98114383bd79e946048ede" translate="yes" xml:space="preserve">
          <source>Construct an uninitialized &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector{T}&lt;/code&gt;&lt;/a&gt; of length &lt;code&gt;n&lt;/code&gt;. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">构造一个长度为 &lt;code&gt;n&lt;/code&gt; 的未初始化&lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector{T}&lt;/code&gt; &lt;/a&gt;。参见&lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e3ce437cb47785e9c47fa7a6dc465bfd8ef0ecab" translate="yes" xml:space="preserve">
          <source>Construct an uninitialized &lt;code&gt;N&lt;/code&gt;-dimensional &lt;a href=&quot;#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; containing elements of type &lt;code&gt;T&lt;/code&gt;. &lt;code&gt;N&lt;/code&gt; can either be supplied explicitly, as in &lt;code&gt;Array{T,N}(undef, dims)&lt;/code&gt;, or be determined by the length or number of &lt;code&gt;dims&lt;/code&gt;. &lt;code&gt;dims&lt;/code&gt; may be a tuple or a series of integer arguments corresponding to the lengths in each dimension. If the rank &lt;code&gt;N&lt;/code&gt; is supplied explicitly, then it must match the length or number of &lt;code&gt;dims&lt;/code&gt;. See &lt;a href=&quot;#Core.undef&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">构造一个未初始化的 &lt;code&gt;N&lt;/code&gt; 维&lt;a href=&quot;#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;其中包含类型 &lt;code&gt;T&lt;/code&gt; 的元素。 &lt;code&gt;N&lt;/code&gt; 可以像 &lt;code&gt;Array{T,N}(undef, dims)&lt;/code&gt; 那样显式提供，也可以由 &lt;code&gt;dims&lt;/code&gt; 的长度或数量确定。 &lt;code&gt;dims&lt;/code&gt; 可以是一个元组，也可以是与每个维度中的长度相对应的一系列整数参数。如果等级 &lt;code&gt;N&lt;/code&gt; 是明确提供的，则它必须匹配 &lt;code&gt;dims&lt;/code&gt; 的长度或数量。参见&lt;a href=&quot;#Core.undef&quot;&gt; &lt;code&gt;undef&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3d99909abef5299b1e1b4f2472e34b18cf81e05f" translate="yes" xml:space="preserve">
          <source>Construct in &lt;code&gt;A&lt;/code&gt; a random cyclic permutation of length &lt;code&gt;length(A)&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;A&lt;/code&gt; 中构造一个长度为 &lt;code&gt;length(A)&lt;/code&gt; 的随机循环置换。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定一个随机数生成器，请参阅&lt;a href=&quot;#Random-Numbers&quot;&gt;随机数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0c5739db91a2916a6de2ec1c1497c1a0a7b92373" translate="yes" xml:space="preserve">
          <source>Construct in &lt;code&gt;A&lt;/code&gt; a random cyclic permutation of length &lt;code&gt;length(A)&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;A&lt;/code&gt; 中构造一个长度为 &lt;code&gt;length(A)&lt;/code&gt; 的随机循环置换。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定随机数生成器，请参阅&lt;a href=&quot;#Random-Numbers-1&quot;&gt;随机数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7616bf15a3d66aa07b787d846cfe0bf2fc90fcbe" translate="yes" xml:space="preserve">
          <source>Construct in &lt;code&gt;A&lt;/code&gt; a random permutation of length &lt;code&gt;length(A)&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator (see &lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;). To randomly permute an arbitrary vector, see &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Random.shuffle!&quot;&gt;&lt;code&gt;shuffle!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;A&lt;/code&gt; 中构造一个长度为 &lt;code&gt;length(A)&lt;/code&gt; 的随机排列。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定一个随机数生成器（请参阅&lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;）。要随机置换任意向量，请参见&lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#Random.shuffle!&quot;&gt; &lt;code&gt;shuffle!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29fed1fdd69043bc2d52edc1a30a547c01f5cae5" translate="yes" xml:space="preserve">
          <source>Construct in &lt;code&gt;A&lt;/code&gt; a random permutation of length &lt;code&gt;length(A)&lt;/code&gt;. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator (see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;). To randomly permute an arbitrary vector, see &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Random.shuffle!&quot;&gt;&lt;code&gt;shuffle!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在 &lt;code&gt;A&lt;/code&gt; 中构造一个长度为 &lt;code&gt;length(A)&lt;/code&gt; 的随机排列。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定一个随机数生成器（请参见&lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;）。要随机置换任意向量，请参见&lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#Random.shuffle!&quot;&gt; &lt;code&gt;shuffle!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b38dc6a46091930691f0979c241388b85fc088b0" translate="yes" xml:space="preserve">
          <source>Construct the intersection of sets. Maintain order with arrays.</source>
          <target state="translated">构造集合的交点。用数组维持秩序。</target>
        </trans-unit>
        <trans-unit id="b5eeb48c87138f172c83ab82669efe34174ef13f" translate="yes" xml:space="preserve">
          <source>Construct the set of elements in &lt;code&gt;s&lt;/code&gt; but not in any of the iterables in &lt;code&gt;itrs&lt;/code&gt;. Maintain order with arrays.</source>
          <target state="translated">在 &lt;code&gt;s&lt;/code&gt; 中构造元素集，但在 &lt;code&gt;itrs&lt;/code&gt; 中的任何可迭代元素中构造元素集。维护数组的顺序。</target>
        </trans-unit>
        <trans-unit id="2a22645f8ad348047eb67f511f7fff20c9a8a19d" translate="yes" xml:space="preserve">
          <source>Construct the symmetric difference of elements in the passed in sets. When &lt;code&gt;s&lt;/code&gt; is not an &lt;code&gt;AbstractSet&lt;/code&gt;, the order is maintained. Note that in this case the multiplicity of elements matters.</source>
          <target state="translated">构造传入集中的元素的对称差。当 &lt;code&gt;s&lt;/code&gt; 不是 &lt;code&gt;AbstractSet&lt;/code&gt; 时，顺序保持不变。注意，在这种情况下，元素的多样性很重要。</target>
        </trans-unit>
        <trans-unit id="0478a19afdbd482d3c0fcafa5d1ed46e5ac1b005" translate="yes" xml:space="preserve">
          <source>Construct the symmetric difference of the passed in sets, and overwrite &lt;code&gt;s&lt;/code&gt; with the result. When &lt;code&gt;s&lt;/code&gt; is an array, the order is maintained. Note that in this case the multiplicity of elements matters.</source>
          <target state="translated">构建在集过去了，重写的对称差 &lt;code&gt;s&lt;/code&gt; 其结果。当 &lt;code&gt;s&lt;/code&gt; 是一个数组时，顺序保持不变。注意，在这种情况下，元素的多样性很重要。</target>
        </trans-unit>
        <trans-unit id="4a79ebc653ff986cbb15a5ea08e6559fdafc9723" translate="yes" xml:space="preserve">
          <source>Construct the union of passed in sets and overwrite &lt;code&gt;s&lt;/code&gt; with the result. Maintain order with arrays.</source>
          <target state="translated">构建集过去了，改写联盟 &lt;code&gt;s&lt;/code&gt; 与结果。维护数组的顺序。</target>
        </trans-unit>
        <trans-unit id="8e4f2bd81d4e0c5eb2e81850ab74130f1b05c10b" translate="yes" xml:space="preserve">
          <source>Construct the union of sets. Maintain order with arrays.</source>
          <target state="translated">构造集合的联合。用数组维持秩序。</target>
        </trans-unit>
        <trans-unit id="e97901b09af90ecffd455fb1a47763d279bd2eaf" translate="yes" xml:space="preserve">
          <source>Constructing an object with &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; converts to the object's declared field types.</source>
          <target state="translated">使用&lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;构造一个对象将转换为该对象的声明的字段类型。</target>
        </trans-unit>
        <trans-unit id="4a770f4b726b7e17438de4d4705a42cdcff41d27" translate="yes" xml:space="preserve">
          <source>Constructing infinite rational values is acceptable:</source>
          <target state="translated">构造无限的理性值是可以接受的。</target>
        </trans-unit>
        <trans-unit id="7fac2273dfc18f832b908b46cc19ab6756b7533f" translate="yes" xml:space="preserve">
          <source>Constructing strings using concatenation can become a bit cumbersome, however. To reduce the need for these verbose calls to &lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; or repeated multiplications, Julia allows interpolation into string literals using &lt;code&gt;$&lt;/code&gt;, as in Perl:</source>
          <target state="translated">但是，使用串联构造字符串可能会变得有些麻烦。为了减少对&lt;a href=&quot;../../base/strings/index#Base.string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt;或重复乘法的这些冗长调用的需要，Julia允许使用 &lt;code&gt;$&lt;/code&gt; 来插值到字符串文字中，如Perl中所示：</target>
        </trans-unit>
        <trans-unit id="1b21aefcdf98b76a2cdb3d34b924ca3a51ce9f3c" translate="yes" xml:space="preserve">
          <source>Construction Sign</source>
          <target state="translated">建筑标志</target>
        </trans-unit>
        <trans-unit id="e1fc1d68d6545bbe2eb454e9442edb86e725d413" translate="yes" xml:space="preserve">
          <source>Construction Worker</source>
          <target state="translated">建筑工人</target>
        </trans-unit>
        <trans-unit id="e2a4ac16668ac3dfb92c81ed57d43e62fd409a66" translate="yes" xml:space="preserve">
          <source>Construction and Initialization</source>
          <target state="translated">建设和初始化</target>
        </trans-unit>
        <trans-unit id="21fac0a207cd61b900dd9c8aab0249aa29234d1a" translate="yes" xml:space="preserve">
          <source>Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed until later on in &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">可以定义适当处理这种混合情况的构造方法，但是稍后将在&lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors中&lt;/a&gt;进行讨论。</target>
        </trans-unit>
        <trans-unit id="d1de0471cc72ee7ecb3e7d438567f5775ca5ab6d" translate="yes" xml:space="preserve">
          <source>Constructor methods to appropriately handle such mixed cases can be defined, but that will not be discussed until later on in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;.</source>
          <target state="translated">可以定义适当处理这种混合情况的构造方法，但是稍后将在&lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors中&lt;/a&gt;进行讨论。</target>
        </trans-unit>
        <trans-unit id="60a5c966a71a24034f9238685790a526710ef75d" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructors</target>
        </trans-unit>
        <trans-unit id="7b15c99cccb175b7231d573558f6e442c98078f7" translate="yes" xml:space="preserve">
          <source>Constructors &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt; are functions that create new objects &amp;ndash; specifically, instances of &lt;a href=&quot;../types/index#Composite-Types-1&quot;&gt;Composite Types&lt;/a&gt;. In Julia, type objects also serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was already mentioned briefly when composite types were introduced. For example:</source>
          <target state="translated">构造函数&lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;是创建新对象的函数，特别是&lt;a href=&quot;../types/index#Composite-Types-1&quot;&gt;Composite Types的&lt;/a&gt;实例。在Julia中，类型对象还充当构造函数：它们在作为参数应用于元组时会创建自己的新实例。引入复合类型时已经简要提到了这一点。例如：</target>
        </trans-unit>
        <trans-unit id="097ecd4b84dcf95c9a0dae551e3a08be98b8a0a4" translate="yes" xml:space="preserve">
          <source>Constructors &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; are functions that create new objects &amp;ndash; specifically, instances of &lt;a href=&quot;../types/index#Composite-Types&quot;&gt;Composite Types&lt;/a&gt;. In Julia, type objects also serve as constructor functions: they create new instances of themselves when applied to an argument tuple as a function. This much was already mentioned briefly when composite types were introduced. For example:</source>
          <target state="translated">构造函数&lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;是创建新对象的函数，特别是&lt;a href=&quot;../types/index#Composite-Types&quot;&gt;Composite Types的&lt;/a&gt;实例。在Julia中，类型对象还充当构造函数：它们在作为参数应用于元组时会创建自己的新实例。引入复合类型时，已经简要提到了这一点。例如：</target>
        </trans-unit>
        <trans-unit id="96c5e9bf4fffd0020a62904e36d49838adcd0526" translate="yes" xml:space="preserve">
          <source>Constructors and Types</source>
          <target state="translated">构造者和类型</target>
        </trans-unit>
        <trans-unit id="0335c1fc2e9e86f516636bf75a62df36bf31b328" translate="yes" xml:space="preserve">
          <source>Constructors exist to create these types from primitive numerical types, and &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; can be used to construct them from &lt;code&gt;AbstractString&lt;/code&gt;s. Once created, they participate in arithmetic with all other numeric types thanks to Julia's &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;type promotion and conversion mechanism&lt;/a&gt;:</source>
          <target state="translated">存在用于从原始数值类型创建这些类型的构造函数，并且可以使用&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;从 &lt;code&gt;AbstractString&lt;/code&gt; 构造它们。创建完成后，由于Julia的&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;类型提升和转换机制&lt;/a&gt;，它们可以与所有其他数字类型一起参与算术运算：</target>
        </trans-unit>
        <trans-unit id="342f876065464f411e3accfff34ace98a77223c0" translate="yes" xml:space="preserve">
          <source>Constructors exist to create these types from primitive numerical types, and the &lt;a href=&quot;../strings/index#non-standard-string-literals&quot;&gt;string literal&lt;/a&gt;&lt;a href=&quot;../../base/numbers/index#Core.@big_str&quot;&gt;&lt;code&gt;@big_str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt; can be used to construct them from &lt;code&gt;AbstractString&lt;/code&gt;s. Once created, they participate in arithmetic with all other numeric types thanks to Julia's &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;type promotion and conversion mechanism&lt;/a&gt;:</source>
          <target state="translated">存在用于从原始数值类型创建这些类型的构造函数，并且&lt;a href=&quot;../strings/index#non-standard-string-literals&quot;&gt;字符串文字&lt;/a&gt;&lt;a href=&quot;../../base/numbers/index#Core.@big_str&quot;&gt; &lt;code&gt;@big_str&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../base/numbers/index#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;可用于从 &lt;code&gt;AbstractString&lt;/code&gt; 构造它们。创建完成后，由于朱莉娅（Julia）的&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;类型提升和转换机制&lt;/a&gt;，他们可以与所有其他数字类型一起进行算术运算：</target>
        </trans-unit>
        <trans-unit id="f53def390cea96c19f58854f6ab25c6fcd002f64" translate="yes" xml:space="preserve">
          <source>Constructors for types unrelated to their arguments</source>
          <target state="translated">与参数无关的类型的构造函数。</target>
        </trans-unit>
        <trans-unit id="f9c0c3b4014f45dbe2772c6f91e5e70044c87424" translate="yes" xml:space="preserve">
          <source>Constructors that don't return instances of their own type</source>
          <target state="translated">不返回自己类型实例的构造函数。</target>
        </trans-unit>
        <trans-unit id="2241b504fd0fc9cdfe7adafcdccaaf1a06355ec8" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;Channel&lt;/code&gt; with an internal buffer that can hold a maximum of &lt;code&gt;size&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; calls on a full channel block until an object is removed with &lt;code&gt;take!&lt;/code&gt;.</source>
          <target state="translated">构造一个 &lt;code&gt;Channel&lt;/code&gt; 与一个最大的可容纳的内部缓冲器 &lt;code&gt;size&lt;/code&gt; 类型的对象 &lt;code&gt;T&lt;/code&gt; 。&lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;调用一个完整的通道块，直到使用 &lt;code&gt;take!&lt;/code&gt; 移除对象为止！。</target>
        </trans-unit>
        <trans-unit id="cf8786bb19baaa35e14eeb1b40975a00c375a3b2" translate="yes" xml:space="preserve">
          <source>Constructs a &lt;code&gt;Channel&lt;/code&gt; with an internal buffer that can hold a maximum of &lt;code&gt;sz&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt;. &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; calls on a full channel block until an object is removed with &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt;&lt;code&gt;take!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">构造一个带有内部缓冲区的 &lt;code&gt;Channel&lt;/code&gt; ，该缓冲区最多可容纳 &lt;code&gt;T&lt;/code&gt; 类型的 &lt;code&gt;sz&lt;/code&gt; 对象。&lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;调用一个完整的通道块，直到使用&lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt; &lt;code&gt;take!&lt;/code&gt; &lt;/a&gt;将对象移除！。</target>
        </trans-unit>
        <trans-unit id="d4f2020b38d81687704d5f3eafd379e31ccefbd8" translate="yes" xml:space="preserve">
          <source>Constructs an upper (&lt;code&gt;uplo=:U&lt;/code&gt;) or lower (&lt;code&gt;uplo=:L&lt;/code&gt;) bidiagonal matrix using the given diagonal (&lt;code&gt;dv&lt;/code&gt;) and off-diagonal (&lt;code&gt;ev&lt;/code&gt;) vectors. The result is of type &lt;code&gt;Bidiagonal&lt;/code&gt; and provides efficient specialized linear solvers, but may be converted into a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short). The length of &lt;code&gt;ev&lt;/code&gt; must be one less than the length of &lt;code&gt;dv&lt;/code&gt;.</source>
          <target state="translated">使用给定的对角线（ &lt;code&gt;dv&lt;/code&gt; ）和非对角线（ &lt;code&gt;ev&lt;/code&gt; ）向量构造一个较高（ &lt;code&gt;uplo=:U&lt;/code&gt; ）或较低（ &lt;code&gt;uplo=:L&lt;/code&gt; ）的对角矩阵。结果的类型为 &lt;code&gt;Bidiagonal&lt;/code&gt; ,并提供有效的专用线性求解器，但可以使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert(Array, _)&lt;/code&gt; &lt;/a&gt;（或 &lt;code&gt;Array(_)&lt;/code&gt; 为Array（_））转换为规则矩阵。 &lt;code&gt;ev&lt;/code&gt; 的长度必须小于 &lt;code&gt;dv&lt;/code&gt; 的长度之一。</target>
        </trans-unit>
        <trans-unit id="b6ef0e63fc68a8523f73ef7005740900302c3bf1" translate="yes" xml:space="preserve">
          <source>Container types generally implement 3-argument &lt;code&gt;show&lt;/code&gt; by calling &lt;code&gt;show(io, MIME&quot;text/plain&quot;(), x)&lt;/code&gt; for elements &lt;code&gt;x&lt;/code&gt;, with &lt;code&gt;:compact =&amp;gt; true&lt;/code&gt; set in an &lt;a href=&quot;#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; passed as the first argument.</source>
          <target state="translated">容器类型通常实现3个参数的 &lt;code&gt;show&lt;/code&gt; 通过调用 &lt;code&gt;show(io, MIME&quot;text/plain&quot;(), x)&lt;/code&gt; 的元件 &lt;code&gt;x&lt;/code&gt; ，具有 &lt;code&gt;:compact =&amp;gt; true&lt;/code&gt; 集在&lt;a href=&quot;#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;作为第一个参数传递。</target>
        </trans-unit>
        <trans-unit id="31855f42648a53f0f883864dfbb8c76728ada032" translate="yes" xml:space="preserve">
          <source>Contains As Member</source>
          <target state="translated">包含为成员</target>
        </trans-unit>
        <trans-unit id="6374949f24934c8f59af915f665fe9ad04edf8fb" translate="yes" xml:space="preserve">
          <source>Contains As Normal Subgroup</source>
          <target state="translated">包含正常的子组</target>
        </trans-unit>
        <trans-unit id="c6255fd2009d9e2b6c2d76d570b84317f3968045" translate="yes" xml:space="preserve">
          <source>Contains As Normal Subgroup Or Equal To</source>
          <target state="translated">包含作为正常子组或等于</target>
        </trans-unit>
        <trans-unit id="bddb6860083f671133b8edfd2c54cc768d4aa9a9" translate="yes" xml:space="preserve">
          <source>Contains With Long Horizontal Stroke</source>
          <target state="translated">包含有长的水平笔画</target>
        </trans-unit>
        <trans-unit id="8b7cbaa37f45d1b7957bf24d5d47157af046982a" translate="yes" xml:space="preserve">
          <source>Contains With Overbar</source>
          <target state="translated">包含有过杆</target>
        </trans-unit>
        <trans-unit id="7c34feec9ab0b7359b089f798a1fbac1a7ebc48f" translate="yes" xml:space="preserve">
          <source>Contains With Vertical Bar At End Of Horizontal Stroke</source>
          <target state="translated">包含在水平笔画末端的垂直条。</target>
        </trans-unit>
        <trans-unit id="c3a18764e13219b073d5d7052ee1c75c3fd0245e" translate="yes" xml:space="preserve">
          <source>Contains the information about HEAD during a fetch, including the name and URL of the branch fetched from, the oid of the HEAD, and whether the fetched HEAD has been merged locally.</source>
          <target state="translated">包含获取过程中关于 HEAD 的信息,包括从哪个分支获取的名称和 URL,HEAD 的 oid,以及获取的 HEAD 是否已经被合并到本地。</target>
        </trans-unit>
        <trans-unit id="7606203ccba192fbac54fde902d8586ac81effb6" translate="yes" xml:space="preserve">
          <source>Contour Integral</source>
          <target state="translated">等高线积分</target>
        </trans-unit>
        <trans-unit id="4722c5ea64f5bf604117b9b25da5ac1ab2753262" translate="yes" xml:space="preserve">
          <source>Control Flow</source>
          <target state="translated">控制流程</target>
        </trans-unit>
        <trans-unit id="e7d0119a994fc38f14a5d2d52d98f6d567da9857" translate="yes" xml:space="preserve">
          <source>Control Flow and Short-Circuiting Operators</source>
          <target state="translated">控制流程和短路操作器</target>
        </trans-unit>
        <trans-unit id="ac3c5834f77ae59c902947ccef1074dc7ca1801a" translate="yes" xml:space="preserve">
          <source>Control flow</source>
          <target state="translated">控制流程</target>
        </trans-unit>
        <trans-unit id="4683dd6403ab370d23d6560a4e21f414bfac0f26" translate="yes" xml:space="preserve">
          <source>Control flow operators including &lt;a href=&quot;../../base/base/index#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../control-flow/index#man-conditional-evaluation&quot;&gt;ternary operator&lt;/a&gt;&lt;code&gt;x ? y : z&lt;/code&gt; do not allow for missing values. This is because of the uncertainty about whether the actual value would be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; if we could observe it, which implies that we do not know how the program should behave. A &lt;a href=&quot;../../base/base/index#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown as soon as a &lt;code&gt;missing&lt;/code&gt; value is encountered in this context</source>
          <target state="translated">控制流运算符，包括&lt;a href=&quot;../../base/base/index#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/base/index#while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../control-flow/index#man-conditional-evaluation&quot;&gt;三元运算符&lt;/a&gt; &lt;code&gt;x ? y : z&lt;/code&gt; 不允许缺少值。这是因为如果可以观察到实际值是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt; 则存在不确定性，这意味着我们不知道程序应如何运行。一个&lt;a href=&quot;../../base/base/index#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;的抛出，一旦 &lt;code&gt;missing&lt;/code&gt; 值在这种情况下遇到</target>
        </trans-unit>
        <trans-unit id="72f9c97f5741988f58f0cfe9c25d834ba26762be" translate="yes" xml:space="preserve">
          <source>Control flow operators including &lt;a href=&quot;../../base/base/index#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/base/index#while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;../control-flow/index#man-conditional-evaluation-1&quot;&gt;ternary operator&lt;/a&gt;&lt;code&gt;x ? y : z&lt;/code&gt; do not allow for missing values. This is because of the uncertainty about whether the actual value would be &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; if we could observe it, which implies that we do not know how the program should behave. A &lt;a href=&quot;../../base/base/index#Core.TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is thrown as soon as a &lt;code&gt;missing&lt;/code&gt; value is encountered in this context</source>
          <target state="translated">控制流运算符，包括&lt;a href=&quot;../../base/base/index#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/base/index#while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../control-flow/index#man-conditional-evaluation-1&quot;&gt;三元运算符&lt;/a&gt; &lt;code&gt;x ? y : z&lt;/code&gt; 不允许缺少值。这是因为如果可以观察到实际值是 &lt;code&gt;true&lt;/code&gt; 还是 &lt;code&gt;false&lt;/code&gt; 的不确定性，这意味着我们不知道程序应该如何运行。一个&lt;a href=&quot;../../base/base/index#Core.TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;的抛出，一旦 &lt;code&gt;missing&lt;/code&gt; 值在这种情况下遇到</target>
        </trans-unit>
        <trans-unit id="14b7866ef465dde33929d7924f93fff8b8dbc0b9" translate="yes" xml:space="preserve">
          <source>Control whether garbage collection is enabled using a boolean argument (&lt;code&gt;true&lt;/code&gt; for enabled, &lt;code&gt;false&lt;/code&gt; for disabled). Return previous GC state.</source>
          <target state="translated">使用布尔参数控制是否启用垃圾收集（ &lt;code&gt;true&lt;/code&gt; 表示启用， &lt;code&gt;false&lt;/code&gt; 表示禁用）。返回先前的GC状态。</target>
        </trans-unit>
        <trans-unit id="14f8f8ee865f088942c342818dc4e3bbb1536995" translate="yes" xml:space="preserve">
          <source>Control whether inlining is permitted, including overriding &lt;code&gt;@inline&lt;/code&gt; declarations</source>
          <target state="translated">控制是否允许内联，包括覆盖 &lt;code&gt;@inline&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="cacef9e904c125c2f7ac4e42d389c8844e172ac2" translate="yes" xml:space="preserve">
          <source>Convenience Store</source>
          <target state="translated">便利店</target>
        </trans-unit>
        <trans-unit id="e97a673f9a9eebff3f10ed71f5a88d461090a8ca" translate="yes" xml:space="preserve">
          <source>Convenience functions for metaprogramming.</source>
          <target state="translated">元编程的便利功能。</target>
        </trans-unit>
        <trans-unit id="fd9b14a00b20c7a8276bd5748c3165fb1ca289f8" translate="yes" xml:space="preserve">
          <source>Conversely, &lt;code&gt;similar(trues(10,10), 2)&lt;/code&gt; returns an uninitialized &lt;code&gt;BitVector&lt;/code&gt; with two elements since &lt;code&gt;BitArray&lt;/code&gt;s are both mutable and can support 1-dimensional arrays:</source>
          <target state="translated">相反，由于 &lt;code&gt;BitArray&lt;/code&gt; 都是可变的并且可以支持一维数组，所以 &lt;code&gt;similar(trues(10,10), 2)&lt;/code&gt; 返回带有两个元素的未初始化 &lt;code&gt;BitVector&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="4234a78959811f144edc9c62e989cabf24ee370a" translate="yes" xml:space="preserve">
          <source>Conversely, when passing a vector of strings to LibGit2, it is generally simplest to rely on implicit conversion:</source>
          <target state="translated">相反,当向 LibGit2 传递一个字符串向量时,一般来说,依靠隐式转换是最简单的。</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="8cc29d077456587b44d9a48d75801504d22c31b2" translate="yes" xml:space="preserve">
          <source>Conversion Functions</source>
          <target state="translated">转换功能</target>
        </trans-unit>
        <trans-unit id="04666b33ed1c43f23bbe0e99877e7f10b6a933fa" translate="yes" xml:space="preserve">
          <source>Conversion and Promotion</source>
          <target state="translated">转换和推广</target>
        </trans-unit>
        <trans-unit id="8d86d2ec0c7b6756fe66cc1bf719bbb241833abb" translate="yes" xml:space="preserve">
          <source>Conversion from rational to floating-point respects the following identity for any integral values of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, with the exception of the case &lt;code&gt;a == 0&lt;/code&gt; and &lt;code&gt;b == 0&lt;/code&gt;:</source>
          <target state="translated">对于从 &lt;code&gt;a&lt;/code&gt; 到 &lt;code&gt;b&lt;/code&gt; 的任何整数值，从有理数到浮点的转换遵循以下标识，但 &lt;code&gt;a == 0&lt;/code&gt; 和 &lt;code&gt;b == 0&lt;/code&gt; 的情况除外：</target>
        </trans-unit>
        <trans-unit id="3a3d18830aded7a67b783185496d43f80b4d4144" translate="yes" xml:space="preserve">
          <source>Conversion isn't always possible, in which case a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is thrown indicating that &lt;code&gt;convert&lt;/code&gt; doesn't know how to perform the requested conversion:</source>
          <target state="translated">转换并非总是可能的，在这种情况下， &lt;code&gt;convert&lt;/code&gt; 抛出&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;，指示convert不知道如何执行请求的转换：</target>
        </trans-unit>
        <trans-unit id="3ee457d7a754e6e789e5e9067e307640598d5fdf" translate="yes" xml:space="preserve">
          <source>Conversion isn't always possible, in which case a no method error is thrown indicating that &lt;code&gt;convert&lt;/code&gt; doesn't know how to perform the requested conversion:</source>
          <target state="translated">转换并非总是可能的，在这种情况下， &lt;code&gt;convert&lt;/code&gt; 引发没有方法错误，指示转换不知道如何执行请求的转换：</target>
        </trans-unit>
        <trans-unit id="2c85fbb802a404d058a90790ec033af382ae6bcd" translate="yes" xml:space="preserve">
          <source>Conversion vs. Construction</source>
          <target state="translated">改造与建设</target>
        </trans-unit>
        <trans-unit id="156f3c8386685fd957672db82cc983d0b1768fc0" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; from degrees to radians.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 从度转换为弧度。</target>
        </trans-unit>
        <trans-unit id="930fbd712c9569bcac9a41934f09fb34d835188c" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; from radians to degrees.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 从弧度转换为度。</target>
        </trans-unit>
        <trans-unit id="aaf4386c273bdc11f6c707ae019613ac6e236b92" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to a C argument of type &lt;code&gt;T&lt;/code&gt; where the input &lt;code&gt;x&lt;/code&gt; must be the return value of &lt;code&gt;cconvert(T, ...)&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 转换为类型 &lt;code&gt;T&lt;/code&gt; 的C参数，其中输入 &lt;code&gt;x&lt;/code&gt; 必须是 &lt;code&gt;cconvert(T, ...)&lt;/code&gt; 的返回值。</target>
        </trans-unit>
        <trans-unit id="c4acb077b4d119d3ed00eeba6aa056446504f49a" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 转换为类型 &lt;code&gt;T&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="91ec563506a54debc59cdb744c1c00d2ff1a3c35" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to a value to be passed to C code as type &lt;code&gt;T&lt;/code&gt;, typically by calling &lt;code&gt;convert(T, x)&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 转换为要作为类型 &lt;code&gt;T&lt;/code&gt; 传递给C代码的值，通常是通过调用 &lt;code&gt;convert(T, x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2d3cb248dc70e1ee69a390558f82f6e2af4dac4b" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;x&lt;/code&gt; to an object that has &lt;code&gt;axes&lt;/code&gt; and supports indexing</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 转换为具有 &lt;code&gt;axes&lt;/code&gt; 并支持索引的对象</target>
        </trans-unit>
        <trans-unit id="def5bf1795c56c2c61188495ac929f9d40e5f863" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;y&lt;/code&gt; to the type of &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;convert(typeof(x), y)&lt;/code&gt;).</source>
          <target state="translated">将 &lt;code&gt;y&lt;/code&gt; 转换为 &lt;code&gt;x&lt;/code&gt; 的类型（ &lt;code&gt;convert(typeof(x), y)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ad4bb4dbf97061448cd4f6b22cbb5a0e5289b08e" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;Date&lt;/code&gt; to a &lt;code&gt;DateTime&lt;/code&gt;. The hour, minute, second, and millisecond parts of the new &lt;code&gt;DateTime&lt;/code&gt; are assumed to be zero.</source>
          <target state="translated">将 &lt;code&gt;Date&lt;/code&gt; 转换为 &lt;code&gt;DateTime&lt;/code&gt; 。新的 &lt;code&gt;DateTime&lt;/code&gt; 的时，分，秒和毫秒部分假定为零。</target>
        </trans-unit>
        <trans-unit id="031081832af367cd87e42057b3adc69a323b88c8" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;DateTime&lt;/code&gt; to a &lt;code&gt;Date&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;DateTime&lt;/code&gt; are truncated, so only the year, month and day parts are used in construction.</source>
          <target state="translated">将 &lt;code&gt;DateTime&lt;/code&gt; 转换为 &lt;code&gt;Date&lt;/code&gt; 。 &lt;code&gt;DateTime&lt;/code&gt; 的小时，分​​钟，秒和毫秒部分被截断，因此在构造中仅使用年，月和日部分。</target>
        </trans-unit>
        <trans-unit id="987898a3319e41bac5f9dbe1956b4e7e2b290ba4" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;DateTime&lt;/code&gt; to a &lt;code&gt;Time&lt;/code&gt;. The hour, minute, second, and millisecond parts of the &lt;code&gt;DateTime&lt;/code&gt; are used to create the new &lt;code&gt;Time&lt;/code&gt;. Microsecond and nanoseconds are zero by default.</source>
          <target state="translated">将 &lt;code&gt;DateTime&lt;/code&gt; 转换为 &lt;code&gt;Time&lt;/code&gt; 。 &lt;code&gt;DateTime&lt;/code&gt; 的时，分，秒和毫秒部分用于创建新的 &lt;code&gt;Time&lt;/code&gt; 。默认情况下，微秒和纳秒为零。</target>
        </trans-unit>
        <trans-unit id="697f574b741b0307339ff2b81d5ecba120fae99d" translate="yes" xml:space="preserve">
          <source>Convert a &lt;code&gt;Ptr&lt;/code&gt; to an object reference. Assumes the pointer refers to a valid heap-allocated Julia object. If this is not the case, undefined behavior results, hence this function is considered &quot;unsafe&quot; and should be used with care.</source>
          <target state="translated">将 &lt;code&gt;Ptr&lt;/code&gt; 转换为对象引用。假定指针指向有效的堆分配的Julia对象。如果不是这种情况，则会导致未定义的行为，因此该功能被视为&amp;ldquo;不安全&amp;rdquo;，应谨慎使用。</target>
        </trans-unit>
        <trans-unit id="4dd17d692e3047c02ceced8797177e51afe3b937" translate="yes" xml:space="preserve">
          <source>Convert a Win32 system call error code to a descriptive string [only available on Windows].</source>
          <target state="translated">将Win32系统调用错误代码转换为描述性字符串[仅在Windows上可用]。</target>
        </trans-unit>
        <trans-unit id="3cd6dfa20fba21ea7113b5c7cbcac03d4ed64703" translate="yes" xml:space="preserve">
          <source>Convert a number of seconds since the epoch to broken-down format, with fields &lt;code&gt;sec&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;hour&lt;/code&gt;, &lt;code&gt;mday&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;wday&lt;/code&gt;, &lt;code&gt;yday&lt;/code&gt;, and &lt;code&gt;isdst&lt;/code&gt;.</source>
          <target state="translated">转换的秒数，因为历元破旧格式，具有字段 &lt;code&gt;sec&lt;/code&gt; ， &lt;code&gt;min&lt;/code&gt; ， &lt;code&gt;hour&lt;/code&gt; ， &lt;code&gt;mday&lt;/code&gt; ， &lt;code&gt;month&lt;/code&gt; ， &lt;code&gt;year&lt;/code&gt; ， &lt;code&gt;wday&lt;/code&gt; ， &lt;code&gt;yday&lt;/code&gt; ，和 &lt;code&gt;isdst&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0bacdc75b4f7b34973b32c316e9223e93efc1358" translate="yes" xml:space="preserve">
          <source>Convert a number or array to a floating point data type.</source>
          <target state="translated">将一个数字或数组转换为浮点数据类型。</target>
        </trans-unit>
        <trans-unit id="e2fe46f6de6c971f0ac0667455bdde8ca5b1ddfa" translate="yes" xml:space="preserve">
          <source>Convert a number to a maximum precision representation (typically &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;BigFloat&lt;/code&gt;). See &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; for information about some pitfalls with floating-point numbers.</source>
          <target state="translated">将数字转换为最大精度表示形式（通常为&lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;BigFloat&lt;/code&gt; ）。有关&lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;的一些陷阱的信息，请参见BigFloat。</target>
        </trans-unit>
        <trans-unit id="66f60301033862b1a2c3227918f5dcb7ad2365b4" translate="yes" xml:space="preserve">
          <source>Convert a number to a signed integer. If the argument is unsigned, it is reinterpreted as signed without checking for overflow.</source>
          <target state="translated">将一个数字转换为有符号的整数。如果参数是无符号的,它将被重新解释为有符号的,而不检查是否有溢出。</target>
        </trans-unit>
        <trans-unit id="d2a09c50d7cce1fe8a525fcca2fb263328178ae3" translate="yes" xml:space="preserve">
          <source>Convert a number to an unsigned integer. If the argument is signed, it is reinterpreted as unsigned without checking for negative values.</source>
          <target state="translated">将一个数字转换为无符号整数。如果参数是有符号的,它将被重新解释为无符号,而不检查负值。</target>
        </trans-unit>
        <trans-unit id="fadb2f4e5a02f95b1f6e83b26d6f82c505453eb8" translate="yes" xml:space="preserve">
          <source>Convert a path to an absolute path by adding the current directory if necessary. Also normalizes the path as in &lt;a href=&quot;#Base.Filesystem.normpath&quot;&gt;&lt;code&gt;normpath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如有必要，可通过添加当前目录将路径转换为绝对路径。也像&lt;a href=&quot;#Base.Filesystem.normpath&quot;&gt; &lt;code&gt;normpath&lt;/code&gt; 中&lt;/a&gt;一样规范路径。</target>
        </trans-unit>
        <trans-unit id="c64e3ac7b8c2c5fca5fadcf3e79dd14dcfa93264" translate="yes" xml:space="preserve">
          <source>Convert a set of paths to a normalized path by joining them together and removing &quot;.&quot; and &quot;..&quot; entries. Equivalent to &lt;code&gt;normpath(joinpath(path, paths...))&lt;/code&gt;.</source>
          <target state="translated">通过将一组路径连接在一起并删除&amp;ldquo;&amp;rdquo;，可以将一组路径转换为规范化路径。和&amp;ldquo; ..&amp;rdquo;条目。等效于 &lt;code&gt;normpath(joinpath(path, paths...))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="99b4eb18032a744b83dd1a3438570db3228d17cf" translate="yes" xml:space="preserve">
          <source>Convert a set of paths to an absolute path by joining them together and adding the current directory if necessary. Equivalent to &lt;code&gt;abspath(joinpath(path, paths...))&lt;/code&gt;.</source>
          <target state="translated">通过将一组路径连接在一起并在必要时添加当前目录，将一组路径转换为绝对路径。等效于 &lt;code&gt;abspath(joinpath(path, paths...))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e9696c8728ca32245943263f7e7949895d8e5a6e" translate="yes" xml:space="preserve">
          <source>Convert a string to &lt;code&gt;String&lt;/code&gt; type and check that it contains only ASCII data, otherwise throwing an &lt;code&gt;ArgumentError&lt;/code&gt; indicating the position of the first non-ASCII byte.</source>
          <target state="translated">将字符串转换为 &lt;code&gt;String&lt;/code&gt; 类型，并检查它是否仅包含ASCII数据，否则抛出 &lt;code&gt;ArgumentError&lt;/code&gt; 来指示第一个非ASCII字节的位置。</target>
        </trans-unit>
        <trans-unit id="c6034bf2e7e922ec416e6749722dfe4bed51455b" translate="yes" xml:space="preserve">
          <source>Convert a string to a contiguous byte array representation encoded as UTF-8 bytes. This representation is often appropriate for passing strings to C.</source>
          <target state="translated">将字符串转换为以UTF-8字节编码的连续字节数组表示。这种表示方式通常适用于向C语言传递字符串。</target>
        </trans-unit>
        <trans-unit id="bdb2e7f4ffa842fe969c9313fede05ab9811deb6" translate="yes" xml:space="preserve">
          <source>Convert a system call error code to a descriptive string</source>
          <target state="translated">将系统调用错误代码转换为描述性字符串。</target>
        </trans-unit>
        <trans-unit id="df69e31a6e1a10ddfb886835ab258a4b8daa2d29" translate="yes" xml:space="preserve">
          <source>Convert a vector &lt;code&gt;A&lt;/code&gt; into a sparse vector of length &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">将向量 &lt;code&gt;A&lt;/code&gt; 转换为长度为 &lt;code&gt;m&lt;/code&gt; 的稀疏向量。</target>
        </trans-unit>
        <trans-unit id="dc282b0433c1cbf1adcdf19666900f8ea0803139" translate="yes" xml:space="preserve">
          <source>Convert all arguments to a common type, and return them all (as a tuple). If no arguments can be converted, an error is raised.</source>
          <target state="translated">将所有参数转换为一个通用类型,并将它们全部返回(作为元组)。如果没有参数可以被转换,就会出现一个错误。</target>
        </trans-unit>
        <trans-unit id="852c15744182eeb7c79c535ea0a2080ac574b6a1" translate="yes" xml:space="preserve">
          <source>Convert an AbstractMatrix &lt;code&gt;A&lt;/code&gt; into a sparse matrix.</source>
          <target state="translated">将AbstractMatrix &lt;code&gt;A&lt;/code&gt; 转换为稀疏矩阵。</target>
        </trans-unit>
        <trans-unit id="dd1965142740f5cf0ae1e7c6f35ada62fa5be03b" translate="yes" xml:space="preserve">
          <source>Convert an array &lt;code&gt;a&lt;/code&gt; of bytes to its hexadecimal string representation, either returning a &lt;code&gt;String&lt;/code&gt; via &lt;code&gt;bytes2hex(a)&lt;/code&gt; or writing the string to an &lt;code&gt;io&lt;/code&gt; stream via &lt;code&gt;bytes2hex(io, a)&lt;/code&gt;. The hexadecimal characters are all lowercase.</source>
          <target state="translated">将字节数组 &lt;code&gt;a&lt;/code&gt; 转换为其十六进制字符串表示形式，或者通过 &lt;code&gt;bytes2hex(a)&lt;/code&gt; 返回 &lt;code&gt;String&lt;/code&gt; ，或者通过 &lt;code&gt;bytes2hex(io, a)&lt;/code&gt; 将字符串写入 &lt;code&gt;io&lt;/code&gt; 流。十六进制字符均为小写。</target>
        </trans-unit>
        <trans-unit id="2a38bb337cc64d1083f1c5c3e38c9c4ed1f44e10" translate="yes" xml:space="preserve">
          <source>Convert an array &lt;code&gt;s&lt;/code&gt; of bytes representing a hexadecimal string to its binary representation, similar to &lt;a href=&quot;#Base.hex2bytes&quot;&gt;&lt;code&gt;hex2bytes&lt;/code&gt;&lt;/a&gt; except that the output is written in-place in &lt;code&gt;d&lt;/code&gt;. The length of &lt;code&gt;s&lt;/code&gt; must be exactly twice the length of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">将代表十六进制字符串的字节数组 &lt;code&gt;s&lt;/code&gt; 转换为其二进制表示形式，类似于&lt;a href=&quot;#Base.hex2bytes&quot;&gt; &lt;code&gt;hex2bytes&lt;/code&gt; ,&lt;/a&gt;不同之处在于将输出原位写入 &lt;code&gt;d&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; 的长度必须恰好是 &lt;code&gt;d&lt;/code&gt; 长度的两倍。</target>
        </trans-unit>
        <trans-unit id="ab9684db5f30d74a1280d752f440f84eeb49090d" translate="yes" xml:space="preserve">
          <source>Convert an integer &lt;code&gt;n&lt;/code&gt; to a string in the given &lt;code&gt;base&lt;/code&gt;, optionally specifying a number of digits to pad to.</source>
          <target state="translated">将整数 &lt;code&gt;n&lt;/code&gt; 转换为给定 &lt;code&gt;base&lt;/code&gt; 中的字符串，可以选择指定要填充的位数。</target>
        </trans-unit>
        <trans-unit id="fb901c455490a134851d84ef564c097e7214f635" translate="yes" xml:space="preserve">
          <source>Convert an integer bitstype to the signed type of the same size.</source>
          <target state="translated">将一个整数位型转换为相同大小的有符号类型。</target>
        </trans-unit>
        <trans-unit id="3a99ef55f693cc997a2d2a862cf2e9207340000d" translate="yes" xml:space="preserve">
          <source>Convert an integer bitstype to the unsigned type of the same size.</source>
          <target state="translated">将整数位型转换为相同大小的无符号类型。</target>
        </trans-unit>
        <trans-unit id="1cc0fdb51bb3f7b06edff8342aa122caf1731c55" translate="yes" xml:space="preserve">
          <source>Convert every array-slicing operation in the given expression (which may be a &lt;code&gt;begin&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; calls (as opposed to &lt;code&gt;array[...]&lt;/code&gt;) are unaffected.</source>
          <target state="translated">转换给定表达式（可能是 &lt;code&gt;begin&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 块，循环，函数等）中的每个数组切片操作以返回视图。标量索引，非数组类型和显式&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;调用（与 &lt;code&gt;array[...]&lt;/code&gt; 相对）不受影响。</target>
        </trans-unit>
        <trans-unit id="8bb7b84b2270454fbcbf5570fc65757f1e6cebfc" translate="yes" xml:space="preserve">
          <source>Convert every array-slicing operation in the given expression (which may be a &lt;code&gt;begin&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; block, loop, function, etc.) to return a view. Scalar indices, non-array types, and explicit &lt;code&gt;getindex&lt;/code&gt; calls (as opposed to &lt;code&gt;array[...]&lt;/code&gt;) are unaffected.</source>
          <target state="translated">转换给定表达式中的每个数组切片操作（可能是 &lt;code&gt;begin&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 块，循环，函数等）以返回视图。标量索引，非数组类型和显式 &lt;code&gt;getindex&lt;/code&gt; 调用（与 &lt;code&gt;array[...]&lt;/code&gt; 相对）不受影响。</target>
        </trans-unit>
        <trans-unit id="7d7ef92f4671416f4ce071adc16fbedc518d6e5a" translate="yes" xml:space="preserve">
          <source>Convert every function call or operator in &lt;code&gt;expr&lt;/code&gt; into a &quot;dot call&quot; (e.g. convert &lt;code&gt;f(x)&lt;/code&gt; to &lt;code&gt;f.(x)&lt;/code&gt;), and convert every assignment in &lt;code&gt;expr&lt;/code&gt; to a &quot;dot assignment&quot; (e.g. convert &lt;code&gt;+=&lt;/code&gt; to &lt;code&gt;.+=&lt;/code&gt;).</source>
          <target state="translated">将 &lt;code&gt;expr&lt;/code&gt; 中的每个函数调用或运算符转换为&amp;ldquo;点调用&amp;rdquo;（例如，将 &lt;code&gt;f(x)&lt;/code&gt; 转换为 &lt;code&gt;f.(x)&lt;/code&gt; ），并将 &lt;code&gt;expr&lt;/code&gt; 中的每个赋值转换为&amp;ldquo;点赋值&amp;rdquo;（例如，将 &lt;code&gt;+=&lt;/code&gt; 转换为 &lt;code&gt;.+=&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6f641f897c98f470a3a4f4e71179b8ae693f515e" translate="yes" xml:space="preserve">
          <source>Convert real numbers or arrays to complex. &lt;code&gt;i&lt;/code&gt; defaults to zero.</source>
          <target state="translated">将实数或数组转换为复数。 &lt;code&gt;i&lt;/code&gt; 默认为零。</target>
        </trans-unit>
        <trans-unit id="ea87e33fbea9c0120e69dc6eed464787821a1d70" translate="yes" xml:space="preserve">
          <source>Convert string data between Unicode encodings. &lt;code&gt;src&lt;/code&gt; is either a &lt;code&gt;String&lt;/code&gt; or a &lt;code&gt;Vector{UIntXX}&lt;/code&gt; of UTF-XX code units, where &lt;code&gt;XX&lt;/code&gt; is 8, 16, or 32. &lt;code&gt;T&lt;/code&gt; indicates the encoding of the return value: &lt;code&gt;String&lt;/code&gt; to return a (UTF-8 encoded) &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;UIntXX&lt;/code&gt; to return a &lt;code&gt;Vector{UIntXX}&lt;/code&gt; of UTF-&lt;code&gt;XX&lt;/code&gt; data. (The alias &lt;a href=&quot;../c/index#Base.Cwchar_t&quot;&gt;&lt;code&gt;Cwchar_t&lt;/code&gt;&lt;/a&gt; can also be used as the integer type, for converting &lt;code&gt;wchar_t*&lt;/code&gt; strings used by external C libraries.)</source>
          <target state="translated">在Unicode编码之间转换字符串数据。 &lt;code&gt;src&lt;/code&gt; 可以是一个 &lt;code&gt;String&lt;/code&gt; 或一 &lt;code&gt;Vector{UIntXX}&lt;/code&gt; 的UTF-XX代码单元，其中 &lt;code&gt;XX&lt;/code&gt; 是8，16或32。 &lt;code&gt;T&lt;/code&gt; 指示的返回值的编码： &lt;code&gt;String&lt;/code&gt; 返回一个（UTF-8编码的） &lt;code&gt;String&lt;/code&gt; 或 &lt;code&gt;UIntXX&lt;/code&gt; 返回UTF- &lt;code&gt;XX&lt;/code&gt; 数据的 &lt;code&gt;Vector{UIntXX}&lt;/code&gt; 。（别名&lt;a href=&quot;../c/index#Base.Cwchar_t&quot;&gt; &lt;code&gt;Cwchar_t&lt;/code&gt; &lt;/a&gt;也可以用作整数类型，用于转换外部C库使用的 &lt;code&gt;wchar_t*&lt;/code&gt; 字符串。）</target>
        </trans-unit>
        <trans-unit id="1172d0b4f4da770ba5d6e3b4b74228cbdea8c23f" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from Little-endian to that used by the Host.</source>
          <target state="translated">将Little-endian的值的endianness转换为主机使用的值。</target>
        </trans-unit>
        <trans-unit id="c18794ff42dbcbf70c7fa0958060c571a3feef1f" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from Network byte order (big-endian) to that used by the Host.</source>
          <target state="translated">将网络字节顺序(big-endian)的值的endianness转换为主机使用的值。</target>
        </trans-unit>
        <trans-unit id="ee8fe2deb202452db007076df4772a7e3e60b91d" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from that used by the Host to Little-endian.</source>
          <target state="translated">将主机使用的值的endianness转换为Little-endian。</target>
        </trans-unit>
        <trans-unit id="b7d61d4fb701d27d4ecda27bcc686224302e3849" translate="yes" xml:space="preserve">
          <source>Convert the endianness of a value from that used by the Host to Network byte order (big-endian).</source>
          <target state="translated">将主机使用的值的endianness转换为网络字节顺序(大endian)。</target>
        </trans-unit>
        <trans-unit id="565d86b9efdcc54de17ee229897b1971efcc1d5c" translate="yes" xml:space="preserve">
          <source>Convert the tuple &lt;code&gt;I&lt;/code&gt; to a tuple of indices for use in indexing into array &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">将元组 &lt;code&gt;I&lt;/code&gt; 转换为索引元组，以用于对数组 &lt;code&gt;A&lt;/code&gt; 进行索引。</target>
        </trans-unit>
        <trans-unit id="52c9208e095da06dd48451e1db0c0aee98a6ff21" translate="yes" xml:space="preserve">
          <source>Convert time, given as a number of seconds since the epoch or a &lt;code&gt;TmStruct&lt;/code&gt;, to a formatted string using the given format. Supported formats are the same as those in the standard C library.</source>
          <target state="translated">使用给定格式将时间（从纪元或 &lt;code&gt;TmStruct&lt;/code&gt; 开始的秒数）转换为格式化的字符串。支持的格式与标准C库中的格式相同。</target>
        </trans-unit>
        <trans-unit id="360e237e67baf5581a5d0115e51882b0bb64ba9d" translate="yes" xml:space="preserve">
          <source>Converting Types</source>
          <target state="translated">转换类型</target>
        </trans-unit>
        <trans-unit id="117dbbf5f7e13aaaf56b35238348c17bd82dc1bc" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;TmStruct&lt;/code&gt; struct to a number of seconds since the epoch.</source>
          <target state="translated">将 &lt;code&gt;TmStruct&lt;/code&gt; 结构转换为自纪元以来的秒数。</target>
        </trans-unit>
        <trans-unit id="5866856f7d0f1c179b640e313eb7bf260c150d0d" translate="yes" xml:space="preserve">
          <source>Converts a matrix &lt;code&gt;A&lt;/code&gt; to Hessenberg form. If &lt;code&gt;A&lt;/code&gt; is balanced with &lt;code&gt;gebal!&lt;/code&gt; then &lt;code&gt;ilo&lt;/code&gt; and &lt;code&gt;ihi&lt;/code&gt; are the outputs of &lt;code&gt;gebal!&lt;/code&gt;. Otherwise they should be &lt;code&gt;ilo = 1&lt;/code&gt; and &lt;code&gt;ihi = size(A,2)&lt;/code&gt;. &lt;code&gt;tau&lt;/code&gt; contains the elementary reflectors of the factorization.</source>
          <target state="translated">将矩阵 &lt;code&gt;A&lt;/code&gt; 转换为Hessenberg形式。如果 &lt;code&gt;A&lt;/code&gt; 与 &lt;code&gt;gebal!&lt;/code&gt; 保持平衡！然后 &lt;code&gt;ilo&lt;/code&gt; 和 &lt;code&gt;ihi&lt;/code&gt; 是输出 &lt;code&gt;gebal!&lt;/code&gt; 。否则，它们应该为 &lt;code&gt;ilo = 1&lt;/code&gt; 和 &lt;code&gt;ihi = size(A,2)&lt;/code&gt; 。 &lt;code&gt;tau&lt;/code&gt; 包含分解的基本反射器。</target>
        </trans-unit>
        <trans-unit id="1711b47dad4f073679f712d5d8503b9e8e2c5d54" translate="yes" xml:space="preserve">
          <source>Converts a symmetric matrix &lt;code&gt;A&lt;/code&gt; (which has been factorized into a triangular matrix) into two matrices &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is upper triangular. If &lt;code&gt;uplo = L&lt;/code&gt;, it is lower triangular. &lt;code&gt;ipiv&lt;/code&gt; is the pivot vector from the triangular factorization. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="translated">转换对称矩阵 &lt;code&gt;A&lt;/code&gt; （其已被因子分解为三角矩阵）转换成两个矩阵 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 为上三角形。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则为下三角形。 &lt;code&gt;ipiv&lt;/code&gt; 是来自三角分解的枢轴向量。 &lt;code&gt;A&lt;/code&gt; 被 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;D&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="d8c7fb874a17720b78d3d32ee54b7667d9caa6f0" translate="yes" xml:space="preserve">
          <source>Cooked Rice</source>
          <target state="translated">煮饭</target>
        </trans-unit>
        <trans-unit id="e4f81994fed009c24d31efd799e2d47a74a60f1f" translate="yes" xml:space="preserve">
          <source>Cookie</source>
          <target state="translated">Cookie</target>
        </trans-unit>
        <trans-unit id="adc0752adbfda6b3ef82749db7442cd223b6747a" translate="yes" xml:space="preserve">
          <source>Cooking</source>
          <target state="translated">Cooking</target>
        </trans-unit>
        <trans-unit id="c9e99b6e36ab0f9069dac6df2dcc61a6537dc4c2" translate="yes" xml:space="preserve">
          <source>Copies a &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.UniformScaling&quot;&gt;&lt;code&gt;UniformScaling&lt;/code&gt;&lt;/a&gt; onto a matrix.</source>
          <target state="translated">将&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.UniformScaling&quot;&gt; &lt;code&gt;UniformScaling&lt;/code&gt; &lt;/a&gt;复制到矩阵上。</target>
        </trans-unit>
        <trans-unit id="418fd7d86083eefae2bf5a47108856be4e4e9db0" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;N&lt;/code&gt; elements from a source array to a destination, starting at offset &lt;code&gt;so&lt;/code&gt; in the source and &lt;code&gt;do&lt;/code&gt; in the destination (1-indexed).</source>
          <target state="translated">拷贝 &lt;code&gt;N&lt;/code&gt; 从源阵列到目的地，元件开始偏移 &lt;code&gt;so&lt;/code&gt; 在源极和 &lt;code&gt;do&lt;/code&gt; 在目的地（1索引）。</target>
        </trans-unit>
        <trans-unit id="7086ba74676f7b4baf8153047650ee206892eea8" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;N&lt;/code&gt; elements from a source pointer to a destination, with no checking. The size of an element is determined by the type of the pointers.</source>
          <target state="translated">将 &lt;code&gt;N&lt;/code&gt; 个元素从源指针复制到目标，无需检查。元素的大小由指针的类型确定。</target>
        </trans-unit>
        <trans-unit id="7118082371777be2d61109ed4a6ec97a39e710bf" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;N&lt;/code&gt; elements from collection &lt;code&gt;src&lt;/code&gt; starting at offset &lt;code&gt;so&lt;/code&gt;, to array &lt;code&gt;dest&lt;/code&gt; starting at offset &lt;code&gt;do&lt;/code&gt;. Return &lt;code&gt;dest&lt;/code&gt;.</source>
          <target state="translated">拷贝 &lt;code&gt;N&lt;/code&gt; 从收集元件 &lt;code&gt;src&lt;/code&gt; 开始偏移 &lt;code&gt;so&lt;/code&gt; ，以阵列 &lt;code&gt;dest&lt;/code&gt; 起始于偏移 &lt;code&gt;do&lt;/code&gt; 。返回 &lt;code&gt;dest&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="616082f2612838a8057d0aa6612b818ee3ba8c7c" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; to array &lt;code&gt;Y&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;. Returns &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">拷贝 &lt;code&gt;n&lt;/code&gt; 阵列的元件 &lt;code&gt;X&lt;/code&gt; 步幅 &lt;code&gt;incx&lt;/code&gt; 到阵列 &lt;code&gt;Y&lt;/code&gt; 与步幅 &lt;code&gt;incy&lt;/code&gt; 。返回 &lt;code&gt;Y&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="253b3d8af9e09ae697807ccdabe6d0a1942c068a" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;nbytes&lt;/code&gt; from &lt;code&gt;ref&lt;/code&gt; (converted to a pointer) into the &lt;code&gt;IO&lt;/code&gt; object.</source>
          <target state="translated">复制 &lt;code&gt;nbytes&lt;/code&gt; 从 &lt;code&gt;ref&lt;/code&gt; （转换为指针）到 &lt;code&gt;IO&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="ea9498c0d16fa0098a8db0d0c7d3b47780674f69" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;nbytes&lt;/code&gt; from the &lt;code&gt;IO&lt;/code&gt; stream object into &lt;code&gt;ref&lt;/code&gt; (converted to a pointer).</source>
          <target state="translated">复制 &lt;code&gt;nbytes&lt;/code&gt; 从 &lt;code&gt;IO&lt;/code&gt; 流对象到 &lt;code&gt;ref&lt;/code&gt; （转换为指针）。</target>
        </trans-unit>
        <trans-unit id="cecc4cc050ce4f8f91b18f5c82de61727aae33fa" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;src&lt;/code&gt; into &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;src&lt;/code&gt; 复制到 &lt;code&gt;dst&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="08e257c9c4d564810a26439e40c66e18e83ae663" translate="yes" xml:space="preserve">
          <source>Copy &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dest&lt;/code&gt;, indexing each dimension modulo its length. &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dest&lt;/code&gt; must have the same size, but can be offset in their indices; any offset results in a (circular) wraparound. If the arrays have overlapping indices, then on the domain of the overlap &lt;code&gt;dest&lt;/code&gt; agrees with &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;src&lt;/code&gt; 复制到 &lt;code&gt;dest&lt;/code&gt; ，索引每个尺寸以其长度为模的索引。 &lt;code&gt;src&lt;/code&gt; 和 &lt;code&gt;dest&lt;/code&gt; 的大小必须相同，但可以在其索引中偏移；任何偏移都会导致（圆形）环绕。如果数组具有重叠索引，则在重叠域上 &lt;code&gt;dest&lt;/code&gt; 与 &lt;code&gt;src&lt;/code&gt; 一致。</target>
        </trans-unit>
        <trans-unit id="9b33b198b9b8b92a3f9f121307b7a03e6e7ec92b" translate="yes" xml:space="preserve">
          <source>Copy a string from the address of a C-style (NUL-terminated) string encoded as UTF-8. (The pointer can be safely freed afterwards.) If &lt;code&gt;length&lt;/code&gt; is specified (the length of the data in bytes), the string does not have to be NUL-terminated.</source>
          <target state="translated">从编码为UTF-8的C样式（NUL终止）字符串的地址中复制一个字符串。如果（指针可以安全之后释放。） &lt;code&gt;length&lt;/code&gt; 指定的（以字节为单位的数据的长度），该字符串没有被NUL终止的。</target>
        </trans-unit>
        <trans-unit id="f8307ea4c313c8f99116fbe12b7c396813b3593b" translate="yes" xml:space="preserve">
          <source>Copy all elements from collection &lt;code&gt;src&lt;/code&gt; to array &lt;code&gt;dest&lt;/code&gt;, whose length must be greater than or equal to the length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;src&lt;/code&gt;. The first &lt;code&gt;n&lt;/code&gt; elements of &lt;code&gt;dest&lt;/code&gt; are overwritten, the other elements are left untouched.</source>
          <target state="translated">所有元素复制从收集 &lt;code&gt;src&lt;/code&gt; 到阵列 &lt;code&gt;dest&lt;/code&gt; ，其长度必须大于或等于长度 &lt;code&gt;n&lt;/code&gt; 的 &lt;code&gt;src&lt;/code&gt; 。 &lt;code&gt;dest&lt;/code&gt; 的前 &lt;code&gt;n&lt;/code&gt; 个元素被覆盖，其他元素保持不变。</target>
        </trans-unit>
        <trans-unit id="6b49bda32e0b471d6ea10bd5d65c62d773295ea5" translate="yes" xml:space="preserve">
          <source>Copy the block of &lt;code&gt;src&lt;/code&gt; in the range of &lt;code&gt;Rsrc&lt;/code&gt; to the block of &lt;code&gt;dest&lt;/code&gt; in the range of &lt;code&gt;Rdest&lt;/code&gt;. The sizes of the two regions must match.</source>
          <target state="translated">的块复制 &lt;code&gt;src&lt;/code&gt; 中的范围 &lt;code&gt;Rsrc&lt;/code&gt; 到的块 &lt;code&gt;dest&lt;/code&gt; 中的范围 &lt;code&gt;Rdest&lt;/code&gt; 。两个区域的大小必须匹配。</target>
        </trans-unit>
        <trans-unit id="2bdeec364785727145bf632b0f9eaad5598f487d" translate="yes" xml:space="preserve">
          <source>Copy the current region in the kill ring</source>
          <target state="translated">在杀戒中复制当前区域</target>
        </trans-unit>
        <trans-unit id="494b84244d7a79e3d342146f96d197a9b13df1d4" translate="yes" xml:space="preserve">
          <source>Copy the file, link, or directory from &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt;. &lt;code&gt;force=true&lt;/code&gt; will first remove an existing &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">将文件，链接或目录从 &lt;code&gt;src&lt;/code&gt; 复制到 &lt;code&gt;dst&lt;/code&gt; 。 &lt;code&gt;force=true&lt;/code&gt; 将首先删除现有的 &lt;code&gt;dst&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee05611b1d41b30e8e6d979b4a8c4ff7e600adce" translate="yes" xml:space="preserve">
          <source>Copying data is not always bad</source>
          <target state="translated">复制数据不一定是坏事</target>
        </trans-unit>
        <trans-unit id="6eab3f0cb190b20918906dcc82257ab7baf2ba9e" translate="yes" xml:space="preserve">
          <source>Copying irregularly-accessed data into a contiguous array before operating on it can result in a large speedup, such as in the example below. Here, a matrix and a vector are being accessed at 800,000 of their randomly-shuffled indices before being multiplied. Copying the views into plain arrays speeds up the multiplication even with the cost of the copying operation.</source>
          <target state="translated">在对数据进行操作之前,将不规则访问的数据复制到一个连续的数组中,可以带来很大的速度提升,比如下面的例子。在这里,一个矩阵和一个向量在被乘法之前以800,000的随机洗牌索引被访问。将视图复制到普通数组中,即使付出了复制操作的代价,也能加快乘法的速度。</target>
        </trans-unit>
        <trans-unit id="d0c22df05117339fafe1fd329c21b24a26965dec" translate="yes" xml:space="preserve">
          <source>Copyright Sign</source>
          <target state="translated">版权标志</target>
        </trans-unit>
        <trans-unit id="68836c550ee20fae0e06b2994e76a40348d2fc30" translate="yes" xml:space="preserve">
          <source>Core</source>
          <target state="translated">Core</target>
        </trans-unit>
        <trans-unit id="fdb7dcf725d9ff74eadf1406976c3bbf0d70d15b" translate="yes" xml:space="preserve">
          <source>Core task operations</source>
          <target state="translated">核心任务业务</target>
        </trans-unit>
        <trans-unit id="68435718cfd9186e13509c3cd4f4f701746b7939" translate="yes" xml:space="preserve">
          <source>Core.&amp;lt;:()</source>
          <target state="translated">Core.&amp;lt;:()</target>
        </trans-unit>
        <trans-unit id="bfa0a59bcde017b3bf44267b3b277a7fdf03f8bf" translate="yes" xml:space="preserve">
          <source>Core.===()</source>
          <target state="translated">Core.===()</target>
        </trans-unit>
        <trans-unit id="fcb0332d7a6b80924b0dfc6c123f03da619ce8d4" translate="yes" xml:space="preserve">
          <source>Core.@big_str</source>
          <target state="translated">Core.@big_str</target>
        </trans-unit>
        <trans-unit id="bd9ec38dd953eaa5a860fec42fa6768a8786b8d0" translate="yes" xml:space="preserve">
          <source>Core.@int128_str</source>
          <target state="translated">Core.@int128_str</target>
        </trans-unit>
        <trans-unit id="0b9fd6658d00a8f0d4ddba1c694762831760c04c" translate="yes" xml:space="preserve">
          <source>Core.@uint128_str</source>
          <target state="translated">Core.@uint128_str</target>
        </trans-unit>
        <trans-unit id="296ea7eb4542328f4efed568f4ac64a33cf2409c" translate="yes" xml:space="preserve">
          <source>Core.AbstractArray</source>
          <target state="translated">Core.AbstractArray</target>
        </trans-unit>
        <trans-unit id="8745757e6d6f0de944cab467602f5200bce73b7e" translate="yes" xml:space="preserve">
          <source>Core.AbstractChar</source>
          <target state="translated">Core.AbstractChar</target>
        </trans-unit>
        <trans-unit id="f9281ac1584aba88d1656863173c6f811866e39f" translate="yes" xml:space="preserve">
          <source>Core.AbstractFloat</source>
          <target state="translated">Core.AbstractFloat</target>
        </trans-unit>
        <trans-unit id="0da6ad13678bdbb6acf562fb31b0b9f43ba7eeae" translate="yes" xml:space="preserve">
          <source>Core.Any</source>
          <target state="translated">Core.Any</target>
        </trans-unit>
        <trans-unit id="b3072e9fbde249b0b11582e28eb5a550b752fb88" translate="yes" xml:space="preserve">
          <source>Core.ArgumentError</source>
          <target state="translated">Core.ArgumentError</target>
        </trans-unit>
        <trans-unit id="22888907eae68bd24b045af66a40d0a8f87acdd9" translate="yes" xml:space="preserve">
          <source>Core.Array</source>
          <target state="translated">Core.Array</target>
        </trans-unit>
        <trans-unit id="5c05caf0af207ca1fc8ad944b0c939c40b9cce04" translate="yes" xml:space="preserve">
          <source>Core.Array()</source>
          <target state="translated">Core.Array()</target>
        </trans-unit>
        <trans-unit id="ef890d110df62768b77f96641bef0d688692fae8" translate="yes" xml:space="preserve">
          <source>Core.AssertionError</source>
          <target state="translated">Core.AssertionError</target>
        </trans-unit>
        <trans-unit id="cda39cf69fda9fce4d0c1778474bccee844768ee" translate="yes" xml:space="preserve">
          <source>Core.Bool</source>
          <target state="translated">Core.Bool</target>
        </trans-unit>
        <trans-unit id="4e265496d9deac0745814371223730156f90e897" translate="yes" xml:space="preserve">
          <source>Core.BoundsError</source>
          <target state="translated">Core.BoundsError</target>
        </trans-unit>
        <trans-unit id="7697e231c0791c99d5656377ad1d693d3f25f083" translate="yes" xml:space="preserve">
          <source>Core.Char</source>
          <target state="translated">Core.Char</target>
        </trans-unit>
        <trans-unit id="872d7172ca50deb1dbfd90eb8902b8b30803b5d4" translate="yes" xml:space="preserve">
          <source>Core.DenseArray</source>
          <target state="translated">Core.DenseArray</target>
        </trans-unit>
        <trans-unit id="db1a4814a9b53a7950c8ccd92b6dbe4af18418aa" translate="yes" xml:space="preserve">
          <source>Core.DivideError</source>
          <target state="translated">Core.DivideError</target>
        </trans-unit>
        <trans-unit id="b63a322de4037bae4a418bcf83078c60409fa5e3" translate="yes" xml:space="preserve">
          <source>Core.DomainError</source>
          <target state="translated">Core.DomainError</target>
        </trans-unit>
        <trans-unit id="2c8038f41e046ff62ed186b6d660cf4350c07ccf" translate="yes" xml:space="preserve">
          <source>Core.ErrorException</source>
          <target state="translated">Core.ErrorException</target>
        </trans-unit>
        <trans-unit id="85a946975d5b2c6fa108054a69ce79f2b5fc2652" translate="yes" xml:space="preserve">
          <source>Core.Expr</source>
          <target state="translated">Core.Expr</target>
        </trans-unit>
        <trans-unit id="adf8a4356b24273f499a98d68588a98afee415cd" translate="yes" xml:space="preserve">
          <source>Core.Float16</source>
          <target state="translated">Core.Float16</target>
        </trans-unit>
        <trans-unit id="ade26249e3759ff4627e030863adb88ab7ffd435" translate="yes" xml:space="preserve">
          <source>Core.Float32</source>
          <target state="translated">Core.Float32</target>
        </trans-unit>
        <trans-unit id="75be2bd2d217782dee5803d78dab051f0a7e3b93" translate="yes" xml:space="preserve">
          <source>Core.Float32()</source>
          <target state="translated">Core.Float32()</target>
        </trans-unit>
        <trans-unit id="574a2ac03f1d4269225e9a7ca962ddc1f5bd6e0d" translate="yes" xml:space="preserve">
          <source>Core.Float64</source>
          <target state="translated">Core.Float64</target>
        </trans-unit>
        <trans-unit id="03b78b265bb8a851f590786360777f4cd4b19a4b" translate="yes" xml:space="preserve">
          <source>Core.Float64()</source>
          <target state="translated">Core.Float64()</target>
        </trans-unit>
        <trans-unit id="7933daacfc58b32ea3800c70c574573e5458dcb7" translate="yes" xml:space="preserve">
          <source>Core.Function</source>
          <target state="translated">Core.Function</target>
        </trans-unit>
        <trans-unit id="038ca03580088ce3d37623c61fcfb6b6d38b3b70" translate="yes" xml:space="preserve">
          <source>Core.InexactError</source>
          <target state="translated">Core.InexactError</target>
        </trans-unit>
        <trans-unit id="d515ef0a8a3fc2e74d7ee3db5592a37ef66cc882" translate="yes" xml:space="preserve">
          <source>Core.InitError</source>
          <target state="translated">Core.InitError</target>
        </trans-unit>
        <trans-unit id="2f346bbcdb1733a15da2deaa4cf7a101a054f984" translate="yes" xml:space="preserve">
          <source>Core.Int128</source>
          <target state="translated">Core.Int128</target>
        </trans-unit>
        <trans-unit id="c76244f8ec1bd146db47ff63ece7126c5ecce326" translate="yes" xml:space="preserve">
          <source>Core.Int16</source>
          <target state="translated">Core.Int16</target>
        </trans-unit>
        <trans-unit id="c07ac7ba49337c002f8438bdc4d76f2c6a794a5c" translate="yes" xml:space="preserve">
          <source>Core.Int32</source>
          <target state="translated">Core.Int32</target>
        </trans-unit>
        <trans-unit id="b1e8c71c0fb7e8eab7fd15e32e3ee02f915bff32" translate="yes" xml:space="preserve">
          <source>Core.Int64</source>
          <target state="translated">Core.Int64</target>
        </trans-unit>
        <trans-unit id="5adeeb593c47c8434e007cc9d7ad654b1432f11e" translate="yes" xml:space="preserve">
          <source>Core.Int8</source>
          <target state="translated">Core.Int8</target>
        </trans-unit>
        <trans-unit id="206ab216f9946898d4ee569a813c97775ab8ffcf" translate="yes" xml:space="preserve">
          <source>Core.Integer</source>
          <target state="translated">Core.Integer</target>
        </trans-unit>
        <trans-unit id="1343f4493cbdfd067dd4f726c3b29faa6c47842a" translate="yes" xml:space="preserve">
          <source>Core.InterruptException</source>
          <target state="translated">Core.InterruptException</target>
        </trans-unit>
        <trans-unit id="fdb7594617144c898358d6c191b858273e707e23" translate="yes" xml:space="preserve">
          <source>Core.Intrinsics.cglobal()</source>
          <target state="translated">Core.Intrinsics.cglobal()</target>
        </trans-unit>
        <trans-unit id="20a6f90cce155a7d96ef21eba9e005decf144663" translate="yes" xml:space="preserve">
          <source>Core.Intrinsics.llvmcall()</source>
          <target state="translated">Core.Intrinsics.llvmcall()</target>
        </trans-unit>
        <trans-unit id="9d1e0921e79d54209b004fcd22a42096752ac75f" translate="yes" xml:space="preserve">
          <source>Core.LoadError</source>
          <target state="translated">Core.LoadError</target>
        </trans-unit>
        <trans-unit id="49c38522ed9ed9a6b135598c807c7b66b22c7d0f" translate="yes" xml:space="preserve">
          <source>Core.MethodError</source>
          <target state="translated">Core.MethodError</target>
        </trans-unit>
        <trans-unit id="08214c47346ff58b29a097b06211a25218897dce" translate="yes" xml:space="preserve">
          <source>Core.Module</source>
          <target state="translated">Core.Module</target>
        </trans-unit>
        <trans-unit id="996b2ba514d97834bc0ceb8962906ba1e309c7be" translate="yes" xml:space="preserve">
          <source>Core.NamedTuple</source>
          <target state="translated">Core.NamedTuple</target>
        </trans-unit>
        <trans-unit id="ddc807b05bcc708dae9f3daa7882c6fde768500d" translate="yes" xml:space="preserve">
          <source>Core.Nothing</source>
          <target state="translated">Core.Nothing</target>
        </trans-unit>
        <trans-unit id="a1605b3e5d4af33eb1d784995584944805da8837" translate="yes" xml:space="preserve">
          <source>Core.Number</source>
          <target state="translated">Core.Number</target>
        </trans-unit>
        <trans-unit id="cffb759d0acecb70b71e451b128264827b26a45a" translate="yes" xml:space="preserve">
          <source>Core.OutOfMemoryError</source>
          <target state="translated">Core.OutOfMemoryError</target>
        </trans-unit>
        <trans-unit id="50247e38ef244b0ab195213eedbe440a9527a25b" translate="yes" xml:space="preserve">
          <source>Core.OverflowError</source>
          <target state="translated">Core.OverflowError</target>
        </trans-unit>
        <trans-unit id="605ce58fd15cef2081e72fcb473a964295017b72" translate="yes" xml:space="preserve">
          <source>Core.Ptr</source>
          <target state="translated">Core.Ptr</target>
        </trans-unit>
        <trans-unit id="4aa22b1ac5767c7ece2ff37b7ab6f5d66aba74b8" translate="yes" xml:space="preserve">
          <source>Core.ReadOnlyMemoryError</source>
          <target state="translated">Core.ReadOnlyMemoryError</target>
        </trans-unit>
        <trans-unit id="9992b8232ed5a4608d8e3e1f57264bdc1498a162" translate="yes" xml:space="preserve">
          <source>Core.Real</source>
          <target state="translated">Core.Real</target>
        </trans-unit>
        <trans-unit id="c4bb8bde829e5b0177d93f78e5c4c26bedd45ec7" translate="yes" xml:space="preserve">
          <source>Core.Ref</source>
          <target state="translated">Core.Ref</target>
        </trans-unit>
        <trans-unit id="1e88502e1b0fca449b8c177759df82c8249fabfb" translate="yes" xml:space="preserve">
          <source>Core.Signed</source>
          <target state="translated">Core.Signed</target>
        </trans-unit>
        <trans-unit id="7de85a1c4301bd314784c9e532d83c75b1188e9d" translate="yes" xml:space="preserve">
          <source>Core.StackOverflowError</source>
          <target state="translated">Core.StackOverflowError</target>
        </trans-unit>
        <trans-unit id="ebfcbc7bb941162c317f7df668e55edccfa18ac5" translate="yes" xml:space="preserve">
          <source>Core.String()</source>
          <target state="translated">Core.String()</target>
        </trans-unit>
        <trans-unit id="c6b2ff713285f8a3d3545ee703798b5068fbc8b6" translate="yes" xml:space="preserve">
          <source>Core.Symbol</source>
          <target state="translated">Core.Symbol</target>
        </trans-unit>
        <trans-unit id="719ea15b5ef608e4f9b483e46d27867d7856adfe" translate="yes" xml:space="preserve">
          <source>Core.Symbol()</source>
          <target state="translated">Core.Symbol()</target>
        </trans-unit>
        <trans-unit id="b6bc78ec3881f86a73e0838ab877c6f01e947ac2" translate="yes" xml:space="preserve">
          <source>Core.Task</source>
          <target state="translated">Core.Task</target>
        </trans-unit>
        <trans-unit id="d4b3751dcc1da5e0797ccacfd253215eabafb483" translate="yes" xml:space="preserve">
          <source>Core.Tuple</source>
          <target state="translated">Core.Tuple</target>
        </trans-unit>
        <trans-unit id="2e5f4d43cf5b759a7ebd1cd5bb3d3b2c243df101" translate="yes" xml:space="preserve">
          <source>Core.TypeError</source>
          <target state="translated">Core.TypeError</target>
        </trans-unit>
        <trans-unit id="724ead70ae6bd23978147c8c986a4fbdc8583ca6" translate="yes" xml:space="preserve">
          <source>Core.UInt128</source>
          <target state="translated">Core.UInt128</target>
        </trans-unit>
        <trans-unit id="bb4c71b5a350b8c4fa05237a29f1315b1c8b4c65" translate="yes" xml:space="preserve">
          <source>Core.UInt16</source>
          <target state="translated">Core.UInt16</target>
        </trans-unit>
        <trans-unit id="6b5bd5abfa77e3c13b1d6819cdf8ff6ea9e64cad" translate="yes" xml:space="preserve">
          <source>Core.UInt32</source>
          <target state="translated">Core.UInt32</target>
        </trans-unit>
        <trans-unit id="3b2afa5595b029a3c3dc735df40952b6a6b196db" translate="yes" xml:space="preserve">
          <source>Core.UInt64</source>
          <target state="translated">Core.UInt64</target>
        </trans-unit>
        <trans-unit id="8c423ad2856bb21a956fcd2f4b4af48877d7fb9e" translate="yes" xml:space="preserve">
          <source>Core.UInt8</source>
          <target state="translated">Core.UInt8</target>
        </trans-unit>
        <trans-unit id="f94b6de69ba6173c6644374bcc0b67c77c478ae9" translate="yes" xml:space="preserve">
          <source>Core.UndefInitializer</source>
          <target state="translated">Core.UndefInitializer</target>
        </trans-unit>
        <trans-unit id="07b2f6fdbd7c59ad9163de0145ef16bf9bb28382" translate="yes" xml:space="preserve">
          <source>Core.UndefKeywordError</source>
          <target state="translated">Core.UndefKeywordError</target>
        </trans-unit>
        <trans-unit id="33d1c00d40609a506a1c35270754761d90c0643e" translate="yes" xml:space="preserve">
          <source>Core.UndefRefError</source>
          <target state="translated">Core.UndefRefError</target>
        </trans-unit>
        <trans-unit id="bdca7f953b36d0f03db4bc9fd8e6e861149fef33" translate="yes" xml:space="preserve">
          <source>Core.UndefVarError</source>
          <target state="translated">Core.UndefVarError</target>
        </trans-unit>
        <trans-unit id="be58e03a069d35a51db9fb4c724606c99abcd8b9" translate="yes" xml:space="preserve">
          <source>Core.Union</source>
          <target state="translated">Core.Union</target>
        </trans-unit>
        <trans-unit id="e8113afc597f4a15b3f06158979a5211244f841e" translate="yes" xml:space="preserve">
          <source>Core.UnionAll</source>
          <target state="translated">Core.UnionAll</target>
        </trans-unit>
        <trans-unit id="d886f4e20b6cb8b062e068aba58a5987a8c7d2da" translate="yes" xml:space="preserve">
          <source>Core.Unsigned</source>
          <target state="translated">Core.Unsigned</target>
        </trans-unit>
        <trans-unit id="33fe88c7ffcf0538e076168da43cd25b19b4de0a" translate="yes" xml:space="preserve">
          <source>Core.Vararg</source>
          <target state="translated">Core.Vararg</target>
        </trans-unit>
        <trans-unit id="4dcab8b27937c697ace2bf0c7ab731d9d437bdeb" translate="yes" xml:space="preserve">
          <source>Core.applicable()</source>
          <target state="translated">Core.applicable()</target>
        </trans-unit>
        <trans-unit id="643b383aa84c34ae8992b0cb054491c81b1dc047" translate="yes" xml:space="preserve">
          <source>Core.eval()</source>
          <target state="translated">Core.eval()</target>
        </trans-unit>
        <trans-unit id="8b059cdc2fd7f4f078d1167b0f81e44ea9df09d6" translate="yes" xml:space="preserve">
          <source>Core.fieldtype()</source>
          <target state="translated">Core.fieldtype()</target>
        </trans-unit>
        <trans-unit id="3ae90d79ffdde7d1fe93c0138223ea72cb2bc8cf" translate="yes" xml:space="preserve">
          <source>Core.getfield()</source>
          <target state="translated">Core.getfield()</target>
        </trans-unit>
        <trans-unit id="2cb5d2a4c6e112f5caca0b950aafc402728e9c5c" translate="yes" xml:space="preserve">
          <source>Core.ifelse()</source>
          <target state="translated">Core.ifelse()</target>
        </trans-unit>
        <trans-unit id="c29e94ae444083d76a880a241f6c75f3ddc68a35" translate="yes" xml:space="preserve">
          <source>Core.invoke()</source>
          <target state="translated">Core.invoke()</target>
        </trans-unit>
        <trans-unit id="76b4f8fbfbbabba6e83b3468fcf7b96015579ea3" translate="yes" xml:space="preserve">
          <source>Core.isa()</source>
          <target state="translated">Core.isa()</target>
        </trans-unit>
        <trans-unit id="36f7c8e658b3370440e7f26e5b0e4965b949fa9d" translate="yes" xml:space="preserve">
          <source>Core.isdefined()</source>
          <target state="translated">Core.isdefined()</target>
        </trans-unit>
        <trans-unit id="9b23ab990d5c62c2a078014be7c66a0c3e4e1394" translate="yes" xml:space="preserve">
          <source>Core.nfields()</source>
          <target state="translated">Core.nfields()</target>
        </trans-unit>
        <trans-unit id="4bfdc3e9e44bf9286116897901c1386226161cb5" translate="yes" xml:space="preserve">
          <source>Core.nothing</source>
          <target state="translated">Core.nothing</target>
        </trans-unit>
        <trans-unit id="6acb02115e779813d9385b137998287991df61da" translate="yes" xml:space="preserve">
          <source>Core.setfield!()</source>
          <target state="translated">Core.setfield!()</target>
        </trans-unit>
        <trans-unit id="bc2b402dd92c1cb92209691d06c9c374342c53a9" translate="yes" xml:space="preserve">
          <source>Core.throw()</source>
          <target state="translated">Core.throw()</target>
        </trans-unit>
        <trans-unit id="12b149e509e75748d21363920cd40e30cf380071" translate="yes" xml:space="preserve">
          <source>Core.tuple()</source>
          <target state="translated">Core.tuple()</target>
        </trans-unit>
        <trans-unit id="00cee46b6d3520d8c9c0c302e4b9730ef4385bad" translate="yes" xml:space="preserve">
          <source>Core.typeassert()</source>
          <target state="translated">Core.typeassert()</target>
        </trans-unit>
        <trans-unit id="7344a7481965a908a1f63b50bbb06366f78822b8" translate="yes" xml:space="preserve">
          <source>Core.typeof()</source>
          <target state="translated">Core.typeof()</target>
        </trans-unit>
        <trans-unit id="4cb44a3ac4df4587e83db94499b7bd7b15a3a955" translate="yes" xml:space="preserve">
          <source>Core.undef</source>
          <target state="translated">Core.undef</target>
        </trans-unit>
        <trans-unit id="2a3a3a3048165677aa2036a7e01c3f31a8bbfbb9" translate="yes" xml:space="preserve">
          <source>CoreLogging.@logmsg</source>
          <target state="translated">CoreLogging.@logmsg</target>
        </trans-unit>
        <trans-unit id="083ef9f048bb882c300a709aa3193ebca0066017" translate="yes" xml:space="preserve">
          <source>CoreLogging.AbstractLogger</source>
          <target state="translated">CoreLogging.AbstractLogger</target>
        </trans-unit>
        <trans-unit id="7c45671f3a729162c6b794ce5d37c65b5cbd80e7" translate="yes" xml:space="preserve">
          <source>CoreLogging.LogLevel</source>
          <target state="translated">CoreLogging.LogLevel</target>
        </trans-unit>
        <trans-unit id="3b0cd222c6d045285b8ee0e92684b83aa993eb4f" translate="yes" xml:space="preserve">
          <source>CoreLogging.NullLogger</source>
          <target state="translated">CoreLogging.NullLogger</target>
        </trans-unit>
        <trans-unit id="75c612241d78e232d7df16e944c5688b6ecbdfbf" translate="yes" xml:space="preserve">
          <source>CoreLogging.SimpleLogger</source>
          <target state="translated">CoreLogging.SimpleLogger</target>
        </trans-unit>
        <trans-unit id="2fdcbae49ec42113338fc354b312540a678eb99e" translate="yes" xml:space="preserve">
          <source>CoreLogging.catch_exceptions()</source>
          <target state="translated">CoreLogging.catch_exceptions()</target>
        </trans-unit>
        <trans-unit id="e26bf5e0d56d658332efbdc5621c8d5d99db9b89" translate="yes" xml:space="preserve">
          <source>CoreLogging.current_logger()</source>
          <target state="translated">CoreLogging.current_logger()</target>
        </trans-unit>
        <trans-unit id="32150b661acfb793c5deeae4288c6191c29a1026" translate="yes" xml:space="preserve">
          <source>CoreLogging.disable_logging()</source>
          <target state="translated">CoreLogging.disable_logging()</target>
        </trans-unit>
        <trans-unit id="1712227ca3e5fec340a2b54bce74f24c7c5894a1" translate="yes" xml:space="preserve">
          <source>CoreLogging.global_logger()</source>
          <target state="translated">CoreLogging.global_logger()</target>
        </trans-unit>
        <trans-unit id="fc77ba9c031aea4b788610634d6c81e058c01fc8" translate="yes" xml:space="preserve">
          <source>CoreLogging.handle_message()</source>
          <target state="translated">CoreLogging.handle_message()</target>
        </trans-unit>
        <trans-unit id="21ade7f50b5f2b77fdf90e85ff21a4ceaddd4938" translate="yes" xml:space="preserve">
          <source>CoreLogging.min_enabled_level()</source>
          <target state="translated">CoreLogging.min_enabled_level()</target>
        </trans-unit>
        <trans-unit id="30f3427e9053621f7d5d000fa501744a3a42e204" translate="yes" xml:space="preserve">
          <source>CoreLogging.shouldlog()</source>
          <target state="translated">CoreLogging.shouldlog()</target>
        </trans-unit>
        <trans-unit id="78d98592599bcbbc6ff9697d2764ea3f8b09a44d" translate="yes" xml:space="preserve">
          <source>CoreLogging.with_logger()</source>
          <target state="translated">CoreLogging.with_logger()</target>
        </trans-unit>
        <trans-unit id="038697113018f4400bc94f1be4aebad0829b635a" translate="yes" xml:space="preserve">
          <source>Coroutines</source>
          <target state="translated">Coroutines</target>
        </trans-unit>
        <trans-unit id="e604caf78b008bde3ccc386c0b84af93d1674441" translate="yes" xml:space="preserve">
          <source>Correspondence of dense and sparse methods</source>
          <target state="translated">密集法和稀疏法的对应关系</target>
        </trans-unit>
        <trans-unit id="2ec7eef5d591077c31b1059b29fd9a3796d5e738" translate="yes" xml:space="preserve">
          <source>Corresponding &lt;code&gt;jl_box_...&lt;/code&gt; functions are used to convert the other way:</source>
          <target state="translated">相应的 &lt;code&gt;jl_box_...&lt;/code&gt; 函数用于转换另一种方式：</target>
        </trans-unit>
        <trans-unit id="a8bdb62815e350c629536da5f5a35ffb4c857a8f" translate="yes" xml:space="preserve">
          <source>Corresponds To</source>
          <target state="translated">对应于</target>
        </trans-unit>
        <trans-unit id="a5e3b3a59299174adc5ed55ffbac2813ee3c97b7" translate="yes" xml:space="preserve">
          <source>Count bytes allocated by each source line</source>
          <target state="translated">计数每个源行分配的字节数</target>
        </trans-unit>
        <trans-unit id="a935e1d9fca63f3ad42808a862be5e14dcaefbac" translate="yes" xml:space="preserve">
          <source>Count executions of source lines</source>
          <target state="translated">计算源行的执行次数</target>
        </trans-unit>
        <trans-unit id="f43f1defbbf16380629ae2bbaba07b0d193c0c34" translate="yes" xml:space="preserve">
          <source>Count the number of elements in &lt;code&gt;A&lt;/code&gt; for which &lt;code&gt;f&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; over the given dimensions.</source>
          <target state="translated">计算 &lt;code&gt;A&lt;/code&gt; 中在给定维度上 &lt;code&gt;f&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 的元素数。</target>
        </trans-unit>
        <trans-unit id="864fe9b91cbdb4ea474b1e34b2b240291fdf1186" translate="yes" xml:space="preserve">
          <source>Count the number of elements in &lt;code&gt;itr&lt;/code&gt; for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;p&lt;/code&gt; is omitted, counts the number of &lt;code&gt;true&lt;/code&gt; elements in &lt;code&gt;itr&lt;/code&gt; (which should be a collection of boolean values).</source>
          <target state="translated">计算 &lt;code&gt;itr&lt;/code&gt; 中谓词 &lt;code&gt;p&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 的元素数。如果省略 &lt;code&gt;p&lt;/code&gt; ，则对 &lt;code&gt;itr&lt;/code&gt; 中的 &lt;code&gt;true&lt;/code&gt; 元素的数量进行计数（应该是布尔值的集合）。</target>
        </trans-unit>
        <trans-unit id="5495a2d2b7b75f22e845e609a82f0800b95ac639" translate="yes" xml:space="preserve">
          <source>Couple With Heart</source>
          <target state="translated">有心夫妇</target>
        </trans-unit>
        <trans-unit id="33935f03e2050408f5414a4ce0ae315ea392ec16" translate="yes" xml:space="preserve">
          <source>Cow</source>
          <target state="translated">Cow</target>
        </trans-unit>
        <trans-unit id="19ec818c8eeccac36c9d30bc148eee4f5bc6c6c2" translate="yes" xml:space="preserve">
          <source>Cow Face</source>
          <target state="translated">牛脸</target>
        </trans-unit>
        <trans-unit id="f45bf4b76973272a188e74b1e822bd5271792064" translate="yes" xml:space="preserve">
          <source>Cptrdiff_t</source>
          <target state="translated">Cptrdiff_t</target>
        </trans-unit>
        <trans-unit id="2052ca757ec7aad7cca2aa68837fc9d25c6aad32" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#Base.Vector&quot;&gt;&lt;code&gt;Vector&lt;/code&gt;&lt;/a&gt; with element type computed from the &lt;code&gt;promote_typeof&lt;/code&gt; of the argument, containing the argument list.</source>
          <target state="translated">创建一个&lt;a href=&quot;#Base.Vector&quot;&gt; &lt;code&gt;Vector&lt;/code&gt; &lt;/a&gt;，其元素类型是根据参数的 &lt;code&gt;promote_typeof&lt;/code&gt; 计算得出的，其中包含参数列表。</target>
        </trans-unit>
        <trans-unit id="a1cfccbb74fce45e29fc62bfbbfd863c0eaf829c" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; by concatenating the string representations of the arguments together.</source>
          <target state="translated">通过将参数的字符串表示连接在一起来创建&lt;a href=&quot;#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b997497f9c1617594d62b35a7977d7c080fb335c" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;#Dates.DateFormat&quot;&gt;&lt;code&gt;DateFormat&lt;/code&gt;&lt;/a&gt; object. Similar to &lt;code&gt;DateFormat(&quot;Y-m-d H:M:S&quot;)&lt;/code&gt; but creates the DateFormat object once during macro expansion.</source>
          <target state="translated">创建一个&lt;a href=&quot;#Dates.DateFormat&quot;&gt; &lt;code&gt;DateFormat&lt;/code&gt; &lt;/a&gt;对象。与 &lt;code&gt;DateFormat(&quot;Y-m-d H:M:S&quot;)&lt;/code&gt; 相似，但是在宏扩展过程中会创建一次DateFormat对象。</target>
        </trans-unit>
        <trans-unit id="7953a760e50891a5121aa77eb1103656235936e1" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; whose values are linked to a file, using memory-mapping; it has the same purpose, works in the same way, and has the same arguments, as &lt;a href=&quot;#Mmap.mmap&quot;&gt;&lt;code&gt;mmap&lt;/code&gt;&lt;/a&gt;, but the byte representation is different.</source>
          <target state="translated">使用内存映射创建一个&lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; ,&lt;/a&gt;其值链接到文件；它具有与&lt;a href=&quot;#Mmap.mmap&quot;&gt; &lt;code&gt;mmap&lt;/code&gt; &lt;/a&gt;相同的目的，以相同的方式工作并且具有相同的参数，但是字节表示形式不同。</target>
        </trans-unit>
        <trans-unit id="dea696a46021d9a2728a369e17215130e20d146d" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;BitArray&lt;/code&gt; with all values set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">创建一个所有值都设置为 &lt;code&gt;false&lt;/code&gt; 的 &lt;code&gt;BitArray&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1d8ab7188df37f14f18fd7682b800d25bb1bf583" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;BitArray&lt;/code&gt; with all values set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">创建一个所有值都设置为 &lt;code&gt;true&lt;/code&gt; 的 &lt;code&gt;BitArray&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a7ea5ce4e6122fb26aa843dbb31c11f3eca6ba2" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Date&lt;/code&gt; through the adjuster API. The starting point will be constructed from the provided &lt;code&gt;y, m, d&lt;/code&gt; arguments, and will be adjusted until &lt;code&gt;f::Function&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. The step size in adjusting can be provided manually through the &lt;code&gt;step&lt;/code&gt; keyword. &lt;code&gt;limit&lt;/code&gt; provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (given that &lt;code&gt;f::Function&lt;/code&gt; is never satisfied).</source>
          <target state="translated">通过调节器API 创建 &lt;code&gt;Date&lt;/code&gt; 。起点将通过提供的 &lt;code&gt;y, m, d&lt;/code&gt; 参数构造，并将一直调整到 &lt;code&gt;f::Function&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 为止。调整中的步长可以通过 &lt;code&gt;step&lt;/code&gt; 关键字手动提供。 &lt;code&gt;limit&lt;/code&gt; 提供了对调整API在引发错误之前将进行的最大迭代次数的限制（假设从不满足 &lt;code&gt;f::Function&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="f6735235a65d9c71ac1be9b11a48f9584b5d2fbf" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;DateTime&lt;/code&gt; through the adjuster API. The starting point will be constructed from the provided &lt;code&gt;y, m, d...&lt;/code&gt; arguments, and will be adjusted until &lt;code&gt;f::Function&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. The step size in adjusting can be provided manually through the &lt;code&gt;step&lt;/code&gt; keyword. &lt;code&gt;limit&lt;/code&gt; provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that &lt;code&gt;f::Function&lt;/code&gt; is never satisfied).</source>
          <target state="translated">通过调整器API 创建 &lt;code&gt;DateTime&lt;/code&gt; 。起点将从提供的 &lt;code&gt;y, m, d...&lt;/code&gt; 参数构造，并将一直调整到 &lt;code&gt;f::Function&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 为止。调整中的步长可以通过 &lt;code&gt;step&lt;/code&gt; 关键字手动提供。 &lt;code&gt;limit&lt;/code&gt; 提供了对调整API在引发错误之前将进行的最大迭代次数的限制（如果从不满足 &lt;code&gt;f::Function&lt;/code&gt; 的情况）。</target>
        </trans-unit>
        <trans-unit id="8f4f3e071879154940403d1e8565c4123c50feeb" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Float32&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is not exactly representable then &lt;code&gt;mode&lt;/code&gt; determines how &lt;code&gt;x&lt;/code&gt; is rounded.</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 创建一个 &lt;code&gt;Float32&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 不能精确表示，则 &lt;code&gt;mode&lt;/code&gt; 确定如何对 &lt;code&gt;x&lt;/code&gt; 进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="cb6cec94ec1ca41eee89abd6d594b2b0d7efa1c2" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Float64&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is not exactly representable then &lt;code&gt;mode&lt;/code&gt; determines how &lt;code&gt;x&lt;/code&gt; is rounded.</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 创建一个 &lt;code&gt;Float64&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 不能精确表示，则 &lt;code&gt;mode&lt;/code&gt; 确定如何对 &lt;code&gt;x&lt;/code&gt; 进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="f0b2de9107e787e44816ea2763bde3a0b81e7b6a" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Future&lt;/code&gt; on process &lt;code&gt;pid&lt;/code&gt;. The default &lt;code&gt;pid&lt;/code&gt; is the current process.</source>
          <target state="translated">在进程 &lt;code&gt;pid&lt;/code&gt; 上创建 &lt;code&gt;Future&lt;/code&gt; 。默认 &lt;code&gt;pid&lt;/code&gt; 是当前进程。</target>
        </trans-unit>
        <trans-unit id="93754c4cc4d2cf6371ad6458eaa46263dd773ceb" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;MersenneTwister&lt;/code&gt; RNG object. Different RNG objects can have their own seeds, which may be useful for generating different streams of random numbers. The &lt;code&gt;seed&lt;/code&gt; may be a non-negative integer or a vector of &lt;code&gt;UInt32&lt;/code&gt; integers. If no seed is provided, a randomly generated one is created (using entropy from the system). See the &lt;a href=&quot;#Random.seed!&quot;&gt;&lt;code&gt;seed!&lt;/code&gt;&lt;/a&gt; function for reseeding an already existing &lt;code&gt;MersenneTwister&lt;/code&gt; object.</source>
          <target state="translated">创建一个 &lt;code&gt;MersenneTwister&lt;/code&gt; RNG对象。不同的RNG对象可以具有自己的种子，这对于生成不同的随机数流可能很有用。该 &lt;code&gt;seed&lt;/code&gt; 可以是一个非负整数或的向量 &lt;code&gt;UInt32&lt;/code&gt; 的整数。如果没有提供种子，则会创建一个随机生成的种子（使用系统的熵）。看到&lt;a href=&quot;#Random.seed!&quot;&gt; &lt;code&gt;seed!&lt;/code&gt; &lt;/a&gt;用于重新播种已存在的 &lt;code&gt;MersenneTwister&lt;/code&gt; 对象的函数。</target>
        </trans-unit>
        <trans-unit id="a3e12d3c226dfe774941f86975e7c21147d9a449" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;RandomDevice&lt;/code&gt; RNG object. Two such objects will always generate different streams of random numbers. The entropy is obtained from the operating system.</source>
          <target state="translated">创建一个 &lt;code&gt;RandomDevice&lt;/code&gt; RNG对象。两个这样的对象将始终生成不同的随机数流。熵是从操作系统获得的。</target>
        </trans-unit>
        <trans-unit id="e8fd6ad24887f0f7617a75f378c73e4ba123e3c8" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;TCPServer&lt;/code&gt; on any port, using hint as a starting point. Returns a tuple of the actual port that the server was created on and the server itself.</source>
          <target state="translated">以提示为起点，在任何端口上创建一个 &lt;code&gt;TCPServer&lt;/code&gt; 。返回创建服务器所在的实际端口和服务器本身的元组。</target>
        </trans-unit>
        <trans-unit id="9e6c48c71c33deba3dc37dfcd9d80b03a98023e0" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Task&lt;/code&gt; (i.e. coroutine) to execute the given function &lt;code&gt;func&lt;/code&gt; (which must be callable with no arguments). The task exits when this function returns.</source>
          <target state="translated">创建一个 &lt;code&gt;Task&lt;/code&gt; （即协程）以执行给定的函数 &lt;code&gt;func&lt;/code&gt; （该函数必须可无参数调用）。该函数返回时，任务退出。</target>
        </trans-unit>
        <trans-unit id="33aebc23f268facb98b68a3291c3e0f31f10f201" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Text&lt;/code&gt; object from a literal string.</source>
          <target state="translated">从文字字符串创建 &lt;code&gt;Text&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="9acff786cd532c004e7fc905975913a4901883b1" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;Time&lt;/code&gt; through the adjuster API. The starting point will be constructed from the provided &lt;code&gt;h, mi, s, ms, us&lt;/code&gt; arguments, and will be adjusted until &lt;code&gt;f::Function&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;. The step size in adjusting can be provided manually through the &lt;code&gt;step&lt;/code&gt; keyword. &lt;code&gt;limit&lt;/code&gt; provides a limit to the max number of iterations the adjustment API will pursue before throwing an error (in the case that &lt;code&gt;f::Function&lt;/code&gt; is never satisfied). Note that the default step will adjust to allow for greater precision for the given arguments; i.e. if hour, minute, and second arguments are provided, the default step will be &lt;code&gt;Millisecond(1)&lt;/code&gt; instead of &lt;code&gt;Second(1)&lt;/code&gt;.</source>
          <target state="translated">通过调节器API 创建 &lt;code&gt;Time&lt;/code&gt; 。起点将根据提供的 &lt;code&gt;h, mi, s, ms, us&lt;/code&gt; 参数构造，并将一直调整到 &lt;code&gt;f::Function&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 为止。调整中的步长可以通过 &lt;code&gt;step&lt;/code&gt; 关键字手动提供。 &lt;code&gt;limit&lt;/code&gt; 提供了对调整API在引发错误之前将进行的最大迭代次数的限制（如果从不满足 &lt;code&gt;f::Function&lt;/code&gt; 的情况）。注意，默认步骤将进行调整，以使给定参数的精度更高；例如，如果提供了小时，分钟和第二个参数，则默认步骤将是 &lt;code&gt;Millisecond(1)&lt;/code&gt; 而不是 &lt;code&gt;Second(1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c627f9ad41e59c07607d6bd4b21b09b55e3881e7" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;WorkerPool&lt;/code&gt; from a vector of worker ids.</source>
          <target state="translated">根据工作者ID的向量创建一个 &lt;code&gt;WorkerPool&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f12caa09152736ae8bfc5bb08f6c10223240aec7" translate="yes" xml:space="preserve">
          <source>Create a async condition that calls the given &lt;code&gt;callback&lt;/code&gt; function. The &lt;code&gt;callback&lt;/code&gt; is passed one argument, the async condition object itself.</source>
          <target state="translated">创建一个异步条件，该条件调用给定的 &lt;code&gt;callback&lt;/code&gt; 函数。该 &lt;code&gt;callback&lt;/code&gt; 传递一个参数，异步条件对象本身。</target>
        </trans-unit>
        <trans-unit id="e5a7b2716d759210ecda9bce2dfa1f57b9170956" translate="yes" xml:space="preserve">
          <source>Create a async condition that wakes up tasks waiting for it (by calling &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the object) when notified from C by a call to &lt;code&gt;uv_async_send&lt;/code&gt;. Waiting tasks are woken with an error when the object is closed (by &lt;a href=&quot;../io-network/index#Base.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;../io-network/index#Base.isopen&quot;&gt;&lt;code&gt;isopen&lt;/code&gt;&lt;/a&gt; to check whether it is still active.</source>
          <target state="translated">创建异步条件，以在通过调用 &lt;code&gt;uv_async_send&lt;/code&gt; 从C通知时唤醒等待它的任务（通过在对象上调用&lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;）。关闭对象时，等待的任务被错误唤醒（通过&lt;a href=&quot;../io-network/index#Base.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt;。使用&lt;a href=&quot;../io-network/index#Base.isopen&quot;&gt; &lt;code&gt;isopen&lt;/code&gt; &lt;/a&gt;来检查其是否仍处于活动状态。</target>
        </trans-unit>
        <trans-unit id="090a3944a91674778ee0a002d6a90d0bc41ff5ca" translate="yes" xml:space="preserve">
          <source>Create a closure around an expression and run it on an automatically-chosen process, returning a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to the result.</source>
          <target state="translated">在表达式周围创建一个闭包，并在自动选择的流程上运行它，将&lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;返回结果。</target>
        </trans-unit>
        <trans-unit id="893f51793311a49b3b24a2293576ed62237ed0ec" translate="yes" xml:space="preserve">
          <source>Create a closure around an expression and run the closure asynchronously on process &lt;code&gt;p&lt;/code&gt;. Return a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to the result. Accepts two arguments, &lt;code&gt;p&lt;/code&gt; and an expression.</source>
          <target state="translated">创建围绕表达式的闭包，并在进程 &lt;code&gt;p&lt;/code&gt; 上异步运行闭包。将&lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;返回结果。接受两个参数 &lt;code&gt;p&lt;/code&gt; 和一个表达式。</target>
        </trans-unit>
        <trans-unit id="85036d818cc4d94ce8946366f07822d8fe6c3c69" translate="yes" xml:space="preserve">
          <source>Create a closure around an expression and run the closure asynchronously on process &lt;code&gt;p&lt;/code&gt;. Return a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; to the result. If &lt;code&gt;p&lt;/code&gt; is the quoted literal symbol &lt;code&gt;:any&lt;/code&gt;, then the system will pick a processor to use automatically.</source>
          <target state="translated">在表达式周围创建一个闭包，并在进程 &lt;code&gt;p&lt;/code&gt; 上异步运行该闭包。将&lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;返回结果。如果 &lt;code&gt;p&lt;/code&gt; 是带引号的文字符号 &lt;code&gt;:any&lt;/code&gt; ，则系统将选择一个处理器以自动使用。</target>
        </trans-unit>
        <trans-unit id="c74b846dbbbc1ae3b521fb938c06a70c93c0aa1c" translate="yes" xml:space="preserve">
          <source>Create a counting semaphore that allows at most &lt;code&gt;sem_size&lt;/code&gt; acquires to be in use at any time. Each acquire must be matched with a release.</source>
          <target state="translated">创建一个计数信号量，该信号量最多允许随时使用 &lt;code&gt;sem_size&lt;/code&gt; 获取。每个获取必须与一个发布匹配。</target>
        </trans-unit>
        <trans-unit id="3c2f227958f5b5ddf7f1444e043ef8a63ac36641" translate="yes" xml:space="preserve">
          <source>Create a deep copy of &lt;code&gt;x&lt;/code&gt;: everything is copied recursively, resulting in a fully independent object. For example, deep-copying an array produces a new array whose elements are deep copies of the original elements. Calling &lt;code&gt;deepcopy&lt;/code&gt; on an object should generally have the same effect as serializing and then deserializing it.</source>
          <target state="translated">创建 &lt;code&gt;x&lt;/code&gt; 的深层副本：递归复制所有内容，从而产生完全独立的对象。例如，对数组进行深度复制将产生一个新数组，其元素是原始元素的深层副本。通常，在对象上调用 &lt;code&gt;deepcopy&lt;/code&gt; 与序列化然后反序列化具有相同的效果。</target>
        </trans-unit>
        <trans-unit id="06de478930a8bc99659c25d8415dcac3d4dfaee0" translate="yes" xml:space="preserve">
          <source>Create a function that checks whether its argument contains &lt;code&gt;needle&lt;/code&gt;, i.e. a function equivalent to &lt;code&gt;haystack -&amp;gt; contains(haystack, needle)&lt;/code&gt;.</source>
          <target state="translated">创建一个检查其参数是否包含 &lt;code&gt;needle&lt;/code&gt; 的函数，即等效于 &lt;code&gt;haystack -&amp;gt; contains(haystack, needle)&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="839327adadbf1969796937dbbf4b3400e310dc29" translate="yes" xml:space="preserve">
          <source>Create a function that checks whether its argument ends with &lt;code&gt;suffix&lt;/code&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; endswith(y, suffix)&lt;/code&gt;.</source>
          <target state="translated">创建一个检查其参数是否以 &lt;code&gt;suffix&lt;/code&gt; 结尾的函数，即等效于 &lt;code&gt;y -&amp;gt; endswith(y, suffix)&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="96755a5423f27566ec27c9cf388800b6e09c90bc" translate="yes" xml:space="preserve">
          <source>Create a function that checks whether its argument starts with &lt;code&gt;prefix&lt;/code&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; startswith(y, prefix)&lt;/code&gt;.</source>
          <target state="translated">创建一个检查其参数是否以 &lt;code&gt;prefix&lt;/code&gt; 开头的函数，即等效于 &lt;code&gt;y -&amp;gt; startswith(y, prefix)&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="fa9e6555c025221820dc540d8f7a0e05f0b656fe" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:!=&quot;&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y != x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(!=)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">创建一个使用&lt;a href=&quot;#Base.:!=&quot;&gt; &lt;code&gt;!=&lt;/code&gt; &lt;/a&gt;将其参数与 &lt;code&gt;x&lt;/code&gt; 进行比较的函数，即等效于 &lt;code&gt;y -&amp;gt; y != x&lt;/code&gt; 。返回的函数的类型为 &lt;code&gt;Base.Fix2{typeof(!=)}&lt;/code&gt; ，可用于实现专门的方法。</target>
        </trans-unit>
        <trans-unit id="af72c3093498da482669882ee76ee4892ac8f823" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;gt;&quot;&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;gt; x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;gt;)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">创建一个使用&lt;a href=&quot;#Base.:&amp;gt;&quot;&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;将其参数与 &lt;code&gt;x&lt;/code&gt; 比较的函数，即等效于 &lt;code&gt;y -&amp;gt; y &amp;gt; x&lt;/code&gt; 。返回的函数的类型为 &lt;code&gt;Base.Fix2{typeof(&amp;gt;)}&lt;/code&gt; ，可用于实现专门的方法。</target>
        </trans-unit>
        <trans-unit id="99645591e772ccfbb35aa20a63f502286477bdca" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;gt;=&quot;&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;gt;= x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;gt;=)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">创建一个使用&lt;a href=&quot;#Base.:&amp;gt;=&quot;&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;/a&gt;将其参数与 &lt;code&gt;x&lt;/code&gt; 比较的函数，即等效于 &lt;code&gt;y -&amp;gt; y &amp;gt;= x&lt;/code&gt; 。返回的函数的类型为 &lt;code&gt;Base.Fix2{typeof(&amp;gt;=)}&lt;/code&gt; ，可用于实现专门的方法。</target>
        </trans-unit>
        <trans-unit id="b397904853b03daedf092cc5a494f6b012bca332" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;lt; x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;lt;)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">创建一个使用&lt;a href=&quot;#Base.:&amp;lt;&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;/a&gt;将其自变量与 &lt;code&gt;x&lt;/code&gt; 比较的函数，即等效于 &lt;code&gt;y -&amp;gt; y &amp;lt; x&lt;/code&gt; 。返回的函数的类型为 &lt;code&gt;Base.Fix2{typeof(&amp;lt;)}&lt;/code&gt; ，可用于实现专门的方法。</target>
        </trans-unit>
        <trans-unit id="d48667c6a66ce4f649d12d09795f7243f057de17" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:&amp;lt;=&quot;&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;lt;= x&lt;/code&gt;. The returned function is of type &lt;code&gt;Base.Fix2{typeof(&amp;lt;=)}&lt;/code&gt;, which can be used to implement specialized methods.</source>
          <target state="translated">创建一个使用&lt;a href=&quot;#Base.:&amp;lt;=&quot;&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &lt;/a&gt;将其自变量与 &lt;code&gt;x&lt;/code&gt; 比较的函数，即等效于 &lt;code&gt;y -&amp;gt; y &amp;lt;= x&lt;/code&gt; 。返回的函数的类型为 &lt;code&gt;Base.Fix2{typeof(&amp;lt;=)}&lt;/code&gt; ，可用于实现专门的方法。</target>
        </trans-unit>
        <trans-unit id="7cc3766565df9d8df73c197f4db993c361226594" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y == x&lt;/code&gt;.</source>
          <target state="translated">创建一个使用&lt;a href=&quot;#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;将其参数与 &lt;code&gt;x&lt;/code&gt; 比较的函数，即等效于 &lt;code&gt;y -&amp;gt; y == x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="39a67963f2c04e3b7585aacebf07d65a32e22eec" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;a href=&quot;#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; isequal(y, x)&lt;/code&gt;.</source>
          <target state="translated">创建一个使用&lt;a href=&quot;#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt;将其参数与 &lt;code&gt;x&lt;/code&gt; 比较的函数，即等效于 &lt;code&gt;y -&amp;gt; isequal(y, x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43bfb5caaef93e97947e222246c6c4ab15ae49d9" translate="yes" xml:space="preserve">
          <source>Create a function that compares its argument to &lt;code&gt;x&lt;/code&gt; using &lt;code&gt;&amp;asymp;&lt;/code&gt;, i.e. a function equivalent to &lt;code&gt;y -&amp;gt; y &amp;asymp; x&lt;/code&gt;.</source>
          <target state="translated">创建一个使用 &lt;code&gt;&amp;asymp;&lt;/code&gt; 将其自变量与 &lt;code&gt;x&lt;/code&gt; 进行比较的函数，即等效于 &lt;code&gt;y -&amp;gt; y &amp;asymp; x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3df28caac8a888672e501e021dd972bc1bf923af" translate="yes" xml:space="preserve">
          <source>Create a generator that iterates over dimensions &lt;code&gt;dims&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt;, returning views that select all the data from the other dimensions in &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">创建一个生成器，该生成器在 &lt;code&gt;A&lt;/code&gt; 的维度 &lt;code&gt;dims&lt;/code&gt; 进行迭代，返回从 &lt;code&gt;A&lt;/code&gt; 的其他维度中选择所有数据的视图。</target>
        </trans-unit>
        <trans-unit id="9bbed9d6a52b2907a10c83ce50cbadca820735e6" translate="yes" xml:space="preserve">
          <source>Create a generator that iterates over the first dimension of vector or matrix &lt;code&gt;A&lt;/code&gt;, returning the rows as &lt;code&gt;AbstractVector&lt;/code&gt; views.</source>
          <target state="translated">创建一个生成器，该生成器在向量或矩阵 &lt;code&gt;A&lt;/code&gt; 的第一维上进行迭代，并将行作为 &lt;code&gt;AbstractVector&lt;/code&gt; 视图返回。</target>
        </trans-unit>
        <trans-unit id="6bf92532f071031f3b73100cad4957bc6f24a44a" translate="yes" xml:space="preserve">
          <source>Create a generator that iterates over the second dimension of matrix &lt;code&gt;A&lt;/code&gt;, returning the columns as &lt;code&gt;AbstractVector&lt;/code&gt; views.</source>
          <target state="translated">创建一个生成器，该生成器在矩阵 &lt;code&gt;A&lt;/code&gt; 的第二维上进行迭代，并将这些列作为 &lt;code&gt;AbstractVector&lt;/code&gt; 视图返回。</target>
        </trans-unit>
        <trans-unit id="c4897ffc204435872d3aa27261454e300b1e8498" translate="yes" xml:space="preserve">
          <source>Create a level-triggered event source. Tasks that call &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on an &lt;code&gt;Event&lt;/code&gt; are suspended and queued until &lt;code&gt;notify&lt;/code&gt; is called on the &lt;code&gt;Event&lt;/code&gt;. After &lt;code&gt;notify&lt;/code&gt; is called, the &lt;code&gt;Event&lt;/code&gt; remains in a signaled state and tasks will no longer block when waiting for it.</source>
          <target state="translated">创建一个级别触发的事件源。在 &lt;code&gt;Event&lt;/code&gt; 上调用&lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; 的&lt;/a&gt;任务被挂起并排队，直到在该 &lt;code&gt;Event&lt;/code&gt; 上调用 &lt;code&gt;notify&lt;/code&gt; 为止。调用 &lt;code&gt;notify&lt;/code&gt; 之后， &lt;code&gt;Event&lt;/code&gt; 保持在已通知状态，并且等待时任务将不再阻塞。</target>
        </trans-unit>
        <trans-unit id="fe9984ac6bdc01807145947503bc5f82261b9154" translate="yes" xml:space="preserve">
          <source>Create a level-triggered event source. Tasks that call &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on an &lt;code&gt;Event&lt;/code&gt; are suspended and queued until &lt;code&gt;notify&lt;/code&gt; is called on the &lt;code&gt;Event&lt;/code&gt;. After &lt;code&gt;notify&lt;/code&gt; is called, the &lt;code&gt;Event&lt;/code&gt; remains in a signaled state and tasks will no longer block when waiting for it.</source>
          <target state="translated">创建一个级别触发的事件源。在 &lt;code&gt;Event&lt;/code&gt; 上调用&lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; 的&lt;/a&gt;任务被挂起并排队，直到在该 &lt;code&gt;Event&lt;/code&gt; 上调用 &lt;code&gt;notify&lt;/code&gt; 为止。调用 &lt;code&gt;notify&lt;/code&gt; 之后， &lt;code&gt;Event&lt;/code&gt; 保持在已通知状态，并且等待时任务将不再阻塞。</target>
        </trans-unit>
        <trans-unit id="6b28ca2340f5d2245f4bb80af46a6a182e72737e" translate="yes" xml:space="preserve">
          <source>Create a log record with an informational &lt;code&gt;message&lt;/code&gt;. For convenience, four logging macros &lt;code&gt;@debug&lt;/code&gt;, &lt;code&gt;@info&lt;/code&gt;, &lt;code&gt;@warn&lt;/code&gt; and &lt;code&gt;@error&lt;/code&gt; are defined which log at the standard severity levels &lt;code&gt;Debug&lt;/code&gt;, &lt;code&gt;Info&lt;/code&gt;, &lt;code&gt;Warn&lt;/code&gt; and &lt;code&gt;Error&lt;/code&gt;. &lt;code&gt;@logmsg&lt;/code&gt; allows &lt;code&gt;level&lt;/code&gt; to be set programmatically to any &lt;code&gt;LogLevel&lt;/code&gt; or custom log level types.</source>
          <target state="translated">创建一条带有参考 &lt;code&gt;message&lt;/code&gt; 的日志记录。为方便起见，四个伐木宏 &lt;code&gt;@debug&lt;/code&gt; ， &lt;code&gt;@info&lt;/code&gt; ， &lt;code&gt;@warn&lt;/code&gt; 和 &lt;code&gt;@error&lt;/code&gt; 定义其日志在标准严重级别 &lt;code&gt;Debug&lt;/code&gt; ， &lt;code&gt;Info&lt;/code&gt; ， &lt;code&gt;Warn&lt;/code&gt; 和 &lt;code&gt;Error&lt;/code&gt; 。 &lt;code&gt;@logmsg&lt;/code&gt; 允许以编程方式将 &lt;code&gt;level&lt;/code&gt; 设置为任何 &lt;code&gt;LogLevel&lt;/code&gt; 或自定义日志级别类型。</target>
        </trans-unit>
        <trans-unit id="17ffd2c5ff267c519e387826ecf2e1a0e8741d44" translate="yes" xml:space="preserve">
          <source>Create a multidimensional index &lt;code&gt;I&lt;/code&gt;, which can be used for indexing a multidimensional array &lt;code&gt;A&lt;/code&gt;. In particular, &lt;code&gt;A[I]&lt;/code&gt; is equivalent to &lt;code&gt;A[i,j,k...]&lt;/code&gt;. One can freely mix integer and &lt;code&gt;CartesianIndex&lt;/code&gt; indices; for example, &lt;code&gt;A[Ipre, i, Ipost]&lt;/code&gt; (where &lt;code&gt;Ipre&lt;/code&gt; and &lt;code&gt;Ipost&lt;/code&gt; are &lt;code&gt;CartesianIndex&lt;/code&gt; indices and &lt;code&gt;i&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt;) can be a useful expression when writing algorithms that work along a single dimension of an array of arbitrary dimensionality.</source>
          <target state="translated">创建多维索引 &lt;code&gt;I&lt;/code&gt; ，其可用于索引多维数组 &lt;code&gt;A&lt;/code&gt; 。特别地， &lt;code&gt;A[I]&lt;/code&gt; 等效于 &lt;code&gt;A[i,j,k...]&lt;/code&gt; 。一个人可以自由地混合整数和 &lt;code&gt;CartesianIndex&lt;/code&gt; 索引。例如， &lt;code&gt;A[Ipre, i, Ipost]&lt;/code&gt; （其中 &lt;code&gt;Ipre&lt;/code&gt; 和 &lt;code&gt;Ipost&lt;/code&gt; 是 &lt;code&gt;CartesianIndex&lt;/code&gt; 索引，而 &lt;code&gt;i&lt;/code&gt; 是 &lt;code&gt;Int&lt;/code&gt; ）在编写沿任意维数组的单个维工作的算法时可能是一个有用的表达式。</target>
        </trans-unit>
        <trans-unit id="ae96087e76a9ce107c6e36702cbdc6f8e4f2b8bf" translate="yes" xml:space="preserve">
          <source>Create a new branch in the repository &lt;code&gt;repo&lt;/code&gt; with name &lt;code&gt;bname&lt;/code&gt;, which points to commit &lt;code&gt;commit_obj&lt;/code&gt; (which has to be part of &lt;code&gt;repo&lt;/code&gt;). If &lt;code&gt;force&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, overwrite an existing branch named &lt;code&gt;bname&lt;/code&gt; if it exists. If &lt;code&gt;force&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and a branch already exists named &lt;code&gt;bname&lt;/code&gt;, this function will throw an error.</source>
          <target state="translated">在名称为 &lt;code&gt;bname&lt;/code&gt; 的存储库 &lt;code&gt;repo&lt;/code&gt; 创建一个新分支，该分支指向commit &lt;code&gt;commit_obj&lt;/code&gt; （必须是 &lt;code&gt;repo&lt;/code&gt; 的一部分）。如果 &lt;code&gt;force&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则覆盖现有的名为 &lt;code&gt;bname&lt;/code&gt; 的分支（如果存在）。如果 &lt;code&gt;force&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 且已经存在名为 &lt;code&gt;bname&lt;/code&gt; 的分支，则此函数将引发错误。</target>
        </trans-unit>
        <trans-unit id="e28bd414b679935ce0ac5b71eed117e81cfc03a3" translate="yes" xml:space="preserve">
          <source>Create a new entry in the &lt;code&gt;ImmutableDict&lt;/code&gt; for a &lt;code&gt;key =&amp;gt; value&lt;/code&gt; pair</source>
          <target state="translated">在 &lt;code&gt;ImmutableDict&lt;/code&gt; 中为 &lt;code&gt;key =&amp;gt; value&lt;/code&gt; 对创建一个新条目</target>
        </trans-unit>
        <trans-unit id="542fd8a0f22e252853b2fa3a6c97502feebfa45d" translate="yes" xml:space="preserve">
          <source>Create a new entry in the Immutable Dictionary for the key =&amp;gt; value pair</source>
          <target state="translated">在不可变字典中为key =&amp;gt; value对创建一个新条目</target>
        </trans-unit>
        <trans-unit id="018e91396b89ddf1c7a72876b6df9778e135f2b3" translate="yes" xml:space="preserve">
          <source>Create a new git tag &lt;code&gt;tag&lt;/code&gt; (e.g. &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt;) in the repository &lt;code&gt;repo&lt;/code&gt;, at the commit &lt;code&gt;commit&lt;/code&gt;.</source>
          <target state="translated">创建一个新的git标签 &lt;code&gt;tag&lt;/code&gt; （例如 &lt;code&gt;&quot;v0.5&quot;&lt;/code&gt; 在仓库中） &lt;code&gt;repo&lt;/code&gt; ，在提交 &lt;code&gt;commit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5b4ff3854097fc8c2ce65e16277d31c3dea329e8" translate="yes" xml:space="preserve">
          <source>Create a new task from &lt;code&gt;func&lt;/code&gt;, bind it to a new channel of type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;size&lt;/code&gt;, and schedule the task, all in a single call.</source>
          <target state="translated">通过 &lt;code&gt;func&lt;/code&gt; 创建一个新任务，将其绑定到类型为 &lt;code&gt;T&lt;/code&gt; 且大小为 &lt;code&gt;size&lt;/code&gt; 的新通道，并在一次调用中安排任务。</target>
        </trans-unit>
        <trans-unit id="5a3af261697fbecd6e1e61df8aa7ec1dc50fe659" translate="yes" xml:space="preserve">
          <source>Create a non-reentrant lock. Recursive use will result in a deadlock. Each &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; must be matched with an &lt;a href=&quot;../parallel/index#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建一个不可重入的锁。递归使用将导致死锁。每个&lt;a href=&quot;../parallel/index#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;必须与一个&lt;a href=&quot;../parallel/index#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="f0f71c0a6b91caaf69c1ff056efc8f9f76af7879" translate="yes" xml:space="preserve">
          <source>Create a non-reentrant, test-and-test-and-set spin lock. Recursive use will result in a deadlock. This kind of lock should only be used around code that takes little time to execute and does not block (e.g. perform I/O). In general, &lt;a href=&quot;../parallel/index#Base.ReentrantLock&quot;&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;&lt;/a&gt; should be used instead.</source>
          <target state="translated">创建一个不可重入的，经过测试和设置的自旋锁。递归使用将导致死锁。这种锁只能在执行时间很少且不会阻塞（例如执行I / O）的代码周围使用。通常，应改用&lt;a href=&quot;../parallel/index#Base.ReentrantLock&quot;&gt; &lt;code&gt;ReentrantLock&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b7e10405fa9ae28a15fde6de2cc04f54c5e19a78" translate="yes" xml:space="preserve">
          <source>Create a pipe to which all C and Julia level &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; output will be redirected. Returns a tuple &lt;code&gt;(rd, wr)&lt;/code&gt; representing the pipe ends. Data written to &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; may now be read from the &lt;code&gt;rd&lt;/code&gt; end of the pipe. The &lt;code&gt;wr&lt;/code&gt; end is given for convenience in case the old &lt;a href=&quot;#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt; object was cached by the user and needs to be replaced elsewhere.</source>
          <target state="translated">创建一个管道，所有C和Julia级别的&lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;输出都将重定向到该管道。返回表示管道末端的元组 &lt;code&gt;(rd, wr)&lt;/code&gt; 。写入的数据&lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;现在可以从所读 &lt;code&gt;rd&lt;/code&gt; 管道的末端。的 &lt;code&gt;wr&lt;/code&gt; 端给出了方便的情况下，旧的&lt;a href=&quot;#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;对象已被用户缓存并需要被更换别处。</target>
        </trans-unit>
        <trans-unit id="d5609ae0d62a4b854bf2c4375ca4d215cbf7c0df" translate="yes" xml:space="preserve">
          <source>Create a pipeline from a data source to a destination. The source and destination can be commands, I/O streams, strings, or results of other &lt;code&gt;pipeline&lt;/code&gt; calls. At least one argument must be a command. Strings refer to filenames. When called with more than two arguments, they are chained together from left to right. For example, &lt;code&gt;pipeline(a,b,c)&lt;/code&gt; is equivalent to &lt;code&gt;pipeline(pipeline(a,b),c)&lt;/code&gt;. This provides a more concise way to specify multi-stage pipelines.</source>
          <target state="translated">创建从数据源到目标的管道。源和目标可以是命令，I / O流，字符串或其他 &lt;code&gt;pipeline&lt;/code&gt; 调用的结果。至少一个参数必须是命令。字符串是指文件名。当使用两个以上参数调用它们时，它们从左到右链接在一起。例如， &lt;code&gt;pipeline(a,b,c)&lt;/code&gt; 等同于 &lt;code&gt;pipeline(pipeline(a,b),c)&lt;/code&gt; 。这提供了一种更简洁的方法来指定多级管道。</target>
        </trans-unit>
        <trans-unit id="ab961019ed0d9e981963c118aa8d4bde8ecc5ebd" translate="yes" xml:space="preserve">
          <source>Create a random length &lt;code&gt;m&lt;/code&gt; sparse vector or &lt;code&gt;m&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; sparse matrix, in which the probability of any element being nonzero is independently given by &lt;code&gt;p&lt;/code&gt; (and hence the mean density of nonzeros is also exactly &lt;code&gt;p&lt;/code&gt;). Nonzero values are sampled from the distribution specified by &lt;code&gt;rfn&lt;/code&gt; and have the type &lt;code&gt;type&lt;/code&gt;. The uniform distribution is used in case &lt;code&gt;rfn&lt;/code&gt; is not specified. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;../random/index#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">创建一个随机长度的 &lt;code&gt;m&lt;/code&gt; 稀疏矢量或 &lt;code&gt;m&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; 稀疏矩阵，其中任意元素为非零的概率由 &lt;code&gt;p&lt;/code&gt; 独立给出（因此，非零的平均密度也正好为 &lt;code&gt;p&lt;/code&gt; ）。非零值是从 &lt;code&gt;rfn&lt;/code&gt; 指定的分布中采样的，类型 &lt;code&gt;type&lt;/code&gt; 。如果未指定 &lt;code&gt;rfn&lt;/code&gt; ,则使用均匀分布。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定一个随机数生成器，请参阅&lt;a href=&quot;../random/index#Random-Numbers&quot;&gt;随机数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="24adb62e84b71340c3f621decef5a321f7e84b6a" translate="yes" xml:space="preserve">
          <source>Create a random length &lt;code&gt;m&lt;/code&gt; sparse vector or &lt;code&gt;m&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; sparse matrix, in which the probability of any element being nonzero is independently given by &lt;code&gt;p&lt;/code&gt; (and hence the mean density of nonzeros is also exactly &lt;code&gt;p&lt;/code&gt;). Nonzero values are sampled from the distribution specified by &lt;code&gt;rfn&lt;/code&gt; and have the type &lt;code&gt;type&lt;/code&gt;. The uniform distribution is used in case &lt;code&gt;rfn&lt;/code&gt; is not specified. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">创建一个随机长度的 &lt;code&gt;m&lt;/code&gt; 稀疏矢量或 &lt;code&gt;m&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; 稀疏矩阵，其中任意元素为非零的概率由 &lt;code&gt;p&lt;/code&gt; 独立给出（因此，非零的平均密度也正好为 &lt;code&gt;p&lt;/code&gt; ）。非零值是从 &lt;code&gt;rfn&lt;/code&gt; 指定的分布中采样的，类型 &lt;code&gt;type&lt;/code&gt; 。如果未指定 &lt;code&gt;rfn&lt;/code&gt; ,则使用均匀分布。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定随机数生成器，请参阅&lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;随机数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="3770a87ac752a36ec36d9d03972bd765749af3ed" translate="yes" xml:space="preserve">
          <source>Create a random sparse vector of length &lt;code&gt;m&lt;/code&gt; or sparse matrix of size &lt;code&gt;m&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; with the specified (independent) probability &lt;code&gt;p&lt;/code&gt; of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;../random/index#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">创建长度为 &lt;code&gt;m&lt;/code&gt; 的随机稀疏向量或大小为 &lt;code&gt;m&lt;/code&gt; 乘 &lt;code&gt;n&lt;/code&gt; 的稀疏矩阵，使任何条目的指定（独立）概率 &lt;code&gt;p&lt;/code&gt; 为非零，其中从正态分布中采样非零值。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定一个随机数生成器，请参阅&lt;a href=&quot;../random/index#Random-Numbers&quot;&gt;随机数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="61e09af9437fe2c45b77d2e9ddd5c2a0aea13bdf" translate="yes" xml:space="preserve">
          <source>Create a random sparse vector of length &lt;code&gt;m&lt;/code&gt; or sparse matrix of size &lt;code&gt;m&lt;/code&gt; by &lt;code&gt;n&lt;/code&gt; with the specified (independent) probability &lt;code&gt;p&lt;/code&gt; of any entry being nonzero, where nonzero values are sampled from the normal distribution. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">创建一个长度为 &lt;code&gt;m&lt;/code&gt; 的随机稀疏向量或大小为 &lt;code&gt;m&lt;/code&gt; 乘 &lt;code&gt;n&lt;/code&gt; 的稀疏矩阵，使任何条目的指定（独立）概率 &lt;code&gt;p&lt;/code&gt; 为非零，其中从正态分布中采样非零值。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定随机数生成器，请参阅&lt;a href=&quot;../random/index#Random-Numbers-1&quot;&gt;随机数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f80f6c84937a0616b960c68c36a1821e1d127b5a" translate="yes" xml:space="preserve">
          <source>Create a random string of length &lt;code&gt;len&lt;/code&gt;, consisting of characters from &lt;code&gt;chars&lt;/code&gt;, which defaults to the set of upper- and lower-case letters and the digits 0-9. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">创建一个长度为 &lt;code&gt;len&lt;/code&gt; 的随机字符串，该字符串由 &lt;code&gt;chars&lt;/code&gt; 中的字符组成，默认为大小写字母和数字0-9的集合。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定一个随机数生成器，请参阅&lt;a href=&quot;#Random-Numbers&quot;&gt;随机数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c1a73a876cebbc3a0c143465473af20e5a925c98" translate="yes" xml:space="preserve">
          <source>Create a random string of length &lt;code&gt;len&lt;/code&gt;, consisting of characters from &lt;code&gt;chars&lt;/code&gt;, which defaults to the set of upper- and lower-case letters and the digits 0-9. The optional &lt;code&gt;rng&lt;/code&gt; argument specifies a random number generator, see &lt;a href=&quot;#Random-Numbers-1&quot;&gt;Random Numbers&lt;/a&gt;.</source>
          <target state="translated">创建一个长度为 &lt;code&gt;len&lt;/code&gt; 的随机字符串，该字符串由 &lt;code&gt;chars&lt;/code&gt; 中的字符组成，该字符串默认为大小写字母和数字0-9的集合。可选的 &lt;code&gt;rng&lt;/code&gt; 参数指定随机数生成器，请参阅&lt;a href=&quot;#Random-Numbers-1&quot;&gt;随机数&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="6ee28ecbd285880a7cd740fd7798c9c1727d428f" translate="yes" xml:space="preserve">
          <source>Create a raw string without interpolation and unescaping. The exception is that quotation marks still must be escaped. Backslashes escape both quotation marks and other backslashes, but only when a sequence of backslashes precedes a quote character. Thus, 2n backslashes followed by a quote encodes n backslashes and the end of the literal while 2n+1 backslashes followed by a quote encodes n backslashes followed by a quote character.</source>
          <target state="translated">创建一个原始字符串,不需要插值和取消转码。例外的是引号仍然必须被转义。反斜线既可以转义引号,也可以转义其他反斜线,但只有当反斜线序列在引号字符之前时,才可以转义。因此,引号后面的2n个反斜杠编码为n个反斜杠和文字的结尾,而引号后面的2n+1个反斜杠编码为n个引号字符后面的反斜杠。</target>
        </trans-unit>
        <trans-unit id="8da7a06794cadd72caef89925cfd7c17951f6bfa" translate="yes" xml:space="preserve">
          <source>Create a read-only &lt;code&gt;IOBuffer&lt;/code&gt; on the data underlying the given string.</source>
          <target state="translated">在基于给定字符串的数据上创建一个只读 &lt;code&gt;IOBuffer&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="19bb0229940b270a1479eaf9165f097e216ed768" translate="yes" xml:space="preserve">
          <source>Create a sampler that just wraps the given value &lt;code&gt;x&lt;/code&gt;. This is the default fall-back for values. The &lt;code&gt;eltype&lt;/code&gt; of this sampler is equal to &lt;code&gt;eltype(x)&lt;/code&gt;.</source>
          <target state="translated">创建一个仅包装给定值 &lt;code&gt;x&lt;/code&gt; 的采样器。这是值的默认后备。此采样器的 &lt;code&gt;eltype&lt;/code&gt; 等于 &lt;code&gt;eltype(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f9f224e016b84200f01ecc706676d9881b66d41f" translate="yes" xml:space="preserve">
          <source>Create a sampler that wraps the given value &lt;code&gt;x&lt;/code&gt; and the &lt;code&gt;data&lt;/code&gt;. The &lt;code&gt;eltype&lt;/code&gt; of this sampler is equal to &lt;code&gt;eltype(x)&lt;/code&gt;.</source>
          <target state="translated">创建一个包装给定值 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 的采样器。此采样器的 &lt;code&gt;eltype&lt;/code&gt; 等于 &lt;code&gt;eltype(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f83dbfbf518114552573b6e6abae3e4139b31cb9" translate="yes" xml:space="preserve">
          <source>Create a shallow copy of &lt;code&gt;x&lt;/code&gt;: the outer structure is copied, but not all internal values. For example, copying an array produces a new array with identically-same elements as the original.</source>
          <target state="translated">创建 &lt;code&gt;x&lt;/code&gt; 的浅表副本：复制外部结构，但不复制所有内部值。例如，复制数组会产生一个新数组，其元素与原始数组相同。</target>
        </trans-unit>
        <trans-unit id="9cb3be6cb095ffdb386198e5a53c66758791ab37" translate="yes" xml:space="preserve">
          <source>Create a sparse matrix &lt;code&gt;S&lt;/code&gt; of dimensions &lt;code&gt;m x n&lt;/code&gt; such that &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt;. The &lt;code&gt;combine&lt;/code&gt; function is used to combine duplicates. If &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are not specified, they are set to &lt;code&gt;maximum(I)&lt;/code&gt; and &lt;code&gt;maximum(J)&lt;/code&gt; respectively. If the &lt;code&gt;combine&lt;/code&gt; function is not supplied, &lt;code&gt;combine&lt;/code&gt; defaults to &lt;code&gt;+&lt;/code&gt; unless the elements of &lt;code&gt;V&lt;/code&gt; are Booleans in which case &lt;code&gt;combine&lt;/code&gt; defaults to &lt;code&gt;|&lt;/code&gt;. All elements of &lt;code&gt;I&lt;/code&gt; must satisfy &lt;code&gt;1 &amp;lt;= I[k] &amp;lt;= m&lt;/code&gt;, and all elements of &lt;code&gt;J&lt;/code&gt; must satisfy &lt;code&gt;1 &amp;lt;= J[k] &amp;lt;= n&lt;/code&gt;. Numerical zeros in (&lt;code&gt;I&lt;/code&gt;, &lt;code&gt;J&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;) are retained as structural nonzeros; to drop numerical zeros, use &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建一个尺寸为 &lt;code&gt;m x n&lt;/code&gt; 的稀疏矩阵 &lt;code&gt;S&lt;/code&gt; ，使得 &lt;code&gt;S[I[k], J[k]] = V[k]&lt;/code&gt; 。该 &lt;code&gt;combine&lt;/code&gt; 功能用于重复结合起来。如果未指定 &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; ，则将它们分别设置为 &lt;code&gt;maximum(I)&lt;/code&gt; 和 &lt;code&gt;maximum(J)&lt;/code&gt; 。如果 &lt;code&gt;combine&lt;/code&gt; 没有被提供的功能， &lt;code&gt;combine&lt;/code&gt; 默认为 &lt;code&gt;+&lt;/code&gt; 除非的元素 &lt;code&gt;V&lt;/code&gt; 是布尔值在这种情况下 &lt;code&gt;combine&lt;/code&gt; 默认为 &lt;code&gt;|&lt;/code&gt; 。 &lt;code&gt;I&lt;/code&gt; 的所有元素必须满足 &lt;code&gt;1 &amp;lt;= I[k] &amp;lt;= m&lt;/code&gt; ，并且I的所有元素 &lt;code&gt;J&lt;/code&gt; 必须满足 &lt;code&gt;1 &amp;lt;= J[k] &amp;lt;= n&lt;/code&gt; 。（ &lt;code&gt;I&lt;/code&gt; ， &lt;code&gt;J&lt;/code&gt; ， &lt;code&gt;V&lt;/code&gt; ）中的数字零保留为结构非零；要删除数字零，请使用&lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c5011b871e48d58f4cd3d39dc5cf861693b7b3f0" translate="yes" xml:space="preserve">
          <source>Create a sparse vector &lt;code&gt;S&lt;/code&gt; of length &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;S[I[k]] = V[k]&lt;/code&gt;. Duplicates are combined using the &lt;code&gt;combine&lt;/code&gt; function, which defaults to &lt;code&gt;+&lt;/code&gt; if no &lt;code&gt;combine&lt;/code&gt; argument is provided, unless the elements of &lt;code&gt;V&lt;/code&gt; are Booleans in which case &lt;code&gt;combine&lt;/code&gt; defaults to &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">创建长度为 &lt;code&gt;m&lt;/code&gt; 的稀疏向量 &lt;code&gt;S&lt;/code&gt; ，使 &lt;code&gt;S[I[k]] = V[k]&lt;/code&gt; 。重复项使用 &lt;code&gt;combine&lt;/code&gt; 函数进行合并，如果未提供 &lt;code&gt;combine&lt;/code&gt; 参数，则默认为 &lt;code&gt;+&lt;/code&gt; ，除非 &lt;code&gt;V&lt;/code&gt; 的元素为布尔值，在这种情况下， &lt;code&gt;combine&lt;/code&gt; 默认为 &lt;code&gt;|&lt;/code&gt; 。。</target>
        </trans-unit>
        <trans-unit id="5af6da27ae9944a05eb6bb91e99e94212274e3cb" translate="yes" xml:space="preserve">
          <source>Create a sparse vector of length &lt;code&gt;m&lt;/code&gt; or sparse matrix of size &lt;code&gt;m x n&lt;/code&gt;. This sparse array will not contain any nonzero values. No storage will be allocated for nonzero values during construction. The type defaults to &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; if not specified.</source>
          <target state="translated">创建长度为 &lt;code&gt;m&lt;/code&gt; 的稀疏向量或大小为 &lt;code&gt;m x n&lt;/code&gt; 稀疏矩阵。该稀疏数组将不包含任何非零值。在构造期间，不会为非零值分配存储空间。如果未指定，则类型默认为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="58a5aeb67ce63929f99f3293ccf57387db820ad0" translate="yes" xml:space="preserve">
          <source>Create a sparse vector of length &lt;code&gt;m&lt;/code&gt; where the nonzero indices are keys from the dictionary, and the nonzero values are the values from the dictionary.</source>
          <target state="translated">创建一个长度为 &lt;code&gt;m&lt;/code&gt; 的稀疏向量，其中非零索引是字典中的键，非零值是字典中的值。</target>
        </trans-unit>
        <trans-unit id="8f503d60ac5dd0352ae777a0e19093ba170f05ca" translate="yes" xml:space="preserve">
          <source>Create a string based upon the URL components provided. When the &lt;code&gt;scheme&lt;/code&gt; keyword is not provided the URL produced will use the alternative &lt;a href=&quot;https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a&quot;&gt;scp-like syntax&lt;/a&gt;.</source>
          <target state="translated">根据提供的URL组件创建一个字符串。如果未提供 &lt;code&gt;scheme&lt;/code&gt; 关键字，则生成的URL将使用其他&lt;a href=&quot;https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a&quot;&gt;类似scp的语法&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="aaa7fda98b7d8855e2b4e7e053b01d032e7a1841" translate="yes" xml:space="preserve">
          <source>Create a string from any value using the &lt;code&gt;show&lt;/code&gt; function. You should not add methods to &lt;code&gt;repr&lt;/code&gt;; define a &lt;code&gt;show&lt;/code&gt; method instead.</source>
          <target state="translated">使用 &lt;code&gt;show&lt;/code&gt; 函数从任何值创建一个字符串。您不应该为 &lt;code&gt;repr&lt;/code&gt; 添加方法；而是定义一个 &lt;code&gt;show&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="e66181553ea669848b336edb8190dd3795b76e53" translate="yes" xml:space="preserve">
          <source>Create a string from any values, except &lt;code&gt;nothing&lt;/code&gt;, using the &lt;a href=&quot;../io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">使用&lt;a href=&quot;../io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;函数从任何值创建字符串，除非 &lt;code&gt;nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e032c39f889cf31d16beb9d571f3e05c8c5832b5" translate="yes" xml:space="preserve">
          <source>Create a symlink from &lt;code&gt;~/.julia/compiled&lt;/code&gt; to a directory in a scratch space.</source>
          <target state="translated">创建从 &lt;code&gt;~/.julia/compiled&lt;/code&gt; 到暂存目录中的目录的符号链接。</target>
        </trans-unit>
        <trans-unit id="6b407e62c50b7579a1b48390737d3d9d521a089c" translate="yes" xml:space="preserve">
          <source>Create a temporary directory in the &lt;code&gt;parent&lt;/code&gt; directory with a name constructed from the given prefix and a random suffix, and return its path. Additionally, any trailing &lt;code&gt;X&lt;/code&gt; characters may be replaced with random characters. If &lt;code&gt;parent&lt;/code&gt; does not exist, throw an error.</source>
          <target state="translated">在 &lt;code&gt;parent&lt;/code&gt; 目录中创建一个临时目录，其名称由给定前缀和随机后缀构成，并返回其路径。此外，任何结尾的 &lt;code&gt;X&lt;/code&gt; 字符都可以替换为随机字符。如果 &lt;code&gt;parent&lt;/code&gt; 不存在，则抛出错误。</target>
        </trans-unit>
        <trans-unit id="1160dbc1e96a164b7ce4fa9acf2aa50398bea6c6" translate="yes" xml:space="preserve">
          <source>Create a temporary directory in the &lt;code&gt;parent&lt;/code&gt; directory with a name constructed from the given prefix and a random suffix, and return its path. Additionally, any trailing &lt;code&gt;X&lt;/code&gt; characters may be replaced with random characters. If &lt;code&gt;parent&lt;/code&gt; does not exist, throw an error. The &lt;code&gt;cleanup&lt;/code&gt; option controls whether the temporary directory is automatically deleted when the process exits.</source>
          <target state="translated">在 &lt;code&gt;parent&lt;/code&gt; 目录中创建一个临时目录，其名称由给定的前缀和一个随机后缀构成，并返回其路径。此外，任何结尾的 &lt;code&gt;X&lt;/code&gt; 字符都可以替换为随机字符。如果 &lt;code&gt;parent&lt;/code&gt; 不存在，则抛出错误。在 &lt;code&gt;cleanup&lt;/code&gt; 选项控制是否临时目录会自动删除该进程退出时。</target>
        </trans-unit>
        <trans-unit id="74d681100427f7076ed67273bc216adc2864cfb4" translate="yes" xml:space="preserve">
          <source>Create a timer that wakes up tasks waiting for it (by calling &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the timer object) and calls the function &lt;code&gt;callback&lt;/code&gt;.</source>
          <target state="translated">创建一个计时器来唤醒等待它的任务（通过在计时器对象上调用&lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;）并调用函数 &lt;code&gt;callback&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9b6c236b317e2feae409a047b5bb9690d7eaa0be" translate="yes" xml:space="preserve">
          <source>Create a timer that wakes up tasks waiting for it (by calling &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the timer object).</source>
          <target state="translated">创建一个计时器来唤醒等待它的任务（通过在计时器对象上调用&lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fe6838aa6e3e621f355c9b1295ab3768c3010eb0" translate="yes" xml:space="preserve">
          <source>Create a tuple of length &lt;code&gt;n&lt;/code&gt;, computing each element as &lt;code&gt;f(i)&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; is the index of the element.</source>
          <target state="translated">创建一个长度为 &lt;code&gt;n&lt;/code&gt; 的元组，将每个元素计算为 &lt;code&gt;f(i)&lt;/code&gt; ，其中 &lt;code&gt;i&lt;/code&gt; 是元素的索引。</target>
        </trans-unit>
        <trans-unit id="6c21b2eac39c09ea54cf9d183a22560ba8078519" translate="yes" xml:space="preserve">
          <source>Create all directories in the given &lt;code&gt;path&lt;/code&gt;, with permissions &lt;code&gt;mode&lt;/code&gt;. &lt;code&gt;mode&lt;/code&gt; defaults to &lt;code&gt;0o777&lt;/code&gt;, modified by the current file creation mask. Return &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">使用权限 &lt;code&gt;mode&lt;/code&gt; 在给定 &lt;code&gt;path&lt;/code&gt; 创建所有目录。 &lt;code&gt;mode&lt;/code&gt; 默认为 &lt;code&gt;0o777&lt;/code&gt; ，由当前文件创建掩码修改。返回 &lt;code&gt;path&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf162de3c9c9ee881cac0dcb3cd170c29ebef959" translate="yes" xml:space="preserve">
          <source>Create an &lt;a href=&quot;#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; object from an integer file descriptor. If &lt;code&gt;own&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, closing this object will close the underlying descriptor. By default, an &lt;code&gt;IOStream&lt;/code&gt; is closed when it is garbage collected. &lt;code&gt;name&lt;/code&gt; allows you to associate the descriptor with a named file.</source>
          <target state="translated">从整数文件描述符创建&lt;a href=&quot;#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt;对象。如果 &lt;code&gt;own&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则关闭此对象将关闭基础描述符。默认情况下， &lt;code&gt;IOStream&lt;/code&gt; 在被垃圾回收时关闭。 &lt;code&gt;name&lt;/code&gt; 允许您将描述符与命名文件关联。</target>
        </trans-unit>
        <trans-unit id="4d27efa244291014a3b2adaa305d7bd4d5b64350" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Array&lt;/code&gt; whose values are linked to a file, using memory-mapping. This provides a convenient way of working with data too large to fit in the computer's memory.</source>
          <target state="translated">使用内存映射创建一个其值链接到文件的 &lt;code&gt;Array&lt;/code&gt; 。这为处理太大而无法放入计算机内存的数据提供了一种便捷的方法。</target>
        </trans-unit>
        <trans-unit id="b8bb86166b97c93700925b2b59c6f26d354e7671" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Array&lt;/code&gt;, with element type &lt;code&gt;T&lt;/code&gt;, of all ones with size specified by &lt;code&gt;dims&lt;/code&gt;. See also: &lt;a href=&quot;#Base.fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建一个 &lt;code&gt;Array&lt;/code&gt; ，其元素类型为 &lt;code&gt;T&lt;/code&gt; ，所有元素的大小均由 &lt;code&gt;dims&lt;/code&gt; 指定。另请参见：&lt;a href=&quot;#Base.fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#Base.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c843cf6b2431abf5229a8828a3d5be9c5597803a" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Array&lt;/code&gt;, with element type &lt;code&gt;T&lt;/code&gt;, of all zeros with size specified by &lt;code&gt;dims&lt;/code&gt;. See also &lt;a href=&quot;#Base.fill&quot;&gt;&lt;code&gt;fill&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.ones&quot;&gt;&lt;code&gt;ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建一个元素类型为 &lt;code&gt;T&lt;/code&gt; 的全零 &lt;code&gt;Array&lt;/code&gt; ，其大小由 &lt;code&gt;dims&lt;/code&gt; 指定。又见&lt;a href=&quot;#Base.fill&quot;&gt; &lt;code&gt;fill&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#Base.ones&quot;&gt; &lt;code&gt;ones&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b6e18437c6870b3441a198a29488dbaad1e36b6c" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;Enum{BaseType}&lt;/code&gt; subtype with name &lt;code&gt;EnumName&lt;/code&gt; and enum member values of &lt;code&gt;value1&lt;/code&gt; and &lt;code&gt;value2&lt;/code&gt; with optional assigned values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, respectively. &lt;code&gt;EnumName&lt;/code&gt; can be used just like other types and enum member values as regular values, such as</source>
          <target state="translated">创建一个名称为 &lt;code&gt;EnumName&lt;/code&gt; 的 &lt;code&gt;Enum{BaseType}&lt;/code&gt; 子类型，并分别使用值 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的可选分配值分别枚举 &lt;code&gt;value1&lt;/code&gt; 和 &lt;code&gt;value2&lt;/code&gt; 的枚举成员值。 &lt;code&gt;EnumName&lt;/code&gt; 可以像其他类型一样使用，并将枚举成员值用作常规值，例如</target>
        </trans-unit>
        <trans-unit id="1988e010ef2dfb8cfcde7da8bec73bf1cf0c049c" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;HTML&lt;/code&gt; object from a literal string.</source>
          <target state="translated">从文字字符串创建 &lt;code&gt;HTML&lt;/code&gt; 对象。</target>
        </trans-unit>
        <trans-unit id="b7f0dc80f42f1aad71a14562fb4f32c0b79e2ba4" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;IO&lt;/code&gt;-like object for creating zeroed-out mmapped-memory that is not tied to a file for use in &lt;a href=&quot;#Mmap.mmap&quot;&gt;&lt;code&gt;Mmap.mmap&lt;/code&gt;&lt;/a&gt;. Used by &lt;code&gt;SharedArray&lt;/code&gt; for creating shared memory arrays.</source>
          <target state="translated">创建一个类似 &lt;code&gt;IO&lt;/code&gt; 的对象，以创建未绑定到&lt;a href=&quot;#Mmap.mmap&quot;&gt; &lt;code&gt;Mmap.mmap&lt;/code&gt; 中&lt;/a&gt;使用的文件的归零mmapped内存。由 &lt;code&gt;SharedArray&lt;/code&gt; 用于创建共享内存阵列。</target>
        </trans-unit>
        <trans-unit id="d4050068afe0146f56219f374e0ff6e6eb7e3429" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;IOContext&lt;/code&gt; that wraps a given stream, adding the specified &lt;code&gt;key=&amp;gt;value&lt;/code&gt; pairs to the properties of that stream (note that &lt;code&gt;io&lt;/code&gt; can itself be an &lt;code&gt;IOContext&lt;/code&gt;).</source>
          <target state="translated">创建一个包装给定流的 &lt;code&gt;IOContext&lt;/code&gt; ，将指定的 &lt;code&gt;key=&amp;gt;value&lt;/code&gt; 对添加到该流的属性中（请注意 &lt;code&gt;io&lt;/code&gt; 本身可以是 &lt;code&gt;IOContext&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="c37df1886c75da4684010c132d283b587ed7e2fa" translate="yes" xml:space="preserve">
          <source>Create an &lt;code&gt;IOContext&lt;/code&gt; that wraps an alternate &lt;code&gt;IO&lt;/code&gt; but inherits the properties of &lt;code&gt;context&lt;/code&gt;.</source>
          <target state="translated">创建一个 &lt;code&gt;IOContext&lt;/code&gt; ，它包装一个备用 &lt;code&gt;IO&lt;/code&gt; ,但继承 &lt;code&gt;context&lt;/code&gt; 的属性。</target>
        </trans-unit>
        <trans-unit id="895f46bbf3cda62374e24ffe50376b92dadf2c8f" translate="yes" xml:space="preserve">
          <source>Create an anonymous function and pass it as the first argument to a function call. For example:</source>
          <target state="translated">创建一个匿名函数,并将其作为函数调用的第一个参数。例如:</target>
        </trans-unit>
        <trans-unit id="182df2225052f7994222327e4b5a296aa23d4ff3" translate="yes" xml:space="preserve">
          <source>Create an arbitrary precision floating point number from &lt;code&gt;x&lt;/code&gt;, with precision &lt;code&gt;precision&lt;/code&gt;. The &lt;code&gt;rounding&lt;/code&gt; argument specifies the direction in which the result should be rounded if the conversion cannot be done exactly. If not provided, these are set by the current global values.</source>
          <target state="translated">从 &lt;code&gt;x&lt;/code&gt; 创建任意精度的浮点数， &lt;code&gt;precision&lt;/code&gt; 。所述 &lt;code&gt;rounding&lt;/code&gt; 参数指定，其中，如果在转换不能精确完成的结果应该被舍入的方向。如果未提供，则由当前全局值设置。</target>
        </trans-unit>
        <trans-unit id="171f32afa59f09b1061417cecc3c2a183be4d108" translate="yes" xml:space="preserve">
          <source>Create an arbitrary precision integer. &lt;code&gt;x&lt;/code&gt; may be an &lt;code&gt;Int&lt;/code&gt; (or anything that can be converted to an &lt;code&gt;Int&lt;/code&gt;). The usual mathematical operators are defined for this type, and results are promoted to a &lt;a href=&quot;#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建一个任意精度的整数。 &lt;code&gt;x&lt;/code&gt; 可以是 &lt;code&gt;Int&lt;/code&gt; （或可以转换为 &lt;code&gt;Int&lt;/code&gt; 的任何东西）。为此类型定义了常用的数学运算符，并将结果提升为&lt;a href=&quot;#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dfce70679587984abb0464685e1cceade3a5bbd1" translate="yes" xml:space="preserve">
          <source>Create an array filled with the value &lt;code&gt;x&lt;/code&gt;. For example, &lt;code&gt;fill(1.0, (5,5))&lt;/code&gt; returns a 5&amp;times;5 array of floats, with each element initialized to &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">创建一个填充值 &lt;code&gt;x&lt;/code&gt; 的数组。例如， &lt;code&gt;fill(1.0, (5,5))&lt;/code&gt; 返回一个5&amp;times;5的float数组，每个元素都初始化为 &lt;code&gt;1.0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="efff1664d300afbe16f9f536bbbebcb903f65216" translate="yes" xml:space="preserve">
          <source>Create an edge-triggered event source that tasks can wait for. Tasks that call &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Condition&lt;/code&gt; are suspended and queued. Tasks are woken up when &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; is later called on the &lt;code&gt;Condition&lt;/code&gt;. Edge triggering means that only tasks waiting at the time &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The &lt;a href=&quot;#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.Event&quot;&gt;&lt;code&gt;Threads.Event&lt;/code&gt;&lt;/a&gt; types do this, and can be used for level-triggered events.</source>
          <target state="translated">创建一个边缘触发的事件源，任务可以等待。任务是呼叫&lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;上一个 &lt;code&gt;Condition&lt;/code&gt; 被挂起，将排队。稍后在 &lt;code&gt;Condition&lt;/code&gt; 上调用&lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt;时，将唤醒任务。边缘触发意味着只能唤醒在调用&lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; 时&lt;/a&gt;等待的任务。对于级别触发的通知，您必须保留额外的状态以跟踪通知是否发生。该&lt;a href=&quot;#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Base.Event&quot;&gt; &lt;code&gt;Threads.Event&lt;/code&gt; &lt;/a&gt;类型做到这一点，可用于电平触发事件。</target>
        </trans-unit>
        <trans-unit id="73332ad1149d51e06da63f19c60ae5d380d61978" translate="yes" xml:space="preserve">
          <source>Create an edge-triggered event source that tasks can wait for. Tasks that call &lt;a href=&quot;#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;code&gt;Condition&lt;/code&gt; are suspended and queued. Tasks are woken up when &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; is later called on the &lt;code&gt;Condition&lt;/code&gt;. Edge triggering means that only tasks waiting at the time &lt;a href=&quot;#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; is called can be woken up. For level-triggered notifications, you must keep extra state to keep track of whether a notification has happened. The &lt;a href=&quot;#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../multi-threading/index#Base.Event&quot;&gt;&lt;code&gt;Threads.Event&lt;/code&gt;&lt;/a&gt; types do this, and can be used for level-triggered events.</source>
          <target state="translated">创建一个边缘触发的事件源，任务可以等待。任务是呼叫&lt;a href=&quot;#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;上一个 &lt;code&gt;Condition&lt;/code&gt; 被挂起，将排队。稍后在 &lt;code&gt;Condition&lt;/code&gt; 上调用&lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt;时，将唤醒任务。边缘触发意味着只能唤醒在调用&lt;a href=&quot;#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; 时&lt;/a&gt;等待的任务。对于级别触发的通知，您必须保留额外的状态以跟踪通知是否发生。该&lt;a href=&quot;#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../multi-threading/index#Base.Event&quot;&gt; &lt;code&gt;Threads.Event&lt;/code&gt; &lt;/a&gt;类型做到这一点，可用于电平触发事件。</target>
        </trans-unit>
        <trans-unit id="520078b92dd7a16aee09f78e8b0db867f75cb94e" translate="yes" xml:space="preserve">
          <source>Create an immutable byte (&lt;code&gt;UInt8&lt;/code&gt;) vector using string syntax.</source>
          <target state="translated">使用字符串语法创建不可变字节（ &lt;code&gt;UInt8&lt;/code&gt; ）向量。</target>
        </trans-unit>
        <trans-unit id="da84c283b9346ebc02fd11c8e5c614ee585502d6" translate="yes" xml:space="preserve">
          <source>Create an in-memory I/O stream, which may optionally operate on a pre-existing array.</source>
          <target state="translated">创建一个内存中的I/O流,它可以选择在一个预先存在的数组上操作。</target>
        </trans-unit>
        <trans-unit id="cb24bf3cac592f5cbadebc13dc99bd00232cae06" translate="yes" xml:space="preserve">
          <source>Create an initialized &lt;code&gt;MersenneTwister&lt;/code&gt; object, whose state is moved forward (without generating numbers) from &lt;code&gt;r&lt;/code&gt; by &lt;code&gt;steps&lt;/code&gt; steps. One such step corresponds to the generation of two &lt;code&gt;Float64&lt;/code&gt; numbers. For each different value of &lt;code&gt;steps&lt;/code&gt;, a large polynomial has to be generated internally. One is already pre-computed for &lt;code&gt;steps=big(10)^20&lt;/code&gt;.</source>
          <target state="translated">创建初始化 &lt;code&gt;MersenneTwister&lt;/code&gt; 对象，其状态从向前移动（无生成数字） &lt;code&gt;r&lt;/code&gt; 由 &lt;code&gt;steps&lt;/code&gt; 的步骤。其中一个步骤对应于生成两个 &lt;code&gt;Float64&lt;/code&gt; 数字。对于每个不同的 &lt;code&gt;steps&lt;/code&gt; 值，必须在内部生成一个较大的多项式。已经为 &lt;code&gt;steps=big(10)^20&lt;/code&gt; 预先计算了一个。</target>
        </trans-unit>
        <trans-unit id="0ea93e0af90bf05567f22a1eb39a67d625d70a2a" translate="yes" xml:space="preserve">
          <source>Create an iterable &lt;code&gt;EachLine&lt;/code&gt; object that will yield each line from an I/O stream or a file. Iteration calls &lt;a href=&quot;#Base.readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; on the stream argument repeatedly with &lt;code&gt;keep&lt;/code&gt; passed through, determining whether trailing end-of-line characters are retained. When called with a file name, the file is opened once at the beginning of iteration and closed at the end. If iteration is interrupted, the file will be closed when the &lt;code&gt;EachLine&lt;/code&gt; object is garbage collected.</source>
          <target state="translated">创建一个可迭代的 &lt;code&gt;EachLine&lt;/code&gt; 对象，该对象将从I / O流或文件中产生每一行。迭代在 &lt;code&gt;keep&lt;/code&gt; 通过的情况下反复调用stream参数上的&lt;a href=&quot;#Base.readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt;，以确定是否保留行尾字符。当使用文件名调用时，文件在迭代开始时打开一次，并在结束时关闭。如果迭代被中断，则在对 &lt;code&gt;EachLine&lt;/code&gt; 对象进行垃圾回收时将关闭文件。</target>
        </trans-unit>
        <trans-unit id="ef0e28d10352752c6450ce2dfc986b9c25b31c66" translate="yes" xml:space="preserve">
          <source>Create an iterable object for visiting each index of an &lt;code&gt;AbstractArray&lt;/code&gt;&lt;code&gt;A&lt;/code&gt; in an efficient manner. For array types that have opted into fast linear indexing (like &lt;code&gt;Array&lt;/code&gt;), this is simply the range &lt;code&gt;1:length(A)&lt;/code&gt;. For other array types, return a specialized Cartesian range to efficiently index into the array with indices specified for every dimension. For other iterables, including strings and dictionaries, return an iterator object supporting arbitrary index types (e.g. unevenly spaced or non-integer indices).</source>
          <target state="translated">创建一个可迭代的对象，以有效的方式访问 &lt;code&gt;AbstractArray&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; 的每个索引。对于选择了快速线性索引的数组类型（如 &lt;code&gt;Array&lt;/code&gt; ），这只是范围 &lt;code&gt;1:length(A)&lt;/code&gt; 。对于其他数组类型，返回专门的笛卡尔范围，以为每个维度指定的索引有效地索引到数组中。对于其他可迭代变量（包括字符串和字典），返回支持任意索引类型（例如不均匀间隔或非整数索引）的迭代器对象。</target>
        </trans-unit>
        <trans-unit id="37a114db40a5b561df4c6998b980d11f164be66f" translate="yes" xml:space="preserve">
          <source>Create an uninitialized mutable array analogous to that specified by &lt;code&gt;storagetype&lt;/code&gt;, but with &lt;code&gt;axes&lt;/code&gt; specified by the last argument. &lt;code&gt;storagetype&lt;/code&gt; might be a type or a function.</source>
          <target state="translated">创建一个类似于 &lt;code&gt;storagetype&lt;/code&gt; 指定的未初始化的可变数组，但使用最后一个参数指定的 &lt;code&gt;axes&lt;/code&gt; 。 &lt;code&gt;storagetype&lt;/code&gt; 可以是类型或函数。</target>
        </trans-unit>
        <trans-unit id="9d8ea45663459513f743906566fff438525d9ff0" translate="yes" xml:space="preserve">
          <source>Create an uninitialized mutable array with the given element type and size, based upon the given source array. The second and third arguments are both optional, defaulting to the given array's &lt;code&gt;eltype&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. The dimensions may be specified either as a single tuple argument or as a series of integer arguments.</source>
          <target state="translated">根据给定的源数组，使用给定的元素类型和大小创建未初始化的可变数组。第二个和第三个参数都是可选的，默认为给定数组的 &lt;code&gt;eltype&lt;/code&gt; 和 &lt;code&gt;size&lt;/code&gt; 。可以将维指定为单个元组参数或一系列整数参数。</target>
        </trans-unit>
        <trans-unit id="79911f08e573f962982b247d6e1b479293a78b80" translate="yes" xml:space="preserve">
          <source>Create and listen on a named pipe / UNIX domain socket.</source>
          <target state="translated">在命名管道/UNIX域套接字上创建和监听。</target>
        </trans-unit>
        <trans-unit id="b3e62302ce3bda257e6680d1de93fd94d29afc80" translate="yes" xml:space="preserve">
          <source>Create and run a &lt;a href=&quot;../parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; on any available thread. To wait for the task to finish, call &lt;a href=&quot;../parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on the result of this macro, or call &lt;code&gt;fetch&lt;/code&gt; to wait and then obtain its return value.</source>
          <target state="translated">在任何可用线程上创建并运行&lt;a href=&quot;../parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;。要等待任务完成，请对该宏的结果调用&lt;a href=&quot;../parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;，或者调用 &lt;code&gt;fetch&lt;/code&gt; 进行等待，然后获取其返回值。</target>
        </trans-unit>
        <trans-unit id="1b543386b4baf8de98d8473a008082cdc29f6cba" translate="yes" xml:space="preserve">
          <source>Create references to remote channels of a specific size and type. &lt;code&gt;f&lt;/code&gt; is a function that when executed on &lt;code&gt;pid&lt;/code&gt; must return an implementation of an &lt;code&gt;AbstractChannel&lt;/code&gt;.</source>
          <target state="translated">创建对特定大小和类型的远程通道的引用。 &lt;code&gt;f&lt;/code&gt; 是在 &lt;code&gt;pid&lt;/code&gt; 上执行时必须返回 &lt;code&gt;AbstractChannel&lt;/code&gt; 的实现的函数。</target>
        </trans-unit>
        <trans-unit id="946b30e9c53338d66c71fd7a6dcea51240337a53" translate="yes" xml:space="preserve">
          <source>Creates a &lt;code&gt;SubArray&lt;/code&gt; from an indexing expression. This can only be applied directly to a reference expression (e.g. &lt;code&gt;@view A[1,2:end]&lt;/code&gt;), and should &lt;em&gt;not&lt;/em&gt; be used as the target of an assignment (e.g. &lt;code&gt;@view(A[1,2:end]) = ...&lt;/code&gt;). See also &lt;a href=&quot;#Base.@views&quot;&gt;&lt;code&gt;@views&lt;/code&gt;&lt;/a&gt; to switch an entire block of code to use views for slicing.</source>
          <target state="translated">从索引表达式创建一个 &lt;code&gt;SubArray&lt;/code&gt; 。这只能直接应用于引用表达式（例如 &lt;code&gt;@view A[1,2:end]&lt;/code&gt; ），而&lt;em&gt;不能&lt;/em&gt;用作分配的目标（例如 &lt;code&gt;@view(A[1,2:end]) = ...&lt;/code&gt; ）。另请参见&lt;a href=&quot;#Base.@views&quot;&gt; &lt;code&gt;@views&lt;/code&gt; &lt;/a&gt;切换整个代码块以使用视图进行切片。</target>
        </trans-unit>
        <trans-unit id="b7df04f96de18b903f8a03412ba0a608ddf39df4" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; matrix of zeros. (&lt;a href=&quot;#SparseArrays.spzeros&quot;&gt;&lt;code&gt;spzeros(m,n)&lt;/code&gt;&lt;/a&gt; is empty.)</source>
          <target state="translated">创建一个零的&lt;em&gt;m&lt;/em&gt; &amp;times; &lt;em&gt;n&lt;/em&gt;矩阵。（&lt;a href=&quot;#SparseArrays.spzeros&quot;&gt; &lt;code&gt;spzeros(m,n)&lt;/code&gt; &lt;/a&gt;为空。）</target>
        </trans-unit>
        <trans-unit id="89e81042f6427ed532f001aa21eed74e1277eedc" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements distributed according to the &lt;em&gt;X&lt;/em&gt; distribution. (Requires the &lt;code&gt;Distributions&lt;/code&gt; package.)</source>
          <target state="translated">创建一个&lt;em&gt;m&lt;/em&gt; &amp;times; &lt;em&gt;n&lt;/em&gt;随机矩阵（密度为&lt;em&gt;d&lt;/em&gt;），其中iid非零元素根据&lt;em&gt;X&lt;/em&gt;分布分布。（需要 &lt;code&gt;Distributions&lt;/code&gt; 包。）</target>
        </trans-unit>
        <trans-unit id="5dcdc6aa977d12b3464dea6213b384f8502692b5" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements distributed according to the standard normal (Gaussian) distribution.</source>
          <target state="translated">创建一个&lt;em&gt;m&lt;/em&gt; &amp;times; &lt;em&gt;n&lt;/em&gt;随机矩阵（密度为&lt;em&gt;d&lt;/em&gt;），其中iid非零元素根据标准正态（高斯）分布进行分布。</target>
        </trans-unit>
        <trans-unit id="f8b69c62af1974d81f87c4f3b0ecd8ee59170f8d" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements distributed uniformly on the half-open interval $[0, 1)$.</source>
          <target state="translated">创建一个&lt;em&gt;m&lt;/em&gt; &amp;times; &lt;em&gt;n的&lt;/em&gt;随机矩阵（密度为&lt;em&gt;d&lt;/em&gt;），其中iid非零元素均匀分布在半开区间$ [0，1）$上。</target>
        </trans-unit>
        <trans-unit id="1e3f3a174293168e940c3aa7395700341e6b3d68" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;m&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; random matrix (of density &lt;em&gt;d&lt;/em&gt;) with iid non-zero elements generated with the &lt;code&gt;rng&lt;/code&gt; random number generator</source>
          <target state="translated">创建一个&lt;em&gt;m&lt;/em&gt; &amp;times; &lt;em&gt;n的&lt;/em&gt;随机矩阵（密度为&lt;em&gt;d&lt;/em&gt;），该矩阵具有由 &lt;code&gt;rng&lt;/code&gt; 随机数生成器生成的iid非零元素</target>
        </trans-unit>
        <trans-unit id="14a84275cae03e282157d756507c417c693cca8f" translate="yes" xml:space="preserve">
          <source>Creates a &lt;em&gt;n&lt;/em&gt;-by-&lt;em&gt;n&lt;/em&gt; identity matrix.</source>
          <target state="translated">创建一个&lt;em&gt;n&lt;/em&gt; &amp;times; &lt;em&gt;n的&lt;/em&gt;单位矩阵。</target>
        </trans-unit>
        <trans-unit id="7f97f983311aae9228c52a6abb46e64693cf2246" translate="yes" xml:space="preserve">
          <source>Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in &lt;code&gt;DEPOT_PATH[1]/compiled&lt;/code&gt;. See &lt;a href=&quot;../../manual/modules/index#Module-initialization-and-precompilation&quot;&gt;Module initialization and precompilation&lt;/a&gt; for important notes.</source>
          <target state="translated">为模块及其所有依赖项创建预编译的缓存文件。这可以用来减少包装的装载时间。缓存文件存储在 &lt;code&gt;DEPOT_PATH[1]/compiled&lt;/code&gt; 。有关重要说明，请参见&lt;a href=&quot;../../manual/modules/index#Module-initialization-and-precompilation&quot;&gt;模块初始化和预编译&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d1606830bc807d0705cb0cd68427ce107b28412" translate="yes" xml:space="preserve">
          <source>Creates a precompiled cache file for a module and all of its dependencies. This can be used to reduce package load times. Cache files are stored in &lt;code&gt;DEPOT_PATH[1]/compiled&lt;/code&gt;. See &lt;a href=&quot;../../manual/modules/index#Module-initialization-and-precompilation-1&quot;&gt;Module initialization and precompilation&lt;/a&gt; for important notes.</source>
          <target state="translated">为模块及其所有依赖项创建预编译的缓存文件。这可用于减少包装加载时间。缓存文件存储在 &lt;code&gt;DEPOT_PATH[1]/compiled&lt;/code&gt; 。有关重要说明，请参见&lt;a href=&quot;../../manual/modules/index#Module-initialization-and-precompilation-1&quot;&gt;模块初始化和预编译&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="cb9535802e7b206a931b1bd5dd7001d10e59c1c3" translate="yes" xml:space="preserve">
          <source>Creates a re-entrant lock for synchronizing &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;s. The same task can acquire the lock as many times as required. Each &lt;a href=&quot;#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; must be matched with an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建用于同步&lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;的重入锁。同一任务可以根据需要多次获取锁定。每个&lt;a href=&quot;#Base.lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt;必须与一个&lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="acabfae1e2f1fc10302e24c287378e2416376616" translate="yes" xml:space="preserve">
          <source>Creates a symbolic link to &lt;code&gt;target&lt;/code&gt; with the name &lt;code&gt;link&lt;/code&gt;.</source>
          <target state="translated">创建一个符号链接，以名称 &lt;code&gt;link&lt;/code&gt; 为 &lt;code&gt;target&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a73f7647123bfc2728187c9560131d8d50116f46" translate="yes" xml:space="preserve">
          <source>Creating C-Compatible Julia Function Pointers</source>
          <target state="translated">创建与C兼容的Julia函数指针</target>
        </trans-unit>
        <trans-unit id="3383e56fce9b7a3ece327ee47bf1ef8a6d2cba06" translate="yes" xml:space="preserve">
          <source>Creating Custom &lt;code&gt;AbstractTestSet&lt;/code&gt; Types</source>
          <target state="translated">创建自定义 &lt;code&gt;AbstractTestSet&lt;/code&gt; 类型</target>
        </trans-unit>
        <trans-unit id="7cd4ab56a79487eec69d5f21bd101f982fbcd5a4" translate="yes" xml:space="preserve">
          <source>Creating a DateFormat object is expensive. Whenever possible, create it once and use it many times or try the &lt;code&gt;dateformat&quot;&quot;&lt;/code&gt; string macro. Using this macro creates the DateFormat object once at macro expansion time and reuses it later. see &lt;a href=&quot;#Dates.@dateformat_str&quot;&gt;&lt;code&gt;@dateformat_str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">创建DateFormat对象非常昂贵。只要有可能，就创建一次并使用多次，或者尝试使用 &lt;code&gt;dateformat&quot;&quot;&lt;/code&gt; 字符串宏。使用此宏可以在宏扩展时创建一次DateFormat对象，并在以后重用。参见&lt;a href=&quot;#Dates.@dateformat_str&quot;&gt; &lt;code&gt;@dateformat_str&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ee7646078f40a52ecc8cd5d5abbf897cedcf3493" translate="yes" xml:space="preserve">
          <source>Creating accidental &quot;copies&quot; of global state from another module, by referencing it directly instead of via its lookup path. For example, (in global scope):</source>
          <target state="translated">通过直接引用而不是通过其查找路径来创建来自另一个模块的全局状态的意外 &quot;副本&quot;。例如,(在全局范围内):</target>
        </trans-unit>
        <trans-unit id="be1f31994e9b5f386872c25814ba699f9d95f309" translate="yes" xml:space="preserve">
          <source>Creating events</source>
          <target state="translated">创建事件</target>
        </trans-unit>
        <trans-unit id="dfc1e3935e5f561b9a3fdb1b5f2655135605e4b0" translate="yes" xml:space="preserve">
          <source>Creating new generators</source>
          <target state="translated">创建新的生成器</target>
        </trans-unit>
        <trans-unit id="6051151a12d03a26f4a70b65c2b0ad21b81b82d7" translate="yes" xml:space="preserve">
          <source>Creation of a &lt;code&gt;Ref&lt;/code&gt; to a value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; is usually written &lt;code&gt;Ref(x)&lt;/code&gt;. Additionally, for creating interior pointers to containers (such as Array or Ptr), it can be written &lt;code&gt;Ref(a, i)&lt;/code&gt; for creating a reference to the &lt;code&gt;i&lt;/code&gt;-th element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">通常将类型为 &lt;code&gt;T&lt;/code&gt; 的值 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;Ref&lt;/code&gt; 创建为 &lt;code&gt;Ref(x)&lt;/code&gt; 。此外，用于创建内部指针到容器（如Array或PTR），它可以被写入 &lt;code&gt;Ref(a, i)&lt;/code&gt; ，用于创建到一个参考 &lt;code&gt;i&lt;/code&gt; 的第元件 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8dc5259164d5812ceebcb04307a85959962c480d" translate="yes" xml:space="preserve">
          <source>Credential authentication is done in the following order (if supported):</source>
          <target state="translated">凭证认证按以下顺序进行(如果支持):</target>
        </trans-unit>
        <trans-unit id="d2942a33f8d919c5d366f7a8dd1e21bb97daf1e5" translate="yes" xml:space="preserve">
          <source>Credential that support only &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; parameters</source>
          <target state="translated">仅支持 &lt;code&gt;user&lt;/code&gt; 和 &lt;code&gt;password&lt;/code&gt; 参数的凭据</target>
        </trans-unit>
        <trans-unit id="69ed5aaf168648107a82ebf81dcad59625ab3893" translate="yes" xml:space="preserve">
          <source>Credit Card</source>
          <target state="translated">信用卡</target>
        </trans-unit>
        <trans-unit id="746fdeaa0f4b76ffba7f25f558ab182a154045eb" translate="yes" xml:space="preserve">
          <source>Crescent Moon</source>
          <target state="translated">新月</target>
        </trans-unit>
        <trans-unit id="9550e2815afbb248fddb5160d9632f01d171be80" translate="yes" xml:space="preserve">
          <source>Crocodile</source>
          <target state="translated">Crocodile</target>
        </trans-unit>
        <trans-unit id="1b84d42ee29ecbd7da313dc3edd661620b90adac" translate="yes" xml:space="preserve">
          <source>Cross Mark</source>
          <target state="translated">十字标</target>
        </trans-unit>
        <trans-unit id="6439d5abed8064d49532208f798b24bad4eeaedb" translate="yes" xml:space="preserve">
          <source>Crossed Flags</source>
          <target state="translated">交叉的旗帜</target>
        </trans-unit>
        <trans-unit id="410494f2cf468cb98b4655657880ea42f72183c0" translate="yes" xml:space="preserve">
          <source>Crown</source>
          <target state="translated">Crown</target>
        </trans-unit>
        <trans-unit id="72f9cdf37b21797f93e24173fe1674094d502584" translate="yes" xml:space="preserve">
          <source>Crying Cat Face</source>
          <target state="translated">哭泣的猫脸</target>
        </trans-unit>
        <trans-unit id="aa2d3386215f67207e9681df8287caf675bf59f2" translate="yes" xml:space="preserve">
          <source>Crying Face</source>
          <target state="translated">哭泣的脸</target>
        </trans-unit>
        <trans-unit id="69723d1a814546ee7350009a712142c1bb170c13" translate="yes" xml:space="preserve">
          <source>Crystal Ball</source>
          <target state="translated">水晶球</target>
        </trans-unit>
        <trans-unit id="f6aabde44a92ffc82d2ba7b1190b078fefc14c2b" translate="yes" xml:space="preserve">
          <source>Cshort</source>
          <target state="translated">Cshort</target>
        </trans-unit>
        <trans-unit id="cad2cc015431eb8277af58253306038c83981e1b" translate="yes" xml:space="preserve">
          <source>Csize_t</source>
          <target state="translated">Csize_t</target>
        </trans-unit>
        <trans-unit id="4022d2757281621dd4126003c4abfb786032fbcf" translate="yes" xml:space="preserve">
          <source>Cssize_t</source>
          <target state="translated">Cssize_t</target>
        </trans-unit>
        <trans-unit id="dfe331758ccf94f376b9ef5ba3fc63195b90e80d" translate="yes" xml:space="preserve">
          <source>Cstring</source>
          <target state="translated">Cstring</target>
        </trans-unit>
        <trans-unit id="6b5a31718a4c0850b761d24de3b5aa88f92f5166" translate="yes" xml:space="preserve">
          <source>Cube Root</source>
          <target state="translated">立方根</target>
        </trans-unit>
        <trans-unit id="e17b700fe47780159b8cf1ee414cd605ea55478e" translate="yes" xml:space="preserve">
          <source>Cuchar</source>
          <target state="translated">Cuchar</target>
        </trans-unit>
        <trans-unit id="19b94831c1a53e707deeb78349f682ad817cafbc" translate="yes" xml:space="preserve">
          <source>Cuint</source>
          <target state="translated">Cuint</target>
        </trans-unit>
        <trans-unit id="bfaf7a56354eba13b1561f6000228821b55aedb8" translate="yes" xml:space="preserve">
          <source>Cuintmax_t</source>
          <target state="translated">Cuintmax_t</target>
        </trans-unit>
        <trans-unit id="91908ced92ffd6336c39db3012de651ae9fc627b" translate="yes" xml:space="preserve">
          <source>Culong</source>
          <target state="translated">Culong</target>
        </trans-unit>
        <trans-unit id="9163538589351903cc7d613710b25bb603d2126c" translate="yes" xml:space="preserve">
          <source>Culonglong</source>
          <target state="translated">Culonglong</target>
        </trans-unit>
        <trans-unit id="6d8929c0661d5c816e4bd42ef00122216903020f" translate="yes" xml:space="preserve">
          <source>Cumulative operation &lt;code&gt;op&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; (providing &lt;code&gt;dims&lt;/code&gt; is optional for vectors). An initial value &lt;code&gt;init&lt;/code&gt; may optionally be provided by a keyword argument. See also &lt;a href=&quot;#Base.accumulate!&quot;&gt;&lt;code&gt;accumulate!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow). For common operations there are specialized variants of &lt;code&gt;accumulate&lt;/code&gt;, see: &lt;a href=&quot;#Base.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#Base.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">沿 &lt;code&gt;A&lt;/code&gt; 的尺寸 &lt;code&gt;dims&lt;/code&gt; 度的累积运算 &lt;code&gt;op&lt;/code&gt; （提供矢量 &lt;code&gt;dims&lt;/code&gt; 是可选的）。初始值 &lt;code&gt;init&lt;/code&gt; 可以选择由关键字参数提供。另见&lt;a href=&quot;#Base.accumulate!&quot;&gt; &lt;code&gt;accumulate!&lt;/code&gt; &lt;/a&gt;使用预分配的输出数组，以提高性能并控制输出的精度（例如，避免溢出）。对于常见的操作还有专门的变种 &lt;code&gt;accumulate&lt;/code&gt; ，请参阅：&lt;a href=&quot;#Base.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#Base.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9c0cc6e2cab956c3eeff9bdbdc51bf164e4d2a3" translate="yes" xml:space="preserve">
          <source>Cumulative operation &lt;code&gt;op&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;, storing the result in &lt;code&gt;B&lt;/code&gt;. Providing &lt;code&gt;dims&lt;/code&gt; is optional for vectors. If the keyword argument &lt;code&gt;init&lt;/code&gt; is given, its value is used to instantiate the accumulation. See also &lt;a href=&quot;#Base.accumulate&quot;&gt;&lt;code&gt;accumulate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">累积运转 &lt;code&gt;op&lt;/code&gt; 上 &lt;code&gt;A&lt;/code&gt; 沿维 &lt;code&gt;dims&lt;/code&gt; ，将结果存储在 &lt;code&gt;B&lt;/code&gt; 。提供矢量 &lt;code&gt;dims&lt;/code&gt; 是可选的。如果给出了关键字参数 &lt;code&gt;init&lt;/code&gt; ，则将其值用于实例化累积。另请参见&lt;a href=&quot;#Base.accumulate&quot;&gt; &lt;code&gt;accumulate&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4cc6a3d14a831428f91a6d92cb0ac7ceb0d411e1" translate="yes" xml:space="preserve">
          <source>Cumulative product along the dimension &lt;code&gt;dim&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumprod!&quot;&gt;&lt;code&gt;cumprod!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">累积产品沿尺寸 &lt;code&gt;dim&lt;/code&gt; 。另请参阅&lt;a href=&quot;#Base.cumprod!&quot;&gt; &lt;code&gt;cumprod!&lt;/code&gt; &lt;/a&gt;使用预分配的输出数组，以提高性能并控制输出的精度（例如，避免溢出）。</target>
        </trans-unit>
        <trans-unit id="c7379162addda6658acdc3f9dd25f46656740bb5" translate="yes" xml:space="preserve">
          <source>Cumulative product of &lt;code&gt;A&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;, storing the result in &lt;code&gt;B&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 的累积积沿维度 &lt;code&gt;dims&lt;/code&gt; ，将结果存储在 &lt;code&gt;B&lt;/code&gt; 中。另请参阅&lt;a href=&quot;#Base.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="544dc176e0d81f953753079e21fc05f7a65a0a2b" translate="yes" xml:space="preserve">
          <source>Cumulative product of a vector &lt;code&gt;x&lt;/code&gt;, storing the result in &lt;code&gt;y&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">向量 &lt;code&gt;x&lt;/code&gt; 的累积积，将结果存储在 &lt;code&gt;y&lt;/code&gt; 中。另请参阅&lt;a href=&quot;#Base.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4a7848eb8353d1872494fd8d4b74c519af24ce82" translate="yes" xml:space="preserve">
          <source>Cumulative product of a vector. See also &lt;a href=&quot;#Base.cumprod!&quot;&gt;&lt;code&gt;cumprod!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">向量的累积乘积。另请参阅&lt;a href=&quot;#Base.cumprod!&quot;&gt; &lt;code&gt;cumprod!&lt;/code&gt; &lt;/a&gt;使用预分配的输出数组，以提高性能并控制输出的精度（例如，避免溢出）。</target>
        </trans-unit>
        <trans-unit id="4542c8440eaef546cac126acfab13b989fe9f95e" translate="yes" xml:space="preserve">
          <source>Cumulative product of an iterator. See also &lt;a href=&quot;#Base.cumprod!&quot;&gt;&lt;code&gt;cumprod!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">迭代器的累积积。另请参阅&lt;a href=&quot;#Base.cumprod!&quot;&gt; &lt;code&gt;cumprod!&lt;/code&gt; &lt;/a&gt;使用预分配的输出数组，以提高性能并控制输出的精度（例如，避免溢出）。</target>
        </trans-unit>
        <trans-unit id="5e5d34284af8b1cd8280022818b948ecd056e9f9" translate="yes" xml:space="preserve">
          <source>Cumulative sum a vector. See also &lt;a href=&quot;#Base.cumsum!&quot;&gt;&lt;code&gt;cumsum!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">累积和向量。另请参见&lt;a href=&quot;#Base.cumsum!&quot;&gt; &lt;code&gt;cumsum!&lt;/code&gt; &lt;/a&gt;使用预分配的输出数组，以提高性能并控制输出的精度（例如，避免溢出）。</target>
        </trans-unit>
        <trans-unit id="7ac42a41a170524b37f027a79ba758b538544698" translate="yes" xml:space="preserve">
          <source>Cumulative sum along the dimension &lt;code&gt;dims&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumsum!&quot;&gt;&lt;code&gt;cumsum!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">沿维度的累计总和 &lt;code&gt;dims&lt;/code&gt; 。另请参见&lt;a href=&quot;#Base.cumsum!&quot;&gt; &lt;code&gt;cumsum!&lt;/code&gt; &lt;/a&gt;使用预分配的输出数组，以提高性能并控制输出的精度（例如，避免溢出）。</target>
        </trans-unit>
        <trans-unit id="28c0c9f82b9df1b46e1d92dc89a14b12f71a0eea" translate="yes" xml:space="preserve">
          <source>Cumulative sum an iterator. See also &lt;a href=&quot;#Base.cumsum!&quot;&gt;&lt;code&gt;cumsum!&lt;/code&gt;&lt;/a&gt; to use a preallocated output array, both for performance and to control the precision of the output (e.g. to avoid overflow).</source>
          <target state="translated">累积和的迭代器。另请参见&lt;a href=&quot;#Base.cumsum!&quot;&gt; &lt;code&gt;cumsum!&lt;/code&gt; &lt;/a&gt;使用预分配的输出数组，以提高性能并控制输出的精度（例如，避免溢出）。</target>
        </trans-unit>
        <trans-unit id="bff05572bc3057d02ece9df07eb6cbd41f496fa0" translate="yes" xml:space="preserve">
          <source>Cumulative sum of &lt;code&gt;A&lt;/code&gt; along the dimension &lt;code&gt;dims&lt;/code&gt;, storing the result in &lt;code&gt;B&lt;/code&gt;. See also &lt;a href=&quot;#Base.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 沿维度的累积总和 &lt;code&gt;dims&lt;/code&gt; ，结果存储在 &lt;code&gt;B&lt;/code&gt; 中。另请参见&lt;a href=&quot;#Base.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="99912e940e13479c415ea623b516e8ffb7fa26f1" translate="yes" xml:space="preserve">
          <source>Curly Logical And</source>
          <target state="translated">卷曲的逻辑和</target>
        </trans-unit>
        <trans-unit id="be512ff433c9dff6b74aeeea37b129ec63571384" translate="yes" xml:space="preserve">
          <source>Curly Logical Or</source>
          <target state="translated">卷曲逻辑或</target>
        </trans-unit>
        <trans-unit id="e60553c7a9a9cdb72bb36b2a44dd16e0bda76d87" translate="yes" xml:space="preserve">
          <source>Curly Loop</source>
          <target state="translated">卷发圈</target>
        </trans-unit>
        <trans-unit id="bfaceaf351e410dbe378f231dc87232a28180ee2" translate="yes" xml:space="preserve">
          <source>Currency Exchange</source>
          <target state="translated">货币兑换</target>
        </trans-unit>
        <trans-unit id="fa21c13b708840eecec79752cb17fc8c7197e8b1" translate="yes" xml:space="preserve">
          <source>Currently Julia supports &lt;code&gt;Intel VTune&lt;/code&gt;, &lt;code&gt;OProfile&lt;/code&gt; and &lt;code&gt;perf&lt;/code&gt; as external profiling tools.</source>
          <target state="translated">目前，Julia支持 &lt;code&gt;Intel VTune&lt;/code&gt; ， &lt;code&gt;OProfile&lt;/code&gt; 和 &lt;code&gt;perf&lt;/code&gt; 作为外部配置工具。</target>
        </trans-unit>
        <trans-unit id="5520b828a027b38a2df58c016c8a9e33a20b2c8f" translate="yes" xml:space="preserve">
          <source>Currently running, or able to run</source>
          <target state="translated">目前正在运行,或能够运行</target>
        </trans-unit>
        <trans-unit id="1cfdd1bbbc6e0ec95ba54ab86c4ed8984999f41c" translate="yes" xml:space="preserve">
          <source>Currently supported rounding modes are:</source>
          <target state="translated">目前支持的四舍五入模式有:</target>
        </trans-unit>
        <trans-unit id="18b6fb5cf9ba1d3a630cca350c13b1d2ae5247dd" translate="yes" xml:space="preserve">
          <source>Currently, all tasks in Julia are executed in a single OS thread co-operatively. Consequently, &lt;code&gt;asyncmap&lt;/code&gt; is beneficial only when the mapping function involves any I/O - disk, network, remote worker invocation, etc.</source>
          <target state="translated">当前，Julia中的所有任务都在一个OS线程中协同执行。因此，仅当映射功能涉及任何I / O（磁盘，网络，远程工作程序调用等）时， &lt;code&gt;asyncmap&lt;/code&gt; 映射才有用。</target>
        </trans-unit>
        <trans-unit id="2b6dbadabdc5ac18fd3d193d17d49f9b69abe7e2" translate="yes" xml:space="preserve">
          <source>Currently, dynamically linking with the &lt;code&gt;libjulia&lt;/code&gt; shared library requires passing the &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; option. In Python, this looks like:</source>
          <target state="translated">当前，与 &lt;code&gt;libjulia&lt;/code&gt; 共享库动态链接需要传递 &lt;code&gt;RTLD_GLOBAL&lt;/code&gt; 选项。在Python中，这看起来像：</target>
        </trans-unit>
        <trans-unit id="9b58fc7e8f3abd23e8c9cb124443e19466f0c18f" translate="yes" xml:space="preserve">
          <source>Currently, only the platform-default C calling convention is supported. This means that &lt;code&gt;@cfunction&lt;/code&gt;-generated pointers cannot be used in calls where WINAPI expects &lt;code&gt;stdcall&lt;/code&gt; function on 32-bit windows, but can be used on WIN64 (where &lt;code&gt;stdcall&lt;/code&gt; is unified with the C calling convention).</source>
          <target state="translated">当前，仅支持平台默认的C调用约定。这意味着 &lt;code&gt;@cfunction&lt;/code&gt; 生成的指针不能在WINAPI需要在32位窗口上使用 &lt;code&gt;stdcall&lt;/code&gt; 函数的调用中使用，而可以在WIN64（其中 &lt;code&gt;stdcall&lt;/code&gt; 与C调用约定统一在一起）上使用。</target>
        </trans-unit>
        <trans-unit id="1c0ed0fbc55fd384be8ba62427107654c612d24c" translate="yes" xml:space="preserve">
          <source>Currently, only the platform-default C calling convention is supported. This means that &lt;code&gt;@cfunction&lt;/code&gt;-generated pointers cannot be used in calls where WINAPI expects a &lt;code&gt;stdcall&lt;/code&gt; function on 32-bit Windows, but can be used on WIN64 (where &lt;code&gt;stdcall&lt;/code&gt; is unified with the C calling convention).</source>
          <target state="translated">当前，仅支持平台默认的C调用约定。这意味着 &lt;code&gt;@cfunction&lt;/code&gt; 生成的指针不能在WINAPI需要在32位Windows上使用 &lt;code&gt;stdcall&lt;/code&gt; 函数的调用中使用，而可以在WIN64（其中 &lt;code&gt;stdcall&lt;/code&gt; 与C调用约定统一在一起）上使用。</target>
        </trans-unit>
        <trans-unit id="f6c1e688c50876a4531f9d7cabb03fb248e6bfc9" translate="yes" xml:space="preserve">
          <source>Currently, sending a message between unconnected workers results in an error. This behaviour, as with the functionality and interface, should be considered experimental in nature and may change in future releases.</source>
          <target state="translated">目前,在未连接的工作者之间发送消息会导致错误。这种行为与功能和界面一样,应视为试验性质,并可能在未来的版本中改变。</target>
        </trans-unit>
        <trans-unit id="e1fc8148f1ad416a0c1c4d0cd037e79c49a7d381" translate="yes" xml:space="preserve">
          <source>Curry And Rice</source>
          <target state="translated">咖喱和米饭</target>
        </trans-unit>
        <trans-unit id="b85bdac6301eb2112a6814938a4d9e9df8648b71" translate="yes" xml:space="preserve">
          <source>Cushort</source>
          <target state="translated">Cushort</target>
        </trans-unit>
        <trans-unit id="8c54a5c7812a0f093c8cd0f91e33751d5c09251e" translate="yes" xml:space="preserve">
          <source>Custard</source>
          <target state="translated">Custard</target>
        </trans-unit>
        <trans-unit id="6f38ef54fa59e818dab5a77f3d2bbd3220e2cdca" translate="yes" xml:space="preserve">
          <source>Custom AbstractArray subtypes may choose which specific array type is best-suited to return for the given element type and dimensionality. If they do not specialize this method, the default is an &lt;code&gt;Array{element_type}(undef, dims...)&lt;/code&gt;.</source>
          <target state="translated">自定义AbstractArray子类型可以选择最适合返回给定元素类型和维数的特定数组类型。如果他们不擅长此方法，则默认值为 &lt;code&gt;Array{element_type}(undef, dims...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cc23a6161705d9edec42bd9037fd1426e4ee526" translate="yes" xml:space="preserve">
          <source>Custom error hints are available as of Julia 1.5.</source>
          <target state="translated">自定义的错误提示在Julia 1.5中就可以使用。</target>
        </trans-unit>
        <trans-unit id="097b8517391234e3c538e3449a9973ab8c13bc85" translate="yes" xml:space="preserve">
          <source>Custom implementation of &lt;code&gt;broadcast!&lt;/code&gt;, specializing on &lt;code&gt;DestStyle&lt;/code&gt;</source>
          <target state="translated">自定义执行 &lt;code&gt;broadcast!&lt;/code&gt; ，专门研究 &lt;code&gt;DestStyle&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06904021bd513a29837f2a6d605afdc08f9d837c" translate="yes" xml:space="preserve">
          <source>Custom implementation of &lt;code&gt;broadcast!&lt;/code&gt;, specializing on &lt;code&gt;DestType&lt;/code&gt;</source>
          <target state="translated">自定义执行 &lt;code&gt;broadcast!&lt;/code&gt; ，专门研究 &lt;code&gt;DestType&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b22d816549f3f00985f636630289bedbe251e80" translate="yes" xml:space="preserve">
          <source>Custom implementation of &lt;code&gt;broadcast&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;broadcast&lt;/code&gt; 自定义实现</target>
        </trans-unit>
        <trans-unit id="ea84a2c763f893aebf33f5fbf487cce49443ce61" translate="yes" xml:space="preserve">
          <source>Custom loggers should come with overloads for the functions described in the &lt;a href=&quot;#AbstractLogger-interface&quot;&gt;reference section&lt;/a&gt;.</source>
          <target state="translated">自定义记录器应具有&lt;a href=&quot;#AbstractLogger-interface&quot;&gt;参考部分&lt;/a&gt;所述功能的重载。</target>
        </trans-unit>
        <trans-unit id="9da5ea657bda58f10cb83ead3ab61bfbc054ab56" translate="yes" xml:space="preserve">
          <source>Custom loggers should come with overloads for the functions described in the &lt;a href=&quot;#AbstractLogger-interface-1&quot;&gt;reference section&lt;/a&gt;.</source>
          <target state="translated">自定义记录器应具有&lt;a href=&quot;#AbstractLogger-interface-1&quot;&gt;参考部分&lt;/a&gt;所述功能的重载。</target>
        </trans-unit>
        <trans-unit id="5f5be3cf33c9dad979d2a47c098609bed1e79588" translate="yes" xml:space="preserve">
          <source>Custom pretty-printing</source>
          <target state="translated">定制漂亮的印刷</target>
        </trans-unit>
        <trans-unit id="240986e918ac3d8fdf4ca20934614f2b94d7e71f" translate="yes" xml:space="preserve">
          <source>Custom sampler types</source>
          <target state="translated">自定义采样器类型</target>
        </trans-unit>
        <trans-unit id="f521cfc6a5585c09da5d9bc813b838a1bd8a6e43" translate="yes" xml:space="preserve">
          <source>Customizable binary operators</source>
          <target state="translated">可定制的二进制运算符</target>
        </trans-unit>
        <trans-unit id="5750ccbb9a21360352689ce8553c6205a82553f4" translate="yes" xml:space="preserve">
          <source>Customization / Configuration</source>
          <target state="translated">定制/配置</target>
        </trans-unit>
        <trans-unit id="7081c24bd2fc87db9d99bce55e22acb378d5b91a" translate="yes" xml:space="preserve">
          <source>Customizing Colors</source>
          <target state="translated">自定义颜色</target>
        </trans-unit>
        <trans-unit id="34880a9b35cda4c00b118d47d483351c6cc5ea2a" translate="yes" xml:space="preserve">
          <source>Customizing broadcasting</source>
          <target state="translated">自定义广播</target>
        </trans-unit>
        <trans-unit id="f9dfc91c94f0af58add748a7278bdfc60588cf5c" translate="yes" xml:space="preserve">
          <source>Customizing keybindings</source>
          <target state="translated">自定义键绑定</target>
        </trans-unit>
        <trans-unit id="22c43c80b6acba6c8e988834746cb3dad10dc13a" translate="yes" xml:space="preserve">
          <source>Customs</source>
          <target state="translated">Customs</target>
        </trans-unit>
        <trans-unit id="9cfe6bc8642611e40313cf0cc79620f14dffbbc6" translate="yes" xml:space="preserve">
          <source>Cwchar_t</source>
          <target state="translated">Cwchar_t</target>
        </trans-unit>
        <trans-unit id="d3862adb8c043e056018bc4b8a261f178c58e987" translate="yes" xml:space="preserve">
          <source>Cwstring</source>
          <target state="translated">Cwstring</target>
        </trans-unit>
        <trans-unit id="33ec23db96b16085821b404cc8c2b54fbfda44f5" translate="yes" xml:space="preserve">
          <source>Cyclone</source>
          <target state="translated">Cyclone</target>
        </trans-unit>
        <trans-unit id="216ff17303fbb44375e7a618a8708d4627fec28a" translate="yes" xml:space="preserve">
          <source>DEPOT_PATH</source>
          <target state="translated">DEPOT_PATH</target>
        </trans-unit>
        <trans-unit id="83dc75e20dcbf622a6cf33144a983d98f677b3aa" translate="yes" xml:space="preserve">
          <source>DI</source>
          <target state="translated">DI</target>
        </trans-unit>
        <trans-unit id="50fb8228b3b9fa5b2166d5730e6bbd9d4de9cae6" translate="yes" xml:space="preserve">
          <source>DL_LOAD_PATH</source>
          <target state="translated">DL_LOAD_PATH</target>
        </trans-unit>
        <trans-unit id="8e0e5961c9dc8c314c3d9bec3aebc5d5dceab1d6" translate="yes" xml:space="preserve">
          <source>Dagger</source>
          <target state="translated">Dagger</target>
        </trans-unit>
        <trans-unit id="d588da27f7b558f43e86a7f0556da786a0f5702f" translate="yes" xml:space="preserve">
          <source>Dalet Symbol / Fourth Transfinite Cardinal</source>
          <target state="translated">达利特符号/第四个无限红衣主教</target>
        </trans-unit>
        <trans-unit id="bbd3fe91db28cc6eaba879d637ff2415c19eaed3" translate="yes" xml:space="preserve">
          <source>Dancer</source>
          <target state="translated">Dancer</target>
        </trans-unit>
        <trans-unit id="4e457c357290fffb26efe10315ee86c05aa550ed" translate="yes" xml:space="preserve">
          <source>Dango</source>
          <target state="translated">Dango</target>
        </trans-unit>
        <trans-unit id="3f48fb7aab68e6aa82c811a8bdd3137296109c01" translate="yes" xml:space="preserve">
          <source>Dark Shade</source>
          <target state="translated">深色系</target>
        </trans-unit>
        <trans-unit id="ec3e5d3b5f51290af48556e1a22232b6c075e886" translate="yes" xml:space="preserve">
          <source>Dash Symbol</source>
          <target state="translated">破折号</target>
        </trans-unit>
        <trans-unit id="d1ee13b5a357f064705d5d2ee301ca24cec2d711" translate="yes" xml:space="preserve">
          <source>Data Formats</source>
          <target state="translated">数据格式</target>
        </trans-unit>
        <trans-unit id="b9a20ab226cf235e7e270845c1fed39a764c870e" translate="yes" xml:space="preserve">
          <source>Data Movement</source>
          <target state="translated">数据移动</target>
        </trans-unit>
        <trans-unit id="e5669bbf5a381f1b45f515386259ddfc4dd6e523" translate="yes" xml:space="preserve">
          <source>Data is necessarily copied over to the remote node for execution. This is the case for both remotecalls and when data is stored to a&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; on a different node. As expected, this results in a copy of the serialized objects on the remote node. However, when the destination node is the local node, i.e. the calling process id is the same as the remote node id, it is executed as a local call. It is usually(not always) executed in a different task - but there is no serialization/deserialization of data. Consequently, the call refers to the same object instances as passed - no copies are created. This behavior is highlighted below:</source>
          <target state="translated">数据必须复制到远程节点以执行。对于&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;和将数据存储到另一个节点上的RemoteChannel / &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;都是如此。如预期的那样，这将在远程节点上生成序列化对象的副本。但是，当目标节点是本地节点时，即呼叫进程ID与远程节点ID相同，它将作为本地呼叫执行。它通常（并非总是）在其他任务中执行-但是没有数据的序列化/反序列化。因此，该调用引用与传递的对象实例相同的对象-不创建任何副本。此行为突出显示在下面：</target>
        </trans-unit>
        <trans-unit id="968eebea0b7cae13cfdef325216bc706131315d1" translate="yes" xml:space="preserve">
          <source>Data-race freedom</source>
          <target state="translated">数据-种族自由</target>
        </trans-unit>
        <trans-unit id="842b7b5d71896a41ecd92997ec80b1df5243c81e" translate="yes" xml:space="preserve">
          <source>Dates</source>
          <target state="translated">Dates</target>
        </trans-unit>
        <trans-unit id="36896b6958dbc42b827d9983351001153fb900f9" translate="yes" xml:space="preserve">
          <source>Dates Functions</source>
          <target state="translated">日期 职能</target>
        </trans-unit>
        <trans-unit id="87a830783aa282885319d8bb8573974c6e9ce862" translate="yes" xml:space="preserve">
          <source>Dates and Time Types</source>
          <target state="translated">日期和时间类型</target>
        </trans-unit>
        <trans-unit id="1c3699dfa0f90796e26bab33925787fed0c43f91" translate="yes" xml:space="preserve">
          <source>Dates.Date</source>
          <target state="translated">Dates.Date</target>
        </trans-unit>
        <trans-unit id="32f52acc781735072821be18d470cd0e9e957322" translate="yes" xml:space="preserve">
          <source>Dates.Time</source>
          <target state="translated">Dates.Time</target>
        </trans-unit>
        <trans-unit id="fdec256842a6d05072d851ee7ef615cfbd56e9d8" translate="yes" xml:space="preserve">
          <source>Day of the month with a minimum width</source>
          <target state="translated">最小宽度的月日</target>
        </trans-unit>
        <trans-unit id="cfc71f3899e9e62bb3cb32d518c2500090d68e5a" translate="yes" xml:space="preserve">
          <source>Days of the Week:</source>
          <target state="translated">天的一周。</target>
        </trans-unit>
        <trans-unit id="75abb16100a8a64fe67d2b115039ae07750abe57" translate="yes" xml:space="preserve">
          <source>De-activate the region (i.e. make it not highlighted)</source>
          <target state="translated">取消激活该区域(即使其不突出显示)。</target>
        </trans-unit>
        <trans-unit id="cf4ca495e016d85d54e9e0c6c172007a72b770a7" translate="yes" xml:space="preserve">
          <source>Debugging and profiling</source>
          <target state="translated">调试和剖析</target>
        </trans-unit>
        <trans-unit id="86110bf8d0223821e4a3030b465ecd127fd05ca4" translate="yes" xml:space="preserve">
          <source>Decide whether the concept in question will be written as &lt;code&gt;MyType&lt;/code&gt; or &lt;code&gt;MyType()&lt;/code&gt;, and stick to it.</source>
          <target state="translated">确定有问题的概念将被编写为 &lt;code&gt;MyType&lt;/code&gt; 还是 &lt;code&gt;MyType()&lt;/code&gt; ，并坚持使用。</target>
        </trans-unit>
        <trans-unit id="f2225e92be396a4c31e9028b01af2d8105bf4719" translate="yes" xml:space="preserve">
          <source>Decides which &lt;code&gt;BroadcastStyle&lt;/code&gt; to use for any number of value arguments. Uses &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt; to get the style for each argument, and uses &lt;a href=&quot;#Base.Broadcast.result_style&quot;&gt;&lt;code&gt;result_style&lt;/code&gt;&lt;/a&gt; to combine styles.</source>
          <target state="translated">决定对任意数量的值参数使用哪个 &lt;code&gt;BroadcastStyle&lt;/code&gt; 。使用&lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt;获取每个参数的样式，并使用&lt;a href=&quot;#Base.Broadcast.result_style&quot;&gt; &lt;code&gt;result_style&lt;/code&gt; &lt;/a&gt;组合样式。</target>
        </trans-unit>
        <trans-unit id="56705d4190361578370161ee548e7b8b5b6f2df3" translate="yes" xml:space="preserve">
          <source>Deciduous Tree</source>
          <target state="translated">落叶树</target>
        </trans-unit>
        <trans-unit id="187bdf507820ae854f975416a37658ae06b738ce" translate="yes" xml:space="preserve">
          <source>Declaration of the indices of &lt;code&gt;x&lt;/code&gt;, as per &lt;code&gt;axes(x)&lt;/code&gt;.</source>
          <target state="translated">根据 &lt;code&gt;axes(x)&lt;/code&gt; 声明 &lt;code&gt;x&lt;/code&gt; 的索引。</target>
        </trans-unit>
        <trans-unit id="c678ba8568226163ef571fe8bacb3339af3cbb35" translate="yes" xml:space="preserve">
          <source>Declarations can also be attached to function definitions:</source>
          <target state="translated">声明也可以附加到函数定义中。</target>
        </trans-unit>
        <trans-unit id="1a398a40b1491048874f131c113c16e7ddf1ebf5" translate="yes" xml:space="preserve">
          <source>Declare the type of &lt;code&gt;x&lt;/code&gt; explicitly as &lt;code&gt;x::Float64 = 1&lt;/code&gt;</source>
          <target state="translated">将 &lt;code&gt;x&lt;/code&gt; 的类型显式声明为 &lt;code&gt;x::Float64 = 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2c99269d5b17a5b20dd25e68e9877e78c5ffa82" translate="yes" xml:space="preserve">
          <source>Declare the type of &lt;code&gt;x&lt;/code&gt;: &lt;code&gt;x::Float64 = 1&lt;/code&gt;</source>
          <target state="translated">声明 &lt;code&gt;x&lt;/code&gt; 的类型： &lt;code&gt;x::Float64 = 1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb67cf4c6f0459524901230203e023a095836c6e" translate="yes" xml:space="preserve">
          <source>Declared Types</source>
          <target state="translated">申报类型</target>
        </trans-unit>
        <trans-unit id="2c66e9dea182f1b50d49414e9afb7bd032249fee" translate="yes" xml:space="preserve">
          <source>Declared structure</source>
          <target state="translated">已宣布的结构</target>
        </trans-unit>
        <trans-unit id="88befac5b75ff9c9169815848fea3c4891d14f29" translate="yes" xml:space="preserve">
          <source>Decode the base64-encoded &lt;code&gt;string&lt;/code&gt; and returns a &lt;code&gt;Vector{UInt8}&lt;/code&gt; of the decoded bytes.</source>
          <target state="translated">解码base64编码的 &lt;code&gt;string&lt;/code&gt; 并返回解码字节的 &lt;code&gt;Vector{UInt8}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="46f09cf010188cfcdb80ed5e20b17e0855505297" translate="yes" xml:space="preserve">
          <source>Decoupling pre-computation from actually generating the values is part of the API, and is also available to the user. As an example, assume that &lt;code&gt;rand(rng, 1:20)&lt;/code&gt; has to be called repeatedly in a loop: the way to take advantage of this decoupling is as follows:</source>
          <target state="translated">将预计算与实际生成的值解耦是API的一部分，并且也可供用户使用。例如，假设必须循环调用 &lt;code&gt;rand(rng, 1:20)&lt;/code&gt; ：利用这种去耦的方式如下：</target>
        </trans-unit>
        <trans-unit id="a6f5642c9108dbd07942cf967b8a2867aca7eec1" translate="yes" xml:space="preserve">
          <source>Def. 4: &lt;code&gt;alpha=0&lt;/code&gt;, &lt;code&gt;beta=1&lt;/code&gt;</source>
          <target state="translated">防御 4： &lt;code&gt;alpha=0&lt;/code&gt; ， &lt;code&gt;beta=1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9595afd3ae45456faaf9d1b3bc37c042164ebce0" translate="yes" xml:space="preserve">
          <source>Def. 5: &lt;code&gt;alpha=0.5&lt;/code&gt;, &lt;code&gt;beta=0.5&lt;/code&gt;</source>
          <target state="translated">防御 5： &lt;code&gt;alpha=0.5&lt;/code&gt; ， &lt;code&gt;beta=0.5&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="077d65f8ac7ab40c5438963ab6b21a85d99f9894" translate="yes" xml:space="preserve">
          <source>Def. 6: &lt;code&gt;alpha=0&lt;/code&gt;, &lt;code&gt;beta=0&lt;/code&gt; (Excel &lt;code&gt;PERCENTILE.EXC&lt;/code&gt;, Python default, Stata &lt;code&gt;altdef&lt;/code&gt;)</source>
          <target state="translated">防御 6： &lt;code&gt;alpha=0&lt;/code&gt; ， &lt;code&gt;beta=0&lt;/code&gt; （Excel &lt;code&gt;PERCENTILE.EXC&lt;/code&gt; ，Python默认值，Stata &lt;code&gt;altdef&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="95183fa1581b054fcf1747b0515a86da5f944d84" translate="yes" xml:space="preserve">
          <source>Def. 7: &lt;code&gt;alpha=1&lt;/code&gt;, &lt;code&gt;beta=1&lt;/code&gt; (Julia, R and NumPy default, Excel &lt;code&gt;PERCENTILE&lt;/code&gt; and &lt;code&gt;PERCENTILE.INC&lt;/code&gt;, Python &lt;code&gt;'inclusive'&lt;/code&gt;)</source>
          <target state="translated">防御 7： &lt;code&gt;alpha=1&lt;/code&gt; ， &lt;code&gt;beta=1&lt;/code&gt; （Julia，R和NumPy默认值，Excel &lt;code&gt;PERCENTILE&lt;/code&gt; 和 &lt;code&gt;PERCENTILE.INC&lt;/code&gt; ，Python'inclusive &lt;code&gt;'inclusive'&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="27146b4be1d656958e4e3b272c15be6fa645045e" translate="yes" xml:space="preserve">
          <source>Def. 8: &lt;code&gt;alpha=1/3&lt;/code&gt;, &lt;code&gt;beta=1/3&lt;/code&gt;</source>
          <target state="translated">防御 8： &lt;code&gt;alpha=1/3&lt;/code&gt; ， &lt;code&gt;beta=1/3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2e5ce22259b1d20b2c1d71acc7e59d337175474" translate="yes" xml:space="preserve">
          <source>Def. 9: &lt;code&gt;alpha=3/8&lt;/code&gt;, &lt;code&gt;beta=3/8&lt;/code&gt;</source>
          <target state="translated">防御 9： &lt;code&gt;alpha=3/8&lt;/code&gt; ， &lt;code&gt;beta=3/8&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="15ac2aa0f274814677f21a2664636a6e0c15f7c8" translate="yes" xml:space="preserve">
          <source>Default is to auto-detect the proxy type.</source>
          <target state="translated">默认为自动检测代理类型。</target>
        </trans-unit>
        <trans-unit id="79c7b4e844bd36e0f1c0ccc6518eefeba8042556" translate="yes" xml:space="preserve">
          <source>Default top-level definitions and bare modules</source>
          <target state="translated">默认的顶层定义和裸模块</target>
        </trans-unit>
        <trans-unit id="5e8200e5de4b40f2a761e04f2a21d530f62ac24a" translate="yes" xml:space="preserve">
          <source>Define a new editor matching &lt;code&gt;pattern&lt;/code&gt; that can be used to open a file (possibly at a given line number) using &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">使用 &lt;code&gt;fn&lt;/code&gt; 定义一个新的编辑器匹配 &lt;code&gt;pattern&lt;/code&gt; ，该模式可用于打开文件（可能以给定的行号）。</target>
        </trans-unit>
        <trans-unit id="dcdff78b360ed6cd29323d1507c31f96970d8e0b" translate="yes" xml:space="preserve">
          <source>Define a region &lt;code&gt;R&lt;/code&gt; spanning a multidimensional rectangular range of integer indices. These are most commonly encountered in the context of iteration, where &lt;code&gt;for I in R ... end&lt;/code&gt; will return &lt;a href=&quot;#Base.IteratorsMD.CartesianIndex&quot;&gt;&lt;code&gt;CartesianIndex&lt;/code&gt;&lt;/a&gt; indices &lt;code&gt;I&lt;/code&gt; equivalent to the nested loops</source>
          <target state="translated">定义一个跨整数整数索引的多维矩形范围的区域 &lt;code&gt;R&lt;/code&gt; 。这些在迭代的情况下，其中最常见的 &lt;code&gt;for I in R ... end&lt;/code&gt; 将返回&lt;a href=&quot;#Base.IteratorsMD.CartesianIndex&quot;&gt; &lt;code&gt;CartesianIndex&lt;/code&gt; &lt;/a&gt;指数 &lt;code&gt;I&lt;/code&gt; 等同于嵌套循环</target>
        </trans-unit>
        <trans-unit id="a0e4dd75ee5019eb13db03c029c41e75b3aaa5e3" translate="yes" xml:space="preserve">
          <source>Define an &lt;code&gt;AbstractUnitRange&lt;/code&gt; that behaves like &lt;code&gt;1:n&lt;/code&gt;, with the added distinction that the lower limit is guaranteed (by the type system) to be 1.</source>
          <target state="translated">定义一个行为类似于 &lt;code&gt;1:n&lt;/code&gt; 的 &lt;code&gt;AbstractUnitRange&lt;/code&gt; ，额外的区别是（通过类型系统）保证下限为1。</target>
        </trans-unit>
        <trans-unit id="588b3c159cb4712c0152a8a53daf119df81aa7ba" translate="yes" xml:space="preserve">
          <source>Define other operations that use &lt;code&gt;f(x)&lt;/code&gt;:</source>
          <target state="translated">定义其他使用 &lt;code&gt;f(x)&lt;/code&gt; 的操作：</target>
        </trans-unit>
        <trans-unit id="d2947f0706fff8e7126e6357ddb46ba0dbd29fa6" translate="yes" xml:space="preserve">
          <source>Defining Methods</source>
          <target state="translated">定义方法</target>
        </trans-unit>
        <trans-unit id="0c22d4ea82e4f1b312acd9a3994522966c35371b" translate="yes" xml:space="preserve">
          <source>Defining New Conversions</source>
          <target state="translated">定义新的转换</target>
        </trans-unit>
        <trans-unit id="4e6963b3110a46628b4c6d35d33fe7d6e7bd71d0" translate="yes" xml:space="preserve">
          <source>Defining Promotion Rules</source>
          <target state="translated">促销规则的定义</target>
        </trans-unit>
        <trans-unit id="ecece75a8f8a880522732b9cd0177884625f667e" translate="yes" xml:space="preserve">
          <source>Defining a basic &lt;code&gt;AbstractTestSet&lt;/code&gt; subtype might look like:</source>
          <target state="translated">定义基本的 &lt;code&gt;AbstractTestSet&lt;/code&gt; 子类型可能类似于：</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="38721ea3df19d3ffaf5150dd675b640530a0546d" translate="yes" xml:space="preserve">
          <source>Degree Sign</source>
          <target state="translated">学位号</target>
        </trans-unit>
        <trans-unit id="1a4e3b4bb8e1094eb26bfa7cb8783cdea32dfe30" translate="yes" xml:space="preserve">
          <source>Delete and return the mapping for &lt;code&gt;key&lt;/code&gt; if it exists in &lt;code&gt;collection&lt;/code&gt;, otherwise return &lt;code&gt;default&lt;/code&gt;, or throw an error if &lt;code&gt;default&lt;/code&gt; is not specified.</source>
          <target state="translated">删除并返回 &lt;code&gt;key&lt;/code&gt; 的映射（如果键的映射存在于 &lt;code&gt;collection&lt;/code&gt; 中)，否则返回 &lt;code&gt;default&lt;/code&gt; ，或者如果未指定 &lt;code&gt;default&lt;/code&gt; 则抛出错误。</target>
        </trans-unit>
        <trans-unit id="d98877669570739f73775c66eb9704f2ba71ab77" translate="yes" xml:space="preserve">
          <source>Delete previous text up to the nearest whitespace</source>
          <target state="translated">删除之前的文字,直到最近的空白处。</target>
        </trans-unit>
        <trans-unit id="80e6b34017de84d227a51e468428b830d3abce81" translate="yes" xml:space="preserve">
          <source>Delete the branch pointed to by &lt;code&gt;branch&lt;/code&gt;.</source>
          <target state="translated">删除branch指向的 &lt;code&gt;branch&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2e26e2e065a1fcbeb86d9a12f9c736cd9f6b54e6" translate="yes" xml:space="preserve">
          <source>Delete the file, link, or empty directory at the given path. If &lt;code&gt;force=true&lt;/code&gt; is passed, a non-existing path is not treated as error. If &lt;code&gt;recursive=true&lt;/code&gt; is passed and the path is a directory, then all contents are removed recursively.</source>
          <target state="translated">删除给定路径下的文件，链接或空目录。如果通过 &lt;code&gt;force=true&lt;/code&gt; ，则不存在的路径不会被视为错误。如果传递了 &lt;code&gt;recursive=true&lt;/code&gt; 且路径是目录，则将以递归方式删除所有内容。</target>
        </trans-unit>
        <trans-unit id="e988febce46cb76c97d9a9f098a2791248f65170" translate="yes" xml:space="preserve">
          <source>Delete the mapping for the given key in a collection, and return the collection.</source>
          <target state="translated">删除集合中给定键的映射,并返回集合。</target>
        </trans-unit>
        <trans-unit id="44ce9985e153ff02b6235d95732bd1b056146857" translate="yes" xml:space="preserve">
          <source>Delete the mapping for the given key in a collection, if any, and return the collection.</source>
          <target state="translated">删除集合中给定键的映射(如果有),并返回集合。</target>
        </trans-unit>
        <trans-unit id="48c4aef19d86e28665c31c2a1fdfed6ed55b27f0" translate="yes" xml:space="preserve">
          <source>Delete the previous character, or the whole region when it's active</source>
          <target state="translated">删除前一个字符,或者当它处于活动状态时删除整个区域。</target>
        </trans-unit>
        <trans-unit id="3cff3520dd83f96bd232342b44e0add55d0baab6" translate="yes" xml:space="preserve">
          <source>Delete the previous word</source>
          <target state="translated">删除前一个词</target>
        </trans-unit>
        <trans-unit id="91ffc8de7f40ffc066d84c7f26109c9e03c6f805" translate="yes" xml:space="preserve">
          <source>Delete, &lt;code&gt;^D&lt;/code&gt;</source>
          <target state="translated">删除， &lt;code&gt;^D&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53e4d82d4995bf30ba309b0818053aa7081c7519" translate="yes" xml:space="preserve">
          <source>Delimited Files</source>
          <target state="translated">限定文件</target>
        </trans-unit>
        <trans-unit id="cec2c59e089d9f58238ee95327e2b286e786faed" translate="yes" xml:space="preserve">
          <source>Delimited slots are marked by specifying the delimiter the parser should expect between two subsequent periods; so &lt;code&gt;&quot;y-m-d&quot;&lt;/code&gt; lets the parser know that between the first and second slots in a date string like &lt;code&gt;&quot;2014-07-16&quot;&lt;/code&gt;, it should find the &lt;code&gt;-&lt;/code&gt; character. The &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;d&lt;/code&gt; characters let the parser know which periods to parse in each slot.</source>
          <target state="translated">通过指定解析器在两个后续周期之间应该期望的定界符来标记定界的时隙。因此， &lt;code&gt;&quot;y-m-d&quot;&lt;/code&gt; 让解析器知道在日期字符串（如 &lt;code&gt;&quot;2014-07-16&quot;&lt;/code&gt; 的第一个和第二个广告位之间，应该找到 &lt;code&gt;-&lt;/code&gt; 字符。的 &lt;code&gt;y&lt;/code&gt; ， &lt;code&gt;m&lt;/code&gt; ，和 &lt;code&gt;d&lt;/code&gt; 字符让解析器知道周期以在每个时隙哪个解析。</target>
        </trans-unit>
        <trans-unit id="51d69934332b769741cf61b5b730a2cdba3eed7c" translate="yes" xml:space="preserve">
          <source>DelimitedFiles.readdlm()</source>
          <target state="translated">DelimitedFiles.readdlm()</target>
        </trans-unit>
        <trans-unit id="480a3033b9d53578f2568ffa94ff98e43e3f7ea6" translate="yes" xml:space="preserve">
          <source>DelimitedFiles.writedlm()</source>
          <target state="translated">DelimitedFiles.writedlm()</target>
        </trans-unit>
        <trans-unit id="895b5ccc82a877146bc08599ac54b9af5f081f65" translate="yes" xml:space="preserve">
          <source>Delivery Truck</source>
          <target state="translated">送货卡车</target>
        </trans-unit>
        <trans-unit id="fdff1d4ceb07d550335cfb224cd4c93c1413a0fa" translate="yes" xml:space="preserve">
          <source>Delta Equal To</source>
          <target state="translated">三角形等于</target>
        </trans-unit>
        <trans-unit id="d876cbfe74b813ac207d0e9f78546f7688d9b032" translate="yes" xml:space="preserve">
          <source>Denominator of the rational representation of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 有理表示的分母。</target>
        </trans-unit>
        <trans-unit id="e9501853c3d6adc0961aff7ed40ae9c83e53f278" translate="yes" xml:space="preserve">
          <source>Dense</source>
          <target state="translated">Dense</target>
        </trans-unit>
        <trans-unit id="bff84cd5bdedc08353d7da69b84b0ab8978ba47b" translate="yes" xml:space="preserve">
          <source>Dense Symmetric/Hermitian</source>
          <target state="translated">密集对称/隐性</target>
        </trans-unit>
        <trans-unit id="36f2b0b5e58f351883eb10f69aec3caeecfa3d2e" translate="yes" xml:space="preserve">
          <source>DenseMatrix</source>
          <target state="translated">DenseMatrix</target>
        </trans-unit>
        <trans-unit id="eccc3b309862b32e23f021b5f67ce45d957d12b0" translate="yes" xml:space="preserve">
          <source>DenseVecOrMat</source>
          <target state="translated">DenseVecOrMat</target>
        </trans-unit>
        <trans-unit id="0359b22dae8b7e9c2a1f55727a94cf7163a84465" translate="yes" xml:space="preserve">
          <source>DenseVector</source>
          <target state="translated">DenseVector</target>
        </trans-unit>
        <trans-unit id="642cae737f8e008435129e4bb7c0bf0176fb92da" translate="yes" xml:space="preserve">
          <source>Department Store</source>
          <target state="translated">百货公司</target>
        </trans-unit>
        <trans-unit id="b943c9c136349bfa294ef95babe063e21021459d" translate="yes" xml:space="preserve">
          <source>Depending on compile-time side-effects persisting through load-time. Example include: modifying arrays or other variables in other Julia modules; maintaining handles to open files or devices; storing pointers to other system resources (including memory);</source>
          <target state="translated">根据编译时的副作用在加载时持续存在。例如:修改其他Julia模块中的数组或其他变量;维护打开的文件或设备的句柄;存储其他系统资源(包括内存)的指针。</target>
        </trans-unit>
        <trans-unit id="5ddfb542597e43f83234973f5482c146195f9e43" translate="yes" xml:space="preserve">
          <source>Depending on the format of the input value, the closest representable value to 2&amp;pi; may be less than 2&amp;pi;. For example, the expression &lt;code&gt;mod2pi(2&amp;pi;)&lt;/code&gt; will not return &lt;code&gt;0&lt;/code&gt;, because the intermediate value of &lt;code&gt;2*&amp;pi;&lt;/code&gt; is a &lt;code&gt;Float64&lt;/code&gt; and &lt;code&gt;2*Float64(&amp;pi;) &amp;lt; 2*big(&amp;pi;)&lt;/code&gt;. See &lt;a href=&quot;#Base.Math.rem2pi&quot;&gt;&lt;code&gt;rem2pi&lt;/code&gt;&lt;/a&gt; for more refined control of this behavior.</source>
          <target state="translated">根据输入值的格式，最接近2&amp;pi;的可表示值可能小于2&amp;pi;。例如，表达 &lt;code&gt;mod2pi(2&amp;pi;)&lt;/code&gt; 将不会返回 &lt;code&gt;0&lt;/code&gt; ，因为中间值 &lt;code&gt;2*&amp;pi;&lt;/code&gt; 是 &lt;code&gt;Float64&lt;/code&gt; 和 &lt;code&gt;2*Float64(&amp;pi;) &amp;lt; 2*big(&amp;pi;)&lt;/code&gt; 。有关此行为的更精细控制，请参见&lt;a href=&quot;#Base.Math.rem2pi&quot;&gt; &lt;code&gt;rem2pi&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d379477708d634a0aa71159aab76fc85b03d4ea8" translate="yes" xml:space="preserve">
          <source>Depending on the tool you choose, compile with &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt;, &lt;code&gt;USE_OPROFILE_JITEVENTS&lt;/code&gt; and &lt;code&gt;USE_PERF_JITEVENTS&lt;/code&gt; set to 1 in &lt;code&gt;Make.user&lt;/code&gt;. Multiple flags are supported.</source>
          <target state="translated">根据您选择的工具，在 &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; ， &lt;code&gt;USE_OPROFILE_JITEVENTS&lt;/code&gt; 和 &lt;code&gt;USE_PERF_JITEVENTS&lt;/code&gt; 设置为1进行 &lt;code&gt;Make.user&lt;/code&gt; 。支持多个标志。</target>
        </trans-unit>
        <trans-unit id="1d3a551db738fe045d83ee6293d4963fb1dfe11c" translate="yes" xml:space="preserve">
          <source>Deprecate method &lt;code&gt;old&lt;/code&gt; and specify the replacement call &lt;code&gt;new&lt;/code&gt;. Prevent &lt;code&gt;@deprecate&lt;/code&gt; from exporting &lt;code&gt;old&lt;/code&gt; by setting &lt;code&gt;ex&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. &lt;code&gt;@deprecate&lt;/code&gt; defines a new method with the same signature as &lt;code&gt;old&lt;/code&gt;.</source>
          <target state="translated">弃用方法 &lt;code&gt;old&lt;/code&gt; 并指定替换调用 &lt;code&gt;new&lt;/code&gt; 。通过将 &lt;code&gt;ex&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 来防止 &lt;code&gt;@deprecate&lt;/code&gt; 导出 &lt;code&gt;old&lt;/code&gt; 。 &lt;code&gt;@deprecate&lt;/code&gt; 定义了一个具有与 &lt;code&gt;old&lt;/code&gt; 相同签名的新方法。</target>
        </trans-unit>
        <trans-unit id="242a5524acc8713087f708386c9c794f5f3931bd" translate="yes" xml:space="preserve">
          <source>Deprecated functions are removed after the subsequent release. For example, functions marked as deprecated in the 0.1 release will not be available starting with the 0.2 release.</source>
          <target state="translated">废弃的功能在后续版本发布后会被移除。例如,在0.1版本中被标记为弃用的功能,从0.2版本开始将无法使用。</target>
        </trans-unit>
        <trans-unit id="06a4e84adec4fa6378a8c2435f1ea8fcbef66398" translate="yes" xml:space="preserve">
          <source>Dequeues</source>
          <target state="translated">Dequeues</target>
        </trans-unit>
        <trans-unit id="c65645dadaf75772aa2463e4bea5df65e0668b6a" translate="yes" xml:space="preserve">
          <source>Describes a single instruction/operation to be performed during the rebase. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_rebase_operation_t&quot;&gt;&lt;code&gt;git_rebase_operation&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">描述在变基期间要执行的单个指令/操作。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_rebase_operation_t&quot;&gt; &lt;code&gt;git_rebase_operation&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="ee984d55c69fd75c93dd767a8b9c6db89c37f979" translate="yes" xml:space="preserve">
          <source>Describing Julia in the lingo of &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_system&quot;&gt;type systems&lt;/a&gt;, it is: dynamic, nominative and parametric. Generic types can be parameterized, and the hierarchical relationships between types are &lt;a href=&quot;https://en.wikipedia.org/wiki/Nominal_type_system&quot;&gt;explicitly declared&lt;/a&gt;, rather than &lt;a href=&quot;https://en.wikipedia.org/wiki/Structural_type_system&quot;&gt;implied by compatible structure&lt;/a&gt;. One particularly distinctive feature of Julia's type system is that concrete types may not subtype each other: all concrete types are final and may only have abstract types as their supertypes. While this might at first seem unduly restrictive, it has many beneficial consequences with surprisingly few drawbacks. It turns out that being able to inherit behavior is much more important than being able to inherit structure, and inheriting both causes significant difficulties in traditional object-oriented languages. Other high-level aspects of Julia's type system that should be mentioned up front are:</source>
          <target state="translated">用&lt;a href=&quot;https://en.wikipedia.org/wiki/Type_system&quot;&gt;类型系统&lt;/a&gt;的术语描述Julia ，它是：动态的，主格的和参数化的。可以对泛型类型进行参数化，并且&lt;a href=&quot;https://en.wikipedia.org/wiki/Nominal_type_system&quot;&gt;显式声明&lt;/a&gt;类型之间的层次关系，而不是&lt;a href=&quot;https://en.wikipedia.org/wiki/Structural_type_system&quot;&gt;由兼容结构隐含&lt;/a&gt;。朱莉娅类型系统的一个特别与众不同的特征是，具体类型不能互为子类型：所有具体类型都是最终类型，并且只能具有抽象类型作为其超类型。虽然这乍看起来似乎是不适当的限制，但它具有许多有益的结果，而缺点却很少。事实证明，能够继承行为比能够继承结构更为重要，并且继承两者都会给传统的面向对象语言带来巨大的困难。朱莉娅类型系统的其他高级方面应在前面提到：</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="e39db8493c1fda362ba77503fa8b88b4e7237b8d" translate="yes" xml:space="preserve">
          <source>Description of changes to one entry. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_delta&quot;&gt;&lt;code&gt;git_diff_delta&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">一项更改的描述。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_delta&quot;&gt; &lt;code&gt;git_diff_delta&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="988fedca2d77cb7c769954515d3380c033f9d5e4" translate="yes" xml:space="preserve">
          <source>Description of one side of a delta. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_file&quot;&gt;&lt;code&gt;git_diff_file&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">三角洲一侧的描述。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_diff_file&quot;&gt; &lt;code&gt;git_diff_file&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="be730a71419945587f16a616135a86d24c6b00df" translate="yes" xml:space="preserve">
          <source>Design Patterns with Parametric Methods</source>
          <target state="translated">参数化方法的设计模式</target>
        </trans-unit>
        <trans-unit id="3c0874aa1f2c5e541e93555aa18c23a58e93cf08" translate="yes" xml:space="preserve">
          <source>Designed for parallelism and distributed computation</source>
          <target state="translated">为并行和分布式计算而设计</target>
        </trans-unit>
        <trans-unit id="3c1ac6acb43140e473d6bbf32a76f1a42622c490" translate="yes" xml:space="preserve">
          <source>Despite these limitations, sampling profilers have substantial strengths:</source>
          <target state="translated">尽管有这些局限性,但采样剖析器仍有很大的优势。</target>
        </trans-unit>
        <trans-unit id="b7fed4399dc2366cfa2c6427b5726d3747fbb7a6" translate="yes" xml:space="preserve">
          <source>Details can be found in the &lt;a href=&quot;#stdlib-sparse-arrays&quot;&gt;Sparse Vectors and Matrices&lt;/a&gt; section of the standard library reference.</source>
          <target state="translated">可以在标准库参考的&amp;ldquo;&lt;a href=&quot;#stdlib-sparse-arrays&quot;&gt;稀疏向量和矩阵&amp;rdquo;&lt;/a&gt;部分中找到详细信息。</target>
        </trans-unit>
        <trans-unit id="3cff394bb90e68ac928062ab33d7e95c09551667" translate="yes" xml:space="preserve">
          <source>Details can be found in the &lt;a href=&quot;#stdlib-sparse-arrays-1&quot;&gt;Sparse Vectors and Matrices&lt;/a&gt; section of the standard library reference.</source>
          <target state="translated">可以在标准库参考的&amp;ldquo; &lt;a href=&quot;#stdlib-sparse-arrays-1&quot;&gt;稀疏向量和矩阵&amp;rdquo;&lt;/a&gt;部分中找到详细信息。</target>
        </trans-unit>
        <trans-unit id="d9abaafa688cd076cbfe0ab170aa5929c003cedc" translate="yes" xml:space="preserve">
          <source>Determine if the branch containing &lt;code&gt;ref&lt;/code&gt; has a specified upstream branch.</source>
          <target state="translated">确定包含 &lt;code&gt;ref&lt;/code&gt; 的分支是否具有指定的上游分支。</target>
        </trans-unit>
        <trans-unit id="fcf969dbd3b4cd23f5e44c248c8256fc35e9a78a" translate="yes" xml:space="preserve">
          <source>Determine if the branch specified by &lt;code&gt;branch_name&lt;/code&gt; exists in the repository &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;remote&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;repo&lt;/code&gt; is assumed to be a remote git repository. Otherwise, it is part of the local filesystem.</source>
          <target state="translated">确定 &lt;code&gt;branch_name&lt;/code&gt; 指定的分支在存储库 &lt;code&gt;repo&lt;/code&gt; 中是否存在。如果 &lt;code&gt;remote&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则将 &lt;code&gt;repo&lt;/code&gt; 假定为远程git存储库。否则，它是本地文件系统的一部分。</target>
        </trans-unit>
        <trans-unit id="34ac1a921df971b54418bdc7fa30b45ba64aa009" translate="yes" xml:space="preserve">
          <source>Determine the declared type of a field (specified by name or index) in a composite DataType &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">确定复合DataType &lt;code&gt;T&lt;/code&gt; 中字段的声明类型（由名称或索引指定）。</target>
        </trans-unit>
        <trans-unit id="2e74d71e6265c1a4d5bccc1bce9622cb2d709544" translate="yes" xml:space="preserve">
          <source>Determine the module containing a given definition of a generic function.</source>
          <target state="translated">确定包含给定通用函数定义的模块。</target>
        </trans-unit>
        <trans-unit id="38ae7ce3fa55379d3288d064511593e9779d54ab" translate="yes" xml:space="preserve">
          <source>Determine the module containing the (first) definition of a generic function.</source>
          <target state="translated">确定包含(第一个)通用函数定义的模块。</target>
        </trans-unit>
        <trans-unit id="ea6f8abc3832bcad08cf551e8f3ae7259442f202" translate="yes" xml:space="preserve">
          <source>Determine the module containing the definition of a (potentially &lt;code&gt;UnionAll&lt;/code&gt;-wrapped) &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">确定包含（可能是 &lt;code&gt;UnionAll&lt;/code&gt; 包装的） &lt;code&gt;DataType&lt;/code&gt; 定义的模块。</target>
        </trans-unit>
        <trans-unit id="fb142e504214629cb5fc814202b65406eb9c20c0" translate="yes" xml:space="preserve">
          <source>Determine the result axes for broadcasting across all values in &lt;code&gt;As&lt;/code&gt;.</source>
          <target state="translated">确定要在 &lt;code&gt;As&lt;/code&gt; 中所有值之间进行广播的结果轴。</target>
        </trans-unit>
        <trans-unit id="410d903111782ec28acaf29cfa71423107052d65" translate="yes" xml:space="preserve">
          <source>Determine the type of the elements generated by iterating a collection of the given &lt;code&gt;type&lt;/code&gt;. For dictionary types, this will be a &lt;code&gt;Pair{KeyType,ValType}&lt;/code&gt;. The definition &lt;code&gt;eltype(x) = eltype(typeof(x))&lt;/code&gt; is provided for convenience so that instances can be passed instead of types. However the form that accepts a type argument should be defined for new types.</source>
          <target state="translated">确定通过迭代给定 &lt;code&gt;type&lt;/code&gt; 的集合生成的元素的类型。对于字典类型，这将是 &lt;code&gt;Pair{KeyType,ValType}&lt;/code&gt; 。为方便起见提供了定义 &lt;code&gt;eltype(x) = eltype(typeof(x))&lt;/code&gt; ，以便可以传递实例而不是类型。但是，应为新类型定义接受类型参数的形式。</target>
        </trans-unit>
        <trans-unit id="31e69d279349192cad6ed6fe456ca3b89eeef551" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same elements. Equivalent to &lt;code&gt;a &amp;sube; b &amp;amp;&amp;amp; b &amp;sube; a&lt;/code&gt; but more efficient when possible.</source>
          <target state="translated">确定 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是否具有相同的元素。等效于 &lt;code&gt;a &amp;sube; b &amp;amp;&amp;amp; b &amp;sube; a&lt;/code&gt; 但在可能的情况下更有效。</target>
        </trans-unit>
        <trans-unit id="aaf34e07d4b25cba011c9553650f31cccd21dfff" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have the same elements. Equivalent to &lt;code&gt;a &amp;sube; b &amp;amp;&amp;amp; b &amp;sube; a&lt;/code&gt;.</source>
          <target state="translated">确定 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 是否具有相同的元素。等效于 &lt;code&gt;a &amp;sube; b &amp;amp;&amp;amp; b &amp;sube; a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6fe224096ee6d271d8650ef5a85d12ddaf29a9aa" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are identical, in the sense that no program could distinguish them. First the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compared. If those are identical, mutable objects are compared by address in memory and immutable objects (such as numbers) are compared by contents at the bit level. This function is sometimes called &quot;egal&quot;. It always returns a &lt;code&gt;Bool&lt;/code&gt; value.</source>
          <target state="translated">在没有程序可以区分它们的意义上，确定 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 是否相同。首先，比较 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的类型。如果这些相同，则将可变对象按内存中的地址进行比较，并将不可变对象（如数字）按位级别的内容进行比较。此功能有时称为&amp;ldquo; egal&amp;rdquo;。它总是返回一个 &lt;code&gt;Bool&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="4c01841b1d19ebebbfd42e2a4519e9eeb23a21ff" translate="yes" xml:space="preserve">
          <source>Determine whether &lt;code&gt;x&lt;/code&gt; is of the given &lt;code&gt;type&lt;/code&gt;. Can also be used as an infix operator, e.g. &lt;code&gt;x isa type&lt;/code&gt;.</source>
          <target state="translated">确定 &lt;code&gt;x&lt;/code&gt; 是否为给定 &lt;code&gt;type&lt;/code&gt; 。也可以用作中缀运算符，例如 &lt;code&gt;x isa type&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3861d13a45d2603781ce381027b447191258c3b4" translate="yes" xml:space="preserve">
          <source>Determine whether Julia is running an interactive session.</source>
          <target state="translated">确定Julia是否正在进行交互式会话。</target>
        </trans-unit>
        <trans-unit id="43e65f5a402fa1bae924db49a2a1b4604ea303b3" translate="yes" xml:space="preserve">
          <source>Determine whether a &lt;a href=&quot;#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; has a value stored to it. Returns immediately, does not block.</source>
          <target state="translated">确定&lt;a href=&quot;#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;是否已存储值。立即返回，不阻塞。</target>
        </trans-unit>
        <trans-unit id="280a7018baf400207d8ed62c131e85ed27290be5" translate="yes" xml:space="preserve">
          <source>Determine whether a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; has a value stored to it.</source>
          <target state="translated">确定&lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;是否存储有值。</target>
        </trans-unit>
        <trans-unit id="5b3324d1290d116032871a2bc5a94e10fb519e78" translate="yes" xml:space="preserve">
          <source>Determine whether a &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt; has a value stored to it. Note that this function can cause race conditions, since by the time you receive its result it may no longer be true. However, it can be safely used on a &lt;a href=&quot;#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; since they are assigned only once.</source>
          <target state="translated">确定&lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt;是否存储有值。请注意，此功能可能会导致争用情况，因为到您收到结果时，该功能可能不再成立。但是，由于它们仅被分配一次，因此可以安全地用于&lt;a href=&quot;#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="fc0458f050932959c86f90b6c0643dab4bcd9d1c" translate="yes" xml:space="preserve">
          <source>Determine whether a MIME type is text data. MIME types are assumed to be binary data except for a set of types known to be text data (possibly Unicode).</source>
          <target state="translated">确定一个MIME类型是否是文本数据。MIME类型被假定为二进制数据,除了一组已知的文本数据类型(可能是Unicode)。</target>
        </trans-unit>
        <trans-unit id="8fc3770027bb1af30a8b4ee8ea80a29e494f0909" translate="yes" xml:space="preserve">
          <source>Determine whether a collection has a mapping for a given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">确定集合是否具有给定 &lt;code&gt;key&lt;/code&gt; 的映射。</target>
        </trans-unit>
        <trans-unit id="c5ba1a2324fb337b282efe50cd8040bf37d77c27" translate="yes" xml:space="preserve">
          <source>Determine whether a collection is empty (has no elements).</source>
          <target state="translated">确定一个集合是否为空(没有元素)。</target>
        </trans-unit>
        <trans-unit id="5ec1cb97856793fb5db0068de1e319eab60e77f5" translate="yes" xml:space="preserve">
          <source>Determine whether a global is declared &lt;code&gt;const&lt;/code&gt; in a given &lt;code&gt;Module&lt;/code&gt;.</source>
          <target state="translated">确定是否在给定 &lt;code&gt;Module&lt;/code&gt; 中将全局声明为 &lt;code&gt;const&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38e06eb740836bfe1cee92d1e7507081c868e8a5" translate="yes" xml:space="preserve">
          <source>Determine whether a path is absolute (begins at the root directory).</source>
          <target state="translated">确定一个路径是否为绝对路径(从根目录开始)。</target>
        </trans-unit>
        <trans-unit id="75728de62cc30cf84c05834c62b8d893a844140e" translate="yes" xml:space="preserve">
          <source>Determine whether a path refers to a directory (for example, ends with a path separator).</source>
          <target state="translated">确定一个路径是否指的是一个目录(例如,以路径分隔符结束)。</target>
        </trans-unit>
        <trans-unit id="8b477691984cbcbed81870b45fc48859b3d53183" translate="yes" xml:space="preserve">
          <source>Determine whether a process has exited.</source>
          <target state="translated">判断一个流程是否已经退出。</target>
        </trans-unit>
        <trans-unit id="c99d868d531dfe2e187331de7c9920869268ba47" translate="yes" xml:space="preserve">
          <source>Determine whether a process is currently running.</source>
          <target state="translated">确定当前是否有进程在运行。</target>
        </trans-unit>
        <trans-unit id="99d55d3a5192933572c51fc97adc04872c6e44fb" translate="yes" xml:space="preserve">
          <source>Determine whether a stream is read-only.</source>
          <target state="translated">确定一个流是否为只读。</target>
        </trans-unit>
        <trans-unit id="bb3bfcd347f5d65568dc838197e09ecfe4405770" translate="yes" xml:space="preserve">
          <source>Determine whether a task has exited because an exception was thrown.</source>
          <target state="translated">判断一个任务是否因为抛出异常而退出。</target>
        </trans-unit>
        <trans-unit id="1e9c8b3c9b00278b97a8c0d5b0fc7fce932e91f2" translate="yes" xml:space="preserve">
          <source>Determine whether a task has exited.</source>
          <target state="translated">判断任务是否已经退出。</target>
        </trans-unit>
        <trans-unit id="ee4f20f770f5b5e7e4b7c777d2abc2362e36eec7" translate="yes" xml:space="preserve">
          <source>Determine whether a task has started executing.</source>
          <target state="translated">确定任务是否已经开始执行。</target>
        </trans-unit>
        <trans-unit id="dbdbed66108e712ca570ca19802dded33371c86c" translate="yes" xml:space="preserve">
          <source>Determine whether all hexadecimal digits of the given &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; are zero.</source>
          <target state="translated">确定给定&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; 的&lt;/a&gt;所有十六进制数字是否均为零。</target>
        </trans-unit>
        <trans-unit id="0dfd98a60f425f1bd73d9aa1e23986ceb9637766" translate="yes" xml:space="preserve">
          <source>Determine whether an item is in the given collection, in the sense that it is &lt;a href=&quot;../math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; to one of the values generated by iterating over the collection. Returns a &lt;code&gt;Bool&lt;/code&gt; value, except if &lt;code&gt;item&lt;/code&gt; is &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;collection&lt;/code&gt; contains &lt;code&gt;missing&lt;/code&gt; but not &lt;code&gt;item&lt;/code&gt;, in which case &lt;code&gt;missing&lt;/code&gt; is returned (&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;, matching the behavior of &lt;a href=&quot;#Base.any-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">确定某项是否在给定的集合中，从某种意义上说，它&lt;a href=&quot;../math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;通过迭代集合而生成的值之一。返回一个 &lt;code&gt;Bool&lt;/code&gt; 值，除非 &lt;code&gt;item&lt;/code&gt; 被&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;collection&lt;/code&gt; 包含 &lt;code&gt;missing&lt;/code&gt; ，但没有 &lt;code&gt;item&lt;/code&gt; ，在这种情况下， &lt;code&gt;missing&lt;/code&gt; 返回（&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;三值逻辑&lt;/a&gt;，匹配的行为，&lt;a href=&quot;#Base.any-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt;与&lt;a href=&quot;../math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="f6d70bfc36332f33986741370b3658ad50a9e6d2" translate="yes" xml:space="preserve">
          <source>Determine whether an object - such as a stream or timer &amp;ndash; is not yet closed. Once an object is closed, it will never produce a new event. However, since a closed stream may still have data to read in its buffer, use &lt;a href=&quot;#Base.eof&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; to check for the ability to read data. Use the &lt;code&gt;FileWatching&lt;/code&gt; package to be notified when a stream might be writable or readable.</source>
          <target state="translated">确定对象（例如流或计时器）是否尚未关闭。一旦对象关闭，它将永远不会产生新的事件。但是，由于封闭流可能仍需要在其缓冲区中读取数据，因此请使用&lt;a href=&quot;#Base.eof&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt;检查读取数据的能力。当流可写或可读时，使用 &lt;code&gt;FileWatching&lt;/code&gt; 包来通知。</target>
        </trans-unit>
        <trans-unit id="c1c47e9d804e0d7ec711f5a7dc45b0f9649cfc5c" translate="yes" xml:space="preserve">
          <source>Determine whether every element of &lt;code&gt;a&lt;/code&gt; is also in &lt;code&gt;b&lt;/code&gt;, using &lt;a href=&quot;#Base.in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;#Base.in&quot;&gt; &lt;code&gt;in&lt;/code&gt; 来&lt;/a&gt;确定 &lt;code&gt;a&lt;/code&gt; 的每个元素是否也在 &lt;code&gt;b&lt;/code&gt; 中。</target>
        </trans-unit>
        <trans-unit id="2d0d549fe24528bf78c84130cee192a01bb9ecc1" translate="yes" xml:space="preserve">
          <source>Determine whether predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements of &lt;code&gt;itr&lt;/code&gt;, returning &lt;code&gt;false&lt;/code&gt; as soon as the first item in &lt;code&gt;itr&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt; is encountered (short-circuiting).</source>
          <target state="translated">确定是否谓词 &lt;code&gt;p&lt;/code&gt; 回报 &lt;code&gt;true&lt;/code&gt; 为所有元素 &lt;code&gt;itr&lt;/code&gt; ，返回 &lt;code&gt;false&lt;/code&gt; ，只要在第一项 &lt;code&gt;itr&lt;/code&gt; 针对 &lt;code&gt;p&lt;/code&gt; 回报 &lt;code&gt;false&lt;/code&gt; 遇到（短路）。</target>
        </trans-unit>
        <trans-unit id="289250da1a3e0fba909534e3d914f76f0a83beed" translate="yes" xml:space="preserve">
          <source>Determine whether predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for any elements of &lt;code&gt;itr&lt;/code&gt;, returning &lt;code&gt;true&lt;/code&gt; as soon as the first item in &lt;code&gt;itr&lt;/code&gt; for which &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; is encountered (short-circuiting).</source>
          <target state="translated">确定是否谓词 &lt;code&gt;p&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 对的任何元素 &lt;code&gt;itr&lt;/code&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ，只要在第一项 &lt;code&gt;itr&lt;/code&gt; 对于其中 &lt;code&gt;p&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 遇到（短路）。</target>
        </trans-unit>
        <trans-unit id="4e07dd9d2d99ac05e19db056ad10a6038f6ab62f" translate="yes" xml:space="preserve">
          <source>Determine whether the first argument is a substring of the second. If &lt;code&gt;needle&lt;/code&gt; is a regular expression, checks whether &lt;code&gt;haystack&lt;/code&gt; contains a match.</source>
          <target state="translated">确定第一个参数是否是第二个参数的子字符串。如果 &lt;code&gt;needle&lt;/code&gt; 是正则表达式，请检查 &lt;code&gt;haystack&lt;/code&gt; 是否包含匹配项。</target>
        </trans-unit>
        <trans-unit id="403cb69fbefe8bf1c1819ec0d30c5d58c5b0c9c0" translate="yes" xml:space="preserve">
          <source>Determine whether the given generic function has a method applicable to the given arguments.</source>
          <target state="translated">确定给定的通用函数是否有适用于给定参数的方法。</target>
        </trans-unit>
        <trans-unit id="0ecef99ec060f64932d509baf07fae2312bff5c4" translate="yes" xml:space="preserve">
          <source>Determine whether the given generic function has a method matching the given &lt;code&gt;Tuple&lt;/code&gt; of argument types with the upper bound of world age given by &lt;code&gt;world&lt;/code&gt;.</source>
          <target state="translated">确定给定泛型函数是否具有给定的匹配方法， &lt;code&gt;Tuple&lt;/code&gt; 参数类型与上限由下式给出世界时代的 &lt;code&gt;world&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="01f095f8302e33c7d6757828961774c336ec1955" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; has exactly one possible instance; for example, a struct type with no fields.</source>
          <target state="translated">确定类型 &lt;code&gt;T&lt;/code&gt; 是否恰好有一个可能的实例；例如，没有字段的结构类型。</target>
        </trans-unit>
        <trans-unit id="c941aa3f3fab8b12bb7a8d06c55662ccc88bd232" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; is a concrete type, meaning it could have direct instances (values &lt;code&gt;x&lt;/code&gt; such that &lt;code&gt;typeof(x) === T&lt;/code&gt;).</source>
          <target state="translated">确定类型 &lt;code&gt;T&lt;/code&gt; 是否为具体类型，这意味着它可以具有直接实例（值 &lt;code&gt;x&lt;/code&gt; ，使得 &lt;code&gt;typeof(x) === T&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="889b4cea5aec1b8d20d423a69b232b4fd8819ea1" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; is a tuple &quot;leaf type&quot;, meaning it could appear as a type signature in dispatch and has no subtypes (or supertypes) which could appear in a call.</source>
          <target state="translated">确定类型 &lt;code&gt;T&lt;/code&gt; 是否为元组&amp;ldquo;叶类型&amp;rdquo;，这意味着它可以作为调度中的类型签名出现，并且没有子类型（或超类型）出现在调用中。</target>
        </trans-unit>
        <trans-unit id="fa3f743073996b313a25298a5751df1facc9b8ca" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; was declared as a primitive type (i.e. using the &lt;code&gt;primitive&lt;/code&gt; keyword).</source>
          <target state="translated">确定类型 &lt;code&gt;T&lt;/code&gt; 是否被声明为原始类型（即，使用 &lt;code&gt;primitive&lt;/code&gt; 关键字）。</target>
        </trans-unit>
        <trans-unit id="6ee927617e47ab19a9ab3eb7c45e5b0d181e4bde" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; was declared as a struct type (i.e. using the &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;mutable struct&lt;/code&gt; keyword).</source>
          <target state="translated">确定是否将类型 &lt;code&gt;T&lt;/code&gt; 声明为结构类型（即使用 &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;mutable struct&lt;/code&gt; 关键字）。</target>
        </trans-unit>
        <trans-unit id="def23a2949c492af43c949112c644220edb792b0" translate="yes" xml:space="preserve">
          <source>Determine whether type &lt;code&gt;T&lt;/code&gt; was declared as an abstract type (i.e. using the &lt;code&gt;abstract&lt;/code&gt; keyword).</source>
          <target state="translated">确定类型 &lt;code&gt;T&lt;/code&gt; 是否被声明为抽象类型（即，使用 &lt;code&gt;abstract&lt;/code&gt; 关键字）。</target>
        </trans-unit>
        <trans-unit id="c539db0242f115c7ed3b7d7b88baedfee34884e5" translate="yes" xml:space="preserve">
          <source>Determines if &lt;code&gt;a&lt;/code&gt; is a subset of, but not equal to, &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">确定 &lt;code&gt;a&lt;/code&gt; 是否是b的子集，但不等于 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d032dc0874cd5aa654968e088fbfba6befcfba64" translate="yes" xml:space="preserve">
          <source>Develop your package</source>
          <target state="translated">开发您的软件包</target>
        </trans-unit>
        <trans-unit id="a5ecd286faa5677726aa083151af6be4709cf28e" translate="yes" xml:space="preserve">
          <source>Diagonal</source>
          <target state="translated">Diagonal</target>
        </trans-unit>
        <trans-unit id="c8ddb8ebd7c9ec0a8a6949cc24c26e5db1b28da8" translate="yes" xml:space="preserve">
          <source>Diagonal matrix</source>
          <target state="translated">对角线矩阵</target>
        </trans-unit>
        <trans-unit id="fb2b46a0ed907e0e3db008e1bf7296f2fa0ee640" translate="yes" xml:space="preserve">
          <source>Diameter Sign</source>
          <target state="translated">直径标志</target>
        </trans-unit>
        <trans-unit id="4e77b4c7440f9011313e26852abc6646e08bbb9b" translate="yes" xml:space="preserve">
          <source>Diamond Operator</source>
          <target state="translated">钻石操作员</target>
        </trans-unit>
        <trans-unit id="cd59a157c959e21a5d8e33ac498a1543408b829b" translate="yes" xml:space="preserve">
          <source>Diamond Shape With A Dot Inside</source>
          <target state="translated">鑽石形狀與一個點內</target>
        </trans-unit>
        <trans-unit id="c979f35c2213ac9ce29d392a08f0cd02319be0a8" translate="yes" xml:space="preserve">
          <source>Diamond With Bottom Half Black</source>
          <target state="translated">鑽石配下半部黑色</target>
        </trans-unit>
        <trans-unit id="ea9affe495abd6a6b0faedd90651c9dfc7405bbb" translate="yes" xml:space="preserve">
          <source>Diamond With Left Half Black</source>
          <target state="translated">鑽石配左半邊黑色</target>
        </trans-unit>
        <trans-unit id="d5a38a7e34ff056cfbb328f94dd973e13e1b0f13" translate="yes" xml:space="preserve">
          <source>Diamond With Right Half Black</source>
          <target state="translated">鑽石配右半邊黑色</target>
        </trans-unit>
        <trans-unit id="17906bab8d1dd54d5285d04d3ccda2d66fc279ee" translate="yes" xml:space="preserve">
          <source>Diamond With Top Half Black</source>
          <target state="translated">鑽石配上半部黑色</target>
        </trans-unit>
        <trans-unit id="3550a4a38c380e14df95457cd13d6dabbd0c0b20" translate="yes" xml:space="preserve">
          <source>Dict</source>
          <target state="translated">Dict</target>
        </trans-unit>
        <trans-unit id="51b0613ac049d8459b061ee15aa8ba7ae5794479" translate="yes" xml:space="preserve">
          <source>Dictionaries</source>
          <target state="translated">Dictionaries</target>
        </trans-unit>
        <trans-unit id="226686711adc28abd6b28df88e06bd40f70ef31c" translate="yes" xml:space="preserve">
          <source>Dictionaries may also be created with generators. For example, &lt;code&gt;Dict(i =&amp;gt; f(i) for i = 1:10)&lt;/code&gt;.</source>
          <target state="translated">字典也可以用生成器创建。例如， &lt;code&gt;Dict(i =&amp;gt; f(i) for i = 1:10)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6c2228958df07965c5237ec0fac371cc94b97788" translate="yes" xml:space="preserve">
          <source>Dictionary and set types, or in general anything that depends on the output of a &lt;code&gt;hash(key)&lt;/code&gt; method, are a trickier case. In the common case where the keys are numbers, strings, symbols, ranges, &lt;code&gt;Expr&lt;/code&gt;, or compositions of these types (via arrays, tuples, sets, pairs, etc.) they are safe to precompile. However, for a few other key types, such as &lt;code&gt;Function&lt;/code&gt; or &lt;code&gt;DataType&lt;/code&gt; and generic user-defined types where you haven't defined a &lt;code&gt;hash&lt;/code&gt; method, the fallback &lt;code&gt;hash&lt;/code&gt; method depends on the memory address of the object (via its &lt;code&gt;objectid&lt;/code&gt;) and hence may change from run to run. If you have one of these key types, or if you aren't sure, to be safe you can initialize this dictionary from within your &lt;code&gt;__init__&lt;/code&gt; function. Alternatively, you can use the &lt;a href=&quot;../../base/collections/index#Base.IdDict&quot;&gt;&lt;code&gt;IdDict&lt;/code&gt;&lt;/a&gt; dictionary type, which is specially handled by precompilation so that it is safe to initialize at compile-time.</source>
          <target state="translated">字典和集合类型，或者通常取决于 &lt;code&gt;hash(key)&lt;/code&gt; 方法输出的任何东西，都比较棘手。在键是数字，字符串，符号，范围， &lt;code&gt;Expr&lt;/code&gt; 或这些类型的组合（通过数组，元组，集合，对等）的常见情况下，可以安全地进行预编译。但是，对于其他一些键类型，例如 &lt;code&gt;Function&lt;/code&gt; 或 &lt;code&gt;DataType&lt;/code&gt; 以及尚未定义 &lt;code&gt;hash&lt;/code&gt; 方法的通用用户定义类型，后备 &lt;code&gt;hash&lt;/code&gt; 方法取决于对象的内存地址（通过其 &lt;code&gt;objectid&lt;/code&gt; )），因此可能会随着运行而变化。如果您具有这些键类型之一，或者不确定，则可以从 &lt;code&gt;__init__&lt;/code&gt; 函数中初始化此字典。或者，您可以使用&lt;a href=&quot;../../base/collections/index#Base.IdDict&quot;&gt; &lt;code&gt;IdDict&lt;/code&gt; &lt;/a&gt;字典类型，该类型由预编译专门处理，因此可以在编译时进行初始化。</target>
        </trans-unit>
        <trans-unit id="dacf1b614fb594526af821a4a2be88604306ed44" translate="yes" xml:space="preserve">
          <source>Dictionary keys can also be tab completed:</source>
          <target state="translated">字典键也可以是标签完成。</target>
        </trans-unit>
        <trans-unit id="292578b4b7085196841d56350bbddafbc7e6d0bb" translate="yes" xml:space="preserve">
          <source>Die Face-1</source>
          <target state="translated">脸-1</target>
        </trans-unit>
        <trans-unit id="cdbec4e00ebdd8c20f5ee4b56ba58057d7e2ec05" translate="yes" xml:space="preserve">
          <source>Die Face-2</source>
          <target state="translated">脸部二</target>
        </trans-unit>
        <trans-unit id="d78fd4a1c34901a2159f7a6e530555949f39daa7" translate="yes" xml:space="preserve">
          <source>Die Face-3</source>
          <target state="translated">颜值三</target>
        </trans-unit>
        <trans-unit id="1e5a67accc5d5c25093b0a623f892e361241ae52" translate="yes" xml:space="preserve">
          <source>Die Face-4</source>
          <target state="translated">Face-4</target>
        </trans-unit>
        <trans-unit id="e4d4e7bdf84edf508b41bc9d8e314d7651a257a0" translate="yes" xml:space="preserve">
          <source>Die Face-5</source>
          <target state="translated">Face-5</target>
        </trans-unit>
        <trans-unit id="14e325af88a46d7bc2d653104317a2958dfaba04" translate="yes" xml:space="preserve">
          <source>Die Face-6</source>
          <target state="translated">Face-6</target>
        </trans-unit>
        <trans-unit id="795ba7a0ce5c58cba555b57bd85cef8a4746539c" translate="yes" xml:space="preserve">
          <source>Difference Between</source>
          <target state="translated">之间的区别</target>
        </trans-unit>
        <trans-unit id="633fcadd9a7c828edcf878f9058272e3b3e9a1b6" translate="yes" xml:space="preserve">
          <source>Difference Between + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">+组合长实心叠加/无间隔长斜线叠加的区别</target>
        </trans-unit>
        <trans-unit id="ffeb2f798ecd4de58b7035483cdc6373fe3233be" translate="yes" xml:space="preserve">
          <source>DimensionMismatch</source>
          <target state="translated">DimensionMismatch</target>
        </trans-unit>
        <trans-unit id="2321ae657c8e83f68d4d7ddbffafe794a2164af3" translate="yes" xml:space="preserve">
          <source>Dims</source>
          <target state="translated">Dims</target>
        </trans-unit>
        <trans-unit id="4fb82b30b311a8f2f43ae3e857d3584f2edb16f3" translate="yes" xml:space="preserve">
          <source>Direct Hit</source>
          <target state="translated">直击</target>
        </trans-unit>
        <trans-unit id="7a610c61d6e2df53d7f7028820759b68c9cdf43a" translate="yes" xml:space="preserve">
          <source>Direct comparison of the numerator and denominator is generally not necessary, since the standard arithmetic and comparison operations are defined for rational values:</source>
          <target state="translated">一般不需要直接比较分子和分母,因为标准的算术和比较运算是针对有理值定义的。</target>
        </trans-unit>
        <trans-unit id="39702e75a6cf1386c6592825cf3db26e55cb9c65" translate="yes" xml:space="preserve">
          <source>Direct construction of &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt; objects with value arguments is powerful, but &lt;code&gt;Expr&lt;/code&gt; constructors can be tedious compared to &quot;normal&quot; Julia syntax. As an alternative, Julia allows &lt;em&gt;interpolation&lt;/em&gt; of literals or expressions into quoted expressions. Interpolation is indicated by a prefix &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">使用值参数直接构造&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; &lt;/a&gt;对象的功能强大，但是与&amp;ldquo;常规&amp;rdquo; Julia语法相比， &lt;code&gt;Expr&lt;/code&gt; 构造函数可能很繁琐。作为替代，朱莉娅允许&lt;em&gt;插&lt;/em&gt;文字或表达式为引用的表达式。内插由前缀 &lt;code&gt;$&lt;/code&gt; 表示。</target>
        </trans-unit>
        <trans-unit id="e859576baf1df468abfbf6259c6df055e40c3865" translate="yes" xml:space="preserve">
          <source>Disable Ctrl-C handler during execution of a function on the current task, for calling external code that may call julia code that is not interrupt safe. Intended to be called using &lt;code&gt;do&lt;/code&gt; block syntax as follows:</source>
          <target state="translated">在当前任务上执行功能期间，请禁用Ctrl-C处理程序，以调用可能调用不安全中断的julia代码的外部代码。打算使用 &lt;code&gt;do&lt;/code&gt; 块语法进行调用，如下所示：</target>
        </trans-unit>
        <trans-unit id="ee5dfa8ba600cccab503575e49577656d5630d4b" translate="yes" xml:space="preserve">
          <source>Disable all log messages at log levels equal to or less than &lt;code&gt;level&lt;/code&gt;. This is a &lt;em&gt;global&lt;/em&gt; setting, intended to make debug logging extremely cheap when disabled.</source>
          <target state="translated">禁用等于或小于 &lt;code&gt;level&lt;/code&gt; 的日志级别的所有日志消息。这是一个&lt;em&gt;全局&lt;/em&gt;设置，旨在使禁用时的调试日志记录非常便宜。</target>
        </trans-unit>
        <trans-unit id="1f365e08d11c88067711c3e53ea5deda45baac76" translate="yes" xml:space="preserve">
          <source>Disable the GC, return previous state as int</source>
          <target state="translated">禁用GC,返回之前的状态为int。</target>
        </trans-unit>
        <trans-unit id="3978fd69ff9f5062319ab42f51b05b0aaac345ec" translate="yes" xml:space="preserve">
          <source>Disabling garbage collection should be used only with caution, as it can cause memory use to grow without bound.</source>
          <target state="translated">禁用垃圾收集只能谨慎使用,因为它会导致内存使用量无限制增长。</target>
        </trans-unit>
        <trans-unit id="876921bd8b5ab79222657dd5d0af64f5515603c3" translate="yes" xml:space="preserve">
          <source>Disallow or enable unsafe floating point optimizations (overrides @fastmath declaration)</source>
          <target state="translated">不允许或启用不安全的浮点优化(覆盖@fastmath声明)</target>
        </trans-unit>
        <trans-unit id="07015f11ed3e9662a9e3d218f4e32dd41d124545" translate="yes" xml:space="preserve">
          <source>Disappointed But Relieved Face</source>
          <target state="translated">失望但欣慰的脸</target>
        </trans-unit>
        <trans-unit id="5bd8d20ec17f66810be7ac160730554259c2f393" translate="yes" xml:space="preserve">
          <source>Disappointed Face</source>
          <target state="translated">失望的脸</target>
        </trans-unit>
        <trans-unit id="4818d3085918b897bb5940cbb6aa6b457b2f50f0" translate="yes" xml:space="preserve">
          <source>Discard the &lt;code&gt;payload&lt;/code&gt; credential from begin re-used in future authentication. Should only be called when authentication was unsuccessful.</source>
          <target state="translated">从开始在将来的身份验证中重新使用时就丢弃 &lt;code&gt;payload&lt;/code&gt; 凭证。仅在身份验证失败时调用。</target>
        </trans-unit>
        <trans-unit id="00ebed03f3d4a5ea390c18a91bde6105d1ff3fe5" translate="yes" xml:space="preserve">
          <source>Dispatch on one argument at a time</source>
          <target state="translated">每次发送一个论点</target>
        </trans-unit>
        <trans-unit id="8960408fead9aa75ceb4aee4e800ae4451c96002" translate="yes" xml:space="preserve">
          <source>Display equations</source>
          <target state="translated">显示方程</target>
        </trans-unit>
        <trans-unit id="1df9a6dc2c17a0ba7bdb95b8c1b94c8fdab3317c" translate="yes" xml:space="preserve">
          <source>Display version information</source>
          <target state="translated">显示版本信息</target>
        </trans-unit>
        <trans-unit id="1b44f5625aa08ea5a916469ddb5a30b0fa48b533" translate="yes" xml:space="preserve">
          <source>Distributed Computing</source>
          <target state="translated">分布式计算</target>
        </trans-unit>
        <trans-unit id="f252c2edb60c7c9bd29fb3437997c2ebdcdd803a" translate="yes" xml:space="preserve">
          <source>Distributed computing</source>
          <target state="translated">分布式计算</target>
        </trans-unit>
        <trans-unit id="75f5d856b9b1768edecb8d197541ee2cc802dc7e" translate="yes" xml:space="preserve">
          <source>Distributed programming in Julia is built on two primitives: &lt;em&gt;remote references&lt;/em&gt; and &lt;em&gt;remote calls&lt;/em&gt;. A remote reference is an object that can be used from any process to refer to an object stored on a particular process. A remote call is a request by one process to call a certain function on certain arguments on another (possibly the same) process.</source>
          <target state="translated">Julia中的分布式编程基于两个原语构建：&lt;em&gt;远程引用&lt;/em&gt;和&lt;em&gt;远程调用&lt;/em&gt;。远程引用是一个对象，可以从任何进程使用它来引用存储在特定进程中的对象。远程调用是一个进程对另一个（可能是相同的）进程上某些自变量调用某个函数的请求。</target>
        </trans-unit>
        <trans-unit id="96434486b44e8b445920f8cfba7cc682d4dfc2db" translate="yes" xml:space="preserve">
          <source>Distributed.@distributed</source>
          <target state="translated">Distributed.@distributed</target>
        </trans-unit>
        <trans-unit id="1a098ddbdf75655cc9180cdc7b6440448f09568d" translate="yes" xml:space="preserve">
          <source>Distributed.@everywhere</source>
          <target state="translated">Distributed.@everywhere</target>
        </trans-unit>
        <trans-unit id="efbc6617cb7c0815e2ea5d73b544497289152b89" translate="yes" xml:space="preserve">
          <source>Distributed.@fetch</source>
          <target state="translated">Distributed.@fetch</target>
        </trans-unit>
        <trans-unit id="59e5edc22d0bcf1af2630d1052c482cdb408f391" translate="yes" xml:space="preserve">
          <source>Distributed.@fetchfrom</source>
          <target state="translated">Distributed.@fetchfrom</target>
        </trans-unit>
        <trans-unit id="af80c7ed9530f2c7e180576f660e05a18aca79bb" translate="yes" xml:space="preserve">
          <source>Distributed.@spawn</source>
          <target state="translated">Distributed.@spawn</target>
        </trans-unit>
        <trans-unit id="da346ed14fde6d1e8361fba9d749980594b148e9" translate="yes" xml:space="preserve">
          <source>Distributed.@spawnat</source>
          <target state="translated">Distributed.@spawnat</target>
        </trans-unit>
        <trans-unit id="cd85ed1cfd9557c350600fd95dc13b777ce3fe85" translate="yes" xml:space="preserve">
          <source>Distributed.AbstractWorkerPool</source>
          <target state="translated">Distributed.AbstractWorkerPool</target>
        </trans-unit>
        <trans-unit id="36af7ae728088acd59fb1d45bca438f98c665d8c" translate="yes" xml:space="preserve">
          <source>Distributed.CachingPool</source>
          <target state="translated">Distributed.CachingPool</target>
        </trans-unit>
        <trans-unit id="22d34851a0eba645399be62bb28846b66823289e" translate="yes" xml:space="preserve">
          <source>Distributed.ClusterManager</source>
          <target state="translated">Distributed.ClusterManager</target>
        </trans-unit>
        <trans-unit id="b0cd727f1d03d744fc280a981fa5b9190b5153e2" translate="yes" xml:space="preserve">
          <source>Distributed.Future</source>
          <target state="translated">Distributed.Future</target>
        </trans-unit>
        <trans-unit id="ea257e0490c136ba7d3090abaaf36e4a0ca8d1a7" translate="yes" xml:space="preserve">
          <source>Distributed.RemoteChannel</source>
          <target state="translated">Distributed.RemoteChannel</target>
        </trans-unit>
        <trans-unit id="4d0b601e8fedd7c09e5642c005570fc3a0473253" translate="yes" xml:space="preserve">
          <source>Distributed.RemoteException</source>
          <target state="translated">Distributed.RemoteException</target>
        </trans-unit>
        <trans-unit id="c33f096540905e1e5959bf9b4378500ff82ca6f7" translate="yes" xml:space="preserve">
          <source>Distributed.WorkerConfig</source>
          <target state="translated">Distributed.WorkerConfig</target>
        </trans-unit>
        <trans-unit id="8ce81814c48804e7f821d092b3e46ed846c5880d" translate="yes" xml:space="preserve">
          <source>Distributed.WorkerPool</source>
          <target state="translated">Distributed.WorkerPool</target>
        </trans-unit>
        <trans-unit id="164200aa0d1a016ac5f4b6fd50cd6698574608fa" translate="yes" xml:space="preserve">
          <source>Distributed.addprocs()</source>
          <target state="translated">Distributed.addprocs()</target>
        </trans-unit>
        <trans-unit id="173fea4d9a9f7c07219a7da8c1a00ac502393d87" translate="yes" xml:space="preserve">
          <source>Distributed.channel_from_id()</source>
          <target state="translated">Distributed.channel_from_id()</target>
        </trans-unit>
        <trans-unit id="226386f83311a76a8211104c4edb61bcf3c75680" translate="yes" xml:space="preserve">
          <source>Distributed.clear!()</source>
          <target state="translated">Distributed.clear!()</target>
        </trans-unit>
        <trans-unit id="a5baf4d266ab8829135539799e42c9d4c0ead21b" translate="yes" xml:space="preserve">
          <source>Distributed.cluster_cookie()</source>
          <target state="translated">Distributed.cluster_cookie()</target>
        </trans-unit>
        <trans-unit id="dc2fa5e71cd9d9b639010b97b4740edbdbb81f56" translate="yes" xml:space="preserve">
          <source>Distributed.default_worker_pool()</source>
          <target state="translated">Distributed.default_worker_pool()</target>
        </trans-unit>
        <trans-unit id="41cdeb4d12b400fba432add756ae6ef656d520c6" translate="yes" xml:space="preserve">
          <source>Distributed.init_worker()</source>
          <target state="translated">Distributed.init_worker()</target>
        </trans-unit>
        <trans-unit id="869d052c4a2a06e70c0d44a1851f76e2f966103b" translate="yes" xml:space="preserve">
          <source>Distributed.interrupt()</source>
          <target state="translated">Distributed.interrupt()</target>
        </trans-unit>
        <trans-unit id="3ea59996280ad714503bd21db89af3ed0ddb5c84" translate="yes" xml:space="preserve">
          <source>Distributed.launch()</source>
          <target state="translated">Distributed.launch()</target>
        </trans-unit>
        <trans-unit id="e48c1d69b737782cf0cea89c2b07847840fe9c44" translate="yes" xml:space="preserve">
          <source>Distributed.manage()</source>
          <target state="translated">Distributed.manage()</target>
        </trans-unit>
        <trans-unit id="05a5ebfc426c1bd80394e5bf665a5fda064e34c4" translate="yes" xml:space="preserve">
          <source>Distributed.myid()</source>
          <target state="translated">Distributed.myid()</target>
        </trans-unit>
        <trans-unit id="1fdb70cf3ecb7a0aa097a69946d096f32726c49e" translate="yes" xml:space="preserve">
          <source>Distributed.nprocs()</source>
          <target state="translated">Distributed.nprocs()</target>
        </trans-unit>
        <trans-unit id="394af0754f2238a05c08dd8f6b6874db18b285c7" translate="yes" xml:space="preserve">
          <source>Distributed.nworkers()</source>
          <target state="translated">Distributed.nworkers()</target>
        </trans-unit>
        <trans-unit id="b85b64151cf4f4ae19fb8cf053b4d77736d64609" translate="yes" xml:space="preserve">
          <source>Distributed.pmap()</source>
          <target state="translated">Distributed.pmap()</target>
        </trans-unit>
        <trans-unit id="f379e8118bd0a8163fb093113934cf152437fe6b" translate="yes" xml:space="preserve">
          <source>Distributed.process_messages()</source>
          <target state="translated">Distributed.process_messages()</target>
        </trans-unit>
        <trans-unit id="c462fb87629ce04f2ef477ae483ec589605d65cb" translate="yes" xml:space="preserve">
          <source>Distributed.procs()</source>
          <target state="translated">Distributed.procs()</target>
        </trans-unit>
        <trans-unit id="328c4408c15f7286da8f5406178cc12a69c58b5c" translate="yes" xml:space="preserve">
          <source>Distributed.remote()</source>
          <target state="translated">Distributed.remote()</target>
        </trans-unit>
        <trans-unit id="7dd1a0dd0aaef1f1d7ae03091ad26ce2253cd598" translate="yes" xml:space="preserve">
          <source>Distributed.remote_do()</source>
          <target state="translated">Distributed.remote_do()</target>
        </trans-unit>
        <trans-unit id="9fb42670c69fd280316f8b2f0ea16afea4c810c9" translate="yes" xml:space="preserve">
          <source>Distributed.remotecall()</source>
          <target state="translated">Distributed.remotecall()</target>
        </trans-unit>
        <trans-unit id="a67cc8bf59dc3c96f9aef1e9811c3479c8b46371" translate="yes" xml:space="preserve">
          <source>Distributed.remotecall_fetch()</source>
          <target state="translated">Distributed.remotecall_fetch()</target>
        </trans-unit>
        <trans-unit id="4dc4a66df6faa8cff424bd89060037bf46df26cd" translate="yes" xml:space="preserve">
          <source>Distributed.remotecall_wait()</source>
          <target state="translated">Distributed.remotecall_wait()</target>
        </trans-unit>
        <trans-unit id="eba77344fe6aa6904b303120e58ddda491f4bb1a" translate="yes" xml:space="preserve">
          <source>Distributed.remoteref_id()</source>
          <target state="translated">Distributed.remoteref_id()</target>
        </trans-unit>
        <trans-unit id="6313c54bbc81e913c52e3ed8676831966128d19d" translate="yes" xml:space="preserve">
          <source>Distributed.rmprocs()</source>
          <target state="translated">Distributed.rmprocs()</target>
        </trans-unit>
        <trans-unit id="a4a167c1c83070eb12b10d5a804750df20f010d6" translate="yes" xml:space="preserve">
          <source>Distributed.start_worker()</source>
          <target state="translated">Distributed.start_worker()</target>
        </trans-unit>
        <trans-unit id="2c121b43490b3f755d6bc8ec22e6e6d7a5a177c3" translate="yes" xml:space="preserve">
          <source>Distributed.worker_id_from_socket()</source>
          <target state="translated">Distributed.worker_id_from_socket()</target>
        </trans-unit>
        <trans-unit id="b65a1ff0a0efeb8eb1c566e4e444c8fdab89ba3a" translate="yes" xml:space="preserve">
          <source>Distributed.workers()</source>
          <target state="translated">Distributed.workers()</target>
        </trans-unit>
        <trans-unit id="01f3300548243049d963e19250b86a197066f883" translate="yes" xml:space="preserve">
          <source>Divide each entry in an array &lt;code&gt;A&lt;/code&gt; by a scalar &lt;code&gt;b&lt;/code&gt; overwriting &lt;code&gt;A&lt;/code&gt; in-place. Use &lt;a href=&quot;#LinearAlgebra.ldiv!&quot;&gt;&lt;code&gt;ldiv!&lt;/code&gt;&lt;/a&gt; to divide scalar from left.</source>
          <target state="translated">将数组 &lt;code&gt;A&lt;/code&gt; 中的每个条目除以就地覆盖 &lt;code&gt;A&lt;/code&gt; 的标量 &lt;code&gt;b&lt;/code&gt; 。使用&lt;a href=&quot;#LinearAlgebra.ldiv!&quot;&gt; &lt;code&gt;ldiv!&lt;/code&gt; &lt;/a&gt;从左除标量。</target>
        </trans-unit>
        <trans-unit id="6c5227a4411a33c2b0a2917ac123771fc4d90473" translate="yes" xml:space="preserve">
          <source>Divide each entry in an array &lt;code&gt;B&lt;/code&gt; by a scalar &lt;code&gt;a&lt;/code&gt; overwriting &lt;code&gt;B&lt;/code&gt; in-place. Use &lt;a href=&quot;#LinearAlgebra.rdiv!&quot;&gt;&lt;code&gt;rdiv!&lt;/code&gt;&lt;/a&gt; to divide scalar from right.</source>
          <target state="translated">划分在一个阵列中的每个条目 &lt;code&gt;B&lt;/code&gt; 通过一个标量 &lt;code&gt;a&lt;/code&gt; 覆盖 &lt;code&gt;B&lt;/code&gt; 就地。使用&lt;a href=&quot;#LinearAlgebra.rdiv!&quot;&gt; &lt;code&gt;rdiv!&lt;/code&gt; &lt;/a&gt;从右除标量。</target>
        </trans-unit>
        <trans-unit id="161ea982f22680e7ef2021310dae639abf1326db" translate="yes" xml:space="preserve">
          <source>Divide two integers or rational numbers, giving a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; result.</source>
          <target state="translated">除以两个整数或有理数，得出&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;结果。</target>
        </trans-unit>
        <trans-unit id="7ad94500626afb00127de3b189a93eaca8744de4" translate="yes" xml:space="preserve">
          <source>Divides</source>
          <target state="translated">Divides</target>
        </trans-unit>
        <trans-unit id="e2b8ca950fd114a793b53e8c5e48ea524b845d7d" translate="yes" xml:space="preserve">
          <source>Division Sign</source>
          <target state="translated">部门标志</target>
        </trans-unit>
        <trans-unit id="361a7f8376269b5b650c0bf43907fe05e5712a64" translate="yes" xml:space="preserve">
          <source>Division Times</source>
          <target state="translated">分部时代</target>
        </trans-unit>
        <trans-unit id="5b52981f5797afbc7daabde2522293d6f287e47f" translate="yes" xml:space="preserve">
          <source>Division errors</source>
          <target state="translated">除法错误</target>
        </trans-unit>
        <trans-unit id="036fd78d0d2fb9786e807e79b9ec1fe9b9f0ab1d" translate="yes" xml:space="preserve">
          <source>Division functions</source>
          <target state="translated">该司的职能</target>
        </trans-unit>
        <trans-unit id="71beaa328c19038dd8d3afa0450399489fcfa5bb" translate="yes" xml:space="preserve">
          <source>Dizzy Face</source>
          <target state="translated">眩晕的脸</target>
        </trans-unit>
        <trans-unit id="271c431f3d459dae90731776142efcc9efba3a41" translate="yes" xml:space="preserve">
          <source>Dizzy Symbol</source>
          <target state="translated">眩晕符号</target>
        </trans-unit>
        <trans-unit id="a72324023e9231ddd2559ff9084345bc66092df6" translate="yes" xml:space="preserve">
          <source>Do I want to use a release, beta, or nightly version of Julia?</source>
          <target state="translated">我是想使用Julia的发行版、测试版还是夜间版?</target>
        </trans-unit>
        <trans-unit id="177063caa465e3c01afe5bd0f45d14afb04f44d4" translate="yes" xml:space="preserve">
          <source>Do I want to use the Stable, LTS, or nightly version of Julia?</source>
          <target state="translated">我是想使用稳定版、LTS版还是夜间版的Julia?</target>
        </trans-unit>
        <trans-unit id="3db8faa5c93df04fc1f4cad1a3ef3da7ae3d5746" translate="yes" xml:space="preserve">
          <source>Do Not Litter Symbol</source>
          <target state="translated">请勿乱扔垃圾的标志</target>
        </trans-unit>
        <trans-unit id="89ad2cd843ab0ac775fb58a33130e35a9ebce093" translate="yes" xml:space="preserve">
          <source>Do any final processing necessary for the given testset. This is called by the &lt;code&gt;@testset&lt;/code&gt; infrastructure after a test block executes. One common use for this function is to record the testset to the parent's results list, using &lt;code&gt;get_testset&lt;/code&gt;.</source>
          <target state="translated">对给定的测试集进行任何必要的最终处理。测试块执行后， &lt;code&gt;@testset&lt;/code&gt; 基础结构调用此方法。此功能的一种常见用法是使用 &lt;code&gt;get_testset&lt;/code&gt; 将测试集记录到父级的结果列表中。</target>
        </trans-unit>
        <trans-unit id="97fbb621c645ddfec0a076ad4bcef012b8a293b3" translate="yes" xml:space="preserve">
          <source>Do not call this on a handle that's already owned by some other part of the system.</source>
          <target state="translated">不要在系统的其他部分已经拥有的句柄上调用这个。</target>
        </trans-unit>
        <trans-unit id="5c71b02f0c824517c5e8eef286d8968d841fb69a" translate="yes" xml:space="preserve">
          <source>Do not repeat yourself.</source>
          <target state="translated">不要重复自己。</target>
        </trans-unit>
        <trans-unit id="d599d6549afb353871b063d385c2f5bb866c837d" translate="yes" xml:space="preserve">
          <source>Do not write &lt;code&gt;x-&amp;gt;f(x)&lt;/code&gt;</source>
          <target state="translated">不要写 &lt;code&gt;x-&amp;gt;f(x)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92d896974fd993f8e2ce0773bf383e98442586f1" translate="yes" xml:space="preserve">
          <source>Do you see that &lt;code&gt;global&lt;/code&gt; annotation in there? Hideous. Obviously this situation could not be tolerated. But seriously, there are two main issues with requiring &lt;code&gt;global&lt;/code&gt; for this kind of top-level code:</source>
          <target state="translated">您在其中看到该 &lt;code&gt;global&lt;/code&gt; 注释吗？可怕。显然，这种情况是不能容忍的。但是，严重的是，对于此类顶级代码，需要 &lt;code&gt;global&lt;/code&gt; 存在两个主要问题：</target>
        </trans-unit>
        <trans-unit id="e93ac681d8ce5c9e419103f5e01e286f7a37841c" translate="yes" xml:space="preserve">
          <source>Do-Block Syntax for Function Arguments</source>
          <target state="translated">函数参数的Do-Block语法</target>
        </trans-unit>
        <trans-unit id="68a4194227be4ab74bc3d32363417c0fc1f30055" translate="yes" xml:space="preserve">
          <source>Docs</source>
          <target state="translated">Docs</target>
        </trans-unit>
        <trans-unit id="951ee5040959da5427656e41d49e8acd4aff75ee" translate="yes" xml:space="preserve">
          <source>Docs.@html_str</source>
          <target state="translated">Docs.@html_str</target>
        </trans-unit>
        <trans-unit id="94211649e4d7dde7192ce3db00bbee03bb4c3e61" translate="yes" xml:space="preserve">
          <source>Docs.@text_str</source>
          <target state="translated">Docs.@text_str</target>
        </trans-unit>
        <trans-unit id="f065f6fa6c71fdad19f0dcd2a0e82257bad77265" translate="yes" xml:space="preserve">
          <source>Docs.apropos()</source>
          <target state="translated">Docs.apropos()</target>
        </trans-unit>
        <trans-unit id="723c13f6eed0956ec36bf5aa24f80dc095fc1a62" translate="yes" xml:space="preserve">
          <source>Docstrings are edited using the same tools as code. Therefore, the same conventions should apply. It is advised to add line breaks after 92 characters.</source>
          <target state="translated">Docstrings的编辑工具与代码相同。因此,同样的惯例也应适用。建议在92个字符后添加换行符。</target>
        </trans-unit>
        <trans-unit id="e776eddce7eaaeece43c53e417a63fdb2d0645c4" translate="yes" xml:space="preserve">
          <source>Docstrings are edited using the same tools as code. Therefore, the same conventions should apply. It is recommended that lines are at most 92 characters wide.</source>
          <target state="translated">Docstrings的编辑工具与代码相同。因此,应适用相同的惯例。建议行数最多为92个字符宽。</target>
        </trans-unit>
        <trans-unit id="e741da5c63f67a2059af6310cbefc21c3af104c4" translate="yes" xml:space="preserve">
          <source>Doctests are enabled by &lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt;&lt;code&gt;Documenter.jl&lt;/code&gt;&lt;/a&gt;. For more detailed documentation see Documenter's &lt;a href=&quot;https://juliadocs.github.io/Documenter.jl/&quot;&gt;manual&lt;/a&gt;.</source>
          <target state="translated">Doctests由&lt;a href=&quot;https://github.com/JuliaDocs/Documenter.jl&quot;&gt; &lt;code&gt;Documenter.jl&lt;/code&gt; &lt;/a&gt;启用。有关更多详细文档，请参见《文档编制者&lt;a href=&quot;https://juliadocs.github.io/Documenter.jl/&quot;&gt;手册》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="1e2dea0c3337740d3f32a466769f4f1557f19738" translate="yes" xml:space="preserve">
          <source>Documentation can be accessed at the REPL or in &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt; by typing &lt;code&gt;?&lt;/code&gt; followed by the name of a function or macro, and pressing &lt;code&gt;Enter&lt;/code&gt;. For example,</source>
          <target state="translated">文档可以在REPL或访问&lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;通过打字 &lt;code&gt;?&lt;/code&gt; 然后是函数或宏的名称，然后按 &lt;code&gt;Enter&lt;/code&gt; 。例如，</target>
        </trans-unit>
        <trans-unit id="82b208253644825d49a694f47eb50e7748d27ea9" translate="yes" xml:space="preserve">
          <source>Documentation is interpreted as &lt;a href=&quot;https://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt;, so you can use indentation and code fences to delimit code examples from text. Technically, any object can be associated with any other as metadata; Markdown happens to be the default, but one can construct other string macros and pass them to the &lt;code&gt;@doc&lt;/code&gt; macro just as well.</source>
          <target state="translated">文档被解释为&lt;a href=&quot;https://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt;，因此您可以使用缩进和代码围栏从文本中分隔代码示例。从技术上讲，任何对象都可以与其他任何对象关联为元数据。Markdown碰巧是默认值，但是可以构造其他字符串宏并将它们也传递给 &lt;code&gt;@doc&lt;/code&gt; 宏。</target>
        </trans-unit>
        <trans-unit id="e29764eb22ce628960d24b7b3d44fcb0f2a8006f" translate="yes" xml:space="preserve">
          <source>Documentation written in non-toplevel blocks, such as &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, and &lt;code&gt;let&lt;/code&gt;, is added to the documentation system as blocks are evaluated. For example:</source>
          <target state="translated">在评估块时，将以非顶级块（例如 &lt;code&gt;begin&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; )编写的文档添加到文档系统中。例如：</target>
        </trans-unit>
        <trans-unit id="09a6ee5d426664cb977432c68132607a67141e74" translate="yes" xml:space="preserve">
          <source>Documenting a &lt;code&gt;baremodule&lt;/code&gt; by placing a docstring above the expression automatically imports &lt;code&gt;@doc&lt;/code&gt; into the module. These imports must be done manually when the module expression is not documented. Empty &lt;code&gt;baremodule&lt;/code&gt;s cannot be documented.</source>
          <target state="translated">记录一个 &lt;code&gt;baremodule&lt;/code&gt; 通过将文档字符串表达上述自动导入 &lt;code&gt;@doc&lt;/code&gt; 到模块。如果未记录模块表达式，则必须手动完成这些导入。空的 &lt;code&gt;baremodule&lt;/code&gt; 无法记录。</target>
        </trans-unit>
        <trans-unit id="f1c8feebb8a44bc5cc0f0c846a0cafe1673c9da0" translate="yes" xml:space="preserve">
          <source>Does Not Contain As Member</source>
          <target state="translated">不包含作为成员</target>
        </trans-unit>
        <trans-unit id="74e9b7a7bc4ad3a9d5021e1c8ba39f60a57b9c8c" translate="yes" xml:space="preserve">
          <source>Does Not Contain As Normal Subgroup</source>
          <target state="translated">不包含正常的子组</target>
        </trans-unit>
        <trans-unit id="0df9d21ab128eedeaeee897e18031c8a630062be" translate="yes" xml:space="preserve">
          <source>Does Not Contain As Normal Subgroup Or Equal</source>
          <target state="translated">不包含正常分组或平等分组</target>
        </trans-unit>
        <trans-unit id="721845ae9c87c5bd1e7a959be4a879539ccf8539" translate="yes" xml:space="preserve">
          <source>Does Not Divide</source>
          <target state="translated">不分家</target>
        </trans-unit>
        <trans-unit id="c17ae6741920f232f1c4dcd981a0894fd4701fd6" translate="yes" xml:space="preserve">
          <source>Does Not Force</source>
          <target state="translated">不强制</target>
        </trans-unit>
        <trans-unit id="dc76e22dd1ef5959f4590996c3e850e4ccf3c6d5" translate="yes" xml:space="preserve">
          <source>Does Not Precede</source>
          <target state="translated">不在前</target>
        </trans-unit>
        <trans-unit id="4431ed14e25542ca1903fbe4b11f8f7bc472370c" translate="yes" xml:space="preserve">
          <source>Does Not Precede Or Equal</source>
          <target state="translated">不先于或等于</target>
        </trans-unit>
        <trans-unit id="91186e108fed6b3b33f14387bc2f31c57be5dd04" translate="yes" xml:space="preserve">
          <source>Does Not Prove</source>
          <target state="translated">不证明</target>
        </trans-unit>
        <trans-unit id="55e9fb335c67326e83c89cc57e089d55541e089b" translate="yes" xml:space="preserve">
          <source>Does Not Succeed</source>
          <target state="translated">不成功</target>
        </trans-unit>
        <trans-unit id="864c65788d1e762c167b1c1749d733189def96f8" translate="yes" xml:space="preserve">
          <source>Does Not Succeed Or Equal</source>
          <target state="translated">不成功或不平等</target>
        </trans-unit>
        <trans-unit id="b866865be01a47a38a8b8e70d9eeb4d216a5889b" translate="yes" xml:space="preserve">
          <source>Dog</source>
          <target state="translated">Dog</target>
        </trans-unit>
        <trans-unit id="822ff2e44dfcb5851a482f2660f9271d7240e881" translate="yes" xml:space="preserve">
          <source>Dog Face</source>
          <target state="translated">狗脸</target>
        </trans-unit>
        <trans-unit id="b352a36f62c29eefc7c223c1e54b444dc8e064a4" translate="yes" xml:space="preserve">
          <source>Dolphin</source>
          <target state="translated">Dolphin</target>
        </trans-unit>
        <trans-unit id="dc77173b84d82a0765230e0c6ba75588bedb585c" translate="yes" xml:space="preserve">
          <source>Don't expose unsafe operations at the interface level</source>
          <target state="translated">不要在接口层暴露不安全的操作。</target>
        </trans-unit>
        <trans-unit id="c4688105e50f89983dad6151436e12d874f53866" translate="yes" xml:space="preserve">
          <source>Don't overload methods of base container types</source>
          <target state="translated">不要重载基本容器类型的方法。</target>
        </trans-unit>
        <trans-unit id="62d0b49edcf8320dfc997b5ca5fb5ff7268edc1a" translate="yes" xml:space="preserve">
          <source>Don't overuse &lt;code&gt;...&lt;/code&gt;</source>
          <target state="translated">不要过度使用 &lt;code&gt;...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1789c363ea41e44595afb63415ed7c18193fd84" translate="yes" xml:space="preserve">
          <source>Don't overuse macros</source>
          <target state="translated">不要过度使用宏</target>
        </trans-unit>
        <trans-unit id="a3e15a90504e4d80a1ded72545703d3f5a6fc9a2" translate="yes" xml:space="preserve">
          <source>Don't overuse try-catch</source>
          <target state="translated">不要过度使用try-catch</target>
        </trans-unit>
        <trans-unit id="215b5f92cd2b36c13430ff90f6606631f634f2bc" translate="yes" xml:space="preserve">
          <source>Don't parenthesize conditions</source>
          <target state="translated">不要把条件括起来</target>
        </trans-unit>
        <trans-unit id="2036ef4184745cfc73dab730959249e97cb41653" translate="yes" xml:space="preserve">
          <source>Don't use unnecessary static parameters</source>
          <target state="translated">不要使用不必要的静态参数</target>
        </trans-unit>
        <trans-unit id="478d47b06dda44ac540199c073ea7b055bb29d18" translate="yes" xml:space="preserve">
          <source>Door</source>
          <target state="translated">Door</target>
        </trans-unit>
        <trans-unit id="ddd653c95e261e24af6fe24fd7e994e1b732c61e" translate="yes" xml:space="preserve">
          <source>Dot Minus</source>
          <target state="translated">点减</target>
        </trans-unit>
        <trans-unit id="da4c9b7a4607f6acdefd66aa7034f05ebdd357f8" translate="yes" xml:space="preserve">
          <source>Dot Operator</source>
          <target state="translated">点运算符</target>
        </trans-unit>
        <trans-unit id="e46bcabadc79a669ff9fab524e27e4536bcce723" translate="yes" xml:space="preserve">
          <source>Dot Plus</source>
          <target state="translated">小点加</target>
        </trans-unit>
        <trans-unit id="1e0712c9faa91162cb0a7e3519494eabc42057de" translate="yes" xml:space="preserve">
          <source>Dot Syntax for Vectorizing Functions</source>
          <target state="translated">矢量化函数的点语法</target>
        </trans-unit>
        <trans-unit id="8ec4c1c9e271c057f7f2ceb82454ca0b4248d7e0" translate="yes" xml:space="preserve">
          <source>Dot function for two complex vectors consisting of &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;Y&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;.</source>
          <target state="translated">点函数由两个复矢量 &lt;code&gt;n&lt;/code&gt; 数组的元素 &lt;code&gt;X&lt;/code&gt; 与步幅 &lt;code&gt;incx&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 阵列的元件 &lt;code&gt;Y&lt;/code&gt; 与步幅 &lt;code&gt;incy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6408bc206b479d599e65eaa3c639906fa5347eee" translate="yes" xml:space="preserve">
          <source>Dot function for two complex vectors, consisting of &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;U&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;, conjugating the first vector.</source>
          <target state="translated">点函数为两个复向量，由 &lt;code&gt;n&lt;/code&gt; 阵列的元件 &lt;code&gt;X&lt;/code&gt; 步幅 &lt;code&gt;incx&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 阵列的元件 &lt;code&gt;U&lt;/code&gt; 与步幅 &lt;code&gt;incy&lt;/code&gt; ，缀合第一矢量。</target>
        </trans-unit>
        <trans-unit id="822ddf4ed45b75296e27e23d4dd969f4b0e252cc" translate="yes" xml:space="preserve">
          <source>Dot product of two vectors consisting of &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;X&lt;/code&gt; with stride &lt;code&gt;incx&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; elements of array &lt;code&gt;Y&lt;/code&gt; with stride &lt;code&gt;incy&lt;/code&gt;.</source>
          <target state="translated">由两个向量的点积 &lt;code&gt;n&lt;/code&gt; 数组的元素 &lt;code&gt;X&lt;/code&gt; 与步幅 &lt;code&gt;incx&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 阵列的元件 &lt;code&gt;Y&lt;/code&gt; 与步幅 &lt;code&gt;incy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ae687eeec34004bd7083ef738bcbb2dfd35f355d" translate="yes" xml:space="preserve">
          <source>Dotted Circle</source>
          <target state="translated">点阵圈</target>
        </trans-unit>
        <trans-unit id="9214357a4af6ad858e4d42896c3023c43dce64c9" translate="yes" xml:space="preserve">
          <source>Dotted Fence</source>
          <target state="translated">点阵围栏</target>
        </trans-unit>
        <trans-unit id="b81c82773994373a1d09d7aae50399f0672d3ba9" translate="yes" xml:space="preserve">
          <source>Dotted Square</source>
          <target state="translated">虚线方块</target>
        </trans-unit>
        <trans-unit id="90b6dc25270ca8eeeb19a2a120979959174221d5" translate="yes" xml:space="preserve">
          <source>Double Colon Equal</source>
          <target state="translated">双结肠平等</target>
        </trans-unit>
        <trans-unit id="a97175043bff5b5c88676e311e52a67c0ae1d95b" translate="yes" xml:space="preserve">
          <source>Double Curly Loop</source>
          <target state="translated">双卷圈</target>
        </trans-unit>
        <trans-unit id="ce6ed1da949d6a90c7025acd0315d2ec7e76fdf2" translate="yes" xml:space="preserve">
          <source>Double Dagger</source>
          <target state="translated">双匕首</target>
        </trans-unit>
        <trans-unit id="3ebfb9a6d6fb0aa10351fcdd8ebc9f2ad2e8e0b0" translate="yes" xml:space="preserve">
          <source>Double Exclamation Mark</source>
          <target state="translated">双感叹号</target>
        </trans-unit>
        <trans-unit id="7206e7e84b3ec15528c9043d5518fb76c3d3b663" translate="yes" xml:space="preserve">
          <source>Double Integral</source>
          <target state="translated">双积分</target>
        </trans-unit>
        <trans-unit id="2f4ad5067d03e83537e91298699b3a861f6334a3" translate="yes" xml:space="preserve">
          <source>Double Intersection</source>
          <target state="translated">双重交叉口</target>
        </trans-unit>
        <trans-unit id="f63efa914d18f07e57920324f154194f8b80e71d" translate="yes" xml:space="preserve">
          <source>Double Logical And</source>
          <target state="translated">双重逻辑和</target>
        </trans-unit>
        <trans-unit id="31d51825a917859490089a0f53f017ee347ae47e" translate="yes" xml:space="preserve">
          <source>Double Logical Or</source>
          <target state="translated">双逻辑或</target>
        </trans-unit>
        <trans-unit id="54ca4b3ab79a1f77836fc85afeeb3989b5791f4d" translate="yes" xml:space="preserve">
          <source>Double Nested Greater-Than</source>
          <target state="translated">双嵌套大于等于</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
