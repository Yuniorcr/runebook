<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="c646760ea02101dd2c78e156bd67fbc1e7939279" translate="yes" xml:space="preserve">
          <source>Double Nested Less-Than With Underbar</source>
          <target state="translated">双重嵌套带下筋的少筋</target>
        </trans-unit>
        <trans-unit id="da273e33c1593b23cc1baf0841e4eb0696481ab6" translate="yes" xml:space="preserve">
          <source>Double Plus</source>
          <target state="translated">双加</target>
        </trans-unit>
        <trans-unit id="a4eb216c233e5e31eaaa029b5a6659a1175205bf" translate="yes" xml:space="preserve">
          <source>Double Precedes</source>
          <target state="translated">双先</target>
        </trans-unit>
        <trans-unit id="94596af0b897ecaa403e2b29d5442ffc485744fa" translate="yes" xml:space="preserve">
          <source>Double Prime</source>
          <target state="translated">双优</target>
        </trans-unit>
        <trans-unit id="d4bb3033b81e3e5bf5fe1b3d95ec1e84254a8648" translate="yes" xml:space="preserve">
          <source>Double Square Intersection</source>
          <target state="translated">双方十字路口</target>
        </trans-unit>
        <trans-unit id="1cdd297d02a50e98fc796a7bb474ae2cbf5b341e" translate="yes" xml:space="preserve">
          <source>Double Square Union</source>
          <target state="translated">双方联盟</target>
        </trans-unit>
        <trans-unit id="8bec3a437a2b0935e9467004616a12d8b9bac5b1" translate="yes" xml:space="preserve">
          <source>Double Subset</source>
          <target state="translated">双子集</target>
        </trans-unit>
        <trans-unit id="1f4f518e5cace96063fb6e4842b29d3c3a0bf8a6" translate="yes" xml:space="preserve">
          <source>Double Succeeds</source>
          <target state="translated">双喜临门</target>
        </trans-unit>
        <trans-unit id="f64b087e350913f39a60133fc102b9f0f94189cc" translate="yes" xml:space="preserve">
          <source>Double Superset</source>
          <target state="translated">双超组合</target>
        </trans-unit>
        <trans-unit id="ca2705c17942fca00d32bc39c06af31f76ecd340" translate="yes" xml:space="preserve">
          <source>Double Union</source>
          <target state="translated">双联</target>
        </trans-unit>
        <trans-unit id="f7eafda32018eb8216c74731243d8bcf503ebd15" translate="yes" xml:space="preserve">
          <source>Double Vertical Bar Double Right Turnstile</source>
          <target state="translated">双立杆双右转门</target>
        </trans-unit>
        <trans-unit id="4e0938d334e779c3d4385d240fa933a4aa60bab1" translate="yes" xml:space="preserve">
          <source>Double Vertical Bar Left Turnstile</source>
          <target state="translated">双垂直杆左转门</target>
        </trans-unit>
        <trans-unit id="bc9a2fa0502c305faf46fd54f952ef44d055b6f5" translate="yes" xml:space="preserve">
          <source>Double Vertical Line / Double Vertical Bar</source>
          <target state="translated">双垂直线/双垂直杆</target>
        </trans-unit>
        <trans-unit id="0c24baa17889b7dd7c44e226a4bfc6668ff9bdeb" translate="yes" xml:space="preserve">
          <source>Double-Ended Multimap</source>
          <target state="translated">双端多图</target>
        </trans-unit>
        <trans-unit id="5fab79944c7fc8e86540423312b6958371754001" translate="yes" xml:space="preserve">
          <source>Double-Line Equal To Or Greater-Than</source>
          <target state="translated">双线等于或大于</target>
        </trans-unit>
        <trans-unit id="09e23fb3335770ae7a2fab59103015e6204ac1a9" translate="yes" xml:space="preserve">
          <source>Double-Line Equal To Or Less-Than</source>
          <target state="translated">双线等于或小于</target>
        </trans-unit>
        <trans-unit id="81443422e1dbb876dc01a2f2800e2f313209c209" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Equal To Or Greater-Than</source>
          <target state="translated">双线斜线等于或大于此线</target>
        </trans-unit>
        <trans-unit id="298a11392e511e8c4817b6337e56afa525bb120d" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Equal To Or Less-Than</source>
          <target state="translated">双线斜线等于或小于此线</target>
        </trans-unit>
        <trans-unit id="a39c2d49b33b8171f0335f4d62c054ebe50e2949" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Greater-Than Or Equal To</source>
          <target state="translated">双线斜线大于或等于</target>
        </trans-unit>
        <trans-unit id="1a8936fc614fa8b11ad34af0ae168622fd04d79a" translate="yes" xml:space="preserve">
          <source>Double-Line Slanted Less-Than Or Equal To</source>
          <target state="translated">小于或等于双线斜线。</target>
        </trans-unit>
        <trans-unit id="5fcd17070ab099bf225ba4ec089d10cd5befd0d0" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital C / Double-Struck C</source>
          <target state="translated">双击大写字母C/双击字母C。</target>
        </trans-unit>
        <trans-unit id="7fe3d74449be0c8a16270734ac281959d2434acb" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Gamma</source>
          <target state="translated">双击资本伽马</target>
        </trans-unit>
        <trans-unit id="2bc51683b00bc656e8387c2a5971b20973b2e68d" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital H / Double-Struck H</source>
          <target state="translated">双击大写字母H/双击字母H。</target>
        </trans-unit>
        <trans-unit id="77f2a8e846cb9408cb76519191f8677c811ec6c2" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital N / Double-Struck N</source>
          <target state="translated">双击大写字母N/双击字母N。</target>
        </trans-unit>
        <trans-unit id="3d9ff0d995aa97605586bd26332422b375e0d4da" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital P / Double-Struck P</source>
          <target state="translated">双击大写字母P/双击P。</target>
        </trans-unit>
        <trans-unit id="8e8bbccb682c6db82d059047113f028c1e9e4935" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Pi</source>
          <target state="translated">双重击打的资本皮</target>
        </trans-unit>
        <trans-unit id="43fb013cca9c4a4a8b1a6e51423770297967de57" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Q / Double-Struck Q</source>
          <target state="translated">大写字母Q/大写字母Q。</target>
        </trans-unit>
        <trans-unit id="a7d9b7fa137bc84092b6dbae26b457a275ea3624" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital R / Double-Struck R</source>
          <target state="translated">双击大写字母R/双击R。</target>
        </trans-unit>
        <trans-unit id="31b7923fbdad31f1ec3bcd8a5c5055fe73e937d5" translate="yes" xml:space="preserve">
          <source>Double-Struck Capital Z / Double-Struck Z</source>
          <target state="translated">双击大写字母Z/双击字母Z。</target>
        </trans-unit>
        <trans-unit id="22b10852f9529884fb8ade41480e3db571e4dab1" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Capital D</source>
          <target state="translated">双击大写字母D</target>
        </trans-unit>
        <trans-unit id="96df4e88f2bfb97c5cf111112b6793cdf4963d06" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small D</source>
          <target state="translated">双击斜体小D</target>
        </trans-unit>
        <trans-unit id="0ba03aedaaff708d7df7636d4094ce50661bf52b" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small E</source>
          <target state="translated">双击斜体小E</target>
        </trans-unit>
        <trans-unit id="33fd110b35ce2a0d08df3e940965ae2eec73859f" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small I</source>
          <target state="translated">双击斜体小I</target>
        </trans-unit>
        <trans-unit id="e7b00a215e1cd74b1415dfeb4e53c76b770b6715" translate="yes" xml:space="preserve">
          <source>Double-Struck Italic Small J</source>
          <target state="translated">双击斜体小J</target>
        </trans-unit>
        <trans-unit id="78f6994be690e96f674586766d03abe261a0d6c0" translate="yes" xml:space="preserve">
          <source>Double-Struck N-Ary Summation</source>
          <target state="translated">双击N-Ary Summation (双击)</target>
        </trans-unit>
        <trans-unit id="7522a251652bf308c1e54e228103454ad9e38cf3" translate="yes" xml:space="preserve">
          <source>Double-Struck Small Gamma</source>
          <target state="translated">双击小伽马</target>
        </trans-unit>
        <trans-unit id="e9209c0ddacbb74a712ae08d417871541bc2ed5d" translate="yes" xml:space="preserve">
          <source>Double-Struck Small Pi</source>
          <target state="translated">双击小皮</target>
        </trans-unit>
        <trans-unit id="e32b900891654ad41d9a370dd7666e75c72537ec" translate="yes" xml:space="preserve">
          <source>Doughnut</source>
          <target state="translated">Doughnut</target>
        </trans-unit>
        <trans-unit id="74b33dde33775abd34211cfb4e20f9d6bde3c7a7" translate="yes" xml:space="preserve">
          <source>Down Right Diagonal Ellipsis</source>
          <target state="translated">右下角对角线省略号</target>
        </trans-unit>
        <trans-unit id="b621fc7da134ad1633ff77f53544dd0b2c6c5e6d" translate="yes" xml:space="preserve">
          <source>Down Tack</source>
          <target state="translated">下攻</target>
        </trans-unit>
        <trans-unit id="05c8ca1a817444b080cfc3aca96ff10f7d2bd3d0" translate="yes" xml:space="preserve">
          <source>Down arrow, &lt;code&gt;^N&lt;/code&gt;</source>
          <target state="translated">向下箭头， &lt;code&gt;^N&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c538452cf7c33c2e1a7c6f852e565ccc86225406" translate="yes" xml:space="preserve">
          <source>Down-Pointing Red Triangle</source>
          <target state="translated">下尖红三角</target>
        </trans-unit>
        <trans-unit id="8bfd316beaffb49e3a9febd43df2eb2cb5afaace" translate="yes" xml:space="preserve">
          <source>Down-Pointing Small Red Triangle</source>
          <target state="translated">下尖小红三角</target>
        </trans-unit>
        <trans-unit id="17cff6f253715144bf846cc6cb0ca961d48c99f6" translate="yes" xml:space="preserve">
          <source>Downdate a Cholesky factorization &lt;code&gt;C&lt;/code&gt; with the vector &lt;code&gt;v&lt;/code&gt;. If &lt;code&gt;A = C.U'C.U&lt;/code&gt; then &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; but the computation of &lt;code&gt;CC&lt;/code&gt; only uses &lt;code&gt;O(n^2)&lt;/code&gt; operations.</source>
          <target state="translated">Downdate一个Cholesky分解 &lt;code&gt;C&lt;/code&gt; 与向量 &lt;code&gt;v&lt;/code&gt; 。如果 &lt;code&gt;A = C.U'C.U&lt;/code&gt; 则 &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; 但 &lt;code&gt;CC&lt;/code&gt; 的计算仅使用 &lt;code&gt;O(n^2)&lt;/code&gt; 运算。</target>
        </trans-unit>
        <trans-unit id="b97c3860e18211639f16883b11f27c780f8f632f" translate="yes" xml:space="preserve">
          <source>Downdate a Cholesky factorization &lt;code&gt;C&lt;/code&gt; with the vector &lt;code&gt;v&lt;/code&gt;. If &lt;code&gt;A = C.U'C.U&lt;/code&gt; then &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; but the computation of &lt;code&gt;CC&lt;/code&gt; only uses &lt;code&gt;O(n^2)&lt;/code&gt; operations. The input factorization &lt;code&gt;C&lt;/code&gt; is updated in place such that on exit &lt;code&gt;C == CC&lt;/code&gt;. The vector &lt;code&gt;v&lt;/code&gt; is destroyed during the computation.</source>
          <target state="translated">Downdate一个Cholesky分解 &lt;code&gt;C&lt;/code&gt; 与向量 &lt;code&gt;v&lt;/code&gt; 。如果 &lt;code&gt;A = C.U'C.U&lt;/code&gt; 则 &lt;code&gt;CC = cholesky(C.U'C.U - v*v')&lt;/code&gt; 但 &lt;code&gt;CC&lt;/code&gt; 的计算仅使用 &lt;code&gt;O(n^2)&lt;/code&gt; 运算。输入因式分解 &lt;code&gt;C&lt;/code&gt; 被适当地更新，使得在出口 &lt;code&gt;C == CC&lt;/code&gt; 。向量 &lt;code&gt;v&lt;/code&gt; 在计算过程中被破坏。</target>
        </trans-unit>
        <trans-unit id="d64fb6577c643a1a98bcc4d17dd77adc7d4f3749" translate="yes" xml:space="preserve">
          <source>Download a file from the given url, optionally renaming it to the given local file name. If no filename is given this will download into a randomly-named file in your temp directory. Note that this function relies on the availability of external tools such as &lt;code&gt;curl&lt;/code&gt;, &lt;code&gt;wget&lt;/code&gt; or &lt;code&gt;fetch&lt;/code&gt; to download the file and is provided for convenience. For production use or situations in which more options are needed, please use a package that provides the desired functionality instead.</source>
          <target state="translated">从给定的URL下载文件，可以选择将其重命名为给定的本地文件名。如果未提供文件名，它将下载到您的temp目录中的一个随机命名的文件中。请注意，此功能依赖于外部工具（例如 &lt;code&gt;curl&lt;/code&gt; ， &lt;code&gt;wget&lt;/code&gt; 或 &lt;code&gt;fetch&lt;/code&gt; )的可用性来下载文件，该功能是为了方便起见而提供的。对于生产用途或需要更多选项的情况，请改用提供所需功能的软件包。</target>
        </trans-unit>
        <trans-unit id="08c3c7d3645a4ce6730f3721ad47fc2949dc976a" translate="yes" xml:space="preserve">
          <source>Downwards Arrow / Down Arrow</source>
          <target state="translated">向下箭头/向下箭头</target>
        </trans-unit>
        <trans-unit id="7dce0d557028c5dea3dace158554e15d9784698b" translate="yes" xml:space="preserve">
          <source>Downwards Arrow From Bar / Down Arrow From Bar</source>
          <target state="translated">从栏杆向下的箭头/从栏杆向下的箭头。</target>
        </trans-unit>
        <trans-unit id="0d1345aef883b3624d484df6c78fa1499f363962" translate="yes" xml:space="preserve">
          <source>Downwards Arrow Leftwards Of Upwards Arrow</source>
          <target state="translated">向下箭头 向上箭头的左边</target>
        </trans-unit>
        <trans-unit id="2156bac33a07bff1c6168c184044e461147f3221" translate="yes" xml:space="preserve">
          <source>Downwards Arrow To Bar</source>
          <target state="translated">向下箭头至栏杆</target>
        </trans-unit>
        <trans-unit id="6a3f0e1b85e70e46f52c461b297ce3b234dd2b8e" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Corner Leftwards / Down Arrow With Corner Left</source>
          <target state="translated">向左转角的向下箭头/向左转角的向下箭头</target>
        </trans-unit>
        <trans-unit id="22f12c6b38c168555c766d9ecd689bee73798e7b" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Double Stroke / Down Arrow With Double Stroke</source>
          <target state="translated">向下箭头双笔画/向下箭头双笔画</target>
        </trans-unit>
        <trans-unit id="3e70b3fbb5e1272dbfb2768c6abc80ebc34f5538" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Horizontal Stroke</source>
          <target state="translated">水平方向的向下箭头</target>
        </trans-unit>
        <trans-unit id="c1bc962d484f0e77f2bb2b3688fdfa2d1422bc61" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Tip Leftwards / Down Arrow With Tip Left</source>
          <target state="translated">向左向下的箭头/向左向下的箭头。</target>
        </trans-unit>
        <trans-unit id="6f17c4c1d048a9705300c820118cf36a53d197eb" translate="yes" xml:space="preserve">
          <source>Downwards Arrow With Tip Rightwards / Down Arrow With Tip Right</source>
          <target state="translated">向下箭头,尖端向右/向下箭头,尖端向右</target>
        </trans-unit>
        <trans-unit id="77827f24b06007c8351d7b42f91be0b4d539c6de" translate="yes" xml:space="preserve">
          <source>Downwards Black Arrow</source>
          <target state="translated">向下的黑箭</target>
        </trans-unit>
        <trans-unit id="b75b010ebb988c0b894244b49f47de83c298a210" translate="yes" xml:space="preserve">
          <source>Downwards Dashed Arrow / Down Dashed Arrow</source>
          <target state="translated">向下虚线箭头/向下虚线箭头。</target>
        </trans-unit>
        <trans-unit id="b052c2e01abe8207481638ce404112cf6c895155" translate="yes" xml:space="preserve">
          <source>Downwards Double Arrow / Down Double Arrow</source>
          <target state="translated">向下双箭头/向下双箭头</target>
        </trans-unit>
        <trans-unit id="39618206cc6f04a2548c6e3a46f1c96431d17934" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left Beside Downwards Harpoon With Barb Right</source>
          <target state="translated">向下的鱼叉,左面向下的鱼叉,右面的鱼叉。</target>
        </trans-unit>
        <trans-unit id="61e7d9beabf27ce96043173d50a1ffbcb3c8f195" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left Beside Upwards Harpoon With Barb Right</source>
          <target state="translated">左边向下的鱼叉,右边向上的鱼叉,右边的鱼叉。</target>
        </trans-unit>
        <trans-unit id="8f99b76aec3d61f79f81cc67881ebb3880b49671" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left From Bar</source>
          <target state="translated">向下的鱼叉,带倒钩,从棒子左边开始</target>
        </trans-unit>
        <trans-unit id="0a957078126f861ff70d4cccc6ee4961501ca412" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Left To Bar</source>
          <target state="translated">向下的鱼叉,带倒钩的左至棒子。</target>
        </trans-unit>
        <trans-unit id="20016dc34aed751d644d5eba1c2ce94f4ccb571f" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Leftwards / Down Harpoon With Barb Left</source>
          <target state="translated">向左的下鱼叉/向左的下鱼叉。</target>
        </trans-unit>
        <trans-unit id="43ff08d740eada07edb33d8b4d43a32fe54cdb0c" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Right From Bar</source>
          <target state="translated">向下的鱼叉,带着倒钩,从棒子的右边开始</target>
        </trans-unit>
        <trans-unit id="fdcd989ee2f4eed7638bcc66aefc50676e2d0de3" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Right To Bar</source>
          <target state="translated">向下的鱼叉,带倒钩,右至杠。</target>
        </trans-unit>
        <trans-unit id="70698ae85402133e06db357acf28e4adb5132348" translate="yes" xml:space="preserve">
          <source>Downwards Harpoon With Barb Rightwards / Down Harpoon With Barb Right</source>
          <target state="translated">向右的下鱼叉/向右的下鱼叉。</target>
        </trans-unit>
        <trans-unit id="e991bdc2966ff71e9f056a8cb1f209c18137ee66" translate="yes" xml:space="preserve">
          <source>Downwards Paired Arrows / Down Paired Arrows</source>
          <target state="translated">向下的配对箭头/向下的配对箭头。</target>
        </trans-unit>
        <trans-unit id="708fb5fb1095e517bca56d05c3a07607b86eea24" translate="yes" xml:space="preserve">
          <source>Downwards Quadruple Arrow</source>
          <target state="translated">向下的四重箭</target>
        </trans-unit>
        <trans-unit id="7832bc44c221f296a0a3557341bf5711ce0ad13e" translate="yes" xml:space="preserve">
          <source>Downwards Triple Arrow</source>
          <target state="translated">向下三箭</target>
        </trans-unit>
        <trans-unit id="71c2a3e9e5d53ca7e448be0dc997a3840d8ffbe4" translate="yes" xml:space="preserve">
          <source>Downwards Two Headed Arrow / Down Two Headed Arrow</source>
          <target state="translated">向下双头箭/向下双头箭。</target>
        </trans-unit>
        <trans-unit id="20bd273f7536e79d1e647c7a4805a10cc0a6024f" translate="yes" xml:space="preserve">
          <source>Downwards White Arrow / White Down Arrow</source>
          <target state="translated">向下白箭/向下白箭</target>
        </trans-unit>
        <trans-unit id="dee70c16d9a7402c3ff7c179d417c02524182f20" translate="yes" xml:space="preserve">
          <source>Downwards Zigzag Arrow / Down Zigzag Arrow</source>
          <target state="translated">向下曲折箭/向下曲折箭。</target>
        </trans-unit>
        <trans-unit id="0f0c13b35658b4610aac908bd6f900baccfacc2c" translate="yes" xml:space="preserve">
          <source>Drafting Point Rightwards Arrow / Drafting Point Right Arrow</source>
          <target state="translated">绘图点向右箭头/绘图点向右箭头。</target>
        </trans-unit>
        <trans-unit id="eb22c5e28adf024cfee08804c00ddb9ac2973892" translate="yes" xml:space="preserve">
          <source>Dragon</source>
          <target state="translated">Dragon</target>
        </trans-unit>
        <trans-unit id="b1d5fd0950f3316f4c616ebe016d1f72cbdff89e" translate="yes" xml:space="preserve">
          <source>Dragon Face</source>
          <target state="translated">龙颜</target>
        </trans-unit>
        <trans-unit id="f61e33bf74dc6cb23e31a4742f4452d5d238daaf" translate="yes" xml:space="preserve">
          <source>Dress</source>
          <target state="translated">Dress</target>
        </trans-unit>
        <trans-unit id="eaae1cbe655bd67615f32293502367c2637ee817" translate="yes" xml:space="preserve">
          <source>Dromedary Camel</source>
          <target state="translated">单峰驼</target>
        </trans-unit>
        <trans-unit id="f9b83daeec2460cd138ef6a2f12cc6f1f9046683" translate="yes" xml:space="preserve">
          <source>Droplet</source>
          <target state="translated">Droplet</target>
        </trans-unit>
        <trans-unit id="5462217de65ccce13656393863d3f8b9357c723d" translate="yes" xml:space="preserve">
          <source>Due to its packed storage format, concurrent access to the elements of a &lt;code&gt;BitArray&lt;/code&gt; where at least one of them is a write is not thread safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4743db582f1472d30e534715a34bc56d951fe4b6" translate="yes" xml:space="preserve">
          <source>Due to the colloquial usage of &lt;code&gt;sha256&lt;/code&gt; to refer to &lt;code&gt;sha2_256&lt;/code&gt;, convenience functions are provided, mapping &lt;code&gt;shaxxx()&lt;/code&gt; function calls to &lt;code&gt;sha2_xxx()&lt;/code&gt;. For SHA-3, no such colloquialisms exist and the user must use the full &lt;code&gt;sha3_xxx()&lt;/code&gt; names.</source>
          <target state="translated">由于 &lt;code&gt;sha256&lt;/code&gt; 经常用于指代 &lt;code&gt;sha2_256&lt;/code&gt; ，因此提供了便捷函数，将 &lt;code&gt;shaxxx()&lt;/code&gt; 函数调用映射到 &lt;code&gt;sha2_xxx()&lt;/code&gt; 。对于SHA-3，不存在这样的口语化，用户必须使用完整的 &lt;code&gt;sha3_xxx()&lt;/code&gt; 名称。</target>
        </trans-unit>
        <trans-unit id="2ede46a500ade748ac355337b865cbc0acd19bf6" translate="yes" xml:space="preserve">
          <source>Durations/Comparisons</source>
          <target state="translated">Durations/Comparisons</target>
        </trans-unit>
        <trans-unit id="9dfdb39c23a955cc3f51336a0530f2307a456f87" translate="yes" xml:space="preserve">
          <source>Dvd</source>
          <target state="translated">Dvd</target>
        </trans-unit>
        <trans-unit id="34b40a7ef9ec304a622a57c3ab20b2c39518c944" translate="yes" xml:space="preserve">
          <source>Dynamic Linker</source>
          <target state="translated">动态链接器</target>
        </trans-unit>
        <trans-unit id="dc0def730e20d274cc00210435f7d12be805f16c" translate="yes" xml:space="preserve">
          <source>Dynamic documentation</source>
          <target state="translated">动态文件</target>
        </trans-unit>
        <trans-unit id="085752d538f762ff5754a9aa26842e80bb0818e2" translate="yes" xml:space="preserve">
          <source>E-Mail Symbol</source>
          <target state="translated">电子邮件图标</target>
        </trans-unit>
        <trans-unit id="7e7d5355c188b846aca335184bbeb5367a48b580" translate="yes" xml:space="preserve">
          <source>E.g., if &lt;code&gt;A&lt;/code&gt; is a matrix, &lt;code&gt;dims=1&lt;/code&gt; will sort rows, &lt;code&gt;dims=2&lt;/code&gt; will sort columns. Note that the default comparison function on one dimensional slices sorts lexicographically.</source>
          <target state="translated">例如，如果 &lt;code&gt;A&lt;/code&gt; 是矩阵，则 &lt;code&gt;dims=1&lt;/code&gt; 将对行进行排序， &lt;code&gt;dims=2&lt;/code&gt; 将对列进行排序。请注意，一维切片上的默认比较功能按字典顺序排序。</target>
        </trans-unit>
        <trans-unit id="1c8872365c161a3e67efcc3a61e6bdd7bd82ccf5" translate="yes" xml:space="preserve">
          <source>ENDIAN_BOM</source>
          <target state="translated">ENDIAN_BOM</target>
        </trans-unit>
        <trans-unit id="086bfb42cb0e1f0682c42f25c92a8f7e76b5bda4" translate="yes" xml:space="preserve">
          <source>ENV</source>
          <target state="translated">ENV</target>
        </trans-unit>
        <trans-unit id="7b9e6e531c95a34720d1a8d1d5a2c5f1c560afeb" translate="yes" xml:space="preserve">
          <source>EOFError</source>
          <target state="translated">EOFError</target>
        </trans-unit>
        <trans-unit id="6c745d78cc4826efc22c10c011aab3cf174ad141" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; contains the function name, file name, line number, lambda info, a flag indicating whether the frame has been inlined, a flag indicating whether it is a C function (by default C functions do not appear in the stack trace), and an integer representation of the pointer returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">每个&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt;包含函数名称，文件名，行号，lambda信息，指示是否已内联框架的标志，指示是否为C函数的标志（默认情况下，C函数不会出现在堆栈跟踪中） ，以及&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt;返回的指针的整数表示形式：</target>
        </trans-unit>
        <trans-unit id="a765a9a50809d8eeae2747483abc88ca1bb085e7" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;../parallel/index#Base.lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; must be matched with an &lt;a href=&quot;../parallel/index#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b43a1b63da011682c91ea2326629ce626a8f4ec" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;ArgumentValue&lt;/code&gt; to &lt;code&gt;llvmcall&lt;/code&gt; will be converted to the corresponding &lt;code&gt;ArgumentType&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(ArgumentType, ArgumentValue)&lt;/code&gt;.</source>
          <target state="translated">每个 &lt;code&gt;ArgumentValue&lt;/code&gt; 到 &lt;code&gt;llvmcall&lt;/code&gt; 将被转换成相应的 &lt;code&gt;ArgumentType&lt;/code&gt; ，通过呼叫的自动插入到 &lt;code&gt;unsafe_convert(ArgumentType, cconvert(ArgumentType, ArgumentValue))&lt;/code&gt; 。（有关更多详细信息，另请参见&lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Base.cconvert&quot;&gt; &lt;code&gt;cconvert&lt;/code&gt; &lt;/a&gt;的文档。）在大多数情况下，这只会导致对 &lt;code&gt;convert(ArgumentType, ArgumentValue)&lt;/code&gt; 的调用。</target>
        </trans-unit>
        <trans-unit id="3efd270aff2961e629ca01262fed000c080a030f" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;argvalue&lt;/code&gt; to &lt;code&gt;@ccall&lt;/code&gt; is converted to the corresponding &lt;code&gt;argtype&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16639880e3d78941c163af0b97ffa26b4ba639e4" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;argvalue&lt;/code&gt; to the &lt;code&gt;ccall&lt;/code&gt; will be converted to the corresponding &lt;code&gt;argtype&lt;/code&gt;, by automatic insertion of calls to &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt;. (See also the documentation for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.cconvert&quot;&gt;&lt;code&gt;cconvert&lt;/code&gt;&lt;/a&gt; for further details.) In most cases, this simply results in a call to &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt;.</source>
          <target state="translated">每个 &lt;code&gt;argvalue&lt;/code&gt; 到 &lt;code&gt;ccall&lt;/code&gt; 将被转换成相应的 &lt;code&gt;argtype&lt;/code&gt; ，通过呼叫的自动插入到 &lt;code&gt;unsafe_convert(argtype, cconvert(argtype, argvalue))&lt;/code&gt; 。（有关更多详细信息，另请参见&lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;#Base.cconvert&quot;&gt; &lt;code&gt;cconvert&lt;/code&gt; &lt;/a&gt;的文档。）在大多数情况下，这只会导致调用 &lt;code&gt;convert(argtype, argvalue)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="87cceae9fc7cfd4af0f8243a86a72515045e2992" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;lock&lt;/code&gt; must be matched by an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每个 &lt;code&gt;lock&lt;/code&gt; 必须与一个&lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="6a58a43e2467e832b243587c5b856d542f30f944" translate="yes" xml:space="preserve">
          <source>Each Julia process thus has 31 communication tasks.</source>
          <target state="translated">因此,每个Julia进程有31个通信任务。</target>
        </trans-unit>
        <trans-unit id="90eeb77500114235cd36d8d57b969eb1e5584ef6" translate="yes" xml:space="preserve">
          <source>Each event generates several pieces of data, some provided by the user and some automatically extracted. Let's examine the user-defined data first:</source>
          <target state="translated">每个事件都会产生几个数据,有些是用户提供的,有些是自动提取的。我们先来看看用户定义的数据。</target>
        </trans-unit>
        <trans-unit id="6afa6a3549818bce117962a7026f18062cf8f803" translate="yes" xml:space="preserve">
          <source>Each exported function (at the time of this writing, SHA-1, SHA-2 224, 256, 384 and 512, and SHA-3 224, 256, 384 and 512 functions are implemented) takes in either an &lt;code&gt;Array{UInt8}&lt;/code&gt;, a &lt;code&gt;ByteString&lt;/code&gt; or an &lt;code&gt;IO&lt;/code&gt; object. This makes it trivial to checksum a file:</source>
          <target state="translated">每个导出的函数（在撰写本文时，SHA-1，SHA-2 224、256、384和512，以及SHA-3 &lt;code&gt;Array{UInt8}&lt;/code&gt; 和512函数均已实现）采用Array {UInt8}，一个 &lt;code&gt;ByteString&lt;/code&gt; 或 &lt;code&gt;IO&lt;/code&gt; 对象。这使得校验和文件变得很简单：</target>
        </trans-unit>
        <trans-unit id="a27894f5ec437e16c54a81d270d486f77eb240c6" translate="yes" xml:space="preserve">
          <source>Each kind of environment defines these three maps differently, as detailed in the following sections.</source>
          <target state="translated">每种环境对这三种地图的定义都不一样,详见下文。</target>
        </trans-unit>
        <trans-unit id="1ff693f28cccaa9f352f467474efbdadbcecc29f" translate="yes" xml:space="preserve">
          <source>Each line of this display represents a particular spot (line number) in the code. Indentation is used to indicate the nested sequence of function calls, with more-indented lines being deeper in the sequence of calls. In each line, the first &quot;field&quot; is the number of backtraces (samples) taken &lt;em&gt;at this line or in any functions executed by this line&lt;/em&gt;. The second field is the file name and line number and the third field is the function name. Note that the specific line numbers may change as Julia's code changes; if you want to follow along, it's best to run this example yourself.</source>
          <target state="translated">此显示的每一行代表代码中的特定点（行号）。缩进用于指示函数调用的嵌套序列，缩进的行在调用序列中更深。在每一行中，第一个&amp;ldquo;字段&amp;rdquo;是&lt;em&gt;在此行或在此行执行的任何函数中&lt;/em&gt;获取的回溯（样本）数。第二个字段是文件名和行号，第三个字段是函数名。请注意，特定行号可能会随着Julia代码的更改而更改；如果您想继续学习，最好自己运行此示例。</target>
        </trans-unit>
        <trans-unit id="01a2902c277d245e34b708c7aa314c4d33622ac3" translate="yes" xml:space="preserve">
          <source>Each method of a generated function has its own view of defined functions:</source>
          <target state="translated">生成函数的每个方法都有自己的定义函数视图。</target>
        </trans-unit>
        <trans-unit id="b280a43cc4fcfe2d9e44a5ed377411ad6dd61b84" translate="yes" xml:space="preserve">
          <source>Each module introduces a new global scope, separate from the global scope of all other modules&amp;mdash;there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the &lt;a href=&quot;../modules/index#modules&quot;&gt;using or import&lt;/a&gt; statements or through qualified access using the dot-notation, i.e. each module is a so-called &lt;em&gt;namespace&lt;/em&gt; as well as a first-class data structure associating names with values. Note that while variable bindings can be read externally, they can only be changed within the module to which they belong. As an escape hatch, you can always evaluate code inside that module to modify a variable; this guarantees, in particular, that module bindings cannot be modified externally by code that never calls &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3717f137bf0edf07318a78ca822c93213e8ab5c5" translate="yes" xml:space="preserve">
          <source>Each module introduces a new global scope, separate from the global scope of all other modules; there is no all-encompassing global scope. Modules can introduce variables of other modules into their scope through the &lt;a href=&quot;../modules/index#modules-1&quot;&gt;using or import&lt;/a&gt; statements or through qualified access using the dot-notation, i.e. each module is a so-called &lt;em&gt;namespace&lt;/em&gt;. Note that variable bindings can only be changed within their global scope and not from an outside module.</source>
          <target state="translated">每个模块都引入了新的全局范围，与所有其他模块的全局范围分开；没有涵盖所有领域的全球范围。模块可以通过&lt;a href=&quot;../modules/index#modules-1&quot;&gt;using或import&lt;/a&gt;语句或通过使用点符号的合格访问将其他模块的变量引入其作用域，即，每个模块都是所谓的&lt;em&gt;命名空间&lt;/em&gt;。请注意，变量绑定只能在其全局范围内更改，而不能从外部模块更改。</target>
        </trans-unit>
        <trans-unit id="bf0da81b3dc87a0fd15f25539852984a31877c54" translate="yes" xml:space="preserve">
          <source>Each process has an associated identifier. The process providing the interactive Julia prompt always has an &lt;code&gt;id&lt;/code&gt; equal to 1. The processes used by default for parallel operations are referred to as &quot;workers&quot;. When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1.</source>
          <target state="translated">每个进程都有一个关联的标识符。提供交互式Julia提示的进程的 &lt;code&gt;id&lt;/code&gt; 始终等于1。默认情况下，用于并行操作的进程称为&amp;ldquo;工人&amp;rdquo;。如果只有一个流程，则将流程1视为工作人员。否则，工作人员将被视为除流程1之外的所有其他流程。</target>
        </trans-unit>
        <trans-unit id="4cf2bd42913eae23239a3ca6155fa30e146609bc" translate="yes" xml:space="preserve">
          <source>Each process has an associated identifier. The process providing the interactive Julia prompt always has an &lt;code&gt;id&lt;/code&gt; equal to 1. The processes used by default for parallel operations are referred to as &quot;workers&quot;. When there is only one process, process 1 is considered a worker. Otherwise, workers are considered to be all processes other than process 1. As a result, adding 2 or more processes is required to gain benefits from parallel processing methods like &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt;. Adding a single process is beneficial if you just wish to do other things in the main process while a long computation is running on the worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df120cd43c18561cb64b8f7f625bd660e549595" translate="yes" xml:space="preserve">
          <source>Each scope must have only one call to &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. Hence, if all variables cannot be pushed once by a single call to &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;, or if there are more than 6 variables to be pushed and using an array of arguments is not an option, then one can use inner blocks:</source>
          <target state="translated">每个作用域只能对 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; 一次调用。因此，如果不能通过一次调用 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; 一次将所有变量压入一次，或者如果要压入的变量超过6个并且使用参数数组不是一种选择，则可以使用内部块：</target>
        </trans-unit>
        <trans-unit id="d282bb8a2c865839d970ad58b137b93bc00c7f72" translate="yes" xml:space="preserve">
          <source>Each successful &lt;code&gt;trylock&lt;/code&gt; must be matched by an &lt;a href=&quot;#Base.unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每个成功的 &lt;code&gt;trylock&lt;/code&gt; 必须与一个&lt;a href=&quot;#Base.unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt;匹配。</target>
        </trans-unit>
        <trans-unit id="22844561d348de2a6b27cf89433a65f8efbcb6b9" translate="yes" xml:space="preserve">
          <source>Each task handles all incoming messages from a single remote worker in a message-processing loop.</source>
          <target state="translated">每个任务在消息处理循环中处理来自单个远程工作者的所有传入消息。</target>
        </trans-unit>
        <trans-unit id="959d90366413778f223799834532da2e5d798af8" translate="yes" xml:space="preserve">
          <source>Each worker binds to only one of the local interfaces and listens on an ephemeral port number assigned by the OS.</source>
          <target state="translated">每个worker只绑定一个本地接口,并在操作系统分配的短暂端口号上监听。</target>
        </trans-unit>
        <trans-unit id="7f33a61e2ebfeda0d2e414fecf682c309512f02f" translate="yes" xml:space="preserve">
          <source>Each worker connects to all workers whose &lt;code&gt;id&lt;/code&gt; is less than the worker's own &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">每个工人都连接到其 &lt;code&gt;id&lt;/code&gt; 小于该工人自己的 &lt;code&gt;id&lt;/code&gt; 所有工人。</target>
        </trans-unit>
        <trans-unit id="296ff54bedf2c4c2f12fadf9f3d4dae7319b0178" translate="yes" xml:space="preserve">
          <source>Each worker starts listening on a free port and writes out its host and port information to &lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">每个工作程序开始在空闲端口上侦听，并将其主机和端口信息写到&lt;a href=&quot;../../base/io-network/index#Base.stdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4b6573c03375a2d09bcdcc1d5adf31597eebb48" translate="yes" xml:space="preserve">
          <source>Eagerly evaluate the lazy matrix transpose/adjoint. Note that the transposition is applied recursively to elements.</source>
          <target state="translated">急于评估懒惰矩阵转置/联合。请注意,转置是递归地应用于元素。</target>
        </trans-unit>
        <trans-unit id="27b938020515cf5bb6d2984093bfbe7ab6d70ad5" translate="yes" xml:space="preserve">
          <source>Ear</source>
          <target state="translated">Ear</target>
        </trans-unit>
        <trans-unit id="f97bff7e2b8198bfce99e20d9dc3037ca7cb582c" translate="yes" xml:space="preserve">
          <source>Ear Of Maize</source>
          <target state="translated">玉米耳</target>
        </trans-unit>
        <trans-unit id="3d9d70794f61bff1149af95c6f4cc244fdd11015" translate="yes" xml:space="preserve">
          <source>Ear Of Rice</source>
          <target state="translated">米耳</target>
        </trans-unit>
        <trans-unit id="b212969dc9e512428d09170cadc608095d96ef4b" translate="yes" xml:space="preserve">
          <source>Early filtering and message handling</source>
          <target state="translated">早期过滤和信息处理</target>
        </trans-unit>
        <trans-unit id="02013cc67046fdd1aae8de2e9297f90c75b1d103" translate="yes" xml:space="preserve">
          <source>Early filtering of events</source>
          <target state="translated">尽早过滤事件</target>
        </trans-unit>
        <trans-unit id="45ba28d774fd86488ce1c503089d1e80918e6cda" translate="yes" xml:space="preserve">
          <source>Earth Globe Americas</source>
          <target state="translated">地球地球美洲公司</target>
        </trans-unit>
        <trans-unit id="32a31b8413404bbe823a0be0f2215daa04efa961" translate="yes" xml:space="preserve">
          <source>Earth Globe Asia-Australia</source>
          <target state="translated">地球环球亚洲-澳大利亚</target>
        </trans-unit>
        <trans-unit id="e225e5febaa3e5d132e6c4f42f17f6e28d6415c5" translate="yes" xml:space="preserve">
          <source>Earth Globe Europe-Africa</source>
          <target state="translated">地球地球欧洲-非洲</target>
        </trans-unit>
        <trans-unit id="38a01a67cf8e4d332986b68f2fc71763c696a896" translate="yes" xml:space="preserve">
          <source>Edit a file or directory optionally providing a line number to edit the file at. Return to the &lt;code&gt;julia&lt;/code&gt; prompt when you quit the editor. The editor can be changed by setting &lt;code&gt;JULIA_EDITOR&lt;/code&gt;, &lt;code&gt;VISUAL&lt;/code&gt; or &lt;code&gt;EDITOR&lt;/code&gt; as an environment variable.</source>
          <target state="translated">编辑文件或目录，可以选择提供一个行号来编辑文件。退出编辑器时，请返回至 &lt;code&gt;julia&lt;/code&gt; 提示符。可以通过将 &lt;code&gt;JULIA_EDITOR&lt;/code&gt; ， &lt;code&gt;VISUAL&lt;/code&gt; 或 &lt;code&gt;EDITOR&lt;/code&gt; 设置为环境变量来更改编辑器。</target>
        </trans-unit>
        <trans-unit id="96bf75cf90aee425bd296ba4a82e787d511340ac" translate="yes" xml:space="preserve">
          <source>Edit the definition of a function, optionally specifying a tuple of types to indicate which method to edit. For modules, open the main source file. The module needs to be loaded with &lt;code&gt;using&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; first.</source>
          <target state="translated">编辑函数的定义，可以选择指定类型的元组以指示要编辑的方法。对于模块，打开主源文件。首先需要 &lt;code&gt;using&lt;/code&gt; 或 &lt;code&gt;import&lt;/code&gt; 模块。</target>
        </trans-unit>
        <trans-unit id="f916e6f9856dcbd1006ae78298c4b5adcd077534" translate="yes" xml:space="preserve">
          <source>Editors which cannot open to a specific line with a command may ignore the &lt;code&gt;line&lt;/code&gt; argument. The &lt;code&gt;fn&lt;/code&gt; callback must return either an appropriate &lt;code&gt;Cmd&lt;/code&gt; object to open a file or &lt;code&gt;nothing&lt;/code&gt; to indicate that they cannot edit this file. Use &lt;code&gt;nothing&lt;/code&gt; to indicate that this editor is not appropriate for the current environment and another editor should be attempted. It is possible to add more general editing hooks that need not spawn external commands by pushing a callback directly to the vector &lt;code&gt;EDITOR_CALLBACKS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c375fe45e00ed5d286a20e4c69197b11257ae1df" translate="yes" xml:space="preserve">
          <source>Efficient algorithms are implemented for &lt;code&gt;H \ b&lt;/code&gt;, &lt;code&gt;det(H)&lt;/code&gt;, and similar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44dc07f2fcde6067bce262b5efc8feb032594384" translate="yes" xml:space="preserve">
          <source>Efficient support for &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode&lt;/a&gt;, including but not limited to &lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;</source>
          <target state="translated">对&lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode&quot;&gt;Unicode的&lt;/a&gt;有效支持，包括但不限于&lt;a href=&quot;https://en.wikipedia.org/wiki/UTF-8&quot;&gt;UTF-8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="86a35f1cb66a4b67fe0a08c54f9a06ca22ca2502" translate="yes" xml:space="preserve">
          <source>Eight Pointed Black Star</source>
          <target state="translated">八角黑星</target>
        </trans-unit>
        <trans-unit id="b096e49c067864c8657cc77cb2489f9c7a46a60c" translate="yes" xml:space="preserve">
          <source>Eight Spoked Asterisk</source>
          <target state="translated">八角星号</target>
        </trans-unit>
        <trans-unit id="64b33bc5b072bf67cae39a4367e9262f072d0983" translate="yes" xml:space="preserve">
          <source>Eighth Note</source>
          <target state="translated">八分音符</target>
        </trans-unit>
        <trans-unit id="3e48f6a437e3973638b906ba62fc55ca1cbd9219" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;EltypeUnknown()&lt;/code&gt; or &lt;code&gt;HasEltype()&lt;/code&gt; as appropriate</source>
          <target state="translated">任一 &lt;code&gt;EltypeUnknown()&lt;/code&gt; 或 &lt;code&gt;HasEltype()&lt;/code&gt; 适当</target>
        </trans-unit>
        <trans-unit id="a0e204f765f5ad928475881aca7c13ef5c65e351" translate="yes" xml:space="preserve">
          <source>Electric Light Bulb</source>
          <target state="translated">电灯泡</target>
        </trans-unit>
        <trans-unit id="b15c5b6da40c647c02530732f2c154f67995f39b" translate="yes" xml:space="preserve">
          <source>Electric Plug</source>
          <target state="translated">电插头</target>
        </trans-unit>
        <trans-unit id="3f114e1bd5e42dad4fb0e15a6f2fe2cdbffd8d5c" translate="yes" xml:space="preserve">
          <source>Electric Torch</source>
          <target state="translated">电筒</target>
        </trans-unit>
        <trans-unit id="8bc90f041dc25b644c48594037e5678f3120b766" translate="yes" xml:space="preserve">
          <source>Electrical Intersection</source>
          <target state="translated">电气交叉口</target>
        </trans-unit>
        <trans-unit id="94a626de4e05a050364a69d3ed8b52928fa721f2" translate="yes" xml:space="preserve">
          <source>Elegant and extensible conversions and promotions for numeric and other types</source>
          <target state="translated">优雅且可扩展的数字和其他类型的转换和促销活动</target>
        </trans-unit>
        <trans-unit id="b145388f2a6c1f663c46cc3fef6df0278b0d0e7b" translate="yes" xml:space="preserve">
          <source>Element Of</source>
          <target state="translated">元素</target>
        </trans-unit>
        <trans-unit id="c7e75d5c58d3d99fb0549bbb6eebd8b77418f140" translate="yes" xml:space="preserve">
          <source>Element Of Opening Downwards</source>
          <target state="translated">向下开放的元素</target>
        </trans-unit>
        <trans-unit id="ec9d5e51a88871a1e6bce9e1d8f55eddb1be4d6d" translate="yes" xml:space="preserve">
          <source>Element Of Opening Upwards</source>
          <target state="translated">向上开放的元素</target>
        </trans-unit>
        <trans-unit id="eabe348be570b5c3a81b5a78a24f6bc500a5b337" translate="yes" xml:space="preserve">
          <source>Element Of With Dot Above</source>
          <target state="translated">元素与点以上</target>
        </trans-unit>
        <trans-unit id="17bfb5ca72c4a27f20d3d15f5185aabec39f3a3b" translate="yes" xml:space="preserve">
          <source>Element Of With Long Horizontal Stroke</source>
          <target state="translated">横向长笔画的元素</target>
        </trans-unit>
        <trans-unit id="f3443f2657692062978d73b4527d8f3f59f40708" translate="yes" xml:space="preserve">
          <source>Element Of With Overbar</source>
          <target state="translated">带过杆的元素</target>
        </trans-unit>
        <trans-unit id="0335789ad2498b26e35d6c835f82cac2d005c318" translate="yes" xml:space="preserve">
          <source>Element Of With Two Horizontal Strokes</source>
          <target state="translated">带有两个水平笔画的元素</target>
        </trans-unit>
        <trans-unit id="71f5f71f9939ea54d51a735c864b74e3967c3ba7" translate="yes" xml:space="preserve">
          <source>Element Of With Underbar</source>
          <target state="translated">元素的带下杆</target>
        </trans-unit>
        <trans-unit id="256f897f2234cedafe188f182b0344400f8e1c28" translate="yes" xml:space="preserve">
          <source>Element Of With Vertical Bar At End Of Horizontal Stroke</source>
          <target state="translated">水平冲程末端有竖条的元素。</target>
        </trans-unit>
        <trans-unit id="86ab7fa25cb358d66e37e0c0a1c13bec1b3787f5" translate="yes" xml:space="preserve">
          <source>Elementary Functions</source>
          <target state="translated">基本功能</target>
        </trans-unit>
        <trans-unit id="97b701a83c60171055869225a728b6d2098cfc55" translate="yes" xml:space="preserve">
          <source>Elementary operations</source>
          <target state="translated">初级业务</target>
        </trans-unit>
        <trans-unit id="1c6f116ce35bbe8b5c5b3a26cfa9e63c4b7cff24" translate="yes" xml:space="preserve">
          <source>Elephant</source>
          <target state="translated">Elephant</target>
        </trans-unit>
        <trans-unit id="628aee648dc7795c701c3ac4168565c49ba7d8a8" translate="yes" xml:space="preserve">
          <source>Eliminates array bounds checking within expressions.</source>
          <target state="translated">消除了表达式中的数组边界检查。</target>
        </trans-unit>
        <trans-unit id="436e5580dafe4837fafc385b6832e44770757da8" translate="yes" xml:space="preserve">
          <source>Em Dash</source>
          <target state="translated">Em Dash</target>
        </trans-unit>
        <trans-unit id="54edea64256fec1b9afd042056c683a5e954b05d" translate="yes" xml:space="preserve">
          <source>Em Space</source>
          <target state="translated">EM空间</target>
        </trans-unit>
        <trans-unit id="fd5fa6acc8725853ec64793d0347faa7182d2f81" translate="yes" xml:space="preserve">
          <source>Embedding Julia</source>
          <target state="translated">嵌入茱莉亚</target>
        </trans-unit>
        <trans-unit id="8638f2d27f26ab330e90a52d10d3ba6e903a995b" translate="yes" xml:space="preserve">
          <source>Emit bounds checks always or never (ignoring declarations)</source>
          <target state="translated">始终或从不发出边界检查(忽略声明)。</target>
        </trans-unit>
        <trans-unit id="6822793744c195c06628e13a8e25bb8ee807d832" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-1-2</source>
          <target state="translated">表情符号修改器 Fitzpatrick Type-1-2</target>
        </trans-unit>
        <trans-unit id="e7d0e508f11f735e99c8bf9621166a5b98508edb" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-3</source>
          <target state="translated">表情符号修改器 Fitzpatrick Type-3</target>
        </trans-unit>
        <trans-unit id="27052bd6bf6386f71c6cd2f5155906907462e4eb" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-4</source>
          <target state="translated">表情符号修改器 Fitzpatrick Type-4</target>
        </trans-unit>
        <trans-unit id="1a1f8c73826ca18825ae5fad787b1128670acb3c" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-5</source>
          <target state="translated">表情符号修改器 Fitzpatrick Type-5</target>
        </trans-unit>
        <trans-unit id="ddf70184418afb46c24a9ba734226beae8038ce5" translate="yes" xml:space="preserve">
          <source>Emoji Modifier Fitzpatrick Type-6</source>
          <target state="translated">表情符号修改器 Fitzpatrick Type-6</target>
        </trans-unit>
        <trans-unit id="92732205e250b4761981020982f3419de88cf7db" translate="yes" xml:space="preserve">
          <source>Empty Set</source>
          <target state="translated">空套</target>
        </trans-unit>
        <trans-unit id="8ec062085bcc2b801f216fc4c40783b689f973cf" translate="yes" xml:space="preserve">
          <source>Empty Set With Left Arrow Above</source>
          <target state="translated">空集,上面有左箭头</target>
        </trans-unit>
        <trans-unit id="d91ae9a03edea62c7bd20d9ba629d7162aa63219" translate="yes" xml:space="preserve">
          <source>Empty Set With Overbar</source>
          <target state="translated">空组带过杆</target>
        </trans-unit>
        <trans-unit id="6d8f951440669eb13bd78e4eb7585eb670aa5993" translate="yes" xml:space="preserve">
          <source>Empty Set With Right Arrow Above</source>
          <target state="translated">空集,上面有右箭头</target>
        </trans-unit>
        <trans-unit id="43f45b3c27e994f1786fe11853d88094ff3f0d3a" translate="yes" xml:space="preserve">
          <source>Empty Set With Small Circle Above</source>
          <target state="translated">空套,上面有小圆圈</target>
        </trans-unit>
        <trans-unit id="5ebfd6f75b259f38d9a9191637cf54107c71d5e2" translate="yes" xml:space="preserve">
          <source>Empty arrays like &lt;code&gt;[]&lt;/code&gt;, which select no elements</source>
          <target state="translated">空数组，例如 &lt;code&gt;[]&lt;/code&gt; ，不选择任何元素</target>
        </trans-unit>
        <trans-unit id="d1b6081c62b3668f73437e7ef55230193e6e2dec" translate="yes" xml:space="preserve">
          <source>Empty generic functions</source>
          <target state="translated">空的通用函数</target>
        </trans-unit>
        <trans-unit id="74006a3cefa65eb24a50f14a080a0a283848825f" translate="yes" xml:space="preserve">
          <source>En Dash</source>
          <target state="translated">En Dash</target>
        </trans-unit>
        <trans-unit id="1628cc600d641d86574721f4cba6f82ac4859ad1" translate="yes" xml:space="preserve">
          <source>En Space</source>
          <target state="translated">En空间</target>
        </trans-unit>
        <trans-unit id="c26082fba43142d1c87a99220a9c21dffcbbcbfe" translate="yes" xml:space="preserve">
          <source>Enable / Set the level of debug info generation (default level is 1 if unspecified or 2 if used without a level)</source>
          <target state="translated">启用/设置调试信息生成的级别(如果没有指定级别,默认为1;如果没有级别,默认为2)。</target>
        </trans-unit>
        <trans-unit id="cdf7726a55289566143a4b529102535c5730b7a5" translate="yes" xml:space="preserve">
          <source>Enable N threads; &lt;code&gt;auto&lt;/code&gt; currently sets N to the number of local CPU threads but this might change in the future</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89b819c104d36c25c43b4b3679d57166fd8a76d" translate="yes" xml:space="preserve">
          <source>Enable debug logging for a file or module, see &lt;a href=&quot;../../stdlib/logging/index#Logging&quot;&gt;&lt;code&gt;Logging&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d7732e401f3ac5abd96dcf18eb471bc62eedcf" translate="yes" xml:space="preserve">
          <source>Enable or disable Julia's default signal handlers</source>
          <target state="translated">启用或禁用Julia的默认信号处理程序。</target>
        </trans-unit>
        <trans-unit id="868de4fff11fc1378b5bf090b18d305dd45bc334" translate="yes" xml:space="preserve">
          <source>Enable or disable color text</source>
          <target state="translated">启用或禁用彩色文本</target>
        </trans-unit>
        <trans-unit id="5c9a249a64cc4fd650a34fa825cad6ef21b766ee" translate="yes" xml:space="preserve">
          <source>Enable or disable incremental precompilation of modules</source>
          <target state="translated">启用或禁用模块的增量预编译。</target>
        </trans-unit>
        <trans-unit id="a51c0e3a6688b962a589c4b3871584f7a8a45cd2" translate="yes" xml:space="preserve">
          <source>Enable or disable method overwrite warnings</source>
          <target state="translated">启用或禁用方法覆盖警告</target>
        </trans-unit>
        <trans-unit id="aca528646e6712e710558c2a4eb1f14f7c2f63c3" translate="yes" xml:space="preserve">
          <source>Enable or disable startup banner</source>
          <target state="translated">启用或禁用启动横幅</target>
        </trans-unit>
        <trans-unit id="2ca0be31a9b9b42744412a3827771e952db1ba08" translate="yes" xml:space="preserve">
          <source>Enable or disable syntax and method deprecation warnings (&lt;code&gt;error&lt;/code&gt; turns warnings into errors)</source>
          <target state="translated">启用或禁用语法和方法弃用警告（ &lt;code&gt;error&lt;/code&gt; 将警告变为错误）</target>
        </trans-unit>
        <trans-unit id="dd61ab9cf22b749efe0c17fd33d2e5ed63c746f4" translate="yes" xml:space="preserve">
          <source>Enable the GC, return previous state as int</source>
          <target state="translated">启用GC,返回之前的状态为int</target>
        </trans-unit>
        <trans-unit id="8e8469c75c7e1c37ce55e37721cd77e479242109" translate="yes" xml:space="preserve">
          <source>Enables or disables Nagle's algorithm on a given TCP server or socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab95ff490fda9c25eacf7c86628805a78ecd8fa" translate="yes" xml:space="preserve">
          <source>End Of Proof</source>
          <target state="translated">证明结束</target>
        </trans-unit>
        <trans-unit id="ad9d937f40f9885915fd0bc9430bfd7d6e63f0d4" translate="yes" xml:space="preserve">
          <source>End With Leftwards Arrow Above</source>
          <target state="translated">以上面的向左箭头结束</target>
        </trans-unit>
        <trans-unit id="348ce364668910edabfd008dfd0d3a94254a6fef" translate="yes" xml:space="preserve">
          <source>End, &lt;code&gt;^E&lt;/code&gt;</source>
          <target state="translated">结束， &lt;code&gt;^E&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0891cb9306e1015f2471b30de2c6d9cc3c5bab0c" translate="yes" xml:space="preserve">
          <source>Ensuring that all arguments support broadcast</source>
          <target state="translated">确保所有论点都支持广播</target>
        </trans-unit>
        <trans-unit id="a74398c918fa81c3c891469eb00e56ab1bce6a94" translate="yes" xml:space="preserve">
          <source>Enter help or shell mode (when at start of a line)</source>
          <target state="translated">进入帮助或shell模式(当行开始时)</target>
        </trans-unit>
        <trans-unit id="e641b987ac9e8ea3ec201a6a67556391d2e16178" translate="yes" xml:space="preserve">
          <source>Enum constant for &lt;a href=&quot;#Libdl.dlopen&quot;&gt;&lt;code&gt;dlopen&lt;/code&gt;&lt;/a&gt;. See your platform man page for details, if applicable.</source>
          <target state="translated">&lt;a href=&quot;#Libdl.dlopen&quot;&gt; &lt;code&gt;dlopen&lt;/code&gt; 的&lt;/a&gt;枚举常量。有关详细信息，请参见您的平台手册页（如果适用）。</target>
        </trans-unit>
        <trans-unit id="3d4759b02e49d42abcfd8c6da270947288cfdfb3" translate="yes" xml:space="preserve">
          <source>Enums.@enum</source>
          <target state="translated">Enums.@enum</target>
        </trans-unit>
        <trans-unit id="9848c4523e6e3aa918b1c25741d4c5549ef8d0ad" translate="yes" xml:space="preserve">
          <source>Enums.Enum</source>
          <target state="translated">Enums.Enum</target>
        </trans-unit>
        <trans-unit id="cc756bbce5c6a1daad1db7d15c8a2dcefb92b0e6" translate="yes" xml:space="preserve">
          <source>EnvDict</source>
          <target state="translated">EnvDict</target>
        </trans-unit>
        <trans-unit id="7f4a2c89d81b1eddb2e5160fabf3758acbd3a82d" translate="yes" xml:space="preserve">
          <source>Envelope</source>
          <target state="translated">Envelope</target>
        </trans-unit>
        <trans-unit id="6762c5bdd1e043549bb3b44e75155fdf9be1b7a5" translate="yes" xml:space="preserve">
          <source>Envelope With Downwards Arrow Above</source>
          <target state="translated">上方有向下箭头的信封</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">环境变量</target>
        </trans-unit>
        <trans-unit id="941617a2c1b6b1aec2faae0db722ab34dd080e87" translate="yes" xml:space="preserve">
          <source>Environment stacks</source>
          <target state="translated">环境堆栈</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">环境变量</target>
        </trans-unit>
        <trans-unit id="89641f9fa6e1bc519a9a2c77cb0174bd0af98e58" translate="yes" xml:space="preserve">
          <source>Environment variables :</source>
          <target state="translated">环境变量 :</target>
        </trans-unit>
        <trans-unit id="19f829a38150f040480818f9393c99b2f11589f5" translate="yes" xml:space="preserve">
          <source>Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI terminal escape sequences&lt;/a&gt;. Julia provides a high-level interface with much of the same functionality; see the section on &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL&quot;&gt;The Julia REPL&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ee4c027fd890e4de416f6f3ab9a71f9c9e72e8" translate="yes" xml:space="preserve">
          <source>Environment variables that determine how REPL output should be formatted at the terminal. Generally, these variables should be set to &lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI terminal escape sequences&lt;/a&gt;. Julia provides a high-level interface with much of the same functionality; see the section on &lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;The Julia REPL&lt;/a&gt;.</source>
          <target state="translated">环境变量，用于确定应如何在终端处格式化REPL输出。通常，应将这些变量设置为&lt;a href=&quot;http://ascii-table.com/ansi-escape-sequences.php&quot;&gt;ANSI终端转义序列&lt;/a&gt;。 Julia提供了具有许多相同功能的高级界面。参见&lt;a href=&quot;../../stdlib/repl/index#The-Julia-REPL-1&quot;&gt;&amp;ldquo;朱莉娅REPL&lt;/a&gt; &amp;rdquo;部分。</target>
        </trans-unit>
        <trans-unit id="017b53c42e43b39e1f5aabf6f7280c2f777243a2" translate="yes" xml:space="preserve">
          <source>Environments</source>
          <target state="translated">Environments</target>
        </trans-unit>
        <trans-unit id="3adc5cf208fce048a876da30f12ee121f6e24ef5" translate="yes" xml:space="preserve">
          <source>Equal And Parallel To</source>
          <target state="translated">相等且平行</target>
        </trans-unit>
        <trans-unit id="9014b90f8a5c287f9f7cca7cf1a09f7419d2e0a4" translate="yes" xml:space="preserve">
          <source>Equal To By Definition</source>
          <target state="translated">根据定义,等同于</target>
        </trans-unit>
        <trans-unit id="527d2270efb77ab589aa3d2bc8b1899c1c160dcc" translate="yes" xml:space="preserve">
          <source>Equal To Or Greater-Than / Equal To Or Greater Than</source>
          <target state="translated">等于或大于/等于或大于</target>
        </trans-unit>
        <trans-unit id="6043f4fef98b74458e43463764bf902e73e8ff02" translate="yes" xml:space="preserve">
          <source>Equal To Or Less-Than / Equal To Or Less Than</source>
          <target state="translated">相当于或少于/等于或少于:</target>
        </trans-unit>
        <trans-unit id="f6b115d144ac2f3557f089ae7d83d11f870e6ef8" translate="yes" xml:space="preserve">
          <source>Equal To Or Precedes</source>
          <target state="translated">等于或先于</target>
        </trans-unit>
        <trans-unit id="3e050032f44766762506ff80de8be9a1911a3683" translate="yes" xml:space="preserve">
          <source>Equal To Or Succeeds</source>
          <target state="translated">等于或成功</target>
        </trans-unit>
        <trans-unit id="15cfd415b36fe06b7025888786ae38085fcb3dbe" translate="yes" xml:space="preserve">
          <source>Equality and Comparison Operators</source>
          <target state="translated">平等和比较运算符</target>
        </trans-unit>
        <trans-unit id="d8dae2f241fe4b5c985e7ee897c6b9676b9479ac" translate="yes" xml:space="preserve">
          <source>Equals Colon / Equal Colon</source>
          <target state="translated">等于冒号/等于冒号</target>
        </trans-unit>
        <trans-unit id="f93dc9419a85602368082c386c9a828a21bf6a6a" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Leftwards Arrow</source>
          <target state="translated">向左箭头上方的等号</target>
        </trans-unit>
        <trans-unit id="ec3132ed55f4f598ba853ce4e35988f1d955c3eb" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Plus Sign</source>
          <target state="translated">等号以上加号</target>
        </trans-unit>
        <trans-unit id="77fb2dbe6663a45556f7650f2f6c1c73a590ed1c" translate="yes" xml:space="preserve">
          <source>Equals Sign Above Tilde Operator</source>
          <target state="translated">等号以上的倾斜操作者</target>
        </trans-unit>
        <trans-unit id="62609b0cf8c4d06d3037a7bf8e6a793f1d27492d" translate="yes" xml:space="preserve">
          <source>Equals Sign And Slanted Parallel</source>
          <target state="translated">等号和倾斜的平行线</target>
        </trans-unit>
        <trans-unit id="23b4d26cbdac9571083cacc41611600ec79ff967" translate="yes" xml:space="preserve">
          <source>Equals Sign And Slanted Parallel With Tilde Above</source>
          <target state="translated">等号,并与上方的倾斜面平行。</target>
        </trans-unit>
        <trans-unit id="392e4a8368a67b37c46109802dbf3b2bbe627e02" translate="yes" xml:space="preserve">
          <source>Equals Sign With Bumpy Above</source>
          <target state="translated">等号,上面有凹凸</target>
        </trans-unit>
        <trans-unit id="f2b106f710b9bbc7d6d2a380faea7b8fd23ed23a" translate="yes" xml:space="preserve">
          <source>Equals Sign With Dot Below</source>
          <target state="translated">下面带点的等号</target>
        </trans-unit>
        <trans-unit id="292a343448e994eeed1ffd3fdb4c2c8eb86b5555" translate="yes" xml:space="preserve">
          <source>Equals Sign With Two Dots Above And Two Dots Below</source>
          <target state="translated">等号,上面有两个点,下面有两个点。</target>
        </trans-unit>
        <trans-unit id="5e945a1cf2921ae612b33494ebe19cfd549e10ac" translate="yes" xml:space="preserve">
          <source>Equals With Asterisk</source>
          <target state="translated">等于带星号</target>
        </trans-unit>
        <trans-unit id="f3f7928443c385bebfa509e6448cd7d63a9cc4a2" translate="yes" xml:space="preserve">
          <source>Equiangular To</source>
          <target state="translated">等于</target>
        </trans-unit>
        <trans-unit id="0dae504b4d888ad200cb544ee05069b242235880" translate="yes" xml:space="preserve">
          <source>Equivalent To</source>
          <target state="translated">相当于</target>
        </trans-unit>
        <trans-unit id="209bb1206181d9c196e80f6965debb3ab3399f46" translate="yes" xml:space="preserve">
          <source>Equivalent With Four Dots Above</source>
          <target state="translated">相当于上面的四个点</target>
        </trans-unit>
        <trans-unit id="bdeb0fcd2d5eaaa85eb93b2bbb4eae42f75d7875" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;addprocs(Sys.CPU_THREADS; kwargs...)&lt;/code&gt;</source>
          <target state="translated">等效于 &lt;code&gt;addprocs(Sys.CPU_THREADS; kwargs...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a444cba5b25b06d85c75d2cdc5490f28108cce13" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawn expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;fetch(@spawn expr)&lt;/code&gt; 。参见 &lt;code&gt;fetch&lt;/code&gt; 和&lt;a href=&quot;#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="04a15056af777844fc12e01881e2375b1a9bb29c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawnat :any expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3145567457b210ea2803bee24b9156158b97cd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;fetch(@spawnat p expr)&lt;/code&gt;. See &lt;code&gt;fetch&lt;/code&gt; and &lt;a href=&quot;#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;fetch(@spawnat p expr)&lt;/code&gt; 。参见 &lt;code&gt;fetch&lt;/code&gt; 和&lt;a href=&quot;#Distributed.@spawnat&quot;&gt; &lt;code&gt;@spawnat&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9ce9a67772da7b41e7c54b6a2b9da8ba6fbcc2a7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git branch&lt;/code&gt;. Create a new branch from the current HEAD.</source>
          <target state="translated">相当于 &lt;code&gt;git branch&lt;/code&gt; 。从当前HEAD创建一个新分支。</target>
        </trans-unit>
        <trans-unit id="8ad57947a691137150d754570a8ec38ac67d31bf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git checkout [-b|-B] &amp;lt;branch_name&amp;gt; [&amp;lt;commit&amp;gt;] [--track &amp;lt;track&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;git checkout [-b|-B] &amp;lt;branch_name&amp;gt; [&amp;lt;commit&amp;gt;] [--track &amp;lt;track&amp;gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d743c43b1f86bc4c8cac6b46919f9f746db86863" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git checkout [-f] --detach &amp;lt;commit&amp;gt;&lt;/code&gt;. Checkout the git commit &lt;code&gt;commit&lt;/code&gt; (a &lt;a href=&quot;#LibGit2.GitHash&quot;&gt;&lt;code&gt;GitHash&lt;/code&gt;&lt;/a&gt; in string form) in &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;force&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, force the checkout and discard any current changes. Note that this detaches the current HEAD.</source>
          <target state="translated">等效于 &lt;code&gt;git checkout [-f] --detach &amp;lt;commit&amp;gt;&lt;/code&gt; 。在 &lt;code&gt;repo&lt;/code&gt; 中检出git commit &lt;code&gt;commit&lt;/code&gt; （字符串形式的&lt;a href=&quot;#LibGit2.GitHash&quot;&gt; &lt;code&gt;GitHash&lt;/code&gt; &lt;/a&gt;）。如果 &lt;code&gt;force&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则强制结帐并放弃任何当前更改。请注意，这将分离当前的HEAD。</target>
        </trans-unit>
        <trans-unit id="901e29752c2ee8a70b5ed5fe68c348abc419a1fa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git clone [-b &amp;lt;branch&amp;gt;] [--bare] &amp;lt;repo_url&amp;gt; &amp;lt;repo_path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;git clone [-b &amp;lt;branch&amp;gt;] [--bare] &amp;lt;repo_url&amp;gt; &amp;lt;repo_path&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bad74bb24ad9c1d3be87108ffc378bb2da2cc9f9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff --name-only --diff-filter=&amp;lt;filter&amp;gt; &amp;lt;branch1&amp;gt; &amp;lt;branch2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;git diff --name-only --diff-filter=&amp;lt;filter&amp;gt; &amp;lt;branch1&amp;gt; &amp;lt;branch2&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43d427754f80d9c8df017cbc0092318835b0e696" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff-index &amp;lt;treeish&amp;gt; [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;git diff-index &amp;lt;treeish&amp;gt; [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f8f3cd0f685b341a1ae14b9341b4e36c903d172" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git diff-index HEAD [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;git diff-index HEAD [-- &amp;lt;pathspecs&amp;gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="332ee7d1accb14409369b51e9d27080d4e0d14ed" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git fetch [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;git fetch [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0083711cca7b02373661eae132e8a9c8507549ec" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git merge [--ff-only] [&amp;lt;committish&amp;gt; | &amp;lt;branch&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;git merge [--ff-only] [&amp;lt;committish&amp;gt; | &amp;lt;branch&amp;gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eabda327026b4f99bb6d32a8fbcdc496382a0b31" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git push [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;git push [&amp;lt;remoteurl&amp;gt;|&amp;lt;repo&amp;gt;] [&amp;lt;refspecs&amp;gt;]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6790132b2a9497e212bac7d4cf8fd0dd3edd5e55" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git reset [--soft | --mixed | --hard] &amp;lt;id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;git reset [--soft | --mixed | --hard] &amp;lt;id&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="652b9155620394c1b1868072030e6b42f726640f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git rev-list --left-right --count &amp;lt;commit1&amp;gt; &amp;lt;commit2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;git rev-list --left-right --count &amp;lt;commit1&amp;gt; &amp;lt;commit2&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="26a71f2870da7113263fbb72943176e45aaa35d2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;git update-index&lt;/code&gt;. Return &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;repo&lt;/code&gt; needs updating.</source>
          <target state="translated">等效于 &lt;code&gt;git update-index&lt;/code&gt; 。如果 &lt;code&gt;repo&lt;/code&gt; 需要更新，则返回 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6ae3107848d44951e6909ca431ab304a4e9d539" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).ctime&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;stat(file).ctime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f6a4ce7135ab64a453fd910fc4aa56e36ba1ee2e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).mode&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;stat(file).mode&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6a1382d7c1945d0f98e93198d22d79e261cf0056" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).mtime&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;stat(file).mtime&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe4fd466e331817e41386a75031f2b796ddfe458" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;stat(file).size&lt;/code&gt;.</source>
          <target state="translated">等效于 &lt;code&gt;stat(file).size&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e823580a07913d38604c722d16a5560458f01a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;view(A,:,:,...,i,:,:,...)&lt;/code&gt; where &lt;code&gt;i&lt;/code&gt; is in position &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">等价于 &lt;code&gt;view(A,:,:,...,i,:,:,...)&lt;/code&gt; ，其中 &lt;code&gt;i&lt;/code&gt; 处于位置 &lt;code&gt;d&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f31ba230aca25c1b698d1cc7150cef0b7b302c5" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;remotecall_eval(Main, procs, expr)&lt;/code&gt;.</source>
          <target state="translated">等效于调用 &lt;code&gt;remotecall_eval(Main, procs, expr)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9eaa630d94bb27275e18bb3b960a961c0a1f0f4b" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;char&lt;/code&gt; c-type.</source>
          <target state="translated">等效于本地 &lt;code&gt;char&lt;/code&gt; c-type。</target>
        </trans-unit>
        <trans-unit id="118bc4f07f9064de09c7d27e3dc69b842c07d3cb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;double&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机 &lt;code&gt;double&lt;/code&gt; &lt;a href=&quot;../numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt; c型（Float64）。</target>
        </trans-unit>
        <trans-unit id="bdf6e4eb22892b98b092275da9c573a01025062d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;float&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机 &lt;code&gt;float&lt;/code&gt; c-type（&lt;a href=&quot;../numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="699b0aa6e72445454df17960d3daa3c9e6cc0497" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;intmax_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本地 &lt;code&gt;intmax_t&lt;/code&gt; c类型（&lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="fb40c99637fa47e326a9d7aab30c227079ce80bd" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;ptrdiff_t&lt;/code&gt; c-type (&lt;code&gt;Int&lt;/code&gt;).</source>
          <target state="translated">等效于本地 &lt;code&gt;ptrdiff_t&lt;/code&gt; c-type（ &lt;code&gt;Int&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="864b89ace5975f766b1aac60a330727b39bce821" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed int&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机 &lt;code&gt;signed int&lt;/code&gt; c类型（&lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="42f2a96aef8ef6b3b801a9ca2e3e8f2afcb4b1e9" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed long long&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机带 &lt;code&gt;signed long long&lt;/code&gt; c-type（&lt;a href=&quot;../numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a5cd170ceee5df72650f75fb3558c1e0d584a0dc" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed long&lt;/code&gt; c-type.</source>
          <target state="translated">等效于本机 &lt;code&gt;signed long&lt;/code&gt; c型。</target>
        </trans-unit>
        <trans-unit id="8bc320fb0e8a7512a786d769855e2e089a153ce2" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;signed short&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int16&quot;&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机带 &lt;code&gt;signed short&lt;/code&gt; c型（&lt;a href=&quot;../numbers/index#Core.Int16&quot;&gt; &lt;code&gt;Int16&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1e69f65df3ca222b477f6e9993f20448b4bdae0f" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;size_t&lt;/code&gt; c-type (&lt;code&gt;UInt&lt;/code&gt;).</source>
          <target state="translated">等效于本机 &lt;code&gt;size_t&lt;/code&gt; c-type（ &lt;code&gt;UInt&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="264d1040fe211b837b556b11ff091efb6a3f53bb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;ssize_t&lt;/code&gt; c-type.</source>
          <target state="translated">等效于本地 &lt;code&gt;ssize_t&lt;/code&gt; c类型。</target>
        </trans-unit>
        <trans-unit id="dbd9e2c996a261d76f3ff53391f8e38719fe9e6e" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;uintmax_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机 &lt;code&gt;uintmax_t&lt;/code&gt; c类型（&lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="1c8ce8fa159766da046ddd33786548e72dee4d9d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned char&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机 &lt;code&gt;unsigned char&lt;/code&gt; c-type（&lt;a href=&quot;../numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="344ab3cdb03d54ba12a0e16e58a7476236a61e4d" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned int&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt32&quot;&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机 &lt;code&gt;unsigned int&lt;/code&gt; c类型（&lt;a href=&quot;../numbers/index#Core.UInt32&quot;&gt; &lt;code&gt;UInt32&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="55d9ab0846117166f39d8e403505f1471a82f976" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned long long&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机 &lt;code&gt;unsigned long long&lt;/code&gt; c类型（&lt;a href=&quot;../numbers/index#Core.UInt64&quot;&gt; &lt;code&gt;UInt64&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="6b3c06e09eab11aa3d1730ea23df9a5045171b15" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned long&lt;/code&gt; c-type.</source>
          <target state="translated">等效于本机 &lt;code&gt;unsigned long&lt;/code&gt; c型。</target>
        </trans-unit>
        <trans-unit id="016e279d1d48e1d87938958891ce84c0cfdfcbbb" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;unsigned short&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机 &lt;code&gt;unsigned short&lt;/code&gt; c类型（&lt;a href=&quot;../numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2c9bbcb68fcb17f0cce9547b0872debb3c579553" translate="yes" xml:space="preserve">
          <source>Equivalent to the native &lt;code&gt;wchar_t&lt;/code&gt; c-type (&lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">等效于本机 &lt;code&gt;wchar_t&lt;/code&gt; c类型（&lt;a href=&quot;../numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">错误处理</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="698b31ff8b5d1a102369509499209b09eacc9225" translate="yes" xml:space="preserve">
          <source>Errors can also be handled by retrying failed computations. Keyword arguments &lt;code&gt;retry_delays&lt;/code&gt; and &lt;code&gt;retry_check&lt;/code&gt; are passed through to &lt;a href=&quot;../../base/base/index#Base.retry&quot;&gt;&lt;code&gt;retry&lt;/code&gt;&lt;/a&gt; as keyword arguments &lt;code&gt;delays&lt;/code&gt; and &lt;code&gt;check&lt;/code&gt; respectively. If batching is specified, and an entire batch fails, all items in the batch are retried.</source>
          <target state="translated">错误也可以通过重试失败的计算来处理。关键字参数 &lt;code&gt;retry_delays&lt;/code&gt; 和 &lt;code&gt;retry_check&lt;/code&gt; 分别作为关键字参数的 &lt;code&gt;delays&lt;/code&gt; 和 &lt;code&gt;check&lt;/code&gt; 传递给&lt;a href=&quot;../../base/base/index#Base.retry&quot;&gt; &lt;code&gt;retry&lt;/code&gt; &lt;/a&gt;。如果指定了批处理，但整个批处理均失败，则将重试该批处理中的所有项目。</target>
        </trans-unit>
        <trans-unit id="e1d7a4876d3316d08fbc2b13153db110692b9665" translate="yes" xml:space="preserve">
          <source>Escaped backslash (&lt;code&gt;\\&lt;/code&gt;)</source>
          <target state="translated">转义的反斜杠（ &lt;code&gt;\\&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="cc1c125b60f307138cb9e72beb52b2e7792689de" translate="yes" xml:space="preserve">
          <source>Escaped double-quote (&lt;code&gt;\&quot;&lt;/code&gt;)</source>
          <target state="translated">转义双引号（ &lt;code&gt;\&quot;&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="06580f39a051b4e6ef99253897a370dadc16359c" translate="yes" xml:space="preserve">
          <source>Essentials</source>
          <target state="translated">Essentials</target>
        </trans-unit>
        <trans-unit id="e8510e15707f994fff8e2c28fa38378116dc350d" translate="yes" xml:space="preserve">
          <source>Estimates</source>
          <target state="translated">Estimates</target>
        </trans-unit>
        <trans-unit id="b9ba339b04699a110d3fe7f5b9f39b67a033e6ff" translate="yes" xml:space="preserve">
          <source>Estimates the error in the solution to &lt;code&gt;A * X = B&lt;/code&gt; (&lt;code&gt;trans = N&lt;/code&gt;), &lt;code&gt;transpose(A) * X = B&lt;/code&gt; (&lt;code&gt;trans = T&lt;/code&gt;), &lt;code&gt;adjoint(A) * X = B&lt;/code&gt; (&lt;code&gt;trans = C&lt;/code&gt;) for &lt;code&gt;side = L&lt;/code&gt;, or the equivalent equations a right-handed &lt;code&gt;side = R&lt;/code&gt;&lt;code&gt;X * A&lt;/code&gt; after computing &lt;code&gt;X&lt;/code&gt; using &lt;code&gt;trtrs!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is upper triangular. If &lt;code&gt;uplo = L&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is lower triangular. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. &lt;code&gt;Ferr&lt;/code&gt; and &lt;code&gt;Berr&lt;/code&gt; are optional inputs. &lt;code&gt;Ferr&lt;/code&gt; is the forward error and &lt;code&gt;Berr&lt;/code&gt; is the backward error, each component-wise.</source>
          <target state="translated">估计在溶液中的错误 &lt;code&gt;A * X = B&lt;/code&gt; （ &lt;code&gt;trans = N&lt;/code&gt; ）， &lt;code&gt;transpose(A) * X = B&lt;/code&gt; （ &lt;code&gt;trans = T&lt;/code&gt; ）， &lt;code&gt;adjoint(A) * X = B&lt;/code&gt; （ &lt;code&gt;trans = C&lt;/code&gt; 为） &lt;code&gt;side = L&lt;/code&gt; ，或等价方程式的右手 &lt;code&gt;side = R&lt;/code&gt; &lt;code&gt;X * A&lt;/code&gt; 然后使用 &lt;code&gt;trtrs!&lt;/code&gt; 计算 &lt;code&gt;X&lt;/code&gt; ！。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 为上三角形。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 为下三角形。如果 &lt;code&gt;diag = N&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 具有非单位对角线元素。如果 &lt;code&gt;diag = U&lt;/code&gt; ，则所有对角元素 &lt;code&gt;A&lt;/code&gt; 是一个。 &lt;code&gt;Ferr&lt;/code&gt; 和 &lt;code&gt;Berr&lt;/code&gt; 是可选输入。每个分量方面， &lt;code&gt;Ferr&lt;/code&gt; 是前向误差，而 &lt;code&gt;Berr&lt;/code&gt; 是后向误差。</target>
        </trans-unit>
        <trans-unit id="f36e35f5e8b00caa694f59163398facd608ea93b" translate="yes" xml:space="preserve">
          <source>Euler Constant / Eulers</source>
          <target state="translated">欧拉常数/欧拉常数</target>
        </trans-unit>
        <trans-unit id="2e207df50d2607a1fe4fc27fe314291135737c83" translate="yes" xml:space="preserve">
          <source>Euler's constant.</source>
          <target state="translated">欧拉常数</target>
        </trans-unit>
        <trans-unit id="44623d7804a9c26efcde5e7649c3cb20b91a39c3" translate="yes" xml:space="preserve">
          <source>Euro Sign</source>
          <target state="translated">欧洲标志</target>
        </trans-unit>
        <trans-unit id="57a3202bd3e441520bd7d609cab598bcb00faf56" translate="yes" xml:space="preserve">
          <source>European Castle</source>
          <target state="translated">欧洲城堡</target>
        </trans-unit>
        <trans-unit id="c85713b44c54b59d5e3730564793b844ff3a2225" translate="yes" xml:space="preserve">
          <source>European Post Office</source>
          <target state="translated">欧洲邮局</target>
        </trans-unit>
        <trans-unit id="70431e2cf67367675e48b7000db056935aff96a4" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt;</source>
          <target state="translated">评估 &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07ce5a176f4ebcfe9263b70e6399c95e665e2889" translate="yes" xml:space="preserve">
          <source>Evaluate &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; and display the result</source>
          <target state="translated">评估 &lt;code&gt;&amp;lt;expr&amp;gt;&lt;/code&gt; 并显示结果</target>
        </trans-unit>
        <trans-unit id="25162b98d6071e304907ff82a3a467fb9271d77e" translate="yes" xml:space="preserve">
          <source>Evaluate an expression in the given module and return the result.</source>
          <target state="translated">在给定模块中评估一个表达式并返回结果。</target>
        </trans-unit>
        <trans-unit id="8f829ca8274917256304e4a58cd74009eea2d9d8" translate="yes" xml:space="preserve">
          <source>Evaluate an expression in the global scope of the containing module. Every &lt;code&gt;Module&lt;/code&gt; (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own 1-argument definition of &lt;code&gt;eval&lt;/code&gt;, which evaluates expressions in that module.</source>
          <target state="translated">在包含模块的全局范围内评估表达式。每个 &lt;code&gt;Module&lt;/code&gt; （除那些用 &lt;code&gt;baremodule&lt;/code&gt; 模块定义的模块外）都有自己的1个参数 &lt;code&gt;eval&lt;/code&gt; 定义，该定义对模块中的表达式求值。</target>
        </trans-unit>
        <trans-unit id="2601dc536c9d898fbb26df788d4c9e5325bd9791" translate="yes" xml:space="preserve">
          <source>Evaluate an expression with values interpolated into it using &lt;code&gt;eval&lt;/code&gt;. If two arguments are provided, the first is the module to evaluate in.</source>
          <target state="translated">使用 &lt;code&gt;eval&lt;/code&gt; 评估一个具有内插值的表达式。如果提供了两个参数，则第一个是要评估的模块。</target>
        </trans-unit>
        <trans-unit id="0e1822550830e88855261b7ab222f92611690733" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of module &lt;code&gt;m&lt;/code&gt;. Every module (except those defined with &lt;a href=&quot;#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt;) has its own 1-argument definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="translated">在模块 &lt;code&gt;m&lt;/code&gt; 的全局范围内评估输入源文件的内容。每个模块（除了那些使用&lt;a href=&quot;#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; &lt;/a&gt;模块定义的模块外）都有自己的 &lt;code&gt;include&lt;/code&gt; 参数的1参数定义，该定义将评估该模块中的文件。返回输入文件最后一次求值表达式的结果。在包含期间，将任务本地包含路径设置为包含文件的目录。 &lt;code&gt;include&lt;/code&gt; 嵌套调用将相对于该路径进行搜索。此功能通常用于以交互方式加载源，或将文件中的文件合并为多个源文件。</target>
        </trans-unit>
        <trans-unit id="b612928c09f072c08e5798d5159ed31466947d90" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of module &lt;code&gt;m&lt;/code&gt;. Every module (except those defined with &lt;a href=&quot;#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt;) has its own definition of &lt;code&gt;include&lt;/code&gt; omitting the &lt;code&gt;m&lt;/code&gt; argument, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d4172b689085063db7676aaaf218e8295b9200" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own 1-argument definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="translated">在包含模块的全局范围内评估输入源文件的内容。每个模块（除了那些使用 &lt;code&gt;baremodule&lt;/code&gt; 模块定义的模块外）都有自己的 &lt;code&gt;include&lt;/code&gt; 参数的1参数定义，该定义将评估该模块中的文件。返回输入文件最后一次求值表达式的结果。在包含期间，将任务本地包含路径设置为包含文件的目录。 &lt;code&gt;include&lt;/code&gt; 嵌套调用将相对于该路径进行搜索。此功能通常用于以交互方式加载源，或将文件中的文件合并为多个源文件。</target>
        </trans-unit>
        <trans-unit id="d9f1c29d4ad5838bc52b4059149cf23bc056eedf" translate="yes" xml:space="preserve">
          <source>Evaluate the contents of the input source file in the global scope of the containing module. Every module (except those defined with &lt;code&gt;baremodule&lt;/code&gt;) has its own definition of &lt;code&gt;include&lt;/code&gt;, which evaluates the file in that module. Returns the result of the last evaluated expression of the input file. During including, a task-local include path is set to the directory containing the file. Nested calls to &lt;code&gt;include&lt;/code&gt; will search relative to that path. This function is typically used to load source interactively, or to combine files in packages that are broken into multiple source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf5bd09edaddcf11f7e48b14ce64a359652894a" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial $\sum_k c[k] z^{k-1}$ for the coefficients &lt;code&gt;c[1]&lt;/code&gt;, &lt;code&gt;c[2]&lt;/code&gt;, ...; that is, the coefficients are given in ascending order by power of &lt;code&gt;z&lt;/code&gt;. This macro expands to efficient inline code that uses either Horner's method or, for complex &lt;code&gt;z&lt;/code&gt;, a more efficient Goertzel-like algorithm.</source>
          <target state="translated">为系数 &lt;code&gt;c[1]&lt;/code&gt; ， &lt;code&gt;c[2]&lt;/code&gt; ，...; 评估多项式$ \ sum_k c [k] z ^ {k-1} $ 。即，系数由 &lt;code&gt;z&lt;/code&gt; 的幂以升序给出。该宏扩展为使用霍纳方法或对于复杂 &lt;code&gt;z&lt;/code&gt; 使用更有效的类似于Goertzel的算法的有效内联代码。</target>
        </trans-unit>
        <trans-unit id="17bdebb1637db1ca1fe9844da888b02d8d7bfdc0" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial $\sum_k x^{k-1} p[k]$ for the coefficients &lt;code&gt;p[1]&lt;/code&gt;, &lt;code&gt;p[2]&lt;/code&gt;, ...; that is, the coefficients are given in ascending order by power of &lt;code&gt;x&lt;/code&gt;. Loops are unrolled at compile time if the number of coefficients is statically known, i.e. when &lt;code&gt;p&lt;/code&gt; is a &lt;code&gt;Tuple&lt;/code&gt;. This function generates efficient code using Horner's method if &lt;code&gt;x&lt;/code&gt; is real, or using a Goertzel-like &lt;sup&gt;&lt;a href=&quot;#footnote-DK62&quot; id=&quot;citeref-DK62&quot;&gt;[DK62]&lt;/a&gt;&lt;/sup&gt; algorithm if &lt;code&gt;x&lt;/code&gt; is complex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c283394a3475c9f10b4259ae3690af8f5faa1d" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial $\sum_k z^{k-1} c[k]$ for the coefficients &lt;code&gt;c[1]&lt;/code&gt;, &lt;code&gt;c[2]&lt;/code&gt;, ...; that is, the coefficients are given in ascending order by power of &lt;code&gt;z&lt;/code&gt;. This macro expands to efficient inline code that uses either Horner's method or, for complex &lt;code&gt;z&lt;/code&gt;, a more efficient Goertzel-like algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf82123eb8f03dbfcdf15d386b828c44539c7f3" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_llvm&quot;&gt;&lt;code&gt;code_llvm&lt;/code&gt;&lt;/a&gt; on the resulting expression. Set the optional keyword arguments &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;dump_module&lt;/code&gt;, &lt;code&gt;debuginfo&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt; by putting them and their value before the function call, like this:</source>
          <target state="translated">计算函数或宏调用的参数，确定其类型，并在结果表达式上调用&lt;a href=&quot;#InteractiveUtils.code_llvm&quot;&gt; &lt;code&gt;code_llvm&lt;/code&gt; &lt;/a&gt;。设置可选的关键字参数 &lt;code&gt;raw&lt;/code&gt; ， &lt;code&gt;dump_module&lt;/code&gt; ， &lt;code&gt;debuginfo&lt;/code&gt; ，通过将它们及其值放在函数调用之前 &lt;code&gt;optimize&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="0574281a0958da4e1fedb99a3969efb400d9fd77" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_native&quot;&gt;&lt;code&gt;code_native&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">计算函数或宏调用的参数，确定其类型，并在结果表达式上调用&lt;a href=&quot;#InteractiveUtils.code_native&quot;&gt; &lt;code&gt;code_native&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="088bbc9cbb660de44f799b6c6a191524f6690255" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;#InteractiveUtils.code_warntype&quot;&gt;&lt;code&gt;code_warntype&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">计算函数或宏调用的参数，确定其类型，并在结果表达式上调用&lt;a href=&quot;#InteractiveUtils.code_warntype&quot;&gt; &lt;code&gt;code_warntype&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="86161509c0da7e0e06a0044e2d468e8408652cab" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;../../base/base/index#Base.code_lowered&quot;&gt;&lt;code&gt;code_lowered&lt;/code&gt;&lt;/a&gt; on the resulting expression.</source>
          <target state="translated">计算函数或宏调用的参数，确定其类型，并在结果表达式上调用&lt;a href=&quot;../../base/base/index#Base.code_lowered&quot;&gt; &lt;code&gt;code_lowered&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d170313f77b7bcf562ce6e89794d222a66dc883d" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls &lt;a href=&quot;../../base/base/index#Base.code_typed&quot;&gt;&lt;code&gt;code_typed&lt;/code&gt;&lt;/a&gt; on the resulting expression. Use the optional argument &lt;code&gt;optimize&lt;/code&gt; with</source>
          <target state="translated">计算函数或宏调用的参数，确定其类型，并在结果表达式上调用&lt;a href=&quot;../../base/base/index#Base.code_typed&quot;&gt; &lt;code&gt;code_typed&lt;/code&gt; &lt;/a&gt;。使用可选参数 &lt;code&gt;optimize&lt;/code&gt; with</target>
        </trans-unit>
        <trans-unit id="84c0397d7e38cfd74be0824e7f63562d46240019" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls the &lt;code&gt;edit&lt;/code&gt; function on the resulting expression.</source>
          <target state="translated">计算函数或宏调用的参数，确定其类型，然后在结果表达式上调用 &lt;code&gt;edit&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="fca23945bcd8a8eb5e9f3ee416d4703a5d82433d" translate="yes" xml:space="preserve">
          <source>Evaluates the arguments to the function or macro call, determines their types, and calls the &lt;code&gt;less&lt;/code&gt; function on the resulting expression.</source>
          <target state="translated">计算函数或宏调用的参数，确定其类型，然后在结果表达式上调用 &lt;code&gt;less&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="2278317a19c030d07ee978a6edb3e56c37e01040" translate="yes" xml:space="preserve">
          <source>Evaluating expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbabc83f5b048a0e83e97e9b394f27da706b3e88" translate="yes" xml:space="preserve">
          <source>Evaluation Scope of Default Values</source>
          <target state="translated">默认值的评估范围</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="01624c7776323f5a2680a97bd186745ab3cf1f28" translate="yes" xml:space="preserve">
          <source>Event processing is controlled by overriding functions associated with &lt;code&gt;AbstractLogger&lt;/code&gt;:</source>
          <target state="translated">事件处理由与 &lt;code&gt;AbstractLogger&lt;/code&gt; 关联的重写函数控制：</target>
        </trans-unit>
        <trans-unit id="c5497bca58468ae64aed6c0fd921109217988db3" translate="yes" xml:space="preserve">
          <source>Events</source>
          <target state="translated">Events</target>
        </trans-unit>
        <trans-unit id="e8a98dc3ac17ae3d77b1ddc48b9496c80b2623e7" translate="yes" xml:space="preserve">
          <source>Evergreen Tree</source>
          <target state="translated">常青树</target>
        </trans-unit>
        <trans-unit id="5d19898d878c5e7ae6a6206e54d456e97f3d4151" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;../modules/index#modules&quot;&gt;module&lt;/a&gt; has its own &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; function that evaluates expressions in its global scope. Expressions passed to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; are not limited to returning values &amp;ndash; they can also have side-effects that alter the state of the enclosing module's environment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d21058e9a447b8fa599cb386e31bf0f68fa38e3" translate="yes" xml:space="preserve">
          <source>Every &lt;a href=&quot;../modules/index#modules-1&quot;&gt;module&lt;/a&gt; has its own &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; function that evaluates expressions in its global scope. Expressions passed to &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; are not limited to returning values &amp;ndash; they can also have side-effects that alter the state of the enclosing module's environment:</source>
          <target state="translated">每个&lt;a href=&quot;../modules/index#modules-1&quot;&gt;模块&lt;/a&gt;都有其自己的&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;函数，该函数在其全局范围内评估表达式。传递给&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 的&lt;/a&gt;表达式不仅限于返回值-它们还可能具有副作用，这些副作用会改变封闭模块环境的状态：</target>
        </trans-unit>
        <trans-unit id="ff9db205866ccce1546fa3a3f0dcf16499413e68" translate="yes" xml:space="preserve">
          <source>Every Julia program starts life as a string:</source>
          <target state="translated">每个Julia程序都是以一个字符串的形式开始的。</target>
        </trans-unit>
        <trans-unit id="554f49a29b61819b844be413863c737b1ffe0f6b" translate="yes" xml:space="preserve">
          <source>Every binary arithmetic and bitwise operator also has an updating version that assigns the result of the operation back into its left operand. The updating version of the binary operator is formed by placing a &lt;code&gt;=&lt;/code&gt; immediately after the operator. For example, writing &lt;code&gt;x += 3&lt;/code&gt; is equivalent to writing &lt;code&gt;x = x + 3&lt;/code&gt;:</source>
          <target state="translated">每个二进制算术和按位运算符还具有一个更新版本，该版本将运算结果分配回其左操作数。二进制运算符的更新版本是通过在运算符后紧跟一个 &lt;code&gt;=&lt;/code&gt; 来形成的。例如，写 &lt;code&gt;x += 3&lt;/code&gt; 等效于写 &lt;code&gt;x = x + 3&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="74d163370c2dd6c3a91981ad81aefa6f4ddbb3ff" translate="yes" xml:space="preserve">
          <source>Every concrete value in the system is an instance of some &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">系统中的每个具体值都是某些 &lt;code&gt;DataType&lt;/code&gt; 的实例。</target>
        </trans-unit>
        <trans-unit id="8f6ede3443e8f7e99e3d1681b81b7bd2c9c393a0" translate="yes" xml:space="preserve">
          <source>Every worker is also notified of other workers in the cluster.</source>
          <target state="translated">每个工人也会被通知到群里的其他工人。</target>
        </trans-unit>
        <trans-unit id="3da573171e36ece7f0a3ae53192e2857a7114b29" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;complex double&lt;/code&gt; type in C (or &lt;code&gt;COMPLEX*16&lt;/code&gt; in Fortran).</source>
          <target state="translated">完全对应于C中的 &lt;code&gt;complex double&lt;/code&gt; 类型（或Fortran中的 &lt;code&gt;COMPLEX*16&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="12b877c370c66bac293ce599efbe5b9cfed8d671" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;complex float&lt;/code&gt; type in C (or &lt;code&gt;COMPLEX*8&lt;/code&gt; in Fortran).</source>
          <target state="translated">完全对应于C中的 &lt;code&gt;complex float&lt;/code&gt; 类型（或Fortran中的 &lt;code&gt;COMPLEX*8&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="9f324ad0c495e9b10cd207dd5c4138beb2a008e4" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;double&lt;/code&gt; type in C (or &lt;code&gt;REAL*8&lt;/code&gt; in Fortran).</source>
          <target state="translated">完全对应于C中的 &lt;code&gt;double&lt;/code&gt; 类型（或Fortran中的 &lt;code&gt;REAL*8&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="3f6752421aa22fb1eeb8d2fd5badfc564def668c" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;float&lt;/code&gt; type in C (or &lt;code&gt;REAL*4&lt;/code&gt; in Fortran).</source>
          <target state="translated">完全对应于C中的 &lt;code&gt;float&lt;/code&gt; 类型（或Fortran中的 &lt;code&gt;REAL*4&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6cffeb7c4b2c762c65b636222df4fb94787880c0" translate="yes" xml:space="preserve">
          <source>Exactly corresponds to the &lt;code&gt;signed&lt;/code&gt; type annotation in C (or any &lt;code&gt;INTEGER&lt;/code&gt; type in Fortran). Any Julia type that is not a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; is assumed to be unsigned.</source>
          <target state="translated">完全对应于C中的带 &lt;code&gt;signed&lt;/code&gt; 类型注释（或Fortran中的任何 &lt;code&gt;INTEGER&lt;/code&gt; 类型）。任何不是&lt;a href=&quot;../../base/numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt;子类型的Julia类型都被假定为未签名。</target>
        </trans-unit>
        <trans-unit id="0d1330aca84c1389777df28581b8c82cd98c2394" translate="yes" xml:space="preserve">
          <source>Examining &lt;code&gt;hello.txt&lt;/code&gt; again will show its contents have been changed.</source>
          <target state="translated">再次检查 &lt;code&gt;hello.txt&lt;/code&gt; 将显示其内容已更改。</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="1e20cb09b4bf0570e117bfae2c451577f63f7028" translate="yes" xml:space="preserve">
          <source>Example using an external library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="373a52dcd1b4d765302f9139879ce9f9a0fb8c90" translate="yes" xml:space="preserve">
          <source>Example: On errors, retry &lt;code&gt;f&lt;/code&gt; on an element a maximum of 3 times without any delay between retries.</source>
          <target state="translated">示例：出现错误时，最多对元素重试 &lt;code&gt;f&lt;/code&gt; 3次，而两次重试之间没有任何延迟。</target>
        </trans-unit>
        <trans-unit id="e833cacc44d10e154db82262037462cf8beef7f2" translate="yes" xml:space="preserve">
          <source>Example: Retry &lt;code&gt;f&lt;/code&gt; only if the exception is not of type &lt;a href=&quot;../../base/base/index#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt;, with exponentially increasing delays up to 3 times. Return a &lt;code&gt;NaN&lt;/code&gt; in place for all &lt;code&gt;InexactError&lt;/code&gt; occurrences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a35fb66c95d0cf88768455058261ed6959091e5" translate="yes" xml:space="preserve">
          <source>Example: Retry &lt;code&gt;f&lt;/code&gt; only if the exception is not of type &lt;code&gt;InexactError&lt;/code&gt;, with exponentially increasing delays up to 3 times. Return a &lt;code&gt;NaN&lt;/code&gt; in place for all &lt;code&gt;InexactError&lt;/code&gt; occurrences.</source>
          <target state="translated">示例：仅当异常不是 &lt;code&gt;InexactError&lt;/code&gt; 类型的异常时才重试 &lt;code&gt;f&lt;/code&gt; ，延迟以指数方式增加最多3倍。对于所有 &lt;code&gt;InexactError&lt;/code&gt; 事件，均返回 &lt;code&gt;NaN&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="b9efd4419a008bc5f5f67da74017e3ce7f66e0fb" translate="yes" xml:space="preserve">
          <source>Examples of operations involving I/O include reading/writing to files, accessing web services, executing external programs, etc. In all these cases, overall execution time can be improved if other tasks can be run while a file is being read, or while waiting for an external service/program to complete.</source>
          <target state="translated">涉及I/O的操作实例包括对文件的读/写、访问Web服务、执行外部程序等。在所有这些情况下,如果可以在读取文件的同时运行其他任务,或者在等待外部服务/程序完成的同时运行其他任务,则可以提高整体执行时间。</target>
        </trans-unit>
        <trans-unit id="9f82b594b309c2e2430648d834395134902abf67" translate="yes" xml:space="preserve">
          <source>Examples should, whenever possible, be written as &lt;em&gt;doctests&lt;/em&gt;. A &lt;em&gt;doctest&lt;/em&gt; is a fenced code block (see &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks&quot;&gt;Code blocks&lt;/a&gt;) starting with &lt;code&gt;```jldoctest&lt;/code&gt; and contains any number of &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompts together with inputs and expected outputs that mimic the Julia REPL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ca7a5cb7aef9e6990554e02b239447ff53ee134" translate="yes" xml:space="preserve">
          <source>Examples should, whenever possible, be written as &lt;em&gt;doctests&lt;/em&gt;. A &lt;em&gt;doctest&lt;/em&gt; is a fenced code block (see &lt;a href=&quot;../../stdlib/markdown/index#Code-blocks-1&quot;&gt;Code blocks&lt;/a&gt;) starting with &lt;code&gt;```jldoctest&lt;/code&gt; and contains any number of &lt;code&gt;julia&amp;gt;&lt;/code&gt; prompts together with inputs and expected outputs that mimic the Julia REPL.</source>
          <target state="translated">示例应尽可能以&lt;em&gt;doctests的&lt;/em&gt;形式编写。甲&lt;em&gt;文档测试&lt;/em&gt;是一个围栏码块（见&lt;a href=&quot;../../stdlib/markdown/index#Code-blocks-1&quot;&gt;代码块&lt;/a&gt;）开始与 &lt;code&gt;```jldoctest&lt;/code&gt; 和含有任何数目的 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 具有输入和预期产出模仿朱莉娅REPL一起提示。</target>
        </trans-unit>
        <trans-unit id="2056efb231cce98ac0668dedf4d2bf625aba4a55" translate="yes" xml:space="preserve">
          <source>Examples that are untestable should be written within fenced code blocks starting with &lt;code&gt;```julia&lt;/code&gt; so that they are highlighted correctly in the generated documentation.</source>
          <target state="translated">不可测试的示例应该写在以 &lt;code&gt;```julia&lt;/code&gt; ''开头的受围代码块中，以便在生成的文档中正确突出显示它们。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="20788aa11834509830be30396b88f6404f087e8c" translate="yes" xml:space="preserve">
          <source>Exception Handling</source>
          <target state="translated">异常处理</target>
        </trans-unit>
        <trans-unit id="bf77702e21f59d94d4eb46c5b52d82853eea421c" translate="yes" xml:space="preserve">
          <source>Exception handling in Julia is done using &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;catch&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;, instead of &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;except&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;. In contrast to Python, it is not recommended to use exception handling as part of the normal workflow in Julia due to performance reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b93cbc45254a123c56a8eaff87f67380fa6af7a8" translate="yes" xml:space="preserve">
          <source>Exception stacks and &lt;code&gt;catch_stack&lt;/code&gt;</source>
          <target state="translated">异常堆栈和 &lt;code&gt;catch_stack&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d404b3b66335698d08bc7e83b3b1da3bf0caaf78" translate="yes" xml:space="preserve">
          <source>Exception stacks requires at least Julia 1.1.</source>
          <target state="translated">异常堆栈至少需要Julia 1.1。</target>
        </trans-unit>
        <trans-unit id="a7f19469182a37332b5dea18474c06d9a6cffcd0" translate="yes" xml:space="preserve">
          <source>Exception thrown when a &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; value is encountered in a situation where it is not supported. The error message, in the &lt;code&gt;msg&lt;/code&gt; field may provide more specific details.</source>
          <target state="translated">在不支持该值的情况下遇到&lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值时引发的异常。 &lt;code&gt;msg&lt;/code&gt; 字段中的错误消息可能会提供更多详细信息。</target>
        </trans-unit>
        <trans-unit id="2886bf315699a79be72431b11e875ca8880a85db" translate="yes" xml:space="preserve">
          <source>Exception thrown when a matrix factorization/solve encounters a zero in a pivot (diagonal) position and cannot proceed. This may &lt;em&gt;not&lt;/em&gt; mean that the matrix is singular: it may be fruitful to switch to a diffent factorization such as pivoted LU that can re-order variables to eliminate spurious zero pivots. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the zero pivot(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a497fe30a5347da8aff63c8337366f7a84f4058" translate="yes" xml:space="preserve">
          <source>Exception thrown when the input matrix has one or more zero-valued eigenvalues, and is not invertible. A linear solve involving such a matrix cannot be computed. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the singular value(s).</source>
          <target state="translated">当输入矩阵具有一个或多个零值特征值且不可逆时，抛出异常。无法计算涉及这种矩阵的线性解。的 &lt;code&gt;info&lt;/code&gt; 字段指示的位置（之一）的奇异值（一个或多个）。</target>
        </trans-unit>
        <trans-unit id="2023c26839abcfb0ae82bfd1150e32fbc284d2ca" translate="yes" xml:space="preserve">
          <source>Exception thrown when the input matrix was not &lt;a href=&quot;https://en.wikipedia.org/wiki/Definiteness_of_a_matrix&quot;&gt;positive definite&lt;/a&gt;. Some linear algebra functions and factorizations are only applicable to positive definite matrices. The &lt;code&gt;info&lt;/code&gt; field indicates the location of (one of) the eigenvalue(s) which is (are) less than/equal to 0.</source>
          <target state="translated">当输入矩阵不是&lt;a href=&quot;https://en.wikipedia.org/wiki/Definiteness_of_a_matrix&quot;&gt;正&lt;/a&gt;定时抛出异常。一些线性代数函数和因式分解仅适用于正定矩阵。的 &lt;code&gt;info&lt;/code&gt; 字段指示的位置（之一）的本征值（S），其是（是）小于/等于0。</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="82857d1e87d55237f9f3e372603e440bfa06f318" translate="yes" xml:space="preserve">
          <source>Exceptions can be created explicitly with &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt;. For example, a function defined only for nonnegative numbers could be written to &lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; a &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; if the argument is negative:</source>
          <target state="translated">可以使用&lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;显式创建异常。例如，函数定义仅适用于非负数可以写入&lt;a href=&quot;../../base/base/index#Core.throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;一个&lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt;如果参数为负：</target>
        </trans-unit>
        <trans-unit id="e4ba2f79f23d1d745b18049a3459429b5707c9cf" translate="yes" xml:space="preserve">
          <source>Exceptions on remote computations are captured and rethrown locally. A &lt;code&gt;RemoteException&lt;/code&gt; wraps the &lt;code&gt;pid&lt;/code&gt; of the worker and a captured exception. A &lt;code&gt;CapturedException&lt;/code&gt; captures the remote exception and a serializable form of the call stack when the exception was raised.</source>
          <target state="translated">远程计算的异常被捕获并在本地重新抛出。一个 &lt;code&gt;RemoteException&lt;/code&gt; 的包裹 &lt;code&gt;pid&lt;/code&gt; 工人和捕获异常。甲 &lt;code&gt;CapturedException&lt;/code&gt; 捕获远程异常和调用堆栈的序列化的形式时异常升高。</target>
        </trans-unit>
        <trans-unit id="47a6e6d3c2e9b02e1dbab62db882a7f9616c024c" translate="yes" xml:space="preserve">
          <source>Exceptions that occur while generating the log event are captured and logged by default. This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system. This behavior can be customized per logger type by extending &lt;a href=&quot;#Base.CoreLogging.catch_exceptions&quot;&gt;&lt;code&gt;Logging.catch_exceptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">默认情况下会捕获并记录生成日志事件时发生的异常。这样可以防止单个中断事件使应用程序崩溃，这在启用生产系统中很少使用的调试事件时很有用。可以通过扩展&lt;a href=&quot;#Base.CoreLogging.catch_exceptions&quot;&gt; &lt;code&gt;Logging.catch_exceptions&lt;/code&gt; &lt;/a&gt;来针对每种记录器类型自定义此行为。</target>
        </trans-unit>
        <trans-unit id="20d32bee5048387540915f82b1cf8f99bd32d983" translate="yes" xml:space="preserve">
          <source>Exceptions that occur while generating the log event are captured and logged by default. This prevents individual broken events from crashing the application, which is helpful when enabling little-used debug events in a production system. This behavior can be customized per logger type by extending &lt;a href=&quot;#Logging.catch_exceptions&quot;&gt;&lt;code&gt;Logging.catch_exceptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249bab0d837de1c736ed6cf322c1023e34887589" translate="yes" xml:space="preserve">
          <source>Excessive use will likely lead to poor performance.</source>
          <target state="translated">过度使用将可能导致性能不佳。</target>
        </trans-unit>
        <trans-unit id="f389ff868b8af6a6f2f6d30e8b679e098d301b92" translate="yes" xml:space="preserve">
          <source>Exchange the current position with the mark</source>
          <target state="translated">将当前的位置与标记交换</target>
        </trans-unit>
        <trans-unit id="c80276d7c0f717bb4d551e808f6db2511c2186fe" translate="yes" xml:space="preserve">
          <source>Exclamation Question Mark</source>
          <target state="translated">感叹号</target>
        </trans-unit>
        <trans-unit id="dac1fed7304cfae795fbd37d78d8443ee698fee8" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;f&lt;/code&gt; in an environment that is temporarily modified (not replaced as in &lt;code&gt;setenv&lt;/code&gt;) by zero or more &lt;code&gt;&quot;var&quot;=&amp;gt;val&lt;/code&gt; arguments &lt;code&gt;kv&lt;/code&gt;. &lt;code&gt;withenv&lt;/code&gt; is generally used via the &lt;code&gt;withenv(kv...) do ... end&lt;/code&gt; syntax. A value of &lt;code&gt;nothing&lt;/code&gt; can be used to temporarily unset an environment variable (if it is set). When &lt;code&gt;withenv&lt;/code&gt; returns, the original environment has been restored.</source>
          <target state="translated">在被零个或多个 &lt;code&gt;&quot;var&quot;=&amp;gt;val&lt;/code&gt; 参数 &lt;code&gt;kv&lt;/code&gt; 临时修改（而不是在 &lt;code&gt;setenv&lt;/code&gt; 中代替）的环境中执行 &lt;code&gt;f&lt;/code&gt; 。 &lt;code&gt;withenv&lt;/code&gt; 通常通过 &lt;code&gt;withenv(kv...) do ... end&lt;/code&gt; 语法使用。的值 &lt;code&gt;nothing&lt;/code&gt; 可以被用于临时取消设置的环境变量（如果它是集）。当 &lt;code&gt;withenv&lt;/code&gt; 回报，原来的环境已经恢复。</target>
        </trans-unit>
        <trans-unit id="303c63e1f5cb3dac07df60b3ba1c0270b3b39672" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;function&lt;/code&gt;, directing all log messages to &lt;code&gt;logger&lt;/code&gt;.</source>
          <target state="translated">执行 &lt;code&gt;function&lt;/code&gt; ，将所有日志消息定向到 &lt;code&gt;logger&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bad793892b867876bd2fc3271d9d2236468940a7" translate="yes" xml:space="preserve">
          <source>Execute Permission</source>
          <target state="translated">执行权限</target>
        </trans-unit>
        <trans-unit id="ccf93fd6554ca73378cd7ef4e9dc68bcbb434afc" translate="yes" xml:space="preserve">
          <source>Execute a transformed version of the expression, which calls functions that may violate strict IEEE semantics. This allows the fastest possible operation, but results are undefined &amp;ndash; be careful when doing this, as it may change numerical results.</source>
          <target state="translated">执行表达式的转换版本，该版本调用可能违反严格的IEEE语义的函数。这样可以实现最快的操作，但结果不确定-执行此操作时要小心，因为它可能会改变数值结果。</target>
        </trans-unit>
        <trans-unit id="5e27a1a745ad8902705c2e6ab83a0903098f9f06" translate="yes" xml:space="preserve">
          <source>Execute an expression under &lt;code&gt;Main&lt;/code&gt; on all &lt;code&gt;procs&lt;/code&gt;. Errors on any of the processes are collected into a &lt;a href=&quot;../../base/base/index#Base.CompositeException&quot;&gt;&lt;code&gt;CompositeException&lt;/code&gt;&lt;/a&gt; and thrown. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c9df83ba80f7ea05232757e37fd45c85f102a7b" translate="yes" xml:space="preserve">
          <source>Execute an expression under &lt;code&gt;Main&lt;/code&gt; on all &lt;code&gt;procs&lt;/code&gt;. Errors on any of the processes are collected into a &lt;code&gt;CompositeException&lt;/code&gt; and thrown. For example:</source>
          <target state="translated">对所有 &lt;code&gt;procs&lt;/code&gt; 在 &lt;code&gt;Main&lt;/code&gt; 下执行一个表达式。任何进程的错误都被收集到 &lt;code&gt;CompositeException&lt;/code&gt; 中并抛出。例如：</target>
        </trans-unit>
        <trans-unit id="ef0298149bb24a28fd471679846d07a4d0087cc3" translate="yes" xml:space="preserve">
          <source>Executes &lt;code&gt;f&lt;/code&gt; on worker &lt;code&gt;id&lt;/code&gt; asynchronously. Unlike &lt;a href=&quot;#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;remotecall&lt;/code&gt;&lt;/a&gt;, it does not store the result of computation, nor is there a way to wait for its completion.</source>
          <target state="translated">异步对worker &lt;code&gt;id&lt;/code&gt; 执行 &lt;code&gt;f&lt;/code&gt; 。与&lt;a href=&quot;#Distributed.remotecall-Tuple%7BAny,Integer,Vararg%7BAny,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;remotecall&lt;/code&gt; &lt;/a&gt;不同，它不存储计算结果，也没有方法等待其完成。</target>
        </trans-unit>
        <trans-unit id="acb80322579157531d28a7bec37d10ea4056bc6f" translate="yes" xml:space="preserve">
          <source>Executing the above snippet results in &lt;code&gt;Main.A&lt;/code&gt; on worker 2 having a different value from &lt;code&gt;Main.A&lt;/code&gt; on worker 3, while the value of &lt;code&gt;Main.A&lt;/code&gt; on node 1 is set to &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">执行上面的片段导致 &lt;code&gt;Main.A&lt;/code&gt; 上具有不同的值工人2 &lt;code&gt;Main.A&lt;/code&gt; 对工人3，而值 &lt;code&gt;Main.A&lt;/code&gt; 在节点1被设定为 &lt;code&gt;nothing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="911180ac9cebe24cefdcdd1680b9c49387acd612" translate="yes" xml:space="preserve">
          <source>Exit (when buffer is empty)</source>
          <target state="translated">退出(缓冲区为空时</target>
        </trans-unit>
        <trans-unit id="d477eb857db4070fa5362225484e2e2cc1160414" translate="yes" xml:space="preserve">
          <source>Exit hooks are allowed to call &lt;code&gt;exit(n)&lt;/code&gt;, in which case Julia will exit with exit code &lt;code&gt;n&lt;/code&gt; (instead of the original exit code). If more than one exit hook calls &lt;code&gt;exit(n)&lt;/code&gt;, then Julia will exit with the exit code corresponding to the last called exit hook that calls &lt;code&gt;exit(n)&lt;/code&gt;. (Because exit hooks are called in LIFO order, &quot;last called&quot; is equivalent to &quot;first registered&quot;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67fb80361f00a1ef919b8a402eb0fa8767e88aa3" translate="yes" xml:space="preserve">
          <source>Expand to a string with the absolute path to the directory of the file containing the macrocall. Return the current working directory if run from a REPL or if evaluated by &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">展开为包含包含宏调用的文件目录的绝对路径的字符串。如果从REPL运行或由 &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt; 评估，则返回当前工作目录。</target>
        </trans-unit>
        <trans-unit id="43f7e4fd43efc93c7c61b01d066abbb6ecd0ad58" translate="yes" xml:space="preserve">
          <source>Expand to a string with the path to the file containing the macrocall, or an empty string if evaluated by &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt;. Return &lt;code&gt;nothing&lt;/code&gt; if the macro was missing parser source information. Alternatively see &lt;a href=&quot;../constants/index#Base.PROGRAM_FILE&quot;&gt;&lt;code&gt;PROGRAM_FILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">扩展为包含宏调用的文件路径的字符串，如果由 &lt;code&gt;julia -e &amp;lt;expr&amp;gt;&lt;/code&gt; 求值则为空字符串。如果宏缺少解析器源信息，则不返回 &lt;code&gt;nothing&lt;/code&gt; 。或者，请参阅&lt;a href=&quot;../constants/index#Base.PROGRAM_FILE&quot;&gt; &lt;code&gt;PROGRAM_FILE&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1f8c8a91207271c3979e8b044e269e773310cb43" translate="yes" xml:space="preserve">
          <source>Expand to the line number of the location of the macrocall. Return &lt;code&gt;0&lt;/code&gt; if the line number could not be determined.</source>
          <target state="translated">展开到宏调用位置的行号。如果无法确定行号，则返回 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c980fcdbd3756987bdd9be9bd2691a2d11e6223d" translate="yes" xml:space="preserve">
          <source>Expecting the filesystem to be unchanged between compile-time and runtime e.g. &lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt;&lt;code&gt;@__FILE__&lt;/code&gt;&lt;/a&gt;/&lt;code&gt;source_path()&lt;/code&gt; to find resources at runtime, or the BinDeps &lt;code&gt;@checked_lib&lt;/code&gt; macro. Sometimes this is unavoidable. However, when possible, it can be good practice to copy resources into the module at compile-time so they won't need to be found at runtime.</source>
          <target state="translated">期望文件系统在编译时和运行时之间保持不变，例如&lt;a href=&quot;../../base/file/index#Base.@__FILE__&quot;&gt; &lt;code&gt;@__FILE__&lt;/code&gt; &lt;/a&gt; / &lt;code&gt;source_path()&lt;/code&gt; 以便在运行时查找资源，或使用BinDeps &lt;code&gt;@checked_lib&lt;/code&gt; 宏。有时这是不可避免的。但是，在可能的情况下，最好在编译时将资源复制到模块中，这样就无需在运行时找到它们。</target>
        </trans-unit>
        <trans-unit id="ef01e9964e65833fa4da94fa27761fbd0428c0b5" translate="yes" xml:space="preserve">
          <source>Experimental multithreading support.</source>
          <target state="translated">实验性的多线程支持。</target>
        </trans-unit>
        <trans-unit id="d1e10c5f2ecca7a990bcf252a20b9966c63ad49c" translate="yes" xml:space="preserve">
          <source>Explicitly finds &lt;code&gt;Q&lt;/code&gt;, the orthogonal/unitary matrix from &lt;code&gt;gehrd!&lt;/code&gt;. &lt;code&gt;ilo&lt;/code&gt;, &lt;code&gt;ihi&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;tau&lt;/code&gt; must correspond to the input/output to &lt;code&gt;gehrd!&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;gehrd!&lt;/code&gt; 明确找到 &lt;code&gt;Q&lt;/code&gt; ，正交/ unit矩阵！。 &lt;code&gt;ilo&lt;/code&gt; ， &lt;code&gt;ihi&lt;/code&gt; ， &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;tau&lt;/code&gt; 必须对应于 &lt;code&gt;gehrd!&lt;/code&gt; 的输入/输出！。</target>
        </trans-unit>
        <trans-unit id="d89ba743e7b20b3225440e90c3ccf3bf8748afa9" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;LQ&lt;/code&gt; factorization after calling &lt;code&gt;gelqf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;gelqf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;gelqf!&lt;/code&gt; 后，明确找到 &lt;code&gt;LQ&lt;/code&gt; 因式分解的矩阵 &lt;code&gt;Q&lt;/code&gt; ！在 &lt;code&gt;A&lt;/code&gt; 上。使用 &lt;code&gt;gelqf!&lt;/code&gt; 的输出！。 &lt;code&gt;A&lt;/code&gt; 被 &lt;code&gt;Q&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="842467dd8285c3ac06d28f0f33b4e3294049f962" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;QL&lt;/code&gt; factorization after calling &lt;code&gt;geqlf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;geqlf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;geqlf!&lt;/code&gt; 后，明确找到 &lt;code&gt;QL&lt;/code&gt; 因式分解的矩阵 &lt;code&gt;Q&lt;/code&gt; ！在 &lt;code&gt;A&lt;/code&gt; 上。使用 &lt;code&gt;geqlf!&lt;/code&gt; 的输出！。 &lt;code&gt;A&lt;/code&gt; 被 &lt;code&gt;Q&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="8ece9405b82e399d70d34379e646461b54cd5e7c" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;QR&lt;/code&gt; factorization after calling &lt;code&gt;geqrf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;geqrf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;geqrf!&lt;/code&gt; 后，明确找到 &lt;code&gt;QR&lt;/code&gt; 因式分解的矩阵 &lt;code&gt;Q&lt;/code&gt; ！在 &lt;code&gt;A&lt;/code&gt; 上。使用 &lt;code&gt;geqrf!&lt;/code&gt; 的输出！。 &lt;code&gt;A&lt;/code&gt; 被 &lt;code&gt;Q&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="54b7a9812258e65fe016e3ff6743203ffc052ea2" translate="yes" xml:space="preserve">
          <source>Explicitly finds the matrix &lt;code&gt;Q&lt;/code&gt; of a &lt;code&gt;RQ&lt;/code&gt; factorization after calling &lt;code&gt;gerqf!&lt;/code&gt; on &lt;code&gt;A&lt;/code&gt;. Uses the output of &lt;code&gt;gerqf!&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">调用 &lt;code&gt;gerqf!&lt;/code&gt; 后，明确找到 &lt;code&gt;RQ&lt;/code&gt; 因式分解的矩阵 &lt;code&gt;Q&lt;/code&gt; ！在 &lt;code&gt;A&lt;/code&gt; 上。使用 &lt;code&gt;gerqf!&lt;/code&gt; 的输出！。 &lt;code&gt;A&lt;/code&gt; 被 &lt;code&gt;Q&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="50220615494147fbec7eb0d31ca7ba3a82c81db3" translate="yes" xml:space="preserve">
          <source>Explicitly passing &lt;code&gt;task&lt;/code&gt; will return the current exception stack on an arbitrary task. This is useful for inspecting tasks which have failed due to uncaught exceptions.</source>
          <target state="translated">显式传递的 &lt;code&gt;task&lt;/code&gt; 将在任意任务上返回当前异常堆栈。这对于检查由于未捕获的异常而失败的任务很有用。</target>
        </trans-unit>
        <trans-unit id="90b58b7713ee5ebddd55f78493a86426624ddf35" translate="yes" xml:space="preserve">
          <source>ExponentialBackOff</source>
          <target state="translated">ExponentialBackOff</target>
        </trans-unit>
        <trans-unit id="d165ee97f26b031b938fc12621899c47ca3e7175" translate="yes" xml:space="preserve">
          <source>Exponentiation</source>
          <target state="translated">Exponentiation</target>
        </trans-unit>
        <trans-unit id="23bf8b64f7777c5abac718af8c1d4675c08d1bd7" translate="yes" xml:space="preserve">
          <source>Exponentiation operator. If &lt;code&gt;x&lt;/code&gt; is a matrix, computes matrix exponentiation.</source>
          <target state="translated">求幂运算符。如果 &lt;code&gt;x&lt;/code&gt; 是矩阵，则计算矩阵幂。</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="2ffaab085f397ec888c88af14ff5370679b8c9cd" translate="yes" xml:space="preserve">
          <source>Expressionless Face</source>
          <target state="translated">无表情的脸</target>
        </trans-unit>
        <trans-unit id="88cbc8428bc0cead64822d528b5aeb2ed594f6d0" translate="yes" xml:space="preserve">
          <source>Expressions and evaluation</source>
          <target state="translated">表达式和评价</target>
        </trans-unit>
        <trans-unit id="395de5a745d120d755d181c48640612c62257526" translate="yes" xml:space="preserve">
          <source>Expressions executed remotely via &lt;code&gt;@spawn&lt;/code&gt;, or closures specified for remote execution using &lt;code&gt;remotecall&lt;/code&gt; may refer to global variables. Global bindings under module &lt;code&gt;Main&lt;/code&gt; are treated a little differently compared to global bindings in other modules. Consider the following code snippet:</source>
          <target state="translated">经由远程执行表达式 &lt;code&gt;@spawn&lt;/code&gt; 使用用于远程执行指定，或者封闭件 &lt;code&gt;remotecall&lt;/code&gt; 可以指全局变量。与其他模块中的全局绑定相比，模块 &lt;code&gt;Main&lt;/code&gt; 下的全局绑定的处理方式略有不同。考虑以下代码片段：</target>
        </trans-unit>
        <trans-unit id="c021e85f0971c261cc893329ddbecca6139c6c2b" translate="yes" xml:space="preserve">
          <source>Expressions executed remotely via &lt;code&gt;@spawnat&lt;/code&gt;, or closures specified for remote execution using &lt;code&gt;remotecall&lt;/code&gt; may refer to global variables. Global bindings under module &lt;code&gt;Main&lt;/code&gt; are treated a little differently compared to global bindings in other modules. Consider the following code snippet:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bdaffe5a439039b7bf8f6bd820ea137bfdd1da7" translate="yes" xml:space="preserve">
          <source>Expressions may also be constructed directly in &lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;prefix notation&lt;/a&gt;:</source>
          <target state="translated">表达式也可以直接用&lt;a href=&quot;https://en.wikipedia.org/wiki/Polish_notation&quot;&gt;前缀表示法&lt;/a&gt;构造：</target>
        </trans-unit>
        <trans-unit id="499636f8c38809ad543e77eff829b775812e07ab" translate="yes" xml:space="preserve">
          <source>Expressions provided by the parser generally only have symbols, other expressions, and literal values as their args, whereas expressions constructed by Julia code can have arbitrary run-time values without literal forms as args. In this specific example, &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; are symbols, &lt;code&gt;*(b,c)&lt;/code&gt; is a subexpression, and &lt;code&gt;1&lt;/code&gt; is a literal 64-bit signed integer.</source>
          <target state="translated">解析器提供的表达式通常仅将符号，其他表达式和文字值作为其args，而由Julia代码构造的表达式可以具有任意运行时值，而没有文字形式的args。在此特定示例中， &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;a&lt;/code&gt; 是符号， &lt;code&gt;*(b,c)&lt;/code&gt; 是子表达式，而 &lt;code&gt;1&lt;/code&gt; 是字面量的64位带符号整数。</target>
        </trans-unit>
        <trans-unit id="7f0edd94f804e2ef96353f1dd584892a96db61b3" translate="yes" xml:space="preserve">
          <source>Expressions starting with &lt;code&gt;0x&lt;/code&gt; are always hexadecimal literals.</source>
          <target state="translated">以 &lt;code&gt;0x&lt;/code&gt; 开头的表达式始终是十六进制文字。</target>
        </trans-unit>
        <trans-unit id="14b0df907ddf13aab95716adce355b18503f9692" translate="yes" xml:space="preserve">
          <source>Expressions starting with a numeric literal followed by &lt;code&gt;e&lt;/code&gt; or &lt;code&gt;E&lt;/code&gt; are always floating-point literals.</source>
          <target state="translated">以数字文字开头，后跟 &lt;code&gt;e&lt;/code&gt; 或 &lt;code&gt;E&lt;/code&gt; 的表达式始终是浮点文字。</target>
        </trans-unit>
        <trans-unit id="168d5e3cbe916c23713fe630f1348b13aac9d055" translate="yes" xml:space="preserve">
          <source>Expressions starting with a numeric literal followed by &lt;code&gt;f&lt;/code&gt; are always 32-bit floating-point literals.</source>
          <target state="translated">以数字文字和 &lt;code&gt;f&lt;/code&gt; 开头的表达式始终是32位浮点文字。</target>
        </trans-unit>
        <trans-unit id="3716e13409c4d9335f64fad9810901c98f3f9853" translate="yes" xml:space="preserve">
          <source>Extended documentation for mathematical symbols &amp;amp; functions is &lt;a href=&quot;../math/index#math-ops&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94855ece22db4469edf3ed1b0b895b74c83b0b49" translate="yes" xml:space="preserve">
          <source>Extended documentation for mathematical symbols &amp;amp; functions is &lt;a href=&quot;../math/index#math-ops-1&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">有关数学符号和函数的扩展文档&lt;a href=&quot;../math/index#math-ops-1&quot;&gt;在这里&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9923a9977a4965d0e75c0d0897087a1b8aae8273" translate="yes" xml:space="preserve">
          <source>Extending broadcast with custom implementations</source>
          <target state="translated">通过自定义实现扩展广播</target>
        </trans-unit>
        <trans-unit id="e37b3da56d0eb7ab09f9dced1733e35bd0cf8f0a" translate="yes" xml:space="preserve">
          <source>Extending in-place broadcasting</source>
          <target state="translated">扩大就地广播</target>
        </trans-unit>
        <trans-unit id="dda79d09f22a8d0b6a55357e8dd3c1f09491aeff" translate="yes" xml:space="preserve">
          <source>External Profiling</source>
          <target state="translated">外部剖析</target>
        </trans-unit>
        <trans-unit id="dcc209bf958342fc6704aa1a6650f41110ebb0ea" translate="yes" xml:space="preserve">
          <source>External applications</source>
          <target state="translated">外部应用</target>
        </trans-unit>
        <trans-unit id="ddfa24e5756c773c710e95d9df553e39fcc67e85" translate="yes" xml:space="preserve">
          <source>External libraries, such as those called via &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, pose a problem for Julia's task-based I/O mechanism. If a C library performs a blocking operation, that prevents the Julia scheduler from executing any other tasks until the call returns. (Exceptions are calls into custom C code that call back into Julia, which may then yield, or C code that calls &lt;code&gt;jl_yield()&lt;/code&gt;, the C equivalent of &lt;a href=&quot;../../base/parallel/index#Base.yield&quot;&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72388f5a580b9a206f5fadf477e9c6409b4ba887" translate="yes" xml:space="preserve">
          <source>Extra keyword arguments can be collected using &lt;code&gt;...&lt;/code&gt;, as in varargs functions:</source>
          <target state="translated">可以使用 &lt;code&gt;...&lt;/code&gt; 收集额外的关键字参数，如varargs函数中所示：</target>
        </trans-unit>
        <trans-unit id="c4546f951699a79deff827a563b0a9a224961ffb" translate="yes" xml:space="preserve">
          <source>Extract a field from a composite &lt;code&gt;value&lt;/code&gt; by name or position. See also &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#Base.fieldnames&quot;&gt;&lt;code&gt;fieldnames&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c542a0937e5c368280ab873c2a76a31ca26a4f2" translate="yes" xml:space="preserve">
          <source>Extract a named field from a &lt;code&gt;value&lt;/code&gt; of composite type. See also &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">从复合类型的 &lt;code&gt;value&lt;/code&gt; 中提取命名字段。另请参阅&lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c60b2d6e5ed4bb81c4f042b61a85bf3046814ef9" translate="yes" xml:space="preserve">
          <source>Extract the &lt;code&gt;significand(s)&lt;/code&gt; (a.k.a. mantissa), in binary representation, of a floating-point number. If &lt;code&gt;x&lt;/code&gt; is a non-zero finite number, then the result will be a number of the same type on the interval $[1,2)$. Otherwise &lt;code&gt;x&lt;/code&gt; is returned.</source>
          <target state="translated">以二进制表示形式提取浮点数的 &lt;code&gt;significand(s)&lt;/code&gt; 位数（即尾数）。如果 &lt;code&gt;x&lt;/code&gt; 是一个非零的有限数字，则结果将是区间$ [1,2）$上相同类型的数字。否则，返回 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4bd9a47407646b7eb349264a1847a577117c4b4b" translate="yes" xml:space="preserve">
          <source>Extracting the type parameter from a super-type</source>
          <target state="translated">从超级类型中提取类型参数</target>
        </trans-unit>
        <trans-unit id="1fbfe5e749872a05dc1c33c2c7e3ca998b7be846" translate="yes" xml:space="preserve">
          <source>Extracting useful information</source>
          <target state="translated">提取有用的信息</target>
        </trans-unit>
        <trans-unit id="a98fa15cfef5c8e370cf565d569aef6f02c37e94" translate="yes" xml:space="preserve">
          <source>Extraction of a substring using range indexing also expects valid byte indices or an error is thrown:</source>
          <target state="translated">使用范围索引提取子串也期望有效的字节索引,否则会抛出错误。</target>
        </trans-unit>
        <trans-unit id="479ced4730cae81bdb549a4c55a6c538ce811e6e" translate="yes" xml:space="preserve">
          <source>Extraterrestrial Alien</source>
          <target state="translated">外星人</target>
        </trans-unit>
        <trans-unit id="794b03ba50df5bea4d6fe059ce926e6abf4b67b1" translate="yes" xml:space="preserve">
          <source>Eyeglasses</source>
          <target state="translated">Eyeglasses</target>
        </trans-unit>
        <trans-unit id="62be7f51429e4e104e01fe3131805c3195ede1d0" translate="yes" xml:space="preserve">
          <source>Eyes</source>
          <target state="translated">Eyes</target>
        </trans-unit>
        <trans-unit id="935b5308312476832a58c20321b71ffe59146c81" translate="yes" xml:space="preserve">
          <source>Face Massage</source>
          <target state="translated">脸部按摩</target>
        </trans-unit>
        <trans-unit id="6d9f49198cfb94a88e7e31f25250998eb9d2d1e4" translate="yes" xml:space="preserve">
          <source>Face Savouring Delicious Food</source>
          <target state="translated">面对美味的食物</target>
        </trans-unit>
        <trans-unit id="28d752ff1cbe0e0d9da042fc2eb4d864b23a6a83" translate="yes" xml:space="preserve">
          <source>Face Screaming In Fear</source>
          <target state="translated">面对恐惧的尖叫</target>
        </trans-unit>
        <trans-unit id="b9e9beed389ea0d867f47293f82e2186403a9ed4" translate="yes" xml:space="preserve">
          <source>Face Throwing A Kiss</source>
          <target state="translated">脸扔一个吻</target>
        </trans-unit>
        <trans-unit id="bbcbf04ff477b2051e7e4f303a290165f6e17c1c" translate="yes" xml:space="preserve">
          <source>Face With Cold Sweat</source>
          <target state="translated">脸上有冷汗</target>
        </trans-unit>
        <trans-unit id="31e3b7279424674f21abf98db495235d209a6f78" translate="yes" xml:space="preserve">
          <source>Face With Look Of Triumph</source>
          <target state="translated">脸上带着胜利的表情</target>
        </trans-unit>
        <trans-unit id="d977220829cb5c54e44951e580b7af5a8be682f2" translate="yes" xml:space="preserve">
          <source>Face With Medical Mask</source>
          <target state="translated">脸部带医用口罩</target>
        </trans-unit>
        <trans-unit id="ed92f3d2a6422f2069bba1ed8548d4fce7291c38" translate="yes" xml:space="preserve">
          <source>Face With No Good Gesture</source>
          <target state="translated">没有好的姿态的脸</target>
        </trans-unit>
        <trans-unit id="506a6677d48e694c03b7beb019db5a830b3143a9" translate="yes" xml:space="preserve">
          <source>Face With Ok Gesture</source>
          <target state="translated">脸部的Ok手势</target>
        </trans-unit>
        <trans-unit id="28e351cf809c3e1056a0ccbe38a572fea7f91813" translate="yes" xml:space="preserve">
          <source>Face With Open Mouth</source>
          <target state="translated">脸与张嘴</target>
        </trans-unit>
        <trans-unit id="ede5660328e307c9c221b7e2a4cda4e1f338198d" translate="yes" xml:space="preserve">
          <source>Face With Open Mouth And Cold Sweat</source>
          <target state="translated">脸上张着嘴,出着冷汗</target>
        </trans-unit>
        <trans-unit id="2ba0e50eb9d9ecd8226c1f88f65005c12090219b" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue</source>
          <target state="translated">脸部有凸出的舌头</target>
        </trans-unit>
        <trans-unit id="0ac1bde49f3cb47f6fb14b275d6c4062eb336a94" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue And Tightly-Closed Eyes</source>
          <target state="translated">嘟嘟嘴的脸和紧闭的眼睛</target>
        </trans-unit>
        <trans-unit id="f4cf7e61567246c7cc07e1da723a4bb7e03afad8" translate="yes" xml:space="preserve">
          <source>Face With Stuck-Out Tongue And Winking Eye</source>
          <target state="translated">脸部与突出的舌头和眨眼睛</target>
        </trans-unit>
        <trans-unit id="a06e070daf131855d1c38e6f755e23cf18f7fde6" translate="yes" xml:space="preserve">
          <source>Face With Tears Of Joy</source>
          <target state="translated">欢乐的泪水的脸</target>
        </trans-unit>
        <trans-unit id="712efae47f8a280e2a18330da009234488ca3fe5" translate="yes" xml:space="preserve">
          <source>Face Without Mouth</source>
          <target state="translated">没有嘴巴的脸</target>
        </trans-unit>
        <trans-unit id="afc193c2d83a82dc7805b7f571fe51bc57700902" translate="yes" xml:space="preserve">
          <source>Factorial of &lt;code&gt;n&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, the factorial is computed as an integer (promoted to at least 64 bits). Note that this may overflow if &lt;code&gt;n&lt;/code&gt; is not small, but you can use &lt;code&gt;factorial(big(n))&lt;/code&gt; to compute the result exactly in arbitrary precision.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 的阶乘。如果 &lt;code&gt;n&lt;/code&gt; 是&lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;，则阶乘将被计算为整数（提升为至少64位）。请注意，如果 &lt;code&gt;n&lt;/code&gt; 不小，这可能会溢出，但是您可以使用 &lt;code&gt;factorial(big(n))&lt;/code&gt; 精确地以任意精度计算结果。</target>
        </trans-unit>
        <trans-unit id="e47b9b1021034a56b7d5f70d92d0481524e78f69" translate="yes" xml:space="preserve">
          <source>Factory</source>
          <target state="translated">Factory</target>
        </trans-unit>
        <trans-unit id="63654e405afb574cef72ea67524c3b8dfe3ad9f8" translate="yes" xml:space="preserve">
          <source>Fallen Leaf</source>
          <target state="translated">落叶</target>
        </trans-unit>
        <trans-unit id="b9484d668f5b5826c667e198c17cfe45233a7bb4" translate="yes" xml:space="preserve">
          <source>Falling Diagonal Crossing North East Arrow</source>
          <target state="translated">坠落式对角线交叉东北箭</target>
        </trans-unit>
        <trans-unit id="393d595d0d4e1a1bb3815008194b595d879c69cb" translate="yes" xml:space="preserve">
          <source>Falling Diagonal Crossing Rising Diagonal</source>
          <target state="translated">下降斜交线上升斜交线</target>
        </trans-unit>
        <trans-unit id="4efb6cb7c018f0c686d4e9d68b615950223b4dd1" translate="yes" xml:space="preserve">
          <source>Family</source>
          <target state="translated">Family</target>
        </trans-unit>
        <trans-unit id="f4b462a59695a129404bc83da0ca619fa6bc84c1" translate="yes" xml:space="preserve">
          <source>FastMath.@fastmath</source>
          <target state="translated">FastMath.@fastmath</target>
        </trans-unit>
        <trans-unit id="5e56c9df8931a964370d4185aaacd5e1646ab9bf" translate="yes" xml:space="preserve">
          <source>Fastforward merge changes into current HEAD. This is only possible if the commit referred to by &lt;code&gt;ann&lt;/code&gt; is descended from the current HEAD (e.g. if pulling changes from a remote branch which is simply ahead of the local branch tip).</source>
          <target state="translated">快进合并更改到当前HEAD。仅当 &lt;code&gt;ann&lt;/code&gt; 引用的提交从当前HEAD降级时（例如，如果从远程分支拉取更改，而该分支只是在本地分支尖端之前），才有可能这样做。</target>
        </trans-unit>
        <trans-unit id="2cb40f791e4167e1561e4d7cf136b54833a93f9c" translate="yes" xml:space="preserve">
          <source>Father Christmas</source>
          <target state="translated">圣诞老人</target>
        </trans-unit>
        <trans-unit id="9f64754b8681b16b5355b0c86ea9df6b53108695" translate="yes" xml:space="preserve">
          <source>Fax Machine</source>
          <target state="translated">传真机</target>
        </trans-unit>
        <trans-unit id="2e7c6c500cc9c35c302564a53fea2d0265ede623" translate="yes" xml:space="preserve">
          <source>Fearful Face</source>
          <target state="translated">恐惧的脸</target>
        </trans-unit>
        <trans-unit id="e8205fe2da2e8213474f5eefce3af1eb9e900095" translate="yes" xml:space="preserve">
          <source>Federated package management and precise software reproducibility are difficult but worthy goals in a package system. In combination, these goals lead to a more complex package loading mechanism than most dynamic languages have, but it also yields scalability and reproducibility that is more commonly associated with static languages. Typically, Julia users should be able to use the built-in package manager to manage their projects without needing a precise understanding of these interactions. A call to &lt;code&gt;Pkg.add(&quot;X&quot;)&lt;/code&gt; will add to the appropriate project and manifest files, selected via &lt;code&gt;Pkg.activate(&quot;Y&quot;)&lt;/code&gt;, so that a future call to &lt;code&gt;import X&lt;/code&gt; will load &lt;code&gt;X&lt;/code&gt; without further thought.</source>
          <target state="translated">在软件包系统中，联合软件包管理和精确的软件可重复性是困难的，但值得实现。总而言之，这些目标导致了比大多数动态语言更复杂的程序包加载机制，但是它还产生了可扩展性和可再现性，而这些可扩展性和可再现性通常与静态语言相关联。通常，Julia用户应该能够使用内置的包管理器来管理他们的项目，而无需对这些交互的精确了解。对 &lt;code&gt;Pkg.add(&quot;X&quot;)&lt;/code&gt; 调用将添加到通过 &lt;code&gt;Pkg.activate(&quot;Y&quot;)&lt;/code&gt; 选择的相应项目和清单文件中，以便将来调用 &lt;code&gt;import X&lt;/code&gt; 将加载 &lt;code&gt;X&lt;/code&gt; ,而无需进一步考虑。</target>
        </trans-unit>
        <trans-unit id="47786ddc55ac4be098cd5e14320506e7fb87ccf0" translate="yes" xml:space="preserve">
          <source>Federation of packages</source>
          <target state="translated">包裹联合会</target>
        </trans-unit>
        <trans-unit id="39d4db59ebfbfc4ac31928560a37f5b11dfbe6ef" translate="yes" xml:space="preserve">
          <source>Female Sign</source>
          <target state="translated">女性标志</target>
        </trans-unit>
        <trans-unit id="5ade35b896f1964ffd73b5188c1b0487a813086e" translate="yes" xml:space="preserve">
          <source>Feminine Ordinal Indicator</source>
          <target state="translated">阴性单数指标</target>
        </trans-unit>
        <trans-unit id="d710ff00c62629aec846cd362ec81d6ef45db696" translate="yes" xml:space="preserve">
          <source>Ferris Wheel</source>
          <target state="translated">摩天轮</target>
        </trans-unit>
        <trans-unit id="df0dbf9f1e3f08dc6fd97eee350731fe6d045e40" translate="yes" xml:space="preserve">
          <source>Fetch from the specified &lt;code&gt;rmt&lt;/code&gt; remote git repository, using &lt;code&gt;refspecs&lt;/code&gt; to determine which remote branch(es) to fetch. The keyword arguments are:</source>
          <target state="translated">从指定的 &lt;code&gt;rmt&lt;/code&gt; 远程git存储库中获取，并使用 &lt;code&gt;refspecs&lt;/code&gt; 确定要获取的远程分支。关键字参数为：</target>
        </trans-unit>
        <trans-unit id="cb2823e177eb0088e61a0c4192de87c90606b3f2" translate="yes" xml:space="preserve">
          <source>Fetch value(s) from a &lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;&lt;code&gt;rr&lt;/code&gt;, removing the value(s) in the process.</source>
          <target state="translated">从&lt;a href=&quot;#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; &lt;/a&gt; &lt;code&gt;rr&lt;/code&gt; 中获取值，并在此过程中删除值。</target>
        </trans-unit>
        <trans-unit id="f75758f2a5b3122c0452e7b217407d3ca4c90027" translate="yes" xml:space="preserve">
          <source>Fetches updates from an upstream of the repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">从存储库的上游取出更新 &lt;code&gt;repo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ab81972fb7d8656b3c745c5f3e56930d139a6985" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;connect_at::Any&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt; can be set by the cluster manager when &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; is called. The value of this field is passed in all &lt;code&gt;connect&lt;/code&gt; callbacks. Typically, it carries information on &lt;em&gt;how to connect&lt;/em&gt; to a worker. For example, the TCP/IP socket transport uses this field to specify the &lt;code&gt;(host, port)&lt;/code&gt; tuple at which to connect to a worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33e0dc3617ed6df7db01aef23ac96c5f906e0e79" translate="yes" xml:space="preserve">
          <source>Field &lt;code&gt;connect_at::Any&lt;/code&gt; in &lt;code&gt;WorkerConfig&lt;/code&gt; can be set by the cluster manager when &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; is called. The value of this field is passed in in all &lt;code&gt;connect&lt;/code&gt; callbacks. Typically, it carries information on &lt;em&gt;how to connect&lt;/em&gt; to a worker. For example, the TCP/IP socket transport uses this field to specify the &lt;code&gt;(host, port)&lt;/code&gt; tuple at which to connect to a worker.</source>
          <target state="translated">现场 &lt;code&gt;connect_at::Any&lt;/code&gt; 在 &lt;code&gt;WorkerConfig&lt;/code&gt; 可以通过集群管理器进行设置，当&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt;时调用。此字段的值在所有 &lt;code&gt;connect&lt;/code&gt; 回调中传递。通常，它包含有关&lt;em&gt;如何连接&lt;/em&gt;到工作人员的信息。例如，TCP / IP套接字传输使用此字段来指定连接到工作线程的 &lt;code&gt;(host, port)&lt;/code&gt; 元组。</target>
        </trans-unit>
        <trans-unit id="a021a8bc64f3d535386a42159616c145f16e2e9f" translate="yes" xml:space="preserve">
          <source>Fields can have type restrictions, which may be parameterized:</source>
          <target state="translated">字段可以有类型限制,可以进行参数化。</target>
        </trans-unit>
        <trans-unit id="85e54bf45d80186bc0d6353b5c2465d78bd8c6a3" translate="yes" xml:space="preserve">
          <source>Fields for output from functions can also be completed:</source>
          <target state="translated">也可以完成函数输出的字段。</target>
        </trans-unit>
        <trans-unit id="9c69000bd588bc2ad85aa2ab7ce5f54b4fa4c471" translate="yes" xml:space="preserve">
          <source>Fields with no type annotation default to &lt;code&gt;Any&lt;/code&gt;, and can accordingly hold any type of value.</source>
          <target state="translated">没有类型注释的字段默认为 &lt;code&gt;Any&lt;/code&gt; ，因此可以保存任何类型的值。</target>
        </trans-unit>
        <trans-unit id="844953f92852d1b54e7d635339a7d17db22cf318" translate="yes" xml:space="preserve">
          <source>File Events</source>
          <target state="translated">文件事件</target>
        </trans-unit>
        <trans-unit id="f78e390524cd3565f0dc8b46bd2ea361def72e8d" translate="yes" xml:space="preserve">
          <source>File Folder</source>
          <target state="translated">文件夹</target>
        </trans-unit>
        <trans-unit id="1b8c4bf7746a674619789c0353c0a64bca75a908" translate="yes" xml:space="preserve">
          <source>File extension for dynamic libraries (e.g. dll, dylib, so) on the current platform.</source>
          <target state="translated">当前平台上动态库的文件扩展名(如dll、dylib、so)。</target>
        </trans-unit>
        <trans-unit id="2a5ce0551b3bc16a4d13e2e3a13e5586cafae52b" translate="yes" xml:space="preserve">
          <source>File locations</source>
          <target state="translated">文件位置</target>
        </trans-unit>
        <trans-unit id="2c420d28b90db2dee25055b2d7bd4981ad9a1524" translate="yes" xml:space="preserve">
          <source>File/function names are sometimes truncated (with &lt;code&gt;...&lt;/code&gt;), and indentation is truncated with a &lt;code&gt;+n&lt;/code&gt; at the beginning, where &lt;code&gt;n&lt;/code&gt; is the number of extra spaces that would have been inserted, had there been room. If you want a complete profile of deeply-nested code, often a good idea is to save to a file using a wide &lt;code&gt;displaysize&lt;/code&gt; in an &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">文件/函数名有时会被截断（用 &lt;code&gt;...&lt;/code&gt; ），并且缩进开头会以 &lt;code&gt;+n&lt;/code&gt; 截断，其中 &lt;code&gt;n&lt;/code&gt; 是存在空间时将插入的多余空格数。如果您需要完整的深度嵌套代码配置文件，通常一个好主意是在&lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; 中&lt;/a&gt;使用大的 &lt;code&gt;displaysize&lt;/code&gt; 保存到文件中：</target>
        </trans-unit>
        <trans-unit id="f8d8d763bd5d522952215bd9a9fc1f2faf928be9" translate="yes" xml:space="preserve">
          <source>FileWatching.poll_fd()</source>
          <target state="translated">FileWatching.poll_fd()</target>
        </trans-unit>
        <trans-unit id="9a0031862648613baa256a2b1e25c479a5254826" translate="yes" xml:space="preserve">
          <source>FileWatching.poll_file()</source>
          <target state="translated">FileWatching.poll_file()</target>
        </trans-unit>
        <trans-unit id="747de65fe94e8175642ef8c7cef685465b1b4bb5" translate="yes" xml:space="preserve">
          <source>FileWatching.unwatch_folder()</source>
          <target state="translated">FileWatching.unwatch_folder()</target>
        </trans-unit>
        <trans-unit id="d92f14cfa1ec3fdb1aad5fa8235becab8031e345" translate="yes" xml:space="preserve">
          <source>FileWatching.watch_file()</source>
          <target state="translated">FileWatching.watch_file()</target>
        </trans-unit>
        <trans-unit id="c0d5eb4225c04b069f17ff8146680ce4c975f229" translate="yes" xml:space="preserve">
          <source>FileWatching.watch_folder()</source>
          <target state="translated">FileWatching.watch_folder()</target>
        </trans-unit>
        <trans-unit id="0b5acc23bb7f272c55693528aa9ca461dacf6e0b" translate="yes" xml:space="preserve">
          <source>Files and file names are mostly unrelated to modules; modules are associated only with module expressions. One can have multiple files per module, and multiple modules per file:</source>
          <target state="translated">文件和文件名大多与模块无关,模块只与模块表达式有关。一个模块可以有多个文件,一个文件可以有多个模块。</target>
        </trans-unit>
        <trans-unit id="092fe85f5c2e62269fa44ec1fcbf190e92f16564" translate="yes" xml:space="preserve">
          <source>Filesystem</source>
          <target state="translated">Filesystem</target>
        </trans-unit>
        <trans-unit id="66d37ac694679d2aaba78e1325d8da6c3e6b2dc1" translate="yes" xml:space="preserve">
          <source>Filesystem.cd()</source>
          <target state="translated">Filesystem.cd()</target>
        </trans-unit>
        <trans-unit id="4b83b49056e1fe9e1c6931b13ab708ea3d3dc5b1" translate="yes" xml:space="preserve">
          <source>Filesystem.cp()</source>
          <target state="translated">Filesystem.cp()</target>
        </trans-unit>
        <trans-unit id="a4dead2a6ad53fe70d8e528eef3724fac180b679" translate="yes" xml:space="preserve">
          <source>Filesystem.mv()</source>
          <target state="translated">Filesystem.mv()</target>
        </trans-unit>
        <trans-unit id="cf83f1b98e2416e6a59699657d24bd33d10365f7" translate="yes" xml:space="preserve">
          <source>Filesystem.rm()</source>
          <target state="translated">Filesystem.rm()</target>
        </trans-unit>
        <trans-unit id="e8602ecc6cdda92120a80db2b2896945fc2bc02d" translate="yes" xml:space="preserve">
          <source>Fill array &lt;code&gt;A&lt;/code&gt; with the value &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill!(A, Foo())&lt;/code&gt; will return &lt;code&gt;A&lt;/code&gt; filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">填充阵列 &lt;code&gt;A&lt;/code&gt; 用值 &lt;code&gt;x&lt;/code&gt; 。如果 &lt;code&gt;x&lt;/code&gt; 是对象引用，则所有元素都将引用同一对象。 &lt;code&gt;fill!(A, Foo())&lt;/code&gt; 将返回 &lt;code&gt;A&lt;/code&gt; ，该A填充一次评估 &lt;code&gt;Foo()&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="15f90b730a9bb3cbbb4e0be4003f4356fc9b9036" translate="yes" xml:space="preserve">
          <source>Fill the array &lt;code&gt;A&lt;/code&gt; with normally-distributed (mean 0, standard deviation 1) random numbers. Also see the &lt;a href=&quot;#Base.rand&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">用正态分布（均值0，标准差1）随机数填充数组 &lt;code&gt;A&lt;/code&gt; 。另请参见&lt;a href=&quot;#Base.rand&quot;&gt; &lt;code&gt;rand&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="7ae93e848c3d30d15d2b5012ea3af3f0ab55b5ca" translate="yes" xml:space="preserve">
          <source>Fill the array &lt;code&gt;A&lt;/code&gt; with random numbers following the exponential distribution (with scale 1).</source>
          <target state="translated">按照指数分布（标度1），用随机数填充数组 &lt;code&gt;A&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0e5d88ef3637a2479a8b258a074f4fa06d769918" translate="yes" xml:space="preserve">
          <source>Fills an array of the digits of &lt;code&gt;n&lt;/code&gt; in the given base. More significant digits are at higher indices. If the array length is insufficient, the least significant digits are filled up to the array length. If the array length is excessive, the excess portion is filled with zeros.</source>
          <target state="translated">用给定的基数填充 &lt;code&gt;n&lt;/code&gt; 的数字数组。较高的数字代表较高的索引。如果数组长度不足，则将最低有效位填充到数组长度。如果数组长度过长，则多余部分将填充零。</target>
        </trans-unit>
        <trans-unit id="6631e6cc1655ad1b4e5dff0d7262c17fe69da03f" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;where&lt;/code&gt; is parsed as an infix operator for writing parametric method and type definitions. Also &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;isa&lt;/code&gt; are parsed as infix operators. Creation of a variable named &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;isa&lt;/code&gt; is allowed though.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396759f79c6ca8385ec1d2296022926c7edb5dd8" translate="yes" xml:space="preserve">
          <source>Finally, distributed computing runs multiple processes with separate memory spaces, potentially on different machines. This functionality is provided by the &lt;code&gt;Distributed&lt;/code&gt; standard library as well as external packages like &lt;code&gt;MPI.jl&lt;/code&gt; and &lt;code&gt;DistributedArrays.jl&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22655b3e2d52ed1fe3abbc273a301c575c9c7fae" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;code&gt;DummyModule.jl&lt;/code&gt; is not a standalone file but a package, then &lt;code&gt;using DummyModule&lt;/code&gt; will &lt;em&gt;load&lt;/em&gt;&lt;code&gt;DummyModule.jl&lt;/code&gt; on all processes, but only bring it into scope on the process where &lt;code&gt;using&lt;/code&gt; was called.</source>
          <target state="translated">最后，如果 &lt;code&gt;DummyModule.jl&lt;/code&gt; 不是独立文件而是包，则 &lt;code&gt;using DummyModule&lt;/code&gt; 将在所有进程上&lt;em&gt;加载&lt;/em&gt; &lt;code&gt;DummyModule.jl&lt;/code&gt; ，但只会将其纳入调用 &lt;code&gt;using&lt;/code&gt; 的进程范围内。</target>
        </trans-unit>
        <trans-unit id="f1c7a00722ed8c5c04db876017518449fd3a13b0" translate="yes" xml:space="preserve">
          <source>Finally, let's take a look at some more complex examples where this rule comes into play. Define a function &lt;code&gt;f(x)&lt;/code&gt;, which initially has one method:</source>
          <target state="translated">最后，让我们看一些更复杂的示例，其中该规则起作用。定义一个函数 &lt;code&gt;f(x)&lt;/code&gt; ，该函数最初具有一种方法：</target>
        </trans-unit>
        <trans-unit id="e8ab1a15d94e7105e3fcab5c9d28790890e0a56b" translate="yes" xml:space="preserve">
          <source>Finally, the &quot;exclusive or&quot; logical operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt; always propagates &lt;code&gt;missing&lt;/code&gt; values, since both operands always have an effect on the result. Also note that the negation operator &lt;a href=&quot;../../base/math/index#Base.:!&quot;&gt;&lt;code&gt;!&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;missing&lt;/code&gt; when the operand is &lt;code&gt;missing&lt;/code&gt; just like other unary operators.</source>
          <target state="translated">最后，&amp;ldquo;异或&amp;rdquo;逻辑运算符&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;始终传播 &lt;code&gt;missing&lt;/code&gt; 值，因为两个操作数始终会对结果产生影响。另请注意，求反运算符&lt;a href=&quot;../../base/math/index#Base.:!&quot;&gt; &lt;code&gt;!&lt;/code&gt; &lt;/a&gt;恢复 &lt;code&gt;missing&lt;/code&gt; 当操作数 &lt;code&gt;missing&lt;/code&gt; ，就像其他一元运算符。</target>
        </trans-unit>
        <trans-unit id="f1606584dd02e5f78a49dbb79dadabcf6a1374a4" translate="yes" xml:space="preserve">
          <source>Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is &lt;em&gt;pre-allocated&lt;/em&gt;, so that repeated calls do not allocate new arrays over and over again for the results (see &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs&quot;&gt;Pre-allocating outputs&lt;/a&gt;). A convenient syntax for this is &lt;code&gt;X .= ...&lt;/code&gt;, which is equivalent to &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; except that, as above, the &lt;code&gt;broadcast!&lt;/code&gt; loop is fused with any nested &quot;dot&quot; calls. For example, &lt;code&gt;X .= sin.(Y)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt;, overwriting &lt;code&gt;X&lt;/code&gt; with &lt;code&gt;sin.(Y)&lt;/code&gt; in-place. If the left-hand side is an array-indexing expression, e.g. &lt;code&gt;X[begin+1:end] .= sin.(Y)&lt;/code&gt;, then it translates to &lt;code&gt;broadcast!&lt;/code&gt; on a &lt;code&gt;view&lt;/code&gt;, e.g. &lt;code&gt;broadcast!(sin, view(X, firstindex(X)+1:lastindex(X)), Y)&lt;/code&gt;, so that the left-hand side is updated in-place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767751161f0cdd1157de7a8f8d7964c9db4474ed" translate="yes" xml:space="preserve">
          <source>Finally, the maximum efficiency is typically achieved when the output array of a vectorized operation is &lt;em&gt;pre-allocated&lt;/em&gt;, so that repeated calls do not allocate new arrays over and over again for the results (see &lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;). A convenient syntax for this is &lt;code&gt;X .= ...&lt;/code&gt;, which is equivalent to &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; except that, as above, the &lt;code&gt;broadcast!&lt;/code&gt; loop is fused with any nested &quot;dot&quot; calls. For example, &lt;code&gt;X .= sin.(Y)&lt;/code&gt; is equivalent to &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt;, overwriting &lt;code&gt;X&lt;/code&gt; with &lt;code&gt;sin.(Y)&lt;/code&gt; in-place. If the left-hand side is an array-indexing expression, e.g. &lt;code&gt;X[2:end] .= sin.(Y)&lt;/code&gt;, then it translates to &lt;code&gt;broadcast!&lt;/code&gt; on a &lt;code&gt;view&lt;/code&gt;, e.g. &lt;code&gt;broadcast!(sin, view(X, 2:lastindex(X)), Y)&lt;/code&gt;, so that the left-hand side is updated in-place.</source>
          <target state="translated">最终，通常在向量化操作的输出数组被&lt;em&gt;预先分配&lt;/em&gt;时才能达到最大效率，因此重复调用不会为结果一遍又一遍地分配新数组（请参阅&lt;a href=&quot;../performance-tips/index#Pre-allocating-outputs-1&quot;&gt;预分配输出&lt;/a&gt;）。一个方便的语法是 &lt;code&gt;X .= ...&lt;/code&gt; ，它等同于 &lt;code&gt;broadcast!(identity, X, ...)&lt;/code&gt; 除了如上所述， &lt;code&gt;broadcast!&lt;/code&gt; 循环与任何嵌套的&amp;ldquo;点&amp;rdquo;调用融合在一起。例如， &lt;code&gt;X .= sin.(Y)&lt;/code&gt; 等效于 &lt;code&gt;broadcast!(sin, X, Y)&lt;/code&gt; ，就地用 &lt;code&gt;sin.(Y)&lt;/code&gt; 覆盖 &lt;code&gt;X&lt;/code&gt; 。如果左侧是数组索引表达式，例如 &lt;code&gt;X[2:end] .= sin.(Y)&lt;/code&gt; ，然后翻译成 &lt;code&gt;broadcast!&lt;/code&gt; 在 &lt;code&gt;view&lt;/code&gt; ，例如 &lt;code&gt;broadcast!(sin, view(X, 2:lastindex(X)), Y)&lt;/code&gt; ，以便左侧就地更新。</target>
        </trans-unit>
        <trans-unit id="c12ff37c90964a19ee534ead21bebd3e9eed8809" translate="yes" xml:space="preserve">
          <source>Finally, we finish off our ongoing case study of Julia's rational number type, which makes relatively sophisticated use of the promotion mechanism with the following promotion rules:</source>
          <target state="translated">最后,我们结束正在进行的Julia有理数型的案例研究,它对推广机制的使用相对复杂,推广规则如下。</target>
        </trans-unit>
        <trans-unit id="30b68f7e7af1c04cf4dd6e837e4591351c43581a" translate="yes" xml:space="preserve">
          <source>Finally, you can use &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to actually generate a call to the library function. Arguments to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; are as follows:</source>
          <target state="translated">最后，您可以使用&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;实际生成对库函数的调用。&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 的&lt;/a&gt;参数如下：</target>
        </trans-unit>
        <trans-unit id="b7d84c29ce4854abb76c4c28bbdd03fd9c5aa451" translate="yes" xml:space="preserve">
          <source>Finally, you can use &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; to actually generate a call to the library function. The arguments to &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feefe85d510994646d16a16714a8d3ae19ac8a26" translate="yes" xml:space="preserve">
          <source>Finally, you may also consider building Julia from source for yourself. This option is mainly for those individuals who are comfortable at the command line, or interested in learning. If this describes you, you may also be interested in reading our &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md&quot;&gt;guidelines for contributing&lt;/a&gt;.</source>
          <target state="translated">最后，您还可以考虑自己从源代码构建Julia。此选项主要适用于那些熟悉命令行或对学习感兴趣的人。如果这描述了您，则您可能也有兴趣阅读我们&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/CONTRIBUTING.md&quot;&gt;的贡献准则&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="9f3fe342dc0e6c8372fd117cdbcdeaa485ff1b80" translate="yes" xml:space="preserve">
          <source>Finally,&lt;code&gt;where&lt;/code&gt; is parsed as an infix operator for writing parametric method and type definitions. Also &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;isa&lt;/code&gt; are parsed as infix operators. Creation of a variable named &lt;code&gt;where&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;isa&lt;/code&gt; is allowed though.</source>
          <target state="translated">最后，将 &lt;code&gt;where&lt;/code&gt; 解析为用于编写参数方法和类型定义的中缀运算符。同样， &lt;code&gt;in&lt;/code&gt; 和 &lt;code&gt;isa&lt;/code&gt; 也被解析为中缀运算符。虽然允许创建名为 &lt;code&gt;where&lt;/code&gt; ， &lt;code&gt;in&lt;/code&gt; 或 &lt;code&gt;isa&lt;/code&gt; 的变量。</target>
        </trans-unit>
        <trans-unit id="c9b51ec67d633a0669dda1015ca213cfa3baaf80" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;y::T&lt;/code&gt; such that &lt;code&gt;x&lt;/code&gt; &amp;equiv; &lt;code&gt;y&lt;/code&gt; (mod n), where n is the number of integers representable in &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; is an integer in &lt;code&gt;[typemin(T),typemax(T)]&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; can represent any integer (e.g. &lt;code&gt;T == BigInt&lt;/code&gt;), then this operation corresponds to a conversion to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">找到 &lt;code&gt;y::T&lt;/code&gt; 使得 &lt;code&gt;x&lt;/code&gt; &amp;equiv; &lt;code&gt;y&lt;/code&gt; （MOD n），其中n为整数的个数中所能表述 &lt;code&gt;T&lt;/code&gt; ，和 &lt;code&gt;y&lt;/code&gt; 是一个整数 &lt;code&gt;[typemin(T),typemax(T)]&lt;/code&gt; 。如果 &lt;code&gt;T&lt;/code&gt; 可以表示任何整数（例如 &lt;code&gt;T == BigInt&lt;/code&gt; ），则此操作对应于对 &lt;code&gt;T&lt;/code&gt; 的转换。</target>
        </trans-unit>
        <trans-unit id="c6150b2996e7de5708d81911408a8ec428d36e07" translate="yes" xml:space="preserve">
          <source>Find &lt;code&gt;y&lt;/code&gt; in the range &lt;code&gt;r&lt;/code&gt; such that $x &amp;equiv; y (mod n)$, where &lt;code&gt;n = length(r)&lt;/code&gt;, i.e. &lt;code&gt;y = mod(x - first(r), n) + first(r)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f647c9d8a07df297d4680ab0a11627650c460ccd" translate="yes" xml:space="preserve">
          <source>Find a merge base (a common ancestor) between the commits &lt;code&gt;one&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt;. &lt;code&gt;one&lt;/code&gt; and &lt;code&gt;two&lt;/code&gt; may both be in string form. Return the &lt;code&gt;GitHash&lt;/code&gt; of the merge base.</source>
          <target state="translated">在提交 &lt;code&gt;one&lt;/code&gt; 和提交 &lt;code&gt;two&lt;/code&gt; 之间找到合并基础（公共祖先）。 &lt;code&gt;one&lt;/code&gt; 和 &lt;code&gt;two&lt;/code&gt; 都可以是字符串形式。返回合并基础的 &lt;code&gt;GitHash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1825fce8a92f2ce1845fd36082521f2d3a4e162f" translate="yes" xml:space="preserve">
          <source>Find the first occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;a href=&quot;#Base.findnext-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt;&lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">查找第一次出现 &lt;code&gt;pattern&lt;/code&gt; 中 &lt;code&gt;string&lt;/code&gt; 。等效于&lt;a href=&quot;#Base.findnext-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt; &lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="80ded0d1fb8ec161dcae3181a5658542cce2200b" translate="yes" xml:space="preserve">
          <source>Find the first occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;code&gt;findnext(pattern, string, firstindex(s))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21d600b94cf0b778ba467005900538f19345af8" translate="yes" xml:space="preserve">
          <source>Find the index of the element of &lt;code&gt;dx&lt;/code&gt; with the maximum absolute value. &lt;code&gt;n&lt;/code&gt; is the length of &lt;code&gt;dx&lt;/code&gt;, and &lt;code&gt;incx&lt;/code&gt; is the stride. If &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;incx&lt;/code&gt; are not provided, they assume default values of &lt;code&gt;n=length(dx)&lt;/code&gt; and &lt;code&gt;incx=stride1(dx)&lt;/code&gt;.</source>
          <target state="translated">找到具有最大绝对值的 &lt;code&gt;dx&lt;/code&gt; 元素的索引。 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;dx&lt;/code&gt; 的长度， &lt;code&gt;incx&lt;/code&gt; 是步幅。如果未提供 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;incx&lt;/code&gt; ，则它们假定默认值为 &lt;code&gt;n=length(dx)&lt;/code&gt; 和 &lt;code&gt;incx=stride1(dx)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6eaf75b6910de284edca0478751e60e1ad92a9d8" translate="yes" xml:space="preserve">
          <source>Find the last occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;a href=&quot;#Base.findprev-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt;&lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">找到最后一次出现 &lt;code&gt;pattern&lt;/code&gt; 中的 &lt;code&gt;string&lt;/code&gt; 。等效于&lt;a href=&quot;#Base.findprev-Tuple%7BAbstractString,AbstractString,Integer%7D&quot;&gt; &lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="67e62ddbda9380872652837135cdba3485044ca2" translate="yes" xml:space="preserve">
          <source>Find the last occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;. Equivalent to &lt;code&gt;findprev(pattern, string, lastindex(string))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e80338a6fd8042cc9a4548c075df3fb6d4dd0cdc" translate="yes" xml:space="preserve">
          <source>Find the last occurrence of character &lt;code&gt;ch&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552c8ae53a2283ce454807a34e7013b314ceea60" translate="yes" xml:space="preserve">
          <source>Find the maximum of &lt;code&gt;A&lt;/code&gt; and the corresponding linear index along singleton dimensions of &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;, and store the results in &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">沿 &lt;code&gt;rval&lt;/code&gt; 和 &lt;code&gt;rind&lt;/code&gt; 的单例尺寸找到 &lt;code&gt;A&lt;/code&gt; 的最大值和相应的线性指数，并将结果存储在 &lt;code&gt;rval&lt;/code&gt; 和 &lt;code&gt;rind&lt;/code&gt; 中。 &lt;code&gt;NaN&lt;/code&gt; 被视为大于所有其他值。</target>
        </trans-unit>
        <trans-unit id="9aa328c598b9330ac1b7a72be0fe532e46cd4d55" translate="yes" xml:space="preserve">
          <source>Find the minimum of &lt;code&gt;A&lt;/code&gt; and the corresponding linear index along singleton dimensions of &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;, and store the results in &lt;code&gt;rval&lt;/code&gt; and &lt;code&gt;rind&lt;/code&gt;. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">沿 &lt;code&gt;rval&lt;/code&gt; 和 &lt;code&gt;rind&lt;/code&gt; 的单例尺寸找到 &lt;code&gt;A&lt;/code&gt; 的最小值和相应的线性指数，并将结果存储在 &lt;code&gt;rval&lt;/code&gt; 和 &lt;code&gt;rind&lt;/code&gt; 中。 &lt;code&gt;NaN&lt;/code&gt; 被视为小于所有其他值。</target>
        </trans-unit>
        <trans-unit id="d865db872da82af36f837e5f310f73145bef3112" translate="yes" xml:space="preserve">
          <source>Find the next index after or including &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;true&lt;/code&gt; element of &lt;code&gt;A&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">查找下一个索引或之后，包括 &lt;code&gt;i&lt;/code&gt; 一个的 &lt;code&gt;true&lt;/code&gt; 的元 &lt;code&gt;A&lt;/code&gt; ，或者 &lt;code&gt;nothing&lt;/code&gt; ，如果没有找到。</target>
        </trans-unit>
        <trans-unit id="3bed36c27812d4cd102ecb3fe1568c0bed863342" translate="yes" xml:space="preserve">
          <source>Find the next index after or including &lt;code&gt;i&lt;/code&gt; of an element of &lt;code&gt;A&lt;/code&gt; for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">查找下一个索引或之后，包括 &lt;code&gt;i&lt;/code&gt; 的一个元素的 &lt;code&gt;A&lt;/code&gt; 针对 &lt;code&gt;predicate&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，或 &lt;code&gt;nothing&lt;/code&gt; ，如果没有找到。</target>
        </trans-unit>
        <trans-unit id="7a1d8f46d937916c8787067db2b2714283d812a5" translate="yes" xml:space="preserve">
          <source>Find the next occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;. &lt;code&gt;pattern&lt;/code&gt; can be either a string, or a regular expression, in which case &lt;code&gt;string&lt;/code&gt; must be of type &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">查找下一个出现的 &lt;code&gt;pattern&lt;/code&gt; 在 &lt;code&gt;string&lt;/code&gt; 开始处的位置 &lt;code&gt;start&lt;/code&gt; 。 &lt;code&gt;pattern&lt;/code&gt; 可以是字符串，也可以是正则表达式，在这种情况下， &lt;code&gt;string&lt;/code&gt; 必须为 &lt;code&gt;String&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="3ea577e1df683b2cdf0866079e5dca95cc8a70df" translate="yes" xml:space="preserve">
          <source>Find the next occurrence of character &lt;code&gt;ch&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5acd53075bd7738ba5874f9d2945af016adac780" translate="yes" xml:space="preserve">
          <source>Find the previous index before or including &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;true&lt;/code&gt; element of &lt;code&gt;A&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">查找上一个索引或包括之前 &lt;code&gt;i&lt;/code&gt; 一个的 &lt;code&gt;true&lt;/code&gt; 的元 &lt;code&gt;A&lt;/code&gt; ，或者 &lt;code&gt;nothing&lt;/code&gt; ，如果没有找到。</target>
        </trans-unit>
        <trans-unit id="ac4b726fe8ef16af102227f0592ab9d5019209eb" translate="yes" xml:space="preserve">
          <source>Find the previous index before or including &lt;code&gt;i&lt;/code&gt; of an element of &lt;code&gt;A&lt;/code&gt; for which &lt;code&gt;predicate&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, or &lt;code&gt;nothing&lt;/code&gt; if not found.</source>
          <target state="translated">查找上一个索引或包括之前 &lt;code&gt;i&lt;/code&gt; 的一个元素的 &lt;code&gt;A&lt;/code&gt; 针对 &lt;code&gt;predicate&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; ，或 &lt;code&gt;nothing&lt;/code&gt; ，如果没有找到。</target>
        </trans-unit>
        <trans-unit id="7099f261e64c52f512558cba2d47b4f0bc49c077" translate="yes" xml:space="preserve">
          <source>Find the previous occurrence of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt; starting at position &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">查找以前发生 &lt;code&gt;pattern&lt;/code&gt; 在 &lt;code&gt;string&lt;/code&gt; 开始处的位置 &lt;code&gt;start&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0eee018a6003d420d94f270f4deb2bf0aff001cc" translate="yes" xml:space="preserve">
          <source>Find the root module of a given module. This is the first module in the chain of parent modules of &lt;code&gt;m&lt;/code&gt; which is either a registered root module or which is its own parent module.</source>
          <target state="translated">查找给定模块的根模块。这是 &lt;code&gt;m&lt;/code&gt; 的父模块链中的第一个模块，它是注册的根模块或它自己的父模块。</target>
        </trans-unit>
        <trans-unit id="48db6f6163bbca28ad1cb048ef296ccaadb4bcda" translate="yes" xml:space="preserve">
          <source>Finding the length of time between two &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is straightforward given their underlying representation as &lt;code&gt;UTInstant{Day}&lt;/code&gt; and &lt;code&gt;UTInstant{Millisecond}&lt;/code&gt;, respectively. The difference between &lt;a href=&quot;#Dates.Date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; is returned in the number of &lt;a href=&quot;#Dates.Day-Tuple%7BTimeType%7D&quot;&gt;&lt;code&gt;Day&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; in the number of &lt;a href=&quot;#Dates.Millisecond-Tuple%7BDateTime%7D&quot;&gt;&lt;code&gt;Millisecond&lt;/code&gt;&lt;/a&gt;. Similarly, comparing &lt;a href=&quot;#Dates.TimeType&quot;&gt;&lt;code&gt;TimeType&lt;/code&gt;&lt;/a&gt; is a simple matter of comparing the underlying machine instants (which in turn compares the internal &lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/a&gt; values).</source>
          <target state="translated">假定两个基础&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;表示为 &lt;code&gt;UTInstant{Day}&lt;/code&gt; 和 &lt;code&gt;UTInstant{Millisecond}&lt;/code&gt; ，就可以轻松地找到两个Date或&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;之间的时间长度。&lt;a href=&quot;#Dates.Date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt;以&lt;a href=&quot;#Dates.Day-Tuple%7BTimeType%7D&quot;&gt; &lt;code&gt;Day&lt;/code&gt; &lt;/a&gt;的数目返回Date和&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;以&lt;a href=&quot;#Dates.Millisecond-Tuple%7BDateTime%7D&quot;&gt; &lt;code&gt;Millisecond&lt;/code&gt; &lt;/a&gt;的数目返回之间的差。类似地，比较&lt;a href=&quot;#Dates.TimeType&quot;&gt; &lt;code&gt;TimeType&lt;/code&gt; &lt;/a&gt;是比较基础机器时刻的一个简单问题（依次比较内部&lt;a href=&quot;../../base/numbers/index#Core.Int64&quot;&gt; &lt;code&gt;Int64&lt;/code&gt; &lt;/a&gt;值）。</target>
        </trans-unit>
        <trans-unit id="2069d729b3672a99ea2f38ff359c481d7de66468" translate="yes" xml:space="preserve">
          <source>Finds the &lt;code&gt;LU&lt;/code&gt; factorization of a tridiagonal matrix with &lt;code&gt;dl&lt;/code&gt; on the subdiagonal, &lt;code&gt;d&lt;/code&gt; on the diagonal, and &lt;code&gt;du&lt;/code&gt; on the superdiagonal.</source>
          <target state="translated">查找一个三对角矩阵的 &lt;code&gt;LU&lt;/code&gt; 分解，其中 &lt;code&gt;dl&lt;/code&gt; 在次对角线上， &lt;code&gt;d&lt;/code&gt; 在对角线上， &lt;code&gt;du&lt;/code&gt; 在超对角线上。</target>
        </trans-unit>
        <trans-unit id="f84cbc64cd18b52fd324e199af11a5fabde58655" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of &lt;code&gt;A&lt;/code&gt; with matrix balancing. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed. If &lt;code&gt;balanc = N&lt;/code&gt;, no balancing is performed. If &lt;code&gt;balanc = P&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is permuted but not scaled. If &lt;code&gt;balanc = S&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is scaled but not permuted. If &lt;code&gt;balanc = B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is permuted and scaled. If &lt;code&gt;sense = N&lt;/code&gt;, no reciprocal condition numbers are computed. If &lt;code&gt;sense = E&lt;/code&gt;, reciprocal condition numbers are computed for the eigenvalues only. If &lt;code&gt;sense = V&lt;/code&gt;, reciprocal condition numbers are computed for the right eigenvectors only. If &lt;code&gt;sense = B&lt;/code&gt;, reciprocal condition numbers are computed for the right eigenvectors and the eigenvectors. If &lt;code&gt;sense = E,B&lt;/code&gt;, the right and left eigenvectors must be computed.</source>
          <target state="translated">查找具有矩阵平衡的 &lt;code&gt;A&lt;/code&gt; 的本征系统。如果 &lt;code&gt;jobvl = N&lt;/code&gt; ，则不计算 &lt;code&gt;A&lt;/code&gt; 的左特征向量。如果 &lt;code&gt;jobvr = N&lt;/code&gt; ，则不计算 &lt;code&gt;A&lt;/code&gt; 的右特征向量。如果 &lt;code&gt;jobvl = V&lt;/code&gt; 或 &lt;code&gt;jobvr = V&lt;/code&gt; ，则计算对应的特征向量。如果 &lt;code&gt;balanc = N&lt;/code&gt; ，则不执行任何平衡。如果 &lt;code&gt;balanc = P&lt;/code&gt; ，则置换 &lt;code&gt;A&lt;/code&gt; ，但不缩放。如果 &lt;code&gt;balanc = S&lt;/code&gt; ，则缩放 &lt;code&gt;A&lt;/code&gt; ，但不进行排列。如果 &lt;code&gt;balanc = B&lt;/code&gt; ，则对 &lt;code&gt;A&lt;/code&gt; 进行排列和缩放。如果 &lt;code&gt;sense = N&lt;/code&gt; ，不计算互惠条件编号。如果 &lt;code&gt;sense = E&lt;/code&gt; ，则仅针对特征值计算倒数条件编号。如果 &lt;code&gt;sense = V&lt;/code&gt; ，则仅为正确的特征向量计算倒数条件编号。如果 &lt;code&gt;sense = B&lt;/code&gt; ，则为正确的特征向量和特征向量计算倒数条件编号。如果 &lt;code&gt;sense = E,B&lt;/code&gt; ，则必须计算左右特征向量。</target>
        </trans-unit>
        <trans-unit id="d0023ab74a3d6a6fa55c15cb99a0305228d939c9" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors of &lt;code&gt;A&lt;/code&gt; aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed. Returns the eigenvalues in &lt;code&gt;W&lt;/code&gt;, the right eigenvectors in &lt;code&gt;VR&lt;/code&gt;, and the left eigenvectors in &lt;code&gt;VL&lt;/code&gt;.</source>
          <target state="translated">查找 &lt;code&gt;A&lt;/code&gt; 的本征系统。如果 &lt;code&gt;jobvl = N&lt;/code&gt; ，则不计算 &lt;code&gt;A&lt;/code&gt; 的左特征向量。如果 &lt;code&gt;jobvr = N&lt;/code&gt; ，则不计算 &lt;code&gt;A&lt;/code&gt; 的右特征向量。如果 &lt;code&gt;jobvl = V&lt;/code&gt; 或 &lt;code&gt;jobvr = V&lt;/code&gt; ，则计算对应的特征向量。返回 &lt;code&gt;W&lt;/code&gt; 中的特征值， &lt;code&gt;VR&lt;/code&gt; 中的右特征向量和 &lt;code&gt;VL&lt;/code&gt; 中的左特征向量。</target>
        </trans-unit>
        <trans-unit id="f3c756f96984dbd050044ac948d5f71380b56742" translate="yes" xml:space="preserve">
          <source>Finds the eigensystem of an upper triangular matrix &lt;code&gt;T&lt;/code&gt;. If &lt;code&gt;side = R&lt;/code&gt;, the right eigenvectors are computed. If &lt;code&gt;side = L&lt;/code&gt;, the left eigenvectors are computed. If &lt;code&gt;side = B&lt;/code&gt;, both sets are computed. If &lt;code&gt;howmny = A&lt;/code&gt;, all eigenvectors are found. If &lt;code&gt;howmny = B&lt;/code&gt;, all eigenvectors are found and backtransformed using &lt;code&gt;VL&lt;/code&gt; and &lt;code&gt;VR&lt;/code&gt;. If &lt;code&gt;howmny = S&lt;/code&gt;, only the eigenvectors corresponding to the values in &lt;code&gt;select&lt;/code&gt; are computed.</source>
          <target state="translated">查找上三角矩阵 &lt;code&gt;T&lt;/code&gt; 的本征系统。如果 &lt;code&gt;side = R&lt;/code&gt; ，则计算右特征向量。如果 &lt;code&gt;side = L&lt;/code&gt; ，则计算左特征向量。如果 &lt;code&gt;side = B&lt;/code&gt; ，则计算两个集合。如果 &lt;code&gt;howmny = A&lt;/code&gt; ，则找到所有特征向量。如果 &lt;code&gt;howmny = B&lt;/code&gt; ，则找到所有特征向量并使用 &lt;code&gt;VL&lt;/code&gt; 和 &lt;code&gt;VR&lt;/code&gt; 进行逆变换。如果 &lt;code&gt;howmny = S&lt;/code&gt; ，则仅计算与 &lt;code&gt;select&lt;/code&gt; 中的值相对应的特征向量。</target>
        </trans-unit>
        <trans-unit id="0322800c8fc7bfd25f123e3f433827d776d8a68b" translate="yes" xml:space="preserve">
          <source>Finds the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangle of &lt;code&gt;A&lt;/code&gt; is used.</source>
          <target state="translated">查找对称矩阵 &lt;code&gt;A&lt;/code&gt; 的特征值（ &lt;code&gt;jobz = N&lt;/code&gt; ）或特征值和特征向量（ &lt;code&gt;jobz = V&lt;/code&gt; ）。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则使用 &lt;code&gt;A&lt;/code&gt; 的上三角。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则使用 &lt;code&gt;A&lt;/code&gt; 的下三角。</target>
        </trans-unit>
        <trans-unit id="d4975ecab6a2216e2ae41b865699cde79f331c8b" translate="yes" xml:space="preserve">
          <source>Finds the eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangle of &lt;code&gt;A&lt;/code&gt; is used. If &lt;code&gt;range = A&lt;/code&gt;, all the eigenvalues are found. If &lt;code&gt;range = V&lt;/code&gt;, the eigenvalues in the half-open interval &lt;code&gt;(vl, vu]&lt;/code&gt; are found. If &lt;code&gt;range = I&lt;/code&gt;, the eigenvalues with indices between &lt;code&gt;il&lt;/code&gt; and &lt;code&gt;iu&lt;/code&gt; are found. &lt;code&gt;abstol&lt;/code&gt; can be set as a tolerance for convergence.</source>
          <target state="translated">查找对称矩阵 &lt;code&gt;A&lt;/code&gt; 的特征值（ &lt;code&gt;jobz = N&lt;/code&gt; ）或特征值和特征向量（ &lt;code&gt;jobz = V&lt;/code&gt; ）。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则使用 &lt;code&gt;A&lt;/code&gt; 的上三角。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则使用 &lt;code&gt;A&lt;/code&gt; 的下三角。如果 &lt;code&gt;range = A&lt;/code&gt; ，则找到所有特征值。如果 &lt;code&gt;range = V&lt;/code&gt; ，则找到半开区间 &lt;code&gt;(vl, vu]&lt;/code&gt; 的特征值；如果 &lt;code&gt;range = I&lt;/code&gt; ，则找到索引 &lt;code&gt;il&lt;/code&gt; 与 &lt;code&gt;iu&lt;/code&gt; 之间的特征值；可以将 &lt;code&gt;abstol&lt;/code&gt; 设置为收敛容差。</target>
        </trans-unit>
        <trans-unit id="61beb0a5e34ea39a8997c5ca322120812554427f" translate="yes" xml:space="preserve">
          <source>Finds the generalized eigendecomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;jobvl = N&lt;/code&gt;, the left eigenvectors aren't computed. If &lt;code&gt;jobvr = N&lt;/code&gt;, the right eigenvectors aren't computed. If &lt;code&gt;jobvl = V&lt;/code&gt; or &lt;code&gt;jobvr = V&lt;/code&gt;, the corresponding eigenvectors are computed.</source>
          <target state="translated">求出 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的广义特征分解。如果 &lt;code&gt;jobvl = N&lt;/code&gt; ，则不计算左特征向量。如果 &lt;code&gt;jobvr = N&lt;/code&gt; ，则不计算正确的特征向量。如果 &lt;code&gt;jobvl = V&lt;/code&gt; 或 &lt;code&gt;jobvr = V&lt;/code&gt; ，则计算对应的特征向量。</target>
        </trans-unit>
        <trans-unit id="c264a1b0e814f3cbf1d8360c3568e4b5d9e1b127" translate="yes" xml:space="preserve">
          <source>Finds the generalized eigenvalues (&lt;code&gt;jobz = N&lt;/code&gt;) or eigenvalues and eigenvectors (&lt;code&gt;jobz = V&lt;/code&gt;) of a symmetric matrix &lt;code&gt;A&lt;/code&gt; and symmetric positive-definite matrix &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper triangles of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are used. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower triangles of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are used. If &lt;code&gt;itype = 1&lt;/code&gt;, the problem to solve is &lt;code&gt;A * x = lambda * B * x&lt;/code&gt;. If &lt;code&gt;itype = 2&lt;/code&gt;, the problem to solve is &lt;code&gt;A * B * x = lambda * x&lt;/code&gt;. If &lt;code&gt;itype = 3&lt;/code&gt;, the problem to solve is &lt;code&gt;B * A * x = lambda * x&lt;/code&gt;.</source>
          <target state="translated">查找对称矩阵 &lt;code&gt;A&lt;/code&gt; 和对称正定矩阵 &lt;code&gt;B&lt;/code&gt; 的广义特征值（ &lt;code&gt;jobz = N&lt;/code&gt; ）或特征值和特征向量（ &lt;code&gt;jobz = V&lt;/code&gt; ）。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则使用 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的上三角。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则使用 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 的下部三角形。如果 &lt;code&gt;itype = 1&lt;/code&gt; ，则要解决的问题是 &lt;code&gt;A * x = lambda * B * x&lt;/code&gt; 。如果 &lt;code&gt;itype = 2&lt;/code&gt; ，则要解决的问题是 &lt;code&gt;A * B * x = lambda * x&lt;/code&gt; 。如果 &lt;code&gt;itype = 3&lt;/code&gt; ，要解决的问题是 &lt;code&gt;B * A * x = lambda * x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="32def567c6d9738ac90487f8efbe1b9b389479aa" translate="yes" xml:space="preserve">
          <source>Finds the generalized singular value decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; and &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt;. &lt;code&gt;D1&lt;/code&gt; has &lt;code&gt;alpha&lt;/code&gt; on its diagonal and &lt;code&gt;D2&lt;/code&gt; has &lt;code&gt;beta&lt;/code&gt; on its diagonal. If &lt;code&gt;jobu = U&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;U&lt;/code&gt; is computed. If &lt;code&gt;jobv = V&lt;/code&gt; the orthogonal/unitary matrix &lt;code&gt;V&lt;/code&gt; is computed. If &lt;code&gt;jobq = Q&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;Q&lt;/code&gt; is computed. If &lt;code&gt;jobu&lt;/code&gt;, &lt;code&gt;jobv&lt;/code&gt; or &lt;code&gt;jobq&lt;/code&gt; is &lt;code&gt;N&lt;/code&gt;, that matrix is not computed. This function is only available in LAPACK versions prior to 3.6.0.</source>
          <target state="translated">发现的广义奇异值分解 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; 和 &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt; 。 &lt;code&gt;D1&lt;/code&gt; 具有 &lt;code&gt;alpha&lt;/code&gt; 在其对角线和 &lt;code&gt;D2&lt;/code&gt; 具有 &lt;code&gt;beta&lt;/code&gt; 在其对角线上。如果 &lt;code&gt;jobu = U&lt;/code&gt; ，则计算正交/ unit矩阵 &lt;code&gt;U&lt;/code&gt; 。如果 &lt;code&gt;jobv = V&lt;/code&gt; ，则计算正交/ unit矩阵 &lt;code&gt;V&lt;/code&gt; 。如果 &lt;code&gt;jobq = Q&lt;/code&gt; ，则计算正交/ unit矩阵 &lt;code&gt;Q&lt;/code&gt; 。如果 &lt;code&gt;jobu&lt;/code&gt; ， &lt;code&gt;jobv&lt;/code&gt; 或 &lt;code&gt;jobq&lt;/code&gt; 为 &lt;code&gt;N&lt;/code&gt; ，则不计算该矩阵。此功能仅在3.6.0之前的LAPACK版本中可用。</target>
        </trans-unit>
        <trans-unit id="210e81d5d1ad1ff32c30a0939ad6da82758f3395" translate="yes" xml:space="preserve">
          <source>Finds the generalized singular value decomposition of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; and &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt;. &lt;code&gt;D1&lt;/code&gt; has &lt;code&gt;alpha&lt;/code&gt; on its diagonal and &lt;code&gt;D2&lt;/code&gt; has &lt;code&gt;beta&lt;/code&gt; on its diagonal. If &lt;code&gt;jobu = U&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;U&lt;/code&gt; is computed. If &lt;code&gt;jobv = V&lt;/code&gt; the orthogonal/unitary matrix &lt;code&gt;V&lt;/code&gt; is computed. If &lt;code&gt;jobq = Q&lt;/code&gt;, the orthogonal/unitary matrix &lt;code&gt;Q&lt;/code&gt; is computed. If &lt;code&gt;jobu&lt;/code&gt;, &lt;code&gt;jobv&lt;/code&gt;, or &lt;code&gt;jobq&lt;/code&gt; is &lt;code&gt;N&lt;/code&gt;, that matrix is not computed. This function requires LAPACK 3.6.0.</source>
          <target state="translated">发现的广义奇异值分解 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;U'*A*Q = D1*R&lt;/code&gt; 和 &lt;code&gt;V'*B*Q = D2*R&lt;/code&gt; 。 &lt;code&gt;D1&lt;/code&gt; 具有 &lt;code&gt;alpha&lt;/code&gt; 在其对角线和 &lt;code&gt;D2&lt;/code&gt; 具有 &lt;code&gt;beta&lt;/code&gt; 在其对角线上。如果 &lt;code&gt;jobu = U&lt;/code&gt; ，则计算正交/ unit矩阵 &lt;code&gt;U&lt;/code&gt; 。如果 &lt;code&gt;jobv = V&lt;/code&gt; ，则计算正交/ unit矩阵 &lt;code&gt;V&lt;/code&gt; 。如果 &lt;code&gt;jobq = Q&lt;/code&gt; ，则计算正交/ unit矩阵 &lt;code&gt;Q&lt;/code&gt; 。如果 &lt;code&gt;jobu&lt;/code&gt; ， &lt;code&gt;jobv&lt;/code&gt; 或 &lt;code&gt;jobq&lt;/code&gt; 为 &lt;code&gt;N&lt;/code&gt; ，则不计算该矩阵。该功能需要LAPACK 3.6.0。</target>
        </trans-unit>
        <trans-unit id="a39c044a480fd441ceb8f283f49fa1d53cc5f0a7" translate="yes" xml:space="preserve">
          <source>Finds the inverse of (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) triangular matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. &lt;code&gt;A&lt;/code&gt; is overwritten with its inverse.</source>
          <target state="translated">查找三角矩阵 &lt;code&gt;A&lt;/code&gt; 的逆（如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则为上部；如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则为下部）。如果 &lt;code&gt;diag = N&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 具有非单位对角线元素。如果 &lt;code&gt;diag = U&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 的所有对角元素均为1。 &lt;code&gt;A&lt;/code&gt; 被其反函数覆盖。</target>
        </trans-unit>
        <trans-unit id="6a5d68361868fdd15faef2d4f1871095495175a9" translate="yes" xml:space="preserve">
          <source>Finds the reciprocal condition number of (upper if &lt;code&gt;uplo = U&lt;/code&gt;, lower if &lt;code&gt;uplo = L&lt;/code&gt;) triangular matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;diag = N&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; has non-unit diagonal elements. If &lt;code&gt;diag = U&lt;/code&gt;, all diagonal elements of &lt;code&gt;A&lt;/code&gt; are one. If &lt;code&gt;norm = I&lt;/code&gt;, the condition number is found in the infinity norm. If &lt;code&gt;norm = O&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, the condition number is found in the one norm.</source>
          <target state="translated">查找（矩阵的倒数）三角形矩阵 &lt;code&gt;A&lt;/code&gt; 的倒数（如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则较高； &lt;code&gt;uplo = L&lt;/code&gt; ，则较低）。如果 &lt;code&gt;diag = N&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 具有非单位对角线元素。如果 &lt;code&gt;diag = U&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 的所有对角元素均为1。如果 &lt;code&gt;norm = I&lt;/code&gt; ，则在无穷范数中找到条件编号。如果 &lt;code&gt;norm = O&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; ，则在一个规范中找到条件编号。</target>
        </trans-unit>
        <trans-unit id="c78886357b0729c06906090f44a5cf8b7b256de8" translate="yes" xml:space="preserve">
          <source>Finds the reciprocal condition number of matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;normtype = I&lt;/code&gt;, the condition number is found in the infinity norm. If &lt;code&gt;normtype = O&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, the condition number is found in the one norm. &lt;code&gt;A&lt;/code&gt; must be the result of &lt;code&gt;getrf!&lt;/code&gt; and &lt;code&gt;anorm&lt;/code&gt; is the norm of &lt;code&gt;A&lt;/code&gt; in the relevant norm.</source>
          <target state="translated">求矩阵 &lt;code&gt;A&lt;/code&gt; 的倒数。如果 &lt;code&gt;normtype = I&lt;/code&gt; ，则在无穷范数中找到条件编号。如果 &lt;code&gt;normtype = O&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; ，则在一个规范中找到条件编号。 &lt;code&gt;A&lt;/code&gt; 必须的结果 &lt;code&gt;getrf!&lt;/code&gt; 和 &lt;code&gt;anorm&lt;/code&gt; 是规范 &lt;code&gt;A&lt;/code&gt; 的相关规范。</target>
        </trans-unit>
        <trans-unit id="6c19c48ac3ae5442f994d8fe0a9d01dd34ef53de" translate="yes" xml:space="preserve">
          <source>Finds the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = U * S * V'&lt;/code&gt;, using a divide and conquer approach. If &lt;code&gt;job = A&lt;/code&gt;, all the columns of &lt;code&gt;U&lt;/code&gt; and the rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;job = N&lt;/code&gt;, no columns of &lt;code&gt;U&lt;/code&gt; or rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;job = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the columns of (thin) &lt;code&gt;U&lt;/code&gt; and the rows of (thin) &lt;code&gt;V'&lt;/code&gt;. If &lt;code&gt;job = S&lt;/code&gt;, the columns of (thin) &lt;code&gt;U&lt;/code&gt; and the rows of (thin) &lt;code&gt;V'&lt;/code&gt; are computed and returned separately.</source>
          <target state="translated">使用分治法找到 &lt;code&gt;A&lt;/code&gt; 的奇异值分解，即 &lt;code&gt;A = U * S * V'&lt;/code&gt; 。如果 &lt;code&gt;job = A&lt;/code&gt; ，则计算 &lt;code&gt;U&lt;/code&gt; 的所有列和 &lt;code&gt;V'&lt;/code&gt; 的行。如果 &lt;code&gt;job = N&lt;/code&gt; ，则不计算 &lt;code&gt;U&lt;/code&gt; 列或 &lt;code&gt;V'&lt;/code&gt; 行。如果 &lt;code&gt;job = O&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 的列将被（细） &lt;code&gt;U&lt;/code&gt; 的列和（细） &lt;code&gt;V'&lt;/code&gt; 的行覆盖。如果 &lt;code&gt;job = S&lt;/code&gt; ，则分别计算（薄） &lt;code&gt;U&lt;/code&gt; 的列和（薄） &lt;code&gt;V'&lt;/code&gt; 的行并返回。</target>
        </trans-unit>
        <trans-unit id="a0b3e8d21586ca0fb1724dcb3c78acc9787461cc" translate="yes" xml:space="preserve">
          <source>Finds the singular value decomposition of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;A = U * S * V'&lt;/code&gt;. If &lt;code&gt;jobu = A&lt;/code&gt;, all the columns of &lt;code&gt;U&lt;/code&gt; are computed. If &lt;code&gt;jobvt = A&lt;/code&gt; all the rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;jobu = N&lt;/code&gt;, no columns of &lt;code&gt;U&lt;/code&gt; are computed. If &lt;code&gt;jobvt = N&lt;/code&gt; no rows of &lt;code&gt;V'&lt;/code&gt; are computed. If &lt;code&gt;jobu = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the columns of (thin) &lt;code&gt;U&lt;/code&gt;. If &lt;code&gt;jobvt = O&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is overwritten with the rows of (thin) &lt;code&gt;V'&lt;/code&gt;. If &lt;code&gt;jobu = S&lt;/code&gt;, the columns of (thin) &lt;code&gt;U&lt;/code&gt; are computed and returned separately. If &lt;code&gt;jobvt = S&lt;/code&gt; the rows of (thin) &lt;code&gt;V'&lt;/code&gt; are computed and returned separately. &lt;code&gt;jobu&lt;/code&gt; and &lt;code&gt;jobvt&lt;/code&gt; can't both be &lt;code&gt;O&lt;/code&gt;.</source>
          <target state="translated">查找 &lt;code&gt;A&lt;/code&gt; 的奇异值分解， &lt;code&gt;A = U * S * V'&lt;/code&gt; 。如果 &lt;code&gt;jobu = A&lt;/code&gt; ，则计算 &lt;code&gt;U&lt;/code&gt; 的所有列。如果 &lt;code&gt;jobvt = A&lt;/code&gt; ，则计算 &lt;code&gt;V'&lt;/code&gt; 的所有行。如果 &lt;code&gt;jobu = N&lt;/code&gt; ，则不计算 &lt;code&gt;U&lt;/code&gt; 的列。如果 &lt;code&gt;jobvt = N&lt;/code&gt; 则不计算 &lt;code&gt;V'&lt;/code&gt; 的行。如果 &lt;code&gt;jobu = O&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 会被（thin） &lt;code&gt;U&lt;/code&gt; 列覆盖。如果 &lt;code&gt;jobvt = O&lt;/code&gt; ，则 &lt;code&gt;A&lt;/code&gt; 会被（细） &lt;code&gt;V'&lt;/code&gt; 的行覆盖。如果 &lt;code&gt;jobu = S&lt;/code&gt; ，则（thin）的列 &lt;code&gt;U&lt;/code&gt; 分别计算并返回。如果 &lt;code&gt;jobvt = S&lt;/code&gt; ，则分别计算（细） &lt;code&gt;V'&lt;/code&gt; 的行并返回。 &lt;code&gt;jobu&lt;/code&gt; 和 &lt;code&gt;jobvt&lt;/code&gt; 不能同时为 &lt;code&gt;O&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bfbc35df929a38fee1ee63d2aef508a3752ae6f0" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; for Hermitian matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;B&lt;/code&gt; is overwritten by the solution &lt;code&gt;X&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Bunch-Kaufman factorization. &lt;code&gt;ipiv&lt;/code&gt; contains pivoting information about the factorization.</source>
          <target state="translated">查找埃尔米特矩阵 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;A * X = B&lt;/code&gt; 的解。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则存储 &lt;code&gt;A&lt;/code&gt; 的上半部分。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则存储下半部分。 &lt;code&gt;B&lt;/code&gt; 由解 &lt;code&gt;X&lt;/code&gt; 覆盖。 &lt;code&gt;A&lt;/code&gt; 被Bunch-Kaufman因式分解所覆盖。 &lt;code&gt;ipiv&lt;/code&gt; 包含有关分解的重要信息。</target>
        </trans-unit>
        <trans-unit id="3f1c2e1c20cfe582666286913369ada94f51d8cf" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; for symmetric matrix &lt;code&gt;A&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt;, the upper half of &lt;code&gt;A&lt;/code&gt; is stored. If &lt;code&gt;uplo = L&lt;/code&gt;, the lower half is stored. &lt;code&gt;B&lt;/code&gt; is overwritten by the solution &lt;code&gt;X&lt;/code&gt;. &lt;code&gt;A&lt;/code&gt; is overwritten by its Bunch-Kaufman factorization. &lt;code&gt;ipiv&lt;/code&gt; contains pivoting information about the factorization.</source>
          <target state="translated">查找对称矩阵 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;A * X = B&lt;/code&gt; 的解。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则存储 &lt;code&gt;A&lt;/code&gt; 的上半部分。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则存储下半部分。 &lt;code&gt;B&lt;/code&gt; 由解 &lt;code&gt;X&lt;/code&gt; 覆盖。 &lt;code&gt;A&lt;/code&gt; 被Bunch-Kaufman因式分解所覆盖。 &lt;code&gt;ipiv&lt;/code&gt; 包含有关分解的重要信息。</target>
        </trans-unit>
        <trans-unit id="05c0a676aeb2122358cb2d2b62a8dc34d0ff96bb" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is a symmetric or Hermitian positive definite matrix whose Cholesky decomposition was computed by &lt;code&gt;potrf!&lt;/code&gt;. If &lt;code&gt;uplo = U&lt;/code&gt; the upper Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; was computed. If &lt;code&gt;uplo = L&lt;/code&gt; the lower Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; was computed. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">查找 &lt;code&gt;A * X = B&lt;/code&gt; 的解，其中 &lt;code&gt;A&lt;/code&gt; 是对称或Hermitian正定矩阵，其Cholesky分解由 &lt;code&gt;potrf!&lt;/code&gt; 计算！。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则计算 &lt;code&gt;A&lt;/code&gt; 的上Cholesky分解。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则计算 &lt;code&gt;A&lt;/code&gt; 的下层Cholesky分解。 &lt;code&gt;B&lt;/code&gt; 被解决方案 &lt;code&gt;X&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="e99b5edae4a2dc1678284239ea67a37fe1921376" translate="yes" xml:space="preserve">
          <source>Finds the solution to &lt;code&gt;A * X = B&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; is a symmetric or Hermitian positive definite matrix. If &lt;code&gt;uplo = U&lt;/code&gt; the upper Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; is computed. If &lt;code&gt;uplo = L&lt;/code&gt; the lower Cholesky decomposition of &lt;code&gt;A&lt;/code&gt; is computed. &lt;code&gt;A&lt;/code&gt; is overwritten by its Cholesky decomposition. &lt;code&gt;B&lt;/code&gt; is overwritten with the solution &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">查找 &lt;code&gt;A * X = B&lt;/code&gt; 的解，其中 &lt;code&gt;A&lt;/code&gt; 是对称或Hermitian正定矩阵。如果 &lt;code&gt;uplo = U&lt;/code&gt; ，则计算 &lt;code&gt;A&lt;/code&gt; 的上Cholesky分解。如果 &lt;code&gt;uplo = L&lt;/code&gt; ，则计算 &lt;code&gt;A&lt;/code&gt; 的下层Cholesky分解。 &lt;code&gt;A&lt;/code&gt; 被其Cholesky分解覆盖。 &lt;code&gt;B&lt;/code&gt; 被解决方案 &lt;code&gt;X&lt;/code&gt; 覆盖。</target>
        </trans-unit>
        <trans-unit id="8e7e713430f9bcb8fd60110d1ddaba473fe37beb" translate="yes" xml:space="preserve">
          <source>Finished with an uncaught exception</source>
          <target state="translated">以一个未被发现的例外完成</target>
        </trans-unit>
        <trans-unit id="d4f94f922955d9b99f89834068cd98fd1aba023b" translate="yes" xml:space="preserve">
          <source>Finite Part Integral</source>
          <target state="translated">有限部分积分</target>
        </trans-unit>
        <trans-unit id="e5b076c42526fba51c6923d8682dc75c64aa4bcd" translate="yes" xml:space="preserve">
          <source>Finite difference operator on a vector or a multidimensional array &lt;code&gt;A&lt;/code&gt;. In the latter case the dimension to operate on needs to be specified with the &lt;code&gt;dims&lt;/code&gt; keyword argument.</source>
          <target state="translated">向量或多维数组 &lt;code&gt;A&lt;/code&gt; 上的有限差分算子。在后一种情况下，需要使用 &lt;code&gt;dims&lt;/code&gt; 关键字参数指定要操作的尺寸。</target>
        </trans-unit>
        <trans-unit id="7a4557ec58940c5eada2fe857ddb8888c78004d3" translate="yes" xml:space="preserve">
          <source>Finite numbers are ordered in the usual manner.</source>
          <target state="translated">有限数按常规方式排序。</target>
        </trans-unit>
        <trans-unit id="78baebfcb4b52665d7e8a9c7826c47b0fa2439f6" translate="yes" xml:space="preserve">
          <source>Fire</source>
          <target state="translated">Fire</target>
        </trans-unit>
        <trans-unit id="ccb3bd276e9391502d5858c0ee82ed61db7ec7a7" translate="yes" xml:space="preserve">
          <source>Fire Engine</source>
          <target state="translated">消防车</target>
        </trans-unit>
        <trans-unit id="c38b663a951f35db127c178e977a734a5f954d31" translate="yes" xml:space="preserve">
          <source>Firework Sparkler</source>
          <target state="translated">烟花爆竹</target>
        </trans-unit>
        <trans-unit id="4f8ff80cb6112a8df5a0ae17110f841b4709fc4a" translate="yes" xml:space="preserve">
          <source>Fireworks</source>
          <target state="translated">Fireworks</target>
        </trans-unit>
        <trans-unit id="0b7bdf63087ea834463f7869ee05ee0f78b2039d" translate="yes" xml:space="preserve">
          <source>First Quarter Moon</source>
          <target state="translated">第一季月亮</target>
        </trans-unit>
        <trans-unit id="8d23a610d2c1a9be816138d8135fd6968e488141" translate="yes" xml:space="preserve">
          <source>First Quarter Moon Symbol</source>
          <target state="translated">第一季月亮符号</target>
        </trans-unit>
        <trans-unit id="74fa6c1e17a3a3252deb8af7194e87d8d33fbc11" translate="yes" xml:space="preserve">
          <source>First Quarter Moon With Face</source>
          <target state="translated">第一季月亮与脸</target>
        </trans-unit>
        <trans-unit id="f1738c1a48a67517ee40f4407fe85d205603ee0a" translate="yes" xml:space="preserve">
          <source>First, a review of some relevant Julia type terminology:</source>
          <target state="translated">首先,回顾一些相关的Julia类型术语。</target>
        </trans-unit>
        <trans-unit id="429810985fd6146395c751081851ef1372d21c2f" translate="yes" xml:space="preserve">
          <source>First, let's review some relevant Julia type terminology:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cea893d2a53ebb1e9b3f78ee61f550c12f76b89" translate="yes" xml:space="preserve">
          <source>First, triple-quoted strings are also dedented to the level of the least-indented line. This is useful for defining strings within code that is indented. For example:</source>
          <target state="translated">首先,三引号的字符串也会被缩进到最不缩进的行的级别。这对于在缩进的代码中定义字符串很有用。例如</target>
        </trans-unit>
        <trans-unit id="f0d11adabc82edc0523feb5883cbbd9e9d59c1cd" translate="yes" xml:space="preserve">
          <source>First, with &lt;code&gt;ntasks&lt;/code&gt; undefined, each element is processed in a different task.</source>
          <target state="translated">首先，在未定义 &lt;code&gt;ntasks&lt;/code&gt; 的情况下，每个元素都在不同的任务中处理。</target>
        </trans-unit>
        <trans-unit id="3030e8ec7633ec1a524bb246aee7dbda6fb3e4bc" translate="yes" xml:space="preserve">
          <source>Fish</source>
          <target state="translated">Fish</target>
        </trans-unit>
        <trans-unit id="08ef4d73924ae1ff99ef9760dad3a8b35cdbc717" translate="yes" xml:space="preserve">
          <source>Fish Cake With Swirl Design</source>
          <target state="translated">漩涡设计的鱼蛋糕</target>
        </trans-unit>
        <trans-unit id="6af9685850189240cc327402ef6a117b0925f447" translate="yes" xml:space="preserve">
          <source>Fisheye</source>
          <target state="translated">Fisheye</target>
        </trans-unit>
        <trans-unit id="217458563b479c9b5e1aa24b33b36b9c5286dff5" translate="yes" xml:space="preserve">
          <source>Fishing Pole And Fish</source>
          <target state="translated">钓鱼竿和鱼</target>
        </trans-unit>
        <trans-unit id="ec1091759eb5098c1ce15fb7122c53128cb7e317" translate="yes" xml:space="preserve">
          <source>Fisted Hand Sign</source>
          <target state="translated">拳手牌</target>
        </trans-unit>
        <trans-unit id="46a9bd02c1e56f8667dcc006e6e80c33bdfb6b09" translate="yes" xml:space="preserve">
          <source>Five-argument &lt;code&gt;mul!&lt;/code&gt; requires at least Julia 1.3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee4d04bcaeb407d6978ec547023834d74dc08028" translate="yes" xml:space="preserve">
          <source>Fix deprecation warnings</source>
          <target state="translated">修正过时警告</target>
        </trans-unit>
        <trans-unit id="f057e4dd9329dfaa6b558f5251558c8bd7042ccf" translate="yes" xml:space="preserve">
          <source>Fixed-width slots are specified by repeating the period character the number of times corresponding to the width with no delimiter between characters. So &lt;code&gt;&quot;yyyymmdd&quot;&lt;/code&gt; would correspond to a date string like &lt;code&gt;&quot;20140716&quot;&lt;/code&gt;. The parser distinguishes a fixed-width slot by the absence of a delimiter, noting the transition &lt;code&gt;&quot;yyyymm&quot;&lt;/code&gt; from one period character to the next.</source>
          <target state="translated">通过将句点字符重复对应于宽度的次数来指定固定宽度的插槽，而字符之间没有定界符。因此， &lt;code&gt;&quot;yyyymmdd&quot;&lt;/code&gt; 将对应于日期字符串，例如 &lt;code&gt;&quot;20140716&quot;&lt;/code&gt; 。解析器通过没有定界符来区分固定宽度的时隙，并指出从一个句点字符到下一个句点字符的 &lt;code&gt;&quot;yyyymm&quot;&lt;/code&gt; 过渡。</target>
        </trans-unit>
        <trans-unit id="5695ea14bfec9e6b7d86faa5e86d6e6aa911f902" translate="yes" xml:space="preserve">
          <source>Flag In Hole</source>
          <target state="translated">孔中旗</target>
        </trans-unit>
        <trans-unit id="58270b038657eb33ab9c272d4b0b663caf6f505b" translate="yes" xml:space="preserve">
          <source>Flatness</source>
          <target state="translated">Flatness</target>
        </trans-unit>
        <trans-unit id="157a69122ac7ee154e0f87d80f294a117ce27465" translate="yes" xml:space="preserve">
          <source>Flexed Biceps</source>
          <target state="translated">弯曲的肱二头肌</target>
        </trans-unit>
        <trans-unit id="ee9ce77c4431cac02ee809f2bf8b3362c097e451" translate="yes" xml:space="preserve">
          <source>Flip the bits of &lt;code&gt;val&lt;/code&gt; indexed by &lt;code&gt;flag&lt;/code&gt;, so that if a bit is &lt;code&gt;0&lt;/code&gt; it will be &lt;code&gt;1&lt;/code&gt; after the toggle, and vice-versa.</source>
          <target state="translated">翻转由 &lt;code&gt;flag&lt;/code&gt; 索引的 &lt;code&gt;val&lt;/code&gt; 的位，以便如果位为 &lt;code&gt;0&lt;/code&gt; ，则在切换后为 &lt;code&gt;1&lt;/code&gt; ，反之亦然。</target>
        </trans-unit>
        <trans-unit id="444518fe06999c30d999423013ab4f1c5d158646" translate="yes" xml:space="preserve">
          <source>Floating-Point Numbers</source>
          <target state="translated">浮点数</target>
        </trans-unit>
        <trans-unit id="50eee28c25d79612d8553be7d7bd2846378f99a9" translate="yes" xml:space="preserve">
          <source>Floating-point arithmetic entails many subtleties which can be surprising to users who are unfamiliar with the low-level implementation details. However, these subtleties are described in detail in most books on scientific computation, and also in the following references:</source>
          <target state="translated">浮点运算有许多微妙的地方,对于不熟悉低级实现细节的用户来说,可能会感到惊讶。不过,这些细微之处在大多数科学计算的书籍中都有详细的描述,在下面的参考文献中也有。</target>
        </trans-unit>
        <trans-unit id="fa83ec82b434276bb3bfc0811f157d35a5e75cfc" translate="yes" xml:space="preserve">
          <source>Floating-point numbers have &lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_zero&quot;&gt;two zeros&lt;/a&gt;, positive zero and negative zero. They are equal to each other but have different binary representations, as can be seen using the &lt;a href=&quot;../../base/numbers/index#Base.bitstring&quot;&gt;&lt;code&gt;bitstring&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">浮点数有&lt;a href=&quot;https://en.wikipedia.org/wiki/Signed_zero&quot;&gt;两个零&lt;/a&gt;，正零和负零。它们彼此相等，但是具有不同的二进制表示形式，如使用&lt;a href=&quot;../../base/numbers/index#Base.bitstring&quot;&gt; &lt;code&gt;bitstring&lt;/code&gt; &lt;/a&gt;函数可以看到的那样：</target>
        </trans-unit>
        <trans-unit id="3fba63653b996ccaa92264b381e4cee8797797a5" translate="yes" xml:space="preserve">
          <source>Floating-point operations on reduction variables can be reordered, possibly causing different results than without &lt;code&gt;@simd&lt;/code&gt;.</source>
          <target state="translated">可以对归约变量的浮点运算进行重新排序，与不使用 &lt;code&gt;@simd&lt;/code&gt; 相比，可能导致不同的结果。</target>
        </trans-unit>
        <trans-unit id="5043ab32eb0ec94e147a66ceca999e1ecfae56b6" translate="yes" xml:space="preserve">
          <source>Floating-point values are promoted to the largest of the floating-point argument types. Integer values are promoted to the larger of either the native machine word size or the largest integer argument type. Mixtures of integers and floating-point values are promoted to a floating-point type big enough to hold all the values. Integers mixed with rationals are promoted to rationals. Rationals mixed with floats are promoted to floats. Complex values mixed with real values are promoted to the appropriate kind of complex value.</source>
          <target state="translated">浮点值被提升为最大的浮点参数类型。整数值被提升到本机字数或最大的整数参数类型中较大的一个。整数和浮点值的混合体会被提升到一个足够大的浮点类型,以容纳所有的值。整数与公理值的混合体被推广为公理类型。与浮点混合的有理数被提升为浮点类型。与实值混合的复值被提升为相应的复值。</target>
        </trans-unit>
        <trans-unit id="cebba3f2674f659c3ac76a05e885a881a3fcce6d" translate="yes" xml:space="preserve">
          <source>Floating-point zero</source>
          <target state="translated">浮点零点</target>
        </trans-unit>
        <trans-unit id="d43047ffbb02b9960d1076b1d1bb9cdef48764e1" translate="yes" xml:space="preserve">
          <source>Flooring division, returning a value consistent with &lt;code&gt;mod1(x,y)&lt;/code&gt;</source>
          <target state="translated">地板分割，返回与 &lt;code&gt;mod1(x,y)&lt;/code&gt; 一致的值</target>
        </trans-unit>
        <trans-unit id="0cb23ae2c189b13f5f90d739cf453c252387dc2d" translate="yes" xml:space="preserve">
          <source>Floppy Disk</source>
          <target state="translated">软盘</target>
        </trans-unit>
        <trans-unit id="00d43012b0d3d0a7fff1c3e0edf1cbd87e191788" translate="yes" xml:space="preserve">
          <source>Flower Playing Cards</source>
          <target state="translated">花牌</target>
        </trans-unit>
        <trans-unit id="3b70164ceac5ab45d8a49385e479599c3b2028ee" translate="yes" xml:space="preserve">
          <source>Flushed Face</source>
          <target state="translated">面色红润</target>
        </trans-unit>
        <trans-unit id="c095ff38e8ffaf6ceac6c9df64aa62e9da573536" translate="yes" xml:space="preserve">
          <source>Flushes the C &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; streams (which may have been written to by external C code).</source>
          <target state="translated">刷新C &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 流（可能已由外部C代码写入）。</target>
        </trans-unit>
        <trans-unit id="88957d8137dbc8ecadcade0adeacd0f2a5ab4356" translate="yes" xml:space="preserve">
          <source>Foggy</source>
          <target state="translated">Foggy</target>
        </trans-unit>
        <trans-unit id="6e5da7739741403346eb36590ee15c92d6501bc4" translate="yes" xml:space="preserve">
          <source>Following the outer constructor definitions, we defined a number of methods for the &lt;code&gt;⊘&lt;/code&gt; operator, which provides a syntax for writing rationals (e.g. &lt;code&gt;1 ⊘ 2&lt;/code&gt;). Julia's &lt;code&gt;Rational&lt;/code&gt; type uses the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator for this purpose. Before these definitions, &lt;code&gt;⊘&lt;/code&gt; is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers&quot;&gt;Rational Numbers&lt;/a&gt; &amp;ndash; its entire behavior is defined in these few lines. The first and most basic definition just makes &lt;code&gt;a ⊘ b&lt;/code&gt; construct a &lt;code&gt;OurRational&lt;/code&gt; by applying the &lt;code&gt;OurRational&lt;/code&gt; constructor to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; when they are integers. When one of the operands of &lt;code&gt;⊘&lt;/code&gt; is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying &lt;code&gt;⊘&lt;/code&gt; to complex integral values creates an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; &amp;ndash; a complex number whose real and imaginary parts are rationals:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c789741f990351befd624144e4fbf31c533b3a78" translate="yes" xml:space="preserve">
          <source>Following the outer constructor definitions, we defined a number of methods for the &lt;code&gt;⊘&lt;/code&gt; operator, which provides a syntax for writing rationals (e.g. &lt;code&gt;1 ⊘ 2&lt;/code&gt;). Julia's &lt;code&gt;Rational&lt;/code&gt; type uses the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator for this purpose. Before these definitions, &lt;code&gt;⊘&lt;/code&gt; is a completely undefined operator with only syntax and no meaning. Afterwards, it behaves just as described in &lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers-1&quot;&gt;Rational Numbers&lt;/a&gt; &amp;ndash; its entire behavior is defined in these few lines. The first and most basic definition just makes &lt;code&gt;a ⊘ b&lt;/code&gt; construct a &lt;code&gt;OurRational&lt;/code&gt; by applying the &lt;code&gt;OurRational&lt;/code&gt; constructor to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; when they are integers. When one of the operands of &lt;code&gt;⊘&lt;/code&gt; is already a rational number, we construct a new rational for the resulting ratio slightly differently; this behavior is actually identical to division of a rational with an integer. Finally, applying &lt;code&gt;⊘&lt;/code&gt; to complex integral values creates an instance of &lt;code&gt;Complex{OurRational}&lt;/code&gt; &amp;ndash; a complex number whose real and imaginary parts are rationals:</source>
          <target state="translated">根据外部构造函数的定义，我们为 &lt;code&gt;⊘&lt;/code&gt; 运算符定义了许多方法，这些方法提供了编写有理数的语法（例如 &lt;code&gt;1 ⊘ 2&lt;/code&gt; ）。为此，Julia的 &lt;code&gt;Rational&lt;/code&gt; 类型使用&lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt;运算符。在这些定义之前， &lt;code&gt;⊘&lt;/code&gt; 是完全未定义的运算符，仅包含语法，没有意义。之后，它的行为就与&lt;a href=&quot;../complex-and-rational-numbers/index#Rational-Numbers-1&quot;&gt;Rational Numbers中&lt;/a&gt;描述的一样-它的整个行为在以下几行中定义。第一，最基本的定义只是让 &lt;code&gt;a ⊘ b&lt;/code&gt; 构建一个 &lt;code&gt;OurRational&lt;/code&gt; 通过应用 &lt;code&gt;OurRational&lt;/code&gt; 构造函数 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 当它们是整数时。当的操作数之一 &lt;code&gt;⊘&lt;/code&gt; 已经是一个有理数，我们构建了所得到的比率稍微不同新理性; 这种行为实际上与有理数与整数的除法相同。最后，将 &lt;code&gt;⊘&lt;/code&gt; 应用于复杂的整数值会创建一个 &lt;code&gt;Complex{OurRational}&lt;/code&gt; 的实例&amp;ndash; Complex的实部和虚部都是有理数：</target>
        </trans-unit>
        <trans-unit id="1e77a8685e1b18b030132d7235106a58bff9d77d" translate="yes" xml:space="preserve">
          <source>Footnote references</source>
          <target state="translated">脚注参考</target>
        </trans-unit>
        <trans-unit id="9d738544b84d3e6ca69948f1d45fc336d259c385" translate="yes" xml:space="preserve">
          <source>Footnote text is defined using the following syntax, which is similar to footnote reference syntax, aside from the &lt;code&gt;:&lt;/code&gt; character that is appended to the footnote label.</source>
          <target state="translated">脚注文本是使用以下语法定义的，该语法类似于脚注参考语法，除了附加在脚注标签上的 &lt;code&gt;:&lt;/code&gt; 字符。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="6f17ee469db4ec0c0c7e81b41c2cbcf9f902b3cc" translate="yes" xml:space="preserve">
          <source>Footprints</source>
          <target state="translated">Footprints</target>
        </trans-unit>
        <trans-unit id="ae9f4e9dfa0443b0ceae859867c4f509f5a9474e" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; objects this can be done either directly or by use of a convenience macro:</source>
          <target state="translated">对于&lt;a href=&quot;../../base/parallel/index#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;对象，可以直接执行此操作，也可以使用便捷宏执行此操作：</target>
        </trans-unit>
        <trans-unit id="b1492f65d2da61bde614e2df1030321603972a60" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../numbers/index#Core.Unsigned&quot;&gt;&lt;code&gt;Unsigned&lt;/code&gt;&lt;/a&gt; integer types, this is equivalent to &lt;a href=&quot;#Base.:&amp;gt;&amp;gt;&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/a&gt;. For &lt;a href=&quot;../numbers/index#Core.Signed&quot;&gt;&lt;code&gt;Signed&lt;/code&gt;&lt;/a&gt; integer types, this is equivalent to &lt;code&gt;signed(unsigned(x) &amp;gt;&amp;gt; n)&lt;/code&gt;.</source>
          <target state="translated">对于&lt;a href=&quot;../numbers/index#Core.Unsigned&quot;&gt; &lt;code&gt;Unsigned&lt;/code&gt; &lt;/a&gt;整数类型，这等效于&lt;a href=&quot;#Base.:&amp;gt;&amp;gt;&quot;&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; &lt;/a&gt;。对于有&lt;a href=&quot;../numbers/index#Core.Signed&quot;&gt; &lt;code&gt;Signed&lt;/code&gt; &lt;/a&gt;整数类型，这等效于有 &lt;code&gt;signed(unsigned(x) &amp;gt;&amp;gt; n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a40737843ce84d120d446cac7c60f6d3a180523" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArray&lt;/code&gt; types that support arbitrary dimensionality, &lt;code&gt;N&lt;/code&gt; can be set to &lt;code&gt;Any&lt;/code&gt;:</source>
          <target state="translated">对于支持任意维的 &lt;code&gt;AbstractArray&lt;/code&gt; 类型，可以将 &lt;code&gt;N&lt;/code&gt; 设置为 &lt;code&gt;Any&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="78cc0c00798ab494e86cd193ffb9a72a0848fb41" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArray&lt;/code&gt; types, defining a &lt;code&gt;BroadcastStyle&lt;/code&gt; supersedes the fallback choice, &lt;a href=&quot;../../base/arrays/index#Base.Broadcast.DefaultArrayStyle&quot;&gt;&lt;code&gt;Broadcast.DefaultArrayStyle&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;DefaultArrayStyle&lt;/code&gt; and the abstract supertype, &lt;code&gt;AbstractArrayStyle&lt;/code&gt;, store the dimensionality as a type parameter to support specialized array types that have fixed dimensionality requirements.</source>
          <target state="translated">对于 &lt;code&gt;AbstractArray&lt;/code&gt; 类型，定义一个 &lt;code&gt;BroadcastStyle&lt;/code&gt; 替代后备选项&lt;a href=&quot;../../base/arrays/index#Base.Broadcast.DefaultArrayStyle&quot;&gt; &lt;code&gt;Broadcast.DefaultArrayStyle&lt;/code&gt; &lt;/a&gt;。 &lt;code&gt;DefaultArrayStyle&lt;/code&gt; 和抽象超类型 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; 将维存储为类型参数，以支持具有固定维要求的专用数组类型。</target>
        </trans-unit>
        <trans-unit id="0c614db39e8f0ca718810e31731f59d181271482" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;AbstractArrays&lt;/code&gt; that only support a certain dimensionality, create a subtype of &lt;code&gt;Broadcast.AbstractArrayStyle{N}&lt;/code&gt; (see below).</source>
          <target state="translated">对于仅支持特定维度的 &lt;code&gt;AbstractArrays&lt;/code&gt; ，请创建 &lt;code&gt;Broadcast.AbstractArrayStyle{N}&lt;/code&gt; 的子类型（请参见下文）。</target>
        </trans-unit>
        <trans-unit id="36e4edbd82274075aaa50a1a6642d0776aa14705" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;MySimpleContainer&lt;/code&gt;, the object is fully-specified by its type and parameters, so the compiler can generate optimized functions. In most instances, this will probably suffice.</source>
          <target state="translated">对于 &lt;code&gt;MySimpleContainer&lt;/code&gt; ，对象由其类型和参数完全指定，因此编译器可以生成优化的函数。在大多数情况下，这可能就足够了。</target>
        </trans-unit>
        <trans-unit id="08c5ae2629f26fdb821a26a0f5b3306f51f209f7" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;SymTridiagonal&lt;/code&gt; block matrices, the elements of &lt;code&gt;dv&lt;/code&gt; are symmetrized. The argument &lt;code&gt;ev&lt;/code&gt; is interpreted as the superdiagonal. Blocks from the subdiagonal are (materialized) transpose of the corresponding superdiagonal blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066f4790c89fa96385b602165d512d492e66ecc6" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;wchar_t*&lt;/code&gt; arguments, the Julia type should be &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt; (if the C routine expects a NUL-terminated string) or &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the &lt;code&gt;Cwstring&lt;/code&gt; type will cause an error to be thrown if the string itself contains NUL characters).</source>
          <target state="translated">对于 &lt;code&gt;wchar_t*&lt;/code&gt; 参数，Julia类型应该为&lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt; &lt;code&gt;Cwstring&lt;/code&gt; &lt;/a&gt;（如果C例程期望以NUL终止的字符串）或否则为 &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; 。还请注意，Julia中的UTF-8字符串数据在内部是NUL终止的，因此可以将其传递给期望NUL终止的数据的C函数，而无需进行复制（但是，如果字符串本身使用 &lt;code&gt;Cwstring&lt;/code&gt; 类型，则将引发错误）包含NUL个字符）。</target>
        </trans-unit>
        <trans-unit id="757bf33c899d624608fa2ee3a0b47130199f6860" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;wchar_t*&lt;/code&gt; arguments, the Julia type should be &lt;a href=&quot;../../base/c/index#Base.Cwstring&quot;&gt;&lt;code&gt;Cwstring&lt;/code&gt;&lt;/a&gt; (if the C routine expects a NUL-terminated string), or &lt;code&gt;Ptr{Cwchar_t}&lt;/code&gt; otherwise. Note also that UTF-8 string data in Julia is internally NUL-terminated, so it can be passed to C functions expecting NUL-terminated data without making a copy (but using the &lt;code&gt;Cwstring&lt;/code&gt; type will cause an error to be thrown if the string itself contains NUL characters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8d4350a3633a902604161c6b5b29254014e76bb" translate="yes" xml:space="preserve">
          <source>For &lt;em&gt;every&lt;/em&gt; binary operation like &lt;code&gt;^&lt;/code&gt;, there is a corresponding &quot;dot&quot; operation &lt;code&gt;.^&lt;/code&gt; that is &lt;em&gt;automatically&lt;/em&gt; defined to perform &lt;code&gt;^&lt;/code&gt; element-by-element on arrays. For example, &lt;code&gt;[1,2,3] ^ 3&lt;/code&gt; is not defined, since there is no standard mathematical meaning to &quot;cubing&quot; a (non-square) array, but &lt;code&gt;[1,2,3] .^ 3&lt;/code&gt; is defined as computing the elementwise (or &quot;vectorized&quot;) result &lt;code&gt;[1^3, 2^3, 3^3]&lt;/code&gt;. Similarly for unary operators like &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;&amp;radic;&lt;/code&gt;, there is a corresponding &lt;code&gt;.&amp;radic;&lt;/code&gt; that applies the operator elementwise.</source>
          <target state="translated">对于&lt;em&gt;每一个&lt;/em&gt;象二进制运算 &lt;code&gt;^&lt;/code&gt; ，有一个相应的&amp;ldquo;点&amp;rdquo;的操作 &lt;code&gt;.^&lt;/code&gt; 是&lt;em&gt;自动&lt;/em&gt;定义来执行 &lt;code&gt;^&lt;/code&gt; 元件逐元件阵列上。例如，未定义 &lt;code&gt;[1,2,3] ^ 3&lt;/code&gt; ，因为不存在&amp;ldquo;立方&amp;rdquo;数组的标准数学含义，但是 &lt;code&gt;[1,2,3] .^ 3&lt;/code&gt; 被定义为计算按元素（或&amp;ldquo;向量化&amp;rdquo;）结果 &lt;code&gt;[1^3, 2^3, 3^3]&lt;/code&gt; 。对于一元运算符也一样 &lt;code&gt;!&lt;/code&gt; 或 &lt;code&gt;&amp;radic;&lt;/code&gt; ，存在一个对应的 &lt;code&gt;.&amp;radic;&lt;/code&gt; ，它会逐级应用运算符。</target>
        </trans-unit>
        <trans-unit id="33b12b0497bd71670a617ce62626d84d142b3953" translate="yes" xml:space="preserve">
          <source>For Adjoint/Transpose-wrapped vectors, return the operator $q$-norm of &lt;code&gt;A&lt;/code&gt;, which is equivalent to the &lt;code&gt;p&lt;/code&gt;-norm with value &lt;code&gt;p = q/(q-1)&lt;/code&gt;. They coincide at &lt;code&gt;p = q = 2&lt;/code&gt;. Use &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt; to compute the &lt;code&gt;p&lt;/code&gt; norm of &lt;code&gt;A&lt;/code&gt; as a vector.</source>
          <target state="translated">对于伴随/移调包裹载体，返回操作$ Q $的范数 &lt;code&gt;A&lt;/code&gt; ，这是相当于 &lt;code&gt;p&lt;/code&gt; 具有值范数 &lt;code&gt;p = q/(q-1)&lt;/code&gt; 。它们在 &lt;code&gt;p = q = 2&lt;/code&gt; 重合。使用&lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt;数将 &lt;code&gt;A&lt;/code&gt; 的 &lt;code&gt;p&lt;/code&gt; 范数计算为向量。</target>
        </trans-unit>
        <trans-unit id="7cce7fbd5f6d7a391c27939f48d9689b1cad7e94" translate="yes" xml:space="preserve">
          <source>For All</source>
          <target state="translated">全部</target>
        </trans-unit>
        <trans-unit id="34ab36290f41b0fe509819193b0860af6e374811" translate="yes" xml:space="preserve">
          <source>For Fortran functions taking variable length strings of type &lt;code&gt;character(len=*)&lt;/code&gt; the string lengths are provided as &lt;em&gt;hidden arguments&lt;/em&gt;. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using &lt;code&gt;Csize_t&lt;/code&gt; as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others &lt;em&gt;optionally&lt;/em&gt; permit placing hidden arguments directly after the character argument (Intel, PGI). For example, Fortran subroutines of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4c87ed1d5890c7a24dd4de829654130f87033e" translate="yes" xml:space="preserve">
          <source>For Fortran functions taking variable length strings of type &lt;code&gt;character(len=*)&lt;/code&gt; the string lengths are provided as &lt;em&gt;hidden arguments&lt;/em&gt;. Type and position of these arguments in the list are compiler specific, where compiler vendors usually default to using &lt;code&gt;Csize_t&lt;/code&gt; as type and append the hidden arguments at the end of the argument list. While this behaviour is fixed for some compilers (GNU), others &lt;em&gt;optionally&lt;/em&gt; permit placing hidden arguments directly after the character argument (Intel,PGI). For example, Fortran subroutines of the form</source>
          <target state="translated">对于采用字符类型为 &lt;code&gt;character(len=*)&lt;/code&gt; 的可变长度字符串的Fortran函数，字符串长度作为&lt;em&gt;隐藏参数&lt;/em&gt;提供。这些参数在列表中的类型和位置是特定于编译器的，其中，编译器供应商通常默认使用 &lt;code&gt;Csize_t&lt;/code&gt; 作为类型，并将隐藏的参数附加在参数列表的末尾。尽管某些编译器（GNU）修复了此问题，但其他编译器&lt;em&gt;可以选择&lt;/em&gt;将隐藏的参数直接放在字符参数（Intel，PGI）之后。例如，形式为Fortran的子例程</target>
        </trans-unit>
        <trans-unit id="d553b36129c90b85dcd46c9add276340b10d3409" translate="yes" xml:space="preserve">
          <source>For Loops and Comprehensions</source>
          <target state="translated">对于循环和理解</target>
        </trans-unit>
        <trans-unit id="717c84af107ffef8e4706cbbe50e715cf976c386" translate="yes" xml:space="preserve">
          <source>For Windows users, Julia's shell mode does not expose windows shell commands. Hence, this will fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f78eccb3fe706727ad782465619222ec9fd8a5" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;String&lt;/code&gt;, note that the result is specific to the UTF-8 encoding (a different checksum would be obtained from a different Unicode encoding). To checksum an &lt;code&gt;a::Array&lt;/code&gt; of some other bitstype, you can do &lt;code&gt;crc32c(reinterpret(UInt8,a))&lt;/code&gt;, but note that the result may be endian-dependent.</source>
          <target state="translated">对于 &lt;code&gt;String&lt;/code&gt; ，请注意结果特定于UTF-8编码（将从不同的Unicode编码获得不同的校验和）。要校验其他位类型的 &lt;code&gt;a::Array&lt;/code&gt; ，可以执行 &lt;code&gt;crc32c(reinterpret(UInt8,a))&lt;/code&gt; ，但请注意，结果可能与字节序有关。</target>
        </trans-unit>
        <trans-unit id="fdbd68155fa3d6b046d9d04578affc99d85e662a" translate="yes" xml:space="preserve">
          <source>For a brief but lucid presentation of how floating-point numbers are represented, see John D. Cook's &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/&quot;&gt;article&lt;/a&gt; on the subject as well as his &lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/&quot;&gt;introduction&lt;/a&gt; to some of the issues arising from how this representation differs in behavior from the idealized abstraction of real numbers.</source>
          <target state="translated">有关浮点数表示方式的简要但清晰的说明，请参阅John D. Cook的&lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/anatomy-of-a-floating-point-number/&quot;&gt;文章&lt;/a&gt;，以及对由于这种表示方式与理想的实数抽象方式不同而引起的一些问题的&lt;a href=&quot;https://www.johndcook.com/blog/2009/04/06/numbers-are-a-leaky-abstraction/&quot;&gt;介绍&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="26d026061b818471461b6e11cb1c3175bde48284" translate="yes" xml:space="preserve">
          <source>For a complete example, let's say you have created a type, &lt;code&gt;ArrayAndChar&lt;/code&gt;, that stores an array and a single character:</source>
          <target state="translated">对于一个完整的示例，假设您创建了一个类型 &lt;code&gt;ArrayAndChar&lt;/code&gt; ，该类型存储一个数组和一个字符：</target>
        </trans-unit>
        <trans-unit id="125644f126fbc4277c5149f11a90f626bb48ac54" translate="yes" xml:space="preserve">
          <source>For a complete list of &lt;em&gt;every&lt;/em&gt; Julia operator's precedence, see the top of this file: &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm&quot;&gt;&lt;code&gt;src/julia-parser.scm&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">有关&lt;em&gt;每个&lt;/em&gt; Julia运算符优先级的完整列表，请参见此文件的顶部：&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm&quot;&gt; &lt;code&gt;src/julia-parser.scm&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f4d0c1cef2d73378f1ab6ea21dcd2e3aa81e9b0" translate="yes" xml:space="preserve">
          <source>For a given period, return the value associated with that period. For example, &lt;code&gt;value(Millisecond(10))&lt;/code&gt; returns 10 as an integer.</source>
          <target state="translated">对于给定的时间段，返回与该时间段关联的值。例如， &lt;code&gt;value(Millisecond(10))&lt;/code&gt; 返回10作为整数。</target>
        </trans-unit>
        <trans-unit id="f1ded20e8e0575e0300cc2adc5a53b33da3694f1" translate="yes" xml:space="preserve">
          <source>For a more general way to make all such calls work sensibly, see &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt;. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general &lt;code&gt;Point&lt;/code&gt; constructor work as one would expect:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ab5fbb77be1d46e4a2df54b426186afb121ac6" translate="yes" xml:space="preserve">
          <source>For a more general way to make all such calls work sensibly, see &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;. At the risk of spoiling the suspense, we can reveal here that all it takes is the following outer method definition to make all calls to the general &lt;code&gt;Point&lt;/code&gt; constructor work as one would expect:</source>
          <target state="translated">有关使所有此类调用合理运行的更一般的方法，请参见&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;转化和升级&lt;/a&gt;。冒着破坏悬念的危险，我们可以在这里揭示所有需要做的就是下面的外部方法定义，以使对通用 &lt;code&gt;Point&lt;/code&gt; 构造函数的所有调用按预期进行：</target>
        </trans-unit>
        <trans-unit id="ed852a3125d50800bb13a676272e7f42d0c371f3" translate="yes" xml:space="preserve">
          <source>For a more specific example, a generic square-matrix multiply pseudo-code might look like:</source>
          <target state="translated">对于一个更具体的例子,一个通用的平方矩阵乘法伪代码可能是这样的。</target>
        </trans-unit>
        <trans-unit id="8b96550022e1c9fcddbfb08ee86d23ebf98de982" translate="yes" xml:space="preserve">
          <source>For a scalar input, &lt;code&gt;eigvals&lt;/code&gt; will return a scalar.</source>
          <target state="translated">对于标量输入， &lt;code&gt;eigvals&lt;/code&gt; 将返回标量。</target>
        </trans-unit>
        <trans-unit id="6e10df5562967eabafd887233bdf313820cd17e4" translate="yes" xml:space="preserve">
          <source>For addition details see the LibGit2 guide on &lt;a href=&quot;https://libgit2.org/docs/guides/authentication/&quot;&gt;authenticating against a server&lt;/a&gt;.</source>
          <target state="translated">有关其他详细信息，请参阅LibGit2指南，以&lt;a href=&quot;https://libgit2.org/docs/guides/authentication/&quot;&gt;针对服务器&lt;/a&gt;进行身份验证。</target>
        </trans-unit>
        <trans-unit id="0f08193acb8e4821221019bdf43b59fe564f1010" translate="yes" xml:space="preserve">
          <source>For additional (algorithmic) information, and for versions of these methods that forgo argument checking, see (unexported) parent methods &lt;code&gt;unchecked_noalias_permute!&lt;/code&gt; and &lt;code&gt;unchecked_aliasing_permute!&lt;/code&gt;.</source>
          <target state="translated">有关其他（算法）信息，以及有关放弃参数检查的这些方法的版本，请参见（未导出）父方法 &lt;code&gt;unchecked_noalias_permute!&lt;/code&gt; 和 &lt;code&gt;unchecked_aliasing_permute!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="42ec6c27994a098a5b5c8be91c0dfca1418b0092" translate="yes" xml:space="preserve">
          <source>For additional documentation and an expert driver, see &lt;code&gt;SparseArrays.sparse!&lt;/code&gt;.</source>
          <target state="translated">有关其他文档和专家驱动程序，请参见 &lt;code&gt;SparseArrays.sparse!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2966c479e2a97d05120d634abb3c3b4fa57bcb14" translate="yes" xml:space="preserve">
          <source>For all practical purposes, such objects behave identically to those of &lt;code&gt;MyStillAmbiguousType&lt;/code&gt;.</source>
          <target state="translated">出于所有实际目的，此类对象的行为与 &lt;code&gt;MyStillAmbiguousType&lt;/code&gt; 的行为相同。</target>
        </trans-unit>
        <trans-unit id="2586b120b44665025a1f73d79469ce79bd89f3e9" translate="yes" xml:space="preserve">
          <source>For allowed arguments, see &lt;a href=&quot;#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关允许的参数，请参见&lt;a href=&quot;#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f1cb1d8b0a6fd3f459dd21aee4330db5fb020cbc" translate="yes" xml:space="preserve">
          <source>For an M-by-N matrix &lt;code&gt;A&lt;/code&gt; and P-by-N matrix &lt;code&gt;B&lt;/code&gt;,</source>
          <target state="translated">对于M&amp;times;N矩阵 &lt;code&gt;A&lt;/code&gt; 和P&amp;times;N矩阵 &lt;code&gt;B&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="c4a55d03c0f3c7fb4fb277a66cb30932f6ca5fde" translate="yes" xml:space="preserve">
          <source>For an array input, return the indices of the maximum elements over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">对于数组输入，返回给定维度上最大元素的索引。 &lt;code&gt;NaN&lt;/code&gt; 被视为大于所有其他值。</target>
        </trans-unit>
        <trans-unit id="f86a7fc66f2b2ba3bac55fe34c24f68f4fabc8c5" translate="yes" xml:space="preserve">
          <source>For an array input, return the indices of the minimum elements over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">对于数组输入，返回给定维度上最小元素的索引。 &lt;code&gt;NaN&lt;/code&gt; 被视为小于所有其他值。</target>
        </trans-unit>
        <trans-unit id="29ced7bd7c80c9a4577211e81fdcb7b16c085cf0" translate="yes" xml:space="preserve">
          <source>For an array input, returns the value and index of the maximum over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as greater than all other values.</source>
          <target state="translated">对于数组输入，返回给定维度上的最大值的值和索引。 &lt;code&gt;NaN&lt;/code&gt; 被视为大于所有其他值。</target>
        </trans-unit>
        <trans-unit id="049c1d61ced18d9f201600808d1def1f22e2bc2b" translate="yes" xml:space="preserve">
          <source>For an array input, returns the value and index of the minimum over the given dimensions. &lt;code&gt;NaN&lt;/code&gt; is treated as less than all other values.</source>
          <target state="translated">对于数组输入，返回给定维度上最小值的值和索引。 &lt;code&gt;NaN&lt;/code&gt; 被视为小于所有其他值。</target>
        </trans-unit>
        <trans-unit id="af04ee9a31664b38b875e97d7dedcb572df90336" translate="yes" xml:space="preserve">
          <source>For an excellent, in-depth discussion of floating-point numbers and issues of numerical accuracy encountered when computing with them, see David Goldberg's paper &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;What Every Computer Scientist Should Know About Floating-Point Arithmetic&lt;/a&gt;.</source>
          <target state="translated">要对浮点数和使用它们进行计算时遇到的数值精度问题进行深入，深入的讨论，请参阅David Goldberg的论文&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.6768&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;《每个计算机科学家应了解的浮点算术》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2b2edf4da8334ec709f88df3d9c11c7bf6cf6a32" translate="yes" xml:space="preserve">
          <source>For an in-place version and algorithmic information, see &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关就地版本和算法信息，请参见&lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="231340498dbc5d7093c855f539374b7859ea6f87" translate="yes" xml:space="preserve">
          <source>For an iterator or collection that has keys and values (e.g. arrays and dictionaries), return an iterator over the keys.</source>
          <target state="translated">对于一个有键和值的迭代器或集合(例如数组和字典),返回一个键的迭代器。</target>
        </trans-unit>
        <trans-unit id="9cf1660ad8de659f871c4cde9fc066e87eb4f30f" translate="yes" xml:space="preserve">
          <source>For an iterator or collection that has keys and values, return an iterator over the values. This function simply returns its argument by default, since the elements of a general iterator are normally considered its &quot;values&quot;.</source>
          <target state="translated">对于一个有键和值的迭代器或集合,返回一个关于值的迭代器。这个函数只是默认返回它的参数,因为一般迭代器的元素通常被认为是它的 &quot;值&quot;。</target>
        </trans-unit>
        <trans-unit id="f5a23131be87d6b23ab4381b2afccc7a7294e103" translate="yes" xml:space="preserve">
          <source>For an ordered container &lt;code&gt;collection&lt;/code&gt;, add the elements of &lt;code&gt;collection2&lt;/code&gt; to the end of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a50cf1c996d77537f503b2b0ab2ae143d3ab0c" translate="yes" xml:space="preserve">
          <source>For an out-of-place version, see &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;. For algorithmic information, see &lt;code&gt;fkeep!&lt;/code&gt;.</source>
          <target state="translated">有关非常&lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; &lt;/a&gt;版本，请参见dropzeros。有关算法的信息，请参见 &lt;code&gt;fkeep!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9698467f9f9a26107005e5cc7d8c52ec73e6fba" translate="yes" xml:space="preserve">
          <source>For an overview of why functions like &lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt;&lt;code&gt;hypot&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt;&lt;code&gt;expm1&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; are necessary and useful, see John D. Cook's excellent pair of blog posts on the subject: &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;expm1, log1p, erfc&lt;/a&gt;, and &lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot&lt;/a&gt;.</source>
          <target state="translated">对于为什么像功能的概述&lt;a href=&quot;../../base/math/index#Base.Math.hypot&quot;&gt; &lt;code&gt;hypot&lt;/code&gt; 将&lt;/a&gt;，&lt;a href=&quot;../../base/math/index#Base.expm1&quot;&gt; &lt;code&gt;expm1&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/math/index#Base.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt;是必要和有益的，看到关于这个问题的约翰&amp;middot;库克的出色对博客文章：&lt;a href=&quot;https://www.johndcook.com/blog/2010/06/07/math-library-functions-that-seem-unnecessary/&quot;&gt;的expm1，log1p，ERFC&lt;/a&gt;和&lt;a href=&quot;https://www.johndcook.com/blog/2010/06/02/whats-so-hard-about-finding-a-hypotenuse/&quot;&gt;hypot将&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d80c08b4c206c014a1c8f4dd0759aa7c625fa2a" translate="yes" xml:space="preserve">
          <source>For any iterable container &lt;code&gt;A&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;norm&lt;/code&gt; is defined), compute the &lt;code&gt;p&lt;/code&gt;-norm (defaulting to &lt;code&gt;p=2&lt;/code&gt;) as if &lt;code&gt;A&lt;/code&gt; were a vector of the corresponding length.</source>
          <target state="translated">对于数字（或定义了 &lt;code&gt;norm&lt;/code&gt; 任何元素类型）的任何可迭代容器 &lt;code&gt;A&lt;/code&gt; （包括任何维度的数组），计算 &lt;code&gt;p&lt;/code&gt; -范数（默认为 &lt;code&gt;p=2&lt;/code&gt; ），就好像 &lt;code&gt;A&lt;/code&gt; 是相应长度的向量。</target>
        </trans-unit>
        <trans-unit id="a3a03065c6c3f77db333198b92d9783df8912cc7" translate="yes" xml:space="preserve">
          <source>For any iterable containers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; (including arrays of any dimension) of numbers (or any element type for which &lt;code&gt;dot&lt;/code&gt; is defined), compute the dot product (or inner product or scalar product), i.e. the sum of &lt;code&gt;dot(x[i],y[i])&lt;/code&gt;, as if they were vectors.</source>
          <target state="translated">对于任何可迭代容器 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; （包括任何尺寸的阵列）的数字（或用于其任何元件类型 &lt;code&gt;dot&lt;/code&gt; 被定义），计算点积（或内积或标量积），即总和 &lt;code&gt;dot(x[i],y[i])&lt;/code&gt; ，就好像它们是向量一样。</target>
        </trans-unit>
        <trans-unit id="9861c33db5cb32a638bd7ed95113f331a3454eb4" translate="yes" xml:space="preserve">
          <source>For any keywords that are not specified, the current settings from &lt;code&gt;cmd&lt;/code&gt; are used. Normally, to create a &lt;code&gt;Cmd&lt;/code&gt; object in the first place, one uses backticks, e.g.</source>
          <target state="translated">对于未指定的任何关键字，将使用 &lt;code&gt;cmd&lt;/code&gt; 中的当前设置。通常，首先要创建一个 &lt;code&gt;Cmd&lt;/code&gt; 对象，使用反引号，例如</target>
        </trans-unit>
        <trans-unit id="85d14ad6a0f26364153773489f0db13bfaafa53f" translate="yes" xml:space="preserve">
          <source>For arrays with conventional indexing (indices start at 1), or any multidimensional array, linear indices range from 1 to &lt;code&gt;length(A)&lt;/code&gt;. However, for &lt;code&gt;AbstractVector&lt;/code&gt;s linear indices are &lt;code&gt;axes(A, 1)&lt;/code&gt;, and therefore do not start at 1 for vectors with unconventional indexing.</source>
          <target state="translated">对于具有常规索引（索引从1开始）的数组或任何多维数组，线性索引的范围是1到 &lt;code&gt;length(A)&lt;/code&gt; 。但是，对于 &lt;code&gt;AbstractVector&lt;/code&gt; ,线性索引是 &lt;code&gt;axes(A, 1)&lt;/code&gt; ，因此对于具有非常规索引的向量，线性索引不从1开始。</target>
        </trans-unit>
        <trans-unit id="81f6c2e801b1d9455cd3aa8ac3e88e840497dca8" translate="yes" xml:space="preserve">
          <source>For arrays, returns a string of size and type info, e.g. &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt;.</source>
          <target state="translated">对于数组，返回大小和类型为info的字符串，例如 &lt;code&gt;10-element Array{Int64,1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="06562c8550b5e93a013f75fd29118d4c0694a02a" translate="yes" xml:space="preserve">
          <source>For arrays, this function requires at least Julia 1.2.</source>
          <target state="translated">对于数组,这个函数至少需要Julia 1.2。</target>
        </trans-unit>
        <trans-unit id="d3e36f74f84aea73dce8e8117a1733e018408eb9" translate="yes" xml:space="preserve">
          <source>For bits types this means that the bit pattern of a value once set will never change and that value is the identity of a bits type.</source>
          <target state="translated">对于比特类型来说,这意味着一个值的位模式一旦被设置就永远不会改变,这个值就是比特类型的标识。</target>
        </trans-unit>
        <trans-unit id="7aee08c8ffda1f859a18b6cbf5bd4f3be6da6c3e" translate="yes" xml:space="preserve">
          <source>For cartesian to linear index conversion, see &lt;a href=&quot;#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于笛卡尔到线性索引的转换，请参见&lt;a href=&quot;#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c8b30defdf847f67d42803fa30f31344e75b07b3" translate="yes" xml:space="preserve">
          <source>For code points less than &lt;code&gt;\u80&lt;/code&gt;, it happens that the UTF-8 encoding of each code point is just the single byte produced by the corresponding &lt;code&gt;\x&lt;/code&gt; escape, so the distinction can safely be ignored. For the escapes &lt;code&gt;\x80&lt;/code&gt; through &lt;code&gt;\xff&lt;/code&gt; as compared to &lt;code&gt;\u80&lt;/code&gt; through &lt;code&gt;\uff&lt;/code&gt;, however, there is a major difference: the former escapes all encode single bytes, which &amp;ndash; unless followed by very specific continuation bytes &amp;ndash; do not form valid UTF-8 data, whereas the latter escapes all represent Unicode code points with two-byte encodings.</source>
          <target state="translated">对于小于 &lt;code&gt;\u80&lt;/code&gt; 代码点，碰巧每个代码点的UTF-8编码只是由相应的 &lt;code&gt;\x&lt;/code&gt; 转义产生的单个字节，因此可以安全地忽略此区别。对于 &lt;code&gt;\x80&lt;/code&gt; 到 &lt;code&gt;\xff&lt;/code&gt; 的转义，与 &lt;code&gt;\u80&lt;/code&gt; 到 &lt;code&gt;\uff&lt;/code&gt; 的转义相比，有一个主要的区别：前者对所有编码的单个字节进行转义，除非其后接非常具体的连续字节，否则不会形成有效的UTF-8数据，而后者转义了所有表示具有两字节编码的Unicode代码点。</target>
        </trans-unit>
        <trans-unit id="7990f7d8e420dec5f948426ee0deb5045c50fdaa" translate="yes" xml:space="preserve">
          <source>For composite types, this means that the identity of the values of its fields will never change. When the fields are bits types, that means their bits will never change, for fields whose values are mutable types like arrays, that means the fields will always refer to the same mutable value even though that mutable value's content may itself be modified.</source>
          <target state="translated">对于复合类型,这意味着其字段的值的身份永远不会改变。当字段是位类型时,这意味着它们的位永远不会改变,对于其值是像数组这样的可突变类型的字段,这意味着字段将始终引用同一个可突变值,即使该可突变值的内容本身可能被修改。</target>
        </trans-unit>
        <trans-unit id="03316709b23be1fe05fb3b1026fde6353f45ac08" translate="yes" xml:space="preserve">
          <source>For consistency across Julia, the call site should always pass a &lt;code&gt;Val&lt;/code&gt;&lt;em&gt;instance&lt;/em&gt; rather than using a &lt;em&gt;type&lt;/em&gt;, i.e., use &lt;code&gt;foo(Val(:bar))&lt;/code&gt; rather than &lt;code&gt;foo(Val{:bar})&lt;/code&gt;.</source>
          <target state="translated">为了确保Julia的一致性，调用站点应始终传递 &lt;code&gt;Val&lt;/code&gt; &lt;em&gt;实例&lt;/em&gt;而不是使用&lt;em&gt;类型&lt;/em&gt;，即，使用 &lt;code&gt;foo(Val(:bar))&lt;/code&gt; 而不是 &lt;code&gt;foo(Val{:bar})&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3d9ce2fe390265769939ee6ced6c2028220d4701" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">为了方便起见， &lt;code&gt;p&lt;/code&gt; 可以是类型而不是值： &lt;code&gt;ceil(dt, Dates.Hour)&lt;/code&gt; 是 &lt;code&gt;ceil(dt, Dates.Hour(1))&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="89f749ab9e4eefe9228d7474faa98982038d612a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">为了方便起见， &lt;code&gt;p&lt;/code&gt; 可以是类型而不是值： &lt;code&gt;floor(dt, Dates.Hour)&lt;/code&gt; 是 &lt;code&gt;floor(dt, Dates.Hour(1))&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="ba5445c2e02b549b16ba3decf8b6cd4aeb77578a" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;p&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">为方便起见， &lt;code&gt;p&lt;/code&gt; 可以是类型而不是值： &lt;code&gt;round(dt, Dates.Hour)&lt;/code&gt; 是 &lt;code&gt;round(dt, Dates.Hour(1))&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="628a74984a13bf54fa3097a1ff489c44e499c284" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">为方便起见， &lt;code&gt;precision&lt;/code&gt; 可以是类型而不是值： &lt;code&gt;ceil(x, Dates.Hour)&lt;/code&gt; 是 &lt;code&gt;ceil(x, Dates.Hour(1))&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="43f856c7ece595cf56ae5fb16a5157cda0b0b39e" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">为了方便起见， &lt;code&gt;precision&lt;/code&gt; 可以是类型而不是值： &lt;code&gt;floor(x, Dates.Hour)&lt;/code&gt; 是 &lt;code&gt;floor(x, Dates.Hour(1))&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="752ad3a1bbf71154ca789079220fccfae5f42c78" translate="yes" xml:space="preserve">
          <source>For convenience, &lt;code&gt;precision&lt;/code&gt; may be a type instead of a value: &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; is a shortcut for &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt;.</source>
          <target state="translated">为方便起见， &lt;code&gt;precision&lt;/code&gt; 可以是类型而不是值： &lt;code&gt;round(x, Dates.Hour)&lt;/code&gt; 是 &lt;code&gt;round(x, Dates.Hour(1))&lt;/code&gt; 的快捷方式。</target>
        </trans-unit>
        <trans-unit id="f72febf4d9dbc862197cbb1a8b226080ce81a9b0" translate="yes" xml:space="preserve">
          <source>For custom matrix and vector types, it is recommended to implement 5-argument &lt;code&gt;mul!&lt;/code&gt; rather than implementing 3-argument &lt;code&gt;mul!&lt;/code&gt; directly if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="337e0be4946ed3262678abe0f2e935f04104f98b" translate="yes" xml:space="preserve">
          <source>For direct C++ interfacing, see the &lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt; package. For tools to create C++ bindings, see the &lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt; package.</source>
          <target state="translated">有关直接C ++接口的信息，请参见&lt;a href=&quot;https://github.com/Keno/Cxx.jl&quot;&gt;Cxx&lt;/a&gt;软件包。有关创建C ++绑定的工具，请参见&lt;a href=&quot;https://github.com/JuliaInterop/CxxWrap.jl&quot;&gt;CxxWrap&lt;/a&gt;程序包。</target>
        </trans-unit>
        <trans-unit id="1e618742c8a5d9129a1258dfbf5438a2e4a87773" translate="yes" xml:space="preserve">
          <source>For each pair &lt;code&gt;old=&amp;gt;new&lt;/code&gt; in &lt;code&gt;old_new&lt;/code&gt;, replace all occurrences of &lt;code&gt;old&lt;/code&gt; in collection &lt;code&gt;A&lt;/code&gt; by &lt;code&gt;new&lt;/code&gt;. Equality is determined using &lt;a href=&quot;../base/index#Base.isequal&quot;&gt;&lt;code&gt;isequal&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;count&lt;/code&gt; is specified, then replace at most &lt;code&gt;count&lt;/code&gt; occurrences in total. See also &lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt;&lt;code&gt;replace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于每一对 &lt;code&gt;old=&amp;gt;new&lt;/code&gt; 在 &lt;code&gt;old_new&lt;/code&gt; ，更换所有出现的 &lt;code&gt;old&lt;/code&gt; 中收集 &lt;code&gt;A&lt;/code&gt; 由 &lt;code&gt;new&lt;/code&gt; 。平等是使用&lt;a href=&quot;../base/index#Base.isequal&quot;&gt; &lt;code&gt;isequal&lt;/code&gt; &lt;/a&gt;确定的。如果指定了 &lt;code&gt;count&lt;/code&gt; ，则总共最多替换一次 &lt;code&gt;count&lt;/code&gt; 。另请参见&lt;a href=&quot;#Base.replace-Tuple%7BAny,Vararg%7BPair,N%7D%20where%20N%7D&quot;&gt; &lt;code&gt;replace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ffd384e9075d866940b3029eb6057da7ada0b04b" translate="yes" xml:space="preserve">
          <source>For ease of understanding, the examples throughout this chapter show full data structures for roots, graph and paths. However, Julia's package loading code does not explicitly create these. Instead, it lazily computes only as much of each structure as it needs to load a given package.</source>
          <target state="translated">为了便于理解,本章中的例子显示了根、图和路径的完整数据结构。然而,Julia的包加载代码并没有明确地创建这些结构。相反,它只在加载给定的包时,根据所需的数量,懒散地计算每个结构。</target>
        </trans-unit>
        <trans-unit id="04e18da25adbbde93578f1eb2fa5f41635ed03eb" translate="yes" xml:space="preserve">
          <source>For empty collections, providing &lt;code&gt;init&lt;/code&gt; will be necessary, except for some special cases (e.g. when &lt;code&gt;op&lt;/code&gt; is one of &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;) when Julia can determine the neutral element of &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">对于空的集合，提供 &lt;code&gt;init&lt;/code&gt; 将是必要的，除了一些特殊情况下（例如，当 &lt;code&gt;op&lt;/code&gt; 是中的一个 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;max&lt;/code&gt; ， &lt;code&gt;min&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; ， &lt;code&gt;|&lt;/code&gt; ）时朱莉娅可以确定的中性元素 &lt;code&gt;op&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4f7a1238b1ac319ac9db6a4c619c8de57eb47bad" translate="yes" xml:space="preserve">
          <source>For even more extensive documentation of the history of, rationale for, and issues with floating-point numbers, as well as discussion of many other topics in numerical computing, see the &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;collected writings&lt;/a&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;William Kahan&lt;/a&gt;, commonly known as the &quot;Father of Floating-Point&quot;. Of particular interest may be &lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;An Interview with the Old Man of Floating-Point&lt;/a&gt;.</source>
          <target state="translated">有关浮点数的历史，基本原理和问题的更详尽文档，以及有关数值计算中许多其他主题的讨论，请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/William_Kahan&quot;&gt;威廉&amp;middot;卡汉&lt;/a&gt;（William Kahan）的&lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/&quot;&gt;著作&lt;/a&gt;集，通常被称为&amp;ldquo;浮法之父&amp;rdquo;。点&amp;rdquo;。特别有趣的是&lt;a href=&quot;https://people.eecs.berkeley.edu/~wkahan/ieee754status/754story.html&quot;&gt;《浮点老人》的采访&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b77b25aae44912586606895a221d1e45b8c25f37" translate="yes" xml:space="preserve">
          <source>For every incoming logical connection with a worker, &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; must be called. This launches a new task that handles reading and writing of messages from/to the worker represented by the &lt;code&gt;IO&lt;/code&gt; objects.</source>
          <target state="translated">对于与工作程序的每个传入逻辑连接，必须调用 &lt;code&gt;Base.process_messages(rd::IO, wr::IO)()&lt;/code&gt; 。这将启动一个新任务，该任务处理与 &lt;code&gt;IO&lt;/code&gt; 对象代表的工作人员之间的消息读写。</target>
        </trans-unit>
        <trans-unit id="b85b3e1a00e44270cd850d12b0754ab94e579430" translate="yes" xml:space="preserve">
          <source>For every worker launched, the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt;&lt;code&gt;launch&lt;/code&gt;&lt;/a&gt; method must add a &lt;code&gt;WorkerConfig&lt;/code&gt; object (with appropriate fields initialized) to &lt;code&gt;launched&lt;/code&gt;</source>
          <target state="translated">对于每个启动的工作程序，&lt;a href=&quot;../../stdlib/distributed/index#Distributed.launch&quot;&gt; &lt;code&gt;launch&lt;/code&gt; &lt;/a&gt;方法必须添加一个 &lt;code&gt;WorkerConfig&lt;/code&gt; 对象（已初始化适当的字段）以 &lt;code&gt;launched&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17c1669fdd5a30442a1d111e532e0e0ca62fed47" translate="yes" xml:space="preserve">
          <source>For example in order to fix &lt;code&gt;findfirst&lt;/code&gt; example above one needs to have a separate copy of &lt;code&gt;rx&lt;/code&gt; variable for each thread:</source>
          <target state="translated">例如，为了修复上面的 &lt;code&gt;findfirst&lt;/code&gt; 示例，需要为每个线程单独复制 &lt;code&gt;rx&lt;/code&gt; 变量：</target>
        </trans-unit>
        <trans-unit id="08186eb20e073535d04d3ee1bc374db09694e868" translate="yes" xml:space="preserve">
          <source>For example in the following docstring a variable &lt;code&gt;a&lt;/code&gt; is defined and the expected result, as printed in a Julia REPL, appears afterwards:</source>
          <target state="translated">例如，在下面的文档字符串中，定义了一个变量 &lt;code&gt;a&lt;/code&gt; ，然后出现在Julia REPL中的预期结果：</target>
        </trans-unit>
        <trans-unit id="b50ac335cd803909aabb34c2ac8aa635fe70764b" translate="yes" xml:space="preserve">
          <source>For example you should write</source>
          <target state="translated">例如,你应该写</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="d30d6b6735d4ff4914afad9079e3d2da944acfc0" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; will evaluate &lt;code&gt;Sys.iswindows()&lt;/code&gt; and insert either &lt;code&gt;foo&lt;/code&gt; or &lt;code&gt;bar&lt;/code&gt; into the expression. This is useful in cases where a construct would be invalid on other platforms, such as a &lt;code&gt;ccall&lt;/code&gt; to a non-existent function. &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; and &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; are also valid syntax.</source>
          <target state="translated">例如， &lt;code&gt;@static Sys.iswindows() ? foo : bar&lt;/code&gt; 将评估 &lt;code&gt;Sys.iswindows()&lt;/code&gt; 并将 &lt;code&gt;foo&lt;/code&gt; 或 &lt;code&gt;bar&lt;/code&gt; 插入表达式中。这是在案件有用的构建将是无效的其他平台上，如 &lt;code&gt;ccall&lt;/code&gt; 到一个不存在的功能。 &lt;code&gt;@static if Sys.isapple() foo end&lt;/code&gt; 和 &lt;code&gt;@static foo &amp;lt;&amp;amp;&amp;amp;,||&amp;gt; bar&lt;/code&gt; 也是有效语法，则为@static。</target>
        </trans-unit>
        <trans-unit id="ebd8456aa0b38dfe42ed79277e4c1654dd3d60d1" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10 on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; 将返回对类型为 &lt;code&gt;Int&lt;/code&gt; 且在 &lt;code&gt;pid&lt;/code&gt; 上大小为10 的通道的引用。</target>
        </trans-unit>
        <trans-unit id="96ff3ffca8d84a68fdc5320415ea0dc59a9a8872" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt;, will return a reference to a channel of type &lt;code&gt;Int&lt;/code&gt; and size 10. The channel exists on worker &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">例如， &lt;code&gt;RemoteChannel(()-&amp;gt;Channel{Int}(10), pid)&lt;/code&gt; 将返回对类型为 &lt;code&gt;Int&lt;/code&gt; 且大小为10的通道的引用。该通道存在于worker &lt;code&gt;pid&lt;/code&gt; 上。</target>
        </trans-unit>
        <trans-unit id="4891a83f30d6618f43c5e0d97b64d34ca2b73c56" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; returns an uninitialized &lt;code&gt;Array{Int,2}&lt;/code&gt; since ranges are neither mutable nor support 2 dimensions:</source>
          <target state="translated">例如， &lt;code&gt;similar(1:10, 1, 4)&lt;/code&gt; 返回未初始化的 &lt;code&gt;Array{Int,2}&lt;/code&gt; 因为范围既不可变也不支持2维：</target>
        </trans-unit>
        <trans-unit id="9440a60be9ec094e973482fb911a180f54e935ef" translate="yes" xml:space="preserve">
          <source>For example, Beowulf clusters are supported via a custom cluster manager implemented in the package &lt;code&gt;ClusterManagers.jl&lt;/code&gt;.</source>
          <target state="translated">例如，通过在 &lt;code&gt;ClusterManagers.jl&lt;/code&gt; 包中实现的自定义群集管理器来支持Beowulf群集。</target>
        </trans-unit>
        <trans-unit id="c68e3216a6f7acab7967abd7cf08e2c4de403780" translate="yes" xml:space="preserve">
          <source>For example, NFKC corresponds to the options &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt;.</source>
          <target state="translated">例如，NFKC对应于以下选项： &lt;code&gt;compose=true, compat=true, stable=true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4599895ae8d119fa4cbac0f0c56af45c7eba0c70" translate="yes" xml:space="preserve">
          <source>For example, a Linux installation with a Julia executable located at &lt;code&gt;/bin/julia&lt;/code&gt;, a &lt;code&gt;DATAROOTDIR&lt;/code&gt; of &lt;code&gt;../share&lt;/code&gt;, and a &lt;code&gt;SYSCONFDIR&lt;/code&gt; of &lt;code&gt;../etc&lt;/code&gt; will have &lt;code&gt;JULIA_BINDIR&lt;/code&gt; set to &lt;code&gt;/bin&lt;/code&gt;, a source-file search path of</source>
          <target state="translated">例如，如果Linux安装中的Julia可执行文件位于 &lt;code&gt;/bin/julia&lt;/code&gt; ， &lt;code&gt;DATAROOTDIR&lt;/code&gt; 为 &lt;code&gt;../share&lt;/code&gt; ，而 &lt;code&gt;SYSCONFDIR&lt;/code&gt; 为 &lt;code&gt;../etc&lt;/code&gt; ,则 &lt;code&gt;JULIA_BINDIR&lt;/code&gt; 设置为 &lt;code&gt;/bin&lt;/code&gt; ，即源文件搜索路径</target>
        </trans-unit>
        <trans-unit id="cb227b31f00d820f5d9d05405c8ad07604ce912a" translate="yes" xml:space="preserve">
          <source>For example, a recursive factorial routine could be defined like this:</source>
          <target state="translated">例如,一个递归因子例程可以这样定义。</target>
        </trans-unit>
        <trans-unit id="a3ee27750c0b683e5c90895147928cfd59e22a42" translate="yes" xml:space="preserve">
          <source>For example, consider a function &lt;code&gt;plot&lt;/code&gt; that plots a line. This function might have many options, for controlling line style, width, color, and so on. If it accepts keyword arguments, a possible call might look like &lt;code&gt;plot(x, y, width=2)&lt;/code&gt;, where we have chosen to specify only line width. Notice that this serves two purposes. The call is easier to read, since we can label an argument with its meaning. It also becomes possible to pass any subset of a large number of arguments, in any order.</source>
          <target state="translated">例如，考虑绘制线的函数 &lt;code&gt;plot&lt;/code&gt; 。此功能可能有许多选项，用于控制线条样式，宽度，颜色等。如果它接受关键字参数，则可能的调用可能类似于 &lt;code&gt;plot(x, y, width=2)&lt;/code&gt; ，在这里我们选择仅指定线宽。请注意，这有两个目的。该调用更易于阅读，因为我们可以用其含义标记一个自变量。也可以按任何顺序传递大量参数的任何子集。</target>
        </trans-unit>
        <trans-unit id="02796f85acf393569f8f018e6f896c1698a7ba0c" translate="yes" xml:space="preserve">
          <source>For example, consider the following definitions of a function &lt;code&gt;addone&lt;/code&gt; that returns one plus its argument:</source>
          <target state="translated">例如，考虑返回一个加一个参数的函数 &lt;code&gt;addone&lt;/code&gt; 的以下定义：</target>
        </trans-unit>
        <trans-unit id="8379ff1b045b6b8381b0fc1dcbd698daf2ddf0cf" translate="yes" xml:space="preserve">
          <source>For example, here is how we can guarantee that an opened file is closed:</source>
          <target state="translated">例如,这里我们可以保证打开的文件被关闭。</target>
        </trans-unit>
        <trans-unit id="4559e10e5bdf85aaaa91ac7c4619e47af5636653" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;x&lt;/code&gt; is an array and &lt;code&gt;v = @view x[1:10]&lt;/code&gt;, then &lt;code&gt;v&lt;/code&gt; acts like a 10-element array, but its data is actually accessing the first 10 elements of &lt;code&gt;x&lt;/code&gt;. Writing to a view, e.g. &lt;code&gt;v[3] = 2&lt;/code&gt;, writes directly to the underlying array &lt;code&gt;x&lt;/code&gt; (in this case modifying &lt;code&gt;x[3]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49582067d66dec7b465ad077603d8140735bdbe0" translate="yes" xml:space="preserve">
          <source>For example, if you define a &lt;code&gt;MyImage&lt;/code&gt; type and know how to write it to a PNG file, you could define a function &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; to allow your images to be displayed on any PNG-capable &lt;code&gt;AbstractDisplay&lt;/code&gt; (such as IJulia). As usual, be sure to &lt;code&gt;import Base.show&lt;/code&gt; in order to add new methods to the built-in Julia function &lt;code&gt;show&lt;/code&gt;.</source>
          <target state="translated">例如，如果定义 &lt;code&gt;MyImage&lt;/code&gt; 类型并知道如何将其写入PNG文件，则可以定义函数 &lt;code&gt;show(io, ::MIME&quot;image/png&quot;, x::MyImage) = ...&lt;/code&gt; 以允许图像显示在任何支持PNG的 &lt;code&gt;AbstractDisplay&lt;/code&gt; （例如IJulia）上。与往常一样，请确保 &lt;code&gt;import Base.show&lt;/code&gt; 以便向内置的Julia函数 &lt;code&gt;show&lt;/code&gt; 添加新方法。</target>
        </trans-unit>
        <trans-unit id="2da1e2276f1c5c558883dab8cb5596d1bc2a1628" translate="yes" xml:space="preserve">
          <source>For example, say we define a type that stores a vector along with an accurate representation of its sum:</source>
          <target state="translated">例如,假设我们定义了一个类型,存储一个向量以及其总和的精确表示。</target>
        </trans-unit>
        <trans-unit id="e2cfd2a7e3ca6e4481d092c3fbc0442d5a4ab757" translate="yes" xml:space="preserve">
          <source>For example, suppose one wants to declare a type that holds a pair of real numbers, subject to the constraint that the first number is not greater than the second one. One could declare it like this:</source>
          <target state="translated">例如,假设我们想声明一个类型,它可以容纳一对实数,但约束条件是第一个数字不大于第二个数字。我们可以这样声明。</target>
        </trans-unit>
        <trans-unit id="79225a639e81658b4de8b5567b3dea63ac5abb4f" translate="yes" xml:space="preserve">
          <source>For example, suppose we want to check our new function &lt;code&gt;foo(x)&lt;/code&gt; works as expected:</source>
          <target state="translated">例如，假设我们要检查新函数 &lt;code&gt;foo(x)&lt;/code&gt; 是否按预期工作：</target>
        </trans-unit>
        <trans-unit id="7eda6e477d1dd1d46e2cafc4f54477c6b2bb0e6a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; functions can be composed like this:</source>
          <target state="translated">例如， &lt;code&gt;sqrt&lt;/code&gt; 和 &lt;code&gt;+&lt;/code&gt; 函数可以这样组成：</target>
        </trans-unit>
        <trans-unit id="5ae23a1c15837ee5f1ee5c9f54f1ec5adaf7300a" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;sqrt&lt;/code&gt; function throws a &lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt;&lt;code&gt;DomainError&lt;/code&gt;&lt;/a&gt; if applied to a negative real value:</source>
          <target state="translated">例如，如果将 &lt;code&gt;sqrt&lt;/code&gt; 函数应用到负实数值，则会抛出&lt;a href=&quot;../../base/base/index#Core.DomainError&quot;&gt; &lt;code&gt;DomainError&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="41fbcb24e42e9f837587084b7759fc106d92d27c" translate="yes" xml:space="preserve">
          <source>For example, the following code</source>
          <target state="translated">例如,以下代码</target>
        </trans-unit>
        <trans-unit id="df53f88b87089b5c188eb151fc2371ed97e5a8bd" translate="yes" xml:space="preserve">
          <source>For example, the following code will not work as intended:</source>
          <target state="translated">例如,以下代码将无法正常工作。</target>
        </trans-unit>
        <trans-unit id="dd2a7ac9bf39edcb33138e7083aee6d2163bed39" translate="yes" xml:space="preserve">
          <source>For example, the following definition supports the negation of ranges:</source>
          <target state="translated">例如,以下定义支持范围的否定。</target>
        </trans-unit>
        <trans-unit id="ebd9e6f4328ccf3da34436709427cc4b4eaab0c0" translate="yes" xml:space="preserve">
          <source>For example, the following regex has all three flags turned on:</source>
          <target state="translated">例如,下面的regex将三个标志都打开了。</target>
        </trans-unit>
        <trans-unit id="f984e5cb891417962d09962040b3dc32bb1ac27e" translate="yes" xml:space="preserve">
          <source>For example, the following would cause the &lt;code&gt;for&lt;/code&gt; loop to wait for more data:</source>
          <target state="translated">例如，以下内容将导致 &lt;code&gt;for&lt;/code&gt; 循环等待更多数据：</target>
        </trans-unit>
        <trans-unit id="eecf63c1cc24adb010e598c33c14402e51c960fb" translate="yes" xml:space="preserve">
          <source>For example, the tuple &lt;code&gt;(a=3.1, b=&quot;hello&quot;)&lt;/code&gt; has a type &lt;code&gt;NamedTuple{(:a, :b),Tuple{Float64,String}}&lt;/code&gt;, which can also be declared via &lt;code&gt;@NamedTuple&lt;/code&gt; as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ca40c2a3ba9787690378fb5f2aab689eee1052" translate="yes" xml:space="preserve">
          <source>For example, to read a simple byte array, we could do:</source>
          <target state="translated">例如,要读取一个简单的字节数组,我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="8878c21d4c3068d1cd94e841b14239269912a492" translate="yes" xml:space="preserve">
          <source>For example, trying to dispatch on the element-type of an array will often run into ambiguous situations. Instead, commonly code will dispatch first on the container type, then recurse down to a more specific method based on eltype. In most cases, the algorithms lend themselves conveniently to this hierarchical approach, while in other cases, this rigor must be resolved manually. This dispatching branching can be observed, for example, in the logic to sum two matrices:</source>
          <target state="translated">例如,试图在一个数组的元素类型上进行派发,往往会遇到模棱两可的情况,而通常代码会先在容器类型上进行派发,然后根据eltype进行递归。相反,通常代码会先在容器类型上进行调度,然后再根据eltype递归到一个更具体的方法。在大多数情况下,算法都能方便地采用这种分层方法,而在其他情况下,必须手动解决这种严格的问题。例如,在两个矩阵求和的逻辑中,可以观察到这种调度分支。</target>
        </trans-unit>
        <trans-unit id="b2c13e0b4d2254aa0c6b075c4f699f03e1e4085d" translate="yes" xml:space="preserve">
          <source>For example, two vectors &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; of the same length can be written as two columns of tab-delimited text to &lt;code&gt;f&lt;/code&gt; by either &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; or by &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt;.</source>
          <target state="translated">例如，可以通过 &lt;code&gt;writedlm(f, [x y])&lt;/code&gt; 或 &lt;code&gt;writedlm(f, zip(x, y))&lt;/code&gt; 将相同长度的两个向量 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 作为两列制表符分隔的文本写入 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="20b7a39286391fad09a5ff705ae3bda829227952" translate="yes" xml:space="preserve">
          <source>For example, when reading all of the output from a command, call &lt;code&gt;read(out, String)&lt;/code&gt;, not &lt;code&gt;wait(process)&lt;/code&gt;, since the former will actively consume all of the data written by the process, whereas the latter will attempt to store the data in the kernel's buffers while waiting for a reader to be connected.</source>
          <target state="translated">例如，在读取命令的所有输出时，请调用 &lt;code&gt;read(out, String)&lt;/code&gt; 而不是 &lt;code&gt;wait(process)&lt;/code&gt; ，因为前者将主动消耗该进程写入的所有数据，而后者将尝试存储该数据。等待读取器连接时，内核缓冲区中的数据。</target>
        </trans-unit>
        <trans-unit id="5029745bd6486130a24ba078811879e64132c558" translate="yes" xml:space="preserve">
          <source>For example, you can define a type that stores the coefficients of a polynomial, but behaves like a function evaluating the polynomial:</source>
          <target state="translated">例如,你可以定义一个存储多项式系数的类型,但其行为就像一个评估多项式的函数。</target>
        </trans-unit>
        <trans-unit id="67f058df3da112643c2b0a1dfa02199be4e0057b" translate="yes" xml:space="preserve">
          <source>For example, you might look up the function via &lt;code&gt;dlsym&lt;/code&gt;, then cache it in a shared reference for that session. For example:</source>
          <target state="translated">例如，您可以通过 &lt;code&gt;dlsym&lt;/code&gt; 查找该函数，然后将其缓存在该会话的共享引用中。例如：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="77957bacdf57512b4372bd5a4e3fd7ed75c7e36e" translate="yes" xml:space="preserve">
          <source>For expert drivers and additional information, see &lt;code&gt;permute!&lt;/code&gt;.</source>
          <target state="translated">有关专家驱动程序和其他信息，请参见 &lt;code&gt;permute!&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="023517bc66d9d3e180b498d61c21e401d08d2db9" translate="yes" xml:space="preserve">
          <source>For file dependencies, a change is determined by examining whether the modification time (mtime) of each file loaded by &lt;code&gt;include&lt;/code&gt; or added explicitly by &lt;code&gt;include_dependency&lt;/code&gt; is unchanged, or equal to the modification time truncated to the nearest second (to accommodate systems that can't copy mtime with sub-second accuracy). It also takes into account whether the path to the file chosen by the search logic in &lt;code&gt;require&lt;/code&gt; matches the path that had created the precompile file. It also takes into account the set of dependencies already loaded into the current process and won't recompile those modules, even if their files change or disappear, in order to avoid creating incompatibilities between the running system and the precompile cache.</source>
          <target state="translated">对于文件依赖性，通过检查是否由 &lt;code&gt;include&lt;/code&gt; 加载或由 &lt;code&gt;include_dependency&lt;/code&gt; 显式添加的每个文件的修改时间（mtime）保持不变，或等于截短到最接近的秒的修改时间（以适应不能以亚秒精度复制mtime）。它也考虑到是否路径由搜索逻辑选择在文件中 &lt;code&gt;require&lt;/code&gt; 的是创造了预编译文件的路径匹配。它还考虑了已经加载到当前进程中的一组依赖项，即使它们的文件更改或消失，它们也不会重新编译，以免在运行的系统和预编译缓存之间造成不兼容。</target>
        </trans-unit>
        <trans-unit id="66dd55e20f602bb211d9c7813d2f9f0ed6928fe9" translate="yes" xml:space="preserve">
          <source>For fixed-size integer types less than 128 bits, &lt;code&gt;widen&lt;/code&gt; will return a type with twice the number of bits.</source>
          <target state="translated">对于小于128位的固定大小的整数类型， &lt;code&gt;widen&lt;/code&gt; 将返回位数为两倍的类型。</target>
        </trans-unit>
        <trans-unit id="b4ff71b16e3ea299f0633e174809e0487289b907" translate="yes" xml:space="preserve">
          <source>For fun, try inserting a &lt;code&gt;println(&quot;mycompare($a, $b)&quot;)&lt;/code&gt; line into &lt;code&gt;mycompare&lt;/code&gt;, which will allow you to see the comparisons that &lt;code&gt;qsort&lt;/code&gt; is performing (and to verify that it is really calling the Julia function that you passed to it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517d5d95b2398e36f4828f9d104f02ccf187deee" translate="yes" xml:space="preserve">
          <source>For functions &lt;code&gt;f(x)&lt;/code&gt;, &lt;code&gt;f(x) = x&lt;/code&gt; defines a new function constant &lt;code&gt;f&lt;/code&gt;, or adds a new method to &lt;code&gt;f&lt;/code&gt; if &lt;code&gt;f&lt;/code&gt; is already defined; this usage is equivalent to &lt;code&gt;function f(x); x; end&lt;/code&gt;.</source>
          <target state="translated">对于函数 &lt;code&gt;f(x)&lt;/code&gt; ， &lt;code&gt;f(x) = x&lt;/code&gt; 定义了一种新函数恒定 &lt;code&gt;f&lt;/code&gt; ，或增加了一个新的方法 &lt;code&gt;f&lt;/code&gt; 如果 &lt;code&gt;f&lt;/code&gt; 已经定义; 这种用法等效于 &lt;code&gt;function f(x); x; end&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="225c4a50cda420749e1622d47819d81476ffb811" translate="yes" xml:space="preserve">
          <source>For functions that do not need to return a value (functions used only for some side effects), the Julia convention is to return the value &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6abe0e3a65b8ed9f51c340da311967dd300c9c" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw add&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参见LLVM的 &lt;code&gt;atomicrmw add&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="a0322dcf17161d23047710cc59f3f8e235c18a53" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw and&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参见LLVM的 &lt;code&gt;atomicrmw and&lt;/code&gt; 说明。</target>
        </trans-unit>
        <trans-unit id="e5b561d9fc0067e467e9e9fcee46e3023283cf28" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw max&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参见LLVM的 &lt;code&gt;atomicrmw max&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="eab5683b8c3c9bc6117f8a69b4da87aa9632a8fb" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw min&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参见LLVM的 &lt;code&gt;atomicrmw min&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="7b7e08b7890af600321c511f13a806cd3559bcfa" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw nand&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参见LLVM的 &lt;code&gt;atomicrmw nand&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="7b8dd1c376a179e2ba56074f5563e776f17ef9ec" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw or&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参阅LLVM的 &lt;code&gt;atomicrmw or&lt;/code&gt; 说明。</target>
        </trans-unit>
        <trans-unit id="48c1004b7dffe90355657654366824768f35001b" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw sub&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参见LLVM的 &lt;code&gt;atomicrmw sub&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="192e95dde72a6e68d2db267b6ee138cf37555d73" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xchg&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参见LLVM的 &lt;code&gt;atomicrmw xchg&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="5e4b67df501ae8428fb22d5e33af878bfbea1ef9" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;atomicrmw xor&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参见LLVM的 &lt;code&gt;atomicrmw xor&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="7ee314d2ce6ee192109b08f74bbfd48cbb0e5cbc" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;cmpxchg&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参见LLVM的 &lt;code&gt;cmpxchg&lt;/code&gt; 指令。</target>
        </trans-unit>
        <trans-unit id="a7755edb4519e4536a6271c13a954434e48a3388" translate="yes" xml:space="preserve">
          <source>For further details, see LLVM's &lt;code&gt;fence&lt;/code&gt; instruction.</source>
          <target state="translated">有关更多详细信息，请参阅LLVM的 &lt;code&gt;fence&lt;/code&gt; 说明。</target>
        </trans-unit>
        <trans-unit id="25a5b4ba8ce7a92e22ffc818fd949e445709bd1e" translate="yes" xml:space="preserve">
          <source>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons&quot;&gt;Numeric Comparisons&lt;/a&gt;. By the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;, these floating-point values are the results of certain arithmetic operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592e1ef0cc917b2ef533393d9872f216dc5c373c" translate="yes" xml:space="preserve">
          <source>For further discussion of how these non-finite floating-point values are ordered with respect to each other and other floats, see &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;Numeric Comparisons&lt;/a&gt;. By the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;, these floating-point values are the results of certain arithmetic operations:</source>
          <target state="translated">有关这些非有限浮点值如何相对于彼此和其他浮点排序的进一步讨论，请参见&amp;ldquo; &lt;a href=&quot;../mathematical-operations/index#Numeric-Comparisons-1&quot;&gt;数值比较&amp;rdquo;&lt;/a&gt;。根据&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754标准&lt;/a&gt;，这些浮点值是某些算术运算的结果：</target>
        </trans-unit>
        <trans-unit id="f6a5e306e2388b19948e17b05f28ec9cf0f8d86c" translate="yes" xml:space="preserve">
          <source>For general non-symmetric matrices it is possible to specify how the matrix is balanced before the eigenvalue calculation. The &lt;code&gt;permute&lt;/code&gt;, &lt;code&gt;scale&lt;/code&gt;, and &lt;code&gt;sortby&lt;/code&gt; keywords are the same as for &lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt;&lt;code&gt;eigen!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于一般的非对称矩阵，可以在特征值计算之前指定矩阵的平衡方式。该 &lt;code&gt;permute&lt;/code&gt; ， &lt;code&gt;scale&lt;/code&gt; 和 &lt;code&gt;sortby&lt;/code&gt; 关键字是一样的&lt;a href=&quot;#LinearAlgebra.eigen!&quot;&gt; &lt;code&gt;eigen!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2a3464000c64f9602c239ac8ef54cb51f0375c94" translate="yes" xml:space="preserve">
          <source>For general nonsymmetric matrices it is possible to specify how the matrix is balanced before the eigenvector calculation. The option &lt;code&gt;permute=true&lt;/code&gt; permutes the matrix to become closer to upper triangular, and &lt;code&gt;scale=true&lt;/code&gt; scales the matrix by its diagonal elements to make rows and columns more equal in norm. The default is &lt;code&gt;true&lt;/code&gt; for both options.</source>
          <target state="translated">对于一般的非对称矩阵，可以在特征向量计算之前指定矩阵的平衡方式。选项 &lt;code&gt;permute=true&lt;/code&gt; 排列矩阵以使其更接近上三角，而 &lt;code&gt;scale=true&lt;/code&gt; 选项通过其对角线元素缩放矩阵，以使行和列的范数更均等。这两个选项的默认值为 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="97272f75bb7bf420f1c0e8253e48bdca2d0549a3" translate="yes" xml:space="preserve">
          <source>For general square matrices, &lt;code&gt;A = A*B&lt;/code&gt; cannot be implemented without temporary storage: &lt;code&gt;A[1,1]&lt;/code&gt; gets computed and stored on the left hand side before you're done using it on the right hand side.</source>
          <target state="translated">对于一般平方矩阵， &lt;code&gt;A = A*B&lt;/code&gt; 没有临时存储，则无法实现A = A * B：在完成在右侧使用 &lt;code&gt;A[1,1]&lt;/code&gt; 之前，先将A [1,1]计算并存储在左侧。</target>
        </trans-unit>
        <trans-unit id="935a8c2e4f251a5770a2bb608ecff08833dd9c32" translate="yes" xml:space="preserve">
          <source>For global variables, only the bindings are captured in a closure, not the data. &lt;code&gt;let&lt;/code&gt; blocks can be used to capture global data.</source>
          <target state="translated">对于全局变量，仅在闭包中捕获绑定，而不捕获数据。 &lt;code&gt;let&lt;/code&gt; 块可用于捕获全局数据。</target>
        </trans-unit>
        <trans-unit id="e5b2b73939c9dca143b01d277fa950512fdcf9e4" translate="yes" xml:space="preserve">
          <source>For implementing primitive operations, such as addition, we use the &lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt;&lt;code&gt;promote_type&lt;/code&gt;&lt;/a&gt; function to compute the desired output type. (As before, we saw this at work in the &lt;code&gt;promote&lt;/code&gt; call in the call to &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">为了实现原始操作（例如加法），我们使用&lt;a href=&quot;../../base/base/index#Base.promote_type&quot;&gt; &lt;code&gt;promote_type&lt;/code&gt; &lt;/a&gt;函数来计算所需的输出类型。（和以前一样，我们在对 &lt;code&gt;+&lt;/code&gt; 的调用中的 &lt;code&gt;promote&lt;/code&gt; 调用中看到了这一点）。</target>
        </trans-unit>
        <trans-unit id="9bbc05f37cbd2b5498a3ab3a593a156112a8c55d" translate="yes" xml:space="preserve">
          <source>For instance, consider this C routine that uses AVX intrinsics:</source>
          <target state="translated">例如,考虑这个使用AVX内在的C例程。</target>
        </trans-unit>
        <trans-unit id="58f3adf26ef93227d12186ad90763f386c1243e3" translate="yes" xml:space="preserve">
          <source>For inverting dense ill-conditioned matrices in a least-squares sense, &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; is recommended.</source>
          <target state="translated">为了在最小二乘意义上反转稠密的病态矩阵，建议使用 &lt;code&gt;rtol = sqrt(eps(real(float(one(eltype(M))))))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="034287249fc47e9292b9e290930968170dd861cb" translate="yes" xml:space="preserve">
          <source>For long docstrings, consider splitting the documentation with an &lt;code&gt;# Extended help&lt;/code&gt; header. The typical help-mode will show only the material above the header; you can access the full help by adding a '?' at the beginning of the expression (i.e., &quot;??foo&quot; rather than &quot;?foo&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3476b291492f6f31f8c69709d348f023db79ecb7" translate="yes" xml:space="preserve">
          <source>For many problems, it is not necessary to think about tasks directly. However, they can be used to wait for multiple events at the same time, which provides for &lt;em&gt;dynamic scheduling&lt;/em&gt;. In dynamic scheduling, a program decides what to compute or where to compute it based on when other jobs finish. This is needed for unpredictable or unbalanced workloads, where we want to assign more work to processes only when they finish their current tasks.</source>
          <target state="translated">对于许多问题，没有必要直接考虑任务。但是，它们可用于同时等待多个事件，从而提供了&lt;em&gt;动态调度&lt;/em&gt;。在动态调度中，程序根据其他作业的完成时间来决定要计算什么或在哪里计算。对于不可预测或不平衡的工作负载而言，这是必需的，在这种工作负载中，我们希望仅在流程完成当前任务时才为它们分配更多的工作。</target>
        </trans-unit>
        <trans-unit id="7f0ae2a2524af9d24fc01426df34e4e2c47f07b3" translate="yes" xml:space="preserve">
          <source>For many types, forming new objects by binding their field values together is all that is ever needed to create instances. However, in some cases more functionality is required when creating composite objects. Sometimes invariants must be enforced, either by checking arguments or by transforming them. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;Recursive data structures&lt;/a&gt;, especially those that may be self-referential, often cannot be constructed cleanly without first being created in an incomplete state and then altered programmatically to be made whole, as a separate step from object creation. Sometimes, it's just convenient to be able to construct objects with fewer or different types of parameters than they have fields. Julia's system for object construction addresses all of these cases and more.</source>
          <target state="translated">对于许多类型，创建实例只需通过将其字段值绑定在一起来形成新对象。但是，在某些情况下，创建复合对象时需要更多功能。有时必须通过检查参数或对其进行转换来强制执行不变量。&lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29#Recursive_data_structures_.28structural_recursion.29&quot;&gt;递归数据结构&lt;/a&gt;，尤其是那些可能是自引用的数据结构，通常必须先以不完整的状态创建，然后以编程方式更改为完整的结构，才能与对象创建分开的一个步骤来进行干净的构造。有时，能够使用比字段更多或更少的参数类型构造对象是很方便的。 Julia的对象构造系统可以解决所有这些情况，甚至更多。</target>
        </trans-unit>
        <trans-unit id="c3ab9fc4f4873966145fee9c6ac1a9124f310742" translate="yes" xml:space="preserve">
          <source>For matrices &lt;code&gt;M&lt;/code&gt; with floating point elements, it is convenient to compute the pseudoinverse by inverting only singular values greater than &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; where &lt;code&gt;&amp;sigma;₁&lt;/code&gt; is the largest singular value of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">对于具有浮点元素的矩阵 &lt;code&gt;M&lt;/code&gt; ，通过仅反转大于 &lt;code&gt;max(atol, rtol*&amp;sigma;₁)&lt;/code&gt; 的奇异值（其中 &lt;code&gt;&amp;sigma;₁&lt;/code&gt; 是 &lt;code&gt;M&lt;/code&gt; 的最大奇异值）来计算拟逆。</target>
        </trans-unit>
        <trans-unit id="ac6da235d612ded03083200d47fe1ab7d98c9b79" translate="yes" xml:space="preserve">
          <source>For more complex functions on matrices, it may be necessary to compute the expected return type for a more complex sequence of operations. This is often performed by the following steps:</source>
          <target state="translated">对于矩阵上更复杂的函数,可能需要计算更复杂的操作序列的预期返回类型。这通常通过以下步骤进行。</target>
        </trans-unit>
        <trans-unit id="4017330d0c6b8db2f9072cd10c06aafbef3ef320" translate="yes" xml:space="preserve">
          <source>For more details on how to pass callbacks to C libraries, see this &lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="translated">有关如何将回调传递到C库的更多详细信息，请参见此&lt;a href=&quot;https://julialang.org/blog/2013/05/callback&quot;&gt;博客文章&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="40c80b687e747654f0a96421e3edca10bc4facd7" translate="yes" xml:space="preserve">
          <source>For more details regarding code loading, see the manual sections on &lt;a href=&quot;../../manual/modules/index#modules&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../../manual/distributed-computing/index#code-availability&quot;&gt;parallel computing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e7422368e9880e43d73e7cf711179bdaf3a6a3" translate="yes" xml:space="preserve">
          <source>For more details regarding code loading, see the manual sections on &lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;modules&lt;/a&gt; and &lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;parallel computing&lt;/a&gt;.</source>
          <target state="translated">有关代码加载的更多详细信息，请参见有关&lt;a href=&quot;../../manual/modules/index#modules-1&quot;&gt;模块&lt;/a&gt;和&lt;a href=&quot;../../manual/parallel-computing/index#code-availability-1&quot;&gt;并行计算&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="5b74d22bb6d8c3dae54e22351d507e76018a8637" translate="yes" xml:space="preserve">
          <source>For more information about stylistic conventions, see the &lt;a href=&quot;../style-guide/index#Style-Guide&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825f5736599d7832ed10460cda99264a6faea4e6" translate="yes" xml:space="preserve">
          <source>For more information about stylistic conventions, see the &lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;Style Guide&lt;/a&gt;.</source>
          <target state="translated">有关样式约定的更多信息，请参见《&lt;a href=&quot;../style-guide/index#Style-Guide-1&quot;&gt;样式指南》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="29a5a734cc9600ff863c3e949c6ca0cd3d61e836" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM Language Reference&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参阅《&lt;a href=&quot;http://llvm.org/docs/LangRef.html#calling-conventions&quot;&gt;LLVM语言参考》&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e94367c7326944c925932ccd75ddf09b0dc2a2ca" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;#footnote-issue8859&quot;&gt;[issue8859]&lt;/a&gt;, &lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt;, &lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt;, &lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]&lt;/a&gt;.</source>
          <target state="translated">有关更多信息，请参见&lt;a href=&quot;#footnote-issue8859&quot;&gt;[issue8859]&lt;/a&gt;，&lt;a href=&quot;#footnote-B96&quot;&gt;[B96]&lt;/a&gt;，&lt;a href=&quot;#footnote-S84&quot;&gt;[S84]&lt;/a&gt;和&lt;a href=&quot;#footnote-KY88&quot;&gt;[KY88]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="1043bbca3d9cff9872a90536395e252c63759842" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;sup&gt;&lt;a href=&quot;#footnote-issue8859&quot; id=&quot;citeref-issue8859&quot;&gt;[issue8859]&lt;/a&gt;&lt;/sup&gt;, &lt;sup&gt;&lt;a href=&quot;#footnote-B96&quot; id=&quot;citeref-B96&quot;&gt;[B96]&lt;/a&gt;&lt;/sup&gt;, &lt;sup&gt;&lt;a href=&quot;#footnote-S84&quot; id=&quot;citeref-S84&quot;&gt;[S84]&lt;/a&gt;&lt;/sup&gt;, &lt;sup&gt;&lt;a href=&quot;#footnote-KY88&quot; id=&quot;citeref-KY88&quot;&gt;[KY88]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c9da6d7f9a8088ccb6c5228fbbc41a8fd90ece" translate="yes" xml:space="preserve">
          <source>For more serious benchmarking, consider the &lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt; package which among other things evaluates the function multiple times in order to reduce noise.</source>
          <target state="translated">对于更严格的基准测试，请考虑&lt;a href=&quot;https://github.com/JuliaCI/BenchmarkTools.jl&quot;&gt;BenchmarkTools.jl&lt;/a&gt;程序包，该程序包除其他功能外多次评估该功能，以减少噪声。</target>
        </trans-unit>
        <trans-unit id="7fb3b51ac0a69c0826f2ccf53c628c34678a1b75" translate="yes" xml:space="preserve">
          <source>For more serious benchmarking, consider the &lt;code&gt;@btime&lt;/code&gt; macro from the BenchmarkTools.jl package which among other things evaluates the function multiple times in order to reduce noise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88557b99f2da7edd1312dcf73383bf3fd839d0cf" translate="yes" xml:space="preserve">
          <source>For most user-defined types, it is better practice to require programmers to supply the expected types to constructor functions explicitly, but sometimes, especially for numeric problems, it can be convenient to do promotion automatically.</source>
          <target state="translated">对于大多数用户定义的类型,最好的做法是要求程序员显式地提供预期类型给构造函数,但有时,特别是对于数值问题,自动进行推广会很方便。</target>
        </trans-unit>
        <trans-unit id="ceb4f91d41747de4680e86cde1985bd3bfc38e4e" translate="yes" xml:space="preserve">
          <source>For multiple collection arguments, apply &lt;code&gt;f&lt;/code&gt; elementwise.</source>
          <target state="translated">对于多个集合参数，请逐个应用 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ea75a21c84d373ef04e66eb8c0a6a1bc5cc64258" translate="yes" xml:space="preserve">
          <source>For newcomers to multi-threading and parallel computing it can be useful to first appreciate the different levels of parallelism offered by Julia. We can divide them in three main categories :</source>
          <target state="translated">对于多线程和并行计算的新手来说,首先了解一下Julia提供的不同级别的并行性是很有用的。我们可以把它们分为三大类 。</target>
        </trans-unit>
        <trans-unit id="ac8a874fecbfe223b7adee365914ddd8f5f53622" translate="yes" xml:space="preserve">
          <source>For non-numeric values, and for fewer or more than two arguments, the function &lt;code&gt;f&lt;/code&gt; remains undefined, and applying it will still result in a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">对于非数字值以及少于或多于两个参数，函数 &lt;code&gt;f&lt;/code&gt; 仍未定义，应用该函数仍将导致&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="c60cf4f6c963a7be1f2993b69f713f92f6b5f1c8" translate="yes" xml:space="preserve">
          <source>For number types, &lt;code&gt;adjoint&lt;/code&gt; returns the complex conjugate, and therefore it is equivalent to the identity function for real numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="235d743e9d754b970eea4778b2f329bcad575d20" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$.</source>
          <target state="translated">对于数字,返回$\left(|x|^p \right)^{1/p}$。</target>
        </trans-unit>
        <trans-unit id="00b6eae180d5b268722ff406a9cc534055692e79" translate="yes" xml:space="preserve">
          <source>For numbers, return $\left( |x|^p \right)^{1/p}$. This is equivalent to &lt;a href=&quot;#LinearAlgebra.norm&quot;&gt;&lt;code&gt;norm&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于数字，返回$ \ left（| x | ^ p \ right）^ {1 / p} $。这等同于&lt;a href=&quot;#LinearAlgebra.norm&quot;&gt; &lt;code&gt;norm&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d4f585a8f761ded66238973d0a20da01f3603d93" translate="yes" xml:space="preserve">
          <source>For one argument, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (1, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi/2, \pi/2]$.</source>
          <target state="translated">对于一个参数，这是正&lt;em&gt;x&lt;/em&gt;轴与点（1，&lt;em&gt;y&lt;/em&gt;）之间的弧度角，返回区间$ [-\ pi / 2，\ pi / 2] $。</target>
        </trans-unit>
        <trans-unit id="cbe3a2c9ed0456d9a3ed109f08314c90a9a6e71e" translate="yes" xml:space="preserve">
          <source>For other types, &lt;code&gt;isequal&lt;/code&gt; defaults to calling &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt;, so if you want to define equality for your own types then you only need to add a &lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt;&lt;code&gt;==&lt;/code&gt;&lt;/a&gt; method. If you define your own equality function, you should probably define a corresponding &lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; method to ensure that &lt;code&gt;isequal(x,y)&lt;/code&gt; implies &lt;code&gt;hash(x) == hash(y)&lt;/code&gt;.</source>
          <target state="translated">对于其他类型， &lt;code&gt;isequal&lt;/code&gt; 默认调用&lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;，因此，如果要为自己的类型定义相等，则只需添加&lt;a href=&quot;../../base/math/index#Base.:==&quot;&gt; &lt;code&gt;==&lt;/code&gt; &lt;/a&gt;方法。如果定义自己的相等函数，则可能应该定义一个相应的&lt;a href=&quot;../../base/base/index#Base.hash&quot;&gt; &lt;code&gt;hash&lt;/code&gt; &lt;/a&gt;方法，以确保 &lt;code&gt;isequal(x,y)&lt;/code&gt; 意味着 &lt;code&gt;hash(x) == hash(y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2b291b40e0be0bd452d639b38ca79aedde9913f1" translate="yes" xml:space="preserve">
          <source>For outputting hours with 12-hour clock</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c2f4b9050307c80e2b4e5b109845a6af03029a8" translate="yes" xml:space="preserve">
          <source>For real or complex floating-point values, if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is not specified, &lt;code&gt;rtol&lt;/code&gt; defaults to the square root of &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt; of the type of &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt;, whichever is bigger (least precise). This corresponds to requiring equality of about half of the significand digits. Otherwise, e.g. for integer arguments or if an &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; is supplied, &lt;code&gt;rtol&lt;/code&gt; defaults to zero.</source>
          <target state="translated">对于实数或复数浮点值，如果未指定 &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; ，则 &lt;code&gt;rtol&lt;/code&gt; 默认为 &lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt; 类型的&lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;的平方根，以较大者为准（最不精确）。这相当于要求相等的有效位数为一半。否则，例如对于整数参数或如果提供了 &lt;code&gt;atol &amp;gt; 0&lt;/code&gt; ，则 &lt;code&gt;rtol&lt;/code&gt; 默认为零。</target>
        </trans-unit>
        <trans-unit id="9a1f18a5fd677ec7a031d2172a281c2590c59640" translate="yes" xml:space="preserve">
          <source>For real vectors &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt;, the Kronecker product is related to the outer product by &lt;code&gt;kron(v,w) == vec(w * transpose(v))&lt;/code&gt; or &lt;code&gt;w * transpose(v) == reshape(kron(v,w), (length(w), length(v)))&lt;/code&gt;. Note how the ordering of &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; differs on the left and right of these expressions (due to column-major storage). For complex vectors, the outer product &lt;code&gt;w * v'&lt;/code&gt; also differs by conjugation of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58b65ff0e6e435abbaf14887e067d0c31d3520b" translate="yes" xml:space="preserve">
          <source>For reasons of length the results are not shown here, but you may wish to try this yourself. Because the type is fully-specified in the first case, the compiler doesn't need to generate any code to resolve the type at run-time. This results in shorter and faster code.</source>
          <target state="translated">由于篇幅原因,这里没有显示结果,但你可能希望自己尝试一下。因为在第一种情况下,类型是完全指定的,编译器不需要在运行时生成任何代码来解析类型。这就导致代码更短、更快。</target>
        </trans-unit>
        <trans-unit id="6fc874bd7cd4d5b9abffad50a8cc5e9ee8fcd173" translate="yes" xml:space="preserve">
          <source>For rectangular &lt;code&gt;A&lt;/code&gt; the result is the minimum-norm least squares solution computed by a pivoted QR factorization of &lt;code&gt;A&lt;/code&gt; and a rank estimate of &lt;code&gt;A&lt;/code&gt; based on the R factor.</source>
          <target state="translated">对于矩形 &lt;code&gt;A&lt;/code&gt; ，结果是由 &lt;code&gt;A&lt;/code&gt; 的枢轴QR分解和基于R因子的 &lt;code&gt;A&lt;/code&gt; 秩估计所计算的最小范数最小二乘解。</target>
        </trans-unit>
        <trans-unit id="96f59651f15b7587bcada98bfc3f714cf7b14bc2" translate="yes" xml:space="preserve">
          <source>For similar reasons, automated translation to Julia would also typically generate unreadable, slow, non-idiomatic code that would not be a good starting point for a native Julia port from another language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="912d3fe9f2697c548ca0705aab244457023707b1" translate="yes" xml:space="preserve">
          <source>For simple functions, it is often clearer to mention the role of the arguments directly in the description of the function's purpose. An argument list would only repeat information already provided elsewhere. However, providing an argument list can be a good idea for complex functions with many arguments (in particular keyword arguments). In that case, insert it after the general description of the function, under an &lt;code&gt;# Arguments&lt;/code&gt; header, with one &lt;code&gt;-&lt;/code&gt; bullet for each argument. The list should mention the types and default values (if any) of the arguments:</source>
          <target state="translated">对于简单函数，通常更清楚地直接在函数目的描述中提及参数的作用。参数列表将仅重复其他地方已经提供的信息。但是，对于具有许多参数（尤其是关键字参数）的复杂函数，提供参数列表可能是一个好主意。在这种情况下，请将其插入到函数的一般说明之后，在 &lt;code&gt;# Arguments&lt;/code&gt; 标头下，每个参数都带有一个 &lt;code&gt;-&lt;/code&gt; 项目符号。该列表应提及参数的类型和默认值（如果有）：</target>
        </trans-unit>
        <trans-unit id="1ea7196a777e8e9b741754a756a982ecdc4df126" translate="yes" xml:space="preserve">
          <source>For simple index types, it defers to the unexported &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; to process each index &lt;code&gt;i&lt;/code&gt;. While this internal function is not intended to be called directly, &lt;code&gt;Base.to_index&lt;/code&gt; may be extended by custom array or index types to provide custom indexing behaviors.</source>
          <target state="translated">对于简单索引类型，它 &lt;code&gt;Base.to_index(A, i)&lt;/code&gt; 未导出的Base.to_index（A，i）来处理每个索引 &lt;code&gt;i&lt;/code&gt; 。虽然不希望直接调用此内部函数， &lt;code&gt;Base.to_index&lt;/code&gt; 可以通过自定义数组或索引类型扩展Base.to_index，以提供自定义索引行为。</target>
        </trans-unit>
        <trans-unit id="53b19a276cd1b474618ba84687e1e90b947ee82e" translate="yes" xml:space="preserve">
          <source>For situations where a value &lt;code&gt;x&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; exists only sometimes, the &lt;code&gt;Union{T, Nothing}&lt;/code&gt; type can be used for function arguments, object fields and array element types as the equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt;&lt;code&gt;Nullable&lt;/code&gt;, &lt;code&gt;Option&lt;/code&gt; or &lt;code&gt;Maybe&lt;/code&gt;&lt;/a&gt; in other languages. If the value itself can be &lt;code&gt;nothing&lt;/code&gt; (notably, when &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;), the &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; type is more appropriate since &lt;code&gt;x == nothing&lt;/code&gt; then indicates the absence of a value, and &lt;code&gt;x == Some(nothing)&lt;/code&gt; indicates the presence of a value equal to &lt;code&gt;nothing&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.something&quot;&gt;&lt;code&gt;something&lt;/code&gt;&lt;/a&gt; function allows unwrapping &lt;code&gt;Some&lt;/code&gt; objects and using a default value instead of &lt;code&gt;nothing&lt;/code&gt; arguments. Note that the compiler is able to generate efficient code when working with &lt;code&gt;Union{T, Nothing}&lt;/code&gt; arguments or fields.</source>
          <target state="translated">对于仅有时存在类型 &lt;code&gt;T&lt;/code&gt; 的值 &lt;code&gt;x&lt;/code&gt; 的情况， &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 类型可用于函数自变量，对象字段和数组元素类型，与其他语言中的&lt;a href=&quot;https://en.wikipedia.org/wiki/Nullable_type&quot;&gt; &lt;code&gt;Nullable&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;Option&lt;/code&gt; 或 &lt;code&gt;Maybe&lt;/code&gt; 等效。如果值本身可以为 &lt;code&gt;nothing&lt;/code&gt; （特别是当 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;Any&lt;/code&gt; 时），则 &lt;code&gt;Union{Some{T}, Nothing}&lt;/code&gt; 类型更合适，因为 &lt;code&gt;x == nothing&lt;/code&gt; 表示没有值， &lt;code&gt;x == Some(nothing)&lt;/code&gt; 表示存在等于 &lt;code&gt;nothing&lt;/code&gt; 值的值。该&lt;a href=&quot;../../base/base/index#Base.something&quot;&gt; &lt;code&gt;something&lt;/code&gt; &lt;/a&gt;函数允许解包 &lt;code&gt;Some&lt;/code&gt; 对象并使用默认值而不是 &lt;code&gt;nothing&lt;/code&gt; 参数。请注意，使用 &lt;code&gt;Union{T, Nothing}&lt;/code&gt; 参数或字段时，编译器能够生成高效的代码。</target>
        </trans-unit>
        <trans-unit id="43a7de4a7810165537aadc6250e15a8a55f9a88d" translate="yes" xml:space="preserve">
          <source>For some types which &quot;wrap&quot; other values, the constructor may wrap its argument inside a new object even if it is already of the requested type. For example &lt;code&gt;Some(x)&lt;/code&gt; wraps &lt;code&gt;x&lt;/code&gt; to indicate that a value is present (in a context where the result might be a &lt;code&gt;Some&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt;). However, &lt;code&gt;x&lt;/code&gt; itself might be the object &lt;code&gt;Some(y)&lt;/code&gt;, in which case the result is &lt;code&gt;Some(Some(y))&lt;/code&gt;, with two levels of wrapping. &lt;code&gt;convert(Some, x)&lt;/code&gt;, on the other hand, would just return &lt;code&gt;x&lt;/code&gt; since it is already a &lt;code&gt;Some&lt;/code&gt;.</source>
          <target state="translated">对于某些&amp;ldquo;包装&amp;rdquo;其他值的类型，构造函数可以将其参数包装在新对象中，即使它已经是请求的类型。例如， &lt;code&gt;Some(x)&lt;/code&gt; 包装 &lt;code&gt;x&lt;/code&gt; 以指示存在值（在结果可能为 &lt;code&gt;Some&lt;/code&gt; 或 &lt;code&gt;nothing&lt;/code&gt; 的上下文中）。但是， &lt;code&gt;x&lt;/code&gt; 本身可能是对象 &lt;code&gt;Some(y)&lt;/code&gt; ，在这种情况下，结果是 &lt;code&gt;Some(Some(y))&lt;/code&gt; ，具有两个包装级别。另一方面， &lt;code&gt;convert(Some, x)&lt;/code&gt; 只会返回 &lt;code&gt;x&lt;/code&gt; ,因为它已经是 &lt;code&gt;Some&lt;/code&gt; 了。</target>
        </trans-unit>
        <trans-unit id="47046f98397f6383243a7899dc2654cd12e6fb38" translate="yes" xml:space="preserve">
          <source>For some types, the machinery to &quot;fuse&quot; operations across nested levels of broadcasting is not available or could be done more efficiently incrementally. In such cases, you may need or want to evaluate &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; as if it had been written &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt;, where the inner operation is evaluated before tackling the outer operation. This sort of eager operation is directly supported by a bit of indirection; instead of directly constructing &lt;code&gt;Broadcasted&lt;/code&gt; objects, Julia lowers the fused expression &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; to &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt;. Now, by default, &lt;code&gt;broadcasted&lt;/code&gt; just calls the &lt;code&gt;Broadcasted&lt;/code&gt; constructor to create the lazy representation of the fused expression tree, but you can choose to override it for a particular combination of function and arguments.</source>
          <target state="translated">对于某些类型，无法跨嵌套的广播级别&amp;ldquo;融合&amp;rdquo;操作的机制可用，或者可以更有效地逐步完成。在这种情况下，您可能需要或想要对 &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; 进行评估，就好像它已被写入 &lt;code&gt;broadcast(*, x, broadcast(+, x, 1))&lt;/code&gt; ，其中在处理之前先评估内部操作外部操作。这种急切的操作由一些间接支持。Julia 不直接构造 &lt;code&gt;Broadcasted&lt;/code&gt; 对象，而是将融合表达式 &lt;code&gt;x .* (x .+ 1)&lt;/code&gt; 为 &lt;code&gt;Broadcast.broadcasted(*, x, Broadcast.broadcasted(+, x, 1))&lt;/code&gt; 。现在，默认情况下， &lt;code&gt;broadcasted&lt;/code&gt; 只是呼叫 &lt;code&gt;Broadcasted&lt;/code&gt; 构造函数来创建融合表达式树的惰性表示形式，但是对于函数和参数的特定组合，可以选择重写它。</target>
        </trans-unit>
        <trans-unit id="08e1dce6d1b843106b2d04dbdc79c4bf75d54149" translate="yes" xml:space="preserve">
          <source>For specializing broadcast on custom types, see</source>
          <target state="translated">关于自定义类型的专业广播,请参阅</target>
        </trans-unit>
        <trans-unit id="1b18cc26dc44ec9e519a2a7660046d4495db6e20" translate="yes" xml:space="preserve">
          <source>For specific exception types, &lt;code&gt;handler&lt;/code&gt; is required to accept additional arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063287ad264bebc20a42dfa1890ff52805f2bb2c" translate="yes" xml:space="preserve">
          <source>For string arguments (&lt;code&gt;char*&lt;/code&gt;) the Julia type should be &lt;code&gt;Cstring&lt;/code&gt; (if NUL- terminated data is expected) or either &lt;code&gt;Ptr{Cchar}&lt;/code&gt; or &lt;code&gt;Ptr{UInt8}&lt;/code&gt; otherwise (these two pointer types have the same effect), as described above, not &lt;code&gt;String&lt;/code&gt;. Similarly, for array arguments (&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt;), the Julia type should again be &lt;code&gt;Ptr{T}&lt;/code&gt;, not &lt;code&gt;Vector{T}&lt;/code&gt;.</source>
          <target state="translated">对于字符串参数（ &lt;code&gt;char*&lt;/code&gt; ），Julia类型应为 &lt;code&gt;Cstring&lt;/code&gt; （如果期望使用NUL终止的数据），或者应为 &lt;code&gt;Ptr{Cchar}&lt;/code&gt; 或 &lt;code&gt;Ptr{UInt8}&lt;/code&gt; 否则（这两种指针类型具有相同的作用），如上所述，而不是 &lt;code&gt;String&lt;/code&gt; 。类似地，对于数组参数（ &lt;code&gt;T[]&lt;/code&gt; 或 &lt;code&gt;T*&lt;/code&gt; ），Julia类型应再次为 &lt;code&gt;Ptr{T}&lt;/code&gt; ，而不是 &lt;code&gt;Vector{T}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0ae9d821284a94b5ce78c69057ff544650721831" translate="yes" xml:space="preserve">
          <source>For string arguments (&lt;code&gt;char*&lt;/code&gt;) the Julia type should be &lt;code&gt;Cstring&lt;/code&gt; (if NUL- terminated data is expected), or either &lt;code&gt;Ptr{Cchar}&lt;/code&gt; or &lt;code&gt;Ptr{UInt8}&lt;/code&gt; otherwise (these two pointer types have the same effect), as described above, not &lt;code&gt;String&lt;/code&gt;. Similarly, for array arguments (&lt;code&gt;T[]&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt;), the Julia type should again be &lt;code&gt;Ptr{T}&lt;/code&gt;, not &lt;code&gt;Vector{T}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3d0b51e2ef5e244357843af21db4dc2c7dfc01" translate="yes" xml:space="preserve">
          <source>For symmetric or Hermitian &lt;code&gt;A&lt;/code&gt;, an eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, otherwise the scaling and squaring algorithm (see &lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt;) is chosen.</source>
          <target state="translated">对于对称或Hermitian &lt;code&gt;A&lt;/code&gt; ，使用&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen），否则选择缩放和平方算法（请参见&lt;a href=&quot;#footnote-H05&quot;&gt;[H05]&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9203451fb420c19124d347a28e5e21e46e2168a9" translate="yes" xml:space="preserve">
          <source>For symmetric or Hermitian &lt;code&gt;A&lt;/code&gt;, an eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, otherwise the scaling and squaring algorithm (see &lt;sup&gt;&lt;a href=&quot;#footnote-H05&quot; id=&quot;citeref-H05&quot;&gt;[H05]&lt;/a&gt;&lt;/sup&gt;) is chosen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c4a6da96174312b12bb84f60f8bf72388ffeca" translate="yes" xml:space="preserve">
          <source>For text I/O, use the &lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;show&lt;/code&gt; methods, depending on your needs (see the documentation for these two methods for a detailed discussion of the difference between them):</source>
          <target state="translated">对于文本I / O，请根据需要使用&lt;a href=&quot;../../base/io-network/index#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;show&lt;/code&gt; 方法（有关这两种方法之间的差异的详细讨论，请参见文档）：</target>
        </trans-unit>
        <trans-unit id="205743ce47116c17ca0d1d16d7b760bea8f341c7" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;Squares&lt;/code&gt; iterable above, we can easily compute the &lt;code&gt;i&lt;/code&gt;th element of the sequence by squaring it. We can expose this as an indexing expression &lt;code&gt;S[i]&lt;/code&gt;. To opt into this behavior, &lt;code&gt;Squares&lt;/code&gt; simply needs to define &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">对于上面的 &lt;code&gt;Squares&lt;/code&gt; 可迭代，我们可以通过平方来轻松计算序列的第 &lt;code&gt;i&lt;/code&gt; 个元素。我们可以将其公开为索引表达式 &lt;code&gt;S[i]&lt;/code&gt; 。要选择这种行为， &lt;code&gt;Squares&lt;/code&gt; 只需定义&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; 即可&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="b61259c05b4f470d8af9ec6b5659050e33e9f420" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return the total number of that day of the week in &lt;code&gt;dt&lt;/code&gt;'s month. Returns 4 or 5. Useful in temporal expressions for specifying the last day of a week in a month by including &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; in the adjuster function.</source>
          <target state="translated">对于一周中的一天 &lt;code&gt;dt&lt;/code&gt; ，返回星期的那一天总数 &lt;code&gt;dt&lt;/code&gt; 的一个月。返回4或5。在时间表达式中很有用，可通过在调节器函数中包含 &lt;code&gt;dayofweekofmonth(dt) == daysofweekinmonth(dt)&lt;/code&gt; 来指定一个月中的一周的最后一天。</target>
        </trans-unit>
        <trans-unit id="fe652373fcfd70aa4cf5d9a9c42f569d7f7beb45" translate="yes" xml:space="preserve">
          <source>For the day of week of &lt;code&gt;dt&lt;/code&gt;, return which number it is in &lt;code&gt;dt&lt;/code&gt;'s month. So if the day of the week of &lt;code&gt;dt&lt;/code&gt; is Monday, then &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; In the range 1:5.</source>
          <target state="translated">对于 &lt;code&gt;dt&lt;/code&gt; 中的星期几，请返回它在 &lt;code&gt;dt&lt;/code&gt; 月份中的数字。因此，如果 &lt;code&gt;dt&lt;/code&gt; 的星期几是星期一，则 &lt;code&gt;1 = First Monday of the month, 2 = Second Monday of the month, etc.&lt;/code&gt; 范围为1：5。</target>
        </trans-unit>
        <trans-unit id="652922b94585bcd03eb665e42d71bab0709ffc65" translate="yes" xml:space="preserve">
          <source>For the default constructor, exactly one argument must be supplied for each field:</source>
          <target state="translated">对于默认的构造函数,每个字段必须提供一个参数。</target>
        </trans-unit>
        <trans-unit id="56d79b9ca82aa7547916a2539b58ed4630995e94" translate="yes" xml:space="preserve">
          <source>For the remaining keyword arguments, see the documentation of &lt;a href=&quot;#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有关其余关键字参数，请参见&lt;a href=&quot;#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;文档！。</target>
        </trans-unit>
        <trans-unit id="b23a97c3c42b32c810ec362860430dab0f399881" translate="yes" xml:space="preserve">
          <source>For the same reason, contrary to logical operators presented above, the short-circuiting boolean operators &lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;||&lt;/code&gt; do not allow for &lt;code&gt;missing&lt;/code&gt; values in situations where the value of the operand determines whether the next operand is evaluated or not. For example</source>
          <target state="translated">由于相同的原因，与上面介绍的逻辑运算符相反，短路布尔运算符&lt;a href=&quot;../../base/math/index#&amp;amp;&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;||&lt;/code&gt; 在操作数的值确定是否对下一个操作数进行求值的情况下，不允许 &lt;code&gt;missing&lt;/code&gt; 值。例如</target>
        </trans-unit>
        <trans-unit id="f6f2cb638bdf85d316fe3667be12ad3cf8fd1cb2" translate="yes" xml:space="preserve">
          <source>For the very common pattern usage pattern of</source>
          <target state="translated">对于非常常见的模式使用模式为</target>
        </trans-unit>
        <trans-unit id="abe66bccf2edc923b8619fe03afd5d016c3843ac" translate="yes" xml:space="preserve">
          <source>For these reasons, it's recommended that you try using the built-in sampling profiler before considering any alternatives.</source>
          <target state="translated">由于这些原因,建议您在考虑任何替代方案之前,先尝试使用内置采样剖析器。</target>
        </trans-unit>
        <trans-unit id="61eee68fc84c521e01e74ee4b3cb32a8a20b7707" translate="yes" xml:space="preserve">
          <source>For translating a C argument list to Julia:</source>
          <target state="translated">用于将C参数列表翻译成Julia。</target>
        </trans-unit>
        <trans-unit id="0c8fe98556d87eebbe139565ad2035f5a8376ab0" translate="yes" xml:space="preserve">
          <source>For translating a C return type to Julia:</source>
          <target state="translated">用于将C语言的返回类型翻译成Julia。</target>
        </trans-unit>
        <trans-unit id="f089947163c1743d34e858e0290c83835145a36d" translate="yes" xml:space="preserve">
          <source>For two arguments, this is the angle in radians between the positive &lt;em&gt;x&lt;/em&gt;-axis and the point (&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;), returning a value in the interval $[-\pi, \pi]$. This corresponds to a standard &lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt;&lt;code&gt;atan2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">对于两个参数，这是正&lt;em&gt;x&lt;/em&gt;轴与点（&lt;em&gt;x&lt;/em&gt;，&lt;em&gt;y&lt;/em&gt;）之间的弧度角，返回区间$ [-\ pi，\ pi] $。这对应于标准&lt;a href=&quot;https://en.wikipedia.org/wiki/Atan2&quot;&gt; &lt;code&gt;atan2&lt;/code&gt; &lt;/a&gt;函数。</target>
        </trans-unit>
        <trans-unit id="8784f2a51d06748e116c26d584683c6da35029e2" translate="yes" xml:space="preserve">
          <source>For unbuffered channels returns &lt;code&gt;true&lt;/code&gt; if there are tasks waiting on a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">对于无缓冲通道，如果有任务等待&lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;，则返回 &lt;code&gt;true&lt;/code&gt; ！。</target>
        </trans-unit>
        <trans-unit id="dcf07feef0790c851bc6f0a6f8cbac38791a64b9" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt;&lt;code&gt;put!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">对于无缓冲的通道，阻塞直到&lt;a href=&quot;#Base.put!-Tuple%7BChannel,Any%7D&quot;&gt; &lt;code&gt;put!&lt;/code&gt; &lt;/a&gt;由其他任务执行。</target>
        </trans-unit>
        <trans-unit id="84b0a200921412bb65f21b5bb7c59da76c4bbed1" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt;&lt;code&gt;take!&lt;/code&gt;&lt;/a&gt; is performed by a different task.</source>
          <target state="translated">对于无缓冲的通道，阻塞直到止步&lt;a href=&quot;#Base.take!-Tuple%7BChannel%7D&quot;&gt; &lt;code&gt;take!&lt;/code&gt; &lt;/a&gt;由其他任务执行。</target>
        </trans-unit>
        <trans-unit id="a1f4f3e026d72a7731be56290972632b9296433b" translate="yes" xml:space="preserve">
          <source>For unbuffered channels, blocks until a &lt;code&gt;take!&lt;/code&gt; is performed by a different task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d88c03e115fa0e1f0ae726ca69a5946e7b8f3d" translate="yes" xml:space="preserve">
          <source>For variable &lt;code&gt;a&lt;/code&gt; and expression &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a = b&lt;/code&gt; makes &lt;code&gt;a&lt;/code&gt; refer to the value of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">对于可变 &lt;code&gt;a&lt;/code&gt; 和表达 &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;a = b&lt;/code&gt; ，使 &lt;code&gt;a&lt;/code&gt; 参考值 &lt;code&gt;b&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a2988c23bad5d1f4419c0c3331b505d6761bfd4" translate="yes" xml:space="preserve">
          <source>For when a capture doesn't match, instead of a substring, &lt;code&gt;m.captures&lt;/code&gt; contains &lt;code&gt;nothing&lt;/code&gt; in that position, and &lt;code&gt;m.offsets&lt;/code&gt; has a zero offset (recall that indices in Julia are 1-based, so a zero offset into a string is invalid). Here is a pair of somewhat contrived examples:</source>
          <target state="translated">因为当捕获不匹配，而不是一个字符串， &lt;code&gt;m.captures&lt;/code&gt; 包含 &lt;code&gt;nothing&lt;/code&gt; 在那个位置，并 &lt;code&gt;m.offsets&lt;/code&gt; 具有零偏移（回想一下，在朱莉娅指数是基于1的，所以抵消了零成字符串无效）。这是一些人为的示例：</target>
        </trans-unit>
        <trans-unit id="cdc4b17a13e956b864dfd62e85ad672e28429820" translate="yes" xml:space="preserve">
          <source>Force a GC run</source>
          <target state="translated">迫使GC运行</target>
        </trans-unit>
        <trans-unit id="5eb175b9460612a847c5831f8d611666f7e129b1" translate="yes" xml:space="preserve">
          <source>Forces</source>
          <target state="translated">Forces</target>
        </trans-unit>
        <trans-unit id="08bb485a70c09a4b008d8b79ee39bee0f080480a" translate="yes" xml:space="preserve">
          <source>Forces synchronization between the in-memory version of a memory-mapped &lt;code&gt;Array&lt;/code&gt; or &lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt;&lt;code&gt;BitArray&lt;/code&gt;&lt;/a&gt; and the on-disk version.</source>
          <target state="translated">强制在内存映射的 &lt;code&gt;Array&lt;/code&gt; 或&lt;a href=&quot;../../base/arrays/index#Base.BitArray&quot;&gt; &lt;code&gt;BitArray&lt;/code&gt; &lt;/a&gt;的内存中版本与磁盘上版本之间进行同步。</target>
        </trans-unit>
        <trans-unit id="a4b44623e8c8994cfd237bbb5a20500862bde2d9" translate="yes" xml:space="preserve">
          <source>Fork And Knife</source>
          <target state="translated">叉子和刀子</target>
        </trans-unit>
        <trans-unit id="cac22bd0e8a69bd849b7be8d79bbdfbf8b44d9d5" translate="yes" xml:space="preserve">
          <source>Forking</source>
          <target state="translated">Forking</target>
        </trans-unit>
        <trans-unit id="050d7641601e8d3bdebb15e95cb05f81983e6de8" translate="yes" xml:space="preserve">
          <source>Format the &lt;code&gt;tok&lt;/code&gt; token from &lt;code&gt;dt&lt;/code&gt; and write it to &lt;code&gt;io&lt;/code&gt;. The formatting can be based on &lt;code&gt;locale&lt;/code&gt;.</source>
          <target state="translated">从 &lt;code&gt;dt&lt;/code&gt; 格式化 &lt;code&gt;tok&lt;/code&gt; 令牌并将其写入 &lt;code&gt;io&lt;/code&gt; 。格式可以基于 &lt;code&gt;locale&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b95515ff3376dd3ae2f977e999ab2880dd7abaa5" translate="yes" xml:space="preserve">
          <source>Fortran Wrapper Example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5449b0de438e10172cfa72d13dabc8ee40d61810" translate="yes" xml:space="preserve">
          <source>Fortran compilers &lt;em&gt;may&lt;/em&gt; also add other hidden arguments for pointers, assumed-shape (&lt;code&gt;:&lt;/code&gt;) and assumed-size (&lt;code&gt;*&lt;/code&gt;) arrays. Such behaviour can be avoided by using &lt;code&gt;ISO_C_BINDING&lt;/code&gt; and including &lt;code&gt;bind(c)&lt;/code&gt; in the definition of the subroutine, which is strongly recommended for interoperable code. In this case there will be no hidden arguments, at the cost of some language features (e.g. only &lt;code&gt;character(len=1)&lt;/code&gt; will be permitted to pass strings).</source>
          <target state="translated">Fortran编译器&lt;em&gt;可以&lt;/em&gt;还添加其他隐藏参数为指针，假定形状（ &lt;code&gt;:&lt;/code&gt; ）和假定大小（ &lt;code&gt;*&lt;/code&gt; ）阵列。可以通过使用 &lt;code&gt;ISO_C_BINDING&lt;/code&gt; 并在子例程的定义中包含 &lt;code&gt;bind(c)&lt;/code&gt; 来避免这种行为，强烈建议对可互操作的代码进行这种操作。在这种情况下，将没有隐藏的参数，这是以某些语言功能为代价的（例如，仅允许 &lt;code&gt;character(len=1)&lt;/code&gt; 传递字符串）。</target>
        </trans-unit>
        <trans-unit id="a0484116def6ba2539f3b9f9921bd8b4ba22a4aa" translate="yes" xml:space="preserve">
          <source>Fortran name</source>
          <target state="translated">Fortran名称</target>
        </trans-unit>
        <trans-unit id="16c35d1374b93a7d00d34b68d3e6ad6a2c21c760" translate="yes" xml:space="preserve">
          <source>Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; to flip coins on two processes. First, write the following function in &lt;code&gt;count_heads.jl&lt;/code&gt;:</source>
          <target state="translated">幸运的是，许多有用的并行计算不需要数据移动。一个常见的例子是蒙特卡洛模拟，其中多个过程可以同时处理独立的模拟试验。我们可以使用&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;在两个过程中翻转硬币。首先，在 &lt;code&gt;count_heads.jl&lt;/code&gt; 中编写以下函数：</target>
        </trans-unit>
        <trans-unit id="c88633f59ce30b4843943132dd5c7b1eb583498a" translate="yes" xml:space="preserve">
          <source>Fortunately, many useful parallel computations do not require data movement. A common example is a Monte Carlo simulation, where multiple processes can handle independent simulation trials simultaneously. We can use &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; to flip coins on two processes. First, write the following function in &lt;code&gt;count_heads.jl&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd1ed1b5512a22fba4de952e82beaad9990da5b" translate="yes" xml:space="preserve">
          <source>Forward delete one character (when buffer has text)</source>
          <target state="translated">向前删除一个字符(当缓冲区有文本时)。</target>
        </trans-unit>
        <trans-unit id="d2bd5de8c2484ca6755e34f338af3268021c0a12" translate="yes" xml:space="preserve">
          <source>Forward delete the next word</source>
          <target state="translated">向前删除下一个字</target>
        </trans-unit>
        <trans-unit id="a187c3285151f39c70caaf5e477c6e87663d3ef4" translate="yes" xml:space="preserve">
          <source>Fountain</source>
          <target state="translated">Fountain</target>
        </trans-unit>
        <trans-unit id="4ab98d03a72763b8222b6d8722ded7966bf98d76" translate="yes" xml:space="preserve">
          <source>Four Leaf Clover</source>
          <target state="translated">四叶草</target>
        </trans-unit>
        <trans-unit id="2b13f83d35f7fc73ce97c8b26bfe724907153aae" translate="yes" xml:space="preserve">
          <source>Four-Per-Em Space</source>
          <target state="translated">四比一空间</target>
        </trans-unit>
        <trans-unit id="73c09759c4507af6948adebc3787e93351d4acda" translate="yes" xml:space="preserve">
          <source>Fourth Root</source>
          <target state="translated">第四根</target>
        </trans-unit>
        <trans-unit id="c54d686ebd31bf6296f3ac8e3de5cdba7b0fe495" translate="yes" xml:space="preserve">
          <source>Fraction Numerator One</source>
          <target state="translated">分数分子一</target>
        </trans-unit>
        <trans-unit id="9f62f41c6fc2c6a6ef7e8630ebef06bc253ed2e9" translate="yes" xml:space="preserve">
          <source>Fractions</source>
          <target state="translated">Fractions</target>
        </trans-unit>
        <trans-unit id="1a4eb1bfc4ceb4284f084ca37c8edbaed934f05c" translate="yes" xml:space="preserve">
          <source>Free and open source (&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;MIT licensed&lt;/a&gt;)</source>
          <target state="translated">免费和开源（&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/LICENSE.md&quot;&gt;MIT许可&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="d150e0aaee05d4d7cee80412f889a1b8c7404089" translate="yes" xml:space="preserve">
          <source>French Fries</source>
          <target state="translated">薯条</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">常问问题</target>
        </trans-unit>
        <trans-unit id="2e42fd5fd57e2eddb93e306ecceb863efd070156" translate="yes" xml:space="preserve">
          <source>Fried Shrimp</source>
          <target state="translated">炒虾</target>
        </trans-unit>
        <trans-unit id="d25d30098e10e7246e59352c44263a5bb1531117" translate="yes" xml:space="preserve">
          <source>Frog Face</source>
          <target state="translated">蛙面</target>
        </trans-unit>
        <trans-unit id="ec026c33022b335b80bd8f0e64407b39229b2c88" translate="yes" xml:space="preserve">
          <source>From the caller's perspective, this is identical to a regular function; in fact, you don't have to know whether you're calling a regular or generated function. Let's see how &lt;code&gt;foo&lt;/code&gt; behaves:</source>
          <target state="translated">从调用者的角度来看，这与常规函数相同；实际上，您不必知道要调用常规函数还是生成的函数。让我们看看 &lt;code&gt;foo&lt;/code&gt; 的行为：</target>
        </trans-unit>
        <trans-unit id="ca77e2b5e973595e2f2f608f9805266ed582b1b8" translate="yes" xml:space="preserve">
          <source>From these definitions, one obtains the following behavior:</source>
          <target state="translated">从这些定义中,我们可以得到以下行为。</target>
        </trans-unit>
        <trans-unit id="b422184537e8dbfbffe465f2c662481e754378a9" translate="yes" xml:space="preserve">
          <source>Front-Facing Baby Chick</source>
          <target state="translated">正面小鸡</target>
        </trans-unit>
        <trans-unit id="6d0c809a561642fe04a663534c34c6a988c1f63d" translate="yes" xml:space="preserve">
          <source>Frown</source>
          <target state="translated">Frown</target>
        </trans-unit>
        <trans-unit id="fb52dd543cda4930bef0a7aed25ec2307f4f2ed5" translate="yes" xml:space="preserve">
          <source>Frowning Face With Open Mouth</source>
          <target state="translated">张嘴皱眉的脸</target>
        </trans-unit>
        <trans-unit id="3b8ae9bdd856b92028c18db46fbc39d04889c711" translate="yes" xml:space="preserve">
          <source>Fuel Pump</source>
          <target state="translated">燃油泵</target>
        </trans-unit>
        <trans-unit id="1dc013b6064daee6213fd09ae3d5ea49df1bdb94" translate="yes" xml:space="preserve">
          <source>Full Block</source>
          <target state="translated">整块</target>
        </trans-unit>
        <trans-unit id="91e2750218473c3715d4640558a3e864dd2b4c5e" translate="yes" xml:space="preserve">
          <source>Full Moon Symbol</source>
          <target state="translated">满月符号</target>
        </trans-unit>
        <trans-unit id="32a64f880ba20480782d9f08062e23749801ebec" translate="yes" xml:space="preserve">
          <source>Full Moon With Face</source>
          <target state="translated">满月与脸</target>
        </trans-unit>
        <trans-unit id="11342457efd18f569b992724d11b3a2d8832ce4b" translate="yes" xml:space="preserve">
          <source>Full Outer Join</source>
          <target state="translated">全外侧加盟</target>
        </trans-unit>
        <trans-unit id="f1096aa4780f9ea80d71f2a7366569059e04d8fc" translate="yes" xml:space="preserve">
          <source>Full day of week name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91bc6576bb78484d08a918ba3eadfec40cb28a6b" translate="yes" xml:space="preserve">
          <source>Full month name according to the &lt;code&gt;locale&lt;/code&gt; keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db63acc70bb8aace65207096c8aa56a922c0d72f" translate="yes" xml:space="preserve">
          <source>Fully implemented by:</source>
          <target state="translated">全面实施的有:</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="95054001cf3f6f293128fbac88deaae7d22cc115" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;abmult&lt;/code&gt; returns a function &lt;code&gt;f&lt;/code&gt; that multiplies its argument by the absolute value of &lt;code&gt;r&lt;/code&gt;. The inner function assigned to &lt;code&gt;f&lt;/code&gt; is called a &quot;closure&quot;. Inner functions are also used by the language for &lt;code&gt;do&lt;/code&gt;-blocks and for generator expressions.</source>
          <target state="translated">函数 &lt;code&gt;abmult&lt;/code&gt; 返回一个函数 &lt;code&gt;f&lt;/code&gt; ，该函数将其参数乘以 &lt;code&gt;r&lt;/code&gt; 的绝对值。分配给 &lt;code&gt;f&lt;/code&gt; 的内部函数称为&amp;ldquo;闭包&amp;rdquo;。该语言还将内部函数用于 &lt;code&gt;do&lt;/code&gt; -block和生成器表达式。</target>
        </trans-unit>
        <trans-unit id="902d94a2b6ad89fe3137e81fa9679244c8f73579" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;exit_on_sigint&lt;/code&gt; requires at least Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7697b6877e6664e26745e5f66999b4cfefbd165c" translate="yes" xml:space="preserve">
          <source>Function body starting with &lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt;</source>
          <target state="translated">以 &lt;code&gt;Body::UNION{T1,T2})&lt;/code&gt; 开头的函数主体</target>
        </trans-unit>
        <trans-unit id="aa0b7e8266dfec8d33dbc09471974455072b6005" translate="yes" xml:space="preserve">
          <source>Function chaining (sometimes called &quot;piping&quot; or &quot;using a pipe&quot; to send data to a subsequent function) is when you apply a function to the previous function's output:</source>
          <target state="translated">函数链(有时也被称为 &quot;管道 &quot;或 &quot;使用管道 &quot;向后续函数发送数据)是指将一个函数应用于前一个函数的输出。</target>
        </trans-unit>
        <trans-unit id="de91ebb3667f8cc24a066c6edb9a49fb5801d827" translate="yes" xml:space="preserve">
          <source>Function composition also works in prefix form: &lt;code&gt;∘(f, g)&lt;/code&gt; is the same as &lt;code&gt;f ∘ g&lt;/code&gt;. The prefix form supports composition of multiple functions: &lt;code&gt;∘(f, g, h) = f ∘ g ∘ h&lt;/code&gt; and splatting &lt;code&gt;∘(fs...)&lt;/code&gt; for composing an iterable collection of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28a100a083f8e25a3bc12e6db11fea904564f3f" translate="yes" xml:space="preserve">
          <source>Function composition and piping</source>
          <target state="translated">功能组成和管道</target>
        </trans-unit>
        <trans-unit id="faa5a28142e8b8d79608d822a7ee2fc012117fa0" translate="yes" xml:space="preserve">
          <source>Function composition is when you combine functions together and apply the resulting composition to arguments. You use the function composition operator (&lt;code&gt;∘&lt;/code&gt;) to compose the functions, so &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; is the same as &lt;code&gt;f(g(args...))&lt;/code&gt;.</source>
          <target state="translated">函数组合是将函数组合在一起并将结果组合应用于参数时。可以使用函数组合运算符（ &lt;code&gt;∘&lt;/code&gt; ）组成的功能，所以 &lt;code&gt;(f ∘ g)(args...)&lt;/code&gt; 是一样的 &lt;code&gt;f(g(args...))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3f2060410180dd6737f9e6d318390fd5317d7bae" translate="yes" xml:space="preserve">
          <source>Function parameters can also be used to constrain the number of arguments that may be supplied to a &quot;varargs&quot; function (&lt;a href=&quot;../functions/index#Varargs-Functions&quot;&gt;Varargs Functions&lt;/a&gt;). The notation &lt;code&gt;Vararg{T,N}&lt;/code&gt; is used to indicate such a constraint. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8cbdb67375da79abe2b0143f8eebcc7cb99416" translate="yes" xml:space="preserve">
          <source>Function parameters can also be used to constrain the number of arguments that may be supplied to a &quot;varargs&quot; function (&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs Functions&lt;/a&gt;). The notation &lt;code&gt;Vararg{T,N}&lt;/code&gt; is used to indicate such a constraint. For example:</source>
          <target state="translated">函数参数还可以用于约束可以提供给&amp;ldquo; varargs&amp;rdquo;函数（&lt;a href=&quot;../functions/index#Varargs-Functions-1&quot;&gt;Varargs函数&lt;/a&gt;）的参数数量。符号 &lt;code&gt;Vararg{T,N}&lt;/code&gt; 被用于指示这样的限制。例如：</target>
        </trans-unit>
        <trans-unit id="c748f42ec833ed8f7d97105f385770153e5f3a88" translate="yes" xml:space="preserve">
          <source>Function sets &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecs and &lt;code&gt;mirror&lt;/code&gt; flag for remote reference.</source>
          <target state="translated">功能集 &lt;code&gt;+refs/*:refs/*&lt;/code&gt; refspecs和用于远程引用的 &lt;code&gt;mirror&lt;/code&gt; 标志。</target>
        </trans-unit>
        <trans-unit id="ea4be7f77276f932f73d95ac11b41c01bca27493" translate="yes" xml:space="preserve">
          <source>Function-like objects</source>
          <target state="translated">功能类对象</target>
        </trans-unit>
        <trans-unit id="79fde2ac8490ff2b99ac9c9890e046fdff6e3659" translate="yes" xml:space="preserve">
          <source>Functionality</source>
          <target state="translated">Functionality</target>
        </trans-unit>
        <trans-unit id="eddb44c7165ef5eabc1df07ca23331299f12c1fa" translate="yes" xml:space="preserve">
          <source>Functionality for base-64 encoded strings and IO.</source>
          <target state="translated">64进制编码字符串和IO的功能。</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="53a4e15f59ddb4061325c79602aaccdf7b922b54" translate="yes" xml:space="preserve">
          <source>Functions &amp;amp; Methods</source>
          <target state="translated">功能与方法</target>
        </trans-unit>
        <trans-unit id="c13326dfc431675363c3f3a461ddb4d2e5748e9f" translate="yes" xml:space="preserve">
          <source>Functions &lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt;&lt;code&gt;workers&lt;/code&gt;&lt;/a&gt;, and others are available as a programmatic means of adding, removing and querying the processes in a cluster.</source>
          <target state="translated">函数&lt;a href=&quot;../../stdlib/distributed/index#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../stdlib/distributed/index#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../stdlib/distributed/index#Distributed.workers&quot;&gt; &lt;code&gt;workers&lt;/code&gt; &lt;/a&gt;和其他函数可以作为在群集中添加，删除和查询进程的编程方式。</target>
        </trans-unit>
        <trans-unit id="0ff075e5c1729ce32f2f5738fecab65d263b0838" translate="yes" xml:space="preserve">
          <source>Functions &lt;code&gt;any&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; also follow the rules of three-valued logic, returning &lt;code&gt;missing&lt;/code&gt; when the result cannot be determined</source>
          <target state="translated">函数 &lt;code&gt;any&lt;/code&gt; 和 &lt;code&gt;all&lt;/code&gt; 也都遵循三值逻辑的规则，当无法确定结果时返回 &lt;code&gt;missing&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7372df3a40ed071a29722d4bc6498e66d76a5da" translate="yes" xml:space="preserve">
          <source>Functions and Methods</source>
          <target state="translated">功能和方法</target>
        </trans-unit>
        <trans-unit id="547df569a8b37a13ed96cad6ad095bccba6ee3ff" translate="yes" xml:space="preserve">
          <source>Functions and variables share the same namespace (&amp;ldquo;Lisp-1&amp;rdquo;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bb375b3fcf2e8e9d0dbcd433eb2746123db60e5" translate="yes" xml:space="preserve">
          <source>Functions are defined with the &lt;code&gt;function&lt;/code&gt; keyword:</source>
          <target state="translated">函数通过 &lt;code&gt;function&lt;/code&gt; 关键字定义：</target>
        </trans-unit>
        <trans-unit id="55e8c66bfd9e6c0e9dfa04cb544f8bb30a80231b" translate="yes" xml:space="preserve">
          <source>Functions in Julia are &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;first-class objects&lt;/a&gt;: they can be assigned to variables, and called using the standard function call syntax from the variable they have been assigned to. They can be used as arguments, and they can be returned as values. They can also be created anonymously, without being given a name, using either of these syntaxes:</source>
          <target state="translated">Julia中的函数是&lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;一类对象&lt;/a&gt;：可以将它们分配给变量，并使用已分配给变量的标准函数调用语法对其进行调用。它们可以用作参数，也可以作为值返回。也可以使用以下两种语法之一匿名创建它们，而无需给出名称：</target>
        </trans-unit>
        <trans-unit id="c04e52a6c310e2a4baade48d1f42fd88819eec1a" translate="yes" xml:space="preserve">
          <source>Functions in Julia can be combined by composing or piping (chaining) them together.</source>
          <target state="translated">在Julia中,函数可以通过合成或管道(链)将它们组合在一起。</target>
        </trans-unit>
        <trans-unit id="ceeb1ec49508dede84853cbb0f013b3decdfa56c" translate="yes" xml:space="preserve">
          <source>Functions in Julia may have multiple implementations, known as methods. While it's good practice for generic functions to have a single purpose, Julia allows methods to be documented individually if necessary. In general, only the most generic method should be documented, or even the function itself (i.e. the object created without any methods by &lt;code&gt;function bar end&lt;/code&gt;). Specific methods should only be documented if their behaviour differs from the more generic ones. In any case, they should not repeat the information provided elsewhere. For example:</source>
          <target state="translated">Julia中的函数可能具有多种实现，称为方法。虽然通用功能具有单一目的是一种很好的做法，但是Julia允许在必要时单独记录方法。通常，仅应记录最通用的方法，甚至应记录函数本身（即，通过 &lt;code&gt;function bar end&lt;/code&gt; 创建没有任何方法的对象）。仅当特定方法的行为与更通用的方法不同时，才应记录这些方法。无论如何，他们不应重复其他地方提供的信息。例如：</target>
        </trans-unit>
        <trans-unit id="0369fd43ccf1e9549a7a746fe6b93020919f4a10" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression or the &lt;code&gt;return&lt;/code&gt; keyword instead of listing the names of variables to return in the function definition (see &lt;a href=&quot;../functions/index#The-return-Keyword&quot;&gt;The return Keyword&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820b3bd7ddec6937c4e242be1bbe2ab057c0ac78" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression or the &lt;code&gt;return&lt;/code&gt; keyword instead of listing the names of variables to return in the function definition (see &lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;The return Keyword&lt;/a&gt; for details).</source>
          <target state="translated">Julia中的函数从其最后一个表达式或 &lt;code&gt;return&lt;/code&gt; 关键字返回值，而不是在函数定义中列出要返回的变量名称（有关详细信息，请参见&lt;a href=&quot;../functions/index#The-return-Keyword-1&quot;&gt;return关键字&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a59fb02f015778c14d39ec5b1bcf732d30a76ac1" translate="yes" xml:space="preserve">
          <source>Functions in Julia return values from their last expression(s) or the &lt;code&gt;return&lt;/code&gt; keyword. Multiple values can be returned from functions and assigned as tuples, e.g. &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; or &lt;code&gt;a, b = myfunction()&lt;/code&gt;, instead of having to pass pointers to values as one would have to do in C/C++ (i.e. &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt;.</source>
          <target state="translated">Julia中的函数从其最后一个表达式或 &lt;code&gt;return&lt;/code&gt; 关键字返回值。可以从函数返回多个值并将其分配为元组，例如 &lt;code&gt;(a, b) = myfunction()&lt;/code&gt; 或 &lt;code&gt;a, b = myfunction()&lt;/code&gt; ，而不必像在C / C ++中那样将指针传递给值（即 &lt;code&gt;a = myfunction(&amp;amp;b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a55840c344c2be9d92831007662fa28bbfaafd80" translate="yes" xml:space="preserve">
          <source>Functions like &lt;code&gt;strange_twos&lt;/code&gt; occur when dealing with data of uncertain type, for example data loaded from an input file that might contain either integers, floats, strings, or something else.</source>
          <target state="translated">处理不确定类型的数据（例如，从输入文件加载的数据中可能包含整数，浮点数，字符串或其他内容）时，会发生诸如 &lt;code&gt;strange_twos&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="7b33eb7808d1f3eaa212ba1f622374dd77c823c6" translate="yes" xml:space="preserve">
          <source>Functions on &lt;code&gt;Expr&lt;/code&gt;essions</source>
          <target state="translated">在功能 &lt;code&gt;Expr&lt;/code&gt; 的宽恕请求</target>
        </trans-unit>
        <trans-unit id="8b8603c397ef929230aa5c590ebf0c5ec135d545" translate="yes" xml:space="preserve">
          <source>Functions pertaining to probability distributions are provided by the &lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;Distributions package&lt;/a&gt;.</source>
          <target state="translated">与概率分布有关的功能由&lt;a href=&quot;https://github.com/JuliaStats/Distributions.jl&quot;&gt;分布软件包提供&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f329adf9adf1ecc64a0f0d4d6a3d48dd49e69578" translate="yes" xml:space="preserve">
          <source>Functions that do not propagate &lt;code&gt;missing&lt;/code&gt; values can be made to do so by wrapping them in the &lt;code&gt;passmissing&lt;/code&gt; function provided by the &lt;a href=&quot;https://github.com/JuliaData/Missings.jl&quot;&gt;Missings.jl&lt;/a&gt; package. For example, &lt;code&gt;f(x)&lt;/code&gt; becomes &lt;code&gt;passmissing(f)(x)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07740f0b9c92a3b6637549532f0dfc491685de70" translate="yes" xml:space="preserve">
          <source>Functions that write to their arguments have names that end in &lt;code&gt;!&lt;/code&gt;. These are sometimes called &quot;mutating&quot; or &quot;in-place&quot; functions because they are intended to produce changes in their arguments after the function is called, not just return a value.</source>
          <target state="translated">写入其参数的函数的名称以 &lt;code&gt;!&lt;/code&gt; 结尾！。有时将它们称为&amp;ldquo;变异&amp;rdquo;或&amp;ldquo;就地&amp;rdquo;函数，因为它们旨在在调用函数后改变其参数，而不仅仅是返回值。</target>
        </trans-unit>
        <trans-unit id="9cba6354edf31323e29d861220b894beb53b62d4" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments are defined using a semicolon in the signature:</source>
          <target state="translated">带有关键字参数的函数在签名中使用分号来定义。</target>
        </trans-unit>
        <trans-unit id="bafd4b54282745a2bed1442852b73f4b3189a77a" translate="yes" xml:space="preserve">
          <source>Further Reading</source>
          <target state="translated">进一步阅读</target>
        </trans-unit>
        <trans-unit id="d740b078ded802ba0e2eac07618b79e4bfdcbb51" translate="yes" xml:space="preserve">
          <source>Furthermore, &quot;dotted&quot; updating operators like &lt;code&gt;a .+= b&lt;/code&gt; (or &lt;code&gt;@. a += b&lt;/code&gt;) are parsed as &lt;code&gt;a .= a .+ b&lt;/code&gt;, where &lt;code&gt;.=&lt;/code&gt; is a fused &lt;em&gt;in-place&lt;/em&gt; assignment operation (see the &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax documentation&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0132f20ae5d3a74b84246e40987da84635bfd3d0" translate="yes" xml:space="preserve">
          <source>Furthermore, &quot;dotted&quot; updating operators like &lt;code&gt;a .+= b&lt;/code&gt; (or &lt;code&gt;@. a += b&lt;/code&gt;) are parsed as &lt;code&gt;a .= a .+ b&lt;/code&gt;, where &lt;code&gt;.=&lt;/code&gt; is a fused &lt;em&gt;in-place&lt;/em&gt; assignment operation (see the &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax documentation&lt;/a&gt;).</source>
          <target state="translated">此外，像 &lt;code&gt;a .+= b&lt;/code&gt; （或 &lt;code&gt;@. a += b&lt;/code&gt; 。a + = b）这样的 &amp;ldquo;点状&amp;rdquo;更新运算符被解析为 &lt;code&gt;a .= a .+ b&lt;/code&gt; ，其中 &lt;code&gt;.=&lt;/code&gt; 是融合&lt;em&gt;的就地&lt;/em&gt;分配操作（请参见&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;点语法文档）&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="9d0dab03985e67ddbff313bf737b40f319ace224" translate="yes" xml:space="preserve">
          <source>Furthermore, the iterable object splatted into a function call need not be a tuple:</source>
          <target state="translated">此外,溅入函数调用的可迭代对象不需要是元组。</target>
        </trans-unit>
        <trans-unit id="047ca54032a1756c098d3bc1a941a0ed8e583df8" translate="yes" xml:space="preserve">
          <source>Future</source>
          <target state="translated">Future</target>
        </trans-unit>
        <trans-unit id="0e833ac5a09d0da4e04120e7544830f8a65151fd" translate="yes" xml:space="preserve">
          <source>G. W. Stewart, &quot;Rank Degeneracy&quot;, SIAM Journal on Scientific and Statistical Computing, 5(2), 1984, 403-413. &lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;doi:10.1137/0905030&lt;/a&gt;</source>
          <target state="translated">GW Stewart，&amp;ldquo;等级退化&amp;rdquo;，SIAM科学与统计计算杂志，5（2），1984，403-413。&lt;a href=&quot;http://epubs.siam.org/doi/abs/10.1137/0905030&quot;&gt;doi：10.1137 / 0905030&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99a3e18460e703b6b52b26b4155c66c3e3ba24bc" translate="yes" xml:space="preserve">
          <source>GC</source>
          <target state="translated">GC</target>
        </trans-unit>
        <trans-unit id="153d4c166a2f860e5ac33c697533af00d178259a" translate="yes" xml:space="preserve">
          <source>GC.@preserve</source>
          <target state="translated">GC.@preserve</target>
        </trans-unit>
        <trans-unit id="3897445415fe5ec5c17d947d2f396ecb73cfab7e" translate="yes" xml:space="preserve">
          <source>GC.enable()</source>
          <target state="translated">GC.enable()</target>
        </trans-unit>
        <trans-unit id="f7f51a07b89aa04e176b4dce9ba6e667279a4cac" translate="yes" xml:space="preserve">
          <source>GC.gc()</source>
          <target state="translated">GC.gc()</target>
        </trans-unit>
        <trans-unit id="dd04fdce0b5db2163f133667347720589a61611d" translate="yes" xml:space="preserve">
          <source>GMP.BigInt</source>
          <target state="translated">GMP.BigInt</target>
        </trans-unit>
        <trans-unit id="ec181f943ce9eb84bc41a51f14f715a4b73d4e15" translate="yes" xml:space="preserve">
          <source>GMP.BigInt()</source>
          <target state="translated">GMP.BigInt()</target>
        </trans-unit>
        <trans-unit id="1f1b07ba1d3f58af4c465921af5b16d96fd0bc35" translate="yes" xml:space="preserve">
          <source>GT</source>
          <target state="translated">GT</target>
        </trans-unit>
        <trans-unit id="f3b1d13cf7d8da8c19344c722b6886a02e91434d" translate="yes" xml:space="preserve">
          <source>Game Die</source>
          <target state="translated">游戏模具</target>
        </trans-unit>
        <trans-unit id="23e043a9ee4de0e7b0c73093401aa0bca44ab49b" translate="yes" xml:space="preserve">
          <source>Garbage Collection Safety</source>
          <target state="translated">垃圾收集安全</target>
        </trans-unit>
        <trans-unit id="d6d5b4be825ce665265510009390d4b69a148c2b" translate="yes" xml:space="preserve">
          <source>Garbage-collection handle for the return value from &lt;code&gt;@cfunction&lt;/code&gt; when the first argument is annotated with '$'. Like all &lt;code&gt;cfunction&lt;/code&gt; handles, it should be passed to &lt;code&gt;ccall&lt;/code&gt; as a &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, and will be converted automatically at the call site to the appropriate type.</source>
          <target state="translated">第一个参数用'$'注释时， &lt;code&gt;@cfunction&lt;/code&gt; 返回值的垃圾回收句柄。像所有 &lt;code&gt;cfunction&lt;/code&gt; 句柄一样，它应作为 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; 传递给 &lt;code&gt;ccall&lt;/code&gt; ，并将在调用站点自动转换为适当的类型。</target>
        </trans-unit>
        <trans-unit id="dbb8c00bae5bbda144f1736a9cba2314230cbae3" translate="yes" xml:space="preserve">
          <source>Gem Stone</source>
          <target state="translated">宝石</target>
        </trans-unit>
        <trans-unit id="ddba2c9277cd909b2d4fac91a3cc754a462c7a90" translate="yes" xml:space="preserve">
          <source>Gemini</source>
          <target state="translated">Gemini</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="9203a7a738516ae214b4ae47d8b7fd816429f200" translate="yes" xml:space="preserve">
          <source>General Collections</source>
          <target state="translated">一般收藏</target>
        </trans-unit>
        <trans-unit id="b87cf666cc00e115fb18674c6deb84af8b517c7f" translate="yes" xml:space="preserve">
          <source>General I/O</source>
          <target state="translated">一般I/O</target>
        </trans-unit>
        <trans-unit id="4979599c738b7850931480557307563f3cf52a2f" translate="yes" xml:space="preserve">
          <source>General Number Functions and Constants</source>
          <target state="translated">一般数字函数和常量</target>
        </trans-unit>
        <trans-unit id="6b7059d9b81b1f245d958405a414e29373725e72" translate="yes" xml:space="preserve">
          <source>General escaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">传统C和Unicode转义序列的常规转义。第一种形式返回转义的字符串，第二种形式将结果打印到 &lt;code&gt;io&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4e9dfb96c25a921933f55dcf7822775fb8e071eb" translate="yes" xml:space="preserve">
          <source>General exceptions can be raised using the functions:</source>
          <target state="translated">可以使用函数提出一般的异常。</target>
        </trans-unit>
        <trans-unit id="aa8e53d9ebff9d0979fd39b344364382458a81b6" translate="yes" xml:space="preserve">
          <source>General non-square</source>
          <target state="translated">一般非正方形</target>
        </trans-unit>
        <trans-unit id="07891976324532c807b79ec56fda0fc0b9da6708" translate="yes" xml:space="preserve">
          <source>General square</source>
          <target state="translated">一般广场</target>
        </trans-unit>
        <trans-unit id="1d3f6af2e9c4d5b2ed46f9e07478d485ceb20715" translate="yes" xml:space="preserve">
          <source>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;.</source>
          <target state="translated">传统C和Unicode转义序列的常规转义。第一种形式返回转义的字符串，第二种形式将结果打印到 &lt;code&gt;io&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8d4a5e7b244f7677a49086fc90992db4311d8da" translate="yes" xml:space="preserve">
          <source>General unescaping of traditional C and Unicode escape sequences. The first form returns the escaped string, the second prints the result to &lt;code&gt;io&lt;/code&gt;. The argument &lt;code&gt;keep&lt;/code&gt; specifies a collection of characters which (along with backlashes) are to be kept as they are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0285ea21d10ed4a7913ad2a66cb346f95bc9d78" translate="yes" xml:space="preserve">
          <source>Generalized SVD</source>
          <target state="translated">笼统的SVD</target>
        </trans-unit>
        <trans-unit id="57f4b7233f83ddd1853b6b2d05e4bb762f7fd0b4" translate="yes" xml:space="preserve">
          <source>Generalized Schur decomposition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d85331d4948d0ae34d7f8f8e070efd57ba16e64" translate="yes" xml:space="preserve">
          <source>Generalized linear models are provided by the &lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM package&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/JuliaStats/GLM.jl&quot;&gt;GLM软件包&lt;/a&gt;提供了广义线性模型。</target>
        </trans-unit>
        <trans-unit id="74e66c6cbf540d5ae8fbca755495f0306efa1594" translate="yes" xml:space="preserve">
          <source>Generalized spectral decomposition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad14a691ce38a290bae999d447b8c703f49ef6b" translate="yes" xml:space="preserve">
          <source>Generally, new types should implement &lt;a href=&quot;#Base.:&amp;lt;&quot;&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/a&gt; instead of this function, and rely on the fallback definition &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">通常，新类型应实现&lt;a href=&quot;#Base.:&amp;lt;&quot;&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;/a&gt;而不是此函数，并依靠后备定义 &lt;code&gt;&amp;gt;(x, y) = y &amp;lt; x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f33a08ad09d1f8b477ee12ea78ff5b8bbea276a6" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;BitArray&lt;/code&gt; of random boolean values.</source>
          <target state="translated">生成随机布尔值的 &lt;code&gt;BitArray&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fd53bfe967151037d3aab623a3c39dc68a9e6a07" translate="yes" xml:space="preserve">
          <source>Generate a C-callable function pointer from the Julia function &lt;code&gt;callable&lt;/code&gt; for the given type signature. To pass the return value to a &lt;code&gt;ccall&lt;/code&gt;, use the argument type &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; in the signature.</source>
          <target state="translated">从 &lt;code&gt;callable&lt;/code&gt; 为给定类型签名调用的Julia函数中生成C调用函数指针。要将返回值传递给 &lt;code&gt;ccall&lt;/code&gt; ，请在签名中使用参数类型 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="464b58935d4b4855a4eca20151ebbc5055b2f194" translate="yes" xml:space="preserve">
          <source>Generate a normally-distributed random number of type &lt;code&gt;T&lt;/code&gt; with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default), and their &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution of variance 1 (corresponding to real and imaginary part having independent normal distribution with mean zero and variance &lt;code&gt;1/2&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e2ff826d751563b9e50313fe308bc12b868933" translate="yes" xml:space="preserve">
          <source>Generate a normally-distributed random number of type &lt;code&gt;T&lt;/code&gt; with mean 0 and standard deviation 1. Optionally generate an array of normally-distributed random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default), and their &lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; counterparts. When the type argument is complex, the values are drawn from the circularly symmetric complex normal distribution.</source>
          <target state="translated">生成均值为0和标准差为1 的类型为 &lt;code&gt;T&lt;/code&gt; 的正态分布随机数。（可选）生成一个正态分布随机数数组。目前， &lt;code&gt;Base&lt;/code&gt; 模块为&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;类型（默认值）及其对应的&lt;a href=&quot;../../base/numbers/index#Base.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt;提供了一种实现。当类型实参为复数时，这些值是从圆对称复数正态分布中得出的。</target>
        </trans-unit>
        <trans-unit id="d735a31a4d0a7d19a36da47899d779f788bda4b7" translate="yes" xml:space="preserve">
          <source>Generate a random number of type &lt;code&gt;T&lt;/code&gt; according to the exponential distribution with scale 1. Optionally generate an array of such random numbers. The &lt;code&gt;Base&lt;/code&gt; module currently provides an implementation for the types &lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (the default).</source>
          <target state="translated">根据刻度为1的指数分布生成类型 &lt;code&gt;T&lt;/code&gt; 的随机数。可选地，生成此类随机数的数组。的 &lt;code&gt;Base&lt;/code&gt; 模块目前提供的各类的实施&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;，和&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;（缺省值）。</target>
        </trans-unit>
        <trans-unit id="a537f03cb21656031e0fd8ad6fc35f3473173ca5" translate="yes" xml:space="preserve">
          <source>Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed due to the very remote posibility of two simultaneous calls to &lt;code&gt;tempname&lt;/code&gt; generating the same file name. The name is guaranteed to differ from all files already existing at the time of the call to &lt;code&gt;tempname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd80a1d3f890e93d6b1dc16c37a28152669461b" translate="yes" xml:space="preserve">
          <source>Generate a temporary file path. This function only returns a path; no file is created. The path is likely to be unique, but this cannot be guaranteed.</source>
          <target state="translated">生成一个临时文件路径。这个函数只返回一个路径,不创建文件。路径可能是唯一的,但不能保证。</target>
        </trans-unit>
        <trans-unit id="3e42af03cf7e4fa9b19d5375dcdec38dc109c9bc" translate="yes" xml:space="preserve">
          <source>Generated functions</source>
          <target state="translated">生成的功能</target>
        </trans-unit>
        <trans-unit id="cba590af8f8ae8e32e66535964125d2756a08bf3" translate="yes" xml:space="preserve">
          <source>Generated functions are only permitted to call functions that were defined &lt;em&gt;before&lt;/em&gt; the definition of the generated function. (Failure to follow this may result in getting &lt;code&gt;MethodErrors&lt;/code&gt; referring to functions from a future world-age.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40080cfd55d586fc4f5401be4bb1834fea88976c" translate="yes" xml:space="preserve">
          <source>Generated functions can achieve high efficiency at run time, but come with a compile time cost: a new function body must be generated for every combination of concrete argument types. Typically, Julia is able to compile &quot;generic&quot; versions of functions that will work for any arguments, but with generated functions this is impossible. This means that programs making heavy use of generated functions might be impossible to statically compile.</source>
          <target state="translated">生成函数可以在运行时实现高效率,但也有编译时间成本:每一个具体参数类型的组合都必须生成一个新的函数体。通常情况下,Julia能够编译 &quot;通用 &quot;版本的函数,这些函数将适用于任何参数,但对于生成函数,这是不可能的。这意味着大量使用生成函数的程序可能无法静态编译。</target>
        </trans-unit>
        <trans-unit id="503406d41ab4e8215a281c0d73cf5e1840925953" translate="yes" xml:space="preserve">
          <source>Generated functions must not &lt;em&gt;mutate&lt;/em&gt; or &lt;em&gt;observe&lt;/em&gt; any non-constant global state (including, for example, IO, locks, non-local dictionaries, or using &lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt;&lt;code&gt;hasmethod&lt;/code&gt;&lt;/a&gt;). This means they can only read global constants, and cannot have any side effects. In other words, they must be completely pure. Due to an implementation limitation, this also means that they currently cannot define a closure or generator.</source>
          <target state="translated">生成的函数不得&lt;em&gt;变异&lt;/em&gt;或&lt;em&gt;观察&lt;/em&gt;任何非恒定的全局状态（例如，包括IO，锁，非本地字典或使用&lt;a href=&quot;../../base/base/index#Base.hasmethod&quot;&gt; &lt;code&gt;hasmethod&lt;/code&gt; &lt;/a&gt;）。这意味着它们只能读取全局常量，而不会产生任何副作用。换句话说，它们必须是完全纯净的。由于实施限制，这还意味着它们当前无法定义闭包或生成器。</target>
        </trans-unit>
        <trans-unit id="3ef0ab87b9316844c35d99faef219c9c7322d80c" translate="yes" xml:space="preserve">
          <source>Generated values can be filtered using the &lt;code&gt;if&lt;/code&gt; keyword:</source>
          <target state="translated">可以使用 &lt;code&gt;if&lt;/code&gt; 关键字过滤生成的值：</target>
        </trans-unit>
        <trans-unit id="43a3b60a1f43668fa7df03ea6999eb9005534d03" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;A&lt;/code&gt; and removes stored numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;rowval&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">生成 &lt;code&gt;A&lt;/code&gt; 的副本，并从该副本中删除存储的数字零，并可以选择在 &lt;code&gt;trim&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时修剪结果的 &lt;code&gt;rowval&lt;/code&gt; 和 &lt;code&gt;nzval&lt;/code&gt; 数组中的多余空间。</target>
        </trans-unit>
        <trans-unit id="eae6d1575ffa43a8d9796f9233f972a39752f20b" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;A&lt;/code&gt; and removes stored numerical zeros from that copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8200a561dd1fd6d9a2571a09a8c0833fd591d2" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;x&lt;/code&gt; and removes numerical zeros from that copy, optionally trimming excess space from the result's &lt;code&gt;nzind&lt;/code&gt; and &lt;code&gt;nzval&lt;/code&gt; arrays when &lt;code&gt;trim&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">生成 &lt;code&gt;x&lt;/code&gt; 的副本，并从该副本中删除数字零，当 &lt;code&gt;trim&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; 时，可以选择修剪结果的 &lt;code&gt;nzind&lt;/code&gt; 和 &lt;code&gt;nzval&lt;/code&gt; 数组中的多余空间。</target>
        </trans-unit>
        <trans-unit id="45dac0453bb6ba7f95de954c9e7abbe105892f30" translate="yes" xml:space="preserve">
          <source>Generates a copy of &lt;code&gt;x&lt;/code&gt; and removes numerical zeros from that copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d35e347a9e9f11c97762e02cb3817fdf6492b95" translate="yes" xml:space="preserve">
          <source>Generates a gensym symbol for a variable. For example, &lt;code&gt;@gensym x y&lt;/code&gt; is transformed into &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt;.</source>
          <target state="translated">为变量生成gensym符号。例如， &lt;code&gt;@gensym x y&lt;/code&gt; 转换为 &lt;code&gt;x = gensym(&quot;x&quot;); y = gensym(&quot;y&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="82624d1ced08378811cc12e5b9bb3247c76bde71" translate="yes" xml:space="preserve">
          <source>Generates a symbol which will not conflict with other variable names.</source>
          <target state="translated">生成一个与其他变量名不冲突的符号。</target>
        </trans-unit>
        <trans-unit id="6493dacd8d9340030628eff5048e31c32e36106f" translate="yes" xml:space="preserve">
          <source>Generates a version 1 (time-based) universally unique identifier (UUID), as specified by RFC 4122. Note that the Node ID is randomly generated (does not identify the host) according to section 4.5 of the RFC.</source>
          <target state="translated">生成RFC 4122规定的版本1(基于时间)的通用唯一标识符(UUID)。请注意,根据RFC的4.5节,节点ID是随机生成的(不识别主机)。</target>
        </trans-unit>
        <trans-unit id="5c0ffbf6fa6cd08065c3fd1e20d39e7262ac9916" translate="yes" xml:space="preserve">
          <source>Generates a version 4 (random or pseudo-random) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">生成RFC 4122规定的第4版(随机或伪随机)通用唯一标识符(UUID)。</target>
        </trans-unit>
        <trans-unit id="6864e40d6120ff94e92379a41401cda33ec26eb1" translate="yes" xml:space="preserve">
          <source>Generates a version 5 (namespace and domain-based) universally unique identifier (UUID), as specified by RFC 4122.</source>
          <target state="translated">生成RFC 4122指定的第5版(基于命名空间和域的)通用唯一标识符(UUID)。</target>
        </trans-unit>
        <trans-unit id="070600dec2910fb2959b8379d05bbc160f7ec7de" translate="yes" xml:space="preserve">
          <source>Generating random values for some distributions may involve various trade-offs. &lt;em&gt;Pre-computed&lt;/em&gt; values, such as an &lt;a href=&quot;https://en.wikipedia.org/wiki/Alias_method&quot;&gt;alias table&lt;/a&gt; for discrete distributions, or &lt;a href=&quot;https://en.wikipedia.org/wiki/Rejection_sampling&quot;&gt;&amp;ldquo;squeezing&amp;rdquo; functions&lt;/a&gt; for univariate distributions, can speed up sampling considerably. How much information should be pre-computed can depend on the number of values we plan to draw from a distribution. Also, some random number generators can have certain properties that various algorithms may want to exploit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ad5eda3014502203f1f1c9f4f8ad8b0addc8bb" translate="yes" xml:space="preserve">
          <source>Generating random values of custom types</source>
          <target state="translated">生成自定义类型的随机值</target>
        </trans-unit>
        <trans-unit id="ea6d79a7c35cdb9d37f8d907393ca6d0663b71e9" translate="yes" xml:space="preserve">
          <source>Generating values for an &lt;code&gt;AbstractFloat&lt;/code&gt; type</source>
          <target state="translated">为 &lt;code&gt;AbstractFloat&lt;/code&gt; 类型生成值</target>
        </trans-unit>
        <trans-unit id="79059f17dfecc212b29a403a6fe768eae1bb1610" translate="yes" xml:space="preserve">
          <source>Generating values from a collection</source>
          <target state="translated">从一个集合中生成数值</target>
        </trans-unit>
        <trans-unit id="5f32399dda528ab0f4979390ae10b103edb83e67" translate="yes" xml:space="preserve">
          <source>Generating values from a type</source>
          <target state="translated">从类型中生成值</target>
        </trans-unit>
        <trans-unit id="217dffa188c85186f3dde4d07c906c09c058f848" translate="yes" xml:space="preserve">
          <source>Generator Expressions</source>
          <target state="translated">生成器表达式</target>
        </trans-unit>
        <trans-unit id="111436dce43eef86f4f13a06226e540548b10b69" translate="yes" xml:space="preserve">
          <source>Generators (creation and seeding)</source>
          <target state="translated">生成器(创建和播种)</target>
        </trans-unit>
        <trans-unit id="23abb36aa0bc1408666d7f17a0f4dc7b6c92131a" translate="yes" xml:space="preserve">
          <source>Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function. For example, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; captures the three variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; from the enclosing scope. Captured variables can present performance challenges; see &lt;a href=&quot;../performance-tips/index#man-performance-captured&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab25cfdc66be945181ae90276749fb192703ddc0" translate="yes" xml:space="preserve">
          <source>Generators are implemented via inner functions. Just like inner functions used elsewhere in the language, variables from the enclosing scope can be &quot;captured&quot; in the inner function. For example, &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; captures the three variables &lt;code&gt;p&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; from the enclosing scope. Captured variables can present performance challenges; see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;performance tips&lt;/a&gt;.</source>
          <target state="translated">生成器通过内部函数实现。就像语言中其他地方使用的内部函数一样，可以将包围范围的变量&amp;ldquo;捕获&amp;rdquo;到内部函数中。例如， &lt;code&gt;sum(p[i] - q[i] for i=1:n)&lt;/code&gt; 从封闭范围中捕获三个变量 &lt;code&gt;p&lt;/code&gt; ， &lt;code&gt;q&lt;/code&gt; 和 &lt;code&gt;n&lt;/code&gt; 。捕获的变量可能会带来性能挑战；查看&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;性能提示&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="83082f46072d254fd933bf6e78414552f2b12960" translate="yes" xml:space="preserve">
          <source>Generic Functions</source>
          <target state="translated">通用函数</target>
        </trans-unit>
        <trans-unit id="2654c4b9018fcc37437c59923d4ac1eabf19c850" translate="yes" xml:space="preserve">
          <source>Generic equality operator. Falls back to &lt;a href=&quot;../base/index#Core.:===&quot;&gt;&lt;code&gt;===&lt;/code&gt;&lt;/a&gt;. Should be implemented for all types with a notion of equality, based on the abstract value that an instance represents. For example, all numeric types are compared by numeric value, ignoring type. Strings are compared as sequences of characters, ignoring encoding. For collections, &lt;code&gt;==&lt;/code&gt; is generally called recursively on all contents, though other properties (like the shape for arrays) may also be taken into account.</source>
          <target state="translated">泛型相等运算符。回落到&lt;a href=&quot;../base/index#Core.:===&quot;&gt; &lt;code&gt;===&lt;/code&gt; &lt;/a&gt;。应该基于实例代表的抽象值，为所有类型都具有相等性的概念实现。例如，所有数字类型均按数字值进行比较，而忽略类型。将字符串作为字符序列进行比较，而忽略编码。对于集合，通常会在所有内容上递归调用 &lt;code&gt;==&lt;/code&gt; ，尽管也可以考虑其他属性（例如数组的形状）。</target>
        </trans-unit>
        <trans-unit id="a247769c311d71434e7dbab7ffa2c58b32221569" translate="yes" xml:space="preserve">
          <source>Generic error type. The error message, in the &lt;code&gt;.msg&lt;/code&gt; field, may provide more specific details.</source>
          <target state="translated">通用错误类型。 &lt;code&gt;.msg&lt;/code&gt; 字段中的错误消息可能会提供更多特定的详细信息。</target>
        </trans-unit>
        <trans-unit id="0a2cbe8ef5a6182effacad0728af04d3466e9419" translate="yes" xml:space="preserve">
          <source>Generically sized uniform scaling operator defined as a scalar times the identity operator, &lt;code&gt;&amp;lambda;*I&lt;/code&gt;. See also &lt;a href=&quot;#LinearAlgebra.I&quot;&gt;&lt;code&gt;I&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">定义为标量倍恒等算子，一般尺寸的均匀缩放操作者 &lt;code&gt;&amp;lambda;*I&lt;/code&gt; 。另见&lt;a href=&quot;#LinearAlgebra.I&quot;&gt; &lt;code&gt;I&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="e7021447d5c6f5d07882ea34fcf74ffd494b65a7" translate="yes" xml:space="preserve">
          <source>Geometric Proportion</source>
          <target state="translated">几何比例</target>
        </trans-unit>
        <trans-unit id="e505f741dc44890868c87aa48f3d8916c6fb0128" translate="yes" xml:space="preserve">
          <source>Geometrically Equal To</source>
          <target state="translated">在几何上等于</target>
        </trans-unit>
        <trans-unit id="f64b845181c47fc7995221a47eaadce47af6bcc8" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To</source>
          <target state="translated">在几何上等同于</target>
        </trans-unit>
        <trans-unit id="30404c5812bd3cd0bc1e26c11cfbb33861e4d141" translate="yes" xml:space="preserve">
          <source>Geometrically Equivalent To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">几何学上等同于+组合长实心叠加/无间隔长斜线叠加。</target>
        </trans-unit>
        <trans-unit id="ea2ac5cf7c4e856204e6a41aeaaa0b3dd4ef2ab5" translate="yes" xml:space="preserve">
          <source>Get Julia's process ID.</source>
          <target state="translated">获取Julia的进程ID。</target>
        </trans-unit>
        <trans-unit id="76117157c574ac5727a236f6277b1450a47c5f21" translate="yes" xml:space="preserve">
          <source>Get a backtrace object for the current program point.</source>
          <target state="translated">获取当前程序点的回溯对象。</target>
        </trans-unit>
        <trans-unit id="6245e1b22dd874707de430f7178865b9a33deacf" translate="yes" xml:space="preserve">
          <source>Get a hash value for &lt;code&gt;x&lt;/code&gt; based on object identity. &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; if &lt;code&gt;x === y&lt;/code&gt;.</source>
          <target state="translated">根据对象标识获取 &lt;code&gt;x&lt;/code&gt; 的哈希值。如果 &lt;code&gt;x === y&lt;/code&gt; 则 &lt;code&gt;objectid(x)==objectid(y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="594cb8bf35cce2c570e740ff46837e8b661e81ff" translate="yes" xml:space="preserve">
          <source>Get a list of all reference names in the &lt;code&gt;repo&lt;/code&gt; repository.</source>
          <target state="translated">获取 &lt;code&gt;repo&lt;/code&gt; 存储库中所有参考名称的列表。</target>
        </trans-unit>
        <trans-unit id="edea7d0cabb9a933daebe03151b03bacc57f2132" translate="yes" xml:space="preserve">
          <source>Get a list of all tags in the git repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">获取git仓库 &lt;code&gt;repo&lt;/code&gt; 中所有标签的列表。</target>
        </trans-unit>
        <trans-unit id="c83b8077da01523efd9ec95df9552f34eef56509" translate="yes" xml:space="preserve">
          <source>Get a module's enclosing &lt;code&gt;Module&lt;/code&gt;. &lt;code&gt;Main&lt;/code&gt; is its own parent.</source>
          <target state="translated">获取模块的封闭 &lt;code&gt;Module&lt;/code&gt; 。 &lt;code&gt;Main&lt;/code&gt; 是自己的父母。</target>
        </trans-unit>
        <trans-unit id="91aa8a1066c0cf259f10453272965a98317015dc" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the first &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">获取一个由 &lt;code&gt;s&lt;/code&gt; 的前 &lt;code&gt;n&lt;/code&gt; 个字符组成的字符串。</target>
        </trans-unit>
        <trans-unit id="a14f2cfc2cb6c1c852e03fd6e4a706f0a47df06c" translate="yes" xml:space="preserve">
          <source>Get a string consisting of the last &lt;code&gt;n&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">获取一个由 &lt;code&gt;s&lt;/code&gt; 的后 &lt;code&gt;n&lt;/code&gt; 个字符组成的字符串。</target>
        </trans-unit>
        <trans-unit id="3372d98da97932978011accfa92cc350dd85fc43" translate="yes" xml:space="preserve">
          <source>Get a tuple or a vector of the properties (&lt;code&gt;x.property&lt;/code&gt;) of an object &lt;code&gt;x&lt;/code&gt;. This is typically the same as &lt;a href=&quot;#Base.fieldnames&quot;&gt;&lt;code&gt;fieldnames(typeof(x))&lt;/code&gt;&lt;/a&gt;, but types that overload &lt;a href=&quot;#Base.getproperty&quot;&gt;&lt;code&gt;getproperty&lt;/code&gt;&lt;/a&gt; should generally overload &lt;code&gt;propertynames&lt;/code&gt; as well to get the properties of an instance of the type.</source>
          <target state="translated">获取对象 &lt;code&gt;x&lt;/code&gt; 的属性（ &lt;code&gt;x.property&lt;/code&gt; ）的元组或向量。这通常与&lt;a href=&quot;#Base.fieldnames&quot;&gt; &lt;code&gt;fieldnames(typeof(x))&lt;/code&gt; 相同&lt;/a&gt;，但是重载&lt;a href=&quot;#Base.getproperty&quot;&gt; &lt;code&gt;getproperty&lt;/code&gt; 的&lt;/a&gt;类型通常也应重载 &lt;code&gt;propertynames&lt;/code&gt; ，以获取该类型实例的属性。</target>
        </trans-unit>
        <trans-unit id="42f453edc0370fb274422ead5407c2776b31db1f" translate="yes" xml:space="preserve">
          <source>Get a tuple with the names of the fields of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">获取具有 &lt;code&gt;DataType&lt;/code&gt; 字段名称的元组。</target>
        </trans-unit>
        <trans-unit id="d530106390fd810b016b6212bad35ad44f20a8f4" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine of the specified type. Throws if no addresses of the specified type are available.</source>
          <target state="translated">获取指定类型的本地机器的IP地址。如果没有指定类型的地址,则抛出。</target>
        </trans-unit>
        <trans-unit id="7cad9add4d27400ccccd1e83a0b5fe65f627675d" translate="yes" xml:space="preserve">
          <source>Get an IP address of the local machine, preferring IPv4 over IPv6. Throws if no addresses are available.</source>
          <target state="translated">获取本地机器的IP地址,优先选择IPv4而不是IPv6。如果没有地址,则抛出。</target>
        </trans-unit>
        <trans-unit id="d1b1f967961007a8e3404abb4f0fb2c9b3d00448" translate="yes" xml:space="preserve">
          <source>Get an array of the names exported by a &lt;code&gt;Module&lt;/code&gt;, excluding deprecated names. If &lt;code&gt;all&lt;/code&gt; is true, then the list also includes non-exported names defined in the module, deprecated names, and compiler-generated names. If &lt;code&gt;imported&lt;/code&gt; is true, then names explicitly imported from other modules are also included.</source>
          <target state="translated">获取由 &lt;code&gt;Module&lt;/code&gt; 导出的名称的数组，不包括不建议使用的名称。如果 &lt;code&gt;all&lt;/code&gt; 为真，则该列表还包括模块中定义的未导出名称，不建议使用的名称以及编译器生成的名称。如果 &lt;code&gt;imported&lt;/code&gt; 为true，那么还将包括从其他模块显式导入的名称。</target>
        </trans-unit>
        <trans-unit id="171cab21a362e3fe558e803f2cb2a0d2a8e62a11" translate="yes" xml:space="preserve">
          <source>Get the &lt;code&gt;Module&lt;/code&gt; of the toplevel eval, which is the &lt;code&gt;Module&lt;/code&gt; code is currently being read from.</source>
          <target state="translated">获取 &lt;code&gt;Module&lt;/code&gt; 的顶层EVAL，它是 &lt;code&gt;Module&lt;/code&gt; 的代码当前正在读出。</target>
        </trans-unit>
        <trans-unit id="7881586bad23ccbb959e0086fba3cebe29d398b8" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;fetch&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to fetch from.</source>
          <target state="translated">获取指定 &lt;code&gt;rmt&lt;/code&gt; 的&lt;em&gt;获取&lt;/em&gt;引用规范。这些refspec包含有关要从哪个分支获取的信息。</target>
        </trans-unit>
        <trans-unit id="f2abefd55e48cb868afd9b2bbc8365ad10b4fa4f" translate="yes" xml:space="preserve">
          <source>Get the &lt;em&gt;push&lt;/em&gt; refspecs for the specified &lt;code&gt;rmt&lt;/code&gt;. These refspecs contain information about which branch(es) to push to.</source>
          <target state="translated">获取指定 &lt;code&gt;rmt&lt;/code&gt; 的&lt;em&gt;push&lt;/em&gt; refspecs 。这些refspec包含有关要推送到哪个分支的信息。</target>
        </trans-unit>
        <trans-unit id="0ec8068370cc3ffbb8329c71ce1fa5a1af831971" translate="yes" xml:space="preserve">
          <source>Get the ID number of the current thread of execution. The master thread has ID &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">获取当前执行线程的ID号。主线程的ID为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="899b97d6f0cff7934c3aa84ef79f50d77403aeb3" translate="yes" xml:space="preserve">
          <source>Get the IP address and port of the remote endpoint that the given socket is connected to. Valid only for connected TCP sockets.</source>
          <target state="translated">获取给定套接字连接的远程端点的IP地址和端口。仅对连接的TCP套接字有效。</target>
        </trans-unit>
        <trans-unit id="b30337efd6e1ddf333502df0ba154f1bbe883302" translate="yes" xml:space="preserve">
          <source>Get the IP address and port that the given socket is bound to.</source>
          <target state="translated">获取给定套接字绑定的IP地址和端口。</target>
        </trans-unit>
        <trans-unit id="ae34bdec6f00934e072471fe83b1ec1bb0253d9e" translate="yes" xml:space="preserve">
          <source>Get the IP addresses of the local machine of the specified type.</source>
          <target state="translated">获取指定类型的本地机器的IP地址。</target>
        </trans-unit>
        <trans-unit id="5f0191f319b101f536ac6e663f42d85f39f5dc3e" translate="yes" xml:space="preserve">
          <source>Get the IP addresses of the local machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e3f3bd81b00cd5fdff2163bfb439bea6bf2f6a" translate="yes" xml:space="preserve">
          <source>Get the IPv4 addresses of the local machine.</source>
          <target state="translated">获取本地机器的IPv4地址。</target>
        </trans-unit>
        <trans-unit id="fc0c58665e06f4bcac50a3a051a380e40687f694" translate="yes" xml:space="preserve">
          <source>Get the additive identity element for the type of &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt; can also specify the type itself).</source>
          <target state="translated">获取 &lt;code&gt;x&lt;/code&gt; 类型的加法标识元素（ &lt;code&gt;x&lt;/code&gt; 也可以指定类型本身）。</target>
        </trans-unit>
        <trans-unit id="13d05d3446c1b045371ca3c580a406fe6efa3a85" translate="yes" xml:space="preserve">
          <source>Get the backtrace of the current exception, for use within &lt;code&gt;catch&lt;/code&gt; blocks.</source>
          <target state="translated">获取当前异常的回溯，以在 &lt;code&gt;catch&lt;/code&gt; 块中使用。</target>
        </trans-unit>
        <trans-unit id="d0b515694c2e31069f75a4341701ebdddc0dbcfa" translate="yes" xml:space="preserve">
          <source>Get the child process ID, if it still exists.</source>
          <target state="translated">获取子进程ID,如果它仍然存在的话。</target>
        </trans-unit>
        <trans-unit id="b7046c13174456af8138867bb2456e8e9106c14f" translate="yes" xml:space="preserve">
          <source>Get the concrete type of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">获得 &lt;code&gt;x&lt;/code&gt; 的具体类型。</target>
        </trans-unit>
        <trans-unit id="47ebb15e57ce473b474a7f913ff4aa9d19236677" translate="yes" xml:space="preserve">
          <source>Get the current floating point rounding mode for type &lt;code&gt;T&lt;/code&gt;, controlling the rounding of basic arithmetic functions (&lt;a href=&quot;../math/index#Base.:+&quot;&gt;&lt;code&gt;+&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;a href=&quot;../math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;sqrt&lt;/code&gt;) and type conversion.</source>
          <target state="translated">获取类型 &lt;code&gt;T&lt;/code&gt; 的当前浮点舍入模式，控制基本算术函数（&lt;a href=&quot;../math/index#Base.:+&quot;&gt; &lt;code&gt;+&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ，&lt;a href=&quot;../math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;sqrt&lt;/code&gt; ）的舍入并进行类型转换。</target>
        </trans-unit>
        <trans-unit id="054e0f64d6af85ef39cd5689d518feb6140528b2" translate="yes" xml:space="preserve">
          <source>Get the current position of a stream.</source>
          <target state="translated">获取一个流的当前位置。</target>
        </trans-unit>
        <trans-unit id="7d101e5841a77867eef23ee238263d38f724a6f3" translate="yes" xml:space="preserve">
          <source>Get the current working directory.</source>
          <target state="translated">获取当前工作目录。</target>
        </trans-unit>
        <trans-unit id="b150736a9f570c696c7e152a5f442d80d1bfe707" translate="yes" xml:space="preserve">
          <source>Get the currently running &lt;a href=&quot;#Core.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取当前正在运行的&lt;a href=&quot;#Core.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="307991aa1f7f375be076c27a6b5e16a8e43f1f24" translate="yes" xml:space="preserve">
          <source>Get the directory part of a path. Trailing characters ('/' or '\') in the path are counted as part of the path.</source>
          <target state="translated">获取路径中的目录部分。路径中的尾部字符('/'或'/')被视为路径的一部分。</target>
        </trans-unit>
        <trans-unit id="15803f5611fdfd7a4570ea4b6299230e231b89c3" translate="yes" xml:space="preserve">
          <source>Get the exponent of a normalized floating-point number.</source>
          <target state="translated">获取归一化浮点数的指数。</target>
        </trans-unit>
        <trans-unit id="428d1e51e8fd8658370395752d8d28b03956207a" translate="yes" xml:space="preserve">
          <source>Get the fetch URL of a remote git repository.</source>
          <target state="translated">获取远程 git 仓库的 fetch URL。</target>
        </trans-unit>
        <trans-unit id="6395adf311f39b7041b3bc31800f3ac3ac69f04a" translate="yes" xml:space="preserve">
          <source>Get the file name part of a path.</source>
          <target state="translated">获取路径中的文件名部分。</target>
        </trans-unit>
        <trans-unit id="45d031a98e3d7988439346e5f12753ad44f6564c" translate="yes" xml:space="preserve">
          <source>Get the first element of an iterable collection. Return the start point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">获取可迭代集合的第一个元素。返回&lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; 的&lt;/a&gt;起点，即使它为空。</target>
        </trans-unit>
        <trans-unit id="e2a67c4001b5073d3effff6ee96ac8c41fc3f469" translate="yes" xml:space="preserve">
          <source>Get the full path of the library &lt;code&gt;libname&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803a6a556ee1107f53d846bba76956752d4f95be" translate="yes" xml:space="preserve">
          <source>Get the fully-qualified name of a module as a tuple of symbols. For example,</source>
          <target state="translated">以符号元组的形式获取模块的全称。例如:</target>
        </trans-unit>
        <trans-unit id="9fe2dd6fafde9402b9bebe656d7e76ff3412ff6a" translate="yes" xml:space="preserve">
          <source>Get the git object to which &lt;code&gt;te&lt;/code&gt; refers and return it as its actual type (the type &lt;a href=&quot;#LibGit2.entrytype&quot;&gt;&lt;code&gt;entrytype&lt;/code&gt;&lt;/a&gt; would show), for instance a &lt;code&gt;GitBlob&lt;/code&gt; or &lt;code&gt;GitTag&lt;/code&gt;.</source>
          <target state="translated">获取 &lt;code&gt;te&lt;/code&gt; 所引用的git对象，并将其返回为其实际类型（类型为&lt;a href=&quot;#LibGit2.entrytype&quot;&gt; &lt;code&gt;entrytype&lt;/code&gt; &lt;/a&gt;），例如 &lt;code&gt;GitBlob&lt;/code&gt; 或 &lt;code&gt;GitTag&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="353f9fc88dc058135091370ad6a5d9c59fcfda6e" translate="yes" xml:space="preserve">
          <source>Get the id of the current process.</source>
          <target state="translated">获取当前进程的id。</target>
        </trans-unit>
        <trans-unit id="4e1a5fc780c8cf7e7bc238f6885dd2ba9bd5e31b" translate="yes" xml:space="preserve">
          <source>Get the key type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取字典类型的键类型。行为与&lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;类似。</target>
        </trans-unit>
        <trans-unit id="7db9e0d4b309f243e7497e360f841540e11cc1fa" translate="yes" xml:space="preserve">
          <source>Get the last element of an ordered collection, if it can be computed in O(1) time. This is accomplished by calling &lt;a href=&quot;#Base.lastindex&quot;&gt;&lt;code&gt;lastindex&lt;/code&gt;&lt;/a&gt; to get the last index. Return the end point of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; even if it is empty.</source>
          <target state="translated">如果可以在O（1）时间中计算出有序集合的最后一个元素，则获取它。这是通过调用&lt;a href=&quot;#Base.lastindex&quot;&gt; &lt;code&gt;lastindex&lt;/code&gt; &lt;/a&gt;获取最后的索引来完成的。返回&lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt;的终点，即使它为空。</target>
        </trans-unit>
        <trans-unit id="acd04aae132c80a71e1f513a908b2702371aa23c" translate="yes" xml:space="preserve">
          <source>Get the local machine's host name.</source>
          <target state="translated">获取本地机器的主机名。</target>
        </trans-unit>
        <trans-unit id="7880b6703d5b76a9fbb2e0506acfbba24be95f11" translate="yes" xml:space="preserve">
          <source>Get the memory address of a Julia object as a &lt;code&gt;Ptr&lt;/code&gt;. The existence of the resulting &lt;code&gt;Ptr&lt;/code&gt; will not protect the object from garbage collection, so you must ensure that the object remains referenced for the whole time that the &lt;code&gt;Ptr&lt;/code&gt; will be used.</source>
          <target state="translated">获取一个Julia对象的内存地址作为 &lt;code&gt;Ptr&lt;/code&gt; 。结果 &lt;code&gt;Ptr&lt;/code&gt; 的存在不会保护对象免受垃圾回收，因此您必须确保在使用 &lt;code&gt;Ptr&lt;/code&gt; 的整个过程中始终保持对对象的引用。</target>
        </trans-unit>
        <trans-unit id="563766b2618b2d015ed0e9c3d29a5e7becea72bb" translate="yes" xml:space="preserve">
          <source>Get the name of a (potentially &lt;code&gt;UnionAll&lt;/code&gt;-wrapped) &lt;code&gt;DataType&lt;/code&gt; (without its parent module) as a symbol.</source>
          <target state="translated">获取（可能是 &lt;code&gt;UnionAll&lt;/code&gt; 包装的） &lt;code&gt;DataType&lt;/code&gt; 的名称（不带其父模块）作为符号。</target>
        </trans-unit>
        <trans-unit id="52de91388eb956065955884b6eac39cce6e61088" translate="yes" xml:space="preserve">
          <source>Get the name of a &lt;code&gt;Module&lt;/code&gt; as a &lt;a href=&quot;#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取 &lt;code&gt;Module&lt;/code&gt; 的名称作为&lt;a href=&quot;#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="d8a8ebbac78211cc23fd2af9d0c3c21bb5d703fa" translate="yes" xml:space="preserve">
          <source>Get the name of a generic &lt;code&gt;Function&lt;/code&gt; as a symbol, or &lt;code&gt;:anonymous&lt;/code&gt;.</source>
          <target state="translated">获取通用 &lt;code&gt;Function&lt;/code&gt; 的名称作为符号，或 &lt;code&gt;:anonymous&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="64e061910a8b5067e4b872f11bbe2bcd37fe4b98" translate="yes" xml:space="preserve">
          <source>Get the name of a generic &lt;code&gt;Function&lt;/code&gt; as a symbol. For anonymous functions, this is a compiler-generated name. For explicitly-declared subtypes of &lt;code&gt;Function&lt;/code&gt;, it is the name of the function's type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5308e8edde6c7f90f89dc8b80d1be8f9e4aed1b" translate="yes" xml:space="preserve">
          <source>Get the name of a remote repository, for instance &lt;code&gt;&quot;origin&quot;&lt;/code&gt;. If the remote is anonymous (see &lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt;&lt;code&gt;GitRemoteAnon&lt;/code&gt;&lt;/a&gt;) the name will be an empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">获取远程存储库的名称，例如 &lt;code&gt;&quot;origin&quot;&lt;/code&gt; 。如果遥控器是匿名的（请参阅&lt;a href=&quot;#LibGit2.GitRemoteAnon&quot;&gt; &lt;code&gt;GitRemoteAnon&lt;/code&gt; &lt;/a&gt;），则名称将为空字符串 &lt;code&gt;&quot;&quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d9cf8794c830b5b5477bd4dd5127e438a0a336f9" translate="yes" xml:space="preserve">
          <source>Get the name of field &lt;code&gt;i&lt;/code&gt; of a &lt;code&gt;DataType&lt;/code&gt;.</source>
          <target state="translated">获取字段的名称 &lt;code&gt;i&lt;/code&gt; 一个的 &lt;code&gt;DataType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f05b4e05331b196f379ecdeee8aa391e63dd1631" translate="yes" xml:space="preserve">
          <source>Get the native address of an array or string, optionally at a given location &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">获取数组或字符串的本机地址，可以选择在给定的位置 &lt;code&gt;index&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="67e6a2296c5e9b9545d8ce6e5fe670e01fcb2193" translate="yes" xml:space="preserve">
          <source>Get the number of available processes.</source>
          <target state="translated">获取可用进程的数量。</target>
        </trans-unit>
        <trans-unit id="6c54bfd12378fd187e6fdf88c8f9a891fd352b8a" translate="yes" xml:space="preserve">
          <source>Get the number of available worker processes. This is one less than &lt;a href=&quot;#Distributed.nprocs&quot;&gt;&lt;code&gt;nprocs()&lt;/code&gt;&lt;/a&gt;. Equal to &lt;code&gt;nprocs()&lt;/code&gt; if &lt;code&gt;nprocs() == 1&lt;/code&gt;.</source>
          <target state="translated">获取可用的工作进程数。比&lt;a href=&quot;#Distributed.nprocs&quot;&gt; &lt;code&gt;nprocs()&lt;/code&gt; 小一&lt;/a&gt;。如果 &lt;code&gt;nprocs() == 1&lt;/code&gt; 等于 &lt;code&gt;nprocs()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d316efb69571072b7b698b64013b0df989b23e2" translate="yes" xml:space="preserve">
          <source>Get the number of fields in the given object.</source>
          <target state="translated">获取给定对象中的字段数。</target>
        </trans-unit>
        <trans-unit id="a93c91e8128e4c3c8ef281740f30c00304272fd2" translate="yes" xml:space="preserve">
          <source>Get the number of fields that an instance of the given type would have. An error is thrown if the type is too abstract to determine this.</source>
          <target state="translated">获取给定类型的实例拥有的字段数。如果类型太抽象,无法确定,则会产生错误。</target>
        </trans-unit>
        <trans-unit id="8783ebd0cc15f38c2e971a316cd9c7666dbba9ce" translate="yes" xml:space="preserve">
          <source>Get the number of threads available to the Julia process. This is the inclusive upper bound on &lt;a href=&quot;#Base.Threads.threadid&quot;&gt;&lt;code&gt;threadid()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3677eab3b97fd3c65939b3bc5a15f59d44d4af9" translate="yes" xml:space="preserve">
          <source>Get the number of threads available to the Julia process. This is the inclusive upper bound on &lt;code&gt;threadid()&lt;/code&gt;.</source>
          <target state="translated">获取可用于Julia进程的线程数。这是 &lt;code&gt;threadid()&lt;/code&gt; 的上限。</target>
        </trans-unit>
        <trans-unit id="3b55f78480b3149c80bfc50e1a7d85e6fa50c73b" translate="yes" xml:space="preserve">
          <source>Get the permissions of the owner of the file as a bitfield of</source>
          <target state="translated">获取文件所有者的权限,作为文件的位域</target>
        </trans-unit>
        <trans-unit id="c5f291709146a9a504c67d3dc2b280d4f865a715" translate="yes" xml:space="preserve">
          <source>Get the precision (in bits) currently used for &lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; arithmetic.</source>
          <target state="translated">获取当前用于&lt;a href=&quot;#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;算术的精度（以位为单位）。</target>
        </trans-unit>
        <trans-unit id="3ec48750990030ca792131bcde102c3d937ba66e" translate="yes" xml:space="preserve">
          <source>Get the precision of a floating point number, as defined by the effective number of bits in the mantissa.</source>
          <target state="translated">获取浮点数的精度,由万字符的有效位数定义。</target>
        </trans-unit>
        <trans-unit id="c82750d28bc29a3941ba9c542817da0f2854ea45" translate="yes" xml:space="preserve">
          <source>Get the precision of a floating point number, as defined by the effective number of bits in the significand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a1d9961dcbce8522f507a9d605791c91380396" translate="yes" xml:space="preserve">
          <source>Get the process title. On some systems, will always return an empty string.</source>
          <target state="translated">获取进程标题。在某些系统中,将总是返回一个空字符串。</target>
        </trans-unit>
        <trans-unit id="8d97afd1ec5aab5d2f47ff664bcaf7b5f14afb9a" translate="yes" xml:space="preserve">
          <source>Get the stack of exceptions currently being handled. For nested catch blocks there may be more than one current exception in which case the most recently thrown exception is last in the stack. The stack is returned as a Vector of &lt;code&gt;(exception,backtrace)&lt;/code&gt; pairs, or a Vector of exceptions if &lt;code&gt;include_bt&lt;/code&gt; is false.</source>
          <target state="translated">获取当前正在处理的异常堆栈。对于嵌套的catch块，可能有多个当前异常，在这种情况下，最近抛出的异常是堆栈中的最后一个异常。堆栈返回为 &lt;code&gt;(exception,backtrace)&lt;/code&gt; 对的Vector，如果 &lt;code&gt;include_bt&lt;/code&gt; 为false ，则返回异常的Vector 。</target>
        </trans-unit>
        <trans-unit id="857485ff0b5ba0b2460dd06bb700b67ed684fb9b" translate="yes" xml:space="preserve">
          <source>Get the stage number of &lt;code&gt;ie&lt;/code&gt;. The stage number &lt;code&gt;0&lt;/code&gt; represents the current state of the working tree, but other numbers can be used in the case of a merge conflict. In such a case, the various stage numbers on an &lt;code&gt;IndexEntry&lt;/code&gt; describe which side(s) of the conflict the current state of the file belongs to. Stage &lt;code&gt;0&lt;/code&gt; is the state before the attempted merge, stage &lt;code&gt;1&lt;/code&gt; is the changes which have been made locally, stages &lt;code&gt;2&lt;/code&gt; and larger are for changes from other branches (for instance, in the case of a multi-branch &quot;octopus&quot; merge, stages &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;4&lt;/code&gt; might be used).</source>
          <target state="translated">获取 &lt;code&gt;ie&lt;/code&gt; 的阶段号。阶段编号 &lt;code&gt;0&lt;/code&gt; 表示工作树的当前状态，但是在合并冲突的情况下可以使用其他编号。在这种情况下， &lt;code&gt;IndexEntry&lt;/code&gt; 上的各个阶段号描述了文件的当前状态属于冲突的哪一侧。阶段 &lt;code&gt;0&lt;/code&gt; 是尝试合并之前的状态，阶段 &lt;code&gt;1&lt;/code&gt; 是本地进行的更改，阶段 &lt;code&gt;2&lt;/code&gt; 和更大的更改是针对其他分支的更改（例如，在多分支&amp;ldquo;章鱼&amp;rdquo;合并的情况下，阶段 &lt;code&gt;2&lt;/code&gt; ， &lt;code&gt;3&lt;/code&gt; 和 &lt;code&gt;4&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="129f24b071e084dab9af722a0959ecf2337e059d" translate="yes" xml:space="preserve">
          <source>Get the step size of an &lt;a href=&quot;#Base.AbstractRange&quot;&gt;&lt;code&gt;AbstractRange&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">获取&lt;a href=&quot;#Base.AbstractRange&quot;&gt; &lt;code&gt;AbstractRange&lt;/code&gt; &lt;/a&gt;对象的步长。</target>
        </trans-unit>
        <trans-unit id="8858aa789b8a95e917ca5b8edf3cb4cfb4672953" translate="yes" xml:space="preserve">
          <source>Get the system time in seconds since the epoch, with fairly high (typically, microsecond) resolution.</source>
          <target state="translated">以秒为单位,获取自纪元以来的系统时间,分辨率相当高(通常为微秒)。</target>
        </trans-unit>
        <trans-unit id="95239b12c16c016f41ece1f43f66824450caaa42" translate="yes" xml:space="preserve">
          <source>Get the time in nanoseconds. The time corresponding to 0 is undefined, and wraps every 5.8 years.</source>
          <target state="translated">获取时间,单位为纳秒。0对应的时间是未定义的,每5.8年封装一次。</target>
        </trans-unit>
        <trans-unit id="860a244a52c686caf400b1420fb67fb1c70889f7" translate="yes" xml:space="preserve">
          <source>Get the total free memory in RAM in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24f1d764ec96114bfff224327fcd8d0d0abdd31" translate="yes" xml:space="preserve">
          <source>Get the total free memory in RAM in kilobytes.</source>
          <target state="translated">获取RAM中的可用内存总量,单位为千字节。</target>
        </trans-unit>
        <trans-unit id="2891099c5c8dc8b6402c7d53caeef5e0b9cc1707" translate="yes" xml:space="preserve">
          <source>Get the total memory in RAM (including that which is currently used) in bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e4ce0e0a7ea7ef86f926adb946a71d925d5beb" translate="yes" xml:space="preserve">
          <source>Get the total memory in RAM (including that which is currently used) in kilobytes.</source>
          <target state="translated">获取RAM中的总内存(包括当前使用的内存),单位为千字节。</target>
        </trans-unit>
        <trans-unit id="e98e2a89d68b00f3fd77d6a63a6d2c70dc724cf3" translate="yes" xml:space="preserve">
          <source>Get the value of the C library's &lt;code&gt;errno&lt;/code&gt;. If an argument is specified, it is used to set the value of &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">获取C库的 &lt;code&gt;errno&lt;/code&gt; 的值。如果指定了参数，则用于设置 &lt;code&gt;errno&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="c2268d21fbee620aaff052e88aa0c0825d399931" translate="yes" xml:space="preserve">
          <source>Get the value type of an dictionary type. Behaves similarly to &lt;a href=&quot;#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">获取字典类型的值类型。行为与&lt;a href=&quot;#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;类似。</target>
        </trans-unit>
        <trans-unit id="9d8ca9fec9f5e29ac3cbc1f3abc652c135b52ec1" translate="yes" xml:space="preserve">
          <source>Get the vector of processes mapping the shared array.</source>
          <target state="translated">获取映射共享数组的进程向量。</target>
        </trans-unit>
        <trans-unit id="db2afe93edd474fc522d8c7d75cb7a001e5b61fe" translate="yes" xml:space="preserve">
          <source>Gets all of the IP addresses of the &lt;code&gt;host&lt;/code&gt;. Uses the operating system's underlying &lt;code&gt;getaddrinfo&lt;/code&gt; implementation, which may do a DNS lookup.</source>
          <target state="translated">获取 &lt;code&gt;host&lt;/code&gt; 所有IP地址。使用操作系统的基础 &lt;code&gt;getaddrinfo&lt;/code&gt; 实现，该实现可以执行DNS查找。</target>
        </trans-unit>
        <trans-unit id="a284592991f22190fd532a8317fc543ce797cfe4" translate="yes" xml:space="preserve">
          <source>Gets the first IP address of the &lt;code&gt;host&lt;/code&gt; of the specified &lt;code&gt;IPAddr&lt;/code&gt; type. Uses the operating system's underlying getaddrinfo implementation, which may do a DNS lookup.</source>
          <target state="translated">获取指定 &lt;code&gt;IPAddr&lt;/code&gt; 类型的 &lt;code&gt;host&lt;/code&gt; 的第一个IP地址。使用操作系统的基础getaddrinfo实现，该实现可以执行DNS查找。</target>
        </trans-unit>
        <trans-unit id="846899bbba33d15c0dd1bf73665c2578909867ff" translate="yes" xml:space="preserve">
          <source>Gets the path of the temporary directory. On Windows, &lt;code&gt;tempdir()&lt;/code&gt; uses the first environment variable found in the ordered list &lt;code&gt;TMP&lt;/code&gt;, &lt;code&gt;TEMP&lt;/code&gt;, &lt;code&gt;USERPROFILE&lt;/code&gt;. On all other operating systems, &lt;code&gt;tempdir()&lt;/code&gt; uses the first environment variable found in the ordered list &lt;code&gt;TMPDIR&lt;/code&gt;, &lt;code&gt;TMP&lt;/code&gt;, &lt;code&gt;TEMP&lt;/code&gt;, and &lt;code&gt;TEMPDIR&lt;/code&gt;. If none of these are found, the path &lt;code&gt;&quot;/tmp&quot;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7f3acf6ca590093170d5ddc3c9107d6f1324074" translate="yes" xml:space="preserve">
          <source>Getting Around</source>
          <target state="translated">交通指南</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">入门</target>
        </trans-unit>
        <trans-unit id="04ccf152a8a13833ef0a70fb0a973a671f0ea746" translate="yes" xml:space="preserve">
          <source>Getting the hygiene rules correct can be a formidable challenge. Before using a macro, you might want to consider whether a function closure would be sufficient. Another useful strategy is to defer as much work as possible to runtime. For example, many macros simply wrap their arguments in a &lt;code&gt;QuoteNode&lt;/code&gt; or other similar &lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt;&lt;code&gt;Expr&lt;/code&gt;&lt;/a&gt;. Some examples of this include &lt;code&gt;@task body&lt;/code&gt; which simply returns &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt;, and &lt;code&gt;@eval expr&lt;/code&gt;, which simply returns &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt;.</source>
          <target state="translated">正确制定卫生规则可能是一个巨大的挑战。在使用宏之前，您可能需要考虑函数闭包是否足够。另一个有用的策略是将尽可能多的工作推迟到运行时。例如，许多宏只是将其参数包装在 &lt;code&gt;QuoteNode&lt;/code&gt; 或其他类似的&lt;a href=&quot;../../base/base/index#Core.Expr&quot;&gt; &lt;code&gt;Expr&lt;/code&gt; 中&lt;/a&gt;。其中的一些示例包括 &lt;code&gt;@task body&lt;/code&gt; ，该 &lt;code&gt;schedule(Task(() -&amp;gt; $body))&lt;/code&gt; 仅返回schedule（Task（（）-&amp;gt; $ body））和 &lt;code&gt;@eval expr&lt;/code&gt; ，其仅返回 &lt;code&gt;eval(QuoteNode(expr))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bf44c9857b696454c5ef1ca708da5e3ee8a0b24a" translate="yes" xml:space="preserve">
          <source>Ghost</source>
          <target state="translated">Ghost</target>
        </trans-unit>
        <trans-unit id="4a4c89342a61073746cb0be5c482a4f233f70856" translate="yes" xml:space="preserve">
          <source>Gimel Symbol / Third Transfinite Cardinal</source>
          <target state="translated">吉梅尔符号/第三位无限枢机主教</target>
        </trans-unit>
        <trans-unit id="29fb58174b748291968c938f5144e432d7a05bc1" translate="yes" xml:space="preserve">
          <source>Girl</source>
          <target state="translated">Girl</target>
        </trans-unit>
        <trans-unit id="d1acb2e33d2070c77075991c4c8d8d1a063d6fb4" translate="yes" xml:space="preserve">
          <source>Give a hint to the compiler that it should not inline a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="585f3a3c7ecf6be9b08fcb5c41bd3f7b4064386b" translate="yes" xml:space="preserve">
          <source>Give a hint to the compiler that this function is worth inlining.</source>
          <target state="translated">给编译器一个提示,这个函数值得内联。</target>
        </trans-unit>
        <trans-unit id="f9f77d5a362582fb87b0f06e19b1b57c8b1806c3" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a character.</source>
          <target state="translated">给出打印一个字符所需的列数。</target>
        </trans-unit>
        <trans-unit id="d66cd5d2057c5b56255474647800cbbea7c7ec15" translate="yes" xml:space="preserve">
          <source>Give the number of columns needed to print a string.</source>
          <target state="translated">给出打印一个字符串所需的列数。</target>
        </trans-unit>
        <trans-unit id="a34ffde7989d779a84306150562bbcc334bb927c" translate="yes" xml:space="preserve">
          <source>Given a 2-argument function &lt;code&gt;f&lt;/code&gt; and an iterator &lt;code&gt;itr&lt;/code&gt;, return a new iterator that successively applies &lt;code&gt;f&lt;/code&gt; to the previous value and the next element of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990b49394e3cec090496333dd6dda71ca867283b" translate="yes" xml:space="preserve">
          <source>Given a &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;-like function &lt;code&gt;writefunc&lt;/code&gt;, which takes an I/O stream as its first argument, &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; calls &lt;code&gt;writefunc&lt;/code&gt; to write &lt;code&gt;args...&lt;/code&gt; to a base64-encoded string, and returns the string. &lt;code&gt;base64encode(args...)&lt;/code&gt; is equivalent to &lt;code&gt;base64encode(write, args...)&lt;/code&gt;: it converts its arguments into bytes using the standard &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; functions and returns the base64-encoded string.</source>
          <target state="translated">给定类似&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;函数 &lt;code&gt;writefunc&lt;/code&gt; ，该函数将I / O流作为第一个参数， &lt;code&gt;base64encode(writefunc, args...)&lt;/code&gt; 调用 &lt;code&gt;writefunc&lt;/code&gt; 将 &lt;code&gt;args...&lt;/code&gt; 写入base64编码的字符串，并返回该字符串。 &lt;code&gt;base64encode(args...)&lt;/code&gt; 等同于 &lt;code&gt;base64encode(write, args...)&lt;/code&gt; ：它使用标准的&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;函数将其参数转换为字节，并返回base64编码的字符串。</target>
        </trans-unit>
        <trans-unit id="f3d33bb8ba673cca2a309308e1c04181d32a390f" translate="yes" xml:space="preserve">
          <source>Given a &lt;code&gt;Ptr{T}&lt;/code&gt;, the contents of type &lt;code&gt;T&lt;/code&gt; can generally be copied from the referenced memory into a Julia object using &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt;. The index argument is optional (default is 1), and follows the Julia-convention of 1-based indexing. This function is intentionally similar to the behavior of &lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;[]&lt;/code&gt; access syntax).</source>
          <target state="translated">给定一个 &lt;code&gt;Ptr{T}&lt;/code&gt; ，通常可以使用 &lt;code&gt;unsafe_load(ptr, [index])&lt;/code&gt; 将类型 &lt;code&gt;T&lt;/code&gt; 的内容从引用的内存复制到Julia对象中。 index参数是可选的（默认为1），并遵循基于Julia的基于1的索引。此功能故意类似于&lt;a href=&quot;../../base/collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;的行为！（例如 &lt;code&gt;[]&lt;/code&gt; 访问语法）。</target>
        </trans-unit>
        <trans-unit id="9276b00b5b100003171aa4d1b53dddc58e924e43" translate="yes" xml:space="preserve">
          <source>Given a collection type &lt;code&gt;S&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(::S)&lt;/code&gt; is defined, an object of type &lt;code&gt;eltype(S)&lt;/code&gt; will be produced. In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="translated">给定一个集合类型 &lt;code&gt;S&lt;/code&gt; ，当前假设如果定义了 &lt;code&gt;rand(::S)&lt;/code&gt; ，则将生成类型为 &lt;code&gt;eltype(S)&lt;/code&gt; 的对象。为了从类型 &lt;code&gt;S&lt;/code&gt; 的对象中定义随机生成，可以定义以下方法： &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt; 。在这里， &lt;code&gt;sp&lt;/code&gt; 只是包装了一个 &lt;code&gt;S&lt;/code&gt; 类型的对象，可以通过 &lt;code&gt;sp[]&lt;/code&gt; 访问它。继续 &lt;code&gt;Die&lt;/code&gt; 示例，我们现在要定义 &lt;code&gt;rand(d::Die)&lt;/code&gt; 来产生一个与 &lt;code&gt;d&lt;/code&gt; 边之一相对应的 &lt;code&gt;Int&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="700a876db14031cb467cacd249ca9851d58258cb" translate="yes" xml:space="preserve">
          <source>Given a collection type &lt;code&gt;S&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(::S)&lt;/code&gt; is defined, an object of type &lt;code&gt;eltype(S)&lt;/code&gt; will be produced. In the last example, a &lt;code&gt;Vector{Any}&lt;/code&gt; is produced; the reason is that &lt;code&gt;eltype(Die) == Any&lt;/code&gt;. The remedy is to define &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f1730c953eabcee66d16110ac2417f817ee88b" translate="yes" xml:space="preserve">
          <source>Given a dictionary &lt;code&gt;D&lt;/code&gt;, the syntax &lt;code&gt;D[x]&lt;/code&gt; returns the value of key &lt;code&gt;x&lt;/code&gt; (if it exists) or throws an error, and &lt;code&gt;D[x] = y&lt;/code&gt; stores the key-value pair &lt;code&gt;x =&amp;gt; y&lt;/code&gt; in &lt;code&gt;D&lt;/code&gt; (replacing any existing value for the key &lt;code&gt;x&lt;/code&gt;). Multiple arguments to &lt;code&gt;D[...]&lt;/code&gt; are converted to tuples; for example, the syntax &lt;code&gt;D[x,y]&lt;/code&gt; is equivalent to &lt;code&gt;D[(x,y)]&lt;/code&gt;, i.e. it refers to the value keyed by the tuple &lt;code&gt;(x,y)&lt;/code&gt;.</source>
          <target state="translated">给定字典 &lt;code&gt;D&lt;/code&gt; ，语法 &lt;code&gt;D[x]&lt;/code&gt; 返回键 &lt;code&gt;x&lt;/code&gt; 的值（如果存在）或引发错误，并且 &lt;code&gt;D[x] = y&lt;/code&gt; 将键值对 &lt;code&gt;x =&amp;gt; y&lt;/code&gt; 在 &lt;code&gt;D&lt;/code&gt; 中（替换现有的键值对）键 &lt;code&gt;x&lt;/code&gt; 的值）。 &lt;code&gt;D[...]&lt;/code&gt; 多个参数将转换为元组；例如，语法 &lt;code&gt;D[x,y]&lt;/code&gt; 等效于 &lt;code&gt;D[(x,y)]&lt;/code&gt; ，即，它引用由元组 &lt;code&gt;(x,y)&lt;/code&gt; 键控的值。</target>
        </trans-unit>
        <trans-unit id="c0b3c9a8cb5b6bf41774ca0094396ad324bf5391" translate="yes" xml:space="preserve">
          <source>Given a library &lt;code&gt;handle&lt;/code&gt; from &lt;code&gt;dlopen&lt;/code&gt;, return the full path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aeb65e7ccb967c9455ef2f486079851e21e2b6b" translate="yes" xml:space="preserve">
          <source>Given a pointer to an execution context (usually generated by a call to &lt;code&gt;backtrace&lt;/code&gt;), looks up stack frame context information. Returns an array of frame information for all functions inlined at that point, innermost function first.</source>
          <target state="translated">给定指向执行上下文的指针（通常由对 &lt;code&gt;backtrace&lt;/code&gt; 的调用生成），查找堆栈框架上下文信息。返回该点内联的所有函数的框架信息数组，最里面的函数在前。</target>
        </trans-unit>
        <trans-unit id="fcada796f1c4aca1cfb31ae96c64d212e649ecf0" translate="yes" xml:space="preserve">
          <source>Given a predicate function &lt;code&gt;flt&lt;/code&gt; and an iterable object &lt;code&gt;itr&lt;/code&gt;, return an iterable object which upon iteration yields the elements &lt;code&gt;x&lt;/code&gt; of &lt;code&gt;itr&lt;/code&gt; that satisfy &lt;code&gt;flt(x)&lt;/code&gt;. The order of the original iterator is preserved.</source>
          <target state="translated">给定一个谓词函数 &lt;code&gt;flt&lt;/code&gt; 和一个可迭代的对象 &lt;code&gt;itr&lt;/code&gt; ，返回一个可迭代的对象，该对象在迭代时产生满足 &lt;code&gt;flt(x)&lt;/code&gt; 的 &lt;code&gt;itr&lt;/code&gt; 元素 &lt;code&gt;x&lt;/code&gt; 。原始迭代器的顺序得以保留。</target>
        </trans-unit>
        <trans-unit id="c16f746a1658b9d1859c84c436dc50bdb9fe0a85" translate="yes" xml:space="preserve">
          <source>Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace &lt;code&gt;data&lt;/code&gt; obtained from &lt;a href=&quot;#Profile.retrieve&quot;&gt;&lt;code&gt;retrieve&lt;/code&gt;&lt;/a&gt;; otherwise, the current internal profile buffer is used.</source>
          <target state="translated">给定先前的概要分析运行，确定谁调用了特定函数。提供文件名（以及可选的定义函数的行号范围）可让您消除重载方法的歧义。返回的值是一个向量，其中包含呼叫次数和有关呼叫者的线路信息的计数。可以选择提供从&lt;a href=&quot;#Profile.retrieve&quot;&gt; &lt;code&gt;retrieve&lt;/code&gt; &lt;/a&gt;获得的回溯 &lt;code&gt;data&lt;/code&gt; ；否则，将使用当前的内部配置文件缓冲区。</target>
        </trans-unit>
        <trans-unit id="67104b7201b61b9623c8478911e24c6cfc8b97bc" translate="yes" xml:space="preserve">
          <source>Given a single iterable argument, constructs a &lt;a href=&quot;#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt; whose key-value pairs are taken from 2-tuples &lt;code&gt;(key,value)&lt;/code&gt; generated by the argument.</source>
          <target state="translated">给定一个可迭代的参数，构造一个&lt;a href=&quot;#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; ,&lt;/a&gt;其键值对取自该参数生成的2元组 &lt;code&gt;(key,value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a19217b165ec900e8bae935104c81bb7e032d599" translate="yes" xml:space="preserve">
          <source>Given a starting value, construct a range either by length or from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt;, optionally with a given step (defaults to 1, a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt;). One of &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;stop&lt;/code&gt; is required. If &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, and &lt;code&gt;step&lt;/code&gt; are all specified, they must agree.</source>
          <target state="translated">给定一个起始值，可以按长度或从 &lt;code&gt;start&lt;/code&gt; 到 &lt;code&gt;stop&lt;/code&gt; 构造一个范围，可以选择使用给定的步骤（默认为1，一个&lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt;）。一个的 &lt;code&gt;length&lt;/code&gt; 或 &lt;code&gt;stop&lt;/code&gt; 是必需的。如果指定 &lt;code&gt;length&lt;/code&gt; ， &lt;code&gt;stop&lt;/code&gt; 和 &lt;code&gt;step&lt;/code&gt; ，则必须一致。</target>
        </trans-unit>
        <trans-unit id="e6bf5e1364f77d196c7b9a51bb62bde8f133bcde" translate="yes" xml:space="preserve">
          <source>Given a string or array &lt;code&gt;s&lt;/code&gt; of ASCII codes for a sequence of hexadecimal digits, returns a &lt;code&gt;Vector{UInt8}&lt;/code&gt; of bytes corresponding to the binary representation: each successive pair of hexadecimal digits in &lt;code&gt;s&lt;/code&gt; gives the value of one byte in the return vector.</source>
          <target state="translated">给定一个十六进制数字序列的ASCII码字符串或数组 &lt;code&gt;s&lt;/code&gt; ，返回对应于二进制表示形式的 &lt;code&gt;Vector{UInt8}&lt;/code&gt; 字节： &lt;code&gt;s&lt;/code&gt; 中每对连续的十六进制数字对在返回向量中给出一个字节的值。</target>
        </trans-unit>
        <trans-unit id="b539dd0aaced1e1e9c21b2db4d99090ee705b0d2" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(T)&lt;/code&gt; is defined, an object of type &lt;code&gt;T&lt;/code&gt; will be produced. &lt;code&gt;SamplerType&lt;/code&gt; is the &lt;em&gt;default sampler for types&lt;/em&gt;. In order to define random generation of values of type &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; method should be defined, and should return values what &lt;code&gt;rand(rng, T)&lt;/code&gt; is expected to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d6a85425c1e72a27deafaba610d488a3457e0f2" translate="yes" xml:space="preserve">
          <source>Given a type &lt;code&gt;T&lt;/code&gt;, it's currently assumed that if &lt;code&gt;rand(T)&lt;/code&gt; is defined, an object of type &lt;code&gt;T&lt;/code&gt; will be produced. In order to define random generation of values of type &lt;code&gt;T&lt;/code&gt;, the following method can be defined: &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; (this should return what &lt;code&gt;rand(rng, T)&lt;/code&gt; is expected to return).</source>
          <target state="translated">给定类型 &lt;code&gt;T&lt;/code&gt; ，当前假设如果定义了 &lt;code&gt;rand(T)&lt;/code&gt; ，将产生类型 &lt;code&gt;T&lt;/code&gt; 的对象。为了定义类型 &lt;code&gt;T&lt;/code&gt; 的值的随机生成，可以定义以下方法： &lt;code&gt;rand(rng::AbstractRNG, ::Random.SamplerType{T})&lt;/code&gt; （这应该返回 &lt;code&gt;rand(rng, T)&lt;/code&gt; 期望返回的值）。</target>
        </trans-unit>
        <trans-unit id="60e4af8cc8de60ffb69850d252bdcd98ee3d2bfa" translate="yes" xml:space="preserve">
          <source>Given an AbstractArray &lt;code&gt;A&lt;/code&gt;, create a view &lt;code&gt;B&lt;/code&gt; such that the dimensions appear to be permuted. Similar to &lt;code&gt;permutedims&lt;/code&gt;, except that no copying occurs (&lt;code&gt;B&lt;/code&gt; shares storage with &lt;code&gt;A&lt;/code&gt;).</source>
          <target state="translated">给定一个AbstractArray &lt;code&gt;A&lt;/code&gt; ，创建一个视图 &lt;code&gt;B&lt;/code&gt; ，以使尺寸看起来是可置换的。与 &lt;code&gt;permutedims&lt;/code&gt; 相似，除了不进行复制（ &lt;code&gt;B&lt;/code&gt; 与 &lt;code&gt;A&lt;/code&gt; 共享存储）。</target>
        </trans-unit>
        <trans-unit id="2273302d369651afdbde86cc33fa4cfcb401046e" translate="yes" xml:space="preserve">
          <source>Given an expression object, one can cause Julia to evaluate (execute) it at global scope using &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">给定一个表达式对象，可以使Julia使用&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; &lt;/a&gt;在全局范围内对其进行评估（执行）：</target>
        </trans-unit>
        <trans-unit id="b05155f37fd5b5acf7427c2b96abcb47e059d8f8" translate="yes" xml:space="preserve">
          <source>Given an index &lt;code&gt;i&lt;/code&gt; in &lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;reverse(v)&lt;/code&gt;&lt;/a&gt;, return the corresponding index in &lt;code&gt;v&lt;/code&gt; so that &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt;. (This can be nontrivial in cases where &lt;code&gt;v&lt;/code&gt; contains non-ASCII characters.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcc48e1bcaa064479ac3ce6a9aad0b807686849" translate="yes" xml:space="preserve">
          <source>Given an index &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;reverse(v)&lt;/code&gt;, return the corresponding index in &lt;code&gt;v&lt;/code&gt; so that &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt;. (This can be nontrivial in cases where &lt;code&gt;v&lt;/code&gt; contains non-ASCII characters.)</source>
          <target state="translated">给定一个索引 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;reverse(v)&lt;/code&gt; ，返回对应的索引 &lt;code&gt;v&lt;/code&gt; ，使得 &lt;code&gt;v[reverseind(v,i)] == reverse(v)[i]&lt;/code&gt; 。（在 &lt;code&gt;v&lt;/code&gt; 包含非ASCII字符的情况下，这可能是不平凡的。）</target>
        </trans-unit>
        <trans-unit id="214692258e5d3f03bf0e19a0c7bce6fe690232a0" translate="yes" xml:space="preserve">
          <source>Given an iterator &lt;code&gt;itr&lt;/code&gt;, then &lt;code&gt;reverse(itr)&lt;/code&gt; is an iterator over the same collection but in the reverse order.</source>
          <target state="translated">给定一个迭代器 &lt;code&gt;itr&lt;/code&gt; ，则 &lt;code&gt;reverse(itr)&lt;/code&gt; 是同一集合上的迭代器，但顺序相反。</target>
        </trans-unit>
        <trans-unit id="089e5e83e8607aed09695c30f3dd1c60f5798574" translate="yes" xml:space="preserve">
          <source>Given an iterator that yields iterators, return an iterator that yields the elements of those iterators. Put differently, the elements of the argument iterator are concatenated.</source>
          <target state="translated">给定一个产生迭代器的迭代器,返回一个产生这些迭代器元素的迭代器。换句话说,参数迭代器的元素是连通的。</target>
        </trans-unit>
        <trans-unit id="3c9b417cfac83aea8a69f80d6bc8cf9a41f8a58a" translate="yes" xml:space="preserve">
          <source>Given such a declaration, for each choice of &lt;code&gt;T&lt;/code&gt;, we have &lt;code&gt;Point{T}&lt;/code&gt; as a subtype of &lt;code&gt;Pointy{T}&lt;/code&gt;:</source>
          <target state="translated">给定这样的声明，对于 &lt;code&gt;T&lt;/code&gt; 的每个选择，我们都有 &lt;code&gt;Point{T}&lt;/code&gt; 作为 &lt;code&gt;Pointy{T}&lt;/code&gt; 的子类型：</target>
        </trans-unit>
        <trans-unit id="d716647091cd161029df5d10c16015ae51186d66" translate="yes" xml:space="preserve">
          <source>Given the git configuration file containing:</source>
          <target state="translated">鉴于git配置文件包含:</target>
        </trans-unit>
        <trans-unit id="915ac53cd4c78783b139cec5dd22b4b42ed2b99a" translate="yes" xml:space="preserve">
          <source>Given the statement &lt;code&gt;using Foo&lt;/code&gt;, the system consults an internal table of top-level modules to look for one named &lt;code&gt;Foo&lt;/code&gt;. If the module does not exist, the system attempts to &lt;code&gt;require(:Foo)&lt;/code&gt;, which typically results in loading code from an installed package.</source>
          <target state="translated">给定 &lt;code&gt;using Foo&lt;/code&gt; 的语句，系统将查询顶级模块的内部表以查找一个名为 &lt;code&gt;Foo&lt;/code&gt; 的模块。如果模块不存在，系统将尝试 &lt;code&gt;require(:Foo)&lt;/code&gt; ，这通常会导致从已安装的软件包中加载代码。</target>
        </trans-unit>
        <trans-unit id="06fe662af1da02e3f2ea7cf7081d137d14c1ea88" translate="yes" xml:space="preserve">
          <source>Given the type of an iterator, return one of the following values:</source>
          <target state="translated">给定一个迭代器的类型,返回以下值之一。</target>
        </trans-unit>
        <trans-unit id="712fa051470c666b0b3c1cf4e1eb3b5cdf800a89" translate="yes" xml:space="preserve">
          <source>Given this dependency &lt;code&gt;graph&lt;/code&gt;, when Julia sees &lt;code&gt;import Priv&lt;/code&gt; in the &lt;code&gt;Pub&lt;/code&gt; package&amp;mdash;which has UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt;&amp;mdash;it looks up:</source>
          <target state="translated">给定此依赖关系 &lt;code&gt;graph&lt;/code&gt; ，当Julia 在 &lt;code&gt;Pub&lt;/code&gt; 包中看到 &lt;code&gt;import Priv&lt;/code&gt; 时，它具有UUID &lt;code&gt;c07ecb7d-0dc9-4db7-8803-fadaaeaf08e1&lt;/code&gt; ,它会查找：</target>
        </trans-unit>
        <trans-unit id="617b3c70bd8eb4654d1000dde442b1913a3d57c6" translate="yes" xml:space="preserve">
          <source>Given this roots map, in &lt;code&gt;App&lt;/code&gt;'s code the statement &lt;code&gt;import Priv&lt;/code&gt; will cause Julia to look up &lt;code&gt;roots[:Priv]&lt;/code&gt;, which yields &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;, the UUID of the &lt;code&gt;Priv&lt;/code&gt; package that is to be loaded in that context. This UUID identifies which &lt;code&gt;Priv&lt;/code&gt; package to load and use when the main application evaluates &lt;code&gt;import Priv&lt;/code&gt;.</source>
          <target state="translated">给定此根映射，在 &lt;code&gt;App&lt;/code&gt; 的代码中，语句 &lt;code&gt;import Priv&lt;/code&gt; 将使Julia查找 &lt;code&gt;roots[:Priv]&lt;/code&gt; ，这将产生 &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; ，这是要在其中加载的 &lt;code&gt;Priv&lt;/code&gt; 包的UUID 该上下文。当主应用程序评估 &lt;code&gt;import Priv&lt;/code&gt; 时，此UUID标识要加载和使用的 &lt;code&gt;Priv&lt;/code&gt; 软件包。</target>
        </trans-unit>
        <trans-unit id="b509e583621052cb07bc486839dfdb1f16ed86dc" translate="yes" xml:space="preserve">
          <source>Global Scope</source>
          <target state="translated">全球范围</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">全局变量</target>
        </trans-unit>
        <trans-unit id="40501a9e5007169fb629c5387c4f8fb6e999c42d" translate="yes" xml:space="preserve">
          <source>Global constants are declared as constants on remote nodes too.</source>
          <target state="translated">全局常量在远程节点上也被声明为常量。</target>
        </trans-unit>
        <trans-unit id="389f13ca82ff7a2453bc65e6b170fb5bce0e7be4" translate="yes" xml:space="preserve">
          <source>Global counters (for example, for attempting to uniquely identify objects). Consider the following code snippet:</source>
          <target state="translated">全局计数器(例如,用于尝试唯一识别对象)。请看下面的代码片段。</target>
        </trans-unit>
        <trans-unit id="9f22cff33a2ca414f07ad83aad20cf6de8acaeaf" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard error stream.</source>
          <target state="translated">全局变量,指的是标准误差流。</target>
        </trans-unit>
        <trans-unit id="9aa21a682323865a22d83920da0f441d6c030675" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard input stream.</source>
          <target state="translated">指向标准输入流的全局变量。</target>
        </trans-unit>
        <trans-unit id="51d6faf5f0e0e6c01ea9efaf0aad4dbd11c26673" translate="yes" xml:space="preserve">
          <source>Global variable referring to the standard out stream.</source>
          <target state="translated">指向标准输出流的全局变量。</target>
        </trans-unit>
        <trans-unit id="70ae8e14e7d7a8122e7468fd602556f9b4388301" translate="yes" xml:space="preserve">
          <source>Global variables</source>
          <target state="translated">全局变量</target>
        </trans-unit>
        <trans-unit id="7d6e1e2bd4cbe556d039d09149551410bf54cb41" translate="yes" xml:space="preserve">
          <source>Global variables exported by native libraries can be accessed by name using the &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; function. The arguments to &lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt;&lt;code&gt;cglobal&lt;/code&gt;&lt;/a&gt; are a symbol specification identical to that used by &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, and a type describing the value stored in the variable:</source>
          <target state="translated">可以使用&lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt;函数按名称访问由本机库导出的全局变量。到参数&lt;a href=&quot;../../base/c/index#Core.Intrinsics.cglobal&quot;&gt; &lt;code&gt;cglobal&lt;/code&gt; &lt;/a&gt;是通过使用一个符号规范完全相同&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;，并且描述存储在该变量中的值的类型：</target>
        </trans-unit>
        <trans-unit id="d02d943210f33ec6146b40f17e3a1be495a87492" translate="yes" xml:space="preserve">
          <source>Globals are re-sent to a destination worker only in the context of a remote call, and then only if its value has changed. Also, the cluster does not synchronize global bindings across nodes. For example:</source>
          <target state="translated">只有在远程调用的上下文中,全局才会被重新发送到目的工作者,然后只有在其值发生变化时才会被发送。另外,集群不会在不同节点间同步全局绑定。比如说</target>
        </trans-unit>
        <trans-unit id="fb02a2aa39a487184ec2e48cce6d9541aa570f94" translate="yes" xml:space="preserve">
          <source>Globals under modules other than &lt;code&gt;Main&lt;/code&gt; are not serialized by value to the remote node. Only a reference is sent. Functions which create global bindings (except under &lt;code&gt;Main&lt;/code&gt;) may cause an &lt;code&gt;UndefVarError&lt;/code&gt; to be thrown later.</source>
          <target state="translated">&lt;code&gt;Main&lt;/code&gt; 以外的模块下的全局变量不会按值序列化到远程节点。仅发送参考。创建全局绑定的函数（ &lt;code&gt;Main&lt;/code&gt; 除外）可能导致稍后引发 &lt;code&gt;UndefVarError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="acd336be94f1ee162a48e523127d9e5b06609fb8" translate="yes" xml:space="preserve">
          <source>Globe With Meridians</source>
          <target state="translated">地球仪与经络</target>
        </trans-unit>
        <trans-unit id="bf6d33bf807dc90549a0d0bac64e3cc4b4bb46ed" translate="yes" xml:space="preserve">
          <source>Glowing Star</source>
          <target state="translated">萤光之星</target>
        </trans-unit>
        <trans-unit id="0e3f5fc25846b7ffc7fbf7ea4a19522f60c6c683" translate="yes" xml:space="preserve">
          <source>Goat</source>
          <target state="translated">Goat</target>
        </trans-unit>
        <trans-unit id="e10a82a4acb4738d8b41ab1910aa292204041524" translate="yes" xml:space="preserve">
          <source>Going back to our &lt;code&gt;Die&lt;/code&gt; example: &lt;code&gt;rand(::Die)&lt;/code&gt; uses random generation from a range, so there is an opportunity for this optimization. We call our custom sampler &lt;code&gt;SamplerDie&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab8916b317afa94c1e7d2eb18cfc9628289063b" translate="yes" xml:space="preserve">
          <source>Good performance, approaching that of statically-compiled languages like C</source>
          <target state="translated">性能良好,接近C语言等静态编译语言的性能</target>
        </trans-unit>
        <trans-unit id="85116c6b5a5273ba053319524800267c175695d4" translate="yes" xml:space="preserve">
          <source>Graduation Cap</source>
          <target state="translated">毕业帽</target>
        </trans-unit>
        <trans-unit id="0de47448267ba383673ef343ee1313af6fa63b74" translate="yes" xml:space="preserve">
          <source>Grapes</source>
          <target state="translated">Grapes</target>
        </trans-unit>
        <trans-unit id="2ef67b67ccfcf902b5da0d871f7bce811117ba2c" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Double-Line Equal Above Less-Than</source>
          <target state="translated">大于双线以上 平于小线以上</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
