<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="5bf36d0687ba161c1ddd5ae9a710ac6b84c65e73" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Less-Than Above Double-Line Equal</source>
          <target state="translated">大于等于以上小于等于以上 双线等于以上</target>
        </trans-unit>
        <trans-unit id="cda9caba673dd1973f8c7d113746b0e633f4f938" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Above Less-Than</source>
          <target state="translated">大于以上 类似以上 小于以下</target>
        </trans-unit>
        <trans-unit id="3a03ecfc7255d8cacd17931a2c17d195720afbd9" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Similar Or Equal</source>
          <target state="translated">大于 以上 相似或相等</target>
        </trans-unit>
        <trans-unit id="eed03df20a091917ea38ceacb7e9c2b67e0f9bb2" translate="yes" xml:space="preserve">
          <source>Greater-Than Above Slanted Equal Above Less-Than Above Slanted Equal</source>
          <target state="translated">大于等于斜上方 小于等于斜上方</target>
        </trans-unit>
        <trans-unit id="ec6a31bc7051547d44e2c612da8aa15b61e41be6" translate="yes" xml:space="preserve">
          <source>Greater-Than And Not Approximate</source>
          <target state="translated">大于而非近似</target>
        </trans-unit>
        <trans-unit id="852f9d0047fa29fbc8fb2cb24463f569deef89ef" translate="yes" xml:space="preserve">
          <source>Greater-Than And Single-Line Not Equal To</source>
          <target state="translated">大于等于和单线不等于。</target>
        </trans-unit>
        <trans-unit id="52afc7afef44a974f7bc9b05b1e17bf964f408a0" translate="yes" xml:space="preserve">
          <source>Greater-Than Beside Less-Than</source>
          <target state="translated">大于等于小于</target>
        </trans-unit>
        <trans-unit id="8002394d4a4c3c62e2b6ebf6a841410b987f3fe3" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To</source>
          <target state="translated">大于但不等于/大于但不等于</target>
        </trans-unit>
        <trans-unit id="9f51323c1f1f2bd6fed8b0133087b13833db9603" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equal To / Greater Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">大于但不等于/大于但不等于+变量选择器-1</target>
        </trans-unit>
        <trans-unit id="a9e5efe496a2b31f56957d4e597885897f8e0eb9" translate="yes" xml:space="preserve">
          <source>Greater-Than But Not Equivalent To / Greater Than But Not Equivalent To</source>
          <target state="translated">大于但不等同于/大于但不等同于</target>
        </trans-unit>
        <trans-unit id="98eff7a1e60f594f0f81d4c3e83cbf5209423bb1" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve</source>
          <target state="translated">大于闭合曲线</target>
        </trans-unit>
        <trans-unit id="099b37f93e6b34dbfa7c526c5fa3f13b59c30374" translate="yes" xml:space="preserve">
          <source>Greater-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">大于等于以上曲线闭合的斜线</target>
        </trans-unit>
        <trans-unit id="bb2d6f56b2861cf6b4d17b1cfddecb19b41dd882" translate="yes" xml:space="preserve">
          <source>Greater-Than Equal To Or Less-Than / Greater Than Equal To Or Less Than</source>
          <target state="translated">大于等于或小于等于/大于等于或小于小于</target>
        </trans-unit>
        <trans-unit id="1f9f324edcdf276db2fba93d474c1d37dd1409bf" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Approximate</source>
          <target state="translated">大于或近似</target>
        </trans-unit>
        <trans-unit id="816b73122f7826a76fc5a27a59be585ac1c20c8e" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equal To / Greater Than Or Equal To</source>
          <target state="translated">大于或等于/大于或等于/大于等于</target>
        </trans-unit>
        <trans-unit id="22f6cd5ba77c22771ae0dcb6dec580b58470b15f" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Equivalent To / Greater Than Or Equivalent To</source>
          <target state="translated">大于或等同于/大于或等同于</target>
        </trans-unit>
        <trans-unit id="da7070ff7fe0d357657567e892ae9e792dd0711c" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Less-Than / Greater Than Or Less Than</source>
          <target state="translated">大於或小於/大於或小於</target>
        </trans-unit>
        <trans-unit id="fc2308a37940cf5145837f4b055616cdf8ed8663" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To</source>
          <target state="translated">大于或斜于</target>
        </trans-unit>
        <trans-unit id="fc0db4bdca25b60daf5c07123869e9c3373f86d1" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">大于或斜于+合并长实心叠加/无间隔长斜线叠加。</target>
        </trans-unit>
        <trans-unit id="3d2877fe16bd8c1aff6ca20742e54d7c40adcfb5" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">大于或斜于 等于 上面的点</target>
        </trans-unit>
        <trans-unit id="5b85b82c5dfec29b3e76371a3c759b7b564d0dcc" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Above Left</source>
          <target state="translated">大于或斜等于左上角有圆点</target>
        </trans-unit>
        <trans-unit id="324053698d665835c3c8543b9475493cada464ce" translate="yes" xml:space="preserve">
          <source>Greater-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">大于或斜于内点的等值线</target>
        </trans-unit>
        <trans-unit id="eaf2aeee67af979dcb4bf973f1c28801c9b3c428" translate="yes" xml:space="preserve">
          <source>Greater-Than Over Equal To / Greater Than Over Equal To</source>
          <target state="translated">大于等于/大于大于等于</target>
        </trans-unit>
        <trans-unit id="88e04ffb7bbd7b8b561e5e62dab6aaf4e8ec7d4c" translate="yes" xml:space="preserve">
          <source>Greater-Than Overlapping Less-Than</source>
          <target state="translated">大于等于重叠小于等于</target>
        </trans-unit>
        <trans-unit id="7eb5603be44b831a023cfdcd22f839b5f6f5bded" translate="yes" xml:space="preserve">
          <source>Greater-Than With Circle Inside</source>
          <target state="translated">大于圈内的圆圈</target>
        </trans-unit>
        <trans-unit id="f158072571829726fe84a7ad0ce7a50ef1ab0879" translate="yes" xml:space="preserve">
          <source>Greater-Than With Dot / Greater Than With Dot</source>
          <target state="translated">大于圆点/大于圆点。</target>
        </trans-unit>
        <trans-unit id="209f35de5184bc36aa0d1b903151a9fc65c6ba61" translate="yes" xml:space="preserve">
          <source>Greater-Than With Question Mark Above</source>
          <target state="translated">大于,上面有问号</target>
        </trans-unit>
        <trans-unit id="1bd3d8bbe04802c889994d907ddead65a92d7cca" translate="yes" xml:space="preserve">
          <source>Greater-than comparison operator. Falls back to &lt;code&gt;y &amp;lt; x&lt;/code&gt;.</source>
          <target state="translated">大于比较运算符。回落到 &lt;code&gt;y &amp;lt; x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed9b75dd8da9fbc05fe433d4046e50ff253af5b8" translate="yes" xml:space="preserve">
          <source>Greater-than-or-equals comparison operator. Falls back to &lt;code&gt;y &amp;lt;= x&lt;/code&gt;.</source>
          <target state="translated">大于等于比较运算符。回落到 &lt;code&gt;y &amp;lt;= x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c889dfd5914acacbd51c9ee1f6424d7475f18ba9" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero).</source>
          <target state="translated">最大公共（正）除数（如果 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 均为零，则为零）。</target>
        </trans-unit>
        <trans-unit id="b3c118d12ee713605454a73fa83e73fd62da99f2" translate="yes" xml:space="preserve">
          <source>Greatest common (positive) divisor (or zero if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are both zero). The arguments may be integer and rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c137f18236c59d67effecc9926b91bc4e6c388c" translate="yes" xml:space="preserve">
          <source>Greek Beta Symbol / Greek Small Letter Curled Beta</source>
          <target state="translated">希腊语Beta符号/希腊语小字卷曲的Beta符号</target>
        </trans-unit>
        <trans-unit id="c90a544a84e41b0027e35535de12e9412929c3b9" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Alpha</source>
          <target state="translated">希腊大写字母Alpha</target>
        </trans-unit>
        <trans-unit id="034c000ae09a7efb7dcd09b84c993f24a59b651a" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Beta</source>
          <target state="translated">希腊大写字母Beta</target>
        </trans-unit>
        <trans-unit id="d91481b132bdcebe4f898c637891a19c7e0d2807" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Chi</source>
          <target state="translated">希腊大写字母Chi</target>
        </trans-unit>
        <trans-unit id="3e715476cf54a47fc160c1f17257b6e0b611dcf0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Delta</source>
          <target state="translated">希腊大写字母Delta</target>
        </trans-unit>
        <trans-unit id="e7b36e8f2dc5d428f4c0fbae5314c79d701290b8" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Epsilon</source>
          <target state="translated">希腊大写字母Epsilon</target>
        </trans-unit>
        <trans-unit id="9632923c81e91309b0197e9f6256e5ddc583b3f1" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Eta</source>
          <target state="translated">希腊大写字母Eta</target>
        </trans-unit>
        <trans-unit id="b63912e4ec51d609e069730c367de176e6e9799e" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Gamma</source>
          <target state="translated">希腊大写字母Gamma</target>
        </trans-unit>
        <trans-unit id="003ecb167b62284b9bb24641dd3e450774ffb206" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Iota</source>
          <target state="translated">希腊大写字母Iota</target>
        </trans-unit>
        <trans-unit id="97e0c3c41b2cd617ba1f3aefc97784af90e81883" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Kappa</source>
          <target state="translated">希腊大写字母Kappa</target>
        </trans-unit>
        <trans-unit id="8766675df925b8c25168f5080a3ffb3054a6bbf7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Lamda / Greek Capital Letter Lambda</source>
          <target state="translated">希腊语大写字母Lamda/希腊语大写字母Lambda</target>
        </trans-unit>
        <trans-unit id="93f0db4c50dab02a7cf643e0e6463e461b78350b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Mu</source>
          <target state="translated">希腊语大写字母Mu</target>
        </trans-unit>
        <trans-unit id="c5ff86b57695b2194281052f49d3a518561ee43b" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Nu</source>
          <target state="translated">希腊大写字母Nu</target>
        </trans-unit>
        <trans-unit id="8d3af0cfd66c1c551b9d25df70d96ca3b3e41655" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omega</source>
          <target state="translated">希腊语大写字母Omega</target>
        </trans-unit>
        <trans-unit id="60cb22c8a7263835043a1bf3e2390a30ccb009da" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Omicron</source>
          <target state="translated">希腊大写字母Omicron</target>
        </trans-unit>
        <trans-unit id="9ef46dcc225d47def0f7ae271f6bce8a9447782c" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Phi</source>
          <target state="translated">希腊大写字母Phi</target>
        </trans-unit>
        <trans-unit id="bdfd940817a68024f4561b28e37abe5c6aa8ae33" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Pi</source>
          <target state="translated">希腊大写字母Pi</target>
        </trans-unit>
        <trans-unit id="9eb135fdc0eb8f41676f0233eced63bfb63b8d29" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Psi</source>
          <target state="translated">希腊大写字母 Psi</target>
        </trans-unit>
        <trans-unit id="42581daba465402bb427e86f725e50cbf13c5589" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Rho</source>
          <target state="translated">希腊大写字母Rho</target>
        </trans-unit>
        <trans-unit id="9ba5f4b3b8d0114e4ebb66c0c247b421553311c0" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Sigma</source>
          <target state="translated">希腊语大写字母Sigma</target>
        </trans-unit>
        <trans-unit id="ce15c49fc86bc080b59dcc6c6f912a5f65fcea89" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Tau</source>
          <target state="translated">希腊语大写字母Tau</target>
        </trans-unit>
        <trans-unit id="c53695a8df7adbb8087dbbf3f92d38bad6c54a97" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Theta</source>
          <target state="translated">希腊大写字母Theta</target>
        </trans-unit>
        <trans-unit id="e5671b238dc9a21dfba521fd40bfb114bae616b4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Upsilon</source>
          <target state="translated">希腊大写字母Upsilon</target>
        </trans-unit>
        <trans-unit id="7ee18055cc5ff646350aabb8125c5079d084ebc7" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Xi</source>
          <target state="translated">希腊语大写字母Xi</target>
        </trans-unit>
        <trans-unit id="ff11a198311aac30e2248ebcb8edaa9900afa1c4" translate="yes" xml:space="preserve">
          <source>Greek Capital Letter Zeta</source>
          <target state="translated">希腊大写字母Zeta</target>
        </trans-unit>
        <trans-unit id="75f6796d9ad54779470705290e7c7602d7a845bd" translate="yes" xml:space="preserve">
          <source>Greek Capital Theta Symbol</source>
          <target state="translated">希腊首都Theta符号</target>
        </trans-unit>
        <trans-unit id="533978fb12373ffa98e45e16bb2525fdaa4ff4dc" translate="yes" xml:space="preserve">
          <source>Greek Kappa Symbol / Greek Small Letter Script Kappa</source>
          <target state="translated">希腊字母Kappa符号/希腊字母小楷Kappa</target>
        </trans-unit>
        <trans-unit id="098ec4a81c9f38263e62700b20a2a6894858fb2e" translate="yes" xml:space="preserve">
          <source>Greek Letter Archaic Koppa</source>
          <target state="translated">希腊字母古希腊语Koppa</target>
        </trans-unit>
        <trans-unit id="c2ec8b8cfe62422b5013f3acdd510642f682d268" translate="yes" xml:space="preserve">
          <source>Greek Letter Digamma / Greek Capital Letter Digamma</source>
          <target state="translated">希腊字母Digamma/希腊大写字母Digamma</target>
        </trans-unit>
        <trans-unit id="ced5a29435b2a381da90865a6dc27f1b51bd0151" translate="yes" xml:space="preserve">
          <source>Greek Letter Koppa / Greek Capital Letter Koppa</source>
          <target state="translated">希腊字母Koppa/希腊大写字母Koppa</target>
        </trans-unit>
        <trans-unit id="b1fd4e84b1e13403c9fa5cc0de48f63d1cf94bc6" translate="yes" xml:space="preserve">
          <source>Greek Letter Sampi / Greek Capital Letter Sampi</source>
          <target state="translated">希腊字母Sampi/希腊语大写字母 Sampi</target>
        </trans-unit>
        <trans-unit id="6736119dd29a2f705206a98b22de530d1dcccd83" translate="yes" xml:space="preserve">
          <source>Greek Letter Stigma / Greek Capital Letter Stigma</source>
          <target state="translated">希腊字母污名/希腊字母大写字母污名</target>
        </trans-unit>
        <trans-unit id="ea7aa3ec425217aedfab9d34ef40b0b566351176" translate="yes" xml:space="preserve">
          <source>Greek Lunate Epsilon Symbol</source>
          <target state="translated">希腊月牙形Epsilon符号</target>
        </trans-unit>
        <trans-unit id="dfaadea9364a20060c114ea92b3c24b30e9e1221" translate="yes" xml:space="preserve">
          <source>Greek Phi Symbol / Greek Small Letter Script Phi</source>
          <target state="translated">希腊语Phi符号/希腊语小字脚本Phi</target>
        </trans-unit>
        <trans-unit id="0ae051b71680a4d39d72cb02f855a3c712e5bd2c" translate="yes" xml:space="preserve">
          <source>Greek Pi Symbol / Greek Small Letter Omega Pi</source>
          <target state="translated">希腊圆周率符号/希腊小字母Omega Pi</target>
        </trans-unit>
        <trans-unit id="f50bb1d13ed32ec906d7d6aaaaee29e7aa027d22" translate="yes" xml:space="preserve">
          <source>Greek Reversed Lunate Epsilon Symbol</source>
          <target state="translated">希腊反转月牙形Epsilon符号</target>
        </trans-unit>
        <trans-unit id="ac07b5056a85d49adcf70f2b544a74ea6ecf6dce" translate="yes" xml:space="preserve">
          <source>Greek Rho Symbol / Greek Small Letter Tailed Rho</source>
          <target state="translated">希腊语Rho符号/希腊语小字尾Rho符号</target>
        </trans-unit>
        <trans-unit id="448dc00d610b9b19fb08a7c7e6eb0a55f13d0a5d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Alpha</source>
          <target state="translated">希腊语小字Alpha</target>
        </trans-unit>
        <trans-unit id="71d9bba39729f37db08ecc6cfd07622c292a3bcb" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Archaic Koppa</source>
          <target state="translated">希腊语小字古文Koppa</target>
        </trans-unit>
        <trans-unit id="c2455c0fc133c1c49b746a40bf7fe8a2f613a4de" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Beta</source>
          <target state="translated">希腊语小字Beta</target>
        </trans-unit>
        <trans-unit id="5f8706d38c341d4055ab40dfb27748f213e0fc49" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Chi</source>
          <target state="translated">希腊语小字Chi</target>
        </trans-unit>
        <trans-unit id="4dcd438cdc63b711ea794ef765006ad5a6535bd8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Delta</source>
          <target state="translated">希腊语小字Delta</target>
        </trans-unit>
        <trans-unit id="970eba5f1fd0ce763d594cfcc46caddd4212150e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Digamma</source>
          <target state="translated">希腊语小字Digamma</target>
        </trans-unit>
        <trans-unit id="37cc4f8ed3f230c47dc11c83e4de12cf526a1b20" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Epsilon</source>
          <target state="translated">希腊语小字Epsilon</target>
        </trans-unit>
        <trans-unit id="7ccbcb67c9381630a226a3b3c4b28371605f0d5a" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Eta</source>
          <target state="translated">希腊语小字Eta</target>
        </trans-unit>
        <trans-unit id="c074819760ca3f5bfb2e80f9147ad5e5b56ba096" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Final Sigma</source>
          <target state="translated">希腊语小字最终Sigma</target>
        </trans-unit>
        <trans-unit id="46c3a6f8bc0a7d2d96bb1cd2543a7109d5b60cf2" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Gamma</source>
          <target state="translated">希腊语小字Gamma</target>
        </trans-unit>
        <trans-unit id="4643eab845743a762892a109cabf22bfe96da620" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Iota</source>
          <target state="translated">希腊语小字Iota</target>
        </trans-unit>
        <trans-unit id="3e9ea92015aac67d0b73db674b1ba4dee8fe5484" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Kappa</source>
          <target state="translated">希腊小字Kappa</target>
        </trans-unit>
        <trans-unit id="c67601530cb0f970279b136a8b536cfe4717bcd6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Koppa</source>
          <target state="translated">希腊语小字Koppa</target>
        </trans-unit>
        <trans-unit id="8c54eb8dc3ac289b41335f3dc67e6533bf270a57" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Lamda / Greek Small Letter Lambda</source>
          <target state="translated">希腊语小字母Lamda/希腊语小字母Lambda</target>
        </trans-unit>
        <trans-unit id="7149178e5cd2592e10a36e0a107bc1c794d4f411" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Mu</source>
          <target state="translated">希腊语小字Mu</target>
        </trans-unit>
        <trans-unit id="e9b48a4ac754761a9dfd350adeabe5d343e5cb8f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Nu</source>
          <target state="translated">希腊语小字Nu</target>
        </trans-unit>
        <trans-unit id="be2da964640e6e3a6c6130c2c98b0cae86bc9a01" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omega</source>
          <target state="translated">希腊语小字母Omega</target>
        </trans-unit>
        <trans-unit id="039c14215303437a5f755bf47c77fbf3d49255e3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Omicron</source>
          <target state="translated">希腊语小字Omicron</target>
        </trans-unit>
        <trans-unit id="b844f337c63e69f41e1119e2ae91153b90ab2b4d" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Phi</source>
          <target state="translated">希腊语小字Phi</target>
        </trans-unit>
        <trans-unit id="95d050ef9ff90d9125fe852cf7d1543f2ce7e841" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Pi</source>
          <target state="translated">希腊语小字母Pi</target>
        </trans-unit>
        <trans-unit id="55e311ff6199f4bde7e5d73ace711e07be007a2f" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Psi</source>
          <target state="translated">希腊语小字Psi</target>
        </trans-unit>
        <trans-unit id="5af5bfd009ec9591a9cb29dfcc2932dec54d6ca8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Rho</source>
          <target state="translated">希腊语小字Rho</target>
        </trans-unit>
        <trans-unit id="85d8bb7b244cafeb1ab811a9df619d45d2234ea6" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sampi</source>
          <target state="translated">希腊语小字Sampi</target>
        </trans-unit>
        <trans-unit id="3ec2ed80a66bc81ead34ee55592a6ea7debfff4e" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Sigma</source>
          <target state="translated">希腊语小字Sigma</target>
        </trans-unit>
        <trans-unit id="cc430dcce9d526f42ad9a59b54895c602c6380d3" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Stigma</source>
          <target state="translated">希腊语小字标点</target>
        </trans-unit>
        <trans-unit id="7c2c0c82fe6e748bf9ed49a1f4249b9e89ebb0b8" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Tau</source>
          <target state="translated">希腊语小字Tau</target>
        </trans-unit>
        <trans-unit id="b13a88433f3cb99d5c62955aca5de95fbd232103" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Theta</source>
          <target state="translated">希腊语小字Theta</target>
        </trans-unit>
        <trans-unit id="cad5938bde69f48a48d99f9b129d82f0acd5468b" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Upsilon</source>
          <target state="translated">希腊语小字Upsilon</target>
        </trans-unit>
        <trans-unit id="0761f90b7168a502798811085d1367b5eca5af17" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Xi</source>
          <target state="translated">希腊语小字Xi</target>
        </trans-unit>
        <trans-unit id="40428b11afaf575da445431ab7ceb811220b9167" translate="yes" xml:space="preserve">
          <source>Greek Small Letter Zeta</source>
          <target state="translated">希腊语小字Zeta</target>
        </trans-unit>
        <trans-unit id="e32107e3b0620ecf09ddae3fe8f4666208d97040" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Beta</source>
          <target state="translated">希腊语字母小字Beta</target>
        </trans-unit>
        <trans-unit id="90a01f237c5981615d18499c4360233abc532e89" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Chi</source>
          <target state="translated">希腊字母小字Chi</target>
        </trans-unit>
        <trans-unit id="e6642d28d8aeb11d500775a8447736e31c6678cc" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Gamma</source>
          <target state="translated">希腊字母小字Gamma</target>
        </trans-unit>
        <trans-unit id="8b5afd737dfb2072bb758ab79fe8cc816442c922" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Phi</source>
          <target state="translated">希腊字母小字Phi</target>
        </trans-unit>
        <trans-unit id="655a658031f914446d83820f4d7947b16f05e79e" translate="yes" xml:space="preserve">
          <source>Greek Subscript Small Letter Rho</source>
          <target state="translated">希腊字母小字Rho</target>
        </trans-unit>
        <trans-unit id="be9f5ea4e76fd688fd62b7dd791af4a7ebcdb5c7" translate="yes" xml:space="preserve">
          <source>Greek Theta Symbol / Greek Small Letter Script Theta</source>
          <target state="translated">希腊文Theta符号/希腊文小字Theta字母脚本</target>
        </trans-unit>
        <trans-unit id="0dc9b81e7212e0baffe967cdd9d850d4352c89f1" translate="yes" xml:space="preserve">
          <source>Green Apple</source>
          <target state="translated">青苹果</target>
        </trans-unit>
        <trans-unit id="6c0c3305620db430350f7c25edbf10ced1e1274b" translate="yes" xml:space="preserve">
          <source>Green Book</source>
          <target state="translated">绿皮书</target>
        </trans-unit>
        <trans-unit id="6c50119d5c6855e408d9ec2a52bd79546e4c4107" translate="yes" xml:space="preserve">
          <source>Green Heart</source>
          <target state="translated">绿色的心</target>
        </trans-unit>
        <trans-unit id="91feac528389c2b95c6eef06c801f2624c19116d" translate="yes" xml:space="preserve">
          <source>Grimacing Face</source>
          <target state="translated">龇牙咧嘴</target>
        </trans-unit>
        <trans-unit id="3f363dede90226435cbc0dd5d44650f61adbd5cf" translate="yes" xml:space="preserve">
          <source>Grinning Cat Face With Smiling Eyes</source>
          <target state="translated">微笑的猫脸与微笑的眼睛</target>
        </trans-unit>
        <trans-unit id="c001d488999b87437147a6834a4b4dff1427af59" translate="yes" xml:space="preserve">
          <source>Grinning Face</source>
          <target state="translated">笑脸</target>
        </trans-unit>
        <trans-unit id="5f9c06d040ed5ced638db3bf446959a48d2a6ba5" translate="yes" xml:space="preserve">
          <source>Grinning Face With Smiling Eyes</source>
          <target state="translated">笑脸与微笑的眼睛</target>
        </trans-unit>
        <trans-unit id="7005b30f708630da7d596e53a5163b84350bd829" translate="yes" xml:space="preserve">
          <source>Grisu.print_shortest()</source>
          <target state="translated">Grisu.print_shortest()</target>
        </trans-unit>
        <trans-unit id="d511874702f7c7ad5ec3b4943a9badded191c85c" translate="yes" xml:space="preserve">
          <source>Growing Heart</source>
          <target state="translated">成长的心</target>
        </trans-unit>
        <trans-unit id="0fa148c7a4ec811ec41fa2cc8e9473dfc48a9226" translate="yes" xml:space="preserve">
          <source>Guardsman</source>
          <target state="translated">Guardsman</target>
        </trans-unit>
        <trans-unit id="94af6c4088103e96d349b87fe76774686b86faa5" translate="yes" xml:space="preserve">
          <source>Guitar</source>
          <target state="translated">Guitar</target>
        </trans-unit>
        <trans-unit id="f089f13a04cfc6546c94da2f6580d6c4eed769fc" translate="yes" xml:space="preserve">
          <source>HE</source>
          <target state="translated">HE</target>
        </trans-unit>
        <trans-unit id="9018ffc109466fc760171905d2397039bc111ebf" translate="yes" xml:space="preserve">
          <source>Had we tried to do the addition without the atomic tag, we might have gotten the wrong answer due to a race condition. An example of what would happen if we didn't avoid the race:</source>
          <target state="translated">如果我们尝试在没有原子标记的情况下做加法,我们可能会因为竞赛条件而得到错误的答案。举个例子说明如果我们不避免竞赛会发生什么。</target>
        </trans-unit>
        <trans-unit id="de960a40df3284e207ad1c9fee37b3f036f0b2a2" translate="yes" xml:space="preserve">
          <source>Hair Space</source>
          <target state="translated">头发空间</target>
        </trans-unit>
        <trans-unit id="2c7a078f496901b9f8903cc399fa79c1c3ab6b95" translate="yes" xml:space="preserve">
          <source>Haircut</source>
          <target state="translated">Haircut</target>
        </trans-unit>
        <trans-unit id="4a11632b50147a0502c9dc634f5c6e0c06ffab6b" translate="yes" xml:space="preserve">
          <source>Half-precision floating-point numbers are also supported (&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt;&lt;code&gt;Float16&lt;/code&gt;&lt;/a&gt;), but they are implemented in software and use &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; for calculations.</source>
          <target state="translated">还支持半精度浮点数（&lt;a href=&quot;../../base/numbers/index#Core.Float16&quot;&gt; &lt;code&gt;Float16&lt;/code&gt; &lt;/a&gt;），但是它们是在软件中实现的，并且使用&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;进行计算。</target>
        </trans-unit>
        <trans-unit id="94c92dceffd55b3ed538a942cce80806cce37fe1" translate="yes" xml:space="preserve">
          <source>Hamburger</source>
          <target state="translated">Hamburger</target>
        </trans-unit>
        <trans-unit id="ab7b8ea47eadf93146c012e72a5ea673322853aa" translate="yes" xml:space="preserve">
          <source>Hammer</source>
          <target state="translated">Hammer</target>
        </trans-unit>
        <trans-unit id="3bff32cf99bd14d58869cbb0d7d31e1bec45d891" translate="yes" xml:space="preserve">
          <source>Hamster Face</source>
          <target state="translated">仓鼠脸</target>
        </trans-unit>
        <trans-unit id="3d3f4dc94e3e321e028a018fa9cae5ff030ce957" translate="yes" xml:space="preserve">
          <source>Handbag</source>
          <target state="translated">Handbag</target>
        </trans-unit>
        <trans-unit id="fffe7d81b4e3e0d9952aa6caa3fd530df68b775c" translate="yes" xml:space="preserve">
          <source>Handle a log event</source>
          <target state="translated">处理一个日志事件</target>
        </trans-unit>
        <trans-unit id="e30eba0eb24c7a8fac8f9c3ba83240b293b51b33" translate="yes" xml:space="preserve">
          <source>Handle excess argument diversity in the caller</source>
          <target state="translated">处理调用者中过多的参数多样性</target>
        </trans-unit>
        <trans-unit id="10a3cb0df00f1fa97a3cb63486616c5cf79959d9" translate="yes" xml:space="preserve">
          <source>Handling Operating System Variation</source>
          <target state="translated">处理操作系统的变化</target>
        </trans-unit>
        <trans-unit id="67509204a791b926a290df40bb29deed545a4fe9" translate="yes" xml:space="preserve">
          <source>Happy Person Raising One Hand</source>
          <target state="translated">快乐的人举起一只手</target>
        </trans-unit>
        <trans-unit id="31f205e87d98bf7472c8354a4586dfc7173d7021" translate="yes" xml:space="preserve">
          <source>Hatching Chick</source>
          <target state="translated">孵化小鸡</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="6ef295c2897db61289ad0eb0b8171326ec851011" translate="yes" xml:space="preserve">
          <source>Headphone</source>
          <target state="translated">Headphone</target>
        </trans-unit>
        <trans-unit id="83fbe44a9f704c02d2d76ee1fa5c115010ff9d8c" translate="yes" xml:space="preserve">
          <source>Hear-No-Evil Monkey</source>
          <target state="translated">邪恶的猴子</target>
        </trans-unit>
        <trans-unit id="2edafb06cf3a183a503a1615f5b8c4da86990553" translate="yes" xml:space="preserve">
          <source>Heart Decoration</source>
          <target state="translated">心形装饰</target>
        </trans-unit>
        <trans-unit id="53648eedc9bfa102fd53ca957c856f7e0d9a2a2f" translate="yes" xml:space="preserve">
          <source>Heart With Arrow</source>
          <target state="translated">心与箭</target>
        </trans-unit>
        <trans-unit id="5461f091ddf4a776ade53602bfcdef544a0feb57" translate="yes" xml:space="preserve">
          <source>Heart With Ribbon</source>
          <target state="translated">心与蝴蝶结</target>
        </trans-unit>
        <trans-unit id="fde3248d8454a04a4138dae1e5a31ab1432bdb78" translate="yes" xml:space="preserve">
          <source>Heavy Black Heart</source>
          <target state="translated">沉重的黑心</target>
        </trans-unit>
        <trans-unit id="662b2b0a5e62dab41b3f6deba4867bbd60a35b8f" translate="yes" xml:space="preserve">
          <source>Heavy Check Mark</source>
          <target state="translated">沉重的检查标记</target>
        </trans-unit>
        <trans-unit id="9ae6c1b9f7bdda7ce9eec6a4c6ee5efca7c871a5" translate="yes" xml:space="preserve">
          <source>Heavy Division Sign</source>
          <target state="translated">重型师团标志</target>
        </trans-unit>
        <trans-unit id="7706e6c735cc207b9267e0979a8dbeb69e5229a0" translate="yes" xml:space="preserve">
          <source>Heavy Dollar Sign</source>
          <target state="translated">沉重的美元标志</target>
        </trans-unit>
        <trans-unit id="93e9c9786874a2de0cddf3ee5e7766e4ea031dca" translate="yes" xml:space="preserve">
          <source>Heavy Exclamation Mark Symbol</source>
          <target state="translated">沉重的感叹号符号</target>
        </trans-unit>
        <trans-unit id="78800e7776274c794a8d095ff4c2c73221dbbbae" translate="yes" xml:space="preserve">
          <source>Heavy Large Circle</source>
          <target state="translated">重型大圆环</target>
        </trans-unit>
        <trans-unit id="980c6d0d2733f3166210e842cefb858e063c0d91" translate="yes" xml:space="preserve">
          <source>Heavy Minus Sign</source>
          <target state="translated">重负号</target>
        </trans-unit>
        <trans-unit id="778bd00186fa7e144e55b7635e11bf1326888ddd" translate="yes" xml:space="preserve">
          <source>Heavy Multiplication X</source>
          <target state="translated">重度乘法X</target>
        </trans-unit>
        <trans-unit id="f686b15ee80bdb7a610f665e9bb567ee7025d65c" translate="yes" xml:space="preserve">
          <source>Heavy Plus Sign</source>
          <target state="translated">重型加号</target>
        </trans-unit>
        <trans-unit id="75c1e5a632008728c5938fd7cc30c147bf32b6b5" translate="yes" xml:space="preserve">
          <source>Heavy Teardrop-Spoked Asterisk</source>
          <target state="translated">沉重的水滴形星号</target>
        </trans-unit>
        <trans-unit id="fda201fd52a223f4da8ab6d74bf72a21faeaf60b" translate="yes" xml:space="preserve">
          <source>Helicopter</source>
          <target state="translated">Helicopter</target>
        </trans-unit>
        <trans-unit id="ae573d0f71ca2ef898057a3a11aeabc86f4048c4" translate="yes" xml:space="preserve">
          <source>Help mode</source>
          <target state="translated">帮助模式</target>
        </trans-unit>
        <trans-unit id="5941c1bf985d2850f77798f46b591f5bf1a7198a" translate="yes" xml:space="preserve">
          <source>Help mode can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">按行首的退格键可以退出帮助模式。</target>
        </trans-unit>
        <trans-unit id="8882ebfc5a29fddc8a80eb230261926f56fd8d5e" translate="yes" xml:space="preserve">
          <source>Herb</source>
          <target state="translated">Herb</target>
        </trans-unit>
        <trans-unit id="bb934b9ceeaa4e54809a9838dfa1ed2cabf6522e" translate="yes" xml:space="preserve">
          <source>Here &quot;inline&quot; refers to elements that can be found within blocks of text, i.e. paragraphs. These include the following elements.</source>
          <target state="translated">这里的 &quot;内联 &quot;指的是可以在文本块(即段落)中找到的元素。这些元素包括以下内容:</target>
        </trans-unit>
        <trans-unit id="0aaf5b43ce3bf447f656063f8ac61c46b777eefc" translate="yes" xml:space="preserve">
          <source>Here Enter was pressed again so that Julia would read the newline. Now, as you can see from this example, &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; takes the data to write as its second argument, while &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; takes the type of the data to be read as the second argument.</source>
          <target state="translated">在这里再次按下Enter键，以便Julia读取换行符。现在，从该示例可以看到，&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;将要写入的数据作为第二个参数，而&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;则将要读取的数据的类型作为第二个参数。</target>
        </trans-unit>
        <trans-unit id="77b8367f53858f5da92aefb29bb20f4abb25843a" translate="yes" xml:space="preserve">
          <source>Here are some examples to demonstrate which type of arrays are strided and which are not:</source>
          <target state="translated">下面是一些例子来证明哪些类型的数组是跨步的,哪些不是。</target>
        </trans-unit>
        <trans-unit id="3b3a2127d824649ba6d32ad8be94f9ae3c5dba0e" translate="yes" xml:space="preserve">
          <source>Here are some examples with bitwise operators:</source>
          <target state="translated">下面是一些带有位运算符的例子。</target>
        </trans-unit>
        <trans-unit id="c2d9b5adfe6cd0f32ce45f61d872c609d6e0a4ff" translate="yes" xml:space="preserve">
          <source>Here are some simple examples using arithmetic operators:</source>
          <target state="translated">下面是一些使用算术运算符的简单例子。</target>
        </trans-unit>
        <trans-unit id="f5ba1cb3713902ae4550268fb70da7530b34b57c" translate="yes" xml:space="preserve">
          <source>Here are some simple examples:</source>
          <target state="translated">下面是一些简单的例子。</target>
        </trans-unit>
        <trans-unit id="d3d30b41b93723417b3a0eda16323a2baedc0a7c" translate="yes" xml:space="preserve">
          <source>Here are some tips for working with Julia efficiently.</source>
          <target state="translated">以下是一些与Julia高效合作的技巧。</target>
        </trans-unit>
        <trans-unit id="4b9dc1697c31ccdd9965aa0170dd226712f2cb14" translate="yes" xml:space="preserve">
          <source>Here each iteration applies &lt;code&gt;f&lt;/code&gt; to a randomly-chosen sample from a vector &lt;code&gt;a&lt;/code&gt; shared by all processes.</source>
          <target state="translated">这里，每次迭代将 &lt;code&gt;f&lt;/code&gt; 应用于所有进程共享的向量 &lt;code&gt;a&lt;/code&gt; 中的随机选择样本。</target>
        </trans-unit>
        <trans-unit id="a76feb46cab9b567bf7483afc7491ed744f3c054" translate="yes" xml:space="preserve">
          <source>Here is a corresponding roots structure, represented as a dictionary:</source>
          <target state="translated">这里是一个相应的根结构,用字典表示。</target>
        </trans-unit>
        <trans-unit id="86a5b746f6fe4ea8f489a225c69f586c3ee94b4f" translate="yes" xml:space="preserve">
          <source>Here is a more complex example, still using Markdown:</source>
          <target state="translated">下面是一个比较复杂的例子,仍然使用Markdown。</target>
        </trans-unit>
        <trans-unit id="32a32a63972b7e15e6bc1e1399ca59536eaf91cf" translate="yes" xml:space="preserve">
          <source>Here is a related case in which the expected behaviour is not necessarily obvious: What happens when we round to the nearest &lt;code&gt;P(2)&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a &lt;a href=&quot;#Dates.Period&quot;&gt;&lt;code&gt;Period&lt;/code&gt;&lt;/a&gt; type? In some cases (specifically, when &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt;) the answer is clear:</source>
          <target state="translated">这是一个预期的行为不一定很明显的相关情况：当我们舍入到最接近的 &lt;code&gt;P(2)&lt;/code&gt; 时会发生什么，其中 &lt;code&gt;P&lt;/code&gt; 是&lt;a href=&quot;#Dates.Period&quot;&gt; &lt;code&gt;Period&lt;/code&gt; &lt;/a&gt;类型？在某些情况下（特别是当 &lt;code&gt;P &amp;lt;: Dates.TimePeriod&lt;/code&gt; ），答案很明确：</target>
        </trans-unit>
        <trans-unit id="cbc1a6d954403affcd824e28b3f149fcba6203f0" translate="yes" xml:space="preserve">
          <source>Here is a representation of a possible paths map for our example &lt;code&gt;App&lt;/code&gt; project environment, as provided in the Manifest given above for the dependency graph, after searching the local file system:</source>
          <target state="translated">搜索本地文件系统后，这是我们的示例 &lt;code&gt;App&lt;/code&gt; 项目环境的可能路径映射的表示形式，如上面在清单中为依赖关系图所提供的那样：</target>
        </trans-unit>
        <trans-unit id="62b973b3d8599e23c2d9da9c0813b08faed1d7f5" translate="yes" xml:space="preserve">
          <source>Here is a second example wrapping the corresponding destructor:</source>
          <target state="translated">这里是第二个包装相应的destructor的例子。</target>
        </trans-unit>
        <trans-unit id="383164a53efb4be492fb1a747035c59b715f139a" translate="yes" xml:space="preserve">
          <source>Here is a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="translated">这是一个返回 &lt;code&gt;Ptr&lt;/code&gt; 类型的C包装器的简单示例：</target>
        </trans-unit>
        <trans-unit id="fd4023e74c6b03e666e958ff6141359ac199b811" translate="yes" xml:space="preserve">
          <source>Here is a simplified definition of Julia's &lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt;&lt;code&gt;@assert&lt;/code&gt;&lt;/a&gt; macro:</source>
          <target state="translated">这是Julia的&lt;a href=&quot;../../base/base/index#Base.@assert&quot;&gt; &lt;code&gt;@assert&lt;/code&gt; &lt;/a&gt;宏的简化定义：</target>
        </trans-unit>
        <trans-unit id="ac903f23df192b2cec33704052829cedd04df512" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname. In this example, the networking library code is assumed to be in a shared library named &quot;libc&quot;. In practice, this function is usually part of the C standard library, and so the &quot;libc&quot; portion should be omitted, but we wish to show here the usage of this syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e40b5507bd00f53ac4347d820f9aea2085f1e997" translate="yes" xml:space="preserve">
          <source>Here is a slightly more complex example that discovers the local machine's hostname:</source>
          <target state="translated">下面是一个稍微复杂一点的例子,可以发现本地机器的主机名。</target>
        </trans-unit>
        <trans-unit id="c20460c3bed82c94ed3787e3dfe27ae7c3b31699" translate="yes" xml:space="preserve">
          <source>Here is a third example passing Julia arrays:</source>
          <target state="translated">下面是第三个传递Julia数组的例子。</target>
        </trans-unit>
        <trans-unit id="d610a40401dd7269ef98b9bc1fb559f31c643ca5" translate="yes" xml:space="preserve">
          <source>Here is an even more complex multi-stage producer-consumer example:</source>
          <target state="translated">下面是一个更复杂的多阶段生产者-消费者的例子。</target>
        </trans-unit>
        <trans-unit id="166759fbb289c37473d7a6b4b102bc98c71ab976" translate="yes" xml:space="preserve">
          <source>Here is an example of a &quot;compound function&quot; that should really be written as multiple definitions:</source>
          <target state="translated">这里是一个 &quot;复合函数 &quot;的例子,其实应该写成多个定义。</target>
        </trans-unit>
        <trans-unit id="dff5c26dbc80f0776c11c28a5633445af4d9d175" translate="yes" xml:space="preserve">
          <source>Here is an example with all three kinds of markup. This program first calculates the finite difference of a one-dimensional array, and then evaluates the L2-norm of the result:</source>
          <target state="translated">下面是一个包含这三种标记的例子。这个程序首先计算一维数组的有限差分,然后评估结果的L2-norm。</target>
        </trans-unit>
        <trans-unit id="f97cb2973176feb8f941a5117a88dd7fad7d8ec1" translate="yes" xml:space="preserve">
          <source>Here is an example with both &lt;code&gt;@inbounds&lt;/code&gt; and &lt;code&gt;@simd&lt;/code&gt; markup (we here use &lt;code&gt;@noinline&lt;/code&gt; to prevent the optimizer from trying to be too clever and defeat our benchmark):</source>
          <target state="translated">这是同时 &lt;code&gt;@inbounds&lt;/code&gt; 和 &lt;code&gt;@simd&lt;/code&gt; 标记的示例（我们在这里使用 &lt;code&gt;@noinline&lt;/code&gt; 来防止优化器过于聪明并破坏我们的基准）：</target>
        </trans-unit>
        <trans-unit id="87f18e8d7ee1b76e68d3166f552e8d656c81958f" translate="yes" xml:space="preserve">
          <source>Here is an extraordinarily simple macro:</source>
          <target state="translated">这里有一个特别简单的宏。</target>
        </trans-unit>
        <trans-unit id="7afc02096736fcb4c01a0c6afaea2e90973eb75e" translate="yes" xml:space="preserve">
          <source>Here is the correct code template for returning the element-type &lt;code&gt;T&lt;/code&gt; of any arbitrary subtype of &lt;code&gt;AbstractArray&lt;/code&gt;:</source>
          <target state="translated">这是用于返回 &lt;code&gt;AbstractArray&lt;/code&gt; 的任意子类型的元素类型 &lt;code&gt;T&lt;/code&gt; 的正确代码模板：</target>
        </trans-unit>
        <trans-unit id="5f4fdb43158ce32a870e863c53f180f3aa098a57" translate="yes" xml:space="preserve">
          <source>Here is the corresponding graph structure, represented as a dictionary:</source>
          <target state="translated">这里是对应的图结构,用字典表示。</target>
        </trans-unit>
        <trans-unit id="f9b6eba975c84af5ac0af3798604d9ad36108359" translate="yes" xml:space="preserve">
          <source>Here module &lt;code&gt;Parent&lt;/code&gt; contains a submodule &lt;code&gt;Utils&lt;/code&gt;, and code in &lt;code&gt;Parent&lt;/code&gt; wants the contents of &lt;code&gt;Utils&lt;/code&gt; to be visible. This is done by starting the &lt;code&gt;using&lt;/code&gt; path with a period. Adding more leading periods moves up additional levels in the module hierarchy. For example &lt;code&gt;using ..Utils&lt;/code&gt; would look for &lt;code&gt;Utils&lt;/code&gt; in &lt;code&gt;Parent&lt;/code&gt;'s enclosing module rather than in &lt;code&gt;Parent&lt;/code&gt; itself.</source>
          <target state="translated">在此模块 &lt;code&gt;Parent&lt;/code&gt; 包含一个子模块 &lt;code&gt;Utils&lt;/code&gt; ，并在代码 &lt;code&gt;Parent&lt;/code&gt; 希望的内容 &lt;code&gt;Utils&lt;/code&gt; 是可见的。这是通过 &lt;code&gt;using&lt;/code&gt; 句点开始使用路径来完成的。添加更多的前置期可以在模块层次结构中上移其他层次。例如， &lt;code&gt;using ..Utils&lt;/code&gt; 将在 &lt;code&gt;Parent&lt;/code&gt; 的封闭模块而不是 &lt;code&gt;Parent&lt;/code&gt; 本身中查找 &lt;code&gt;Utils&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cf5b1250aa2128de01974785ca5a0cd9b855ebd1" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;1:5&lt;/code&gt; is a range object, representing the sequence of numbers 1, 2, 3, 4, 5. The &lt;code&gt;for&lt;/code&gt; loop iterates through these values, assigning each one in turn to the variable &lt;code&gt;i&lt;/code&gt;. One rather important distinction between the previous &lt;code&gt;while&lt;/code&gt; loop form and the &lt;code&gt;for&lt;/code&gt; loop form is the scope during which the variable is visible. If the variable &lt;code&gt;i&lt;/code&gt; has not been introduced in another scope, in the &lt;code&gt;for&lt;/code&gt; loop form, it is visible only inside of the &lt;code&gt;for&lt;/code&gt; loop, and not outside/afterwards. You'll either need a new interactive session instance or a different variable name to test this:</source>
          <target state="translated">在这里， &lt;code&gt;1:5&lt;/code&gt; 的范围对象，表示数字1，2，3，4的顺序，5 &lt;code&gt;for&lt;/code&gt; 通过这些数值循环迭代中，分配每一个依次与可变 &lt;code&gt;i&lt;/code&gt; 。前一个 &lt;code&gt;while&lt;/code&gt; 循环形式和 &lt;code&gt;for&lt;/code&gt; 循环形式之间的一个相当重要的区别是变量可见的范围。如果变量 &lt;code&gt;i&lt;/code&gt; 尚未以 &lt;code&gt;for&lt;/code&gt; 循环形式引入其他范围，则仅在 &lt;code&gt;for&lt;/code&gt; 循环内部可见，而在外部/之后则不可见。您将需要一个新的交互式会话实例或一个不同的变量名称来对此进行测试：</target>
        </trans-unit>
        <trans-unit id="052893fe9e50a40443ea78d54cd3b33cb280eb4e" translate="yes" xml:space="preserve">
          <source>Here the call &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; could be handled by either the &lt;code&gt;g(Float64, Any)&lt;/code&gt; or the &lt;code&gt;g(Any, Float64)&lt;/code&gt; method, and neither is more specific than the other. In such cases, Julia raises a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; rather than arbitrarily picking a method. You can avoid method ambiguities by specifying an appropriate method for the intersection case:</source>
          <target state="translated">在这里，调用 &lt;code&gt;g(2.0, 3.0)&lt;/code&gt; 可以由 &lt;code&gt;g(Float64, Any)&lt;/code&gt; 或 &lt;code&gt;g(Any, Float64)&lt;/code&gt; 方法处理，两者都不比其他方法更具体。在这种情况下，Julia引发&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;而不是任意选择一个方法。您可以通过为相交情况指定适当的方法来避免方法歧义：</target>
        </trans-unit>
        <trans-unit id="373c14d6a8445cd3c00b580baccefb5fd3f3d12c" translate="yes" xml:space="preserve">
          <source>Here the first number is printed after a delay of two seconds, then the following numbers are printed quickly.</source>
          <target state="translated">在这里,第一个数字在延迟两秒后打印,然后快速打印下面的数字。</target>
        </trans-unit>
        <trans-unit id="f3418902a4f242b518d4d5f42412b650db9149b7" translate="yes" xml:space="preserve">
          <source>Here the user expression &lt;code&gt;ex&lt;/code&gt; is a call to &lt;code&gt;time&lt;/code&gt;, but not the same &lt;code&gt;time&lt;/code&gt; function that the macro uses. It clearly refers to &lt;code&gt;MyModule.time&lt;/code&gt;. Therefore we must arrange for the code in &lt;code&gt;ex&lt;/code&gt; to be resolved in the macro call environment. This is done by &quot;escaping&quot; the expression with &lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt;&lt;code&gt;esc&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">这里的用户表达式 &lt;code&gt;ex&lt;/code&gt; 是对 &lt;code&gt;time&lt;/code&gt; 的调用，但不是宏使用的同一 &lt;code&gt;time&lt;/code&gt; 函数。它明确地指向 &lt;code&gt;MyModule.time&lt;/code&gt; 。因此，我们必须安排 &lt;code&gt;ex&lt;/code&gt; 中的代码在宏调用环境中进行解析。这可以通过使用&lt;a href=&quot;../../base/base/index#Base.esc&quot;&gt; &lt;code&gt;esc&lt;/code&gt; &lt;/a&gt; &amp;ldquo;转义&amp;rdquo;表达式来完成：</target>
        </trans-unit>
        <trans-unit id="319de09db8b0ceed706c2722ad8c4f12c486b513" translate="yes" xml:space="preserve">
          <source>Here the zero-argument constructor method calls the single-argument constructor method, which in turn calls the automatically provided two-argument constructor method. For reasons that will become clear very shortly, additional constructor methods declared as normal methods like this are called &lt;em&gt;outer&lt;/em&gt; constructor methods. Outer constructor methods can only ever create a new instance by calling another constructor method, such as the automatically provided default ones.</source>
          <target state="translated">此处，零参数构造函数方法调用单参数构造函数方法，后者又调用自动提供的两参数构造函数方法。由于很快就会明白的原因，像这样的声明为普通方法的其他构造方法称为&lt;em&gt;外部&lt;/em&gt;构造方法。外部构造函数方法只能通过调用另一个构造函数方法（例如自动提供的默认实例）来创建新实例。</target>
        </trans-unit>
        <trans-unit id="754489125a9dd659e2690c5c486d5c6350ca9a2b" translate="yes" xml:space="preserve">
          <source>Here we create and store two closures that return variable &lt;code&gt;i&lt;/code&gt;. However, it is always the same variable &lt;code&gt;i&lt;/code&gt;, so the two closures behave identically. We can use &lt;code&gt;let&lt;/code&gt; to create a new binding for &lt;code&gt;i&lt;/code&gt;:</source>
          <target state="translated">在这里，我们创建并存储两个返回变量 &lt;code&gt;i&lt;/code&gt; 的闭包。但是，它始终是相同的变量 &lt;code&gt;i&lt;/code&gt; ，因此两个闭包的行为相同。我们可以使用 &lt;code&gt;let&lt;/code&gt; 为 &lt;code&gt;i&lt;/code&gt; 创建一个新的绑定：</target>
        </trans-unit>
        <trans-unit id="f311d723a18a177fef2791eca3f472638877d565" translate="yes" xml:space="preserve">
          <source>Here we created a function &lt;code&gt;change_array!&lt;/code&gt;, that assigns &lt;code&gt;5&lt;/code&gt; to the first element of the passed array (bound to &lt;code&gt;x&lt;/code&gt; at the call site, and bound to &lt;code&gt;A&lt;/code&gt; within the function). Notice that, after the function call, &lt;code&gt;x&lt;/code&gt; is still bound to the same array, but the content of that array changed: the variables &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; were distinct bindings referring to the same mutable &lt;code&gt;Array&lt;/code&gt; object.</source>
          <target state="translated">在这里，我们创建了一个函数 &lt;code&gt;change_array!&lt;/code&gt; ，将 &lt;code&gt;5&lt;/code&gt; 分配给所传递数组的第一个元素（在调用位置绑定到 &lt;code&gt;x&lt;/code&gt; ，并在函数内绑定到 &lt;code&gt;A&lt;/code&gt; ）。请注意，在函数调用之后， &lt;code&gt;x&lt;/code&gt; 仍绑定到同一数组，但是该数组的内容发生了变化：变量 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;x&lt;/code&gt; 是引用同一可变 &lt;code&gt;Array&lt;/code&gt; 对象的不同绑定。</target>
        </trans-unit>
        <trans-unit id="36a8f92884e992830034696fb443df46cbb7f016" translate="yes" xml:space="preserve">
          <source>Here we define a sampler for a collection. If no pre-computed data is required, it can be implemented with a &lt;code&gt;SamplerTrivial&lt;/code&gt; sampler, which is in fact the &lt;em&gt;default fallback for values&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97836fe829ccf3f620529d58616382e12cd6d98d" translate="yes" xml:space="preserve">
          <source>Here we have created a type &lt;code&gt;BitVector&lt;/code&gt; which has no parameters, but where the element-type is still fully specified, with &lt;code&gt;T&lt;/code&gt; equal to &lt;code&gt;Bool&lt;/code&gt;!</source>
          <target state="translated">在这里，我们创建了一个没有参数的 &lt;code&gt;BitVector&lt;/code&gt; 类型，但是仍然完全指定了element-type，其中 &lt;code&gt;T&lt;/code&gt; 等于 &lt;code&gt;Bool&lt;/code&gt; ！</target>
        </trans-unit>
        <trans-unit id="5afb8d5acf60ecdcd4dfe5d3e5a47e7bac7660ac" translate="yes" xml:space="preserve">
          <source>Here we use &lt;a href=&quot;../../base/base/index#Base.include_string&quot;&gt;&lt;code&gt;include_string&lt;/code&gt;&lt;/a&gt;, to evaluate &lt;code&gt;code&lt;/code&gt; as though it were the contents of a file. We could also save &lt;code&gt;code&lt;/code&gt; to a file and then call &lt;code&gt;include&lt;/code&gt; on that file&amp;mdash;the result would be the same. As you can see, this behaves quite different from evaluating the same code in the REPL. Let's break down what's happening here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9af6aad35623f9ee689638f54770ed7633fd26" translate="yes" xml:space="preserve">
          <source>Here's a brief example:</source>
          <target state="translated">下面是一个简单的例子。</target>
        </trans-unit>
        <trans-unit id="e0b11719421310c6cc4a896b044019316b57f70b" translate="yes" xml:space="preserve">
          <source>Here's a simple example of running an external program:</source>
          <target state="translated">下面是一个运行外部程序的简单例子。</target>
        </trans-unit>
        <trans-unit id="1cdb1c514a8c4179306e34bfddd814358210098d" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a6acaa904201f8599df8ef13450aeef27c5681" translate="yes" xml:space="preserve">
          <source>Here, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; first opens the file for writing and then passes the resulting output stream to the anonymous function you defined in the &lt;code&gt;do ... end&lt;/code&gt; block. After your function exits, &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; will make sure that the stream is properly closed, regardless of whether your function exited normally or threw an exception. (The &lt;code&gt;try/finally&lt;/code&gt; construct will be described in &lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow&lt;/a&gt;.)</source>
          <target state="translated">在这里，&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;首先打开要写入的文件，然后将结果输出流传递给您在 &lt;code&gt;do ... end&lt;/code&gt; 块中定义的匿名函数。函数退出后，无论函数正常退出还是引发异常，&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;都会确保流已正确关闭。（ &lt;code&gt;try/finally&lt;/code&gt; 结构将在&lt;a href=&quot;../control-flow/index#Control-Flow-1&quot;&gt;Control Flow中&lt;/a&gt;描述。）</target>
        </trans-unit>
        <trans-unit id="b6b3a9234aa3e202da30078d8340c4a596ef7790" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; and the first argument &amp;mdash; the element type &amp;mdash; is optional, defaulting to &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a90ca3f6b58f2547fca94266c1813296e387071" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;(2, 3)&lt;/code&gt; is a &lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;(2, 3)&lt;/code&gt; 是一个&lt;a href=&quot;../../base/base/index#Core.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="5216371c7d0926d72d95ff987a3d80e32321d1dd" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;count&lt;/code&gt; finds the number of commits along the walk with a certain &lt;code&gt;GitHash&lt;/code&gt;. Since the &lt;code&gt;GitHash&lt;/code&gt; is unique to a commit, &lt;code&gt;cnt&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;count&lt;/code&gt; 查找使用某个 &lt;code&gt;GitHash&lt;/code&gt; 的遍历中的提交数。由于 &lt;code&gt;GitHash&lt;/code&gt; 对于提交是唯一的，因此 &lt;code&gt;cnt&lt;/code&gt; 将为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2161ca87d055525464e4a5b1fd21109ca2813404" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;map&lt;/code&gt; visits each commit using the &lt;code&gt;GitRevWalker&lt;/code&gt; and finds its &lt;code&gt;GitHash&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;map&lt;/code&gt; 使用 &lt;code&gt;GitRevWalker&lt;/code&gt; 访问每个提交并找到其 &lt;code&gt;GitHash&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="290a784ce45faad752be9227fb340601f3f76ead" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;sp.data&lt;/code&gt; refers to the second parameter in the call to the &lt;code&gt;SamplerSimple&lt;/code&gt; constructor (in this case equal to &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt;), while the &lt;code&gt;Die&lt;/code&gt; object can be accessed via &lt;code&gt;sp[]&lt;/code&gt;.</source>
          <target state="translated">在这里， &lt;code&gt;sp.data&lt;/code&gt; 指向对 &lt;code&gt;SamplerSimple&lt;/code&gt; 构造函数的调用中的第二个参数（在本例中等于 &lt;code&gt;Sampler(rng, 1:die.nsides, r)&lt;/code&gt; ），而 &lt;code&gt;Die&lt;/code&gt; 对象可以通过 &lt;code&gt;sp[]&lt;/code&gt; 访问。</target>
        </trans-unit>
        <trans-unit id="e6537ead3e178965ea266058307a50f1c2fbf640" translate="yes" xml:space="preserve">
          <source>Here, Julia was able to detect that &lt;code&gt;B&lt;/code&gt; is in fact symmetric, and used a more appropriate factorization. Often it's possible to write more efficient code for a matrix that is known to have certain properties e.g. it is symmetric, or tridiagonal. Julia provides some special types so that you can &quot;tag&quot; matrices as having these properties. For instance:</source>
          <target state="translated">在这里，Julia能够检测到 &lt;code&gt;B&lt;/code&gt; 实际上是对称的，并使用了更合适的因式分解。通常，可以为已知具有某些属性（例如对称或三对角）的矩阵编写更有效的代码。Julia提供了一些特殊类型，以便您可以&amp;ldquo;标记&amp;rdquo;具有这些属性的矩阵。例如：</target>
        </trans-unit>
        <trans-unit id="c40867232cf6016f6f8e42d642627bb64b253d86" translate="yes" xml:space="preserve">
          <source>Here, the evaluation of an expression object causes a value to be assigned to the global variable &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">在此，表达式对象的求值导致将一个值分配给全局变量 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6153340adbaa08a931cc654aec620e3452eb7b03" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e6a3f428f565fb6b0000baaea7b4aa785dbcfc" translate="yes" xml:space="preserve">
          <source>Here, the input &lt;code&gt;p&lt;/code&gt; is declared to be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, meaning that the memory that &lt;code&gt;p&lt;/code&gt; points to may be managed by Julia or by C. A pointer to memory allocated by C should be of type &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt;, but it is convertible using &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; and therefore can be used in the same (covariant) context of the input argument to a &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;. A pointer to memory allocated by Julia must be of type &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt;, to ensure that the memory address pointed to is valid and that Julia's garbage collector manages the chunk of memory pointed to correctly. Therefore, the &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; declaration allows pointers managed by C or Julia to be used.</source>
          <target state="translated">在这里，输入 &lt;code&gt;p&lt;/code&gt; 声明为 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 类型，这意味着 &lt;code&gt;p&lt;/code&gt; 指向的内存可以由Julia或C管理。指向C分配的内存的指针应为 &lt;code&gt;Ptr{gsl_permutation}&lt;/code&gt; 类型，但是它可以使用&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;转换，因此可以在&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;的输入参数的相同（协变）上下文中使用。指向Julia分配的内存的指针必须为 &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 类型，以确保指向的内存地址有效，并且Julia的垃圾回收器可以正确管理指向的内存块。因此， &lt;code&gt;Ref{gsl_permutation}&lt;/code&gt; 声明允许使用C或Julia管理的指针。</target>
        </trans-unit>
        <trans-unit id="1ab09345f1dd2caf08c8b3f5ca36d5682164ea59" translate="yes" xml:space="preserve">
          <source>Here, the option &lt;code&gt;--math-mode=ieee&lt;/code&gt; disables the &lt;code&gt;@fastmath&lt;/code&gt; macro, so that we can compare results.</source>
          <target state="translated">在这里，选项 &lt;code&gt;--math-mode=ieee&lt;/code&gt; 禁用了 &lt;code&gt;@fastmath&lt;/code&gt; 宏，以便我们可以比较结果。</target>
        </trans-unit>
        <trans-unit id="6cbc6c9a872faab52c966ca377e3e05b9b758b19" translate="yes" xml:space="preserve">
          <source>Here, the total produced by &lt;code&gt;sum&lt;/code&gt; is passed to the &lt;code&gt;sqrt&lt;/code&gt; function. The equivalent composition would be:</source>
          <target state="translated">在这里，由 &lt;code&gt;sum&lt;/code&gt; 产生的总数将传递给 &lt;code&gt;sqrt&lt;/code&gt; 函数。等效组成为：</target>
        </trans-unit>
        <trans-unit id="4e8ac284e43281c0f4a614327786f479a4ecc8c6" translate="yes" xml:space="preserve">
          <source>Here, though, we'll use the text-based display that comes with the standard library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab8445a2aa7f75fce1fbdd298d4317a2e164c25" translate="yes" xml:space="preserve">
          <source>Here, we happened to know that the first element of &lt;code&gt;a&lt;/code&gt; would be an &lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/a&gt;. Making an annotation like this has the added benefit that it will raise a run-time error if the value is not of the expected type, potentially catching certain bugs earlier.</source>
          <target state="translated">在这里，我们碰巧知道 &lt;code&gt;a&lt;/code&gt; 的第一个元素是&lt;a href=&quot;../../base/numbers/index#Core.Int32&quot;&gt; &lt;code&gt;Int32&lt;/code&gt; &lt;/a&gt;。进行这样的注释会带来额外的好处，即如果该值不是预期的类型，它将引发运行时错误，从而可能更早地捕获某些错误。</target>
        </trans-unit>
        <trans-unit id="3b5f47a75f954e4b2fddf51e62aa2e1f9d263c7c" translate="yes" xml:space="preserve">
          <source>Here, we want &lt;code&gt;t0&lt;/code&gt;, &lt;code&gt;t1&lt;/code&gt;, and &lt;code&gt;val&lt;/code&gt; to be private temporary variables, and we want &lt;code&gt;time&lt;/code&gt; to refer to the &lt;code&gt;time&lt;/code&gt; function in Julia Base, not to any &lt;code&gt;time&lt;/code&gt; variable the user might have (the same applies to &lt;code&gt;println&lt;/code&gt;). Imagine the problems that could occur if the user expression &lt;code&gt;ex&lt;/code&gt; also contained assignments to a variable called &lt;code&gt;t0&lt;/code&gt;, or defined its own &lt;code&gt;time&lt;/code&gt; variable. We might get errors, or mysteriously incorrect behavior.</source>
          <target state="translated">在这里，我们希望 &lt;code&gt;t0&lt;/code&gt; ， &lt;code&gt;t1&lt;/code&gt; 和 &lt;code&gt;val&lt;/code&gt; 为私有临时变量，并且我们希望 &lt;code&gt;time&lt;/code&gt; 引用Julia Base中的 &lt;code&gt;time&lt;/code&gt; 函数，而不是用户可能拥有的任何 &lt;code&gt;time&lt;/code&gt; 变量（对 &lt;code&gt;println&lt;/code&gt; 也是一样）。想象一下，如果用户表达式 &lt;code&gt;ex&lt;/code&gt; 还包含对名为 &lt;code&gt;t0&lt;/code&gt; 的变量的赋值或定义了自己的 &lt;code&gt;time&lt;/code&gt; 变量，可能会出现的问题。我们可能会得到错误或神秘的错误行为。</target>
        </trans-unit>
        <trans-unit id="9694586c6d84150f32d012165fb51d66a0071dfd" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fb6a6428243b8c36b29add8e81342285442dea" translate="yes" xml:space="preserve">
          <source>Here, we've added a custom constructor function so that it can take arguments of different &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; types and promote them to a common type (see &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt; and &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt;). (Of course, we would have to define lots of other methods, too, to make it act like a &lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt;&lt;code&gt;Number&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;one&lt;/code&gt;, &lt;code&gt;zero&lt;/code&gt;, promotion rules and so on.) By default, instances of this type display rather simply, with information about the type name and the field values, as e.g. &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt;.</source>
          <target state="translated">在这里，我们添加了一个自定义构造函数，以便它可以接受不同&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;型类型的参数并将其提升为通用类型（请参见&lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;构造函数&lt;/a&gt;以及&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;转换和升级&lt;/a&gt;）。 （当然，我们还必须定义许多其他方法，以使其像&lt;a href=&quot;../../base/numbers/index#Core.Number&quot;&gt; &lt;code&gt;Number&lt;/code&gt; 一样工作&lt;/a&gt;，例如 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; ， &lt;code&gt;one&lt;/code&gt; ， &lt;code&gt;zero&lt;/code&gt; ，升级规则等。）默认情况下，此类型的实例显示非常简单，其中包含有关类型名称和字段值的信息，例如 &lt;code&gt;Polar{Float64}(3.0,4.0)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7a8c4e9914a1889e98efb20fcf34b5a7f7c01253" translate="yes" xml:space="preserve">
          <source>Here, you've created the same problem all over again: the compiler can't guess what &lt;code&gt;n&lt;/code&gt; is, so it doesn't know the &lt;em&gt;type&lt;/em&gt; of &lt;code&gt;Val(n)&lt;/code&gt;. Attempting to use &lt;code&gt;Val&lt;/code&gt;, but doing so incorrectly, can easily make performance &lt;em&gt;worse&lt;/em&gt; in many situations. (Only in situations where you're effectively combining &lt;code&gt;Val&lt;/code&gt; with the function-barrier trick, to make the kernel function more efficient, should code like the above be used.)</source>
          <target state="translated">在这里，你已经创建了同样的问题一遍：编译器无法猜测 &lt;code&gt;n&lt;/code&gt; 是，所以它不知道&lt;em&gt;类型&lt;/em&gt;的 &lt;code&gt;Val(n)&lt;/code&gt; 。尝试使用 &lt;code&gt;Val&lt;/code&gt; ，但是使用方法不正确，很容易在许多情况下使性能&lt;em&gt;变差&lt;/em&gt;。（仅在将 &lt;code&gt;Val&lt;/code&gt; 与功能屏障技巧有效地结合在一起以使内核功能更有效的情况下，才应使用上述代码。）</target>
        </trans-unit>
        <trans-unit id="c7628673517938376c201f828128315e60314655" translate="yes" xml:space="preserve">
          <source>Hermitian Conjugate Matrix</source>
          <target state="translated">隐代共轭矩阵</target>
        </trans-unit>
        <trans-unit id="7426047f57253430c62cd4ed4e8350b30626acf7" translate="yes" xml:space="preserve">
          <source>Hermitian matrix</source>
          <target state="translated">隐性矩阵</target>
        </trans-unit>
        <trans-unit id="10678e1b00011a887c8ed10343c313db680c592e" translate="yes" xml:space="preserve">
          <source>Hessenberg decomposition</source>
          <target state="translated">海森伯格分解</target>
        </trans-unit>
        <trans-unit id="18dcd84b08d39e78997dcf4fc69cbfdf65766429" translate="yes" xml:space="preserve">
          <source>Hex bytes (&lt;code&gt;\x&lt;/code&gt; with 1-2 trailing hex digits)</source>
          <target state="translated">十六进制字节（带有1-2个尾随十六进制数字的 &lt;code&gt;\x&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="5829ae1ed6f556d7c22293c127a375905a4cde38" translate="yes" xml:space="preserve">
          <source>Hexadecimal floating-point literals are also valid, but only as &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; values, with &lt;code&gt;p&lt;/code&gt; preceding the base-2 exponent:</source>
          <target state="translated">十六进制浮点字面量也有效，但仅作为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;值使用，其中 &lt;code&gt;p&lt;/code&gt; 在以2为底的指数前：</target>
        </trans-unit>
        <trans-unit id="566a781a74cd1186e4a86a913b9dfbcd8a9760f5" translate="yes" xml:space="preserve">
          <source>Hibiscus</source>
          <target state="translated">Hibiscus</target>
        </trans-unit>
        <trans-unit id="590d79aff0a27abac1599349b9f60e654406e4f9" translate="yes" xml:space="preserve">
          <source>High Brightness Symbol</source>
          <target state="translated">高亮度符号</target>
        </trans-unit>
        <trans-unit id="5c42b554d600e8a00d6d46015f5546b8d19934a3" translate="yes" xml:space="preserve">
          <source>High Voltage Sign</source>
          <target state="translated">高电压标志</target>
        </trans-unit>
        <trans-unit id="ab1b93cb46a149db7c34f14c047358adef0d1f47" translate="yes" xml:space="preserve">
          <source>High-Heeled Shoe</source>
          <target state="translated">高跟鞋</target>
        </trans-unit>
        <trans-unit id="22cda4a90e394a1d9c3ad940b9369d0797179dd6" translate="yes" xml:space="preserve">
          <source>High-Level Embedding</source>
          <target state="translated">高层嵌入</target>
        </trans-unit>
        <trans-unit id="772ba23e35e2b9a933b76e30398f7eb414430f46" translate="yes" xml:space="preserve">
          <source>High-Level Embedding on Windows with Visual Studio</source>
          <target state="translated">在Windows上使用Visual Studio的高级嵌入技术</target>
        </trans-unit>
        <trans-unit id="9f567cb6bf549d8f1f72a7aad5d5c25bc17a082a" translate="yes" xml:space="preserve">
          <source>High-Speed Train</source>
          <target state="translated">高速列车</target>
        </trans-unit>
        <trans-unit id="00e1cd5d9c96d48229c7017e30357cb8a8d1334d" translate="yes" xml:space="preserve">
          <source>High-Speed Train With Bullet Nose</source>
          <target state="translated">子弹头高速列车</target>
        </trans-unit>
        <trans-unit id="1b2be27c3b5a49f7125a227298d591cb7aea55af" translate="yes" xml:space="preserve">
          <source>High-level libraries like &lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;</source>
          <target state="translated">像&lt;a href=&quot;https://github.com/JuliaComputing/ArrayFire.jl&quot;&gt;ArrayFire.jl&lt;/a&gt;和&lt;a href=&quot;https://github.com/JuliaGPU/GPUArrays.jl&quot;&gt;GPUArrays.jl&lt;/a&gt;这样的高级库</target>
        </trans-unit>
        <trans-unit id="7e0b3549b5782921269587cd589e55b82058b718" translate="yes" xml:space="preserve">
          <source>High-level vendor-specific abstractions like &lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</source>
          <target state="translated">特定于供应商的高层抽象，例如&lt;a href=&quot;https://github.com/JuliaGPU/CuArrays.jl&quot;&gt;CuArrays.jl&lt;/a&gt;和&lt;a href=&quot;https://github.com/JuliaGPU/CLArrays.jl&quot;&gt;CLArrays.jl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cef2d62c8136407d7a5910b738c2a4954d1ff380" translate="yes" xml:space="preserve">
          <source>Hocho</source>
          <target state="translated">Hocho</target>
        </trans-unit>
        <trans-unit id="1183df425fd69adfff4afc7c4b9f794b3027f62e" translate="yes" xml:space="preserve">
          <source>Hold up: why macros?</source>
          <target state="translated">等等:为什么是宏?</target>
        </trans-unit>
        <trans-unit id="a19d1b5e13bc5eadd5512a5657629c48486fc2aa" translate="yes" xml:space="preserve">
          <source>Holds a reference to an object of type &lt;code&gt;T&lt;/code&gt;, ensuring that it is only accessed atomically, i.e. in a thread-safe manner.</source>
          <target state="translated">持有对类型 &lt;code&gt;T&lt;/code&gt; 的对象的引用，确保仅以原子方式（即以线程安全的方式）对其进行访问。</target>
        </trans-unit>
        <trans-unit id="6d4b2c4793516d9999da8f3caabfcc7a3164599f" translate="yes" xml:space="preserve">
          <source>Home, &lt;code&gt;^A&lt;/code&gt;</source>
          <target state="translated">家， &lt;code&gt;^A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85d163149ee6c8d4bb4972a8d9d62f2349badb11" translate="yes" xml:space="preserve">
          <source>Homothetic</source>
          <target state="translated">Homothetic</target>
        </trans-unit>
        <trans-unit id="642aac9525060b37b0f7470d6f6c49db706b03d9" translate="yes" xml:space="preserve">
          <source>Honey Pot</source>
          <target state="translated">蜂蜜罐</target>
        </trans-unit>
        <trans-unit id="a643db335a306154edebc33a5e2763a380d1411b" translate="yes" xml:space="preserve">
          <source>Honeybee</source>
          <target state="translated">Honeybee</target>
        </trans-unit>
        <trans-unit id="79734fdcfe66d25a072a5769ba821cd7967d89f5" translate="yes" xml:space="preserve">
          <source>Hooking into the &lt;code&gt;Random&lt;/code&gt; API</source>
          <target state="translated">迷上 &lt;code&gt;Random&lt;/code&gt; API</target>
        </trans-unit>
        <trans-unit id="a938072797969a150ccb7384d30e3585d81c5ec0" translate="yes" xml:space="preserve">
          <source>Horizontal Black Hexagon</source>
          <target state="translated">横向黑色六边形</target>
        </trans-unit>
        <trans-unit id="9d0c97d942673d5e711ab71b642cc25b6f24a2b9" translate="yes" xml:space="preserve">
          <source>Horizontal Ellipsis</source>
          <target state="translated">水平省略号</target>
        </trans-unit>
        <trans-unit id="3627a44f223e474759956cf47448b20612b0d19a" translate="yes" xml:space="preserve">
          <source>Horizontal Traffic Light</source>
          <target state="translated">水平交通灯</target>
        </trans-unit>
        <trans-unit id="b7e611daf03b332b5f4ec9209097868ee372b256" translate="yes" xml:space="preserve">
          <source>Horizontal and vertical concatenation in one call. This function is called for block matrix syntax. The first argument specifies the number of arguments to concatenate in each block row.</source>
          <target state="translated">水平和垂直连接一次调用。此函数是针对块状矩阵语法调用的。第一个参数指定每行块中要连接的参数数。</target>
        </trans-unit>
        <trans-unit id="f26372d5f0aca43e155e7d006ab50ec72ec57fe2" translate="yes" xml:space="preserve">
          <source>Horizontal rules</source>
          <target state="translated">横向规则</target>
        </trans-unit>
        <trans-unit id="26dfe8116b93ced6cfca858f375d23f1489d3207" translate="yes" xml:space="preserve">
          <source>Horse</source>
          <target state="translated">Horse</target>
        </trans-unit>
        <trans-unit id="4a166dcec39a913a939b3a42f695d1c218fcaebb" translate="yes" xml:space="preserve">
          <source>Horse Face</source>
          <target state="translated">马脸</target>
        </trans-unit>
        <trans-unit id="8f21624d2501467ee4a054c705bd995e4b73ebab" translate="yes" xml:space="preserve">
          <source>Horse Racing</source>
          <target state="translated">赛马</target>
        </trans-unit>
        <trans-unit id="dbb927867e102f755c1433b1f25539bafdd7268b" translate="yes" xml:space="preserve">
          <source>Hospital</source>
          <target state="translated">Hospital</target>
        </trans-unit>
        <trans-unit id="ef97c144078e1020e0c1fdf8b383ff06d12e8270" translate="yes" xml:space="preserve">
          <source>Hot Beverage</source>
          <target state="translated">热饮</target>
        </trans-unit>
        <trans-unit id="cb506dd41a005a6fcc0d4c18104ce66e01d7afa8" translate="yes" xml:space="preserve">
          <source>Hot Springs</source>
          <target state="translated">温泉</target>
        </trans-unit>
        <trans-unit id="9c4ba7d047eb56093b34e5dc3e51e5fcc74603f4" translate="yes" xml:space="preserve">
          <source>Hotel</source>
          <target state="translated">Hotel</target>
        </trans-unit>
        <trans-unit id="c29e8e28d3952318903de2fb6079804d2ed9d9e6" translate="yes" xml:space="preserve">
          <source>Hour (24-hour clock) with a minimum width</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcc1b57017e3ac9f33e4e51068baf64a23795adf" translate="yes" xml:space="preserve">
          <source>Hourglass</source>
          <target state="translated">Hourglass</target>
        </trans-unit>
        <trans-unit id="bf7a0304247679d7272f0a79f9d388f130597fd4" translate="yes" xml:space="preserve">
          <source>Hourglass With Flowing Sand</source>
          <target state="translated">流沙沙漏</target>
        </trans-unit>
        <trans-unit id="dc8745ba30beefa5d028f85ba9b11599a2ac8d7e" translate="yes" xml:space="preserve">
          <source>House</source>
          <target state="translated">House</target>
        </trans-unit>
        <trans-unit id="b6ac911209d87615e6f295e017b36c332cd3b878" translate="yes" xml:space="preserve">
          <source>House Building</source>
          <target state="translated">建房</target>
        </trans-unit>
        <trans-unit id="b07df507eb5fd0e4b6c36328d58c64ebcc7b5d32" translate="yes" xml:space="preserve">
          <source>House With Garden</source>
          <target state="translated">带花园的房子</target>
        </trans-unit>
        <trans-unit id="75af347bffc8062b7ea5afa0a699184af65b1a37" translate="yes" xml:space="preserve">
          <source>How can I constrain or compute type parameters?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eefa8d28bdac822ea112d7e5259409579ba61c80" translate="yes" xml:space="preserve">
          <source>How can I modify the declaration of a type in my session?</source>
          <target state="translated">如何修改会话中的类型声明?</target>
        </trans-unit>
        <trans-unit id="515d85b9b31cb430ad4b0705dfed0fd34c859e1a" translate="yes" xml:space="preserve">
          <source>How did the file name get quoted? Julia knows that &lt;code&gt;file&lt;/code&gt; is meant to be interpolated as a single argument, so it quotes the word for you. Actually, that is not quite accurate: the value of &lt;code&gt;file&lt;/code&gt; is never interpreted by a shell, so there's no need for actual quoting; the quotes are inserted only for presentation to the user. This will even work if you interpolate a value as part of a shell word:</source>
          <target state="translated">文件名如何被引用？Julia知道该 &lt;code&gt;file&lt;/code&gt; 应作为单个参数插入，因此它为您引用了该词。实际上，这还不是很准确：shell永远不会解释 &lt;code&gt;file&lt;/code&gt; 的值，因此不需要实际的引用。引号仅用于向用户展示。如果您将值作为外壳单词的一部分进行插值，这甚至可以工作：</target>
        </trans-unit>
        <trans-unit id="7554712c2d173a82ff8ff4725649f94b899a6cab" translate="yes" xml:space="preserve">
          <source>How do I catch CTRL-C in a script?</source>
          <target state="translated">如何在脚本中抓住CTRL-C?</target>
        </trans-unit>
        <trans-unit id="2a65d886539b09798da7278037976d95b79a6f2f" translate="yes" xml:space="preserve">
          <source>How do I check if the current file is being run as the main script?</source>
          <target state="translated">如何检查当前文件是否作为主脚本运行?</target>
        </trans-unit>
        <trans-unit id="07f058f4bf96d455fe968f2d1e89bd25936e7928" translate="yes" xml:space="preserve">
          <source>How do I delete an object in memory?</source>
          <target state="translated">如何删除内存中的对象?</target>
        </trans-unit>
        <trans-unit id="07788c6091915f1a67274d44211a41dbc53e6935" translate="yes" xml:space="preserve">
          <source>How do I manage precompilation caches in distributed file systems?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b215618760cff9b8483504445b91edb71bee5871" translate="yes" xml:space="preserve">
          <source>How do I pass options to &lt;code&gt;julia&lt;/code&gt; using &lt;code&gt;#!/usr/bin/env&lt;/code&gt;?</source>
          <target state="translated">如何使用 &lt;code&gt;#!/usr/bin/env&lt;/code&gt; 将选项传递给 &lt;code&gt;julia&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="eb9157ff1fb18352038c8a12eae2a15bbdb246dd" translate="yes" xml:space="preserve">
          <source>How does &quot;null&quot;, &quot;nothingness&quot; or &quot;missingness&quot; work in Julia?</source>
          <target state="translated">茱莉亚的 &quot;空&quot;、&quot;无&quot;、&quot;缺 &quot;怎么用?</target>
        </trans-unit>
        <trans-unit id="b5188f1df50966f544cd1288a28b80d8b68a2b7f" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd885280d6cbd9f996932c72e9d360397c1bf016" translate="yes" xml:space="preserve">
          <source>How does one construct a &lt;code&gt;Point&lt;/code&gt; object? It is possible to define custom constructors for composite types, which will be discussed in detail in &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;Constructors&lt;/a&gt;, but in the absence of any special constructor declarations, there are two default ways of creating new composite objects, one in which the type parameters are explicitly given and the other in which they are implied by the arguments to the object constructor.</source>
          <target state="translated">一个人如何构造一个 &lt;code&gt;Point&lt;/code&gt; 对象？可以为复合类型定义自定义构造函数，这将在&amp;ldquo; &lt;a href=&quot;../constructors/index#man-constructors-1&quot;&gt;构造函数&amp;rdquo;&lt;/a&gt;中详细讨论，但是在没有任何特殊构造函数声明的情况下，有两种创建新复合对象的默认方法，一种是显式给出类型参数另一种是在对象构造函数的参数中暗含它们。</target>
        </trans-unit>
        <trans-unit id="06e308a7a0638232b6f09929d443c3620a3b020e" translate="yes" xml:space="preserve">
          <source>How these arguments are initialized depends on the &quot;outer&quot; function; here, &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; will sequentially set &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, calling the anonymous function on each, just as would happen in the syntax &lt;code&gt;map(func, [A, B, C])&lt;/code&gt;.</source>
          <target state="translated">这些参数的初始化方式取决于&amp;ldquo;外部&amp;rdquo;功能。在这里，&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;会依次将 &lt;code&gt;x&lt;/code&gt; 设置为 &lt;code&gt;A&lt;/code&gt; ， &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; ，并在每个函数上调用匿名函数，就像语法 &lt;code&gt;map(func, [A, B, C])&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eaf97b67896b3cc13483847a79f98eac92d8c7ad" translate="yes" xml:space="preserve">
          <source>How you use this information is up to you. Obviously, it would be far and away best to fix &lt;code&gt;pos&lt;/code&gt; to be type-stable: if you did so, all of the variables in &lt;code&gt;f&lt;/code&gt; would be concrete, and its performance would be optimal. However, there are circumstances where this kind of &lt;em&gt;ephemeral&lt;/em&gt; type instability might not matter too much: for example, if &lt;code&gt;pos&lt;/code&gt; is never used in isolation, the fact that &lt;code&gt;f&lt;/code&gt;'s output is type-stable (for &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; inputs) will shield later code from the propagating effects of type instability. This is particularly relevant in cases where fixing the type instability is difficult or impossible. In such cases, the tips above (e.g., adding type annotations and/or breaking up functions) are your best tools to contain the &quot;damage&quot; from type instability. Also, note that even Julia Base has functions that are type unstable. For example, the function &lt;code&gt;findfirst&lt;/code&gt; returns the index into an array where a key is found, or &lt;code&gt;nothing&lt;/code&gt; if it is not found, a clear type instability. In order to make it easier to find the type instabilities that are likely to be important, &lt;code&gt;Union&lt;/code&gt;s containing either &lt;code&gt;missing&lt;/code&gt; or &lt;code&gt;nothing&lt;/code&gt; are color highlighted in yellow, instead of red.</source>
          <target state="translated">您如何使用此信息取决于您。显然，最好将 &lt;code&gt;pos&lt;/code&gt; 固定为类型稳定的最好的选择：如果这样做，则 &lt;code&gt;f&lt;/code&gt; 中的所有变量都将是具体的，并且其性能将是最佳的。但是，在某些情况下，这种&lt;em&gt;短暂&lt;/em&gt;类型的不稳定可能并不太重要：例如，如果从未将 &lt;code&gt;pos&lt;/code&gt; &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;使用，则 &lt;code&gt;f&lt;/code&gt; 的输出是类型稳定的事实（对于Float64输入）将保护以后的代码不受类型不稳定的影响。在解决类型不稳定性困难或不可能的情况下，这尤其重要。在这种情况下，上面的技巧（例如，添加类型注释和/或分解功能）是遏制类型不稳定性造成的&amp;ldquo;损害&amp;rdquo;的最佳工具。另外，请注意，即使Julia Julia也具有不稳定类型的函数。例如，函数 &lt;code&gt;findfirst&lt;/code&gt; 将索引返回到找到键的数组中，如果找不到键，则不返回 &lt;code&gt;nothing&lt;/code&gt; ，这是明显的类型不稳定。为了更容易地找到可能很重要的类型不稳定性， &lt;code&gt;Union&lt;/code&gt; 包含 &lt;code&gt;missing&lt;/code&gt; 或 &lt;code&gt;nothing&lt;/code&gt; 包含任何内容 用黄色而不是红色突出显示颜色。</target>
        </trans-unit>
        <trans-unit id="042ec23eb15357af1265112d56deb61892b131f1" translate="yes" xml:space="preserve">
          <source>However one should keep in mind, that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime:</source>
          <target state="translated">然而我们应该记住,宏调度是基于交给宏的AST类型,而不是AST在运行时评估的类型。</target>
        </trans-unit>
        <trans-unit id="ec8145ef611e8eb6adb7aa2875037ca9cf5cb809" translate="yes" xml:space="preserve">
          <source>However, all the information we need for the loop is embedded in the type information of the arguments. Thus, we can utilize generated functions to move the iteration to compile-time; in compiler parlance, we use generated functions to manually unroll the loop. The body becomes almost identical, but instead of calculating the linear index, we build up an &lt;em&gt;expression&lt;/em&gt; that calculates the index:</source>
          <target state="translated">但是，循环所需的所有信息都嵌入在参数的类型信息中。因此，我们可以利用生成的函数将迭代移至编译时。用编译器的话来说，我们使用生成的函数来手动展开循环。主体几乎完全相同，但是我们没有计算线性索引，而是建立了一个计算索引的&lt;em&gt;表达式&lt;/em&gt;：</target>
        </trans-unit>
        <trans-unit id="42e7ab564618248599a98b48397f91d9696cc5fd" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently accomplish a similar effect.</source>
          <target state="translated">但是,这样做也会很慢,而且会泄漏内存,所以你通常应该避免这样做,而是继续阅读。下一节将讨论如何使用间接调用来有效地达到类似的效果。</target>
        </trans-unit>
        <trans-unit id="d98a9aa4753704d7124f1d48bec32b6c3a7df644" translate="yes" xml:space="preserve">
          <source>However, doing this will also be very slow and leak memory, so you should usually avoid this and instead keep reading. The next section discusses how to use indirect calls to efficiently achieve a similar effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f4c1ec1ac04c3b7530d92971ca6fe0a67c59d9d" translate="yes" xml:space="preserve">
          <source>However, for mutable objects the warning is printed as expected:</source>
          <target state="translated">然而,对于可突变的对象,警告会按预期打印出来。</target>
        </trans-unit>
        <trans-unit id="2b94a9c2374adeaf4e451f1d8f8dbbec3cf93bf0" translate="yes" xml:space="preserve">
          <source>However, future calls to &lt;code&gt;tryeval&lt;/code&gt; will continue to see the definition of &lt;code&gt;newfun&lt;/code&gt; as it was &lt;em&gt;at the previous statement at the REPL&lt;/em&gt;, and thus before that call to &lt;code&gt;tryeval&lt;/code&gt;.</source>
          <target state="translated">然而，未来的呼叫 &lt;code&gt;tryeval&lt;/code&gt; 将继续看到的定义 &lt;code&gt;newfun&lt;/code&gt; ，因为它是&lt;em&gt;在在REPL此前的说法&lt;/em&gt;，因此这一呼吁之前 &lt;code&gt;tryeval&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d2749cf17a2b4294f113fe7c480d466ff1081a71" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;x&lt;/code&gt; is bound to an object of type &lt;code&gt;Array&lt;/code&gt; (or any other &lt;em&gt;mutable&lt;/em&gt; type). From within the function, you cannot &quot;unbind&quot; &lt;code&gt;x&lt;/code&gt; from this Array, but you &lt;em&gt;can&lt;/em&gt; change its content. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a28d68e1fc2327784959f0995bfa65f1bc559d" translate="yes" xml:space="preserve">
          <source>However, if needed you can specialize on any or all of these arguments. The final argument &lt;code&gt;bc&lt;/code&gt; is a lazy representation of a (potentially fused) broadcast operation, a &lt;code&gt;Broadcasted&lt;/code&gt; object. For these purposes, the most important fields of the wrapper are &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, describing the function and argument list, respectively. Note that the argument list can &amp;mdash; and often does &amp;mdash; include other nested &lt;code&gt;Broadcasted&lt;/code&gt; wrappers.</source>
          <target state="translated">但是，如果需要，您可以专注于任何或所有这些参数。最终参数 &lt;code&gt;bc&lt;/code&gt; 是（可能融合的）广播操作（ &lt;code&gt;Broadcasted&lt;/code&gt; 对象）的惰性表示。为此，包装器的最重要字段是 &lt;code&gt;f&lt;/code&gt; 和 &lt;code&gt;args&lt;/code&gt; ，分别描述函数和参数列表。请注意，参数列表可以并且经常包括其他嵌套的 &lt;code&gt;Broadcasted&lt;/code&gt; 包装器。</target>
        </trans-unit>
        <trans-unit id="a1a03264a4e905ebd619a9b03ec0d4363bf201f9" translate="yes" xml:space="preserve">
          <source>However, if you try to redefine a built-in constant or function already in use, Julia will give you an error:</source>
          <target state="translated">然而,如果你试图重新定义一个已经在使用的内置常量或函数,Julia会给你一个错误。</target>
        </trans-unit>
        <trans-unit id="b612aa5b83e1e5e4f183ec87a4a8051d812c4982" translate="yes" xml:space="preserve">
          <source>However, it is not hard to construct cases where this will fail:</source>
          <target state="translated">然而,不难构造出会失败的案例。</target>
        </trans-unit>
        <trans-unit id="f588e867dce1639bbbc3e181485bd13a34f96de5" translate="yes" xml:space="preserve">
          <source>However, it is occasionally useful to reuse an existing local variable as the iteration variable. This can be done conveniently by adding the keyword &lt;code&gt;outer&lt;/code&gt;:</source>
          <target state="translated">但是，重用现有的局部变量作为迭代变量有时会很有用。这可以通过添加关键字 &lt;code&gt;outer&lt;/code&gt; 来方便地完成：</target>
        </trans-unit>
        <trans-unit id="b3fc16da92345edab485c9b8587412c5e7cbbb69" translate="yes" xml:space="preserve">
          <source>However, it's still possible, for instance, to send a &lt;code&gt;MyType&lt;/code&gt; to a process which has loaded &lt;code&gt;DummyModule&lt;/code&gt; even if it's not in scope:</source>
          <target state="translated">但是，例如，仍然可以将 &lt;code&gt;MyType&lt;/code&gt; 发送到已加载 &lt;code&gt;DummyModule&lt;/code&gt; 的进程，即使它不在范围内：</target>
        </trans-unit>
        <trans-unit id="0206b7f024c599046b1522c22d104a0f2b4ea5b8" translate="yes" xml:space="preserve">
          <source>However, making use of such techniques can be surprisingly subtle. For example, it would be of no help if you called &lt;code&gt;array3&lt;/code&gt; from a function like this:</source>
          <target state="translated">但是，使用此类技术可能令人惊讶地微妙。例如，如果您从如下函数调用 &lt;code&gt;array3&lt;/code&gt; ，将毫无帮助：</target>
        </trans-unit>
        <trans-unit id="1ad09b70c7675ac7974cd81421e0b196fa34837e" translate="yes" xml:space="preserve">
          <source>However, other similar calls still don't work:</source>
          <target state="translated">但是,其他类似的电话还是不能用。</target>
        </trans-unit>
        <trans-unit id="d6c01a830ee4c6c4b08c6d0fd04973c57ba502a5" translate="yes" xml:space="preserve">
          <source>However, since the automatic vectorization cannot be relied upon, future use will mostly be via libraries that use &lt;code&gt;llvmcall&lt;/code&gt;.</source>
          <target state="translated">但是，由于不能依赖自动矢量化，因此将来的使用将主要通过使用 &lt;code&gt;llvmcall&lt;/code&gt; 的库进行。</target>
        </trans-unit>
        <trans-unit id="0a9c9e751e43cb6eaac4e5372d46543dc59ec370" translate="yes" xml:space="preserve">
          <source>However, since this is slightly cumbersome, there are several convenience methods provided. For example, we could have written the above as:</source>
          <target state="translated">不过,由于这样做略显繁琐,所以提供了几种方便的方法。例如,我们可以把上面的内容写成:</target>
        </trans-unit>
        <trans-unit id="4963644e11f9a07fc917ac8319ecfbd548bbe63b" translate="yes" xml:space="preserve">
          <source>However, some modules contain submodules, which means you sometimes need to access a non-top-level module. There are two ways to do this. The first is to use an absolute path, for example &lt;code&gt;using Base.Sort&lt;/code&gt;. The second is to use a relative path, which makes it easier to import submodules of the current module or any of its enclosing modules:</source>
          <target state="translated">但是，某些模块包含子模块，这意味着您有时需要访问非顶级模块。有两种方法可以做到这一点。第一种是使用绝对路径，例如 &lt;code&gt;using Base.Sort&lt;/code&gt; 。第二个是使用相对路径，这使得导入当前模块或其任何封闭模块的子模块更加容易：</target>
        </trans-unit>
        <trans-unit id="5f8e9c86265d52a44715f5ea3dcba697bb6fdada" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788054e244adc6c2716171e1c63990c4810a9000" translate="yes" xml:space="preserve">
          <source>However, sometimes it makes sense to keep the uppercase first letter, for instance if an argument to a function is a capital letter: &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt;.</source>
          <target state="translated">但是，有时保留大写的第一个字母是有意义的，例如，如果函数的参数为​​大写字母： &lt;code&gt;size(A,1) == size(B,2) || throw(DimensionMismatch(&quot;A has first dimension...&quot;))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="734c2f5135f1e869aae040511570811afbc769c7" translate="yes" xml:space="preserve">
          <source>However, the outer &lt;code&gt;quote&lt;/code&gt; expression is able to interpolate values inside the &lt;code&gt;$&lt;/code&gt; in the inner quote. This is done with multiple &lt;code&gt;$&lt;/code&gt;s:</source>
          <target state="translated">但是，外部 &lt;code&gt;quote&lt;/code&gt; 表达式可以在内部报价的 &lt;code&gt;$&lt;/code&gt; 内插值。这是通过多个 &lt;code&gt;$&lt;/code&gt; s 完成的：</target>
        </trans-unit>
        <trans-unit id="a78965b80768b2188b4d959fddb093f72b6aa627" translate="yes" xml:space="preserve">
          <source>However, there are cases where you may need to declare different versions of the outer function for different element types or types of the &lt;code&gt;AbstractVector&lt;/code&gt; of the field &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;MySimpleContainer&lt;/code&gt;. You could do it like this:</source>
          <target state="translated">然而，有些情况下你可能需要声明不同的版本不同的元素类型或类型的外部功能的情况下 &lt;code&gt;AbstractVector&lt;/code&gt; 领域的 &lt;code&gt;a&lt;/code&gt; 在 &lt;code&gt;MySimpleContainer&lt;/code&gt; 。您可以这样做：</target>
        </trans-unit>
        <trans-unit id="3975391f531616484a0e31ee77d8e0e00f61fa9e" translate="yes" xml:space="preserve">
          <source>However, there are three key differences:</source>
          <target state="translated">然而,有三个主要区别。</target>
        </trans-unit>
        <trans-unit id="f5c45c8616fbe8c99fd70a67651ffd25fb8f16b8" translate="yes" xml:space="preserve">
          <source>However, this is &lt;em&gt;not&lt;/em&gt; recommended. Instead, use the more efficient &lt;code&gt;complex&lt;/code&gt; function to construct a complex value directly from its real and imaginary parts:</source>
          <target state="translated">但是，&lt;em&gt;不&lt;/em&gt;建议这样做。而是使用更高效的 &lt;code&gt;complex&lt;/code&gt; 函数直接从其实部和虚部构造一个复杂值：</target>
        </trans-unit>
        <trans-unit id="a2261e024bded1ce38fa0b00996da87c5f69ba9d" translate="yes" xml:space="preserve">
          <source>However, type promotion between the primitive types above and &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt;&lt;code&gt;BigFloat&lt;/code&gt;&lt;/a&gt; is not automatic and must be explicitly stated.</source>
          <target state="translated">但是，上述原始类型与&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;../../base/numbers/index#Base.MPFR.BigFloat&quot;&gt; &lt;code&gt;BigFloat&lt;/code&gt; &lt;/a&gt;之间的类型提升不是自动的，必须明确声明。</target>
        </trans-unit>
        <trans-unit id="a17c41ad2e8a1887210e57ce0ca80b0a2e7e175c" translate="yes" xml:space="preserve">
          <source>However, we don't do this for a good reason: wrapping the &lt;code&gt;expr&lt;/code&gt; in a new scope block (the anonymous function) also slightly changes the meaning of the expression (the scope of any variables in it), while we want &lt;code&gt;@time&lt;/code&gt; to be usable with minimum impact on the wrapped code.</source>
          <target state="translated">但是，我们没有为一个很好的理由这样做：包裹 &lt;code&gt;expr&lt;/code&gt; 在新的作用域块（匿名函数）也略有改变表达式（其中的任何变量的作用域）的意思，而我们要 &lt;code&gt;@time&lt;/code&gt; 到在对包装的代码影响最小的情况下可用。</target>
        </trans-unit>
        <trans-unit id="0b0f70feaa3a28d45e6f3a13fc1f48acf2f37d7c" translate="yes" xml:space="preserve">
          <source>However, while the type layout must be known statically to compute the intended C ABI, the static parameters of the function are considered to be part of this static environment. The static parameters of the function may be used as type parameters in the call signature, as long as they don't affect the layout of the type. For example, &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; is valid, since &lt;code&gt;Ptr&lt;/code&gt; is always a word-size primitive type. But, &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; is not valid, since the type layout of &lt;code&gt;T&lt;/code&gt; is not known statically.</source>
          <target state="translated">但是，虽然必须静态知道类型布局才能计算出预期的C ABI，但该函数的静态参数被认为是此静态环境的一部分。该函数的静态参数可以在调用签名中用作类型参数，只要它们不影响类型的布局即可。例如， &lt;code&gt;f(x::T) where {T} = ccall(:valid, Ptr{T}, (Ptr{T},), x)&lt;/code&gt; 是有效的，因为 &lt;code&gt;Ptr&lt;/code&gt; 始终是字长的原始类型。但是，由于 &lt;code&gt;g(x::T) where {T} = ccall(:notvalid, T, (T,), x)&lt;/code&gt; 无效，因为 &lt;code&gt;T&lt;/code&gt; 的类型布局不是静态已知的。</target>
        </trans-unit>
        <trans-unit id="08e25fd1d8072dc28d6c1dfa6f07c1fbd4ffc288" translate="yes" xml:space="preserve">
          <source>However, you can get access to &lt;code&gt;PowerShell&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d668f1d842d230950802dd8f5eb4d3254c4568" translate="yes" xml:space="preserve">
          <source>Hundred Points Symbol</source>
          <target state="translated">百点符号</target>
        </trans-unit>
        <trans-unit id="fdd59db74c581af271b7941aa03e44ed5fe0b191" translate="yes" xml:space="preserve">
          <source>Hushed Face</source>
          <target state="translated">羞涩的脸</target>
        </trans-unit>
        <trans-unit id="37906f8372f8c377be7b1e328309d3c4f609ea59" translate="yes" xml:space="preserve">
          <source>Hygiene</source>
          <target state="translated">Hygiene</target>
        </trans-unit>
        <trans-unit id="9dfda2b4e8d2ebd709351cb5956b33e0e4ffe363" translate="yes" xml:space="preserve">
          <source>Hyndman, R.J and Fan, Y. (1996) &quot;Sample Quantiles in Statistical Packages&quot;, &lt;em&gt;The American Statistician&lt;/em&gt;, Vol. 50, No. 4, pp. 361-365</source>
          <target state="translated">Hyndman，RJ和Fan，Y.（1996）&amp;ldquo;统计软件包中的样本分位数&amp;rdquo;，&lt;em&gt;《美国统计师》&lt;/em&gt;，第1卷。50，第4号，第361-365页</target>
        </trans-unit>
        <trans-unit id="cde96ad42b76d0bdd741afbb558f7a3b372bce7e" translate="yes" xml:space="preserve">
          <source>I (interval)</source>
          <target state="translated">I(区间)</target>
        </trans-unit>
        <trans-unit id="1f1b2f73366cab7e556f4c5764548bfeee9e55d4" translate="yes" xml:space="preserve">
          <source>I passed an argument &lt;code&gt;x&lt;/code&gt; to a function, modified it inside that function, but on the outside, the variable &lt;code&gt;x&lt;/code&gt; is still unchanged. Why?</source>
          <target state="translated">我将参数 &lt;code&gt;x&lt;/code&gt; 传递给函数，并在该函数内部对其进行了修改，但在外部，变量 &lt;code&gt;x&lt;/code&gt; 仍保持不变。为什么？</target>
        </trans-unit>
        <trans-unit id="f6d15c9cfe8c2c69adbb304be5e27663dff93f96" translate="yes" xml:space="preserve">
          <source>I.e. the value returned by &lt;code&gt;codeunit(s, i)&lt;/code&gt; is of the type returned by &lt;code&gt;codeunit(s)&lt;/code&gt;.</source>
          <target state="translated">即，由返回的值 &lt;code&gt;codeunit(s, i)&lt;/code&gt; 是由返回的类型的 &lt;code&gt;codeunit(s)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cf18e3da9119216f8e328e30538193a84b6a06e" translate="yes" xml:space="preserve">
          <source>I/O and Network</source>
          <target state="translated">I/O和网络</target>
        </trans-unit>
        <trans-unit id="f202b270f0bf2c3423308846f107faa93c51a606" translate="yes" xml:space="preserve">
          <source>ID of the device that contains the file</source>
          <target state="translated">包含文件的设备的ID</target>
        </trans-unit>
        <trans-unit id="f9c4d94c8313e5f3e388b78d066d32450a104438" translate="yes" xml:space="preserve">
          <source>IO Output Contextual Properties</source>
          <target state="translated">IO输出上下文属性</target>
        </trans-unit>
        <trans-unit id="197f5eacc88f8f1df449bfc2c0077d2d00ba82c7" translate="yes" xml:space="preserve">
          <source>IO redirection can be accomplished by passing keyword arguments &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt;, and &lt;code&gt;stderr&lt;/code&gt; to the &lt;code&gt;pipeline&lt;/code&gt; function:</source>
          <target state="translated">可以通过将关键字参数 &lt;code&gt;stdin&lt;/code&gt; ， &lt;code&gt;stdout&lt;/code&gt; 和 &lt;code&gt;stderr&lt;/code&gt; 传递给 &lt;code&gt;pipeline&lt;/code&gt; 函数来实现IO重定向：</target>
        </trans-unit>
        <trans-unit id="01d2fc4baf23050afed6538bf5b3afda200aec20" translate="yes" xml:space="preserve">
          <source>IOBuffer</source>
          <target state="translated">IOBuffer</target>
        </trans-unit>
        <trans-unit id="1e240958856813e40093848d027d47dc30e4009a" translate="yes" xml:space="preserve">
          <source>IOContext</source>
          <target state="translated">IOContext</target>
        </trans-unit>
        <trans-unit id="29093ff8b21b1b330d3e6699a2ad82a180dd947e" translate="yes" xml:space="preserve">
          <source>IOContext()</source>
          <target state="translated">IOContext()</target>
        </trans-unit>
        <trans-unit id="3afa239559b1455a86cd4aafab53cb6dd69792c0" translate="yes" xml:space="preserve">
          <source>IOStream</source>
          <target state="translated">IOStream</target>
        </trans-unit>
        <trans-unit id="8d31d2211f88e51d4dac04058ee63fd1f5837600" translate="yes" xml:space="preserve">
          <source>Ice Cream</source>
          <target state="translated">冰淇淋</target>
        </trans-unit>
        <trans-unit id="2b3a1ae210dbbbf1609a9fd75685f6380218b075" translate="yes" xml:space="preserve">
          <source>IdDict</source>
          <target state="translated">IdDict</target>
        </trans-unit>
        <trans-unit id="898cecd14809e1e6d2d6a1ad03f40fe8f8898ff9" translate="yes" xml:space="preserve">
          <source>Identical To</source>
          <target state="translated">同类</target>
        </trans-unit>
        <trans-unit id="c539ce4823e892243cf1d72e5cda29852ab1bb48" translate="yes" xml:space="preserve">
          <source>Identical To And Slanted Parallel</source>
          <target state="translated">同类和倾斜的平行线</target>
        </trans-unit>
        <trans-unit id="44763ae8a5457dbe6219995560f8ceac0b654107" translate="yes" xml:space="preserve">
          <source>Identical With Dot Above</source>
          <target state="translated">与上面的点相同</target>
        </trans-unit>
        <trans-unit id="49f0f00de3919e6aa513f490a486fcbae4d4df50" translate="yes" xml:space="preserve">
          <source>If $n$ is negative, then it is defined in terms of the identity</source>
          <target state="translated">如果$n$是负数,那么它的定义是以身份为单位的</target>
        </trans-unit>
        <trans-unit id="4ed2889e692f7a726f27cb34a6abbc329da52fe8" translate="yes" xml:space="preserve">
          <source>If $n$ is non-negative, then it is the number of ways to choose &lt;code&gt;k&lt;/code&gt; out of &lt;code&gt;n&lt;/code&gt; items:</source>
          <target state="translated">如果$ n $为非负数，则是从 &lt;code&gt;n&lt;/code&gt; 个项目中选择 &lt;code&gt;k&lt;/code&gt; 个的方法的数量：</target>
        </trans-unit>
        <trans-unit id="21a045b4d60526617fd3c07b9d46739e69a41cdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalue, compute the principal matrix logarithm of &lt;code&gt;A&lt;/code&gt;, i.e. the unique matrix $X$ such that $e^X = A$ and $-\pi &amp;lt; Im(\lambda) &amp;lt; \pi$ for all the eigenvalues $\lambda$ of $X$. If &lt;code&gt;A&lt;/code&gt; has nonpositive eigenvalues, a nonprincipal matrix function is returned whenever possible.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 没有负实特征值，则计算 &lt;code&gt;A&lt;/code&gt; 的主矩阵对数，即唯一矩阵$ X $，使得$ e ^ X = A $，并且$-\ pi &amp;lt;Im（\ lambda）&amp;lt;\ pi $ $ X $的特征值$ \ lambda $。如果 &lt;code&gt;A&lt;/code&gt; 具有非正特征值，则尽可能返回非主矩阵函数。</target>
        </trans-unit>
        <trans-unit id="7259d98627a04b894a1123257649b9b0e506f9f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; has no negative real eigenvalues, compute the principal matrix square root of &lt;code&gt;A&lt;/code&gt;, that is the unique matrix $X$ with eigenvalues having positive real part such that $X^2 = A$. Otherwise, a nonprincipal square root is returned.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 没有负面实特征值，计算的主矩阵平方根 &lt;code&gt;A&lt;/code&gt; ，即独特的矩阵$ X $与具有正实部，使得$ X ^ 2 = A $特征值。否则，返回非主平方根。</target>
        </trans-unit>
        <trans-unit id="390ecc8380adb6dd4fff37f515d8dc55040ad6a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is &lt;a href=&quot;#LinearAlgebra.Hermitian&quot;&gt;&lt;code&gt;Hermitian&lt;/code&gt;&lt;/a&gt; or real-&lt;a href=&quot;#LinearAlgebra.Symmetric&quot;&gt;&lt;code&gt;Symmetric&lt;/code&gt;&lt;/a&gt;, then the Hessenberg decomposition produces a real-symmetric tridiagonal matrix and &lt;code&gt;F.H&lt;/code&gt; is of type &lt;a href=&quot;#LinearAlgebra.SymTridiagonal&quot;&gt;&lt;code&gt;SymTridiagonal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e08a2a0f6796f08007ab9fdda2c45c43480624f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is a &lt;code&gt;StridedArray&lt;/code&gt;, then its elements are stored in memory with offsets, which may vary between dimensions but are constant within a dimension. For example, &lt;code&gt;A&lt;/code&gt; could have stride 2 in dimension 1, and stride 3 in dimension 2. Incrementing &lt;code&gt;A&lt;/code&gt; along dimension &lt;code&gt;d&lt;/code&gt; jumps in memory by [&lt;code&gt;strides(A, d)&lt;/code&gt;] slots. Strided arrays are particularly important and useful because they can sometimes be passed directly as pointers to foreign language libraries like BLAS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d3df34d4b0d8669771d98ccd80e4361eb22b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is real-symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. For such matrices, eigenvalues &amp;lambda; that appear to be slightly negative due to roundoff errors are treated as if they were zero More precisely, matrices with all eigenvalues &lt;code&gt;&amp;ge; -rtol*(max |&amp;lambda;|)&lt;/code&gt; are treated as semidefinite (yielding a Hermitian square root), with negative eigenvalues taken to be zero. &lt;code&gt;rtol&lt;/code&gt; is a keyword argument to &lt;code&gt;sqrt&lt;/code&gt; (in the Hermitian/real-symmetric case only) that defaults to machine precision scaled by &lt;code&gt;size(A,1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b01775b8b82ce68d3f6a6f522f474a638dda03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the cosine. Otherwise, the cosine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是对称的或Hermitian的，则使用其&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen）计算余弦。否则，通过调用 &lt;code&gt;exp&lt;/code&gt; 确定余弦。</target>
        </trans-unit>
        <trans-unit id="acf6a44af56176e5053aa08ad7d4eea1a7727bea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是对称的或Hermitian的，则其&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen）用于计算反余弦。否则，使用 &lt;code&gt;log&lt;/code&gt; 和 &lt;code&gt;sqrt&lt;/code&gt; 确定反余弦值。有关用于计算此函数的理论和对数公式，请参见&lt;a href=&quot;#footnote-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="656a2e02dd9901a5d5d038f1484c6e9a0c0da179" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse cosine. Otherwise, the inverse cosine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_1&quot; id=&quot;citeref-AH16_1&quot;&gt;[AH16_1]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfce79aa807e6b2cb49ddfffb2847f191045922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是对称的或Hermitian的，则其&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen）用于计算反正弦。否则，通过使用 &lt;code&gt;log&lt;/code&gt; 和 &lt;code&gt;sqrt&lt;/code&gt; 确定反正弦。有关用于计算此函数的理论和对数公式，请参见&lt;a href=&quot;#footnote-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c57d54383c6569d422099f76dc516cae4a4a6b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse sine. Otherwise, the inverse sine is determined by using &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;sqrt&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_2&quot; id=&quot;citeref-AH16_2&quot;&gt;[AH16_2]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2646487106f321c98004368d4fc3670f47b0a86e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是对称的或Hermitian的，则其&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen）用于计算反正切。否则，通过使用 &lt;code&gt;log&lt;/code&gt; 确定反正切。有关用于计算此函数的理论和对数公式，请参见&lt;a href=&quot;#footnote-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="88a24bd15ac5a68c08c00b78778d22ccaac3c21f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the inverse tangent. Otherwise, the inverse tangent is determined by using &lt;code&gt;log&lt;/code&gt;. For the theory and logarithmic formulas used to compute this function, see &lt;sup&gt;&lt;a href=&quot;#footnote-AH16_3&quot; id=&quot;citeref-AH16_3&quot;&gt;[AH16_3]&lt;/a&gt;&lt;/sup&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317ce8e704df5d75a6762d7ee94cb8590a0eeb84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the sine. Otherwise, the sine is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是对称的或Hermitian的，则其&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen）用于计算正弦。否则，通过调用 &lt;code&gt;exp&lt;/code&gt; 确定正弦。</target>
        </trans-unit>
        <trans-unit id="8f03ca25824d588274952404db5eb47ba9feeba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the square root. Otherwise, the square root is determined by means of the Bj&amp;ouml;rck-Hammarling method &lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83]&lt;/a&gt;, which computes the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) and then the complex square root of the triangular factor.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是对称的或Hermitian的，则其&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen）用于计算平方根。否则，该平方根由Bj&amp;ouml;rck-Hammarling方法确定&lt;a href=&quot;#footnote-BH83&quot;&gt;[BH83] &lt;/a&gt;，其计算复杂舒尔形式（&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt;），然后将三角因子的复杂的平方根。</target>
        </trans-unit>
        <trans-unit id="da6d9fe794edc15bdf1db668291afd8d8cb893d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used to compute the tangent. Otherwise, the tangent is determined by calling &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是对称的或Hermitian的，则其&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen）用于计算切线。否则，通过调用 &lt;code&gt;exp&lt;/code&gt; 确定切线。</target>
        </trans-unit>
        <trans-unit id="e82ebcef54c304de01d1461f11b56325e46b2234" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt; and &lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="translated">如果 &lt;code&gt;A&lt;/code&gt; 是对称的或Hermitian的，则使用其&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt; &lt;code&gt;eigen&lt;/code&gt; &lt;/a&gt;分解（eigen），如果 &lt;code&gt;A&lt;/code&gt; 是三角形的，则采用反比例缩放和平方的改进版本（请参见&lt;a href=&quot;#footnote-AH12&quot;&gt;[AH12]&lt;/a&gt;和&lt;a href=&quot;#footnote-AHR13&quot;&gt;[AHR13]&lt;/a&gt;）。对于一般矩阵，计算复数Schur形式（&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt; &lt;code&gt;schur&lt;/code&gt; &lt;/a&gt;），并在三角因子上使用三角算法。</target>
        </trans-unit>
        <trans-unit id="7cd81f11c1d70424b51ccffe350316108e01c22e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; is symmetric or Hermitian, its eigendecomposition (&lt;a href=&quot;#LinearAlgebra.eigen&quot;&gt;&lt;code&gt;eigen&lt;/code&gt;&lt;/a&gt;) is used, if &lt;code&gt;A&lt;/code&gt; is triangular an improved version of the inverse scaling and squaring method is employed (see &lt;sup&gt;&lt;a href=&quot;#footnote-AH12&quot; id=&quot;citeref-AH12&quot;&gt;[AH12]&lt;/a&gt;&lt;/sup&gt; and &lt;sup&gt;&lt;a href=&quot;#footnote-AHR13&quot; id=&quot;citeref-AHR13&quot;&gt;[AHR13]&lt;/a&gt;&lt;/sup&gt;). For general matrices, the complex Schur form (&lt;a href=&quot;#LinearAlgebra.schur&quot;&gt;&lt;code&gt;schur&lt;/code&gt;&lt;/a&gt;) is computed and the triangular algorithm is used on the triangular factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31effe06eb8010b919cfa614d0573384a4c26bdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;DataType&lt;/code&gt;&lt;code&gt;T&lt;/code&gt; does not have a specific size, an error is thrown.</source>
          <target state="translated">如果 &lt;code&gt;DataType&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 没有特定的大小，则会引发错误。</target>
        </trans-unit>
        <trans-unit id="65a78265c4f32be6b8f80e6ff2b5005fabff1e58" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Eigen&lt;/code&gt; is the factorization object, the eigenvalues can be obtained via &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors as the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c71436c7107833fddd5b4b5c6ae6ac2cda922a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::GeneralizedEigen&lt;/code&gt; is the factorization object, the eigenvalues can be obtained via &lt;code&gt;F.values&lt;/code&gt; and the eigenvectors as the columns of the matrix &lt;code&gt;F.vectors&lt;/code&gt;. (The &lt;code&gt;k&lt;/code&gt;th eigenvector can be obtained from the slice &lt;code&gt;F.vectors[:, k]&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01e4881f70ca748aeb84922a14f5f7db186c9f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::GeneralizedSchur&lt;/code&gt; is the factorization object, the (quasi) triangular Schur factors can be obtained via &lt;code&gt;F.S&lt;/code&gt; and &lt;code&gt;F.T&lt;/code&gt;, the left unitary/orthogonal Schur vectors via &lt;code&gt;F.left&lt;/code&gt; or &lt;code&gt;F.Q&lt;/code&gt;, and the right unitary/orthogonal Schur vectors can be obtained with &lt;code&gt;F.right&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A=F.left*F.S*F.right'&lt;/code&gt; and &lt;code&gt;B=F.left*F.T*F.right'&lt;/code&gt;. The generalized eigenvalues of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; can be obtained with &lt;code&gt;F.&amp;alpha;./F.&amp;beta;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab48030073624eeb674b91b0955f920e2a071342" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Hessenberg&lt;/code&gt; is the factorization object, the unitary matrix can be accessed with &lt;code&gt;F.Q&lt;/code&gt; and the Hessenberg matrix with &lt;code&gt;F.H&lt;/code&gt;. When &lt;code&gt;Q&lt;/code&gt; is extracted, the resulting type is the &lt;code&gt;HessenbergQ&lt;/code&gt; object, and may be converted to a regular matrix with &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert(Array, _)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;Array(_)&lt;/code&gt; for short).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4e73df12d848cb37ff07b3e198fc0482a106ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::SVD&lt;/code&gt; is the factorization object, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; can be obtained via &lt;code&gt;F.U&lt;/code&gt;, &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.V&lt;/code&gt; and &lt;code&gt;F.Vt&lt;/code&gt;, such that &lt;code&gt;A = U * Diagonal(S) * Vt&lt;/code&gt;. The singular values in &lt;code&gt;S&lt;/code&gt; are sorted in descending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f171f3d3fce677fec26e12b57715e21774c193" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F::Schur&lt;/code&gt; is the factorization object, the (quasi) triangular Schur factor can be obtained via either &lt;code&gt;F.Schur&lt;/code&gt; or &lt;code&gt;F.T&lt;/code&gt; and the orthogonal/unitary Schur vectors via &lt;code&gt;F.vectors&lt;/code&gt; or &lt;code&gt;F.Z&lt;/code&gt; such that &lt;code&gt;A = F.vectors * F.Schur * F.vectors'&lt;/code&gt;. The eigenvalues of &lt;code&gt;A&lt;/code&gt; can be obtained with &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70ac2f54db074364d37a4067713ee52ebafa3e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I_1&lt;/code&gt; is changed to a two-dimensional matrix, then &lt;code&gt;X&lt;/code&gt; becomes an &lt;code&gt;n+1&lt;/code&gt;-dimensional array of shape &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt;. The matrix adds a dimension.</source>
          <target state="translated">如果将 &lt;code&gt;I_1&lt;/code&gt; 更改为二维矩阵，则 &lt;code&gt;X&lt;/code&gt; 变为形状为 &lt;code&gt;(size(I_1, 1), size(I_1, 2), length(I_2), ..., length(I_n))&lt;/code&gt; 的 &lt;code&gt;n+1&lt;/code&gt; 维数组））。矩阵会添加一个尺寸。</target>
        </trans-unit>
        <trans-unit id="2337775037e3e4a6505e42024632bd3eb4bbd6dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S::BunchKaufman&lt;/code&gt; is the factorization object, the components can be obtained via &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c942e11644bfa14cfe833c922c7cc44bc3db5861" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;S::LQ&lt;/code&gt; is the factorization object, the lower triangular component can be obtained via &lt;code&gt;S.L&lt;/code&gt;, and the orthogonal/unitary component via &lt;code&gt;S.Q&lt;/code&gt;, such that &lt;code&gt;A &amp;asymp; S.L*S.Q&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d018b41d67fa72dfd3dd7eab414a34042d26fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;Any&lt;/code&gt;, then the memory is assumed to contain a reference to a Julia object (a &lt;code&gt;jl_value_t*&lt;/code&gt;), the result will be a reference to this object, and the object will not be copied. You must be careful in this case to ensure that the object was always visible to the garbage collector (pointers do not count, but the new reference does) to ensure the memory is not prematurely freed. Note that if the object was not originally allocated by Julia, the new object will never be finalized by Julia's garbage collector. If the &lt;code&gt;Ptr&lt;/code&gt; itself is actually a &lt;code&gt;jl_value_t*&lt;/code&gt;, it can be converted back to a Julia object reference by &lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt;&lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt;&lt;/a&gt;. (Julia values &lt;code&gt;v&lt;/code&gt; can be converted to &lt;code&gt;jl_value_t*&lt;/code&gt; pointers, as &lt;code&gt;Ptr{Cvoid}&lt;/code&gt;, by calling &lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt;&lt;code&gt;pointer_from_objref(v)&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 为 &lt;code&gt;Any&lt;/code&gt; ，则假定内存包含对Julia对象的引用（ &lt;code&gt;jl_value_t*&lt;/code&gt; ），结果将是对此对象的引用，并且不会复制该对象。在这种情况下，您必须小心以确保垃圾收集器始终可见该对象（指针不计数，但新引用可以计数），以确保不会过早释放内存。请注意，如果对象最初不是由Julia分配的，则新对象将永远不会被Julia的垃圾收集器终结。如果 &lt;code&gt;Ptr&lt;/code&gt; 本身实际上是 &lt;code&gt;jl_value_t*&lt;/code&gt; ，则可以通过&lt;a href=&quot;../../base/c/index#Base.unsafe_pointer_to_objref&quot;&gt; &lt;code&gt;unsafe_pointer_to_objref(ptr)&lt;/code&gt; &lt;/a&gt;将其转换回Julia对象引用。 （朱莉娅价值观 &lt;code&gt;v&lt;/code&gt; 可以通过调用&lt;a href=&quot;../../base/c/index#Base.pointer_from_objref&quot;&gt; &lt;code&gt;pointer_from_objref(v)&lt;/code&gt; &lt;/a&gt;转换为 &lt;code&gt;jl_value_t*&lt;/code&gt; 指针，如 &lt;code&gt;Ptr{Cvoid}&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="51788d4fcfdfd4d39c958952b0bc0324310a6a5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt;&lt;code&gt;AbstractFloat&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; type, then it will return the closest value to &lt;code&gt;x&lt;/code&gt; representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是&lt;a href=&quot;../numbers/index#Core.AbstractFloat&quot;&gt; &lt;code&gt;AbstractFloat&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;类型，则它将返回最接近于 &lt;code&gt;x&lt;/code&gt; 的值（由 &lt;code&gt;T&lt;/code&gt; 表示）。</target>
        </trans-unit>
        <trans-unit id="dedc994cd3fc0835ff4382a890fe92f16cb71d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a collection type and &lt;code&gt;x&lt;/code&gt; a collection, the result of &lt;code&gt;convert(T, x)&lt;/code&gt; may alias all or part of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是集合类型， &lt;code&gt;x&lt;/code&gt; 是集合，则 &lt;code&gt;convert(T, x)&lt;/code&gt; 可以为 &lt;code&gt;x&lt;/code&gt; 的全部或部分别名。</target>
        </trans-unit>
        <trans-unit id="ca5b35227b72b028ed45253536f1af95a0b6efba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a floating-point type, the result is the nearest representable value, which could be positive or negative infinity.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是浮点类型，则结果是最接近的可表示值，可以是正无穷大或负无穷大。</target>
        </trans-unit>
        <trans-unit id="4201a0a82cce066dea7c824bdf90b57c195e9972" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a numeric type, the result is an array of that type, with any non-numeric elements as &lt;code&gt;NaN&lt;/code&gt; for floating-point types, or zero. Other useful values of &lt;code&gt;T&lt;/code&gt; include &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;AbstractString&lt;/code&gt;, and &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是数字类型，则结果是该类型的数组，对于浮点类型，任何非数字元素 &lt;code&gt;NaN&lt;/code&gt; 表示，或者为零。 &lt;code&gt;T&lt;/code&gt; 的其他有用值包括 &lt;code&gt;String&lt;/code&gt; ， &lt;code&gt;AbstractString&lt;/code&gt; 和 &lt;code&gt;Any&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5708e9143fa5c221a25e2fd582d17441adb4aff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is a union of types containing &lt;code&gt;Missing&lt;/code&gt;, return a new type with &lt;code&gt;Missing&lt;/code&gt; removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69fee994b4c0ef137b6453b3ceac4a68a22fb0fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt; type, an &lt;a href=&quot;#Core.InexactError&quot;&gt;&lt;code&gt;InexactError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;, for example if &lt;code&gt;x&lt;/code&gt; is not integer-valued, or is outside the range supported by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是&lt;a href=&quot;../numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;类型，如果 &lt;code&gt;x&lt;/code&gt; 不能用 &lt;code&gt;T&lt;/code&gt; 表示，例如 &lt;code&gt;x&lt;/code&gt; 不是整数，或者不在 &lt;code&gt;T&lt;/code&gt; 支持的范围内，则会引发&lt;a href=&quot;#Core.InexactError&quot;&gt; &lt;code&gt;InexactError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c36ac776e4be839ff56e17825105904e00568128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;T&lt;/code&gt; is an integer type, an &lt;code&gt;InexactError&lt;/code&gt; is raised if &lt;code&gt;x&lt;/code&gt; is not representable by &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;T&lt;/code&gt; 是整数类型，并且 &lt;code&gt;x&lt;/code&gt; 不能由 &lt;code&gt;T&lt;/code&gt; 表示，则会引发 &lt;code&gt;InexactError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c7762b87399cdbea094b67bb56bb79bce4032130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and but does &lt;em&gt;not&lt;/em&gt; have a top-level UUID entry, &lt;code&gt;uuid&lt;/code&gt; is a dummy UUID generated by hashing the canonical (real) path to &lt;code&gt;X/Project.toml&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;X/Project.toml&lt;/code&gt; 存在并且&lt;em&gt;不&lt;/em&gt;具有顶级UUID条目，则 &lt;code&gt;uuid&lt;/code&gt; 是通过对 &lt;code&gt;X/Project.toml&lt;/code&gt; 的规范（实际）路径进行哈希处理而生成的虚拟UUID 。</target>
        </trans-unit>
        <trans-unit id="57feda5962ebeb025a02c2fc5115db7f5ee74658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X/Project.toml&lt;/code&gt; exists and has a &lt;code&gt;uuid&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; is that value.</source>
          <target state="translated">如果 &lt;code&gt;X/Project.toml&lt;/code&gt; 存在并且具有 &lt;code&gt;uuid&lt;/code&gt; 条目，则 &lt;code&gt;uuid&lt;/code&gt; 是该值。</target>
        </trans-unit>
        <trans-unit id="b0ad6875ad056062a02a932f0ca014f6680202e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alg = DivideAndConquer()&lt;/code&gt; a divide-and-conquer algorithm is used to calculate the SVD. Another (typically slower but more accurate) option is &lt;code&gt;alg = QRIteration()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6feb00535e98202cbe0e255e2cd1a8e59544d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (the default), this function will block repeatedly trying to read all requested bytes, until an error or end-of-file occurs. If &lt;code&gt;all&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, at most one &lt;code&gt;read&lt;/code&gt; call is performed, and the amount of data returned is device-dependent. Note that not all stream types support the &lt;code&gt;all&lt;/code&gt; option.</source>
          <target state="translated">如果 &lt;code&gt;all&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; （默认设置），则此函数将反复尝试读取所有请求的字节，直到发生错误或文件结束为止，该函数将被阻止。如果 &lt;code&gt;all&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则最多执行一次 &lt;code&gt;read&lt;/code&gt; 调用，并且返回的数据量取决于设备。请注意，并非所有流类型都支持 &lt;code&gt;all&lt;/code&gt; 选项。</target>
        </trans-unit>
        <trans-unit id="7b3a53d050caeb89134ca9bb80d1091ff36a0cf4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a power of 2 or 10, &lt;a href=&quot;#Base.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; should be used, as these will typically be faster and more accurate. For example,</source>
          <target state="translated">如果 &lt;code&gt;b&lt;/code&gt; 为2或10的幂，则应使用&lt;a href=&quot;#Base.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#Base.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt;，因为它们通常更快，更准确。例如，</target>
        </trans-unit>
        <trans-unit id="89b9fac160344d84b2e97547e3cbb9b2dd975a11" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;batch_size&lt;/code&gt; is specified, the collection is processed in batch mode. &lt;code&gt;f&lt;/code&gt; must then be a function that must accept a &lt;code&gt;Vector&lt;/code&gt; of argument tuples and must return a vector of results. The input vector will have a length of &lt;code&gt;batch_size&lt;/code&gt; or less.</source>
          <target state="translated">如果指定 &lt;code&gt;batch_size&lt;/code&gt; ，则将以批处理方式处理集合。然后， &lt;code&gt;f&lt;/code&gt; 必须是一个必须接受参数元组的 &lt;code&gt;Vector&lt;/code&gt; 并必须返回结果矢量的函数。输入向量的长度为 &lt;code&gt;batch_size&lt;/code&gt; 或更小。</target>
        </trans-unit>
        <trans-unit id="9a514f5181b462b5cf60570457a733a924782944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;collection&lt;/code&gt; is ordered, use &lt;a href=&quot;#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt; to add all the elements of another collection to it. The result of the preceding example is equivalent to &lt;code&gt;append!([1, 2, 3], [4, 5, 6])&lt;/code&gt;. For &lt;code&gt;AbstractSet&lt;/code&gt; objects, &lt;a href=&quot;#Base.union!&quot;&gt;&lt;code&gt;union!&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2467dc77e236fb9b24d515beabeb30ab9b34314" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dims&lt;/code&gt; is a tuple, the order of the dimensions in &lt;code&gt;dims&lt;/code&gt; is relevant and specifies the linear order of the slices. E.g., if &lt;code&gt;A&lt;/code&gt; is three dimensional and &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(1, 2)&lt;/code&gt;, the orderings of the first two dimensions are re-arranged such such that the slices (of the remaining third dimension) are sorted. If &lt;code&gt;dims&lt;/code&gt; is &lt;code&gt;(2, 1)&lt;/code&gt; instead, the same slices will be taken, but the result order will be row-major instead.</source>
          <target state="translated">如果 &lt;code&gt;dims&lt;/code&gt; 是一个元组，则 &lt;code&gt;dims&lt;/code&gt; 中尺寸的顺序是相关的，并指定切片的线性顺序。例如，如果 &lt;code&gt;A&lt;/code&gt; 为三维，并且 &lt;code&gt;dims&lt;/code&gt; 为 &lt;code&gt;(1, 2)&lt;/code&gt; ，则重新排列前两个二维的顺序，以便对（其余第三维的）切片进行排序。如果 &lt;code&gt;dims&lt;/code&gt; 为 &lt;code&gt;(2, 1)&lt;/code&gt; ，则将采用相同的切片，但结果顺序将改为行优先。</target>
        </trans-unit>
        <trans-unit id="74fad15bfd2101b3b16f9ea74a15c93af724d1dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dlm&lt;/code&gt; is omitted, it defaults to &lt;a href=&quot;#Base.Unicode.isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果省略 &lt;code&gt;dlm&lt;/code&gt; ，则默认为&lt;a href=&quot;#Base.Unicode.isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d7429e0d71b847a07568d302028712dbaf31f03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;factorize&lt;/code&gt; is called on a Hermitian positive-definite matrix, for instance, then &lt;code&gt;factorize&lt;/code&gt; will return a Cholesky factorization.</source>
          <target state="translated">例如，如果在Hermitian正定矩阵上调用 &lt;code&gt;factorize&lt;/code&gt; ，则 &lt;code&gt;factorize&lt;/code&gt; 将返回Cholesky因子分解。</target>
        </trans-unit>
        <trans-unit id="b7c73e768a4a1fc2665ff51aa066980c89d3ec1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;follow_symlinks=false&lt;/code&gt;, and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be created as a symbolic link. If &lt;code&gt;follow_symlinks=true&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; is a symbolic link, &lt;code&gt;dst&lt;/code&gt; will be a copy of the file or directory &lt;code&gt;src&lt;/code&gt; refers to. Return &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;follow_symlinks=false&lt;/code&gt; ，并且 &lt;code&gt;src&lt;/code&gt; 是符号链接，则将 &lt;code&gt;dst&lt;/code&gt; 创建为符号链接。如果 &lt;code&gt;follow_symlinks=true&lt;/code&gt; 且 &lt;code&gt;src&lt;/code&gt; 是符号链接，则 &lt;code&gt;dst&lt;/code&gt; 将是 &lt;code&gt;src&lt;/code&gt; 引用的文件或目录的副本。返回 &lt;code&gt;dst&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0fefe7c70552bb288eba8725570e0711eb9913bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;full = false&lt;/code&gt; (default), a &quot;thin&quot; SVD is returned. For a $M \times N$ matrix &lt;code&gt;A&lt;/code&gt;, in the full factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times M&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times N&lt;/code&gt;, while in the thin factorization &lt;code&gt;U&lt;/code&gt; is &lt;code&gt;M \times K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;N \times K&lt;/code&gt;, where &lt;code&gt;K = \min(M,N)&lt;/code&gt; is the number of singular values.</source>
          <target state="translated">如果 &lt;code&gt;full = false&lt;/code&gt; （默认），则返回&amp;ldquo;瘦&amp;rdquo; SVD。对于$ M&amp;times;N $矩阵 &lt;code&gt;A&lt;/code&gt; ，在完全分解中， &lt;code&gt;U&lt;/code&gt; 是 &lt;code&gt;M \times M&lt;/code&gt; &amp;times; M，而 &lt;code&gt;V&lt;/code&gt; 是 &lt;code&gt;N \times N&lt;/code&gt; &amp;times; N，而在稀分解中， &lt;code&gt;U&lt;/code&gt; 是 &lt;code&gt;M \times K&lt;/code&gt; &amp;times; K， &lt;code&gt;V&lt;/code&gt; 是 &lt;code&gt;N \times K&lt;/code&gt; ，其中 &lt;code&gt;K = \min(M,N)&lt;/code&gt; 是奇异值的数量。</target>
        </trans-unit>
        <trans-unit id="e7087620ad88bc806c680dac427ffd57a67879dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fussy_sqrt&lt;/code&gt; is called with a negative value from another function, instead of trying to continue execution of the calling function, it returns immediately, displaying the error message in the interactive session:</source>
          <target state="translated">如果使用另一个函数的负值调用 &lt;code&gt;fussy_sqrt&lt;/code&gt; ，则它不会立即尝试继续执行该调用函数，而是立即返回，并在交互式会话中显示错误消息：</target>
        </trans-unit>
        <trans-unit id="c19e0b85728fe9481b7abf51cbb032dc0e45287a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, the returned &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to fallback implementations. An error is thrown if no fallback implementation exists. If &lt;code&gt;generated&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, these &lt;code&gt;CodeInfo&lt;/code&gt; instances will correspond to the method bodies yielded by expanding the generators.</source>
          <target state="translated">如果 &lt;code&gt;generated&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则返回的 &lt;code&gt;CodeInfo&lt;/code&gt; 实例将对应于后备实现。如果不存在任何后备实现，则将引发错误。如果 &lt;code&gt;generated&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则这些 &lt;code&gt;CodeInfo&lt;/code&gt; 实例将对应于通过扩展生成器产生的方法主体。</target>
        </trans-unit>
        <trans-unit id="3b5b7e505ab23a5d0aa601628f61af1433ebc0f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;header&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the first row of data will be read as header and the tuple &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; is returned instead of only &lt;code&gt;data_cells&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;header&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则数据的第一行将作为header读取，并返回元组 &lt;code&gt;(data_cells, header_cells)&lt;/code&gt; 而不是仅 &lt;code&gt;data_cells&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c950181a2a1658a2e38c89bd49475efe3e66e317" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding code unit &lt;code&gt;i&lt;/code&gt; is part of. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return &lt;code&gt;i&lt;/code&gt;; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to 0 or &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; return &lt;code&gt;i&lt;/code&gt;. In all other cases throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;s&lt;/code&gt; 的范围内，则返回该字符的开始索引，该字符是 &lt;code&gt;i&lt;/code&gt; 的编码单元。换句话说，如果 &lt;code&gt;i&lt;/code&gt; 是字符的开头，则返回 &lt;code&gt;i&lt;/code&gt; ；如果 &lt;code&gt;i&lt;/code&gt; 不是字符的开头，请快退直到字符的开头并返回该索引。如果 &lt;code&gt;i&lt;/code&gt; 等于0或 &lt;code&gt;ncodeunits(s)+1&lt;/code&gt; 返回 &lt;code&gt;i&lt;/code&gt; 。在所有其他情况下，抛出 &lt;code&gt;BoundsError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed8634de2b332fe1583659d48b66208896196beb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts after index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the next character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, move forward until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt; return &lt;code&gt;1&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is in bounds but greater or equal to &lt;code&gt;lastindex(str)&lt;/code&gt; return &lt;code&gt;ncodeunits(str)+1&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;s&lt;/code&gt; 的范围内，则返回字符的开头的索引，该字符的编码从索引 &lt;code&gt;i&lt;/code&gt; 开始。换句话说，如果 &lt;code&gt;i&lt;/code&gt; 是字符的开头，则返回下一个字符的开头；否则，返回i。如果 &lt;code&gt;i&lt;/code&gt; 不是字符的开头，请向前移动直到字符的开头并返回该索引。如果 &lt;code&gt;i&lt;/code&gt; 等于 &lt;code&gt;0&lt;/code&gt; ,则返回 &lt;code&gt;1&lt;/code&gt; 。如果 &lt;code&gt;i&lt;/code&gt; 在范围之内但大于或等于 &lt;code&gt;lastindex(str)&lt;/code&gt; ,则返回 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 。否则抛出 &lt;code&gt;BoundsError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5bcc465fac95b41229c6fb79ecf0d3dab69e75e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;i&lt;/code&gt; is in bounds in &lt;code&gt;s&lt;/code&gt; return the index of the start of the character whose encoding starts before index &lt;code&gt;i&lt;/code&gt;. In other words, if &lt;code&gt;i&lt;/code&gt; is the start of a character, return the start of the previous character; if &lt;code&gt;i&lt;/code&gt; is not the start of a character, rewind until the start of a character and return that index. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;1&lt;/code&gt; return &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;i&lt;/code&gt; is equal to &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; return &lt;code&gt;lastindex(str)&lt;/code&gt;. Otherwise throw &lt;code&gt;BoundsError&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;i&lt;/code&gt; 在 &lt;code&gt;s&lt;/code&gt; 的范围内，则返回字符的开头的索引，该字符的编码在索引 &lt;code&gt;i&lt;/code&gt; 之前开始。换句话说，如果 &lt;code&gt;i&lt;/code&gt; 是字符的开头，则返回前一个字符的开头；否则，返回false。如果 &lt;code&gt;i&lt;/code&gt; 不是字符的开头，请快退直到字符的开头并返回该索引。如果 &lt;code&gt;i&lt;/code&gt; 等于 &lt;code&gt;1&lt;/code&gt; ,则返回 &lt;code&gt;0&lt;/code&gt; 。如果 &lt;code&gt;i&lt;/code&gt; 等于 &lt;code&gt;ncodeunits(str)+1&lt;/code&gt; 返回 &lt;code&gt;lastindex(str)&lt;/code&gt; 。否则抛出 &lt;code&gt;BoundsError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ebe5e40c213fd1e7b9dc945437a4e812c30e543" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), then &lt;code&gt;ix&lt;/code&gt; is initialized to contain the indices of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fcfeccc007b268d4af436c2f9443a9d036bba79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, but &lt;code&gt;ix&lt;/code&gt; does not contain (a permutation of) the indices of &lt;code&gt;v&lt;/code&gt;, the behavior of &lt;code&gt;partialsortperm!&lt;/code&gt; is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfff02ba2ab7ab8f47553333086d7d3b017d4eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is not specified, &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; are used to connect.</source>
          <target state="translated">如果未指定 &lt;code&gt;io&lt;/code&gt; ，则使用 &lt;code&gt;host&lt;/code&gt; 和 &lt;code&gt;port&lt;/code&gt; 进行连接。</target>
        </trans-unit>
        <trans-unit id="675d2f45d06133423691ac8939a36ff3793bfbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;io&lt;/code&gt; is specified, it is used to read host/port information. A Julia worker prints out its bind address and port at startup. This allows Julia workers to listen on any free port available instead of requiring worker ports to be configured manually.</source>
          <target state="translated">如果指定了 &lt;code&gt;io&lt;/code&gt; ，它将用于读取主机/端口信息。Julia工作者在启动时会打印出其绑定地址和端口。这使Julia工作人员可以侦听可用的任何可用端口，而无需手动配置工作端口。</target>
        </trans-unit>
        <trans-unit id="23c03ff245d9cf669803a913ec063d9d852e916b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;irange&lt;/code&gt; is not &lt;code&gt;1:n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the dimension of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">如果 &lt;code&gt;irange&lt;/code&gt; 不是 &lt;code&gt;1:n&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;A&lt;/code&gt; 的维度，则返回的分解将是&lt;em&gt;截断的&lt;/em&gt;分解。</target>
        </trans-unit>
        <trans-unit id="33bb6515a9488e11cd97387cfe2fdf0354f00b17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;isless(x, y)&lt;/code&gt; is defined, then so is &lt;code&gt;isless(y, x)&lt;/code&gt; and &lt;code&gt;isequal(x, y)&lt;/code&gt;, and exactly one of those three yields &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;isless(x, y)&lt;/code&gt; ，那么 &lt;code&gt;isless(y, x)&lt;/code&gt; 和 &lt;code&gt;isequal(x, y)&lt;/code&gt; ，并且这三个 &lt;code&gt;true&lt;/code&gt; 之一恰好得出true。</target>
        </trans-unit>
        <trans-unit id="27bcd4132639e391333ba702df2bbfcfeb96c942" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if &lt;code&gt;itr&lt;/code&gt; contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the median of non-missing values.</source>
          <target state="translated">如果 &lt;code&gt;itr&lt;/code&gt; 包含 &lt;code&gt;NaN&lt;/code&gt; 或&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值，则结果也为 &lt;code&gt;NaN&lt;/code&gt; 或 &lt;code&gt;missing&lt;/code&gt; （如果 &lt;code&gt;itr&lt;/code&gt; 包含两个值，则 &lt;code&gt;missing&lt;/code&gt; 优先。）使用&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;函数可忽略 &lt;code&gt;missing&lt;/code&gt; 条目并计算非缺失值的中位数。</target>
        </trans-unit>
        <trans-unit id="c3e083f5fc9364992337e03964ee084acea5fae6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the mean of non-missing values.</source>
          <target state="translated">如果 &lt;code&gt;itr&lt;/code&gt; 包含 &lt;code&gt;NaN&lt;/code&gt; 或&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值，则结果也为 &lt;code&gt;NaN&lt;/code&gt; 或 &lt;code&gt;missing&lt;/code&gt; （如果数组同时包含两者，则 &lt;code&gt;missing&lt;/code&gt; 优先。）使用&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;函数可以省略 &lt;code&gt;missing&lt;/code&gt; 条目并计算非缺失值的平均值。</target>
        </trans-unit>
        <trans-unit id="6474b35658d7c26eeead842892ada1aea0d886f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;itr&lt;/code&gt; 是 &lt;code&gt;AbstractArray&lt;/code&gt; ， &lt;code&gt;dims&lt;/code&gt; 可被提供给计算过尺寸的标准偏差，和 &lt;code&gt;m&lt;/code&gt; 可含有用于的每个维度 &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="51822a7fae2f9177cdbe8acba291b2ecbdaf5a84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions, and &lt;code&gt;means&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;itr&lt;/code&gt; 是 &lt;code&gt;AbstractArray&lt;/code&gt; ， &lt;code&gt;dims&lt;/code&gt; 可被提供给计算过尺寸的标准偏差，并且 &lt;code&gt;means&lt;/code&gt; 可以包含用于每个维度手段 &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a062a8f0de1a26806b03ecc36f3c075df17d6625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the standard deviation over dimensions. In that case, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf5ec759432f757b892cc486fe0509d46288036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;m&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;itr&lt;/code&gt; 是 &lt;code&gt;AbstractArray&lt;/code&gt; ，则可以提供 &lt;code&gt;dims&lt;/code&gt; 来计算维度的方差，并且 &lt;code&gt;m&lt;/code&gt; 可以包含 &lt;code&gt;itr&lt;/code&gt; 每个维度的均值。</target>
        </trans-unit>
        <trans-unit id="37d953297aa88c0f3bc07a3115b3b34627aebd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions, and &lt;code&gt;mean&lt;/code&gt; may contain means for each dimension of &lt;code&gt;itr&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;itr&lt;/code&gt; 是 &lt;code&gt;AbstractArray&lt;/code&gt; ， &lt;code&gt;dims&lt;/code&gt; 可被提供给计算过尺寸的方差，并且 &lt;code&gt;mean&lt;/code&gt; 可以包含用于每个维度手段 &lt;code&gt;itr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="990c04cdd5ec49c07722688547969ed041fe0726" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c42d84f4d44608418a9c06e641987a8cc6e81e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;itr&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt;, &lt;code&gt;dims&lt;/code&gt; can be provided to compute the variance over dimensions. In that case, &lt;code&gt;mean&lt;/code&gt; must be an array with the same shape as &lt;code&gt;mean(itr, dims=dims)&lt;/code&gt; (additional trailing singleton dimensions are allowed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c5a74c045541a90c529fb0859ca2583588298de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range (a &lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt;&lt;code&gt;LinRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">如果 &lt;code&gt;length&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; 被提供并且 &lt;code&gt;step&lt;/code&gt; 不是，步长将被计算自动使得存在 &lt;code&gt;length&lt;/code&gt; 线性地在范围（以间隔元件&lt;a href=&quot;../collections/index#Base.LinRange&quot;&gt; &lt;code&gt;LinRange&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a704a76b38109c4ddf6a00329dc6ebcf8c7f4fac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;step&lt;/code&gt; is not, the step size will be computed automatically such that there are &lt;code&gt;length&lt;/code&gt; linearly spaced elements in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51d6d1b8a88beec41cb040befac543132aff1625" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;overlap=true&lt;/code&gt;, the matching sequences are allowed to overlap indices in the original string, otherwise they must be from disjoint character ranges.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0677161ec30784ce49b4b8aeda531d688c559665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pids&lt;/code&gt; is left unspecified, the shared array will be mapped across all processes on the current host, including the master. But, &lt;code&gt;localindices&lt;/code&gt; and &lt;code&gt;indexpids&lt;/code&gt; will only refer to worker processes. This facilitates work distribution code to use workers for actual computation with the master process acting as a driver.</source>
          <target state="translated">如果未指定 &lt;code&gt;pids&lt;/code&gt; ，则共享阵列将映射到当前主机（包括主服务器）上的所有进程。但是， &lt;code&gt;localindices&lt;/code&gt; 和 &lt;code&gt;indexpids&lt;/code&gt; 将仅指工作进程。这有助于工作分配代码在主进程充当驱动程序的情况下使用工人进行实际计算。</target>
        </trans-unit>
        <trans-unit id="39265b02d633cf948cee760fccd02e8e4c595e22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;quotes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, columns enclosed within double-quote (&quot;) characters are allowed to contain new lines and column delimiters. Double-quote characters within a quoted field must be escaped with another double-quote. Specifying &lt;code&gt;dims&lt;/code&gt; as a tuple of the expected rows and columns (including header, if any) may speed up reading of large files. If &lt;code&gt;comments&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, lines beginning with &lt;code&gt;comment_char&lt;/code&gt; and text following &lt;code&gt;comment_char&lt;/code&gt; in any line are ignored.</source>
          <target state="translated">如果 &lt;code&gt;quotes&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则允许用双引号（&amp;ldquo;）引起来的列包含新行和列定界符。带引号的字段中的双引号字符必须用另一个双引号转义。将 &lt;code&gt;dims&lt;/code&gt; 指定为期望的元组行和列（包括标题，如果有的话）可能会加快大文件的读取速度；如果 &lt;code&gt;comments&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则将忽略 &lt;code&gt;comment_char&lt;/code&gt; 开头的行以及 &lt;code&gt;comment_char&lt;/code&gt; 之后的文本。</target>
        </trans-unit>
        <trans-unit id="072d5e68fa14ef444211e0638bdf60961c940d9d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reuseaddr=true&lt;/code&gt;, multiple threads or processes can bind to the same address without error if they all set &lt;code&gt;reuseaddr=true&lt;/code&gt;, but only the last to bind will receive any traffic.</source>
          <target state="translated">如果 &lt;code&gt;reuseaddr=true&lt;/code&gt; ，如果多个线程或进程都都设置了 &lt;code&gt;reuseaddr=true&lt;/code&gt; ，则多个线程或进程可以无错误地绑定到同一地址，但是只有最后一个绑定的线程或进程将接收任何流量。</target>
        </trans-unit>
        <trans-unit id="88b9f6afde6b8b83ebdb2719c69ddd36ee622e38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rng&lt;/code&gt; is not specified, it defaults to seeding the state of the shared thread-local generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dd9d0433c4fe181d962946c85904ec68a57d1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rook&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, rook pivoting is used. If &lt;code&gt;rook&lt;/code&gt; is false, rook pivoting is not used.</source>
          <target state="translated">如果 &lt;code&gt;rook&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则使用rook透视。如果 &lt;code&gt;rook&lt;/code&gt; 为假，则不使用rook透视。</target>
        </trans-unit>
        <trans-unit id="3686d47af71436aa8068aa094e6acfdb577abbc8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skipblanks&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, blank lines in the input will be ignored.</source>
          <target state="translated">如果 &lt;code&gt;skipblanks&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则输入中的空白行将被忽略。</target>
        </trans-unit>
        <trans-unit id="01862aa97c770501d33a4692799d52e5b5e3dee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;spawn = true&lt;/code&gt;, the Task created for &lt;code&gt;func&lt;/code&gt; may be scheduled on another thread in parallel, equivalent to creating a task via &lt;a href=&quot;../multi-threading/index#Base.Threads.@spawn&quot;&gt;&lt;code&gt;Threads.@spawn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a873983f34f90f6f3366d1e91c3b5438a1e6c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced (a &lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt;&lt;code&gt;StepRange&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">如果提供了 &lt;code&gt;step&lt;/code&gt; 和 &lt;code&gt;stop&lt;/code&gt; ，而没有提供 &lt;code&gt;length&lt;/code&gt; ，则将自动计算整个范围的长度，以使元素以 &lt;code&gt;step&lt;/code&gt; 距分隔（&lt;a href=&quot;../collections/index#Base.StepRange&quot;&gt; &lt;code&gt;StepRange&lt;/code&gt; &lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="a062e99e636224da62916657b0080cc837347ab0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;step&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are provided and &lt;code&gt;length&lt;/code&gt; is not, the overall range length will be computed automatically such that the elements are &lt;code&gt;step&lt;/code&gt; spaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a505616ea56a3e3c587fbb37c2a52b74909df91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;InterruptException&lt;/code&gt; is not thrown by Ctrl-C. Running code upon such event requires &lt;a href=&quot;../base/index#Base.atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt;. This is the default behavior in Julia script run without &lt;code&gt;-i&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1a52fdda97e9a9edb8d40a32fdbba7468a954c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is an abstract type, then the method that would be called by &lt;code&gt;invoke&lt;/code&gt; is returned.</source>
          <target state="translated">如果 &lt;code&gt;types&lt;/code&gt; 是抽象类型，则返回将由 &lt;code&gt;invoke&lt;/code&gt; 调用的方法。</target>
        </trans-unit>
        <trans-unit id="99dfe42909a3f5fda34b5da4dc246c9c5fb25583" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, return an array of methods whose types match. If &lt;code&gt;module&lt;/code&gt; is specified, return an array of methods defined in that module. A list of modules can also be specified as an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58b04b4e4485017440ce0c5de7416ee07070fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, returns an array of methods whose types match.</source>
          <target state="translated">如果指定了 &lt;code&gt;types&lt;/code&gt; ，则返回类型匹配的方法数组。</target>
        </trans-unit>
        <trans-unit id="b3892fb415986ed95819205d489e6d5bbab6470a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mmap&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the file specified by &lt;code&gt;source&lt;/code&gt; is memory mapped for potential speedups. Default is &lt;code&gt;true&lt;/code&gt; except on Windows. On Windows, you may want to specify &lt;code&gt;true&lt;/code&gt; if the file is large, and is only read once and not written to.</source>
          <target state="translated">如果 &lt;code&gt;use_mmap&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则将 &lt;code&gt;source&lt;/code&gt; 指定的文件映射到内存以实现潜在的加速。除Windows以外，默认值为 &lt;code&gt;true&lt;/code&gt; 。在Windows上，如果文件很大并且只能读取一次而不写入，则可能需要指定 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5645668108ab9880ec8d6ff07db8800e64be268c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;wait&lt;/code&gt; is false, the process runs asynchronously. You can later wait for it and check its exit status by calling &lt;code&gt;success&lt;/code&gt; on the returned process object.</source>
          <target state="translated">如果 &lt;code&gt;wait&lt;/code&gt; 为false，则该过程异步运行。您可以稍后等待它，并通过对返回的流程对象调用 &lt;code&gt;success&lt;/code&gt; 来检查其退出状态。</target>
        </trans-unit>
        <trans-unit id="4328d82bb88eefa0e600962ab951d3053ce804f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a number, this is essentially the same as &lt;code&gt;one(x)/x&lt;/code&gt;, but for some types &lt;code&gt;inv(x)&lt;/code&gt; may be slightly more efficient.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是一个数字，则本质上与 &lt;code&gt;one(x)/x&lt;/code&gt; 相同，但是对于某些类型， &lt;code&gt;inv(x)&lt;/code&gt; 可能会稍微更有效。</target>
        </trans-unit>
        <trans-unit id="5d6e97018433ee560ec26ad905f78e6763128a42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a type, return a &quot;larger&quot; type, defined so that arithmetic operations &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; are guaranteed not to overflow nor lose precision for any combination of values that type &lt;code&gt;x&lt;/code&gt; can hold.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是类型，则返回定义的&amp;ldquo;更大&amp;rdquo;类型，以确保对于类型 &lt;code&gt;x&lt;/code&gt; 可以容纳的值的任何组合，算术运算符 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;-&lt;/code&gt; 不会溢出也不损失精度。</target>
        </trans-unit>
        <trans-unit id="88ba7ee31764ff507d81e94f6a3b385c0be71e42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a value, it is converted to &lt;code&gt;widen(typeof(x))&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是一个值，则将其转换为 &lt;code&gt;widen(typeof(x))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a828e6b72bb380836af54de218be15aa9ebea9db" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object. &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; will return an array filled with the result of evaluating &lt;code&gt;Foo()&lt;/code&gt; once.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 是对象引用，则所有元素都将引用同一对象。 &lt;code&gt;fill(Foo(), dims)&lt;/code&gt; 将返回一个数组，该数组填充一次评估 &lt;code&gt;Foo()&lt;/code&gt; 的结果。</target>
        </trans-unit>
        <trans-unit id="c793973e3f101c15348a8c798bb0a96d340155d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an object reference, all elements will refer to the same object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db317e66581e31b148fb1c68097906f9ec9dcecb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not an &lt;code&gt;AbstractArray&lt;/code&gt; but it supports &lt;code&gt;axes&lt;/code&gt;, indexing, and its type supports &lt;code&gt;ndims&lt;/code&gt;, then &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; may be implemented to just return itself. Further, if &lt;code&gt;x&lt;/code&gt; defines its own &lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt;&lt;code&gt;BroadcastStyle&lt;/code&gt;&lt;/a&gt;, then it must define its &lt;code&gt;broadcastable&lt;/code&gt; method to return itself for the custom style to have any effect.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 不是 &lt;code&gt;AbstractArray&lt;/code&gt; ,但它支持 &lt;code&gt;axes&lt;/code&gt; ，索引，并且其类型支持 &lt;code&gt;ndims&lt;/code&gt; ，则可以实现 &lt;code&gt;broadcastable(::typeof(x))&lt;/code&gt; 只是返回自身。此外，如果 &lt;code&gt;x&lt;/code&gt; 定义了自己的&lt;a href=&quot;#Base.Broadcast.BroadcastStyle&quot;&gt; &lt;code&gt;BroadcastStyle&lt;/code&gt; &lt;/a&gt;，则它必须定义其 &lt;code&gt;broadcastable&lt;/code&gt; 方法以返回自身，以使自定义样式生效。</target>
        </trans-unit>
        <trans-unit id="ead093ec45b992f54a438f256340d7b0a0ef7df6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; supports iteration, the returned value should have the same &lt;code&gt;axes&lt;/code&gt; and indexing behaviors as &lt;code&gt;collect(x)&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;x&lt;/code&gt; 支持迭代，则返回的值应具有与 &lt;code&gt;collect(x)&lt;/code&gt; 相同的 &lt;code&gt;axes&lt;/code&gt; 和索引行为。</target>
        </trans-unit>
        <trans-unit id="9eb6d4efdb2a84932dc930c8197ad4f7fad62394" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt; literal (e.g. &lt;code&gt;2&lt;/code&gt; in &lt;code&gt;x^2&lt;/code&gt; or &lt;code&gt;-3&lt;/code&gt; in &lt;code&gt;x^-3&lt;/code&gt;), the Julia code &lt;code&gt;x^y&lt;/code&gt; is transformed by the compiler to &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt;, to enable compile-time specialization on the value of the exponent. (As a default fallback we have &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt;, where usually &lt;code&gt;^ == Base.^&lt;/code&gt; unless &lt;code&gt;^&lt;/code&gt; has been defined in the calling namespace.)</source>
          <target state="translated">如果 &lt;code&gt;y&lt;/code&gt; 是 &lt;code&gt;Int&lt;/code&gt; 文字（例如 &lt;code&gt;2&lt;/code&gt; 中 &lt;code&gt;x^2&lt;/code&gt; 或 &lt;code&gt;-3&lt;/code&gt; 中 &lt;code&gt;x^-3&lt;/code&gt; ）时，朱代码 &lt;code&gt;x^y&lt;/code&gt; 是由编译器变换为 &lt;code&gt;Base.literal_pow(^, x, Val(y))&lt;/code&gt; ，以对指数值启用编译时专用化。 （作为默认后备，我们有 &lt;code&gt;Base.literal_pow(^, x, Val(y)) = ^(x,y)&lt;/code&gt; ，其中通常 &lt;code&gt;^ == Base.^&lt;/code&gt; 除非在调用名称空间中定义了 &lt;code&gt;^&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="4030642b9b0fac77c474cfa27dc2012de7dca7c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;yes&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, subsequent floating-point operations follow rules for IEEE arithmetic on subnormal values (&quot;denormals&quot;). Otherwise, floating-point operations are permitted (but not required) to convert subnormal inputs or outputs to zero. Returns &lt;code&gt;true&lt;/code&gt; unless &lt;code&gt;yes==true&lt;/code&gt; but the hardware does not support zeroing of subnormal numbers.</source>
          <target state="translated">如果 &lt;code&gt;yes&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; ，则后续的浮点运算将遵循有关次正规值（&amp;ldquo;非正规&amp;rdquo;）的IEEE算术规则。否则，允许（但不是必需）浮点运算将次正规输入或输出转换为零。除非 &lt;code&gt;yes==true&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; ,否则返回true，但硬件不支持将次正规数归零。</target>
        </trans-unit>
        <trans-unit id="4fe82c65bb97ee33e80659528026f81237a00185" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the slurping operator might have been written as &lt;code&gt;&amp;lt;-...&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">如果朱莉娅是那更加自由地使用的ASCII字符的语言中，啜运营商可能已经被写成 &lt;code&gt;&amp;lt;-...&lt;/code&gt; 代替 &lt;code&gt;...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c31aabb66505776aad35d90bd36db4dbf2d1b9d" translate="yes" xml:space="preserve">
          <source>If Julia were a language that made more liberal use of ASCII characters, the splatting operator might have been written as &lt;code&gt;...-&amp;gt;&lt;/code&gt; instead of &lt;code&gt;...&lt;/code&gt;.</source>
          <target state="translated">如果朱莉娅是那更加自由地使用的ASCII字符的语言中，泼洒运营商可能已经被写成 &lt;code&gt;...-&amp;gt;&lt;/code&gt; ，而不是 &lt;code&gt;...&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="60a92e91dcf7c91c0849e69c5ad346e21b345fcf" translate="yes" xml:space="preserve">
          <source>If [&lt;code&gt;vl&lt;/code&gt;, &lt;code&gt;vu&lt;/code&gt;] does not contain all eigenvalues of &lt;code&gt;A&lt;/code&gt;, then the returned factorization will be a &lt;em&gt;truncated&lt;/em&gt; factorization.</source>
          <target state="translated">如果[ &lt;code&gt;vl&lt;/code&gt; ， &lt;code&gt;vu&lt;/code&gt; ]不包含 &lt;code&gt;A&lt;/code&gt; 的所有特征值，则返回的分解将是&lt;em&gt;截断的&lt;/em&gt;分解。</target>
        </trans-unit>
        <trans-unit id="730dc1af168d94eefd1482151f83529bc44df580" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is empty, readers (on a &lt;code&gt;take!&lt;/code&gt; call) will block until data is available.</source>
          <target state="translated">如果&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;是空的，读者（对 &lt;code&gt;take!&lt;/code&gt; 调用）将阻塞，直到数据可用。</target>
        </trans-unit>
        <trans-unit id="84662f0c325b992dd59906d92d27342a4c4aeef8" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is full, writers (on a &lt;code&gt;put!&lt;/code&gt; call) will block until space becomes available.</source>
          <target state="translated">如果&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;已满，则写入器（在 &lt;code&gt;put!&lt;/code&gt; 调用中）将阻塞，直到有可用空间为止。</target>
        </trans-unit>
        <trans-unit id="800a9b7d396fd78b7b6ed22445dc02985ff5d965" translate="yes" xml:space="preserve">
          <source>If a C/C++ routine has an argument or return value that is a native SIMD type, the corresponding Julia type is a homogeneous tuple of &lt;code&gt;VecElement&lt;/code&gt; that naturally maps to the SIMD type. Specifically:</source>
          <target state="translated">如果C / C ++例程的参数或返回值是本机SIMD类型，则对应的Julia类型是 &lt;code&gt;VecElement&lt;/code&gt; 的同类元组，该元组自然地映射到SIMD类型。特别：</target>
        </trans-unit>
        <trans-unit id="c33b9c9ad9c6bea2ac47b4bed7df57b3ce4b628b" translate="yes" xml:space="preserve">
          <source>If a Julia function returns an array, the return value of &lt;code&gt;jl_eval_string&lt;/code&gt; and &lt;code&gt;jl_call&lt;/code&gt; can be cast to a &lt;code&gt;jl_array_t*&lt;/code&gt;:</source>
          <target state="translated">如果Julia函数返回一个数组，则可以将 &lt;code&gt;jl_eval_string&lt;/code&gt; 和 &lt;code&gt;jl_call&lt;/code&gt; 的返回值强制转换为 &lt;code&gt;jl_array_t*&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="da26aec502d267a61bc582bb3d104bf1101787e9" translate="yes" xml:space="preserve">
          <source>If a composite type is declared with &lt;code&gt;mutable struct&lt;/code&gt; instead of &lt;code&gt;struct&lt;/code&gt;, then instances of it can be modified:</source>
          <target state="translated">如果使用 &lt;code&gt;mutable struct&lt;/code&gt; 而不是 &lt;code&gt;struct&lt;/code&gt; 声明了复合类型，则可以修改其实例：</target>
        </trans-unit>
        <trans-unit id="4c7983e304a903c4c76a6412696125933d637b1a" translate="yes" xml:space="preserve">
          <source>If a function name requires multiple words, consider whether it might represent more than one concept and might be better split into pieces.</source>
          <target state="translated">如果一个函数名需要多个字,就要考虑它是否可能代表多个概念,最好是拆成几块。</target>
        </trans-unit>
        <trans-unit id="38936f146450cf1d3ca2236e47484dcaa49c5476" translate="yes" xml:space="preserve">
          <source>If a keyword argument is not assigned a default value in the method definition, then it is &lt;em&gt;required&lt;/em&gt;: an &lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt;&lt;code&gt;UndefKeywordError&lt;/code&gt;&lt;/a&gt; exception will be thrown if the caller does not assign it a value:</source>
          <target state="translated">如果未在方法定义中为关键字参数分配默认值，则&lt;em&gt;需要此参数&lt;/em&gt;：如果调用者未为其分配值，则将引发&lt;a href=&quot;../../base/base/index#Core.UndefKeywordError&quot;&gt; &lt;code&gt;UndefKeywordError&lt;/code&gt; &lt;/a&gt;异常：</target>
        </trans-unit>
        <trans-unit id="605fe15674b1485baef4edc3c0b585f43273c96f" translate="yes" xml:space="preserve">
          <source>If a name is qualified (e.g. &lt;code&gt;Base.sin&lt;/code&gt;), then it can be accessed even if it is not exported. This is often useful when debugging. It can also have methods added to it by using the qualified name as the function name. However, due to syntactic ambiguities that arise, if you wish to add methods to a function in a different module whose name contains only symbols, such as an operator, &lt;code&gt;Base.+&lt;/code&gt; for example, you must use &lt;code&gt;Base.:+&lt;/code&gt; to refer to it. If the operator is more than one character in length you must surround it in brackets, such as: &lt;code&gt;Base.:(==)&lt;/code&gt;.</source>
          <target state="translated">如果名称是合格的（例如 &lt;code&gt;Base.sin&lt;/code&gt; ），则即使未导出名称也可以访问它。这在调试时通常很有用。通过使用限定名称作为函数名称，它也可以添加方法。但是，由于出现语法上的歧义，如果您希望在名称仅包含符号的不同模块中的函数中添加方法，例如运算符 &lt;code&gt;Base.+&lt;/code&gt; ，则必须使用 &lt;code&gt;Base.:+&lt;/code&gt; 来引用它。 。如果运算符的长度超过一个字符，则必须将其括在方括号中，例如： &lt;code&gt;Base.:(==)&lt;/code&gt; . :( ==）。</target>
        </trans-unit>
        <trans-unit id="906babc709733bae3d983752e96904e9364b6d02" translate="yes" xml:space="preserve">
          <source>If a number doesn't have an exact floating-point representation, it must be rounded to an appropriate representable value. However, the manner in which this rounding is done can be changed if required according to the rounding modes presented in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;.</source>
          <target state="translated">如果数字没有精确的浮点表示形式，则必须将其四舍五入为适当的可表示值。但是，如果需要，可以根据&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754标准中&lt;/a&gt;提出的舍入模式更改进行舍入的方式。</target>
        </trans-unit>
        <trans-unit id="b6c6ec423ec9e7ccad324608060715dc6c4297ac" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has a project file, then the graph entry for its UUID is the &lt;code&gt;[deps]&lt;/code&gt; map of the project file, which is considered to be empty if the section is absent.</source>
          <target state="translated">如果程序包子目录中有一个项目文件，则其UUID的图形条目是该项目文件的 &lt;code&gt;[deps]&lt;/code&gt; 映射，如果该部分不存在，则视为空白。</target>
        </trans-unit>
        <trans-unit id="b858ef46784b4025474ecb1ef203d57b534b42bf" translate="yes" xml:space="preserve">
          <source>If a package subdirectory has no project file, then it is omitted from graph and import statements in its code are treated as top-level, the same as the main project and REPL.</source>
          <target state="translated">如果一个包子目录没有项目文件,那么就从图中省略,其代码中的导入语句按顶层处理,与主项目和REPL一样。</target>
        </trans-unit>
        <trans-unit id="2f45dbf01a0d76d1b423a11e7134b517f4cc2734" translate="yes" xml:space="preserve">
          <source>If a regular expression does match, the value returned by &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; is a &lt;code&gt;RegexMatch&lt;/code&gt; object. These objects record how the expression matches, including the substring that the pattern matches and any captured substrings, if there are any. This example only captures the portion of the substring that matches, but perhaps we want to capture any non-blank text after the comment character. We could do the following:</source>
          <target state="translated">如果正则表达式确实匹配，返回的值&lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; &lt;/a&gt;是 &lt;code&gt;RegexMatch&lt;/code&gt; 对象。这些对象记录表达式的匹配方式，包括模式匹配的子字符串和任何捕获的子字符串（如果有）。此示例仅捕获匹配的子字符串部分，但是也许我们希望捕获注释字符之后的所有非空白文本。我们可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="5e6085fa6af3d4081b0dc16abe2813cbe1633ab2" translate="yes" xml:space="preserve">
          <source>If a second argument &lt;code&gt;val&lt;/code&gt; is provided, it will be passed to the task (via the return value of &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;) when it runs again. If &lt;code&gt;error&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the value is raised as an exception in the woken task.</source>
          <target state="translated">如果提供了第二个参数 &lt;code&gt;val&lt;/code&gt; ，它将在再次运行时（通过&lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;的返回值）传递给任务。如果 &lt;code&gt;error&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，那么该值将作为唤醒任务中的异常引发。</target>
        </trans-unit>
        <trans-unit id="731b72f6b2ff317794a532fdec183702202f0468" translate="yes" xml:space="preserve">
          <source>If a subtype is used to represent values that may occasionally be rational (e.g. a square-root type that represents &lt;code&gt;&amp;radic;n&lt;/code&gt; for integers &lt;code&gt;n&lt;/code&gt; will give a rational result when &lt;code&gt;n&lt;/code&gt; is a perfect square), then it should also implement &lt;code&gt;isinteger&lt;/code&gt;, &lt;code&gt;iszero&lt;/code&gt;, &lt;code&gt;isone&lt;/code&gt;, and &lt;code&gt;==&lt;/code&gt; with &lt;code&gt;Real&lt;/code&gt; values (since all of these default to &lt;code&gt;false&lt;/code&gt; for &lt;code&gt;AbstractIrrational&lt;/code&gt; types), as well as defining &lt;a href=&quot;../base/index#Base.hash&quot;&gt;&lt;code&gt;hash&lt;/code&gt;&lt;/a&gt; to equal that of the corresponding &lt;code&gt;Rational&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad86ee27c201caed09e850508017b392f709911" translate="yes" xml:space="preserve">
          <source>If a test fails consistently it can be changed to use the &lt;code&gt;@test_broken&lt;/code&gt; macro. This will denote the test as &lt;code&gt;Broken&lt;/code&gt; if the test continues to fail and alerts the user via an &lt;code&gt;Error&lt;/code&gt; if the test succeeds.</source>
          <target state="translated">如果测试始终失败，则可以更改为使用 &lt;code&gt;@test_broken&lt;/code&gt; 宏。如果测试继续失败，则将测试表示为&amp;ldquo; &lt;code&gt;Broken&lt;/code&gt; 如果测试成功，则将通过&amp;ldquo; &lt;code&gt;Error&lt;/code&gt; 向用户发出警报。</target>
        </trans-unit>
        <trans-unit id="f4acf383897e60ec242acf14416a5081e1af3573" translate="yes" xml:space="preserve">
          <source>If a tuple of keyword argument names &lt;code&gt;kwnames&lt;/code&gt; is provided, this also checks whether the method of &lt;code&gt;f&lt;/code&gt; matching &lt;code&gt;t&lt;/code&gt; has the given keyword argument names. If the matching method accepts a variable number of keyword arguments, e.g. with &lt;code&gt;kwargs...&lt;/code&gt;, any names given in &lt;code&gt;kwnames&lt;/code&gt; are considered valid. Otherwise the provided names must be a subset of the method's keyword arguments.</source>
          <target state="translated">如果提供了关键字参数名称 &lt;code&gt;kwnames&lt;/code&gt; 的元组，这还将检查 &lt;code&gt;f&lt;/code&gt; 匹配 &lt;code&gt;t&lt;/code&gt; 的方法是否具有给定的关键字参数名称。如果匹配方法接受可变数量的关键字参数，例如 &lt;code&gt;kwargs...&lt;/code&gt; ，则 &lt;code&gt;kwnames&lt;/code&gt; 中给出的任何名称均被视为有效。否则，提供的名称必须是方法的关键字参数的子集。</target>
        </trans-unit>
        <trans-unit id="abfdad8cad5f7ab5488ad45c94b34a153640fd97" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df6568badc4d30be904f3a616a563af8fd77a0a" translate="yes" xml:space="preserve">
          <source>If a type is defined as a subtype of &lt;code&gt;AbstractArray&lt;/code&gt;, it inherits a very large set of rich behaviors including iteration and multidimensional indexing built on top of single-element access. See the &lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;arrays manual page&lt;/a&gt; and the &lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia Base section&lt;/a&gt; for more supported methods.</source>
          <target state="translated">如果将类型定义为 &lt;code&gt;AbstractArray&lt;/code&gt; 的子类型，则它将继承大量丰富的行为，包括基于单元素访问建立的迭代和多维索引。有关更多受支持的方法，请参见&lt;a href=&quot;../arrays/index#man-multi-dim-arrays-1&quot;&gt;数组手册页&lt;/a&gt;和&lt;a href=&quot;../../base/arrays/index#lib-arrays-1&quot;&gt;Julia基础部分&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="72a8103071abaea7ac2a617ea71042865eddd171" translate="yes" xml:space="preserve">
          <source>If a type is effectively an enumeration, it should be defined as a single (ideally immutable struct or primitive) type, with the enumeration values being instances of it. Constructors and conversions can check whether values are valid. This design is preferred over making the enumeration an abstract type, with the &quot;values&quot; as subtypes.</source>
          <target state="translated">如果一个类型实际上是一个枚举,那么它应该被定义为一个单一的(最好是不可变的结构或基元)类型,枚举值是它的实例。构造函数和转换函数可以检查值是否有效。这种设计比把枚举变成一个抽象类型,把 &quot;值 &quot;作为子类型更可取。</target>
        </trans-unit>
        <trans-unit id="22206d1a9cff4ea1aad87ee3f387a4a25003f12d" translate="yes" xml:space="preserve">
          <source>If a user is presented with a credential prompt they can abort the prompt by typing &lt;code&gt;^D&lt;/code&gt; (pressing the control key together with the &lt;code&gt;d&lt;/code&gt; key).</source>
          <target state="translated">如果向用户显示凭据提示，则可以通过键入 &lt;code&gt;^D&lt;/code&gt; （同时按Ctrl键和 &lt;code&gt;d&lt;/code&gt; 键）来中止提示。</target>
        </trans-unit>
        <trans-unit id="ebb7b0aa6b2c808bffa6df77883dc4cf4f4f7ece" translate="yes" xml:space="preserve">
          <source>If a worker pool is not specified, all available workers, i.e., the default worker pool is used.</source>
          <target state="translated">如果没有指定工人池,则使用所有可用的工人,即使用默认的工人池。</target>
        </trans-unit>
        <trans-unit id="ec5bfd99caef655cee76ea6c587f7690d264c4bb" translate="yes" xml:space="preserve">
          <source>If all data is numeric, the result will be a numeric array. If some elements cannot be parsed as numbers, a heterogeneous array of numbers and strings is returned.</source>
          <target state="translated">如果所有数据都是数字,那么结果将是一个数字数组。如果有些元素不能被解析为数字,则返回一个数字和字符串的异构数组。</target>
        </trans-unit>
        <trans-unit id="9ac5a121e4737af42e151921b98260446a6d1fe7" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are integers, then the value in location &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value of &lt;code&gt;X&lt;/code&gt;, &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;ing to the &lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt;&lt;code&gt;eltype&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;A&lt;/code&gt; if necessary.</source>
          <target state="translated">如果所有指数 &lt;code&gt;I_k&lt;/code&gt; 是整数，然后在位置值 &lt;code&gt;I_1, I_2, ..., I_n&lt;/code&gt; 的 &lt;code&gt;A&lt;/code&gt; 被改写的值 &lt;code&gt;X&lt;/code&gt; ，&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;荷兰国际集团的&lt;a href=&quot;../../base/collections/index#Base.eltype&quot;&gt; &lt;code&gt;eltype&lt;/code&gt; &lt;/a&gt;的 &lt;code&gt;A&lt;/code&gt; ，如果必要的。</target>
        </trans-unit>
        <trans-unit id="16c375c96eb496fe31b2274a71fede0f6283f232" translate="yes" xml:space="preserve">
          <source>If all indices &lt;code&gt;I_k&lt;/code&gt; are vectors, for example, then the shape of &lt;code&gt;X&lt;/code&gt; would be &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt;, with location &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; of &lt;code&gt;X&lt;/code&gt; containing the value &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt;.</source>
          <target state="translated">如果所有指数 &lt;code&gt;I_k&lt;/code&gt; 是矢量，例如，然后的形状 &lt;code&gt;X&lt;/code&gt; 将是 &lt;code&gt;(length(I_1), length(I_2), ..., length(I_n))&lt;/code&gt; ，与位置 &lt;code&gt;i_1, i_2, ..., i_n&lt;/code&gt; 的 &lt;code&gt;X&lt;/code&gt; 包含值 &lt;code&gt;A[I_1[i_1], I_2[i_2], ..., I_n[i_n]]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7329bd9dbc66827b90f349500e9813dc3f4dd6b" translate="yes" xml:space="preserve">
          <source>If all the arguments are scalars or zero-dimensional arrays, it returns an unwrapped scalar.</source>
          <target state="translated">如果所有参数都是标量或零维数组,则返回一个未封装的标量。</target>
        </trans-unit>
        <trans-unit id="947c4d2702167c0b010760802f3c8902ac7ef2b7" translate="yes" xml:space="preserve">
          <source>If all the indices are scalars, then the result &lt;code&gt;X&lt;/code&gt; is a single element from the array &lt;code&gt;A&lt;/code&gt;. Otherwise, &lt;code&gt;X&lt;/code&gt; is an array with the same number of dimensions as the sum of the dimensionalities of all the indices.</source>
          <target state="translated">如果所有索引都是标量，则结果 &lt;code&gt;X&lt;/code&gt; 是数组 &lt;code&gt;A&lt;/code&gt; 中的单个元素。否则， &lt;code&gt;X&lt;/code&gt; 是一个维数与所有索引的维数总和相同的数组。</target>
        </trans-unit>
        <trans-unit id="3044600e4ff9e45b323c2058f952d5b48a41642d" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="translated">如果所有这些检查均通过，则将对消息和键值对进行完整评估，并通过&lt;a href=&quot;#Base.CoreLogging.handle_message&quot;&gt; &lt;code&gt;Logging.handle_message&lt;/code&gt; &lt;/a&gt;函数将其传递给当前记录器。 &lt;code&gt;handle_message()&lt;/code&gt; 可以根据需要执行其他过滤，并将事件显示在屏幕上，将其保存到文件等。</target>
        </trans-unit>
        <trans-unit id="80169baf9571e6bf174d6f8272d7aa9246651030" translate="yes" xml:space="preserve">
          <source>If all these checks pass, the message and key&amp;ndash;value pairs are evaluated in full and passed to the current logger via the &lt;a href=&quot;#Logging.handle_message&quot;&gt;&lt;code&gt;Logging.handle_message&lt;/code&gt;&lt;/a&gt; function. &lt;code&gt;handle_message()&lt;/code&gt; may perform additional filtering as required and display the event to the screen, save it to a file, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bec4431d05d00195da3b5ef4209465d15c43707c" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function of the type &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; is specified, it is called on all the participating workers.</source>
          <target state="translated">如果指定了 &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 类型的 &lt;code&gt;init&lt;/code&gt; 函数，则会在所有参与的worker上调用它。</target>
        </trans-unit>
        <trans-unit id="3b65b9c692ce6d8deffe1b518910973b66bdfe66" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;init&lt;/code&gt; function, of signature &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt;, is specified, it is called on all the participating workers. You can specify that each worker runs the &lt;code&gt;init&lt;/code&gt; function on a distinct portion of the array, thereby parallelizing initialization.</source>
          <target state="translated">如果指定了签名为 &lt;code&gt;initfn(S::SharedArray)&lt;/code&gt; 的 &lt;code&gt;init&lt;/code&gt; 函数，则会在所有参与的worker上调用它。您可以指定每个工作程序在数组的不同部分上运行 &lt;code&gt;init&lt;/code&gt; 函数，从而并行化初始化。</target>
        </trans-unit>
        <trans-unit id="dcd6328c4dd12bc549abfb594d444224ffd4160c" translate="yes" xml:space="preserve">
          <source>If an array of eltype &lt;code&gt;Ptr{T}&lt;/code&gt; is passed as a &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; argument, &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; will attempt to first make a null-terminated copy of the array with each element replaced by its &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; version. This allows, for example, passing an &lt;code&gt;argv&lt;/code&gt; pointer array of type &lt;code&gt;Vector{String}&lt;/code&gt; to an argument of type &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt;.</source>
          <target state="translated">如果将Eltype &lt;code&gt;Ptr{T}&lt;/code&gt; 的数组作为 &lt;code&gt;Ptr{Ptr{T}}&lt;/code&gt; 参数&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;，则Base.cconvert将尝试首先为该数组创建一个以空终止的副本，并用其&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;版本替换每个元素。例如，这允许将 &lt;code&gt;Vector{String}&lt;/code&gt; 类型的 &lt;code&gt;argv&lt;/code&gt; 指针数组传递给 &lt;code&gt;Ptr{Ptr{Cchar}}&lt;/code&gt; 类型的参数。</target>
        </trans-unit>
        <trans-unit id="8aa768f627a40c9d0913fe21e857ab82ce9b4abc" translate="yes" xml:space="preserve">
          <source>If any conflicts arise which cannot be automatically resolved, the rebase will abort, leaving the repository and working tree in its original state, and the function will throw a &lt;code&gt;GitError&lt;/code&gt;. This is roughly equivalent to the following command line statement:</source>
          <target state="translated">如果出现任何无法自动解决的冲突，则重新建立基础将中止，从而使存储库和工作树保持其原始状态，并且该函数将引发 &lt;code&gt;GitError&lt;/code&gt; 。这大致等效于以下命令行语句：</target>
        </trans-unit>
        <trans-unit id="cb2726b6f11cf6d744cc2e0de08cc88e0caae92f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d387af77f5db6a955f974f865de51228d37bd15f" translate="yes" xml:space="preserve">
          <source>If any index &lt;code&gt;I_k&lt;/code&gt; selects more than one location, then the right hand side &lt;code&gt;X&lt;/code&gt; must be an array with the same shape as the result of indexing &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; or a vector with the same number of elements. The value in location &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; is overwritten with the value &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt;, converting if necessary. The element-wise assignment operator &lt;code&gt;.=&lt;/code&gt; may be used to &lt;a href=&quot;#Broadcasting-1&quot;&gt;broadcast&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; across the selected locations:</source>
          <target state="translated">如果任何索引 &lt;code&gt;I_k&lt;/code&gt; 选择多个位置，则右侧 &lt;code&gt;X&lt;/code&gt; 必须是具有与索引 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; 相同的形状的数组或具有相同元素数的向量。 A的位置 &lt;code&gt;I_1[i_1], I_2[i_2], ..., I_n[i_n]&lt;/code&gt; 中的值 &lt;code&gt;A&lt;/code&gt; 被值 &lt;code&gt;X[I_1, I_2, ..., I_n]&lt;/code&gt; 覆盖，并在必要时进行转换。逐元素分配运算符 &lt;code&gt;.=&lt;/code&gt; 可用于在所选位置之间&lt;a href=&quot;#Broadcasting-1&quot;&gt;广播&lt;/a&gt; &lt;code&gt;X&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="a2dae61ea17ea95a5a6582831ba526a24537cb67" translate="yes" xml:space="preserve">
          <source>If any inner constructor method is defined, no default constructor method is provided: it is presumed that you have supplied yourself with all the inner constructors you need. The default constructor is equivalent to writing your own inner constructor method that takes all of the object's fields as parameters (constrained to be of the correct type, if the corresponding field has a type), and passes them to &lt;code&gt;new&lt;/code&gt;, returning the resulting object:</source>
          <target state="translated">如果定义了任何内部构造函数方法，则不会提供默认的构造函数方法：假定您已为自己提供了所需的所有内部构造函数。默认构造函数等效于编写自己的内部构造函数方法，该方法将对象的所有字段都用作参数（如果对应的字段具有类型，则约束为正确的类型），并将它们传递给 &lt;code&gt;new&lt;/code&gt; ，并返回结果对象：</target>
        </trans-unit>
        <trans-unit id="e9dbb4d7bac298e185fc7fe07e57c374bc123283" translate="yes" xml:space="preserve">
          <source>If any of these result in success, the path to the source code entry point will be either that result, the relative path from that result plus &lt;code&gt;src/X.jl&lt;/code&gt;; otherwise, there is no path mapping for &lt;code&gt;uuid&lt;/code&gt;. When loading &lt;code&gt;X&lt;/code&gt;, if no source code path is found, the lookup will fail, and the user may be prompted to install the appropriate package version or to take other corrective action (e.g. declaring &lt;code&gt;X&lt;/code&gt; as a dependency).</source>
          <target state="translated">如果这些结果中的任何一个成功，则到源代码入口点的路径将是该结果，即该结果的相对路径加上 &lt;code&gt;src/X.jl&lt;/code&gt; ；否则，没有 &lt;code&gt;uuid&lt;/code&gt; 的路径映射。加载 &lt;code&gt;X&lt;/code&gt; 时，如果未找到源代码路径，查找将失败，并且可能会提示用户安装适当的软件包版本或采取其他纠正措施（例如，将 &lt;code&gt;X&lt;/code&gt; 声明为依赖项）。</target>
        </trans-unit>
        <trans-unit id="4ddf1789b0cb07d74b04fcfdb8b7aef3cf09d72f" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the standard deviation of non-missing values.</source>
          <target state="translated">如果数组包含 &lt;code&gt;NaN&lt;/code&gt; 或&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值，则结果也为 &lt;code&gt;NaN&lt;/code&gt; 或 &lt;code&gt;missing&lt;/code&gt; （如果数组同时包含两者，则 &lt;code&gt;missing&lt;/code&gt; 优先。）使用&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;功能可以省略 &lt;code&gt;missing&lt;/code&gt; 条目并计算非遗漏值的标准偏差。</target>
        </trans-unit>
        <trans-unit id="3a6293b5e98855a8ee42f2bca1bebc73fa339517" translate="yes" xml:space="preserve">
          <source>If array contains &lt;code&gt;NaN&lt;/code&gt; or &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, the result is also &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;missing&lt;/code&gt; (&lt;code&gt;missing&lt;/code&gt; takes precedence if array contains both). Use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to omit &lt;code&gt;missing&lt;/code&gt; entries and compute the variance of non-missing values.</source>
          <target state="translated">如果数组包含 &lt;code&gt;NaN&lt;/code&gt; 或&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值，则结果也为 &lt;code&gt;NaN&lt;/code&gt; 或 &lt;code&gt;missing&lt;/code&gt; （如果数组同时包含两者，则 &lt;code&gt;missing&lt;/code&gt; 优先。）使用&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;函数可以省略 &lt;code&gt;missing&lt;/code&gt; 条目并计算非缺失值的方差。</target>
        </trans-unit>
        <trans-unit id="38e45e26639753f801787edbbd58523b34871d79" translate="yes" xml:space="preserve">
          <source>If at least one argument is a tuple and all others are scalars or zero-dimensional arrays, it returns a tuple.</source>
          <target state="translated">如果至少有一个参数是元组,而其他所有参数都是标量或零维数组,它就返回一个元组。</target>
        </trans-unit>
        <trans-unit id="186a2528019c2b28f2ac036bd36737c001f4c334" translate="yes" xml:space="preserve">
          <source>If called with the optional &lt;code&gt;stream&lt;/code&gt; argument, then returns &lt;code&gt;stream&lt;/code&gt; itself.</source>
          <target state="translated">如果使用可选的 &lt;code&gt;stream&lt;/code&gt; 参数调用，则返回 &lt;code&gt;stream&lt;/code&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="c2dc6a2dba2346f86620a63b3cfed83cd90e27f4" translate="yes" xml:space="preserve">
          <source>If captured variables are used in a performance-critical section of the code, then the following tips help ensure that their use is performant. First, if it is known that a captured variable does not change its type, then this can be declared explicitly with a type annotation (on the variable, not the right-hand side):</source>
          <target state="translated">如果捕获的变量被用于代码中对性能要求很高的部分,那么下面的提示有助于确保它们的使用是高性能的。首先,如果知道捕获的变量不会改变其类型,那么可以用类型注解(在变量上,而不是右侧)明确声明。</target>
        </trans-unit>
        <trans-unit id="1a5d4d133718a06af974dc91ca305c022dd4e098" translate="yes" xml:space="preserve">
          <source>If field types are specified, the arguments are converted. Otherwise the types of the arguments are used directly.</source>
          <target state="translated">如果指定了字段类型,参数会被转换。否则直接使用参数的类型。</target>
        </trans-unit>
        <trans-unit id="8f773999b3dbcf00b06936dfadd297798081b077" translate="yes" xml:space="preserve">
          <source>If instead you want to specialize on the destination type &lt;code&gt;DestType&lt;/code&gt; without specializing on &lt;code&gt;DestStyle&lt;/code&gt;, then you should define a method with the following signature:</source>
          <target state="translated">相反，如果您想专注于目标类型 &lt;code&gt;DestType&lt;/code&gt; 而不专注于 &lt;code&gt;DestStyle&lt;/code&gt; ，那么您应该使用以下签名定义一个方法：</target>
        </trans-unit>
        <trans-unit id="861e841404a73546cfbc58b3413de786fc3740a2" translate="yes" xml:space="preserve">
          <source>If it does not have a project file, it can import any top-level package&amp;mdash;i.e. the same packages that can be loaded in &lt;code&gt;Main&lt;/code&gt; or the REPL.</source>
          <target state="translated">如果没有项目文件，则可以导入任何顶级软件包，即可以在 &lt;code&gt;Main&lt;/code&gt; 或REPL中加载的相同软件包。</target>
        </trans-unit>
        <trans-unit id="4cdc37b95e5e03c0daf7e3854e30ae2e06ab2fbd" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry, compute a deterministic hash function of &lt;code&gt;uuid&lt;/code&gt; and &lt;code&gt;git-tree-sha1&lt;/code&gt;&amp;mdash;call it &lt;code&gt;slug&lt;/code&gt;&amp;mdash;and look for a directory named &lt;code&gt;packages/X/$slug&lt;/code&gt; in each directory in the Julia &lt;code&gt;DEPOT_PATH&lt;/code&gt; global array. Use the first such directory that exists.</source>
          <target state="translated">如果它有一个 &lt;code&gt;git-tree-sha1&lt;/code&gt; 项，计算的确定性哈希函数 &lt;code&gt;uuid&lt;/code&gt; 和 &lt;code&gt;git-tree-sha1&lt;/code&gt; -call它 &lt;code&gt;slug&lt;/code&gt; -和查找一个名为目录 &lt;code&gt;packages/X/$slug&lt;/code&gt; 在朱莉娅在每个目录 &lt;code&gt;DEPOT_PATH&lt;/code&gt; 全局数组。使用存在的第一个这样的目录。</target>
        </trans-unit>
        <trans-unit id="cd1241924f2c661cd879945fa2b395e0b0c5bf1c" translate="yes" xml:space="preserve">
          <source>If it has a &lt;code&gt;path&lt;/code&gt; entry, use that path (relative to the directory containing the manifest file).</source>
          <target state="translated">如果它具有 &lt;code&gt;path&lt;/code&gt; 条目，请使用该路径（相对于包含清单文件的目录）。</target>
        </trans-unit>
        <trans-unit id="ecfbca60e91ee74286b0eaf619c2ce8c59e2470c" translate="yes" xml:space="preserve">
          <source>If it has a project file, it can only import those packages which are identified in the &lt;code&gt;[deps]&lt;/code&gt; section of the project file.</source>
          <target state="translated">如果具有项目文件，则只能导入在项目文件的 &lt;code&gt;[deps]&lt;/code&gt; 部分中标识的那些软件包。</target>
        </trans-unit>
        <trans-unit id="d73050aa6cb9e92d8510b86ef26b845581d55552" translate="yes" xml:space="preserve">
          <source>If it is required to hold the pointer to a variable between functions (or block scopes), then it is not possible to use &lt;code&gt;JL_GC_PUSH*&lt;/code&gt;. In this case, it is necessary to create and keep a reference to the variable in the Julia global scope. One simple way to accomplish this is to use a global &lt;code&gt;IdDict&lt;/code&gt; that will hold the references, avoiding deallocation by the GC. However, this method will only work properly with mutable types.</source>
          <target state="translated">如果需要在函数（或块作用域）之间保留指向变量的指针，则无法使用 &lt;code&gt;JL_GC_PUSH*&lt;/code&gt; 。在这种情况下，有必要在Julia全局范围内创建并保留对变量的引用。一种简单的方法是使用全局 &lt;code&gt;IdDict&lt;/code&gt; ，该IdDict将保存引用，从而避免了GC的重新分配。但是，此方法仅适用于可变类型。</target>
        </trans-unit>
        <trans-unit id="473e682023e21d67484bab11333a56f6e24d4e3e" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt;, then counts for the number of calls to &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; and &lt;code&gt;maybe_collect()&lt;/code&gt; are printed.</source>
          <target state="translated">如果是第 &lt;code&gt;n&lt;/code&gt; 次调用 &lt;code&gt;jl_gc_collect()&lt;/code&gt; ，并且 &lt;code&gt;n&lt;/code&gt; 属于 &lt;code&gt;$JULIA_GC_ALLOC_PRINT&lt;/code&gt; 表示的算术序列，则打印对 &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; 和 &lt;code&gt;maybe_collect()&lt;/code&gt; 的调用次数。</target>
        </trans-unit>
        <trans-unit id="130d982e40fa648e81bf69006602371d8efc3765" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">如果是第 &lt;code&gt;n&lt;/code&gt; 次调用 &lt;code&gt;jl_gc_pool_alloc()&lt;/code&gt; ，并且 &lt;code&gt;n&lt;/code&gt; 属于 &lt;code&gt;$JULIA_GC_ALLOC_POOL&lt;/code&gt; 表示的算术序列，则将强制进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="40d1d12e4aea313c12b9b3da68ad08e9a0d521e5" translate="yes" xml:space="preserve">
          <source>If it's the &lt;code&gt;n&lt;/code&gt;th time that &lt;code&gt;maybe_collect()&lt;/code&gt; has been called, and &lt;code&gt;n&lt;/code&gt; belongs to the arithmetic sequence represented by &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt;, then garbage collection is forced.</source>
          <target state="translated">如果是第 &lt;code&gt;n&lt;/code&gt; 次调用 &lt;code&gt;maybe_collect()&lt;/code&gt; ，并且 &lt;code&gt;n&lt;/code&gt; 属于 &lt;code&gt;$JULIA_GC_ALLOC_OTHER&lt;/code&gt; 表示的算术序列，则将强制进行垃圾回收。</target>
        </trans-unit>
        <trans-unit id="74f9655f12c7f5e7ed84cb6e935e104ba2688d1a" translate="yes" xml:space="preserve">
          <source>If keyword &lt;code&gt;supertypes&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, also return arguments with a parent type of &lt;code&gt;typ&lt;/code&gt;, excluding type &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">如果关键字 &lt;code&gt;supertypes&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则还返回其父类型为 &lt;code&gt;typ&lt;/code&gt; 的参数，但不包括 &lt;code&gt;Any&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="bc696527340f0e0e085e98638a1e2d12825b4024" translate="yes" xml:space="preserve">
          <source>If memory usage is your concern, you can always replace objects with ones that consume less memory. For example, if &lt;code&gt;A&lt;/code&gt; is a gigabyte-sized array that you no longer need, you can free the memory with &lt;code&gt;A = nothing&lt;/code&gt;. The memory will be released the next time the garbage collector runs; you can force this to happen with &lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt;&lt;code&gt;gc()&lt;/code&gt;&lt;/a&gt;. Moreover, an attempt to use &lt;code&gt;A&lt;/code&gt; will likely result in an error, because most methods are not defined on type &lt;code&gt;Nothing&lt;/code&gt;.</source>
          <target state="translated">如果您关注内存使用情况，则始终可以用消耗更少内存的对象替换对象。例如，如果 &lt;code&gt;A&lt;/code&gt; 是不再需要的千兆字节大小的数组，则可以使用 &lt;code&gt;A = nothing&lt;/code&gt; 释放内存。下次垃圾回收器运行时将释放内存；您可以使用&lt;a href=&quot;../../base/base/index#Base.GC.gc&quot;&gt; &lt;code&gt;gc()&lt;/code&gt; &lt;/a&gt;强制执行此操作。此外，尝试使用 &lt;code&gt;A&lt;/code&gt; 可能会导致错误，因为大多数方法未在 &lt;code&gt;Nothing&lt;/code&gt; 类型上定义。</target>
        </trans-unit>
        <trans-unit id="5d311a5ead70c39f70d69a25fb13adf9b0a2959d" translate="yes" xml:space="preserve">
          <source>If much of your run time is spent executing a particular line of code, this line will show up frequently in the set of all backtraces. In other words, the &quot;cost&quot; of a given line&amp;ndash;or really, the cost of the sequence of function calls up to and including this line&amp;ndash;is proportional to how often it appears in the set of all backtraces.</source>
          <target state="translated">如果您花费大量的运行时间来执行特定的代码行，则此行将频繁出现在所有回溯的集合中。换句话说，给定行的&amp;ldquo;成本&amp;rdquo;，或者实际上，直到并包括该行的函数调用序列的成本，与它在所有回溯集中出现的频率成正比。</target>
        </trans-unit>
        <trans-unit id="99791a8f1a9660eaeaa9f5b9e831b943f3ed9006" translate="yes" xml:space="preserve">
          <source>If needed, the sorting algorithm can be chosen:</source>
          <target state="translated">如果需要,可以选择排序算法。</target>
        </trans-unit>
        <trans-unit id="4223679e9c9b3c609f6bfb56a1e1db206adba7ec" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;type&lt;/code&gt; argument is specified, the default is &lt;code&gt;Vector{UInt8}&lt;/code&gt;.</source>
          <target state="translated">如果未指定 &lt;code&gt;type&lt;/code&gt; 参数，则默认值为 &lt;code&gt;Vector{UInt8}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="dfa8e1861fd13b4e706313c90dcab6ea83fe0c35" translate="yes" xml:space="preserve">
          <source>If no argument is passed, the task blocks for an undefined period. A task can only be restarted by an explicit call to &lt;a href=&quot;#Base.schedule&quot;&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果未传递任何参数，则任务将阻塞一段不确定的时间。只能通过显式调用&lt;a href=&quot;#Base.schedule&quot;&gt; &lt;code&gt;schedule&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;来重新启动任务。</target>
        </trans-unit>
        <trans-unit id="aa0a9f892d2c7e314c83b4254ca8ced8f31ecd25" translate="yes" xml:space="preserve">
          <source>If no custom testset type is given it defaults to creating a &lt;code&gt;DefaultTestSet&lt;/code&gt;. &lt;code&gt;DefaultTestSet&lt;/code&gt; records all the results and, if there are any &lt;code&gt;Fail&lt;/code&gt;s or &lt;code&gt;Error&lt;/code&gt;s, throws an exception at the end of the top-level (non-nested) test set, along with a summary of the test results.</source>
          <target state="translated">如果未提供自定义测试集类型，则默认为创建 &lt;code&gt;DefaultTestSet&lt;/code&gt; 。 &lt;code&gt;DefaultTestSet&lt;/code&gt; 记录所有结果，并且如果有任何 &lt;code&gt;Fail&lt;/code&gt; 或 &lt;code&gt;Error&lt;/code&gt; ，则会在顶级（非嵌套）测试集的末尾引发异常，以及测试结果的摘要。</target>
        </trans-unit>
        <trans-unit id="9b7b804c01f85b077652b971d063a65bcf5b1f8e" translate="yes" xml:space="preserve">
          <source>If one of the editor environment variables is set, but no editor entry matches it, the default editor entry is invoked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0f744d0d8245436d7c2b792319d69a40debe40" translate="yes" xml:space="preserve">
          <source>If possible, &lt;code&gt;one(x)&lt;/code&gt; returns a value of the same type as &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;one(T)&lt;/code&gt; returns a value of type &lt;code&gt;T&lt;/code&gt;. However, this may not be the case for types representing dimensionful quantities (e.g. time in days), since the multiplicative identity must be dimensionless. In that case, &lt;code&gt;one(x)&lt;/code&gt; should return an identity value of the same precision (and shape, for matrices) as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">如果可能， &lt;code&gt;one(x)&lt;/code&gt; 返回与 &lt;code&gt;x&lt;/code&gt; 相同类型的值，并且 &lt;code&gt;one(T)&lt;/code&gt; 返回 &lt;code&gt;T&lt;/code&gt; 类型的值。但是，对于表示维量（例如，以天为单位的时间）的类型，情况可能并非如此，因为乘法身份必须是无量纲的。在这种情况下， &lt;code&gt;one(x)&lt;/code&gt; 应返回的同一精度的标识值（和形状，矩阵）作为 &lt;code&gt;x&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe767ad4883ee037996d5cf486b48b4286df5e71" translate="yes" xml:space="preserve">
          <source>If set to a string that starts with the case-insensitive substring &lt;code&gt;&quot;infinite&quot;&lt;/code&gt;, then spinning threads never sleep. Otherwise, &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; is interpreted as an unsigned 64-bit integer (&lt;code&gt;uint64_t&lt;/code&gt;) and gives, in nanoseconds, the amount of time after which spinning threads should sleep.</source>
          <target state="translated">如果设置为以不区分大小写的子字符串 &lt;code&gt;&quot;infinite&quot;&lt;/code&gt; 开头的字符串，则旋转线程永远不会休眠。否则， &lt;code&gt;$JULIA_THREAD_SLEEP_THRESHOLD&lt;/code&gt; 被解释为一个无符号的64位整数（ &lt;code&gt;uint64_t&lt;/code&gt; ），并给出以秒为单位的旋转线程应该休眠的时间（以纳秒为单位）。</target>
        </trans-unit>
        <trans-unit id="20e80c59100f13ca7e73369cbf1cacf7e59c1aa3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then Julia's thread policy is consistent with running on a dedicated machine: the master thread is on proc 0, and threads are affinitized. Otherwise, Julia lets the operating system handle thread policy.</source>
          <target state="translated">如果设置为 &lt;code&gt;0&lt;/code&gt; 以外的任何值，则Julia的线程策略与在专用计算机上运行一致：主线程在proc 0上，并且线程是亲和的。否则，Julia让操作系统处理线程策略。</target>
        </trans-unit>
        <trans-unit id="f40c9b9b4bbc428bc99a8f3b50c7542418d6c605" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector never performs &quot;quick sweeps&quot; of memory.</source>
          <target state="translated">如果设置为除 &lt;code&gt;0&lt;/code&gt; 之外的任何值，那么Julia垃圾收集器将永远不会执行&amp;ldquo;快速扫描&amp;rdquo;内存。</target>
        </trans-unit>
        <trans-unit id="eb0219b86b58bf1246d63c4e45daa90f20eb81c3" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the Julia garbage collector will wait for a debugger to attach instead of aborting whenever there's a critical error.</source>
          <target state="translated">如果将其设置为除 &lt;code&gt;0&lt;/code&gt; 之外的任何值，则Julia垃圾收集器将在发生严重错误时等待调试器附加，而不是中止。</target>
        </trans-unit>
        <trans-unit id="1ba30fe7de8eb6c5eb6e36c3ca16b929b1d23810" translate="yes" xml:space="preserve">
          <source>If set to anything besides &lt;code&gt;0&lt;/code&gt;, then the compiler will create and register an event listener for just-in-time (JIT) profiling.</source>
          <target state="translated">如果设置为 &lt;code&gt;0&lt;/code&gt; 以外的任何值，则编译器将创建并注册一个事件侦听器以进行即时（JIT）分析。</target>
        </trans-unit>
        <trans-unit id="3b0cd4807865348218a8157872f2d19ba8cef0a0" translate="yes" xml:space="preserve">
          <source>If set, then Julia prints detailed information about the cache in the loading process of &lt;a href=&quot;../../base/base/index#Base.require&quot;&gt;&lt;code&gt;Base.require&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果已设置，则Julia在&lt;a href=&quot;../../base/base/index#Base.require&quot;&gt; &lt;code&gt;Base.require&lt;/code&gt; &lt;/a&gt;的加载过程中打印有关缓存的详细信息。</target>
        </trans-unit>
        <trans-unit id="31ed13caeaa2adf17adcff6b38e069bb43cc30cf" translate="yes" xml:space="preserve">
          <source>If set, these environment variables take strings that optionally start with the character &lt;code&gt;'r'&lt;/code&gt;, followed by a string interpolation of a colon-separated list of three signed 64-bit integers (&lt;code&gt;int64_t&lt;/code&gt;). This triple of integers &lt;code&gt;a:b:c&lt;/code&gt; represents the arithmetic sequence &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;a + b&lt;/code&gt;, &lt;code&gt;a + 2*b&lt;/code&gt;, ... &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">如果设置，则这些环境变量将使用以 &lt;code&gt;'r'&lt;/code&gt; 字符开头的字符串，然后以冒号分隔的三个有符号64位整数（ &lt;code&gt;int64_t&lt;/code&gt; ）列表的形式进行字符串内插。整数 &lt;code&gt;a:b:c&lt;/code&gt; 的三进制表示算术序列 &lt;code&gt;a&lt;/code&gt; ， &lt;code&gt;a + b&lt;/code&gt; ， &lt;code&gt;a + 2*b&lt;/code&gt; ，... &lt;code&gt;c&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="24ec6755ec5d15a629cdab4809712a90cbd8c460" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will have the effect of prepending &lt;code&gt;/foo/bar&lt;/code&gt; to the default depot path. If &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;DEPOT_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty depot path via the environment variable. If you want the default depot path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">如果已经设置了 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 环境变量，则其旧值将以 &lt;code&gt;/foo/bar&lt;/code&gt; 开头。另一方面，如果未设置 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; ，则它将设置为 &lt;code&gt;/foo/bar:&lt;/code&gt; ：，其作用是将 &lt;code&gt;/foo/bar&lt;/code&gt; 设置为默认软件仓库路径。如果 &lt;code&gt;JULIA_DEPOT_PATH&lt;/code&gt; 设置为空字符串，它将扩展为空的 &lt;code&gt;DEPOT_PATH&lt;/code&gt; 数组。换句话说，空字符串被解释为零元素数组，而不是空字符串的一元素数组。选择此行为是为了可以通过环境变量设置空的仓库路径。如果需要默认的软件仓库路径，请取消设置环境变量，或者如果它必须具有值，请将其设置为字符串 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="951a284bb764079dcd311388a60d7dc6fdec988b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_DIR&lt;/code&gt; environment variable hasn't been setup, add it using the System panel before starting Visual Studio. The &lt;code&gt;bin&lt;/code&gt; folder under JULIA_DIR should be on the system PATH.</source>
          <target state="translated">如果尚未设置 &lt;code&gt;JULIA_DIR&lt;/code&gt; 环境变量，请在启动Visual Studio之前使用&amp;ldquo;系统&amp;rdquo;面板添加它。JULIA_DIR下的 &lt;code&gt;bin&lt;/code&gt; 文件夹应位于系统PATH上。</target>
        </trans-unit>
        <trans-unit id="17b0935fee49a1bcd1eec16c0060a0a58dff07ff" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; environment variable is already set, its old value will be prepended with &lt;code&gt;/foo/bar&lt;/code&gt;. On the other hand, if &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is not set, then it will be set to &lt;code&gt;/foo/bar:&lt;/code&gt; which will expand to a &lt;code&gt;LOAD_PATH&lt;/code&gt; value of &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt;. If &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; is set to the empty string, it expands to an empty &lt;code&gt;LOAD_PATH&lt;/code&gt; array. In other words, the empty string is interpreted as a zero-element array, not a one-element array of the empty string. This behavior was chosen so that it would be possible to set an empty load path via the environment variable. If you want the default load path, either unset the environment variable or if it must have a value, set it to the string &lt;code&gt;:&lt;/code&gt;.</source>
          <target state="translated">如果已经设置了 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; 环境变量，则其旧值将以 &lt;code&gt;/foo/bar&lt;/code&gt; 开头。另一方面，如果未设置 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; ，则将其设置为 &lt;code&gt;/foo/bar:&lt;/code&gt; 它将扩展为 &lt;code&gt;LOAD_PATH&lt;/code&gt; 值，为 &lt;code&gt;[&quot;/foo/bar&quot;, &quot;@&quot;, &quot;@v#.#&quot;, &quot;@stdlib&quot;]&lt;/code&gt; 。如果 &lt;code&gt;JULIA_LOAD_PATH&lt;/code&gt; 设置为空字符串，它将扩展为空 &lt;code&gt;LOAD_PATH&lt;/code&gt; 数组。换句话说，空字符串被解释为零元素数组，而不是空字符串的一元素数组。选择此行为是为了可以通过环境变量设置空的加载路径。如果要使用默认的加载路径，请取消设置环境变量，或者如果它必须具有值，请将其设置为字符串 &lt;code&gt;:&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c31f515fa1981bd1d01e28ffd032994e4003fc1e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;digits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of digits after the decimal place (or before if negative), in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">如果提供了 &lt;code&gt;digits&lt;/code&gt; 关键字参数，则将其以base &lt;code&gt;base&lt;/code&gt; 舍入到小数点后（或如果为负，则在小数点后）的指定位数。</target>
        </trans-unit>
        <trans-unit id="f504c38da450ab2719c1e9cd12d8dd34afd33e92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;optimize&lt;/code&gt; keyword is unset, the code will be shown before LLVM optimizations. All metadata and dbg.* calls are removed from the printed bitcode. For the full IR, set the &lt;code&gt;raw&lt;/code&gt; keyword to true. To dump the entire module that encapsulates the function (with declarations), set the &lt;code&gt;dump_module&lt;/code&gt; keyword to true. Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of source (default) or none, to specify the verbosity of code comments.</source>
          <target state="translated">如果未设置 &lt;code&gt;optimize&lt;/code&gt; 关键字，则将在LLVM优化之前显示代码。所有元数据和dbg。*调用都从打印的位码中删除。对于完整的IR，请将 &lt;code&gt;raw&lt;/code&gt; 关键字设置为true。要转储封装函数（带有声明）的整个模块，请将 &lt;code&gt;dump_module&lt;/code&gt; 关键字设置为true。关键字参数 &lt;code&gt;debuginfo&lt;/code&gt; 可以是源之一（默认值），也可以是无源，以指定代码注释的详细程度。</target>
        </trans-unit>
        <trans-unit id="383ecf21766e01ab864dfe9bc7ce841c588d3356" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sigdigits&lt;/code&gt; keyword argument is provided, it rounds to the specified number of significant digits, in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">如果提供了 &lt;code&gt;sigdigits&lt;/code&gt; 关键字参数，则将其四舍五入到以base为 &lt;code&gt;base&lt;/code&gt; 的指定有效数字位数。</target>
        </trans-unit>
        <trans-unit id="cee1b7494eb88d56f5f87336c27b832a3eac177f" translate="yes" xml:space="preserve">
          <source>If the C wrapper never expects the user to pass pointers to memory managed by Julia, then using &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; for the method signature of the wrapper and similarly in the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; is also acceptable.</source>
          <target state="translated">如果C包装程序从不希望用户将指针传递给Julia所管理的内存，则可以使用 &lt;code&gt;p::Ptr{gsl_permutation}&lt;/code&gt; 作为包装程序的方法签名，并且类似地在&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;中也可以接受。</target>
        </trans-unit>
        <trans-unit id="e69c1bb25c07d7be2be84b2aa57348cae51e4053" translate="yes" xml:space="preserve">
          <source>If the above example source is saved in the file &lt;code&gt;embed_example.c&lt;/code&gt;, then the following command will compile it into a running program on Linux and Windows (MSYS2 environment), or if on OS/X, then substitute &lt;code&gt;clang&lt;/code&gt; for &lt;code&gt;gcc&lt;/code&gt;.:</source>
          <target state="translated">如果以上示例源保存在文件 &lt;code&gt;embed_example.c&lt;/code&gt; 中，则以下命令会将其编译为Linux和Windows（MSYS2环境）上正在运行的程序，或者，如果在OS / X上，则将 &lt;code&gt;clang&lt;/code&gt; 替换为 &lt;code&gt;gcc&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9e156941127d94f84d815e5639eaa0e64bcbc457" translate="yes" xml:space="preserve">
          <source>If the above is not the case and the project file has a corresponding manifest file and the manifest contains a stanza matching &lt;code&gt;uuid&lt;/code&gt; then:</source>
          <target state="translated">如果不是上述情况，并且项目文件具有相应的清单文件，并且清单包含与 &lt;code&gt;uuid&lt;/code&gt; 相匹配的节，则：</target>
        </trans-unit>
        <trans-unit id="9f8fd643e0107bc4fc2c8bed2be168d68373f53a" translate="yes" xml:space="preserve">
          <source>If the alias is documented and not the real definition then the docsystem (&lt;code&gt;?&lt;/code&gt; mode) will not return the docstring attached to the alias when the real definition is searched for.</source>
          <target state="translated">如果记录了别名而不是真实定义，那么当搜索真实定义时，文档系统（ &lt;code&gt;?&lt;/code&gt; 模式）将不会返回附加到别名的文档字符串。</target>
        </trans-unit>
        <trans-unit id="f3fd8dba5118a65c9f036f4528fd62b5f0cc2628" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;Future&lt;/code&gt; is owned by a different node, this call will block to wait for the answer. It is recommended to wait for &lt;code&gt;rr&lt;/code&gt; in a separate task instead or to use a local &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; as a proxy:</source>
          <target state="translated">如果参数 &lt;code&gt;Future&lt;/code&gt; 由其他节点拥有，则此调用将阻塞以等待答案。建议在单独的任务中等待 &lt;code&gt;rr&lt;/code&gt; 或使用本地&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;作为代理：</target>
        </trans-unit>
        <trans-unit id="a730ef6e1a231827c433cc4447592ea8e3ba9efc" translate="yes" xml:space="preserve">
          <source>If the arguments inside the square brackets are separated by semicolons (&lt;code&gt;;&lt;/code&gt;) or newlines instead of commas, then their contents are &lt;em&gt;vertically concatenated&lt;/em&gt; together instead of the arguments being used as elements themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5145bb0b73803c7679be17ccbd9728f2cf20e73d" translate="yes" xml:space="preserve">
          <source>If the condition could not be evaluated because an exception was thrown, which occurs in this case because &lt;code&gt;length&lt;/code&gt; is not defined for symbols, an &lt;code&gt;Error&lt;/code&gt; object is returned and an exception is thrown:</source>
          <target state="translated">如果由于抛出异常而无法评估条件，这种情况是由于未为符号定义 &lt;code&gt;length&lt;/code&gt; 而发生的，则返回 &lt;code&gt;Error&lt;/code&gt; 对象并抛出异常：</target>
        </trans-unit>
        <trans-unit id="e94faa3d332e304494043498c5a9abf524bed6e4" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is &lt;code&gt;true&lt;/code&gt;, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. Here it is in action:</source>
          <target state="translated">如果条件表达式 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则对相应的块求值；否则，条件表达式 &lt;code&gt;x &amp;gt; y&lt;/code&gt; 被求值，如果为 &lt;code&gt;true&lt;/code&gt; ，则对相应的块求值；如果两个表达式都不为真，则对 &lt;code&gt;else&lt;/code&gt; 块求值。它在起作用：</target>
        </trans-unit>
        <trans-unit id="e00b24f52421478ecff61089fe0cac3ea509a829" translate="yes" xml:space="preserve">
          <source>If the condition expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, then the corresponding block is evaluated; otherwise the condition expression &lt;code&gt;x &amp;gt; y&lt;/code&gt; is evaluated, and if it is true, the corresponding block is evaluated; if neither expression is true, the &lt;code&gt;else&lt;/code&gt; block is evaluated. The &lt;code&gt;elseif&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; blocks are optional, and as many &lt;code&gt;elseif&lt;/code&gt; blocks as desired can be used.</source>
          <target state="translated">如果条件表达式 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 为真，则对相应的块求值；否则对条件表达式 &lt;code&gt;x &amp;gt; y&lt;/code&gt; 求值，如果为真，则对相应的块求值；如果两个表达式都不为真，则对 &lt;code&gt;else&lt;/code&gt; 块求值。的 &lt;code&gt;elseif&lt;/code&gt; 和 &lt;code&gt;else&lt;/code&gt; 块是可选的，并且尽可能多的 &lt;code&gt;elseif&lt;/code&gt; 块可以根据需要使用。</target>
        </trans-unit>
        <trans-unit id="03e22d8ef38f6c3785531b2aa7d1787777d83c8c" translate="yes" xml:space="preserve">
          <source>If the condition is false, then a &lt;code&gt;Fail&lt;/code&gt; is returned and an exception is thrown:</source>
          <target state="translated">如果条件为假，则返回 &lt;code&gt;Fail&lt;/code&gt; 并引发异常：</target>
        </trans-unit>
        <trans-unit id="6b3bbdbb81ff4f33d7f44d969bf8034d1606bc1e" translate="yes" xml:space="preserve">
          <source>If the condition is true, a &lt;code&gt;Pass&lt;/code&gt; is returned:</source>
          <target state="translated">如果条件为真，一个 &lt;code&gt;Pass&lt;/code&gt; 返回：</target>
        </trans-unit>
        <trans-unit id="cc2105b7ae7cdead96d8521e45a1f5d3d101c4e9" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;x &amp;lt; y&lt;/code&gt; is true, the entire ternary operator expression evaluates to the string &lt;code&gt;&quot;less than&quot;&lt;/code&gt; and otherwise it evaluates to the string &lt;code&gt;&quot;not less than&quot;&lt;/code&gt;. The original three-way example requires chaining multiple uses of the ternary operator together:</source>
          <target state="translated">如果表达式 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 为true，则整个三元运算符表达式的计算结果为字符串 &lt;code&gt;&quot;less than&quot;&lt;/code&gt; ，否则，其计算结果为字符串 &lt;code&gt;&quot;not less than&quot;&lt;/code&gt; 。原始的三向示例要求将三元运算符的多种用法链接在一起：</target>
        </trans-unit>
        <trans-unit id="07cadc79598faa1c956be711a85436f8d736e63e" translate="yes" xml:space="preserve">
          <source>If the file does not exist a new file is created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1992d697b66c6b6347599acbdb8e5fdb9a6621c" translate="yes" xml:space="preserve">
          <source>If the first argument is a single integer &lt;code&gt;n&lt;/code&gt;, then all block rows are assumed to have &lt;code&gt;n&lt;/code&gt; block columns.</source>
          <target state="translated">如果第一个参数是单个整数 &lt;code&gt;n&lt;/code&gt; ，则假定所有块行都具有 &lt;code&gt;n&lt;/code&gt; 个块列。</target>
        </trans-unit>
        <trans-unit id="87ae95240cbc769b0a9964dbc95f1267c9ef783f" translate="yes" xml:space="preserve">
          <source>If the index vector &lt;code&gt;ix&lt;/code&gt; is initialized with the indices of &lt;code&gt;v&lt;/code&gt; (or a permutation thereof), &lt;code&gt;initialized&lt;/code&gt; should be set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c79a9397806971d24321842119edaddb016dad" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">如果输入包含&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值，则遵循&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;三值逻辑&lt;/a&gt;，如果所有非缺失值均为 &lt;code&gt;false&lt;/code&gt; （或者等效地，如果输入不包含 &lt;code&gt;true&lt;/code&gt; 值），则返回 &lt;code&gt;missing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5db00182f423a4757b1d59390942e088eaf24587" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;../base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">如果输入包含&lt;a href=&quot;../base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值，则遵循&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;三值逻辑&lt;/a&gt;，如果所有非缺失值均为 &lt;code&gt;true&lt;/code&gt; （或者等效地，如果输入不包含 &lt;code&gt;false&lt;/code&gt; 值），则返回 &lt;code&gt;missing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8eeb9c03396e664e28a99fc47d48774045eb6d62" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;false&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;true&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">如果输入包含&lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值，则遵循&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;三值逻辑&lt;/a&gt;，如果所有非缺失值均为 &lt;code&gt;false&lt;/code&gt; （或者等效地，如果输入不包含 &lt;code&gt;true&lt;/code&gt; 值），则返回 &lt;code&gt;missing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2728419995e95b64eb82cdbd209797e56617a7a2" translate="yes" xml:space="preserve">
          <source>If the input contains &lt;a href=&quot;base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; values, return &lt;code&gt;missing&lt;/code&gt; if all non-missing values are &lt;code&gt;true&lt;/code&gt; (or equivalently, if the input contains no &lt;code&gt;false&lt;/code&gt; value), following &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;three-valued logic&lt;/a&gt;.</source>
          <target state="translated">如果输入包含&lt;a href=&quot;base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;值，则遵循&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;三值逻辑&lt;/a&gt;，如果所有非缺失值均为 &lt;code&gt;true&lt;/code&gt; （或者等效地，如果输入不包含 &lt;code&gt;false&lt;/code&gt; 值），则返回 &lt;code&gt;missing&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="43376b031124803be76025ed520e15accd07f21d" translate="yes" xml:space="preserve">
          <source>If the julia program needs to access symbols from the main executable, it may be necessary to add &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; linker flag at compile time on Linux in addition to the ones generated by &lt;code&gt;julia-config.jl&lt;/code&gt; described below. This is not necessary when compiling a shared library.</source>
          <target state="translated">如果julia程序需要访问主可执行文件中的符号，则除了在下面描述的 &lt;code&gt;julia-config.jl&lt;/code&gt; 生成的那些符号外，还可能需要在Linux上的编译时添加 &lt;code&gt;-Wl,--export-dynamic&lt;/code&gt; 链接器标志。编译共享库时，这不是必需的。</target>
        </trans-unit>
        <trans-unit id="a36bc8b8e7c85e66ed4f1f189a3aca52b1c00920" translate="yes" xml:space="preserve">
          <source>If the keyword argument &lt;code&gt;parallel&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;peakflops&lt;/code&gt; is run in parallel on all the worker processors. The flop rate of the entire parallel computer is returned. When running in parallel, only 1 BLAS thread is used. The argument &lt;code&gt;n&lt;/code&gt; still refers to the size of the problem that is solved on each processor.</source>
          <target state="translated">如果关键字参数 &lt;code&gt;parallel&lt;/code&gt; 设置为 &lt;code&gt;true&lt;/code&gt; ， &lt;code&gt;peakflops&lt;/code&gt; 将在所有辅助处理器上并行运行。返回整个并行计算机的失败率。并行运行时，仅使用1个BLAS线程。参数 &lt;code&gt;n&lt;/code&gt; 仍指每个处理器上要解决的问题的大小。</target>
        </trans-unit>
        <trans-unit id="8e60aaeb2ffed3f0c824ded63844d08244a81e67" translate="yes" xml:space="preserve">
          <source>If the last component of a path contains a dot, split the path into everything before the dot and everything including and after the dot. Otherwise, return a tuple of the argument unmodified and the empty string.</source>
          <target state="translated">如果路径的最后一个组件包含一个点,则将路径分割成点之前的所有内容和包括点之后的所有内容。否则,返回参数未修改的元组和空字符串。</target>
        </trans-unit>
        <trans-unit id="474f41b19a8b8b1c73bfdf0eee429dd261cef652" translate="yes" xml:space="preserve">
          <source>If the library cannot be found, this method throws an error, unless the keyword argument &lt;code&gt;throw_error&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, in which case this method returns &lt;code&gt;nothing&lt;/code&gt;.</source>
          <target state="translated">如果找不到该库，则该方法将引发错误，除非将关键字参数 &lt;code&gt;throw_error&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; ，在这种情况下，此方法将 &lt;code&gt;nothing&lt;/code&gt; 返回任何内容。</target>
        </trans-unit>
        <trans-unit id="87fd4485b83cceeff36ce0886165792add3d72c0" translate="yes" xml:space="preserve">
          <source>If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal situation and terminates. This timeout can be controlled via environment variable &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt;. The value of &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; on the master process specifies the number of seconds a newly launched worker waits for connection establishment.</source>
          <target state="translated">如果主进程在60.0秒内未能与新启动的工作程序建立连接，则工作程序将其视为致命情况并终止。可以通过环境变量 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; 来控制此超时。主进程上的 &lt;code&gt;JULIA_WORKER_TIMEOUT&lt;/code&gt; 的值指定新启动的工作程序等待连接建立的秒数。</target>
        </trans-unit>
        <trans-unit id="1862e9ef97d71a1468775f4ed8202c8fd632c055" translate="yes" xml:space="preserve">
          <source>If the memory is already owned by Julia, or is an &lt;code&gt;isbits&lt;/code&gt; type, and is known to be non-null:</source>
          <target state="translated">如果内存已经由Julia拥有，或者是 &lt;code&gt;isbits&lt;/code&gt; 类型，并且已知为非null：</target>
        </trans-unit>
        <trans-unit id="da0b487002a4f8f988224bf9329d865f41bc0778" translate="yes" xml:space="preserve">
          <source>If the memory is owned by C:</source>
          <target state="translated">如果内存为C所有。</target>
        </trans-unit>
        <trans-unit id="f1a7911f936ea8810a1eaa7a8869f8e6799d2d65" translate="yes" xml:space="preserve">
          <source>If the numerator and denominator of a rational have common factors, they are reduced to lowest terms such that the denominator is non-negative:</source>
          <target state="translated">如果一个有理数的分子和分母有共同的因数,则将它们化为最低项,使分母是非负数。</target>
        </trans-unit>
        <trans-unit id="0a769d477ab736aacb751c850c5686d3d0e58a61" translate="yes" xml:space="preserve">
          <source>If the optional vector of eigenvalues &lt;code&gt;eigvals&lt;/code&gt; is specified, &lt;code&gt;eigvecs&lt;/code&gt; returns the specific corresponding eigenvectors.</source>
          <target state="translated">如果指定了特征值 &lt;code&gt;eigvals&lt;/code&gt; 的可选向量，则 &lt;code&gt;eigvecs&lt;/code&gt; 返回特定的对应特征向量。</target>
        </trans-unit>
        <trans-unit id="0f4dba4502da69dc32bb858b6da003d9801f45e4" translate="yes" xml:space="preserve">
          <source>If the pointer of interest is a plain-data array (primitive type or immutable struct), the function &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; may be more useful. The final parameter should be true if Julia should &quot;take ownership&quot; of the underlying buffer and call &lt;code&gt;free(ptr)&lt;/code&gt; when the returned &lt;code&gt;Array&lt;/code&gt; object is finalized. If the &lt;code&gt;own&lt;/code&gt; parameter is omitted or false, the caller must ensure the buffer remains in existence until all access is complete.</source>
          <target state="translated">如果感兴趣的指针是纯数据数组（原始类型或不可变结构），则函数 &lt;code&gt;unsafe_wrap(Array, ptr,dims, own = false)&lt;/code&gt; 可能更有用。如果Julia应该&amp;ldquo;获得&amp;rdquo;底层缓冲区的所有权并在返回的 &lt;code&gt;Array&lt;/code&gt; 对象完成时调用 &lt;code&gt;free(ptr)&lt;/code&gt; ，则final参数应该为true 。如果 &lt;code&gt;own&lt;/code&gt; 参数被省略或为false，则调用者必须确保在所有访问完成之前缓冲区仍然存在。</target>
        </trans-unit>
        <trans-unit id="0a512e781dfe335955a62e8e7a271098861da5ec" translate="yes" xml:space="preserve">
          <source>If the project file in the directory matches &lt;code&gt;uuid&lt;/code&gt; and name &lt;code&gt;X&lt;/code&gt;, then either:</source>
          <target state="translated">如果目录中的项目文件与 &lt;code&gt;uuid&lt;/code&gt; 和名称 &lt;code&gt;X&lt;/code&gt; 匹配，则可以：</target>
        </trans-unit>
        <trans-unit id="bf4eb78a003bcabdcd8e4f19b55a5c4f0ed307f6" translate="yes" xml:space="preserve">
          <source>If the regular expression does not match the given string, &lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; &amp;ndash; a special value that does not print anything at the interactive prompt. Other than not printing, it is a completely normal value and you can test for it programmatically:</source>
          <target state="translated">如果正则表达式与给定的字符串不匹配，则&lt;a href=&quot;../../base/strings/index#Base.match&quot;&gt; &lt;code&gt;match&lt;/code&gt; 不&lt;/a&gt;返回&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt; -特殊值，在交互式提示符下不显示任何内容。除了不打印以外，它是一个完全正常的值，您可以通过编程方式对其进行测试：</target>
        </trans-unit>
        <trans-unit id="ee4c72df00bad1d261a873768e4600ba229c34af" translate="yes" xml:space="preserve">
          <source>If the type were declared &lt;code&gt;mutable&lt;/code&gt;, you could reach in and directly change the field values to violate this invariant. Of course, messing around with an object's internals uninvited is bad practice. You (or someone else) can also provide additional outer constructor methods at any later point, but once a type is declared, there is no way to add more inner constructor methods. Since outer constructor methods can only create objects by calling other constructor methods, ultimately, some inner constructor must be called to create an object. This guarantees that all objects of the declared type must come into existence by a call to one of the inner constructor methods provided with the type, thereby giving some degree of enforcement of a type's invariants.</source>
          <target state="translated">如果将类型声明为 &lt;code&gt;mutable&lt;/code&gt; ，则可以进入并直接更改字段值以违反此不变式。当然，不请自来地弄乱对象的内部是不好的做法。您（或其他人）也可以在以后的任何时候提供其他外部构造函数方法，但是一旦声明了类型，就无法添加更多内部构造函数方法。由于外部构造函数方法只能通过调用其他构造函数方法来创建对象，因此最终必须调用某些内部构造函数来创建对象。这保证了必须通过调用随该类型提供的内部构造方法之一来实现已声明类型的所有对象，从而在某种程度上强制执行类型的不变量。</target>
        </trans-unit>
        <trans-unit id="01f0d92fa173f69330393a510ea1e6b5d8ca8533" translate="yes" xml:space="preserve">
          <source>If the value of the environment variable begins with the character &lt;code&gt;'r'&lt;/code&gt;, then the interval between garbage collection events is randomized.</source>
          <target state="translated">如果环境变量的值以字符 &lt;code&gt;'r'&lt;/code&gt; 开头，则垃圾回收事件之间的间隔是随机的。</target>
        </trans-unit>
        <trans-unit id="820aaeab0441978d6dfdcb42b5456e2d42286bc7" translate="yes" xml:space="preserve">
          <source>If the variable is immutable, then it needs to be wrapped in an equivalent mutable container or, preferably, in a &lt;code&gt;RefValue{Any}&lt;/code&gt; before it is pushed to &lt;code&gt;IdDict&lt;/code&gt;. In this approach, the container has to be created or filled in via C code using, for example, the function &lt;code&gt;jl_new_struct&lt;/code&gt;. If the container is created by &lt;code&gt;jl_call*&lt;/code&gt;, then you will need to reload the pointer to be used in C code.</source>
          <target state="translated">如果变量是不可变的，则在将其推送到 &lt;code&gt;IdDict&lt;/code&gt; 之前，需要将其包装在等效的可变容器中，或者最好包装在 &lt;code&gt;RefValue{Any}&lt;/code&gt; 。在这种方法中，必须使用例如函数 &lt;code&gt;jl_new_struct&lt;/code&gt; 通过C代码创建或填充容器。如果容器是由 &lt;code&gt;jl_call*&lt;/code&gt; 创建的，那么您将需要重新加载要在C代码中使用的指针。</target>
        </trans-unit>
        <trans-unit id="fdaae9a23c5ac63bef99dbd5a31ebb51593f593b" translate="yes" xml:space="preserve">
          <source>If these default definitions are not wanted, modules can be defined using the keyword &lt;a href=&quot;../../base/base/index#baremodule&quot;&gt;&lt;code&gt;baremodule&lt;/code&gt;&lt;/a&gt; instead (note: &lt;code&gt;Core&lt;/code&gt; is still imported, as per above). In terms of &lt;code&gt;baremodule&lt;/code&gt;, a standard &lt;code&gt;module&lt;/code&gt; looks like this:</source>
          <target state="translated">如果不需要这些默认定义，则可以使用关键字&lt;a href=&quot;../../base/base/index#baremodule&quot;&gt; &lt;code&gt;baremodule&lt;/code&gt; &lt;/a&gt;模块来定义模块（注意：按照上面的说明， &lt;code&gt;Core&lt;/code&gt; 仍然被导入）。就 &lt;code&gt;baremodule&lt;/code&gt; &lt;code&gt;module&lt;/code&gt; 而言，标准模块如下所示：</target>
        </trans-unit>
        <trans-unit id="c97bc8058490cb5b35c86c1a7b0a8b4a5dcbea0d" translate="yes" xml:space="preserve">
          <source>If this example were rewritten to use a &lt;code&gt;for&lt;/code&gt; keyword for each variable, then the output would be different: the second and fourth values would contain &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">如果将本示例重写 &lt;code&gt;for&lt;/code&gt; 对每个变量使用for关键字，则输出将不同：第二个和第四个值将包含 &lt;code&gt;0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="38daf5829da47e0525cef7ca98a723264df0b06d" translate="yes" xml:space="preserve">
          <source>If this file refers to a device, the ID of the device it refers to</source>
          <target state="translated">如果这个文件涉及到一个设备,那么它所涉及到的设备的ID。</target>
        </trans-unit>
        <trans-unit id="0d9cafaaf4c7067eb590c8bf606a63edc65e8a80" translate="yes" xml:space="preserve">
          <source>If this is a recursive lock which has been acquired before, decrement an internal counter and return immediately.</source>
          <target state="translated">如果这是一个之前已经获得的递归锁,则递减一个内部计数器并立即返回。</target>
        </trans-unit>
        <trans-unit id="63b7f441c98451c302d3c2456a6e97efda6509d1" translate="yes" xml:space="preserve">
          <source>If this is all extremely confusing, try reading &lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&quot;The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets&quot;&lt;/a&gt;. It's an excellent introduction to Unicode and UTF-8, and may help alleviate some confusion regarding the matter.</source>
          <target state="translated">如果这一切都非常令人困惑，请尝试阅读&lt;a href=&quot;https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/&quot;&gt;&amp;ldquo;绝对绝对肯定地每个软件开发人员都必须了解Unicode和字符集&amp;rdquo;&lt;/a&gt;。这是对Unicode和UTF-8的出色介绍，并可能有助于减轻对此问题的某些困惑。</target>
        </trans-unit>
        <trans-unit id="3b40c130d40171e44a3b89ef397dcc6ac5ad60b6" translate="yes" xml:space="preserve">
          <source>If unspecified, &lt;code&gt;rmprocs&lt;/code&gt; will wait until all requested &lt;code&gt;pids&lt;/code&gt; are removed.</source>
          <target state="translated">如果未指定，则 &lt;code&gt;rmprocs&lt;/code&gt; 将等待直到所有请求的 &lt;code&gt;pids&lt;/code&gt; 被删除。</target>
        </trans-unit>
        <trans-unit id="7a6ee4e75683acdd450d6763b02459999f504699" translate="yes" xml:space="preserve">
          <source>If we also wanted to test the debug messages, these need to be enabled with the &lt;code&gt;min_level&lt;/code&gt; keyword:</source>
          <target state="translated">如果我们还想测试调试消息，则需要使用 &lt;code&gt;min_level&lt;/code&gt; 关键字启用它们：</target>
        </trans-unit>
        <trans-unit id="61986d68f0f6799ea1176f1c31636a4efe0c3579" translate="yes" xml:space="preserve">
          <source>If we create &lt;code&gt;SharedArray&lt;/code&gt;s and time these functions, we get the following results (with &lt;code&gt;julia -p 4&lt;/code&gt;):</source>
          <target state="translated">如果创建 &lt;code&gt;SharedArray&lt;/code&gt; 并对这些函数计时，则将获得以下结果（使用 &lt;code&gt;julia -p 4&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="a1227c57ad13fa72c3a7892e71df86ffd4baf6f1" translate="yes" xml:space="preserve">
          <source>If we expect that evaluating an expression &lt;em&gt;should&lt;/em&gt; throw an exception, then we can use &lt;code&gt;@test_throws&lt;/code&gt; to check that this occurs:</source>
          <target state="translated">如果我们希望对表达式求值&lt;em&gt;应&lt;/em&gt;引发异常，则可以使用 &lt;code&gt;@test_throws&lt;/code&gt; 来检查是否发生了这种情况：</target>
        </trans-unit>
        <trans-unit id="0245cafc71ed8d5f923ae289b03588ae96f1d3b5" translate="yes" xml:space="preserve">
          <source>If we instead pass &lt;code&gt;x&lt;/code&gt; as an argument to the function it no longer allocates memory (the allocation reported below is due to running the &lt;code&gt;@time&lt;/code&gt; macro in global scope) and is significantly faster after the first call:</source>
          <target state="translated">如果我们改为将 &lt;code&gt;x&lt;/code&gt; 作为参数传递给函数，则它不再分配内存（下面报告的分配是由于在全局范围内运行 &lt;code&gt;@time&lt;/code&gt; 宏），并且在第一次调用后明显更快：</target>
        </trans-unit>
        <trans-unit id="f2aae1a0bcfd34dce76c0f68b8969fc76cde279d" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad5a88256f096da52ec6c3ef7cb82d3f97728f34" translate="yes" xml:space="preserve">
          <source>If we want it to display instead as &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt;, we would define the following method to print the object to a given output object &lt;code&gt;io&lt;/code&gt; (representing a file, terminal, buffer, etcetera; see &lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;Networking and Streams&lt;/a&gt;):</source>
          <target state="translated">如果我们希望将其显示为 &lt;code&gt;3.0 * exp(4.0im)&lt;/code&gt; ，我们将定义以下方法将对象打印到给定的输出对象 &lt;code&gt;io&lt;/code&gt; （代表文件，终端，缓冲区等；请参见&lt;a href=&quot;../networking-and-streams/index#Networking-and-Streams-1&quot;&gt;网络和流&lt;/a&gt;）：</target>
        </trans-unit>
        <trans-unit id="a3d5a08a0cd3e04540689d3b049bf572b10229ab" translate="yes" xml:space="preserve">
          <source>If you apply &lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt;&lt;code&gt;supertype&lt;/code&gt;&lt;/a&gt; to other type objects (or non-type objects), a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; is raised:</source>
          <target state="translated">如果&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../../base/base/index#Base.supertype&quot;&gt; &lt;code&gt;supertype&lt;/code&gt; &lt;/a&gt;应用于其他类型对象（或非类型对象），则会引发MethodError：</target>
        </trans-unit>
        <trans-unit id="a311e1352bca4f5ac56973ae4e9111089c7fd93d" translate="yes" xml:space="preserve">
          <source>If you are defining a method &quot;cascade&quot; that supplies defaults, be careful about dropping any arguments that correspond to potential defaults. For example, suppose you're writing a digital filtering algorithm and you have a method that handles the edges of the signal by applying padding:</source>
          <target state="translated">如果你正在定义一个提供默认值的方法 &quot;级联&quot;,那么要小心放弃任何对应于潜在默认值的参数。例如,假设你正在编写一个数字滤波算法,并且你有一个通过应用padding处理信号边缘的方法。</target>
        </trans-unit>
        <trans-unit id="1ec45be5f3cad18e0598bb550f7ab8781aa51939" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="translated">如果要定义一个数组类型，允许非传统的索引（该指数在开始1以外的东西），你应该专门 &lt;code&gt;axes&lt;/code&gt; 。您还应该专门化&lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt; &lt;code&gt;similar&lt;/code&gt; &lt;/a&gt;以便 &lt;code&gt;dims&lt;/code&gt; 参数（通常是 &lt;code&gt;Dims&lt;/code&gt; 大小元组）可以接受 &lt;code&gt;AbstractUnitRange&lt;/code&gt; 对象，也许是您自己设计的范围类型 &lt;code&gt;Ind&lt;/code&gt; 。有关更多信息，请参见&lt;a href=&quot;https://docs.julialang.org/en/v1.2.0/devdocs/offset-arrays/#man-custom-indices-1&quot;&gt;带有自定义索引的数组&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="24ace472fa970e0efc7d5e99433a90005d823df2" translate="yes" xml:space="preserve">
          <source>If you are defining an array type that allows non-traditional indexing (indices that start at something other than 1), you should specialize &lt;code&gt;axes&lt;/code&gt;. You should also specialize &lt;a href=&quot;../../base/arrays/index#Base.similar&quot;&gt;&lt;code&gt;similar&lt;/code&gt;&lt;/a&gt; so that the &lt;code&gt;dims&lt;/code&gt; argument (ordinarily a &lt;code&gt;Dims&lt;/code&gt; size-tuple) can accept &lt;code&gt;AbstractUnitRange&lt;/code&gt; objects, perhaps range-types &lt;code&gt;Ind&lt;/code&gt; of your own design. For more information, see &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;Arrays with custom indices&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e74f29b3463d83a18c14379e83918c00f3cf63aa" translate="yes" xml:space="preserve">
          <source>If you are ever stuck, you can ask &lt;code&gt;Pkg&lt;/code&gt; for help:</source>
          <target state="translated">如果您遇到困难，可以向 &lt;code&gt;Pkg&lt;/code&gt; 寻求帮助：</target>
        </trans-unit>
        <trans-unit id="8735c4e810f6e4e3ffda27e1b3f1ab39f60104c6" translate="yes" xml:space="preserve">
          <source>If you are using the Julia C API from a language that supports exceptions (e.g. Python, C#, C++), it makes sense to wrap each call into &lt;code&gt;libjulia&lt;/code&gt; with a function that checks whether an exception was thrown, and then rethrows the exception in the host language.</source>
          <target state="translated">如果您使用支持异常的语言（例如Python，C＃，C ++）使用Julia C API，则将每个调用包装到 &lt;code&gt;libjulia&lt;/code&gt; 中是有意义的，该函数具有检查是否引发异常的函数，然后将异常重新引发主机语言。</target>
        </trans-unit>
        <trans-unit id="9d33189460471265e09a2493a0c7846b4727b27d" translate="yes" xml:space="preserve">
          <source>If you call it in an interactive session without assigning the return value anywhere, you will see the tuple returned:</source>
          <target state="translated">如果你在交互式会话中调用它而不在任何地方分配返回值,你将看到返回的元组。</target>
        </trans-unit>
        <trans-unit id="757e93c7d7c03576f2e8bdb2961d5a609265324d" translate="yes" xml:space="preserve">
          <source>If you define both styles of indexing for your &lt;code&gt;AbstractArray&lt;/code&gt;, this trait can be used to select the most performant indexing style. Some methods check this trait on their inputs, and dispatch to different algorithms depending on the most efficient access pattern. In particular, &lt;a href=&quot;#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; creates an iterator whose type depends on the setting of this trait.</source>
          <target state="translated">如果您为 &lt;code&gt;AbstractArray&lt;/code&gt; 定义了两种索引编制样式，则可以使用此特征来选择性能最高的索引编制样式。一些方法在其输入上检查此特征，并根据最有效的访问模式将其分配给不同的算法。特别是，&lt;a href=&quot;#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;都会创建一个迭代器，其类型取决于此特征的设置。</target>
        </trans-unit>
        <trans-unit id="9ff95da549c7d7e30f1529ab4e07584cdcd87231" translate="yes" xml:space="preserve">
          <source>If you define custom exception types, your &lt;code&gt;showerror&lt;/code&gt; method can support hints by calling &lt;a href=&quot;#Base.Experimental.show_error_hints&quot;&gt;&lt;code&gt;Experimental.show_error_hints&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0561f634340ef3ef5927debe41e5dcc4c8cce30a" translate="yes" xml:space="preserve">
          <source>If you examine the contents of &lt;code&gt;hello.txt&lt;/code&gt; at this point, you will notice that it is empty; nothing has actually been written to disk yet. This is because the &lt;code&gt;IOStream&lt;/code&gt; must be closed before the write is actually flushed to disk:</source>
          <target state="translated">如果此时检查 &lt;code&gt;hello.txt&lt;/code&gt; 的内容，您会发现它是空的。实际上还没有任何内容写入磁盘。这是因为在实际将写入刷新到磁盘之前，必须关闭 &lt;code&gt;IOStream&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="61d643164ec2351bd9d6fcf481fa957527066f53" translate="yes" xml:space="preserve">
          <source>If you have a matrix &lt;code&gt;A&lt;/code&gt; that is slightly non-Hermitian due to roundoff errors in its construction, wrap it in &lt;code&gt;Hermitian(A)&lt;/code&gt; before passing it to &lt;code&gt;cholesky&lt;/code&gt; in order to treat it as perfectly Hermitian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eaa143836add2b691eb62610bcaeb5c4d609829" translate="yes" xml:space="preserve">
          <source>If you have a type that uses a native pointer:</source>
          <target state="translated">如果你有一个使用本地指针的类型。</target>
        </trans-unit>
        <trans-unit id="aaf9e1541b4bdb0c52c8f375b573b49db90dd938" translate="yes" xml:space="preserve">
          <source>If you have code that you want executed whenever Julia is run, you can put it in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">如果您有要在每次运行Julia时执行的代码，可以将其放在 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c6993e56b8a3ed1437873eaf20d58be9dd8dc4fb" translate="yes" xml:space="preserve">
          <source>If you have data in CSC format from a different application or library, and wish to import it in Julia, make sure that you use 1-based indexing. The row indices in every column need to be sorted. If your &lt;code&gt;SparseMatrixCSC&lt;/code&gt; object contains unsorted row indices, one quick way to sort them is by doing a double transpose.</source>
          <target state="translated">如果您具有来自其他应用程序或库的CSC格式的数据，并希望将其导入Julia中，请确保使用基于1的索引。每列中的行索引需要排序。如果您的 &lt;code&gt;SparseMatrixCSC&lt;/code&gt; 对象包含未排序的行索引，则对它们进行排序的一种快速方法是执行两次转置。</target>
        </trans-unit>
        <trans-unit id="be1012643129d3902e3bcc736a2f09368b135cc7" translate="yes" xml:space="preserve">
          <source>If you interpolate an array as part of a shell word, Julia emulates the shell's &lt;code&gt;{a,b,c}&lt;/code&gt; argument generation:</source>
          <target state="translated">如果将数组内插作为shell单词的一部分，Julia会模拟shell的 &lt;code&gt;{a,b,c}&lt;/code&gt; 参数生成：</target>
        </trans-unit>
        <trans-unit id="66c0ea7806057d283c6cb2263bc03f2b5f51cca2" translate="yes" xml:space="preserve">
          <source>If you know that a module is &lt;em&gt;not&lt;/em&gt; safe to precompile your module (for example, for one of the reasons described below), you should put &lt;code&gt;__precompile__(false)&lt;/code&gt; in the module file (typically placed at the top). This will cause &lt;code&gt;Base.compilecache&lt;/code&gt; to throw an error, and will cause &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; to load it directly into the current process and skip the precompile and caching. This also thereby prevents the module from being imported by any other precompiled module.</source>
          <target state="translated">如果你知道一个模块是&lt;em&gt;不是&lt;/em&gt;安全的，预编译模块（例如，下面的原因之一描述的），你应该把 &lt;code&gt;__precompile__(false)&lt;/code&gt; 模块文件（通常放置在顶部）。这将导致 &lt;code&gt;Base.compilecache&lt;/code&gt; 引发错误，并导致 &lt;code&gt;using&lt;/code&gt; / &lt;code&gt;import&lt;/code&gt; 将其直接加载到当前进程中，并跳过预编译和缓存。因此，这也防止了该模块被任何其他预编译的模块导入。</target>
        </trans-unit>
        <trans-unit id="8e09fd6adcf3b546269be2b7ff41cc7243507fad" translate="yes" xml:space="preserve">
          <source>If you need a reference to the created task, pass a &lt;code&gt;Ref{Task}&lt;/code&gt; object via the keyword argument &lt;code&gt;taskref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9119dc7e0716f5e2cbcc069fcd20399d5871b899" translate="yes" xml:space="preserve">
          <source>If you need to dispatch on multiple arguments, and there are many fallbacks with too many combinations to make it practical to define all possible variants, then consider introducing a &quot;name cascade&quot; where (for example) you dispatch on the first argument and then call an internal method:</source>
          <target state="translated">如果你需要对多个参数进行派发,而且有很多回退,组合太多,无法实际定义所有可能的变体,那么可以考虑引入一个 &quot;名称级联&quot;,(例如)你对第一个参数进行派发,然后调用一个内部方法。</target>
        </trans-unit>
        <trans-unit id="5c6a0fa6b882b862c349ff5b92d17fa1f5f4c109" translate="yes" xml:space="preserve">
          <source>If you need to guarantee exact reproducibility of random data, it is advisable to simply &lt;em&gt;save the data&lt;/em&gt; (e.g. as a supplementary attachment in a scientific publication). (You can also, of course, specify a particular Julia version and package manifest, especially if you require bit reproducibility.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f3bebbfec4cfb424affa402369c33eff6a7949" translate="yes" xml:space="preserve">
          <source>If you need to obtain valid indices for a string, you can use the &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt;&lt;code&gt;prevind&lt;/code&gt;&lt;/a&gt; functions to increment/decrement to the next/previous valid index, as mentioned above. You can also use the &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; function to iterate over the valid character indices:</source>
          <target state="translated">如果需要获取字符串的有效索引，则可以使用&lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/strings/index#Base.prevind&quot;&gt; &lt;code&gt;prevind&lt;/code&gt; &lt;/a&gt;函数递增/递减到下一个/上一个有效索引，如上所述。您还可以使用&lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;函数来迭代有效的字符索引：</target>
        </trans-unit>
        <trans-unit id="ffe59bec712e7149856d034145a9690621f691b0" translate="yes" xml:space="preserve">
          <source>If you need to solve many systems of the form &lt;code&gt;(A+&amp;mu;I)x = b&lt;/code&gt; for the same &lt;code&gt;A&lt;/code&gt; and different &lt;code&gt;&amp;mu;&lt;/code&gt;, it might be beneficial to first compute the Hessenberg factorization &lt;code&gt;F&lt;/code&gt; of &lt;code&gt;A&lt;/code&gt; via the &lt;a href=&quot;#LinearAlgebra.hessenberg&quot;&gt;&lt;code&gt;hessenberg&lt;/code&gt;&lt;/a&gt; function. Given &lt;code&gt;F&lt;/code&gt;, Julia employs an efficient algorithm for &lt;code&gt;(F+&amp;mu;*I) \ b&lt;/code&gt; (equivalent to &lt;code&gt;(A+&amp;mu;*I)x \ b&lt;/code&gt;) and related operations like determinants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37c200e4c125ec6f24cad360d6dae92d524d5333" translate="yes" xml:space="preserve">
          <source>If you prefer to use the environment variable you can set it as follows in Bash (Linux/macOS):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e449fc3b5ae85ea55ddb2c14a81e3b450b101b1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;multiplex=true&lt;/code&gt; as an option to &lt;code&gt;addprocs&lt;/code&gt;, SSH multiplexing is used to create a tunnel between the master and workers. If you have configured SSH multiplexing on your own and the connection has already been established, SSH multiplexing is used regardless of &lt;code&gt;multiplex&lt;/code&gt; option. If multiplexing is enabled, forwarding is set by using the existing connection (&lt;code&gt;-O forward&lt;/code&gt; option in ssh). This is beneficial if your servers require password authentication; you can avoid authentication in Julia by logging in to the server ahead of &lt;code&gt;addprocs&lt;/code&gt;. The control socket will be located at &lt;code&gt;~/.ssh/julia-%r@%h:%p&lt;/code&gt; during the session unless the existing multiplexing connection is used. Note that bandwidth may be limited if you create multiple processes on a node and enable multiplexing, because in that case processes share a single multiplexing TCP connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801f3bd6c180fb1f8c8c459f54a17ac585429686" translate="yes" xml:space="preserve">
          <source>If you specify a &lt;code&gt;branch&lt;/code&gt;, this must be done in reference format, since the string will be turned into a &lt;code&gt;GitReference&lt;/code&gt;. For example, if you wanted to merge branch &lt;code&gt;branch_a&lt;/code&gt;, you would call &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt;.</source>
          <target state="translated">如果指定 &lt;code&gt;branch&lt;/code&gt; ，则必须以引用格式进行此操作，因为该字符串将变成 &lt;code&gt;GitReference&lt;/code&gt; 。例如，如果您想合并分支 &lt;code&gt;branch_a&lt;/code&gt; ，则将调用 &lt;code&gt;merge!(repo, branch=&quot;refs/heads/branch_a&quot;)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12b4daadf4d05ca4bd1781bb32cf57f260bb2750" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, &lt;code&gt;eachindex&lt;/code&gt; will return an iterable that spans the largest range along each dimension.</source>
          <target state="translated">如果提供多个 &lt;code&gt;AbstractArray&lt;/code&gt; 参数，则 &lt;code&gt;eachindex&lt;/code&gt; 将创建一个可迭代对象，该对象对于所有参数都是快速的（如果所有输入都具有快速线性索引，&lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt; &lt;code&gt;UnitRange&lt;/code&gt; &lt;/a&gt;，否则为&lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt;）。如果数组具有不同的大小和/或维数，则 &lt;code&gt;eachindex&lt;/code&gt; 将返回一个沿每个维跨越最大范围的可迭代对象。</target>
        </trans-unit>
        <trans-unit id="f56a6f95645242ddef63028fd0be36ad60f0ec75" translate="yes" xml:space="preserve">
          <source>If you supply more than one &lt;code&gt;AbstractArray&lt;/code&gt; argument, &lt;code&gt;eachindex&lt;/code&gt; will create an iterable object that is fast for all arguments (a &lt;a href=&quot;../collections/index#Base.UnitRange&quot;&gt;&lt;code&gt;UnitRange&lt;/code&gt;&lt;/a&gt; if all inputs have fast linear indexing, a &lt;a href=&quot;#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt; otherwise). If the arrays have different sizes and/or dimensionalities, a DimensionMismatch exception will be thrown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad751359c9250bca5bb370e9aaa6dde27fda5aad" translate="yes" xml:space="preserve">
          <source>If you try this in the REPL, you will see that &lt;code&gt;schedule&lt;/code&gt; returns immediately. That is because it simply adds &lt;code&gt;t&lt;/code&gt; to an internal queue of tasks to run. Then, the REPL will print the next prompt and wait for more input. Waiting for keyboard input provides an opportunity for other tasks to run, so at that point &lt;code&gt;t&lt;/code&gt; will start. &lt;code&gt;t&lt;/code&gt; calls &lt;a href=&quot;../../base/parallel/index#Base.sleep&quot;&gt;&lt;code&gt;sleep&lt;/code&gt;&lt;/a&gt;, which sets a timer and stops execution. If other tasks have been scheduled, they could run then. After five seconds, the timer fires and restarts &lt;code&gt;t&lt;/code&gt;, and you will see &lt;code&gt;done&lt;/code&gt; printed. &lt;code&gt;t&lt;/code&gt; is then finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf64552bec6648b4a2dbc60f5636537b6e39be4" translate="yes" xml:space="preserve">
          <source>If you want a quantity that is of the same type as &lt;code&gt;x&lt;/code&gt;, or of type &lt;code&gt;T&lt;/code&gt;, even if &lt;code&gt;x&lt;/code&gt; is dimensionful, use &lt;a href=&quot;#Base.oneunit&quot;&gt;&lt;code&gt;oneunit&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">如果您想要与 &lt;code&gt;x&lt;/code&gt; 具有相同类型或 &lt;code&gt;T&lt;/code&gt; 的类型的数量，即使 &lt;code&gt;x&lt;/code&gt; 是一维的，请改用&lt;a href=&quot;#Base.oneunit&quot;&gt; &lt;code&gt;oneunit&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0d6bdd166c95ac54bc84be65e3c70b26b5a5d3fc" translate="yes" xml:space="preserve">
          <source>If you want to &lt;em&gt;avoid&lt;/em&gt; adding dots for selected function calls in &lt;code&gt;expr&lt;/code&gt;, splice those function calls in with &lt;code&gt;$&lt;/code&gt;. For example, &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; is equivalent to &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; (no dot for &lt;code&gt;sort&lt;/code&gt;).</source>
          <target state="translated">如果要&lt;em&gt;避免&lt;/em&gt;在 &lt;code&gt;expr&lt;/code&gt; 中为选定的函数调用添加点，请使用 &lt;code&gt;$&lt;/code&gt; 拼接这些函数调用。例如， &lt;code&gt;@. sqrt(abs($sort(x)))&lt;/code&gt; 等同于 &lt;code&gt;sqrt.(abs.(sort(x)))&lt;/code&gt; （ &lt;code&gt;sort&lt;/code&gt; 不能用点表示）。</target>
        </trans-unit>
        <trans-unit id="683a65524138ed99d613028444b793379d0ca4fd" translate="yes" xml:space="preserve">
          <source>If you want to extract a character from a string, you index into it:</source>
          <target state="translated">如果你想从一个字符串中提取一个字符,你可以将其作为索引。</target>
        </trans-unit>
        <trans-unit id="af6bdcdecfb445706192e5de8fd952192d9e2d0e" translate="yes" xml:space="preserve">
          <source>If you want to read the output of the external command, &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; can be used instead:</source>
          <target state="translated">如果要读取外部命令的输出，则可以使用&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;代替：</target>
        </trans-unit>
        <trans-unit id="9ee9527d2c41ad82a10f035e6e19f07b44c36b95" translate="yes" xml:space="preserve">
          <source>If you want to test that some particular messages are generated while ignoring the rest, you can set the keyword &lt;code&gt;match_mode=:any&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66677df9764417ef6a9289f8e4f6bf8274c36caa" translate="yes" xml:space="preserve">
          <source>If you want to use logging as an audit trail you should disable this for your logger type.</source>
          <target state="translated">如果您想将日志记录用作审计跟踪,您应该为您的日志记录器类型禁用此功能。</target>
        </trans-unit>
        <trans-unit id="e7c7d63501e2b9d2d6b42831c4f6216f8a461efd" translate="yes" xml:space="preserve">
          <source>If you want to write to a file, you can open it with the write (&lt;code&gt;&quot;w&quot;&lt;/code&gt;) flag:</source>
          <target state="translated">如果要写入文件，可以使用write（ &lt;code&gt;&quot;w&quot;&lt;/code&gt; ）标志打开它：</target>
        </trans-unit>
        <trans-unit id="c3b03f51e5a4a15df40aa0cdfd2977b041193157" translate="yes" xml:space="preserve">
          <source>If you were to profile &lt;code&gt;dumbsum3&lt;/code&gt;, and a backtrace was taken while it was executing &lt;code&gt;dumbsum(1)&lt;/code&gt;, the backtrace would look like this:</source>
          <target state="translated">如果要分析 &lt;code&gt;dumbsum3&lt;/code&gt; ，并且在执行 &lt;code&gt;dumbsum(1)&lt;/code&gt; 时进行了回溯，则回溯应如下所示：</target>
        </trans-unit>
        <trans-unit id="0bc4f596ffa41c5fb93ede00ad1673e3a89c26be" translate="yes" xml:space="preserve">
          <source>If you wish to specialize on a particular style &lt;code&gt;DestStyle&lt;/code&gt;, define a method for</source>
          <target state="translated">如果您想专门研究特定样式 &lt;code&gt;DestStyle&lt;/code&gt; ，请定义一个方法</target>
        </trans-unit>
        <trans-unit id="9416eec2408335a70a9403f87954e9d92bc5beb6" translate="yes" xml:space="preserve">
          <source>If you would like to define your own block, for example a &lt;code&gt;terminology&lt;/code&gt; block used like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81fa178f278896f499b8c79cc33cce8975b52ac" translate="yes" xml:space="preserve">
          <source>If you write a custom &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt; type, you can specify that it has fast linear indexing using</source>
          <target state="translated">如果编写自定义&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;类型，则可以使用以下命令指定它具有快速线性索引的功能</target>
        </trans-unit>
        <trans-unit id="731e84cb8afd8370c60140146ac6c2a5c345b233" translate="yes" xml:space="preserve">
          <source>If you write generic code which handles numbers, and which can be expected to run with many different numeric type arguments, try using literals of a numeric type that will affect the arguments as little as possible through promotion.</source>
          <target state="translated">如果你写的是处理数字的通用代码,并且可以预期它将以许多不同的数字类型参数运行,请尝试使用数字类型的字元,通过推广将尽可能少地影响参数。</target>
        </trans-unit>
        <trans-unit id="dcea13c507e05364e2e2a422c4d4bb092770bc50" translate="yes" xml:space="preserve">
          <source>If your array type does have fixed dimensionality requirements, then you should subtype &lt;code&gt;AbstractArrayStyle&lt;/code&gt;. For example, the sparse array code has the following definitions:</source>
          <target state="translated">如果您的数组类型确实具有固定的维数要求，则应将其 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; 。例如，稀疏数组代码具有以下定义：</target>
        </trans-unit>
        <trans-unit id="86e175e64e8da6c7e916078c1c6ea2b5a935db82" translate="yes" xml:space="preserve">
          <source>If your code has recursion, one potentially-confusing point is that a line in a &quot;child&quot; function can accumulate more counts than there are total backtraces. Consider the following function definitions:</source>
          <target state="translated">如果你的代码有递归,有一个潜在的混淆点是,一个 &quot;子 &quot;函数中的一行可以积累比总回溯更多的计数。考虑以下的函数定义。</target>
        </trans-unit>
        <trans-unit id="aa3f9be2eca1806a6c02bd56dca6f747bcc2726c" translate="yes" xml:space="preserve">
          <source>If your function returns an &lt;code&gt;Array&lt;/code&gt; or some other complex type, it may have to allocate memory. Unfortunately, oftentimes allocation and its converse, garbage collection, are substantial bottlenecks.</source>
          <target state="translated">如果您的函数返回 &lt;code&gt;Array&lt;/code&gt; 或其他某种复杂类型，则可能必须分配内存。不幸的是，通常分配及其相反的垃圾收集是巨大的瓶颈。</target>
        </trans-unit>
        <trans-unit id="203770fc43c2ec3f449524fb36ddffdf662a89aa" translate="yes" xml:space="preserve">
          <source>If, on the other hand, Julia was loading the &lt;em&gt;other&lt;/em&gt;&lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt;&amp;mdash;it finds its stanza in the manifest, see that it does &lt;em&gt;not&lt;/em&gt; have a &lt;code&gt;path&lt;/code&gt; entry, but that it does have a &lt;code&gt;git-tree-sha1&lt;/code&gt; entry. It then computes the &lt;code&gt;slug&lt;/code&gt; for this UUID/SHA-1 pair, which is &lt;code&gt;HDkrT&lt;/code&gt; (the exact details of this computation aren't important, but it is consistent and deterministic). This means that the path to this &lt;code&gt;Priv&lt;/code&gt; package will be &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; in one of the package depots. Suppose the contents of &lt;code&gt;DEPOT_PATH&lt;/code&gt; is &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt;, then Julia will look at the following paths to see if they exist:</source>
          <target state="translated">如果，另一方面，茱莉亚加载&lt;em&gt;其他&lt;/em&gt; &lt;code&gt;Priv&lt;/code&gt; 包了一个与UUID &lt;code&gt;2d15fe94-a1f7-436c-a4d8-07a9a496e01c&lt;/code&gt; -它发现在清单的节，看，它并&lt;em&gt;不能&lt;/em&gt;有一个 &lt;code&gt;path&lt;/code&gt; 项，但它确实有一个 &lt;code&gt;git-tree-sha1&lt;/code&gt; 条目。然后，它计算 &lt;code&gt;slug&lt;/code&gt; 此UUID / SHA-1对，其是 &lt;code&gt;HDkrT&lt;/code&gt; （该计算的确切细节并不重要，但它是一致的，确定性的）。这意味着此 &lt;code&gt;Priv&lt;/code&gt; 软件包的路径将是其中一个软件包仓库中的package &lt;code&gt;packages/Priv/HDkrT/src/Priv.jl&lt;/code&gt; 假设 &lt;code&gt;DEPOT_PATH&lt;/code&gt; 的内容是 &lt;code&gt;[&quot;/home/me/.julia&quot;, &quot;/usr/local/julia&quot;]&lt;/code&gt; ，那么Julia将查看以下路径以查看它们是否存在：</target>
        </trans-unit>
        <trans-unit id="08884ba6d9fbd224895a7cbdeceeec1f4c59bf40" translate="yes" xml:space="preserve">
          <source>Image Of</source>
          <target state="translated">形象</target>
        </trans-unit>
        <trans-unit id="6ea4ebbef3751656124627e822bd05d7b6569f88" translate="yes" xml:space="preserve">
          <source>Image Of Or Approximately Equal To</source>
          <target state="translated">图像或近似等于</target>
        </trans-unit>
        <trans-unit id="09e871c98fef3b901a775def173e4126aaf73b42" translate="yes" xml:space="preserve">
          <source>Images</source>
          <target state="translated">Images</target>
        </trans-unit>
        <trans-unit id="a1dd283e60c10a07da0fde84cdded35b0d62bc7f" translate="yes" xml:space="preserve">
          <source>Immediately run finalizers registered for object &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">立即运行为对象 &lt;code&gt;x&lt;/code&gt; 注册的终结器。</target>
        </trans-unit>
        <trans-unit id="3f8a84e660062cc9351aa99e4736b44741ec8c96" translate="yes" xml:space="preserve">
          <source>Immutable composite types with no fields are singletons; there can be only one instance of such types:</source>
          <target state="translated">无字段的不可变复合类型是单子,这种类型只能有一个实例。</target>
        </trans-unit>
        <trans-unit id="546c2aff0baec3bbc325a5abd6340afd6a503d6d" translate="yes" xml:space="preserve">
          <source>ImmutableDict</source>
          <target state="translated">ImmutableDict</target>
        </trans-unit>
        <trans-unit id="4d5fca35f85700fe41f680f762e716a68cf32a0c" translate="yes" xml:space="preserve">
          <source>ImmutableDict is a Dictionary implemented as an immutable linked list, which is optimal for small dictionaries that are constructed over many individual insertions Note that it is not possible to remove a value, although it can be partially overridden and hidden by inserting a new value with the same key</source>
          <target state="translated">ImmutableDict是一个以不可改变的链接列表形式实现的Dictionary,这对于通过许多单独的插入来构建的小型字典来说是最合适的 注意,虽然可以通过插入一个具有相同键的新值来部分覆盖和隐藏一个值,但是不可能删除一个值。</target>
        </trans-unit>
        <trans-unit id="5a205de46742b724da4bcd47864315bbfb29bffa" translate="yes" xml:space="preserve">
          <source>Imp</source>
          <target state="translated">Imp</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="91db407238f7692c5a1c288977c0c95bb564522e" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers using custom transports. It should establish a logical connection to worker with id &lt;code&gt;pid&lt;/code&gt;, specified by &lt;code&gt;config&lt;/code&gt; and return a pair of &lt;code&gt;IO&lt;/code&gt; objects. Messages from &lt;code&gt;pid&lt;/code&gt; to current process will be read off &lt;code&gt;instrm&lt;/code&gt;, while messages to be sent to &lt;code&gt;pid&lt;/code&gt; will be written to &lt;code&gt;outstrm&lt;/code&gt;. The custom transport implementation must ensure that messages are delivered and received completely and in order. &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; sets up TCP/IP socket connections in-between workers.</source>
          <target state="translated">由集群管理器使用自定义传输来实现。它应与 &lt;code&gt;config&lt;/code&gt; 指定的id为 &lt;code&gt;pid&lt;/code&gt; 的 worker建立逻辑连接，并返回一对 &lt;code&gt;IO&lt;/code&gt; 对象。从 &lt;code&gt;pid&lt;/code&gt; 到当前进程的消息将从 &lt;code&gt;instrm&lt;/code&gt; 中读取，而要发送到 &lt;code&gt;pid&lt;/code&gt; 的消息将被写入 &lt;code&gt;outstrm&lt;/code&gt; 中。定制传输实现必须确保完整，有序地传递和接收消息。 &lt;code&gt;connect(manager::ClusterManager.....)&lt;/code&gt; 在工作程序之间建立TCP / IP套接字连接。</target>
        </trans-unit>
        <trans-unit id="08979f61f84f8ad3b659b0b75ccddbf1892ea3a4" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. For every Julia worker launched by this function, it should append a &lt;code&gt;WorkerConfig&lt;/code&gt; entry to &lt;code&gt;launched&lt;/code&gt; and notify &lt;code&gt;launch_ntfy&lt;/code&gt;. The function MUST exit once all workers, requested by &lt;code&gt;manager&lt;/code&gt; have been launched. &lt;code&gt;params&lt;/code&gt; is a dictionary of all keyword arguments &lt;a href=&quot;#Distributed.addprocs&quot;&gt;&lt;code&gt;addprocs&lt;/code&gt;&lt;/a&gt; was called with.</source>
          <target state="translated">由群集管理器实施。对于此函数启动的每个Julia工作者，它应在 &lt;code&gt;launched&lt;/code&gt; 附加一个 &lt;code&gt;WorkerConfig&lt;/code&gt; 条目，并通知 &lt;code&gt;launch_ntfy&lt;/code&gt; 。一旦 &lt;code&gt;manager&lt;/code&gt; 要求的所有工作人员都已启动，该功能必须退出。 &lt;code&gt;params&lt;/code&gt; 是调用了&lt;a href=&quot;#Distributed.addprocs&quot;&gt; &lt;code&gt;addprocs&lt;/code&gt; &lt;/a&gt;的所有关键字参数的字典。</target>
        </trans-unit>
        <trans-unit id="b5a68dbaa7e53b1fdc013e1b1b627c788dfd10b1" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, by &lt;a href=&quot;#Distributed.rmprocs&quot;&gt;&lt;code&gt;rmprocs&lt;/code&gt;&lt;/a&gt;. It should cause the remote worker specified by &lt;code&gt;pid&lt;/code&gt; to exit. &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; executes a remote &lt;code&gt;exit()&lt;/code&gt; on &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">由群集管理器实施。它在主进程上由&lt;a href=&quot;#Distributed.rmprocs&quot;&gt; &lt;code&gt;rmprocs&lt;/code&gt; 调用&lt;/a&gt;。它应导致由 &lt;code&gt;pid&lt;/code&gt; 指定的远程工作者退出。 &lt;code&gt;kill(manager::ClusterManager.....)&lt;/code&gt; &lt;code&gt;exit()&lt;/code&gt; 在 &lt;code&gt;pid&lt;/code&gt; 上执行远程exit（）。</target>
        </trans-unit>
        <trans-unit id="dba266234257c3d4b0aca4b478ddab2be6ca2905" translate="yes" xml:space="preserve">
          <source>Implemented by cluster managers. It is called on the master process, during a worker's lifetime, with appropriate &lt;code&gt;op&lt;/code&gt; values:</source>
          <target state="translated">由群集管理器实施。在工人的一生中，使用适当的 &lt;code&gt;op&lt;/code&gt; 值在主进程上调用它：</target>
        </trans-unit>
        <trans-unit id="2d46cc8d098f423748bfcc369918df042e230bb1" translate="yes" xml:space="preserve">
          <source>Implicit names from identifiers and dot expressions are available as of Julia 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6456a3318802fc28959139bf29a9bdf8b9e1954" translate="yes" xml:space="preserve">
          <source>Import Command</source>
          <target state="translated">导入命令</target>
        </trans-unit>
        <trans-unit id="a4489b5a6e6e45ce5f1172241f2ce59438e83997" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MyModule&lt;/code&gt; above we wanted to add a method to the standard &lt;code&gt;show&lt;/code&gt; function, so we had to write &lt;code&gt;import Base.show&lt;/code&gt;. Functions whose names are only visible via &lt;code&gt;using&lt;/code&gt; cannot be extended.</source>
          <target state="translated">在上面的 &lt;code&gt;MyModule&lt;/code&gt; 中，我们想向标准 &lt;code&gt;show&lt;/code&gt; 函数添加一个方法，因此我们必须编写 &lt;code&gt;import Base.show&lt;/code&gt; 。名称仅通过 &lt;code&gt;using&lt;/code&gt; 可见的功能无法扩展。</target>
        </trans-unit>
        <trans-unit id="035c9cab15fd9dc0120582c57dc7ae1a95ac181b" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;very rare&lt;/em&gt; cases it might make sense for the constructor &lt;code&gt;T(x)&lt;/code&gt; to return an object not of type &lt;code&gt;T&lt;/code&gt;. This could happen if a wrapper type is its own inverse (e.g. &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt;), or to support an old calling syntax for backwards compatibility when a library is restructured. But &lt;code&gt;convert(T, x)&lt;/code&gt; should always return a value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">在&lt;em&gt;极少数&lt;/em&gt;情况下，构造函数 &lt;code&gt;T(x)&lt;/code&gt; 返回非 &lt;code&gt;T&lt;/code&gt; 类型的对象可能是有意义的。如果包装器类型是其自身的逆类型（例如 &lt;code&gt;Flip(Flip(x)) === x&lt;/code&gt; ），或者在重构库时支持向后兼容的旧调用语法，则可能会发生这种情况。但是 &lt;code&gt;convert(T, x)&lt;/code&gt; 应该始终返回类型 &lt;code&gt;T&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="d6ddd3549cd522fa313ced4025d3d58df8994646" translate="yes" xml:space="preserve">
          <source>In C++ or Java, for example, in a method call like &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt;, the object obj &quot;receives&quot; the method call and is implicitly passed to the method via the &lt;code&gt;this&lt;/code&gt; keyword, rather than as an explicit method argument. When the current &lt;code&gt;this&lt;/code&gt; object is the receiver of a method call, it can be omitted altogether, writing just &lt;code&gt;meth(arg1,arg2)&lt;/code&gt;, with &lt;code&gt;this&lt;/code&gt; implied as the receiving object.</source>
          <target state="translated">例如，在C ++或Java中，在 &lt;code&gt;obj.meth(arg1,arg2)&lt;/code&gt; 之类的方法调用中，对象obj&amp;ldquo;接收&amp;rdquo;该方法调用，并通过 &lt;code&gt;this&lt;/code&gt; 关键字隐式传递给该方法，而不是作为显式方法参数传递给该方法。。当当前 &lt;code&gt;this&lt;/code&gt; 对象是方法调用的接收者时，可以完全省略，只写 &lt;code&gt;meth(arg1,arg2)&lt;/code&gt; ，将 &lt;code&gt;this&lt;/code&gt; 隐含为接收对象。</target>
        </trans-unit>
        <trans-unit id="0b44231782a66524e37b6a261f0e356297afae45" translate="yes" xml:space="preserve">
          <source>In C++, by default, you have static dispatch, i.e. you need to annotate a function as virtual, in order to have dynamic dispatch. On the other hand, in Julia every method is &quot;virtual&quot; (although it's more general than that since methods are dispatched on every argument type, not only &lt;code&gt;this&lt;/code&gt;, using the most-specific-declaration rule).</source>
          <target state="translated">在C ++中，默认情况下，您具有静态分配，即，您需要将一个函数注释为虚函数，以便进行动态分配。另一方面，在Julia中，每个方法都是&amp;ldquo;虚拟的&amp;rdquo;（尽管比一般方法更通用，因为方法是使用最具体的声明规则在每个参数类型上分配的，而不仅是 &lt;code&gt;this&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="848c2eb8261286f9fd639a07ac24e094cd08249a" translate="yes" xml:space="preserve">
          <source>In Julia &amp;le; 0.6, all global scopes did work like the current REPL: when &lt;code&gt;x = &amp;lt;value&amp;gt;&lt;/code&gt; occurred in a loop (or &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;, or &lt;code&gt;struct&lt;/code&gt; body) but outside of a function body (or &lt;code&gt;let&lt;/code&gt; block or comprehension), it was decided based on whether a global named &lt;code&gt;x&lt;/code&gt; was defined or not whether &lt;code&gt;x&lt;/code&gt; should be local to the loop. This behavior has the advantage of being intuitive and convenient since it approximates the behavior inside of a function body as closely as possible. In particular, it makes it easy to move code back and forth between a function body and the REPL when trying to debug the behavior of a function. However, it has some downsides. First, it's quite a complex behavior: many people over the years were confused about this behavior and complained that it was complicated and hard both to explain and understand. Fair point. Second, and arguably worse, is that it's bad for programming &quot;at scale.&quot; When you see a small piece of code in one place like this, it's quite clear what's going on:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a64f4137e1f00234d12e399e1c5435c90a8e6c63" translate="yes" xml:space="preserve">
          <source>In Julia (as in much of scientific computation), dense linear-algebra operations are based on the &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK library&lt;/a&gt;, which in turn is built on top of basic linear-algebra building-blocks known as the &lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt;. There are highly optimized implementations of BLAS available for every computer architecture, and sometimes in high-performance linear algebra routines it is useful to call the BLAS functions directly.</source>
          <target state="translated">在Julia中（就像许多科学计算一样），密集的线性代数运算基于&lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK库&lt;/a&gt;，而LAPACK库又建立在称为&lt;a href=&quot;http://www.netlib.org/blas/&quot;&gt;BLAS&lt;/a&gt;的基本线性代数构件之上。每种计算机体系结构都有高度优化的BLAS实现，有时在高性能线性代数例程中，直接调用BLAS函数很有用。</target>
        </trans-unit>
        <trans-unit id="247a76ccd2e14a487830d09d4cedad7b8f5df0c1" translate="yes" xml:space="preserve">
          <source>In Julia 1.0 this method only supported a square destination matrix. Julia 1.1. added support for a rectangular matrix.</source>
          <target state="translated">在Julia 1.0中,这个方法只支持正方形目标矩阵。Julia 1.1.增加了对矩形矩阵的支持。</target>
        </trans-unit>
        <trans-unit id="7eb90fb66dbd8787a2bcb4484cc97817d278a46b" translate="yes" xml:space="preserve">
          <source>In Julia 1.0, the default &lt;code&gt;--project=@.&lt;/code&gt; option did not search up from the root directory of a Git repository for the &lt;code&gt;Project.toml&lt;/code&gt; file. From Julia 1.1 forward, it does.</source>
          <target state="translated">在Julia 1.0中，默认 &lt;code&gt;--project=@.&lt;/code&gt; 选项没有从Git存储库的根目录中搜索 &lt;code&gt;Project.toml&lt;/code&gt; 文件。从Julia 1.1开始，确实如此。</target>
        </trans-unit>
        <trans-unit id="0050127afe87c7fac6e12932d051462ec8c65b3e" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randcycle&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">在Julia 1.1中， &lt;code&gt;randcycle&lt;/code&gt; 返回带有 &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; 的向量 &lt;code&gt;v&lt;/code&gt; ，而在Julia 1.0中， &lt;code&gt;eltype(v) == Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d8b5eb0c54cc4aad9911d4c5d77bfea05f710df6" translate="yes" xml:space="preserve">
          <source>In Julia 1.1 &lt;code&gt;randperm&lt;/code&gt; returns a vector &lt;code&gt;v&lt;/code&gt; with &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; while in Julia 1.0 &lt;code&gt;eltype(v) == Int&lt;/code&gt;.</source>
          <target state="translated">在Julia 1.1中， &lt;code&gt;randperm&lt;/code&gt; 返回带有 &lt;code&gt;eltype(v) == typeof(n)&lt;/code&gt; 的向量 &lt;code&gt;v&lt;/code&gt; ，而在Julia 1.0中， &lt;code&gt;eltype(v) == Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f25573f2ef6b2638e0373e20cdd6eceb2e703331" translate="yes" xml:space="preserve">
          <source>In Julia 1.5 and above the number of threads can also be specified on startup using the &lt;code&gt;-t&lt;/code&gt;/&lt;code&gt;--threads&lt;/code&gt; command line argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d630cc94b63c31ac28921da908c57f1454c54e15" translate="yes" xml:space="preserve">
          <source>In Julia &lt;code&gt;%&lt;/code&gt; is the remainder operator, whereas in Python it is the modulus.</source>
          <target state="translated">在Julia中， &lt;code&gt;%&lt;/code&gt; 是余数运算符，而在Python中，它是模数。</target>
        </trans-unit>
        <trans-unit id="cbc49b243ca968548d5e6046855ea243ea0a10fe" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external C routines, ordinary (non-pointer) data should be declared to be of type &lt;code&gt;T&lt;/code&gt; inside the &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt;, as they are passed by value. For C code accepting pointers, &lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt;&lt;code&gt;Ref{T}&lt;/code&gt;&lt;/a&gt; should generally be used for the types of input arguments, allowing the use of pointers to memory managed by either Julia or C through the implicit call to &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt;. In contrast, pointers returned by the C function called should be declared to be of output type &lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt;&lt;code&gt;Ptr{T}&lt;/code&gt;&lt;/a&gt;, reflecting that the memory pointed to is managed by C only. Pointers contained in C structs should be represented as fields of type &lt;code&gt;Ptr{T}&lt;/code&gt; within the corresponding Julia struct types designed to mimic the internal structure of corresponding C structs.</source>
          <target state="translated">在Julia代码包装对外部C例程的调用中，普通（非指针）数据应在&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; 中&lt;/a&gt;声明为 &lt;code&gt;T&lt;/code&gt; 类型，因为它们是通过值传递的。对于C代码接受指针，通常应将&lt;a href=&quot;../../base/c/index#Core.Ref&quot;&gt; &lt;code&gt;Ref{T}&lt;/code&gt; &lt;/a&gt;用作输入参数的类型，从而允许通过对&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;的隐式调用来使用由Julia或C管理的内存的指针。相反，由C函数返回的指针应声明为输出类型&lt;a href=&quot;../../base/c/index#Core.Ptr&quot;&gt; &lt;code&gt;Ptr{T}&lt;/code&gt; &lt;/a&gt;，这表明所指向的内存仅由C管理。 C结构中包含的指针应表示为 &lt;code&gt;Ptr{T}&lt;/code&gt; 类型的字段 在相应的Julia结构类型中进行设计，以模仿相应的C结构的内部结构。</target>
        </trans-unit>
        <trans-unit id="1fa4d6ec34fe20b0509960e834e463ea1a6b4cc7" translate="yes" xml:space="preserve">
          <source>In Julia code wrapping calls to external Fortran routines, all input arguments should be declared as of type &lt;code&gt;Ref{T}&lt;/code&gt;, as Fortran passes all variables by pointers to memory locations. The return type should either be &lt;code&gt;Cvoid&lt;/code&gt; for Fortran subroutines, or a &lt;code&gt;T&lt;/code&gt; for Fortran functions returning the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">在Julia对外部Fortran例程的代码包装调用中，所有输入参数都应声明为 &lt;code&gt;Ref{T}&lt;/code&gt; 类型，因为Fortran会通过指针将所有变量传递到内存位置。返回类型应或者是 &lt;code&gt;Cvoid&lt;/code&gt; Fortran的子程序，或 &lt;code&gt;T&lt;/code&gt; Fortran的函数返回类型 &lt;code&gt;T&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="34f3cdb66f13e42ca43c63a9c817a8c4007728b9" translate="yes" xml:space="preserve">
          <source>In Julia each module has its own global scope/namespace, whereas in MATLAB there is just one global scope.</source>
          <target state="translated">在Julia中,每个模块都有自己的全局范围/命名空间,而在MATLAB中,只有一个全局范围。</target>
        </trans-unit>
        <trans-unit id="a3d6aa810b7eb985858c7d4e38c552636ecace4b" translate="yes" xml:space="preserve">
          <source>In Julia loops are fast, there is no need to write &quot;vectorized&quot; code for performance reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9649a4e1eb5caa62495053957d722a3d4bba674" translate="yes" xml:space="preserve">
          <source>In Julia mode, the REPL supports something called &lt;em&gt;prompt pasting&lt;/em&gt;. This activates when pasting text that starts with &lt;code&gt;julia&amp;gt;&lt;/code&gt; into the REPL. In that case, only expressions starting with &lt;code&gt;julia&amp;gt;&lt;/code&gt; are parsed, others are removed. This makes it is possible to paste a chunk of code that has been copied from a REPL session without having to scrub away prompts and outputs. This feature is enabled by default but can be disabled or enabled at will with &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt;. If it is enabled, you can try it out by pasting the code block above this paragraph straight into the REPL. This feature does not work on the standard Windows command prompt due to its limitation at detecting when a paste occurs.</source>
          <target state="translated">在Julia模式下，REPL支持所谓的&lt;em&gt;提示粘贴&lt;/em&gt;。将以 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 开头的文本粘贴到REPL中时，此功能将激活。在这种情况下，仅分析以 &lt;code&gt;julia&amp;gt;&lt;/code&gt; 开头的表达式，而其他表达式则被删除。这样就可以粘贴从REPL会话复制的代码块，而不必清除提示和输出。默认情况下启用此功能，但可以使用 &lt;code&gt;REPL.enable_promptpaste(::Bool)&lt;/code&gt; 禁用或随意启用此功能。如果启用了此功能，则可以通过将本段上方的代码块直接粘贴到REPL中来进行尝试。由于此功能在检测粘贴发生时的限制，因此在标准Windows命令提示符下不起作用。</target>
        </trans-unit>
        <trans-unit id="7129a6b15edfb73c2cd4cd30d7a70ed28691edca" translate="yes" xml:space="preserve">
          <source>In Julia the &lt;code&gt;@&lt;/code&gt; symbol refers to a macro, whereas in Python it refers to a decorator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d6ea2617d808e81c678587852ffabe403f81cb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;&amp;lt;-&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt; are not assignment operators.</source>
          <target state="translated">在Julia中， &lt;code&gt;&amp;lt;-&lt;/code&gt; ， &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; 和 &lt;code&gt;-&amp;gt;&lt;/code&gt; 不是赋值运算符。</target>
        </trans-unit>
        <trans-unit id="601692d3aba8995fb01afb976c7c7f5a8aab46fc" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;...&lt;/code&gt; is not used to continue lines of code. Instead, incomplete expressions automatically continue onto the next line.</source>
          <target state="translated">在Julia中， &lt;code&gt;...&lt;/code&gt; 不用于继续代码行。相反，不完整的表达式会自动继续到下一行。</target>
        </trans-unit>
        <trans-unit id="5bdd69cd27046bb2e3189abcdf750e49518e8509" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;Ref&lt;/code&gt; objects are dereferenced (loaded or stored) with &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">在Julia中， &lt;code&gt;Ref&lt;/code&gt; 对象通过 &lt;code&gt;[]&lt;/code&gt; 取消引用（加载或存储）。</target>
        </trans-unit>
        <trans-unit id="bbe698f34efa48506b3a034b90fcbacaa3b44d79" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; produces &lt;code&gt;[1, 3]&lt;/code&gt;.</source>
          <target state="translated">在Julia中， &lt;code&gt;[1, 2, 3, 4][[true, false, true, false]]&lt;/code&gt; 产生 &lt;code&gt;[1, 3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="41c6478a96484907c7a62d3fc652aeb5cc697413" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; throws a &lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt;&lt;code&gt;BoundsError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Julia中， &lt;code&gt;[1, 2, 3, 4][[true, false]]&lt;/code&gt; 引发&lt;a href=&quot;../../base/base/index#Core.BoundsError&quot;&gt; &lt;code&gt;BoundsError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="0974da83f18cbcaffe16bb6459e3edda104c9151" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;[x,y,z]&lt;/code&gt; will always construct a 3-element array containing &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">在Julia中， &lt;code&gt;[x,y,z]&lt;/code&gt; 将始终构造一个包含 &lt;code&gt;x&lt;/code&gt; ， &lt;code&gt;y&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 的3元素数组。</target>
        </trans-unit>
        <trans-unit id="1d138a3241eb075445bbb09d48ceedbc03b1d34e" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;a:b&lt;/code&gt; and &lt;code&gt;a:b:c&lt;/code&gt; construct &lt;code&gt;AbstractRange&lt;/code&gt; objects. To construct a full vector like in MATLAB, use &lt;code&gt;collect(a:b)&lt;/code&gt;. Generally, there is no need to call &lt;code&gt;collect&lt;/code&gt; though. An &lt;code&gt;AbstractRange&lt;/code&gt; object will act like a normal array in most cases but is more efficient because it lazily computes its values. This pattern of creating specialized objects instead of full arrays is used frequently, and is also seen in functions such as &lt;a href=&quot;../../base/math/index#Base.range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt;, or with iterators such as &lt;code&gt;enumerate&lt;/code&gt;, and &lt;code&gt;zip&lt;/code&gt;. The special objects can mostly be used as if they were normal arrays.</source>
          <target state="translated">在Julia中， &lt;code&gt;a:b&lt;/code&gt; 和 &lt;code&gt;a:b:c&lt;/code&gt; 构造 &lt;code&gt;AbstractRange&lt;/code&gt; 对象。要像在MATLAB中那样构造一个完整的向量，请使用 &lt;code&gt;collect(a:b)&lt;/code&gt; 。通常，虽然不需要调用 &lt;code&gt;collect&lt;/code&gt; 。一个 &lt;code&gt;AbstractRange&lt;/code&gt; 对象会像在大多数情况下通常的阵列，但是更有效的，因为它懒惰地计算其值。这种创建专用对象而不是完整数组的模式经常被使用，并且在诸如&lt;a href=&quot;../../base/math/index#Base.range&quot;&gt; &lt;code&gt;range&lt;/code&gt; 的&lt;/a&gt;函数中，或者与诸如 &lt;code&gt;enumerate&lt;/code&gt; 和 &lt;code&gt;zip&lt;/code&gt; 的迭代器中也可以看到这种模式。特殊对象通常可以像普通数组一样使用。</target>
        </trans-unit>
        <trans-unit id="5622f51f1798995f4e2f17cefbf558acb8bdcceb" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;return&lt;/code&gt; does not require parentheses.</source>
          <target state="translated">在Julia中， &lt;code&gt;return&lt;/code&gt; 不需要括号。</target>
        </trans-unit>
        <trans-unit id="c5612272a8f825cb7424d2a9deb9bd304a01ce42" translate="yes" xml:space="preserve">
          <source>In Julia, &lt;code&gt;x += y&lt;/code&gt; gets replaced during parsing by &lt;code&gt;x = x + y&lt;/code&gt;. For arrays, this has the consequence that, rather than storing the result in the same location in memory as &lt;code&gt;x&lt;/code&gt;, it allocates a new array to store the result.</source>
          <target state="translated">在Julia中， &lt;code&gt;x += y&lt;/code&gt; 在解析过程中被 &lt;code&gt;x = x + y&lt;/code&gt; 替换。对于数组，其结果是，与其将结果存储在与 &lt;code&gt;x&lt;/code&gt; 相同的内存中，不如分配一个新的数组来存储结果。</target>
        </trans-unit>
        <trans-unit id="40831d3e8b132da3257b046df4af0d9dab5df46c" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, because they can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b1700c001aef7c6e8210d638550d343b095441" translate="yes" xml:space="preserve">
          <source>In Julia, a function is an object that maps a tuple of argument values to a return value. Julia functions are not pure mathematical functions, in the sense that functions can alter and be affected by the global state of the program. The basic syntax for defining functions in Julia is:</source>
          <target state="translated">在Julia中,函数是一个将参数值的元组映射到返回值的对象。Julia函数不是纯粹的数学函数,从这个意义上说,函数可以改变程序的全局状态并受其影响。在Julia中定义函数的基本语法是:。</target>
        </trans-unit>
        <trans-unit id="1c8982a95e255a5e2cc9c0e2345b6061fd0be88f" translate="yes" xml:space="preserve">
          <source>In Julia, a function may contain multiple concrete implementations (called &lt;em&gt;Methods&lt;/em&gt;), selected via multiple dispatch, whereas functions in Python have a single implementation (no polymorphism).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f670eb9f52ba71aa8ad7654d94717d406c50aa0" translate="yes" xml:space="preserve">
          <source>In Julia, a new local scope is introduced by most code blocks, including loops and &lt;code&gt;try&lt;/code&gt; &amp;mdash; &lt;code&gt;catch&lt;/code&gt; &amp;mdash; &lt;code&gt;finally&lt;/code&gt;. Note that comprehensions (list, generator, etc.) introduce a new local scope both in Python and Julia, whereas &lt;code&gt;if&lt;/code&gt; blocks do not introduce a new local scope in both languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f9d45e10bb7e036a0e05a4d8d4376715db6b481" translate="yes" xml:space="preserve">
          <source>In Julia, a range like &lt;code&gt;a:b&lt;/code&gt; is not shorthand for a vector like in R, but is a specialized &lt;code&gt;AbstractRange&lt;/code&gt; object that is used for iteration without high memory overhead. To convert a range into a vector, use &lt;code&gt;collect(a:b)&lt;/code&gt;.</source>
          <target state="translated">在Julia中，像 &lt;code&gt;a:b&lt;/code&gt; 这样的范围不是像R中那样的向量的简写，而是一个专门的 &lt;code&gt;AbstractRange&lt;/code&gt; 对象，该对象用于迭代而没有很高的内存开销。要将范围转换为向量，请使用 &lt;code&gt;collect(a:b)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="40f5223023ecdb73df06f3b1a01d3f068c335d77" translate="yes" xml:space="preserve">
          <source>In Julia, all arguments to functions are &lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;passed by sharing&lt;/a&gt; (i.e. by pointers). Some technical computing languages pass arrays by value, and while this prevents accidental modification by callees of a value in the caller, it makes avoiding unwanted copying of arrays difficult. By convention, a function name ending with a &lt;code&gt;!&lt;/code&gt; indicates that it will mutate or destroy the value of one or more of its arguments (compare, for example, &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;). Callees must make explicit copies to ensure that they don't modify inputs that they don't intend to change. Many non- mutating functions are implemented by calling a function of the same name with an added &lt;code&gt;!&lt;/code&gt; at the end on an explicit copy of the input, and returning that copy.</source>
          <target state="translated">在Julia中，函数的所有参数都是&lt;a href=&quot;https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing&quot;&gt;通过共享&lt;/a&gt;（即通过指针）传递的。某些技术计算语言按值传递数组，虽然这可以防止被调用方在调用方中意外修改值，但是这使得避免不必要的数组复制变得很困难。按照约定，函数名称以 &lt;code&gt;!&lt;/code&gt; 结尾。表示它将改变或破坏其一个或多个参数的值（例如，比较&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;）。被呼叫者必须进行明确的复制，以确保他们不会修改他们不打算更改的输入。通过调用带有加号 &lt;code&gt;!&lt;/code&gt; 的同名函数可以实现许多非变异函数。 最后在输入的显式副本上，然后返回该副本。</target>
        </trans-unit>
        <trans-unit id="9c3127614001f5fb915dc8fbc84746b3f3f27566" translate="yes" xml:space="preserve">
          <source>In Julia, an array &quot;slice&quot; expression like &lt;code&gt;array[1:5, :]&lt;/code&gt; creates a copy of that data (except on the left-hand side of an assignment, where &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; assigns in-place to that portion of &lt;code&gt;array&lt;/code&gt;). If you are doing many operations on the slice, this can be good for performance because it is more efficient to work with a smaller contiguous copy than it would be to index into the original array. On the other hand, if you are just doing a few simple operations on the slice, the cost of the allocation and copy operations can be substantial.</source>
          <target state="translated">在Julia中，像 &lt;code&gt;array[1:5, :]&lt;/code&gt; ，：]这样的数组&amp;ldquo;切片&amp;rdquo;表达式创建该数据的副本（赋值左侧除外，其中 &lt;code&gt;array[1:5, :] = ...&lt;/code&gt; ，：] = ...分配就位到 &lt;code&gt;array&lt;/code&gt; 的该部分）。如果您对切片执行许多操作，这可能会提高性能，因为使用较小的连续副本比索引原始数组更有效。另一方面，如果仅对片执行一些简单的操作，则分配和复制操作的成本可能会很高。</target>
        </trans-unit>
        <trans-unit id="3012ec15c747cb5e8c8ab3cbb7a1be0e9f5c2879" translate="yes" xml:space="preserve">
          <source>In Julia, exceeding the maximum representable value of a given type results in a wraparound behavior:</source>
          <target state="translated">在Julia中,超过给定类型的最大可表示值会导致一个包围行为。</target>
        </trans-unit>
        <trans-unit id="64ca87b8c062eb3ffaa0f39bec7e937ad18a966d" translate="yes" xml:space="preserve">
          <source>In Julia, if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are arrays, logical comparison operations like &lt;code&gt;A == B&lt;/code&gt; do not return an array of booleans. Instead, use &lt;code&gt;A .== B&lt;/code&gt;, and similarly for the other boolean operators like &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在Julia中，如果 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 是数组，则逻辑比较操作（如 &lt;code&gt;A == B&lt;/code&gt; 不会返回布尔数组。取而代之的是，使用 &lt;code&gt;A .== B&lt;/code&gt; ，并且类似地用于其他布尔运算符（如 &lt;code&gt;&amp;lt;&lt;/code&gt; ， &lt;code&gt;&amp;gt;&lt;/code&gt; )。</target>
        </trans-unit>
        <trans-unit id="8d1570d580f73be0193694bd4c3eb228fc48008c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing a matrix with arrays like &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; refers to a sub-matrix that contains the intersections of the first and second rows with the first and third columns. In Python, &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; refers to a vector that contains the values of cell &lt;code&gt;[1,1]&lt;/code&gt; and &lt;code&gt;[2,3]&lt;/code&gt; in the matrix. &lt;code&gt;X[[1,2], [1,3]]&lt;/code&gt; in Julia is equivalent with &lt;code&gt;X[np.ix_([0,1],[0,2])]&lt;/code&gt; in Python. &lt;code&gt;X[[0,1], [0,2]]&lt;/code&gt; in Python is equivalent with &lt;code&gt;X[[CartesianIndex(1,1), CartesianIndex(2,3)]]&lt;/code&gt; in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d922f5b73911084e1798e1fbea58a0f20f71a33c" translate="yes" xml:space="preserve">
          <source>In Julia, indexing of arrays, strings, etc. is 1-based not 0-based.</source>
          <target state="translated">在Julia中,数组、字符串等的索引是基于1而不是基于0。</target>
        </trans-unit>
        <trans-unit id="06df6596eaa7007459b69a3e35309023ab071dc0" translate="yes" xml:space="preserve">
          <source>In Julia, like Python but unlike R, strings can be created with triple quotes &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt;. This syntax is convenient for constructing strings that contain line breaks.</source>
          <target state="translated">在Julia中，与Python一样，但与R不同，可以使用三引号 &lt;code&gt;&quot;&quot;&quot; ... &quot;&quot;&quot;&lt;/code&gt; 创建字符串。此语法对于构造包含换行符的字符串很方便。</target>
        </trans-unit>
        <trans-unit id="6ff09f4efca3c4661d730a90a1c75212c7df44ad" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b7771804f2b70605beeefa21f23d88e1f845ae" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create integers instead of floating point numbers. As a result, some operations can throw a domain error if they expect a float; for example, &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; throws a domain error, as the result is not an integer (see &lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;the FAQ entry on domain errors&lt;/a&gt; for details).</source>
          <target state="translated">在Julia中，不带小数点的文字数字（例如 &lt;code&gt;42&lt;/code&gt; ）将创建整数而不是浮点数。结果，某些操作如果期望浮点数，则可能会引发域错误。例如 &lt;code&gt;julia&amp;gt; a = -1; 2^a&lt;/code&gt; 会引发域错误，因为结果不是整数（有关详细信息，请参阅&lt;a href=&quot;../faq/index#faq-domain-errors-1&quot;&gt;有关域错误的FAQ条目&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="abe9d8d534555f871e47223b8068b11086c34b86" translate="yes" xml:space="preserve">
          <source>In Julia, literal numbers without a decimal point (such as &lt;code&gt;42&lt;/code&gt;) create signed integers, of type &lt;code&gt;Int&lt;/code&gt;, but literals too large to fit in the machine word size will automatically be promoted to a larger size type, such as &lt;code&gt;Int64&lt;/code&gt; (if &lt;code&gt;Int&lt;/code&gt; is &lt;code&gt;Int32&lt;/code&gt;), &lt;code&gt;Int128&lt;/code&gt;, or the arbitrarily large &lt;code&gt;BigInt&lt;/code&gt; type. There are no numeric literal suffixes, such as &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;LL&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;UL&lt;/code&gt;, &lt;code&gt;ULL&lt;/code&gt; to indicate unsigned and/or signed vs. unsigned. Decimal literals are always signed, and hexadecimal literals (which start with &lt;code&gt;0x&lt;/code&gt; like C/C++), are unsigned. Hexadecimal literals also, unlike C/C++/Java and unlike decimal literals in Julia, have a type based on the &lt;em&gt;length&lt;/em&gt; of the literal, including leading 0s. For example, &lt;code&gt;0x0&lt;/code&gt; and &lt;code&gt;0x00&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt;&lt;code&gt;UInt8&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;0x000&lt;/code&gt; and &lt;code&gt;0x0000&lt;/code&gt; have type &lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/a&gt;, then literals with 5 to 8 hex digits have type &lt;code&gt;UInt32&lt;/code&gt;, 9 to 16 hex digits type &lt;code&gt;UInt64&lt;/code&gt; and 17 to 32 hex digits type &lt;code&gt;UInt128&lt;/code&gt;. This needs to be taken into account when defining hexadecimal masks, for example &lt;code&gt;~0xf == 0xf0&lt;/code&gt; is very different from &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt;. 64 bit &lt;code&gt;Float64&lt;/code&gt; and 32 bit &lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt;&lt;code&gt;Float32&lt;/code&gt;&lt;/a&gt; bit literals are expressed as &lt;code&gt;1.0&lt;/code&gt; and &lt;code&gt;1.0f0&lt;/code&gt; respectively. Floating point literals are rounded (and not promoted to the &lt;code&gt;BigFloat&lt;/code&gt; type) if they can not be exactly represented. Floating point literals are closer in behavior to C/C++. Octal (prefixed with &lt;code&gt;0o&lt;/code&gt;) and binary (prefixed with &lt;code&gt;0b&lt;/code&gt;) literals are also treated as unsigned.</source>
          <target state="translated">在Julia中，不带小数点的文字数字（例如 &lt;code&gt;42&lt;/code&gt; ）会创建 &lt;code&gt;Int&lt;/code&gt; 类型的带符号整数，但是太大而无法容纳机器字大小的文字会自动提升为较大的类型，例如 &lt;code&gt;Int64&lt;/code&gt; （如果 &lt;code&gt;Int&lt;/code&gt; 为 &lt;code&gt;Int32&lt;/code&gt; ）， &lt;code&gt;Int128&lt;/code&gt; 或任意大的 &lt;code&gt;BigInt&lt;/code&gt; 类型。没有数字文字后缀，例如 &lt;code&gt;L&lt;/code&gt; ， &lt;code&gt;LL&lt;/code&gt; ， &lt;code&gt;U&lt;/code&gt; ， &lt;code&gt;UL&lt;/code&gt; ， &lt;code&gt;ULL&lt;/code&gt; 来表示无符号和/或有符号与无符号。十进制字面量总是带符号的，十六进制字面量（以 &lt;code&gt;0x&lt;/code&gt; 开头)像C / C ++）是无符号的。与C / C ++ / Java和Julia中的十进制文字不同，十六进制文字也具有基于文字&lt;em&gt;长度&lt;/em&gt;的类型，包括前导0。例如， &lt;code&gt;0x0&lt;/code&gt; 和 &lt;code&gt;0x00&lt;/code&gt; 具有键入&lt;a href=&quot;../../base/numbers/index#Core.UInt8&quot;&gt; &lt;code&gt;UInt8&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;0x000&lt;/code&gt; 的和 &lt;code&gt;0x0000&lt;/code&gt; 有键入&lt;a href=&quot;../../base/numbers/index#Core.UInt16&quot;&gt; &lt;code&gt;UInt16&lt;/code&gt; &lt;/a&gt;，然后用5至8个十六进制数字的文字已经键入 &lt;code&gt;UInt32&lt;/code&gt; 的，9〜16个十六进制数字键入 &lt;code&gt;UInt64&lt;/code&gt; 和17〜32个十六进制数字键入 &lt;code&gt;UInt128&lt;/code&gt; 。这需要定义十六进制掩模时，可以考虑到，例如 &lt;code&gt;~0xf == 0xf0&lt;/code&gt; 是从非常不同 &lt;code&gt;~0x000f == 0xfff0&lt;/code&gt; 。 64位 &lt;code&gt;Float64&lt;/code&gt; 和32位&lt;a href=&quot;../../base/numbers/index#Core.Float32&quot;&gt; &lt;code&gt;Float32&lt;/code&gt; &lt;/a&gt;位文字分别表示为 &lt;code&gt;1.0&lt;/code&gt; 和 &lt;code&gt;1.0f0&lt;/code&gt; 。如果不能精确表示浮点字面量，则四舍五入（不提升为 &lt;code&gt;BigFloat&lt;/code&gt; 类型）。浮点文字在行为上更接近于C / C ++。八进制（以 &lt;code&gt;0o&lt;/code&gt; 前缀）和二进制（以 &lt;code&gt;0b&lt;/code&gt; 前缀）文字也被视为无符号。</target>
        </trans-unit>
        <trans-unit id="bdfe6baa0b2a1067c27d35abb55f2ee6ec449a3c" translate="yes" xml:space="preserve">
          <source>In Julia, missing values are represented by the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object rather than by &lt;code&gt;NA&lt;/code&gt;. Use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;ismissing.(x)&lt;/code&gt; for element-wise operation on vectors) instead of &lt;code&gt;is.na(x)&lt;/code&gt;. The &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function is generally used instead of &lt;code&gt;na.rm=TRUE&lt;/code&gt; (though in some particular cases functions take a &lt;code&gt;skipmissing&lt;/code&gt; argument).</source>
          <target state="translated">在Julia中，缺失值由&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;对象而不是 &lt;code&gt;NA&lt;/code&gt; 表示。使用&lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt;（或 &lt;code&gt;ismissing.(x)&lt;/code&gt; 进行矢量元素操作），而不是 &lt;code&gt;is.na(x)&lt;/code&gt; 。该&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;函数一般用来代替 &lt;code&gt;na.rm=TRUE&lt;/code&gt; （尽管在某些特定情况下的功能采取 &lt;code&gt;skipmissing&lt;/code&gt; 参数）。</target>
        </trans-unit>
        <trans-unit id="c2883abece45992fb07a9eafea704ad64c7847f2" translate="yes" xml:space="preserve">
          <source>In Julia, modulus is &lt;code&gt;mod(a, b)&lt;/code&gt;, not &lt;code&gt;a %% b&lt;/code&gt;. &lt;code&gt;%&lt;/code&gt; in Julia is the remainder operator.</source>
          <target state="translated">在Julia中，模数是 &lt;code&gt;mod(a, b)&lt;/code&gt; ，而不是 &lt;code&gt;a %% b&lt;/code&gt; 。Julia中的 &lt;code&gt;%&lt;/code&gt; 是余数运算符。</target>
        </trans-unit>
        <trans-unit id="d79893a1ef0fe5a790c5d1bb686e33bb258470f4" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e2622d04790dce54d4881a8ca271df72d322df7" translate="yes" xml:space="preserve">
          <source>In Julia, most operators are just functions with support for special syntax. (The exceptions are operators with special evaluation semantics like &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;. These operators cannot be functions since &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;Short-Circuit Evaluation&lt;/a&gt; requires that their operands are not evaluated before evaluation of the operator.) Accordingly, you can also apply them using parenthesized argument lists, just as you would any other function:</source>
          <target state="translated">在Julia中，大多数运算符只是支持特殊语法的函数。 （例外是具有特殊评估语义的运算符，如 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; 。这些运算符不能用作函数，因为&amp;ldquo; &lt;a href=&quot;../control-flow/index#Short-Circuit-Evaluation-1&quot;&gt;短路评估&amp;rdquo;&lt;/a&gt;要求在评估运算符之前不对它们的操作数进行评估。）因此，还可以使用带括号的参数列表来应用它们。 ，就像您执行其他任何功能一样：</target>
        </trans-unit>
        <trans-unit id="cec708186271fab31b28911da66c39fb5ef32d0d" translate="yes" xml:space="preserve">
          <source>In Julia, multiple values are returned and assigned as tuples, e.g. &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; or &lt;code&gt;a, b = 1, 2&lt;/code&gt;. MATLAB's &lt;code&gt;nargout&lt;/code&gt;, which is often used in MATLAB to do optional work based on the number of returned values, does not exist in Julia. Instead, users can use optional and keyword arguments to achieve similar capabilities.</source>
          <target state="translated">在Julia中，返回多个值并将其分配为元组，例如 &lt;code&gt;(a, b) = (1, 2)&lt;/code&gt; 或 &lt;code&gt;a, b = 1, 2&lt;/code&gt; 。Julia中不存在MATLAB的 &lt;code&gt;nargout&lt;/code&gt; ，它通常在MATLAB中用于根据返回值的数量进行可选工作。相反，用户可以使用可选参数和关键字参数来实现类似的功能。</target>
        </trans-unit>
        <trans-unit id="4f6861a8c923af27ce752544647b06d9e6a0a07e" translate="yes" xml:space="preserve">
          <source>In Julia, not all data structures support logical indexing. Furthermore, logical indexing in Julia is supported only with vectors of length equal to the object being indexed. For example:</source>
          <target state="translated">在Julia中,并非所有的数据结构都支持逻辑索引。此外,Julia中的逻辑索引只支持长度等于被索引对象的向量。例如:</target>
        </trans-unit>
        <trans-unit id="451c3e5bbe0419b361a11d608a26c62bcc892288" translate="yes" xml:space="preserve">
          <source>In Julia, one returns a tuple of values to simulate returning multiple values. However, tuples can be created and destructured without needing parentheses, thereby providing an illusion that multiple values are being returned, rather than a single tuple value. For example, the following function returns a pair of values:</source>
          <target state="translated">在Julia中,人们返回一个元组的值来模拟返回多个值。然而,tuple可以在不需要括号的情况下创建和重构,从而提供了一种错觉,即返回的是多个值,而不是单个tuple值。例如,以下函数返回一对值。</target>
        </trans-unit>
        <trans-unit id="d1f236e7a8645aa4ffbd134429aa159fdbc206da" translate="yes" xml:space="preserve">
          <source>In Julia, parentheses must be used to call a function with zero arguments, like in &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在Julia中，必须使用括号来调用带有零参数的函数，例如&lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand()&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b62993ba8b73165f19053f9f6eaf87bfbe97454f" translate="yes" xml:space="preserve">
          <source>In Julia, reductions such as &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; are performed over every element of an array when called with a single argument, as in &lt;code&gt;sum(A)&lt;/code&gt;, even if &lt;code&gt;A&lt;/code&gt; has more than one dimension.</source>
          <target state="translated">在Julia中，当使用单个参数调用数组的每个元素时，都会像 &lt;code&gt;sum(A)&lt;/code&gt; 那样对数组的每个元素执行诸如&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; 的约&lt;/a&gt;简，即使 &lt;code&gt;A&lt;/code&gt; 具有多个维。</target>
        </trans-unit>
        <trans-unit id="6b1973243505286be855fb241367233be8bd84fa" translate="yes" xml:space="preserve">
          <source>In Julia, sparse matrices are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;Compressed Sparse Column (CSC) format&lt;/a&gt;. Julia sparse matrices have the type &lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt;&lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt;&lt;/a&gt;, where &lt;code&gt;Tv&lt;/code&gt; is the type of the stored values, and &lt;code&gt;Ti&lt;/code&gt; is the integer type for storing column pointers and row indices. The internal representation of &lt;code&gt;SparseMatrixCSC&lt;/code&gt; is as follows:</source>
          <target state="translated">在Julia中，稀疏矩阵以&lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_.28CSC_or_CCS.29&quot;&gt;压缩稀疏列（CSC）格式存储&lt;/a&gt;。 Julia稀疏矩阵的类型为&lt;a href=&quot;#SparseArrays.SparseMatrixCSC&quot;&gt; &lt;code&gt;SparseMatrixCSC{Tv,Ti}&lt;/code&gt; &lt;/a&gt;，其中 &lt;code&gt;Tv&lt;/code&gt; 是存储值的类型， &lt;code&gt;Ti&lt;/code&gt; 是用于存储列指针和行索引的整数类型。 &lt;code&gt;SparseMatrixCSC&lt;/code&gt; 的内部表示如下：</target>
        </trans-unit>
        <trans-unit id="a5c3c759720c16030d42ce9ed7346415b8cda62d" translate="yes" xml:space="preserve">
          <source>In Julia, the &lt;code&gt;adjoint&lt;/code&gt; function performs conjugate transposition; in MATLAB, &lt;code&gt;adjoint&lt;/code&gt; provides the &quot;adjugate&quot; or classical adjoint, which is the transpose of the matrix of cofactors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8bc1ec2e65356b67489d496d41c529e84e8334" translate="yes" xml:space="preserve">
          <source>In Julia, the binding of a variable &lt;code&gt;x&lt;/code&gt; cannot be changed by passing &lt;code&gt;x&lt;/code&gt; as an argument to a function. When calling &lt;code&gt;change_value!(x)&lt;/code&gt; in the above example, &lt;code&gt;y&lt;/code&gt; is a newly created variable, bound initially to the value of &lt;code&gt;x&lt;/code&gt;, i.e. &lt;code&gt;10&lt;/code&gt;; then &lt;code&gt;y&lt;/code&gt; is rebound to the constant &lt;code&gt;17&lt;/code&gt;, while the variable &lt;code&gt;x&lt;/code&gt; of the outer scope is left untouched.</source>
          <target state="translated">在Julia中，不能通过将 &lt;code&gt;x&lt;/code&gt; 作为参数传递给函数来更改变量 &lt;code&gt;x&lt;/code&gt; 的绑定。在上面的示例中，当调用 &lt;code&gt;change_value!(x)&lt;/code&gt; 时， &lt;code&gt;y&lt;/code&gt; 是一个新创建的变量，最初绑定到 &lt;code&gt;x&lt;/code&gt; 的值，即 &lt;code&gt;10&lt;/code&gt; ；然后 &lt;code&gt;y&lt;/code&gt; 反弹到常数 &lt;code&gt;17&lt;/code&gt; ，而外部范围的变量 &lt;code&gt;x&lt;/code&gt; 保持不变。</target>
        </trans-unit>
        <trans-unit id="e2d42d83a28f2989051e64390c6b07102af77a3d" translate="yes" xml:space="preserve">
          <source>In Julia, the commonly used &lt;code&gt;Int&lt;/code&gt; type corresponds to the machine integer type (&lt;code&gt;Int32&lt;/code&gt; or &lt;code&gt;Int64&lt;/code&gt;), unlike in Python, where &lt;code&gt;int&lt;/code&gt; is an arbitrary length integer. This means in Julia the &lt;code&gt;Int&lt;/code&gt; type will overflow, such that &lt;code&gt;2^64 == 0&lt;/code&gt;. If you need larger values use another appropriate type, such as &lt;code&gt;Int128&lt;/code&gt;, &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; or a floating point type like &lt;code&gt;Float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad2abcec621eb10f8cdb25e242afd4f9efd6dd1" translate="yes" xml:space="preserve">
          <source>In Julia, the elements of a collection can be passed as arguments to a function using the splat operator &lt;code&gt;...&lt;/code&gt;, as in &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt;.</source>
          <target state="translated">在Julia中，可以使用splat运算符 &lt;code&gt;...&lt;/code&gt; 将集合的元素作为参数传递给函数，如 &lt;code&gt;xs=[1,2]; f(xs...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d494edc49792467615a5bbbdd57215d8dd338e99" translate="yes" xml:space="preserve">
          <source>In Julia, the exponentiation operator is &lt;code&gt;^&lt;/code&gt;, not &lt;code&gt;**&lt;/code&gt; as in Python.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d049ffcb952000d0f8ebc0a66e0ee55d575d87" translate="yes" xml:space="preserve">
          <source>In Julia, the operator &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) performs the bitwise XOR operation, i.e. &lt;code&gt;^&lt;/code&gt; in C/C++. Also, the bitwise operators do not have the same precedence as C/++, so parenthesis may be required.</source>
          <target state="translated">在Julia中，运算符&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;）执行按位XOR运算，即C / C ++中的 &lt;code&gt;^&lt;/code&gt; 。同样，按位运算符的优先级与C / ++的优先级不同，因此可能需要括号。</target>
        </trans-unit>
        <trans-unit id="8490fa684242627635a34751122775551824f7e6" translate="yes" xml:space="preserve">
          <source>In Julia, the operators &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;|&lt;/code&gt;, and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;) perform the bitwise operations equivalent to &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, and &lt;code&gt;xor&lt;/code&gt; respectively in MATLAB, and have precedence similar to Python's bitwise operators (unlike C). They can operate on scalars or element-wise across arrays and can be used to combine logical arrays, but note the difference in order of operations: parentheses may be required (e.g., to select elements of &lt;code&gt;A&lt;/code&gt; equal to 1 or 2 use &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt;).</source>
          <target state="translated">在Julia中，运算符&lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt;， &lt;code&gt;|&lt;/code&gt; 。，和&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt;（&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;）分别执行与MATLAB中的 &lt;code&gt;and&lt;/code&gt; ， &lt;code&gt;or&lt;/code&gt; ，和 &lt;code&gt;xor&lt;/code&gt; 等效的按位运算，并且其优先级类似于Python的按位运算符（与C不同）。它们可以按标量或跨数组按元素进行操作，并且可以用于组合逻辑数组，但请注意操作顺序的区别：可能需要括号（例如，选择 &lt;code&gt;A&lt;/code&gt; 等于1或2的元素使用 &lt;code&gt;(A .== 1) .| (A .== 2)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1e2a4d55a36175a20161ae921b2cf660cd6f7ede" translate="yes" xml:space="preserve">
          <source>In Julia, the standard operators over a matrix type are matrix operations, whereas, in Python, the standard operators are element-wise operations. When both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, &lt;code&gt;A * B&lt;/code&gt; in Julia performs matrix multiplication, not element-wise multiplication as in Python. &lt;code&gt;A * B&lt;/code&gt; in Julia is equivalent with &lt;code&gt;A @ B&lt;/code&gt; in Python, whereas &lt;code&gt;A * B&lt;/code&gt; in Python is equivalent with &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c924b695c23524838be4cdefba6d4ecf3f12bd7f" translate="yes" xml:space="preserve">
          <source>In Julia, values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller. This is very different from R and allows new functions to operate on large data structures much more efficiently.</source>
          <target state="translated">在Julia中,当分配或传递给一个函数时,值不会被复制。如果一个函数修改了一个数组,其变化将在调用者中可见。这一点与R非常不同,可以让新函数更有效地操作大型数据结构。</target>
        </trans-unit>
        <trans-unit id="4125f91a0372e71681729284bfb74b1b5f121b87" translate="yes" xml:space="preserve">
          <source>In Julia, varargs are specified using the splat operator &lt;code&gt;...&lt;/code&gt;, which always follows the name of a specific variable, unlike R, for which &lt;code&gt;...&lt;/code&gt; can occur in isolation.</source>
          <target state="translated">在Julia中，使用splat运算符 &lt;code&gt;...&lt;/code&gt; 指定varargs ，该运算符始终跟随特定变量的名称，与R不同，对于 &lt;code&gt;...&lt;/code&gt; &amp;hellip;可以单独发生。</target>
        </trans-unit>
        <trans-unit id="61706e2cf7e3e0b63c2023adcea629882d9748dd" translate="yes" xml:space="preserve">
          <source>In Julia, vectors and matrices are concatenated using &lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt;&lt;code&gt;hcat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt;&lt;code&gt;vcat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt;&lt;code&gt;hvcat&lt;/code&gt;&lt;/a&gt;, not &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;rbind&lt;/code&gt; and &lt;code&gt;cbind&lt;/code&gt; like in R.</source>
          <target state="translated">在Julia中，像R中一样，使用&lt;a href=&quot;../../base/arrays/index#Base.hcat&quot;&gt; &lt;code&gt;hcat&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/arrays/index#Base.vcat&quot;&gt; &lt;code&gt;vcat&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/arrays/index#Base.hvcat&quot;&gt; &lt;code&gt;hvcat&lt;/code&gt; &lt;/a&gt;而不是 &lt;code&gt;c&lt;/code&gt; ， &lt;code&gt;rbind&lt;/code&gt; 和 &lt;code&gt;cbind&lt;/code&gt; 连接向量和矩阵。</target>
        </trans-unit>
        <trans-unit id="c15bdde6dec6d1761a5dc60f223d32d1ac186e83" translate="yes" xml:space="preserve">
          <source>In Julia, we can access the parts independently to make a copy of that string:</source>
          <target state="translated">在Julia中,我们可以独立地访问各个部分,对该字符串进行复制。</target>
        </trans-unit>
        <trans-unit id="8bbe2d9f25b242e167641a97cc1e17c904778314" translate="yes" xml:space="preserve">
          <source>In Julia, whitespace is significant, unlike C/C++, so care must be taken when adding/removing whitespace from a Julia program.</source>
          <target state="translated">在Julia中,与C/C++不同,whitespace是很重要的,所以在Julia程序中添加/删除whitespace时必须小心。</target>
        </trans-unit>
        <trans-unit id="dfd2a6192ce5ab720952e7ded70bfe43e1c2837a" translate="yes" xml:space="preserve">
          <source>In Julia, you can't dispatch on a &lt;em&gt;value&lt;/em&gt; such as &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. However, you can dispatch on parametric types, and Julia allows you to include &quot;plain bits&quot; values (Types, Symbols, Integers, floating-point numbers, tuples, etc.) as type parameters. A common example is the dimensionality parameter in &lt;code&gt;Array{T,N}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type (e.g., &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;) but &lt;code&gt;N&lt;/code&gt; is just an &lt;code&gt;Int&lt;/code&gt;.</source>
          <target state="translated">在Julia中，您不能调度诸如 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 的&lt;em&gt;值&lt;/em&gt;。但是，您可以调度参数类型，Julia允许您将&amp;ldquo;普通位&amp;rdquo;值（类型，符号，整数，浮点数，元组等）包括为类型参数。一个常见的示例是 &lt;code&gt;Array{T,N}&lt;/code&gt; 的维度参数，其中 &lt;code&gt;T&lt;/code&gt; 是类型（例如&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;），而 &lt;code&gt;N&lt;/code&gt; 只是 &lt;code&gt;Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0987332b373dba2f6dccb678d104e0da95c47a9e" translate="yes" xml:space="preserve">
          <source>In MATLAB, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; or in the statement &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">在MATLAB中，删除不想要的值的惯用方式是使用逻辑索引，例如在表达式 &lt;code&gt;x(x&amp;gt;3)&lt;/code&gt; 或语句 &lt;code&gt;x(x&amp;gt;3) = []&lt;/code&gt; 中就地修改 &lt;code&gt;x&lt;/code&gt; 。相反，Julia提供了高阶函数&lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;，允许用户编写 &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 和 &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 来代替相应的音译 &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; 和 &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; 。使用&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;减少使用临时数组。</target>
        </trans-unit>
        <trans-unit id="af1c31248c4802059b749cc923a13d7acffd80c9" translate="yes" xml:space="preserve">
          <source>In Python, the majority of values can be used in logical contexts (e.g. &lt;code&gt;if &quot;a&quot;:&lt;/code&gt; means the following block is executed, and &lt;code&gt;if &quot;&quot;:&lt;/code&gt; means it is not). In Julia, you need explicit conversion to &lt;code&gt;Bool&lt;/code&gt; (e.g. &lt;code&gt;if &quot;a&quot;&lt;/code&gt; throws an exception). If you want to test for a non-empty string in Julia, you would explicitly write &lt;code&gt;if !isempty(&quot;&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e02ea871ca138515cbf18e7481d0fb87b2d5244" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">在R中， &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE)]&lt;/code&gt; 等效于 &lt;code&gt;c(1, 3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="616e3b4685be805ef30bd44974ee4d2b22ae8fea" translate="yes" xml:space="preserve">
          <source>In R, &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; is equivalent to &lt;code&gt;c(1, 3)&lt;/code&gt;.</source>
          <target state="translated">在R中， &lt;code&gt;c(1, 2, 3, 4)[c(TRUE, FALSE, TRUE, FALSE)]&lt;/code&gt; 等效于 &lt;code&gt;c(1, 3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ce0a60c169bc6c80688de200a5cb77dbd4fa3448" translate="yes" xml:space="preserve">
          <source>In R, an idiomatic way to remove unwanted values is to use logical indexing, like in the expression &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; or in the statement &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; to modify &lt;code&gt;x&lt;/code&gt; in-place. In contrast, Julia provides the higher order functions &lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt;, allowing users to write &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; and &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; as alternatives to the corresponding transliterations &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; and &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt;. Using &lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt;&lt;code&gt;filter!&lt;/code&gt;&lt;/a&gt; reduces the use of temporary arrays.</source>
          <target state="translated">在R中，删除不想要的值的惯用方式是使用逻辑索引，例如在表达式 &lt;code&gt;x[x&amp;gt;3]&lt;/code&gt; 或语句 &lt;code&gt;x = x[x&amp;gt;3]&lt;/code&gt; 中就地修改 &lt;code&gt;x&lt;/code&gt; 。相反，Julia提供了高阶函数&lt;a href=&quot;../../base/collections/index#Base.filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;，允许用户编写 &lt;code&gt;filter(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 和 &lt;code&gt;filter!(z-&amp;gt;z&amp;gt;3, x)&lt;/code&gt; 来代替相应的音译 &lt;code&gt;x[x.&amp;gt;3]&lt;/code&gt; 和 &lt;code&gt;x = x[x.&amp;gt;3]&lt;/code&gt; 。使用&lt;a href=&quot;../../base/collections/index#Base.filter!&quot;&gt; &lt;code&gt;filter!&lt;/code&gt; &lt;/a&gt;减少使用临时数组。</target>
        </trans-unit>
        <trans-unit id="f6752ab2f8e0e7630531a6d7a1987e0bbb17b890" translate="yes" xml:space="preserve">
          <source>In R, performance requires vectorization. In Julia, almost the opposite is true: the best performing code is often achieved by using devectorized loops.</source>
          <target state="translated">在R中,性能需要矢量化。在Julia中,情况几乎正好相反:性能最好的代码往往是通过使用去向量化的循环来实现的。</target>
        </trans-unit>
        <trans-unit id="01878b8d1b390512d629c49ff65589c19ca63ad8" translate="yes" xml:space="preserve">
          <source>In a linear-algebra context, this means that even though operations like &lt;code&gt;vector + vector&lt;/code&gt; and &lt;code&gt;vector * scalar&lt;/code&gt; are defined, it can be advantageous to instead use &lt;code&gt;vector .+ vector&lt;/code&gt; and &lt;code&gt;vector .* scalar&lt;/code&gt; because the resulting loops can be fused with surrounding computations. For example, consider the two functions:</source>
          <target state="translated">在线性代数上下文中，这意味着即使定义了诸如 &lt;code&gt;vector + vector&lt;/code&gt; 和 &lt;code&gt;vector * scalar&lt;/code&gt; ，但最好使用 &lt;code&gt;vector .+ vector&lt;/code&gt; 和 &lt;code&gt;vector .* scalar&lt;/code&gt; 因为生成的循环可以与周围的计算融合。例如，考虑两个功能：</target>
        </trans-unit>
        <trans-unit id="9e1d6d725f550ad6f9da6bf98cc247f18f2108d6" translate="yes" xml:space="preserve">
          <source>In a local scope, all variables are inherited from its parent global scope block unless:</source>
          <target state="translated">在局部作用域中,所有的变量都从它的父全局作用域块中继承,除非。</target>
        </trans-unit>
        <trans-unit id="8fb94127a63695dc8bd7c2b91c9aa1704119e38b" translate="yes" xml:space="preserve">
          <source>In a module, declare that the file specified by &lt;code&gt;path&lt;/code&gt; (relative or absolute) is a dependency for precompilation; that is, the module will need to be recompiled if this file changes.</source>
          <target state="translated">在模块中，声明 &lt;code&gt;path&lt;/code&gt; 指定的文件（相对或绝对）是预编译的依赖项；也就是说，如果此文件更改，则将需要重新编译模块。</target>
        </trans-unit>
        <trans-unit id="ba39320cdec145895823bcc997669a25a6af7855" translate="yes" xml:space="preserve">
          <source>In a sense, Julia falls into the &quot;no automatic promotion&quot; category: mathematical operators are just functions with special syntax, and the arguments of functions are never automatically converted. However, one may observe that applying mathematical operations to a wide variety of mixed argument types is just an extreme case of polymorphic multiple dispatch &amp;ndash; something which Julia's dispatch and type systems are particularly well-suited to handle. &quot;Automatic&quot; promotion of mathematical operands simply emerges as a special application: Julia comes with pre-defined catch-all dispatch rules for mathematical operators, invoked when no specific implementation exists for some combination of operand types. These catch-all rules first promote all operands to a common type using user-definable promotion rules, and then invoke a specialized implementation of the operator in question for the resulting values, now of the same type. User-defined types can easily participate in this promotion system by defining methods for conversion to and from other types, and providing a handful of promotion rules defining what types they should promote to when mixed with other types.</source>
          <target state="translated">从某种意义上说，Julia属于&amp;ldquo;没有自动提升&amp;rdquo;类别：数学运算符只是具有特殊语法的函数，而函数的参数永远不会自动转换。但是，可能会观察到，将数学运算应用于多种混合参数类型只是多态多重分派的极端情况-Julia的分派和类型系统特别适合处理这种情况。数学操作数的&amp;ldquo;自动&amp;rdquo;升级只是作为一种特殊应用出现：Julia附带了针对数学运算符的预定义全部捕获调度规则，当对操作数类型的某种组合不存在特定实现时调用。这些通用规则首先使用用户可定义的提升规则将所有操作数提升为一个通用类型，然后为产生的值（现在是相同类型）调用有问题的运算符的专用实现。用户定义的类型可以通过定义用于与其他类型之间进行转换的方法，并提供一些促销规则来定义它们与其他类型混合时应提升为哪种类型，从而轻松地参与此促销系统。</target>
        </trans-unit>
        <trans-unit id="c6a6dfe6183c6c2d1bbad1fc9762d95e2e3097dd" translate="yes" xml:space="preserve">
          <source>In a similar fashion as to how one can define keyword arguments programmatically, a named tuple can be created by giving a pair &lt;code&gt;name::Symbol =&amp;gt; value&lt;/code&gt; or splatting an iterator yielding such pairs after a semicolon inside a tuple literal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18e44910a826a7be9fd86ad6a5c3ed3f73d517fa" translate="yes" xml:space="preserve">
          <source>In addition to (and as part of) its support for multi-dimensional arrays, Julia provides native implementations of many common and useful linear algebra operations which can be loaded with &lt;code&gt;using LinearAlgebra&lt;/code&gt;. Basic operations, such as &lt;a href=&quot;#LinearAlgebra.tr&quot;&gt;&lt;code&gt;tr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#LinearAlgebra.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;inv&lt;/code&gt; are all supported:</source>
          <target state="translated">除了对多维数组的支持（并作为其一部分）之外，Julia还提供了许多常见且有用的线性代数运算的本机实现，可以 &lt;code&gt;using LinearAlgebra&lt;/code&gt; 加载这些运算。支持基本操作，例如&lt;a href=&quot;#LinearAlgebra.tr&quot;&gt; &lt;code&gt;tr&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;#LinearAlgebra.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;inv&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f10487aa88c806dfd44fdee05bfc7281d910b478" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt;, a few other basic functions are needed to use tasks effectively.</source>
          <target state="translated">除了&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; 之外&lt;/a&gt;，还需要一些其他基本功能来有效使用任务。</target>
        </trans-unit>
        <trans-unit id="f2ab7ee40bd53e11319399c116d8d2cc2c48169d" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;using Base&lt;/code&gt;, modules also automatically contain definitions of the &lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt;&lt;code&gt;eval&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt; functions, which evaluate expressions/files within the global scope of that module.</source>
          <target state="translated">除了 &lt;code&gt;using Base&lt;/code&gt; ，模块还自动包含&lt;a href=&quot;../../base/base/index#Base.MainInclude.eval&quot;&gt; &lt;code&gt;eval&lt;/code&gt; 的&lt;/a&gt;定义并&lt;a href=&quot;../../base/base/index#Base.MainInclude.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;函数，该函数在该模块的全局范围内评估表达式/文件。</target>
        </trans-unit>
        <trans-unit id="10d21e803c8a9917ec9f0f6ebe5595e193060fc6" translate="yes" xml:space="preserve">
          <source>In addition to all the iterable and indexable methods from above, these types can also interact with each other and use most of the methods defined in Julia Base for &lt;code&gt;AbstractArrays&lt;/code&gt;:</source>
          <target state="translated">除了上述所有可迭代和可索引的方法之外，这些类型还可以彼此交互，并使用Julia Base中为 &lt;code&gt;AbstractArrays&lt;/code&gt; 定义的大多数方法：</target>
        </trans-unit>
        <trans-unit id="e406211c0c63c531f5fd9ccb75f3528a5be0658c" translate="yes" xml:space="preserve">
          <source>In addition to linear indexing, an &lt;code&gt;N&lt;/code&gt;-dimensional array may be indexed with fewer or more than &lt;code&gt;N&lt;/code&gt; indices in certain situations.</source>
          <target state="translated">除了线性索引，在某些情况下，可以使用少于或多于 &lt;code&gt;N&lt;/code&gt; 个索引来索引 &lt;code&gt;N&lt;/code&gt; 维数组。</target>
        </trans-unit>
        <trans-unit id="98e86e056613a088089dad092fe39f17f798108b" translate="yes" xml:space="preserve">
          <source>In addition to tasks Julia forwards natively supports multi-threading. Note that this section is experimental and the interfaces may change in the future.</source>
          <target state="translated">除了任务,Julia转发原生支持多线程。需要注意的是,这部分是实验性的,未来接口可能会有变化。</target>
        </trans-unit>
        <trans-unit id="ec666f0e17f38401053d73ee95bfc69ad9a82cc3" translate="yes" xml:space="preserve">
          <source>In addition to the given argument list, every macro is passed extra arguments named &lt;code&gt;__source__&lt;/code&gt; and &lt;code&gt;__module__&lt;/code&gt;.</source>
          <target state="translated">除了给定的参数列表外，每个宏还传递了名为 &lt;code&gt;__source__&lt;/code&gt; 和 &lt;code&gt;__module__&lt;/code&gt; 的其他参数。</target>
        </trans-unit>
        <trans-unit id="f681189a6c7a87dd61774b09673a55a0c0fa70a2" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24215bb3919d42188faab69329d0bd6705349ee5" translate="yes" xml:space="preserve">
          <source>In addition, Julia provides many &lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;factorizations&lt;/a&gt; which can be used to speed up problems such as linear solve or matrix exponentiation by pre-factorizing a matrix into a form more amenable (for performance or memory reasons) to the problem. See the documentation on &lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt;&lt;code&gt;factorize&lt;/code&gt;&lt;/a&gt; for more information. As an example:</source>
          <target state="translated">此外，Julia提供了许多&lt;a href=&quot;#man-linalg-factorizations-1&quot;&gt;分解因子&lt;/a&gt;，可以通过将矩阵预先分解为更适合该问题的形式（出于性能或存储方面的考虑），从而加快诸如线性求解或矩阵求幂之类的问题。有关更多信息，请参见关于&lt;a href=&quot;#LinearAlgebra.factorize&quot;&gt; &lt;code&gt;factorize&lt;/code&gt; &lt;/a&gt;的文档。举个例子：</target>
        </trans-unit>
        <trans-unit id="655d29ad2536f5920e2f78273e9aa1a0a062ab22" translate="yes" xml:space="preserve">
          <source>In all cases the ambiguity is resolved in favor of interpretation as numeric literals:</source>
          <target state="translated">在所有情况下,歧义的解决都有利于作为数字文字的解释。</target>
        </trans-unit>
        <trans-unit id="73ededace2cf23e632ef0400ebd52a78d322cb00" translate="yes" xml:space="preserve">
          <source>In all of the above modes, the executed lines get saved to a history file, which can be searched. To initiate an incremental search through the previous history, type &lt;code&gt;^R&lt;/code&gt; &amp;ndash; the control key together with the &lt;code&gt;r&lt;/code&gt; key. The prompt will change to &lt;code&gt;(reverse-i-search)`':&lt;/code&gt;, and as you type the search query will appear in the quotes. The most recent result that matches the query will dynamically update to the right of the colon as more is typed. To find an older result using the same query, simply type &lt;code&gt;^R&lt;/code&gt; again.</source>
          <target state="translated">在以上所有模式下，执行的行都保存到历史文件中，可以进行搜索。要在以前的历史记录中进行增量搜索，请键入 &lt;code&gt;^R&lt;/code&gt; &amp;ndash;控制键和 &lt;code&gt;r&lt;/code&gt; 键。提示将变为 &lt;code&gt;(reverse-i-search)`':&lt;/code&gt; ,并且在您键入时，搜索查询将出现在引号中。键入查询时，与查询匹配的最新结果将动态更新到冒号右侧。要使用相同的查询查找较旧的结果，只需再次输入 &lt;code&gt;^R&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="486b6c3b28f75c69ec1138bc26e8cd5e151040ee" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; ultimately operates on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt; object, which is in charge of queueing and restarting tasks. When a task calls &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt;&lt;code&gt;Condition&lt;/code&gt;&lt;/a&gt;, the task is marked as non-runnable, added to the condition's queue, and switches to the scheduler. The scheduler will then pick another task to run, or block waiting for external events. If all goes well, eventually an event handler will call &lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt;&lt;code&gt;notify&lt;/code&gt;&lt;/a&gt; on the condition, which causes tasks waiting for that condition to become runnable again.</source>
          <target state="translated">在所有这些情况下，&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;最终都会在&lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt;对象上运行，该对象负责排队和重新启动任务。当任务在&lt;a href=&quot;../../base/parallel/index#Base.Condition&quot;&gt; &lt;code&gt;Condition&lt;/code&gt; &lt;/a&gt;上调用&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;时，该任务被标记为不可运行，添加到条件的队列中，并切换到调度程序。然后，调度程序将选择另一个要运行的任务，或阻止等待外部事件。如果一切顺利，最终事件处理程序将在条件上调用&lt;a href=&quot;../../base/parallel/index#Base.notify&quot;&gt; &lt;code&gt;notify&lt;/code&gt; &lt;/a&gt;，这将导致等待该条件的任务再次变为可运行状态。</target>
        </trans-unit>
        <trans-unit id="a3a06ca6a5caa39934e953da1e9f4336d389c6e0" translate="yes" xml:space="preserve">
          <source>In all these cases, &lt;code&gt;x&lt;/code&gt; is bound to a tuple of the trailing values passed to &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">在所有这些情况下， &lt;code&gt;x&lt;/code&gt; 绑定到传递给 &lt;code&gt;bar&lt;/code&gt; 的尾随值的元组。</target>
        </trans-unit>
        <trans-unit id="b99ce256d318c1c2f2354f48619a6804a821c4e0" translate="yes" xml:space="preserve">
          <source>In an all-to-all topology (the default), all workers connect to each other via plain TCP sockets. The security policy on the cluster nodes must thus ensure free connectivity between workers for the ephemeral port range (varies by OS).</source>
          <target state="translated">在全对全拓扑中(默认情况下),所有工作者都通过普通TCP套接字相互连接。因此,集群节点上的安全策略必须确保工人之间在短暂端口范围内的自由连接(因操作系统而异)。</target>
        </trans-unit>
        <trans-unit id="3c8cda3e1e2865b38c43f81658a24d808d5fe92a" translate="yes" xml:space="preserve">
          <source>In both Julia and MATLAB, the variable &lt;code&gt;ans&lt;/code&gt; is set to the value of the last expression issued in an interactive session. In Julia, unlike MATLAB, &lt;code&gt;ans&lt;/code&gt; is not set when Julia code is run in non-interactive mode.</source>
          <target state="translated">在Julia和MATLAB中，变量 &lt;code&gt;ans&lt;/code&gt; 均设置为在交互式会话中发布的最后一个表达式的值。在Julia中，与MATLAB不同，在非交互模式下运行Julia代码时未设置 &lt;code&gt;ans&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8e4ada1bafffe80f21502163f1a66167c6265bb" translate="yes" xml:space="preserve">
          <source>In both the Julian and help modes of the REPL, one can enter the first few characters of a function or type and then press the tab key to get a list all matches:</source>
          <target state="translated">在REPL的Julian和帮助模式下,可以输入函数或类型的前几个字符,然后按tab键,得到一个所有匹配的列表。</target>
        </trans-unit>
        <trans-unit id="661336deabc49d6bd089fab9e0056b342efe5561" translate="yes" xml:space="preserve">
          <source>In case of remote references, the size of the local reference object is quite small, while the value stored on the remote node may be quite large. Since the local object may not be collected immediately, it is a good practice to explicitly call &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; on local instances of a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt;&lt;code&gt;RemoteChannel&lt;/code&gt;&lt;/a&gt;, or on unfetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Since calling &lt;code&gt;fetch&lt;/code&gt; on a &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; also removes its reference from the remote store, this is not required on fetched &lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt;s. Explicitly calling &lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt;&lt;code&gt;finalize&lt;/code&gt;&lt;/a&gt; results in an immediate message sent to the remote node to go ahead and remove its reference to the value.</source>
          <target state="translated">对于远程引用，本地引用对象的大小很小，而存储在远程节点上的值可能很大。由于可能不会立即收集本地对象，因此优良作法是在&lt;a href=&quot;../../stdlib/distributed/index#Distributed.RemoteChannel&quot;&gt; &lt;code&gt;RemoteChannel&lt;/code&gt; 的&lt;/a&gt;本地实例或未提取的&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;上显式调用&lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; &lt;/a&gt;。由于在&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;上调用 &lt;code&gt;fetch&lt;/code&gt; 还会从远程存储中删除其引用，因此在获取的&lt;a href=&quot;../../stdlib/distributed/index#Distributed.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt;上不需要此操作。显式调用&lt;a href=&quot;../../base/base/index#Base.finalize&quot;&gt; &lt;code&gt;finalize&lt;/code&gt; 会&lt;/a&gt;导致立即向远程节点发送一条消息，以继续操作并删除其对该值的引用。</target>
        </trans-unit>
        <trans-unit id="bf07799a9aab60dca9abdd6af2de0083f4fd55f9" translate="yes" xml:space="preserve">
          <source>In cases where &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; would need to take a Julia object and turn it into a &lt;code&gt;Ptr&lt;/code&gt;, this function should be used to define and perform that conversion.</source>
          <target state="translated">如果&lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;需要使用Julia对象并将其转换为 &lt;code&gt;Ptr&lt;/code&gt; ，则应使用此函数来定义和执行该转换。</target>
        </trans-unit>
        <trans-unit id="62d2a9fdaaf73a0db81376306b368d8784225fa7" translate="yes" xml:space="preserve">
          <source>In cases where &lt;code&gt;x&lt;/code&gt; cannot be safely converted to &lt;code&gt;T&lt;/code&gt;, unlike &lt;a href=&quot;../base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;cconvert&lt;/code&gt; may return an object of a type different from &lt;code&gt;T&lt;/code&gt;, which however is suitable for &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; to handle. The result of this function should be kept valid (for the GC) until the result of &lt;a href=&quot;#Base.unsafe_convert&quot;&gt;&lt;code&gt;unsafe_convert&lt;/code&gt;&lt;/a&gt; is not needed anymore. This can be used to allocate memory that will be accessed by the &lt;code&gt;ccall&lt;/code&gt;. If multiple objects need to be allocated, a tuple of the objects can be used as return value.</source>
          <target state="translated">在无法将 &lt;code&gt;x&lt;/code&gt; 安全转换为 &lt;code&gt;T&lt;/code&gt; 的情况下，与&lt;a href=&quot;../base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;不同， &lt;code&gt;cconvert&lt;/code&gt; 可能返回类型不同于 &lt;code&gt;T&lt;/code&gt; 的对象，但是该对象适合&lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt;处理。该功能的结果（对于GC）应保持有效，直到不再需要&lt;a href=&quot;#Base.unsafe_convert&quot;&gt; &lt;code&gt;unsafe_convert&lt;/code&gt; &lt;/a&gt;的结果为止。这可用于分配 &lt;code&gt;ccall&lt;/code&gt; 将访问的内存。如果需要分配多个对象，则可以将这些对象的元组用作返回值。</target>
        </trans-unit>
        <trans-unit id="20a6a008693353a3bba07852d46b5ac7a61ffe13" translate="yes" xml:space="preserve">
          <source>In cases where you want to be able to mix multiple &lt;code&gt;AbstractArrayStyle&lt;/code&gt;s and keep track of dimensionality, your style needs to support a &lt;a href=&quot;../base/index#Base.Val&quot;&gt;&lt;code&gt;Val&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">如果您希望能够混合使用多个 &lt;code&gt;AbstractArrayStyle&lt;/code&gt; 并跟踪维数，则您的样式需要支持&lt;a href=&quot;../base/index#Base.Val&quot;&gt; &lt;code&gt;Val&lt;/code&gt; &lt;/a&gt;构造函数：</target>
        </trans-unit>
        <trans-unit id="371183813ad83fb61979b332a5033cb1b76e325b" translate="yes" xml:space="preserve">
          <source>In code that performs state changes or uses resources like files, there is typically clean-up work (such as closing files) that needs to be done when the code is finished. Exceptions potentially complicate this task, since they can cause a block of code to exit before reaching its normal end. The &lt;code&gt;finally&lt;/code&gt; keyword provides a way to run some code when a given block of code exits, regardless of how it exits.</source>
          <target state="translated">在执行状态更改或使用资源（如文件）的代码中，通常需要在代码完成后执行清理工作（例如关闭文件）。异常可能会使此任务复杂化，因为异常可能导致代码块在到达正常末端之前退出。当关键字给定的代码块退出时，无论它如何退出， &lt;code&gt;finally&lt;/code&gt; 关键字都提供了一种运行某些代码的方法。</target>
        </trans-unit>
        <trans-unit id="439d8b30359bbc8d6b7d18a09ea082d188e37311" translate="yes" xml:space="preserve">
          <source>In contrast to the use of the &lt;code&gt;...&lt;/code&gt; operator to denote slurping many different arguments into one argument when defining a function, the &lt;code&gt;...&lt;/code&gt; operator is also used to cause a single function argument to be split apart into many different arguments when used in the context of a function call. This use of &lt;code&gt;...&lt;/code&gt; is called splatting:</source>
          <target state="translated">与 &lt;code&gt;...&lt;/code&gt; 操作符表示在定义一个函数时将许多不同的参数混入一个参数相比， &lt;code&gt;...&lt;/code&gt; 操作符还用于将单个函数参数拆分为许多不同的参数，用于...函数调用的上下文。这种使用的 &lt;code&gt;...&lt;/code&gt; 被称为泼洒：</target>
        </trans-unit>
        <trans-unit id="9c8f753b1f6a1a771efd3464599b303870131486" translate="yes" xml:space="preserve">
          <source>In contrast with &lt;code&gt;for i = 1:length(A)&lt;/code&gt;, iterating with &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex&lt;/code&gt;&lt;/a&gt; provides an efficient way to iterate over any array type.</source>
          <target state="translated">与 &lt;code&gt;for i = 1:length(A)&lt;/code&gt; ，使用&lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex&lt;/code&gt; &lt;/a&gt;进行迭代提供了一种有效的方法来迭代任何数组类型。</target>
        </trans-unit>
        <trans-unit id="7142e8f2e408ab35102cc379780cf0e33b4e8234" translate="yes" xml:space="preserve">
          <source>In contrast, once &lt;code&gt;m&lt;/code&gt; is constructed, the type of &lt;code&gt;m.a&lt;/code&gt; cannot change:</source>
          <target state="translated">相反，一旦构造了 &lt;code&gt;m&lt;/code&gt; ， &lt;code&gt;m.a&lt;/code&gt; 的类型就不能改变：</target>
        </trans-unit>
        <trans-unit id="0d5137a043d33963d37d01766416ca959609cfd8" translate="yes" xml:space="preserve">
          <source>In general you can place a &lt;code&gt;return&lt;/code&gt; statement anywhere within a function body, including within deeply nested loops or conditionals, but be careful with &lt;code&gt;do&lt;/code&gt; blocks. For example:</source>
          <target state="translated">通常，您可以在函数体内的任何地方放置 &lt;code&gt;return&lt;/code&gt; 语句，包括在深层嵌套的循环或条件语句中，但要小心 &lt;code&gt;do&lt;/code&gt; 块。例如：</target>
        </trans-unit>
        <trans-unit id="c2d6d0431d403e66982fc3bf0664898813b75b58" translate="yes" xml:space="preserve">
          <source>In general, a broadcast operation is represented by a lazy &lt;code&gt;Broadcasted&lt;/code&gt; container that holds onto the function to be applied alongside its arguments. Those arguments may themselves be more nested &lt;code&gt;Broadcasted&lt;/code&gt; containers, forming a large expression tree to be evaluated. A nested tree of &lt;code&gt;Broadcasted&lt;/code&gt; containers is directly constructed by the implicit dot syntax; &lt;code&gt;5 .+ 2.*x&lt;/code&gt; is transiently represented by &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt;, for example. This is invisible to users as it is immediately realized through a call to &lt;code&gt;copy&lt;/code&gt;, but it is this container that provides the basis for broadcast's extensibility for authors of custom types. The built-in broadcast machinery will then determine the result type and size based upon the arguments, allocate it, and then finally copy the realization of the &lt;code&gt;Broadcasted&lt;/code&gt; object into it with a default &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; method. The built-in fallback &lt;code&gt;broadcast&lt;/code&gt; and &lt;code&gt;broadcast!&lt;/code&gt; methods similarly construct a transient &lt;code&gt;Broadcasted&lt;/code&gt; representation of the operation so they can follow the same codepath. This allows custom array implementations to provide their own &lt;code&gt;copyto!&lt;/code&gt; specialization to customize and optimize broadcasting. This is again determined by the computed broadcast style. This is such an important part of the operation that it is stored as the first type parameter of the &lt;code&gt;Broadcasted&lt;/code&gt; type, allowing for dispatch and specialization.</source>
          <target state="translated">通常，广播操作由惰性 &lt;code&gt;Broadcasted&lt;/code&gt; 容器表示，该容器保留要与参数一起应用的函数。这些参数本身可能是更多嵌套的 &lt;code&gt;Broadcasted&lt;/code&gt; 容器，从而形成了要评估的大型表达式树。 &lt;code&gt;Broadcasted&lt;/code&gt; 容器的嵌套树是通过隐式点语法直接构造的； &lt;code&gt;5 .+ 2.*x&lt;/code&gt; 暂时由 &lt;code&gt;Broadcasted(+, 5, Broadcasted(*, 2, x))&lt;/code&gt; 表示。用户看不到它，因为它是通过调用 &lt;code&gt;copy&lt;/code&gt; 立即实现的，但正是这个容器为自定义类型的作者提供了广播扩展性的基础。然后，内置的广播机制将根据参数确定结果类型和大小，对其进行分配，最后使用默认的 &lt;code&gt;copyto!(::AbstractArray, ::Broadcasted)&lt;/code&gt; 方法将 &lt;code&gt;Broadcasted&lt;/code&gt; 对象的实现复制到其中。内置后备 &lt;code&gt;broadcast&lt;/code&gt; 和 &lt;code&gt;broadcast!&lt;/code&gt; 方法类似地构造操作的瞬时 &lt;code&gt;Broadcasted&lt;/code&gt; 表示，因此它们可以遵循相同的代码路径。这允许自定义数组实现提供自己的 &lt;code&gt;copyto!&lt;/code&gt; 专业定制和优化广播。再次由计算的广播样式确定。这是该操作的重要组成部分，它被存储为 &lt;code&gt;Broadcasted&lt;/code&gt; 类型的第一个类型参数，从而允许分派和专门化。</target>
        </trans-unit>
        <trans-unit id="8d1babd281f2e672316bf23dea36c5ab29827a0a" translate="yes" xml:space="preserve">
          <source>In general, if you have &lt;code&gt;N&lt;/code&gt; samples collected at a line, you can expect an uncertainty on the order of &lt;code&gt;sqrt(N)&lt;/code&gt; (barring other sources of noise, like how busy the computer is with other tasks). The major exception to this rule is garbage collection, which runs infrequently but tends to be quite expensive. (Since Julia's garbage collector is written in C, such events can be detected using the &lt;code&gt;C=true&lt;/code&gt; output mode described below, or by using &lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;.)</source>
          <target state="translated">通常，如果在一行中收集了 &lt;code&gt;N&lt;/code&gt; 个样本，则可以预期 &lt;code&gt;sqrt(N)&lt;/code&gt; 量级的不确定性（除非存在其他噪声源，例如计算机忙于其他任务）。该规则的主要例外是垃圾收集，它很少运行，但是往往很昂贵。 （由于Julia的垃圾收集器是用C编写的，因此可以使用下面介绍的 &lt;code&gt;C=true&lt;/code&gt; 输出模式或使用&lt;a href=&quot;https://github.com/timholy/ProfileView.jl&quot;&gt;ProfileView.jl&lt;/a&gt;来检测此类事件。）</target>
        </trans-unit>
        <trans-unit id="efbd7c168e8e9417f99b66ae892e749285151330" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;for&lt;/code&gt; loop construct can iterate over any container. In these cases, the alternative (but fully equivalent) keyword &lt;code&gt;in&lt;/code&gt; or &lt;code&gt;&amp;isin;&lt;/code&gt; is typically used instead of &lt;code&gt;=&lt;/code&gt;, since it makes the code read more clearly:</source>
          <target state="translated">通常， &lt;code&gt;for&lt;/code&gt; 循环构造可以在任何容器上进行迭代。在这些情况下，通常使用 &lt;code&gt;in&lt;/code&gt; 或 &lt;code&gt;&amp;isin;&lt;/code&gt; 中的替代（但完全等效）关键字代替 &lt;code&gt;=&lt;/code&gt; ，因为它使代码更清晰地读取：</target>
        </trans-unit>
        <trans-unit id="e63801e02d1bdf10fcfad068986ce15007cba3d8" translate="yes" xml:space="preserve">
          <source>In general, the Julia backtick syntax is carefully designed so that you can just cut-and-paste shell commands as is into backticks and they will work: the escaping, quoting, and interpolation behaviors are the same as the shell's. The only difference is that the interpolation is integrated and aware of Julia's notion of what is a single string value, and what is a container for multiple values. Let's try the above two examples in Julia:</source>
          <target state="translated">一般来说,Julia的回标语法是经过精心设计的,因此你可以将shell命令原封不动地剪切粘贴到回标中,它们就可以工作了:转义、引用和插值行为与shell的一样。唯一的区别是插值是集成的,并且知道Julia的概念,即什么是单个字符串值,什么是多个值的容器。让我们在Julia中尝试以上两个例子。</target>
        </trans-unit>
        <trans-unit id="e9d0a19dc1691ca7e9543783f1a58a636105f54f" translate="yes" xml:space="preserve">
          <source>In general, unlike many other technical computing languages, Julia does not expect programs to be written in a vectorized style for performance. Julia's compiler uses type inference and generates optimized code for scalar array indexing, allowing programs to be written in a style that is convenient and readable, without sacrificing performance, and using less memory at times.</source>
          <target state="translated">一般来说,与许多其他技术计算语言不同,Julia并不希望为了性能而以矢量化的风格编写程序。Julia的编译器使用类型推理,并为标量数组索引生成优化的代码,使得程序的编写风格既方便可读,又不牺牲性能,有时还能使用较少的内存。</target>
        </trans-unit>
        <trans-unit id="0aca2d8ec448ee15667ecd2efa9a783d316a76f6" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">通常，您不能假定 &lt;code&gt;display&lt;/code&gt; 输出转到 &lt;code&gt;stdout&lt;/code&gt; （与&lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print(x)&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; 不同&lt;/a&gt;）。例如， &lt;code&gt;display(x)&lt;/code&gt; 可能会打开一个带有图像的单独窗口。 &lt;code&gt;display(x)&lt;/code&gt; 表示&amp;ldquo; 以最佳方式为当前输出设备显示 &lt;code&gt;x&lt;/code&gt; &amp;rdquo;。如果您希望确保将类似于REPL的文本输出转到 &lt;code&gt;stdout&lt;/code&gt; ，请使用&lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="7ec09f4dcceb1c007da785592e4c12f3a7b2638d" translate="yes" xml:space="preserve">
          <source>In general, you cannot assume that &lt;code&gt;display&lt;/code&gt; output goes to &lt;code&gt;stdout&lt;/code&gt; (unlike &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print(x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt;). For example, &lt;code&gt;display(x)&lt;/code&gt; may open up a separate window with an image. &lt;code&gt;display(x)&lt;/code&gt; means &quot;show &lt;code&gt;x&lt;/code&gt; in the best way you can for the current output device(s).&quot; If you want REPL-like text output that is guaranteed to go to &lt;code&gt;stdout&lt;/code&gt;, use &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(stdout, &quot;text/plain&quot;, x)&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421d35772a37767957f94e34c887a2a8d79cd54e" translate="yes" xml:space="preserve">
          <source>In interpreting the results, there are a few important details. Under the &lt;code&gt;user&lt;/code&gt; setting, the first line of any function directly called from the REPL will exhibit allocation due to events that happen in the REPL code itself. More significantly, JIT-compilation also adds to allocation counts, because much of Julia's compiler is written in Julia (and compilation usually requires memory allocation). The recommended procedure is to force compilation by executing all the commands you want to analyze, then call &lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt;&lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt;&lt;/a&gt; to reset all allocation counters. Finally, execute the desired commands and quit Julia to trigger the generation of the &lt;code&gt;.mem&lt;/code&gt; files.</source>
          <target state="translated">在解释结果时，有一些重要的细节。在 &lt;code&gt;user&lt;/code&gt; 设置下，由于REPL代码本身中发生的事件，直接从REPL调用的任何函数的第一行都会显示分配。更重要的是，JIT编译还会增加分配计数，因为Julia的大部分编译器都是用Julia编写的（并且编译通常需要内存分配）。建议的过程是通过执行要分析的所有命令来强制编译，然后调用&lt;a href=&quot;../../stdlib/profile/index#Profile.clear_malloc_data&quot;&gt; &lt;code&gt;Profile.clear_malloc_data()&lt;/code&gt; &lt;/a&gt;以重置所有分配计数器。最后，执行所需的命令并退出Julia以触发 &lt;code&gt;.mem&lt;/code&gt; 文件的生成。</target>
        </trans-unit>
        <trans-unit id="dfcc306e80c7cf321f53ff98ff95ac030d502bfd" translate="yes" xml:space="preserve">
          <source>In loops and &lt;a href=&quot;../arrays/index#man-comprehensions&quot;&gt;comprehensions&lt;/a&gt;, new variables introduced in their body scopes are freshly allocated for each loop iteration, as if the loop body were surrounded by a &lt;code&gt;let&lt;/code&gt; block, as demonstrated by this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b38f63219b850b33b9abc3b16ad8edd611a5f30" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e2766644f11aec36d4590582770e2731974fc5" translate="yes" xml:space="preserve">
          <source>In mainstream object oriented languages, such as C++, Java, Python and Ruby, composite types also have named functions associated with them, and the combination is called an &quot;object&quot;. In purer object-oriented languages, such as Ruby or Smalltalk, all values are objects whether they are composites or not. In less pure object oriented languages, including C++ and Java, some values, such as integers and floating-point values, are not objects, while instances of user-defined composite types are true objects with associated methods. In Julia, all values are objects, but functions are not bundled with the objects they operate on. This is necessary since Julia chooses which method of a function to use by multiple dispatch, meaning that the types of &lt;em&gt;all&lt;/em&gt; of a function's arguments are considered when selecting a method, rather than just the first one (see &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt; for more information on methods and dispatch). Thus, it would be inappropriate for functions to &quot;belong&quot; to only their first argument. Organizing methods into function objects rather than having named bags of methods &quot;inside&quot; each object ends up being a highly beneficial aspect of the language design.</source>
          <target state="translated">在主流的面向对象的语言（例如C ++，Java，Python和Ruby）中，复合类型还具有与之关联的命名函数，这种组合称为&amp;ldquo;对象&amp;rdquo;。在诸如Ruby或Smalltalk之类的纯面向对象的语言中，所有值都是对象，无论它们是否是复合的。在不太纯的面向对象的语言（包括C ++和Java）中，某些值（例如整数和浮点值）不是对象，而用户定义的复合类型的实例是具有关联方法的真实对象。在Julia中，所有值都是对象，但函数并未与其所操作的对象捆绑在一起。这是必要的，因为Julia选择了要通过多次分派使用的函数方法，这意味着&lt;em&gt;所有&lt;/em&gt;类型&lt;em&gt;&lt;/em&gt;选择方法时，将考虑函数的自变量，而不仅仅是第一个（有关方法和调度的更多信息，请参见&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;方法&lt;/a&gt;）。因此，函数仅&amp;ldquo;属于&amp;rdquo;它们的第一个参数是不合适的。将方法组织到功能对象中，而不是在每个对象内部&amp;ldquo;命名&amp;rdquo;方法包，最终成为语言设计的一个非常有益的方面。</target>
        </trans-unit>
        <trans-unit id="eae8b05ff1c12682f8c0f5b0dacd56bde327dcb6" translate="yes" xml:space="preserve">
          <source>In many cases there are in-place versions of matrix operations that allow you to supply a pre-allocated output vector or matrix. This is useful when optimizing critical code in order to avoid the overhead of repeated allocations. These in-place operations are suffixed with &lt;code&gt;!&lt;/code&gt; below (e.g. &lt;code&gt;mul!&lt;/code&gt;) according to the usual Julia convention.</source>
          <target state="translated">在许多情况下，存在矩阵操作的就地版本，可让您提供预分配的输出矢量或矩阵。在优化关键代码以避免重复分配的开销时，这很有用。这些就地操作后缀 &lt;code&gt;!&lt;/code&gt; 根据通常的Julia约定在下面（例如 &lt;code&gt;mul!&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1ed441529eec7f43ad66971217220df4ecd80a6e" translate="yes" xml:space="preserve">
          <source>In many cases, Julia is able to automatically vectorize inner for loops without the use of &lt;code&gt;@simd&lt;/code&gt;. Using &lt;code&gt;@simd&lt;/code&gt; gives the compiler a little extra leeway to make it possible in more situations. In either case, your inner loop should have the following properties to allow vectorization:</source>
          <target state="translated">在许多情况下，Julia无需使用 &lt;code&gt;@simd&lt;/code&gt; 即可自动向量化内部for循环。使用 &lt;code&gt;@simd&lt;/code&gt; 使编译器有更多的余地，以便在更多情况下使用它。无论哪种情况，您的内部循环都应具有以下属性以允许向量化：</target>
        </trans-unit>
        <trans-unit id="36269174e578550d7d7f0601c4aea1c6ce0438f9" translate="yes" xml:space="preserve">
          <source>In many cases, function arguments have sensible default values and therefore might not need to be passed explicitly in every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="translated">在许多情况下，函数参数具有合理的默认值，因此可能不需要在每次调用中都显式传递。例如，来自 &lt;code&gt;Dates&lt;/code&gt; 模块的函数&lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt; &lt;code&gt;Date(y, [m, d])&lt;/code&gt; &lt;/a&gt;为给定的年 &lt;code&gt;y&lt;/code&gt; ，月 &lt;code&gt;m&lt;/code&gt; 和日 &lt;code&gt;d&lt;/code&gt; 构造一个 &lt;code&gt;Date&lt;/code&gt; 类型。但是， &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 参数是可选的，其默认值为 &lt;code&gt;1&lt;/code&gt; 。此行为可以简明表示为：</target>
        </trans-unit>
        <trans-unit id="1dd343721288798b24ab9ba3f9547e7ac41c164d" translate="yes" xml:space="preserve">
          <source>In many cases, it is redundant to provide the type of &lt;code&gt;Point&lt;/code&gt; object one wants to construct, since the types of arguments to the constructor call already implicitly provide type information. For that reason, you can also apply &lt;code&gt;Point&lt;/code&gt; itself as a constructor, provided that the implied value of the parameter type &lt;code&gt;T&lt;/code&gt; is unambiguous:</source>
          <target state="translated">在许多情况下，提供要构造的 &lt;code&gt;Point&lt;/code&gt; 对象的类型是多余的，因为构造函数调用的参数类型已经隐式提供了类型信息。因此，您还可以将 &lt;code&gt;Point&lt;/code&gt; 本身用作构造函数，只要参数类型 &lt;code&gt;T&lt;/code&gt; 的隐含值是明确的：</target>
        </trans-unit>
        <trans-unit id="269254287f284598e6e04a282963713d5ef0932c" translate="yes" xml:space="preserve">
          <source>In many cases, the resolution specified for rounding (e.g., &lt;code&gt;Dates.Second(30)&lt;/code&gt;) divides evenly into the next largest period (in this case, &lt;code&gt;Dates.Minute(1)&lt;/code&gt;). But rounding behaviour in cases in which this is not true may lead to confusion. What is the expected result of rounding a &lt;a href=&quot;#Dates.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; to the nearest 10 hours?</source>
          <target state="translated">在许多情况下，为四舍五入指定的分辨率（例如， &lt;code&gt;Dates.Second(30)&lt;/code&gt; ）平均划分为下一个最大时间段（在这种情况下，为 &lt;code&gt;Dates.Minute(1)&lt;/code&gt; ）。但是在不正确的情况下四舍五入的行为可能会导致混乱。将&lt;a href=&quot;#Dates.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt;舍入到最近的10小时会有什么预期结果？</target>
        </trans-unit>
        <trans-unit id="619846970e9e167e4db1b981435711d687bd4ed9" translate="yes" xml:space="preserve">
          <source>In many languages with optional type declarations, adding declarations is the principal way to make code run faster. This is &lt;em&gt;not&lt;/em&gt; the case in Julia. In Julia, the compiler generally knows the types of all function arguments, local variables, and expressions. However, there are a few specific instances where declarations are helpful.</source>
          <target state="translated">在许多具有可选类型声明的语言中，添加声明是使代码运行更快的主要方法。这是&lt;em&gt;不是&lt;/em&gt;在朱莉娅的情况。在Julia中，编译器通常知道所有函数参数，局部变量和表达式的类型。但是，在某些特定的情况下，声明很有用。</target>
        </trans-unit>
        <trans-unit id="9450b748dbcdb8ba9fd42add95485312cab4012f" translate="yes" xml:space="preserve">
          <source>In mathematics, &lt;code&gt;+&lt;/code&gt; usually denotes a &lt;em&gt;commutative&lt;/em&gt; operation, where the order of the operands does not matter. An example of this is matrix addition, where &lt;code&gt;A + B == B + A&lt;/code&gt; for any matrices &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; that have the same shape. In contrast, &lt;code&gt;*&lt;/code&gt; typically denotes a &lt;em&gt;noncommutative&lt;/em&gt; operation, where the order of the operands &lt;em&gt;does&lt;/em&gt; matter. An example of this is matrix multiplication, where in general &lt;code&gt;A * B != B * A&lt;/code&gt;. As with matrix multiplication, string concatenation is noncommutative: &lt;code&gt;greet * whom != whom * greet&lt;/code&gt;. As such, &lt;code&gt;*&lt;/code&gt; is a more natural choice for an infix string concatenation operator, consistent with common mathematical use.</source>
          <target state="translated">在数学中， &lt;code&gt;+&lt;/code&gt; 通常表示&lt;em&gt;可交换&lt;/em&gt;运算，其中操作数的顺序无关紧要。这样的一个示例是矩阵加法，其中对于具有相同形状的任何矩阵 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; ， &lt;code&gt;A + B == B + A&lt;/code&gt; 。相反， &lt;code&gt;*&lt;/code&gt; 通常表示&lt;em&gt;非交换&lt;/em&gt;操作，其中操作数的顺序&lt;em&gt;确实很&lt;/em&gt;重要。这样的一个例子是矩阵乘法，其中一般而言 &lt;code&gt;A * B != B * A&lt;/code&gt; 。与矩阵乘法一样，字符串连接也是不可交换的： &lt;code&gt;greet * whom != whom * greet&lt;/code&gt; 。因此， &lt;code&gt;*&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; 对于infix字符串连接运算符，这是更自然的选择，与常用的数学用法一致。</target>
        </trans-unit>
        <trans-unit id="d668367cdfd665ad4130e8623549b132951b0865" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities&quot;&gt;below&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8bd1f7589c990d976c1051b69449b020a43727" translate="yes" xml:space="preserve">
          <source>In more complex cases, resolving method ambiguities involves a certain element of design; this topic is explored further &lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">在更复杂的情况下，解决方法的歧义涉及设计的某些元素；该主题将&lt;a href=&quot;#man-method-design-ambiguities-1&quot;&gt;在下面&lt;/a&gt;进一步探讨。</target>
        </trans-unit>
        <trans-unit id="79e9987996de7a2336075063e303687b6133cecc" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;a href=&quot;../../base/math/index#Base.abs&quot;&gt;&lt;code&gt;abs&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4d8bd032078d1d618f689c7b9a8339132970a1" translate="yes" xml:space="preserve">
          <source>In most cases, if &lt;code&gt;A&lt;/code&gt; is a subtype &lt;code&gt;S&lt;/code&gt; of &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; with an element type &lt;code&gt;T&lt;/code&gt; supporting &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;, the return type is &lt;code&gt;LU{T,S{T}}&lt;/code&gt;. If pivoting is chosen (default) the element type should also support &lt;code&gt;abs&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">在大多数情况下，如果 &lt;code&gt;A&lt;/code&gt; 是 &lt;code&gt;AbstractMatrix{T}&lt;/code&gt; 的子类型 &lt;code&gt;S&lt;/code&gt; ，且元素类型 &lt;code&gt;T&lt;/code&gt; 支持 &lt;code&gt;+&lt;/code&gt; ， &lt;code&gt;-&lt;/code&gt; ， &lt;code&gt;*&lt;/code&gt; 和 &lt;code&gt;/&lt;/code&gt; ，则返回类型为 &lt;code&gt;LU{T,S{T}}&lt;/code&gt; 。如果选择了透视（默认），则元素类型也应支持 &lt;code&gt;abs&lt;/code&gt; 和 &lt;code&gt;&amp;lt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b67b5f42c4b6dbeb6aa0f0d5f6894ea2c19994e" translate="yes" xml:space="preserve">
          <source>In order to &lt;a href=&quot;#catch-ctrl-c&quot;&gt;catch CTRL-C&lt;/a&gt; in the script you can use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01897c1c5dfe56ff403bf92da50402dc901b089" translate="yes" xml:space="preserve">
          <source>In order to access the data of x, we can use &lt;code&gt;jl_array_data&lt;/code&gt;:</source>
          <target state="translated">为了访问x的数据，我们可以使用 &lt;code&gt;jl_array_data&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1c8c964572487783a93c9f805bd24c6191a24c97" translate="yes" xml:space="preserve">
          <source>In order to build this program you have to put the path to the Julia header into the include path and link against &lt;code&gt;libjulia&lt;/code&gt;. For instance, when Julia is installed to &lt;code&gt;$JULIA_DIR&lt;/code&gt;, one can compile the above test program &lt;code&gt;test.c&lt;/code&gt; with &lt;code&gt;gcc&lt;/code&gt; using:</source>
          <target state="translated">为了构建该程序，您必须将Julia标头的路径放入include路径，并链接到 &lt;code&gt;libjulia&lt;/code&gt; 。例如，将Julia安装到 &lt;code&gt;$JULIA_DIR&lt;/code&gt; ，可以使用 &lt;code&gt;gcc&lt;/code&gt; 使用以下命令编译上述测试程序 &lt;code&gt;test.c&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f634f39fd97c0fd5eaef9dfae9571e089a9c4f67" translate="yes" xml:space="preserve">
          <source>In order to check whether &lt;code&gt;ret&lt;/code&gt; is of a specific Julia type, we can use the &lt;code&gt;jl_isa&lt;/code&gt;, &lt;code&gt;jl_typeis&lt;/code&gt;, or &lt;code&gt;jl_is_...&lt;/code&gt; functions. By typing &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; into the Julia shell we can see that the return type is &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;double&lt;/code&gt; in C). To convert the boxed Julia value into a C double the &lt;code&gt;jl_unbox_float64&lt;/code&gt; function is used in the above code snippet.</source>
          <target state="translated">为了检查 &lt;code&gt;ret&lt;/code&gt; 是否为特定的Julia类型，我们可以使用 &lt;code&gt;jl_isa&lt;/code&gt; ， &lt;code&gt;jl_typeis&lt;/code&gt; 或 &lt;code&gt;jl_is_...&lt;/code&gt; 函数。通过在Julia Shell中键入 &lt;code&gt;typeof(sqrt(2.0))&lt;/code&gt; ，我们可以看到返回类型为&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;（C语言中为 &lt;code&gt;double&lt;/code&gt; ）。要将框内的Julia值转换为C的两倍，以上代码段中使用了 &lt;code&gt;jl_unbox_float64&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="c26dfd25e758364e0dcd1c617a188ec51d32baad" translate="yes" xml:space="preserve">
          <source>In order to compute trigonometric functions with degrees instead of radians, suffix the function with &lt;code&gt;d&lt;/code&gt;. For example, &lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt;&lt;code&gt;sind(x)&lt;/code&gt;&lt;/a&gt; computes the sine of &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;x&lt;/code&gt; is specified in degrees. The complete list of trigonometric functions with degree variants is:</source>
          <target state="translated">为了使用度数而不是弧度来计算三角函数，请在函数后缀 &lt;code&gt;d&lt;/code&gt; 。例如，&lt;a href=&quot;../../base/math/index#Base.Math.sind&quot;&gt; &lt;code&gt;sind(x)&lt;/code&gt; &lt;/a&gt;计算的正弦值 &lt;code&gt;x&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 是在度指定。具有度数变体的三角函数的完整列表为：</target>
        </trans-unit>
        <trans-unit id="f65b6a7038eae90009481c5aaae33e0c39a02ac4" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;repr(io, mime, x)&lt;/code&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="translated">为了定义一个新的显示后端，一个应首先创建亚型 &lt;code&gt;D&lt;/code&gt; 抽象类的&lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt; &lt;code&gt;AbstractDisplay&lt;/code&gt; &lt;/a&gt;。然后，对于可以在 &lt;code&gt;D&lt;/code&gt; 上显示的每种MIME类型（ &lt;code&gt;mime&lt;/code&gt; 字符串），应该定义一个函数 &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; ，将 &lt;code&gt;x&lt;/code&gt; 显示为该MIME类型，通常通过调用&lt;a href=&quot;#Base.show-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;show(io, mime, x)&lt;/code&gt; &lt;/a&gt;或 &lt;code&gt;repr(io, mime, x)&lt;/code&gt; 。甲&lt;a href=&quot;../base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;如果应甩 &lt;code&gt;x&lt;/code&gt; 不能被显示为MIME类型;如果一个呼叫 &lt;code&gt;show&lt;/code&gt; 或 &lt;code&gt;repr&lt;/code&gt; 这是自动的。最后，应该定义一个函数 &lt;code&gt;display(d::D, x)&lt;/code&gt; 查询&lt;a href=&quot;#Base.Multimedia.showable&quot;&gt; &lt;code&gt;showable(mime, x)&lt;/code&gt; &lt;/a&gt;以获取 &lt;code&gt;D&lt;/code&gt; 支持的 &lt;code&gt;mime&lt;/code&gt; 类型并显示&amp;ldquo;最佳&amp;rdquo;一个；一个 &lt;code&gt;MethodError&lt;/code&gt; 如果没有支持的MIME类型的发现应甩 &lt;code&gt;x&lt;/code&gt; 。同样，某些子类型可能希望覆盖&lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt; &lt;code&gt;redisplay(d::D, ...)&lt;/code&gt; &lt;/a&gt;。 （同样，应该 &lt;code&gt;import Base.display&lt;/code&gt; 以添加新的 &lt;code&gt;display&lt;/code&gt; 方法。）这些函数的返回值取决于实现（因为在某些情况下，返回某种类型的显示&amp;ldquo;句柄&amp;rdquo;可能很有用）。然后可以直接调用 &lt;code&gt;D&lt;/code&gt; 的显示函数，但也可以从&lt;a href=&quot;#Base.Multimedia.display&quot;&gt; &lt;code&gt;display(x)&lt;/code&gt; &lt;/a&gt;自动调用它们 只需使用以下命令将新的显示推入显示后端堆栈：</target>
        </trans-unit>
        <trans-unit id="704ebdff29ebf61fba245cec0a90e4a3393b7079" translate="yes" xml:space="preserve">
          <source>In order to define a new display backend, one should first create a subtype &lt;code&gt;D&lt;/code&gt; of the abstract class &lt;a href=&quot;#Base.Multimedia.AbstractDisplay&quot;&gt;&lt;code&gt;AbstractDisplay&lt;/code&gt;&lt;/a&gt;. Then, for each MIME type (&lt;code&gt;mime&lt;/code&gt; string) that can be displayed on &lt;code&gt;D&lt;/code&gt;, one should define a function &lt;code&gt;display(d::D, ::MIME&quot;mime&quot;, x) = ...&lt;/code&gt; that displays &lt;code&gt;x&lt;/code&gt; as that MIME type, usually by calling &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(io, mime, x)&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#Base.repr-Tuple%7BMIME,Any%7D&quot;&gt;&lt;code&gt;repr(io, mime, x)&lt;/code&gt;&lt;/a&gt;. A &lt;a href=&quot;../base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt; should be thrown if &lt;code&gt;x&lt;/code&gt; cannot be displayed as that MIME type; this is automatic if one calls &lt;code&gt;show&lt;/code&gt; or &lt;code&gt;repr&lt;/code&gt;. Finally, one should define a function &lt;code&gt;display(d::D, x)&lt;/code&gt; that queries &lt;a href=&quot;#Base.Multimedia.showable&quot;&gt;&lt;code&gt;showable(mime, x)&lt;/code&gt;&lt;/a&gt; for the &lt;code&gt;mime&lt;/code&gt; types supported by &lt;code&gt;D&lt;/code&gt; and displays the &quot;best&quot; one; a &lt;code&gt;MethodError&lt;/code&gt; should be thrown if no supported MIME types are found for &lt;code&gt;x&lt;/code&gt;. Similarly, some subtypes may wish to override &lt;a href=&quot;#Base.Multimedia.redisplay&quot;&gt;&lt;code&gt;redisplay(d::D, ...)&lt;/code&gt;&lt;/a&gt;. (Again, one should &lt;code&gt;import Base.display&lt;/code&gt; to add new methods to &lt;code&gt;display&lt;/code&gt;.) The return values of these functions are up to the implementation (since in some cases it may be useful to return a display &quot;handle&quot; of some type). The display functions for &lt;code&gt;D&lt;/code&gt; can then be called directly, but they can also be invoked automatically from &lt;a href=&quot;#Base.Multimedia.display&quot;&gt;&lt;code&gt;display(x)&lt;/code&gt;&lt;/a&gt; simply by pushing a new display onto the display-backend stack with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc544618a386ab5d58649ad21c68fc6a33673b83" translate="yes" xml:space="preserve">
          <source>In order to define automatically the values of this dictionary at startup time, one can use the &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; function in the &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; file, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c036b6a91aa7223777701c5e046f12ec492ccc" translate="yes" xml:space="preserve">
          <source>In order to define random generation out of objects of type &lt;code&gt;S&lt;/code&gt;, the following method should be defined: &lt;code&gt;rand(rng::AbstractRNG, sp::Random.SamplerTrivial{S})&lt;/code&gt;. Here, &lt;code&gt;sp&lt;/code&gt; simply wraps an object of type &lt;code&gt;S&lt;/code&gt;, which can be accessed via &lt;code&gt;sp[]&lt;/code&gt;. Continuing the &lt;code&gt;Die&lt;/code&gt; example, we want now to define &lt;code&gt;rand(d::Die)&lt;/code&gt; to produce an &lt;code&gt;Int&lt;/code&gt; corresponding to one of &lt;code&gt;d&lt;/code&gt;'s sides:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fa42e97ec0c0f5639428f8bc25c0313c261f3b" translate="yes" xml:space="preserve">
          <source>In order to dispatch a multi-level parametric argument list, often it is best to separate each level of dispatch into distinct functions. This may sound similar in approach to single-dispatch, but as we shall see below, it is still more flexible.</source>
          <target state="translated">为了调度一个多级参数列表,通常最好将每一级的调度分离成不同的函数。这在方法上听起来可能与单调度类似,但正如我们在下面将看到的那样,它还是比较灵活的。</target>
        </trans-unit>
        <trans-unit id="c64f4c986b251a9a23920c12ed0e829f663e97f9" translate="yes" xml:space="preserve">
          <source>In order to implement such a &lt;code&gt;copy&lt;/code&gt; or &lt;code&gt;copyto!&lt;/code&gt;, method, of course, you must work with the &lt;code&gt;Broadcasted&lt;/code&gt; wrapper to compute each element. There are two main ways of doing so:</source>
          <target state="translated">为了实现这样的 &lt;code&gt;copy&lt;/code&gt; 或 &lt;code&gt;copyto!&lt;/code&gt; 当然，您必须使用 &lt;code&gt;Broadcasted&lt;/code&gt; 包装器来计算每个元素。这样做的主要方法有两种：</target>
        </trans-unit>
        <trans-unit id="7c65ae2a5b36599056aee26d3163a0e9101f727b" translate="yes" xml:space="preserve">
          <source>In order to losslessly represent arbitrary byte streams stored in a &lt;code&gt;String&lt;/code&gt;, a &lt;code&gt;Char&lt;/code&gt; value may store information that cannot be converted to a Unicode codepoint &amp;mdash; converting such a &lt;code&gt;Char&lt;/code&gt; to &lt;code&gt;UInt32&lt;/code&gt; will throw an error. The &lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;isvalid(c::Char)&lt;/code&gt;&lt;/a&gt; function can be used to query whether &lt;code&gt;c&lt;/code&gt; represents a valid Unicode character.</source>
          <target state="translated">为了无损地表示存储在 &lt;code&gt;String&lt;/code&gt; 中的任意字节流， &lt;code&gt;Char&lt;/code&gt; 值可以存储无法转换为Unicode代码点的信息-将此类 &lt;code&gt;Char&lt;/code&gt; 转换为 &lt;code&gt;UInt32&lt;/code&gt; 会引发错误。所述&lt;a href=&quot;#Base.isvalid-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;isvalid(c::Char)&lt;/code&gt; &lt;/a&gt;是否函数可以用来查询 &lt;code&gt;c&lt;/code&gt; 表示有效的Unicode字符。</target>
        </trans-unit>
        <trans-unit id="fab91460cbe612949b4b9d95753296ca7abe3d3b" translate="yes" xml:space="preserve">
          <source>In order to pass this function to C, we obtain its address using the macro &lt;code&gt;@cfunction&lt;/code&gt;:</source>
          <target state="translated">为了将此函数传递给C，我们使用 &lt;code&gt;@cfunction&lt;/code&gt; 宏获取其地址：</target>
        </trans-unit>
        <trans-unit id="cd5618b4a563dff2d7a927d5353ef78a361df290" translate="yes" xml:space="preserve">
          <source>In order to refer to &lt;code&gt;MyType&lt;/code&gt; across all processes, &lt;code&gt;DummyModule.jl&lt;/code&gt; needs to be loaded on every process. Calling &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; loads it only on a single process. To load it on every process, use the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt;&lt;code&gt;@everywhere&lt;/code&gt;&lt;/a&gt; macro (starting Julia with &lt;code&gt;julia -p 2&lt;/code&gt;):</source>
          <target state="translated">为了在所有进程中引用 &lt;code&gt;MyType&lt;/code&gt; ，需要在每个进程上加载 &lt;code&gt;DummyModule.jl&lt;/code&gt; 。调用 &lt;code&gt;include(&quot;DummyModule.jl&quot;)&lt;/code&gt; 仅在单个进程上加载它。要在每个进程上加载它，请使用&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@everywhere&quot;&gt; &lt;code&gt;@everywhere&lt;/code&gt; &lt;/a&gt;宏（以 &lt;code&gt;julia -p 2&lt;/code&gt; 开头Julia ）：</target>
        </trans-unit>
        <trans-unit id="47f30e462ec98fcc58c9494bb836f85ec8257aff" translate="yes" xml:space="preserve">
          <source>In order to support mutation, such objects are generally allocated on the heap, and have stable memory addresses. A mutable object is like a little container that might hold different values over time, and so can only be reliably identified with its address. In contrast, an instance of an immutable type is associated with specific field values &amp;ndash;- the field values alone tell you everything about the object. In deciding whether to make a type mutable, ask whether two instances with the same field values would be considered identical, or if they might need to change independently over time. If they would be considered identical, the type should probably be immutable.</source>
          <target state="translated">为了支持变异，此类对象通常在堆上分配，并具有稳定的内存地址。可变对象就像一个小容器，随着时间的推移可能具有不同的值，因此只能通过其地址可靠地进行标识。相反，不可变类型的实例与特定的字段值相关联-单独的字段值可以告诉您有关对象的所有信息。在确定是否使类型可变时，请问是否具有相同字段值的两个实例将被视为相同，或者是否可能需要随时间进行独立更改。如果将它们视为相同，则类型可能应该是不变的。</target>
        </trans-unit>
        <trans-unit id="2f2293a5b64eabd8ff88bd22ea606404b9b1e108" translate="yes" xml:space="preserve">
          <source>In other circumstances, it is handy to be able to stop an iteration and move on to the next one immediately. The &lt;code&gt;continue&lt;/code&gt; keyword accomplishes this:</source>
          <target state="translated">在其他情况下，能够停止迭代并立即继续进行下一个迭代很方便。在 &lt;code&gt;continue&lt;/code&gt; 关键字实现这一点：</target>
        </trans-unit>
        <trans-unit id="c004c636d1b0703eca9cda2590edfd6579e7129c" translate="yes" xml:space="preserve">
          <source>In other words, &lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt;&lt;code&gt;isa(A,Type{B})&lt;/code&gt;&lt;/a&gt; is true if and only if &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are the same object and that object is a type. Without the parameter, &lt;code&gt;Type&lt;/code&gt; is simply an abstract type which has all type objects as its instances, including, of course, singleton types:</source>
          <target state="translated">换句话说，当且仅当 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 是同一对象并且该对象是类型时，&lt;a href=&quot;../../base/base/index#Core.isa&quot;&gt; &lt;code&gt;isa(A,Type{B})&lt;/code&gt; &lt;/a&gt;为true 。没有参数， &lt;code&gt;Type&lt;/code&gt; 只是一个抽象类型，它以所有类型对象作为其实例，当然包括单例类型：</target>
        </trans-unit>
        <trans-unit id="fb4e1a8fb772b24b6039451c201b81e5c718d91a" translate="yes" xml:space="preserve">
          <source>In other words, in the parlance of type theory, Julia's type parameters are &lt;em&gt;invariant&lt;/em&gt;, rather than being &lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;covariant (or even contravariant)&lt;/a&gt;. This is for practical reasons: while any instance of &lt;code&gt;Point{Float64}&lt;/code&gt; may conceptually be like an instance of &lt;code&gt;Point{Real}&lt;/code&gt; as well, the two types have different representations in memory:</source>
          <target state="translated">换句话说，以类型论的说法，Julia的类型参数是&lt;em&gt;不变的&lt;/em&gt;，而不是&lt;a href=&quot;https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29&quot;&gt;协变的（甚至&lt;/a&gt;是协变的）。这是出于实际原因：虽然 &lt;code&gt;Point{Float64}&lt;/code&gt; 任何实例在概念上也可能类似于 &lt;code&gt;Point{Real}&lt;/code&gt; 的实例，但两种类型在内存中具有不同的表示形式：</target>
        </trans-unit>
        <trans-unit id="2489400c16a870eb77390027298b5bae2afac7fd" translate="yes" xml:space="preserve">
          <source>In particular this means that overlong and too-high code unit sequences and prefixes thereof are treated as a single invalid character rather than multiple invalid characters. This rule may be best explained with an example:</source>
          <target state="translated">特别是这意味着,过长和过高的代码单元序列及其前缀被视为单个无效字符,而不是多个无效字符。这个规则最好用一个例子来解释。</target>
        </trans-unit>
        <trans-unit id="86e6d7b557572810776afd763390d8c87a4b9b3f" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="translated">特别地， &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; 通常是一个&amp;ldquo;漂亮印刷版&amp;rdquo; &lt;code&gt;x&lt;/code&gt; 设计用于人类消费。另请参见 &lt;code&gt;repr(x)&lt;/code&gt; 以代替返回与&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show(x)&lt;/code&gt; &lt;/a&gt;相对应的字符串，该字符串可能更接近 &lt;code&gt;x&lt;/code&gt; 在Julia中输入的值。</target>
        </trans-unit>
        <trans-unit id="44f2256825b7ba89fb1041db2fbe0f7cb5785da9" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;repr(&quot;text/plain&quot;, x)&lt;/code&gt; is typically a &quot;pretty-printed&quot; version of &lt;code&gt;x&lt;/code&gt; designed for human consumption. See also &lt;code&gt;repr(x)&lt;/code&gt; to instead return a string corresponding to &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show(x)&lt;/code&gt;&lt;/a&gt; that may be closer to how the value of &lt;code&gt;x&lt;/code&gt; would be entered in Julia.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a352a9e712137ef0293428d01a95dc381f03f45f" translate="yes" xml:space="preserve">
          <source>In particular, if you define a &lt;code&gt;function __init__()&lt;/code&gt; in a module, then Julia will call &lt;code&gt;__init__()&lt;/code&gt; immediately &lt;em&gt;after&lt;/em&gt; the module is loaded (e.g., by &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;using&lt;/code&gt;, or &lt;code&gt;require&lt;/code&gt;) at runtime for the &lt;em&gt;first&lt;/em&gt; time (i.e., &lt;code&gt;__init__&lt;/code&gt; is only called once, and only after all statements in the module have been executed). Because it is called after the module is fully imported, any submodules or other imported modules have their &lt;code&gt;__init__&lt;/code&gt; functions called &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;__init__&lt;/code&gt; of the enclosing module.</source>
          <target state="translated">特别是，如果你定义一个 &lt;code&gt;function __init__()&lt;/code&gt; 的模块中，然后朱莉娅将调用 &lt;code&gt;__init__()&lt;/code&gt; 立即&lt;em&gt;之后&lt;/em&gt;加载模块（例如，通过 &lt;code&gt;import&lt;/code&gt; ， &lt;code&gt;using&lt;/code&gt; ，或 &lt;code&gt;require&lt;/code&gt; 在运行时）在&lt;em&gt;第一&lt;/em&gt;时间（即， &lt;code&gt;__init__&lt;/code&gt; 是仅被调用一次，并且仅在模块中的所有语句均已执行之后）。因为是在完全导入模块之后调用的，所以任何子模块或其他导入的模块都会在封闭模块的 &lt;code&gt;__init__&lt;/code&gt; &lt;em&gt;之前&lt;/em&gt;调用其 &lt;code&gt;__init__&lt;/code&gt; 函数。&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f00fe64f586624c25d908def02434ca5a5747cc" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;LibGit2.free&lt;/code&gt; should be called afterward on the &lt;code&gt;Ref&lt;/code&gt; object.</source>
          <target state="translated">特别要注意， &lt;code&gt;LibGit2.free&lt;/code&gt; 应在 &lt;code&gt;Ref&lt;/code&gt; 对象上调用LibGit2.free。</target>
        </trans-unit>
        <trans-unit id="1b992ee319e3397f73ab42aa368ea422a279c258" translate="yes" xml:space="preserve">
          <source>In particular, note that &lt;code&gt;missing == missing&lt;/code&gt; returns &lt;code&gt;missing&lt;/code&gt;, so &lt;code&gt;==&lt;/code&gt; cannot be used to test whether a value is missing. To test whether &lt;code&gt;x&lt;/code&gt; is &lt;code&gt;missing&lt;/code&gt;, use &lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt;&lt;code&gt;ismissing(x)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">特别要注意的是， &lt;code&gt;missing == missing&lt;/code&gt; 返回 &lt;code&gt;missing&lt;/code&gt; ，因此 &lt;code&gt;==&lt;/code&gt; 不能用于测试值是否缺失。要测试 &lt;code&gt;x&lt;/code&gt; 是否 &lt;code&gt;missing&lt;/code&gt; ，请使用&lt;a href=&quot;../../base/base/index#Base.ismissing&quot;&gt; &lt;code&gt;ismissing(x)&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="10aa2526d9c8eb28f8fc8b12b251cb66391f9afe" translate="yes" xml:space="preserve">
          <source>In particular, this means that small enough immutable values like integers and floats are typically passed to functions in registers (or stack allocated).</source>
          <target state="translated">特别是,这意味着像整数和浮点数这样的足够小的不可变的值通常会被传递给寄存器(或堆栈分配)中的函数。</target>
        </trans-unit>
        <trans-unit id="bd271b290661f2d2dcd371ac877e792e11b0ae4c" translate="yes" xml:space="preserve">
          <source>In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent to writing:</source>
          <target state="translated">取代书面语法,宏调用在解析时扩展到它的返回结果。这就相当于写。</target>
        </trans-unit>
        <trans-unit id="f1faf89b83d5028304b1044be098d4330cb094e6" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在实践中，尤其是在提供可重用功能时，通常将&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;用途包装在Julia函数中，以建立参数，然后以C或Fortran函数指示它们的任何方式检查错误，并传播给Julia调用方作为异常。这一点特别重要，因为众所周知，C和Fortran API在指示错误情况的方式上是不一致的。例如， &lt;code&gt;getenv&lt;/code&gt; C库函数包装在以下Julia函数中，该函数是&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt; &lt;code&gt;env.jl&lt;/code&gt; 中&lt;/a&gt;实际定义的简化版本：</target>
        </trans-unit>
        <trans-unit id="4ee03fd7f1bb01022cf62529b6c1e2c9383e98c5" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function specifies. And if an error occurs it is thrown as a normal Julia exception. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="804d748c80f6e79bb9e342f1f2304330f7eae29d" translate="yes" xml:space="preserve">
          <source>In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.</source>
          <target state="translated">原则上,Markdown解析器本身也可以通过软件包任意扩展,或者使用完全自定义的Markdown风味,但一般来说应该没有必要。</target>
        </trans-unit>
        <trans-unit id="f1e4e6ce2511929e6de42c91eafd73bc415389d8" translate="yes" xml:space="preserve">
          <source>In short, it is an immutable dictionary that is a subclass of &lt;code&gt;IO&lt;/code&gt;. It supports standard dictionary operations such as &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, and can also be used as an I/O stream.</source>
          <target state="translated">简而言之，它是不可变的字典，是 &lt;code&gt;IO&lt;/code&gt; 的子类。它支持标准字典操作，如&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;，也可以用作I / O流。</target>
        </trans-unit>
        <trans-unit id="638b74bbfc0d77182896b29b38f7e41990e9ec77" translate="yes" xml:space="preserve">
          <source>In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise. For example, instead of initializing &lt;code&gt;a&lt;/code&gt; with zeros, initialize it with:</source>
          <target state="translated">在某些应用中，将零下数归零的一种替代方法是注入一点噪声。例如，不要用零初始化 &lt;code&gt;a&lt;/code&gt; ，而是用：</target>
        </trans-unit>
        <trans-unit id="c0f7478a3f0be2e5b9c7e0905c13888f63fbab1a" translate="yes" xml:space="preserve">
          <source>In some applications, it is convenient to store explicit zero values in a &lt;code&gt;SparseMatrixCSC&lt;/code&gt;. These &lt;em&gt;are&lt;/em&gt; accepted by functions in &lt;code&gt;Base&lt;/code&gt; (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The &lt;a href=&quot;#SparseArrays.nnz&quot;&gt;&lt;code&gt;nnz&lt;/code&gt;&lt;/a&gt; function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use &lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt;&lt;code&gt;count(!iszero, x)&lt;/code&gt;&lt;/a&gt;, which inspects every stored element of a sparse matrix. &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;, and the in-place &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;, can be used to remove stored zeros from the sparse matrix.</source>
          <target state="translated">在某些应用程序中，在 &lt;code&gt;SparseMatrixCSC&lt;/code&gt; 中存储显式零值很方便。这些&lt;em&gt;被&lt;/em&gt; &lt;code&gt;Base&lt;/code&gt; 中的函数接受（但不能保证它们会在变异操作中保留）。这样的显式存储的零被许多例程视为结构非零。所述&lt;a href=&quot;#SparseArrays.nnz&quot;&gt; &lt;code&gt;nnz&lt;/code&gt; &lt;/a&gt;函数返回明确地存储在稀疏数据结构元素，包括结构非零元素的个数。为了计算数字非零的确切数量，请使用&lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt; &lt;code&gt;count(!iszero, x)&lt;/code&gt; &lt;/a&gt;，它检查稀疏矩阵的每个存储元素。&lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; &lt;/a&gt;和就地&lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt;可用于从稀疏矩阵中删除存储的零。</target>
        </trans-unit>
        <trans-unit id="7200ec90f922f3162b688616528f07bbd46b3f3f" translate="yes" xml:space="preserve">
          <source>In some cases changing the value of a &lt;code&gt;const&lt;/code&gt; variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.</source>
          <target state="translated">在某些情况下，更改 &lt;code&gt;const&lt;/code&gt; 变量的值会发出警告而不是错误。但是，这可能会导致无法预测的行为或破坏程序的状态，因此应避免使用。此功能仅是为了方便交互使用。</target>
        </trans-unit>
        <trans-unit id="0bca4b7af7b2c3f590b22d6bdc9c439dda8d86d1" translate="yes" xml:space="preserve">
          <source>In some cases it might be convenient not to have to define &lt;code&gt;MyStyle&lt;/code&gt;, in which case you can leverage one of the general broadcast wrappers:</source>
          <target state="translated">在某些情况下，不必定义 &lt;code&gt;MyStyle&lt;/code&gt; 可能会很方便，在这种情况下，您可以利用常规广播包装器之一：</target>
        </trans-unit>
        <trans-unit id="6f5f29a98f7076181fba48634a540b92f8996002" translate="yes" xml:space="preserve">
          <source>In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called &lt;em&gt;parallel map&lt;/em&gt;, implemented in Julia as the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; function. For example, we could compute the singular values of several large random matrices in parallel as follows:</source>
          <target state="translated">在某些情况下，不需要归约运算符，而我们仅希望将函数应用于某个范围内的所有整数（或更笼统地说，应用于某个集合中的所有元素）。这是另一个有用的操作，称为&lt;em&gt;并行映射&lt;/em&gt;，在Julia中作为&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;函数实现。例如，我们可以并行计算以下几个大型随机矩阵的奇异值：</target>
        </trans-unit>
        <trans-unit id="6de51e42bc98441adfec5061cc53937870969a7a" translate="yes" xml:space="preserve">
          <source>In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for &lt;code&gt;MersenneTwister&lt;/code&gt;, which natively writes random values in an array.</source>
          <target state="translated">在某些情况下，对于给定的RNG类型，使用专用方法生成随机值数组可能比仅使用之前说明的解耦技术更有效。例如， &lt;code&gt;MersenneTwister&lt;/code&gt; 就是这种情况，它本机将随机值写入数组。</target>
        </trans-unit>
        <trans-unit id="f953f89be50274569ebdd1d16dd1091ac2cf9f4a" translate="yes" xml:space="preserve">
          <source>In some cases, it is useful to adjust the behavior of &lt;code&gt;show&lt;/code&gt; methods depending on the context. This can be achieved via the &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; type, which allows passing contextual properties together with a wrapped IO stream. For example, we can build a shorter representation in our &lt;code&gt;show&lt;/code&gt; method when the &lt;code&gt;:compact&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, falling back to the long representation if the property is &lt;code&gt;false&lt;/code&gt; or absent:</source>
          <target state="translated">在某些情况下，根据上下文调整 &lt;code&gt;show&lt;/code&gt; 方法的行为很有用。这可以通过&lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;类型实现，该类型允许将上下文属性与包装的IO流一起传递。例如，当 &lt;code&gt;:compact&lt;/code&gt; 属性设置为 &lt;code&gt;true&lt;/code&gt; 时，可以在 &lt;code&gt;show&lt;/code&gt; 方法中构建一个较短的表示形式，如果该属性为 &lt;code&gt;false&lt;/code&gt; 或不存在，则退回到长表示形式：</target>
        </trans-unit>
        <trans-unit id="ef681cb1496bc3731bd754661d5504701ec7c4ad" translate="yes" xml:space="preserve">
          <source>In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the &lt;code&gt;Sampler&lt;/code&gt; constructor. Let's assume we defined two helper types for &lt;code&gt;Die&lt;/code&gt;, say &lt;code&gt;SamplerDie1&lt;/code&gt; which should be used to generate only few random values, and &lt;code&gt;SamplerDieMany&lt;/code&gt; for many values. We can use those types as follows:</source>
          <target state="translated">在某些情况下，是只生成少量值还是生成大量值都会影响算法的选择。这是通过 &lt;code&gt;Sampler&lt;/code&gt; 构造函数的第三个参数处理的。假设我们定义了两个帮手类型 &lt;code&gt;Die&lt;/code&gt; ，说 &lt;code&gt;SamplerDie1&lt;/code&gt; 它应该被用来生成只有少数的随机值，并 &lt;code&gt;SamplerDieMany&lt;/code&gt; 许多值。我们可以按如下方式使用这些类型：</target>
        </trans-unit>
        <trans-unit id="a8e2e50c5e5c4d32f74208fde4cbb36b4d6312f3" translate="yes" xml:space="preserve">
          <source>In some languages, the empty tuple (&lt;code&gt;()&lt;/code&gt;) is considered the canonical form of nothingness. However, in julia it is best thought of as just a regular tuple that happens to contain zero values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5807b7c193c64d46f5bc3d42f551af1a206e90" translate="yes" xml:space="preserve">
          <source>In some problems, the various pieces of required work are not naturally related by function calls; there is no obvious &quot;caller&quot; or &quot;callee&quot; among the jobs that need to be done. An example is the producer-consumer problem, where one complex procedure is generating values and another complex procedure is consuming them. The consumer cannot simply call a producer function to get a value, because the producer may have more values to generate and so might not yet be ready to return. With tasks, the producer and consumer can both run as long as they need to, passing values back and forth as necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bc7cae3ed284ebaa58a72dfb5ca4f122d19b91" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793adcc5e6d1a8b0006e672f0871fab8bd1ee12e" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools-1&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="translated">在某些情况下，您的函数可能需要分配内存作为其操作的一部分，这会使上面的简单图片变得复杂。在这种情况下，请考虑使用以下&lt;a href=&quot;#tools-1&quot;&gt;工具&lt;/a&gt;之一来诊断问题，或编写将您的分配与算法方面分开的函数版本（请参见&lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;预分配输出&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2a0f5f99ad11403dc52acb366ff631558f32f389" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; for the tests.</source>
          <target state="translated">在下面的步骤2中，编辑 &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; 以更改源代码，并 &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; 以进行测试。</target>
        </trans-unit>
        <trans-unit id="18fa22072854af164b60f3647ea657dba3a66a38" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and create any test file of your choosing.</source>
          <target state="translated">在下面的步骤2中，编辑 &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; 以更改源代码，并创建您选择的任何测试文件。</target>
        </trans-unit>
        <trans-unit id="4a0eaae9f72d9710fb65a9583dfc845568e81d5f" translate="yes" xml:space="preserve">
          <source>In such cases one should redesign the code to avoid the possibility of a race condition or use &lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;synchronization primitives&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，应该重新设计代码，以避免发生竞争状况或使用&lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;同步原语&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e9e71bba5509813057399a4f8d90c9c53704d76" translate="yes" xml:space="preserve">
          <source>In such cases, the result is always 1-d.</source>
          <target state="translated">在这种情况下,结果总是1-d。</target>
        </trans-unit>
        <trans-unit id="de5de110f5af15ec4cd1a61e4b555c94b532b3cc" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c795388eedec3a869fe287bc8b5bbacb71a43dbd" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="translated">在技​​术计算语言中，通常有函数的&amp;ldquo;向量化&amp;rdquo;版本，这些版本仅将给定函数 &lt;code&gt;f(x)&lt;/code&gt; 应用于数组 &lt;code&gt;A&lt;/code&gt; 的每个元素，以通过 &lt;code&gt;f(A)&lt;/code&gt; 生成新数组。这种语法对于数据处理很方便，但是在其他语言中，性能通常也需要向量化：如果循环很慢，则函数的&amp;ldquo;向量化&amp;rdquo;版本可以调用以低级语言编写的快速库代码。在Julia中，矢量化函数&lt;em&gt;并不是&lt;/em&gt;执行性能所必需的，实际上编写自己的循环通常是有好处的（请参见&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;），但是它们仍然很方便。因此，&lt;em&gt;任何&lt;/em&gt; Julia函数 &lt;code&gt;f&lt;/code&gt; 可以使用语法 &lt;code&gt;f.(A)&lt;/code&gt; 逐元素地应用于任何数组（或其他集合）。例如，可以将 &lt;code&gt;sin&lt;/code&gt; 应用于向量 &lt;code&gt;A&lt;/code&gt; 中的所有元素，如下所示：</target>
        </trans-unit>
        <trans-unit id="1295513c71d65c30e7efa46afbaa35e5c9e76740" translate="yes" xml:space="preserve">
          <source>In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to by both &lt;code&gt;echo&lt;/code&gt; processes, and the other end of the pipe is read from by the &lt;code&gt;sort&lt;/code&gt; command.</source>
          <target state="translated">就UNIX管道而言，这里发生的是两个 &lt;code&gt;echo&lt;/code&gt; 进程都创建并写入了一个UNIX管道对象，而 &lt;code&gt;sort&lt;/code&gt; 命令从管道的另一端读取了管道对象。</target>
        </trans-unit>
        <trans-unit id="bc29b396f06d90d9310efc41817564ce48560df4" translate="yes" xml:space="preserve">
          <source>In the Julia REPL and several other Julia editing environments, you can type many Unicode math symbols by typing the backslashed LaTeX symbol name followed by tab. For example, the variable name &lt;code&gt;&amp;delta;&lt;/code&gt; can be entered by typing &lt;code&gt;\delta&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;, or even &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; by &lt;code&gt;\alpha&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\hat&lt;/code&gt;- &lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\_2&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;. (If you find a symbol somewhere, e.g. in someone else's code, that you don't know how to type, the REPL help will tell you: just type &lt;code&gt;?&lt;/code&gt; and then paste the symbol.)</source>
          <target state="translated">在Julia REPL和其他几个Julia编辑环境中，您可以通过键入反斜杠LaTeX符号名称后跟制表符来键入许多Unicode数学符号。例如，变量名 &lt;code&gt;&amp;delta;&lt;/code&gt; 可以通过打字输入 &lt;code&gt;\delta&lt;/code&gt; - &lt;em&gt;标签&lt;/em&gt;，或甚至 &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; 通过 &lt;code&gt;\alpha&lt;/code&gt; - &lt;em&gt;标签&lt;/em&gt; - &lt;code&gt;\hat&lt;/code&gt; - &lt;em&gt;标签&lt;/em&gt; - &lt;code&gt;\_2&lt;/code&gt; - &lt;em&gt;标签&lt;/em&gt;。 （如果您在某个地方（例如在他人的代码中）发现不知道如何键入的符号，则REPL帮助将告诉您：只需键入 &lt;code&gt;?&lt;/code&gt; ，然后粘贴该符号即可。）</target>
        </trans-unit>
        <trans-unit id="7569c827c9a13b3faf85c9b20e363a3375ada161" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;@everywhere module Foo&lt;/code&gt; defined &lt;code&gt;Foo&lt;/code&gt; on all nodes. However the call to &lt;code&gt;Foo.foo()&lt;/code&gt; created a new global binding &lt;code&gt;gvar&lt;/code&gt; on the local node, but this was not found on node 2 resulting in an &lt;code&gt;UndefVarError&lt;/code&gt; error.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;@everywhere module Foo&lt;/code&gt; &lt;code&gt;Foo&lt;/code&gt; 在所有节点上定义了Foo。但是，对 &lt;code&gt;Foo.foo()&lt;/code&gt; 的调用在本地节点上创建了一个新的全局绑定 &lt;code&gt;gvar&lt;/code&gt; ，但是在节点2上找不到它，从而导致 &lt;code&gt;UndefVarError&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="4befd8beabfc58d36d63a701ccb0fcbe3c3991f4" translate="yes" xml:space="preserve">
          <source>In the absence of a type declaration with &lt;code&gt;::&lt;/code&gt;, the type of a method parameter is &lt;code&gt;Any&lt;/code&gt; by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type &lt;code&gt;Any&lt;/code&gt;. Thus, we can define a catch-all method for &lt;code&gt;f&lt;/code&gt; like so:</source>
          <target state="translated">如果没有使用 &lt;code&gt;::&lt;/code&gt; 进行类型声明，则默认情况下方法参数的类型为 &lt;code&gt;Any&lt;/code&gt; ，这意味着它不受限制，因为Julia中的所有值都是抽象类型 &lt;code&gt;Any&lt;/code&gt; 的实例。因此，我们可以为 &lt;code&gt;f&lt;/code&gt; 定义一个包罗万象的方法，如下所示：</target>
        </trans-unit>
        <trans-unit id="804c2e460ca33d08a52c531b866706df762bfe07" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e6eb62fa9a3db0a4d3297fcd4c7b6e7504f490" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="translated">在赋值形式中，函数的主体必须是单个表达式，尽管它可以是复合表达式（请参见&lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Compound Expressions&lt;/a&gt;）。简短，简单的函数定义在Julia中很常见。因此，短函数语法非常惯用，大大减少了打字和视觉噪音。</target>
        </trans-unit>
        <trans-unit id="8b4a822ba35b7b2a2b87214b87f56abe71bd6a7e" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values &amp;ndash; and any function that was defined &lt;em&gt;before&lt;/em&gt; the definition of the generated function.</source>
          <target state="translated">在生成函数的主体中，您只能访问参数的&lt;em&gt;类型&lt;/em&gt;（而不是参数的值）以及在生成函数的定义&lt;em&gt;之前&lt;/em&gt;定义的任何函数。</target>
        </trans-unit>
        <trans-unit id="50c2c4d1cb9a5c5c26d9acf8cbb1ac2672dac8d1" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4f8a53fe3cbe9ccdbd0383d96fd01b1b384f1cc" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;Point&lt;/code&gt;, the type of &lt;code&gt;T&lt;/code&gt; is unambiguously implied if and only if the two arguments to &lt;code&gt;Point&lt;/code&gt; have the same type. When this isn't the case, the constructor will fail with a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在 &lt;code&gt;Point&lt;/code&gt; 的情况下，当且仅当 &lt;code&gt;Point&lt;/code&gt; 的两个参数具有相同的类型时， &lt;code&gt;T&lt;/code&gt; 的类型才明确隐含。如果不是这种情况，则构造函数将失败，并出现&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8083b5b25cdad6fa0ec0e103815341575e54f6a2" translate="yes" xml:space="preserve">
          <source>In the case that the type of &lt;code&gt;a[1]&lt;/code&gt; is not known precisely, &lt;code&gt;x&lt;/code&gt; can be declared via &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt;. The use of the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function allows &lt;code&gt;a[1]&lt;/code&gt; to be any object convertible to an &lt;code&gt;Int32&lt;/code&gt; (such as &lt;code&gt;UInt8&lt;/code&gt;), thus increasing the genericity of the code by loosening the type requirement. Notice that &lt;code&gt;convert&lt;/code&gt; itself needs a type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce the type of the return value of a function, even &lt;code&gt;convert&lt;/code&gt;, unless the types of all the function's arguments are known.</source>
          <target state="translated">在该情况下的类型 &lt;code&gt;a[1]&lt;/code&gt; 不是精确已知的， &lt;code&gt;x&lt;/code&gt; 可以声明通过 &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt; 。使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;函数允许 &lt;code&gt;a[1]&lt;/code&gt; 是可转换为 &lt;code&gt;Int32&lt;/code&gt; 的任何对象（例如 &lt;code&gt;UInt8&lt;/code&gt; ），从而通过放宽类型要求来增加代码的通用性。注意， &lt;code&gt;convert&lt;/code&gt; 本身在此上下文中需要类型注释，以实现类型稳定性。这是因为编译器不能推断出一个函数的返回值的类型，甚至 &lt;code&gt;convert&lt;/code&gt; ，除非所有的函数的参数类型是已知的。</target>
        </trans-unit>
        <trans-unit id="7c1119f311ce545842278fe205e3f9855f274299" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="831b049ac64422357fdc2a1f1e12b98990a72d96" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">在表达式的上下文中，使用符号来表示对变量的访问。在计算表达式时，在适当的&lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;范围内&lt;/a&gt;，将符号替换为绑定到该符号的值。</target>
        </trans-unit>
        <trans-unit id="bb0ccf20285ac1f5e0c9e737c0f406f1f62a6d45" translate="yes" xml:space="preserve">
          <source>In the context of function definitions, the &lt;code&gt;...&lt;/code&gt; operator is used to combine many different arguments into a single argument. This use of &lt;code&gt;...&lt;/code&gt; for combining many different arguments into a single argument is called slurping:</source>
          <target state="translated">在函数定义的上下文中， &lt;code&gt;...&lt;/code&gt; 运算符用于将许多不同的参数组合为一个参数。 &lt;code&gt;...&lt;/code&gt; 用于将许多不同的参数组合为一个参数的用法称为饮：</target>
        </trans-unit>
        <trans-unit id="93652cdf53268e5b525c9968aae662e21595f44e" translate="yes" xml:space="preserve">
          <source>In the end we will present Julia's approach to distributed and parallel computing. With scientific computing in mind, Julia natively implements interfaces to distribute a process across multiple cores or machines. Also we will mention useful external packages for distributed programming like &lt;code&gt;MPI.jl&lt;/code&gt; and &lt;code&gt;DistributedArrays.jl&lt;/code&gt;.</source>
          <target state="translated">最后，我们将介绍Julia的分布式和并行计算方法。考虑到科学计算，Julia本机实现接口以在多个内核或机器之间分配流程。我们还将提到有用的外部程序包，例如 &lt;code&gt;MPI.jl&lt;/code&gt; 和 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d323acfd53199deb66ce97dad2e67a0a4f124fda" translate="yes" xml:space="preserve">
          <source>In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:</source>
          <target state="translated">如果一个嵌套的测试集没有失败,就像这里的情况一样,它将被隐藏在摘要中。如果我们确实有一个测试失败,只有失败的测试集的细节会被显示出来。</target>
        </trans-unit>
        <trans-unit id="381773d3ab62fd2b5a03a4a6a4af80e1db7c0e67" translate="yes" xml:space="preserve">
          <source>In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; provide non-standard string literal &lt;code&gt;@x_str&lt;/code&gt;, then one can write &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; or &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; to disambiguate between the two.</source>
          <target state="translated">如果两个模块提供具有相同名称的非标准字符串或命令文字，则可以使用模块名称来限定字符串或命令文字。例如，如果 &lt;code&gt;Foo&lt;/code&gt; 和 &lt;code&gt;Bar&lt;/code&gt; 都提供非标准字符串文字 &lt;code&gt;@x_str&lt;/code&gt; ，则可以写 &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; 或 &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; 来消除两者之间的歧义。</target>
        </trans-unit>
        <trans-unit id="9a888754236863b7dc502d80ea92bd70226cbd16" translate="yes" xml:space="preserve">
          <source>In the example above, the code between &lt;code&gt;#=&lt;/code&gt; and &lt;code&gt;=#&lt;/code&gt; is run as a &lt;code&gt;bash&lt;/code&gt; script. Julia ignores this part since it is a multi-line comment for Julia. The Julia code after &lt;code&gt;=#&lt;/code&gt; is ignored by &lt;code&gt;bash&lt;/code&gt; since it stops parsing the file once it reaches to the &lt;code&gt;exec&lt;/code&gt; statement.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;#=&lt;/code&gt; 和 &lt;code&gt;=#&lt;/code&gt; 之间的代码作为 &lt;code&gt;bash&lt;/code&gt; 脚本运行。朱莉娅忽略了这部分，因为它是朱莉娅的多行注释。 &lt;code&gt;bash&lt;/code&gt; 会忽略 &lt;code&gt;=#&lt;/code&gt; 之后的Julia代码，因为一旦到达 &lt;code&gt;exec&lt;/code&gt; 语句，它将停止解析文件。</target>
        </trans-unit>
        <trans-unit id="7fab8ccf3e309196934d3171621e67c5c348c19f" translate="yes" xml:space="preserve">
          <source>In the example below the in-range check for referencing element &lt;code&gt;i&lt;/code&gt; of array &lt;code&gt;A&lt;/code&gt; is skipped to improve performance.</source>
          <target state="translated">在下面的示例中，跳过了对数组 &lt;code&gt;A&lt;/code&gt; 的引用元素 &lt;code&gt;i&lt;/code&gt; 的范围内检查以提高性能。</target>
        </trans-unit>
        <trans-unit id="93579590b1d00912366971a9f1eaa55dfd5a9050" translate="yes" xml:space="preserve">
          <source>In the example manifest file above, to find the path of the first &lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;&amp;mdash;Julia looks for its stanza in the manifest file, sees that it has a &lt;code&gt;path&lt;/code&gt; entry, looks at &lt;code&gt;deps/Priv&lt;/code&gt; relative to the &lt;code&gt;App&lt;/code&gt; project directory&amp;mdash;let's suppose the &lt;code&gt;App&lt;/code&gt; code lives in &lt;code&gt;/home/me/projects/App&lt;/code&gt;&amp;mdash;sees that &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; exists and therefore loads &lt;code&gt;Priv&lt;/code&gt; from there.</source>
          <target state="translated">在上面的示例清单文件中，要找到第一个 &lt;code&gt;Priv&lt;/code&gt; 程序包的路径（UUID为 &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; 的程序包），Julia在清单文件中查找其节，看到它具有 &lt;code&gt;path&lt;/code&gt; 条目，相对于 &lt;code&gt;App&lt;/code&gt; 项目目录位于 &lt;code&gt;deps/Priv&lt;/code&gt; （假设 &lt;code&gt;App&lt;/code&gt; 代码位于 &lt;code&gt;/home/me/projects/App&lt;/code&gt; 中),会发现 &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; 存在，因此从那里加载 &lt;code&gt;Priv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5f7b0ad7d3e9a880bbfbe0e4c7c117bb4c01b0c" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt;, each &lt;code&gt;I_k&lt;/code&gt; may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在表达式 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; ，每个 &lt;code&gt;I_k&lt;/code&gt; 可以是标量索引，标量索引数组或表示标量索引数组的对象，并且可以通过&lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt;转换为：</target>
        </trans-unit>
        <trans-unit id="fa27a03548fec1bfca9a5a7f95888f72d9a7ae58" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">在表达式 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 中，仅当 &lt;code&gt;a&lt;/code&gt; 的值为 &lt;code&gt;true&lt;/code&gt; 时才对子表达式 &lt;code&gt;b&lt;/code&gt; 求值。</target>
        </trans-unit>
        <trans-unit id="bac07dea1e6da71dd93fed592d9cea2988762e4a" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a || b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在表达式中 &lt;code&gt;a || b&lt;/code&gt; ，仅当 &lt;code&gt;a&lt;/code&gt; 的结果为 &lt;code&gt;false&lt;/code&gt; 时，才对子表达式 &lt;code&gt;b&lt;/code&gt; 进行评估。</target>
        </trans-unit>
        <trans-unit id="96db94e2ee75dc648cf0225c95d894886287a60b" translate="yes" xml:space="preserve">
          <source>In the first example, the return breaks out of &lt;code&gt;test1&lt;/code&gt; as soon as it hits an even number, so &lt;code&gt;test1([5,6,7])&lt;/code&gt; returns &lt;code&gt;12&lt;/code&gt;.</source>
          <target state="translated">在第一个示例中，返回值在碰到偶数后就立即退出 &lt;code&gt;test1&lt;/code&gt; ，因此 &lt;code&gt;test1([5,6,7])&lt;/code&gt; 返回 &lt;code&gt;12&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b8c088e43cc4d9778c3e9bd051248b7beb86cd4" translate="yes" xml:space="preserve">
          <source>In the first step, a handle to the Julia function &lt;code&gt;sqrt&lt;/code&gt; is retrieved by calling &lt;code&gt;jl_get_function&lt;/code&gt;. The first argument passed to &lt;code&gt;jl_get_function&lt;/code&gt; is a pointer to the &lt;code&gt;Base&lt;/code&gt; module in which &lt;code&gt;sqrt&lt;/code&gt; is defined. Then, the double value is boxed using &lt;code&gt;jl_box_float64&lt;/code&gt;. Finally, in the last step, the function is called using &lt;code&gt;jl_call1&lt;/code&gt;. &lt;code&gt;jl_call0&lt;/code&gt;, &lt;code&gt;jl_call2&lt;/code&gt;, and &lt;code&gt;jl_call3&lt;/code&gt; functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use &lt;code&gt;jl_call&lt;/code&gt;:</source>
          <target state="translated">第一步，通过调用 &lt;code&gt;jl_get_function&lt;/code&gt; 检索Julia函数 &lt;code&gt;sqrt&lt;/code&gt; 的句柄。传递给 &lt;code&gt;jl_get_function&lt;/code&gt; 的第一个参数是指向其中定义 &lt;code&gt;sqrt&lt;/code&gt; 的 &lt;code&gt;Base&lt;/code&gt; 模块的指针。然后，使用 &lt;code&gt;jl_box_float64&lt;/code&gt; 将双精度值装箱。最后，在最后一步中，使用 &lt;code&gt;jl_call1&lt;/code&gt; 调用该函数。还存在 &lt;code&gt;jl_call0&lt;/code&gt; ， &lt;code&gt;jl_call2&lt;/code&gt; 和 &lt;code&gt;jl_call3&lt;/code&gt; 函数，以方便地处理不同数量的参数。要传递更多参数，请使用 &lt;code&gt;jl_call&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7b958da57c917010bf3ef94ad88b96d1969aed7b" translate="yes" xml:space="preserve">
          <source>In the following REPL session:</source>
          <target state="translated">在下面的REPL会议上:</target>
        </trans-unit>
        <trans-unit id="c8932c25606bd0610c3cdf0d60756b479ad881b6" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes and call a generic function on it.</source>
          <target state="translated">在下面的示例中，我们将同时使用 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; 和 &lt;code&gt;CuArrays.jl&lt;/code&gt; 在多个进程之间分配数组，并在其上调用通用函数。</target>
        </trans-unit>
        <trans-unit id="7ef78cc2f03187abe5d3245512be5e3c871b1647" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes by first casting it through &lt;code&gt;distribute()&lt;/code&gt; and &lt;code&gt;CuArray()&lt;/code&gt;.</source>
          <target state="translated">在下面的例子中，我们将同时使用 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; 和 &lt;code&gt;CuArrays.jl&lt;/code&gt; 通过第一铸造分配在多个流程的阵列它通过 &lt;code&gt;distribute()&lt;/code&gt; 和 &lt;code&gt;CuArray()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eddb2dbc7e71b5027d64a28a0762a40add354815" translate="yes" xml:space="preserve">
          <source>In the following examples &lt;code&gt;&quot;...&quot;&lt;/code&gt; is used to illustrate an arbitrary docstring.</source>
          <target state="translated">在以下示例中， &lt;code&gt;&quot;...&quot;&lt;/code&gt; 用于说明任意文档字符串。</target>
        </trans-unit>
        <trans-unit id="89782f85382fa4913d7651a1e194d5e19db89926" translate="yes" xml:space="preserve">
          <source>In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.</source>
          <target state="translated">在下面的章节中,我们简单地介绍了一些可以帮助你的Julia代码尽可能快地运行的技术。</target>
        </trans-unit>
        <trans-unit id="04625a717e704769cefecb369eb2164fdede25ee" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.</source>
          <target state="translated">在前一种情况下,整数被扩大到系统字的大小,因此结果是128。在后一种情况下,不会发生这样的扩大,整数溢出的结果是-128。</target>
        </trans-unit>
        <trans-unit id="96b938fab6579b9bca905e7cf7ff960b0076051e" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is &lt;code&gt;Int64[100, 128]&lt;/code&gt;. In the latter case, no such widening happens and integer overflow results in &lt;code&gt;Int8[100, -128]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459cd312cf19872b6f89a3fcbc8f7c42d8e4d02e" translate="yes" xml:space="preserve">
          <source>In the last example, a &lt;code&gt;Vector{Any}&lt;/code&gt; is produced; the reason is that &lt;code&gt;eltype(Die) == Any&lt;/code&gt;. The remedy is to define &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt;.</source>
          <target state="translated">在最后一个示例中，产生了一个 &lt;code&gt;Vector{Any}&lt;/code&gt; ；原因是 &lt;code&gt;eltype(Die) == Any&lt;/code&gt; 。解决方法是定义 &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cbf68db8681a41c42664645e9482a6f5917d216" translate="yes" xml:space="preserve">
          <source>In the latter case, the result type is &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; since &lt;code&gt;BigInt&lt;/code&gt; is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; and &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; &amp;ndash; the symmetry is implied by the way &lt;code&gt;promote_rule&lt;/code&gt; is used in the promotion process.</source>
          <target state="translated">在后一种情况下，结果类型为&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; ,&lt;/a&gt;因为 &lt;code&gt;BigInt&lt;/code&gt; 是唯一足够大以容纳用于任意精度整数算术的整数的类型。另请注意，无需同时定义 &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; 和 &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; &amp;ndash;对称性由在升级过程中使用 &lt;code&gt;promote_rule&lt;/code&gt; 的方式。</target>
        </trans-unit>
        <trans-unit id="53f7c1a582426e8808f0c1bf813e62ee2f97e7c7" translate="yes" xml:space="preserve">
          <source>In the meantime, overflow-safe integer operations can be achieved through the use of external libraries such as &lt;a href=&quot;https://github.com/JeffreySarnoff/SaferIntegers.jl&quot;&gt;SaferIntegers.jl&lt;/a&gt;. Note that, as stated previously, the use of these libraries significantly increases the execution time of code using the checked integer types. However, for limited usage, this is far less of an issue than if it were used for all integer operations. You can follow the status of the discussion &lt;a href=&quot;https://github.com/JuliaLang/julia/issues/855&quot;&gt;here&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898e17acc6c8cf82e0dc07003deafaedea5b3686" translate="yes" xml:space="preserve">
          <source>In these and other cases, you can get the result you want by choosing an &lt;em&gt;input type&lt;/em&gt; that conveys your willingness to accept an &lt;em&gt;output type&lt;/em&gt; in which the result can be represented:</source>
          <target state="translated">在这些和其他情况下，可以通过选择一种表达您愿意接受可以表示结果的&lt;em&gt;输出类型&lt;/em&gt;的&lt;em&gt;输入类型&lt;/em&gt;来获得所需的结果：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0181a5895aa6ed6a57ecf3e1abb5400987bdae76" translate="yes" xml:space="preserve">
          <source>In these examples, &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt;, which has two fields. &lt;code&gt;b&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt;, which is a primitive bitstype with no fields at all. &lt;code&gt;ex&lt;/code&gt; is an &lt;a href=&quot;#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt;, which has one field.</source>
          <target state="translated">在这些示例中， &lt;code&gt;a&lt;/code&gt; 是&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;，具有两个字段。 &lt;code&gt;b&lt;/code&gt; 是一个 &lt;code&gt;Int&lt;/code&gt; ，它是一个基本的位类型，根本没有任何字段。 &lt;code&gt;ex&lt;/code&gt; 是一个&lt;a href=&quot;#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt;，它具有一个字段。</target>
        </trans-unit>
        <trans-unit id="e95b83474ed0f82b1495ebdd8823b0e63d6666c2" translate="yes" xml:space="preserve">
          <source>In this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.</source>
          <target state="translated">在这个例子和所有下面的例子中,假设它们的顶层是一个具有干净工作空间的全局作用域,例如一个新启动的 REPL。</target>
        </trans-unit>
        <trans-unit id="ffae775fe01ba274356f2a5f0bbbfa16bf832464" translate="yes" xml:space="preserve">
          <source>In this case &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; MUST be defined in the remote process. Note that &lt;code&gt;A&lt;/code&gt; is a global variable defined in the local workspace. Worker 2 does not have a variable called &lt;code&gt;A&lt;/code&gt; under &lt;code&gt;Main&lt;/code&gt;. The act of shipping the closure &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; to worker 2 results in &lt;code&gt;Main.A&lt;/code&gt; being defined on 2. &lt;code&gt;Main.A&lt;/code&gt; continues to exist on worker 2 even after the call &lt;code&gt;remotecall_fetch&lt;/code&gt; returns. Remote calls with embedded global references (under &lt;code&gt;Main&lt;/code&gt; module only) manage globals as follows:</source>
          <target state="translated">在这种情况下，必须在远程过程中定义&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;。请注意， &lt;code&gt;A&lt;/code&gt; 是在本地工作空间中定义的全局变量。 Worker 2 在 &lt;code&gt;Main&lt;/code&gt; 下没有名为 &lt;code&gt;A&lt;/code&gt; 的变量。航运封闭件的动作 &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; 到工人2个结果 &lt;code&gt;Main.A&lt;/code&gt; 正在对2中定义 &lt;code&gt;Main.A&lt;/code&gt; 继续甚至在调用之后对工人2存在 &lt;code&gt;remotecall_fetch&lt;/code&gt; 回报。具有嵌入式全局引用的远程调用（仅在 &lt;code&gt;Main&lt;/code&gt; 模块下）按以下方式管理全局：</target>
        </trans-unit>
        <trans-unit id="0560676ee24f0b0b03f58f97d95e6f878eed22df" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; is better. It is also more helpful to the compiler to annotate specific uses (e.g. &lt;code&gt;a[i]::Int&lt;/code&gt;) than to try to pack many alternatives into one type.</source>
          <target state="translated">在这种情况下， &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; 更好。与尝试将许多替代方法打包成一种类型相比，对编译器进行注释（例如 &lt;code&gt;a[i]::Int&lt;/code&gt; ）也更有用。</target>
        </trans-unit>
        <trans-unit id="e89af6907bd5ca30fed3e340c7ce252f260cfa01" translate="yes" xml:space="preserve">
          <source>In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:</source>
          <target state="translated">在这种情况下,一个值的元组被拼接到varargs调用中,恰恰是变量参数数的去处。然而,情况并非如此。</target>
        </trans-unit>
        <trans-unit id="567cd07e5f348036853e90930a72f1f415e7cf4a" translate="yes" xml:space="preserve">
          <source>In this case the final (empty) line before the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; sets the indentation level.</source>
          <target state="translated">在这种情况下，关闭 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 之前的最后一行（空）将设置缩进级别。</target>
        </trans-unit>
        <trans-unit id="192b075c1bd1fea405ec3cb3c290131367b6aebf" translate="yes" xml:space="preserve">
          <source>In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if &lt;code&gt;q[i,j,t]&lt;/code&gt; is near the end of the block assigned to one worker and &lt;code&gt;q[i,j,t+1]&lt;/code&gt; is near the beginning of the block assigned to another, it's very likely that &lt;code&gt;q[i,j,t]&lt;/code&gt; will not be ready at the time it's needed for computing &lt;code&gt;q[i,j,t+1]&lt;/code&gt;. In such cases, one is better off chunking the array manually. Let's split along the second dimension. Define a function that returns the &lt;code&gt;(irange, jrange)&lt;/code&gt; indices assigned to this worker:</source>
          <target state="translated">在这种情况下，如果我们尝试使用一维索引拆分工作，则很可能会遇到麻烦：如果 &lt;code&gt;q[i,j,t]&lt;/code&gt; 在分配给一个工人的块的末尾附近，而 &lt;code&gt;q[i,j,t+1]&lt;/code&gt; 在分配给另一个块的开始处附近，很有可能 &lt;code&gt;q[i,j,t]&lt;/code&gt; 在计算 &lt;code&gt;q[i,j,t+1]&lt;/code&gt; 。在这种情况下，最好手动对数组进行分块。让我们沿着第二个维度分裂。定义一个函数，该函数返回分配给此工作程序的 &lt;code&gt;(irange, jrange)&lt;/code&gt; 索引：</target>
        </trans-unit>
        <trans-unit id="b26744f8a00507231770f287451074d8e90f3846" translate="yes" xml:space="preserve">
          <source>In this case, the character &lt;code&gt;&amp;forall;&lt;/code&gt; is a three-byte character, so the indices 2 and 3 are invalid and the next character's index is 4; this next valid index can be computed by &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind(s,1)&lt;/code&gt;&lt;/a&gt;, and the next index after that by &lt;code&gt;nextind(s,4)&lt;/code&gt; and so on.</source>
          <target state="translated">在这种情况下，字符 &lt;code&gt;&amp;forall;&lt;/code&gt; 是一个三字节字符，因此索引2和3无效，下一个字符的索引为4；此下一个有效索引可以由&lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind(s,1)&lt;/code&gt; &lt;/a&gt;计算，其后的下一个索引可以由 &lt;code&gt;nextind(s,4)&lt;/code&gt; 依此类推。</target>
        </trans-unit>
        <trans-unit id="e5db3b629f524d1fec7f4ffc91f2ae6bde25d1db" translate="yes" xml:space="preserve">
          <source>In this case, the speedup due to &lt;code&gt;@fastmath&lt;/code&gt; is a factor of about 3.7. This is unusually large &amp;ndash; in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result &amp;ndash; in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.</source>
          <target state="translated">在这种情况下，由于 &lt;code&gt;@fastmath&lt;/code&gt; 导致的加速约为3.7倍。这非常大-通常，加速会更小。 （在此特定示例中，基准的工作集足够小，可以放入处理器的L1缓存中，因此内存访问延迟不起作用，并且计算时间由CPU使用率决定。在许多实际程序中事实并非如此。）此外，在这种情况下，这种优化不会更改结果-通常，结果会略有不同。在某些情况下，尤其是对于数值不稳定的算法，结果可能会非常不同。</target>
        </trans-unit>
        <trans-unit id="6188940203c290544c44a0f6a7e7493e9e0ab89b" translate="yes" xml:space="preserve">
          <source>In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see &lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，MPI是指MPI-1标准。从MPI-2开始，MPI标准委员会引入了一套新的通信机制，统称为远程存储器访问（RMA）。将RMA添加到MPI标准的动机是促进单方面的沟通模式。有关最新MPI标准的其他信息，请参阅&lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92a7a3f559dc2f0e3123bf1d2da5d1162f830e7c" translate="yes" xml:space="preserve">
          <source>In this example it is accomplished by defining &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; to create the appropriate wrapped array. (Note that while &lt;code&gt;similar&lt;/code&gt; supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it's important that &lt;code&gt;SparseArray&lt;/code&gt; is mutable (supports &lt;code&gt;setindex!&lt;/code&gt;). Defining &lt;code&gt;similar&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt; and &lt;code&gt;setindex!&lt;/code&gt; for &lt;code&gt;SparseArray&lt;/code&gt; also makes it possible to &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; the array:</source>
          <target state="translated">在此示例中，它是通过定义 &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; 来创建合适的包装数组来完成的。 （请注意，尽管 &lt;code&gt;similar&lt;/code&gt; 支持1和2参数形式，但在大多数情况下，您只需要专门化3参数形式。）要使此功能有效，重要的是 &lt;code&gt;SparseArray&lt;/code&gt; 是可变的（支持 &lt;code&gt;setindex!&lt;/code&gt; ）。定义 &lt;code&gt;similar&lt;/code&gt; ， &lt;code&gt;getindex&lt;/code&gt; 和 &lt;code&gt;setindex!&lt;/code&gt; 对于 &lt;code&gt;SparseArray&lt;/code&gt; ,还可以&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;数组：</target>
        </trans-unit>
        <trans-unit id="05a24eb92f7d5686dff145712d9c9981f290a66e" translate="yes" xml:space="preserve">
          <source>In this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After exiting both catch blocks normally (i.e., without throwing a further exception) all exceptions are removed from the stack and are no longer accessible.</source>
          <target state="translated">在这个例子中,根源异常(A)是堆栈中的第一个异常,后面还有一个异常(B)。在正常退出这两个捕获块后(即不抛出进一步的异常),所有的异常都从堆栈中删除,不再可以访问。</target>
        </trans-unit>
        <trans-unit id="4336cae1e8edd1087fd9411fb166bd6a222c2c06" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;A&lt;/code&gt; is a mutable container that contains one element, which can be set by &lt;code&gt;A[] = 1.0&lt;/code&gt; and retrieved with &lt;code&gt;A[]&lt;/code&gt;. All zero-dimensional arrays have the same size (&lt;code&gt;size(A) == ()&lt;/code&gt;), and length (&lt;code&gt;length(A) == 1&lt;/code&gt;). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia's definition.</source>
          <target state="translated">在此示例中， &lt;code&gt;A&lt;/code&gt; 是一个可变容器，其中包含一个元素，可以通过 &lt;code&gt;A[] = 1.0&lt;/code&gt; 进行设置，并使用 &lt;code&gt;A[]&lt;/code&gt; 检索。所有零维数组都具有相同的大小（ &lt;code&gt;size(A) == ()&lt;/code&gt; ）和长度（ &lt;code&gt;length(A) == 1&lt;/code&gt; ）。特别是零维数组不为空。如果您发现这不太直观，这里有一些想法可能有助于理解Julia的定义。</target>
        </trans-unit>
        <trans-unit id="6a0bf2dc540c812cb1923adeb5876321d55dbf26" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;N&lt;/code&gt; is passed as a parameter, so its &quot;value&quot; is known to the compiler. Essentially, &lt;code&gt;Val(T)&lt;/code&gt; works only when &lt;code&gt;T&lt;/code&gt; is either hard-coded/literal (&lt;code&gt;Val(3)&lt;/code&gt;) or already specified in the type-domain.</source>
          <target state="translated">在此示例中， &lt;code&gt;N&lt;/code&gt; 作为参数传递，因此编译器知道其&amp;ldquo;值&amp;rdquo;。本质上， &lt;code&gt;Val(T)&lt;/code&gt; 仅在 &lt;code&gt;T&lt;/code&gt; 是硬编码/文字（ &lt;code&gt;Val(3)&lt;/code&gt; ）或已在类型域中指定时才起作用。</target>
        </trans-unit>
        <trans-unit id="92f4b81b4c3f20308317f94d5766f434fb02e58c" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;b&lt;/code&gt; is a runnable &lt;code&gt;Task&lt;/code&gt; that hasn't started yet.</source>
          <target state="translated">在此示例中， &lt;code&gt;b&lt;/code&gt; 是尚未启动的可运行 &lt;code&gt;Task&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f7bc1ef4d38fd2e360681f2040c8ad0f73774eb" translate="yes" xml:space="preserve">
          <source>In this example, observe that the new definition for &lt;code&gt;newfun&lt;/code&gt; has been created, but can't be immediately called. The new global is immediately visible to the &lt;code&gt;tryeval&lt;/code&gt; function, so you could write &lt;code&gt;return newfun&lt;/code&gt; (without parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new method definition!</source>
          <target state="translated">在此示例中，观察到 &lt;code&gt;newfun&lt;/code&gt; 的新定义已创建，但是不能立即调用。 &lt;code&gt;tryeval&lt;/code&gt; 函数可以立即看到新的全局变量，因此可以编写 &lt;code&gt;return newfun&lt;/code&gt; （不带括号）。但是您，您的任何调用者，他们调用的函数等都无法调用此新方法定义！</target>
        </trans-unit>
        <trans-unit id="f0f0d16b1aed858c0d51da9625d8755a2c35d48e" translate="yes" xml:space="preserve">
          <source>In this example, the remote which is being fetched from &lt;em&gt;does&lt;/em&gt; have a file called &lt;code&gt;our_file&lt;/code&gt; in its index, which is why we must reset.</source>
          <target state="translated">在此示例中，要从&lt;em&gt;中&lt;/em&gt;获取远程文件的索引中&lt;em&gt;确实&lt;/em&gt;有一个名为 &lt;code&gt;our_file&lt;/code&gt; 的文件，这就是我们必须重置的原因。</target>
        </trans-unit>
        <trans-unit id="a138591f083f547736d80bd3d40dd03ced901f2b" translate="yes" xml:space="preserve">
          <source>In this example, the task ran on pid 2, called from pid 1.</source>
          <target state="translated">在这个例子中,任务运行在pid 2上,由pid 1调用。</target>
        </trans-unit>
        <trans-unit id="f39c0221e85d683a6f4024da4ca9271cf6b8c812" translate="yes" xml:space="preserve">
          <source>In this example, the tuple &lt;code&gt;(1,2,3)&lt;/code&gt; is interpolated as an expression into a conditional test:</source>
          <target state="translated">在此示例中，将元组 &lt;code&gt;(1,2,3)&lt;/code&gt; 作为表达式插入到条件测试中：</target>
        </trans-unit>
        <trans-unit id="a8e780cf12ef36b63b08a74c8c07d0b380150440" translate="yes" xml:space="preserve">
          <source>In this example, the value of variable &lt;code&gt;a&lt;/code&gt; is interpolated:</source>
          <target state="translated">在此示例中，对变量 &lt;code&gt;a&lt;/code&gt; 的值进行插值：</target>
        </trans-unit>
        <trans-unit id="d77924d6298476fc4b219142016e1167310fe63c" translate="yes" xml:space="preserve">
          <source>In this example, we can see that the top level function called is in the file &lt;code&gt;event.jl&lt;/code&gt;. This is the function that runs the REPL when you launch Julia. If you examine line 97 of &lt;code&gt;REPL.jl&lt;/code&gt;, you'll see this is where the function &lt;code&gt;eval_user_input()&lt;/code&gt; is called. This is the function that evaluates what you type at the REPL, and since we're working interactively these functions were invoked when we entered &lt;code&gt;@profile myfunc()&lt;/code&gt;. The next line reflects actions taken in the &lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt;&lt;code&gt;@profile&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">在此示例中，我们可以看到调用的顶级函数在文件 &lt;code&gt;event.jl&lt;/code&gt; 中。这是启动Julia时运行REPL的功能。如果检查 &lt;code&gt;REPL.jl&lt;/code&gt; 的第97 行，则会看到在这里调用了 &lt;code&gt;eval_user_input()&lt;/code&gt; 函数。这是评估您在REPL上键入内容的函数，由于我们正在交互工作，因此在输入 &lt;code&gt;@profile myfunc()&lt;/code&gt; 时将调用这些函数。下一行反映了&lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt; &lt;code&gt;@profile&lt;/code&gt; &lt;/a&gt;宏中执行的操作。</target>
        </trans-unit>
        <trans-unit id="4c91076ff3785f6e6c7acf1c7077368cdbb7151f" translate="yes" xml:space="preserve">
          <source>In this manner, Julia acts as its own &lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;preprocessor&lt;/a&gt;, and allows code generation from inside the language. The above code could be written slightly more tersely using the &lt;code&gt;:&lt;/code&gt; prefix quoting form:</source>
          <target state="translated">通过这种方式，Julia充当其自己的&lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;预处理器&lt;/a&gt;，并允许从语言内部生成代码。上面的代码可以使用 &lt;code&gt;:&lt;/code&gt; 前缀引用形式更简洁地编写：</target>
        </trans-unit>
        <trans-unit id="7bd6fc4b177020a8a663dcee2fb9c4c397754164" translate="yes" xml:space="preserve">
          <source>In this module we export the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; functions (with the keyword &lt;code&gt;export&lt;/code&gt;), and also have the non-exported function &lt;code&gt;p&lt;/code&gt;. There are several different ways to load the Module and its inner functions into the current workspace:</source>
          <target state="translated">在此模块中，我们导出 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 函数（使用关键字 &lt;code&gt;export&lt;/code&gt; ），并且还具有未导出的函数 &lt;code&gt;p&lt;/code&gt; 。有几种不同的方法可以将模块及其内部功能加载到当前工作空间中：</target>
        </trans-unit>
        <trans-unit id="dcdbf4c0d317d8b968227eee1bb592e9cd8a0e88" translate="yes" xml:space="preserve">
          <source>In this particular case, the number of elements skipped &lt;em&gt;in memory&lt;/em&gt; matches the number of &lt;em&gt;linear indices&lt;/em&gt; skipped. This is only the case for contiguous arrays like &lt;code&gt;Array&lt;/code&gt; (and other &lt;code&gt;DenseArray&lt;/code&gt; subtypes) and is not true in general. Views with range indices are a good example of &lt;em&gt;non-contiguous&lt;/em&gt; strided arrays; consider &lt;code&gt;V = @view A[1:3:4, 2:2:6, 2:-1:1]&lt;/code&gt;. This view &lt;code&gt;V&lt;/code&gt; refers to the same memory as &lt;code&gt;A&lt;/code&gt; but is skipping and re-arranging some of its elements. The stride of the first dimension of &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;3&lt;/code&gt; because we're only selecting every third row from our original array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fa363c46c4da719440f0a895d038cea7c0f22d" translate="yes" xml:space="preserve">
          <source>In this situation, use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to skip missing values</source>
          <target state="translated">在这种情况下，请使用&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;函数跳过遗漏的值</target>
        </trans-unit>
        <trans-unit id="9db9e9e3387eacd52cbab3963439723e71f36736" translate="yes" xml:space="preserve">
          <source>In this style of definition, the code generation feature is essentially an optional optimization. The compiler will use it if convenient, but otherwise may choose to use the normal implementation instead. This style is preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since normal code is more readable than code-generating code. However, which implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically.</source>
          <target state="translated">在这种风格的定义中,代码生成功能本质上是一种可选的优化。编译器在方便的情况下会使用它,但其他情况下可能会选择使用正常的实现来代替。这种风格是比较好的,因为它允许编译器做出更多的决定,以更多的方式编译程序,而且正常代码比代码生成代码更易读。但是,使用哪种实现取决于编译器的实现细节,所以两种实现的行为必须完全相同。</target>
        </trans-unit>
        <trans-unit id="2472bd128ff5a0c2f02732fc91d35900b7540e31" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="translated">在这个玩具示例中，这两种方法很容易区分和选择。但是，在实际程序中，设计数据移动可能需要更多的考虑，并且可能需要一些度量。例如，如果第一个过程需要矩阵 &lt;code&gt;A&lt;/code&gt; ,则第一个方法可能会更好。或者，如果计算 &lt;code&gt;A&lt;/code&gt; 昂贵且仅当前进程拥有它，那么将其转移到另一个进程可能是不可避免的。或者，如果当前过程在&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;fetch(Bref)&lt;/code&gt; 之间没有什么关系，则最好完全消除并行性。或想象用更昂贵的操作替换 &lt;code&gt;rand(1000,1000)&lt;/code&gt; 。然后可能仅在此步骤中添加另一个&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;语句。</target>
        </trans-unit>
        <trans-unit id="4f15c62fbcd9523fb3f2a21376c6d6f2fb45889e" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawnat&quot;&gt;&lt;code&gt;@spawnat&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf538f8e56ca0f93d90636a083c95bfe08cc9992" translate="yes" xml:space="preserve">
          <source>In this way a mesh network is established, wherein every worker is directly connected with every other worker.</source>
          <target state="translated">这样就建立了一个网状网络,在这个网络中,每一个工作者都与其他每一个工作者直接相连。</target>
        </trans-unit>
        <trans-unit id="77e752e41de1e6877a1adbe41bf7b76e4f16d104" translate="yes" xml:space="preserve">
          <source>In-memory representation of a file entry in the index. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt;&lt;code&gt;git_index_entry&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">索引中文件条目的内存表示形式。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt; &lt;code&gt;git_index_entry&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="06c7aeba98a0f145bac3596871ee20c6209a6fe5" translate="yes" xml:space="preserve">
          <source>In-place broadcasting can be supported by defining the appropriate &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; method. Because you might want to specialize either on &lt;code&gt;dest&lt;/code&gt; or the specific subtype of &lt;code&gt;bc&lt;/code&gt;, to avoid ambiguities between packages we recommend the following convention.</source>
          <target state="translated">可以通过定义适当的 &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; 方法来支持就地广播。因为你可能想专门无论是在 &lt;code&gt;dest&lt;/code&gt; 的或特定亚型 &lt;code&gt;bc&lt;/code&gt; ，避免包之间的模糊，我们建议以下约定。</target>
        </trans-unit>
        <trans-unit id="9b8eaa806ba1cb1b5e2ab868bf0bb847fbaf77f5" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Base.reverse-Tuple%7BAbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc665a97127feb38e6b15a0be58c4193afb4afe7" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt;: randomly permute &lt;code&gt;v&lt;/code&gt; in-place, optionally supplying the random-number generator &lt;code&gt;rng&lt;/code&gt;.</source>
          <target state="translated">随机&lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt;的就地版本：随地随机置换 &lt;code&gt;v&lt;/code&gt; ，可以选择提供随机数生成器 &lt;code&gt;rng&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ceae787569f3577706adf60b6b428b09067c76dc" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;code&gt;reverse&lt;/code&gt;.</source>
          <target state="translated">就地版本的 &lt;code&gt;reverse&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d77496985aa0ae694adc6f64d73e36e7d090fe55" translate="yes" xml:space="preserve">
          <source>Inbox Tray</source>
          <target state="translated">收件箱托盘</target>
        </trans-unit>
        <trans-unit id="973cab0f46e932b28084ce2f784990fa4e35559b" translate="yes" xml:space="preserve">
          <source>Include a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.</source>
          <target state="translated">在简化签字块之后,用一个单行句子说明函数的作用或对象所代表的内容。如有必要,可在第二段的空白行后提供更多细节。</target>
        </trans-unit>
        <trans-unit id="7962fdf356cdba272a5b5a5a58199f8e50948161" translate="yes" xml:space="preserve">
          <source>Include any code examples in an &lt;code&gt;# Examples&lt;/code&gt; section.</source>
          <target state="translated">在&amp;ldquo; &lt;code&gt;# Examples&lt;/code&gt; 部分中包含所有代码示例。</target>
        </trans-unit>
        <trans-unit id="66cb3917171f2315e55b05172cef1568516a6218" translate="yes" xml:space="preserve">
          <source>Including the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base definitions, for example testing code by running it with &quot;safe&quot; versions of some operators:</source>
          <target state="translated">在不同的模块中包含相同的代码,提供了类似 mixin 的行为。人们可以使用这一点来用不同的基础定义来运行相同的代码,例如,通过使用某些操作符的 &quot;安全 &quot;版本来测试代码。</target>
        </trans-unit>
        <trans-unit id="3677c6602caed5b57fccc20b31958c9939eb0f57" translate="yes" xml:space="preserve">
          <source>Incoming Envelope</source>
          <target state="translated">来料信封</target>
        </trans-unit>
        <trans-unit id="1cebd71683222b1c7af41849d615c19b10f8b1ef" translate="yes" xml:space="preserve">
          <source>Incomplete Initialization</source>
          <target state="translated">不完整的初始化</target>
        </trans-unit>
        <trans-unit id="700503508878aea14fc71ea0dd89adddb349e058" translate="yes" xml:space="preserve">
          <source>Increases As</source>
          <target state="translated">增加的原因</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="81769cec07065990cf97fe9de01e67d1dff5a01a" translate="yes" xml:space="preserve">
          <source>Incremental history search, described above</source>
          <target state="translated">递增式历史检索,如上所述</target>
        </trans-unit>
        <trans-unit id="7777e9a1cc822589b38fa2cf3b16ff5bb4405461" translate="yes" xml:space="preserve">
          <source>IndexCartesian</source>
          <target state="translated">IndexCartesian</target>
        </trans-unit>
        <trans-unit id="0ad6144c812efd669c1e0522b10d3e8d01b0818e" translate="yes" xml:space="preserve">
          <source>IndexLinear</source>
          <target state="translated">IndexLinear</target>
        </trans-unit>
        <trans-unit id="5c7d3a57514b6cbb8c7494df1aa031252a9240c0" translate="yes" xml:space="preserve">
          <source>IndexStyle</source>
          <target state="translated">IndexStyle</target>
        </trans-unit>
        <trans-unit id="8b48578d3b12e1d393eb06b8ea5bee4e6f0ec92a" translate="yes" xml:space="preserve">
          <source>Indexable Collections</source>
          <target state="translated">可索引收藏</target>
        </trans-unit>
        <trans-unit id="04f77b5a53e8914ea949c0d3dbe59ff927176c3a" translate="yes" xml:space="preserve">
          <source>Indexed Assignment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="0795ddb093e3d5dd1a985acb78a5e1baf2eef779" translate="yes" xml:space="preserve">
          <source>Indexing and assignment</source>
          <target state="translated">编制索引和转让</target>
        </trans-unit>
        <trans-unit id="4274ea6199202594d8373033384d6bdb729f3196" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.</source>
          <target state="translated">表示排序函数应该使用插入排序算法。插入排序一次遍历一个元素的集合,将每个元素插入到输出列表中正确的排序位置。</target>
        </trans-unit>
        <trans-unit id="1a127225335e9d3a07a6be83a0e208ad31b15ede" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.</source>
          <target state="translated">表示排序函数应使用合并排序算法。合并排序将集合划分为子集合,并反复合并,每一步都对每个子集合进行排序,直到整个集合以排序形式重新组合。</target>
        </trans-unit>
        <trans-unit id="f0d9438aae14ca6f51f78f417b7df01df9f079a5" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest &lt;code&gt;k&lt;/code&gt; elements sorted from smallest to largest, finding them and sorting them using &lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt;&lt;code&gt;QuickSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指示排序功能应使用部分快速排序算法。局部快速排序返回从最小到最大排序的最小 &lt;code&gt;k&lt;/code&gt; 个元素，找到它们并使用&lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt; &lt;code&gt;QuickSort&lt;/code&gt; &lt;/a&gt;对其进行排序。</target>
        </trans-unit>
        <trans-unit id="d5c75327b4e50aced7a786e9b2e8496c590cde6e" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the quick sort algorithm, which is &lt;em&gt;not&lt;/em&gt; stable.</source>
          <target state="translated">指示排序功能应该使用快速排序算法，这是&lt;em&gt;不是&lt;/em&gt;稳定。</target>
        </trans-unit>
        <trans-unit id="a54eb733590aa2b40370b6fb359ea865b8d99e9b" translate="yes" xml:space="preserve">
          <source>Indicate whether &lt;code&gt;x&lt;/code&gt; is &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指示 &lt;code&gt;x&lt;/code&gt; 是否&lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efe98c42fb3d546aaef0cbe63f84a3ed426eef2d" translate="yes" xml:space="preserve">
          <source>Indicates a test that should pass but currently consistently fails. Tests that the expression &lt;code&gt;ex&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; or causes an exception. Returns a &lt;code&gt;Broken&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it does, or an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if the expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">表示应该通过但当前始终失败的测试。测试表达式 &lt;code&gt;ex&lt;/code&gt; 的计算结果是否为 &lt;code&gt;false&lt;/code&gt; 或导致异常。如果是，则返回&amp;ldquo; &lt;code&gt;Broken&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 如果表达式的 &lt;code&gt;Result&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则返回&amp;ldquo; &lt;code&gt;Error&lt;/code&gt; 结果 &amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="f58aeaea39a890601871a48e22cb88bfcd1c627a" translate="yes" xml:space="preserve">
          <source>Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).</source>
          <target state="translated">表示一个进程的退出状态有问题,当运行命令或管道时,抛出该信息表示返回了一个非零的退出代码(即被调用的进程失败了)。当运行命令或管道时,会抛出这个消息,表示返回了一个非零的退出代码(即调用的进程失败了)。</target>
        </trans-unit>
        <trans-unit id="ff3a5eaf7321b1b596df1bcd003dbd2f9fcf89b1" translate="yes" xml:space="preserve">
          <source>Indices are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">索引的类型与&lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt;返回的类型相同。</target>
        </trans-unit>
        <trans-unit id="f9e9b57819d8a4759652850ab76b4d97192200f0" translate="yes" xml:space="preserve">
          <source>Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.</source>
          <target state="translated">如果未索引的尾随尺寸均为长度一，则可以省略索引。换句话说，仅当对于入站索引表达式只有一个可能的值时，才可以省略尾随索引。例如，尺寸为 &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; 3、4、2、1）的四维数组可能只用三个索引编制索引，因为被跳过的维（第四维）的长度为1。请注意，线性索引优先于此规则。</target>
        </trans-unit>
        <trans-unit id="a9eddea567bcc33c91213abd188cec156d2bbedc" translate="yes" xml:space="preserve">
          <source>Indices or keys are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">索引或键的类型与&lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt;返回的类型相同。</target>
        </trans-unit>
        <trans-unit id="3e37e52d9d94ec6a75ede0c2186d1f73dd06e01f" translate="yes" xml:space="preserve">
          <source>Indirect Calls</source>
          <target state="translated">间接电话</target>
        </trans-unit>
        <trans-unit id="8b89285e1320e669387b56f7e30bddb1aefce498" translate="yes" xml:space="preserve">
          <source>Individual pointers returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; can be translated into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s by passing them into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt;&lt;code&gt;StackTraces.lookup&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">通过返回的单个指针&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt;可以翻译成&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt;通过它们传递到s中&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt; &lt;code&gt;StackTraces.lookup&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f462554871703067824392ec24cc8ae7c200c6ce" translate="yes" xml:space="preserve">
          <source>Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes. Here's a simple example of a Perl one-liner at a shell prompt:</source>
          <target state="translated">难免会想写一些不太简单的命令,这时就需要使用引号。下面是一个简单的例子,在shell提示符下,Perl的一句话。</target>
        </trans-unit>
        <trans-unit id="b24e30d8c474981541dc914b04b492ae2c3460dd" translate="yes" xml:space="preserve">
          <source>Inexact equality comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt;. The default &lt;code&gt;atol&lt;/code&gt; is zero and the default &lt;code&gt;rtol&lt;/code&gt; depends on the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The keyword argument &lt;code&gt;nans&lt;/code&gt; determines whether or not NaN values are considered equal (defaults to false).</source>
          <target state="translated">不精确的相等性比较： &lt;code&gt;true&lt;/code&gt; 如果 &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt; 。默认 &lt;code&gt;atol&lt;/code&gt; 为零，默认 &lt;code&gt;rtol&lt;/code&gt; 取决于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的类型。关键字参数 &lt;code&gt;nans&lt;/code&gt; 确定NaN值是否相等（默认为false）。</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="3b4f77ed6217d60a7fd4f6a9b544f27db8d0b2a2" translate="yes" xml:space="preserve">
          <source>Inf16</source>
          <target state="translated">Inf16</target>
        </trans-unit>
        <trans-unit id="f32fd60229b61d38504c1b80cfc905d76eb231a4" translate="yes" xml:space="preserve">
          <source>Inf32</source>
          <target state="translated">Inf32</target>
        </trans-unit>
        <trans-unit id="13b9b86c9d296608a20ee6add58865dfa6405d7b" translate="yes" xml:space="preserve">
          <source>Inference on the generated function may be run at &lt;em&gt;any&lt;/em&gt; time, including while your code is attempting to observe or mutate this state.</source>
          <target state="translated">在生成的函数可以推断在运行&lt;em&gt;任何&lt;/em&gt;时候，包括当你的代码试图观察或变异这种状态。</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="c7144cf7afebc5115a987ddb86ab81776ccb312f" translate="yes" xml:space="preserve">
          <source>Information Desk Person</source>
          <target state="translated">问讯处人员</target>
        </trans-unit>
        <trans-unit id="ee1bf915e3a7b6dbf22c44b17ef750f99d415033" translate="yes" xml:space="preserve">
          <source>Information Source</source>
          <target state="translated">信息来源</target>
        </trans-unit>
        <trans-unit id="1bcf6aaebaf6b2210eb3e22e29d6b1d78dde678a" translate="yes" xml:space="preserve">
          <source>Information about the datatype</source>
          <target state="translated">关于数据类型的信息</target>
        </trans-unit>
        <trans-unit id="bc0f7289c05621e36794cb837d6af7d6579a4164" translate="yes" xml:space="preserve">
          <source>Information about the sizes of the array</source>
          <target state="translated">阵列的尺寸信息</target>
        </trans-unit>
        <trans-unit id="2e1d962528e312390b3433d954b1b586fbe1d39c" translate="yes" xml:space="preserve">
          <source>Initialize &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;x = 1.0&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;x = 1.0&lt;/code&gt; 初始化 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d24f12b12b26a182fb25787fca39632feae214b" translate="yes" xml:space="preserve">
          <source>Initialize with the first loop iteration, to &lt;code&gt;x = 1 / rand()&lt;/code&gt;, then loop &lt;code&gt;for i = 2:10&lt;/code&gt;</source>
          <target state="translated">用第一个循环迭代进行初始化，以 &lt;code&gt;x = 1 / rand()&lt;/code&gt; ，然后循环 &lt;code&gt;for i = 2:10&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1daf596559638b5a2545966e4511677e06d2d3d" translate="yes" xml:space="preserve">
          <source>Initially &lt;code&gt;f(x)&lt;/code&gt; has one definition</source>
          <target state="translated">最初 &lt;code&gt;f(x)&lt;/code&gt; 有一个定义</target>
        </trans-unit>
        <trans-unit id="65a228b7147b9d8893c482dc6a5436ee38235915" translate="yes" xml:space="preserve">
          <source>Inline elements</source>
          <target state="translated">内联元素</target>
        </trans-unit>
        <trans-unit id="45667ade36979348043d403d58a921b295a413f5" translate="yes" xml:space="preserve">
          <source>Inner Constructor Methods</source>
          <target state="translated">内建函数方法</target>
        </trans-unit>
        <trans-unit id="5b1b953a0d0fba8d5b16a917eed0d32fa9a3dd01" translate="yes" xml:space="preserve">
          <source>Inner local scopes can, however, update variables in their parent scopes:</source>
          <target state="translated">然而,内部局部作用域可以更新其父作用域中的变量。</target>
        </trans-unit>
        <trans-unit id="8da1f19e44e7c32bb595b50d82bbd6ceb59679ad" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Capital Letters</source>
          <target state="translated">拉丁大写字母的输入符号</target>
        </trans-unit>
        <trans-unit id="c3dacb4d5649dfd7003c41b511f2d5e28217bcec" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Letters</source>
          <target state="translated">拉丁字母的输入符号</target>
        </trans-unit>
        <trans-unit id="c56fdb4bd109b10836666b2146d13e58e8c262da" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Small Letters</source>
          <target state="translated">拉丁小字的输入符号</target>
        </trans-unit>
        <trans-unit id="daa856648c7327c1e747ce6132f831c138ebed2c" translate="yes" xml:space="preserve">
          <source>Input Symbol For Numbers</source>
          <target state="translated">数字的输入符号</target>
        </trans-unit>
        <trans-unit id="393164c17095f31b175cd1b93cce56c3dedbfb1e" translate="yes" xml:space="preserve">
          <source>Input Symbol For Symbols</source>
          <target state="translated">符号的输入符号</target>
        </trans-unit>
        <trans-unit id="6ac623d9f5d1fbc2e0f23f9accfd989544cd258f" translate="yes" xml:space="preserve">
          <source>Insert a sequential-consistency memory fence</source>
          <target state="translated">插入顺序一致性内存栅栏。</target>
        </trans-unit>
        <trans-unit id="811acf3875523c22a2281d416b5b4f8370319cc7" translate="yes" xml:space="preserve">
          <source>Insert an &lt;code&gt;item&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. &lt;code&gt;index&lt;/code&gt; is the index of &lt;code&gt;item&lt;/code&gt; in the resulting &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">插入一个 &lt;code&gt;item&lt;/code&gt; 到 &lt;code&gt;a&lt;/code&gt; 给定的 &lt;code&gt;index&lt;/code&gt; 。 &lt;code&gt;index&lt;/code&gt; 是结果 &lt;code&gt;a&lt;/code&gt; 中 &lt;code&gt;item&lt;/code&gt; 的索引。</target>
        </trans-unit>
        <trans-unit id="559e8d8937fda6b9aa5389a26a8c99a01c1659f4" translate="yes" xml:space="preserve">
          <source>Insert new line without executing it</source>
          <target state="translated">插入新行而不执行</target>
        </trans-unit>
        <trans-unit id="db69c06d74ad468e37833a8eff3cd0b19f6c2cae" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the beginning of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;collection&lt;/code&gt; 开始时插入一个或多个 &lt;code&gt;items&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e38ad6a771799a9a8891ef79be267ec402e8ceac" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;collection&lt;/code&gt; 的末尾插入一个或多个 &lt;code&gt;items&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6f3f950f8d7377ccffdca0b939ba6ac7684b1f51" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; in &lt;code&gt;collection&lt;/code&gt;. If &lt;code&gt;collection&lt;/code&gt; is an ordered container, the items are inserted at the end (in the given order).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1912a8c6dfd808836326783d91aa44bc473362" translate="yes" xml:space="preserve">
          <source>Insert the elements of &lt;code&gt;items&lt;/code&gt; to the beginning of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">插入的元素 &lt;code&gt;items&lt;/code&gt; 至年初 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eec80463f132fabaec00763dec1737d74a5ca8f8" translate="yes" xml:space="preserve">
          <source>Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.</source>
          <target state="translated">插入一个具有顺序一致的排序语义的内存栅栏。有一些算法需要这样做,即获取/释放顺序不充分。</target>
        </trans-unit>
        <trans-unit id="8a79f039f9c26eb844e9abd4767d0e8224e23795" translate="yes" xml:space="preserve">
          <source>Inserts a point in the program where garbage collection may run. This can be useful in rare cases in multi-threaded programs where some threads are allocating memory (and hence may need to run GC) but other threads are doing only simple operations (no allocation, task switches, or I/O). Calling this function periodically in non-allocating threads allows garbage collection to run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea0f92c3d70dd355408c14ed7bbf0a9be4aeff9" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;kwargs&lt;/code&gt; will be a key-value iterator over a named tuple. Named tuples (as well as dictionaries with keys of &lt;code&gt;Symbol&lt;/code&gt;) can be passed as keyword arguments using a semicolon in a call, e.g. &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;f&lt;/code&gt; 内部， &lt;code&gt;kwargs&lt;/code&gt; 将是命名元组上的键值迭代器。可以在调用中使用分号将命名的元组（以及具有 &lt;code&gt;Symbol&lt;/code&gt; 键的字典）作为关键字参数传递，例如 &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d505904dee884402cee2bfc93d1e5e6eac91aed0" translate="yes" xml:space="preserve">
          <source>Inside a function call, &lt;code&gt;f(a=b)&lt;/code&gt; passes &lt;code&gt;b&lt;/code&gt; as the value of keyword argument &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在函数调用内部， &lt;code&gt;f(a=b)&lt;/code&gt; 将 &lt;code&gt;b&lt;/code&gt; 作为关键字参数 &lt;code&gt;a&lt;/code&gt; 的值传递。</target>
        </trans-unit>
        <trans-unit id="5c0628bcc3fe3dc7f18266ed4703a4ef8a1c7fc8" translate="yes" xml:space="preserve">
          <source>Inside a local scope a global variable can be assigned to by using the keyword &lt;a href=&quot;../../base/base/index#global&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在局部范围内，可以使用关键字&lt;a href=&quot;../../base/base/index#global&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt;来分配全局变量：</target>
        </trans-unit>
        <trans-unit id="582d7159a5b73cf78ab92b918e0b2d46bdf1e604" translate="yes" xml:space="preserve">
          <source>Inside a local scope a variable can be forced to be a new local variable using the &lt;a href=&quot;../../base/base/index#local&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">在局部范围内，可以使用&lt;a href=&quot;../../base/base/index#local&quot;&gt; &lt;code&gt;local&lt;/code&gt; &lt;/a&gt;关键字将变量强制为新的局部变量：</target>
        </trans-unit>
        <trans-unit id="2d117997a7534c274cbe92ad615675971d22bedb" translate="yes" xml:space="preserve">
          <source>Inside of the &lt;code&gt;greet&lt;/code&gt; function, the assignment &lt;code&gt;x = &quot;hello&quot;&lt;/code&gt; causes &lt;code&gt;x&lt;/code&gt; to be a new local variable in the function's scope. There are two relevant facts: the assignment occurs in local scope and there is no existing local &lt;code&gt;x&lt;/code&gt; variable. Since &lt;code&gt;x&lt;/code&gt; is local, it doesn't matter if there is a global named &lt;code&gt;x&lt;/code&gt; or not. Here for example we define &lt;code&gt;x = 123&lt;/code&gt; before defining and calling &lt;code&gt;greet&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fad0a2de99eca8b6794c525262e6ccd85a1c70" translate="yes" xml:space="preserve">
          <source>Inside parentheses with commas, &lt;code&gt;(a=1,)&lt;/code&gt; constructs a &lt;a href=&quot;#Core.NamedTuple&quot;&gt;&lt;code&gt;NamedTuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在带逗号的括号内， &lt;code&gt;(a=1,)&lt;/code&gt; 构造了一个&lt;a href=&quot;#Core.NamedTuple&quot;&gt; &lt;code&gt;NamedTuple&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="456c6fe8fc3a9803d2d238636df3fddf2e8ebda8" translate="yes" xml:space="preserve">
          <source>Inspects the given UUID and returns its version (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;).</source>
          <target state="translated">检查给定的UUID并返回其版本（请参阅&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4ff8674778688251123ee296e21a5f29ce889b67" translate="yes" xml:space="preserve">
          <source>Instances can be constructed from strings via &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, or using the &lt;code&gt;big&lt;/code&gt; string literal.</source>
          <target state="translated">可以通过&lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;或使用 &lt;code&gt;big&lt;/code&gt; 字符串文字从字符串构造实例。</target>
        </trans-unit>
        <trans-unit id="e2cd4547e98e69f493a2391724e35284eddfcf3f" translate="yes" xml:space="preserve">
          <source>Instead of calculating something or performing some action, you return a &lt;em&gt;quoted expression&lt;/em&gt; which, when evaluated, does what you want.</source>
          <target state="translated">您无需计算或执行某些操作，而是返回带&lt;em&gt;引号的表达式&lt;/em&gt;，该&lt;em&gt;表达式&lt;/em&gt;在被求值时会执行您想要的操作。</target>
        </trans-unit>
        <trans-unit id="e11074b6a3ddd4db91a1d67bb7c4e17f5cc3596e" translate="yes" xml:space="preserve">
          <source>Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:</source>
          <target state="translated">你可以不直接对一个数组进行排序,而是计算一个数组指数的排列组合,将数组放入排序顺序。</target>
        </trans-unit>
        <trans-unit id="d807ed905e686ec4c6c31127918a04393e4003ae" translate="yes" xml:space="preserve">
          <source>Instead of immediately running the command, backticks create a &lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; object to represent the command. You can use this object to connect the command to others via pipes, &lt;a href=&quot;../../base/base/index#Base.run&quot;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/a&gt; it, and &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">反引号不是立即运行命令，而是创建一个&lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt;对象来表示命令。您可以使用此对象通过管道命令连接到其他人，&lt;a href=&quot;../../base/base/index#Base.run&quot;&gt; &lt;code&gt;run&lt;/code&gt; &lt;/a&gt;它，并&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;它。</target>
        </trans-unit>
        <trans-unit id="78863694892c2019c43a79b283ebb340da799f84" translate="yes" xml:space="preserve">
          <source>Instead of loading a registered version of &lt;code&gt;Example&lt;/code&gt;, Julia will load the source code contained in &lt;code&gt;tutorial/dev/Example&lt;/code&gt;.</source>
          <target state="translated">代替加载 &lt;code&gt;Example&lt;/code&gt; 的注册版本，Julia将加载 &lt;code&gt;tutorial/dev/Example&lt;/code&gt; 中包含的源代码。</target>
        </trans-unit>
        <trans-unit id="80cddaa6c38b52b1b6910a5df7e62d1058e97067" translate="yes" xml:space="preserve">
          <source>Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments. When a generated function is called, the expression it returns is compiled and then run. To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on allowed constructs.</source>
          <target state="translated">生成函数声明不是执行一些计算或动作,而是返回一个引号的表达式,然后形成与参数类型相对应的方法的主体。当一个生成函数被调用时,它返回的表达式会被编译,然后运行。为了提高效率,通常会对结果进行缓存。而为了使之可推断,只有有限的语言子集可以使用。因此,生成函数提供了一种将工作从运行时转移到编译时的灵活方式,但代价是对允许的构造有更大的限制。</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="a3a52a1be0f1de968cc5d8921a39676d67c34867" translate="yes" xml:space="preserve">
          <source>Instead, use a semicolon or insert a line break after &lt;code&gt;catch&lt;/code&gt;:</source>
          <target state="translated">而是使用分号或在 &lt;code&gt;catch&lt;/code&gt; 后面插入换行符：</target>
        </trans-unit>
        <trans-unit id="3f6b46a05cf7ae83de7f241a566b6dcab9f9f12b" translate="yes" xml:space="preserve">
          <source>Integer division (the &lt;code&gt;div&lt;/code&gt; function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt;) by -1. Both of these cases throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt;. The remainder and modulus functions (&lt;code&gt;rem&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;) throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt; when their second argument is zero.</source>
          <target state="translated">整数除法（ &lt;code&gt;div&lt;/code&gt; 函数）有两种特殊情况：除以零，并将最低的负数（&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt;）除以-1。这两种情况都抛出&lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; &lt;/a&gt;。余数和模数函数（ &lt;code&gt;rem&lt;/code&gt; 和 &lt;code&gt;mod&lt;/code&gt; ）在第二个参数为零时抛出&lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27477953a7f5629b70d1f8667b4ce5a95bd7d163" translate="yes" xml:space="preserve">
          <source>Integer division was attempted with a denominator value of 0.</source>
          <target state="translated">尝试整数除法,分母值为0。</target>
        </trans-unit>
        <trans-unit id="44e36daccd6ac7a9f894c249dbe1f367783e4537" translate="yes" xml:space="preserve">
          <source>Integer square root: the largest integer &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt;.</source>
          <target state="translated">整数平方根：使得 &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt; 的最大整数 &lt;code&gt;m&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0f622cf48cf7d80bd106d7df1f3da91566c330d" translate="yes" xml:space="preserve">
          <source>Integer value N launches N additional local worker processes; &lt;code&gt;auto&lt;/code&gt; launches as many workers as the number of local CPU threads (logical cores)</source>
          <target state="translated">整数N会启动N个其他本地工作进程； &lt;code&gt;auto&lt;/code&gt; 启动与本地CPU线程（逻辑核心）数量一样多的工作程序</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="0be1ec1ce9bd8f5a453ecb566c11ab0a7c7144d0" translate="yes" xml:space="preserve">
          <source>Integers and Floating-Point Numbers</source>
          <target state="translated">整数和浮点数</target>
        </trans-unit>
        <trans-unit id="cdcba026c96bc24c46aaded28b7a473dd9b651d8" translate="yes" xml:space="preserve">
          <source>Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, &lt;code&gt;1&lt;/code&gt; is an integer literal, while &lt;code&gt;1.0&lt;/code&gt; is a floating-point literal; their binary in-memory representations as objects are numeric primitives.</source>
          <target state="translated">整数和浮点值是算术和计算的基本构建块。这种值的内置表示形式称为数字原语，而整数和浮点数的表示形式作为代码中的立即值称为数字文字。例如， &lt;code&gt;1&lt;/code&gt; 是整数文字，而 &lt;code&gt;1.0&lt;/code&gt; 是浮点文字；它们作为对象的二进制内存表示形式是数字基元。</target>
        </trans-unit>
        <trans-unit id="be404ce277aac9d3b9b27f0140b709ff517b7820" translate="yes" xml:space="preserve">
          <source>Integers are compared in the standard manner &amp;ndash; by comparison of bits. Floating-point numbers are compared according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;:</source>
          <target state="translated">以标准方式比较整数-通过比较位。浮点数根据&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754标准进行比较&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="70680c64952b0114adcda3eb14a614e1841cd0c6" translate="yes" xml:space="preserve">
          <source>Integral Around A Point Operator</source>
          <target state="translated">绕点算子的积分</target>
        </trans-unit>
        <trans-unit id="425335bd88e128f008b3f48181d1c27b517bcc72" translate="yes" xml:space="preserve">
          <source>Integral Average With Slash</source>
          <target state="translated">带斜线的整数平均值</target>
        </trans-unit>
        <trans-unit id="c6bac88caff6c11517b441d63dd4587857621bab" translate="yes" xml:space="preserve">
          <source>Integral With Double Stroke</source>
          <target state="translated">整体式,带双行程</target>
        </trans-unit>
        <trans-unit id="18238ecc8130fd86a404d903215b4901fbd6604e" translate="yes" xml:space="preserve">
          <source>Integral With Intersection</source>
          <target state="translated">整体与交叉点</target>
        </trans-unit>
        <trans-unit id="8a62b59c92abaaa075d87faf375d4d0d5e2fdc39" translate="yes" xml:space="preserve">
          <source>Integral With Overbar</source>
          <target state="translated">整体带过杆</target>
        </trans-unit>
        <trans-unit id="08588fc154d2b615a7916934fe8e56ebda68acf8" translate="yes" xml:space="preserve">
          <source>Integral With Times Sign</source>
          <target state="translated">与时代符号的整体性</target>
        </trans-unit>
        <trans-unit id="31ecf2a75d24fa7ec2a5569e3665d7f415d4db51" translate="yes" xml:space="preserve">
          <source>Integral With Underbar</source>
          <target state="translated">整体式带下杆</target>
        </trans-unit>
        <trans-unit id="23eafe62fdaca340d651a852cff8f87d44076b09" translate="yes" xml:space="preserve">
          <source>Integral With Union</source>
          <target state="translated">与联盟的整体性</target>
        </trans-unit>
        <trans-unit id="2885cb42f64585560c85104eeedf86ba7e0ed77e" translate="yes" xml:space="preserve">
          <source>Intel's &lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade; Amplifier&lt;/a&gt; (&lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt; in the build configuration), or</source>
          <target state="translated">英特尔的&lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade;放大器&lt;/a&gt;（在构建配置 &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; ），或</target>
        </trans-unit>
        <trans-unit id="207cb56e67212ece90d1329dc4b01521c8f13014" translate="yes" xml:space="preserve">
          <source>Interacting with the contents or methods of &lt;code&gt;Core.Compiler&lt;/code&gt; in any way.</source>
          <target state="translated">以任何方式与 &lt;code&gt;Core.Compiler&lt;/code&gt; 的内容或方法进行交互。</target>
        </trans-unit>
        <trans-unit id="d4f66ae8b3da23aee8b514d4076de7a8e09b0b4e" translate="yes" xml:space="preserve">
          <source>Interactive Utilities</source>
          <target state="translated">互动实用工具</target>
        </trans-unit>
        <trans-unit id="71fefc1d52a78f40748037e8a91fc8ea4f8e2578" translate="yes" xml:space="preserve">
          <source>Interactive mode; REPL runs and &lt;code&gt;isinteractive()&lt;/code&gt; is true</source>
          <target state="translated">互动模式；REPL运行并且 &lt;code&gt;isinteractive()&lt;/code&gt; 为true</target>
        </trans-unit>
        <trans-unit id="0270e20982d6093d44ba136572cbf822d6290a5d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_llvm</source>
          <target state="translated">InteractiveUtils.@code_llvm</target>
        </trans-unit>
        <trans-unit id="0309be470088530490561ff83d97b95071df357e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_lowered</source>
          <target state="translated">InteractiveUtils.@code_lowered</target>
        </trans-unit>
        <trans-unit id="00a7a46c62638c2b2d4deb9dc4bd43a8d3c3582c" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_native</source>
          <target state="translated">InteractiveUtils.@code_native</target>
        </trans-unit>
        <trans-unit id="4fa27864c86ced13027d392baeedb020be6c560a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_typed</source>
          <target state="translated">InteractiveUtils.@code_typed</target>
        </trans-unit>
        <trans-unit id="1e45473f814223dcb1c417d561e1870e1450bf83" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_warntype</source>
          <target state="translated">InteractiveUtils.@code_warntype</target>
        </trans-unit>
        <trans-unit id="eedef913d7842aa079f915bdbbb5f5e90c47c7f6" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@edit</source>
          <target state="translated">InteractiveUtils.@edit</target>
        </trans-unit>
        <trans-unit id="a6df5f45ac03e2c658d92e8736e88cafa5b98995" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@functionloc</source>
          <target state="translated">InteractiveUtils.@functionloc</target>
        </trans-unit>
        <trans-unit id="49e359f4c318b876f99ccb7d37f63e69deb2003d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@less</source>
          <target state="translated">InteractiveUtils.@less</target>
        </trans-unit>
        <trans-unit id="6e359d1c5b33d4212df3c4f8c3762813890df9ae" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@which</source>
          <target state="translated">InteractiveUtils.@which</target>
        </trans-unit>
        <trans-unit id="2d50f6ed31622302ae5f5a5feebfb95f2c420a04" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.clipboard()</source>
          <target state="translated">InteractiveUtils.clipboard()</target>
        </trans-unit>
        <trans-unit id="c1ad553095bd7ae0c9db5b342934998a5be27479" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_llvm()</source>
          <target state="translated">InteractiveUtils.code_llvm()</target>
        </trans-unit>
        <trans-unit id="a70df8f6770abff941be7ee8196e397ae5bbd4b8" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_native()</source>
          <target state="translated">InteractiveUtils.code_native()</target>
        </trans-unit>
        <trans-unit id="f009b2e3c7cb61122f070c557fb9f4dcd1edf6db" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_warntype()</source>
          <target state="translated">InteractiveUtils.code_warntype()</target>
        </trans-unit>
        <trans-unit id="d4c1c9ee2ecb7996d780a0e5d5ccea921a53d56a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.edit()</source>
          <target state="translated">InteractiveUtils.edit()</target>
        </trans-unit>
        <trans-unit id="424927890145616c60279ce930588fd54c4ac90e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.less()</source>
          <target state="translated">InteractiveUtils.less()</target>
        </trans-unit>
        <trans-unit id="49eeeef411d4549f28b217525726cf46e51440cb" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.methodswith()</source>
          <target state="translated">InteractiveUtils.methodswith()</target>
        </trans-unit>
        <trans-unit id="59973fd047bc66e11de11bff485ff30fc8072b48" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.subtypes()</source>
          <target state="translated">InteractiveUtils.subtypes()</target>
        </trans-unit>
        <trans-unit id="8cc40b484c66058018a0b8c42f2ab741a2014154" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.varinfo()</source>
          <target state="translated">InteractiveUtils.varinfo()</target>
        </trans-unit>
        <trans-unit id="391d124220b1a9c25f8d3323e7bb133c849aadc9" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.versioninfo()</source>
          <target state="translated">InteractiveUtils.versioninfo()</target>
        </trans-unit>
        <trans-unit id="068a8966386d6f477f70dcc54b094caba48a03f4" translate="yes" xml:space="preserve">
          <source>Intercalate</source>
          <target state="translated">Intercalate</target>
        </trans-unit>
        <trans-unit id="a791af570ec4e5730c5e110c39b173c357ea4d3a" translate="yes" xml:space="preserve">
          <source>Interconverts between dense and sparse formats.</source>
          <target state="translated">在密集和稀疏格式之间进行转换。</target>
        </trans-unit>
        <trans-unit id="c3229f4e0f20d697072608271bc7f20c5b6d789f" translate="yes" xml:space="preserve">
          <source>Interface to BLAS subroutines.</source>
          <target state="translated">BLAS子程序的接口。</target>
        </trans-unit>
        <trans-unit id="bcdb1ff794ae28041f3196a504b6115b3dea810a" translate="yes" xml:space="preserve">
          <source>Interface to libc, the C standard library.</source>
          <target state="translated">libc,C标准库的接口。</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="c2b213458be4f2f6fdec41d29483b814cba730b1" translate="yes" xml:space="preserve">
          <source>Interfaces to LAPACK subroutines.</source>
          <target state="translated">LAPACK子程序的接口。</target>
        </trans-unit>
        <trans-unit id="a514e8807ceddceeb9d1c2be8e83634758fea386" translate="yes" xml:space="preserve">
          <source>Interior Product</source>
          <target state="translated">内部产品</target>
        </trans-unit>
        <trans-unit id="0c4a9d0a55deb37d51d5b2b7f615f0874ed971d8" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;promote_type&lt;/code&gt; is used inside of &lt;code&gt;promote&lt;/code&gt; to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, which defines the complete promotion mechanism in about 35 lines.</source>
          <target state="translated">在内部， &lt;code&gt;promote_type&lt;/code&gt; 在promote内部使用，以确定应将哪种类型的参数值转换为 &lt;code&gt;promote&lt;/code&gt; 。但是，它本身可能会很有用。好奇的读者可以阅读&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; 中&lt;/a&gt;的代码，该代码在大约35行中定义了完整的提升机制。</target>
        </trans-unit>
        <trans-unit id="818408de3c95448c6a4c8c7cc57f8a8c85a4002d" translate="yes" xml:space="preserve">
          <source>Internally, an &lt;code&gt;AbstractChar&lt;/code&gt; type may use a variety of encodings. Conversion via &lt;code&gt;codepoint(char)&lt;/code&gt; will not reveal this encoding because it always returns the Unicode value of the character. &lt;code&gt;print(io, c)&lt;/code&gt; of any &lt;code&gt;c::AbstractChar&lt;/code&gt; produces an encoding determined by &lt;code&gt;io&lt;/code&gt; (UTF-8 for all built-in &lt;code&gt;IO&lt;/code&gt; types), via conversion to &lt;code&gt;Char&lt;/code&gt; if necessary.</source>
          <target state="translated">在内部， &lt;code&gt;AbstractChar&lt;/code&gt; 类型可以使用多种编码。通过 &lt;code&gt;codepoint(char)&lt;/code&gt; 进行的转换不会显示这种编码，因为它始终返回字符的Unicode值。任何 &lt;code&gt;c::AbstractChar&lt;/code&gt; &lt;code&gt;print(io, c)&lt;/code&gt; 都会产生一个由 &lt;code&gt;io&lt;/code&gt; （对于所有内置 &lt;code&gt;IO&lt;/code&gt; 类型为UTF-8）确定的编码，如有必要，可以转换为 &lt;code&gt;Char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4952806e1eda6ad8d06e741bd80f1e6d3a2efafd" translate="yes" xml:space="preserve">
          <source>Internally, this code creates two implementations of the function: a generated one where the first block in &lt;code&gt;if @generated&lt;/code&gt; is used, and a normal one where the &lt;code&gt;else&lt;/code&gt; block is used. Inside the &lt;code&gt;then&lt;/code&gt; part of the &lt;code&gt;if @generated&lt;/code&gt; block, code has the same semantics as other generated functions: argument names refer to types, and the code should return an expression. Multiple &lt;code&gt;if @generated&lt;/code&gt; blocks may occur, in which case the generated implementation uses all of the &lt;code&gt;then&lt;/code&gt; blocks and the alternate implementation uses all of the &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">在内部，此代码创建函数的两种实现：生成的函数，其中使用 &lt;code&gt;if @generated&lt;/code&gt; 中的第一个块，而普通的函数中则使用 &lt;code&gt;else&lt;/code&gt; 块。在 &lt;code&gt;if @generated&lt;/code&gt; 块的 &lt;code&gt;then&lt;/code&gt; 部分中，代码与其他生成的函数具有相同的语义：参数名称引用类型，并且代码应返回表达式。可能会出现多个 &lt;code&gt;if @generated&lt;/code&gt; 块，在这种情况下，生成的实现使用所有 &lt;code&gt;then&lt;/code&gt; 块，而备用实现使用所有 &lt;code&gt;else&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="48012c80f49c5c1a3bff1ed20d31a89b4f215742" translate="yes" xml:space="preserve">
          <source>Interpolating into an unquoted expression is not supported and will cause a compile-time error:</source>
          <target state="translated">不支持向未引用的表达式插值,并会导致编译时错误。</target>
        </trans-unit>
        <trans-unit id="213daae9f453b89afd1148247dfa9083fa51630b" translate="yes" xml:space="preserve">
          <source>Interpolating values via &lt;code&gt;$&lt;/code&gt; is available as of Julia 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="d67b7c5f52f05b37b77a64fd823fc76a0fce5a66" translate="yes" xml:space="preserve">
          <source>Interpret an iterable of key-value pairs as a named tuple, and perform a merge.</source>
          <target state="translated">将键值对的迭代解释为一个命名元组,并执行合并。</target>
        </trans-unit>
        <trans-unit id="cc53b2acfc42c6cf13c71d4c67ea40578eaaf1f7" translate="yes" xml:space="preserve">
          <source>Interpretation: accessing elements of poorly-typed arrays</source>
          <target state="translated">解释:访问类型不佳的数组元素。</target>
        </trans-unit>
        <trans-unit id="7894bb109218bbe3ea53cb08c360e18b2453f383" translate="yes" xml:space="preserve">
          <source>Interpretation: call to a type-unstable function &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">解释：调用类型不稳定的函数 &lt;code&gt;g&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7784e3d882b6a7b4c22ed3b7f03fb99cea250d48" translate="yes" xml:space="preserve">
          <source>Interpretation: function with unstable return type</source>
          <target state="translated">解释:函数的返回类型不稳定</target>
        </trans-unit>
        <trans-unit id="9f71e4dd30d3efc21956f72596ba4278f8921c99" translate="yes" xml:space="preserve">
          <source>Interpretation: getting a field that is of non-leaf type. In this case, &lt;code&gt;ArrayContainer&lt;/code&gt; had a field &lt;code&gt;data::Array{T}&lt;/code&gt;. But &lt;code&gt;Array&lt;/code&gt; needs the dimension &lt;code&gt;N&lt;/code&gt;, too, to be a concrete type.</source>
          <target state="translated">解释：获取非叶子类型的字段。在这种情况下， &lt;code&gt;ArrayContainer&lt;/code&gt; 具有字段 &lt;code&gt;data::Array{T}&lt;/code&gt; 。但是 &lt;code&gt;Array&lt;/code&gt; 也需要尺寸 &lt;code&gt;N&lt;/code&gt; 才能成为具体类型。</target>
        </trans-unit>
        <trans-unit id="f71c83c811d3e87825b69245ec2c0dff4c1686bd" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; in the above example, such output is shown in uppercase.</source>
          <target state="translated">解释&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;的输出（如其表亲&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt; &lt;code&gt;@code_lowered&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt; &lt;code&gt;@code_typed&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt; &lt;code&gt;@code_llvm&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt; &lt;code&gt;@code_native&lt;/code&gt; 的输出&lt;/a&gt;）需要一些实践。您的代码将以其在生成编译的机器代码的方式中被大量消化的形式呈现。大多数表达式都用 &lt;code&gt;::T&lt;/code&gt; 表示的类型注释（例如 &lt;code&gt;T&lt;/code&gt; 可能是&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;）。&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;的最重要特征是非混凝土类型以红色显示；在上面的示例中，此类输出以大写形式显示。</target>
        </trans-unit>
        <trans-unit id="b25ba536a0a42dea499d4fc2b8979e5924399239" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; since this document is written in Markdown, which has no color, in this document, red text is denoted by uppercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc939bea48b5a28296b21d2be9495aa8bccd0b19" translate="yes" xml:space="preserve">
          <source>Interrupt or cancel</source>
          <target state="translated">中断或取消</target>
        </trans-unit>
        <trans-unit id="23165f09bcddd0acc011e45e34282dbbd91bd4cd" translate="yes" xml:space="preserve">
          <source>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</source>
          <target state="translated">中断指定工人上当前正在执行的任务。这相当于在本地机器上按Ctrl-C键。如果没有给定参数,则中断所有工人。</target>
        </trans-unit>
        <trans-unit id="658cc9a8a17acd75a5bc21930b12d446eea71552" translate="yes" xml:space="preserve">
          <source>Intersect all passed in sets and overwrite &lt;code&gt;s&lt;/code&gt; with the result. Maintain order with arrays.</source>
          <target state="translated">相交全部通过中集和覆盖 &lt;code&gt;s&lt;/code&gt; 与结果。维护数组的顺序。</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="7d65fe6f634dc82a5910e500d111d1c2553d45ad" translate="yes" xml:space="preserve">
          <source>Intersection Beside And Joined With Intersection</source>
          <target state="translated">交叉口旁边并与交叉口连接</target>
        </trans-unit>
        <trans-unit id="f70ced5527bc06ac0250ff3ce0c6433b4fc007ad" translate="yes" xml:space="preserve">
          <source>Intersection With Dot</source>
          <target state="translated">与点的交叉点</target>
        </trans-unit>
        <trans-unit id="fea160380c26aea0a6f5cf6d33e5059a2528bb99" translate="yes" xml:space="preserve">
          <source>Intersection With Logical And</source>
          <target state="translated">与逻辑和逻辑的交集</target>
        </trans-unit>
        <trans-unit id="8a447498c8a13bd62bc28a71db064abbbd2ce851" translate="yes" xml:space="preserve">
          <source>Intersection With Overbar</source>
          <target state="translated">与过街天桥的交叉口</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="95010e236dbeb1d0c89e9d5b6ed0ea0da0ed9572" translate="yes" xml:space="preserve">
          <source>Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's signature (when the signature matches).</source>
          <target state="translated">直观地说,这相当于函数的参数类型是函数签名的子类型(当签名匹配时)。</target>
        </trans-unit>
        <trans-unit id="f4bc4f6c3fe38fa1ef542295504817c8e94651bb" translate="yes" xml:space="preserve">
          <source>Inverse Bullet</source>
          <target state="translated">逆向子弹</target>
        </trans-unit>
        <trans-unit id="a2b80ae8599265e5e4df3c9c6eae5101a072d85a" translate="yes" xml:space="preserve">
          <source>Inverse White Circle</source>
          <target state="translated">逆白圈</target>
        </trans-unit>
        <trans-unit id="f5c93f67585d1f2ce3d07fe77774efdd8e1c494a" translate="yes" xml:space="preserve">
          <source>Inverted Exclamation Mark</source>
          <target state="translated">倒置的感叹号</target>
        </trans-unit>
        <trans-unit id="8ed370a70ad4ba84f93ff72e14bb89b2e795837a" translate="yes" xml:space="preserve">
          <source>Inverted Lazy S</source>
          <target state="translated">倒立的懒人S</target>
        </trans-unit>
        <trans-unit id="7e3bf2655c3d6132b1040ffc28240e0e2706a489" translate="yes" xml:space="preserve">
          <source>Inverted Ohm Sign / Mho</source>
          <target state="translated">倒置欧姆符号/Mho</target>
        </trans-unit>
        <trans-unit id="77352625457aa55d3c246bb35487f40a40f194e5" translate="yes" xml:space="preserve">
          <source>Inverted Question Mark</source>
          <target state="translated">倒装问号</target>
        </trans-unit>
        <trans-unit id="1dc2af95223d452f5604dae81acef5fd3a117e33" translate="yes" xml:space="preserve">
          <source>Invoke a method for the given generic function &lt;code&gt;f&lt;/code&gt; matching the specified types &lt;code&gt;argtypes&lt;/code&gt; on the specified arguments &lt;code&gt;args&lt;/code&gt; and passing the keyword arguments &lt;code&gt;kwargs&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; must conform with the specified types in &lt;code&gt;argtypes&lt;/code&gt;, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).</source>
          <target state="translated">为给定泛型函数 &lt;code&gt;f&lt;/code&gt; 调用一个与指定参数 &lt;code&gt;args&lt;/code&gt; 上的指定类型 &lt;code&gt;argtypes&lt;/code&gt; 相匹配并传递关键字参数 &lt;code&gt;kwargs&lt;/code&gt; 的方法。参数 &lt;code&gt;args&lt;/code&gt; 必须符合 &lt;code&gt;argtypes&lt;/code&gt; 中指定的类型，即不会自动执行转换。此方法允许调用除最具体的匹配方法之外的方法，当明确需要更一般的定义的行为时（通常作为同一功能的更具体的方法的实现的一部分），该方法很有用。</target>
        </trans-unit>
        <trans-unit id="f0c54c7c50c82bf234e4ed64cb3ce50f2fd86de8" translate="yes" xml:space="preserve">
          <source>Invoke all handlers from &lt;a href=&quot;#Base.Experimental.register_error_hint&quot;&gt;&lt;code&gt;Experimental.register_error_hint&lt;/code&gt;&lt;/a&gt; for the particular exception type &lt;code&gt;typeof(ex)&lt;/code&gt;. &lt;code&gt;args&lt;/code&gt; must contain any other arguments expected by the handler for that type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe30ecc758896527e5047bf5e1ab5207bc281f3" translate="yes" xml:space="preserve">
          <source>Irrational</source>
          <target state="translated">Irrational</target>
        </trans-unit>
        <trans-unit id="474a6d17a6faabac287216094db27839ef426282" translate="yes" xml:space="preserve">
          <source>Is Julia named after someone or something?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21fa8512b05ce15e621a0c6aca735529c300b50" translate="yes" xml:space="preserve">
          <source>Issue 8859, &quot;Fix least squares&quot;, https://github.com/JuliaLang/julia/pull/8859</source>
          <target state="translated">问题8859,&quot;修正最小二乘法&quot;,https://github.com/JuliaLang/julia/pull/8859。</target>
        </trans-unit>
        <trans-unit id="beadd95d62ed185b3348f8f407f354b8cc251415" translate="yes" xml:space="preserve">
          <source>It also makes writing exponential functions more elegant:</source>
          <target state="translated">这也使得指数函数的编写更加优雅。</target>
        </trans-unit>
        <trans-unit id="f6ba82c6b32228a1dcbba192584fb70b95766cb3" translate="yes" xml:space="preserve">
          <source>It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.</source>
          <target state="translated">它可以更有效率。一些结构可以高效地打包成数组,在某些情况下,编译器能够完全避免分配不可变的对象。</target>
        </trans-unit>
        <trans-unit id="2138e5233860592eb48b0938be0063487a8c3bbe" translate="yes" xml:space="preserve">
          <source>It can happen that &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; is already defined in the &lt;code&gt;Random&lt;/code&gt; module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding &lt;code&gt;SamplerS&lt;/code&gt; type is considered as internal detail, and may be changed without warning.</source>
          <target state="translated">可能发生在 &lt;code&gt;Random&lt;/code&gt; 模块中已经定义了 &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; 。这样一来，实际上就可以跳过步骤1）（如果要专门针对这种特定的RNG类型生成），但是相应的 &lt;code&gt;SamplerS&lt;/code&gt; 类型被视为内部细节，可以在不发出警告的情况下进行更改。</target>
        </trans-unit>
        <trans-unit id="b7db5f9d834448c3fd65f59044d31e02c3be0663" translate="yes" xml:space="preserve">
          <source>It can profile into Julia's core code and even (optionally) into C and Fortran libraries.</source>
          <target state="translated">它可以配置文件到Julia的核心代码中,甚至(可选)到C和Fortran库中。</target>
        </trans-unit>
        <trans-unit id="c491763305aba9f2c8a952732183092d445bd3cb" translate="yes" xml:space="preserve">
          <source>It decomposes &lt;code&gt;[A; B]&lt;/code&gt; into &lt;code&gt;[UC; VS]H&lt;/code&gt;, where &lt;code&gt;[UC; VS]&lt;/code&gt; is a natural orthogonal basis for the column space of &lt;code&gt;[A; B]&lt;/code&gt;, and &lt;code&gt;H = RQ'&lt;/code&gt; is a natural non-orthogonal basis for the rowspace of &lt;code&gt;[A;B]&lt;/code&gt;, where the top rows are most closely attributed to the &lt;code&gt;A&lt;/code&gt; matrix, and the bottom to the &lt;code&gt;B&lt;/code&gt; matrix. The multi-cosine/sine matrices &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt; provide a multi-measure of how much &lt;code&gt;A&lt;/code&gt; vs how much &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; provide directions in which these are measured.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10e801b8b0e3436ff2d170e31afdf3876bf67ea" translate="yes" xml:space="preserve">
          <source>It does not return.</source>
          <target state="translated">它不返回。</target>
        </trans-unit>
        <trans-unit id="62d668cd36ba8709a3dd4638a2eee6fedce824d7" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type and the tuple length is in the set {2-6,8-10,16}.</source>
          <target state="translated">它有一个特殊的编译规则：当 &lt;code&gt;T&lt;/code&gt; 是原始位类型并且元组长度在集合{2-6,8-10,16}中时， &lt;code&gt;VecElement{T}&lt;/code&gt; 的同质元组映射到LLVM &lt;code&gt;vector&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="60e06d084730278b0af0749e7022e6e9535b9603" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f1e7a71c8a1cc6e09f468c80045e4456b3f7b6" translate="yes" xml:space="preserve">
          <source>It has a toplevel &lt;code&gt;path&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; will be mapped to that path, interpreted relative to the directory containing the project file.</source>
          <target state="translated">它具有一个顶级 &lt;code&gt;path&lt;/code&gt; 条目，然后 &lt;code&gt;uuid&lt;/code&gt; 将被映射到该路径，相对于包含项目文件的目录进行解释。</target>
        </trans-unit>
        <trans-unit id="5302402dcc63d9a0a8348f68814a706354ef52ba" translate="yes" xml:space="preserve">
          <source>It has access to a special locally existent function called &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; that creates objects of the block's type.</source>
          <target state="translated">它可以访问一个称为&lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; 的&lt;/a&gt;本地特殊功能，该功能创建块类型的对象。</target>
        </trans-unit>
        <trans-unit id="e219a846f311411f285e81a3aae4c1e7bf0947a9" translate="yes" xml:space="preserve">
          <source>It is almost always preferable to wrap an existing primitive type in a new composite type than to define your own primitive type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fbc8a317cac4fe1eddafff9a3cee6a2e600d5c8" translate="yes" xml:space="preserve">
          <source>It is also important to see how &lt;code&gt;@generated&lt;/code&gt; functions interact with method redefinition. Following the principle that a correct &lt;code&gt;@generated&lt;/code&gt; function must not observe any mutable state or cause any mutation of global state, we see the following behavior. Observe that the generated function &lt;em&gt;cannot&lt;/em&gt; call any method that was not defined prior to the &lt;em&gt;definition&lt;/em&gt; of the generated function itself.</source>
          <target state="translated">同样重要的是要看到 &lt;code&gt;@generated&lt;/code&gt; 函数如何与方法重定义交互。遵循正确的 &lt;code&gt;@generated&lt;/code&gt; 函数不得观察任何可变状态或引起全局状态任何突变的原则，我们看到以下行为。观察到生成的函数&lt;em&gt;不能&lt;/em&gt;调用在&lt;em&gt;定义&lt;/em&gt;生成的函数本身之前未定义的任何方法。</target>
        </trans-unit>
        <trans-unit id="acbe3463a0ccc2ec8908f82ece54174f7671b1ae" translate="yes" xml:space="preserve">
          <source>It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;1[] == 1&lt;/code&gt;). In particular, if &lt;code&gt;x = 0.0&lt;/code&gt; is defined as a scalar, it is an error to attempt to change its value via &lt;code&gt;x[] = 1.0&lt;/code&gt;. A scalar &lt;code&gt;x&lt;/code&gt; can be converted into a zero-dimensional array containing it via &lt;code&gt;fill(x)&lt;/code&gt;, and conversely, a zero-dimensional array &lt;code&gt;a&lt;/code&gt; can be converted to the contained scalar via &lt;code&gt;a[]&lt;/code&gt;. Another difference is that a scalar can participate in linear algebra operations such as &lt;code&gt;2 * rand(2,2)&lt;/code&gt;, but the analogous operation with a zero-dimensional array &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; is an error.</source>
          <target state="translated">了解与普通标量的区别也很重要。标量不是可变容器（即使它们是可迭代的，并且定义了诸如 &lt;code&gt;length&lt;/code&gt; ， &lt;code&gt;getindex&lt;/code&gt; 之类的东西，&lt;em&gt;例如&lt;/em&gt; &lt;code&gt;1[] == 1&lt;/code&gt; ）。特别是，如果将 &lt;code&gt;x = 0.0&lt;/code&gt; 定义为标量，则尝试通过 &lt;code&gt;x[] = 1.0&lt;/code&gt; 更改其值是错误的。标量 &lt;code&gt;x&lt;/code&gt; 可以通过 &lt;code&gt;fill(x)&lt;/code&gt; 转换为包含它的零维数组，相反，零维数组 &lt;code&gt;a&lt;/code&gt; 可以通过 &lt;code&gt;a[]&lt;/code&gt; 转换为包含的标量。另一个区别是标量可以参与线性代数运算，例如 &lt;code&gt;2 * rand(2,2)&lt;/code&gt; ，但是使用零维数组 &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; 的类似操作是错误的。</target>
        </trans-unit>
        <trans-unit id="a6aa34f5f096577fc826b15725104feebe319049" translate="yes" xml:space="preserve">
          <source>It is also often useful to allow iteration over a collection in &lt;em&gt;reverse order&lt;/em&gt; by iterating over &lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt;&lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt;&lt;/a&gt;. To actually support reverse-order iteration, however, an iterator type &lt;code&gt;T&lt;/code&gt; needs to implement &lt;code&gt;iterate&lt;/code&gt; for &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt;. (Given &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt;, the underling iterator of type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;r.itr&lt;/code&gt;.) In our &lt;code&gt;Squares&lt;/code&gt; example, we would implement &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; methods:</source>
          <target state="translated">通过在&lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt; &lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt; &lt;/a&gt;上进行迭代，以&lt;em&gt;相反的顺序&lt;/em&gt;进行集合迭代通常也很有用。但是，要真正支持逆序迭代，迭代器类型 &lt;code&gt;T&lt;/code&gt; 需要为 &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt; 实现 &lt;code&gt;iterate&lt;/code&gt; 。（给出 &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt; ，类型 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;r.itr&lt;/code&gt; 迭代器是r.itr。）在我们的 &lt;code&gt;Squares&lt;/code&gt; 示例中，我们将实现 &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="3e1077394826061ef79c129bd16ea289c7d0ba39" translate="yes" xml:space="preserve">
          <source>It is also possible to apply boldface formatting by using &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; as a color. For instance, to print answers in boldface font, one can use the following as a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">也可以通过使用 &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; 作为颜色来应用粗体格式。例如，要以黑体字显示答案，可以将以下内容用作 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b553bb959838778f24d5092568f001b6908e4f87" translate="yes" xml:space="preserve">
          <source>It is also possible to interact with a Julia REPL in the browser via &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;. See the package home for details.</source>
          <target state="translated">也可以通过&lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;与浏览器中的Julia REPL进行交互。有关详细信息，请参见软件包主页。</target>
        </trans-unit>
        <trans-unit id="107b61cbdd6b182357e4837cba9afce4360112e7" translate="yes" xml:space="preserve">
          <source>It is also used to &lt;code&gt;show&lt;/code&gt; julia source code which has gone through macro hygiene or otherwise contains variable names which can't be parsed normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f0d3358e54fed68167ad7e2f2668925a7d33bb" translate="yes" xml:space="preserve">
          <source>It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like &lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt;&lt;code&gt;pi&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">还值得强调的是，函数应该带有参数，而不是直接对全局变量进行操作（除了像&lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt; &lt;code&gt;pi&lt;/code&gt; &lt;/a&gt;这样的常量）。</target>
        </trans-unit>
        <trans-unit id="af4f80c2a3eb6b9cc2e18a2eac5ff00feaaaca4a" translate="yes" xml:space="preserve">
          <source>It is better to avoid errors than to rely on catching them.</source>
          <target state="translated">避免出错,不如依靠抓错。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
