<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="bd271b290661f2d2dcd371ac877e792e11b0ae4c" translate="yes" xml:space="preserve">
          <source>In place of the written syntax, the macro call is expanded at parse time to its returned result. This is equivalent to writing:</source>
          <target state="translated">取代书面语法,宏调用在解析时扩展到它的返回结果。这就相当于写。</target>
        </trans-unit>
        <trans-unit id="f1faf89b83d5028304b1044be098d4330cb094e6" translate="yes" xml:space="preserve">
          <source>In practice, especially when providing reusable functionality, one generally wraps &lt;a href=&quot;../../base/c/index#ccall&quot;&gt;&lt;code&gt;ccall&lt;/code&gt;&lt;/a&gt; uses in Julia functions that set up arguments and then check for errors in whatever manner the C or Fortran function indicates them, propagating to the Julia caller as exceptions. This is especially important since C and Fortran APIs are notoriously inconsistent about how they indicate error conditions. For example, the &lt;code&gt;getenv&lt;/code&gt; C library function is wrapped in the following Julia function, which is a simplified version of the actual definition from &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt;&lt;code&gt;env.jl&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在实践中，尤其是在提供可重用功能时，通常将&lt;a href=&quot;../../base/c/index#ccall&quot;&gt; &lt;code&gt;ccall&lt;/code&gt; &lt;/a&gt;用途包装在Julia函数中，以建立参数，然后以C或Fortran函数指示它们的任何方式检查错误，并传播给Julia调用方作为异常。这一点特别重要，因为众所周知，C和Fortran API在指示错误情况的方式上是不一致的。例如， &lt;code&gt;getenv&lt;/code&gt; C库函数包装在以下Julia函数中，该函数是&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/env.jl&quot;&gt; &lt;code&gt;env.jl&lt;/code&gt; 中&lt;/a&gt;实际定义的简化版本：</target>
        </trans-unit>
        <trans-unit id="804d748c80f6e79bb9e342f1f2304330f7eae29d" translate="yes" xml:space="preserve">
          <source>In principle, the Markdown parser itself can also be arbitrarily extended by packages, or an entirely custom flavour of Markdown can be used, but this should generally be unnecessary.</source>
          <target state="translated">原则上,Markdown解析器本身也可以通过软件包任意扩展,或者使用完全自定义的Markdown风味,但一般来说应该没有必要。</target>
        </trans-unit>
        <trans-unit id="f1e4e6ce2511929e6de42c91eafd73bc415389d8" translate="yes" xml:space="preserve">
          <source>In short, it is an immutable dictionary that is a subclass of &lt;code&gt;IO&lt;/code&gt;. It supports standard dictionary operations such as &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, and can also be used as an I/O stream.</source>
          <target state="translated">简而言之，它是不可变的字典，是 &lt;code&gt;IO&lt;/code&gt; 的子类。它支持标准字典操作，如&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;，也可以用作I / O流。</target>
        </trans-unit>
        <trans-unit id="638b74bbfc0d77182896b29b38f7e41990e9ec77" translate="yes" xml:space="preserve">
          <source>In some applications, an alternative to zeroing subnormal numbers is to inject a tiny bit of noise. For example, instead of initializing &lt;code&gt;a&lt;/code&gt; with zeros, initialize it with:</source>
          <target state="translated">在某些应用中，将零下数归零的一种替代方法是注入一点噪声。例如，不要用零初始化 &lt;code&gt;a&lt;/code&gt; ，而是用：</target>
        </trans-unit>
        <trans-unit id="c0f7478a3f0be2e5b9c7e0905c13888f63fbab1a" translate="yes" xml:space="preserve">
          <source>In some applications, it is convenient to store explicit zero values in a &lt;code&gt;SparseMatrixCSC&lt;/code&gt;. These &lt;em&gt;are&lt;/em&gt; accepted by functions in &lt;code&gt;Base&lt;/code&gt; (but there is no guarantee that they will be preserved in mutating operations). Such explicitly stored zeros are treated as structural nonzeros by many routines. The &lt;a href=&quot;#SparseArrays.nnz&quot;&gt;&lt;code&gt;nnz&lt;/code&gt;&lt;/a&gt; function returns the number of elements explicitly stored in the sparse data structure, including structural nonzeros. In order to count the exact number of numerical nonzeros, use &lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt;&lt;code&gt;count(!iszero, x)&lt;/code&gt;&lt;/a&gt;, which inspects every stored element of a sparse matrix. &lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt;&lt;code&gt;dropzeros&lt;/code&gt;&lt;/a&gt;, and the in-place &lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt;&lt;code&gt;dropzeros!&lt;/code&gt;&lt;/a&gt;, can be used to remove stored zeros from the sparse matrix.</source>
          <target state="translated">在某些应用程序中，在 &lt;code&gt;SparseMatrixCSC&lt;/code&gt; 中存储显式零值很方便。这些&lt;em&gt;被&lt;/em&gt; &lt;code&gt;Base&lt;/code&gt; 中的函数接受（但不能保证它们会在变异操作中保留）。这样的显式存储的零被许多例程视为结构非零。所述&lt;a href=&quot;#SparseArrays.nnz&quot;&gt; &lt;code&gt;nnz&lt;/code&gt; &lt;/a&gt;函数返回明确地存储在稀疏数据结构元素，包括结构非零元素的个数。为了计算数字非零的确切数量，请使用&lt;a href=&quot;../../base/collections/index#Base.count&quot;&gt; &lt;code&gt;count(!iszero, x)&lt;/code&gt; &lt;/a&gt;，它检查稀疏矩阵的每个存储元素。&lt;a href=&quot;#SparseArrays.dropzeros&quot;&gt; &lt;code&gt;dropzeros&lt;/code&gt; &lt;/a&gt;和就地&lt;a href=&quot;#SparseArrays.dropzeros!&quot;&gt; &lt;code&gt;dropzeros!&lt;/code&gt; &lt;/a&gt;可用于从稀疏矩阵中删除存储的零。</target>
        </trans-unit>
        <trans-unit id="7200ec90f922f3162b688616528f07bbd46b3f3f" translate="yes" xml:space="preserve">
          <source>In some cases changing the value of a &lt;code&gt;const&lt;/code&gt; variable gives a warning instead of an error. However, this can produce unpredictable behavior or corrupt the state of your program, and so should be avoided. This feature is intended only for convenience during interactive use.</source>
          <target state="translated">在某些情况下，更改 &lt;code&gt;const&lt;/code&gt; 变量的值会发出警告而不是错误。但是，这可能会导致无法预测的行为或破坏程序的状态，因此应避免使用。此功能仅是为了方便交互使用。</target>
        </trans-unit>
        <trans-unit id="0bca4b7af7b2c3f590b22d6bdc9c439dda8d86d1" translate="yes" xml:space="preserve">
          <source>In some cases it might be convenient not to have to define &lt;code&gt;MyStyle&lt;/code&gt;, in which case you can leverage one of the general broadcast wrappers:</source>
          <target state="translated">在某些情况下，不必定义 &lt;code&gt;MyStyle&lt;/code&gt; 可能会很方便，在这种情况下，您可以利用常规广播包装器之一：</target>
        </trans-unit>
        <trans-unit id="6f5f29a98f7076181fba48634a540b92f8996002" translate="yes" xml:space="preserve">
          <source>In some cases no reduction operator is needed, and we merely wish to apply a function to all integers in some range (or, more generally, to all elements in some collection). This is another useful operation called &lt;em&gt;parallel map&lt;/em&gt;, implemented in Julia as the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; function. For example, we could compute the singular values of several large random matrices in parallel as follows:</source>
          <target state="translated">在某些情况下，不需要归约运算符，而我们仅希望将函数应用于某个范围内的所有整数（或更笼统地说，应用于某个集合中的所有元素）。这是另一个有用的操作，称为&lt;em&gt;并行映射&lt;/em&gt;，在Julia中作为&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;函数实现。例如，我们可以并行计算以下几个大型随机矩阵的奇异值：</target>
        </trans-unit>
        <trans-unit id="6de51e42bc98441adfec5061cc53937870969a7a" translate="yes" xml:space="preserve">
          <source>In some cases, for a given RNG type, generating an array of random values can be more efficient with a specialized method than by merely using the decoupling technique explained before. This is for example the case for &lt;code&gt;MersenneTwister&lt;/code&gt;, which natively writes random values in an array.</source>
          <target state="translated">在某些情况下，对于给定的RNG类型，使用专用方法生成随机值数组可能比仅使用之前说明的解耦技术更有效。例如， &lt;code&gt;MersenneTwister&lt;/code&gt; 就是这种情况，它本机将随机值写入数组。</target>
        </trans-unit>
        <trans-unit id="f953f89be50274569ebdd1d16dd1091ac2cf9f4a" translate="yes" xml:space="preserve">
          <source>In some cases, it is useful to adjust the behavior of &lt;code&gt;show&lt;/code&gt; methods depending on the context. This can be achieved via the &lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt;&lt;code&gt;IOContext&lt;/code&gt;&lt;/a&gt; type, which allows passing contextual properties together with a wrapped IO stream. For example, we can build a shorter representation in our &lt;code&gt;show&lt;/code&gt; method when the &lt;code&gt;:compact&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, falling back to the long representation if the property is &lt;code&gt;false&lt;/code&gt; or absent:</source>
          <target state="translated">在某些情况下，根据上下文调整 &lt;code&gt;show&lt;/code&gt; 方法的行为很有用。这可以通过&lt;a href=&quot;../../base/io-network/index#Base.IOContext&quot;&gt; &lt;code&gt;IOContext&lt;/code&gt; &lt;/a&gt;类型实现，该类型允许将上下文属性与包装的IO流一起传递。例如，当 &lt;code&gt;:compact&lt;/code&gt; 属性设置为 &lt;code&gt;true&lt;/code&gt; 时，可以在 &lt;code&gt;show&lt;/code&gt; 方法中构建一个较短的表示形式，如果该属性为 &lt;code&gt;false&lt;/code&gt; 或不存在，则退回到长表示形式：</target>
        </trans-unit>
        <trans-unit id="ef681cb1496bc3731bd754661d5504701ec7c4ad" translate="yes" xml:space="preserve">
          <source>In some cases, whether one wants to generate only a handful of values or a large number of values will have an impact on the choice of algorithm. This is handled with the third parameter of the &lt;code&gt;Sampler&lt;/code&gt; constructor. Let's assume we defined two helper types for &lt;code&gt;Die&lt;/code&gt;, say &lt;code&gt;SamplerDie1&lt;/code&gt; which should be used to generate only few random values, and &lt;code&gt;SamplerDieMany&lt;/code&gt; for many values. We can use those types as follows:</source>
          <target state="translated">在某些情况下，是只生成少量值还是生成大量值都会影响算法的选择。这是通过 &lt;code&gt;Sampler&lt;/code&gt; 构造函数的第三个参数处理的。假设我们定义了两个帮手类型 &lt;code&gt;Die&lt;/code&gt; ，说 &lt;code&gt;SamplerDie1&lt;/code&gt; 它应该被用来生成只有少数的随机值，并 &lt;code&gt;SamplerDieMany&lt;/code&gt; 许多值。我们可以按如下方式使用这些类型：</target>
        </trans-unit>
        <trans-unit id="793adcc5e6d1a8b0006e672f0871fab8bd1ee12e" translate="yes" xml:space="preserve">
          <source>In some situations, your function may need to allocate memory as part of its operation, and this can complicate the simple picture above. In such cases, consider using one of the &lt;a href=&quot;#tools-1&quot;&gt;tools&lt;/a&gt; below to diagnose problems, or write a version of your function that separates allocation from its algorithmic aspects (see &lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;Pre-allocating outputs&lt;/a&gt;).</source>
          <target state="translated">在某些情况下，您的函数可能需要分配内存作为其操作的一部分，这会使上面的简单图片变得复杂。在这种情况下，请考虑使用以下&lt;a href=&quot;#tools-1&quot;&gt;工具&lt;/a&gt;之一来诊断问题，或编写将您的分配与算法方面分开的函数版本（请参见&lt;a href=&quot;#Pre-allocating-outputs-1&quot;&gt;预分配输出&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="2a0f5f99ad11403dc52acb366ff631558f32f389" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; for the tests.</source>
          <target state="translated">在下面的步骤2中，编辑 &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; 以更改源代码，并 &lt;code&gt;MyPkg/test/runtests.jl&lt;/code&gt; 以进行测试。</target>
        </trans-unit>
        <trans-unit id="18fa22072854af164b60f3647ea657dba3a66a38" translate="yes" xml:space="preserve">
          <source>In step 2 below, edit &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; to change the source code, and create any test file of your choosing.</source>
          <target state="translated">在下面的步骤2中，编辑 &lt;code&gt;MyPkg/src/MyPkg.jl&lt;/code&gt; 以更改源代码，并创建您选择的任何测试文件。</target>
        </trans-unit>
        <trans-unit id="4a0eaae9f72d9710fb65a9583dfc845568e81d5f" translate="yes" xml:space="preserve">
          <source>In such cases one should redesign the code to avoid the possibility of a race condition or use &lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;synchronization primitives&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，应该重新设计代码，以避免发生竞争状况或使用&lt;a href=&quot;https://docs.julialang.org/en/latest/base/multi-threading/#Synchronization-Primitives-1&quot;&gt;同步原语&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="2e9e71bba5509813057399a4f8d90c9c53704d76" translate="yes" xml:space="preserve">
          <source>In such cases, the result is always 1-d.</source>
          <target state="translated">在这种情况下,结果总是1-d。</target>
        </trans-unit>
        <trans-unit id="c795388eedec3a869fe287bc8b5bbacb71a43dbd" translate="yes" xml:space="preserve">
          <source>In technical-computing languages, it is common to have &quot;vectorized&quot; versions of functions, which simply apply a given function &lt;code&gt;f(x)&lt;/code&gt; to each element of an array &lt;code&gt;A&lt;/code&gt; to yield a new array via &lt;code&gt;f(A)&lt;/code&gt;. This kind of syntax is convenient for data processing, but in other languages vectorization is also often required for performance: if loops are slow, the &quot;vectorized&quot; version of a function can call fast library code written in a low-level language. In Julia, vectorized functions are &lt;em&gt;not&lt;/em&gt; required for performance, and indeed it is often beneficial to write your own loops (see &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;), but they can still be convenient. Therefore, &lt;em&gt;any&lt;/em&gt; Julia function &lt;code&gt;f&lt;/code&gt; can be applied elementwise to any array (or other collection) with the syntax &lt;code&gt;f.(A)&lt;/code&gt;. For example, &lt;code&gt;sin&lt;/code&gt; can be applied to all elements in the vector &lt;code&gt;A&lt;/code&gt; like so:</source>
          <target state="translated">在技​​术计算语言中，通常有函数的&amp;ldquo;向量化&amp;rdquo;版本，这些版本仅将给定函数 &lt;code&gt;f(x)&lt;/code&gt; 应用于数组 &lt;code&gt;A&lt;/code&gt; 的每个元素，以通过 &lt;code&gt;f(A)&lt;/code&gt; 生成新数组。这种语法对于数据处理很方便，但是在其他语言中，性能通常也需要向量化：如果循环很慢，则函数的&amp;ldquo;向量化&amp;rdquo;版本可以调用以低级语言编写的快速库代码。在Julia中，矢量化函数&lt;em&gt;并不是&lt;/em&gt;执行性能所必需的，实际上编写自己的循环通常是有好处的（请参见&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;），但是它们仍然很方便。因此，&lt;em&gt;任何&lt;/em&gt; Julia函数 &lt;code&gt;f&lt;/code&gt; 可以使用语法 &lt;code&gt;f.(A)&lt;/code&gt; 逐元素地应用于任何数组（或其他集合）。例如，可以将 &lt;code&gt;sin&lt;/code&gt; 应用于向量 &lt;code&gt;A&lt;/code&gt; 中的所有元素，如下所示：</target>
        </trans-unit>
        <trans-unit id="1295513c71d65c30e7efa46afbaa35e5c9e76740" translate="yes" xml:space="preserve">
          <source>In terms of UNIX plumbing, what's happening here is that a single UNIX pipe object is created and written to by both &lt;code&gt;echo&lt;/code&gt; processes, and the other end of the pipe is read from by the &lt;code&gt;sort&lt;/code&gt; command.</source>
          <target state="translated">就UNIX管道而言，这里发生的是两个 &lt;code&gt;echo&lt;/code&gt; 进程都创建并写入了一个UNIX管道对象，而 &lt;code&gt;sort&lt;/code&gt; 命令从管道的另一端读取了管道对象。</target>
        </trans-unit>
        <trans-unit id="bc29b396f06d90d9310efc41817564ce48560df4" translate="yes" xml:space="preserve">
          <source>In the Julia REPL and several other Julia editing environments, you can type many Unicode math symbols by typing the backslashed LaTeX symbol name followed by tab. For example, the variable name &lt;code&gt;&amp;delta;&lt;/code&gt; can be entered by typing &lt;code&gt;\delta&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;, or even &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; by &lt;code&gt;\alpha&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\hat&lt;/code&gt;- &lt;em&gt;tab&lt;/em&gt;-&lt;code&gt;\_2&lt;/code&gt;-&lt;em&gt;tab&lt;/em&gt;. (If you find a symbol somewhere, e.g. in someone else's code, that you don't know how to type, the REPL help will tell you: just type &lt;code&gt;?&lt;/code&gt; and then paste the symbol.)</source>
          <target state="translated">在Julia REPL和其他几个Julia编辑环境中，您可以通过键入反斜杠LaTeX符号名称后跟制表符来键入许多Unicode数学符号。例如，变量名 &lt;code&gt;&amp;delta;&lt;/code&gt; 可以通过打字输入 &lt;code&gt;\delta&lt;/code&gt; - &lt;em&gt;标签&lt;/em&gt;，或甚至 &lt;code&gt;&amp;alpha;̂₂&lt;/code&gt; 通过 &lt;code&gt;\alpha&lt;/code&gt; - &lt;em&gt;标签&lt;/em&gt; - &lt;code&gt;\hat&lt;/code&gt; - &lt;em&gt;标签&lt;/em&gt; - &lt;code&gt;\_2&lt;/code&gt; - &lt;em&gt;标签&lt;/em&gt;。 （如果您在某个地方（例如在他人的代码中）发现不知道如何键入的符号，则REPL帮助将告诉您：只需键入 &lt;code&gt;?&lt;/code&gt; ，然后粘贴该符号即可。）</target>
        </trans-unit>
        <trans-unit id="7569c827c9a13b3faf85c9b20e363a3375ada161" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;@everywhere module Foo&lt;/code&gt; defined &lt;code&gt;Foo&lt;/code&gt; on all nodes. However the call to &lt;code&gt;Foo.foo()&lt;/code&gt; created a new global binding &lt;code&gt;gvar&lt;/code&gt; on the local node, but this was not found on node 2 resulting in an &lt;code&gt;UndefVarError&lt;/code&gt; error.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;@everywhere module Foo&lt;/code&gt; &lt;code&gt;Foo&lt;/code&gt; 在所有节点上定义了Foo。但是，对 &lt;code&gt;Foo.foo()&lt;/code&gt; 的调用在本地节点上创建了一个新的全局绑定 &lt;code&gt;gvar&lt;/code&gt; ，但是在节点2上找不到它，从而导致 &lt;code&gt;UndefVarError&lt;/code&gt; 错误。</target>
        </trans-unit>
        <trans-unit id="4befd8beabfc58d36d63a701ccb0fcbe3c3991f4" translate="yes" xml:space="preserve">
          <source>In the absence of a type declaration with &lt;code&gt;::&lt;/code&gt;, the type of a method parameter is &lt;code&gt;Any&lt;/code&gt; by default, meaning that it is unconstrained since all values in Julia are instances of the abstract type &lt;code&gt;Any&lt;/code&gt;. Thus, we can define a catch-all method for &lt;code&gt;f&lt;/code&gt; like so:</source>
          <target state="translated">如果没有使用 &lt;code&gt;::&lt;/code&gt; 进行类型声明，则默认情况下方法参数的类型为 &lt;code&gt;Any&lt;/code&gt; ，这意味着它不受限制，因为Julia中的所有值都是抽象类型 &lt;code&gt;Any&lt;/code&gt; 的实例。因此，我们可以为 &lt;code&gt;f&lt;/code&gt; 定义一个包罗万象的方法，如下所示：</target>
        </trans-unit>
        <trans-unit id="14e6eb62fa9a3db0a4d3297fcd4c7b6e7504f490" translate="yes" xml:space="preserve">
          <source>In the assignment form, the body of the function must be a single expression, although it can be a compound expression (see &lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Compound Expressions&lt;/a&gt;). Short, simple function definitions are common in Julia. The short function syntax is accordingly quite idiomatic, considerably reducing both typing and visual noise.</source>
          <target state="translated">在赋值形式中，函数的主体必须是单个表达式，尽管它可以是复合表达式（请参见&lt;a href=&quot;../control-flow/index#man-compound-expressions-1&quot;&gt;Compound Expressions&lt;/a&gt;）。简短，简单的函数定义在Julia中很常见。因此，短函数语法非常惯用，大大减少了打字和视觉噪音。</target>
        </trans-unit>
        <trans-unit id="8b4a822ba35b7b2a2b87214b87f56abe71bd6a7e" translate="yes" xml:space="preserve">
          <source>In the body of the generated function you only have access to the &lt;em&gt;types&lt;/em&gt; of the arguments &amp;ndash; not their values &amp;ndash; and any function that was defined &lt;em&gt;before&lt;/em&gt; the definition of the generated function.</source>
          <target state="translated">在生成函数的主体中，您只能访问参数的&lt;em&gt;类型&lt;/em&gt;（而不是参数的值）以及在生成函数的定义&lt;em&gt;之前&lt;/em&gt;定义的任何函数。</target>
        </trans-unit>
        <trans-unit id="d4f8a53fe3cbe9ccdbd0383d96fd01b1b384f1cc" translate="yes" xml:space="preserve">
          <source>In the case of &lt;code&gt;Point&lt;/code&gt;, the type of &lt;code&gt;T&lt;/code&gt; is unambiguously implied if and only if the two arguments to &lt;code&gt;Point&lt;/code&gt; have the same type. When this isn't the case, the constructor will fail with a &lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt;&lt;code&gt;MethodError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在 &lt;code&gt;Point&lt;/code&gt; 的情况下，当且仅当 &lt;code&gt;Point&lt;/code&gt; 的两个参数具有相同的类型时， &lt;code&gt;T&lt;/code&gt; 的类型才明确隐含。如果不是这种情况，则构造函数将失败，并出现&lt;a href=&quot;../../base/base/index#Core.MethodError&quot;&gt; &lt;code&gt;MethodError&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="8083b5b25cdad6fa0ec0e103815341575e54f6a2" translate="yes" xml:space="preserve">
          <source>In the case that the type of &lt;code&gt;a[1]&lt;/code&gt; is not known precisely, &lt;code&gt;x&lt;/code&gt; can be declared via &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt;. The use of the &lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt;&lt;code&gt;convert&lt;/code&gt;&lt;/a&gt; function allows &lt;code&gt;a[1]&lt;/code&gt; to be any object convertible to an &lt;code&gt;Int32&lt;/code&gt; (such as &lt;code&gt;UInt8&lt;/code&gt;), thus increasing the genericity of the code by loosening the type requirement. Notice that &lt;code&gt;convert&lt;/code&gt; itself needs a type annotation in this context in order to achieve type stability. This is because the compiler cannot deduce the type of the return value of a function, even &lt;code&gt;convert&lt;/code&gt;, unless the types of all the function's arguments are known.</source>
          <target state="translated">在该情况下的类型 &lt;code&gt;a[1]&lt;/code&gt; 不是精确已知的， &lt;code&gt;x&lt;/code&gt; 可以声明通过 &lt;code&gt;x = convert(Int32, a[1])::Int32&lt;/code&gt; 。使用&lt;a href=&quot;../../base/base/index#Base.convert&quot;&gt; &lt;code&gt;convert&lt;/code&gt; &lt;/a&gt;函数允许 &lt;code&gt;a[1]&lt;/code&gt; 是可转换为 &lt;code&gt;Int32&lt;/code&gt; 的任何对象（例如 &lt;code&gt;UInt8&lt;/code&gt; ），从而通过放宽类型要求来增加代码的通用性。注意， &lt;code&gt;convert&lt;/code&gt; 本身在此上下文中需要类型注释，以实现类型稳定性。这是因为编译器不能推断出一个函数的返回值的类型，甚至 &lt;code&gt;convert&lt;/code&gt; ，除非所有的函数的参数类型是已知的。</target>
        </trans-unit>
        <trans-unit id="831b049ac64422357fdc2a1f1e12b98990a72d96" translate="yes" xml:space="preserve">
          <source>In the context of an expression, symbols are used to indicate access to variables; when an expression is evaluated, a symbol is replaced with the value bound to that symbol in the appropriate &lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;scope&lt;/a&gt;.</source>
          <target state="translated">在表达式的上下文中，使用符号来表示对变量的访问。在计算表达式时，在适当的&lt;a href=&quot;../variables-and-scoping/index#scope-of-variables-1&quot;&gt;范围内&lt;/a&gt;，将符号替换为绑定到该符号的值。</target>
        </trans-unit>
        <trans-unit id="bb0ccf20285ac1f5e0c9e737c0f406f1f62a6d45" translate="yes" xml:space="preserve">
          <source>In the context of function definitions, the &lt;code&gt;...&lt;/code&gt; operator is used to combine many different arguments into a single argument. This use of &lt;code&gt;...&lt;/code&gt; for combining many different arguments into a single argument is called slurping:</source>
          <target state="translated">在函数定义的上下文中， &lt;code&gt;...&lt;/code&gt; 运算符用于将许多不同的参数组合为一个参数。 &lt;code&gt;...&lt;/code&gt; 用于将许多不同的参数组合为一个参数的用法称为饮：</target>
        </trans-unit>
        <trans-unit id="93652cdf53268e5b525c9968aae662e21595f44e" translate="yes" xml:space="preserve">
          <source>In the end we will present Julia's approach to distributed and parallel computing. With scientific computing in mind, Julia natively implements interfaces to distribute a process across multiple cores or machines. Also we will mention useful external packages for distributed programming like &lt;code&gt;MPI.jl&lt;/code&gt; and &lt;code&gt;DistributedArrays.jl&lt;/code&gt;.</source>
          <target state="translated">最后，我们将介绍Julia的分布式和并行计算方法。考虑到科学计算，Julia本机实现接口以在多个内核或机器之间分配流程。我们还将提到有用的外部程序包，例如 &lt;code&gt;MPI.jl&lt;/code&gt; 和 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d323acfd53199deb66ce97dad2e67a0a4f124fda" translate="yes" xml:space="preserve">
          <source>In the event that a nested test set has no failures, as happened here, it will be hidden in the summary. If we do have a test failure, only the details for the failed test sets will be shown:</source>
          <target state="translated">如果一个嵌套的测试集没有失败,就像这里的情况一样,它将被隐藏在摘要中。如果我们确实有一个测试失败,只有失败的测试集的细节会被显示出来。</target>
        </trans-unit>
        <trans-unit id="381773d3ab62fd2b5a03a4a6a4af80e1db7c0e67" translate="yes" xml:space="preserve">
          <source>In the event that two modules provide non-standard string or command literals with the same name, it is possible to qualify the string or command literal with a module name. For instance, if both &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Bar&lt;/code&gt; provide non-standard string literal &lt;code&gt;@x_str&lt;/code&gt;, then one can write &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; or &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; to disambiguate between the two.</source>
          <target state="translated">如果两个模块提供具有相同名称的非标准字符串或命令文字，则可以使用模块名称来限定字符串或命令文字。例如，如果 &lt;code&gt;Foo&lt;/code&gt; 和 &lt;code&gt;Bar&lt;/code&gt; 都提供非标准字符串文字 &lt;code&gt;@x_str&lt;/code&gt; ，则可以写 &lt;code&gt;Foo.x&quot;literal&quot;&lt;/code&gt; 或 &lt;code&gt;Bar.x&quot;literal&quot;&lt;/code&gt; 来消除两者之间的歧义。</target>
        </trans-unit>
        <trans-unit id="9a888754236863b7dc502d80ea92bd70226cbd16" translate="yes" xml:space="preserve">
          <source>In the example above, the code between &lt;code&gt;#=&lt;/code&gt; and &lt;code&gt;=#&lt;/code&gt; is run as a &lt;code&gt;bash&lt;/code&gt; script. Julia ignores this part since it is a multi-line comment for Julia. The Julia code after &lt;code&gt;=#&lt;/code&gt; is ignored by &lt;code&gt;bash&lt;/code&gt; since it stops parsing the file once it reaches to the &lt;code&gt;exec&lt;/code&gt; statement.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;#=&lt;/code&gt; 和 &lt;code&gt;=#&lt;/code&gt; 之间的代码作为 &lt;code&gt;bash&lt;/code&gt; 脚本运行。朱莉娅忽略了这部分，因为它是朱莉娅的多行注释。 &lt;code&gt;bash&lt;/code&gt; 会忽略 &lt;code&gt;=#&lt;/code&gt; 之后的Julia代码，因为一旦到达 &lt;code&gt;exec&lt;/code&gt; 语句，它将停止解析文件。</target>
        </trans-unit>
        <trans-unit id="7fab8ccf3e309196934d3171621e67c5c348c19f" translate="yes" xml:space="preserve">
          <source>In the example below the in-range check for referencing element &lt;code&gt;i&lt;/code&gt; of array &lt;code&gt;A&lt;/code&gt; is skipped to improve performance.</source>
          <target state="translated">在下面的示例中，跳过了对数组 &lt;code&gt;A&lt;/code&gt; 的引用元素 &lt;code&gt;i&lt;/code&gt; 的范围内检查以提高性能。</target>
        </trans-unit>
        <trans-unit id="93579590b1d00912366971a9f1eaa55dfd5a9050" translate="yes" xml:space="preserve">
          <source>In the example manifest file above, to find the path of the first &lt;code&gt;Priv&lt;/code&gt; package&amp;mdash;the one with UUID &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt;&amp;mdash;Julia looks for its stanza in the manifest file, sees that it has a &lt;code&gt;path&lt;/code&gt; entry, looks at &lt;code&gt;deps/Priv&lt;/code&gt; relative to the &lt;code&gt;App&lt;/code&gt; project directory&amp;mdash;let's suppose the &lt;code&gt;App&lt;/code&gt; code lives in &lt;code&gt;/home/me/projects/App&lt;/code&gt;&amp;mdash;sees that &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; exists and therefore loads &lt;code&gt;Priv&lt;/code&gt; from there.</source>
          <target state="translated">在上面的示例清单文件中，要找到第一个 &lt;code&gt;Priv&lt;/code&gt; 程序包的路径（UUID为 &lt;code&gt;ba13f791-ae1d-465a-978b-69c3ad90f72b&lt;/code&gt; 的程序包），Julia在清单文件中查找其节，看到它具有 &lt;code&gt;path&lt;/code&gt; 条目，相对于 &lt;code&gt;App&lt;/code&gt; 项目目录位于 &lt;code&gt;deps/Priv&lt;/code&gt; （假设 &lt;code&gt;App&lt;/code&gt; 代码位于 &lt;code&gt;/home/me/projects/App&lt;/code&gt; 中),会发现 &lt;code&gt;/home/me/projects/App/deps/Priv&lt;/code&gt; 存在，因此从那里加载 &lt;code&gt;Priv&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d5f7b0ad7d3e9a880bbfbe0e4c7c117bb4c01b0c" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt;, each &lt;code&gt;I_k&lt;/code&gt; may be a scalar index, an array of scalar indices, or an object that represents an array of scalar indices and can be converted to such by &lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt;&lt;code&gt;to_indices&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在表达式 &lt;code&gt;A[I_1, I_2, ..., I_n]&lt;/code&gt; ，每个 &lt;code&gt;I_k&lt;/code&gt; 可以是标量索引，标量索引数组或表示标量索引数组的对象，并且可以通过&lt;a href=&quot;../../base/arrays/index#Base.to_indices&quot;&gt; &lt;code&gt;to_indices&lt;/code&gt; &lt;/a&gt;转换为：</target>
        </trans-unit>
        <trans-unit id="fa27a03548fec1bfca9a5a7f95888f72d9a7ae58" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">在表达式 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 中，仅当 &lt;code&gt;a&lt;/code&gt; 的值为 &lt;code&gt;true&lt;/code&gt; 时才对子表达式 &lt;code&gt;b&lt;/code&gt; 求值。</target>
        </trans-unit>
        <trans-unit id="bac07dea1e6da71dd93fed592d9cea2988762e4a" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;a || b&lt;/code&gt;, the subexpression &lt;code&gt;b&lt;/code&gt; is only evaluated if &lt;code&gt;a&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">在表达式中 &lt;code&gt;a || b&lt;/code&gt; ，仅当 &lt;code&gt;a&lt;/code&gt; 的结果为 &lt;code&gt;false&lt;/code&gt; 时，才对子表达式 &lt;code&gt;b&lt;/code&gt; 进行评估。</target>
        </trans-unit>
        <trans-unit id="96db94e2ee75dc648cf0225c95d894886287a60b" translate="yes" xml:space="preserve">
          <source>In the first example, the return breaks out of &lt;code&gt;test1&lt;/code&gt; as soon as it hits an even number, so &lt;code&gt;test1([5,6,7])&lt;/code&gt; returns &lt;code&gt;12&lt;/code&gt;.</source>
          <target state="translated">在第一个示例中，返回值在碰到偶数后就立即退出 &lt;code&gt;test1&lt;/code&gt; ，因此 &lt;code&gt;test1([5,6,7])&lt;/code&gt; 返回 &lt;code&gt;12&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3b8c088e43cc4d9778c3e9bd051248b7beb86cd4" translate="yes" xml:space="preserve">
          <source>In the first step, a handle to the Julia function &lt;code&gt;sqrt&lt;/code&gt; is retrieved by calling &lt;code&gt;jl_get_function&lt;/code&gt;. The first argument passed to &lt;code&gt;jl_get_function&lt;/code&gt; is a pointer to the &lt;code&gt;Base&lt;/code&gt; module in which &lt;code&gt;sqrt&lt;/code&gt; is defined. Then, the double value is boxed using &lt;code&gt;jl_box_float64&lt;/code&gt;. Finally, in the last step, the function is called using &lt;code&gt;jl_call1&lt;/code&gt;. &lt;code&gt;jl_call0&lt;/code&gt;, &lt;code&gt;jl_call2&lt;/code&gt;, and &lt;code&gt;jl_call3&lt;/code&gt; functions also exist, to conveniently handle different numbers of arguments. To pass more arguments, use &lt;code&gt;jl_call&lt;/code&gt;:</source>
          <target state="translated">第一步，通过调用 &lt;code&gt;jl_get_function&lt;/code&gt; 检索Julia函数 &lt;code&gt;sqrt&lt;/code&gt; 的句柄。传递给 &lt;code&gt;jl_get_function&lt;/code&gt; 的第一个参数是指向其中定义 &lt;code&gt;sqrt&lt;/code&gt; 的 &lt;code&gt;Base&lt;/code&gt; 模块的指针。然后，使用 &lt;code&gt;jl_box_float64&lt;/code&gt; 将双精度值装箱。最后，在最后一步中，使用 &lt;code&gt;jl_call1&lt;/code&gt; 调用该函数。还存在 &lt;code&gt;jl_call0&lt;/code&gt; ， &lt;code&gt;jl_call2&lt;/code&gt; 和 &lt;code&gt;jl_call3&lt;/code&gt; 函数，以方便地处理不同数量的参数。要传递更多参数，请使用 &lt;code&gt;jl_call&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7b958da57c917010bf3ef94ad88b96d1969aed7b" translate="yes" xml:space="preserve">
          <source>In the following REPL session:</source>
          <target state="translated">在下面的REPL会议上:</target>
        </trans-unit>
        <trans-unit id="c8932c25606bd0610c3cdf0d60756b479ad881b6" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes and call a generic function on it.</source>
          <target state="translated">在下面的示例中，我们将同时使用 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; 和 &lt;code&gt;CuArrays.jl&lt;/code&gt; 在多个进程之间分配数组，并在其上调用通用函数。</target>
        </trans-unit>
        <trans-unit id="7ef78cc2f03187abe5d3245512be5e3c871b1647" translate="yes" xml:space="preserve">
          <source>In the following example we will use both &lt;code&gt;DistributedArrays.jl&lt;/code&gt; and &lt;code&gt;CuArrays.jl&lt;/code&gt; to distribute an array across multiple processes by first casting it through &lt;code&gt;distribute()&lt;/code&gt; and &lt;code&gt;CuArray()&lt;/code&gt;.</source>
          <target state="translated">在下面的例子中，我们将同时使用 &lt;code&gt;DistributedArrays.jl&lt;/code&gt; 和 &lt;code&gt;CuArrays.jl&lt;/code&gt; 通过第一铸造分配在多个流程的阵列它通过 &lt;code&gt;distribute()&lt;/code&gt; 和 &lt;code&gt;CuArray()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eddb2dbc7e71b5027d64a28a0762a40add354815" translate="yes" xml:space="preserve">
          <source>In the following examples &lt;code&gt;&quot;...&quot;&lt;/code&gt; is used to illustrate an arbitrary docstring.</source>
          <target state="translated">在以下示例中， &lt;code&gt;&quot;...&quot;&lt;/code&gt; 用于说明任意文档字符串。</target>
        </trans-unit>
        <trans-unit id="89782f85382fa4913d7651a1e194d5e19db89926" translate="yes" xml:space="preserve">
          <source>In the following sections, we briefly go through a few techniques that can help make your Julia code run as fast as possible.</source>
          <target state="translated">在下面的章节中,我们简单地介绍了一些可以帮助你的Julia代码尽可能快地运行的技术。</target>
        </trans-unit>
        <trans-unit id="04625a717e704769cefecb369eb2164fdede25ee" translate="yes" xml:space="preserve">
          <source>In the former case, the integers are widened to system word size and therefore the result is 128. In the latter case, no such widening happens and integer overflow results in -128.</source>
          <target state="translated">在前一种情况下,整数被扩大到系统字的大小,因此结果是128。在后一种情况下,不会发生这样的扩大,整数溢出的结果是-128。</target>
        </trans-unit>
        <trans-unit id="459cd312cf19872b6f89a3fcbc8f7c42d8e4d02e" translate="yes" xml:space="preserve">
          <source>In the last example, a &lt;code&gt;Vector{Any}&lt;/code&gt; is produced; the reason is that &lt;code&gt;eltype(Die) == Any&lt;/code&gt;. The remedy is to define &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt;.</source>
          <target state="translated">在最后一个示例中，产生了一个 &lt;code&gt;Vector{Any}&lt;/code&gt; ；原因是 &lt;code&gt;eltype(Die) == Any&lt;/code&gt; 。解决方法是定义 &lt;code&gt;Base.eltype(::Type{Die}) = Int&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1cbf68db8681a41c42664645e9482a6f5917d216" translate="yes" xml:space="preserve">
          <source>In the latter case, the result type is &lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt;&lt;code&gt;BigInt&lt;/code&gt;&lt;/a&gt; since &lt;code&gt;BigInt&lt;/code&gt; is the only type large enough to hold integers for arbitrary-precision integer arithmetic. Also note that one does not need to define both &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; and &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; &amp;ndash; the symmetry is implied by the way &lt;code&gt;promote_rule&lt;/code&gt; is used in the promotion process.</source>
          <target state="translated">在后一种情况下，结果类型为&lt;a href=&quot;../../base/numbers/index#Base.GMP.BigInt&quot;&gt; &lt;code&gt;BigInt&lt;/code&gt; ,&lt;/a&gt;因为 &lt;code&gt;BigInt&lt;/code&gt; 是唯一足够大以容纳用于任意精度整数算术的整数的类型。另请注意，无需同时定义 &lt;code&gt;promote_rule(::Type{A}, ::Type{B})&lt;/code&gt; 和 &lt;code&gt;promote_rule(::Type{B}, ::Type{A})&lt;/code&gt; &amp;ndash;对称性由在升级过程中使用 &lt;code&gt;promote_rule&lt;/code&gt; 的方式。</target>
        </trans-unit>
        <trans-unit id="898e17acc6c8cf82e0dc07003deafaedea5b3686" translate="yes" xml:space="preserve">
          <source>In these and other cases, you can get the result you want by choosing an &lt;em&gt;input type&lt;/em&gt; that conveys your willingness to accept an &lt;em&gt;output type&lt;/em&gt; in which the result can be represented:</source>
          <target state="translated">在这些和其他情况下，可以通过选择一种表达您愿意接受可以表示结果的&lt;em&gt;输出类型&lt;/em&gt;的&lt;em&gt;输入类型&lt;/em&gt;来获得所需的结果：&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0181a5895aa6ed6a57ecf3e1abb5400987bdae76" translate="yes" xml:space="preserve">
          <source>In these examples, &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt;, which has two fields. &lt;code&gt;b&lt;/code&gt; is an &lt;code&gt;Int&lt;/code&gt;, which is a primitive bitstype with no fields at all. &lt;code&gt;ex&lt;/code&gt; is an &lt;a href=&quot;#Core.ErrorException&quot;&gt;&lt;code&gt;ErrorException&lt;/code&gt;&lt;/a&gt;, which has one field.</source>
          <target state="translated">在这些示例中， &lt;code&gt;a&lt;/code&gt; 是&lt;a href=&quot;../numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;，具有两个字段。 &lt;code&gt;b&lt;/code&gt; 是一个 &lt;code&gt;Int&lt;/code&gt; ，它是一个基本的位类型，根本没有任何字段。 &lt;code&gt;ex&lt;/code&gt; 是一个&lt;a href=&quot;#Core.ErrorException&quot;&gt; &lt;code&gt;ErrorException&lt;/code&gt; &lt;/a&gt;，它具有一个字段。</target>
        </trans-unit>
        <trans-unit id="e95b83474ed0f82b1495ebdd8823b0e63d6666c2" translate="yes" xml:space="preserve">
          <source>In this and all following examples it is assumed that their top-level is a global scope with a clean workspace, for instance a newly started REPL.</source>
          <target state="translated">在这个例子和所有下面的例子中,假设它们的顶层是一个具有干净工作空间的全局作用域,例如一个新启动的 REPL。</target>
        </trans-unit>
        <trans-unit id="ffae775fe01ba274356f2a5f0bbbfa16bf832464" translate="yes" xml:space="preserve">
          <source>In this case &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; MUST be defined in the remote process. Note that &lt;code&gt;A&lt;/code&gt; is a global variable defined in the local workspace. Worker 2 does not have a variable called &lt;code&gt;A&lt;/code&gt; under &lt;code&gt;Main&lt;/code&gt;. The act of shipping the closure &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; to worker 2 results in &lt;code&gt;Main.A&lt;/code&gt; being defined on 2. &lt;code&gt;Main.A&lt;/code&gt; continues to exist on worker 2 even after the call &lt;code&gt;remotecall_fetch&lt;/code&gt; returns. Remote calls with embedded global references (under &lt;code&gt;Main&lt;/code&gt; module only) manage globals as follows:</source>
          <target state="translated">在这种情况下，必须在远程过程中定义&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;。请注意， &lt;code&gt;A&lt;/code&gt; 是在本地工作空间中定义的全局变量。 Worker 2 在 &lt;code&gt;Main&lt;/code&gt; 下没有名为 &lt;code&gt;A&lt;/code&gt; 的变量。航运封闭件的动作 &lt;code&gt;()-&amp;gt;sum(A)&lt;/code&gt; 到工人2个结果 &lt;code&gt;Main.A&lt;/code&gt; 正在对2中定义 &lt;code&gt;Main.A&lt;/code&gt; 继续甚至在调用之后对工人2存在 &lt;code&gt;remotecall_fetch&lt;/code&gt; 回报。具有嵌入式全局引用的远程调用（仅在 &lt;code&gt;Main&lt;/code&gt; 模块下）按以下方式管理全局：</target>
        </trans-unit>
        <trans-unit id="0560676ee24f0b0b03f58f97d95e6f878eed22df" translate="yes" xml:space="preserve">
          <source>In this case &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; is better. It is also more helpful to the compiler to annotate specific uses (e.g. &lt;code&gt;a[i]::Int&lt;/code&gt;) than to try to pack many alternatives into one type.</source>
          <target state="translated">在这种情况下， &lt;code&gt;Vector{Any}(undef, n)&lt;/code&gt; 更好。与尝试将许多替代方法打包成一种类型相比，对编译器进行注释（例如 &lt;code&gt;a[i]::Int&lt;/code&gt; ）也更有用。</target>
        </trans-unit>
        <trans-unit id="e89af6907bd5ca30fed3e340c7ce252f260cfa01" translate="yes" xml:space="preserve">
          <source>In this case a tuple of values is spliced into a varargs call precisely where the variable number of arguments go. This need not be the case, however:</source>
          <target state="translated">在这种情况下,一个值的元组被拼接到varargs调用中,恰恰是变量参数数的去处。然而,情况并非如此。</target>
        </trans-unit>
        <trans-unit id="567cd07e5f348036853e90930a72f1f415e7cf4a" translate="yes" xml:space="preserve">
          <source>In this case the final (empty) line before the closing &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; sets the indentation level.</source>
          <target state="translated">在这种情况下，关闭 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 之前的最后一行（空）将设置缩进级别。</target>
        </trans-unit>
        <trans-unit id="192b075c1bd1fea405ec3cb3c290131367b6aebf" translate="yes" xml:space="preserve">
          <source>In this case, if we try to split up the work using a one-dimensional index, we are likely to run into trouble: if &lt;code&gt;q[i,j,t]&lt;/code&gt; is near the end of the block assigned to one worker and &lt;code&gt;q[i,j,t+1]&lt;/code&gt; is near the beginning of the block assigned to another, it's very likely that &lt;code&gt;q[i,j,t]&lt;/code&gt; will not be ready at the time it's needed for computing &lt;code&gt;q[i,j,t+1]&lt;/code&gt;. In such cases, one is better off chunking the array manually. Let's split along the second dimension. Define a function that returns the &lt;code&gt;(irange, jrange)&lt;/code&gt; indices assigned to this worker:</source>
          <target state="translated">在这种情况下，如果我们尝试使用一维索引拆分工作，则很可能会遇到麻烦：如果 &lt;code&gt;q[i,j,t]&lt;/code&gt; 在分配给一个工人的块的末尾附近，而 &lt;code&gt;q[i,j,t+1]&lt;/code&gt; 在分配给另一个块的开始处附近，很有可能 &lt;code&gt;q[i,j,t]&lt;/code&gt; 在计算 &lt;code&gt;q[i,j,t+1]&lt;/code&gt; 。在这种情况下，最好手动对数组进行分块。让我们沿着第二个维度分裂。定义一个函数，该函数返回分配给此工作程序的 &lt;code&gt;(irange, jrange)&lt;/code&gt; 索引：</target>
        </trans-unit>
        <trans-unit id="b26744f8a00507231770f287451074d8e90f3846" translate="yes" xml:space="preserve">
          <source>In this case, the character &lt;code&gt;&amp;forall;&lt;/code&gt; is a three-byte character, so the indices 2 and 3 are invalid and the next character's index is 4; this next valid index can be computed by &lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt;&lt;code&gt;nextind(s,1)&lt;/code&gt;&lt;/a&gt;, and the next index after that by &lt;code&gt;nextind(s,4)&lt;/code&gt; and so on.</source>
          <target state="translated">在这种情况下，字符 &lt;code&gt;&amp;forall;&lt;/code&gt; 是一个三字节字符，因此索引2和3无效，下一个字符的索引为4；此下一个有效索引可以由&lt;a href=&quot;../../base/strings/index#Base.nextind&quot;&gt; &lt;code&gt;nextind(s,1)&lt;/code&gt; &lt;/a&gt;计算，其后的下一个索引可以由 &lt;code&gt;nextind(s,4)&lt;/code&gt; 依此类推。</target>
        </trans-unit>
        <trans-unit id="e5db3b629f524d1fec7f4ffc91f2ae6bde25d1db" translate="yes" xml:space="preserve">
          <source>In this case, the speedup due to &lt;code&gt;@fastmath&lt;/code&gt; is a factor of about 3.7. This is unusually large &amp;ndash; in general, the speedup will be smaller. (In this particular example, the working set of the benchmark is small enough to fit into the L1 cache of the processor, so that memory access latency does not play a role, and computing time is dominated by CPU usage. In many real world programs this is not the case.) Also, in this case this optimization does not change the result &amp;ndash; in general, the result will be slightly different. In some cases, especially for numerically unstable algorithms, the result can be very different.</source>
          <target state="translated">在这种情况下，由于 &lt;code&gt;@fastmath&lt;/code&gt; 导致的加速约为3.7倍。这非常大-通常，加速会更小。 （在此特定示例中，基准的工作集足够小，可以放入处理器的L1缓存中，因此内存访问延迟不起作用，并且计算时间由CPU使用率决定。在许多实际程序中事实并非如此。）此外，在这种情况下，这种优化不会更改结果-通常，结果会略有不同。在某些情况下，尤其是对于数值不稳定的算法，结果可能会非常不同。</target>
        </trans-unit>
        <trans-unit id="6188940203c290544c44a0f6a7e7493e9e0ab89b" translate="yes" xml:space="preserve">
          <source>In this context, MPI refers to the MPI-1 standard. Beginning with MPI-2, the MPI standards committee introduced a new set of communication mechanisms, collectively referred to as Remote Memory Access (RMA). The motivation for adding rma to the MPI standard was to facilitate one-sided communication patterns. For additional information on the latest MPI standard, see &lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs&lt;/a&gt;.</source>
          <target state="translated">在这种情况下，MPI是指MPI-1标准。从MPI-2开始，MPI标准委员会引入了一套新的通信机制，统称为远程存储器访问（RMA）。将RMA添加到MPI标准的动机是促进单方面的沟通模式。有关最新MPI标准的其他信息，请参阅&lt;a href=&quot;https://mpi-forum.org/docs&quot;&gt;https://mpi-forum.org/docs&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="92a7a3f559dc2f0e3123bf1d2da5d1162f830e7c" translate="yes" xml:space="preserve">
          <source>In this example it is accomplished by defining &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; to create the appropriate wrapped array. (Note that while &lt;code&gt;similar&lt;/code&gt; supports 1- and 2-argument forms, in most case you only need to specialize the 3-argument form.) For this to work it's important that &lt;code&gt;SparseArray&lt;/code&gt; is mutable (supports &lt;code&gt;setindex!&lt;/code&gt;). Defining &lt;code&gt;similar&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt; and &lt;code&gt;setindex!&lt;/code&gt; for &lt;code&gt;SparseArray&lt;/code&gt; also makes it possible to &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; the array:</source>
          <target state="translated">在此示例中，它是通过定义 &lt;code&gt;Base.similar{T}(A::SparseArray, ::Type{T}, dims::Dims)&lt;/code&gt; 来创建合适的包装数组来完成的。 （请注意，尽管 &lt;code&gt;similar&lt;/code&gt; 支持1和2参数形式，但在大多数情况下，您只需要专门化3参数形式。）要使此功能有效，重要的是 &lt;code&gt;SparseArray&lt;/code&gt; 是可变的（支持 &lt;code&gt;setindex!&lt;/code&gt; ）。定义 &lt;code&gt;similar&lt;/code&gt; ， &lt;code&gt;getindex&lt;/code&gt; 和 &lt;code&gt;setindex!&lt;/code&gt; 对于 &lt;code&gt;SparseArray&lt;/code&gt; ,还可以&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;数组：</target>
        </trans-unit>
        <trans-unit id="05a24eb92f7d5686dff145712d9c9981f290a66e" translate="yes" xml:space="preserve">
          <source>In this example the root cause exception (A) is first on the stack, with a further exception (B) following it. After exiting both catch blocks normally (i.e., without throwing a further exception) all exceptions are removed from the stack and are no longer accessible.</source>
          <target state="translated">在这个例子中,根源异常(A)是堆栈中的第一个异常,后面还有一个异常(B)。在正常退出这两个捕获块后(即不抛出进一步的异常),所有的异常都从堆栈中删除,不再可以访问。</target>
        </trans-unit>
        <trans-unit id="4336cae1e8edd1087fd9411fb166bd6a222c2c06" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;A&lt;/code&gt; is a mutable container that contains one element, which can be set by &lt;code&gt;A[] = 1.0&lt;/code&gt; and retrieved with &lt;code&gt;A[]&lt;/code&gt;. All zero-dimensional arrays have the same size (&lt;code&gt;size(A) == ()&lt;/code&gt;), and length (&lt;code&gt;length(A) == 1&lt;/code&gt;). In particular, zero-dimensional arrays are not empty. If you find this unintuitive, here are some ideas that might help to understand Julia's definition.</source>
          <target state="translated">在此示例中， &lt;code&gt;A&lt;/code&gt; 是一个可变容器，其中包含一个元素，可以通过 &lt;code&gt;A[] = 1.0&lt;/code&gt; 进行设置，并使用 &lt;code&gt;A[]&lt;/code&gt; 检索。所有零维数组都具有相同的大小（ &lt;code&gt;size(A) == ()&lt;/code&gt; ）和长度（ &lt;code&gt;length(A) == 1&lt;/code&gt; ）。特别是零维数组不为空。如果您发现这不太直观，这里有一些想法可能有助于理解Julia的定义。</target>
        </trans-unit>
        <trans-unit id="6a0bf2dc540c812cb1923adeb5876321d55dbf26" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;N&lt;/code&gt; is passed as a parameter, so its &quot;value&quot; is known to the compiler. Essentially, &lt;code&gt;Val(T)&lt;/code&gt; works only when &lt;code&gt;T&lt;/code&gt; is either hard-coded/literal (&lt;code&gt;Val(3)&lt;/code&gt;) or already specified in the type-domain.</source>
          <target state="translated">在此示例中， &lt;code&gt;N&lt;/code&gt; 作为参数传递，因此编译器知道其&amp;ldquo;值&amp;rdquo;。本质上， &lt;code&gt;Val(T)&lt;/code&gt; 仅在 &lt;code&gt;T&lt;/code&gt; 是硬编码/文字（ &lt;code&gt;Val(3)&lt;/code&gt; ）或已在类型域中指定时才起作用。</target>
        </trans-unit>
        <trans-unit id="92f4b81b4c3f20308317f94d5766f434fb02e58c" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;b&lt;/code&gt; is a runnable &lt;code&gt;Task&lt;/code&gt; that hasn't started yet.</source>
          <target state="translated">在此示例中， &lt;code&gt;b&lt;/code&gt; 是尚未启动的可运行 &lt;code&gt;Task&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f7bc1ef4d38fd2e360681f2040c8ad0f73774eb" translate="yes" xml:space="preserve">
          <source>In this example, observe that the new definition for &lt;code&gt;newfun&lt;/code&gt; has been created, but can't be immediately called. The new global is immediately visible to the &lt;code&gt;tryeval&lt;/code&gt; function, so you could write &lt;code&gt;return newfun&lt;/code&gt; (without parentheses). But neither you, nor any of your callers, nor the functions they call, or etc. can call this new method definition!</source>
          <target state="translated">在此示例中，观察到 &lt;code&gt;newfun&lt;/code&gt; 的新定义已创建，但是不能立即调用。 &lt;code&gt;tryeval&lt;/code&gt; 函数可以立即看到新的全局变量，因此可以编写 &lt;code&gt;return newfun&lt;/code&gt; （不带括号）。但是您，您的任何调用者，他们调用的函数等都无法调用此新方法定义！</target>
        </trans-unit>
        <trans-unit id="f0f0d16b1aed858c0d51da9625d8755a2c35d48e" translate="yes" xml:space="preserve">
          <source>In this example, the remote which is being fetched from &lt;em&gt;does&lt;/em&gt; have a file called &lt;code&gt;our_file&lt;/code&gt; in its index, which is why we must reset.</source>
          <target state="translated">在此示例中，要从&lt;em&gt;中&lt;/em&gt;获取远程文件的索引中&lt;em&gt;确实&lt;/em&gt;有一个名为 &lt;code&gt;our_file&lt;/code&gt; 的文件，这就是我们必须重置的原因。</target>
        </trans-unit>
        <trans-unit id="a138591f083f547736d80bd3d40dd03ced901f2b" translate="yes" xml:space="preserve">
          <source>In this example, the task ran on pid 2, called from pid 1.</source>
          <target state="translated">在这个例子中,任务运行在pid 2上,由pid 1调用。</target>
        </trans-unit>
        <trans-unit id="f39c0221e85d683a6f4024da4ca9271cf6b8c812" translate="yes" xml:space="preserve">
          <source>In this example, the tuple &lt;code&gt;(1,2,3)&lt;/code&gt; is interpolated as an expression into a conditional test:</source>
          <target state="translated">在此示例中，将元组 &lt;code&gt;(1,2,3)&lt;/code&gt; 作为表达式插入到条件测试中：</target>
        </trans-unit>
        <trans-unit id="a8e780cf12ef36b63b08a74c8c07d0b380150440" translate="yes" xml:space="preserve">
          <source>In this example, the value of variable &lt;code&gt;a&lt;/code&gt; is interpolated:</source>
          <target state="translated">在此示例中，对变量 &lt;code&gt;a&lt;/code&gt; 的值进行插值：</target>
        </trans-unit>
        <trans-unit id="d77924d6298476fc4b219142016e1167310fe63c" translate="yes" xml:space="preserve">
          <source>In this example, we can see that the top level function called is in the file &lt;code&gt;event.jl&lt;/code&gt;. This is the function that runs the REPL when you launch Julia. If you examine line 97 of &lt;code&gt;REPL.jl&lt;/code&gt;, you'll see this is where the function &lt;code&gt;eval_user_input()&lt;/code&gt; is called. This is the function that evaluates what you type at the REPL, and since we're working interactively these functions were invoked when we entered &lt;code&gt;@profile myfunc()&lt;/code&gt;. The next line reflects actions taken in the &lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt;&lt;code&gt;@profile&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">在此示例中，我们可以看到调用的顶级函数在文件 &lt;code&gt;event.jl&lt;/code&gt; 中。这是启动Julia时运行REPL的功能。如果检查 &lt;code&gt;REPL.jl&lt;/code&gt; 的第97 行，则会看到在这里调用了 &lt;code&gt;eval_user_input()&lt;/code&gt; 函数。这是评估您在REPL上键入内容的函数，由于我们正在交互工作，因此在输入 &lt;code&gt;@profile myfunc()&lt;/code&gt; 时将调用这些函数。下一行反映了&lt;a href=&quot;../../stdlib/profile/index#Profile.@profile&quot;&gt; &lt;code&gt;@profile&lt;/code&gt; &lt;/a&gt;宏中执行的操作。</target>
        </trans-unit>
        <trans-unit id="4c91076ff3785f6e6c7acf1c7077368cdbb7151f" translate="yes" xml:space="preserve">
          <source>In this manner, Julia acts as its own &lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;preprocessor&lt;/a&gt;, and allows code generation from inside the language. The above code could be written slightly more tersely using the &lt;code&gt;:&lt;/code&gt; prefix quoting form:</source>
          <target state="translated">通过这种方式，Julia充当其自己的&lt;a href=&quot;https://en.wikipedia.org/wiki/Preprocessor&quot;&gt;预处理器&lt;/a&gt;，并允许从语言内部生成代码。上面的代码可以使用 &lt;code&gt;:&lt;/code&gt; 前缀引用形式更简洁地编写：</target>
        </trans-unit>
        <trans-unit id="7bd6fc4b177020a8a663dcee2fb9c4c397754164" translate="yes" xml:space="preserve">
          <source>In this module we export the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; functions (with the keyword &lt;code&gt;export&lt;/code&gt;), and also have the non-exported function &lt;code&gt;p&lt;/code&gt;. There are several different ways to load the Module and its inner functions into the current workspace:</source>
          <target state="translated">在此模块中，我们导出 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 函数（使用关键字 &lt;code&gt;export&lt;/code&gt; ），并且还具有未导出的函数 &lt;code&gt;p&lt;/code&gt; 。有几种不同的方法可以将模块及其内部功能加载到当前工作空间中：</target>
        </trans-unit>
        <trans-unit id="81fa363c46c4da719440f0a895d038cea7c0f22d" translate="yes" xml:space="preserve">
          <source>In this situation, use the &lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt;&lt;code&gt;skipmissing&lt;/code&gt;&lt;/a&gt; function to skip missing values</source>
          <target state="translated">在这种情况下，请使用&lt;a href=&quot;../../base/base/index#Base.skipmissing&quot;&gt; &lt;code&gt;skipmissing&lt;/code&gt; &lt;/a&gt;函数跳过遗漏的值</target>
        </trans-unit>
        <trans-unit id="9db9e9e3387eacd52cbab3963439723e71f36736" translate="yes" xml:space="preserve">
          <source>In this style of definition, the code generation feature is essentially an optional optimization. The compiler will use it if convenient, but otherwise may choose to use the normal implementation instead. This style is preferred, since it allows the compiler to make more decisions and compile programs in more ways, and since normal code is more readable than code-generating code. However, which implementation is used depends on compiler implementation details, so it is essential for the two implementations to behave identically.</source>
          <target state="translated">在这种风格的定义中,代码生成功能本质上是一种可选的优化。编译器在方便的情况下会使用它,但其他情况下可能会选择使用正常的实现来代替。这种风格是比较好的,因为它允许编译器做出更多的决定,以更多的方式编译程序,而且正常代码比代码生成代码更易读。但是,使用哪种实现取决于编译器的实现细节,所以两种实现的行为必须完全相同。</target>
        </trans-unit>
        <trans-unit id="2472bd128ff5a0c2f02732fc91d35900b7540e31" translate="yes" xml:space="preserve">
          <source>In this toy example, the two methods are easy to distinguish and choose from. However, in a real program designing data movement might require more thought and likely some measurement. For example, if the first process needs matrix &lt;code&gt;A&lt;/code&gt; then the first method might be better. Or, if computing &lt;code&gt;A&lt;/code&gt; is expensive and only the current process has it, then moving it to another process might be unavoidable. Or, if the current process has very little to do between the &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch(Bref)&lt;/code&gt;, it might be better to eliminate the parallelism altogether. Or imagine &lt;code&gt;rand(1000,1000)&lt;/code&gt; is replaced with a more expensive operation. Then it might make sense to add another &lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt;&lt;code&gt;@spawn&lt;/code&gt;&lt;/a&gt; statement just for this step.</source>
          <target state="translated">在这个玩具示例中，这两种方法很容易区分和选择。但是，在实际程序中，设计数据移动可能需要更多的考虑，并且可能需要一些度量。例如，如果第一个过程需要矩阵 &lt;code&gt;A&lt;/code&gt; ,则第一个方法可能会更好。或者，如果计算 &lt;code&gt;A&lt;/code&gt; 昂贵且仅当前进程拥有它，那么将其转移到另一个进程可能是不可避免的。或者，如果当前过程在&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;fetch(Bref)&lt;/code&gt; 之间没有什么关系，则最好完全消除并行性。或想象用更昂贵的操作替换 &lt;code&gt;rand(1000,1000)&lt;/code&gt; 。然后可能仅在此步骤中添加另一个&lt;a href=&quot;../../stdlib/distributed/index#Distributed.@spawn&quot;&gt; &lt;code&gt;@spawn&lt;/code&gt; &lt;/a&gt;语句。</target>
        </trans-unit>
        <trans-unit id="cf538f8e56ca0f93d90636a083c95bfe08cc9992" translate="yes" xml:space="preserve">
          <source>In this way a mesh network is established, wherein every worker is directly connected with every other worker.</source>
          <target state="translated">这样就建立了一个网状网络,在这个网络中,每一个工作者都与其他每一个工作者直接相连。</target>
        </trans-unit>
        <trans-unit id="77e752e41de1e6877a1adbe41bf7b76e4f16d104" translate="yes" xml:space="preserve">
          <source>In-memory representation of a file entry in the index. Matches the &lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt;&lt;code&gt;git_index_entry&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">索引中文件条目的内存表示形式。匹配&lt;a href=&quot;https://libgit2.org/libgit2/#HEAD/type/git_index_entry&quot;&gt; &lt;code&gt;git_index_entry&lt;/code&gt; &lt;/a&gt;结构。</target>
        </trans-unit>
        <trans-unit id="06c7aeba98a0f145bac3596871ee20c6209a6fe5" translate="yes" xml:space="preserve">
          <source>In-place broadcasting can be supported by defining the appropriate &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; method. Because you might want to specialize either on &lt;code&gt;dest&lt;/code&gt; or the specific subtype of &lt;code&gt;bc&lt;/code&gt;, to avoid ambiguities between packages we recommend the following convention.</source>
          <target state="translated">可以通过定义适当的 &lt;code&gt;copyto!(dest, bc::Broadcasted)&lt;/code&gt; 方法来支持就地广播。因为你可能想专门无论是在 &lt;code&gt;dest&lt;/code&gt; 的或特定亚型 &lt;code&gt;bc&lt;/code&gt; ，避免包之间的模糊，我们建议以下约定。</target>
        </trans-unit>
        <trans-unit id="bc665a97127feb38e6b15a0be58c4193afb4afe7" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;a href=&quot;#Random.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt;: randomly permute &lt;code&gt;v&lt;/code&gt; in-place, optionally supplying the random-number generator &lt;code&gt;rng&lt;/code&gt;.</source>
          <target state="translated">随机&lt;a href=&quot;#Random.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt;的就地版本：随地随机置换 &lt;code&gt;v&lt;/code&gt; ，可以选择提供随机数生成器 &lt;code&gt;rng&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ceae787569f3577706adf60b6b428b09067c76dc" translate="yes" xml:space="preserve">
          <source>In-place version of &lt;code&gt;reverse&lt;/code&gt;.</source>
          <target state="translated">就地版本的 &lt;code&gt;reverse&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d77496985aa0ae694adc6f64d73e36e7d090fe55" translate="yes" xml:space="preserve">
          <source>Inbox Tray</source>
          <target state="translated">收件箱托盘</target>
        </trans-unit>
        <trans-unit id="973cab0f46e932b28084ce2f784990fa4e35559b" translate="yes" xml:space="preserve">
          <source>Include a single one-line sentence describing what the function does or what the object represents after the simplified signature block. If needed, provide more details in a second paragraph, after a blank line.</source>
          <target state="translated">在简化签字块之后,用一个单行句子说明函数的作用或对象所代表的内容。如有必要,可在第二段的空白行后提供更多细节。</target>
        </trans-unit>
        <trans-unit id="7962fdf356cdba272a5b5a5a58199f8e50948161" translate="yes" xml:space="preserve">
          <source>Include any code examples in an &lt;code&gt;# Examples&lt;/code&gt; section.</source>
          <target state="translated">在&amp;ldquo; &lt;code&gt;# Examples&lt;/code&gt; 部分中包含所有代码示例。</target>
        </trans-unit>
        <trans-unit id="66cb3917171f2315e55b05172cef1568516a6218" translate="yes" xml:space="preserve">
          <source>Including the same code in different modules provides mixin-like behavior. One could use this to run the same code with different base definitions, for example testing code by running it with &quot;safe&quot; versions of some operators:</source>
          <target state="translated">在不同的模块中包含相同的代码,提供了类似 mixin 的行为。人们可以使用这一点来用不同的基础定义来运行相同的代码,例如,通过使用某些操作符的 &quot;安全 &quot;版本来测试代码。</target>
        </trans-unit>
        <trans-unit id="3677c6602caed5b57fccc20b31958c9939eb0f57" translate="yes" xml:space="preserve">
          <source>Incoming Envelope</source>
          <target state="translated">来料信封</target>
        </trans-unit>
        <trans-unit id="1cebd71683222b1c7af41849d615c19b10f8b1ef" translate="yes" xml:space="preserve">
          <source>Incomplete Initialization</source>
          <target state="translated">不完整的初始化</target>
        </trans-unit>
        <trans-unit id="700503508878aea14fc71ea0dd89adddb349e058" translate="yes" xml:space="preserve">
          <source>Increases As</source>
          <target state="translated">增加的原因</target>
        </trans-unit>
        <trans-unit id="d12f1fabbb58a9af82666365bdf1d6e784f1a197" translate="yes" xml:space="preserve">
          <source>Increment</source>
          <target state="translated">Increment</target>
        </trans-unit>
        <trans-unit id="81769cec07065990cf97fe9de01e67d1dff5a01a" translate="yes" xml:space="preserve">
          <source>Incremental history search, described above</source>
          <target state="translated">递增式历史检索,如上所述</target>
        </trans-unit>
        <trans-unit id="7777e9a1cc822589b38fa2cf3b16ff5bb4405461" translate="yes" xml:space="preserve">
          <source>IndexCartesian</source>
          <target state="translated">IndexCartesian</target>
        </trans-unit>
        <trans-unit id="0ad6144c812efd669c1e0522b10d3e8d01b0818e" translate="yes" xml:space="preserve">
          <source>IndexLinear</source>
          <target state="translated">IndexLinear</target>
        </trans-unit>
        <trans-unit id="5c7d3a57514b6cbb8c7494df1aa031252a9240c0" translate="yes" xml:space="preserve">
          <source>IndexStyle</source>
          <target state="translated">IndexStyle</target>
        </trans-unit>
        <trans-unit id="8b48578d3b12e1d393eb06b8ea5bee4e6f0ec92a" translate="yes" xml:space="preserve">
          <source>Indexable Collections</source>
          <target state="translated">可索引收藏</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="0795ddb093e3d5dd1a985acb78a5e1baf2eef779" translate="yes" xml:space="preserve">
          <source>Indexing and assignment</source>
          <target state="translated">编制索引和转让</target>
        </trans-unit>
        <trans-unit id="4274ea6199202594d8373033384d6bdb729f3196" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the insertion sort algorithm. Insertion sort traverses the collection one element at a time, inserting each element into its correct, sorted position in the output list.</source>
          <target state="translated">表示排序函数应该使用插入排序算法。插入排序一次遍历一个元素的集合,将每个元素插入到输出列表中正确的排序位置。</target>
        </trans-unit>
        <trans-unit id="1a127225335e9d3a07a6be83a0e208ad31b15ede" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the merge sort algorithm. Merge sort divides the collection into subcollections and repeatedly merges them, sorting each subcollection at each step, until the entire collection has been recombined in sorted form.</source>
          <target state="translated">表示排序函数应使用合并排序算法。合并排序将集合划分为子集合,并反复合并,每一步都对每个子集合进行排序,直到整个集合以排序形式重新组合。</target>
        </trans-unit>
        <trans-unit id="f0d9438aae14ca6f51f78f417b7df01df9f079a5" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the partial quick sort algorithm. Partial quick sort returns the smallest &lt;code&gt;k&lt;/code&gt; elements sorted from smallest to largest, finding them and sorting them using &lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt;&lt;code&gt;QuickSort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指示排序功能应使用部分快速排序算法。局部快速排序返回从最小到最大排序的最小 &lt;code&gt;k&lt;/code&gt; 个元素，找到它们并使用&lt;a href=&quot;#Base.Sort.QuickSort&quot;&gt; &lt;code&gt;QuickSort&lt;/code&gt; &lt;/a&gt;对其进行排序。</target>
        </trans-unit>
        <trans-unit id="d5c75327b4e50aced7a786e9b2e8496c590cde6e" translate="yes" xml:space="preserve">
          <source>Indicate that a sorting function should use the quick sort algorithm, which is &lt;em&gt;not&lt;/em&gt; stable.</source>
          <target state="translated">指示排序功能应该使用快速排序算法，这是&lt;em&gt;不是&lt;/em&gt;稳定。</target>
        </trans-unit>
        <trans-unit id="a54eb733590aa2b40370b6fb359ea865b8d99e9b" translate="yes" xml:space="preserve">
          <source>Indicate whether &lt;code&gt;x&lt;/code&gt; is &lt;a href=&quot;#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">指示 &lt;code&gt;x&lt;/code&gt; 是否&lt;a href=&quot;#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="efe98c42fb3d546aaef0cbe63f84a3ed426eef2d" translate="yes" xml:space="preserve">
          <source>Indicates a test that should pass but currently consistently fails. Tests that the expression &lt;code&gt;ex&lt;/code&gt; evaluates to &lt;code&gt;false&lt;/code&gt; or causes an exception. Returns a &lt;code&gt;Broken&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if it does, or an &lt;code&gt;Error&lt;/code&gt;&lt;code&gt;Result&lt;/code&gt; if the expression evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">表示应该通过但当前始终失败的测试。测试表达式 &lt;code&gt;ex&lt;/code&gt; 的计算结果是否为 &lt;code&gt;false&lt;/code&gt; 或导致异常。如果是，则返回&amp;ldquo; &lt;code&gt;Broken&lt;/code&gt; &lt;code&gt;Result&lt;/code&gt; 如果表达式的 &lt;code&gt;Result&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则返回&amp;ldquo; &lt;code&gt;Error&lt;/code&gt; 结果 &amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="f58aeaea39a890601871a48e22cb88bfcd1c627a" translate="yes" xml:space="preserve">
          <source>Indicates problematic exit status of a process. When running commands or pipelines, this is thrown to indicate a nonzero exit code was returned (i.e. that the invoked process failed).</source>
          <target state="translated">表示一个进程的退出状态有问题,当运行命令或管道时,抛出该信息表示返回了一个非零的退出代码(即被调用的进程失败了)。当运行命令或管道时,会抛出这个消息,表示返回了一个非零的退出代码(即调用的进程失败了)。</target>
        </trans-unit>
        <trans-unit id="ff3a5eaf7321b1b596df1bcd003dbd2f9fcf89b1" translate="yes" xml:space="preserve">
          <source>Indices are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">索引的类型与&lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt;返回的类型相同。</target>
        </trans-unit>
        <trans-unit id="f9e9b57819d8a4759652850ab76b4d97192200f0" translate="yes" xml:space="preserve">
          <source>Indices may be omitted if the trailing dimensions that are not indexed into are all length one. In other words, trailing indices can be omitted only if there is only one possible value that those omitted indices could be for an in-bounds indexing expression. For example, a four-dimensional array with size &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; may be indexed with only three indices as the dimension that gets skipped (the fourth dimension) has length one. Note that linear indexing takes precedence over this rule.</source>
          <target state="translated">如果未索引的尾随尺寸均为长度一，则可以省略索引。换句话说，仅当对于入站索引表达式只有一个可能的值时，才可以省略尾随索引。例如，尺寸为 &lt;code&gt;(3, 4, 2, 1)&lt;/code&gt; 3、4、2、1）的四维数组可能只用三个索引编制索引，因为被跳过的维（第四维）的长度为1。请注意，线性索引优先于此规则。</target>
        </trans-unit>
        <trans-unit id="a9eddea567bcc33c91213abd188cec156d2bbedc" translate="yes" xml:space="preserve">
          <source>Indices or keys are of the same type as those returned by &lt;a href=&quot;../collections/index#Base.keys&quot;&gt;&lt;code&gt;keys(A)&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">索引或键的类型与&lt;a href=&quot;../collections/index#Base.keys&quot;&gt; &lt;code&gt;keys(A)&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs(A)&lt;/code&gt; &lt;/a&gt;返回的类型相同。</target>
        </trans-unit>
        <trans-unit id="3e37e52d9d94ec6a75ede0c2186d1f73dd06e01f" translate="yes" xml:space="preserve">
          <source>Indirect Calls</source>
          <target state="translated">间接电话</target>
        </trans-unit>
        <trans-unit id="8b89285e1320e669387b56f7e30bddb1aefce498" translate="yes" xml:space="preserve">
          <source>Individual pointers returned by &lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt;&lt;code&gt;backtrace&lt;/code&gt;&lt;/a&gt; can be translated into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt;&lt;code&gt;StackTraces.StackFrame&lt;/code&gt;&lt;/a&gt; s by passing them into &lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt;&lt;code&gt;StackTraces.lookup&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">通过返回的单个指针&lt;a href=&quot;../../base/base/index#Base.backtrace&quot;&gt; &lt;code&gt;backtrace&lt;/code&gt; &lt;/a&gt;可以翻译成&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.StackFrame&quot;&gt; &lt;code&gt;StackTraces.StackFrame&lt;/code&gt; &lt;/a&gt;通过它们传递到s中&lt;a href=&quot;../../base/stacktraces/index#Base.StackTraces.lookup&quot;&gt; &lt;code&gt;StackTraces.lookup&lt;/code&gt; &lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="f462554871703067824392ec24cc8ae7c200c6ce" translate="yes" xml:space="preserve">
          <source>Inevitably, one wants to write commands that aren't quite so simple, and it becomes necessary to use quotes. Here's a simple example of a Perl one-liner at a shell prompt:</source>
          <target state="translated">难免会想写一些不太简单的命令,这时就需要使用引号。下面是一个简单的例子,在shell提示符下,Perl的一句话。</target>
        </trans-unit>
        <trans-unit id="b24e30d8c474981541dc914b04b492ae2c3460dd" translate="yes" xml:space="preserve">
          <source>Inexact equality comparison: &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt;. The default &lt;code&gt;atol&lt;/code&gt; is zero and the default &lt;code&gt;rtol&lt;/code&gt; depends on the types of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. The keyword argument &lt;code&gt;nans&lt;/code&gt; determines whether or not NaN values are considered equal (defaults to false).</source>
          <target state="translated">不精确的相等性比较： &lt;code&gt;true&lt;/code&gt; 如果 &lt;code&gt;norm(x-y) &amp;lt;= max(atol, rtol*max(norm(x), norm(y)))&lt;/code&gt; 。默认 &lt;code&gt;atol&lt;/code&gt; 为零，默认 &lt;code&gt;rtol&lt;/code&gt; 取决于 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的类型。关键字参数 &lt;code&gt;nans&lt;/code&gt; 确定NaN值是否相等（默认为false）。</target>
        </trans-unit>
        <trans-unit id="a1d71ca242908209d7ea479076e7d5102e909486" translate="yes" xml:space="preserve">
          <source>Inf</source>
          <target state="translated">Inf</target>
        </trans-unit>
        <trans-unit id="3b4f77ed6217d60a7fd4f6a9b544f27db8d0b2a2" translate="yes" xml:space="preserve">
          <source>Inf16</source>
          <target state="translated">Inf16</target>
        </trans-unit>
        <trans-unit id="f32fd60229b61d38504c1b80cfc905d76eb231a4" translate="yes" xml:space="preserve">
          <source>Inf32</source>
          <target state="translated">Inf32</target>
        </trans-unit>
        <trans-unit id="13b9b86c9d296608a20ee6add58865dfa6405d7b" translate="yes" xml:space="preserve">
          <source>Inference on the generated function may be run at &lt;em&gt;any&lt;/em&gt; time, including while your code is attempting to observe or mutate this state.</source>
          <target state="translated">在生成的函数可以推断在运行&lt;em&gt;任何&lt;/em&gt;时候，包括当你的代码试图观察或变异这种状态。</target>
        </trans-unit>
        <trans-unit id="0219fd54bd5841008b18c414a5b2dea331bad1c5" translate="yes" xml:space="preserve">
          <source>Infinity</source>
          <target state="translated">Infinity</target>
        </trans-unit>
        <trans-unit id="c7144cf7afebc5115a987ddb86ab81776ccb312f" translate="yes" xml:space="preserve">
          <source>Information Desk Person</source>
          <target state="translated">问讯处人员</target>
        </trans-unit>
        <trans-unit id="ee1bf915e3a7b6dbf22c44b17ef750f99d415033" translate="yes" xml:space="preserve">
          <source>Information Source</source>
          <target state="translated">信息来源</target>
        </trans-unit>
        <trans-unit id="1bcf6aaebaf6b2210eb3e22e29d6b1d78dde678a" translate="yes" xml:space="preserve">
          <source>Information about the datatype</source>
          <target state="translated">关于数据类型的信息</target>
        </trans-unit>
        <trans-unit id="bc0f7289c05621e36794cb837d6af7d6579a4164" translate="yes" xml:space="preserve">
          <source>Information about the sizes of the array</source>
          <target state="translated">阵列的尺寸信息</target>
        </trans-unit>
        <trans-unit id="2e1d962528e312390b3433d954b1b586fbe1d39c" translate="yes" xml:space="preserve">
          <source>Initialize &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;x = 1.0&lt;/code&gt;</source>
          <target state="translated">用 &lt;code&gt;x = 1.0&lt;/code&gt; 初始化 &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d24f12b12b26a182fb25787fca39632feae214b" translate="yes" xml:space="preserve">
          <source>Initialize with the first loop iteration, to &lt;code&gt;x = 1 / rand()&lt;/code&gt;, then loop &lt;code&gt;for i = 2:10&lt;/code&gt;</source>
          <target state="translated">用第一个循环迭代进行初始化，以 &lt;code&gt;x = 1 / rand()&lt;/code&gt; ，然后循环 &lt;code&gt;for i = 2:10&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1daf596559638b5a2545966e4511677e06d2d3d" translate="yes" xml:space="preserve">
          <source>Initially &lt;code&gt;f(x)&lt;/code&gt; has one definition</source>
          <target state="translated">最初 &lt;code&gt;f(x)&lt;/code&gt; 有一个定义</target>
        </trans-unit>
        <trans-unit id="65a228b7147b9d8893c482dc6a5436ee38235915" translate="yes" xml:space="preserve">
          <source>Inline elements</source>
          <target state="translated">内联元素</target>
        </trans-unit>
        <trans-unit id="45667ade36979348043d403d58a921b295a413f5" translate="yes" xml:space="preserve">
          <source>Inner Constructor Methods</source>
          <target state="translated">内建函数方法</target>
        </trans-unit>
        <trans-unit id="5b1b953a0d0fba8d5b16a917eed0d32fa9a3dd01" translate="yes" xml:space="preserve">
          <source>Inner local scopes can, however, update variables in their parent scopes:</source>
          <target state="translated">然而,内部局部作用域可以更新其父作用域中的变量。</target>
        </trans-unit>
        <trans-unit id="8da1f19e44e7c32bb595b50d82bbd6ceb59679ad" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Capital Letters</source>
          <target state="translated">拉丁大写字母的输入符号</target>
        </trans-unit>
        <trans-unit id="c3dacb4d5649dfd7003c41b511f2d5e28217bcec" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Letters</source>
          <target state="translated">拉丁字母的输入符号</target>
        </trans-unit>
        <trans-unit id="c56fdb4bd109b10836666b2146d13e58e8c262da" translate="yes" xml:space="preserve">
          <source>Input Symbol For Latin Small Letters</source>
          <target state="translated">拉丁小字的输入符号</target>
        </trans-unit>
        <trans-unit id="daa856648c7327c1e747ce6132f831c138ebed2c" translate="yes" xml:space="preserve">
          <source>Input Symbol For Numbers</source>
          <target state="translated">数字的输入符号</target>
        </trans-unit>
        <trans-unit id="393164c17095f31b175cd1b93cce56c3dedbfb1e" translate="yes" xml:space="preserve">
          <source>Input Symbol For Symbols</source>
          <target state="translated">符号的输入符号</target>
        </trans-unit>
        <trans-unit id="6ac623d9f5d1fbc2e0f23f9accfd989544cd258f" translate="yes" xml:space="preserve">
          <source>Insert a sequential-consistency memory fence</source>
          <target state="translated">插入顺序一致性内存栅栏。</target>
        </trans-unit>
        <trans-unit id="811acf3875523c22a2281d416b5b4f8370319cc7" translate="yes" xml:space="preserve">
          <source>Insert an &lt;code&gt;item&lt;/code&gt; into &lt;code&gt;a&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. &lt;code&gt;index&lt;/code&gt; is the index of &lt;code&gt;item&lt;/code&gt; in the resulting &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">插入一个 &lt;code&gt;item&lt;/code&gt; 到 &lt;code&gt;a&lt;/code&gt; 给定的 &lt;code&gt;index&lt;/code&gt; 。 &lt;code&gt;index&lt;/code&gt; 是结果 &lt;code&gt;a&lt;/code&gt; 中 &lt;code&gt;item&lt;/code&gt; 的索引。</target>
        </trans-unit>
        <trans-unit id="559e8d8937fda6b9aa5389a26a8c99a01c1659f4" translate="yes" xml:space="preserve">
          <source>Insert new line without executing it</source>
          <target state="translated">插入新行而不执行</target>
        </trans-unit>
        <trans-unit id="db69c06d74ad468e37833a8eff3cd0b19f6c2cae" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the beginning of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;collection&lt;/code&gt; 开始时插入一个或多个 &lt;code&gt;items&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e38ad6a771799a9a8891ef79be267ec402e8ceac" translate="yes" xml:space="preserve">
          <source>Insert one or more &lt;code&gt;items&lt;/code&gt; at the end of &lt;code&gt;collection&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;collection&lt;/code&gt; 的末尾插入一个或多个 &lt;code&gt;items&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af1912a8c6dfd808836326783d91aa44bc473362" translate="yes" xml:space="preserve">
          <source>Insert the elements of &lt;code&gt;items&lt;/code&gt; to the beginning of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">插入的元素 &lt;code&gt;items&lt;/code&gt; 至年初 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eec80463f132fabaec00763dec1737d74a5ca8f8" translate="yes" xml:space="preserve">
          <source>Inserts a memory fence with sequentially-consistent ordering semantics. There are algorithms where this is needed, i.e. where an acquire/release ordering is insufficient.</source>
          <target state="translated">插入一个具有顺序一致的排序语义的内存栅栏。有一些算法需要这样做,即获取/释放顺序不充分。</target>
        </trans-unit>
        <trans-unit id="3ea0f92c3d70dd355408c14ed7bbf0a9be4aeff9" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;kwargs&lt;/code&gt; will be a key-value iterator over a named tuple. Named tuples (as well as dictionaries with keys of &lt;code&gt;Symbol&lt;/code&gt;) can be passed as keyword arguments using a semicolon in a call, e.g. &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;f&lt;/code&gt; 内部， &lt;code&gt;kwargs&lt;/code&gt; 将是命名元组上的键值迭代器。可以在调用中使用分号将命名的元组（以及具有 &lt;code&gt;Symbol&lt;/code&gt; 键的字典）作为关键字参数传递，例如 &lt;code&gt;f(x, z=1; kwargs...)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d505904dee884402cee2bfc93d1e5e6eac91aed0" translate="yes" xml:space="preserve">
          <source>Inside a function call, &lt;code&gt;f(a=b)&lt;/code&gt; passes &lt;code&gt;b&lt;/code&gt; as the value of keyword argument &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">在函数调用内部， &lt;code&gt;f(a=b)&lt;/code&gt; 将 &lt;code&gt;b&lt;/code&gt; 作为关键字参数 &lt;code&gt;a&lt;/code&gt; 的值传递。</target>
        </trans-unit>
        <trans-unit id="5c0628bcc3fe3dc7f18266ed4703a4ef8a1c7fc8" translate="yes" xml:space="preserve">
          <source>Inside a local scope a global variable can be assigned to by using the keyword &lt;a href=&quot;../../base/base/index#global&quot;&gt;&lt;code&gt;global&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">在局部范围内，可以使用关键字&lt;a href=&quot;../../base/base/index#global&quot;&gt; &lt;code&gt;global&lt;/code&gt; &lt;/a&gt;来分配全局变量：</target>
        </trans-unit>
        <trans-unit id="582d7159a5b73cf78ab92b918e0b2d46bdf1e604" translate="yes" xml:space="preserve">
          <source>Inside a local scope a variable can be forced to be a new local variable using the &lt;a href=&quot;../../base/base/index#local&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt; keyword:</source>
          <target state="translated">在局部范围内，可以使用&lt;a href=&quot;../../base/base/index#local&quot;&gt; &lt;code&gt;local&lt;/code&gt; &lt;/a&gt;关键字将变量强制为新的局部变量：</target>
        </trans-unit>
        <trans-unit id="49fad0a2de99eca8b6794c525262e6ccd85a1c70" translate="yes" xml:space="preserve">
          <source>Inside parentheses with commas, &lt;code&gt;(a=1,)&lt;/code&gt; constructs a &lt;a href=&quot;#Core.NamedTuple&quot;&gt;&lt;code&gt;NamedTuple&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">在带逗号的括号内， &lt;code&gt;(a=1,)&lt;/code&gt; 构造了一个&lt;a href=&quot;#Core.NamedTuple&quot;&gt; &lt;code&gt;NamedTuple&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="456c6fe8fc3a9803d2d238636df3fddf2e8ebda8" translate="yes" xml:space="preserve">
          <source>Inspects the given UUID and returns its version (see &lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;).</source>
          <target state="translated">检查给定的UUID并返回其版本（请参阅&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="4ff8674778688251123ee296e21a5f29ce889b67" translate="yes" xml:space="preserve">
          <source>Instances can be constructed from strings via &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, or using the &lt;code&gt;big&lt;/code&gt; string literal.</source>
          <target state="translated">可以通过&lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;或使用 &lt;code&gt;big&lt;/code&gt; 字符串文字从字符串构造实例。</target>
        </trans-unit>
        <trans-unit id="e2cd4547e98e69f493a2391724e35284eddfcf3f" translate="yes" xml:space="preserve">
          <source>Instead of calculating something or performing some action, you return a &lt;em&gt;quoted expression&lt;/em&gt; which, when evaluated, does what you want.</source>
          <target state="translated">您无需计算或执行某些操作，而是返回带&lt;em&gt;引号的表达式&lt;/em&gt;，该&lt;em&gt;表达式&lt;/em&gt;在被求值时会执行您想要的操作。</target>
        </trans-unit>
        <trans-unit id="e11074b6a3ddd4db91a1d67bb7c4e17f5cc3596e" translate="yes" xml:space="preserve">
          <source>Instead of directly sorting an array, you can compute a permutation of the array's indices that puts the array into sorted order:</source>
          <target state="translated">你可以不直接对一个数组进行排序,而是计算一个数组指数的排列组合,将数组放入排序顺序。</target>
        </trans-unit>
        <trans-unit id="d807ed905e686ec4c6c31127918a04393e4003ae" translate="yes" xml:space="preserve">
          <source>Instead of immediately running the command, backticks create a &lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; object to represent the command. You can use this object to connect the command to others via pipes, &lt;a href=&quot;../../base/base/index#Base.run&quot;&gt;&lt;code&gt;run&lt;/code&gt;&lt;/a&gt; it, and &lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt;&lt;code&gt;read&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">反引号不是立即运行命令，而是创建一个&lt;a href=&quot;../../base/base/index#Base.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt;对象来表示命令。您可以使用此对象通过管道命令连接到其他人，&lt;a href=&quot;../../base/base/index#Base.run&quot;&gt; &lt;code&gt;run&lt;/code&gt; &lt;/a&gt;它，并&lt;a href=&quot;../../base/io-network/index#Base.read&quot;&gt; &lt;code&gt;read&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../base/io-network/index#Base.write&quot;&gt; &lt;code&gt;write&lt;/code&gt; &lt;/a&gt;它。</target>
        </trans-unit>
        <trans-unit id="78863694892c2019c43a79b283ebb340da799f84" translate="yes" xml:space="preserve">
          <source>Instead of loading a registered version of &lt;code&gt;Example&lt;/code&gt;, Julia will load the source code contained in &lt;code&gt;tutorial/dev/Example&lt;/code&gt;.</source>
          <target state="translated">代替加载 &lt;code&gt;Example&lt;/code&gt; 的注册版本，Julia将加载 &lt;code&gt;tutorial/dev/Example&lt;/code&gt; 中包含的源代码。</target>
        </trans-unit>
        <trans-unit id="80cddaa6c38b52b1b6910a5df7e62d1058e97067" translate="yes" xml:space="preserve">
          <source>Instead of performing some calculation or action, a generated function declaration returns a quoted expression which then forms the body for the method corresponding to the types of the arguments. When a generated function is called, the expression it returns is compiled and then run. To make this efficient, the result is usually cached. And to make this inferable, only a limited subset of the language is usable. Thus, generated functions provide a flexible way to move work from run time to compile time, at the expense of greater restrictions on allowed constructs.</source>
          <target state="translated">生成函数声明不是执行一些计算或动作,而是返回一个引号的表达式,然后形成与参数类型相对应的方法的主体。当一个生成函数被调用时,它返回的表达式会被编译,然后运行。为了提高效率,通常会对结果进行缓存。而为了使之可推断,只有有限的语言子集可以使用。因此,生成函数提供了一种将工作从运行时转移到编译时的灵活方式,但代价是对允许的构造有更大的限制。</target>
        </trans-unit>
        <trans-unit id="c042f3d9b71b32db250543be269d410c99d13527" translate="yes" xml:space="preserve">
          <source>Instead of:</source>
          <target state="translated">而不是:</target>
        </trans-unit>
        <trans-unit id="a3a52a1be0f1de968cc5d8921a39676d67c34867" translate="yes" xml:space="preserve">
          <source>Instead, use a semicolon or insert a line break after &lt;code&gt;catch&lt;/code&gt;:</source>
          <target state="translated">而是使用分号或在 &lt;code&gt;catch&lt;/code&gt; 后面插入换行符：</target>
        </trans-unit>
        <trans-unit id="3f6b46a05cf7ae83de7f241a566b6dcab9f9f12b" translate="yes" xml:space="preserve">
          <source>Integer division (the &lt;code&gt;div&lt;/code&gt; function) has two exceptional cases: dividing by zero, and dividing the lowest negative number (&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt;&lt;code&gt;typemin&lt;/code&gt;&lt;/a&gt;) by -1. Both of these cases throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt;. The remainder and modulus functions (&lt;code&gt;rem&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt;) throw a &lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt;&lt;code&gt;DivideError&lt;/code&gt;&lt;/a&gt; when their second argument is zero.</source>
          <target state="translated">整数除法（ &lt;code&gt;div&lt;/code&gt; 函数）有两种特殊情况：除以零，并将最低的负数（&lt;a href=&quot;../../base/base/index#Base.typemin&quot;&gt; &lt;code&gt;typemin&lt;/code&gt; &lt;/a&gt;）除以-1。这两种情况都抛出&lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; &lt;/a&gt;。余数和模数函数（ &lt;code&gt;rem&lt;/code&gt; 和 &lt;code&gt;mod&lt;/code&gt; ）在第二个参数为零时抛出&lt;a href=&quot;../../base/base/index#Core.DivideError&quot;&gt; &lt;code&gt;DivideError&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="27477953a7f5629b70d1f8667b4ce5a95bd7d163" translate="yes" xml:space="preserve">
          <source>Integer division was attempted with a denominator value of 0.</source>
          <target state="translated">尝试整数除法,分母值为0。</target>
        </trans-unit>
        <trans-unit id="44e36daccd6ac7a9f894c249dbe1f367783e4537" translate="yes" xml:space="preserve">
          <source>Integer square root: the largest integer &lt;code&gt;m&lt;/code&gt; such that &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt;.</source>
          <target state="translated">整数平方根：使得 &lt;code&gt;m*m &amp;lt;= n&lt;/code&gt; 的最大整数 &lt;code&gt;m&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d0f622cf48cf7d80bd106d7df1f3da91566c330d" translate="yes" xml:space="preserve">
          <source>Integer value N launches N additional local worker processes; &lt;code&gt;auto&lt;/code&gt; launches as many workers as the number of local CPU threads (logical cores)</source>
          <target state="translated">整数N会启动N个其他本地工作进程； &lt;code&gt;auto&lt;/code&gt; 启动与本地CPU线程（逻辑核心）数量一样多的工作程序</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="0be1ec1ce9bd8f5a453ecb566c11ab0a7c7144d0" translate="yes" xml:space="preserve">
          <source>Integers and Floating-Point Numbers</source>
          <target state="translated">整数和浮点数</target>
        </trans-unit>
        <trans-unit id="cdcba026c96bc24c46aaded28b7a473dd9b651d8" translate="yes" xml:space="preserve">
          <source>Integers and floating-point values are the basic building blocks of arithmetic and computation. Built-in representations of such values are called numeric primitives, while representations of integers and floating-point numbers as immediate values in code are known as numeric literals. For example, &lt;code&gt;1&lt;/code&gt; is an integer literal, while &lt;code&gt;1.0&lt;/code&gt; is a floating-point literal; their binary in-memory representations as objects are numeric primitives.</source>
          <target state="translated">整数和浮点值是算术和计算的基本构建块。这种值的内置表示形式称为数字原语，而整数和浮点数的表示形式作为代码中的立即值称为数字文字。例如， &lt;code&gt;1&lt;/code&gt; 是整数文字，而 &lt;code&gt;1.0&lt;/code&gt; 是浮点文字；它们作为对象的二进制内存表示形式是数字基元。</target>
        </trans-unit>
        <trans-unit id="be404ce277aac9d3b9b27f0140b709ff517b7820" translate="yes" xml:space="preserve">
          <source>Integers are compared in the standard manner &amp;ndash; by comparison of bits. Floating-point numbers are compared according to the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;:</source>
          <target state="translated">以标准方式比较整数-通过比较位。浮点数根据&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754标准进行比较&lt;/a&gt;：</target>
        </trans-unit>
        <trans-unit id="e3b59c9f1c26e320e172cac39695e68589e740a0" translate="yes" xml:space="preserve">
          <source>Integral</source>
          <target state="translated">Integral</target>
        </trans-unit>
        <trans-unit id="70680c64952b0114adcda3eb14a614e1841cd0c6" translate="yes" xml:space="preserve">
          <source>Integral Around A Point Operator</source>
          <target state="translated">绕点算子的积分</target>
        </trans-unit>
        <trans-unit id="425335bd88e128f008b3f48181d1c27b517bcc72" translate="yes" xml:space="preserve">
          <source>Integral Average With Slash</source>
          <target state="translated">带斜线的整数平均值</target>
        </trans-unit>
        <trans-unit id="c6bac88caff6c11517b441d63dd4587857621bab" translate="yes" xml:space="preserve">
          <source>Integral With Double Stroke</source>
          <target state="translated">整体式,带双行程</target>
        </trans-unit>
        <trans-unit id="18238ecc8130fd86a404d903215b4901fbd6604e" translate="yes" xml:space="preserve">
          <source>Integral With Intersection</source>
          <target state="translated">整体与交叉点</target>
        </trans-unit>
        <trans-unit id="8a62b59c92abaaa075d87faf375d4d0d5e2fdc39" translate="yes" xml:space="preserve">
          <source>Integral With Overbar</source>
          <target state="translated">整体带过杆</target>
        </trans-unit>
        <trans-unit id="08588fc154d2b615a7916934fe8e56ebda68acf8" translate="yes" xml:space="preserve">
          <source>Integral With Times Sign</source>
          <target state="translated">与时代符号的整体性</target>
        </trans-unit>
        <trans-unit id="31ecf2a75d24fa7ec2a5569e3665d7f415d4db51" translate="yes" xml:space="preserve">
          <source>Integral With Underbar</source>
          <target state="translated">整体式带下杆</target>
        </trans-unit>
        <trans-unit id="23eafe62fdaca340d651a852cff8f87d44076b09" translate="yes" xml:space="preserve">
          <source>Integral With Union</source>
          <target state="translated">与联盟的整体性</target>
        </trans-unit>
        <trans-unit id="2885cb42f64585560c85104eeedf86ba7e0ed77e" translate="yes" xml:space="preserve">
          <source>Intel's &lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade; Amplifier&lt;/a&gt; (&lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; set to &lt;code&gt;1&lt;/code&gt; in the build configuration), or</source>
          <target state="translated">英特尔的&lt;a href=&quot;https://software.intel.com/en-us/vtune&quot;&gt;VTune&amp;trade;放大器&lt;/a&gt;（在构建配置 &lt;code&gt;USE_INTEL_JITEVENTS&lt;/code&gt; 设置为 &lt;code&gt;1&lt;/code&gt; ），或</target>
        </trans-unit>
        <trans-unit id="207cb56e67212ece90d1329dc4b01521c8f13014" translate="yes" xml:space="preserve">
          <source>Interacting with the contents or methods of &lt;code&gt;Core.Compiler&lt;/code&gt; in any way.</source>
          <target state="translated">以任何方式与 &lt;code&gt;Core.Compiler&lt;/code&gt; 的内容或方法进行交互。</target>
        </trans-unit>
        <trans-unit id="d4f66ae8b3da23aee8b514d4076de7a8e09b0b4e" translate="yes" xml:space="preserve">
          <source>Interactive Utilities</source>
          <target state="translated">互动实用工具</target>
        </trans-unit>
        <trans-unit id="71fefc1d52a78f40748037e8a91fc8ea4f8e2578" translate="yes" xml:space="preserve">
          <source>Interactive mode; REPL runs and &lt;code&gt;isinteractive()&lt;/code&gt; is true</source>
          <target state="translated">互动模式；REPL运行并且 &lt;code&gt;isinteractive()&lt;/code&gt; 为true</target>
        </trans-unit>
        <trans-unit id="0270e20982d6093d44ba136572cbf822d6290a5d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_llvm</source>
          <target state="translated">InteractiveUtils.@code_llvm</target>
        </trans-unit>
        <trans-unit id="0309be470088530490561ff83d97b95071df357e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_lowered</source>
          <target state="translated">InteractiveUtils.@code_lowered</target>
        </trans-unit>
        <trans-unit id="00a7a46c62638c2b2d4deb9dc4bd43a8d3c3582c" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_native</source>
          <target state="translated">InteractiveUtils.@code_native</target>
        </trans-unit>
        <trans-unit id="4fa27864c86ced13027d392baeedb020be6c560a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_typed</source>
          <target state="translated">InteractiveUtils.@code_typed</target>
        </trans-unit>
        <trans-unit id="1e45473f814223dcb1c417d561e1870e1450bf83" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@code_warntype</source>
          <target state="translated">InteractiveUtils.@code_warntype</target>
        </trans-unit>
        <trans-unit id="eedef913d7842aa079f915bdbbb5f5e90c47c7f6" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@edit</source>
          <target state="translated">InteractiveUtils.@edit</target>
        </trans-unit>
        <trans-unit id="a6df5f45ac03e2c658d92e8736e88cafa5b98995" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@functionloc</source>
          <target state="translated">InteractiveUtils.@functionloc</target>
        </trans-unit>
        <trans-unit id="49e359f4c318b876f99ccb7d37f63e69deb2003d" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@less</source>
          <target state="translated">InteractiveUtils.@less</target>
        </trans-unit>
        <trans-unit id="6e359d1c5b33d4212df3c4f8c3762813890df9ae" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.@which</source>
          <target state="translated">InteractiveUtils.@which</target>
        </trans-unit>
        <trans-unit id="2d50f6ed31622302ae5f5a5feebfb95f2c420a04" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.clipboard()</source>
          <target state="translated">InteractiveUtils.clipboard()</target>
        </trans-unit>
        <trans-unit id="c1ad553095bd7ae0c9db5b342934998a5be27479" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_llvm()</source>
          <target state="translated">InteractiveUtils.code_llvm()</target>
        </trans-unit>
        <trans-unit id="a70df8f6770abff941be7ee8196e397ae5bbd4b8" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_native()</source>
          <target state="translated">InteractiveUtils.code_native()</target>
        </trans-unit>
        <trans-unit id="f009b2e3c7cb61122f070c557fb9f4dcd1edf6db" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.code_warntype()</source>
          <target state="translated">InteractiveUtils.code_warntype()</target>
        </trans-unit>
        <trans-unit id="d4c1c9ee2ecb7996d780a0e5d5ccea921a53d56a" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.edit()</source>
          <target state="translated">InteractiveUtils.edit()</target>
        </trans-unit>
        <trans-unit id="424927890145616c60279ce930588fd54c4ac90e" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.less()</source>
          <target state="translated">InteractiveUtils.less()</target>
        </trans-unit>
        <trans-unit id="49eeeef411d4549f28b217525726cf46e51440cb" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.methodswith()</source>
          <target state="translated">InteractiveUtils.methodswith()</target>
        </trans-unit>
        <trans-unit id="59973fd047bc66e11de11bff485ff30fc8072b48" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.subtypes()</source>
          <target state="translated">InteractiveUtils.subtypes()</target>
        </trans-unit>
        <trans-unit id="8cc40b484c66058018a0b8c42f2ab741a2014154" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.varinfo()</source>
          <target state="translated">InteractiveUtils.varinfo()</target>
        </trans-unit>
        <trans-unit id="391d124220b1a9c25f8d3323e7bb133c849aadc9" translate="yes" xml:space="preserve">
          <source>InteractiveUtils.versioninfo()</source>
          <target state="translated">InteractiveUtils.versioninfo()</target>
        </trans-unit>
        <trans-unit id="068a8966386d6f477f70dcc54b094caba48a03f4" translate="yes" xml:space="preserve">
          <source>Intercalate</source>
          <target state="translated">Intercalate</target>
        </trans-unit>
        <trans-unit id="a791af570ec4e5730c5e110c39b173c357ea4d3a" translate="yes" xml:space="preserve">
          <source>Interconverts between dense and sparse formats.</source>
          <target state="translated">在密集和稀疏格式之间进行转换。</target>
        </trans-unit>
        <trans-unit id="c3229f4e0f20d697072608271bc7f20c5b6d789f" translate="yes" xml:space="preserve">
          <source>Interface to BLAS subroutines.</source>
          <target state="translated">BLAS子程序的接口。</target>
        </trans-unit>
        <trans-unit id="bcdb1ff794ae28041f3196a504b6115b3dea810a" translate="yes" xml:space="preserve">
          <source>Interface to libc, the C standard library.</source>
          <target state="translated">libc,C标准库的接口。</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="c2b213458be4f2f6fdec41d29483b814cba730b1" translate="yes" xml:space="preserve">
          <source>Interfaces to LAPACK subroutines.</source>
          <target state="translated">LAPACK子程序的接口。</target>
        </trans-unit>
        <trans-unit id="a514e8807ceddceeb9d1c2be8e83634758fea386" translate="yes" xml:space="preserve">
          <source>Interior Product</source>
          <target state="translated">内部产品</target>
        </trans-unit>
        <trans-unit id="0c4a9d0a55deb37d51d5b2b7f615f0874ed971d8" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;promote_type&lt;/code&gt; is used inside of &lt;code&gt;promote&lt;/code&gt; to determine what type argument values should be converted to for promotion. It can, however, be useful in its own right. The curious reader can read the code in &lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt;&lt;code&gt;promotion.jl&lt;/code&gt;&lt;/a&gt;, which defines the complete promotion mechanism in about 35 lines.</source>
          <target state="translated">在内部， &lt;code&gt;promote_type&lt;/code&gt; 在promote内部使用，以确定应将哪种类型的参数值转换为 &lt;code&gt;promote&lt;/code&gt; 。但是，它本身可能会很有用。好奇的读者可以阅读&lt;a href=&quot;https://github.com/JuliaLang/julia/blob/master/base/promotion.jl&quot;&gt; &lt;code&gt;promotion.jl&lt;/code&gt; 中&lt;/a&gt;的代码，该代码在大约35行中定义了完整的提升机制。</target>
        </trans-unit>
        <trans-unit id="818408de3c95448c6a4c8c7cc57f8a8c85a4002d" translate="yes" xml:space="preserve">
          <source>Internally, an &lt;code&gt;AbstractChar&lt;/code&gt; type may use a variety of encodings. Conversion via &lt;code&gt;codepoint(char)&lt;/code&gt; will not reveal this encoding because it always returns the Unicode value of the character. &lt;code&gt;print(io, c)&lt;/code&gt; of any &lt;code&gt;c::AbstractChar&lt;/code&gt; produces an encoding determined by &lt;code&gt;io&lt;/code&gt; (UTF-8 for all built-in &lt;code&gt;IO&lt;/code&gt; types), via conversion to &lt;code&gt;Char&lt;/code&gt; if necessary.</source>
          <target state="translated">在内部， &lt;code&gt;AbstractChar&lt;/code&gt; 类型可以使用多种编码。通过 &lt;code&gt;codepoint(char)&lt;/code&gt; 进行的转换不会显示这种编码，因为它始终返回字符的Unicode值。任何 &lt;code&gt;c::AbstractChar&lt;/code&gt; &lt;code&gt;print(io, c)&lt;/code&gt; 都会产生一个由 &lt;code&gt;io&lt;/code&gt; （对于所有内置 &lt;code&gt;IO&lt;/code&gt; 类型为UTF-8）确定的编码，如有必要，可以转换为 &lt;code&gt;Char&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4952806e1eda6ad8d06e741bd80f1e6d3a2efafd" translate="yes" xml:space="preserve">
          <source>Internally, this code creates two implementations of the function: a generated one where the first block in &lt;code&gt;if @generated&lt;/code&gt; is used, and a normal one where the &lt;code&gt;else&lt;/code&gt; block is used. Inside the &lt;code&gt;then&lt;/code&gt; part of the &lt;code&gt;if @generated&lt;/code&gt; block, code has the same semantics as other generated functions: argument names refer to types, and the code should return an expression. Multiple &lt;code&gt;if @generated&lt;/code&gt; blocks may occur, in which case the generated implementation uses all of the &lt;code&gt;then&lt;/code&gt; blocks and the alternate implementation uses all of the &lt;code&gt;else&lt;/code&gt; blocks.</source>
          <target state="translated">在内部，此代码创建函数的两种实现：生成的函数，其中使用 &lt;code&gt;if @generated&lt;/code&gt; 中的第一个块，而普通的函数中则使用 &lt;code&gt;else&lt;/code&gt; 块。在 &lt;code&gt;if @generated&lt;/code&gt; 块的 &lt;code&gt;then&lt;/code&gt; 部分中，代码与其他生成的函数具有相同的语义：参数名称引用类型，并且代码应返回表达式。可能会出现多个 &lt;code&gt;if @generated&lt;/code&gt; 块，在这种情况下，生成的实现使用所有 &lt;code&gt;then&lt;/code&gt; 块，而备用实现使用所有 &lt;code&gt;else&lt;/code&gt; 块。</target>
        </trans-unit>
        <trans-unit id="653edb0bfdb6bd20dfe7affb5776bc7d271237c7" translate="yes" xml:space="preserve">
          <source>Internals</source>
          <target state="translated">Internals</target>
        </trans-unit>
        <trans-unit id="48012c80f49c5c1a3bff1ed20d31a89b4f215742" translate="yes" xml:space="preserve">
          <source>Interpolating into an unquoted expression is not supported and will cause a compile-time error:</source>
          <target state="translated">不支持向未引用的表达式插值,并会导致编译时错误。</target>
        </trans-unit>
        <trans-unit id="6a9858c9bf3149456595f98943cf88e41039822e" translate="yes" xml:space="preserve">
          <source>Interpolation</source>
          <target state="translated">Interpolation</target>
        </trans-unit>
        <trans-unit id="d67b7c5f52f05b37b77a64fd823fc76a0fce5a66" translate="yes" xml:space="preserve">
          <source>Interpret an iterable of key-value pairs as a named tuple, and perform a merge.</source>
          <target state="translated">将键值对的迭代解释为一个命名元组,并执行合并。</target>
        </trans-unit>
        <trans-unit id="cc53b2acfc42c6cf13c71d4c67ea40578eaaf1f7" translate="yes" xml:space="preserve">
          <source>Interpretation: accessing elements of poorly-typed arrays</source>
          <target state="translated">解释:访问类型不佳的数组元素。</target>
        </trans-unit>
        <trans-unit id="7894bb109218bbe3ea53cb08c360e18b2453f383" translate="yes" xml:space="preserve">
          <source>Interpretation: call to a type-unstable function &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">解释：调用类型不稳定的函数 &lt;code&gt;g&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7784e3d882b6a7b4c22ed3b7f03fb99cea250d48" translate="yes" xml:space="preserve">
          <source>Interpretation: function with unstable return type</source>
          <target state="translated">解释:函数的返回类型不稳定</target>
        </trans-unit>
        <trans-unit id="9f71e4dd30d3efc21956f72596ba4278f8921c99" translate="yes" xml:space="preserve">
          <source>Interpretation: getting a field that is of non-leaf type. In this case, &lt;code&gt;ArrayContainer&lt;/code&gt; had a field &lt;code&gt;data::Array{T}&lt;/code&gt;. But &lt;code&gt;Array&lt;/code&gt; needs the dimension &lt;code&gt;N&lt;/code&gt;, too, to be a concrete type.</source>
          <target state="translated">解释：获取非叶子类型的字段。在这种情况下， &lt;code&gt;ArrayContainer&lt;/code&gt; 具有字段 &lt;code&gt;data::Array{T}&lt;/code&gt; 。但是 &lt;code&gt;Array&lt;/code&gt; 也需要尺寸 &lt;code&gt;N&lt;/code&gt; 才能成为具体类型。</target>
        </trans-unit>
        <trans-unit id="f71c83c811d3e87825b69245ec2c0dff4c1686bd" translate="yes" xml:space="preserve">
          <source>Interpreting the output of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt;, like that of its cousins &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt;&lt;code&gt;@code_lowered&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt;&lt;code&gt;@code_typed&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt;&lt;code&gt;@code_llvm&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt;&lt;code&gt;@code_native&lt;/code&gt;&lt;/a&gt;, takes a little practice. Your code is being presented in form that has been heavily digested on its way to generating compiled machine code. Most of the expressions are annotated by a type, indicated by the &lt;code&gt;::T&lt;/code&gt; (where &lt;code&gt;T&lt;/code&gt; might be &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt;, for example). The most important characteristic of &lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt;&lt;code&gt;@code_warntype&lt;/code&gt;&lt;/a&gt; is that non-concrete types are displayed in red; in the above example, such output is shown in uppercase.</source>
          <target state="translated">解释&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;的输出（如其表亲&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_lowered&quot;&gt; &lt;code&gt;@code_lowered&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_typed&quot;&gt; &lt;code&gt;@code_typed&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_llvm&quot;&gt; &lt;code&gt;@code_llvm&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_native&quot;&gt; &lt;code&gt;@code_native&lt;/code&gt; 的输出&lt;/a&gt;）需要一些实践。您的代码将以其在生成编译的机器代码的方式中被大量消化的形式呈现。大多数表达式都用 &lt;code&gt;::T&lt;/code&gt; 表示的类型注释（例如 &lt;code&gt;T&lt;/code&gt; 可能是&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;）。&lt;a href=&quot;../../stdlib/interactiveutils/index#InteractiveUtils.@code_warntype&quot;&gt; &lt;code&gt;@code_warntype&lt;/code&gt; &lt;/a&gt;的最重要特征是非混凝土类型以红色显示；在上面的示例中，此类输出以大写形式显示。</target>
        </trans-unit>
        <trans-unit id="cc939bea48b5a28296b21d2be9495aa8bccd0b19" translate="yes" xml:space="preserve">
          <source>Interrupt or cancel</source>
          <target state="translated">中断或取消</target>
        </trans-unit>
        <trans-unit id="23165f09bcddd0acc011e45e34282dbbd91bd4cd" translate="yes" xml:space="preserve">
          <source>Interrupt the current executing task on the specified workers. This is equivalent to pressing Ctrl-C on the local machine. If no arguments are given, all workers are interrupted.</source>
          <target state="translated">中断指定工人上当前正在执行的任务。这相当于在本地机器上按Ctrl-C键。如果没有给定参数,则中断所有工人。</target>
        </trans-unit>
        <trans-unit id="658cc9a8a17acd75a5bc21930b12d446eea71552" translate="yes" xml:space="preserve">
          <source>Intersect all passed in sets and overwrite &lt;code&gt;s&lt;/code&gt; with the result. Maintain order with arrays.</source>
          <target state="translated">相交全部通过中集和覆盖 &lt;code&gt;s&lt;/code&gt; 与结果。维护数组的顺序。</target>
        </trans-unit>
        <trans-unit id="d0f596ba112a353008597117b57b10b067fc620b" translate="yes" xml:space="preserve">
          <source>Intersection</source>
          <target state="translated">Intersection</target>
        </trans-unit>
        <trans-unit id="7d65fe6f634dc82a5910e500d111d1c2553d45ad" translate="yes" xml:space="preserve">
          <source>Intersection Beside And Joined With Intersection</source>
          <target state="translated">交叉口旁边并与交叉口连接</target>
        </trans-unit>
        <trans-unit id="f70ced5527bc06ac0250ff3ce0c6433b4fc007ad" translate="yes" xml:space="preserve">
          <source>Intersection With Dot</source>
          <target state="translated">与点的交叉点</target>
        </trans-unit>
        <trans-unit id="fea160380c26aea0a6f5cf6d33e5059a2528bb99" translate="yes" xml:space="preserve">
          <source>Intersection With Logical And</source>
          <target state="translated">与逻辑和逻辑的交集</target>
        </trans-unit>
        <trans-unit id="8a447498c8a13bd62bc28a71db064abbbd2ce851" translate="yes" xml:space="preserve">
          <source>Intersection With Overbar</source>
          <target state="translated">与过街天桥的交叉口</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="95010e236dbeb1d0c89e9d5b6ed0ea0da0ed9572" translate="yes" xml:space="preserve">
          <source>Intuitively, this corresponds to the type of a function's arguments being a subtype of the function's signature (when the signature matches).</source>
          <target state="translated">直观地说,这相当于函数的参数类型是函数签名的子类型(当签名匹配时)。</target>
        </trans-unit>
        <trans-unit id="f4bc4f6c3fe38fa1ef542295504817c8e94651bb" translate="yes" xml:space="preserve">
          <source>Inverse Bullet</source>
          <target state="translated">逆向子弹</target>
        </trans-unit>
        <trans-unit id="a2b80ae8599265e5e4df3c9c6eae5101a072d85a" translate="yes" xml:space="preserve">
          <source>Inverse White Circle</source>
          <target state="translated">逆白圈</target>
        </trans-unit>
        <trans-unit id="f5c93f67585d1f2ce3d07fe77774efdd8e1c494a" translate="yes" xml:space="preserve">
          <source>Inverted Exclamation Mark</source>
          <target state="translated">倒置的感叹号</target>
        </trans-unit>
        <trans-unit id="8ed370a70ad4ba84f93ff72e14bb89b2e795837a" translate="yes" xml:space="preserve">
          <source>Inverted Lazy S</source>
          <target state="translated">倒立的懒人S</target>
        </trans-unit>
        <trans-unit id="7e3bf2655c3d6132b1040ffc28240e0e2706a489" translate="yes" xml:space="preserve">
          <source>Inverted Ohm Sign / Mho</source>
          <target state="translated">倒置欧姆符号/Mho</target>
        </trans-unit>
        <trans-unit id="77352625457aa55d3c246bb35487f40a40f194e5" translate="yes" xml:space="preserve">
          <source>Inverted Question Mark</source>
          <target state="translated">倒装问号</target>
        </trans-unit>
        <trans-unit id="1dc2af95223d452f5604dae81acef5fd3a117e33" translate="yes" xml:space="preserve">
          <source>Invoke a method for the given generic function &lt;code&gt;f&lt;/code&gt; matching the specified types &lt;code&gt;argtypes&lt;/code&gt; on the specified arguments &lt;code&gt;args&lt;/code&gt; and passing the keyword arguments &lt;code&gt;kwargs&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; must conform with the specified types in &lt;code&gt;argtypes&lt;/code&gt;, i.e. conversion is not automatically performed. This method allows invoking a method other than the most specific matching method, which is useful when the behavior of a more general definition is explicitly needed (often as part of the implementation of a more specific method of the same function).</source>
          <target state="translated">为给定泛型函数 &lt;code&gt;f&lt;/code&gt; 调用一个与指定参数 &lt;code&gt;args&lt;/code&gt; 上的指定类型 &lt;code&gt;argtypes&lt;/code&gt; 相匹配并传递关键字参数 &lt;code&gt;kwargs&lt;/code&gt; 的方法。参数 &lt;code&gt;args&lt;/code&gt; 必须符合 &lt;code&gt;argtypes&lt;/code&gt; 中指定的类型，即不会自动执行转换。此方法允许调用除最具体的匹配方法之外的方法，当明确需要更一般的定义的行为时（通常作为同一功能的更具体的方法的实现的一部分），该方法很有用。</target>
        </trans-unit>
        <trans-unit id="0fe30ecc758896527e5047bf5e1ab5207bc281f3" translate="yes" xml:space="preserve">
          <source>Irrational</source>
          <target state="translated">Irrational</target>
        </trans-unit>
        <trans-unit id="f21fa8512b05ce15e621a0c6aca735529c300b50" translate="yes" xml:space="preserve">
          <source>Issue 8859, &quot;Fix least squares&quot;, https://github.com/JuliaLang/julia/pull/8859</source>
          <target state="translated">问题8859,&quot;修正最小二乘法&quot;,https://github.com/JuliaLang/julia/pull/8859。</target>
        </trans-unit>
        <trans-unit id="beadd95d62ed185b3348f8f407f354b8cc251415" translate="yes" xml:space="preserve">
          <source>It also makes writing exponential functions more elegant:</source>
          <target state="translated">这也使得指数函数的编写更加优雅。</target>
        </trans-unit>
        <trans-unit id="f6ba82c6b32228a1dcbba192584fb70b95766cb3" translate="yes" xml:space="preserve">
          <source>It can be more efficient. Some structs can be packed efficiently into arrays, and in some cases the compiler is able to avoid allocating immutable objects entirely.</source>
          <target state="translated">它可以更有效率。一些结构可以高效地打包成数组,在某些情况下,编译器能够完全避免分配不可变的对象。</target>
        </trans-unit>
        <trans-unit id="2138e5233860592eb48b0938be0063487a8c3bbe" translate="yes" xml:space="preserve">
          <source>It can happen that &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; is already defined in the &lt;code&gt;Random&lt;/code&gt; module. It would then be possible to skip step 1) in practice (if one wants to specialize generation for this particular RNG type), but the corresponding &lt;code&gt;SamplerS&lt;/code&gt; type is considered as internal detail, and may be changed without warning.</source>
          <target state="translated">可能发生在 &lt;code&gt;Random&lt;/code&gt; 模块中已经定义了 &lt;code&gt;Sampler(rng::AbstractRNG, ::S, ::Repetition)&lt;/code&gt; 。这样一来，实际上就可以跳过步骤1）（如果要专门针对这种特定的RNG类型生成），但是相应的 &lt;code&gt;SamplerS&lt;/code&gt; 类型被视为内部细节，可以在不发出警告的情况下进行更改。</target>
        </trans-unit>
        <trans-unit id="b7db5f9d834448c3fd65f59044d31e02c3be0663" translate="yes" xml:space="preserve">
          <source>It can profile into Julia's core code and even (optionally) into C and Fortran libraries.</source>
          <target state="translated">它可以配置文件到Julia的核心代码中,甚至(可选)到C和Fortran库中。</target>
        </trans-unit>
        <trans-unit id="c10e801b8b0e3436ff2d170e31afdf3876bf67ea" translate="yes" xml:space="preserve">
          <source>It does not return.</source>
          <target state="translated">它不返回。</target>
        </trans-unit>
        <trans-unit id="62d668cd36ba8709a3dd4638a2eee6fedce824d7" translate="yes" xml:space="preserve">
          <source>It has a special compilation rule: a homogeneous tuple of &lt;code&gt;VecElement{T}&lt;/code&gt; maps to an LLVM &lt;code&gt;vector&lt;/code&gt; type when &lt;code&gt;T&lt;/code&gt; is a primitive bits type and the tuple length is in the set {2-6,8-10,16}.</source>
          <target state="translated">它有一个特殊的编译规则：当 &lt;code&gt;T&lt;/code&gt; 是原始位类型并且元组长度在集合{2-6,8-10,16}中时， &lt;code&gt;VecElement{T}&lt;/code&gt; 的同质元组映射到LLVM &lt;code&gt;vector&lt;/code&gt; 类型。</target>
        </trans-unit>
        <trans-unit id="35f1e7a71c8a1cc6e09f468c80045e4456b3f7b6" translate="yes" xml:space="preserve">
          <source>It has a toplevel &lt;code&gt;path&lt;/code&gt; entry, then &lt;code&gt;uuid&lt;/code&gt; will be mapped to that path, interpreted relative to the directory containing the project file.</source>
          <target state="translated">它具有一个顶级 &lt;code&gt;path&lt;/code&gt; 条目，然后 &lt;code&gt;uuid&lt;/code&gt; 将被映射到该路径，相对于包含项目文件的目录进行解释。</target>
        </trans-unit>
        <trans-unit id="5302402dcc63d9a0a8348f68814a706354ef52ba" translate="yes" xml:space="preserve">
          <source>It has access to a special locally existent function called &lt;a href=&quot;../../base/base/index#new&quot;&gt;&lt;code&gt;new&lt;/code&gt;&lt;/a&gt; that creates objects of the block's type.</source>
          <target state="translated">它可以访问一个称为&lt;a href=&quot;../../base/base/index#new&quot;&gt; &lt;code&gt;new&lt;/code&gt; 的&lt;/a&gt;本地特殊功能，该功能创建块类型的对象。</target>
        </trans-unit>
        <trans-unit id="3fbc8a317cac4fe1eddafff9a3cee6a2e600d5c8" translate="yes" xml:space="preserve">
          <source>It is also important to see how &lt;code&gt;@generated&lt;/code&gt; functions interact with method redefinition. Following the principle that a correct &lt;code&gt;@generated&lt;/code&gt; function must not observe any mutable state or cause any mutation of global state, we see the following behavior. Observe that the generated function &lt;em&gt;cannot&lt;/em&gt; call any method that was not defined prior to the &lt;em&gt;definition&lt;/em&gt; of the generated function itself.</source>
          <target state="translated">同样重要的是要看到 &lt;code&gt;@generated&lt;/code&gt; 函数如何与方法重定义交互。遵循正确的 &lt;code&gt;@generated&lt;/code&gt; 函数不得观察任何可变状态或引起全局状态任何突变的原则，我们看到以下行为。观察到生成的函数&lt;em&gt;不能&lt;/em&gt;调用在&lt;em&gt;定义&lt;/em&gt;生成的函数本身之前未定义的任何方法。</target>
        </trans-unit>
        <trans-unit id="acbe3463a0ccc2ec8908f82ece54174f7671b1ae" translate="yes" xml:space="preserve">
          <source>It is also important to understand the differences to ordinary scalars. Scalars are not mutable containers (even though they are iterable and define things like &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;getindex&lt;/code&gt;, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;1[] == 1&lt;/code&gt;). In particular, if &lt;code&gt;x = 0.0&lt;/code&gt; is defined as a scalar, it is an error to attempt to change its value via &lt;code&gt;x[] = 1.0&lt;/code&gt;. A scalar &lt;code&gt;x&lt;/code&gt; can be converted into a zero-dimensional array containing it via &lt;code&gt;fill(x)&lt;/code&gt;, and conversely, a zero-dimensional array &lt;code&gt;a&lt;/code&gt; can be converted to the contained scalar via &lt;code&gt;a[]&lt;/code&gt;. Another difference is that a scalar can participate in linear algebra operations such as &lt;code&gt;2 * rand(2,2)&lt;/code&gt;, but the analogous operation with a zero-dimensional array &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; is an error.</source>
          <target state="translated">了解与普通标量的区别也很重要。标量不是可变容器（即使它们是可迭代的，并且定义了诸如 &lt;code&gt;length&lt;/code&gt; ， &lt;code&gt;getindex&lt;/code&gt; 之类的东西，&lt;em&gt;例如&lt;/em&gt; &lt;code&gt;1[] == 1&lt;/code&gt; ）。特别是，如果将 &lt;code&gt;x = 0.0&lt;/code&gt; 定义为标量，则尝试通过 &lt;code&gt;x[] = 1.0&lt;/code&gt; 更改其值是错误的。标量 &lt;code&gt;x&lt;/code&gt; 可以通过 &lt;code&gt;fill(x)&lt;/code&gt; 转换为包含它的零维数组，相反，零维数组 &lt;code&gt;a&lt;/code&gt; 可以通过 &lt;code&gt;a[]&lt;/code&gt; 转换为包含的标量。另一个区别是标量可以参与线性代数运算，例如 &lt;code&gt;2 * rand(2,2)&lt;/code&gt; ，但是使用零维数组 &lt;code&gt;fill(2) * rand(2,2)&lt;/code&gt; 的类似操作是错误的。</target>
        </trans-unit>
        <trans-unit id="a6aa34f5f096577fc826b15725104feebe319049" translate="yes" xml:space="preserve">
          <source>It is also often useful to allow iteration over a collection in &lt;em&gt;reverse order&lt;/em&gt; by iterating over &lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt;&lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt;&lt;/a&gt;. To actually support reverse-order iteration, however, an iterator type &lt;code&gt;T&lt;/code&gt; needs to implement &lt;code&gt;iterate&lt;/code&gt; for &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt;. (Given &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt;, the underling iterator of type &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;r.itr&lt;/code&gt;.) In our &lt;code&gt;Squares&lt;/code&gt; example, we would implement &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; methods:</source>
          <target state="translated">通过在&lt;a href=&quot;../../base/iterators/index#Base.Iterators.reverse&quot;&gt; &lt;code&gt;Iterators.reverse(iterator)&lt;/code&gt; &lt;/a&gt;上进行迭代，以&lt;em&gt;相反的顺序&lt;/em&gt;进行集合迭代通常也很有用。但是，要真正支持逆序迭代，迭代器类型 &lt;code&gt;T&lt;/code&gt; 需要为 &lt;code&gt;Iterators.Reverse{T}&lt;/code&gt; 实现 &lt;code&gt;iterate&lt;/code&gt; 。（给出 &lt;code&gt;r::Iterators.Reverse{T}&lt;/code&gt; ，类型 &lt;code&gt;T&lt;/code&gt; 的 &lt;code&gt;r.itr&lt;/code&gt; 迭代器是r.itr。）在我们的 &lt;code&gt;Squares&lt;/code&gt; 示例中，我们将实现 &lt;code&gt;Iterators.Reverse{Squares}&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="3e1077394826061ef79c129bd16ea289c7d0ba39" translate="yes" xml:space="preserve">
          <source>It is also possible to apply boldface formatting by using &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; as a color. For instance, to print answers in boldface font, one can use the following as a &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">也可以通过使用 &lt;code&gt;Base.text_colors[:bold]&lt;/code&gt; 作为颜色来应用粗体格式。例如，要以黑体字显示答案，可以将以下内容用作 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b553bb959838778f24d5092568f001b6908e4f87" translate="yes" xml:space="preserve">
          <source>It is also possible to interact with a Julia REPL in the browser via &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;. See the package home for details.</source>
          <target state="translated">也可以通过&lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;与浏览器中的Julia REPL进行交互。有关详细信息，请参见软件包主页。</target>
        </trans-unit>
        <trans-unit id="77f0d3358e54fed68167ad7e2f2668925a7d33bb" translate="yes" xml:space="preserve">
          <source>It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like &lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt;&lt;code&gt;pi&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">还值得强调的是，函数应该带有参数，而不是直接对全局变量进行操作（除了像&lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt; &lt;code&gt;pi&lt;/code&gt; &lt;/a&gt;这样的常量）。</target>
        </trans-unit>
        <trans-unit id="af4f80c2a3eb6b9cc2e18a2eac5ff00feaaaca4a" translate="yes" xml:space="preserve">
          <source>It is better to avoid errors than to rely on catching them.</source>
          <target state="translated">避免出错,不如依靠抓错。</target>
        </trans-unit>
        <trans-unit id="62c8e496514b2a89c93f19599f4b3b4a2fbaa739" translate="yes" xml:space="preserve">
          <source>It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them to local variables:</source>
          <target state="translated">将捕获以数组的形式返回是很方便的,这样就可以使用解构语法将它们绑定到本地变量。</target>
        </trans-unit>
        <trans-unit id="d47b317b6ddbcdcb526b152229f01524e725a05a" translate="yes" xml:space="preserve">
          <source>It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.</source>
          <target state="translated">将声明的C类型与其在Julia中的声明完全匹配是至关重要的。不一致会导致在一个系统上正确运行的代码失败,或者在不同系统上产生不确定的结果。</target>
        </trans-unit>
        <trans-unit id="fed6b1dba676362bbdda7d92763627e5b989669b" translate="yes" xml:space="preserve">
          <source>It is declared inside the block of a type declaration, rather than outside of it like normal methods.</source>
          <target state="translated">它是在类型声明的块内声明的,而不是像普通方法那样在块外声明。</target>
        </trans-unit>
        <trans-unit id="be90e9f486db27a87a15823d4ded324a5b8722df" translate="yes" xml:space="preserve">
          <source>It is good practice to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.</source>
          <target state="translated">最好的做法是提供尽可能少的内部构造函数方法:只提供那些显式地接受所有参数并执行必要的错误检查和转换的方法。额外的方便构造方法,提供默认值或辅助转换,应该作为外部构造函数提供,调用内部构造函数来完成繁重的工作。这种分离通常是很自然的。</target>
        </trans-unit>
        <trans-unit id="055af1e6d77e563e261b9cddc84477b0892ca389" translate="yes" xml:space="preserve">
          <source>It is good practice to use such special versions in comparisons (particularly, the trailing &lt;code&gt;-&lt;/code&gt; should always be used on upper bounds unless there's a good reason not to), but they must not be used as the actual version number of anything, as they are invalid in the semantic versioning scheme.</source>
          <target state="translated">优良作法是在比较中使用此类特殊版本（尤其是尾随 &lt;code&gt;-&lt;/code&gt; 除非有充分的理由，否则应始终在上限上使用），但不得将它们用作任何内容的实际版本号，因为它们是在语义版本控制方案中无效。</target>
        </trans-unit>
        <trans-unit id="94f57801215f48bd353cec6fcbf15e2489fd5bd7" translate="yes" xml:space="preserve">
          <source>It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is to call the &lt;code&gt;show&lt;/code&gt; function within the macro body:</source>
          <target state="translated">必须强调的是，宏将其参数作为表达式，文字或符号来接收。探索宏参数的一种方法是在宏主体内调用 &lt;code&gt;show&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="02a6b6b86295c683044f57772927ffaa28e3765b" translate="yes" xml:space="preserve">
          <source>It is important to note that &lt;em&gt;when&lt;/em&gt; an object is locally garbage collected depends on the size of the object and the current memory pressure in the system.</source>
          <target state="translated">重要的是要注意，&lt;em&gt;在&lt;/em&gt;本地存储对象时，垃圾回收取决于对象的大小和系统中的当前内存压力。</target>
        </trans-unit>
        <trans-unit id="600388b971e8fe9fe40cf23408b11ce42cda8c10" translate="yes" xml:space="preserve">
          <source>It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the &lt;code&gt;parent&lt;/code&gt; object was just allocated and garbage collection was not run since then. Remember that most &lt;code&gt;jl_...&lt;/code&gt; functions can sometimes invoke garbage collection.</source>
          <target state="translated">通常无法预测在运行时哪些值将是旧的，因此必须在所有显式存储之后插入写屏障。一个值得注意的例外是，如果仅分配了 &lt;code&gt;parent&lt;/code&gt; 对象，并且此后未运行垃圾回收。请记住，大多数 &lt;code&gt;jl_...&lt;/code&gt; 函数有时可以调用垃圾回收。</target>
        </trans-unit>
        <trans-unit id="1e58853c75f92756885fe162715552efead15275" translate="yes" xml:space="preserve">
          <source>It is not permitted to modify the value of an immutable type.</source>
          <target state="translated">不允许修改不可变类型的值。</target>
        </trans-unit>
        <trans-unit id="737fc29ba3e3878487296ae0904e3501ba8b3de3" translate="yes" xml:space="preserve">
          <source>It is not possible to violate the invariants provided by the type's constructors.</source>
          <target state="translated">不能违反类型的构造函数所提供的不变量。</target>
        </trans-unit>
        <trans-unit id="9c82744b33d4a8c920b021b98d324b0dd36c7c0d" translate="yes" xml:space="preserve">
          <source>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last argument with an ellipsis:</source>
          <target state="translated">能够编写任意数量的参数的函数通常是很方便的。这种函数传统上被称为 &quot;varargs &quot;函数,它是 &quot;可变参数数 &quot;的缩写。你可以在最后一个参数后面用省略号来定义一个varargs函数。</target>
        </trans-unit>
        <trans-unit id="67322f4620eb4bffc38ad6db6fb50c1b9b16e04a" translate="yes" xml:space="preserve">
          <source>It is often convenient to work with data structures that may contain values of any type (arrays of type &lt;code&gt;Array{Any}&lt;/code&gt;). But, if you're using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:</source>
          <target state="translated">使用可能包含任何类型的值（数组 &lt;code&gt;Array{Any}&lt;/code&gt; 数组）的数据结构通常很方便。但是，如果您使用的是这些结构之一，并且碰巧知道元素的类型，则有助于与编译器共享此知识：</target>
        </trans-unit>
        <trans-unit id="284677cc407d046b65013c8fed718805f3d17cb7" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;Parametrically-constrained Varargs methods&lt;/a&gt;.</source>
          <target state="translated">可以限制作为变量参数传递的值的数量。稍后将在&lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;参数约束Varargs方法中&lt;/a&gt;对此进行讨论。</target>
        </trans-unit>
        <trans-unit id="a70320747de27e26b4b70f213eeadabc7679b96a" translate="yes" xml:space="preserve">
          <source>It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:</source>
          <target state="translated">可以定义一组函数方法,使其不存在适用于某些参数组合的唯一的最特定方法。</target>
        </trans-unit>
        <trans-unit id="deea519c4200e4fe336ac8810c406887e0570f07" translate="yes" xml:space="preserve">
          <source>It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:</source>
          <target state="translated">可以将Julia函数传递给接受函数指针参数的本地C函数。例如,为了匹配形式的C原型。</target>
        </trans-unit>
        <trans-unit id="b862a89ec67717dcb808d8174cdd3cd9cf5de933" translate="yes" xml:space="preserve">
          <source>It is possible to write definitions like the following:</source>
          <target state="translated">可以写这样的定义:</target>
        </trans-unit>
        <trans-unit id="079123703d5fe6500844bec9cf4fbeb95441a39c" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">建议子类型 &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; 覆盖以下方法签名以提供更有效的实现： &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4972fa162a33587e78213cfd46e68a922aa11ce5" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">建议子类型 &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; 重写以下方法签名以提供更有效的实现： &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e657552abcb773fba2d1c58477efeff3641733f" translate="yes" xml:space="preserve">
          <source>It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.</source>
          <target state="translated">建议首先界定消除歧义的方法,否则,在界定更具体的方法之前,即使是短暂的,也会存在歧义。</target>
        </trans-unit>
        <trans-unit id="3205262d1b20d05a3ec0c7f09158500e89b8710e" translate="yes" xml:space="preserve">
          <source>It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.</source>
          <target state="translated">以任意或重叠顺序执行迭代是安全的,要特别考虑还原变量。</target>
        </trans-unit>
        <trans-unit id="d10887452da1b7a8299e792daec58426383fc305" translate="yes" xml:space="preserve">
          <source>It is significant that like &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt;, the expressions before and after the &lt;code&gt;:&lt;/code&gt; are only evaluated if the condition expression evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively:</source>
          <target state="translated">重要的是，像 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; 一样，仅在条件表达式分别为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 时才对 &lt;code&gt;:&lt;/code&gt; 之前和之后的表达式进行求值：</target>
        </trans-unit>
        <trans-unit id="6abc534e54f65480aad0f619aee6267faddc4174" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient to terminate the repetition of a &lt;code&gt;while&lt;/code&gt; before the test condition is falsified or stop iterating in a &lt;code&gt;for&lt;/code&gt; loop before the end of the iterable object is reached. This can be accomplished with the &lt;code&gt;break&lt;/code&gt; keyword:</source>
          <target state="translated">有时很方便的是 &lt;code&gt;while&lt;/code&gt; 伪造测试条件之前终止一段时间的重复，或者在到达可迭代对象的末尾之前在 &lt;code&gt;for&lt;/code&gt; 循环中停止迭代。这可以通过 &lt;code&gt;break&lt;/code&gt; 关键字完成：</target>
        </trans-unit>
        <trans-unit id="20dfcec28a6dd8951f574998a3986a215e74fce8" translate="yes" xml:space="preserve">
          <source>It is sometimes helpful during module development to turn off incremental precompilation. The command line flag &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; enables you to toggle module precompilation on and off. When Julia is started with &lt;code&gt;--compiled-modules=no&lt;/code&gt; the serialized modules in the compile cache are ignored when loading modules and module dependencies. &lt;code&gt;Base.compilecache&lt;/code&gt; can still be called manually. The state of this command line flag is passed to &lt;code&gt;Pkg.build&lt;/code&gt; to disable automatic precompilation triggering when installing, updating, and explicitly building packages.</source>
          <target state="translated">有时在模块开发期间关闭增量预编译很有用。命令行标志 &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; 使您可以打开和关闭模块预编译。当Julia以 &lt;code&gt;--compiled-modules=no&lt;/code&gt; 开头时，在加载模块和模块依赖项时，编译缓存中的序列化模块将被忽略。 &lt;code&gt;Base.compilecache&lt;/code&gt; 仍然可以手动调用。此命令行标志的状态传递给 &lt;code&gt;Pkg.build&lt;/code&gt; ,以在安装，更新和显式生成软件包时禁用自动预编译触发。</target>
        </trans-unit>
        <trans-unit id="94baf48d740dae1d64cb4dabcdca4ac61d569c1b" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the &lt;code&gt;Libdl&lt;/code&gt; functions to manage the library explicitly, such as:</source>
          <target state="translated">有时关闭（卸载）库以重新加载它很有用。例如，当开发用于Julia的C代码时，可能需要进行编译，从Julia中调用C代码，然后关闭库，进行编辑，重新编译并加载新更改。可以重新启动Julia或使用 &lt;code&gt;Libdl&lt;/code&gt; 函数来显式管理该库，例如：</target>
        </trans-unit>
        <trans-unit id="32e81dce90195c032e275e55f3bfa20c146074b3" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:</source>
          <target state="translated">有时,对不同大小的数组进行逐元素的二进制操作是很有用的,比如在矩阵的每一列中添加一个向量。一个低效的方法是将向量复制到矩阵的大小。</target>
        </trans-unit>
        <trans-unit id="58d81677369240f5f99e6de14b72f59ff777800d" translate="yes" xml:space="preserve">
          <source>It is to be noted that this is generally not an issue. It is something to be factored in only if the object is both being stored locally and modifed post the call. In such cases it may be appropriate to store a &lt;code&gt;deepcopy&lt;/code&gt; of the object.</source>
          <target state="translated">要注意的是，这通常不是问题。仅当对象既在本地存储又在调用后进行修改时，才应考虑这一点。在这种情况下，可能需要存储对象的 &lt;code&gt;deepcopy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4930241b205d76b9c3d495f83abf296392db54b7" translate="yes" xml:space="preserve">
          <source>It is usually best to avoid capturing references to instances of internal metadata objects such as &lt;code&gt;Method&lt;/code&gt;, &lt;code&gt;MethodInstance&lt;/code&gt;, &lt;code&gt;MethodTable&lt;/code&gt;, &lt;code&gt;TypeMapLevel&lt;/code&gt;, &lt;code&gt;TypeMapEntry&lt;/code&gt; and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.</source>
          <target state="translated">通常最好避免捕获对内部元数据对象实例（例如 &lt;code&gt;Method&lt;/code&gt; ， &lt;code&gt;MethodInstance&lt;/code&gt; ， &lt;code&gt;MethodTable&lt;/code&gt; ，MethodTable， &lt;code&gt;TypeMapLevel&lt;/code&gt; ， &lt;code&gt;TypeMapEntry&lt;/code&gt; )的引用以及这些对象的字段，因为这可能会使序列化程序混淆，并且可能不会导致您想要的结果。这样做不一定是错误的，但是您只需要准备好系统将尝试复制其中一些并创建其他实例的唯一实例即可。</target>
        </trans-unit>
        <trans-unit id="b19a6924f8364edbfe868e5511ad36bcb64fff31" translate="yes" xml:space="preserve">
          <source>It is usually not much help to construct arrays like the following:</source>
          <target state="translated">通常情况下,像下面这样构造数组是没什么用的。</target>
        </trans-unit>
        <trans-unit id="e4380a1b0acd2209a89981ccd04cfa0fd834aaba" translate="yes" xml:space="preserve">
          <source>It is very important that the called function does not call back into Julia, as it will segfault.</source>
          <target state="translated">非常重要的一点是,被调用的函数不能回调到Julia中,因为这会导致segfault。</target>
        </trans-unit>
        <trans-unit id="805fdc406fb3dba1fb93a133c29b22878b4c87dc" translate="yes" xml:space="preserve">
          <source>It may take optional keyword arguments:</source>
          <target state="translated">它可以接受可选的关键字参数。</target>
        </trans-unit>
        <trans-unit id="9d3c85b9245c7315a1b23d4e146f385ddcbfb243" translate="yes" xml:space="preserve">
          <source>It means that the type of the output is predictable from the types of the inputs. In particular, it means that the type of the output cannot vary depending on the &lt;em&gt;values&lt;/em&gt; of the inputs. The following code is &lt;em&gt;not&lt;/em&gt; type-stable:</source>
          <target state="translated">这意味着可以根据输入的类型来预测输出的类型。特别是，这意味着输出的类型不能根据输入的&lt;em&gt;值&lt;/em&gt;而变化。以下代码&lt;em&gt;不是&lt;/em&gt;类型稳定的：</target>
        </trans-unit>
        <trans-unit id="c3b7dcbf1418595d94f20981812341bdb45796ab" translate="yes" xml:space="preserve">
          <source>It only makes sense to take ratios of integer values, so the parameter type &lt;code&gt;T&lt;/code&gt; is restricted to being a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, and a ratio of integers represents a value on the real number line, so any &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; is an instance of the &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; abstraction.</source>
          <target state="translated">仅取整数值的比率才有意义，因此将参数类型 &lt;code&gt;T&lt;/code&gt; 限制为&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;的子类型，并且整数比率表示实数行上的值，因此任何&lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;都是&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;抽象的实例。</target>
        </trans-unit>
        <trans-unit id="a692191dac5658d6e6f21b53ff80758c81d0148d" translate="yes" xml:space="preserve">
          <source>It provides a mutable wrapper around an iterator and its iteration state.</source>
          <target state="translated">它提供了一个围绕迭代器及其迭代状态的可突变封装器。</target>
        </trans-unit>
        <trans-unit id="75d07a5f3996139947136e92cd3660ed889424cf" translate="yes" xml:space="preserve">
          <source>It returns either an &lt;code&gt;Int&lt;/code&gt; or a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult.</source>
          <target state="translated">根据其参数值，它返回 &lt;code&gt;Int&lt;/code&gt; 或&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;。由于Julia无法在编译时预测此函数的返回类型，因此使用该函数的任何计算都必须防范可能发生的两种类型，从而难以生成快速的机器代码。</target>
        </trans-unit>
        <trans-unit id="e13bba493365e2c5b2e76f0ae39f91eaa1b27bd1" translate="yes" xml:space="preserve">
          <source>It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code written as the &lt;code&gt;mynorm&lt;/code&gt; example.</source>
          <target state="translated">但是应该注意，编译器在优化作为 &lt;code&gt;mynorm&lt;/code&gt; 示例编写的代码中的无效分支方面非常有效。</target>
        </trans-unit>
        <trans-unit id="429ea7fe9a07243d9d929909311d0c5286ba8da0" translate="yes" xml:space="preserve">
          <source>It turns an iterator-like abstraction into a &lt;code&gt;Channel&lt;/code&gt;-like abstraction.</source>
          <target state="translated">它将类似迭代器的抽象转换为类似 &lt;code&gt;Channel&lt;/code&gt; 的抽象。</target>
        </trans-unit>
        <trans-unit id="85d168e5e85b9af5b4b41b997ebf680755497e13" translate="yes" xml:space="preserve">
          <source>It's a good idea to first run the code you intend to profile at least once (unless you want to profile Julia's JIT-compiler):</source>
          <target state="translated">最好是先运行你打算配置的代码至少一次(除非你想配置Julia的JIT编译器)。</target>
        </trans-unit>
        <trans-unit id="6aa7c46c7a469a8066f30e0a6330c5f7107a8c6d" translate="yes" xml:space="preserve">
          <source>It's also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:</source>
          <target state="translated">也可以在Julia文档中添加对其他文档中的函数/方法/变量的交叉引用。例如:在Julia文档中,可以添加交叉引用到其他文档中的函数/方法/变量。</target>
        </trans-unit>
        <trans-unit id="d58241f9f697434c4e06081f155d61314cbdb71e" translate="yes" xml:space="preserve">
          <source>It's an iterator that mutates to become its own rest iterator whenever an item is produced.</source>
          <target state="translated">这是一个迭代器,每当一个项目产生时,它就会变异成为自己的休息迭代器。</target>
        </trans-unit>
        <trans-unit id="4aa36d32a2c02cf6990c1d5d08f2ca5067ed910f" translate="yes" xml:space="preserve">
          <source>It's easiest to illustrate this with an example. We can declare a generated function &lt;code&gt;foo&lt;/code&gt; as</source>
          <target state="translated">举个例子最容易说明这一点。我们可以将生成的函数 &lt;code&gt;foo&lt;/code&gt; 声明为</target>
        </trans-unit>
        <trans-unit id="38dda39f4395bbec3e9a522986faf60e028082c7" translate="yes" xml:space="preserve">
          <source>It's good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some &lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;tricky issues&lt;/a&gt; to deal with (though much less so for day-precision types).</source>
          <target state="translated">当使用任何语言/日期框架来熟悉如何处理日期周期算术时，这是一个好习惯，因为要处理一些&lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;棘手的问题&lt;/a&gt;（尽管对于日精度类型而言要少得多）。</target>
        </trans-unit>
        <trans-unit id="0640f8fda4ec7bf5464b3cee97ae0f4dda5ee1e4" translate="yes" xml:space="preserve">
          <source>It's important to be aware of potentially dangerous situations such as concatenation of invalid UTF-8 strings. The resulting string may contain different characters than the input strings, and its number of characters may be lower than sum of numbers of characters of the concatenated strings, e.g.:</source>
          <target state="translated">重要的是要注意潜在的危险情况,如无效UTF-8字符串的连接。所产生的字符串可能包含与输入字符串不同的字符,其字符数可能低于连接字符串的字符数之和,例如:。</target>
        </trans-unit>
        <trans-unit id="3dbecc240e8c1b98fcd4c298d9a96ae72e276750" translate="yes" xml:space="preserve">
          <source>It's important to note that there's a very large assymmetry in the performance of these conversions. Converting a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than multiplication. While some arrays &amp;mdash; like &lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; itself &amp;mdash; are implemented using a linear chunk of memory and directly use a linear index in their implementations, other arrays &amp;mdash; like &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt; &amp;mdash; need the full set of cartesian indices to do their lookup (see &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt; to introspect which is which). As such, when iterating over an entire array, it's much better to iterate over &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex(A)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;1:length(A)&lt;/code&gt;. Not only will the former be much faster in cases where &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;IndexCartesian&lt;/code&gt;, but it will also support OffsetArrays, too.</source>
          <target state="translated">重要的是要注意，这些转换的性能存在很大的不对称性。将线性索引转换为一组笛卡尔索引需要除以余数，而采用另一种方法就是相乘和相加。在现代处理器中，整数除法可能比乘法慢10至50倍。尽管某些数组（例如&lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;本身）是使用线性内存块实现的，并在其实现中直接使用线性索引，但其他数组（例如&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; &lt;/a&gt;）则需要完整的笛卡尔索引集来进行查找（请参阅&lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt;进行自省，哪一个）。这样，当遍历整个数组时，最好遍历&lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex(A)&lt;/code&gt; &lt;/a&gt;而不是遍历 &lt;code&gt;1:length(A)&lt;/code&gt; 。在 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;IndexCartesian&lt;/code&gt; 的情况下，前者不仅会更快，而且也将支持OffsetArrays。</target>
        </trans-unit>
        <trans-unit id="53f0c889cfa216f7a561510a3ad57de629360e4b" translate="yes" xml:space="preserve">
          <source>It's now possible to get a sampler with &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt;, and use &lt;code&gt;sp&lt;/code&gt; instead of &lt;code&gt;die&lt;/code&gt; in any &lt;code&gt;rand&lt;/code&gt; call involving &lt;code&gt;rng&lt;/code&gt;. In the simplistic example above, &lt;code&gt;die&lt;/code&gt; doesn't need to be stored in &lt;code&gt;SamplerDie&lt;/code&gt; but this is often the case in practice.</source>
          <target state="translated">现在可以使用 &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt; 获得一个采样器，并在涉及 &lt;code&gt;rng&lt;/code&gt; 的任何 &lt;code&gt;rand&lt;/code&gt; 调用中使用 &lt;code&gt;sp&lt;/code&gt; 代替 &lt;code&gt;die&lt;/code&gt; 。在上面的简单示例中，无需将 &lt;code&gt;die&lt;/code&gt; 存储在 &lt;code&gt;SamplerDie&lt;/code&gt; 中,但实际上通常是这样。</target>
        </trans-unit>
        <trans-unit id="435e5d30b709899a41a3dc97d975e671346837d6" translate="yes" xml:space="preserve">
          <source>It's quite instructive to compare the sheer amount code generated for a simple function</source>
          <target state="translated">比较一下一个简单函数所产生的代码量是很有启发意义的。</target>
        </trans-unit>
        <trans-unit id="485af6f7d5c0b66af203ac099b1bf7b0eba726ba" translate="yes" xml:space="preserve">
          <source>It's worth emphasizing that &lt;code&gt;localindices&lt;/code&gt; exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a &lt;code&gt;SharedArray&lt;/code&gt;, all indices should be equally fast for each worker process.</source>
          <target state="translated">值得强调的是， &lt;code&gt;localindices&lt;/code&gt; 纯粹是为了方便起见而存在，您可以按自己希望的方式在工人之间对阵列进行分区。对于 &lt;code&gt;SharedArray&lt;/code&gt; ，每个工作进程的所有索引都应同样快。</target>
        </trans-unit>
        <trans-unit id="7d5d6404960db7e0b184fd1dfa040fb8f1124932" translate="yes" xml:space="preserve">
          <source>It's worth noting that it's extremely easy to mis-use parametric &quot;value&quot; types, including &lt;code&gt;Val&lt;/code&gt;; in unfavorable cases, you can easily end up making the performance of your code much &lt;em&gt;worse&lt;/em&gt;. In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of &lt;code&gt;Val&lt;/code&gt;, please read the more extensive discussion in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;the performance tips&lt;/a&gt;.</source>
          <target state="translated">值得注意的是，滥用参数&amp;ldquo;值&amp;rdquo;类型非常容易，包括 &lt;code&gt;Val&lt;/code&gt; ；在不利的情况下，您很容易最终使代码的性能&lt;em&gt;变差&lt;/em&gt;。特别是，您永远都不想编写如上所述的实际代码。有关正确（和不正确）使用 &lt;code&gt;Val&lt;/code&gt; 的更多信息，请阅读&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;性能提示中&lt;/a&gt;更广泛的讨论。</target>
        </trans-unit>
        <trans-unit id="3b9b0722d0d43e4d14ff92cca723a64b8e24e4f0" translate="yes" xml:space="preserve">
          <source>Italics</source>
          <target state="translated">Italics</target>
        </trans-unit>
        <trans-unit id="c218bb3261ced0b188316d903cb0484a6a43b61a" translate="yes" xml:space="preserve">
          <source>Iterable Collections</source>
          <target state="translated">迭代集合</target>
        </trans-unit>
        <trans-unit id="81a99e5d5fc07b72d6b1647c497a7c5192f69fad" translate="yes" xml:space="preserve">
          <source>Iterate over a collection &lt;code&gt;n&lt;/code&gt; elements at a time.</source>
          <target state="translated">一次遍历一个集合 &lt;code&gt;n&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="7878c863963cb51356acf7ca3e8ea44be505a483" translate="yes" xml:space="preserve">
          <source>Iterated dispatch</source>
          <target state="translated">迭代调度</target>
        </trans-unit>
        <trans-unit id="42206b6c92650b3931037fd07719156176dc0314" translate="yes" xml:space="preserve">
          <source>Iterating over the &lt;code&gt;CartesianIndices&lt;/code&gt; of the &lt;code&gt;axes(::Broadcasted)&lt;/code&gt; and using indexing with the resulting &lt;code&gt;CartesianIndex&lt;/code&gt; object to compute the result.</source>
          <target state="translated">遍历axis &lt;code&gt;axes(::Broadcasted)&lt;/code&gt; 的 &lt;code&gt;CartesianIndices&lt;/code&gt; ，并将索引与结果 &lt;code&gt;CartesianIndex&lt;/code&gt; 对象一起使用以计算结果。</target>
        </trans-unit>
        <trans-unit id="a4979919b853dff1595ccf476a13a01680f6c472" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Q&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, &lt;code&gt;F.&amp;alpha;&lt;/code&gt;, and &lt;code&gt;F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">迭代分解产生组分 &lt;code&gt;F.S&lt;/code&gt; ， &lt;code&gt;F.T&lt;/code&gt; ， &lt;code&gt;F.Q&lt;/code&gt; ， &lt;code&gt;F.Z&lt;/code&gt; ， &lt;code&gt;F.&amp;alpha;&lt;/code&gt; ，和 &lt;code&gt;F.&amp;beta;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc67e8a927f1aa6eff5ad47840e758df966f518f" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, and &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生分量 &lt;code&gt;F.T&lt;/code&gt; ， &lt;code&gt;F.Z&lt;/code&gt; 和 &lt;code&gt;F.values&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4d4ad8d2cf2c1ee9c60ddef640294bbac58cbc2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.values&lt;/code&gt; and &lt;code&gt;F.vectors&lt;/code&gt;.</source>
          <target state="translated">迭代分解会生成分量 &lt;code&gt;F.values&lt;/code&gt; 和 &lt;code&gt;F.vectors&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86506020c8187a26d343a03489380c16723ff386" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">迭代分解产生组分 &lt;code&gt;Q&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0eea487785d89d96fdac640a6604fc8fe54c944d" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生分量 &lt;code&gt;Q&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cab411fc4fe9253bda3d235df40d5dfd6ef9668c" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and if extant &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生分量 &lt;code&gt;Q&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; 和（如果存在） &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3b6360c2464673a0e4fb9b1ed45a041967155d6" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="translated">在给定 &lt;code&gt;S.uplo&lt;/code&gt; 和 &lt;code&gt;S.p&lt;/code&gt; 情况下，迭代分解将生成适当的分量 &lt;code&gt;S.D&lt;/code&gt; ， &lt;code&gt;S.U&lt;/code&gt; 或 &lt;code&gt;S.L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f77bd282f84af7bfe48cdf3c4e7e8dc8c570cc8e" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.L&lt;/code&gt; and &lt;code&gt;S.Q&lt;/code&gt;.</source>
          <target state="translated">迭代分解会生成分量 &lt;code&gt;S.L&lt;/code&gt; 和 &lt;code&gt;S.Q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89ebce396ac9da86f707ddc5cfcf6229ef6143e2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">迭代分解产生组分 &lt;code&gt;U&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c715668f8440af4b021f6c74fa32fef39d559c06" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;, &lt;code&gt;D2&lt;/code&gt;, and &lt;code&gt;R0&lt;/code&gt;.</source>
          <target state="translated">迭代分解会生成分量 &lt;code&gt;U&lt;/code&gt; ， &lt;code&gt;V&lt;/code&gt; ， &lt;code&gt;Q&lt;/code&gt; ， &lt;code&gt;D1&lt;/code&gt; ， &lt;code&gt;D2&lt;/code&gt; 和 &lt;code&gt;R0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b09a0a43519ceb489793a2ede6c213029b86bdfc" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the factors &lt;code&gt;F.Q&lt;/code&gt; and &lt;code&gt;F.H&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生因子 &lt;code&gt;F.Q&lt;/code&gt; 和 &lt;code&gt;F.H&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f58aa126be8fea0928c97cbc1c2e33d08204701b" translate="yes" xml:space="preserve">
          <source>Iterating the factorization produces the components &lt;code&gt;F.L&lt;/code&gt;, &lt;code&gt;F.U&lt;/code&gt;, and &lt;code&gt;F.p&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生分量 &lt;code&gt;F.L&lt;/code&gt; ， &lt;code&gt;F.U&lt;/code&gt; 和 &lt;code&gt;F.p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="ca49cf020b23404ede665f3ef9ef58b961aea893" translate="yes" xml:space="preserve">
          <source>Iteration over &lt;code&gt;NamedTuple&lt;/code&gt;s produces the &lt;em&gt;values&lt;/em&gt; without the names. (See example below.) To iterate over the name-value pairs, use the &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">对 &lt;code&gt;NamedTuple&lt;/code&gt; 进行迭代将生成不带名称的&lt;em&gt;值&lt;/em&gt;。（请参见下面的示例。）要遍历名称/值对，请使用&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="029d5196356372d794cb53808ecda6f8a64c6198" translate="yes" xml:space="preserve">
          <source>Iteration utilities</source>
          <target state="translated">迭代工具</target>
        </trans-unit>
        <trans-unit id="bc1f336bbebec9ed2484b3179ad56691be7b079d" translate="yes" xml:space="preserve">
          <source>IteratorEltype</source>
          <target state="translated">IteratorEltype</target>
        </trans-unit>
        <trans-unit id="762bcf9ad00a1c98c7dfe72f3f1da300a726ae97" translate="yes" xml:space="preserve">
          <source>IteratorSize</source>
          <target state="translated">IteratorSize</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="ade312c99a3f29ec263e6761dccc45de6d98af27" translate="yes" xml:space="preserve">
          <source>Iterators.Pairs</source>
          <target state="translated">Iterators.Pairs</target>
        </trans-unit>
        <trans-unit id="7f99860914bab93742ec0677d93601e7f754aab7" translate="yes" xml:space="preserve">
          <source>Iterators.Stateful</source>
          <target state="translated">Iterators.Stateful</target>
        </trans-unit>
        <trans-unit id="4b22c43fb78a467e966bea6e6bf82f640caa802a" translate="yes" xml:space="preserve">
          <source>Iterators.countfrom()</source>
          <target state="translated">Iterators.countfrom()</target>
        </trans-unit>
        <trans-unit id="6e9ea1a37868f81f1c387104af3ddce669dd91f6" translate="yes" xml:space="preserve">
          <source>Iterators.cycle()</source>
          <target state="translated">Iterators.cycle()</target>
        </trans-unit>
        <trans-unit id="15fc1b0f962745a0f7d6dddec1a5029f764fddf9" translate="yes" xml:space="preserve">
          <source>Iterators.drop()</source>
          <target state="translated">Iterators.drop()</target>
        </trans-unit>
        <trans-unit id="b622262f6019cdcf33dc40c2166a76e9968c2d6f" translate="yes" xml:space="preserve">
          <source>Iterators.enumerate()</source>
          <target state="translated">Iterators.enumerate()</target>
        </trans-unit>
        <trans-unit id="18c6e2577f1cb3f1df18e8349820ab2df102ed03" translate="yes" xml:space="preserve">
          <source>Iterators.filter()</source>
          <target state="translated">Iterators.filter()</target>
        </trans-unit>
        <trans-unit id="1c4406a3948ea47560dd3a48a99cedb41058481a" translate="yes" xml:space="preserve">
          <source>Iterators.flatten()</source>
          <target state="translated">Iterators.flatten()</target>
        </trans-unit>
        <trans-unit id="e6b2ae68200d1658f8b9b58b1bda15c7a94398ec" translate="yes" xml:space="preserve">
          <source>Iterators.partition()</source>
          <target state="translated">Iterators.partition()</target>
        </trans-unit>
        <trans-unit id="8d055b9ee1bc21393531304979f760c0dcaf8ed7" translate="yes" xml:space="preserve">
          <source>Iterators.product()</source>
          <target state="translated">Iterators.product()</target>
        </trans-unit>
        <trans-unit id="f82f74da2e638549fe42f2abf5e3d47275b9d6dc" translate="yes" xml:space="preserve">
          <source>Iterators.repeated()</source>
          <target state="translated">Iterators.repeated()</target>
        </trans-unit>
        <trans-unit id="d0a4aaf299b047ef88d9088cb3265b8c9ec460f8" translate="yes" xml:space="preserve">
          <source>Iterators.rest()</source>
          <target state="translated">Iterators.rest()</target>
        </trans-unit>
        <trans-unit id="78c5327cecfd4b16a167206d910e94f07f9e5a1d" translate="yes" xml:space="preserve">
          <source>Iterators.reverse()</source>
          <target state="translated">Iterators.reverse()</target>
        </trans-unit>
        <trans-unit id="1780ae66e17e617d0386e7c850f35f9a46563eec" translate="yes" xml:space="preserve">
          <source>Iterators.take()</source>
          <target state="translated">Iterators.take()</target>
        </trans-unit>
        <trans-unit id="38d733610a11317778f298c2adaafc9ed0e772f3" translate="yes" xml:space="preserve">
          <source>Iterators.zip()</source>
          <target state="translated">Iterators.zip()</target>
        </trans-unit>
        <trans-unit id="e5c9811ac9fab746e9ba97b16b953053ef624d64" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndex</source>
          <target state="translated">IteratorsMD.CartesianIndex</target>
        </trans-unit>
        <trans-unit id="dab2cf0daf838d270ad35eb4a74061238bf4a503" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndices</source>
          <target state="translated">IteratorsMD.CartesianIndices</target>
        </trans-unit>
        <trans-unit id="30ab5c44fe067198393909d62c86b0c386a162b7" translate="yes" xml:space="preserve">
          <source>Its second argument &lt;code&gt;args&lt;/code&gt; is an array of &lt;code&gt;jl_value_t*&lt;/code&gt; arguments and &lt;code&gt;nargs&lt;/code&gt; is the number of arguments.</source>
          <target state="translated">它的第二个参数 &lt;code&gt;args&lt;/code&gt; 是 &lt;code&gt;jl_value_t*&lt;/code&gt; 参数的数组，而 &lt;code&gt;nargs&lt;/code&gt; 是参数的数量。</target>
        </trans-unit>
        <trans-unit id="286bb02d594ea15955d87681e8267067be410857" translate="yes" xml:space="preserve">
          <source>Izakaya Lantern</source>
          <target state="translated">居酒屋灯笼</target>
        </trans-unit>
        <trans-unit id="2f5fc08c12a2ccfd9c859b035ca12cb9526ce0af" translate="yes" xml:space="preserve">
          <source>J R Bunch and L Kaufman, Some stable methods for calculating inertia</source>
          <target state="translated">J R Bunch and L Kaufman,Some stable methods for calculating intia.</target>
        </trans-unit>
        <trans-unit id="831fdbe2f742b632acf268054e5932135a416335" translate="yes" xml:space="preserve">
          <source>Jack-O-Lantern</source>
          <target state="translated">Jack-O-Lantern</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="ad6d155a582ef676e9240bfd2300a9eb9553e4f3" translate="yes" xml:space="preserve">
          <source>Japanese Castle</source>
          <target state="translated">日本城</target>
        </trans-unit>
        <trans-unit id="ed8bfe0cf71057039bd166fcb8a33ed47c1d1057" translate="yes" xml:space="preserve">
          <source>Japanese Dolls</source>
          <target state="translated">日本娃娃</target>
        </trans-unit>
        <trans-unit id="97302784bd85c6fc3ccdcadbac4da292edfbb8ba" translate="yes" xml:space="preserve">
          <source>Japanese Goblin</source>
          <target state="translated">日本妖精</target>
        </trans-unit>
        <trans-unit id="7263dbff30ade45b8568943da751abb88bf70826" translate="yes" xml:space="preserve">
          <source>Japanese Ogre</source>
          <target state="translated">日本食人魔</target>
        </trans-unit>
        <trans-unit id="134fe6f595c84ed345de3ae0637be6654696bcaa" translate="yes" xml:space="preserve">
          <source>Japanese Post Office</source>
          <target state="translated">日本邮局</target>
        </trans-unit>
        <trans-unit id="0239b1f09d4f7c4b093fb50eb113f3c45f2d4d30" translate="yes" xml:space="preserve">
          <source>Japanese Symbol For Beginner</source>
          <target state="translated">初级日语符号</target>
        </trans-unit>
        <trans-unit id="d1e9767d8a0bd6d2bf67011d187d114cce67abb1" translate="yes" xml:space="preserve">
          <source>Jeans</source>
          <target state="translated">Jeans</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="76788f50771e86fe282c9d53f0b06082b3018e7d" translate="yes" xml:space="preserve">
          <source>Join an array of &lt;code&gt;strings&lt;/code&gt; into a single string, inserting the given delimiter between adjacent strings. If &lt;code&gt;last&lt;/code&gt; is given, it will be used instead of &lt;code&gt;delim&lt;/code&gt; between the last two strings. If &lt;code&gt;io&lt;/code&gt; is given, the result is written to &lt;code&gt;io&lt;/code&gt; rather than returned as as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;strings&lt;/code&gt; 数组连接为单个字符串，在相邻字符串之间插入给定的分隔符。如果给出了 &lt;code&gt;last&lt;/code&gt; ，则将在最后两个字符串之间使用它代替 &lt;code&gt;delim&lt;/code&gt; 。如果给定 &lt;code&gt;io&lt;/code&gt; ，则将结果写入 &lt;code&gt;io&lt;/code&gt; 而不是作为 &lt;code&gt;String&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="0499501b2bb39022852369c1a09b6f3fb6fc16a6" translate="yes" xml:space="preserve">
          <source>Join path components into a full path. If some argument is an absolute path or (on Windows) has a drive specification that doesn't match the drive computed for the join of the preceding paths, then prior components are dropped.</source>
          <target state="translated">将路径组件连接成一个完整的路径。如果某个参数是绝对路径,或者(在Windows下)它的驱动器规格与前面路径的连接计算的驱动器不匹配,那么前面的组件将被放弃。</target>
        </trans-unit>
        <trans-unit id="e64d664b335757ab1b0ed70dc6883a5f412be34b" translate="yes" xml:space="preserve">
          <source>Julia</source>
          <target state="translated">Julia</target>
        </trans-unit>
        <trans-unit id="34915350c4729155e12aa2a18e1437b46a254b8d" translate="yes" xml:space="preserve">
          <source>Julia 1.1</source>
          <target state="translated">Julia 1.1</target>
        </trans-unit>
        <trans-unit id="20d44d7c210bfc70cdc873c771c707c9f3303af5" translate="yes" xml:space="preserve">
          <source>Julia 1.2</source>
          <target state="translated">Julia 1.2</target>
        </trans-unit>
        <trans-unit id="8b642007f455f270d5f4ca8eeb353a9cd627fd87" translate="yes" xml:space="preserve">
          <source>Julia 1.2 Documentation</source>
          <target state="translated">Julia 1.2 文档</target>
        </trans-unit>
        <trans-unit id="858ca45563192af10cdc21c94e7d577c6f26612b" translate="yes" xml:space="preserve">
          <source>Julia Base Type</source>
          <target state="translated">茱莉亚基地类型</target>
        </trans-unit>
        <trans-unit id="c3d7a86babfba0e54357fb2d1ed82f5bfe9ac6bf" translate="yes" xml:space="preserve">
          <source>Julia Base contains a range of functions and macros appropriate for performing scientific and numerical computing, but is also as broad as those of many general purpose programming languages. Additional functionality is available from a growing collection of available packages. Functions are grouped by topic below.</source>
          <target state="translated">Julia Base包含一系列适合于进行科学和数值计算的函数和宏,但也和许多通用编程语言一样广泛。其他的功能可以从越来越多的可用包中获得。下面按主题对函数进行了分类。</target>
        </trans-unit>
        <trans-unit id="ecea329751a7da4bad931e777e922977157ad8f8" translate="yes" xml:space="preserve">
          <source>Julia Base uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;), and others which are just modifying (e.g., &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt;&lt;code&gt;pop!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt;&lt;code&gt;splice!&lt;/code&gt;&lt;/a&gt;). It is typical for such functions to also return the modified array for convenience.</source>
          <target state="translated">Julia Base始终使用该约定，并包含具有复制和修改形式的函数示例（例如，&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;），以及仅在进行修改的函数示例（例如，&lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt; &lt;code&gt;pop!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt; &lt;code&gt;splice!&lt;/code&gt; &lt;/a&gt;）。为了方便起见，此类函数通常还返回修改后的数组。</target>
        </trans-unit>
        <trans-unit id="7694e2fcb791d9c25c404da14cf2f301a28f48ea" translate="yes" xml:space="preserve">
          <source>Julia Coroutines (Green Threading)</source>
          <target state="translated">Julia Coroutines (Green Threading)</target>
        </trans-unit>
        <trans-unit id="79e749c34e72bbae64d0f791f7a71e619f74aae2" translate="yes" xml:space="preserve">
          <source>Julia GPU man pages</source>
          <target state="translated">Julia GPU手册</target>
        </trans-unit>
        <trans-unit id="a42ee146344a47614f0b605c9369dddac1347289" translate="yes" xml:space="preserve">
          <source>Julia Releases</source>
          <target state="translated">茱莉亚发布</target>
        </trans-unit>
        <trans-unit id="8d8d2a4a743981227407130fd283bf2436f883ac" translate="yes" xml:space="preserve">
          <source>Julia aims to create an unprecedented combination of ease-of-use, power, and efficiency in a single language. In addition to the above, some advantages of Julia over comparable systems include:</source>
          <target state="translated">茱莉亚的目标是在单一语言中创造一个前所未有的易用性、强大性和高效性的结合。除上述之外,Julia与同类系统相比的一些优势还包括:</target>
        </trans-unit>
        <trans-unit id="05d11d59ee07392ef31079bd1e459ad76c3f824e" translate="yes" xml:space="preserve">
          <source>Julia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, &lt;code&gt;x[1,]&lt;/code&gt; in R would return the first row of a matrix; in Julia, however, the comma is ignored, so &lt;code&gt;x[1,] == x[1]&lt;/code&gt;, and will return the first element. To extract a row, be sure to use &lt;code&gt;:&lt;/code&gt;, as in &lt;code&gt;x[1,:]&lt;/code&gt;.</source>
          <target state="translated">当该逗号不改变代码的含义时，Julia允许使用可选的结尾逗号。索引到数组时，这可能会在R用户之间引起混乱。例如，R中的 &lt;code&gt;x[1,]&lt;/code&gt; 将返回矩阵的第一行；但是在Julia中，逗号将被忽略，因此 &lt;code&gt;x[1,] == x[1]&lt;/code&gt; 并将返回第一个元素。要提取一行，请确保使用 &lt;code&gt;:&lt;/code&gt; ，如 &lt;code&gt;x[1,:]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c83ba6941f781ea6f95d544e9edf743cc32b5bdb" translate="yes" xml:space="preserve">
          <source>Julia also defines the types &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;UInt&lt;/code&gt;, which are aliases for the system's signed and unsigned native integer types respectively:</source>
          <target state="translated">Julia还定义了类型 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;UInt&lt;/code&gt; ，它们分别是系统的有符号和无符号本机整数类型的别名：</target>
        </trans-unit>
        <trans-unit id="5b4f0844a2699d5ea273cd05f5a3f5753244a2f6" translate="yes" xml:space="preserve">
          <source>Julia also provides &lt;code&gt;*&lt;/code&gt; for string concatenation:</source>
          <target state="translated">Julia还提供 &lt;code&gt;*&lt;/code&gt; 用于字符串连接：</target>
        </trans-unit>
        <trans-unit id="42a5af28aae285694adf3f30e69a77a9764131d7" translate="yes" xml:space="preserve">
          <source>Julia also provides the &lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt;&lt;code&gt;nextfloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt;&lt;code&gt;prevfloat&lt;/code&gt;&lt;/a&gt; functions which return the next largest or smallest representable floating-point number to the argument respectively:</source>
          <target state="translated">Julia还提供了&lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt; &lt;code&gt;nextfloat&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt; &lt;code&gt;prevfloat&lt;/code&gt; &lt;/a&gt;函数，分别将下一个最大或最小的可表示浮点数返回给参数：</target>
        </trans-unit>
        <trans-unit id="06ed8be5c06d7dc93b6c0404ce3653f58e45b54f" translate="yes" xml:space="preserve">
          <source>Julia also supports &lt;a href=&quot;#man-multithreading-1&quot;&gt;experimental multi-threading&lt;/a&gt;, where execution is forked and an anonymous function is run across all threads. Known as the fork-join approach, parallel threads execute independently, and must ultimately be joined in Julia's main thread to allow serial execution to continue. Multi-threading is supported using the &lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt;&lt;code&gt;Base.Threads&lt;/code&gt;&lt;/a&gt; module that is still considered experimental, as Julia is not yet fully thread-safe. In particular segfaults seem to occur during I/O operations and task switching. As an up-to-date reference, keep an eye on &lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;the issue tracker&lt;/a&gt;. Multi-Threading should only be used if you take into consideration global variables, locks and atomics, all of which are explained later.</source>
          <target state="translated">Julia还支持&lt;a href=&quot;#man-multithreading-1&quot;&gt;实验性多线程&lt;/a&gt;，其中执行被派生，并且匿名函数在所有线程上运行。被称为fork-join的方法，并行线程是独立执行的，最终必须在Julia的主线程中加入，以允许串行执行继续进行。使用仍被认为是实验性的&lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt; &lt;code&gt;Base.Threads&lt;/code&gt; &lt;/a&gt;模块支持多线程，因为Julia尚不是完全线程安全的。特别是在I / O操作和任务切换期间似乎会发生段错误。作为最新参考，请关注&lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;问题跟踪器&lt;/a&gt;。仅在考虑全局变量，锁和原子的情况下才应使用多线程，所有这些都将在后面说明。</target>
        </trans-unit>
        <trans-unit id="ab93a47c44a4029660cdea5a681e67f3452b925f" translate="yes" xml:space="preserve">
          <source>Julia and C can share array data without copying. The next example will show how this works.</source>
          <target state="translated">Julia和C可以共享数组数据,而无需复制。下一个例子将展示如何工作。</target>
        </trans-unit>
        <trans-unit id="989b4bbc6cbc89a53b5cc95fd259449cc83265cf" translate="yes" xml:space="preserve">
          <source>Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:</source>
          <target state="translated">Julia及其软件包生态系统包括一些工具,这些工具可能会帮助您诊断问题并提高代码的性能。</target>
        </trans-unit>
        <trans-unit id="bb6140d98b962ed45444f6097b48c1ab7b34b758" translate="yes" xml:space="preserve">
          <source>Julia applies the following order and associativity of operations, from highest precedence to lowest:</source>
          <target state="translated">茱莉亚应用以下操作顺序和关联性,从最高优先级到最低。</target>
        </trans-unit>
        <trans-unit id="79e54f86310ed0d0b6726cbc9118645ff3e41ba9" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia数组是列专业的（Fortran排序），而C / C ++数组是行专业的（默认）排序。为了在遍历数组时获得最佳性能，应该在Julia中相对于C / C ++颠倒循环的顺序（请参阅&amp;ldquo; &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;性能提示&amp;rdquo;的&lt;/a&gt;相关部分）。</target>
        </trans-unit>
        <trans-unit id="101c9a575d6ee596869371a0022ecfe27370c862" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">默认情况下，Julia数组是列专业的（Fortran排序），而NumPy数组是行专业的（C排序）。为了在遍历数组时获得最佳性能，应该在Julia中相对于NumPy颠倒循环顺序（请参阅&amp;ldquo; &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;性能提示&amp;rdquo;的&lt;/a&gt;相关部分）。</target>
        </trans-unit>
        <trans-unit id="4295a55355c53bb69700ac344333d3ad56193792" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, &lt;code&gt;A[i,j]&lt;/code&gt;.</source>
          <target state="translated">Julia数组用方括号 &lt;code&gt;A[i,j]&lt;/code&gt; 索引。</target>
        </trans-unit>
        <trans-unit id="6ee791aabb20af6c1bfdaa172e030af0dec26574" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, and can have more than one dimension &lt;code&gt;A[i,j]&lt;/code&gt;. This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between versions).</source>
          <target state="translated">Julia数组用方括号索引，并且可以具有多个维 &lt;code&gt;A[i,j]&lt;/code&gt; 。这种语法不仅像C / C ++中那样是指向指针或地址的引用的语法糖。有关数组构造的语法，请参见Julia文档（在版本之间已更改）。</target>
        </trans-unit>
        <trans-unit id="4b072870337da75d87b7efdc10a5b80a2cf3a54d" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well.</source>
          <target state="translated">分配给另一个变量时，不会复制Julia数组。后 &lt;code&gt;A = B&lt;/code&gt; ，的变化的元素 &lt;code&gt;B&lt;/code&gt; 将修改 &lt;code&gt;A&lt;/code&gt; 为好。</target>
        </trans-unit>
        <trans-unit id="ee983dec29328f6ef30dd7f19c04408b414cdba1" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well. Updating operators like &lt;code&gt;+=&lt;/code&gt; do not operate in-place, they are equivalent to &lt;code&gt;A = A + B&lt;/code&gt; which rebinds the left-hand side to the result of the right-hand side expression.</source>
          <target state="translated">分配给另一个变量时，不会复制Julia数组。后 &lt;code&gt;A = B&lt;/code&gt; ，的变化的元素 &lt;code&gt;B&lt;/code&gt; 将修改 &lt;code&gt;A&lt;/code&gt; 为好。像 &lt;code&gt;+=&lt;/code&gt; 这样的更新运算符不会就地进行运算，它们等效于 &lt;code&gt;A = A + B&lt;/code&gt; ，它将左手边重新绑定到右手边表达式的结果。</target>
        </trans-unit>
        <trans-unit id="f8885b17b4a7f2b903bda15b50d42d46540e083d" translate="yes" xml:space="preserve">
          <source>Julia arrays are represented in C by the datatype &lt;code&gt;jl_array_t*&lt;/code&gt;. Basically, &lt;code&gt;jl_array_t&lt;/code&gt; is a struct that contains:</source>
          <target state="translated">Julia数组在C中由数据类型 &lt;code&gt;jl_array_t*&lt;/code&gt; 。基本上， &lt;code&gt;jl_array_t&lt;/code&gt; 是一个包含以下内容的结构：</target>
        </trans-unit>
        <trans-unit id="f90d5ad1f221d4a17d6ad64fe11db8244636641f" translate="yes" xml:space="preserve">
          <source>Julia automatically inserts calls to the &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; function to convert each argument to the specified type. For example, the following call:</source>
          <target state="translated">Julia自动将调用插入&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;函数，以将每个参数转换为指定的类型。例如，以下调用：</target>
        </trans-unit>
        <trans-unit id="94aa685212fa097b84259cd91052f6a151ab1143" translate="yes" xml:space="preserve">
          <source>Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writing</source>
          <target state="translated">Julia从shell、Perl和Ruby中借鉴了命令的backtick符号。然而,在Julia中,写</target>
        </trans-unit>
        <trans-unit id="1e4dcf624482d6017b9073977072d06f0c1e1383" translate="yes" xml:space="preserve">
          <source>Julia can be configured with a number of environment variables, set either in the usual way for each operating system, or in a portable way from within Julia. Supposing that you want to set the environment variable &lt;code&gt;JULIA_EDITOR&lt;/code&gt; to &lt;code&gt;vim&lt;/code&gt;, you can type &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; (for instance, in the REPL) to make this change on a case by case basis, or add the same to the user configuration file &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; in the user's home directory to have a permanent effect. The current value of the same environment variable can be determined by evaluating &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt;.</source>
          <target state="translated">Julia可以配置许多环境变量，这些变量可以按照每种操作系统的常规方式设置，也可以从Julia内部以可移植的方式设置。假设您要将环境变量 &lt;code&gt;JULIA_EDITOR&lt;/code&gt; 设置为 &lt;code&gt;vim&lt;/code&gt; ，可以键入 &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; （例如，在REPL中），以根据具体情况进行更改，或将其添加到用户主目录中的用户配置文件 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 可以永久生效。可以通过评估 &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt; 来确定相同环境变量的当前值。</target>
        </trans-unit>
        <trans-unit id="25624934c68cd4d66c22470ba9dffff20f4e4703" translate="yes" xml:space="preserve">
          <source>Julia can be started in parallel mode with either the &lt;code&gt;-p&lt;/code&gt; or the &lt;code&gt;--machine-file&lt;/code&gt; options. &lt;code&gt;-p n&lt;/code&gt; will launch an additional &lt;code&gt;n&lt;/code&gt; worker processes, while &lt;code&gt;--machine-file file&lt;/code&gt; will launch a worker for each line in file &lt;code&gt;file&lt;/code&gt;. The machines defined in &lt;code&gt;file&lt;/code&gt; must be accessible via a password-less &lt;code&gt;ssh&lt;/code&gt; login, with Julia installed at the same location as the current host. Each machine definition takes the form &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt;. &lt;code&gt;user&lt;/code&gt; defaults to current user, &lt;code&gt;port&lt;/code&gt; to the standard ssh port. &lt;code&gt;count&lt;/code&gt; is the number of workers to spawn on the node, and defaults to 1. The optional &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; specifies the IP address and port that other workers should use to connect to this worker.</source>
          <target state="translated">可以使用 &lt;code&gt;-p&lt;/code&gt; 或 &lt;code&gt;--machine-file&lt;/code&gt; 选项以并行模式启动Julia 。 &lt;code&gt;-p n&lt;/code&gt; 将推出额外 &lt;code&gt;n&lt;/code&gt; 工作进程，而 &lt;code&gt;--machine-file file&lt;/code&gt; 将启动一个工人在文件中的每个线 &lt;code&gt;file&lt;/code&gt; 。必须通过无密码 &lt;code&gt;ssh&lt;/code&gt; 登录名访问 &lt;code&gt;file&lt;/code&gt; 定义的计算机，并将Julia安装在与当前主机相同的位置。每个计算机定义都采用 &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt; 。 &lt;code&gt;user&lt;/code&gt; 默认为当前用户， &lt;code&gt;port&lt;/code&gt; 为标准ssh端口。 &lt;code&gt;count&lt;/code&gt; 是要在节点上生成的工作线程数，默认为1。可选的 &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; 指定其他工作线程用于连接到该工作线程的IP地址和端口。</target>
        </trans-unit>
        <trans-unit id="1aef7868e131aa3765142ca6c54c8fa0eb438e27" translate="yes" xml:space="preserve">
          <source>Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</source>
          <target state="translated">Julia可以通过对字符串的索引来创建子串。在R中,在创建子串之前,必须将字符串转换为字符向量。</target>
        </trans-unit>
        <trans-unit id="5f876f801dbf3de94a121a0fbe557fe7c2dabadb" translate="yes" xml:space="preserve">
          <source>Julia can run multiple commands in parallel:</source>
          <target state="translated">Julia可以并行运行多个命令。</target>
        </trans-unit>
        <trans-unit id="d72c9df952d8a93730d24273b050dd7a87c41b99" translate="yes" xml:space="preserve">
          <source>Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt;.</source>
          <target state="translated">Julia不能在赋值操作的左侧赋值给函数调用的结果：您不能编写 &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9b5bf6c00b042abbcf8493eca58ab2e8c4ebfcf" translate="yes" xml:space="preserve">
          <source>Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops, departmental clusters, or even the cloud. This section covers network security requirements for the inbuilt &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt;:</source>
          <target state="translated">Julia群集的设计目的是在基础设施（例如本地笔记本电脑，部门群集甚至云）上已经受保护的环境中执行。本节介绍了内置 &lt;code&gt;LocalManager&lt;/code&gt; 和 &lt;code&gt;SSHManager&lt;/code&gt; 的网络安全要求：</target>
        </trans-unit>
        <trans-unit id="dbe512ceba50dc3b08408e0b7101fcd9582324dd" translate="yes" xml:space="preserve">
          <source>Julia code can throw exceptions. For example, consider:</source>
          <target state="translated">Julia代码可以抛出异常。例如,考虑一下。</target>
        </trans-unit>
        <trans-unit id="d4d45a9c6d816f57f235a4b45d059535efea33d0" translate="yes" xml:space="preserve">
          <source>Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the &lt;code&gt;julia&lt;/code&gt; executable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by simply calling &lt;code&gt;julia&lt;/code&gt; with no arguments or double-clicking on the executable:</source>
          <target state="translated">Julia带有内置在 &lt;code&gt;julia&lt;/code&gt; 可执行文件中的功能齐全的交互式命令行REPL（read-eval-print循环）。除了可以快速轻松地评估Julia语句外，它还具有可搜索的历史记录，制表符补全，许多有用的键绑定以及专用的帮助和shell模式。可以通过简单地不带任何参数调用 &lt;code&gt;julia&lt;/code&gt; 或双击可执行文件来启动REPL ：</target>
        </trans-unit>
        <trans-unit id="04f431b0e99b100c80ed3b37854b8baa69220c9e" translate="yes" xml:space="preserve">
          <source>Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at &lt;code&gt;8&lt;/code&gt; (or the number of your cores).</source>
          <target state="translated">Julia编译并使用自己的OpenBLAS副本，当前线程的上限为 &lt;code&gt;8&lt;/code&gt; （或您的内核数）。</target>
        </trans-unit>
        <trans-unit id="0463aec28ff8f6050169511f8bc7eb9f0e64fcdf" translate="yes" xml:space="preserve">
          <source>Julia constructs vectors using brackets. Julia's &lt;code&gt;[1, 2, 3]&lt;/code&gt; is the equivalent of R's &lt;code&gt;c(1, 2, 3)&lt;/code&gt;.</source>
          <target state="translated">Julia使用方括号构造向量。Julia的 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 等效于R的 &lt;code&gt;c(1, 2, 3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c3022b87e47f6ac9e21545c147897ab28a7faa7" translate="yes" xml:space="preserve">
          <source>Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in &lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;packages&lt;/a&gt; under the &lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats organization&lt;/a&gt;. For example:</source>
          <target state="translated">朱莉娅不鼓励使用函数填充主命名空间。在&lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats组织的&lt;/a&gt;&lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;软件包中&lt;/a&gt;找到了Julia的大多数统计功能。例如：</target>
        </trans-unit>
        <trans-unit id="4d3373777de6110679b5b20361db329af8df4ef4" translate="yes" xml:space="preserve">
          <source>Julia discourages the use of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output.</source>
          <target state="translated">朱莉娅不鼓励使用分号来结束语句。语句的结果不会自动打印（在交互式提示下除外），并且代码行不需要以分号结尾。&lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt;可用于打印特定的输出。</target>
        </trans-unit>
        <trans-unit id="04e059ffc127f6546f46c24be663b53bb5ca0e7a" translate="yes" xml:space="preserve">
          <source>Julia does not automatically grow arrays in an assignment statement. Whereas in MATLAB &lt;code&gt;a(4) = 3.2&lt;/code&gt; can create the array &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; and &lt;code&gt;a(5) = 7&lt;/code&gt; can grow it into &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt;, the corresponding Julia statement &lt;code&gt;a[5] = 7&lt;/code&gt; throws an error if the length of &lt;code&gt;a&lt;/code&gt; is less than 5 or if this statement is the first use of the identifier &lt;code&gt;a&lt;/code&gt;. Julia has &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;, which grow &lt;code&gt;Vector&lt;/code&gt;s much more efficiently than MATLAB's &lt;code&gt;a(end+1) = val&lt;/code&gt;.</source>
          <target state="translated">Julia不会在赋值语句中自动增长数组。而在MATLAB中 &lt;code&gt;a(4) = 3.2&lt;/code&gt; 可以创建数组 &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; 而 &lt;code&gt;a(5) = 7&lt;/code&gt; 可以将数组增长为 &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt; ，相应的Julia语句 &lt;code&gt;a[5] = 7&lt;/code&gt; 引发错误如果长度 &lt;code&gt;a&lt;/code&gt; 小于5，或者如果该语句是第一次使用该标识符的 &lt;code&gt;a&lt;/code&gt; 。朱莉娅已&lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;并&lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;，其成长 &lt;code&gt;Vector&lt;/code&gt; 小号要比MATLAB更有效地是 &lt;code&gt;a(end+1) = val&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="113852d54ae1eab98b745b5419ac194b68416265" translate="yes" xml:space="preserve">
          <source>Julia does not have an analog of MATLAB's &lt;code&gt;clear&lt;/code&gt; function; once a name is defined in a Julia session (technically, in module &lt;code&gt;Main&lt;/code&gt;), it is always present.</source>
          <target state="translated">Julia没有MATLAB的 &lt;code&gt;clear&lt;/code&gt; 函数的类似物；一旦在Julia会话中定义了名称（从技术上讲，在模块 &lt;code&gt;Main&lt;/code&gt; 中），该名称便始终存在。</target>
        </trans-unit>
        <trans-unit id="976166bb189635ca72f2fa234ae3939afd751bdc" translate="yes" xml:space="preserve">
          <source>Julia does not provide &lt;code&gt;nrow&lt;/code&gt; and &lt;code&gt;ncol&lt;/code&gt;. Instead, use &lt;code&gt;size(M, 1)&lt;/code&gt; for &lt;code&gt;nrow(M)&lt;/code&gt; and &lt;code&gt;size(M, 2)&lt;/code&gt; for &lt;code&gt;ncol(M)&lt;/code&gt;.</source>
          <target state="translated">朱莉娅不提供 &lt;code&gt;nrow&lt;/code&gt; 和 &lt;code&gt;ncol&lt;/code&gt; 。取而代之的是，使用 &lt;code&gt;size(M, 1)&lt;/code&gt; 为 &lt;code&gt;nrow(M)&lt;/code&gt; 和 &lt;code&gt;size(M, 2)&lt;/code&gt; 用于 &lt;code&gt;ncol(M)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9006bf61e6f8840d28990bf4b3458318711564d6" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">在编写 &lt;code&gt;if&lt;/code&gt; 语句或 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 循环时，Julia不需要括号： &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; 中 &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; 而不是for（在c（1、2、3）中 &lt;code&gt;if i == 1&lt;/code&gt; ）以及if = 1而不是 &lt;code&gt;if (i == 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef86462da92aecc95d832b0a401463ce19d89f34" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">在编写 &lt;code&gt;if&lt;/code&gt; 语句或 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 循环时，Julia不需要括号： &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; 中 &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; 而不是for（int i = 1; i &amp;lt;= 3; i ++）， &lt;code&gt;if i == 1&lt;/code&gt; 而不是 &lt;code&gt;if (i == 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dab151404329caee20c7d4f7fc1cfb9d014b7b4" translate="yes" xml:space="preserve">
          <source>Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output. In the REPL, &lt;code&gt;;&lt;/code&gt; can be used to suppress output. &lt;code&gt;;&lt;/code&gt; also has a different meaning within &lt;code&gt;[ ]&lt;/code&gt;, something to watch out for. &lt;code&gt;;&lt;/code&gt; can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.</source>
          <target state="translated">Julia不需要使用分号来结束语句。表达式的结果不会自动打印（交互式提示（即REPL）除外），并且代码行无需以分号结尾。&lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt;可用于打印特定的输出。在REPL， &lt;code&gt;;&lt;/code&gt; 可用于抑制输出。 &lt;code&gt;;&lt;/code&gt; 在 &lt;code&gt;[ ]&lt;/code&gt; 也有不同的含义，需要提防。 &lt;code&gt;;&lt;/code&gt; 可以用于在单行上分隔表达式，但在许多情况下并非必须严格使用，并且更有助于提高可读性。</target>
        </trans-unit>
        <trans-unit id="3aeb7f64792ed5618bd5020762501e30791645d0" translate="yes" xml:space="preserve">
          <source>Julia does not support negative indices. In particular, the last element of a list or array is indexed with &lt;code&gt;end&lt;/code&gt; in Julia, not &lt;code&gt;-1&lt;/code&gt; as in Python.</source>
          <target state="translated">Julia不支持负索引。特别是，列表或数组的最后一个元素在Julia中以 &lt;code&gt;end&lt;/code&gt; 结尾，而不是在Python中为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5ece5c5877f48513873a461f405e2da3018d04a" translate="yes" xml:space="preserve">
          <source>Julia does not support the &lt;code&gt;NULL&lt;/code&gt; type. The closest equivalent is &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;, but it behaves like a scalar value rather than like a list. Use &lt;code&gt;x === nothing&lt;/code&gt; instead of &lt;code&gt;is.null(x)&lt;/code&gt;.</source>
          <target state="translated">Julia不支持 &lt;code&gt;NULL&lt;/code&gt; 类型。最接近的等价物为&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;，但其行为类似于标量值而不是列表。使用 &lt;code&gt;x === nothing&lt;/code&gt; 代替 &lt;code&gt;is.null(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c5112c931f9c26dffeeec5c85f5a9032e0c2b42" translate="yes" xml:space="preserve">
          <source>Julia does not treat the numbers &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; as Booleans. You cannot write &lt;code&gt;if (1)&lt;/code&gt; in Julia, because &lt;code&gt;if&lt;/code&gt; statements accept only booleans. Instead, you can write &lt;code&gt;if true&lt;/code&gt;, &lt;code&gt;if Bool(1)&lt;/code&gt;, or &lt;code&gt;if 1==1&lt;/code&gt;.</source>
          <target state="translated">Julia不会将数字 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 视为布尔值。您无法在Julia中编写 &lt;code&gt;if (1)&lt;/code&gt; ，因为 &lt;code&gt;if&lt;/code&gt; 语句仅接受布尔值。相反，您可以编写 &lt;code&gt;if true&lt;/code&gt; ， &lt;code&gt;if Bool(1)&lt;/code&gt; 或 &lt;code&gt;if 1==1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5d0ea94ce19e9b69c6095b45e92d65e847fbab5" translate="yes" xml:space="preserve">
          <source>Julia doesn't require parens around conditions in &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;. Write:</source>
          <target state="translated">朱莉娅不需要在 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;while&lt;/code&gt; 中围绕条件宽恕。写：</target>
        </trans-unit>
        <trans-unit id="c7d384a3039a9f94436def1f2e231fafa1ebc407" translate="yes" xml:space="preserve">
          <source>Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since Julia 0.4.</source>
          <target state="translated">从Julia 0.4开始,Julia就通过内置的文档系统,让包的开发者和用户能够轻松地记录函数、类型和其他对象。</target>
        </trans-unit>
        <trans-unit id="a610a30b8a22b7162af81fa68a40648223fcdceb" translate="yes" xml:space="preserve">
          <source>Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia's multiple dispatch system means that &lt;code&gt;table(x::TypeA)&lt;/code&gt; and &lt;code&gt;table(x::TypeB)&lt;/code&gt; act like R's &lt;code&gt;table.TypeA(x)&lt;/code&gt; and &lt;code&gt;table.TypeB(x)&lt;/code&gt;.</source>
          <target state="translated">Julia鼓励用户编写自己的类型，这种类型比R中的S3或S4对象更易于使用 &lt;code&gt;table.TypeA(x)&lt;/code&gt; 的多调度系统意味着 &lt;code&gt;table(x::TypeA)&lt;/code&gt; 和 &lt;code&gt;table(x::TypeB)&lt;/code&gt; 行为就像R的table.TypeA（ x）和 &lt;code&gt;table.TypeB(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93dbc5f2b7cd97919b61b2ba139686426c401f37" translate="yes" xml:space="preserve">
          <source>Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function &lt;code&gt;f(x=rand()) = x&lt;/code&gt; returns a new random number every time it is invoked without argument. On the other hand, the function &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; returns &lt;code&gt;[1,2,3]&lt;/code&gt; every time it is called as &lt;code&gt;g()&lt;/code&gt;.</source>
          <target state="translated">每次调用方法时，Julia都会评估函数参数的默认值，这与Python中定义函数时仅对默认值进行一次评估的Python不同。例如，函数 &lt;code&gt;f(x=rand()) = x&lt;/code&gt; 每次无参数调用时都会返回一个新的随机数。另一方面，函数 &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; 每次被称为 &lt;code&gt;g()&lt;/code&gt; 时都返回 &lt;code&gt;[1,2,3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96712ad66b3fa51cd94fd25a53b3080e67ce2f4b" translate="yes" xml:space="preserve">
          <source>Julia features optional typing, multiple dispatch, and good performance, achieved using type inference and &lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;just-in-time (JIT) compilation&lt;/a&gt;, implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt;. It is multi-paradigm, combining features of imperative, functional, and object-oriented programming. Julia provides ease and expressiveness for high-level numerical computing, in the same way as languages such as R, MATLAB, and Python, but also supports general programming. To achieve this, Julia builds upon the lineage of mathematical programming languages, but also borrows much from popular dynamic languages, including &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby&lt;/a&gt;.</source>
          <target state="translated">Julia具有可选的类型输入，多次分派和良好的性能，这是通过使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt;实现的类型推断和&lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;即时（JIT）编译&lt;/a&gt;实现的。它是多范式，结合了命令式，功能性和面向对象编程的功能。 Julia以与R，MATLAB和Python之类的语言相同的方式为高级数值计算提供了简便和表达性，但还支持常规编程。为了实现这一点，Julia建立在数学编程语言的基础上，但也从流行的动态语言（包括&lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby）中&lt;/a&gt;借鉴了很多东西。</target>
        </trans-unit>
        <trans-unit id="bc5383570d2537e5c864f51ec5fa00e7be9531d0" translate="yes" xml:space="preserve">
          <source>Julia fully supports Unicode characters and strings. As &lt;a href=&quot;#man-characters-1&quot;&gt;discussed above&lt;/a&gt;, in character literals, Unicode code points can be represented using Unicode &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\U&lt;/code&gt; escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</source>
          <target state="translated">Julia完全支持Unicode字符和字符串。正如&lt;a href=&quot;#man-characters-1&quot;&gt;上面所讨论的&lt;/a&gt;，在字符文字，Unicode代码点可以使用Unicode表示 &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\U&lt;/code&gt; 转义序列，以及所有的标准C转义序列。这些同样可以用来编写字符串文字：</target>
        </trans-unit>
        <trans-unit id="ddd78f6e5bc711118d9be3c491d9cc07a50a79b9" translate="yes" xml:space="preserve">
          <source>Julia function arguments follow a convention sometimes called &quot;pass-by-sharing&quot;, which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable &lt;em&gt;bindings&lt;/em&gt; (new locations that can refer to values), but the values they refer to are identical to the passed values. Modifications to mutable values (such as &lt;code&gt;Array&lt;/code&gt;s) made within a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.</source>
          <target state="translated">Julia函数参数遵循有时称为&amp;ldquo;传递共享&amp;rdquo;的约定，这意味着将值传递给函数时不会将其复制。函数参数本身充当新的变量&lt;em&gt;绑定&lt;/em&gt;（可以引用值的新位置），但是它们引用的值与传递的值相同。在函数内对可变值（例如 &lt;code&gt;Array&lt;/code&gt; ）进行的修改对调用者是可见的。这与Scheme，大多数Lisps，Python，Ruby和Perl等动态语言中的行为相同。</target>
        </trans-unit>
        <trans-unit id="f080283d31381a5962b780da17f950587890e071" translate="yes" xml:space="preserve">
          <source>Julia has Perl-compatible regular expressions (regexes), as provided by the &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; library (a description of the syntax can be found &lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;here&lt;/a&gt;). Regular expressions are related to strings in two ways: the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with &lt;code&gt;r&lt;/code&gt;. The most basic regular expression literal without any options turned on just uses &lt;code&gt;r&quot;...&quot;&lt;/code&gt;:</source>
          <target state="translated">Julia具有&lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt;库提供的与Perl兼容的正则表达式（regexes）（有关语法的说明，请参见&lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;此处&lt;/a&gt;）。正则表达式通过两种方式与字符串相关：明显的联系是，正则表达式用于查找字符串中的正则模式。另一个联系是，正则表达式本身是作为字符串输入的，它们被解析为状态机，可用于有效地搜索字符串中的模式。在Julia中，使用以 &lt;code&gt;r&lt;/code&gt; 开头的各种标识符作为前缀的非标准字符串文字输入正则表达式。没有打开任何选项的最基本的正则表达式文字只使用 &lt;code&gt;r&quot;...&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1bf49a0edfd1fa830fafecd8986f8d037e52871d" translate="yes" xml:space="preserve">
          <source>Julia has a built-in data structure called a &lt;em&gt;tuple&lt;/em&gt; that is closely related to function arguments and return values. A tuple is a fixed-length container that can hold any values, but cannot be modified (it is &lt;em&gt;immutable&lt;/em&gt;). Tuples are constructed with commas and parentheses, and can be accessed via indexing:</source>
          <target state="translated">Julia具有一个称为&lt;em&gt;元组&lt;/em&gt;的内置数据结构，该结构与函数参数和返回值密切相关。元组是一个固定长度的容器，可以容纳任何值，但不能修改（它是&lt;em&gt;不可变的&lt;/em&gt;）。元组由逗号和括号构成，可以通过索引进行访问：</target>
        </trans-unit>
        <trans-unit id="c552e8e0854f7810a14a1b85cee7a089274fe437" translate="yes" xml:space="preserve">
          <source>Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">Julia有一个有理数类型来表示整数的精确比例。使用&lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt;运算符构造有理数：</target>
        </trans-unit>
        <trans-unit id="b40bd35bfba54a15cc9852aeface053edb4835d0" translate="yes" xml:space="preserve">
          <source>Julia has a special &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax&lt;/a&gt; that converts any scalar function into a &quot;vectorized&quot; function call, and any operator into a &quot;vectorized&quot; operator, with the special property that nested &quot;dot calls&quot; are &lt;em&gt;fusing&lt;/em&gt;: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use &lt;code&gt;.=&lt;/code&gt; and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</source>
          <target state="translated">朱莉娅有一个特殊的&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;点语法&lt;/a&gt;是将任何标量函数变成了&amp;ldquo;矢量化&amp;rdquo;功能调用，任何运营商成&amp;ldquo;矢量&amp;rdquo;运营商，拥有特殊的属性，嵌套&amp;ldquo;点电话&amp;rdquo;是&lt;em&gt;融合&lt;/em&gt;：它们在语法层面为结合一个循环，而无需分配临时数组。如果使用 &lt;code&gt;.=&lt;/code&gt; 和类似的赋值运算符，则结果也可以就地存储在预分配的数组中（请参见上文）。</target>
        </trans-unit>
        <trans-unit id="d6c4ab07a2249226dfaeff8c414c6f4ecccc5db7" translate="yes" xml:space="preserve">
          <source>Julia has a specialized version of &lt;code&gt;ntuple&lt;/code&gt; that accepts a &lt;code&gt;Val{::Int}&lt;/code&gt; instance as the second parameter; by passing &lt;code&gt;N&lt;/code&gt; as a type-parameter, you make its &quot;value&quot; known to the compiler. Consequently, this version of &lt;code&gt;array3&lt;/code&gt; allows the compiler to predict the return type.</source>
          <target state="translated">Julia有一个专门的 &lt;code&gt;ntuple&lt;/code&gt; 版本，它接受 &lt;code&gt;Val{::Int}&lt;/code&gt; 实例作为第二个参数。通过将 &lt;code&gt;N&lt;/code&gt; 作为类型参数传递，可以使编译器知道其&amp;ldquo;值&amp;rdquo;。因此，此版本的 &lt;code&gt;array3&lt;/code&gt; 允许编译器预测返回类型。</target>
        </trans-unit>
        <trans-unit id="dd0467e099e9e6d5ba4caf88a327947c41a492c3" translate="yes" xml:space="preserve">
          <source>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;Integers and Floating-Point Numbers&lt;/a&gt;, &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;, &lt;a href=&quot;../types/index#man-types-1&quot;&gt;Types&lt;/a&gt;, and &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</source>
          <target state="translated">Julia有一个用于将数学运算符的参数提升为通用类型的系统，在其他各个部分中都提到了该系统，包括&lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;整数和浮点数&lt;/a&gt;，&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;数学运算和基本函数&lt;/a&gt;，&lt;a href=&quot;../types/index#man-types-1&quot;&gt;类型&lt;/a&gt;和&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;方法&lt;/a&gt;。在本节中，我们将说明此升级系统如何工作，以及如何将其扩展为新类型并将其应用于除内置数学运算符之外的函数。传统上，就促进算术参数而言，编程语言分为两个阵营：</target>
        </trans-unit>
        <trans-unit id="3580c0f9206e567ece3500a7602b2f938ef0cdc5" translate="yes" xml:space="preserve">
          <source>Julia has an enumeration type, expressed using the macro &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; For example: &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</source>
          <target state="translated">Julia具有枚举类型，使用宏 &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; ，例如： &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e22281e2e9ddb304102a3e2035cc1b7d70261e86" translate="yes" xml:space="preserve">
          <source>Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable algorithms and sorts in standard ascending order:</source>
          <target state="translated">Julia有一个广泛而灵活的API,用于排序和与已经排序的值数组进行交互。默认情况下,Julia会选择合理的算法,并按照标准的升序进行排序。</target>
        </trans-unit>
        <trans-unit id="bf9ed794914c3a1a76c39f0be8423b02c7aa0fa9" translate="yes" xml:space="preserve">
          <source>Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</source>
          <target state="translated">Julia没有延续行的语法:如果在一行结束时,到目前为止输入的是一个完整的表达式,则认为已经完成;否则输入将继续。强制表达式继续的一种方法是用括号将其包裹起来。</target>
        </trans-unit>
        <trans-unit id="6e3f85fe865aed948db80d8506da1145de6fdbbe" translate="yes" xml:space="preserve">
          <source>Julia has several functions that can mutate their arguments. For example, it has both &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia有几个可以改变其论点的函数。例如，它既有&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;又有&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dced25e0f1eb19647f27c26102392f9de718e8bc" translate="yes" xml:space="preserve">
          <source>Julia has support for sparse vectors and &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;sparse matrices&lt;/a&gt; in the &lt;code&gt;SparseArrays&lt;/code&gt; stdlib module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.</source>
          <target state="translated">Julia 在 &lt;code&gt;SparseArrays&lt;/code&gt; stdlib模块中支持稀疏向量和&lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;稀疏矩阵&lt;/a&gt;。稀疏数组是包含足够零的数组，与密集数组相比，零存储在特殊的数据结构中可节省空间和执行时间。</target>
        </trans-unit>
        <trans-unit id="7e110deec010cf13200f416e320f962b03651cd3" translate="yes" xml:space="preserve">
          <source>Julia has true one-dimensional arrays. Column vectors are of size &lt;code&gt;N&lt;/code&gt;, not &lt;code&gt;Nx1&lt;/code&gt;. For example, &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand(N)&lt;/code&gt;&lt;/a&gt; makes a 1-dimensional array.</source>
          <target state="translated">朱莉娅拥有真正的一维数组。列向量的大小为 &lt;code&gt;N&lt;/code&gt; ，而不是 &lt;code&gt;Nx1&lt;/code&gt; 。例如，&lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand(N)&lt;/code&gt; &lt;/a&gt;生成一维数组。</target>
        </trans-unit>
        <trans-unit id="0821ee6b098b6e9c3f3f70ea62ba30df9ae8eca8" translate="yes" xml:space="preserve">
          <source>Julia has two mechanisms for loading code:</source>
          <target state="translated">Julia有两种加载代码的机制。</target>
        </trans-unit>
        <trans-unit id="c7c1de145d34e5e8002d957a023c35b25d8ff0be" translate="yes" xml:space="preserve">
          <source>Julia has two right-shift operators, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; performs an arithmetic shift, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; always performs a logical shift, unlike C/C++, where the meaning of &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; depends on the type of the value being shifted.</source>
          <target state="translated">Julia有两个右移运算符 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 执行算术移位， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 始终执行逻辑移位，与C / C ++不同， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 的含义取决于要移位的值的类型。</target>
        </trans-unit>
        <trans-unit id="a82ef00db4da7adcbac13bd1f8a38ec016519663" translate="yes" xml:space="preserve">
          <source>Julia identifiers and code excerpts should always appear between backticks &lt;code&gt;`&lt;/code&gt; to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks &lt;code&gt;``&lt;/code&gt;. Use Unicode characters rather than their LaTeX escape sequence, i.e. &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; rather than &lt;code&gt;``\\alpha = 1``&lt;/code&gt;.</source>
          <target state="translated">Julia标识符和代码摘录应始终出现在反引号 &lt;code&gt;`&lt;/code&gt; 之间，以使突出显示。可以将LaTeX语法中的方程式插入到两个反引号之间 &lt;code&gt;``&lt;/code&gt; 。使用Unicode字符而不是其LaTeX转义序列，即 &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; &lt;code&gt;``\\alpha = 1``&lt;/code&gt; 而不是``\\ alpha = 1''。</target>
        </trans-unit>
        <trans-unit id="556d3efaca190f2ea064a6e9ec15d293042ee9a4" translate="yes" xml:space="preserve">
          <source>Julia includes predefined types for both complex and rational numbers, and supports all the standard &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt; on them. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</source>
          <target state="translated">Julia包括针对复数和有理数的预定义类型，并支持所有标准的&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;数学运算和基本函数&lt;/a&gt;。定义了&amp;ldquo; &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;转换&amp;rdquo;和&amp;ldquo;提升&amp;rdquo;&lt;/a&gt;，以便对预定义数字类型（原始的或复合的）的任何组合进行的操作均符合预期。</target>
        </trans-unit>
        <trans-unit id="7ddd4e3aafc825251162512ccf2a33928bb02903" translate="yes" xml:space="preserve">
          <source>Julia installation is straightforward, whether using precompiled binaries or compiling from source. Download and install Julia by following the instructions at &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;.</source>
          <target state="translated">无论使用预编译的二进制文件还是从源代码进行编译，Julia的安装都非常简单。按照&lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/上&lt;/a&gt;的说明下载并安装Julia 。</target>
        </trans-unit>
        <trans-unit id="ebd85d8192dfa3106e5516cbab7ad06e8387fb26" translate="yes" xml:space="preserve">
          <source>Julia is careful to distinguish scalars, vectors and matrices. In R, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;c(1)&lt;/code&gt; are the same. In Julia, they cannot be used interchangeably.</source>
          <target state="translated">Julia小心区分标量，向量和矩阵。在R中， &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;c(1)&lt;/code&gt; 相同。在Julia中，它们不能互换使用。</target>
        </trans-unit>
        <trans-unit id="b86e5dd8d3107ffdd2a0b40698efdff29052007c" translate="yes" xml:space="preserve">
          <source>Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</source>
          <target state="translated">Julia是急于评估的,不支持R式的懒惰评估。对于大多数用户来说,这意味着很少有未引用的表达式或列名。</target>
        </trans-unit>
        <trans-unit id="3107ebb99f64b1456a558b1a35edcbfee43840dd" translate="yes" xml:space="preserve">
          <source>Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with &lt;code&gt;make test&lt;/code&gt;. In a binary install, you can run the test suite using &lt;code&gt;Base.runtests()&lt;/code&gt;.</source>
          <target state="translated">Julia正在快速开发中，并且具有广泛的测试套件来验证跨多个平台的功能。如果从源代码构建Julia，则可以使用 &lt;code&gt;make test&lt;/code&gt; 运行此测试套件。在二进制安装中，可以使用 &lt;code&gt;Base.runtests()&lt;/code&gt; 运行测试套件。</target>
        </trans-unit>
        <trans-unit id="9746bea5d9fab2c69edf57da506dab8c4cb797c1" translate="yes" xml:space="preserve">
          <source>Julia lacks the equivalent of R's &lt;code&gt;assign&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt;.</source>
          <target state="translated">朱莉娅（Julia）缺少R的 &lt;code&gt;assign&lt;/code&gt; 或 &lt;code&gt;get&lt;/code&gt; 的等效项。</target>
        </trans-unit>
        <trans-unit id="b0362643e3d8faddbbdc08525668acd4db05eb64" translate="yes" xml:space="preserve">
          <source>Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the &lt;code&gt;@&lt;/code&gt; character, and have both a function-like syntax, &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt;, and a statement-like syntax, &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt;. The forms are interchangeable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the distributed &lt;code&gt;for&lt;/code&gt; construct: &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt;. Where the end of the macro construct may be unclear, use the function-like form.</source>
          <target state="translated">Julia宏对解析的表达式进行操作，而不是对程序文本进行操作，这使它们可以执行Julia代码的复杂转换。宏名称以 &lt;code&gt;@&lt;/code&gt; 字符开头，并且具有类似于函数的语法 &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt; 和具有类似于语句的语法 &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt; 。形式可以互换；如果宏出现在另一个表达式中并且通常是最清晰的，则类似于函数的形式就特别有用。类似于语句的形式通常用于注释块，例如在分布式 &lt;code&gt;for&lt;/code&gt; 构造中： &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt; 。如果宏构造的结尾可能不清楚，请使用类似于函数的形式。</target>
        </trans-unit>
        <trans-unit id="7722324abb1e33c9620fc5bb1dbd294982f5257b" translate="yes" xml:space="preserve">
          <source>Julia performs matrix transposition using the &lt;code&gt;transpose&lt;/code&gt; function and conjugated transposition using the &lt;code&gt;'&lt;/code&gt; operator or the &lt;code&gt;adjoint&lt;/code&gt; function. Julia's &lt;code&gt;transpose(A)&lt;/code&gt; is therefore equivalent to R's &lt;code&gt;t(A)&lt;/code&gt;. Additionally a non-recursive transpose in Julia is provided by the &lt;code&gt;permutedims&lt;/code&gt; function.</source>
          <target state="translated">Julia使用 &lt;code&gt;transpose&lt;/code&gt; 函数执行矩阵转置，并使用 &lt;code&gt;'&lt;/code&gt; 运算符或 &lt;code&gt;adjoint&lt;/code&gt; 函数执行共轭转置。因此，朱莉娅的 &lt;code&gt;transpose(A)&lt;/code&gt; 等于R的 &lt;code&gt;t(A)&lt;/code&gt; 。另外， &lt;code&gt;permutedims&lt;/code&gt; 函数提供了Julia中的非递归转置。</target>
        </trans-unit>
        <trans-unit id="52ca89425115cf081b45ea4b026826f1b8b7932f" translate="yes" xml:space="preserve">
          <source>Julia provides &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt;, which gives the distance between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable floating-point value:</source>
          <target state="translated">Julia提供了&lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;，它给出了 &lt;code&gt;1.0&lt;/code&gt; 与下一个更大的可表示浮点值之间的距离：</target>
        </trans-unit>
        <trans-unit id="b5151abe259ad1efc62c73fed3cdaac381488d9a" translate="yes" xml:space="preserve">
          <source>Julia provides a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; mechanism for solving this problem. A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is a waitable first-in first-out queue which can have multiple tasks reading from and writing to it.</source>
          <target state="translated">Julia提供了一种解决此问题的&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;机制。一个&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;是一个可等待的先入先出队列，可以有多个任务读取和写入数据。</target>
        </trans-unit>
        <trans-unit id="8d6a50d7fd1b9d32a07f2f0f7b72bc0c75328556" translate="yes" xml:space="preserve">
          <source>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</source>
          <target state="translated">Julia提供了广泛的原始数值类型，并在其上定义了算术和按位运算符以及标准数学函数的完整补充。这些直接映射到现代计算机上本机支持的数字类型和运算上，从而使Julia可以充分利用计算资源。此外，Julia为&lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;提供了软件支持，该算法可以处理无法在本机硬件表示中有效表示的数值上的运算，但是会以相对较慢的性能为代价。</target>
        </trans-unit>
        <trans-unit id="5e01948cafe564bc35cc3886e5615297521aba0b" translate="yes" xml:space="preserve">
          <source>Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as providing portable, efficient implementations of a comprehensive collection of standard mathematical functions.</source>
          <target state="translated">Julia提供了一个完整的基本算术和位智运算符集合,涵盖了所有的数值基元类型,并提供了全面的标准数学函数集合的可移植、高效的实现。</target>
        </trans-unit>
        <trans-unit id="123ae94e81e1f4b6a65e379d812783d382dbfd58" translate="yes" xml:space="preserve">
          <source>Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.</source>
          <target state="translated">Julia提供了一个全面的数学函数和运算符的集合。这些数学运算在允许合理定义的范围内定义了广泛的数值类别,包括整数、浮点数、有理数和复数,只要这些定义是合理的。</target>
        </trans-unit>
        <trans-unit id="07cfc6f69cd91f9494ead12f841604f628160c20" translate="yes" xml:space="preserve">
          <source>Julia provides a reserved word &lt;code&gt;do&lt;/code&gt; for rewriting this code more clearly:</source>
          <target state="translated">Julia提供了保留字 &lt;code&gt;do&lt;/code&gt; 来更清楚地重写此代码：</target>
        </trans-unit>
        <trans-unit id="eea9a879394b78dc7fcabf301d30239602afa073" translate="yes" xml:space="preserve">
          <source>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;coroutine&lt;/a&gt;) functionality.</source>
          <target state="translated">Julia提供了一个丰富的接口来处理流I / O对象，例如终端，管道和TCP套接字。该接口尽管在系统级别是异步的，但以同步的方式呈现给程序员，通常不必考虑底层的异步操作。这是通过大量使用Julia合作线程（&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;协程&lt;/a&gt;）功能来实现的。</target>
        </trans-unit>
        <trans-unit id="abe3cae0b0fe31f45bb29933297244a39702e5dd" translate="yes" xml:space="preserve">
          <source>Julia provides a variety of control flow constructs:</source>
          <target state="translated">Julia提供了多种控制流构造。</target>
        </trans-unit>
        <trans-unit id="379525ee528141070933df39d7ce42ca05dd4bf0" translate="yes" xml:space="preserve">
          <source>Julia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:</source>
          <target state="translated">Julia提供了额外的函数来测试数字的特殊值,这在哈希键比较等情况下很有用。</target>
        </trans-unit>
        <trans-unit id="e0540cb6db7126d29223e3d70501bf3d70244816" translate="yes" xml:space="preserve">
          <source>Julia provides an extremely flexible system for naming variables. Variable names are case-sensitive, and have no semantic meaning (that is, the language will not treat variables differently based on their names).</source>
          <target state="translated">Julia为变量的命名提供了一个极其灵活的系统。变量名是区分大小写的,而且没有语义意义(也就是说,语言不会因为变量名而对其进行不同的处理)。</target>
        </trans-unit>
        <trans-unit id="eab744df916b515fec425ab1cfaf69348d24b932" translate="yes" xml:space="preserve">
          <source>Julia provides built-in, efficient functions to test for oddness and evenness called &lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt;&lt;code&gt;iseven&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt;&lt;code&gt;isodd&lt;/code&gt;&lt;/a&gt; so the above definitions should only be considered to be examples of scope, not efficient design.</source>
          <target state="translated">Julia提供了内置的高效函数来测试&lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt; &lt;code&gt;iseven&lt;/code&gt; &lt;/a&gt;性，即iseven和&lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt; &lt;code&gt;isodd&lt;/code&gt; ,&lt;/a&gt;因此上述定义仅应视为范围的示例，而不是有效的设计。</target>
        </trans-unit>
        <trans-unit id="378329d878ac43129f252ba96bb3ab40b65f2250" translate="yes" xml:space="preserve">
          <source>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.</source>
          <target state="translated">Julia提供了一些函数,这些函数返回对应于指定类型或给定变量类型的文字0和1。</target>
        </trans-unit>
        <trans-unit id="affb7609b4adcfecba8a7c2be6b8ababed17f3bf" translate="yes" xml:space="preserve">
          <source>Julia provides support for representing missing values in the statistical sense, that is for situations where no value is available for a variable in an observation, but a valid value theoretically exists. Missing values are represented via the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object, which is the singleton instance of the type &lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;missing&lt;/code&gt; is equivalent to &lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;&lt;code&gt;NULL&lt;/code&gt; in SQL&lt;/a&gt; and &lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;&lt;code&gt;NA&lt;/code&gt; in R&lt;/a&gt;, and behaves like them in most situations.</source>
          <target state="translated">Julia提供了从统计学意义上表示缺失值的支持，也就是说，对于观察值中的变量没有可用值但理论上存在有效值的情况。缺失值通过&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;对象表示，该对象是类型&lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; &lt;/a&gt;的单例实例。&lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;在SQL中&lt;/a&gt;， &lt;code&gt;missing&lt;/code&gt; 等效于 &lt;code&gt;NULL&lt;/code&gt; ；&lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;在R中&lt;/a&gt;，失踪等效于 &lt;code&gt;NA&lt;/code&gt; ；并且在大多数情况下，行为类似于它们。</target>
        </trans-unit>
        <trans-unit id="105b1a0ce6d2b2d8bfa2faba37832a7982f4eb0d" translate="yes" xml:space="preserve">
          <source>Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt;, use &lt;code&gt;(1, 2)&lt;/code&gt; or &lt;code&gt;(a=1, b=2)&lt;/code&gt;.</source>
          <target state="translated">Julia提供了元组和真实的哈希表，但没有提供R样式列表。返回多个项目时，通常应使用一个元组或一个命名的元组：代替 &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt; ，使用 &lt;code&gt;(1, 2)&lt;/code&gt; 或 &lt;code&gt;(a=1, b=2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12d6b550dc7735e370a3f8c010496abe63394b14" translate="yes" xml:space="preserve">
          <source>Julia provides two in-built cluster managers:</source>
          <target state="translated">Julia提供了两个内置的集群管理器。</target>
        </trans-unit>
        <trans-unit id="c65c2e80d135867ac3b507bcd217f7ad2507c745" translate="yes" xml:space="preserve">
          <source>Julia requires &lt;code&gt;end&lt;/code&gt; to end a block. Unlike Python, Julia has no &lt;code&gt;pass&lt;/code&gt; keyword.</source>
          <target state="translated">茱莉亚（Julia）需要 &lt;code&gt;end&lt;/code&gt; 相接。与Python不同，Julia没有 &lt;code&gt;pass&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="42da913aac127180e179863fc35f1ca348a1d911" translate="yes" xml:space="preserve">
          <source>Julia should load our new code. Let's test it:</source>
          <target state="translated">Julia应该会加载我们的新代码。我们来测试一下</target>
        </trans-unit>
        <trans-unit id="b7c7299bbee239f4f34ffd5f256e5fa27242ff3f" translate="yes" xml:space="preserve">
          <source>Julia supports accessing and modifying values &lt;em&gt;atomically&lt;/em&gt;, that is, in a thread-safe way to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;race conditions&lt;/a&gt;. A value (which must be of a primitive type) can be wrapped as &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt;&lt;code&gt;Threads.Atomic&lt;/code&gt;&lt;/a&gt; to indicate it must be accessed in this way. Here we can see an example:</source>
          <target state="translated">Julia支持&lt;em&gt;原子&lt;/em&gt;访问和修改值，即以线程安全的方式避免&lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;竞争条件&lt;/a&gt;。值（必须是原始类型）可以包装为&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt; &lt;code&gt;Threads.Atomic&lt;/code&gt; &lt;/a&gt;表示必须以这种方式访问​​。在这里我们可以看到一个例子：</target>
        </trans-unit>
        <trans-unit id="b32a099891e5d6d1de5f4e3ebb7913c9c9d83a6a" translate="yes" xml:space="preserve">
          <source>Julia supports federated package management, which means that multiple independent parties can maintain both public and private packages and registries of packages, and that projects can depend on a mix of public and private packages from different registries. Packages from various registries are installed and managed using a common set of tools and workflows. The &lt;code&gt;Pkg&lt;/code&gt; package manager that ships with Julia lets you install and manage your projects' dependencies. It assists in creating and manipulating project files (which describe what other projects that your project depends on), and manifest files (which snapshot exact versions of your project's complete dependency graph).</source>
          <target state="translated">Julia支持联合程序包管理，这意味着多个独立方可以维护公共程序包和私有程序包以及程序包注册表，并且项目可以依赖于来自不同注册表的公共程序包和私有程序包的混合。使用一组通用的工具和工作流来安装和管理来自各个注册表的软件包。Julia附带的 &lt;code&gt;Pkg&lt;/code&gt; 软件包管理器使您可以安装和管理项目的依赖项。它有助于创建和处理项目文件（描述项目所依赖的其他项目）和清单文件（对项目的完整依赖图的确切版本进行快照）。</target>
        </trans-unit>
        <trans-unit id="3e86dc9fbf230d572664966d4794a26de9273668" translate="yes" xml:space="preserve">
          <source>Julia supports parallel loops using the &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt;&lt;code&gt;Threads.@threads&lt;/code&gt;&lt;/a&gt; macro. This macro is affixed in front of a &lt;code&gt;for&lt;/code&gt; loop to indicate to Julia that the loop is a multi-threaded region:</source>
          <target state="translated">Julia使用&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt; &lt;code&gt;Threads.@threads&lt;/code&gt; &lt;/a&gt;宏支持并行循环。此宏附加在 &lt;code&gt;for&lt;/code&gt; 循环的前面，以向Julia指示该循环是一个多线程区域：</target>
        </trans-unit>
        <trans-unit id="a5283fbcd3917bac5a655bc39180ded4c3af822e" translate="yes" xml:space="preserve">
          <source>Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.</source>
          <target state="translated">Julia支持三种形式的数值转换,它们对不精确转换的处理方式不同。</target>
        </trans-unit>
        <trans-unit id="ab0cbf25806d0b9c5fc2aa6aef5c6cef44171513" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;lexical scoping&lt;/a&gt;, meaning that a function's scope does not inherit from its caller's scope, but from the scope in which the function was defined. For example, in the following code the &lt;code&gt;x&lt;/code&gt; inside &lt;code&gt;foo&lt;/code&gt; refers to the &lt;code&gt;x&lt;/code&gt; in the global scope of its module &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">Julia使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;词法作用域&lt;/a&gt;，即函数的作用域不是从调用者的作用域继承，而是从定义函数的作用域继承。例如，在以下代码中， &lt;code&gt;foo&lt;/code&gt; 内部的 &lt;code&gt;x&lt;/code&gt; 引用其模块 &lt;code&gt;Bar&lt;/code&gt; 的全局范围内的 &lt;code&gt;x&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c3c73ac079b0c4f92a7cd6345869462d4c4c72df" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;, because of the operator precedence.</source>
          <target state="translated">Julia使用 &lt;code&gt;end&lt;/code&gt; 表示条件块的结尾，例如 &lt;code&gt;if&lt;/code&gt; ，循环块，如 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 和函数。代替单行 &lt;code&gt;if ( cond ) statement&lt;/code&gt; ，Julia允许使用 &lt;code&gt;if cond; statement; end&lt;/code&gt; 形式的语句；声明; end， &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; 和 &lt;code&gt;!cond || statement&lt;/code&gt; 。由于运算符优先级，后两种语法中的赋值语句必须显式包装在括号中，例如 &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cabc05bc6f900c3729476582490d063a944c3f3" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;.</source>
          <target state="translated">Julia使用 &lt;code&gt;end&lt;/code&gt; 表示条件块的结尾，例如 &lt;code&gt;if&lt;/code&gt; ，循环块，如 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 和函数。代替单行 &lt;code&gt;if ( cond ) statement&lt;/code&gt; ，Julia允许使用 &lt;code&gt;if cond; statement; end&lt;/code&gt; 形式的语句；声明; end， &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; 和 &lt;code&gt;!cond || statement&lt;/code&gt; 。后两种语法中的赋值语句必须显式包装在括号中，例如 &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1da921baa95047321b954687696b91e15a78b61" translate="yes" xml:space="preserve">
          <source>Julia uses machine arithmetic for integer computations. This means that the range of &lt;code&gt;Int&lt;/code&gt; values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</source>
          <target state="translated">Julia uses machine arithmetic for integer computations. This means that the range of &lt;code&gt;Int&lt;/code&gt; values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</target>
        </trans-unit>
        <trans-unit id="51011bd7d0e6585180df272ca646802fbeb44e3f" translate="yes" xml:space="preserve">
          <source>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; package implements &lt;code&gt;UTF16String&lt;/code&gt; and &lt;code&gt;UTF32String&lt;/code&gt; types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on &lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;byte array literals&lt;/a&gt;. The &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</source>
          <target state="translated">Julia默认使用UTF-8编码，并且可以通过软件包添加对新编码的支持。例如，&lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt;包实现了 &lt;code&gt;UTF16String&lt;/code&gt; 和 &lt;code&gt;UTF32String&lt;/code&gt; 类型。目前，关于其他编码以及如何实现对它们的支持的其他讨论不在本文的讨论范围之内。有关UTF-8编码问题的进一步讨论，请参见下面有关&lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;字节数组文字&lt;/a&gt;的部分。所述&lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt;被设置功能到各个UTF-XX编码之间转换数据，主要用于与外部数据和库的工作。</target>
        </trans-unit>
        <trans-unit id="5e0e9c6a66c5fa559fda71e594a3ae5240a6637e" translate="yes" xml:space="preserve">
          <source>Julia uses the first of these that exists to try to load the public &lt;code&gt;Priv&lt;/code&gt; package from the file &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; in the depot where it was found.</source>
          <target state="translated">Julia使用存在的第一个 &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; 尝试从发现它的软件仓库中的文件packages / Priv / HDKrT / src / Priv.jl中加载公共 &lt;code&gt;Priv&lt;/code&gt; 软件包。</target>
        </trans-unit>
        <trans-unit id="30edeef56ee9d985332259b8e62139e00973bd46" translate="yes" xml:space="preserve">
          <source>Julia uses your system's locale and language settings to determine which characters can be printed as-is and which must be output using the generic, escaped &lt;code&gt;\u&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; input forms. In addition to these Unicode escape forms, all of &lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;C's traditional escaped input forms&lt;/a&gt; can also be used:</source>
          <target state="translated">Julia使用系统的语言环境和语言设置来确定哪些字符可以原样打印，哪些字符必须使用转义的 &lt;code&gt;\u&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; 输入形式输出。除了这些Unicode转义形式之外，还可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;C的&lt;/a&gt;所有传统转义输入形式：</target>
        </trans-unit>
        <trans-unit id="bd0dc71ebce3799f196e4c40689f527bedaa69fb" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">当分配或传递给一个函数时,Julia的值不会被复制。如果一个函数修改了一个数组,其变化将在调用者中可见。</target>
        </trans-unit>
        <trans-unit id="7ac4008d58382151203baf7753fcd45089959029" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">当传递给函数时,Julia的值不会被复制。如果一个函数修改了一个数组,那么在调用者中就会看到其变化。</target>
        </trans-unit>
        <trans-unit id="8837407288696b8f56b310a5e7e527268f191a69" translate="yes" xml:space="preserve">
          <source>Julia will even let you redefine built-in constants and functions if needed (although this is not recommended to avoid potential confusions):</source>
          <target state="translated">如果需要的话,Julia甚至会让你重新定义内置的常量和函数(尽管不建议这样做以避免潜在的混乱)。</target>
        </trans-unit>
        <trans-unit id="bbfd1a84071c3afc3da5111c8fd03dbd6cb9cfcf" translate="yes" xml:space="preserve">
          <source>Julia workers must NOT be started with &lt;code&gt;--worker&lt;/code&gt;. Starting with &lt;code&gt;--worker&lt;/code&gt; will result in the newly launched workers defaulting to the TCP/IP socket transport implementation.</source>
          <target state="translated">朱莉娅工人不得以 &lt;code&gt;--worker&lt;/code&gt; 开头。以 &lt;code&gt;--worker&lt;/code&gt; 开头将导致新启动的worker默认使用TCP / IP套接字传输实现。</target>
        </trans-unit>
        <trans-unit id="d2e71f463c75ed1f922e909db643a6a01be0bb01" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; takes the function first, then its arguments, unlike &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; in R. Similarly Julia's equivalent of &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; in R is &lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt;&lt;code&gt;mapslices&lt;/code&gt;&lt;/a&gt; where the function is the first argument.</source>
          <target state="translated">与 &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; 不同，Julia的&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;首先获取函数，然后获取参数。同样，R中的Julia（相当于Julia ） &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; 是&lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt; &lt;code&gt;mapslices&lt;/code&gt; &lt;/a&gt;，其中函数是第一个论点。</target>
        </trans-unit>
        <trans-unit id="f5bb002ee0de69716a37fbfcd112bddd1aed44f5" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; are different from their counterparts in R. They all accept an optional keyword argument &lt;code&gt;dims&lt;/code&gt;, which indicates the dimensions, over which the operation is carried out. For instance, let &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; in Julia and &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; be the same matrix in R. Then &lt;code&gt;sum(A)&lt;/code&gt; gives the same result as &lt;code&gt;sum(B)&lt;/code&gt;, but &lt;code&gt;sum(A, dims=1)&lt;/code&gt; is a row vector containing the sum over each column and &lt;code&gt;sum(A, dims=2)&lt;/code&gt; is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate &lt;code&gt;colSums(B)&lt;/code&gt; and &lt;code&gt;rowSums(B)&lt;/code&gt; functions provide these functionalities. If the &lt;code&gt;dims&lt;/code&gt; keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt;. It should be noted that there is no error checking regarding the second argument.</source>
          <target state="translated">Julia的&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt;不同于R中的对等字符。它们都接受可选的关键字参数 &lt;code&gt;dims&lt;/code&gt; ，该参数指示执行操作的维度。例如，令 &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; 在Julia和 &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; 是R中的相同矩阵。然后 &lt;code&gt;sum(A)&lt;/code&gt; 得出与 &lt;code&gt;sum(B)&lt;/code&gt; 相同的结果，但是 &lt;code&gt;sum(A, dims=1)&lt;/code&gt; 是包含每列 &lt;code&gt;sum(A, dims=2)&lt;/code&gt; 的行向量，sum（A，dims = 2）是包含每行总和的列向量。这与R的行为形成对比，其中R分开 &lt;code&gt;colSums(B)&lt;/code&gt; 和 &lt;code&gt;rowSums(B)&lt;/code&gt; 函数提供了这些功能。如果 &lt;code&gt;dims&lt;/code&gt; 关键字参数是向量，则它指定执行求和的所有维，同时保留求和数组的维，例如 &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt; 。应该注意的是，没有关于第二个参数的错误检查。</target>
        </trans-unit>
        <trans-unit id="fa67fe88be62afc80adeb10ce9e92a9b5f6f9cf4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; are the equivalent of &lt;code&gt;pmax&lt;/code&gt; and &lt;code&gt;pmin&lt;/code&gt; respectively in R, but both arguments need to have the same dimensions. While &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; replace &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; in R, there are important differences.</source>
          <target state="translated">Julia的&lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/math/index#Base.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt;分别等于R中的 &lt;code&gt;pmax&lt;/code&gt; 和 &lt;code&gt;pmin&lt;/code&gt; ，但是两个参数都必须具有相同的尺寸。虽然&lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt;替换了R中的 &lt;code&gt;max&lt;/code&gt; 和 &lt;code&gt;min&lt;/code&gt; ，但有一些重要的区别。</target>
        </trans-unit>
        <trans-unit id="948bcc3b1298520e6e2ce90508494e37d41ff33b" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; is designed for the case where each function call does a large amount of work. In contrast, &lt;code&gt;@distributed for&lt;/code&gt; can handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;@distributed for&lt;/code&gt; for the parallel computation. In case of &lt;code&gt;@distributed for&lt;/code&gt;, the final reduction is done on the calling process.</source>
          <target state="translated">Julia的&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;是为每个函数调用都需要大量工作的情况而设计的。相反， &lt;code&gt;@distributed for&lt;/code&gt; 可以处理每次迭代很小的情况，也许只需将两个数字求和即可。&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;@distributed for&lt;/code&gt; 仅将工作进程用于并行计算。对于 &lt;code&gt;@distributed for&lt;/code&gt; ，最后的减少是在调用过程中完成的。</target>
        </trans-unit>
        <trans-unit id="1dee74c8ab40f9a1e425f6d177c82bc6b08fa25e" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt;&lt;code&gt;diag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt;&lt;code&gt;diagm&lt;/code&gt;&lt;/a&gt; are not like R's.</source>
          <target state="translated">Julia的&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt; &lt;code&gt;diag&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt; &lt;code&gt;diagm&lt;/code&gt; &lt;/a&gt;并不如R的。</target>
        </trans-unit>
        <trans-unit id="05bb4ea25c67464af30f3b1789a99b7d0ce690d4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; returns singular values as a vector instead of as a dense diagonal matrix.</source>
          <target state="translated">朱莉娅的&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt;将奇异值作为向量而不是密集的对角矩阵返回。</target>
        </trans-unit>
        <trans-unit id="aa13bfca9375abd93cb6c7683cece63cd5fd2582" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;*&lt;/code&gt; operator can perform matrix multiplication, unlike in R. If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, then &lt;code&gt;A * B&lt;/code&gt; denotes a matrix multiplication in Julia, equivalent to R's &lt;code&gt;A %*% B&lt;/code&gt;. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="translated">与R不同，Julia的 &lt;code&gt;*&lt;/code&gt; 运算符可以执行矩阵乘法。如果 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 是矩阵，则 &lt;code&gt;A * B&lt;/code&gt; 表示Julia中的矩阵乘法，等效于R的 &lt;code&gt;A %*% B&lt;/code&gt; 。在R中，相同的表示法将执行元素级（Hadamard）乘积。要获得按元素的乘法运算，您需要在Julia中编写 &lt;code&gt;A .* B&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6c182bb057e6aaee719738d353d529a33805be" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function, it does not access a member via a pointer.</source>
          <target state="translated">Julia's- &lt;code&gt;-&amp;gt;&lt;/code&gt; 创建一个匿名函数，它不通过指针访问成员。</target>
        </trans-unit>
        <trans-unit id="0862128440ff742c36348e2d0db0ca8e8f8925ae" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function.</source>
          <target state="translated">朱莉娅的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 创建一个匿名函数。</target>
        </trans-unit>
        <trans-unit id="5ae5cdad8a8956ce245f1722cb08571c8a10bd0f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;Char&lt;/code&gt; type is 32 bits, which is not the same as the wide character type (&lt;code&gt;wchar_t&lt;/code&gt; or &lt;code&gt;wint_t&lt;/code&gt;) on all platforms.</source>
          <target state="translated">Julia的 &lt;code&gt;Char&lt;/code&gt; 类型为32位，与所有平台上的宽字符类型（ &lt;code&gt;wchar_t&lt;/code&gt; 或 &lt;code&gt;wint_t&lt;/code&gt; ）不同。</target>
        </trans-unit>
        <trans-unit id="b385c4d6332873c3dcd00293c1c25f1adc3ec233" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;^&lt;/code&gt; is exponentiation (pow), not bitwise XOR as in C/C++ (use &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;, in Julia)</source>
          <target state="translated">Julia的 &lt;code&gt;^&lt;/code&gt; 是幂（pow），而不是C / C ++中的按位XOR（在Julia中使用&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="b992e2bb2c187c81d565dd2576257e75a4ff2ac1" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. blocks are terminated by the &lt;code&gt;end&lt;/code&gt; keyword. Indentation level is not significant as it is in Python.</source>
          <target state="translated">Julia的 &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 等等块以 &lt;code&gt;end&lt;/code&gt; 关键字终止。缩进级别并不像Python中那样重要。</target>
        </trans-unit>
        <trans-unit id="4a5e37d3fa53f0bf640b0dba96a1ab8faecfac9f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;struct&lt;/code&gt;s do not support dynamically adding fields at runtime, unlike MATLAB's &lt;code&gt;class&lt;/code&gt;es. Instead, use a &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia的 &lt;code&gt;struct&lt;/code&gt; ■不要在运行时动态支持添加字段，不像MATLAB的 &lt;code&gt;class&lt;/code&gt; 上课。而是使用&lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="eb62051205cdc85bbd2ca3341a23ca3df8234a6b" translate="yes" xml:space="preserve">
          <source>Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to &lt;code&gt;REPL.setup_interface&lt;/code&gt;. The keys of this dictionary may be characters or strings. The key &lt;code&gt;'*'&lt;/code&gt; refers to the default action. Control plus character &lt;code&gt;x&lt;/code&gt; bindings are indicated with &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. Meta plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt;. The values of the custom keymap must be &lt;code&gt;nothing&lt;/code&gt; (indicating that the input should be ignored) or functions that accept the signature &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt;. The &lt;code&gt;REPL.setup_interface&lt;/code&gt; function must be called before the REPL is initialized, by registering the operation with &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">通过将字典传递给 &lt;code&gt;REPL.setup_interface&lt;/code&gt; ,可以完全根据用户的喜好自定义Julia的REPL键绑定。该词典的键可以是字符或字符串。键 &lt;code&gt;'*'&lt;/code&gt; 是指默认操作。控件加字符 &lt;code&gt;x&lt;/code&gt; 的绑定用 &lt;code&gt;&quot;^x&quot;&lt;/code&gt; 。 Meta plus &lt;code&gt;x&lt;/code&gt; 可以写为 &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt; 。自定义键映射的值必须为 &lt;code&gt;nothing&lt;/code&gt; （指示应忽略输入）或接受签名的函数 &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt; 。所述 &lt;code&gt;REPL.setup_interface&lt;/code&gt; 的REPL初始化之前函数必须被调用，通过与登记操作&lt;a href=&quot;#Base.atreplinit&quot;&gt; &lt;code&gt;atreplinit&lt;/code&gt; &lt;/a&gt;。例如，要绑定上下箭头键以浏览历史记录而无需前缀搜索，可以将以下代码放入 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="ff3f30910627d9bc09b7bdaeca1a62844f17b994" translate="yes" xml:space="preserve">
          <source>Julia's base library has a an internal &lt;code&gt;sub2ind&lt;/code&gt; function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index &lt;code&gt;i&lt;/code&gt; that can be used to index into an array &lt;code&gt;A&lt;/code&gt; using &lt;code&gt;A[i]&lt;/code&gt;, instead of &lt;code&gt;A[x,y,z,...]&lt;/code&gt;. One possible implementation is the following:</source>
          <target state="translated">Julia的基本库具有一个内部 &lt;code&gt;sub2ind&lt;/code&gt; 函数来计算的线性索引到一个n维阵列的基础上，一组N个多线性指数-换句话说，计算出索引 &lt;code&gt;i&lt;/code&gt; 可用于索引到一个数组 &lt;code&gt;A&lt;/code&gt; 使用 &lt;code&gt;A[i]&lt;/code&gt; ，而不是 &lt;code&gt;A[x,y,z,...]&lt;/code&gt; 。一种可能的实现如下：</target>
        </trans-unit>
        <trans-unit id="a8c2555d21a070c01d642324e7f2023f9aae7e60" translate="yes" xml:space="preserve">
          <source>Julia's compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of &lt;code&gt;a&lt;/code&gt; during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of &lt;code&gt;fill_twos!&lt;/code&gt; for different types of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Julia的编译器专门用于参数类型的代码在功能边界，所以在最初的实现，它不知道的类型， &lt;code&gt;a&lt;/code&gt; 在循环过程（因为它是随机选择）。因此，第二个版本通常更快，因为可以将内部循环作为 &lt;code&gt;fill_twos!&lt;/code&gt; 一部分重新编译！针对不同类型的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33f4b2b5366e275dc9d4f8493361eee0738216e2" translate="yes" xml:space="preserve">
          <source>Julia's implementation of message passing is different from other environments such as MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</source>
          <target state="translated">Julia的消息传递实现不同于MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;等其他环境。 Julia中的通信通常是&amp;ldquo;单边的&amp;rdquo;，这意味着程序员仅需要在两进程操作中显式管理一个进程。此外，这些操作通常看起来不像&amp;ldquo;消息发送&amp;rdquo;和&amp;ldquo;消息接收&amp;rdquo;，而是类似于更高级别的操作，例如对用户函数的调用。</target>
        </trans-unit>
        <trans-unit id="2d95266cdef29852b478ae12f711e31b88ca02d5" translate="yes" xml:space="preserve">
          <source>Julia's internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</source>
          <target state="translated">Julia的内部索引机制将自动(而且是隐形的)将所有的索引操作转换为首选的样式。这使得用户可以使用任何索引样式来访问数组中的元素,即使没有提供明确的方法。</target>
        </trans-unit>
        <trans-unit id="63b1a2fb20181eebd075a05851e2cc85e0131235" translate="yes" xml:space="preserve">
          <source>Julia's macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique (using the &lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt;&lt;code&gt;gensym&lt;/code&gt;&lt;/a&gt; function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro's locals will not conflict with any user variables, and &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;println&lt;/code&gt; will refer to the Julia Base definitions.</source>
          <target state="translated">Julia的宏扩展器通过以下方式解决了这些问题。首先，宏结果中的变量分为本地变量或全局变量。如果将变量分配给变量（而不是声明为全局变量），声明为局部变量或用作函数参数名称，则将其视为局部变量。否则，它被认为是全局的。然后将局部变量重命名为唯一的（使用生成新符号的&lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt; &lt;code&gt;gensym&lt;/code&gt; &lt;/a&gt;函数），并在宏定义环境中解析全局变量。因此，以上两个问题都得到了解决。宏的本地变量不会与任何用户变量冲突， &lt;code&gt;time&lt;/code&gt; 和 &lt;code&gt;println&lt;/code&gt; 将引用Julia基定义。</target>
        </trans-unit>
        <trans-unit id="86edf724d95c13484ea1286ad4816e866d0db9af" translate="yes" xml:space="preserve">
          <source>Julia's markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual &lt;code&gt;show&lt;/code&gt; methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.</source>
          <target state="translated">Julia的markdown以与基本字符串文字非常相似的方式支持插值，区别在于它将对象本身存储在Markdown树中（而不是将其转换为字符串）。呈现Markdown内容时，将调用常规的 &lt;code&gt;show&lt;/code&gt; 方法，并且可以照常覆盖这些方法。这种设计使Markdown可以扩展为具有任意复杂功能（例如引用）的基本语法。</target>
        </trans-unit>
        <trans-unit id="0901cb4cceb0fa7182b9eca38ef424535bdbefb3" translate="yes" xml:space="preserve">
          <source>Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for &lt;a href=&quot;#man-ambiguities-1&quot;&gt;ambiguities&lt;/a&gt; to arise.</source>
          <target state="translated">Julia的方法多态性是其最强大的功能之一，但是利用这种功能可能会带来设计挑战。特别是，在更复杂的方法层次结构中，出现&lt;a href=&quot;#man-ambiguities-1&quot;&gt;歧义&lt;/a&gt;并不罕见。</target>
        </trans-unit>
        <trans-unit id="23f2c84d6fee04af47b767e6d6e002d54d481014" translate="yes" xml:space="preserve">
          <source>Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:</source>
          <target state="translated">Julia的多维数组是以列-大顺序存储在内存中的。下面是一些创建二维数组并访问其属性的代码。</target>
        </trans-unit>
        <trans-unit id="5f52e87d6645fc0ed7cad30b976ecccc50cc320e" translate="yes" xml:space="preserve">
          <source>Julia's parallel programming platform uses &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;Tasks (aka Coroutines)&lt;/a&gt; to switch among multiple computations. To express an order of execution between lightweight threads communication primitives are necessary. Julia offers &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; that creates a new task from &lt;code&gt;func&lt;/code&gt;, binds it to a new channel of type &lt;code&gt;ctype&lt;/code&gt; and size &lt;code&gt;csize&lt;/code&gt; and schedule the task. &lt;code&gt;Channels&lt;/code&gt; can serve as a way to communicate between tasks, as &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; creates a buffered channel of type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;sz&lt;/code&gt;. Whenever code performs a communication operation like &lt;code&gt;fetch&lt;/code&gt; or &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the current task is suspended and a scheduler picks another task to run. A task is restarted when the event it is waiting for completes.</source>
          <target state="translated">Julia的并行编程平台使用&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;Tasks（又名协程）&lt;/a&gt;在多个计算之间进行切换。为了表达轻量级线程之间的执行顺序，需要通信原语。 Julia提供了 &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; ，该 &lt;code&gt;func&lt;/code&gt; 从func创建新任务，并将其绑定到 &lt;code&gt;ctype&lt;/code&gt; 和size &lt;code&gt;csize&lt;/code&gt; 类型的新通道并调度任务。 &lt;code&gt;Channels&lt;/code&gt; 可以用作任务之间通信的一种方式，因为 &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; 创建一个类型为 &lt;code&gt;T&lt;/code&gt; 且大小为 &lt;code&gt;sz&lt;/code&gt; 的缓冲通道。每当代码执行诸如 &lt;code&gt;fetch&lt;/code&gt; 或&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;，当前任务被挂起，调度程序选择另一个任务来运行。等待任务完成的任务会重新启动。</target>
        </trans-unit>
        <trans-unit id="b466bf8ce3736bba15b2ecdae9872de461ea3a56" translate="yes" xml:space="preserve">
          <source>Julia's promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; for details of the promotion system.</source>
          <target state="translated">Julia的晋升系统自然而自动地对参数类型混合的算术运算&amp;ldquo;起作用&amp;rdquo;。有关升级系统的详细信息，请参见&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;转换和升级&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="4c3a6166fa4f354bffc12e579d7219f7b110624c" translate="yes" xml:space="preserve">
          <source>Julia's single quotes enclose characters, not strings.</source>
          <target state="translated">茱莉亚的单引号括的是字符,而不是字符串。</target>
        </trans-unit>
        <trans-unit id="5826232507a46053a3ad6eca3433bcfcdddedfd4" translate="yes" xml:space="preserve">
          <source>Julia's slice indexing includes the last element, unlike in Python. &lt;code&gt;a[2:3]&lt;/code&gt; in Julia is &lt;code&gt;a[1:3]&lt;/code&gt; in Python.</source>
          <target state="translated">与Python不同，Julia的切片索引包括最后一个元素。 &lt;code&gt;a[2:3]&lt;/code&gt; 在Julia是 &lt;code&gt;a[1:3]&lt;/code&gt; 在Python。</target>
        </trans-unit>
        <trans-unit id="d3f2b1b2df721c7080cd008996870d53e3376216" translate="yes" xml:space="preserve">
          <source>Julia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia programmers may never feel the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with declared types.</source>
          <target state="translated">Julia的类型系统被设计成功能强大、表现力强,但又清晰、直观、不显眼。许多Julia程序员可能永远不会觉得需要编写明确使用类型的代码。然而,有些类型的编程,在声明类型的情况下会变得更清晰、更简单、更快速、更健壮。</target>
        </trans-unit>
        <trans-unit id="2601bca815fd3b23be75d3eb7a5f70824d2baba0" translate="yes" xml:space="preserve">
          <source>Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, but is rooted in the type system presented here.</source>
          <target state="translated">朱莉娅的类型系统是动态的，但是通过表明某些值属于特定类型，可以获得静态类型系统的某些优点。这对于生成有效的代码可能有很大的帮助，但更重要的是，它允许对函数参数类型的方法分派与该语言进行深度集成。在&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;方法&lt;/a&gt;中详细探讨了方法分配，但它扎根于此处介绍的类型系统。</target>
        </trans-unit>
        <trans-unit id="060a807b9436918cd4c19176ffcd9bf4c0ffdec4" translate="yes" xml:space="preserve">
          <source>Julia's updating operators (e.g. &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, ...) are &lt;em&gt;not in-place&lt;/em&gt; whereas NumPy's are. This means &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; doesn't change values in &lt;code&gt;A&lt;/code&gt;, it rather rebinds the name &lt;code&gt;B&lt;/code&gt; to the result of the right-hand side &lt;code&gt;B = B + 3&lt;/code&gt;, which is a new array. For in-place operation, use &lt;code&gt;B .+= 3&lt;/code&gt; (see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;), explicit loops, or &lt;code&gt;InplaceOps.jl&lt;/code&gt;.</source>
          <target state="translated">Julia的更新运算符（例如 &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; ，...）&lt;em&gt;不在位，&lt;/em&gt;而NumPy则&lt;em&gt;在位&lt;/em&gt;。这意味着 &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; 不会更改 &lt;code&gt;A&lt;/code&gt; 中的值，而是将名称 &lt;code&gt;B&lt;/code&gt; 重新绑定到右侧 &lt;code&gt;B = B + 3&lt;/code&gt; ，这是一个新数组。对于就地操作，请使用 &lt;code&gt;B .+= 3&lt;/code&gt; （另请参阅&lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;点运算符&lt;/a&gt;），显式循环或 &lt;code&gt;InplaceOps.jl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="29157447971e1b4b6b81d91fd76c285c2b275482" translate="yes" xml:space="preserve">
          <source>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;manual section on the AbstractArray interface&lt;/a&gt; for more details on implementing a custom array type.</source>
          <target state="translated">像大多数技术计算语言一样，Julia提供了一流的数组实现。大多数技术计算语言都以牺牲其他容器为代价来关注其数组实现。 Julia不以任何特殊方式对待数组。数组库几乎完全在Julia本身中实现，并且像在Julia中编写的任何其他代码一样，从编译器获得其性能。这样，也可以通过继承&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;来定义自定义数组类型。有关实现自定义数组类型的更多详细信息，请参见&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;AbstractArray接口上&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="88d1577dcc4f245ab6ce133765fe78bb8913aa7f" translate="yes" xml:space="preserve">
          <source>Jupiter</source>
          <target state="translated">Jupiter</target>
        </trans-unit>
        <trans-unit id="baa896b33786524acff2009a8d27bd6b3009cef2" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;^R&lt;/code&gt; is a reverse search, &lt;code&gt;^S&lt;/code&gt; is a forward search, with the prompt &lt;code&gt;(i-search)`':&lt;/code&gt;. The two may be used in conjunction with each other to move through the previous or next matching results, respectively.</source>
          <target state="translated">正如 &lt;code&gt;^R&lt;/code&gt; 是反向搜索， &lt;code&gt;^S&lt;/code&gt; 是一个前向搜索，与提示 &lt;code&gt;(i-search)`':&lt;/code&gt; 。两者可以相互结合使用，以分别遍历前一个或下一个匹配结果。</target>
        </trans-unit>
        <trans-unit id="9365c41bee7315e2eb3ab59d3b982ca7ca4bb4b9" translate="yes" xml:space="preserve">
          <source>Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as &lt;code&gt;?&lt;/code&gt; entered help mode when at the beginning of the line, a semicolon (&lt;code&gt;;&lt;/code&gt;) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">正如帮助模式对于快速访问文档很有用，另一个常见任务是使用系统外壳执行系统命令。一样 &lt;code&gt;?&lt;/code&gt; 在该行的开头进入帮助模式时，分号（ &lt;code&gt;;&lt;/code&gt; ）将进入shell模式。可以通过在行首按退格键退出。</target>
        </trans-unit>
        <trans-unit id="e330a59e23d168a0ce147528d526c6c70e235165" translate="yes" xml:space="preserve">
          <source>Just as in &lt;a href=&quot;#man-array-indexing-1&quot;&gt;Indexing&lt;/a&gt;, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">就像在&lt;a href=&quot;#man-array-indexing-1&quot;&gt;Indexing中一样&lt;/a&gt;， &lt;code&gt;end&lt;/code&gt; 关键字可以用来表示索引括号内每个维度的最后一个索引，这由分配给数组的大小确定。没有 &lt;code&gt;end&lt;/code&gt; 关键字的索引赋值语法等效于对&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;的调用！：</target>
        </trans-unit>
        <trans-unit id="129fdfb9651f86a9c5a6d204baf7fd51a6f897e9" translate="yes" xml:space="preserve">
          <source>Just as text output is performed by &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; and user-defined types can indicate their textual representation by overloading &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</source>
          <target state="translated">正如文本输出是通过&lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;执行的，用户定义的类型可以通过&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;的重载来指示其文本表示一样，Julia提供了一种标准化的机制来实现丰富的多媒体输出（例如图像，带格式的文本，甚至是音频和视频），该机制由三部分组成：</target>
        </trans-unit>
        <trans-unit id="f31418705dc05a56f9681110f63d545eb15e8a22" translate="yes" xml:space="preserve">
          <source>Just as you can put subtype constraints on type parameters in type declarations (see &lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt;), you can also constrain type parameters of methods:</source>
          <target state="translated">正如您可以在类型声明中将子类型约束放置在类型参数上一样（请参阅&lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt;），您也可以约束方法的类型参数：</target>
        </trans-unit>
        <trans-unit id="3a5b8319210d6e829092640e9c9931c8b6b93159" translate="yes" xml:space="preserve">
          <source>Just like condition expressions used in &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt; or the ternary operator, the operands of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; must be boolean values (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:</source>
          <target state="translated">就像 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;elseif&lt;/code&gt; 或三元运算符中使用的条件表达式一样， &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;||&lt;/code&gt; 的操作数 必须为布尔值（ &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）。在条件链中最后一个条目以外的任何地方使用非布尔值是一个错误：</target>
        </trans-unit>
        <trans-unit id="89b905a2ec6630efe24e67a128976a957febd0eb" translate="yes" xml:space="preserve">
          <source>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:</source>
          <target state="translated">并列的文字系数语法可能会与两种数字文字语法发生冲突:十六进制整数文字和浮点文字的工程符号。下面是一些出现语法冲突的情况。</target>
        </trans-unit>
        <trans-unit id="9ec40672083b66df6ef7fbca9db99f5cc01dc9d5" translate="yes" xml:space="preserve">
          <source>Keep in mind that some Julia features are not currently supported by CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt; , especially some functions like &lt;code&gt;sin&lt;/code&gt; will need to be replaced with &lt;code&gt;CUDAnative.sin&lt;/code&gt;(cc: @maleadt).</source>
          <target state="translated">请记住，CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;当前不支持某些Julia功能，尤其是诸如 &lt;code&gt;sin&lt;/code&gt; 之类的某些功能需要替换为 &lt;code&gt;CUDAnative.sin&lt;/code&gt; （cc：@maleadt）。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="2f019ec46ab9548a295fae40fb32bbf280932bb8" translate="yes" xml:space="preserve">
          <source>Key bindings</source>
          <target state="translated">钥匙扣</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="23f6f8047d85e8db9b2a5eaadf76de7dfe565d74" translate="yes" xml:space="preserve">
          <source>Keybinding</source>
          <target state="translated">Keybinding</target>
        </trans-unit>
        <trans-unit id="59ba1e5a90c9cfee0b263032ac6574298fc3c42e" translate="yes" xml:space="preserve">
          <source>Keycap Ten</source>
          <target state="translated">钥匙帽十</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="db32172db3cd21ae36313d815fba0dd39bd7127a" translate="yes" xml:space="preserve">
          <source>Keyword Arguments</source>
          <target state="translated">關鍵字參數</target>
        </trans-unit>
        <trans-unit id="37a1398f40ad5a5758f3118ecb2e0028c1f656ac" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of &lt;code&gt;:source&lt;/code&gt; or &lt;code&gt;:none&lt;/code&gt; (default), to specify the verbosity of code comments.</source>
          <target state="translated">关键字参数 &lt;code&gt;debuginfo&lt;/code&gt; 可以是 &lt;code&gt;:source&lt;/code&gt; 或 &lt;code&gt;:none&lt;/code&gt; （默认值）之一，以指定代码注释的详细程度。</target>
        </trans-unit>
        <trans-unit id="4eec148d4683d6a5be8244fa8544e4bc73995042" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;lazy=true|false&lt;/code&gt; only affects &lt;code&gt;topology&lt;/code&gt; option &lt;code&gt;:all_to_all&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, the cluster starts off with the master connected to all workers. Specific worker-worker connections are established at the first remote invocation between two workers. This helps in reducing initial resources allocated for intra-cluster communication. Connections are setup depending on the runtime requirements of a parallel program. Default value for &lt;code&gt;lazy&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">关键字参数 &lt;code&gt;lazy=true|false&lt;/code&gt; 仅影响 &lt;code&gt;topology&lt;/code&gt; 选项 &lt;code&gt;:all_to_all&lt;/code&gt; 。如果为 &lt;code&gt;true&lt;/code&gt; ，则集群在主服务器连接到所有工作服务器的情况下启动。在两个工作人员之间的第一次远程调用时，将建立特定的工作人员－工作人员连接。这有助于减少分配给集群内通信的初始资源。根据并行程序的运行时要求来建立连接。为默认值 &lt;code&gt;lazy&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a85841ebcc4fbb3f6bb0af53f5f74a1d1107441b" translate="yes" xml:space="preserve">
          <source>Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.</source>
          <target state="translated">关键字参数的缺省值仅在必要时(当没有传递相应的关键字参数时)才会被评估,并且按照从左到右的顺序。因此默认表达式可能会参考之前的关键字参数。</target>
        </trans-unit>
        <trans-unit id="cd222673b8a5eeb28c17fea40269820af080e4d5" translate="yes" xml:space="preserve">
          <source>Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.</source>
          <target state="translated">关键字参数的行为与普通的位置参数完全不同。特别是,它们不参与方法的调度。方法的调度只基于位置参数,关键字参数在匹配的方法被识别后进行处理。</target>
        </trans-unit>
        <trans-unit id="e1f80b2c92c551f95f3994cdc90a44e035d56013" translate="yes" xml:space="preserve">
          <source>Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">关键字参数（如果有）将传递给 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8804a97595c6605af997f797488e9f7a887cea7" translate="yes" xml:space="preserve">
          <source>Keyword arguments:</source>
          <target state="translated">嵉论。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e42f478ffbc394a252424af959d3abd0a98e41e6" translate="yes" xml:space="preserve">
          <source>Keywords are also displayed in the suggested methods after &lt;code&gt;;&lt;/code&gt;, see below line where &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;keepempty&lt;/code&gt; are keyword arguments:</source>
          <target state="translated">关键字也显示在建议的方法之后 &lt;code&gt;;&lt;/code&gt; ，请参见以下行，其中 &lt;code&gt;limit&lt;/code&gt; 和 &lt;code&gt;keepempty&lt;/code&gt; 是关键字参数：</target>
        </trans-unit>
        <trans-unit id="924acc699e5835f0f13e0c55c14fdfbfa6ba40d8" translate="yes" xml:space="preserve">
          <source>Kimono</source>
          <target state="translated">Kimono</target>
        </trans-unit>
        <trans-unit id="4dbc43957024c86f07374b147dcca5a43c62318b" translate="yes" xml:space="preserve">
          <source>Kiss</source>
          <target state="translated">Kiss</target>
        </trans-unit>
        <trans-unit id="23d1162dbd548a5b7ebb3cb6c2092223a1165283" translate="yes" xml:space="preserve">
          <source>Kiss Mark</source>
          <target state="translated">吻痕</target>
        </trans-unit>
        <trans-unit id="bc19b3dfb9379c314c1b8e3bb9dc5e6a2b26f09b" translate="yes" xml:space="preserve">
          <source>Kissing Cat Face With Closed Eyes</source>
          <target state="translated">闭目养神的猫咪</target>
        </trans-unit>
        <trans-unit id="b58aa4e85bf24740360e2d6b347305a564dca4a1" translate="yes" xml:space="preserve">
          <source>Kissing Face</source>
          <target state="translated">吻脸</target>
        </trans-unit>
        <trans-unit id="2fe6ec1bfe77e7354379b52c0bee899a96c21add" translate="yes" xml:space="preserve">
          <source>Kissing Face With Closed Eyes</source>
          <target state="translated">闭眼吻脸</target>
        </trans-unit>
        <trans-unit id="fcaff6a193904e107dc7d4aa4f3190493c405457" translate="yes" xml:space="preserve">
          <source>Kissing Face With Smiling Eyes</source>
          <target state="translated">吻脸与微笑的眼睛</target>
        </trans-unit>
        <trans-unit id="74ae77190d30e9483b1024a2bf19d64715a77757" translate="yes" xml:space="preserve">
          <source>Koala</source>
          <target state="translated">Koala</target>
        </trans-unit>
        <trans-unit id="9afe7e71a0cd3f5b45d3038779f47e6ab11c4a9d" translate="yes" xml:space="preserve">
          <source>Konstantinos Konstantinides and Kung Yao, &quot;Statistical analysis of effective singular values in matrix rank determination&quot;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. &lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;doi:10.1109/29.1585&lt;/a&gt;</source>
          <target state="translated">Konstantinos Konstantinides和Kung Yao，&amp;ldquo;矩阵秩确定中有效奇异值的统计分析&amp;rdquo;，IEEE声学，语音和信号处理学报，36（5），1988，757-763。&lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;doi：10.1109 / 29.1585&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4a94c6e095d242bfd65b4080bf588284c946f8c" translate="yes" xml:space="preserve">
          <source>Kronecker tensor product of two vectors or two matrices.</source>
          <target state="translated">两个向量或两个矩阵的Kronecker张量积。</target>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="d4e9710203cf5806e211a4382bda892c104cc46d" translate="yes" xml:space="preserve">
          <source>LAPACK Functions</source>
          <target state="translated">LAPACK功能</target>
        </trans-unit>
        <trans-unit id="b4aff6bdb4998cc3553c7001845a94833e9f4e43" translate="yes" xml:space="preserve">
          <source>LDLt (see &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt;&lt;code&gt;ldlt&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LDLt（请参阅&lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt; &lt;code&gt;ldlt&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="26214decf703290192f10270d6b0b515c7511762" translate="yes" xml:space="preserve">
          <source>LLVM Interface</source>
          <target state="translated">LLVM接口</target>
        </trans-unit>
        <trans-unit id="f5f4f14ed2c38473c6c2d9123249c93ff3ece227" translate="yes" xml:space="preserve">
          <source>LOAD_PATH</source>
          <target state="translated">LOAD_PATH</target>
        </trans-unit>
        <trans-unit id="160e7ef90659bedaf209eec44edbbe3caf988121" translate="yes" xml:space="preserve">
          <source>LU (see &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LU（请参阅&lt;a href=&quot;#LinearAlgebra.lu&quot;&gt; &lt;code&gt;lu&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="23dbe335a346e4f78af48a087f0c1292440d8cc7" translate="yes" xml:space="preserve">
          <source>LU factorization</source>
          <target state="translated">LU因子化</target>
        </trans-unit>
        <trans-unit id="a905567226043f1b393e816a77aec998343c78b4" translate="yes" xml:space="preserve">
          <source>LU factorization for &lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt;&lt;code&gt;Tridiagonal&lt;/code&gt;&lt;/a&gt; matrices</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt; &lt;code&gt;Tridiagonal&lt;/code&gt; &lt;/a&gt;矩阵的LU分解</target>
        </trans-unit>
        <trans-unit id="366152a7d098555665a4453404d639ac8b476b7a" translate="yes" xml:space="preserve">
          <source>Labels a statement with the symbolic label &lt;code&gt;name&lt;/code&gt;. The label marks the end-point of an unconditional jump with &lt;a href=&quot;#Base.@goto&quot;&gt;&lt;code&gt;@goto name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用符号标签 &lt;code&gt;name&lt;/code&gt; 标记语句。标签使用&lt;a href=&quot;#Base.@goto&quot;&gt; &lt;code&gt;@goto name&lt;/code&gt; &lt;/a&gt;标记无条件跳转的终点。</target>
        </trans-unit>
        <trans-unit id="ff8f52e27fbdf435514705d351e8d01e3dd57b73" translate="yes" xml:space="preserve">
          <source>Lady Beetle</source>
          <target state="translated">甲虫夫人</target>
        </trans-unit>
        <trans-unit id="4dee08e75e78fb7f2ea26537626acf062390bc00" translate="yes" xml:space="preserve">
          <source>Large $\LaTeX$ equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the &quot;language&quot; &lt;code&gt;math&lt;/code&gt; as in the example below.</source>
          <target state="translated">不能在段落中内联的较大的$ \ LaTeX $方程式可以使用带有&amp;ldquo;语言&amp;rdquo; &lt;code&gt;math&lt;/code&gt; 的围栏代码块作为显示方程式编写，如下例所示。</target>
        </trans-unit>
        <trans-unit id="8f95211a940e3d08b42c29bbf9dbc496ccfe208b" translate="yes" xml:space="preserve">
          <source>Large Blue Circle</source>
          <target state="translated">大蓝圈</target>
        </trans-unit>
        <trans-unit id="68e7dfd86e1bad5177b243cce59909605d2d63ff" translate="yes" xml:space="preserve">
          <source>Large Blue Diamond</source>
          <target state="translated">大号蓝钻</target>
        </trans-unit>
        <trans-unit id="1489faea46cdb0a914888faa83aaccbf1a1018b6" translate="yes" xml:space="preserve">
          <source>Large Circle</source>
          <target state="translated">大圆</target>
        </trans-unit>
        <trans-unit id="47d39efcf737a8cb7cff31b45c3eae3b9768a070" translate="yes" xml:space="preserve">
          <source>Large Down Tack</source>
          <target state="translated">大羽绒服</target>
        </trans-unit>
        <trans-unit id="19d1a6d4bde006ab21ff3b1a9ce0c5b1f656efbe" translate="yes" xml:space="preserve">
          <source>Large Orange Diamond</source>
          <target state="translated">橙色大钻石</target>
        </trans-unit>
        <trans-unit id="2be06620aa858eeb1cfd65e452ba545d7194c263" translate="yes" xml:space="preserve">
          <source>Large Red Circle</source>
          <target state="translated">大红圈</target>
        </trans-unit>
        <trans-unit id="93780c9bf758bfc5b064c94682265b362eac13d6" translate="yes" xml:space="preserve">
          <source>Large Up Tack</source>
          <target state="translated">大号鞋带</target>
        </trans-unit>
        <trans-unit id="c567cf1fe685a9b85ba876a5fdec9645963ce55b" translate="yes" xml:space="preserve">
          <source>Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount of code. Julia creates precompiled caches of the module to reduce this time.</source>
          <target state="translated">大型模块可能需要几秒钟的时间来加载,因为执行一个模块中的所有语句往往需要编译大量的代码。Julia创建了模块的预编译缓存来减少这个时间。</target>
        </trans-unit>
        <trans-unit id="836cd86751bc175f6a1c3513d9545f0269900a32" translate="yes" xml:space="preserve">
          <source>Larger Than</source>
          <target state="translated">大于</target>
        </trans-unit>
        <trans-unit id="8fc4e576fc574f75bb7c600973def67858d8bb40" translate="yes" xml:space="preserve">
          <source>Larger Than Or Equal To</source>
          <target state="translated">大于或等于</target>
        </trans-unit>
        <trans-unit id="d737eee8172d65bba64271f9c8b335b8b815d284" translate="yes" xml:space="preserve">
          <source>Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, regardless of the system type:</source>
          <target state="translated">不能只用32位来表示,但可以用64位来表示的较大的整数字元总是创建64位整数,不管系统类型如何。</target>
        </trans-unit>
        <trans-unit id="2c5201c8ea16b6383c4f6c269ee86f7c5d37bb84" translate="yes" xml:space="preserve">
          <source>Largest integer less than or equal to &lt;code&gt;x/y&lt;/code&gt;.</source>
          <target state="translated">小于或等于 &lt;code&gt;x/y&lt;/code&gt; 的最大整数。</target>
        </trans-unit>
        <trans-unit id="45e54723a9bf0cd3ba0bd2155ce7b7bac5bfafd9" translate="yes" xml:space="preserve">
          <source>Largest value</source>
          <target state="translated">最大值</target>
        </trans-unit>
        <trans-unit id="af72fbc94064a4c9a0a644731e497dc5dc7beff9" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon</source>
          <target state="translated">最后一刻月</target>
        </trans-unit>
        <trans-unit id="4d7f319a09451056e084d65cad158f125e2020cc" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon Symbol</source>
          <target state="translated">最后一个季度的月亮符号</target>
        </trans-unit>
        <trans-unit id="a7b4069351f71ce4f08da44121a5414042cbca4b" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon With Face</source>
          <target state="translated">最后一刻月与脸</target>
        </trans-unit>
        <trans-unit id="18cf37d7758974150aba5efc169a132701c98591" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter A With Ring Above / Latin Capital Letter A Ring</source>
          <target state="translated">拉丁字母A环以上/拉丁字母A环以上</target>
        </trans-unit>
        <trans-unit id="387186c7a8fff866e6fbacb8a7a99c078e963118" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Ae / Latin Capital Letter A E</source>
          <target state="translated">拉丁文大写字母Ae/拉丁文大写字母A E.</target>
        </trans-unit>
        <trans-unit id="f2c0864bdd70eeadaffc0e4bf8122d6178ff53bb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter D With Stroke / Latin Capital Letter D Bar</source>
          <target state="translated">拉丁文大写字母D带笔画/拉丁文大写字母D条带笔画</target>
        </trans-unit>
        <trans-unit id="18ee11f5dfc96b5ea1e522af1744aced409d9ff1" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eng</source>
          <target state="translated">拉丁文大写字母英文</target>
        </trans-unit>
        <trans-unit id="7e38029cb2d0c6ce87bf45f5170886022a280556" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eth</source>
          <target state="translated">拉丁字母Eth</target>
        </trans-unit>
        <trans-unit id="261b92b2c69498043ebd035666aae447dd5fc40c" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter L With Stroke / Latin Capital Letter L Slash</source>
          <target state="translated">拉丁文大写字母L带笔画/拉丁文大写字母L斜线部分</target>
        </trans-unit>
        <trans-unit id="81f5aedd8e8fccac1ab8a6bc67c43be5b7c7e7f6" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter O With Stroke / Latin Capital Letter O Slash</source>
          <target state="translated">拉丁文大写字母O带笔画/拉丁文大写字母O斜线部分</target>
        </trans-unit>
        <trans-unit id="3e1d1bce5c9a11240957721f8ef29a635e048ab3" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Thorn</source>
          <target state="translated">拉丁文大写字母荆棘</target>
        </trans-unit>
        <trans-unit id="4b4cf2ef98d43801be6875ab83c9e3c993eddbbb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Z With Stroke / Latin Capital Letter Z Bar</source>
          <target state="translated">拉丁文大写字母Z加笔画/拉丁文大写字母Z吧</target>
        </trans-unit>
        <trans-unit id="5ae3e818634045d7a9130d2b676f3527521e0150" translate="yes" xml:space="preserve">
          <source>Latin Capital Ligature Oe / Latin Capital Letter O E</source>
          <target state="translated">拉丁文大写字母Oe/拉丁文大写字母O E .</target>
        </trans-unit>
        <trans-unit id="957520bb4ae3c78ec831bd317cdfd85081025ee6" translate="yes" xml:space="preserve">
          <source>Latin Letter Alveolar Click / Latin Letter Pipe Double Bar</source>
          <target state="translated">拉丁字母牙槽点击/拉丁字母管子双条形</target>
        </trans-unit>
        <trans-unit id="43073b60cf8171df59d1497357356aa7115c7db3" translate="yes" xml:space="preserve">
          <source>Latin Letter Glottal Stop</source>
          <target state="translated">拉丁字母喉结</target>
        </trans-unit>
        <trans-unit id="fc36244b6362ae3e3d6d20e2d335c02a7af88997" translate="yes" xml:space="preserve">
          <source>Latin Letter Inverted Glottal Stop</source>
          <target state="translated">拉丁字母倒置喉头停顿</target>
        </trans-unit>
        <trans-unit id="680f41038e731ff5fdc7bf24ce99313a70d99990" translate="yes" xml:space="preserve">
          <source>Latin Letter Pharyngeal Voiced Fricative / Latin Letter Reversed Glottal Stop</source>
          <target state="translated">拉丁字母咽喉发声擦音/拉丁字母反转喉停音</target>
        </trans-unit>
        <trans-unit id="7e9e2bfa072cd28ac12f89b807c22a2d9b6b5f07" translate="yes" xml:space="preserve">
          <source>Latin Small Letter A With Ring Above / Latin Small Letter A Ring</source>
          <target state="translated">拉丁文小字母A上面有环/拉丁文小字母A环</target>
        </trans-unit>
        <trans-unit id="aeaa4f1f1687667c2f5fc22a10bca6a0268c7e52" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ae / Latin Small Letter A E</source>
          <target state="translated">拉丁文小字Ae/拉丁文小字A E .</target>
        </trans-unit>
        <trans-unit id="bd81bee974151364620b17177c4955612e0e03fa" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Closed Omega</source>
          <target state="translated">拉丁文小字封闭式欧米茄</target>
        </trans-unit>
        <trans-unit id="c4abfd40c74b3eb74040658788c6847cb7128777" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Stroke / Latin Small Letter D Bar</source>
          <target state="translated">拉丁文小字D(带笔画)/拉丁文小字D条(带笔画)</target>
        </trans-unit>
        <trans-unit id="79664c84e38ddc705c095d22df17f6ba110cb657" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Tail / Latin Small Letter D Retroflex Hook</source>
          <target state="translated">拉丁语小字母D带尾巴/拉丁语小字母D反折钩。</target>
        </trans-unit>
        <trans-unit id="0bae965510de34e4507ca1c9f6442e6f063065a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dezh Digraph / Latin Small Letter D Yogh</source>
          <target state="translated">拉丁文小字Dezh Digraph/拉丁文小字D Yogh (Yogh)</target>
        </trans-unit>
        <trans-unit id="93c7ebd3f43b49c98f8c0737391432699e082aa6" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless I</source>
          <target state="translated">拉丁文小字无点I</target>
        </trans-unit>
        <trans-unit id="0639f709a04d29a7d92f491504f4b15becbc375e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless J</source>
          <target state="translated">拉丁文小字无点J</target>
        </trans-unit>
        <trans-unit id="cf365327a81aadb5e405df4d0f48b32472c24b2e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eng</source>
          <target state="translated">拉丁文小字英文</target>
        </trans-unit>
        <trans-unit id="93c2ec38cecdf8e443b85db5de563a216ffd9d34" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Esh</source>
          <target state="translated">拉丁文小字Esh</target>
        </trans-unit>
        <trans-unit id="2e8a26241b482f37e00adb250b979246ca85beea" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eth</source>
          <target state="translated">拉丁文小字Eth</target>
        </trans-unit>
        <trans-unit id="40104027bfc2f3a58be7509f94be97c17e39f2f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ezh / Latin Small Letter Yogh</source>
          <target state="translated">拉丁文小字Ezh/拉丁文小字Yogh(Yogh)</target>
        </trans-unit>
        <trans-unit id="f9e515806fd1b60b14e5fc8f3af7f90ac6e9364a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Gamma</source>
          <target state="translated">拉丁语小字Gamma</target>
        </trans-unit>
        <trans-unit id="97085caf81a24ef927fdc386fc6b04e27e1f72b9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter H With Stroke / Latin Small Letter H Bar</source>
          <target state="translated">拉丁文小字H(带笔画)/拉丁文小字H条(带笔画)</target>
        </trans-unit>
        <trans-unit id="399d282443390fef914db664bba2883747b928af" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Hv / Latin Small Letter H V</source>
          <target state="translated">拉丁文小字Hv/拉丁文小字H V</target>
        </trans-unit>
        <trans-unit id="2422e4f11c03b366715aa80ec860fc60eae0c461" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Belt / Latin Small Letter L Belt</source>
          <target state="translated">拉丁文小字L型腰带/拉丁文小字L型腰带。</target>
        </trans-unit>
        <trans-unit id="82d31c79255d3b522eb37fa11b7bb67ebf6d75a1" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Retroflex Hook / Latin Small Letter L Retroflex Hook</source>
          <target state="translated">拉丁语小字L带折返钩/拉丁语小字L折返钩。</target>
        </trans-unit>
        <trans-unit id="432e37bd3e31540f66f1af3dfdcfd97516ca52f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Stroke / Latin Small Letter L Slash</source>
          <target state="translated">拉丁文小字L(带笔画)/拉丁文小字L(斜线)</target>
        </trans-unit>
        <trans-unit id="c6dc1b09cb591ac95922c661ff9481278d4d2de7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter M With Hook / Latin Small Letter M Hook</source>
          <target state="translated">拉丁文小字母M带钩/拉丁文小字母M带钩</target>
        </trans-unit>
        <trans-unit id="0218525707cb4bb564235a036cc2842ec67b0748" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Left Hook / Latin Small Letter N Hook</source>
          <target state="translated">拉丁文小字N(左鉤)/拉丁文小字N鉤</target>
        </trans-unit>
        <trans-unit id="b20690f24cf5bf99ca0c7018eee110ebe0e15a04" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Long Right Leg</source>
          <target state="translated">拉丁文小字N,右腿长</target>
        </trans-unit>
        <trans-unit id="31ec66aaa00a79d775f1c857d59f5c7a74247d09" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Retroflex Hook / Latin Small Letter N Retroflex Hook</source>
          <target state="translated">拉丁语小字母N带折返钩/拉丁语小字母N折返钩。</target>
        </trans-unit>
        <trans-unit id="7874ede875d3c7ae94e73df07ed062477861ae44" translate="yes" xml:space="preserve">
          <source>Latin Small Letter O With Stroke / Latin Small Letter O Slash</source>
          <target state="translated">拉丁文小字母O加笔画/拉丁文小字母O斜线</target>
        </trans-unit>
        <trans-unit id="07add9523a52497c0c262c0382ad46de39eb16bd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Open O</source>
          <target state="translated">拉丁语小字开口O</target>
        </trans-unit>
        <trans-unit id="1b7b0f5e96e58726dfbb7a30f8602204b9a71f82" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Phi</source>
          <target state="translated">拉丁语小字Phi</target>
        </trans-unit>
        <trans-unit id="ff12afa374c372c8fc23589cff50c4ee6f2f6cde" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Fishhook / Latin Small Letter Fishhook R</source>
          <target state="translated">拉丁文小字R与鱼钩/拉丁文小字鱼钩R在一起。</target>
        </trans-unit>
        <trans-unit id="591234998559d2fb9e34782769a6a85e552ca14a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Long Leg</source>
          <target state="translated">拉丁语小字母R配长腿</target>
        </trans-unit>
        <trans-unit id="c1a50f7f5584c407c2b721281ea3abe4e34d13d4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Tail / Latin Small Letter R Hook</source>
          <target state="translated">拉丁文小字母R带尾巴/拉丁文小字母R钩。</target>
        </trans-unit>
        <trans-unit id="ef19cd34955161980d339367d254aafdd02b4cb7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Rams Horn / Latin Small Letter Baby Gamma</source>
          <target state="translated">拉丁文小字公羊角/拉丁文小字宝贝Gamma号。</target>
        </trans-unit>
        <trans-unit id="bf1d74257f1f62e2e52e3dc8b76fe85f6a2c3e96" translate="yes" xml:space="preserve">
          <source>Latin Small Letter S With Hook / Latin Small Letter S Hook</source>
          <target state="translated">拉丁文小字S挂钩/拉丁文小字S挂钩</target>
        </trans-unit>
        <trans-unit id="f17b9219c1288784e62e066762b90b3f1e0e55a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Schwa</source>
          <target state="translated">拉丁文小字Schwa</target>
        </trans-unit>
        <trans-unit id="19e904077d5fb0771a0c4bf22aebcb8d18879d02" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Sharp S</source>
          <target state="translated">拉丁文小字锐S</target>
        </trans-unit>
        <trans-unit id="4e3c130c920943099dd727660677e4cfb89ea723" translate="yes" xml:space="preserve">
          <source>Latin Small Letter T With Retroflex Hook / Latin Small Letter T Retroflex Hook</source>
          <target state="translated">拉丁小字T型反折钩/拉丁小字T型反折钩。</target>
        </trans-unit>
        <trans-unit id="b4aa5dce4f194d4f86cea8db7ef720a452c10472" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Tesh Digraph / Latin Small Letter T Esh</source>
          <target state="translated">拉丁文小字 Tesh Digraph/拉丁文小字 T Esh</target>
        </trans-unit>
        <trans-unit id="9a88a6a40f3264cff644fc36d6ea39b7e80dee4b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Thorn</source>
          <target state="translated">拉丁文小字荆棘</target>
        </trans-unit>
        <trans-unit id="206fdfa3558c503d9e843533aa39ca8750c5100a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned A</source>
          <target state="translated">拉丁文小字转A</target>
        </trans-unit>
        <trans-unit id="44391e675633f27178e360e38182fb1c89dcc786" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Alpha / Latin Small Letter Turned Script A</source>
          <target state="translated">拉丁文小字转为字母/拉丁文小字转为字母A</target>
        </trans-unit>
        <trans-unit id="a45dfaa69d6b3db6daa54b07a19c0a16bc93f9c4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned H</source>
          <target state="translated">拉丁文小字转H</target>
        </trans-unit>
        <trans-unit id="d0a8378f24aaa4a7fd08ad76eab02d85f9db34c3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned K</source>
          <target state="translated">拉丁语小字转K</target>
        </trans-unit>
        <trans-unit id="f60605b6d90f4154d38bac9031c2a73d3e7fb2fd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M</source>
          <target state="translated">拉丁文小字转M</target>
        </trans-unit>
        <trans-unit id="80870744996553dd1a355c5c68035612071c93d5" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M With Long Leg</source>
          <target state="translated">拉丁文小字长腿转M</target>
        </trans-unit>
        <trans-unit id="4e330127b9bd74c3ac0ed39785e51192a2a6804b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R</source>
          <target state="translated">拉丁文小字转R</target>
        </trans-unit>
        <trans-unit id="7f2283c2045b7461f57d11ba1b67518361b943d3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Hook / Latin Small Letter Turned R Hook</source>
          <target state="translated">拉丁文小字转R钩/拉丁文小字转R钩</target>
        </trans-unit>
        <trans-unit id="78ca75233c25b210f82d0fa683b1e829340273d9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Long Leg</source>
          <target state="translated">拉丁文小字转R长腿</target>
        </trans-unit>
        <trans-unit id="b693ad995bba90f1295c3eb3fa51e43c784b64eb" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned T</source>
          <target state="translated">拉丁文小字转T</target>
        </trans-unit>
        <trans-unit id="5209a0d49366580ead3e1dad9d6ff2475775f51f" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned V</source>
          <target state="translated">拉丁文小字转V</target>
        </trans-unit>
        <trans-unit id="450f985cc65d78122edf815571e08094f13be358" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned W</source>
          <target state="translated">拉丁文小字转W</target>
        </trans-unit>
        <trans-unit id="d4b68356f1e5f3312b5bc8059eb8f75757a7c22d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Y</source>
          <target state="translated">拉丁文小字转Y</target>
        </trans-unit>
        <trans-unit id="1c50afa8247e2b596bb5484c0bdf31af4356cb8d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Upsilon</source>
          <target state="translated">拉丁文小字Upsilon</target>
        </trans-unit>
        <trans-unit id="cf80e9e2586cd62109287c1d07560fe914a80d16" translate="yes" xml:space="preserve">
          <source>Latin Small Letter V With Hook / Latin Small Letter Script V</source>
          <target state="translated">拉丁文小字V(带钩)/拉丁文小字书法V(带钩)</target>
        </trans-unit>
        <trans-unit id="6a5f81b7b582dc216e4c1f24b62d26cf5af68967" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Z With Retroflex Hook / Latin Small Letter Z Retroflex Hook</source>
          <target state="translated">拉丁语小字母Z带回形钩/拉丁语小字母Z回形钩</target>
        </trans-unit>
        <trans-unit id="e2c17f6ce613463c3e30d1a4aed82bceb3d0bf26" translate="yes" xml:space="preserve">
          <source>Latin Small Ligature Oe / Latin Small Letter O E</source>
          <target state="translated">拉丁文小字Oe/拉丁文小字O E.</target>
        </trans-unit>
        <trans-unit id="ab095c443113e11acf431c2bb30a86ce8ce57bb6" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter A</source>
          <target state="translated">拉丁文下标小字母A</target>
        </trans-unit>
        <trans-unit id="fff77fcf01dc719ec1ab77e81e213e93b8d0115a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter E</source>
          <target state="translated">拉丁文下标小字母E</target>
        </trans-unit>
        <trans-unit id="363c386941760c298d65628800930f8354b1c700" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter H</source>
          <target state="translated">拉丁字母小字H</target>
        </trans-unit>
        <trans-unit id="982401be038720a241d1e68deecf4cf7746b55ab" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter I</source>
          <target state="translated">拉丁文下标小字母I</target>
        </trans-unit>
        <trans-unit id="f36b34411ebc69050abaa08db12014b29b018b19" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter J</source>
          <target state="translated">拉丁文下标小字母J</target>
        </trans-unit>
        <trans-unit id="5d9192cce944b6338e9e19cf0e5aff75bc6458e0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter K</source>
          <target state="translated">拉丁文下标小字母K</target>
        </trans-unit>
        <trans-unit id="98e7def8db7a6c66ec697114dd36225f86e432d0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter L</source>
          <target state="translated">拉丁字母小字L</target>
        </trans-unit>
        <trans-unit id="c88fe2a6e8d4931c9b29a2de9c39672213e2a09e" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter M</source>
          <target state="translated">拉丁字母小字M</target>
        </trans-unit>
        <trans-unit id="09020dd38fd21fc2f0e9c9b2f5cd4719b876181a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter N</source>
          <target state="translated">拉丁文下标小字母N</target>
        </trans-unit>
        <trans-unit id="bf874a171794f22663d7decf77255804ee48a4b5" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter O</source>
          <target state="translated">拉丁文下标小字母O</target>
        </trans-unit>
        <trans-unit id="2f2d68aab8bef5631b7658f2f25cb157fe1312d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter P</source>
          <target state="translated">拉丁字母小字P</target>
        </trans-unit>
        <trans-unit id="6ae5998c63d2b847c715037212f1596e577e11d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter R</source>
          <target state="translated">拉丁字母小字R</target>
        </trans-unit>
        <trans-unit id="cbfb24f449387bbaf3bab5247af9c1ad7c5a2e87" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter S</source>
          <target state="translated">拉丁字母小字S</target>
        </trans-unit>
        <trans-unit id="54984068e00469db35d3a41626ebb9a634073396" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter Schwa</source>
          <target state="translated">拉丁文下标小字Schwa</target>
        </trans-unit>
        <trans-unit id="24e9ea8cb7bc17431bfd5069bebcda4cd2e0d7f4" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter T</source>
          <target state="translated">拉丁字母小字T</target>
        </trans-unit>
        <trans-unit id="c11091f07852038d224bf6a198262288070ac4af" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter U</source>
          <target state="translated">拉丁字母小字U</target>
        </trans-unit>
        <trans-unit id="59e0fc501529d38b3e42a1402845967ae6868b9c" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter V</source>
          <target state="translated">拉丁文下标小字母V</target>
        </trans-unit>
        <trans-unit id="87def54837d4f750a3ac2cc91c670222eecf573b" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter X</source>
          <target state="translated">拉丁字母小字X</target>
        </trans-unit>
        <trans-unit id="96f66def5d4a8c399dd4712422d81130f5b17cc9" translate="yes" xml:space="preserve">
          <source>Launches worker processes via the specified cluster manager.</source>
          <target state="translated">通过指定的群集管理器启动工人进程。</target>
        </trans-unit>
        <trans-unit id="230ffdc98fdacb0f873a14dccabfdda12422305b" translate="yes" xml:space="preserve">
          <source>Launches workers using the in-built &lt;code&gt;LocalManager&lt;/code&gt; which only launches workers on the local host. This can be used to take advantage of multiple cores. &lt;code&gt;addprocs(4)&lt;/code&gt; will add 4 processes on the local machine. If &lt;code&gt;restrict&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, binding is restricted to &lt;code&gt;127.0.0.1&lt;/code&gt;. Keyword args &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;exename&lt;/code&gt;, &lt;code&gt;exeflags&lt;/code&gt;, &lt;code&gt;topology&lt;/code&gt;, &lt;code&gt;lazy&lt;/code&gt; and &lt;code&gt;enable_threaded_blas&lt;/code&gt; have the same effect as documented for &lt;code&gt;addprocs(machines)&lt;/code&gt;.</source>
          <target state="translated">使用内置的 &lt;code&gt;LocalManager&lt;/code&gt; 启动工作程序，该程序仅在本地主机上启动工作程序。这可用于利用多个内核。 &lt;code&gt;addprocs(4)&lt;/code&gt; 将在本地计算机上添加4个进程。如果 &lt;code&gt;restrict&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则绑定限制为 &lt;code&gt;127.0.0.1&lt;/code&gt; 。关键字args &lt;code&gt;dir&lt;/code&gt; ， &lt;code&gt;exename&lt;/code&gt; ， &lt;code&gt;exeflags&lt;/code&gt; ， &lt;code&gt;topology&lt;/code&gt; ， &lt;code&gt;lazy&lt;/code&gt; 和 &lt;code&gt;enable_threaded_blas&lt;/code&gt; 具有与 &lt;code&gt;addprocs(machines)&lt;/code&gt; 相同的效果。</target>
        </trans-unit>
        <trans-unit id="5651fa0fd68350a3db0e0ce46acc644a6f99f032" translate="yes" xml:space="preserve">
          <source>Lazy adjoint (conjugate transposition) (also postfix &lt;code&gt;'&lt;/code&gt;). Note that &lt;code&gt;adjoint&lt;/code&gt; is applied recursively to elements.</source>
          <target state="translated">懒惰伴随（共轭换位）（也是后缀 &lt;code&gt;'&lt;/code&gt; ）。请注意， &lt;code&gt;adjoint&lt;/code&gt; 是递归地应用于元素。</target>
        </trans-unit>
        <trans-unit id="4dabe105e2961d8642efb76e1ebd7539fca5122b" translate="yes" xml:space="preserve">
          <source>Lazy transpose. Mutating the returned object should appropriately mutate &lt;code&gt;A&lt;/code&gt;. Often, but not always, yields &lt;code&gt;Transpose(A)&lt;/code&gt;, where &lt;code&gt;Transpose&lt;/code&gt; is a lazy transpose wrapper. Note that this operation is recursive.</source>
          <target state="translated">懒惰转置。变异返回的对象应该适当地发生变异 &lt;code&gt;A&lt;/code&gt; 。通常但并非总是产生 &lt;code&gt;Transpose(A)&lt;/code&gt; ，其中 &lt;code&gt;Transpose&lt;/code&gt; 是一个懒惰的转置包装器。请注意，此操作是递归的。</target>
        </trans-unit>
        <trans-unit id="52790bab6c96ca4ca79f6c9dcbc5f04f90742a02" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for a transpose view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Transpose&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">底层线性代数对象的转置视图的惰性包装器类型，通常是 &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; ，但也可以包含一些 &lt;code&gt;Factorization&lt;/code&gt; 。通常，不应直接调用 &lt;code&gt;Transpose&lt;/code&gt; 构造函数，而应使用&lt;a href=&quot;#Base.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; &lt;/a&gt;。要实现视图，请使用&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea87c3f92c6c2a81bda14868b1fa3651e1788be6" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for an adjoint view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Adjoint&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.adjoint&quot;&gt;&lt;code&gt;adjoint&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">底层线性代数对象的伴随视图的惰性包装类型，例如通常是 &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; ，但也可以包含一些 &lt;code&gt;Factorization&lt;/code&gt; 。通常，不应直接调用 &lt;code&gt;Adjoint&lt;/code&gt; 构造函数，而应使用&lt;a href=&quot;#Base.adjoint&quot;&gt; &lt;code&gt;adjoint&lt;/code&gt; &lt;/a&gt;。要实现视图，请使用&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c31303ce475bc8493699e997a666b0db70d41d90" translate="yes" xml:space="preserve">
          <source>Leaf Fluttering In Wind</source>
          <target state="translated">叶子在风中飞舞</target>
        </trans-unit>
        <trans-unit id="22d214839b787ba0cbf83b35c8637e398eb00b60" translate="yes" xml:space="preserve">
          <source>Least common (non-negative) multiple.</source>
          <target state="translated">最不常见的(非负数)倍数。</target>
        </trans-unit>
        <trans-unit id="1aa2f31ee7ccbdf2fc8c6c567cdca2fb29dac2a6" translate="yes" xml:space="preserve">
          <source>Ledger</source>
          <target state="translated">Ledger</target>
        </trans-unit>
        <trans-unit id="8ae1c34bd37fad49cc5f8e02da648a78e89c3ed8" translate="yes" xml:space="preserve">
          <source>Left</source>
          <target state="translated">Left</target>
        </trans-unit>
        <trans-unit id="75d0899e95136f2da4eac284be2b987384e5c533" translate="yes" xml:space="preserve">
          <source>Left Arrow With Circled Plus</source>
          <target state="translated">左箭头带圆圈加号</target>
        </trans-unit>
        <trans-unit id="72aee17ac3f066d41059e365fe7ffff8c87f2b40" translate="yes" xml:space="preserve">
          <source>Left Arrow With Small Circle</source>
          <target state="translated">左箭头带小圆圈</target>
        </trans-unit>
        <trans-unit id="e4186034491319e4fea56b94c110018858b681a3" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Down Harpoon</source>
          <target state="translated">左侧倒钩向下 右侧倒钩向下 鱼叉</target>
        </trans-unit>
        <trans-unit id="ae21e1eb75451dd870d85a61a1cfa6bc8df2ba78" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Up Harpoon</source>
          <target state="translated">左倒钩向下 右倒钩向上 鱼叉</target>
        </trans-unit>
        <trans-unit id="bcae4f39e04c712debc4107f48695498ba926272" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Down Harpoon</source>
          <target state="translated">左侧倒钩向上 右侧倒钩向下 鱼叉</target>
        </trans-unit>
        <trans-unit id="f15664f5c11100645f7ec0fc503d10e242c811c4" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Up Harpoon</source>
          <target state="translated">左侧倒钩向上 右侧倒钩向上 鱼叉</target>
        </trans-unit>
        <trans-unit id="a3c4bf704acbb06ce3404e8185007c7d40dd50dc" translate="yes" xml:space="preserve">
          <source>Left Ceiling</source>
          <target state="translated">左天花板</target>
        </trans-unit>
        <trans-unit id="72a9f53c8c863fcc58b749c2d802910b9dd69204" translate="yes" xml:space="preserve">
          <source>Left Double Quotation Mark / Double Turned Comma Quotation Mark</source>
          <target state="translated">左侧双引号/双转逗号引号</target>
        </trans-unit>
        <trans-unit id="33ab45e60f973d03d477e320c9c21d10102209f2" translate="yes" xml:space="preserve">
          <source>Left Floor</source>
          <target state="translated">左层</target>
        </trans-unit>
        <trans-unit id="acdcba05803275d77a8ff9d944d257c2f355cc32" translate="yes" xml:space="preserve">
          <source>Left Half Black Circle</source>
          <target state="translated">左半边黑色圆环</target>
        </trans-unit>
        <trans-unit id="98f2260c432833cdcda74a0d3fd1bcf7149895fd" translate="yes" xml:space="preserve">
          <source>Left Half Block</source>
          <target state="translated">左半块</target>
        </trans-unit>
        <trans-unit id="b2d1cb4617e2395b9bcddfaba836b4ff2e6e68a3" translate="yes" xml:space="preserve">
          <source>Left Luggage</source>
          <target state="translated">左侧行李箱</target>
        </trans-unit>
        <trans-unit id="6fc8b4239d1345e60f61ab6561b7d80a0e196edc" translate="yes" xml:space="preserve">
          <source>Left Normal Factor Semidirect Product</source>
          <target state="translated">左法向系数半间接产品</target>
        </trans-unit>
        <trans-unit id="a759ee17e030c9538e681ee56e56b5128b9fcd58" translate="yes" xml:space="preserve">
          <source>Left Outer Join</source>
          <target state="translated">左外侧加入</target>
        </trans-unit>
        <trans-unit id="bea5ba9ebfbff15c8175b8c30772408ad172251f" translate="yes" xml:space="preserve">
          <source>Left Right Arrow</source>
          <target state="translated">左右箭头</target>
        </trans-unit>
        <trans-unit id="92b57eec514e84ae8d71456c14f7cff82b10a548" translate="yes" xml:space="preserve">
          <source>Left Right Arrow Through Small Circle</source>
          <target state="translated">左右箭头穿过小圆圈</target>
        </trans-unit>
        <trans-unit id="8f9b98c29f15c9b6eaf2eadce9578f5dc5b96041" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Double Vertical Stroke</source>
          <target state="translated">左右箭头双竖笔</target>
        </trans-unit>
        <trans-unit id="09fe21e697a5fa104980be3384a847b808e4d81a" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Stroke</source>
          <target state="translated">左右箭头与笔画</target>
        </trans-unit>
        <trans-unit id="c3c516b47151666dadcf1dd0a1b3b7ab23f3f3ab" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Vertical Stroke</source>
          <target state="translated">左右箭头与垂直笔画</target>
        </trans-unit>
        <trans-unit id="4f5213e5966d1dc7812d67e6434bf47c9574b0b4" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow</source>
          <target state="translated">左右双箭头</target>
        </trans-unit>
        <trans-unit id="83ed63f2653f9ec7aef827c095dc0fd80a9657f8" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Stroke</source>
          <target state="translated">左右双箭头加笔画</target>
        </trans-unit>
        <trans-unit id="a2ff1377f747643672f8858987628f93747b7eb2" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Vertical Stroke</source>
          <target state="translated">左右双箭头垂直划线</target>
        </trans-unit>
        <trans-unit id="172365e73cff74845a1277eb1fb198684eed94bd" translate="yes" xml:space="preserve">
          <source>Left Right Open-Headed Arrow</source>
          <target state="translated">左 右 开头箭头</target>
        </trans-unit>
        <trans-unit id="8055689a32aa93576b189b393a7f7e70b68fbc3d" translate="yes" xml:space="preserve">
          <source>Left Right Wave Arrow</source>
          <target state="translated">左右波浪箭</target>
        </trans-unit>
        <trans-unit id="37d876c1c2c475cd47f27703a88e7f2f9166fd62" translate="yes" xml:space="preserve">
          <source>Left Semidirect Product</source>
          <target state="translated">左半间接产品</target>
        </trans-unit>
        <trans-unit id="62324b102cc4b4bf016fb9203c38bec07856133a" translate="yes" xml:space="preserve">
          <source>Left Single Quotation Mark / Single Turned Comma Quotation Mark</source>
          <target state="translated">左侧单引号/单转逗号引号</target>
        </trans-unit>
        <trans-unit id="19e4168df09f34516f6fddcc4e445fc021594bcb" translate="yes" xml:space="preserve">
          <source>Left Square Bracket Lower Corner</source>
          <target state="translated">左方托架下角</target>
        </trans-unit>
        <trans-unit id="ac1fd430a7759464f468517dfa51418639f0abf8" translate="yes" xml:space="preserve">
          <source>Left Tack</source>
          <target state="translated">左后卫</target>
        </trans-unit>
        <trans-unit id="07241f21177a787dd3313c67746b03f50c2d9592" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar</source>
          <target state="translated">竖条旁的左三角</target>
        </trans-unit>
        <trans-unit id="3b3a0479d1df49711a0b5dda01c8a9f250ee53e9" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">竖条旁的左三角+组合长实心叠加/无间隔长斜线叠加。</target>
        </trans-unit>
        <trans-unit id="24f6c1c79f67d997809b3110481aa58d9f740e6a" translate="yes" xml:space="preserve">
          <source>Left Vertical Box Line</source>
          <target state="translated">左侧垂直框线</target>
        </trans-unit>
        <trans-unit id="e2e904284d118de6f14c002567a428193497055e" translate="yes" xml:space="preserve">
          <source>Left arrow, &lt;code&gt;^B&lt;/code&gt;</source>
          <target state="translated">左箭头 &lt;code&gt;^B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43c75bdc1fa38ddb43ed3abfdf3e4dda383f45ac" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;B&lt;/code&gt; with elements shifted &lt;code&gt;n&lt;/code&gt; positions backwards, filling with &lt;code&gt;false&lt;/code&gt; values. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, elements are shifted forwards. Equivalent to &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">左移位运算符 &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt; 。当 &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; ，结果为 &lt;code&gt;B&lt;/code&gt; ，元素向后移动 &lt;code&gt;n&lt;/code&gt; 个位置，并填充 &lt;code&gt;false&lt;/code&gt; 值。如果 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; ，则元素向前移动。等效于 &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="700db7c2e4663e2dc271d4c36173f17b6c63b025" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;x&lt;/code&gt; shifted left by &lt;code&gt;n&lt;/code&gt; bits, filling with &lt;code&gt;0&lt;/code&gt;s. This is equivalent to &lt;code&gt;x * 2^n&lt;/code&gt;. For &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, this is equivalent to &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">左移位运算符， &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt; 。对于 &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; ，结果将 &lt;code&gt;x&lt;/code&gt; 左移 &lt;code&gt;n&lt;/code&gt; 位，以 &lt;code&gt;0&lt;/code&gt; s 填充。这等效于 &lt;code&gt;x * 2^n&lt;/code&gt; 。对于 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; ，这等效于 &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47e029a3c897df6f4c0de3d067011451de3151f3" translate="yes" xml:space="preserve">
          <source>Left division operator: multiplication of &lt;code&gt;y&lt;/code&gt; by the inverse of &lt;code&gt;x&lt;/code&gt; on the left. Gives floating-point results for integer arguments.</source>
          <target state="translated">左除法运算符： &lt;code&gt;y&lt;/code&gt; 乘以左边 &lt;code&gt;x&lt;/code&gt; 的倒数。给出整数参数的浮点结果。</target>
        </trans-unit>
        <trans-unit id="5ddde4aec1f53e97b5a1f34009e407e1cb187578" translate="yes" xml:space="preserve">
          <source>Left-Pointing Magnifying Glass</source>
          <target state="translated">左旋式放大镜</target>
        </trans-unit>
        <trans-unit id="35088a4f27322015e328e0637be16cff0df478d9" translate="yes" xml:space="preserve">
          <source>Left-rotate matrix &lt;code&gt;A&lt;/code&gt; 90 degrees counterclockwise an integer &lt;code&gt;k&lt;/code&gt; number of times. If &lt;code&gt;k&lt;/code&gt; is a multiple of four (including zero), this is equivalent to a &lt;code&gt;copy&lt;/code&gt;.</source>
          <target state="translated">左旋转矩阵 &lt;code&gt;A&lt;/code&gt; 逆时针旋转90度，整数倍 &lt;code&gt;k&lt;/code&gt; 次。如果 &lt;code&gt;k&lt;/code&gt; 是4的倍数（包括零），则等效于 &lt;code&gt;copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af413d32c0aefe9e0a6c5345832116ac3819cfc9" translate="yes" xml:space="preserve">
          <source>Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</source>
          <target state="translated">Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b0da9967a31e27b91c5f79f61cda48210161da5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow / Left Arrow</source>
          <target state="translated">向左箭头/左箭头</target>
        </trans-unit>
        <trans-unit id="bb62e777d053b849a3960927799605c68d6f5eca" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Almost Equal To</source>
          <target state="translated">向左上方的箭头几乎等于</target>
        </trans-unit>
        <trans-unit id="c453288b80fc56c56e06ba24b30f84f5dac9e172" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Almost Equal To</source>
          <target state="translated">反面上方的左向箭头几乎等于</target>
        </trans-unit>
        <trans-unit id="c80976998c602bbf7e0960e57864b997e7fa3170" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Tilde Operator</source>
          <target state="translated">反向倾斜操作器上方的向左箭头。</target>
        </trans-unit>
        <trans-unit id="b339bc529a24441191ee0d608b29a79c5db84b52" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar / Left Arrow From Bar</source>
          <target state="translated">向左箭头从栏杆开始/向左箭头从栏杆开始</target>
        </trans-unit>
        <trans-unit id="1e84d429549228a5c098aec3446031d7ead6505a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar To Black Diamond</source>
          <target state="translated">向左箭头从酒吧到黑钻石</target>
        </trans-unit>
        <trans-unit id="3b47b1dfc544dad6abdaf2ebcb4206c54487efc5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Over Rightwards Arrow / Left Arrow Over Right Arrow</source>
          <target state="translated">向左箭头高于向右箭头/向左箭头高于向右箭头。</target>
        </trans-unit>
        <trans-unit id="ae9989b5442d5772a5dadc97fcf089e63cd8bb1f" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Through X</source>
          <target state="translated">向左箭头穿过X</target>
        </trans-unit>
        <trans-unit id="ae63102c5c00038eb021088d9b27a739caf11f6e" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar / Left Arrow To Bar</source>
          <target state="translated">向左箭头到栏杆/向左箭头到栏杆</target>
        </trans-unit>
        <trans-unit id="ba54e194d48c6e6846ca63e167eaa511daf10b83" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar Over Rightwards Arrow To Bar / Left Arrow To Bar Over Right Arrow To Bar</source>
          <target state="translated">向左箭头转杠高于向右箭头转杠/向左箭头转杠高于向右箭头转杠。</target>
        </trans-unit>
        <trans-unit id="352323837c59795cd0e83f313a7f1aad09357b67" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Black Diamond</source>
          <target state="translated">向左箭头至黑钻石</target>
        </trans-unit>
        <trans-unit id="0dbfe3aca18f61d6f1a6e05b8ae3c26d1725c775" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Dotted Stem</source>
          <target state="translated">向左箭头,带点状茎</target>
        </trans-unit>
        <trans-unit id="b5f4b7ef2746d70757e6dc984fb3961f86960c29" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Double Vertical Stroke</source>
          <target state="translated">向左箭头,双垂直笔画</target>
        </trans-unit>
        <trans-unit id="42e353d97e79c0c1b091dc7d9378f532aaef3b3d" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Hook / Left Arrow With Hook</source>
          <target state="translated">向左箭头带钩/左箭头带钩</target>
        </trans-unit>
        <trans-unit id="023d9a3502015dcd3b3f76fa14c946cbbc2d6f32" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Loop / Left Arrow With Loop</source>
          <target state="translated">向左箭头带环/向左箭头带环。</target>
        </trans-unit>
        <trans-unit id="9e22f7f96528d90c3397d6b157c1fdc2594ea742" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Plus Below</source>
          <target state="translated">向左箭头,下方为加号</target>
        </trans-unit>
        <trans-unit id="cc480573c42bb17cb0e2940abfedd3c8ea38e8ea" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Stroke / Left Arrow With Stroke</source>
          <target state="translated">向左箭头加笔画/左箭头加笔画。</target>
        </trans-unit>
        <trans-unit id="52d1604edf7ef87df0bdda8c2b40df8871c49a60" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail / Left Arrow With Tail</source>
          <target state="translated">向左箭尾/向左箭尾</target>
        </trans-unit>
        <trans-unit id="88f9604cfadba8964cc29be77251abe676f9051a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">向左箭头,带尾巴,双垂直行程。</target>
        </trans-unit>
        <trans-unit id="390234b436d1a22d91a1f9368ac90420d25a50f9" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Vertical Stroke</source>
          <target state="translated">向左箭头,尾部有垂直行程</target>
        </trans-unit>
        <trans-unit id="11ebeb1eafd67ffeeffad131d7ac82c3b52085be" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Vertical Stroke</source>
          <target state="translated">向左箭头与垂直行程</target>
        </trans-unit>
        <trans-unit id="c87c24a3eb1d8323b9fa96777c93ec260174835d" translate="yes" xml:space="preserve">
          <source>Leftwards Black Arrow</source>
          <target state="translated">左向黑箭</target>
        </trans-unit>
        <trans-unit id="33cfca8919d0753ef59ada74348c2a4c4b3bf344" translate="yes" xml:space="preserve">
          <source>Leftwards Dashed Arrow / Left Dashed Arrow</source>
          <target state="translated">向左虚线/向左虚线</target>
        </trans-unit>
        <trans-unit id="8a19ba0a75d89ee68704a7ebb90ffd71f1e1b278" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow / Left Double Arrow</source>
          <target state="translated">向左双箭头/左双箭头</target>
        </trans-unit>
        <trans-unit id="60c9a06f1f5b3ab83b89088f525d893f40459a8e" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow From Bar</source>
          <target state="translated">向左转双箭头 从酒吧</target>
        </trans-unit>
        <trans-unit id="0d8615420d5ad768b1f26184a0a7a40704148a7d" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Stroke / Left Double Arrow With Stroke</source>
          <target state="translated">向左双箭头加笔画/向左双箭头加笔画。</target>
        </trans-unit>
        <trans-unit id="4f6b99ebd5ed363e088c4f88602ef903b8e06f64" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Vertical Stroke</source>
          <target state="translated">向左的双箭头,带垂直笔画</target>
        </trans-unit>
        <trans-unit id="4f794063524482bcc21c38eae616ca798ede37a8" translate="yes" xml:space="preserve">
          <source>Leftwards Double Dash Arrow</source>
          <target state="translated">向左双冲箭头</target>
        </trans-unit>
        <trans-unit id="39e96a986704f562e46fbf1d03e4f9e54add9f77" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon Over Rightwards Harpoon / Left Harpoon Over Right Harpoon</source>
          <target state="translated">向左鱼叉胜向右鱼叉/向左鱼叉胜向右鱼叉。</target>
        </trans-unit>
        <trans-unit id="690c48df2218ae792864eaf9456cf6955b424427" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Above Rightwards Harpoon With Barb Down</source>
          <target state="translated">向左的鱼叉,上面有倒刺 向右的鱼叉,下面有倒刺。</target>
        </trans-unit>
        <trans-unit id="2a8c5adb9efda04b9d2fabf980287f590ba155e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Below Long Dash</source>
          <target state="translated">左向鱼叉带倒钩下长冲程</target>
        </trans-unit>
        <trans-unit id="d60c5396df85f38cca433173bdcae8dd56a90b18" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down From Bar</source>
          <target state="translated">左向鱼叉,带倒钩,从棒子上向下。</target>
        </trans-unit>
        <trans-unit id="93c5200b6461e9ba3314eb9a0b244de1ac0949de" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down To Bar</source>
          <target state="translated">左向鱼叉,带倒钩,下至棒状物</target>
        </trans-unit>
        <trans-unit id="b6d93e8905d73cadcac079a3790b467b97f9e3ec" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Downwards / Left Harpoon With Barb Down</source>
          <target state="translated">向左的鱼叉带倒刺向下/向左的鱼叉带倒刺向下。</target>
        </trans-unit>
        <trans-unit id="662b3d2cbb862798f1987f0dd2c11e4c77a5182f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Down</source>
          <target state="translated">左向鱼叉,上方有倒钩 左向鱼叉,下方有倒钩</target>
        </trans-unit>
        <trans-unit id="b0567c46db77bd91abd63923235b4420e5bd82e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Long Dash</source>
          <target state="translated">向左的鱼叉,带倒钩的长冲程以上。</target>
        </trans-unit>
        <trans-unit id="0084ef3852a19447620ab7c0dfc2d2b12aeeb77d" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Up</source>
          <target state="translated">左向鱼叉,上面有倒钩 右向鱼叉,上面有倒钩</target>
        </trans-unit>
        <trans-unit id="730216336dfd2e32435830075fdb2df0dfaa397f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up From Bar</source>
          <target state="translated">左向鱼叉,带倒钩,从棒子上起</target>
        </trans-unit>
        <trans-unit id="4cbc38b13463300c356dd264e992f7457f26d5f3" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up To Bar</source>
          <target state="translated">向左的鱼叉,带倒钩,向上至棒状物</target>
        </trans-unit>
        <trans-unit id="42c26ac6b35b0c13895bf055d9cecb545b0ec09a" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Upwards / Left Harpoon With Barb Up</source>
          <target state="translated">向左的鱼叉与向上的倒钩/向左的鱼叉与向上的倒钩。</target>
        </trans-unit>
        <trans-unit id="5439409c437a7e20e57d117b3dc53bfc59be5b1e" translate="yes" xml:space="preserve">
          <source>Leftwards Open-Headed Arrow</source>
          <target state="translated">向左开头箭头</target>
        </trans-unit>
        <trans-unit id="fb802d31c4d84700fe501788c56f0616bde89895" translate="yes" xml:space="preserve">
          <source>Leftwards Paired Arrows / Left Paired Arrows</source>
          <target state="translated">左向成对箭头/左向成对箭头。</target>
        </trans-unit>
        <trans-unit id="1e30b6357af1b8210adc5e8500513f1780a44b86" translate="yes" xml:space="preserve">
          <source>Leftwards Quadruple Arrow</source>
          <target state="translated">向左四箭头</target>
        </trans-unit>
        <trans-unit id="e990b5a5a1b8966a349729643a9904c9a464f8f2" translate="yes" xml:space="preserve">
          <source>Leftwards Squiggle Arrow / Left Squiggle Arrow</source>
          <target state="translated">向左曲折箭头/向左曲折箭头。</target>
        </trans-unit>
        <trans-unit id="40ef7c42edfad6e4a2b0c741f7a2e57b2d0a3d17" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Arrow / Left Triple Arrow</source>
          <target state="translated">向左三箭头/左三箭头</target>
        </trans-unit>
        <trans-unit id="e443b0f54a32ffe38d3c2940e3150615527deb02" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Dash Arrow</source>
          <target state="translated">向左三冲箭头</target>
        </trans-unit>
        <trans-unit id="0e6ace611eb46c42c60ebf869526d6d80107ee54" translate="yes" xml:space="preserve">
          <source>Leftwards Two Headed Arrow / Left Two Headed Arrow</source>
          <target state="translated">向左双头箭/向左双头箭。</target>
        </trans-unit>
        <trans-unit id="73e956493780be5029f93be5ee242950d63a7b37" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow From Bar</source>
          <target state="translated">向左的双头箭头 从酒吧</target>
        </trans-unit>
        <trans-unit id="c8fe728344df16251ef3411400150ba0b2c50044" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Double Vertical Stroke</source>
          <target state="translated">向左的双头箭,双垂直行程。</target>
        </trans-unit>
        <trans-unit id="19a7c2f943c6a266d93318b4faccd25877a453bc" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail</source>
          <target state="translated">向左的双头尾箭</target>
        </trans-unit>
        <trans-unit id="fad45cb4bffed0212e02a7dd5b2b9636aeff862a" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">左向双头箭,尾部有双垂直行程</target>
        </trans-unit>
        <trans-unit id="5354b323327ab9574144f2502eac42843f5fcc1b" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Vertical Stroke</source>
          <target state="translated">向左的双头箭,尾部有垂直行程</target>
        </trans-unit>
        <trans-unit id="be95b8e9e0c8c9337712cb0f314c9ab2a05f3613" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Vertical Stroke</source>
          <target state="translated">向左的双头箭,竖直笔画</target>
        </trans-unit>
        <trans-unit id="43f10f58eb0471f466412a154b6c2de8a4b85793" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Triple Dash Arrow</source>
          <target state="translated">向左的双头三冲箭头</target>
        </trans-unit>
        <trans-unit id="54be3ecc08f6dfc79a630a29d3be179ecc6e1de9" translate="yes" xml:space="preserve">
          <source>Leftwards Wave Arrow / Left Wave Arrow</source>
          <target state="translated">向左波浪箭/左波浪箭</target>
        </trans-unit>
        <trans-unit id="a8988dc4aff78fbf3d6dec72ae6a15340f71c39b" translate="yes" xml:space="preserve">
          <source>Leftwards White Arrow / White Left Arrow</source>
          <target state="translated">左向白箭/左向白箭</target>
        </trans-unit>
        <trans-unit id="53789e63c0a26b06f6ee3389f57916b3259c1e85" translate="yes" xml:space="preserve">
          <source>Legend:</source>
          <target state="translated">Legend:</target>
        </trans-unit>
        <trans-unit id="4459b791a680572873dc2cf033487dc21edfcb9c" translate="yes" xml:space="preserve">
          <source>Lemon</source>
          <target state="translated">Lemon</target>
        </trans-unit>
        <trans-unit id="cfaf50ac3721461bd3a2d27ef5f35e144901fbb6" translate="yes" xml:space="preserve">
          <source>Leo</source>
          <target state="translated">Leo</target>
        </trans-unit>
        <trans-unit id="3ee924e59f48f89881e4cde275cb373a5ca3ccb1" translate="yes" xml:space="preserve">
          <source>Leopard</source>
          <target state="translated">Leopard</target>
        </trans-unit>
        <trans-unit id="2b515baec988fd996a77420ccdf808df339479aa" translate="yes" xml:space="preserve">
          <source>Less-Than Above Double-Line Equal Above Greater-Than</source>
          <target state="translated">小于双线以上 平于大线以上</target>
        </trans-unit>
        <trans-unit id="5132ce6dbd42eef8696f2795c98fbde608c55ddc" translate="yes" xml:space="preserve">
          <source>Less-Than Above Greater-Than Above Double-Line Equal</source>
          <target state="translated">小于以上 大于以上 双线相等</target>
        </trans-unit>
        <trans-unit id="0996bf12be96a0c9cfd35d9c3d1cd4d7ae0dc489" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Above Greater-Than</source>
          <target state="translated">小于以上 类似以上 大于以上</target>
        </trans-unit>
        <trans-unit id="f47dca757b69c3cbb5c4318a3148b185aa51ad59" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Or Equal</source>
          <target state="translated">少于或高于类似或相等</target>
        </trans-unit>
        <trans-unit id="d46f5f3bf1beaa31682309e60c70c4c4589a153d" translate="yes" xml:space="preserve">
          <source>Less-Than Above Slanted Equal Above Greater-Than Above Slanted Equal</source>
          <target state="translated">小于等于斜上方 大于等于斜上方</target>
        </trans-unit>
        <trans-unit id="713b9a189c39738ac2705479504dc75c64634c14" translate="yes" xml:space="preserve">
          <source>Less-Than And Not Approximate</source>
          <target state="translated">小于且非近似值</target>
        </trans-unit>
        <trans-unit id="2796bb948b259786fd87ad28f516271749c20d52" translate="yes" xml:space="preserve">
          <source>Less-Than And Single-Line Not Equal To</source>
          <target state="translated">少线和单线不等于单线。</target>
        </trans-unit>
        <trans-unit id="709360d5eb9bea213909aadcf59a29aa892cbe75" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To</source>
          <target state="translated">小于但不等于/小于但不等于的标准。</target>
        </trans-unit>
        <trans-unit id="e453412818d96e7a4f420ee26bac5ea434246d68" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">小于但不等于/小于但不等于+变量选择器-1。</target>
        </trans-unit>
        <trans-unit id="2f4b9cde7d599f1fdfcdcd2d149da1761281cf59" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equivalent To / Less Than But Not Equivalent To</source>
          <target state="translated">小于但不等于/小于但不等于......。</target>
        </trans-unit>
        <trans-unit id="d47b00bfbef46bd9077401979c412c7c9f4f06db" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve</source>
          <target state="translated">小于闭合曲线</target>
        </trans-unit>
        <trans-unit id="e9bc15ca0894be74c91d83dd7307ed3d4d198f47" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">小于闭合的曲线上面的斜面相等</target>
        </trans-unit>
        <trans-unit id="22c4db9e780b7f321b3a098f0b550b5d05360802" translate="yes" xml:space="preserve">
          <source>Less-Than Equal To Or Greater-Than / Less Than Equal To Or Greater Than</source>
          <target state="translated">小于等于或大于等于/小于等于或大于大于</target>
        </trans-unit>
        <trans-unit id="125980c6753f24cfef91a7aee66e7177aefa9911" translate="yes" xml:space="preserve">
          <source>Less-Than Or Approximate</source>
          <target state="translated">小于或近似</target>
        </trans-unit>
        <trans-unit id="c6b5679738cc00d2db14ba6a2056c401ded59619" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equal To / Less Than Or Equal To</source>
          <target state="translated">少于或等于/少于或等于</target>
        </trans-unit>
        <trans-unit id="35d27cfb30206b75fdeb27b601c10d1aad047c85" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equivalent To / Less Than Or Equivalent To</source>
          <target state="translated">小于或等同于/小于或等同于</target>
        </trans-unit>
        <trans-unit id="b9b477ee81eb35999da4d54deb44ce4b860fe5f0" translate="yes" xml:space="preserve">
          <source>Less-Than Or Greater-Than / Less Than Or Greater Than</source>
          <target state="translated">小于或大于/小于或大于</target>
        </trans-unit>
        <trans-unit id="cfd32ee1a60232f0de86d5e566782496b87faa45" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To</source>
          <target state="translated">小于或斜于</target>
        </trans-unit>
        <trans-unit id="c2210b5afd5a3271bd637771d340007b9651af50" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">小于或斜于+组合长实心叠加/无间隔长斜线叠加。</target>
        </trans-unit>
        <trans-unit id="a5250f1e7fd00d514cf7de98b151fff6e960ca41" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">小于或斜于等于与点以上</target>
        </trans-unit>
        <trans-unit id="08ee594bef0f1ebfc9a347365790474b8aa06aae" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above Right</source>
          <target state="translated">小于或斜于等于右上角有点的地方</target>
        </trans-unit>
        <trans-unit id="6028a8d9f280a98196c48a63aa608f95a5002030" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">小于或斜于等于带点内侧。</target>
        </trans-unit>
        <trans-unit id="a654d5c89ef59a82d905f082b763c64619e9d053" translate="yes" xml:space="preserve">
          <source>Less-Than Over Equal To / Less Than Over Equal To</source>
          <target state="translated">低于等于以上/小于等于以上的部分</target>
        </trans-unit>
        <trans-unit id="3cd5d177f863b189035a69ddc7dc355152c827d7" translate="yes" xml:space="preserve">
          <source>Less-Than With Circle Inside</source>
          <target state="translated">小于圆圈内侧</target>
        </trans-unit>
        <trans-unit id="f5f82e2a0d06ff7d257c2989f80e7e63fdfcc406" translate="yes" xml:space="preserve">
          <source>Less-Than With Dot / Less Than With Dot</source>
          <target state="translated">小于点/小于点</target>
        </trans-unit>
        <trans-unit id="e8d2d29dc34fdea25f29dead5f22ec63a8a158fd" translate="yes" xml:space="preserve">
          <source>Less-Than With Question Mark Above</source>
          <target state="translated">小于,上面有问号</target>
        </trans-unit>
        <trans-unit id="98215ce56f609905c57ffcaa9fd368bd9a664b9f" translate="yes" xml:space="preserve">
          <source>Less-than comparison operator. Falls back to &lt;a href=&quot;../base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt;. Because of the behavior of floating-point NaN values, this operator implements a partial order.</source>
          <target state="translated">小于比较运算符。回落到&lt;a href=&quot;../base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt;。由于浮点NaN值的行为，此运算符实现了部分顺序。</target>
        </trans-unit>
        <trans-unit id="6b17017e386fc2cfd407cedbcefdc1a56529ec61" translate="yes" xml:space="preserve">
          <source>Less-than-or-equals comparison operator. Falls back to &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt;.</source>
          <target state="translated">小于等于比较运算符。回落到 &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7223264dca9d07a87ce4ee4c3f4c203febf05b3c" translate="yes" xml:space="preserve">
          <source>Let Blocks</source>
          <target state="translated">让块</target>
        </trans-unit>
        <trans-unit id="7a4b5aa264a12a56a65beda1765bedfd0c0c5b4a" translate="yes" xml:space="preserve">
          <source>Let us explore the low level construct &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; to understand how task switching works. &lt;code&gt;yieldto(task,value)&lt;/code&gt; suspends the current task, switches to the specified &lt;code&gt;task&lt;/code&gt;, and causes that task's last &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; call to return the specified &lt;code&gt;value&lt;/code&gt;. Notice that &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called &quot;symmetric coroutines&quot;; each task is switched to and from using the same mechanism.</source>
          <target state="translated">让我们探索底层构造的&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;以了解任务切换的工作原理。 &lt;code&gt;yieldto(task,value)&lt;/code&gt; 挂起当前任务，切换到指定的 &lt;code&gt;task&lt;/code&gt; ，并使该任务的最后一个&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;调用返回指定的 &lt;code&gt;value&lt;/code&gt; 。注意&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;是使用任务样式的控制流所需的唯一操作。而不是调用并返回，我们始终只是切换到其他任务。这就是为什么此功能也称为&amp;ldquo;对称协程&amp;rdquo;的原因。每个任务都使用相同的机制来回切换。</target>
        </trans-unit>
        <trans-unit id="67246c5c8735d7e8441000a86e3cb7192688e453" translate="yes" xml:space="preserve">
          <source>Let us illustrate this principle with the logical &quot;or&quot; operator &lt;code&gt;|&lt;/code&gt;. Following the rules of boolean logic, if one of the operands is &lt;code&gt;true&lt;/code&gt;, the value of the other operand does not have an influence on the result, which will always be &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">让我们用逻辑&amp;ldquo;或&amp;rdquo;运算符说明这一原理 &lt;code&gt;|&lt;/code&gt; 。遵循布尔逻辑规则，如果一个操作数为 &lt;code&gt;true&lt;/code&gt; ，则另一个操作数的值不会影响结果，该结果将始终为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5989117a8f456835a0f1be3863e508fbd507b1e1" translate="yes" xml:space="preserve">
          <source>Let us operate on this array simultaneously using 4 threads. We'll have each thread write its thread ID into each location.</source>
          <target state="translated">让我们用4个线程同时对这个数组进行操作。我们将让每个线程把它的线程ID写入每个位置。</target>
        </trans-unit>
        <trans-unit id="6183c7c4afe71ef5b8231a90fffb2c5978fa45fa" translate="yes" xml:space="preserve">
          <source>Let's consider some of the abstract types that make up Julia's numerical hierarchy:</source>
          <target state="translated">让我们考虑一下构成Julia数值层次结构的一些抽象类型。</target>
        </trans-unit>
        <trans-unit id="01a2c551d7b29ee2d56fdf88a3feffacdd9828c3" translate="yes" xml:space="preserve">
          <source>Let's define a producer task, which produces values via the &lt;code&gt;put!&lt;/code&gt; call. To consume values, we need to schedule the producer to run in a new task. A special &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; constructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel. We can then &lt;code&gt;take!&lt;/code&gt; values repeatedly from the channel object:</source>
          <target state="translated">让我们定义一个生产者任务，该任务通过 &lt;code&gt;put!&lt;/code&gt; 产生价值！呼叫。要消耗值，我们需要安排生产者在新任务中运行。接受1-arg函数作为参数的特殊&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;构造函数可用于运行绑定到Channel的任务。然后，我们可以 &lt;code&gt;take!&lt;/code&gt; 通道对象重复的值：</target>
        </trans-unit>
        <trans-unit id="9df15ca83d0947dbf1751a612bf2340b275f4ac4" translate="yes" xml:space="preserve">
          <source>Let's first discuss the two positional arguments, and later the keyword arguments:</source>
          <target state="translated">我们先讨论两个位置论点,后面再讨论关键词论点。</target>
        </trans-unit>
        <trans-unit id="6418114a78265d3efb7f605d5f750649435cf8a7" translate="yes" xml:space="preserve">
          <source>Let's jump right in with a simple example involving TCP sockets. This functionality is in a standard library package called &lt;code&gt;Sockets&lt;/code&gt;. Let's first create a simple server:</source>
          <target state="translated">让我们直接看一个涉及TCP套接字的简单示例。此功能在称为 &lt;code&gt;Sockets&lt;/code&gt; 的标准库包中。首先创建一个简单的服务器：</target>
        </trans-unit>
        <trans-unit id="1122c34c203c69e459bc638ef4ea480a5b8130e2" translate="yes" xml:space="preserve">
          <source>Let's say you want to create an &lt;code&gt;N&lt;/code&gt;-dimensional array that has size 3 along each axis. Such arrays can be created like this:</source>
          <target state="translated">假设您要创建一个 &lt;code&gt;N&lt;/code&gt; 维数组，每个轴的大小为3。这样的数组可以这样创建：</target>
        </trans-unit>
        <trans-unit id="8748cf620bf48795063bf239466aafbea94faee0" translate="yes" xml:space="preserve">
          <source>Let's set up a new environment so we may experiment. To set the active environment, use &lt;code&gt;activate&lt;/code&gt;:</source>
          <target state="translated">让我们建立一个新的环境，以便我们进行实验。要设置活动环境，请使用 &lt;code&gt;activate&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="71ba98ed632749544ae49e36ff83983c01e402b0" translate="yes" xml:space="preserve">
          <source>Let's take the following example: we implement a &lt;code&gt;Die&lt;/code&gt; type, with a variable number &lt;code&gt;n&lt;/code&gt; of sides, numbered from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. We want &lt;code&gt;rand(Die)&lt;/code&gt; to produce a die with a random number of up to 20 sides (and at least 4):</source>
          <target state="translated">让我们以下面的示例为例：我们实现一个 &lt;code&gt;Die&lt;/code&gt; 类型，其边数为 &lt;code&gt;n&lt;/code&gt; ，从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 进行编号。我们希望 &lt;code&gt;rand(Die)&lt;/code&gt; 产生一个随机数最多20面（至少4面）的模具：</target>
        </trans-unit>
        <trans-unit id="f3530d6febbeb3af1b1c75ff5864143019e5c7e9" translate="yes" xml:space="preserve">
          <source>Let's try it out. First we modify the file at &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; and add a simple function:</source>
          <target state="translated">让我们尝试一下。首先，我们在 &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; 中修改文件，并添加一个简单的函数：</target>
        </trans-unit>
        <trans-unit id="d9f3d5d59e7aa3d7e910a3c03fcdc92c22584287" translate="yes" xml:space="preserve">
          <source>Let's try this out. Starting with &lt;code&gt;julia -p n&lt;/code&gt; provides &lt;code&gt;n&lt;/code&gt; worker processes on the local machine. Generally it makes sense for &lt;code&gt;n&lt;/code&gt; to equal the number of CPU threads (logical cores) on the machine. Note that the &lt;code&gt;-p&lt;/code&gt; argument implicitly loads module &lt;code&gt;Distributed&lt;/code&gt;.</source>
          <target state="translated">让我们尝试一下。以 &lt;code&gt;julia -p n&lt;/code&gt; ，在本地计算机上提供了 &lt;code&gt;n&lt;/code&gt; 个工作进程。通常，将 &lt;code&gt;n&lt;/code&gt; 等于机器上的CPU线程（逻辑内核）数量是有意义的。注意， &lt;code&gt;-p&lt;/code&gt; 参数隐式加载模块 &lt;code&gt;Distributed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b446a4746adc500fc9039decd4f98dd1f28494be" translate="yes" xml:space="preserve">
          <source>Let's verify there are 4 threads at our disposal.</source>
          <target state="translated">让我们来验证一下有4条线在我们手上。</target>
        </trans-unit>
        <trans-unit id="a857063978f61fa4bd1f41b325d1aa75b04e9d5e" translate="yes" xml:space="preserve">
          <source>Let's work a simple example using our native threads. Let us create an array of zeros:</source>
          <target state="translated">让我们用我们的本地线程来做一个简单的例子。让我们创建一个0数组。</target>
        </trans-unit>
        <trans-unit id="01ca76f755ba1afdf88a6b78abbe4839783a3a4d" translate="yes" xml:space="preserve">
          <source>Let's work with a simple test case:</source>
          <target state="translated">让我们用一个简单的测试案例来工作。</target>
        </trans-unit>
        <trans-unit id="ee8556898b2b9f9b2564fd6a9f4e2eeba1821894" translate="yes" xml:space="preserve">
          <source>LibGit2</source>
          <target state="translated">LibGit2</target>
        </trans-unit>
        <trans-unit id="76b53f15ef89ba2bfb2e2f62f34201129332b916" translate="yes" xml:space="preserve">
          <source>Libc</source>
          <target state="translated">Libc</target>
        </trans-unit>
        <trans-unit id="60368a5f4bc52be83598e88566f2089a47f21a35" translate="yes" xml:space="preserve">
          <source>Libc.FormatMessage()</source>
          <target state="translated">Libc.FormatMessage()</target>
        </trans-unit>
        <trans-unit id="41585a339c2503f89fb1f9aa92fdc8fb9adcdd4d" translate="yes" xml:space="preserve">
          <source>Libc.GetLastError()</source>
          <target state="translated">Libc.GetLastError()</target>
        </trans-unit>
        <trans-unit id="a85a19153d65e87480d301d0383428f7125ed99b" translate="yes" xml:space="preserve">
          <source>Libc.RawFD</source>
          <target state="translated">Libc.RawFD</target>
        </trans-unit>
        <trans-unit id="b9d6e139e984d53b5bcde695421e487faedd7c51" translate="yes" xml:space="preserve">
          <source>Libc.TmStruct</source>
          <target state="translated">Libc.TmStruct</target>
        </trans-unit>
        <trans-unit id="bc871e61e3ca821c6cfe4accdd2d8e0693a588e4" translate="yes" xml:space="preserve">
          <source>Libc.calloc()</source>
          <target state="translated">Libc.calloc()</target>
        </trans-unit>
        <trans-unit id="1f4d269c85f0cdd9201cbed97992b84adebdf595" translate="yes" xml:space="preserve">
          <source>Libc.errno()</source>
          <target state="translated">Libc.errno()</target>
        </trans-unit>
        <trans-unit id="0848e3c16acc14bb2ec577b598d650c18e77b315" translate="yes" xml:space="preserve">
          <source>Libc.flush_cstdio()</source>
          <target state="translated">Libc.flush_cstdio()</target>
        </trans-unit>
        <trans-unit id="3ce556c3b59d7aa2c3af19ecb0b6877f650470df" translate="yes" xml:space="preserve">
          <source>Libc.free()</source>
          <target state="translated">Libc.free()</target>
        </trans-unit>
        <trans-unit id="b0704af4d5eaf445364159bc7d46c36ac0dd99b9" translate="yes" xml:space="preserve">
          <source>Libc.gethostname()</source>
          <target state="translated">Libc.gethostname()</target>
        </trans-unit>
        <trans-unit id="34f021f7afa28bfc40d0c964b655d57537eeeb56" translate="yes" xml:space="preserve">
          <source>Libc.getpid()</source>
          <target state="translated">Libc.getpid()</target>
        </trans-unit>
        <trans-unit id="b3ae4ddcce36b5e6214d98b8603cc79d72f7795f" translate="yes" xml:space="preserve">
          <source>Libc.malloc()</source>
          <target state="translated">Libc.malloc()</target>
        </trans-unit>
        <trans-unit id="755d16743ca50b746f3e9f832dc2d5638fe7b1d4" translate="yes" xml:space="preserve">
          <source>Libc.realloc()</source>
          <target state="translated">Libc.realloc()</target>
        </trans-unit>
        <trans-unit id="189c473490df982a84b81ce12725d8d1b054705a" translate="yes" xml:space="preserve">
          <source>Libc.strerror()</source>
          <target state="translated">Libc.strerror()</target>
        </trans-unit>
        <trans-unit id="9c2a2e1ec6af2d38549c677ba7248e856a349879" translate="yes" xml:space="preserve">
          <source>Libc.strftime()</source>
          <target state="translated">Libc.strftime()</target>
        </trans-unit>
        <trans-unit id="291439a5e7bded77e555ba7822b85155ea0e9ab9" translate="yes" xml:space="preserve">
          <source>Libc.strptime()</source>
          <target state="translated">Libc.strptime()</target>
        </trans-unit>
        <trans-unit id="50e854ed1dcc836eb5e225047ee11442a2f80cd3" translate="yes" xml:space="preserve">
          <source>Libc.systemsleep()</source>
          <target state="translated">Libc.systemsleep()</target>
        </trans-unit>
        <trans-unit id="81d6424efbc87c9c17b0813b0c148152bd3c2475" translate="yes" xml:space="preserve">
          <source>Libc.time()</source>
          <target state="translated">Libc.time()</target>
        </trans-unit>
        <trans-unit id="f9ac7f64b772b55f84e761baea56c702c55005b2" translate="yes" xml:space="preserve">
          <source>Libdl.RTLD_NOW</source>
          <target state="translated">Libdl.RTLD_NOW</target>
        </trans-unit>
        <trans-unit id="754e38c44e40a9e9cb516d0f693c9b5afa0d7ec7" translate="yes" xml:space="preserve">
          <source>Libdl.dlclose()</source>
          <target state="translated">Libdl.dlclose()</target>
        </trans-unit>
        <trans-unit id="b20c01d11dde97a5fa90df2ec685adbcf15207ab" translate="yes" xml:space="preserve">
          <source>Libdl.dlext</source>
          <target state="translated">Libdl.dlext</target>
        </trans-unit>
        <trans-unit id="bbe848e2a374e3e28b9be1468210bde354760df9" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen()</source>
          <target state="translated">Libdl.dlopen()</target>
        </trans-unit>
        <trans-unit id="bc44712bf06d7cde2930672cea24ac5283dc04d2" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen_e()</source>
          <target state="translated">Libdl.dlopen_e()</target>
        </trans-unit>
        <trans-unit id="f76c025cd327748a8ae48ab21c1d0d6937ee6cf3" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym()</source>
          <target state="translated">Libdl.dlsym()</target>
        </trans-unit>
        <trans-unit id="ddc83875e28b579f9ad7f02bee458a0c03e115cf" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym_e()</source>
          <target state="translated">Libdl.dlsym_e()</target>
        </trans-unit>
        <trans-unit id="e5858af9f095388c617c420aefd6c16e0594c3bf" translate="yes" xml:space="preserve">
          <source>Libdl.find_library()</source>
          <target state="translated">Libdl.find_library()</target>
        </trans-unit>
        <trans-unit id="cb8e2b307865af7fc3116bd1827bf102132b7b87" translate="yes" xml:space="preserve">
          <source>Libra</source>
          <target state="translated">Libra</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="8a1bb5e870bb9b77202596bab439b6db423dbba2" translate="yes" xml:space="preserve">
          <source>Light Rail</source>
          <target state="translated">轻轨</target>
        </trans-unit>
        <trans-unit id="4944819e2ca85d61a3c9e24619e3eb246b5a52a9" translate="yes" xml:space="preserve">
          <source>Light Shade</source>
          <target state="translated">灯罩</target>
        </trans-unit>
        <trans-unit id="9921ca32d9a43716da2c222cd03f37ec5fd109a5" translate="yes" xml:space="preserve">
          <source>Lightweight &quot;green&quot; threading (&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;coroutines&lt;/a&gt;)</source>
          <target state="translated">轻量级的&amp;ldquo;绿色&amp;rdquo;线程（&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;协程&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8a26ac5926eeae89368f7fb44a40e4b026751c42" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, but store the result of &lt;code&gt;broadcast(f, As...)&lt;/code&gt; in the &lt;code&gt;dest&lt;/code&gt; array. Note that &lt;code&gt;dest&lt;/code&gt; is only used to store the result, and does not supply arguments to &lt;code&gt;f&lt;/code&gt; unless it is also listed in the &lt;code&gt;As&lt;/code&gt;, as in &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; to perform &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt;.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;，但是将 &lt;code&gt;broadcast(f, As...)&lt;/code&gt; 的结果存储在 &lt;code&gt;dest&lt;/code&gt; 数组中。请注意， &lt;code&gt;dest&lt;/code&gt; 仅用于存储结果，并且不提供 &lt;code&gt;f&lt;/code&gt; 的参数，除非它也在 &lt;code&gt;As&lt;/code&gt; 中列出，如 &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; 执行 &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1bc834338e49af8951a520f98a93394195b34a0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions for people who neither own the file nor are a member of the group owning the file</source>
          <target state="translated">像&lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; &lt;/a&gt;一样，但获得了既不拥有文件也不是拥有文件的组成员的权限</target>
        </trans-unit>
        <trans-unit id="52da4e2a0d663a1dbba38c505be636c82ff3a124" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions of the group owning the file.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; ,&lt;/a&gt;但获得拥有该文件的组的权限。</target>
        </trans-unit>
        <trans-unit id="55b69ac4b886c93cd981119d2156a08505ea6f20" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt;&lt;code&gt;partialsortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(ix)&lt;/code&gt;.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt; &lt;code&gt;partialsortperm&lt;/code&gt; &lt;/a&gt;，但是接受预分配的索引向量 &lt;code&gt;ix&lt;/code&gt; 。如果 &lt;code&gt;initialized&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; （默认值），则将 &lt;code&gt;ix&lt;/code&gt; 初始化为包含值 &lt;code&gt;1:length(ix)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="529e4e84127591bc458006a7c31028da87258a93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;, but stores output in &lt;code&gt;results&lt;/code&gt; rather than returning a collection.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt;，但是将输出存储在 &lt;code&gt;results&lt;/code&gt; 而不是返回集合。</target>
        </trans-unit>
        <trans-unit id="06d62bd10c05ce2bf6e378f3ac0cebfd0dc1f43e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, except reads code from the given string rather than from a file.</source>
          <target state="translated">与&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;一样，区别在于从给定的字符串而不是文件中读取代码。</target>
        </trans-unit>
        <trans-unit id="33fc1f575b86086215aa1689af4abbedb592d014" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, but stores the result in &lt;code&gt;destination&lt;/code&gt; rather than a new collection. &lt;code&gt;destination&lt;/code&gt; must be at least as large as the first collection.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;，但是将结果存储在 &lt;code&gt;destination&lt;/code&gt; 而不是新集合中。 &lt;code&gt;destination&lt;/code&gt; 必须至少与第一个集合一样大。</target>
        </trans-unit>
        <trans-unit id="9053e0f6dd39d888ac2c2e819878de129f87dfec" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity, as in &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">就像&lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt;一样，但是具有保证的左关联性，就像在&lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; 中一样&lt;/a&gt;。如果提供，关键字参数 &lt;code&gt;init&lt;/code&gt; 将只使用一次。通常，有必要提供 &lt;code&gt;init&lt;/code&gt; 来处理空集合。</target>
        </trans-unit>
        <trans-unit id="ffe977f18117519aca83d726747101ffed876b72" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity, as in &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt;，但是具有正确的关联性，如&lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; 中所示&lt;/a&gt;。如果提供，关键字参数 &lt;code&gt;init&lt;/code&gt; 将只使用一次。通常，有必要提供 &lt;code&gt;init&lt;/code&gt; 来处理空集合。</target>
        </trans-unit>
        <trans-unit id="9d8eaa8363c2e7fc8a90587868e4968a125caadc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, but returns either a value of the requested type, or &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; if the string does not contain a valid number.</source>
          <target state="translated">像&lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;，但要么返回请求类型的值，或者&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;，如果字符串不包含有效数字。</target>
        </trans-unit>
        <trans-unit id="51eaec3c8abd237c8d9e9bba6cf07e3a4cb08010" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;permute!&lt;/code&gt;&lt;/a&gt;, but the inverse of the given permutation is applied.</source>
          <target state="translated">喜欢&lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt; &lt;code&gt;permute!&lt;/code&gt; &lt;/a&gt;，但应用给定排列的倒数。</target>
        </trans-unit>
        <trans-unit id="4756a006313f096261885c0ef2037e8fe0a50c17" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt;，但对于&lt;a href=&quot;#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f085d340882a97bb66329f21bdf7b61cf3ba9878" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;. Note that the order of the return tuple is still &lt;code&gt;(rd, wr)&lt;/code&gt;, i.e. data to be read from &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; may be written to &lt;code&gt;wr&lt;/code&gt;.</source>
          <target state="translated">像&lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt;一样，但是对于&lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;。请注意，返回元组的顺序仍然是 &lt;code&gt;(rd, wr)&lt;/code&gt; ，即可以将从&lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;读取的数据写入 &lt;code&gt;wr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f5dd7f815a4d7bf1a89e4740bb5b8ac9a464da9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;，但是保证了左联想性。如果提供，关键字参数 &lt;code&gt;init&lt;/code&gt; 将只使用一次。通常，有必要提供 &lt;code&gt;init&lt;/code&gt; 来处理空集合。</target>
        </trans-unit>
        <trans-unit id="024595a61bd923552b757965d3ba72515fa95986" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">像&lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;一样，但是具有正确的关联性。如果提供，关键字参数 &lt;code&gt;init&lt;/code&gt; 将只使用一次。通常，有必要提供 &lt;code&gt;init&lt;/code&gt; 来处理空集合。</target>
        </trans-unit>
        <trans-unit id="1ef0876ab486f437b72ce65e44751d3b6dbccac7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.sortperm&quot;&gt;&lt;code&gt;sortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(v)&lt;/code&gt;.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.sortperm&quot;&gt; &lt;code&gt;sortperm&lt;/code&gt; &lt;/a&gt;，但是接受预分配的索引向量 &lt;code&gt;ix&lt;/code&gt; 。如果 &lt;code&gt;initialized&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; （默认值），则将 &lt;code&gt;ix&lt;/code&gt; 初始化为包含值 &lt;code&gt;1:length(v)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08026f6d5cc67e6a499233d241ca672fd865f4fa" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.</source>
          <target state="translated">像&lt;a href=&quot;#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;一样，但是对于符号链接，它获取链接本身的信息，而不是它所引用的文件。必须在文件路径而不是文件对象或文件描述符上调用此函数。</target>
        </trans-unit>
        <trans-unit id="b3086501e29c75ea565e72a0019576b980b02fe5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Random.randsubseq&quot;&gt;&lt;code&gt;randsubseq&lt;/code&gt;&lt;/a&gt;, but the results are stored in &lt;code&gt;S&lt;/code&gt; (which is resized as needed).</source>
          <target state="translated">和&lt;a href=&quot;#Random.randsubseq&quot;&gt; &lt;code&gt;randsubseq&lt;/code&gt; &lt;/a&gt;一样，但是结果存储在 &lt;code&gt;S&lt;/code&gt; 中（根据需要调整大小）。</target>
        </trans-unit>
        <trans-unit id="eb969f16d7c8b092d782534c60f5aa57438f02b4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Statistics.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, but may overwrite the input vector.</source>
          <target state="translated">类似于&lt;a href=&quot;#Statistics.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;，但可能会覆盖输入向量。</target>
        </trans-unit>
        <trans-unit id="c740cd8f4daa963edb800319e0b46fdd4c9b8a9e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent array &lt;code&gt;A&lt;/code&gt; with the given indices instead of making a copy. Calling &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; on the returned &lt;code&gt;SubArray&lt;/code&gt; computes the indices to the parent array on the fly without checking bounds.</source>
          <target state="translated">类似于&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;，但是返回具有给定索引的父数组 &lt;code&gt;A&lt;/code&gt; 的视图，而不是进行复制。调用&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;在返回的 &lt;code&gt;SubArray&lt;/code&gt; 上，无需检查边界即可动态计算父数组的索引。</target>
        </trans-unit>
        <trans-unit id="a4ecbe47eb2e0c87296b762b01d3e9398f50b6c5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent string &lt;code&gt;s&lt;/code&gt; within range &lt;code&gt;i:j&lt;/code&gt; or &lt;code&gt;r&lt;/code&gt; respectively instead of making a copy.</source>
          <target state="translated">类似于&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;，但返回分别在 &lt;code&gt;i:j&lt;/code&gt; 或 &lt;code&gt;r&lt;/code&gt; 范围内的父字符串 &lt;code&gt;s&lt;/code&gt; 的视图，而不是进行复制。</target>
        </trans-unit>
        <trans-unit id="807404638eb67f1a49cc813e53a998bea5df9d33" translate="yes" xml:space="preserve">
          <source>Like C and Java, but unlike most dynamic languages, Julia has a first-class type for representing a single character, called &lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt;&lt;code&gt;AbstractChar&lt;/code&gt;&lt;/a&gt;. The built-in &lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; subtype of &lt;code&gt;AbstractChar&lt;/code&gt; is a 32-bit primitive type that can represent any Unicode character (and which is based on the UTF-8 encoding).</source>
          <target state="translated">像C和Java一样，但与大多数动态语言不同，Julia具有用于表示单个字符的一流类型，称为&lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt; &lt;code&gt;AbstractChar&lt;/code&gt; &lt;/a&gt;。内置的&lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt;子类型 &lt;code&gt;AbstractChar&lt;/code&gt; 是32位基本类型，可以表示任何Unicode字符（并且基于UTF-8编码）。</target>
        </trans-unit>
        <trans-unit id="b144d1ab3b4daafe713dd1906d84dd6576675e14" translate="yes" xml:space="preserve">
          <source>Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">和 ccall 一样,所有这些参数都将在编译时,当包含方法被定义时被评估。</target>
        </trans-unit>
        <trans-unit id="d14af23f7b07876d0e17dec387b3e911da07b564" translate="yes" xml:space="preserve">
          <source>Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range. For example, &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; is valid R but the equivalent &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; will throw an error in Julia.</source>
          <target state="translated">像许多语言一样，Julia并不总是允许对不同长度的向量进行运算，这与R中的向量只需要共享一个公共索引范围不同。例如， &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; 是有效的R，但是等效项 &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; 将在Julia中引发错误。</target>
        </trans-unit>
        <trans-unit id="76129ab650b5177af08ad48252475d8daddeec47" translate="yes" xml:space="preserve">
          <source>Like many other environments, Julia has an &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; function, which takes a filename and returns an &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; object that you can use to read and write things from the file. For example, if we have a file, &lt;code&gt;hello.txt&lt;/code&gt;, whose contents are &lt;code&gt;Hello, World!&lt;/code&gt;:</source>
          <target state="translated">像许多其他环境一样，Julia具有一个&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;函数，该函数需要一个文件名并返回一个&lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt;对象，您可以使用该对象读取和写入文件中的内容。例如，如果我们有一个文件 &lt;code&gt;hello.txt&lt;/code&gt; ，其内容为 &lt;code&gt;Hello, World!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f57deb1de610f6542b69d3ee454e00aa561ce8c" translate="yes" xml:space="preserve">
          <source>Like non-standard string literals, non-standard command literals exist using a prefixed variant of the command literal syntax. The command literal &lt;code&gt;custom`literal`&lt;/code&gt; is parsed as &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt;. Julia itself does not contain any non-standard command literals, but packages can make use of this syntax. Aside from the different syntax and the &lt;code&gt;_cmd&lt;/code&gt; suffix instead of the &lt;code&gt;_str&lt;/code&gt; suffix, non-standard command literals behave exactly like non-standard string literals.</source>
          <target state="translated">像非标准字符串文字一样，使用命令文字语法的前缀变体也存在非标准命令文字。命令文字 &lt;code&gt;custom`literal`&lt;/code&gt; 被解析为 &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt; 。Julia本身不包含任何非标准命令文字，但是程序包可以使用此语法。除了不同的语法和 &lt;code&gt;_cmd&lt;/code&gt; 后缀，而不是 &lt;code&gt;_str&lt;/code&gt; 后缀，非标准指令的文字完全一样的非标准字符串文字。</target>
        </trans-unit>
        <trans-unit id="ca04337635b1b8ca769f7475dd5bb9a710a07316" translate="yes" xml:space="preserve">
          <source>Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles mapping the shared segment being released sooner.</source>
          <target state="translated">和远程引用一样,共享数组也依赖于创建节点上的垃圾收集,以释放所有参与工作者的引用。创建许多短暂的共享数组对象的代码将受益于尽快明确地最终确定这些对象。这将导致映射共享段的内存和文件句柄都能更快释放。</target>
        </trans-unit>
        <trans-unit id="bc02118fe44dfd1db0138406f1b30a59afe69954" translate="yes" xml:space="preserve">
          <source>Likewise, the global variable &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; determines a relative path to the configuration file directory. Then Julia searches for a &lt;code&gt;startup.jl&lt;/code&gt; file at</source>
          <target state="translated">同样，全局变量 &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; 确定配置文件目录的相对路径。然后Julia在以下位置搜索 &lt;code&gt;startup.jl&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="40654ee5f02852c7196e6e2f00f07fee2fb0ef03" translate="yes" xml:space="preserve">
          <source>Limit usage of CPU features up to &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt;; set to &lt;code&gt;help&lt;/code&gt; to see the available options</source>
          <target state="translated">将CPU功能的使用限制为 &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt; ; 设置以 &lt;code&gt;help&lt;/code&gt; 查看可用选项</target>
        </trans-unit>
        <trans-unit id="8d96ce8bb4e79cb43743b90921151985b53e510c" translate="yes" xml:space="preserve">
          <source>LinRange</source>
          <target state="translated">LinRange</target>
        </trans-unit>
        <trans-unit id="d937e9c2df56b1e58e5b8819252e720563fa79ea" translate="yes" xml:space="preserve">
          <source>Line 3 of &lt;code&gt;myfunc&lt;/code&gt; contains the call to &lt;code&gt;maximum&lt;/code&gt;, and there were 28 (out of 80) backtraces taken here. Below that, you can see the specific places in &lt;code&gt;base/reduce.jl&lt;/code&gt; that carry out the time-consuming operations in the &lt;code&gt;maximum&lt;/code&gt; function for this type of input data.</source>
          <target state="translated">&lt;code&gt;myfunc&lt;/code&gt; 的第3行包含对 &lt;code&gt;maximum&lt;/code&gt; 的调用，并且在此处进行了28条（总共80条）回溯。下面，你可以看到具体的地方在 &lt;code&gt;base/reduce.jl&lt;/code&gt; 是进行耗时的操作的 &lt;code&gt;maximum&lt;/code&gt; 功能为这种类型的输入数据。</target>
        </trans-unit>
        <trans-unit id="677b9ff91279f2c92df14e8f98feaaad0ff02671" translate="yes" xml:space="preserve">
          <source>Line Integration Not Including The Pole</source>
          <target state="translated">不包括极点的线路整合</target>
        </trans-unit>
        <trans-unit id="aa862b80ca648d32974899a07b490c840367365f" translate="yes" xml:space="preserve">
          <source>Line Integration With Rectangular Path Around Pole</source>
          <target state="translated">带矩形路径的绕极线积分</target>
        </trans-unit>
        <trans-unit id="cd235d8e390a116750618564e9fef4ddd8d815c0" translate="yes" xml:space="preserve">
          <source>Line Integration With Semicircular Path Around Pole</source>
          <target state="translated">带半圆路径的绕极线积分法</target>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="translated">线性代数</target>
        </trans-unit>
        <trans-unit id="3ab90484838b94648400b6fcaea9c0833f594271" translate="yes" xml:space="preserve">
          <source>Linear algebra functions in Julia are largely implemented by calling functions from &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK&lt;/a&gt;. Sparse factorizations call functions from &lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse&lt;/a&gt;.</source>
          <target state="translated">Julia中的线性代数函数主要通过调用&lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK来实现&lt;/a&gt;。&lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse中的&lt;/a&gt;稀疏分解调用函数。</target>
        </trans-unit>
        <trans-unit id="d1c65bd6bdbd1cc3a07c925c8d1f63a9ef479713" translate="yes" xml:space="preserve">
          <source>Linear index to cartesian index conversion exploits the fact that a &lt;code&gt;CartesianIndices&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt; and can be indexed linearly:</source>
          <target state="translated">线性索引到笛卡尔索引转换利用了这样一个事实 &lt;code&gt;CartesianIndices&lt;/code&gt; 是 &lt;code&gt;AbstractArray&lt;/code&gt; 和可线性索引：</target>
        </trans-unit>
        <trans-unit id="c1c4acc4812d010d9f4c5b8b2c947ad6bf3a9bbc" translate="yes" xml:space="preserve">
          <source>Linear indexing</source>
          <target state="translated">线性指数化</target>
        </trans-unit>
        <trans-unit id="a4c16b0102a66cf314085c9fb0015204063e6fd3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Adjoint</source>
          <target state="translated">LinearAlgebra.Adjoint</target>
        </trans-unit>
        <trans-unit id="f15dbf32eea38f12565a79b8c505de8f87a92ec9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS</source>
          <target state="translated">LinearAlgebra.BLAS</target>
        </trans-unit>
        <trans-unit id="e45107bca3f2265e5d9c85ca1c9fec27cc17de1c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.asum()</source>
          <target state="translated">LinearAlgebra.BLAS.asum()</target>
        </trans-unit>
        <trans-unit id="0372d64ede3f868ef8099f9d2d0ba0d26301cae5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.blascopy!()</source>
          <target state="translated">LinearAlgebra.BLAS.blascopy!()</target>
        </trans-unit>
        <trans-unit id="d13717e84d8e032e30650fc47582fb7cd32b85c2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotc()</source>
          <target state="translated">LinearAlgebra.BLAS.dotc()</target>
        </trans-unit>
        <trans-unit id="80b561d6fb654a4f5dbc4d039a743babeb78f05a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotu()</source>
          <target state="translated">LinearAlgebra.BLAS.dotu()</target>
        </trans-unit>
        <trans-unit id="182543675c48dfba38aa5478d8ce3279d26d4ef4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv!()</target>
        </trans-unit>
        <trans-unit id="6cec9f631b39a94bb3001b07c15c7364aacddbae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv()</target>
        </trans-unit>
        <trans-unit id="59202f7fad0ff0f17101364487458d9228718112" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm!()</target>
        </trans-unit>
        <trans-unit id="a90dea0e894e7db5d100f0da8dd99eb55becb11a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm()</target>
        </trans-unit>
        <trans-unit id="9c43130d6006aefdd06d70d7199a76e138e6d41f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv!()</target>
        </trans-unit>
        <trans-unit id="9e7d057213847eff9fcee5278de6f9c65c129248" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv()</target>
        </trans-unit>
        <trans-unit id="7de983e341dd493a6005bdeccd16b2008abe1b4c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.ger!()</source>
          <target state="translated">LinearAlgebra.BLAS.ger!()</target>
        </trans-unit>
        <trans-unit id="c508786b30abc595e3c001798b77caf3e83ceab1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.her!()</source>
          <target state="translated">LinearAlgebra.BLAS.her!()</target>
        </trans-unit>
        <trans-unit id="01f3abbc9926c6680a10dada97213576f68220e4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk!()</source>
          <target state="translated">LinearAlgebra.BLAS.herk!()</target>
        </trans-unit>
        <trans-unit id="7ca416ce67850358cd75772ae19bf13edb1e3145" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk()</source>
          <target state="translated">LinearAlgebra.BLAS.herk()</target>
        </trans-unit>
        <trans-unit id="ae660954410680fe7bf17073b8a5a13e3d858105" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.iamax()</source>
          <target state="translated">LinearAlgebra.BLAS.iamax()</target>
        </trans-unit>
        <trans-unit id="cd1a2671bbd0fd5d0123954f4b697032be1e635c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.nrm2()</source>
          <target state="translated">LinearAlgebra.BLAS.nrm2()</target>
        </trans-unit>
        <trans-unit id="e90dcf81b0d3bcd42a1f41c82cba29bfcb9a2dc1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv!()</target>
        </trans-unit>
        <trans-unit id="726229488f087bf6f4b29c015474123c38acb7e3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv()</target>
        </trans-unit>
        <trans-unit id="e38b1b5860121c691bed2ff0a82bb4bddb43aeda" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal!()</source>
          <target state="translated">LinearAlgebra.BLAS.scal!()</target>
        </trans-unit>
        <trans-unit id="4a5ae3b0e35b9b56d0ca4f544caed75fc4410c97" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal()</source>
          <target state="translated">LinearAlgebra.BLAS.scal()</target>
        </trans-unit>
        <trans-unit id="bd2ae45b248f17f2163a416ae8b1b8f316599548" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.set_num_threads()</source>
          <target state="translated">LinearAlgebra.BLAS.set_num_threads()</target>
        </trans-unit>
        <trans-unit id="0ee907ef539363efacff8c904278837def446859" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm!()</source>
          <target state="translated">LinearAlgebra.BLAS.symm!()</target>
        </trans-unit>
        <trans-unit id="2ca89af9829c4450e1da15d694b423f02feaf2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm()</source>
          <target state="translated">LinearAlgebra.BLAS.symm()</target>
        </trans-unit>
        <trans-unit id="c4ff899252dc161c59c729ece50db7c6e510be1f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv!()</source>
          <target state="translated">LinearAlgebra.BLAS.symv!()</target>
        </trans-unit>
        <trans-unit id="c3f814d8d8c968ce7e35bf9e0c795e7503d54b00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv()</source>
          <target state="translated">LinearAlgebra.BLAS.symv()</target>
        </trans-unit>
        <trans-unit id="5668a0235a5cc16113ef6c829d5f4f3cb946eb77" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syr!()</source>
          <target state="translated">LinearAlgebra.BLAS.syr!()</target>
        </trans-unit>
        <trans-unit id="0ea3ba86e685fafe1804ca06ce2cc0aa30792e4d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk!()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk!()</target>
        </trans-unit>
        <trans-unit id="2910b73b192710f5034193e1b67ded6bb10699b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk()</target>
        </trans-unit>
        <trans-unit id="c657c078868b4b49e269336d3ff46af071f8fa01" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm!()</target>
        </trans-unit>
        <trans-unit id="04b9bf86a921535849558977a38bc7efdcdd3272" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm()</target>
        </trans-unit>
        <trans-unit id="9d8cb1ea03abc954f9254445e2db3781f49756de" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv!()</target>
        </trans-unit>
        <trans-unit id="72558d3ed3ecbb2cf81ea6ad3401440af8b8f050" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv()</target>
        </trans-unit>
        <trans-unit id="218cea369dcdb92ba6f1e8b45bda62d05efdb29f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm!()</target>
        </trans-unit>
        <trans-unit id="05197b08bc46d65744a62e5816cecfcc72ef9983" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm()</target>
        </trans-unit>
        <trans-unit id="a147ea56a9e55d82d2590cd764be5c11a28ac42c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv!()</target>
        </trans-unit>
        <trans-unit id="3205efa3be1bef6bfc936054e89c97d514d48dc9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv()</target>
        </trans-unit>
        <trans-unit id="6364f45353271734da7f68207b58b49b90c519aa" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Bidiagonal</source>
          <target state="translated">LinearAlgebra.Bidiagonal</target>
        </trans-unit>
        <trans-unit id="b0cf658cc297affd7bac8f29cb18f8d5898c988a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Diagonal</source>
          <target state="translated">LinearAlgebra.Diagonal</target>
        </trans-unit>
        <trans-unit id="1b39c6247cb769989ac9ddbddb50b7a2c7340d63" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Givens</source>
          <target state="translated">LinearAlgebra.Givens</target>
        </trans-unit>
        <trans-unit id="202cd7384296c88f891bea55496b32195e848e3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Hermitian</source>
          <target state="translated">LinearAlgebra.Hermitian</target>
        </trans-unit>
        <trans-unit id="79fc319c7c269772fed2f361672bd676a3520fae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.I</source>
          <target state="translated">LinearAlgebra.I</target>
        </trans-unit>
        <trans-unit id="2a1626ced0dce6995c5f58e8d3def911fe7d751f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK</source>
          <target state="translated">LinearAlgebra.LAPACK</target>
        </trans-unit>
        <trans-unit id="6952bafd874a0b24bee2d594a25adae4924e4368" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsdc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsdc!()</target>
        </trans-unit>
        <trans-unit id="8d0c6a0d204bac9380f45220c8b25a01fbcacfc6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsqr!()</target>
        </trans-unit>
        <trans-unit id="21f727539d33d03dc8b986b7ecf7ebc53925b185" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrf!()</target>
        </trans-unit>
        <trans-unit id="2bb72a67df1d100e66f590117e79a6b1fe23456f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrs!()</target>
        </trans-unit>
        <trans-unit id="042b17e7fbbcced06624b5d18cecc1aa4880dfbf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebak!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebak!()</target>
        </trans-unit>
        <trans-unit id="5d6511493ba85c27c966c3e62df9148d39254215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebal!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebal!()</target>
        </trans-unit>
        <trans-unit id="3f829c89a9fa98bb138c195dfc567bcd88556869" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebrd!()</target>
        </trans-unit>
        <trans-unit id="7b9eae4d91dc7949a3ab26f80620c6913329a279" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gecon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gecon!()</target>
        </trans-unit>
        <trans-unit id="bb09b2b974d5f60b025547cb0fa46b9c45f6eabf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gees!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gees!()</target>
        </trans-unit>
        <trans-unit id="4adfdd0d27bb95b254d684fb07bba4182c2a0a10" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geev!()</target>
        </trans-unit>
        <trans-unit id="f5fc1d59d033c8ca0452a21a055c7e9b2cdc3409" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geevx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geevx!()</target>
        </trans-unit>
        <trans-unit id="4162f14b7f241061ff814adad6bc4880eae0e215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gehrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gehrd!()</target>
        </trans-unit>
        <trans-unit id="8e52c2ea87a7196909af8b847322a690fcef6a4f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelqf!()</target>
        </trans-unit>
        <trans-unit id="b7bb54e5159886ceee34f20483cdbbf42f4c1539" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gels!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gels!()</target>
        </trans-unit>
        <trans-unit id="7f10b1dc3cf7af9a395a67850e24907c94936d00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsd!()</target>
        </trans-unit>
        <trans-unit id="80af9020ee1658e044f9880edaa420f6156e7344" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsy!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsy!()</target>
        </trans-unit>
        <trans-unit id="0287631b489ed93feb1a00a1ebe340392e903cd8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gemqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gemqrt!()</target>
        </trans-unit>
        <trans-unit id="756fb9e8e80236b54ccbf1725c3d3d72fe14d0a7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqlf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqlf!()</target>
        </trans-unit>
        <trans-unit id="0fa233b136691bcd50a971792940b70a927e194d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqp3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqp3!()</target>
        </trans-unit>
        <trans-unit id="965cf80f5d69f9b2fe0863a82cdd4b368ed4eba1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrf!()</target>
        </trans-unit>
        <trans-unit id="47893a6fd6bd1458706a0673e1d64d54be6d20ec" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt!()</target>
        </trans-unit>
        <trans-unit id="94f19bfcd3971a4989d673487abd3bd487d293d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt3!()</target>
        </trans-unit>
        <trans-unit id="19ff37cfcf822fda7f988e77f92c195943446d8b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gerqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gerqf!()</target>
        </trans-unit>
        <trans-unit id="c47fe5b7f34f49ec65d1767c07d0c357d6c12e20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesdd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesdd!()</target>
        </trans-unit>
        <trans-unit id="5abf4ebce7739a88e07c58cc2ab150c8e79b9a6f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesv!()</target>
        </trans-unit>
        <trans-unit id="f900ac3ce3ebbd4997a5abaafa85072405326271" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvd!()</target>
        </trans-unit>
        <trans-unit id="3a69b9c0d56562dd7ea697ae7f5eea3c3217e8c4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvx!()</target>
        </trans-unit>
        <trans-unit id="997ad4b85fe561bd14fecda4a9185c9be5de7367" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrf!()</target>
        </trans-unit>
        <trans-unit id="d93427849097672e5ca2dd0b81aead36db3bffe6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getri!()</target>
        </trans-unit>
        <trans-unit id="46614120fda23ffee34b46ef06a4d2717d89fb72" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrs!()</target>
        </trans-unit>
        <trans-unit id="3d14f5edf2f52561c8b1cfcc015d4eefd5e8344a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gges!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gges!()</target>
        </trans-unit>
        <trans-unit id="7a73e7bdeb2ad0938d68fd93e6f27345108ba8b1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggev!()</target>
        </trans-unit>
        <trans-unit id="3ae17e2685021efceba3fcfa226528ce1e41d6a9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gglse!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gglse!()</target>
        </trans-unit>
        <trans-unit id="3100382b56a5f6703f1da34614842b2f9fd9e2ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd!()</target>
        </trans-unit>
        <trans-unit id="61dfaab553dd3ccfaacf89bcaa2704beb947b945" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd3!()</target>
        </trans-unit>
        <trans-unit id="db05e9a4a5c735805bf40092dca7033de637b064" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gtsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gtsv!()</target>
        </trans-unit>
        <trans-unit id="9b6b3e96efd10abaf039016da8b07d6fdefa2dac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrf!()</target>
        </trans-unit>
        <trans-unit id="7d5b231fee9480951dc3ad4ba6239425f9a1a69e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrs!()</target>
        </trans-unit>
        <trans-unit id="56b45916f3c5b6ccae7d5897efff708c77670fe9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hesv!()</target>
        </trans-unit>
        <trans-unit id="1dd5d2c561afecfbda18ff5f8f3e44ea02e6d2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrf!()</target>
        </trans-unit>
        <trans-unit id="cf6a921b989ce1adbf03be52e76504708a3db4ac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetri!()</target>
        </trans-unit>
        <trans-unit id="a535b2e2552fdefb2e31ef5cf705c68b406e0e4e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrs!()</target>
        </trans-unit>
        <trans-unit id="3c7e4832c831bf40fdec955ad64e7df4981b628e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orghr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orghr!()</target>
        </trans-unit>
        <trans-unit id="9afd9979936c6db6319fad409953eb23f579d5ca" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orglq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orglq!()</target>
        </trans-unit>
        <trans-unit id="72fc39a42e1ba3ec988e4e34aca8961c7d4dd43b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgql!()</target>
        </trans-unit>
        <trans-unit id="3f36d991b78dd60e8ba960e3ddf5db19bd097fb8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgqr!()</target>
        </trans-unit>
        <trans-unit id="18eb3015f314ddb831889efa958dd72893b66864" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgrq!()</target>
        </trans-unit>
        <trans-unit id="ee585149aad96671646932b1d3634278142c13f9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormlq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormlq!()</target>
        </trans-unit>
        <trans-unit id="bdfbc8d40444d8bafd90c67f455d3b34e73228cf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormql!()</target>
        </trans-unit>
        <trans-unit id="1087b8488a465127e32826863adc779bd9d1327c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormqr!()</target>
        </trans-unit>
        <trans-unit id="a2fb188b73bde57195bb1d824030a4ed0bbd608b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrq!()</target>
        </trans-unit>
        <trans-unit id="ffa8283f30595d57d465f23f206871d42b88b987" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrz!()</target>
        </trans-unit>
        <trans-unit id="c7253e7d1bd1dce84f707a9c7bb94c23529af18b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.posv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.posv!()</target>
        </trans-unit>
        <trans-unit id="9686f05e5f67aa477b854f99ab98169e47b19084" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrf!()</target>
        </trans-unit>
        <trans-unit id="a162ea4f7602eae7842c83604fa469aeb77c3bfd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potri!()</target>
        </trans-unit>
        <trans-unit id="22fdc042984e65bbd42e11f87af366faeef74622" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrs!()</target>
        </trans-unit>
        <trans-unit id="2e152451a9c97ebf916e592216ff01087a6982bd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pstrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pstrf!()</target>
        </trans-unit>
        <trans-unit id="9a048d5b8589397c46ecf7dd3a023271382559b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ptsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ptsv!()</target>
        </trans-unit>
        <trans-unit id="6bd4c3257dbbd4280e5dfb016628a7275adf1a33" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrf!()</target>
        </trans-unit>
        <trans-unit id="959a9d0a79a973f313fff6fc55c623c797c6c7f7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrs!()</target>
        </trans-unit>
        <trans-unit id="6d7e0b67347ba1e8b9a711859117ac575684e8e1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stebz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stebz!()</target>
        </trans-unit>
        <trans-unit id="e4c4102de134bdf1c8c27920913760be8971f8a2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stegr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stegr!()</target>
        </trans-unit>
        <trans-unit id="09e672928c1ecc7dda3783503f4b5dded92b9673" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stein!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stein!()</target>
        </trans-unit>
        <trans-unit id="eace3492602beabe1f2ab7981e7d9209cfc2204c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stev!()</target>
        </trans-unit>
        <trans-unit id="66d07521e84ded0664c8e6d24cb062cfa0abf44c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syconv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syconv!()</target>
        </trans-unit>
        <trans-unit id="e37c017154e2c1fa3c47a038f981c9a2f9b128ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syev!()</target>
        </trans-unit>
        <trans-unit id="371acb573fdc2cfe58acc84371e930aa7f66f883" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syevr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syevr!()</target>
        </trans-unit>
        <trans-unit id="4489b4eba27fe6a94403f8fc257631ee4a85b0d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sygvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sygvd!()</target>
        </trans-unit>
        <trans-unit id="f6128668d243c8ac355a7d5c46c06adfedbfe0c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sysv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sysv!()</target>
        </trans-unit>
        <trans-unit id="022ac6bcea134ce5fe3a89f3bf4383107b51b2a0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrf!()</target>
        </trans-unit>
        <trans-unit id="a8bb80be7fdb78fb2ac23b9a1ad4b26eace9add4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytri!()</target>
        </trans-unit>
        <trans-unit id="9d2a23098c970b0a82d03a2a452ca8118a4c74c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrs!()</target>
        </trans-unit>
        <trans-unit id="83c634bcfc2f6365a7a5ab5dac799d6cefa5dae1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tgsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tgsen!()</target>
        </trans-unit>
        <trans-unit id="b190b8b87f953db3f01614e0cef9f46ab8ddef6c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trcon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trcon!()</target>
        </trans-unit>
        <trans-unit id="81c93a5fe65faa5e18e25557226f1e29499c9834" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trevc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trevc!()</target>
        </trans-unit>
        <trans-unit id="0fde83f3dc9a18889586b82aefe631e75f1ca0a5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trexc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trexc!()</target>
        </trans-unit>
        <trans-unit id="e0a6fb5f31ac808c6c4c2d58c9bd3c8bf4547c3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trrfs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trrfs!()</target>
        </trans-unit>
        <trans-unit id="b4a63b08edea3206f96883f52f887e335290d30c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsen!()</target>
        </trans-unit>
        <trans-unit id="0981f544b1017b88401f0c0d727a8512e3a16911" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsyl!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsyl!()</target>
        </trans-unit>
        <trans-unit id="0dd13d83537af1986304c93341975314e0a3cb92" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtri!()</target>
        </trans-unit>
        <trans-unit id="6ace8e21c229caf81f057c6691dc06ea1d7feacb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtrs!()</target>
        </trans-unit>
        <trans-unit id="9f4a95aa5cd6a48d65dcce0dfbc0c2104db08ddb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tzrzf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tzrzf!()</target>
        </trans-unit>
        <trans-unit id="8dc3928b7aacf4bc69fb8fb480397c2bd0754291" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LowerTriangular</source>
          <target state="translated">LinearAlgebra.LowerTriangular</target>
        </trans-unit>
        <trans-unit id="d296a34551600570579f05eb52f68d858500b6d0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.PosDefException</source>
          <target state="translated">LinearAlgebra.PosDefException</target>
        </trans-unit>
        <trans-unit id="1a5ee969e2fda57a234091ffc7169bb0717b4b55" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QR</source>
          <target state="translated">LinearAlgebra.QR</target>
        </trans-unit>
        <trans-unit id="f252432902b3e7d2b6f5a1f541fab2b2b837e497" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRCompactWY</source>
          <target state="translated">LinearAlgebra.QRCompactWY</target>
        </trans-unit>
        <trans-unit id="f69a9de928f655bcff2c3bb620374afc9c7adc36" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRPivoted</source>
          <target state="translated">LinearAlgebra.QRPivoted</target>
        </trans-unit>
        <trans-unit id="91c43501578d11cc7b806496b694bc7fb0798c40" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SingularException</source>
          <target state="translated">LinearAlgebra.SingularException</target>
        </trans-unit>
        <trans-unit id="21fa708b4606d3744276dbdb6504d1d33fb0880d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SymTridiagonal</source>
          <target state="translated">LinearAlgebra.SymTridiagonal</target>
        </trans-unit>
        <trans-unit id="c49662dfefa654d140f37c4f501e68d902dc9896" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Symmetric</source>
          <target state="translated">LinearAlgebra.Symmetric</target>
        </trans-unit>
        <trans-unit id="0b7bcff88afd509726e928a1da4371d5aad48e96" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Transpose</source>
          <target state="translated">LinearAlgebra.Transpose</target>
        </trans-unit>
        <trans-unit id="2f6e7904ca2d80d08fecb44ff694e5529ca8a0d2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Tridiagonal</source>
          <target state="translated">LinearAlgebra.Tridiagonal</target>
        </trans-unit>
        <trans-unit id="bcd3cd958cfc2292b170f7eb25170c03f9af2ed5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UniformScaling</source>
          <target state="translated">LinearAlgebra.UniformScaling</target>
        </trans-unit>
        <trans-unit id="5441959246e16a93a832c57343376624fe880467" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitLowerTriangular</source>
          <target state="translated">LinearAlgebra.UnitLowerTriangular</target>
        </trans-unit>
        <trans-unit id="828cc10c694c730e1acddbbb4fe2c09ed2dca433" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitUpperTriangular</source>
          <target state="translated">LinearAlgebra.UnitUpperTriangular</target>
        </trans-unit>
        <trans-unit id="fa757c0838038ffc2a6e801a13ed5a7b6a193380" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UpperTriangular</source>
          <target state="translated">LinearAlgebra.UpperTriangular</target>
        </trans-unit>
        <trans-unit id="738beaba8ed2df6f31a673ee2db8f7e43295d515" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.adjoint!()</source>
          <target state="translated">LinearAlgebra.adjoint!()</target>
        </trans-unit>
        <trans-unit id="9920d50dc92a459847aa3353d4531d0f64c48729" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.axpy!()</source>
          <target state="translated">LinearAlgebra.axpy!()</target>
        </trans-unit>
        <trans-unit id="8382532f0eba26f9bafb22dc5faa9989630741b4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman!()</source>
          <target state="translated">LinearAlgebra.bunchkaufman!()</target>
        </trans-unit>
        <trans-unit id="f1ff255591a788d659f39c668b504aff71f28694" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman()</source>
          <target state="translated">LinearAlgebra.bunchkaufman()</target>
        </trans-unit>
        <trans-unit id="49b3835122bf27c1a5c23bc1f6af4df7016dfd20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.checksquare()</source>
          <target state="translated">LinearAlgebra.checksquare()</target>
        </trans-unit>
        <trans-unit id="f296f09ff80bdc588b439135e7b625bce1f0d744" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky!()</source>
          <target state="translated">LinearAlgebra.cholesky!()</target>
        </trans-unit>
        <trans-unit id="2614d615a16d87a3a50db7af9f3788e4b71855b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky()</source>
          <target state="translated">LinearAlgebra.cholesky()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
