<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="julia">
    <body>
      <group id="julia">
        <trans-unit id="b553bb959838778f24d5092568f001b6908e4f87" translate="yes" xml:space="preserve">
          <source>It is also possible to interact with a Julia REPL in the browser via &lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;. See the package home for details.</source>
          <target state="translated">也可以通过&lt;a href=&quot;https://github.com/JuliaLang/IJulia.jl&quot;&gt;IJulia&lt;/a&gt;与浏览器中的Julia REPL进行交互。有关详细信息，请参见软件包主页。</target>
        </trans-unit>
        <trans-unit id="107b61cbdd6b182357e4837cba9afce4360112e7" translate="yes" xml:space="preserve">
          <source>It is also used to &lt;code&gt;show&lt;/code&gt; julia source code which has gone through macro hygiene or otherwise contains variable names which can't be parsed normally.</source>
          <target state="translated">它还用于 &lt;code&gt;show&lt;/code&gt; 经过宏观卫生检查或包含无法正常解析的变量名的julia源代码。</target>
        </trans-unit>
        <trans-unit id="77f0d3358e54fed68167ad7e2f2668925a7d33bb" translate="yes" xml:space="preserve">
          <source>It is also worth emphasizing that functions should take arguments, instead of operating directly on global variables (aside from constants like &lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt;&lt;code&gt;pi&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">还值得强调的是，函数应该带有参数，而不是直接对全局变量进行操作（除了像&lt;a href=&quot;../../base/numbers/index#Base.MathConstants.pi&quot;&gt; &lt;code&gt;pi&lt;/code&gt; &lt;/a&gt;这样的常量）。</target>
        </trans-unit>
        <trans-unit id="af4f80c2a3eb6b9cc2e18a2eac5ff00feaaaca4a" translate="yes" xml:space="preserve">
          <source>It is better to avoid errors than to rely on catching them.</source>
          <target state="translated">避免出错,不如依靠抓错。</target>
        </trans-unit>
        <trans-unit id="de317509d863583987ae78748b3c0fbd35bb5918" translate="yes" xml:space="preserve">
          <source>It is common to want to create a task and schedule it right away, so the macro &lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt;&lt;code&gt;@async&lt;/code&gt;&lt;/a&gt; is provided for that purpose &amp;ndash;- &lt;code&gt;@async x&lt;/code&gt; is equivalent to &lt;code&gt;schedule(@task x)&lt;/code&gt;.</source>
          <target state="translated">通常要创建一个任务并立即对其进行调度，因此&lt;a href=&quot;../../base/parallel/index#Base.@async&quot;&gt; &lt;code&gt;@async&lt;/code&gt; &lt;/a&gt;提供了@async宏&amp;ndash; &lt;code&gt;@async x&lt;/code&gt; 等同于 &lt;code&gt;schedule(@task x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="62c8e496514b2a89c93f19599f4b3b4a2fbaa739" translate="yes" xml:space="preserve">
          <source>It is convenient to have captures returned as an array so that one can use destructuring syntax to bind them to local variables:</source>
          <target state="translated">将捕获以数组的形式返回是很方便的,这样就可以使用解构语法将它们绑定到本地变量。</target>
        </trans-unit>
        <trans-unit id="d47b317b6ddbcdcb526b152229f01524e725a05a" translate="yes" xml:space="preserve">
          <source>It is critical to exactly match the declared C type with its declaration in Julia. Inconsistencies can cause code that works correctly on one system to fail or produce indeterminate results on a different system.</source>
          <target state="translated">将声明的C类型与其在Julia中的声明完全匹配是至关重要的。不一致会导致在一个系统上正确运行的代码失败,或者在不同系统上产生不确定的结果。</target>
        </trans-unit>
        <trans-unit id="fed6b1dba676362bbdda7d92763627e5b989669b" translate="yes" xml:space="preserve">
          <source>It is declared inside the block of a type declaration, rather than outside of it like normal methods.</source>
          <target state="translated">它是在类型声明的块内声明的,而不是像普通方法那样在块外声明。</target>
        </trans-unit>
        <trans-unit id="be90e9f486db27a87a15823d4ded324a5b8722df" translate="yes" xml:space="preserve">
          <source>It is good practice to provide as few inner constructor methods as possible: only those taking all arguments explicitly and enforcing essential error checking and transformation. Additional convenience constructor methods, supplying default values or auxiliary transformations, should be provided as outer constructors that call the inner constructors to do the heavy lifting. This separation is typically quite natural.</source>
          <target state="translated">最好的做法是提供尽可能少的内部构造函数方法:只提供那些显式地接受所有参数并执行必要的错误检查和转换的方法。额外的方便构造方法,提供默认值或辅助转换,应该作为外部构造函数提供,调用内部构造函数来完成繁重的工作。这种分离通常是很自然的。</target>
        </trans-unit>
        <trans-unit id="055af1e6d77e563e261b9cddc84477b0892ca389" translate="yes" xml:space="preserve">
          <source>It is good practice to use such special versions in comparisons (particularly, the trailing &lt;code&gt;-&lt;/code&gt; should always be used on upper bounds unless there's a good reason not to), but they must not be used as the actual version number of anything, as they are invalid in the semantic versioning scheme.</source>
          <target state="translated">优良作法是在比较中使用此类特殊版本（尤其是尾随 &lt;code&gt;-&lt;/code&gt; 除非有充分的理由，否则应始终在上限上使用），但不得将它们用作任何内容的实际版本号，因为它们是在语义版本控制方案中无效。</target>
        </trans-unit>
        <trans-unit id="94f57801215f48bd353cec6fcbf15e2489fd5bd7" translate="yes" xml:space="preserve">
          <source>It is important to emphasize that macros receive their arguments as expressions, literals, or symbols. One way to explore macro arguments is to call the &lt;code&gt;show&lt;/code&gt; function within the macro body:</source>
          <target state="translated">必须强调的是，宏将其参数作为表达式，文字或符号来接收。探索宏参数的一种方法是在宏主体内调用 &lt;code&gt;show&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="02a6b6b86295c683044f57772927ffaa28e3765b" translate="yes" xml:space="preserve">
          <source>It is important to note that &lt;em&gt;when&lt;/em&gt; an object is locally garbage collected depends on the size of the object and the current memory pressure in the system.</source>
          <target state="translated">重要的是要注意，&lt;em&gt;在&lt;/em&gt;本地存储对象时，垃圾回收取决于对象的大小和系统中的当前内存压力。</target>
        </trans-unit>
        <trans-unit id="600388b971e8fe9fe40cf23408b11ce42cda8c10" translate="yes" xml:space="preserve">
          <source>It is in general impossible to predict which values will be old at runtime, so the write barrier must be inserted after all explicit stores. One notable exception is if the &lt;code&gt;parent&lt;/code&gt; object was just allocated and garbage collection was not run since then. Remember that most &lt;code&gt;jl_...&lt;/code&gt; functions can sometimes invoke garbage collection.</source>
          <target state="translated">通常无法预测在运行时哪些值将是旧的，因此必须在所有显式存储之后插入写屏障。一个值得注意的例外是，如果仅分配了 &lt;code&gt;parent&lt;/code&gt; 对象，并且此后未运行垃圾回收。请记住，大多数 &lt;code&gt;jl_...&lt;/code&gt; 函数有时可以调用垃圾回收。</target>
        </trans-unit>
        <trans-unit id="1e58853c75f92756885fe162715552efead15275" translate="yes" xml:space="preserve">
          <source>It is not permitted to modify the value of an immutable type.</source>
          <target state="translated">不允许修改不可变类型的值。</target>
        </trans-unit>
        <trans-unit id="737fc29ba3e3878487296ae0904e3501ba8b3de3" translate="yes" xml:space="preserve">
          <source>It is not possible to violate the invariants provided by the type's constructors.</source>
          <target state="translated">不能违反类型的构造函数所提供的不变量。</target>
        </trans-unit>
        <trans-unit id="9c82744b33d4a8c920b021b98d324b0dd36c7c0d" translate="yes" xml:space="preserve">
          <source>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last argument with an ellipsis:</source>
          <target state="translated">能够编写任意数量的参数的函数通常是很方便的。这种函数传统上被称为 &quot;varargs &quot;函数,它是 &quot;可变参数数 &quot;的缩写。你可以在最后一个参数后面用省略号来定义一个varargs函数。</target>
        </trans-unit>
        <trans-unit id="03d37775863d3d8aefef1deee1f9fba7a5cc77f8" translate="yes" xml:space="preserve">
          <source>It is often convenient to be able to write functions taking an arbitrary number of arguments. Such functions are traditionally known as &quot;varargs&quot; functions, which is short for &quot;variable number of arguments&quot;. You can define a varargs function by following the last positional argument with an ellipsis:</source>
          <target state="translated">编写任意数量的参数的函数往往很方便。这种函数传统上被称为 &quot;varargs &quot;函数,它是 &quot;可变参数数 &quot;的缩写。你可以在最后一个位置参数后面用省略号来定义一个varargs函数。</target>
        </trans-unit>
        <trans-unit id="67322f4620eb4bffc38ad6db6fb50c1b9b16e04a" translate="yes" xml:space="preserve">
          <source>It is often convenient to work with data structures that may contain values of any type (arrays of type &lt;code&gt;Array{Any}&lt;/code&gt;). But, if you're using one of these structures and happen to know the type of an element, it helps to share this knowledge with the compiler:</source>
          <target state="translated">使用可能包含任何类型的值（数组 &lt;code&gt;Array{Any}&lt;/code&gt; 数组）的数据结构通常很方便。但是，如果您使用的是这些结构之一，并且碰巧知道元素的类型，则有助于与编译器共享此知识：</target>
        </trans-unit>
        <trans-unit id="096c719abfea35b0b455d36ba64fc9420aa68bfd" translate="yes" xml:space="preserve">
          <source>It is often possible to provide sensible default values for function arguments. This can save users from having to pass every argument on every call. For example, the function &lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt;&lt;code&gt;Date(y, [m, d])&lt;/code&gt;&lt;/a&gt; from &lt;code&gt;Dates&lt;/code&gt; module constructs a &lt;code&gt;Date&lt;/code&gt; type for a given year &lt;code&gt;y&lt;/code&gt;, month &lt;code&gt;m&lt;/code&gt; and day &lt;code&gt;d&lt;/code&gt;. However, &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; arguments are optional and their default value is &lt;code&gt;1&lt;/code&gt;. This behavior can be expressed concisely as:</source>
          <target state="translated">通常可以为函数参数提供合理的默认值。这样可以避免用户在每次调用时都传递每个参数。例如，来自 &lt;code&gt;Dates&lt;/code&gt; 模块的函数&lt;a href=&quot;../../stdlib/dates/index#Dates.Date&quot;&gt; &lt;code&gt;Date(y, [m, d])&lt;/code&gt; &lt;/a&gt;为给定的年 &lt;code&gt;y&lt;/code&gt; ，月 &lt;code&gt;m&lt;/code&gt; 和日 &lt;code&gt;d&lt;/code&gt; 构造一个 &lt;code&gt;Date&lt;/code&gt; 类型。但是， &lt;code&gt;m&lt;/code&gt; 和 &lt;code&gt;d&lt;/code&gt; 参数是可选的，其默认值为 &lt;code&gt;1&lt;/code&gt; 。此行为可以简明表示为：</target>
        </trans-unit>
        <trans-unit id="4293de250d5dd5832be57fecdaa6e0a3c7af489c" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods&quot;&gt;Parametrically-constrained Varargs methods&lt;/a&gt;.</source>
          <target state="translated">可以限制作为变量参数传递的值的数量。稍后将在&lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods&quot;&gt;参数约束Varargs方法中&lt;/a&gt;对此进行讨论。</target>
        </trans-unit>
        <trans-unit id="284677cc407d046b65013c8fed718805f3d17cb7" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the number of values passed as a variable argument; this will be discussed later in &lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;Parametrically-constrained Varargs methods&lt;/a&gt;.</source>
          <target state="translated">可以限制作为变量参数传递的值的数量。稍后将在&lt;a href=&quot;../methods/index#Parametrically-constrained-Varargs-methods-1&quot;&gt;参数约束Varargs方法中&lt;/a&gt;对此进行讨论。</target>
        </trans-unit>
        <trans-unit id="a70320747de27e26b4b70f213eeadabc7679b96a" translate="yes" xml:space="preserve">
          <source>It is possible to define a set of function methods such that there is no unique most specific method applicable to some combinations of arguments:</source>
          <target state="translated">可以定义一组函数方法,使其不存在适用于某些参数组合的唯一的最特定方法。</target>
        </trans-unit>
        <trans-unit id="637c214ddc147146d30043be14f7af002a6afb37" translate="yes" xml:space="preserve">
          <source>It is possible to make use of metaprogramming to assist in the creation of documentation. When using string-interpolation within the docstring you will need to use an extra &lt;code&gt;$&lt;/code&gt; as shown with &lt;code&gt;$($name)&lt;/code&gt;:</source>
          <target state="translated">可以利用元编程来帮助创建文档。在文档字符串中使用字符串插值时，您将需要使用额外的 &lt;code&gt;$&lt;/code&gt; ，如 &lt;code&gt;$($name)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="deea519c4200e4fe336ac8810c406887e0570f07" translate="yes" xml:space="preserve">
          <source>It is possible to pass Julia functions to native C functions that accept function pointer arguments. For example, to match C prototypes of the form:</source>
          <target state="translated">可以将Julia函数传递给接受函数指针参数的本地C函数。例如,为了匹配形式的C原型。</target>
        </trans-unit>
        <trans-unit id="b862a89ec67717dcb808d8174cdd3cd9cf5de933" translate="yes" xml:space="preserve">
          <source>It is possible to write definitions like the following:</source>
          <target state="translated">可以写这样的定义:</target>
        </trans-unit>
        <trans-unit id="079123703d5fe6500844bec9cf4fbeb95441a39c" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">建议子类型 &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; 覆盖以下方法签名以提供更有效的实现： &lt;code&gt;unsafe_read(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4972fa162a33587e78213cfd46e68a922aa11ce5" translate="yes" xml:space="preserve">
          <source>It is recommended that subtypes &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; override the following method signature to provide more efficient implementations: &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</source>
          <target state="translated">建议子类型 &lt;code&gt;T&amp;lt;:IO&lt;/code&gt; 重写以下方法签名以提供更有效的实现： &lt;code&gt;unsafe_write(s::T, p::Ptr{UInt8}, n::UInt)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8e657552abcb773fba2d1c58477efeff3641733f" translate="yes" xml:space="preserve">
          <source>It is recommended that the disambiguating method be defined first, since otherwise the ambiguity exists, if transiently, until the more specific method is defined.</source>
          <target state="translated">建议首先界定消除歧义的方法,否则,在界定更具体的方法之前,即使是短暂的,也会存在歧义。</target>
        </trans-unit>
        <trans-unit id="3205262d1b20d05a3ec0c7f09158500e89b8710e" translate="yes" xml:space="preserve">
          <source>It is safe to execute iterations in arbitrary or overlapping order, with special consideration for reduction variables.</source>
          <target state="translated">以任意或重叠顺序执行迭代是安全的,要特别考虑还原变量。</target>
        </trans-unit>
        <trans-unit id="d10887452da1b7a8299e792daec58426383fc305" translate="yes" xml:space="preserve">
          <source>It is significant that like &lt;code&gt;if&lt;/code&gt;-&lt;code&gt;elseif&lt;/code&gt;-&lt;code&gt;else&lt;/code&gt;, the expressions before and after the &lt;code&gt;:&lt;/code&gt; are only evaluated if the condition expression evaluates to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively:</source>
          <target state="translated">重要的是，像 &lt;code&gt;if&lt;/code&gt; - &lt;code&gt;elseif&lt;/code&gt; - &lt;code&gt;else&lt;/code&gt; 一样，仅在条件表达式分别为 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 时才对 &lt;code&gt;:&lt;/code&gt; 之前和之后的表达式进行求值：</target>
        </trans-unit>
        <trans-unit id="6b7dd92481471c3be503cbed8b0ada7bae73d043" translate="yes" xml:space="preserve">
          <source>It is significantly more expensive to compute Cartesian indices from a linear index than it is to go the other way. The former operation requires division &amp;mdash; a very costly operation &amp;mdash; whereas the latter only uses multiplication and addition and is essentially free. This asymmetry means it is far more costly to use linear indexing with an &lt;code&gt;IndexCartesian&lt;/code&gt; array than it is to use Cartesian indexing with an &lt;code&gt;IndexLinear&lt;/code&gt; array.</source>
          <target state="translated">从线性索引计算笛卡尔索引要比用另一种方法昂贵得多。前一种运算需要除法-这是非常昂贵的运算-而后者仅使用乘法和加法，并且基本上是免费的。这种不对称装置这是更为昂贵使用线性索引与 &lt;code&gt;IndexCartesian&lt;/code&gt; 阵列比它是使用笛卡尔索引与 &lt;code&gt;IndexLinear&lt;/code&gt; 阵列。</target>
        </trans-unit>
        <trans-unit id="6abc534e54f65480aad0f619aee6267faddc4174" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient to terminate the repetition of a &lt;code&gt;while&lt;/code&gt; before the test condition is falsified or stop iterating in a &lt;code&gt;for&lt;/code&gt; loop before the end of the iterable object is reached. This can be accomplished with the &lt;code&gt;break&lt;/code&gt; keyword:</source>
          <target state="translated">有时很方便的是 &lt;code&gt;while&lt;/code&gt; 伪造测试条件之前终止一段时间的重复，或者在到达可迭代对象的末尾之前在 &lt;code&gt;for&lt;/code&gt; 循环中停止迭代。这可以通过 &lt;code&gt;break&lt;/code&gt; 关键字完成：</target>
        </trans-unit>
        <trans-unit id="20dfcec28a6dd8951f574998a3986a215e74fce8" translate="yes" xml:space="preserve">
          <source>It is sometimes helpful during module development to turn off incremental precompilation. The command line flag &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; enables you to toggle module precompilation on and off. When Julia is started with &lt;code&gt;--compiled-modules=no&lt;/code&gt; the serialized modules in the compile cache are ignored when loading modules and module dependencies. &lt;code&gt;Base.compilecache&lt;/code&gt; can still be called manually. The state of this command line flag is passed to &lt;code&gt;Pkg.build&lt;/code&gt; to disable automatic precompilation triggering when installing, updating, and explicitly building packages.</source>
          <target state="translated">有时在模块开发期间关闭增量预编译很有用。命令行标志 &lt;code&gt;--compiled-modules={yes|no}&lt;/code&gt; 使您可以打开和关闭模块预编译。当Julia以 &lt;code&gt;--compiled-modules=no&lt;/code&gt; 开头时，在加载模块和模块依赖项时，编译缓存中的序列化模块将被忽略。 &lt;code&gt;Base.compilecache&lt;/code&gt; 仍然可以手动调用。此命令行标志的状态传递给 &lt;code&gt;Pkg.build&lt;/code&gt; ,以在安装，更新和显式生成软件包时禁用自动预编译触发。</target>
        </trans-unit>
        <trans-unit id="94baf48d740dae1d64cb4dabcdca4ac61d569c1b" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to close (unload) a library so that it can be reloaded. For instance, when developing C code for use with Julia, one may need to compile, call the C code from Julia, then close the library, make an edit, recompile, and load in the new changes. One can either restart Julia or use the &lt;code&gt;Libdl&lt;/code&gt; functions to manage the library explicitly, such as:</source>
          <target state="translated">有时关闭（卸载）库以重新加载它很有用。例如，当开发用于Julia的C代码时，可能需要进行编译，从Julia中调用C代码，然后关闭库，进行编辑，重新编译并加载新更改。可以重新启动Julia或使用 &lt;code&gt;Libdl&lt;/code&gt; 函数来显式管理该库，例如：</target>
        </trans-unit>
        <trans-unit id="32e81dce90195c032e275e55f3bfa20c146074b3" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to perform element-by-element binary operations on arrays of different sizes, such as adding a vector to each column of a matrix. An inefficient way to do this would be to replicate the vector to the size of the matrix:</source>
          <target state="translated">有时,对不同大小的数组进行逐元素的二进制操作是很有用的,比如在矩阵的每一列中添加一个向量。一个低效的方法是将向量复制到矩阵的大小。</target>
        </trans-unit>
        <trans-unit id="58d81677369240f5f99e6de14b72f59ff777800d" translate="yes" xml:space="preserve">
          <source>It is to be noted that this is generally not an issue. It is something to be factored in only if the object is both being stored locally and modifed post the call. In such cases it may be appropriate to store a &lt;code&gt;deepcopy&lt;/code&gt; of the object.</source>
          <target state="translated">要注意的是，这通常不是问题。仅当对象既在本地存储又在调用后进行修改时，才应考虑这一点。在这种情况下，可能需要存储对象的 &lt;code&gt;deepcopy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4930241b205d76b9c3d495f83abf296392db54b7" translate="yes" xml:space="preserve">
          <source>It is usually best to avoid capturing references to instances of internal metadata objects such as &lt;code&gt;Method&lt;/code&gt;, &lt;code&gt;MethodInstance&lt;/code&gt;, &lt;code&gt;MethodTable&lt;/code&gt;, &lt;code&gt;TypeMapLevel&lt;/code&gt;, &lt;code&gt;TypeMapEntry&lt;/code&gt; and fields of those objects, as this can confuse the serializer and may not lead to the outcome you desire. It is not necessarily an error to do this, but you simply need to be prepared that the system will try to copy some of these and to create a single unique instance of others.</source>
          <target state="translated">通常最好避免捕获对内部元数据对象实例（例如 &lt;code&gt;Method&lt;/code&gt; ， &lt;code&gt;MethodInstance&lt;/code&gt; ， &lt;code&gt;MethodTable&lt;/code&gt; ，MethodTable， &lt;code&gt;TypeMapLevel&lt;/code&gt; ， &lt;code&gt;TypeMapEntry&lt;/code&gt; )的引用以及这些对象的字段，因为这可能会使序列化程序混淆，并且可能不会导致您想要的结果。这样做不一定是错误的，但是您只需要准备好系统将尝试复制其中一些并创建其他实例的唯一实例即可。</target>
        </trans-unit>
        <trans-unit id="b19a6924f8364edbfe868e5511ad36bcb64fff31" translate="yes" xml:space="preserve">
          <source>It is usually not much help to construct arrays like the following:</source>
          <target state="translated">通常情况下,像下面这样构造数组是没什么用的。</target>
        </trans-unit>
        <trans-unit id="e4380a1b0acd2209a89981ccd04cfa0fd834aaba" translate="yes" xml:space="preserve">
          <source>It is very important that the called function does not call back into Julia, as it will segfault.</source>
          <target state="translated">非常重要的一点是,被调用的函数不能回调到Julia中,因为这会导致segfault。</target>
        </trans-unit>
        <trans-unit id="334c0921872b88ab33e359bc32c0c7cf09fbdeba" translate="yes" xml:space="preserve">
          <source>It is worth emphasizing that strides are about offsets in memory rather than indexing. If you are looking to convert between linear (single-index) indexing and cartesian (multi-index) indexing, see &lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt;&lt;code&gt;LinearIndices&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt;&lt;code&gt;CartesianIndices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">值得强调的是，跨度是关于内存中的偏移量而不是索引。如果要在线性（单索引）索引和笛卡尔（多索引）索引之间进行转换，请参见&lt;a href=&quot;../../base/arrays/index#Base.LinearIndices&quot;&gt; &lt;code&gt;LinearIndices&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/arrays/index#Base.IteratorsMD.CartesianIndices&quot;&gt; &lt;code&gt;CartesianIndices&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="805fdc406fb3dba1fb93a133c29b22878b4c87dc" translate="yes" xml:space="preserve">
          <source>It may take optional keyword arguments:</source>
          <target state="translated">它可以接受可选的关键字参数。</target>
        </trans-unit>
        <trans-unit id="9d3c85b9245c7315a1b23d4e146f385ddcbfb243" translate="yes" xml:space="preserve">
          <source>It means that the type of the output is predictable from the types of the inputs. In particular, it means that the type of the output cannot vary depending on the &lt;em&gt;values&lt;/em&gt; of the inputs. The following code is &lt;em&gt;not&lt;/em&gt; type-stable:</source>
          <target state="translated">这意味着可以根据输入的类型来预测输出的类型。特别是，这意味着输出的类型不能根据输入的&lt;em&gt;值&lt;/em&gt;而变化。以下代码&lt;em&gt;不是&lt;/em&gt;类型稳定的：</target>
        </trans-unit>
        <trans-unit id="c3b7dcbf1418595d94f20981812341bdb45796ab" translate="yes" xml:space="preserve">
          <source>It only makes sense to take ratios of integer values, so the parameter type &lt;code&gt;T&lt;/code&gt; is restricted to being a subtype of &lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt;&lt;code&gt;Integer&lt;/code&gt;&lt;/a&gt;, and a ratio of integers represents a value on the real number line, so any &lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt;&lt;code&gt;Rational&lt;/code&gt;&lt;/a&gt; is an instance of the &lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; abstraction.</source>
          <target state="translated">仅取整数值的比率才有意义，因此将参数类型 &lt;code&gt;T&lt;/code&gt; 限制为&lt;a href=&quot;../../base/numbers/index#Core.Integer&quot;&gt; &lt;code&gt;Integer&lt;/code&gt; &lt;/a&gt;的子类型，并且整数比率表示实数行上的值，因此任何&lt;a href=&quot;../../base/numbers/index#Base.Rational&quot;&gt; &lt;code&gt;Rational&lt;/code&gt; &lt;/a&gt;都是&lt;a href=&quot;../../base/numbers/index#Core.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt;抽象的实例。</target>
        </trans-unit>
        <trans-unit id="a692191dac5658d6e6f21b53ff80758c81d0148d" translate="yes" xml:space="preserve">
          <source>It provides a mutable wrapper around an iterator and its iteration state.</source>
          <target state="translated">它提供了一个围绕迭代器及其迭代状态的可突变封装器。</target>
        </trans-unit>
        <trans-unit id="1341640325353ec21dd6ae9c9b69ddf97792b73e" translate="yes" xml:space="preserve">
          <source>It returns either an &lt;code&gt;Int&lt;/code&gt; or a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it must be able to cope with values of both types, which makes it hard to produce fast machine code.</source>
          <target state="translated">根据其参数值，它返回 &lt;code&gt;Int&lt;/code&gt; 或&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;。由于Julia无法在编译时预测此函数的返回类型，因此使用该函数的任何计算都必须能够处理两种类型的值，这使得难以生成快速的机器代码。</target>
        </trans-unit>
        <trans-unit id="75d07a5f3996139947136e92cd3660ed889424cf" translate="yes" xml:space="preserve">
          <source>It returns either an &lt;code&gt;Int&lt;/code&gt; or a &lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt;&lt;code&gt;Float64&lt;/code&gt;&lt;/a&gt; depending on the value of its argument. Since Julia can't predict the return type of this function at compile-time, any computation that uses it will have to guard against both types possibly occurring, making generation of fast machine code difficult.</source>
          <target state="translated">根据其参数值，它返回 &lt;code&gt;Int&lt;/code&gt; 或&lt;a href=&quot;../../base/numbers/index#Core.Float64&quot;&gt; &lt;code&gt;Float64&lt;/code&gt; &lt;/a&gt;。由于Julia无法在编译时预测此函数的返回类型，因此使用该函数的任何计算都必须防范可能发生的两种类型，从而难以生成快速的机器代码。</target>
        </trans-unit>
        <trans-unit id="e13bba493365e2c5b2e76f0ae39f91eaa1b27bd1" translate="yes" xml:space="preserve">
          <source>It should however be noted that the compiler is quite efficient at optimizing away the dead branches in code written as the &lt;code&gt;mynorm&lt;/code&gt; example.</source>
          <target state="translated">但是应该注意，编译器在优化作为 &lt;code&gt;mynorm&lt;/code&gt; 示例编写的代码中的无效分支方面非常有效。</target>
        </trans-unit>
        <trans-unit id="429ea7fe9a07243d9d929909311d0c5286ba8da0" translate="yes" xml:space="preserve">
          <source>It turns an iterator-like abstraction into a &lt;code&gt;Channel&lt;/code&gt;-like abstraction.</source>
          <target state="translated">它将类似迭代器的抽象转换为类似 &lt;code&gt;Channel&lt;/code&gt; 的抽象。</target>
        </trans-unit>
        <trans-unit id="85d168e5e85b9af5b4b41b997ebf680755497e13" translate="yes" xml:space="preserve">
          <source>It's a good idea to first run the code you intend to profile at least once (unless you want to profile Julia's JIT-compiler):</source>
          <target state="translated">最好是先运行你打算配置的代码至少一次(除非你想配置Julia的JIT编译器)。</target>
        </trans-unit>
        <trans-unit id="6aa7c46c7a469a8066f30e0a6330c5f7107a8c6d" translate="yes" xml:space="preserve">
          <source>It's also possible to add cross-references to other documented functions/methods/variables within the Julia documentation itself. For example:</source>
          <target state="translated">也可以在Julia文档中添加对其他文档中的函数/方法/变量的交叉引用。例如:在Julia文档中,可以添加交叉引用到其他文档中的函数/方法/变量。</target>
        </trans-unit>
        <trans-unit id="d58241f9f697434c4e06081f155d61314cbdb71e" translate="yes" xml:space="preserve">
          <source>It's an iterator that mutates to become its own rest iterator whenever an item is produced.</source>
          <target state="translated">这是一个迭代器,每当一个项目产生时,它就会变异成为自己的休息迭代器。</target>
        </trans-unit>
        <trans-unit id="4aa36d32a2c02cf6990c1d5d08f2ca5067ed910f" translate="yes" xml:space="preserve">
          <source>It's easiest to illustrate this with an example. We can declare a generated function &lt;code&gt;foo&lt;/code&gt; as</source>
          <target state="translated">举个例子最容易说明这一点。我们可以将生成的函数 &lt;code&gt;foo&lt;/code&gt; 声明为</target>
        </trans-unit>
        <trans-unit id="7ecf0f0b27cffd70c113f40a095f8c8f53901430" translate="yes" xml:space="preserve">
          <source>It's far less clear what should happen here. Since &lt;code&gt;x + &quot;hello&quot;&lt;/code&gt; is a method error, it seems probable that the intention is for &lt;code&gt;x&lt;/code&gt; to be local to the &lt;code&gt;for&lt;/code&gt; loop. But runtime values and what methods happen to exist cannot be used to determine the scopes of variables. With the Julia &amp;le; 0.6 behavior, it's especially concerning that someone might have written the &lt;code&gt;for&lt;/code&gt; loop first, had it working just fine, but later when someone else adds a new global far away&amp;mdash;possibly in a different file&amp;mdash;the code suddenly changes meaning and either breaks noisily or, worse still, silently does the wrong thing. This kind of &lt;a href=&quot;https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)&quot;&gt;&quot;spooky action at a distance&quot;&lt;/a&gt; is something that good programming language designs should prevent.</source>
          <target state="translated">目前尚不清楚在这里应该发生什么。由于 &lt;code&gt;x + &quot;hello&quot;&lt;/code&gt; 是方法错误，因此看来 &lt;code&gt;x&lt;/code&gt; 的意图很可能是 &lt;code&gt;for&lt;/code&gt; 循环的局部变量。但是不能使用运行时值和存在的方法来确定变量的范围。对于Julia&amp;le;0.6的行为，尤其令人担忧的是，有人可能首先编写了 &lt;code&gt;for&lt;/code&gt; 循环，使其工作正常，但是后来当其他人在较远的地方（可能在另一个文件中）添加了新的全局变量时，代码突然改变了含义，要么吵闹，要么更糟的是，默默地做错事。良好的编程语言设计应避免这种&lt;a href=&quot;https://en.wikipedia.org/wiki/Action_at_a_distance_(computer_programming)&quot;&gt;&amp;ldquo;远距离的怪异动作&amp;rdquo;&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="38dda39f4395bbec3e9a522986faf60e028082c7" translate="yes" xml:space="preserve">
          <source>It's good practice when using any language/date framework to be familiar with how date-period arithmetic is handled as there are some &lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;tricky issues&lt;/a&gt; to deal with (though much less so for day-precision types).</source>
          <target state="translated">当使用任何语言/日期框架来熟悉如何处理日期周期算术时，这是一个好习惯，因为要处理一些&lt;a href=&quot;https://codeblog.jonskeet.uk/2010/12/01/the-joys-of-date-time-arithmetic/&quot;&gt;棘手的问题&lt;/a&gt;（尽管对于日精度类型而言要少得多）。</target>
        </trans-unit>
        <trans-unit id="0640f8fda4ec7bf5464b3cee97ae0f4dda5ee1e4" translate="yes" xml:space="preserve">
          <source>It's important to be aware of potentially dangerous situations such as concatenation of invalid UTF-8 strings. The resulting string may contain different characters than the input strings, and its number of characters may be lower than sum of numbers of characters of the concatenated strings, e.g.:</source>
          <target state="translated">重要的是要注意潜在的危险情况,如无效UTF-8字符串的连接。所产生的字符串可能包含与输入字符串不同的字符,其字符数可能低于连接字符串的字符数之和,例如:。</target>
        </trans-unit>
        <trans-unit id="3dbecc240e8c1b98fcd4c298d9a96ae72e276750" translate="yes" xml:space="preserve">
          <source>It's important to note that there's a very large assymmetry in the performance of these conversions. Converting a linear index to a set of cartesian indices requires dividing and taking the remainder, whereas going the other way is just multiplies and adds. In modern processors, integer division can be 10-50 times slower than multiplication. While some arrays &amp;mdash; like &lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt; itself &amp;mdash; are implemented using a linear chunk of memory and directly use a linear index in their implementations, other arrays &amp;mdash; like &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt;&lt;code&gt;Diagonal&lt;/code&gt;&lt;/a&gt; &amp;mdash; need the full set of cartesian indices to do their lookup (see &lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt;&lt;code&gt;IndexStyle&lt;/code&gt;&lt;/a&gt; to introspect which is which). As such, when iterating over an entire array, it's much better to iterate over &lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt;&lt;code&gt;eachindex(A)&lt;/code&gt;&lt;/a&gt; instead of &lt;code&gt;1:length(A)&lt;/code&gt;. Not only will the former be much faster in cases where &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;IndexCartesian&lt;/code&gt;, but it will also support OffsetArrays, too.</source>
          <target state="translated">重要的是要注意，这些转换的性能存在很大的不对称性。将线性索引转换为一组笛卡尔索引需要除以余数，而采用另一种方法就是相乘和相加。在现代处理器中，整数除法可能比乘法慢10至50倍。尽管某些数组（例如&lt;a href=&quot;../../base/arrays/index#Core.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt;本身）是使用线性内存块实现的，并在其实现中直接使用线性索引，但其他数组（例如&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.Diagonal&quot;&gt; &lt;code&gt;Diagonal&lt;/code&gt; &lt;/a&gt;）则需要完整的笛卡尔索引集来进行查找（请参阅&lt;a href=&quot;../../base/arrays/index#Base.IndexStyle&quot;&gt; &lt;code&gt;IndexStyle&lt;/code&gt; &lt;/a&gt;进行自省，哪一个）。这样，当遍历整个数组时，最好遍历&lt;a href=&quot;../../base/arrays/index#Base.eachindex&quot;&gt; &lt;code&gt;eachindex(A)&lt;/code&gt; &lt;/a&gt;而不是遍历 &lt;code&gt;1:length(A)&lt;/code&gt; 。在 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;IndexCartesian&lt;/code&gt; 的情况下，前者不仅会更快，而且也将支持OffsetArrays。</target>
        </trans-unit>
        <trans-unit id="2ae198b8fe13fc0c80ed5149210f17463c0121d1" translate="yes" xml:space="preserve">
          <source>It's no longer convenient to copy and paste the code from inside a function body into the REPL to debug it&amp;mdash;you have to add &lt;code&gt;global&lt;/code&gt; annotations and then remove them again to go back;</source>
          <target state="translated">从函数体内复制代码并将其粘贴到REPL中进行调试不再方便了-您必须添加 &lt;code&gt;global&lt;/code&gt; 注释，然后再次将其删除以返回；</target>
        </trans-unit>
        <trans-unit id="53f0c889cfa216f7a561510a3ad57de629360e4b" translate="yes" xml:space="preserve">
          <source>It's now possible to get a sampler with &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt;, and use &lt;code&gt;sp&lt;/code&gt; instead of &lt;code&gt;die&lt;/code&gt; in any &lt;code&gt;rand&lt;/code&gt; call involving &lt;code&gt;rng&lt;/code&gt;. In the simplistic example above, &lt;code&gt;die&lt;/code&gt; doesn't need to be stored in &lt;code&gt;SamplerDie&lt;/code&gt; but this is often the case in practice.</source>
          <target state="translated">现在可以使用 &lt;code&gt;sp = Sampler(rng, die)&lt;/code&gt; 获得一个采样器，并在涉及 &lt;code&gt;rng&lt;/code&gt; 的任何 &lt;code&gt;rand&lt;/code&gt; 调用中使用 &lt;code&gt;sp&lt;/code&gt; 代替 &lt;code&gt;die&lt;/code&gt; 。在上面的简单示例中，无需将 &lt;code&gt;die&lt;/code&gt; 存储在 &lt;code&gt;SamplerDie&lt;/code&gt; 中,但实际上通常是这样。</target>
        </trans-unit>
        <trans-unit id="435e5d30b709899a41a3dc97d975e671346837d6" translate="yes" xml:space="preserve">
          <source>It's quite instructive to compare the sheer amount code generated for a simple function</source>
          <target state="translated">比较一下一个简单函数所产生的代码量是很有启发意义的。</target>
        </trans-unit>
        <trans-unit id="485af6f7d5c0b66af203ac099b1bf7b0eba726ba" translate="yes" xml:space="preserve">
          <source>It's worth emphasizing that &lt;code&gt;localindices&lt;/code&gt; exists purely as a convenience, and you can partition work on the array among workers any way you wish. For a &lt;code&gt;SharedArray&lt;/code&gt;, all indices should be equally fast for each worker process.</source>
          <target state="translated">值得强调的是， &lt;code&gt;localindices&lt;/code&gt; 纯粹是为了方便起见而存在，您可以按自己希望的方式在工人之间对阵列进行分区。对于 &lt;code&gt;SharedArray&lt;/code&gt; ，每个工作进程的所有索引都应同样快。</target>
        </trans-unit>
        <trans-unit id="948d6de7c32c1a31093f07d2e218322318e4b407" translate="yes" xml:space="preserve">
          <source>It's worth noting that it's extremely easy to mis-use parametric &quot;value&quot; types, including &lt;code&gt;Val&lt;/code&gt;; in unfavorable cases, you can easily end up making the performance of your code much &lt;em&gt;worse&lt;/em&gt;. In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of &lt;code&gt;Val&lt;/code&gt;, please read &lt;a href=&quot;../performance-tips/index#man-performance-value-type&quot;&gt;the more extensive discussion in the performance tips&lt;/a&gt;.</source>
          <target state="translated">值得注意的是，滥用包括 &lt;code&gt;Val&lt;/code&gt; 在内的参数&amp;ldquo;值&amp;rdquo;类型非常容易。在不利的情况下，您很容易最终使代码的性能&lt;em&gt;变差&lt;/em&gt;。特别是，您永远都不想编写如上所述的实际代码。有关正确（和不正确）使用 &lt;code&gt;Val&lt;/code&gt; 的更多信息，请阅读&lt;a href=&quot;../performance-tips/index#man-performance-value-type&quot;&gt;性能提示中更广泛的讨论&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="7d5d6404960db7e0b184fd1dfa040fb8f1124932" translate="yes" xml:space="preserve">
          <source>It's worth noting that it's extremely easy to mis-use parametric &quot;value&quot; types, including &lt;code&gt;Val&lt;/code&gt;; in unfavorable cases, you can easily end up making the performance of your code much &lt;em&gt;worse&lt;/em&gt;. In particular, you would never want to write actual code as illustrated above. For more information about the proper (and improper) uses of &lt;code&gt;Val&lt;/code&gt;, please read the more extensive discussion in &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;the performance tips&lt;/a&gt;.</source>
          <target state="translated">值得注意的是，滥用参数&amp;ldquo;值&amp;rdquo;类型非常容易，包括 &lt;code&gt;Val&lt;/code&gt; ；在不利的情况下，您很容易最终使代码的性能&lt;em&gt;变差&lt;/em&gt;。特别是，您永远都不想编写如上所述的实际代码。有关正确（和不正确）使用 &lt;code&gt;Val&lt;/code&gt; 的更多信息，请阅读&lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;性能提示中&lt;/a&gt;更广泛的讨论。</target>
        </trans-unit>
        <trans-unit id="3b9b0722d0d43e4d14ff92cca723a64b8e24e4f0" translate="yes" xml:space="preserve">
          <source>Italics</source>
          <target state="translated">Italics</target>
        </trans-unit>
        <trans-unit id="c218bb3261ced0b188316d903cb0484a6a43b61a" translate="yes" xml:space="preserve">
          <source>Iterable Collections</source>
          <target state="translated">迭代集合</target>
        </trans-unit>
        <trans-unit id="81a99e5d5fc07b72d6b1647c497a7c5192f69fad" translate="yes" xml:space="preserve">
          <source>Iterate over a collection &lt;code&gt;n&lt;/code&gt; elements at a time.</source>
          <target state="translated">一次遍历一个集合 &lt;code&gt;n&lt;/code&gt; 个元素。</target>
        </trans-unit>
        <trans-unit id="7878c863963cb51356acf7ca3e8ea44be505a483" translate="yes" xml:space="preserve">
          <source>Iterated dispatch</source>
          <target state="translated">迭代调度</target>
        </trans-unit>
        <trans-unit id="42206b6c92650b3931037fd07719156176dc0314" translate="yes" xml:space="preserve">
          <source>Iterating over the &lt;code&gt;CartesianIndices&lt;/code&gt; of the &lt;code&gt;axes(::Broadcasted)&lt;/code&gt; and using indexing with the resulting &lt;code&gt;CartesianIndex&lt;/code&gt; object to compute the result.</source>
          <target state="translated">遍历axis &lt;code&gt;axes(::Broadcasted)&lt;/code&gt; 的 &lt;code&gt;CartesianIndices&lt;/code&gt; ，并将索引与结果 &lt;code&gt;CartesianIndex&lt;/code&gt; 对象一起使用以计算结果。</target>
        </trans-unit>
        <trans-unit id="a4979919b853dff1595ccf476a13a01680f6c472" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.S&lt;/code&gt;, &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Q&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, &lt;code&gt;F.&amp;alpha;&lt;/code&gt;, and &lt;code&gt;F.&amp;beta;&lt;/code&gt;.</source>
          <target state="translated">迭代分解产生组分 &lt;code&gt;F.S&lt;/code&gt; ， &lt;code&gt;F.T&lt;/code&gt; ， &lt;code&gt;F.Q&lt;/code&gt; ， &lt;code&gt;F.Z&lt;/code&gt; ， &lt;code&gt;F.&amp;alpha;&lt;/code&gt; ，和 &lt;code&gt;F.&amp;beta;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fc67e8a927f1aa6eff5ad47840e758df966f518f" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.T&lt;/code&gt;, &lt;code&gt;F.Z&lt;/code&gt;, and &lt;code&gt;F.values&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生分量 &lt;code&gt;F.T&lt;/code&gt; ， &lt;code&gt;F.Z&lt;/code&gt; 和 &lt;code&gt;F.values&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4d4ad8d2cf2c1ee9c60ddef640294bbac58cbc2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;F.values&lt;/code&gt; and &lt;code&gt;F.vectors&lt;/code&gt;.</source>
          <target state="translated">迭代分解会生成分量 &lt;code&gt;F.values&lt;/code&gt; 和 &lt;code&gt;F.vectors&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="86506020c8187a26d343a03489380c16723ff386" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">迭代分解产生组分 &lt;code&gt;Q&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0eea487785d89d96fdac640a6604fc8fe54c944d" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生分量 &lt;code&gt;Q&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cab411fc4fe9253bda3d235df40d5dfd6ef9668c" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, and if extant &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生分量 &lt;code&gt;Q&lt;/code&gt; ， &lt;code&gt;R&lt;/code&gt; 和（如果存在） &lt;code&gt;p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b3b6360c2464673a0e4fb9b1ed45a041967155d6" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.D&lt;/code&gt;, &lt;code&gt;S.U&lt;/code&gt; or &lt;code&gt;S.L&lt;/code&gt; as appropriate given &lt;code&gt;S.uplo&lt;/code&gt;, and &lt;code&gt;S.p&lt;/code&gt;.</source>
          <target state="translated">在给定 &lt;code&gt;S.uplo&lt;/code&gt; 和 &lt;code&gt;S.p&lt;/code&gt; 情况下，迭代分解将生成适当的分量 &lt;code&gt;S.D&lt;/code&gt; ， &lt;code&gt;S.U&lt;/code&gt; 或 &lt;code&gt;S.L&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f77bd282f84af7bfe48cdf3c4e7e8dc8c570cc8e" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;S.L&lt;/code&gt; and &lt;code&gt;S.Q&lt;/code&gt;.</source>
          <target state="translated">迭代分解会生成分量 &lt;code&gt;S.L&lt;/code&gt; 和 &lt;code&gt;S.Q&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="89ebce396ac9da86f707ddc5cfcf6229ef6143e2" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, and &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">迭代分解产生组分 &lt;code&gt;U&lt;/code&gt; ， &lt;code&gt;S&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c715668f8440af4b021f6c74fa32fef39d559c06" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the components &lt;code&gt;U&lt;/code&gt;, &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;Q&lt;/code&gt;, &lt;code&gt;D1&lt;/code&gt;, &lt;code&gt;D2&lt;/code&gt;, and &lt;code&gt;R0&lt;/code&gt;.</source>
          <target state="translated">迭代分解会生成分量 &lt;code&gt;U&lt;/code&gt; ， &lt;code&gt;V&lt;/code&gt; ， &lt;code&gt;Q&lt;/code&gt; ， &lt;code&gt;D1&lt;/code&gt; ， &lt;code&gt;D2&lt;/code&gt; 和 &lt;code&gt;R0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="58ad8afd3ef50f0b4cdfded417b61d5f6036a1c3" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the factors &lt;code&gt;F.Q, F.H, F.&amp;mu;&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生因子 &lt;code&gt;F.Q, F.H, F.&amp;mu;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b09a0a43519ceb489793a2ede6c213029b86bdfc" translate="yes" xml:space="preserve">
          <source>Iterating the decomposition produces the factors &lt;code&gt;F.Q&lt;/code&gt; and &lt;code&gt;F.H&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生因子 &lt;code&gt;F.Q&lt;/code&gt; 和 &lt;code&gt;F.H&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f58aa126be8fea0928c97cbc1c2e33d08204701b" translate="yes" xml:space="preserve">
          <source>Iterating the factorization produces the components &lt;code&gt;F.L&lt;/code&gt;, &lt;code&gt;F.U&lt;/code&gt;, and &lt;code&gt;F.p&lt;/code&gt;.</source>
          <target state="translated">迭代分解会产生分量 &lt;code&gt;F.L&lt;/code&gt; ， &lt;code&gt;F.U&lt;/code&gt; 和 &lt;code&gt;F.p&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="18905aab409cadb5b72681a650ec99001cb221e0" translate="yes" xml:space="preserve">
          <source>Iteration</source>
          <target state="translated">Iteration</target>
        </trans-unit>
        <trans-unit id="ca49cf020b23404ede665f3ef9ef58b961aea893" translate="yes" xml:space="preserve">
          <source>Iteration over &lt;code&gt;NamedTuple&lt;/code&gt;s produces the &lt;em&gt;values&lt;/em&gt; without the names. (See example below.) To iterate over the name-value pairs, use the &lt;a href=&quot;../collections/index#Base.pairs&quot;&gt;&lt;code&gt;pairs&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">对 &lt;code&gt;NamedTuple&lt;/code&gt; 进行迭代将生成不带名称的&lt;em&gt;值&lt;/em&gt;。（请参见下面的示例。）要遍历名称/值对，请使用&lt;a href=&quot;../collections/index#Base.pairs&quot;&gt; &lt;code&gt;pairs&lt;/code&gt; &lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="029d5196356372d794cb53808ecda6f8a64c6198" translate="yes" xml:space="preserve">
          <source>Iteration utilities</source>
          <target state="translated">迭代工具</target>
        </trans-unit>
        <trans-unit id="bc1f336bbebec9ed2484b3179ad56691be7b079d" translate="yes" xml:space="preserve">
          <source>IteratorEltype</source>
          <target state="translated">IteratorEltype</target>
        </trans-unit>
        <trans-unit id="762bcf9ad00a1c98c7dfe72f3f1da300a726ae97" translate="yes" xml:space="preserve">
          <source>IteratorSize</source>
          <target state="translated">IteratorSize</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="ade312c99a3f29ec263e6761dccc45de6d98af27" translate="yes" xml:space="preserve">
          <source>Iterators.Pairs</source>
          <target state="translated">Iterators.Pairs</target>
        </trans-unit>
        <trans-unit id="7f99860914bab93742ec0677d93601e7f754aab7" translate="yes" xml:space="preserve">
          <source>Iterators.Stateful</source>
          <target state="translated">Iterators.Stateful</target>
        </trans-unit>
        <trans-unit id="4b22c43fb78a467e966bea6e6bf82f640caa802a" translate="yes" xml:space="preserve">
          <source>Iterators.countfrom()</source>
          <target state="translated">Iterators.countfrom()</target>
        </trans-unit>
        <trans-unit id="6e9ea1a37868f81f1c387104af3ddce669dd91f6" translate="yes" xml:space="preserve">
          <source>Iterators.cycle()</source>
          <target state="translated">Iterators.cycle()</target>
        </trans-unit>
        <trans-unit id="15fc1b0f962745a0f7d6dddec1a5029f764fddf9" translate="yes" xml:space="preserve">
          <source>Iterators.drop()</source>
          <target state="translated">Iterators.drop()</target>
        </trans-unit>
        <trans-unit id="b622262f6019cdcf33dc40c2166a76e9968c2d6f" translate="yes" xml:space="preserve">
          <source>Iterators.enumerate()</source>
          <target state="translated">Iterators.enumerate()</target>
        </trans-unit>
        <trans-unit id="18c6e2577f1cb3f1df18e8349820ab2df102ed03" translate="yes" xml:space="preserve">
          <source>Iterators.filter()</source>
          <target state="translated">Iterators.filter()</target>
        </trans-unit>
        <trans-unit id="1c4406a3948ea47560dd3a48a99cedb41058481a" translate="yes" xml:space="preserve">
          <source>Iterators.flatten()</source>
          <target state="translated">Iterators.flatten()</target>
        </trans-unit>
        <trans-unit id="e6b2ae68200d1658f8b9b58b1bda15c7a94398ec" translate="yes" xml:space="preserve">
          <source>Iterators.partition()</source>
          <target state="translated">Iterators.partition()</target>
        </trans-unit>
        <trans-unit id="8d055b9ee1bc21393531304979f760c0dcaf8ed7" translate="yes" xml:space="preserve">
          <source>Iterators.product()</source>
          <target state="translated">Iterators.product()</target>
        </trans-unit>
        <trans-unit id="f82f74da2e638549fe42f2abf5e3d47275b9d6dc" translate="yes" xml:space="preserve">
          <source>Iterators.repeated()</source>
          <target state="translated">Iterators.repeated()</target>
        </trans-unit>
        <trans-unit id="d0a4aaf299b047ef88d9088cb3265b8c9ec460f8" translate="yes" xml:space="preserve">
          <source>Iterators.rest()</source>
          <target state="translated">Iterators.rest()</target>
        </trans-unit>
        <trans-unit id="78c5327cecfd4b16a167206d910e94f07f9e5a1d" translate="yes" xml:space="preserve">
          <source>Iterators.reverse()</source>
          <target state="translated">Iterators.reverse()</target>
        </trans-unit>
        <trans-unit id="1780ae66e17e617d0386e7c850f35f9a46563eec" translate="yes" xml:space="preserve">
          <source>Iterators.take()</source>
          <target state="translated">Iterators.take()</target>
        </trans-unit>
        <trans-unit id="38d733610a11317778f298c2adaafc9ed0e772f3" translate="yes" xml:space="preserve">
          <source>Iterators.zip()</source>
          <target state="translated">Iterators.zip()</target>
        </trans-unit>
        <trans-unit id="e5c9811ac9fab746e9ba97b16b953053ef624d64" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndex</source>
          <target state="translated">IteratorsMD.CartesianIndex</target>
        </trans-unit>
        <trans-unit id="dab2cf0daf838d270ad35eb4a74061238bf4a503" translate="yes" xml:space="preserve">
          <source>IteratorsMD.CartesianIndices</source>
          <target state="translated">IteratorsMD.CartesianIndices</target>
        </trans-unit>
        <trans-unit id="30ab5c44fe067198393909d62c86b0c386a162b7" translate="yes" xml:space="preserve">
          <source>Its second argument &lt;code&gt;args&lt;/code&gt; is an array of &lt;code&gt;jl_value_t*&lt;/code&gt; arguments and &lt;code&gt;nargs&lt;/code&gt; is the number of arguments.</source>
          <target state="translated">它的第二个参数 &lt;code&gt;args&lt;/code&gt; 是 &lt;code&gt;jl_value_t*&lt;/code&gt; 参数的数组，而 &lt;code&gt;nargs&lt;/code&gt; 是参数的数量。</target>
        </trans-unit>
        <trans-unit id="286bb02d594ea15955d87681e8267067be410857" translate="yes" xml:space="preserve">
          <source>Izakaya Lantern</source>
          <target state="translated">居酒屋灯笼</target>
        </trans-unit>
        <trans-unit id="2f5fc08c12a2ccfd9c859b035ca12cb9526ce0af" translate="yes" xml:space="preserve">
          <source>J R Bunch and L Kaufman, Some stable methods for calculating inertia</source>
          <target state="translated">J R Bunch and L Kaufman,Some stable methods for calculating intia.</target>
        </trans-unit>
        <trans-unit id="831fdbe2f742b632acf268054e5932135a416335" translate="yes" xml:space="preserve">
          <source>Jack-O-Lantern</source>
          <target state="translated">Jack-O-Lantern</target>
        </trans-unit>
        <trans-unit id="efed3690ea2243f5f1ac77cbb0987e5335440258" translate="yes" xml:space="preserve">
          <source>Jan</source>
          <target state="translated">Jan</target>
        </trans-unit>
        <trans-unit id="7a22d73d336abd6281d4dd71080220a230cb79de" translate="yes" xml:space="preserve">
          <source>January</source>
          <target state="translated">January</target>
        </trans-unit>
        <trans-unit id="ad6d155a582ef676e9240bfd2300a9eb9553e4f3" translate="yes" xml:space="preserve">
          <source>Japanese Castle</source>
          <target state="translated">日本城</target>
        </trans-unit>
        <trans-unit id="ed8bfe0cf71057039bd166fcb8a33ed47c1d1057" translate="yes" xml:space="preserve">
          <source>Japanese Dolls</source>
          <target state="translated">日本娃娃</target>
        </trans-unit>
        <trans-unit id="97302784bd85c6fc3ccdcadbac4da292edfbb8ba" translate="yes" xml:space="preserve">
          <source>Japanese Goblin</source>
          <target state="translated">日本妖精</target>
        </trans-unit>
        <trans-unit id="7263dbff30ade45b8568943da751abb88bf70826" translate="yes" xml:space="preserve">
          <source>Japanese Ogre</source>
          <target state="translated">日本食人魔</target>
        </trans-unit>
        <trans-unit id="134fe6f595c84ed345de3ae0637be6654696bcaa" translate="yes" xml:space="preserve">
          <source>Japanese Post Office</source>
          <target state="translated">日本邮局</target>
        </trans-unit>
        <trans-unit id="0239b1f09d4f7c4b093fb50eb113f3c45f2d4d30" translate="yes" xml:space="preserve">
          <source>Japanese Symbol For Beginner</source>
          <target state="translated">初级日语符号</target>
        </trans-unit>
        <trans-unit id="d1e9767d8a0bd6d2bf67011d187d114cce67abb1" translate="yes" xml:space="preserve">
          <source>Jeans</source>
          <target state="translated">Jeans</target>
        </trans-unit>
        <trans-unit id="e0d73143de80d17e82de2e017ac156ca3b9c4e01" translate="yes" xml:space="preserve">
          <source>Join</source>
          <target state="translated">Join</target>
        </trans-unit>
        <trans-unit id="3b3813dad3290588a2d14e75a092fcd63a072388" translate="yes" xml:space="preserve">
          <source>Join an array of &lt;code&gt;strings&lt;/code&gt; into a single string, inserting the given delimiter (if any) between adjacent strings. If &lt;code&gt;last&lt;/code&gt; is given, it will be used instead of &lt;code&gt;delim&lt;/code&gt; between the last two strings. If &lt;code&gt;io&lt;/code&gt; is given, the result is written to &lt;code&gt;io&lt;/code&gt; rather than returned as as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;strings&lt;/code&gt; 数组连接到单个字符串中，然后在相邻字符串之间插入给定的分隔符（如果有）。如果给出了 &lt;code&gt;last&lt;/code&gt; ，则将在最后两个字符串之间使用它代替 &lt;code&gt;delim&lt;/code&gt; 。如果给定 &lt;code&gt;io&lt;/code&gt; ，则将结果写入 &lt;code&gt;io&lt;/code&gt; 而不是作为 &lt;code&gt;String&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="76788f50771e86fe282c9d53f0b06082b3018e7d" translate="yes" xml:space="preserve">
          <source>Join an array of &lt;code&gt;strings&lt;/code&gt; into a single string, inserting the given delimiter between adjacent strings. If &lt;code&gt;last&lt;/code&gt; is given, it will be used instead of &lt;code&gt;delim&lt;/code&gt; between the last two strings. If &lt;code&gt;io&lt;/code&gt; is given, the result is written to &lt;code&gt;io&lt;/code&gt; rather than returned as as a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">将 &lt;code&gt;strings&lt;/code&gt; 数组连接为单个字符串，在相邻字符串之间插入给定的分隔符。如果给出了 &lt;code&gt;last&lt;/code&gt; ，则将在最后两个字符串之间使用它代替 &lt;code&gt;delim&lt;/code&gt; 。如果给定 &lt;code&gt;io&lt;/code&gt; ，则将结果写入 &lt;code&gt;io&lt;/code&gt; 而不是作为 &lt;code&gt;String&lt;/code&gt; 返回。</target>
        </trans-unit>
        <trans-unit id="0499501b2bb39022852369c1a09b6f3fb6fc16a6" translate="yes" xml:space="preserve">
          <source>Join path components into a full path. If some argument is an absolute path or (on Windows) has a drive specification that doesn't match the drive computed for the join of the preceding paths, then prior components are dropped.</source>
          <target state="translated">将路径组件连接成一个完整的路径。如果某个参数是绝对路径,或者(在Windows下)它的驱动器规格与前面路径的连接计算的驱动器不匹配,那么前面的组件将被放弃。</target>
        </trans-unit>
        <trans-unit id="e64d664b335757ab1b0ed70dc6883a5f412be34b" translate="yes" xml:space="preserve">
          <source>Julia</source>
          <target state="translated">Julia</target>
        </trans-unit>
        <trans-unit id="34915350c4729155e12aa2a18e1437b46a254b8d" translate="yes" xml:space="preserve">
          <source>Julia 1.1</source>
          <target state="translated">Julia 1.1</target>
        </trans-unit>
        <trans-unit id="20d44d7c210bfc70cdc873c771c707c9f3303af5" translate="yes" xml:space="preserve">
          <source>Julia 1.2</source>
          <target state="translated">Julia 1.2</target>
        </trans-unit>
        <trans-unit id="8b642007f455f270d5f4ca8eeb353a9cd627fd87" translate="yes" xml:space="preserve">
          <source>Julia 1.2 Documentation</source>
          <target state="translated">Julia 1.2 文档</target>
        </trans-unit>
        <trans-unit id="735bc5320f837b1441f2cfffa31dd786468645d6" translate="yes" xml:space="preserve">
          <source>Julia 1.5 Documentation</source>
          <target state="translated">Julia 1.5 文档</target>
        </trans-unit>
        <trans-unit id="858ca45563192af10cdc21c94e7d577c6f26612b" translate="yes" xml:space="preserve">
          <source>Julia Base Type</source>
          <target state="translated">茱莉亚基地类型</target>
        </trans-unit>
        <trans-unit id="c3d7a86babfba0e54357fb2d1ed82f5bfe9ac6bf" translate="yes" xml:space="preserve">
          <source>Julia Base contains a range of functions and macros appropriate for performing scientific and numerical computing, but is also as broad as those of many general purpose programming languages. Additional functionality is available from a growing collection of available packages. Functions are grouped by topic below.</source>
          <target state="translated">Julia Base包含一系列适合于进行科学和数值计算的函数和宏,但也和许多通用编程语言一样广泛。其他的功能可以从越来越多的可用包中获得。下面按主题对函数进行了分类。</target>
        </trans-unit>
        <trans-unit id="ecea329751a7da4bad931e777e922977157ad8f8" translate="yes" xml:space="preserve">
          <source>Julia Base uses this convention throughout and contains examples of functions with both copying and modifying forms (e.g., &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;), and others which are just modifying (e.g., &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt;&lt;code&gt;pop!&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt;&lt;code&gt;splice!&lt;/code&gt;&lt;/a&gt;). It is typical for such functions to also return the modified array for convenience.</source>
          <target state="translated">Julia Base始终使用该约定，并包含具有复制和修改形式的函数示例（例如，&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;），以及仅在进行修改的函数示例（例如，&lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/collections/index#Base.pop!&quot;&gt; &lt;code&gt;pop!&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/collections/index#Base.splice!&quot;&gt; &lt;code&gt;splice!&lt;/code&gt; &lt;/a&gt;）。为了方便起见，此类函数通常还返回修改后的数组。</target>
        </trans-unit>
        <trans-unit id="7694e2fcb791d9c25c404da14cf2f301a28f48ea" translate="yes" xml:space="preserve">
          <source>Julia Coroutines (Green Threading)</source>
          <target state="translated">Julia Coroutines (Green Threading)</target>
        </trans-unit>
        <trans-unit id="79e749c34e72bbae64d0f791f7a71e619f74aae2" translate="yes" xml:space="preserve">
          <source>Julia GPU man pages</source>
          <target state="translated">Julia GPU手册</target>
        </trans-unit>
        <trans-unit id="a42ee146344a47614f0b605c9369dddac1347289" translate="yes" xml:space="preserve">
          <source>Julia Releases</source>
          <target state="translated">茱莉亚发布</target>
        </trans-unit>
        <trans-unit id="799d12425163528cdf3dbdb65e3972da06d0f30c" translate="yes" xml:space="preserve">
          <source>Julia Tasks allow suspending and resuming computations for I/O, event handling, producer-consumer processes, and similar patterns. Tasks can synchronize through operations like &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fetch&lt;/code&gt;, and communicate via &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">Julia Tasks允许暂停和恢复I / O，事件处理，生产者-消费者过程和类似模式的计算。任务可以通过诸如&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;fetch&lt;/code&gt; 之类的操作进行同步，并通过&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; 进行&lt;/a&gt;通信。</target>
        </trans-unit>
        <trans-unit id="8d8d2a4a743981227407130fd283bf2436f883ac" translate="yes" xml:space="preserve">
          <source>Julia aims to create an unprecedented combination of ease-of-use, power, and efficiency in a single language. In addition to the above, some advantages of Julia over comparable systems include:</source>
          <target state="translated">茱莉亚的目标是在单一语言中创造一个前所未有的易用性、强大性和高效性的结合。除上述之外,Julia与同类系统相比的一些优势还包括:</target>
        </trans-unit>
        <trans-unit id="05d11d59ee07392ef31079bd1e459ad76c3f824e" translate="yes" xml:space="preserve">
          <source>Julia allows an optional trailing comma when that comma does not change the meaning of code. This can cause confusion among R users when indexing into arrays. For example, &lt;code&gt;x[1,]&lt;/code&gt; in R would return the first row of a matrix; in Julia, however, the comma is ignored, so &lt;code&gt;x[1,] == x[1]&lt;/code&gt;, and will return the first element. To extract a row, be sure to use &lt;code&gt;:&lt;/code&gt;, as in &lt;code&gt;x[1,:]&lt;/code&gt;.</source>
          <target state="translated">当该逗号不改变代码的含义时，Julia允许使用可选的结尾逗号。索引到数组时，这可能会在R用户之间引起混乱。例如，R中的 &lt;code&gt;x[1,]&lt;/code&gt; 将返回矩阵的第一行；但是在Julia中，逗号将被忽略，因此 &lt;code&gt;x[1,] == x[1]&lt;/code&gt; 并将返回第一个元素。要提取一行，请确保使用 &lt;code&gt;:&lt;/code&gt; ，如 &lt;code&gt;x[1,:]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c83ba6941f781ea6f95d544e9edf743cc32b5bdb" translate="yes" xml:space="preserve">
          <source>Julia also defines the types &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;UInt&lt;/code&gt;, which are aliases for the system's signed and unsigned native integer types respectively:</source>
          <target state="translated">Julia还定义了类型 &lt;code&gt;Int&lt;/code&gt; 和 &lt;code&gt;UInt&lt;/code&gt; ，它们分别是系统的有符号和无符号本机整数类型的别名：</target>
        </trans-unit>
        <trans-unit id="5b4f0844a2699d5ea273cd05f5a3f5753244a2f6" translate="yes" xml:space="preserve">
          <source>Julia also provides &lt;code&gt;*&lt;/code&gt; for string concatenation:</source>
          <target state="translated">Julia还提供 &lt;code&gt;*&lt;/code&gt; 用于字符串连接：</target>
        </trans-unit>
        <trans-unit id="42a5af28aae285694adf3f30e69a77a9764131d7" translate="yes" xml:space="preserve">
          <source>Julia also provides the &lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt;&lt;code&gt;nextfloat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt;&lt;code&gt;prevfloat&lt;/code&gt;&lt;/a&gt; functions which return the next largest or smallest representable floating-point number to the argument respectively:</source>
          <target state="translated">Julia还提供了&lt;a href=&quot;../../base/numbers/index#Base.nextfloat&quot;&gt; &lt;code&gt;nextfloat&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/numbers/index#Base.prevfloat&quot;&gt; &lt;code&gt;prevfloat&lt;/code&gt; &lt;/a&gt;函数，分别将下一个最大或最小的可表示浮点数返回给参数：</target>
        </trans-unit>
        <trans-unit id="06ed8be5c06d7dc93b6c0404ce3653f58e45b54f" translate="yes" xml:space="preserve">
          <source>Julia also supports &lt;a href=&quot;#man-multithreading-1&quot;&gt;experimental multi-threading&lt;/a&gt;, where execution is forked and an anonymous function is run across all threads. Known as the fork-join approach, parallel threads execute independently, and must ultimately be joined in Julia's main thread to allow serial execution to continue. Multi-threading is supported using the &lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt;&lt;code&gt;Base.Threads&lt;/code&gt;&lt;/a&gt; module that is still considered experimental, as Julia is not yet fully thread-safe. In particular segfaults seem to occur during I/O operations and task switching. As an up-to-date reference, keep an eye on &lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;the issue tracker&lt;/a&gt;. Multi-Threading should only be used if you take into consideration global variables, locks and atomics, all of which are explained later.</source>
          <target state="translated">Julia还支持&lt;a href=&quot;#man-multithreading-1&quot;&gt;实验性多线程&lt;/a&gt;，其中执行被派生，并且匿名函数在所有线程上运行。被称为fork-join的方法，并行线程是独立执行的，最终必须在Julia的主线程中加入，以允许串行执行继续进行。使用仍被认为是实验性的&lt;a href=&quot;../../base/multi-threading/index#lib-multithreading-1&quot;&gt; &lt;code&gt;Base.Threads&lt;/code&gt; &lt;/a&gt;模块支持多线程，因为Julia尚不是完全线程安全的。特别是在I / O操作和任务切换期间似乎会发生段错误。作为最新参考，请关注&lt;a href=&quot;https://github.com/JuliaLang/julia/issues?q=is%3Aopen+is%3Aissue+label%3Amultithreading&quot;&gt;问题跟踪器&lt;/a&gt;。仅在考虑全局变量，锁和原子的情况下才应使用多线程，所有这些都将在后面说明。</target>
        </trans-unit>
        <trans-unit id="ab93a47c44a4029660cdea5a681e67f3452b925f" translate="yes" xml:space="preserve">
          <source>Julia and C can share array data without copying. The next example will show how this works.</source>
          <target state="translated">Julia和C可以共享数组数据,而无需复制。下一个例子将展示如何工作。</target>
        </trans-unit>
        <trans-unit id="989b4bbc6cbc89a53b5cc95fd259449cc83265cf" translate="yes" xml:space="preserve">
          <source>Julia and its package ecosystem includes tools that may help you diagnose problems and improve the performance of your code:</source>
          <target state="translated">Julia及其软件包生态系统包括一些工具,这些工具可能会帮助您诊断问题并提高代码的性能。</target>
        </trans-unit>
        <trans-unit id="bb6140d98b962ed45444f6097b48c1ab7b34b758" translate="yes" xml:space="preserve">
          <source>Julia applies the following order and associativity of operations, from highest precedence to lowest:</source>
          <target state="translated">茱莉亚应用以下操作顺序和关联性,从最高优先级到最低。</target>
        </trans-unit>
        <trans-unit id="a2d556e852ab5ec005eba2ee374bde91855e354e" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see &lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;relevant section of Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia数组是列专业的（Fortran排序），而C / C ++数组是行专业的（默认）排序。为了在遍历数组时获得最佳性能，应该在Julia中相对于C / C ++颠倒循环的顺序（请参阅&lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;&amp;ldquo;性能提示&amp;rdquo;的相关部分&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="79e54f86310ed0d0b6726cbc9118645ff3e41ba9" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas C/C++ arrays are row major ordered by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to C/C++ (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">Julia数组是列专业的（Fortran排序），而C / C ++数组是行专业的（默认）排序。为了在遍历数组时获得最佳性能，应该在Julia中相对于C / C ++颠倒循环的顺序（请参阅&amp;ldquo; &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;性能提示&amp;rdquo;的&lt;/a&gt;相关部分）。</target>
        </trans-unit>
        <trans-unit id="c5aee379485d3e8989f69a590d396666e706c30b" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see &lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;relevant section of Performance Tips&lt;/a&gt;).</source>
          <target state="translated">默认情况下，Julia数组是列专业的（Fortran排序），而NumPy数组是行专业的（C排序）。为了在遍历数组时获得最佳性能，应该在Julia中相对于NumPy颠倒循环顺序（请参阅&lt;a href=&quot;../performance-tips/index#man-performance-column-major&quot;&gt;&amp;ldquo;性能提示&amp;rdquo;的相关部分&lt;/a&gt;）。</target>
        </trans-unit>
        <trans-unit id="101c9a575d6ee596869371a0022ecfe27370c862" translate="yes" xml:space="preserve">
          <source>Julia arrays are column major (Fortran ordered) whereas NumPy arrays are row major (C-ordered) by default. To get optimal performance when looping over arrays, the order of the loops should be reversed in Julia relative to NumPy (see relevant section of &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;Performance Tips&lt;/a&gt;).</source>
          <target state="translated">默认情况下，Julia数组是列专业的（Fortran排序），而NumPy数组是行专业的（C排序）。为了在遍历数组时获得最佳性能，应该在Julia中相对于NumPy颠倒循环顺序（请参阅&amp;ldquo; &lt;a href=&quot;../performance-tips/index#man-performance-tips-1&quot;&gt;性能提示&amp;rdquo;的&lt;/a&gt;相关部分）。</target>
        </trans-unit>
        <trans-unit id="4295a55355c53bb69700ac344333d3ad56193792" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, &lt;code&gt;A[i,j]&lt;/code&gt;.</source>
          <target state="translated">Julia数组用方括号 &lt;code&gt;A[i,j]&lt;/code&gt; 索引。</target>
        </trans-unit>
        <trans-unit id="6ee791aabb20af6c1bfdaa172e030af0dec26574" translate="yes" xml:space="preserve">
          <source>Julia arrays are indexed with square brackets, and can have more than one dimension &lt;code&gt;A[i,j]&lt;/code&gt;. This syntax is not just syntactic sugar for a reference to a pointer or address as in C/C++. See the Julia documentation for the syntax for array construction (it has changed between versions).</source>
          <target state="translated">Julia数组用方括号索引，并且可以具有多个维 &lt;code&gt;A[i,j]&lt;/code&gt; 。这种语法不仅像C / C ++中那样是指向指针或地址的引用的语法糖。有关数组构造的语法，请参见Julia文档（在版本之间已更改）。</target>
        </trans-unit>
        <trans-unit id="4b072870337da75d87b7efdc10a5b80a2cf3a54d" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well.</source>
          <target state="translated">分配给另一个变量时，不会复制Julia数组。后 &lt;code&gt;A = B&lt;/code&gt; ，的变化的元素 &lt;code&gt;B&lt;/code&gt; 将修改 &lt;code&gt;A&lt;/code&gt; 为好。</target>
        </trans-unit>
        <trans-unit id="ee983dec29328f6ef30dd7f19c04408b414cdba1" translate="yes" xml:space="preserve">
          <source>Julia arrays are not copied when assigned to another variable. After &lt;code&gt;A = B&lt;/code&gt;, changing elements of &lt;code&gt;B&lt;/code&gt; will modify &lt;code&gt;A&lt;/code&gt; as well. Updating operators like &lt;code&gt;+=&lt;/code&gt; do not operate in-place, they are equivalent to &lt;code&gt;A = A + B&lt;/code&gt; which rebinds the left-hand side to the result of the right-hand side expression.</source>
          <target state="translated">分配给另一个变量时，不会复制Julia数组。后 &lt;code&gt;A = B&lt;/code&gt; ，的变化的元素 &lt;code&gt;B&lt;/code&gt; 将修改 &lt;code&gt;A&lt;/code&gt; 为好。像 &lt;code&gt;+=&lt;/code&gt; 这样的更新运算符不会就地进行运算，它们等效于 &lt;code&gt;A = A + B&lt;/code&gt; ，它将左手边重新绑定到右手边表达式的结果。</target>
        </trans-unit>
        <trans-unit id="f8885b17b4a7f2b903bda15b50d42d46540e083d" translate="yes" xml:space="preserve">
          <source>Julia arrays are represented in C by the datatype &lt;code&gt;jl_array_t*&lt;/code&gt;. Basically, &lt;code&gt;jl_array_t&lt;/code&gt; is a struct that contains:</source>
          <target state="translated">Julia数组在C中由数据类型 &lt;code&gt;jl_array_t*&lt;/code&gt; 。基本上， &lt;code&gt;jl_array_t&lt;/code&gt; 是一个包含以下内容的结构：</target>
        </trans-unit>
        <trans-unit id="f90d5ad1f221d4a17d6ad64fe11db8244636641f" translate="yes" xml:space="preserve">
          <source>Julia automatically inserts calls to the &lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt;&lt;code&gt;Base.cconvert&lt;/code&gt;&lt;/a&gt; function to convert each argument to the specified type. For example, the following call:</source>
          <target state="translated">Julia自动将调用插入&lt;a href=&quot;../../base/c/index#Base.cconvert&quot;&gt; &lt;code&gt;Base.cconvert&lt;/code&gt; &lt;/a&gt;函数，以将每个参数转换为指定的类型。例如，以下调用：</target>
        </trans-unit>
        <trans-unit id="94aa685212fa097b84259cd91052f6a151ab1143" translate="yes" xml:space="preserve">
          <source>Julia borrows backtick notation for commands from the shell, Perl, and Ruby. However, in Julia, writing</source>
          <target state="translated">Julia从shell、Perl和Ruby中借鉴了命令的backtick符号。然而,在Julia中,写</target>
        </trans-unit>
        <trans-unit id="1e4dcf624482d6017b9073977072d06f0c1e1383" translate="yes" xml:space="preserve">
          <source>Julia can be configured with a number of environment variables, set either in the usual way for each operating system, or in a portable way from within Julia. Supposing that you want to set the environment variable &lt;code&gt;JULIA_EDITOR&lt;/code&gt; to &lt;code&gt;vim&lt;/code&gt;, you can type &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; (for instance, in the REPL) to make this change on a case by case basis, or add the same to the user configuration file &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; in the user's home directory to have a permanent effect. The current value of the same environment variable can be determined by evaluating &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt;.</source>
          <target state="translated">Julia可以配置许多环境变量，这些变量可以按照每种操作系统的常规方式设置，也可以从Julia内部以可移植的方式设置。假设您要将环境变量 &lt;code&gt;JULIA_EDITOR&lt;/code&gt; 设置为 &lt;code&gt;vim&lt;/code&gt; ，可以键入 &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;] = &quot;vim&quot;&lt;/code&gt; （例如，在REPL中），以根据具体情况进行更改，或将其添加到用户主目录中的用户配置文件 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; 可以永久生效。可以通过评估 &lt;code&gt;ENV[&quot;JULIA_EDITOR&quot;]&lt;/code&gt; 来确定相同环境变量的当前值。</target>
        </trans-unit>
        <trans-unit id="25624934c68cd4d66c22470ba9dffff20f4e4703" translate="yes" xml:space="preserve">
          <source>Julia can be started in parallel mode with either the &lt;code&gt;-p&lt;/code&gt; or the &lt;code&gt;--machine-file&lt;/code&gt; options. &lt;code&gt;-p n&lt;/code&gt; will launch an additional &lt;code&gt;n&lt;/code&gt; worker processes, while &lt;code&gt;--machine-file file&lt;/code&gt; will launch a worker for each line in file &lt;code&gt;file&lt;/code&gt;. The machines defined in &lt;code&gt;file&lt;/code&gt; must be accessible via a password-less &lt;code&gt;ssh&lt;/code&gt; login, with Julia installed at the same location as the current host. Each machine definition takes the form &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt;. &lt;code&gt;user&lt;/code&gt; defaults to current user, &lt;code&gt;port&lt;/code&gt; to the standard ssh port. &lt;code&gt;count&lt;/code&gt; is the number of workers to spawn on the node, and defaults to 1. The optional &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; specifies the IP address and port that other workers should use to connect to this worker.</source>
          <target state="translated">可以使用 &lt;code&gt;-p&lt;/code&gt; 或 &lt;code&gt;--machine-file&lt;/code&gt; 选项以并行模式启动Julia 。 &lt;code&gt;-p n&lt;/code&gt; 将推出额外 &lt;code&gt;n&lt;/code&gt; 工作进程，而 &lt;code&gt;--machine-file file&lt;/code&gt; 将启动一个工人在文件中的每个线 &lt;code&gt;file&lt;/code&gt; 。必须通过无密码 &lt;code&gt;ssh&lt;/code&gt; 登录名访问 &lt;code&gt;file&lt;/code&gt; 定义的计算机，并将Julia安装在与当前主机相同的位置。每个计算机定义都采用 &lt;code&gt;[count*][user@]host[:port] [bind_addr[:port]]&lt;/code&gt; 。 &lt;code&gt;user&lt;/code&gt; 默认为当前用户， &lt;code&gt;port&lt;/code&gt; 为标准ssh端口。 &lt;code&gt;count&lt;/code&gt; 是要在节点上生成的工作线程数，默认为1。可选的 &lt;code&gt;bind-to bind_addr[:port]&lt;/code&gt; 指定其他工作线程用于连接到该工作线程的IP地址和端口。</target>
        </trans-unit>
        <trans-unit id="1aef7868e131aa3765142ca6c54c8fa0eb438e27" translate="yes" xml:space="preserve">
          <source>Julia can create substrings by indexing into strings. In R, strings must be converted into character vectors before creating substrings.</source>
          <target state="translated">Julia可以通过对字符串的索引来创建子串。在R中,在创建子串之前,必须将字符串转换为字符向量。</target>
        </trans-unit>
        <trans-unit id="5f876f801dbf3de94a121a0fbe557fe7c2dabadb" translate="yes" xml:space="preserve">
          <source>Julia can run multiple commands in parallel:</source>
          <target state="translated">Julia可以并行运行多个命令。</target>
        </trans-unit>
        <trans-unit id="d72c9df952d8a93730d24273b050dd7a87c41b99" translate="yes" xml:space="preserve">
          <source>Julia cannot assign to the results of function calls on the left hand side of an assignment operation: you cannot write &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt;.</source>
          <target state="translated">Julia不能在赋值操作的左侧赋值给函数调用的结果：您不能编写 &lt;code&gt;diag(M) = fill(1, n)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b9b5bf6c00b042abbcf8493eca58ab2e8c4ebfcf" translate="yes" xml:space="preserve">
          <source>Julia clusters are designed to be executed on already secured environments on infrastructure such as local laptops, departmental clusters, or even the cloud. This section covers network security requirements for the inbuilt &lt;code&gt;LocalManager&lt;/code&gt; and &lt;code&gt;SSHManager&lt;/code&gt;:</source>
          <target state="translated">Julia群集的设计目的是在基础设施（例如本地笔记本电脑，部门群集甚至云）上已经受保护的环境中执行。本节介绍了内置 &lt;code&gt;LocalManager&lt;/code&gt; 和 &lt;code&gt;SSHManager&lt;/code&gt; 的网络安全要求：</target>
        </trans-unit>
        <trans-unit id="dbe512ceba50dc3b08408e0b7101fcd9582324dd" translate="yes" xml:space="preserve">
          <source>Julia code can throw exceptions. For example, consider:</source>
          <target state="translated">Julia代码可以抛出异常。例如,考虑一下。</target>
        </trans-unit>
        <trans-unit id="d4d45a9c6d816f57f235a4b45d059535efea33d0" translate="yes" xml:space="preserve">
          <source>Julia comes with a full-featured interactive command-line REPL (read-eval-print loop) built into the &lt;code&gt;julia&lt;/code&gt; executable. In addition to allowing quick and easy evaluation of Julia statements, it has a searchable history, tab-completion, many helpful keybindings, and dedicated help and shell modes. The REPL can be started by simply calling &lt;code&gt;julia&lt;/code&gt; with no arguments or double-clicking on the executable:</source>
          <target state="translated">Julia带有内置在 &lt;code&gt;julia&lt;/code&gt; 可执行文件中的功能齐全的交互式命令行REPL（read-eval-print循环）。除了可以快速轻松地评估Julia语句外，它还具有可搜索的历史记录，制表符补全，许多有用的键绑定以及专用的帮助和shell模式。可以通过简单地不带任何参数调用 &lt;code&gt;julia&lt;/code&gt; 或双击可执行文件来启动REPL ：</target>
        </trans-unit>
        <trans-unit id="04f431b0e99b100c80ed3b37854b8baa69220c9e" translate="yes" xml:space="preserve">
          <source>Julia compiles and uses its own copy of OpenBLAS, with threads currently capped at &lt;code&gt;8&lt;/code&gt; (or the number of your cores).</source>
          <target state="translated">Julia编译并使用自己的OpenBLAS副本，当前线程的上限为 &lt;code&gt;8&lt;/code&gt; （或您的内核数）。</target>
        </trans-unit>
        <trans-unit id="0463aec28ff8f6050169511f8bc7eb9f0e64fcdf" translate="yes" xml:space="preserve">
          <source>Julia constructs vectors using brackets. Julia's &lt;code&gt;[1, 2, 3]&lt;/code&gt; is the equivalent of R's &lt;code&gt;c(1, 2, 3)&lt;/code&gt;.</source>
          <target state="translated">Julia使用方括号构造向量。Julia的 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 等效于R的 &lt;code&gt;c(1, 2, 3)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c3022b87e47f6ac9e21545c147897ab28a7faa7" translate="yes" xml:space="preserve">
          <source>Julia discourages populating the main namespace with functions. Most statistical functionality for Julia is found in &lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;packages&lt;/a&gt; under the &lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats organization&lt;/a&gt;. For example:</source>
          <target state="translated">朱莉娅不鼓励使用函数填充主命名空间。在&lt;a href=&quot;https://github.com/JuliaStats&quot;&gt;JuliaStats组织的&lt;/a&gt;&lt;a href=&quot;https://pkg.julialang.org/&quot;&gt;软件包中&lt;/a&gt;找到了Julia的大多数统计功能。例如：</target>
        </trans-unit>
        <trans-unit id="4d3373777de6110679b5b20361db329af8df4ef4" translate="yes" xml:space="preserve">
          <source>Julia discourages the use of semicolons to end statements. The results of statements are not automatically printed (except at the interactive prompt), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output.</source>
          <target state="translated">朱莉娅不鼓励使用分号来结束语句。语句的结果不会自动打印（在交互式提示下除外），并且代码行不需要以分号结尾。&lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt;可用于打印特定的输出。</target>
        </trans-unit>
        <trans-unit id="04e059ffc127f6546f46c24be663b53bb5ca0e7a" translate="yes" xml:space="preserve">
          <source>Julia does not automatically grow arrays in an assignment statement. Whereas in MATLAB &lt;code&gt;a(4) = 3.2&lt;/code&gt; can create the array &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; and &lt;code&gt;a(5) = 7&lt;/code&gt; can grow it into &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt;, the corresponding Julia statement &lt;code&gt;a[5] = 7&lt;/code&gt; throws an error if the length of &lt;code&gt;a&lt;/code&gt; is less than 5 or if this statement is the first use of the identifier &lt;code&gt;a&lt;/code&gt;. Julia has &lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt;&lt;code&gt;push!&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt;&lt;code&gt;append!&lt;/code&gt;&lt;/a&gt;, which grow &lt;code&gt;Vector&lt;/code&gt;s much more efficiently than MATLAB's &lt;code&gt;a(end+1) = val&lt;/code&gt;.</source>
          <target state="translated">Julia不会在赋值语句中自动增长数组。而在MATLAB中 &lt;code&gt;a(4) = 3.2&lt;/code&gt; 可以创建数组 &lt;code&gt;a = [0 0 0 3.2]&lt;/code&gt; 而 &lt;code&gt;a(5) = 7&lt;/code&gt; 可以将数组增长为 &lt;code&gt;a = [0 0 0 3.2 7]&lt;/code&gt; ，相应的Julia语句 &lt;code&gt;a[5] = 7&lt;/code&gt; 引发错误如果长度 &lt;code&gt;a&lt;/code&gt; 小于5，或者如果该语句是第一次使用该标识符的 &lt;code&gt;a&lt;/code&gt; 。朱莉娅已&lt;a href=&quot;../../base/collections/index#Base.push!&quot;&gt; &lt;code&gt;push!&lt;/code&gt; &lt;/a&gt;并&lt;a href=&quot;../../base/collections/index#Base.append!&quot;&gt; &lt;code&gt;append!&lt;/code&gt; &lt;/a&gt;，其成长 &lt;code&gt;Vector&lt;/code&gt; 小号要比MATLAB更有效地是 &lt;code&gt;a(end+1) = val&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="113852d54ae1eab98b745b5419ac194b68416265" translate="yes" xml:space="preserve">
          <source>Julia does not have an analog of MATLAB's &lt;code&gt;clear&lt;/code&gt; function; once a name is defined in a Julia session (technically, in module &lt;code&gt;Main&lt;/code&gt;), it is always present.</source>
          <target state="translated">Julia没有MATLAB的 &lt;code&gt;clear&lt;/code&gt; 函数的类似物；一旦在Julia会话中定义了名称（从技术上讲，在模块 &lt;code&gt;Main&lt;/code&gt; 中），该名称便始终存在。</target>
        </trans-unit>
        <trans-unit id="976166bb189635ca72f2fa234ae3939afd751bdc" translate="yes" xml:space="preserve">
          <source>Julia does not provide &lt;code&gt;nrow&lt;/code&gt; and &lt;code&gt;ncol&lt;/code&gt;. Instead, use &lt;code&gt;size(M, 1)&lt;/code&gt; for &lt;code&gt;nrow(M)&lt;/code&gt; and &lt;code&gt;size(M, 2)&lt;/code&gt; for &lt;code&gt;ncol(M)&lt;/code&gt;.</source>
          <target state="translated">朱莉娅不提供 &lt;code&gt;nrow&lt;/code&gt; 和 &lt;code&gt;ncol&lt;/code&gt; 。取而代之的是，使用 &lt;code&gt;size(M, 1)&lt;/code&gt; 为 &lt;code&gt;nrow(M)&lt;/code&gt; 和 &lt;code&gt;size(M, 2)&lt;/code&gt; 用于 &lt;code&gt;ncol(M)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9006bf61e6f8840d28990bf4b3458318711564d6" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">在编写 &lt;code&gt;if&lt;/code&gt; 语句或 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 循环时，Julia不需要括号： &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; 中 &lt;code&gt;for (i in c(1, 2, 3))&lt;/code&gt; 而不是for（在c（1、2、3）中 &lt;code&gt;if i == 1&lt;/code&gt; ）以及if = 1而不是 &lt;code&gt;if (i == 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef86462da92aecc95d832b0a401463ce19d89f34" translate="yes" xml:space="preserve">
          <source>Julia does not require parentheses when writing &lt;code&gt;if&lt;/code&gt; statements or &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; loops: use &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; instead of &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; and &lt;code&gt;if i == 1&lt;/code&gt; instead of &lt;code&gt;if (i == 1)&lt;/code&gt;.</source>
          <target state="translated">在编写 &lt;code&gt;if&lt;/code&gt; 语句或 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; 循环时，Julia不需要括号： &lt;code&gt;for i in [1, 2, 3]&lt;/code&gt; 中 &lt;code&gt;for (int i=1; i &amp;lt;= 3; i++)&lt;/code&gt; 而不是for（int i = 1; i &amp;lt;= 3; i ++）， &lt;code&gt;if i == 1&lt;/code&gt; 而不是 &lt;code&gt;if (i == 1)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9dab151404329caee20c7d4f7fc1cfb9d014b7b4" translate="yes" xml:space="preserve">
          <source>Julia does not require the use of semicolons to end statements. The results of expressions are not automatically printed (except at the interactive prompt, i.e. the REPL), and lines of code do not need to end with semicolons. &lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt;&lt;code&gt;println&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt;&lt;code&gt;@printf&lt;/code&gt;&lt;/a&gt; can be used to print specific output. In the REPL, &lt;code&gt;;&lt;/code&gt; can be used to suppress output. &lt;code&gt;;&lt;/code&gt; also has a different meaning within &lt;code&gt;[ ]&lt;/code&gt;, something to watch out for. &lt;code&gt;;&lt;/code&gt; can be used to separate expressions on a single line, but are not strictly necessary in many cases, and are more an aid to readability.</source>
          <target state="translated">Julia不需要使用分号来结束语句。表达式的结果不会自动打印（交互式提示（即REPL）除外），并且代码行无需以分号结尾。&lt;a href=&quot;../../base/io-network/index#Base.println&quot;&gt; &lt;code&gt;println&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../stdlib/printf/index#Printf.@printf&quot;&gt; &lt;code&gt;@printf&lt;/code&gt; &lt;/a&gt;可用于打印特定的输出。在REPL， &lt;code&gt;;&lt;/code&gt; 可用于抑制输出。 &lt;code&gt;;&lt;/code&gt; 在 &lt;code&gt;[ ]&lt;/code&gt; 也有不同的含义，需要提防。 &lt;code&gt;;&lt;/code&gt; 可以用于在单行上分隔表达式，但在许多情况下并非必须严格使用，并且更有助于提高可读性。</target>
        </trans-unit>
        <trans-unit id="3aeb7f64792ed5618bd5020762501e30791645d0" translate="yes" xml:space="preserve">
          <source>Julia does not support negative indices. In particular, the last element of a list or array is indexed with &lt;code&gt;end&lt;/code&gt; in Julia, not &lt;code&gt;-1&lt;/code&gt; as in Python.</source>
          <target state="translated">Julia不支持负索引。特别是，列表或数组的最后一个元素在Julia中以 &lt;code&gt;end&lt;/code&gt; 结尾，而不是在Python中为 &lt;code&gt;-1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f5ece5c5877f48513873a461f405e2da3018d04a" translate="yes" xml:space="preserve">
          <source>Julia does not support the &lt;code&gt;NULL&lt;/code&gt; type. The closest equivalent is &lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt;, but it behaves like a scalar value rather than like a list. Use &lt;code&gt;x === nothing&lt;/code&gt; instead of &lt;code&gt;is.null(x)&lt;/code&gt;.</source>
          <target state="translated">Julia不支持 &lt;code&gt;NULL&lt;/code&gt; 类型。最接近的等价物为&lt;a href=&quot;../../base/constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;，但其行为类似于标量值而不是列表。使用 &lt;code&gt;x === nothing&lt;/code&gt; 代替 &lt;code&gt;is.null(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2c5112c931f9c26dffeeec5c85f5a9032e0c2b42" translate="yes" xml:space="preserve">
          <source>Julia does not treat the numbers &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; as Booleans. You cannot write &lt;code&gt;if (1)&lt;/code&gt; in Julia, because &lt;code&gt;if&lt;/code&gt; statements accept only booleans. Instead, you can write &lt;code&gt;if true&lt;/code&gt;, &lt;code&gt;if Bool(1)&lt;/code&gt;, or &lt;code&gt;if 1==1&lt;/code&gt;.</source>
          <target state="translated">Julia不会将数字 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 视为布尔值。您无法在Julia中编写 &lt;code&gt;if (1)&lt;/code&gt; ，因为 &lt;code&gt;if&lt;/code&gt; 语句仅接受布尔值。相反，您可以编写 &lt;code&gt;if true&lt;/code&gt; ， &lt;code&gt;if Bool(1)&lt;/code&gt; 或 &lt;code&gt;if 1==1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5d0ea94ce19e9b69c6095b45e92d65e847fbab5" translate="yes" xml:space="preserve">
          <source>Julia doesn't require parens around conditions in &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt;. Write:</source>
          <target state="translated">朱莉娅不需要在 &lt;code&gt;if&lt;/code&gt; 和 &lt;code&gt;while&lt;/code&gt; 中围绕条件宽恕。写：</target>
        </trans-unit>
        <trans-unit id="c7d384a3039a9f94436def1f2e231fafa1ebc407" translate="yes" xml:space="preserve">
          <source>Julia enables package developers and users to document functions, types and other objects easily via a built-in documentation system since Julia 0.4.</source>
          <target state="translated">从Julia 0.4开始,Julia就通过内置的文档系统,让包的开发者和用户能够轻松地记录函数、类型和其他对象。</target>
        </trans-unit>
        <trans-unit id="a610a30b8a22b7162af81fa68a40648223fcdceb" translate="yes" xml:space="preserve">
          <source>Julia encourages users to write their own types, which are easier to use than S3 or S4 objects in R. Julia's multiple dispatch system means that &lt;code&gt;table(x::TypeA)&lt;/code&gt; and &lt;code&gt;table(x::TypeB)&lt;/code&gt; act like R's &lt;code&gt;table.TypeA(x)&lt;/code&gt; and &lt;code&gt;table.TypeB(x)&lt;/code&gt;.</source>
          <target state="translated">Julia鼓励用户编写自己的类型，这种类型比R中的S3或S4对象更易于使用 &lt;code&gt;table.TypeA(x)&lt;/code&gt; 的多调度系统意味着 &lt;code&gt;table(x::TypeA)&lt;/code&gt; 和 &lt;code&gt;table(x::TypeB)&lt;/code&gt; 行为就像R的table.TypeA（ x）和 &lt;code&gt;table.TypeB(x)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="93dbc5f2b7cd97919b61b2ba139686426c401f37" translate="yes" xml:space="preserve">
          <source>Julia evaluates default values of function arguments every time the method is invoked, unlike in Python where the default values are evaluated only once when the function is defined. For example, the function &lt;code&gt;f(x=rand()) = x&lt;/code&gt; returns a new random number every time it is invoked without argument. On the other hand, the function &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; returns &lt;code&gt;[1,2,3]&lt;/code&gt; every time it is called as &lt;code&gt;g()&lt;/code&gt;.</source>
          <target state="translated">每次调用方法时，Julia都会评估函数参数的默认值，这与Python中定义函数时仅对默认值进行一次评估的Python不同。例如，函数 &lt;code&gt;f(x=rand()) = x&lt;/code&gt; 每次无参数调用时都会返回一个新的随机数。另一方面，函数 &lt;code&gt;g(x=[1,2]) = push!(x,3)&lt;/code&gt; 每次被称为 &lt;code&gt;g()&lt;/code&gt; 时都返回 &lt;code&gt;[1,2,3]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="96712ad66b3fa51cd94fd25a53b3080e67ce2f4b" translate="yes" xml:space="preserve">
          <source>Julia features optional typing, multiple dispatch, and good performance, achieved using type inference and &lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;just-in-time (JIT) compilation&lt;/a&gt;, implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt;. It is multi-paradigm, combining features of imperative, functional, and object-oriented programming. Julia provides ease and expressiveness for high-level numerical computing, in the same way as languages such as R, MATLAB, and Python, but also supports general programming. To achieve this, Julia builds upon the lineage of mathematical programming languages, but also borrows much from popular dynamic languages, including &lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt;, and &lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby&lt;/a&gt;.</source>
          <target state="translated">Julia具有可选的类型输入，多次分派和良好的性能，这是通过使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Low_Level_Virtual_Machine&quot;&gt;LLVM&lt;/a&gt;实现的类型推断和&lt;a href=&quot;https://en.wikipedia.org/wiki/Just-in-time_compilation&quot;&gt;即时（JIT）编译&lt;/a&gt;实现的。它是多范式，结合了命令式，功能性和面向对象编程的功能。 Julia以与R，MATLAB和Python之类的语言相同的方式为高级数值计算提供了简便和表达性，但还支持常规编程。为了实现这一点，Julia建立在数学编程语言的基础上，但也从流行的动态语言（包括&lt;a href=&quot;https://en.wikipedia.org/wiki/Lisp_(programming_language)&quot;&gt;Lisp&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Perl_(programming_language)&quot;&gt;Perl&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Python_(programming_language)&quot;&gt;Python&lt;/a&gt;，&lt;a href=&quot;https://en.wikipedia.org/wiki/Lua_(programming_language)&quot;&gt;Lua&lt;/a&gt;和&lt;a href=&quot;https://en.wikipedia.org/wiki/Ruby_(programming_language)&quot;&gt;Ruby）中&lt;/a&gt;借鉴了很多东西。</target>
        </trans-unit>
        <trans-unit id="20fa6f6d170887fa888519e147a5de3f67149aab" translate="yes" xml:space="preserve">
          <source>Julia fully supports Unicode characters and strings. As &lt;a href=&quot;#man-characters&quot;&gt;discussed above&lt;/a&gt;, in character literals, Unicode code points can be represented using Unicode &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\U&lt;/code&gt; escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</source>
          <target state="translated">Julia完全支持Unicode字符和字符串。正如&lt;a href=&quot;#man-characters&quot;&gt;上面所讨论的&lt;/a&gt;，在字符文字，Unicode代码点可以使用Unicode表示 &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\U&lt;/code&gt; 转义序列，以及所有的标准C转义序列。这些同样可以用来编写字符串文字：</target>
        </trans-unit>
        <trans-unit id="bc5383570d2537e5c864f51ec5fa00e7be9531d0" translate="yes" xml:space="preserve">
          <source>Julia fully supports Unicode characters and strings. As &lt;a href=&quot;#man-characters-1&quot;&gt;discussed above&lt;/a&gt;, in character literals, Unicode code points can be represented using Unicode &lt;code&gt;\u&lt;/code&gt; and &lt;code&gt;\U&lt;/code&gt; escape sequences, as well as all the standard C escape sequences. These can likewise be used to write string literals:</source>
          <target state="translated">Julia完全支持Unicode字符和字符串。正如&lt;a href=&quot;#man-characters-1&quot;&gt;上面所讨论的&lt;/a&gt;，在字符文字，Unicode代码点可以使用Unicode表示 &lt;code&gt;\u&lt;/code&gt; 和 &lt;code&gt;\U&lt;/code&gt; 转义序列，以及所有的标准C转义序列。这些同样可以用来编写字符串文字：</target>
        </trans-unit>
        <trans-unit id="ddd78f6e5bc711118d9be3c491d9cc07a50a79b9" translate="yes" xml:space="preserve">
          <source>Julia function arguments follow a convention sometimes called &quot;pass-by-sharing&quot;, which means that values are not copied when they are passed to functions. Function arguments themselves act as new variable &lt;em&gt;bindings&lt;/em&gt; (new locations that can refer to values), but the values they refer to are identical to the passed values. Modifications to mutable values (such as &lt;code&gt;Array&lt;/code&gt;s) made within a function will be visible to the caller. This is the same behavior found in Scheme, most Lisps, Python, Ruby and Perl, among other dynamic languages.</source>
          <target state="translated">Julia函数参数遵循有时称为&amp;ldquo;传递共享&amp;rdquo;的约定，这意味着将值传递给函数时不会将其复制。函数参数本身充当新的变量&lt;em&gt;绑定&lt;/em&gt;（可以引用值的新位置），但是它们引用的值与传递的值相同。在函数内对可变值（例如 &lt;code&gt;Array&lt;/code&gt; ）进行的修改对调用者是可见的。这与Scheme，大多数Lisps，Python，Ruby和Perl等动态语言中的行为相同。</target>
        </trans-unit>
        <trans-unit id="f080283d31381a5962b780da17f950587890e071" translate="yes" xml:space="preserve">
          <source>Julia has Perl-compatible regular expressions (regexes), as provided by the &lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt; library (a description of the syntax can be found &lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;here&lt;/a&gt;). Regular expressions are related to strings in two ways: the obvious connection is that regular expressions are used to find regular patterns in strings; the other connection is that regular expressions are themselves input as strings, which are parsed into a state machine that can be used to efficiently search for patterns in strings. In Julia, regular expressions are input using non-standard string literals prefixed with various identifiers beginning with &lt;code&gt;r&lt;/code&gt;. The most basic regular expression literal without any options turned on just uses &lt;code&gt;r&quot;...&quot;&lt;/code&gt;:</source>
          <target state="translated">Julia具有&lt;a href=&quot;http://www.pcre.org/&quot;&gt;PCRE&lt;/a&gt;库提供的与Perl兼容的正则表达式（regexes）（有关语法的说明，请参见&lt;a href=&quot;http://www.pcre.org/current/doc/html/pcre2syntax.html&quot;&gt;此处&lt;/a&gt;）。正则表达式通过两种方式与字符串相关：明显的联系是，正则表达式用于查找字符串中的正则模式。另一个联系是，正则表达式本身是作为字符串输入的，它们被解析为状态机，可用于有效地搜索字符串中的模式。在Julia中，使用以 &lt;code&gt;r&lt;/code&gt; 开头的各种标识符作为前缀的非标准字符串文字输入正则表达式。没有打开任何选项的最基本的正则表达式文字只使用 &lt;code&gt;r&quot;...&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1bf49a0edfd1fa830fafecd8986f8d037e52871d" translate="yes" xml:space="preserve">
          <source>Julia has a built-in data structure called a &lt;em&gt;tuple&lt;/em&gt; that is closely related to function arguments and return values. A tuple is a fixed-length container that can hold any values, but cannot be modified (it is &lt;em&gt;immutable&lt;/em&gt;). Tuples are constructed with commas and parentheses, and can be accessed via indexing:</source>
          <target state="translated">Julia具有一个称为&lt;em&gt;元组&lt;/em&gt;的内置数据结构，该结构与函数参数和返回值密切相关。元组是一个固定长度的容器，可以容纳任何值，但不能修改（它是&lt;em&gt;不可变的&lt;/em&gt;）。元组由逗号和括号构成，可以通过索引进行访问：</target>
        </trans-unit>
        <trans-unit id="c552e8e0854f7810a14a1b85cee7a089274fe437" translate="yes" xml:space="preserve">
          <source>Julia has a rational number type to represent exact ratios of integers. Rationals are constructed using the &lt;a href=&quot;../../base/math/index#Base.://&quot;&gt;&lt;code&gt;//&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">Julia有一个有理数类型来表示整数的精确比例。使用&lt;a href=&quot;../../base/math/index#Base.://&quot;&gt; &lt;code&gt;//&lt;/code&gt; &lt;/a&gt;运算符构造有理数：</target>
        </trans-unit>
        <trans-unit id="f16da71d7eefd561befb9a12573735daa1e67ea2" translate="yes" xml:space="preserve">
          <source>Julia has a special &lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;dot syntax&lt;/a&gt; that converts any scalar function into a &quot;vectorized&quot; function call, and any operator into a &quot;vectorized&quot; operator, with the special property that nested &quot;dot calls&quot; are &lt;em&gt;fusing&lt;/em&gt;: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use &lt;code&gt;.=&lt;/code&gt; and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</source>
          <target state="translated">朱莉娅有一个特殊的&lt;a href=&quot;../functions/index#man-vectorized&quot;&gt;点语法&lt;/a&gt;是将任何标量函数变成了&amp;ldquo;矢量化&amp;rdquo;功能调用，任何运营商成&amp;ldquo;矢量&amp;rdquo;运营商，拥有特殊的属性，嵌套&amp;ldquo;点电话&amp;rdquo;是&lt;em&gt;融合&lt;/em&gt;：它们在语法层面为结合一个循环，而无需分配临时数组。如果使用 &lt;code&gt;.=&lt;/code&gt; 和类似的赋值运算符，则结果也可以就地存储在预分配的数组中（请参见上文）。</target>
        </trans-unit>
        <trans-unit id="b40bd35bfba54a15cc9852aeface053edb4835d0" translate="yes" xml:space="preserve">
          <source>Julia has a special &lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;dot syntax&lt;/a&gt; that converts any scalar function into a &quot;vectorized&quot; function call, and any operator into a &quot;vectorized&quot; operator, with the special property that nested &quot;dot calls&quot; are &lt;em&gt;fusing&lt;/em&gt;: they are combined at the syntax level into a single loop, without allocating temporary arrays. If you use &lt;code&gt;.=&lt;/code&gt; and similar assignment operators, the result can also be stored in-place in a pre-allocated array (see above).</source>
          <target state="translated">朱莉娅有一个特殊的&lt;a href=&quot;../functions/index#man-vectorized-1&quot;&gt;点语法&lt;/a&gt;是将任何标量函数变成了&amp;ldquo;矢量化&amp;rdquo;功能调用，任何运营商成&amp;ldquo;矢量&amp;rdquo;运营商，拥有特殊的属性，嵌套&amp;ldquo;点电话&amp;rdquo;是&lt;em&gt;融合&lt;/em&gt;：它们在语法层面为结合一个循环，而无需分配临时数组。如果使用 &lt;code&gt;.=&lt;/code&gt; 和类似的赋值运算符，则结果也可以就地存储在预分配的数组中（请参见上文）。</target>
        </trans-unit>
        <trans-unit id="d6c4ab07a2249226dfaeff8c414c6f4ecccc5db7" translate="yes" xml:space="preserve">
          <source>Julia has a specialized version of &lt;code&gt;ntuple&lt;/code&gt; that accepts a &lt;code&gt;Val{::Int}&lt;/code&gt; instance as the second parameter; by passing &lt;code&gt;N&lt;/code&gt; as a type-parameter, you make its &quot;value&quot; known to the compiler. Consequently, this version of &lt;code&gt;array3&lt;/code&gt; allows the compiler to predict the return type.</source>
          <target state="translated">Julia有一个专门的 &lt;code&gt;ntuple&lt;/code&gt; 版本，它接受 &lt;code&gt;Val{::Int}&lt;/code&gt; 实例作为第二个参数。通过将 &lt;code&gt;N&lt;/code&gt; 作为类型参数传递，可以使编译器知道其&amp;ldquo;值&amp;rdquo;。因此，此版本的 &lt;code&gt;array3&lt;/code&gt; 允许编译器预测返回类型。</target>
        </trans-unit>
        <trans-unit id="3dbaaf5104fbb919890d9bf95a666a5ce54dc8a0" translate="yes" xml:space="preserve">
          <source>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers&quot;&gt;Integers and Floating-Point Numbers&lt;/a&gt;, &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;, &lt;a href=&quot;../types/index#man-types&quot;&gt;Types&lt;/a&gt;, and &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</source>
          <target state="translated">Julia有一个用于将数学运算符的参数提升为通用类型的系统，在其他各个部分中都提到了该系统，包括&lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers&quot;&gt;整数和浮点数&lt;/a&gt;，&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;数学运算和基本函数&lt;/a&gt;，&lt;a href=&quot;../types/index#man-types&quot;&gt;类型&lt;/a&gt;和&lt;a href=&quot;../methods/index#Methods&quot;&gt;方法&lt;/a&gt;。在本节中，我们将说明此升级系统是如何工作的，以及如何将其扩展为新类型并将其应用于除内置数学运算符之外的函数。传统上，就促进算术参数而言，编程语言分为两个阵营：</target>
        </trans-unit>
        <trans-unit id="dd0467e099e9e6d5ba4caf88a327947c41a492c3" translate="yes" xml:space="preserve">
          <source>Julia has a system for promoting arguments of mathematical operators to a common type, which has been mentioned in various other sections, including &lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;Integers and Floating-Point Numbers&lt;/a&gt;, &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt;, &lt;a href=&quot;../types/index#man-types-1&quot;&gt;Types&lt;/a&gt;, and &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;. In this section, we explain how this promotion system works, as well as how to extend it to new types and apply it to functions besides built-in mathematical operators. Traditionally, programming languages fall into two camps with respect to promotion of arithmetic arguments:</source>
          <target state="translated">Julia有一个用于将数学运算符的参数提升为通用类型的系统，在其他各个部分中都提到了该系统，包括&lt;a href=&quot;../integers-and-floating-point-numbers/index#Integers-and-Floating-Point-Numbers-1&quot;&gt;整数和浮点数&lt;/a&gt;，&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;数学运算和基本函数&lt;/a&gt;，&lt;a href=&quot;../types/index#man-types-1&quot;&gt;类型&lt;/a&gt;和&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;方法&lt;/a&gt;。在本节中，我们将说明此升级系统如何工作，以及如何将其扩展为新类型并将其应用于除内置数学运算符之外的函数。传统上，就促进算术参数而言，编程语言分为两个阵营：</target>
        </trans-unit>
        <trans-unit id="3580c0f9206e567ece3500a7602b2f938ef0cdc5" translate="yes" xml:space="preserve">
          <source>Julia has an enumeration type, expressed using the macro &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; For example: &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</source>
          <target state="translated">Julia具有枚举类型，使用宏 &lt;code&gt;@enum(name, value1, value2, ...)&lt;/code&gt; ，例如： &lt;code&gt;@enum(Fruit, banana=1, apple, pear)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e22281e2e9ddb304102a3e2035cc1b7d70261e86" translate="yes" xml:space="preserve">
          <source>Julia has an extensive, flexible API for sorting and interacting with already-sorted arrays of values. By default, Julia picks reasonable algorithms and sorts in standard ascending order:</source>
          <target state="translated">Julia有一个广泛而灵活的API,用于排序和与已经排序的值数组进行交互。默认情况下,Julia会选择合理的算法,并按照标准的升序进行排序。</target>
        </trans-unit>
        <trans-unit id="bf9ed794914c3a1a76c39f0be8423b02c7aa0fa9" translate="yes" xml:space="preserve">
          <source>Julia has no line continuation syntax: if, at the end of a line, the input so far is a complete expression, it is considered done; otherwise the input continues. One way to force an expression to continue is to wrap it in parentheses.</source>
          <target state="translated">Julia没有延续行的语法:如果在一行结束时,到目前为止输入的是一个完整的表达式,则认为已经完成;否则输入将继续。强制表达式继续的一种方法是用括号将其包裹起来。</target>
        </trans-unit>
        <trans-unit id="6e3f85fe865aed948db80d8506da1145de6fdbbe" translate="yes" xml:space="preserve">
          <source>Julia has several functions that can mutate their arguments. For example, it has both &lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt;&lt;code&gt;sort!&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia有几个可以改变其论点的函数。例如，它既有&lt;a href=&quot;../../base/sort/index#Base.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt;又有&lt;a href=&quot;../../base/sort/index#Base.sort!&quot;&gt; &lt;code&gt;sort!&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="dced25e0f1eb19647f27c26102392f9de718e8bc" translate="yes" xml:space="preserve">
          <source>Julia has support for sparse vectors and &lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;sparse matrices&lt;/a&gt; in the &lt;code&gt;SparseArrays&lt;/code&gt; stdlib module. Sparse arrays are arrays that contain enough zeros that storing them in a special data structure leads to savings in space and execution time, compared to dense arrays.</source>
          <target state="translated">Julia 在 &lt;code&gt;SparseArrays&lt;/code&gt; stdlib模块中支持稀疏向量和&lt;a href=&quot;https://en.wikipedia.org/wiki/Sparse_matrix&quot;&gt;稀疏矩阵&lt;/a&gt;。稀疏数组是包含足够零的数组，与密集数组相比，零存储在特殊的数据结构中可节省空间和执行时间。</target>
        </trans-unit>
        <trans-unit id="7e110deec010cf13200f416e320f962b03651cd3" translate="yes" xml:space="preserve">
          <source>Julia has true one-dimensional arrays. Column vectors are of size &lt;code&gt;N&lt;/code&gt;, not &lt;code&gt;Nx1&lt;/code&gt;. For example, &lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt;&lt;code&gt;rand(N)&lt;/code&gt;&lt;/a&gt; makes a 1-dimensional array.</source>
          <target state="translated">朱莉娅拥有真正的一维数组。列向量的大小为 &lt;code&gt;N&lt;/code&gt; ，而不是 &lt;code&gt;Nx1&lt;/code&gt; 。例如，&lt;a href=&quot;../../stdlib/random/index#Base.rand&quot;&gt; &lt;code&gt;rand(N)&lt;/code&gt; &lt;/a&gt;生成一维数组。</target>
        </trans-unit>
        <trans-unit id="0821ee6b098b6e9c3f3f70ea62ba30df9ae8eca8" translate="yes" xml:space="preserve">
          <source>Julia has two mechanisms for loading code:</source>
          <target state="translated">Julia有两种加载代码的机制。</target>
        </trans-unit>
        <trans-unit id="c7c1de145d34e5e8002d957a023c35b25d8ff0be" translate="yes" xml:space="preserve">
          <source>Julia has two right-shift operators, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; performs an arithmetic shift, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; always performs a logical shift, unlike C/C++, where the meaning of &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; depends on the type of the value being shifted.</source>
          <target state="translated">Julia有两个右移运算符 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 。 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 执行算术移位， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 始终执行逻辑移位，与C / C ++不同， &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 的含义取决于要移位的值的类型。</target>
        </trans-unit>
        <trans-unit id="a82ef00db4da7adcbac13bd1f8a38ec016519663" translate="yes" xml:space="preserve">
          <source>Julia identifiers and code excerpts should always appear between backticks &lt;code&gt;`&lt;/code&gt; to enable highlighting. Equations in the LaTeX syntax can be inserted between double backticks &lt;code&gt;``&lt;/code&gt;. Use Unicode characters rather than their LaTeX escape sequence, i.e. &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; rather than &lt;code&gt;``\\alpha = 1``&lt;/code&gt;.</source>
          <target state="translated">Julia标识符和代码摘录应始终出现在反引号 &lt;code&gt;`&lt;/code&gt; 之间，以使突出显示。可以将LaTeX语法中的方程式插入到两个反引号之间 &lt;code&gt;``&lt;/code&gt; 。使用Unicode字符而不是其LaTeX转义序列，即 &lt;code&gt;``&amp;alpha; = 1``&lt;/code&gt; &lt;code&gt;``\\alpha = 1``&lt;/code&gt; 而不是``\\ alpha = 1''。</target>
        </trans-unit>
        <trans-unit id="ad9eda654d6c5b8e4f3d947e9256ba07cba9012f" translate="yes" xml:space="preserve">
          <source>Julia includes predefined types for both complex and rational numbers, and supports all the standard &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt; on them. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt; are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</source>
          <target state="translated">Julia包括针对复数和有理数的预定义类型，并在其上支持所有标准的&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions&quot;&gt;数学运算和基本函数&lt;/a&gt;。定义了&amp;ldquo;&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;转换&amp;rdquo;和&amp;ldquo;提升&amp;rdquo;&lt;/a&gt;，以便对预定义数字类型（原始的或复合的）的任何组合进行的操作均符合预期。</target>
        </trans-unit>
        <trans-unit id="556d3efaca190f2ea064a6e9ec15d293042ee9a4" translate="yes" xml:space="preserve">
          <source>Julia includes predefined types for both complex and rational numbers, and supports all the standard &lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;Mathematical Operations and Elementary Functions&lt;/a&gt; on them. &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; are defined so that operations on any combination of predefined numeric types, whether primitive or composite, behave as expected.</source>
          <target state="translated">Julia包括针对复数和有理数的预定义类型，并支持所有标准的&lt;a href=&quot;../mathematical-operations/index#Mathematical-Operations-and-Elementary-Functions-1&quot;&gt;数学运算和基本函数&lt;/a&gt;。定义了&amp;ldquo; &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;转换&amp;rdquo;和&amp;ldquo;提升&amp;rdquo;&lt;/a&gt;，以便对预定义数字类型（原始的或复合的）的任何组合进行的操作均符合预期。</target>
        </trans-unit>
        <trans-unit id="7ddd4e3aafc825251162512ccf2a33928bb02903" translate="yes" xml:space="preserve">
          <source>Julia installation is straightforward, whether using precompiled binaries or compiling from source. Download and install Julia by following the instructions at &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;.</source>
          <target state="translated">无论使用预编译的二进制文件还是从源代码进行编译，Julia的安装都非常简单。按照&lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/上&lt;/a&gt;的说明下载并安装Julia 。</target>
        </trans-unit>
        <trans-unit id="ebd85d8192dfa3106e5516cbab7ad06e8387fb26" translate="yes" xml:space="preserve">
          <source>Julia is careful to distinguish scalars, vectors and matrices. In R, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;c(1)&lt;/code&gt; are the same. In Julia, they cannot be used interchangeably.</source>
          <target state="translated">Julia小心区分标量，向量和矩阵。在R中， &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;c(1)&lt;/code&gt; 相同。在Julia中，它们不能互换使用。</target>
        </trans-unit>
        <trans-unit id="b86e5dd8d3107ffdd2a0b40698efdff29052007c" translate="yes" xml:space="preserve">
          <source>Julia is eagerly evaluated and does not support R-style lazy evaluation. For most users, this means that there are very few unquoted expressions or column names.</source>
          <target state="translated">Julia是急于评估的,不支持R式的懒惰评估。对于大多数用户来说,这意味着很少有未引用的表达式或列名。</target>
        </trans-unit>
        <trans-unit id="3107ebb99f64b1456a558b1a35edcbfee43840dd" translate="yes" xml:space="preserve">
          <source>Julia is under rapid development and has an extensive test suite to verify functionality across multiple platforms. If you build Julia from source, you can run this test suite with &lt;code&gt;make test&lt;/code&gt;. In a binary install, you can run the test suite using &lt;code&gt;Base.runtests()&lt;/code&gt;.</source>
          <target state="translated">Julia正在快速开发中，并且具有广泛的测试套件来验证跨多个平台的功能。如果从源代码构建Julia，则可以使用 &lt;code&gt;make test&lt;/code&gt; 运行此测试套件。在二进制安装中，可以使用 &lt;code&gt;Base.runtests()&lt;/code&gt; 运行测试套件。</target>
        </trans-unit>
        <trans-unit id="9746bea5d9fab2c69edf57da506dab8c4cb797c1" translate="yes" xml:space="preserve">
          <source>Julia lacks the equivalent of R's &lt;code&gt;assign&lt;/code&gt; or &lt;code&gt;get&lt;/code&gt;.</source>
          <target state="translated">朱莉娅（Julia）缺少R的 &lt;code&gt;assign&lt;/code&gt; 或 &lt;code&gt;get&lt;/code&gt; 的等效项。</target>
        </trans-unit>
        <trans-unit id="b0362643e3d8faddbbdc08525668acd4db05eb64" translate="yes" xml:space="preserve">
          <source>Julia macros operate on parsed expressions, rather than the text of the program, which allows them to perform sophisticated transformations of Julia code. Macro names start with the &lt;code&gt;@&lt;/code&gt; character, and have both a function-like syntax, &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt;, and a statement-like syntax, &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt;. The forms are interchangeable; the function-like form is particularly useful if the macro appears within another expression, and is often clearest. The statement-like form is often used to annotate blocks, as in the distributed &lt;code&gt;for&lt;/code&gt; construct: &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt;. Where the end of the macro construct may be unclear, use the function-like form.</source>
          <target state="translated">Julia宏对解析的表达式进行操作，而不是对程序文本进行操作，这使它们可以执行Julia代码的复杂转换。宏名称以 &lt;code&gt;@&lt;/code&gt; 字符开头，并且具有类似于函数的语法 &lt;code&gt;@mymacro(arg1, arg2, arg3)&lt;/code&gt; 和具有类似于语句的语法 &lt;code&gt;@mymacro arg1 arg2 arg3&lt;/code&gt; 。形式可以互换；如果宏出现在另一个表达式中并且通常是最清晰的，则类似于函数的形式就特别有用。类似于语句的形式通常用于注释块，例如在分布式 &lt;code&gt;for&lt;/code&gt; 构造中： &lt;code&gt;@distributed for i in 1:n; #= body =#; end&lt;/code&gt; 。如果宏构造的结尾可能不清楚，请使用类似于函数的形式。</target>
        </trans-unit>
        <trans-unit id="7722324abb1e33c9620fc5bb1dbd294982f5257b" translate="yes" xml:space="preserve">
          <source>Julia performs matrix transposition using the &lt;code&gt;transpose&lt;/code&gt; function and conjugated transposition using the &lt;code&gt;'&lt;/code&gt; operator or the &lt;code&gt;adjoint&lt;/code&gt; function. Julia's &lt;code&gt;transpose(A)&lt;/code&gt; is therefore equivalent to R's &lt;code&gt;t(A)&lt;/code&gt;. Additionally a non-recursive transpose in Julia is provided by the &lt;code&gt;permutedims&lt;/code&gt; function.</source>
          <target state="translated">Julia使用 &lt;code&gt;transpose&lt;/code&gt; 函数执行矩阵转置，并使用 &lt;code&gt;'&lt;/code&gt; 运算符或 &lt;code&gt;adjoint&lt;/code&gt; 函数执行共轭转置。因此，朱莉娅的 &lt;code&gt;transpose(A)&lt;/code&gt; 等于R的 &lt;code&gt;t(A)&lt;/code&gt; 。另外， &lt;code&gt;permutedims&lt;/code&gt; 函数提供了Julia中的非递归转置。</target>
        </trans-unit>
        <trans-unit id="52ca89425115cf081b45ea4b026826f1b8b7932f" translate="yes" xml:space="preserve">
          <source>Julia provides &lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt;&lt;code&gt;eps&lt;/code&gt;&lt;/a&gt;, which gives the distance between &lt;code&gt;1.0&lt;/code&gt; and the next larger representable floating-point value:</source>
          <target state="translated">Julia提供了&lt;a href=&quot;../../stdlib/dates/index#Base.eps&quot;&gt; &lt;code&gt;eps&lt;/code&gt; &lt;/a&gt;，它给出了 &lt;code&gt;1.0&lt;/code&gt; 与下一个更大的可表示浮点值之间的距离：</target>
        </trans-unit>
        <trans-unit id="b5151abe259ad1efc62c73fed3cdaac381488d9a" translate="yes" xml:space="preserve">
          <source>Julia provides a &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; mechanism for solving this problem. A &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; is a waitable first-in first-out queue which can have multiple tasks reading from and writing to it.</source>
          <target state="translated">Julia提供了一种解决此问题的&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;机制。一个&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;是一个可等待的先入先出队列，可以有多个任务读取和写入数据。</target>
        </trans-unit>
        <trans-unit id="476c4c45db4a5f4592324ce839944c2c37cd8d0a" translate="yes" xml:space="preserve">
          <source>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for &lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</source>
          <target state="translated">Julia提供了广泛的原始数值类型，并在其上定义了算术和按位运算符以及标准数学函数的完整补充。这些直接映射到现代计算机本身支持的数字类型和运算上，从而使Julia可以充分利用计算资源。此外，Julia为&lt;a href=&quot;#Arbitrary-Precision-Arithmetic&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;提供了软件支持，该算法可以处理无法在本机硬件表示中有效表示的数值上的运算，但会以相对较慢的性能为代价。</target>
        </trans-unit>
        <trans-unit id="8d6a50d7fd1b9d32a07f2f0f7b72bc0c75328556" translate="yes" xml:space="preserve">
          <source>Julia provides a broad range of primitive numeric types, and a full complement of arithmetic and bitwise operators as well as standard mathematical functions are defined over them. These map directly onto numeric types and operations that are natively supported on modern computers, thus allowing Julia to take full advantage of computational resources. Additionally, Julia provides software support for &lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;, which can handle operations on numeric values that cannot be represented effectively in native hardware representations, but at the cost of relatively slower performance.</source>
          <target state="translated">Julia提供了广泛的原始数值类型，并在其上定义了算术和按位运算符以及标准数学函数的完整补充。这些直接映射到现代计算机上本机支持的数字类型和运算上，从而使Julia可以充分利用计算资源。此外，Julia为&lt;a href=&quot;#Arbitrary-Precision-Arithmetic-1&quot;&gt;Arbitrary Precision Arithmetic&lt;/a&gt;提供了软件支持，该算法可以处理无法在本机硬件表示中有效表示的数值上的运算，但是会以相对较慢的性能为代价。</target>
        </trans-unit>
        <trans-unit id="5e01948cafe564bc35cc3886e5615297521aba0b" translate="yes" xml:space="preserve">
          <source>Julia provides a complete collection of basic arithmetic and bitwise operators across all of its numeric primitive types, as well as providing portable, efficient implementations of a comprehensive collection of standard mathematical functions.</source>
          <target state="translated">Julia提供了一个完整的基本算术和位智运算符集合,涵盖了所有的数值基元类型,并提供了全面的标准数学函数集合的可移植、高效的实现。</target>
        </trans-unit>
        <trans-unit id="123ae94e81e1f4b6a65e379d812783d382dbfd58" translate="yes" xml:space="preserve">
          <source>Julia provides a comprehensive collection of mathematical functions and operators. These mathematical operations are defined over as broad a class of numerical values as permit sensible definitions, including integers, floating-point numbers, rationals, and complex numbers, wherever such definitions make sense.</source>
          <target state="translated">Julia提供了一个全面的数学函数和运算符的集合。这些数学运算在允许合理定义的范围内定义了广泛的数值类别,包括整数、浮点数、有理数和复数,只要这些定义是合理的。</target>
        </trans-unit>
        <trans-unit id="07cfc6f69cd91f9494ead12f841604f628160c20" translate="yes" xml:space="preserve">
          <source>Julia provides a reserved word &lt;code&gt;do&lt;/code&gt; for rewriting this code more clearly:</source>
          <target state="translated">Julia提供了保留字 &lt;code&gt;do&lt;/code&gt; 来更清楚地重写此代码：</target>
        </trans-unit>
        <trans-unit id="657c78188298a00e823c4644aeb3647f8f14a312" translate="yes" xml:space="preserve">
          <source>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (&lt;a href=&quot;../control-flow/index#man-tasks&quot;&gt;coroutine&lt;/a&gt;) functionality.</source>
          <target state="translated">Julia提供了一个丰富的接口来处理流I / O对象，例如终端，管道和TCP套接字。该接口尽管在系统级别是异步的，但以同步的方式呈现给程序员，通常不必考虑底层的异步操作。这是通过大量使用Julia合作线程（&lt;a href=&quot;../control-flow/index#man-tasks&quot;&gt;协程&lt;/a&gt;）功能来实现的。</target>
        </trans-unit>
        <trans-unit id="eea9a879394b78dc7fcabf301d30239602afa073" translate="yes" xml:space="preserve">
          <source>Julia provides a rich interface to deal with streaming I/O objects such as terminals, pipes and TCP sockets. This interface, though asynchronous at the system level, is presented in a synchronous manner to the programmer and it is usually unnecessary to think about the underlying asynchronous operation. This is achieved by making heavy use of Julia cooperative threading (&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;coroutine&lt;/a&gt;) functionality.</source>
          <target state="translated">Julia提供了一个丰富的接口来处理流I / O对象，例如终端，管道和TCP套接字。该接口尽管在系统级别是异步的，但以同步的方式呈现给程序员，通常不必考虑底层的异步操作。这是通过大量使用Julia合作线程（&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;协程&lt;/a&gt;）功能来实现的。</target>
        </trans-unit>
        <trans-unit id="abe3cae0b0fe31f45bb29933297244a39702e5dd" translate="yes" xml:space="preserve">
          <source>Julia provides a variety of control flow constructs:</source>
          <target state="translated">Julia提供了多种控制流构造。</target>
        </trans-unit>
        <trans-unit id="379525ee528141070933df39d7ce42ca05dd4bf0" translate="yes" xml:space="preserve">
          <source>Julia provides additional functions to test numbers for special values, which can be useful in situations like hash key comparisons:</source>
          <target state="translated">Julia提供了额外的函数来测试数字的特殊值,这在哈希键比较等情况下很有用。</target>
        </trans-unit>
        <trans-unit id="e0540cb6db7126d29223e3d70501bf3d70244816" translate="yes" xml:space="preserve">
          <source>Julia provides an extremely flexible system for naming variables. Variable names are case-sensitive, and have no semantic meaning (that is, the language will not treat variables differently based on their names).</source>
          <target state="translated">Julia为变量的命名提供了一个极其灵活的系统。变量名是区分大小写的,而且没有语义意义(也就是说,语言不会因为变量名而对其进行不同的处理)。</target>
        </trans-unit>
        <trans-unit id="eab744df916b515fec425ab1cfaf69348d24b932" translate="yes" xml:space="preserve">
          <source>Julia provides built-in, efficient functions to test for oddness and evenness called &lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt;&lt;code&gt;iseven&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt;&lt;code&gt;isodd&lt;/code&gt;&lt;/a&gt; so the above definitions should only be considered to be examples of scope, not efficient design.</source>
          <target state="translated">Julia提供了内置的高效函数来测试&lt;a href=&quot;../../base/numbers/index#Base.iseven&quot;&gt; &lt;code&gt;iseven&lt;/code&gt; &lt;/a&gt;性，即iseven和&lt;a href=&quot;../../base/numbers/index#Base.isodd&quot;&gt; &lt;code&gt;isodd&lt;/code&gt; ,&lt;/a&gt;因此上述定义仅应视为范围的示例，而不是有效的设计。</target>
        </trans-unit>
        <trans-unit id="378329d878ac43129f252ba96bb3ab40b65f2250" translate="yes" xml:space="preserve">
          <source>Julia provides functions which return literal 0 and 1 corresponding to a specified type or the type of a given variable.</source>
          <target state="translated">Julia提供了一些函数,这些函数返回对应于指定类型或给定变量类型的文字0和1。</target>
        </trans-unit>
        <trans-unit id="affb7609b4adcfecba8a7c2be6b8ababed17f3bf" translate="yes" xml:space="preserve">
          <source>Julia provides support for representing missing values in the statistical sense, that is for situations where no value is available for a variable in an observation, but a valid value theoretically exists. Missing values are represented via the &lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt;&lt;code&gt;missing&lt;/code&gt;&lt;/a&gt; object, which is the singleton instance of the type &lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt;&lt;code&gt;Missing&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;missing&lt;/code&gt; is equivalent to &lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;&lt;code&gt;NULL&lt;/code&gt; in SQL&lt;/a&gt; and &lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;&lt;code&gt;NA&lt;/code&gt; in R&lt;/a&gt;, and behaves like them in most situations.</source>
          <target state="translated">Julia提供了从统计学意义上表示缺失值的支持，也就是说，对于观察值中的变量没有可用值但理论上存在有效值的情况。缺失值通过&lt;a href=&quot;../../base/base/index#Base.missing&quot;&gt; &lt;code&gt;missing&lt;/code&gt; &lt;/a&gt;对象表示，该对象是类型&lt;a href=&quot;../../base/base/index#Base.Missing&quot;&gt; &lt;code&gt;Missing&lt;/code&gt; &lt;/a&gt;的单例实例。&lt;a href=&quot;https://en.wikipedia.org/wiki/NULL_(SQL)&quot;&gt;在SQL中&lt;/a&gt;， &lt;code&gt;missing&lt;/code&gt; 等效于 &lt;code&gt;NULL&lt;/code&gt; ；&lt;a href=&quot;https://cran.r-project.org/doc/manuals/r-release/R-lang.html#NA-handling&quot;&gt;在R中&lt;/a&gt;，失踪等效于 &lt;code&gt;NA&lt;/code&gt; ；并且在大多数情况下，行为类似于它们。</target>
        </trans-unit>
        <trans-unit id="105b1a0ce6d2b2d8bfa2faba37832a7982f4eb0d" translate="yes" xml:space="preserve">
          <source>Julia provides tuples and real hash tables, but not R-style lists. When returning multiple items, you should typically use a tuple or a named tuple: instead of &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt;, use &lt;code&gt;(1, 2)&lt;/code&gt; or &lt;code&gt;(a=1, b=2)&lt;/code&gt;.</source>
          <target state="translated">Julia提供了元组和真实的哈希表，但没有提供R样式列表。返回多个项目时，通常应使用一个元组或一个命名的元组：代替 &lt;code&gt;list(a = 1, b = 2)&lt;/code&gt; ，使用 &lt;code&gt;(1, 2)&lt;/code&gt; 或 &lt;code&gt;(a=1, b=2)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="12d6b550dc7735e370a3f8c010496abe63394b14" translate="yes" xml:space="preserve">
          <source>Julia provides two in-built cluster managers:</source>
          <target state="translated">Julia提供了两个内置的集群管理器。</target>
        </trans-unit>
        <trans-unit id="46d26e39331065ec318009a2e11c1e691fbfaee6" translate="yes" xml:space="preserve">
          <source>Julia requires &lt;code&gt;end&lt;/code&gt; for indexing until the last element. &lt;code&gt;x[1:]&lt;/code&gt; in Python is equivalent to &lt;code&gt;x[2:end]&lt;/code&gt; in Julia.</source>
          <target state="translated">Julia要求索引 &lt;code&gt;end&lt;/code&gt; 直到最后一个元素。Python中的 &lt;code&gt;x[1:]&lt;/code&gt; 等效于Julia中的 &lt;code&gt;x[2:end]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c65c2e80d135867ac3b507bcd217f7ad2507c745" translate="yes" xml:space="preserve">
          <source>Julia requires &lt;code&gt;end&lt;/code&gt; to end a block. Unlike Python, Julia has no &lt;code&gt;pass&lt;/code&gt; keyword.</source>
          <target state="translated">茱莉亚（Julia）需要 &lt;code&gt;end&lt;/code&gt; 相接。与Python不同，Julia没有 &lt;code&gt;pass&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="42da913aac127180e179863fc35f1ca348a1d911" translate="yes" xml:space="preserve">
          <source>Julia should load our new code. Let's test it:</source>
          <target state="translated">Julia应该会加载我们的新代码。我们来测试一下</target>
        </trans-unit>
        <trans-unit id="50af488570ea82992b042e6982e9d5b39f404c93" translate="yes" xml:space="preserve">
          <source>Julia structures may have exactly one abstract supertype, whereas Python classes can inherit from one or more (abstract or concrete) superclasses.</source>
          <target state="translated">Julia结构可能只有一个抽象的超类型,而Python类可以从一个或多个(抽象或具体)超类继承。</target>
        </trans-unit>
        <trans-unit id="b7c7299bbee239f4f34ffd5f256e5fa27242ff3f" translate="yes" xml:space="preserve">
          <source>Julia supports accessing and modifying values &lt;em&gt;atomically&lt;/em&gt;, that is, in a thread-safe way to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;race conditions&lt;/a&gt;. A value (which must be of a primitive type) can be wrapped as &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt;&lt;code&gt;Threads.Atomic&lt;/code&gt;&lt;/a&gt; to indicate it must be accessed in this way. Here we can see an example:</source>
          <target state="translated">Julia支持&lt;em&gt;原子&lt;/em&gt;访问和修改值，即以线程安全的方式避免&lt;a href=&quot;https://en.wikipedia.org/wiki/Race_condition&quot;&gt;竞争条件&lt;/a&gt;。值（必须是原始类型）可以包装为&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.Atomic&quot;&gt; &lt;code&gt;Threads.Atomic&lt;/code&gt; &lt;/a&gt;表示必须以这种方式访问​​。在这里我们可以看到一个例子：</target>
        </trans-unit>
        <trans-unit id="b32a099891e5d6d1de5f4e3ebb7913c9c9d83a6a" translate="yes" xml:space="preserve">
          <source>Julia supports federated package management, which means that multiple independent parties can maintain both public and private packages and registries of packages, and that projects can depend on a mix of public and private packages from different registries. Packages from various registries are installed and managed using a common set of tools and workflows. The &lt;code&gt;Pkg&lt;/code&gt; package manager that ships with Julia lets you install and manage your projects' dependencies. It assists in creating and manipulating project files (which describe what other projects that your project depends on), and manifest files (which snapshot exact versions of your project's complete dependency graph).</source>
          <target state="translated">Julia支持联合程序包管理，这意味着多个独立方可以维护公共程序包和私有程序包以及程序包注册表，并且项目可以依赖于来自不同注册表的公共程序包和私有程序包的混合。使用一组通用的工具和工作流来安装和管理来自各个注册表的软件包。Julia附带的 &lt;code&gt;Pkg&lt;/code&gt; 软件包管理器使您可以安装和管理项目的依赖项。它有助于创建和处理项目文件（描述项目所依赖的其他项目）和清单文件（对项目的完整依赖图的确切版本进行快照）。</target>
        </trans-unit>
        <trans-unit id="3e86dc9fbf230d572664966d4794a26de9273668" translate="yes" xml:space="preserve">
          <source>Julia supports parallel loops using the &lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt;&lt;code&gt;Threads.@threads&lt;/code&gt;&lt;/a&gt; macro. This macro is affixed in front of a &lt;code&gt;for&lt;/code&gt; loop to indicate to Julia that the loop is a multi-threaded region:</source>
          <target state="translated">Julia使用&lt;a href=&quot;../../base/multi-threading/index#Base.Threads.@threads&quot;&gt; &lt;code&gt;Threads.@threads&lt;/code&gt; &lt;/a&gt;宏支持并行循环。此宏附加在 &lt;code&gt;for&lt;/code&gt; 循环的前面，以向Julia指示该循环是一个多线程区域：</target>
        </trans-unit>
        <trans-unit id="a5283fbcd3917bac5a655bc39180ded4c3af822e" translate="yes" xml:space="preserve">
          <source>Julia supports three forms of numerical conversion, which differ in their handling of inexact conversions.</source>
          <target state="translated">Julia支持三种形式的数值转换,它们对不精确转换的处理方式不同。</target>
        </trans-unit>
        <trans-unit id="8cd4a62b540f64bfcf5a4bbfe0bf9740f9b0515a" translate="yes" xml:space="preserve">
          <source>Julia supports three main categories of features for concurrent and parallel programming:</source>
          <target state="translated">Julia支持并发和并行编程的三大类功能。</target>
        </trans-unit>
        <trans-unit id="58e2d62c4e474d2e3cdad1aedacbc766563cd1d6" translate="yes" xml:space="preserve">
          <source>Julia uses 1-based indexing for arrays by default, and it can also handle arbitrary &lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;index offsets&lt;/a&gt;.</source>
          <target state="translated">Julia默认情况下对数组使用基于1的索引，它还可以处理任意&lt;a href=&quot;https://docs.julialang.org/en/v1.5.3/devdocs/offset-arrays/#man-custom-indices&quot;&gt;索引偏移量&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ab0cbf25806d0b9c5fc2aa6aef5c6cef44171513" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;lexical scoping&lt;/a&gt;, meaning that a function's scope does not inherit from its caller's scope, but from the scope in which the function was defined. For example, in the following code the &lt;code&gt;x&lt;/code&gt; inside &lt;code&gt;foo&lt;/code&gt; refers to the &lt;code&gt;x&lt;/code&gt; in the global scope of its module &lt;code&gt;Bar&lt;/code&gt;:</source>
          <target state="translated">Julia使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_%28computer_science%29#Lexical_scoping_vs._dynamic_scoping&quot;&gt;词法作用域&lt;/a&gt;，即函数的作用域不是从调用者的作用域继承，而是从定义函数的作用域继承。例如，在以下代码中， &lt;code&gt;foo&lt;/code&gt; 内部的 &lt;code&gt;x&lt;/code&gt; 引用其模块 &lt;code&gt;Bar&lt;/code&gt; 的全局范围内的 &lt;code&gt;x&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c3c73ac079b0c4f92a7cd6345869462d4c4c72df" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;, because of the operator precedence.</source>
          <target state="translated">Julia使用 &lt;code&gt;end&lt;/code&gt; 表示条件块的结尾，例如 &lt;code&gt;if&lt;/code&gt; ，循环块，如 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 和函数。代替单行 &lt;code&gt;if ( cond ) statement&lt;/code&gt; ，Julia允许使用 &lt;code&gt;if cond; statement; end&lt;/code&gt; 形式的语句；声明; end， &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; 和 &lt;code&gt;!cond || statement&lt;/code&gt; 。由于运算符优先级，后两种语法中的赋值语句必须显式包装在括号中，例如 &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0cabc05bc6f900c3729476582490d063a944c3f3" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;end&lt;/code&gt; to denote the end of conditional blocks, like &lt;code&gt;if&lt;/code&gt;, loop blocks, like &lt;code&gt;while&lt;/code&gt;/ &lt;code&gt;for&lt;/code&gt;, and functions. In lieu of the one-line &lt;code&gt;if ( cond ) statement&lt;/code&gt;, Julia allows statements of the form &lt;code&gt;if cond; statement; end&lt;/code&gt;, &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; and &lt;code&gt;!cond || statement&lt;/code&gt;. Assignment statements in the latter two syntaxes must be explicitly wrapped in parentheses, e.g. &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt;.</source>
          <target state="translated">Julia使用 &lt;code&gt;end&lt;/code&gt; 表示条件块的结尾，例如 &lt;code&gt;if&lt;/code&gt; ，循环块，如 &lt;code&gt;while&lt;/code&gt; / &lt;code&gt;for&lt;/code&gt; 和函数。代替单行 &lt;code&gt;if ( cond ) statement&lt;/code&gt; ，Julia允许使用 &lt;code&gt;if cond; statement; end&lt;/code&gt; 形式的语句；声明; end， &lt;code&gt;cond &amp;amp;&amp;amp; statement&lt;/code&gt; 和 &lt;code&gt;!cond || statement&lt;/code&gt; 。后两种语法中的赋值语句必须显式包装在括号中，例如 &lt;code&gt;cond &amp;amp;&amp;amp; (x = value)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="07096f6426ddf7d6431c3e711ca9f0c89cf1dd4d" translate="yes" xml:space="preserve">
          <source>Julia uses &lt;code&gt;nothing&lt;/code&gt; of type &lt;code&gt;Nothing&lt;/code&gt; to represent a null value, whereas Python uses &lt;code&gt;None&lt;/code&gt; of type &lt;code&gt;NoneType&lt;/code&gt;.</source>
          <target state="translated">朱莉娅使用 &lt;code&gt;nothing&lt;/code&gt; 类型的 &lt;code&gt;Nothing&lt;/code&gt; 来表示一个空值，而Python使用 &lt;code&gt;None&lt;/code&gt; 类型的 &lt;code&gt;NoneType&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c1da921baa95047321b954687696b91e15a78b61" translate="yes" xml:space="preserve">
          <source>Julia uses machine arithmetic for integer computations. This means that the range of &lt;code&gt;Int&lt;/code&gt; values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</source>
          <target state="translated">Julia uses machine arithmetic for integer computations. This means that the range of &lt;code&gt;Int&lt;/code&gt; values is bounded and wraps around at either end so that adding, subtracting and multiplying integers can overflow or underflow, leading to some results that can be unsettling at first:</target>
        </trans-unit>
        <trans-unit id="89c53eee9d134c8dd587da06fe96b8ba48e316ee" translate="yes" xml:space="preserve">
          <source>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; package implements &lt;code&gt;UTF16String&lt;/code&gt; and &lt;code&gt;UTF32String&lt;/code&gt; types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on &lt;a href=&quot;#man-byte-array-literals&quot;&gt;byte array literals&lt;/a&gt;. The &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</source>
          <target state="translated">Julia默认使用UTF-8编码，并且可以通过软件包添加对新编码的支持。例如，&lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt;包实现了 &lt;code&gt;UTF16String&lt;/code&gt; 和 &lt;code&gt;UTF32String&lt;/code&gt; 类型。目前，关于其他编码以及如何实现对它们的支持的其他讨论不在本文的讨论范围之内。有关UTF-8编码问题的进一步讨论，请参见下面有关&lt;a href=&quot;#man-byte-array-literals&quot;&gt;字节数组文字&lt;/a&gt;的部分。所述&lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt;被设置功能到各个UTF-XX编码之间转换数据，主要用于与外部数据和库的工作。</target>
        </trans-unit>
        <trans-unit id="51011bd7d0e6585180df272ca646802fbeb44e3f" translate="yes" xml:space="preserve">
          <source>Julia uses the UTF-8 encoding by default, and support for new encodings can be added by packages. For example, the &lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt; package implements &lt;code&gt;UTF16String&lt;/code&gt; and &lt;code&gt;UTF32String&lt;/code&gt; types. Additional discussion of other encodings and how to implement support for them is beyond the scope of this document for the time being. For further discussion of UTF-8 encoding issues, see the section below on &lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;byte array literals&lt;/a&gt;. The &lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt;&lt;code&gt;transcode&lt;/code&gt;&lt;/a&gt; function is provided to convert data between the various UTF-xx encodings, primarily for working with external data and libraries.</source>
          <target state="translated">Julia默认使用UTF-8编码，并且可以通过软件包添加对新编码的支持。例如，&lt;a href=&quot;https://github.com/JuliaStrings/LegacyStrings.jl&quot;&gt;LegacyStrings.jl&lt;/a&gt;包实现了 &lt;code&gt;UTF16String&lt;/code&gt; 和 &lt;code&gt;UTF32String&lt;/code&gt; 类型。目前，关于其他编码以及如何实现对它们的支持的其他讨论不在本文的讨论范围之内。有关UTF-8编码问题的进一步讨论，请参见下面有关&lt;a href=&quot;#man-byte-array-literals-1&quot;&gt;字节数组文字&lt;/a&gt;的部分。所述&lt;a href=&quot;../../base/strings/index#Base.transcode&quot;&gt; &lt;code&gt;transcode&lt;/code&gt; &lt;/a&gt;被设置功能到各个UTF-XX编码之间转换数据，主要用于与外部数据和库的工作。</target>
        </trans-unit>
        <trans-unit id="5e0e9c6a66c5fa559fda71e594a3ae5240a6637e" translate="yes" xml:space="preserve">
          <source>Julia uses the first of these that exists to try to load the public &lt;code&gt;Priv&lt;/code&gt; package from the file &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; in the depot where it was found.</source>
          <target state="translated">Julia使用存在的第一个 &lt;code&gt;packages/Priv/HDKrT/src/Priv.jl&lt;/code&gt; 尝试从发现它的软件仓库中的文件packages / Priv / HDKrT / src / Priv.jl中加载公共 &lt;code&gt;Priv&lt;/code&gt; 软件包。</target>
        </trans-unit>
        <trans-unit id="30edeef56ee9d985332259b8e62139e00973bd46" translate="yes" xml:space="preserve">
          <source>Julia uses your system's locale and language settings to determine which characters can be printed as-is and which must be output using the generic, escaped &lt;code&gt;\u&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; input forms. In addition to these Unicode escape forms, all of &lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;C's traditional escaped input forms&lt;/a&gt; can also be used:</source>
          <target state="translated">Julia使用系统的语言环境和语言设置来确定哪些字符可以原样打印，哪些字符必须使用转义的 &lt;code&gt;\u&lt;/code&gt; 或 &lt;code&gt;\U&lt;/code&gt; 输入形式输出。除了这些Unicode转义形式之外，还可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/C_syntax#Backslash_escapes&quot;&gt;C的&lt;/a&gt;所有传统转义输入形式：</target>
        </trans-unit>
        <trans-unit id="bd0dc71ebce3799f196e4c40689f527bedaa69fb" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when assigned or passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">当分配或传递给一个函数时,Julia的值不会被复制。如果一个函数修改了一个数组,其变化将在调用者中可见。</target>
        </trans-unit>
        <trans-unit id="7ac4008d58382151203baf7753fcd45089959029" translate="yes" xml:space="preserve">
          <source>Julia values are not copied when passed to a function. If a function modifies an array, the changes will be visible in the caller.</source>
          <target state="translated">当传递给函数时,Julia的值不会被复制。如果一个函数修改了一个数组,那么在调用者中就会看到其变化。</target>
        </trans-unit>
        <trans-unit id="8837407288696b8f56b310a5e7e527268f191a69" translate="yes" xml:space="preserve">
          <source>Julia will even let you redefine built-in constants and functions if needed (although this is not recommended to avoid potential confusions):</source>
          <target state="translated">如果需要的话,Julia甚至会让你重新定义内置的常量和函数(尽管不建议这样做以避免潜在的混乱)。</target>
        </trans-unit>
        <trans-unit id="bbfd1a84071c3afc3da5111c8fd03dbd6cb9cfcf" translate="yes" xml:space="preserve">
          <source>Julia workers must NOT be started with &lt;code&gt;--worker&lt;/code&gt;. Starting with &lt;code&gt;--worker&lt;/code&gt; will result in the newly launched workers defaulting to the TCP/IP socket transport implementation.</source>
          <target state="translated">朱莉娅工人不得以 &lt;code&gt;--worker&lt;/code&gt; 开头。以 &lt;code&gt;--worker&lt;/code&gt; 开头将导致新启动的worker默认使用TCP / IP套接字传输实现。</target>
        </trans-unit>
        <trans-unit id="d2e71f463c75ed1f922e909db643a6a01be0bb01" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; takes the function first, then its arguments, unlike &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; in R. Similarly Julia's equivalent of &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; in R is &lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt;&lt;code&gt;mapslices&lt;/code&gt;&lt;/a&gt; where the function is the first argument.</source>
          <target state="translated">与 &lt;code&gt;lapply(&amp;lt;structure&amp;gt;, function, ...)&lt;/code&gt; 不同，Julia的&lt;a href=&quot;../../base/collections/index#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;首先获取函数，然后获取参数。同样，R中的Julia（相当于Julia ） &lt;code&gt;apply(X, MARGIN, FUN, ...)&lt;/code&gt; 是&lt;a href=&quot;../../base/arrays/index#Base.mapslices&quot;&gt; &lt;code&gt;mapslices&lt;/code&gt; &lt;/a&gt;，其中函数是第一个论点。</target>
        </trans-unit>
        <trans-unit id="f5bb002ee0de69716a37fbfcd112bddd1aed44f5" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; are different from their counterparts in R. They all accept an optional keyword argument &lt;code&gt;dims&lt;/code&gt;, which indicates the dimensions, over which the operation is carried out. For instance, let &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; in Julia and &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; be the same matrix in R. Then &lt;code&gt;sum(A)&lt;/code&gt; gives the same result as &lt;code&gt;sum(B)&lt;/code&gt;, but &lt;code&gt;sum(A, dims=1)&lt;/code&gt; is a row vector containing the sum over each column and &lt;code&gt;sum(A, dims=2)&lt;/code&gt; is a column vector containing the sum over each row. This contrasts to the behavior of R, where separate &lt;code&gt;colSums(B)&lt;/code&gt; and &lt;code&gt;rowSums(B)&lt;/code&gt; functions provide these functionalities. If the &lt;code&gt;dims&lt;/code&gt; keyword argument is a vector, then it specifies all the dimensions over which the sum is performed, while retaining the dimensions of the summed array, e.g. &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt;. It should be noted that there is no error checking regarding the second argument.</source>
          <target state="translated">Julia的&lt;a href=&quot;../../base/collections/index#Base.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/collections/index#Base.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt;，&lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt;不同于R中的对等字符。它们都接受可选的关键字参数 &lt;code&gt;dims&lt;/code&gt; ，该参数指示执行操作的维度。例如，令 &lt;code&gt;A = [1 2; 3 4]&lt;/code&gt; 在Julia和 &lt;code&gt;B &amp;lt;- rbind(c(1,2),c(3,4))&lt;/code&gt; 是R中的相同矩阵。然后 &lt;code&gt;sum(A)&lt;/code&gt; 得出与 &lt;code&gt;sum(B)&lt;/code&gt; 相同的结果，但是 &lt;code&gt;sum(A, dims=1)&lt;/code&gt; 是包含每列 &lt;code&gt;sum(A, dims=2)&lt;/code&gt; 的行向量，sum（A，dims = 2）是包含每行总和的列向量。这与R的行为形成对比，其中R分开 &lt;code&gt;colSums(B)&lt;/code&gt; 和 &lt;code&gt;rowSums(B)&lt;/code&gt; 函数提供了这些功能。如果 &lt;code&gt;dims&lt;/code&gt; 关键字参数是向量，则它指定执行求和的所有维，同时保留求和数组的维，例如 &lt;code&gt;sum(A, dims=(1,2)) == hcat(10)&lt;/code&gt; 。应该注意的是，没有关于第二个参数的错误检查。</target>
        </trans-unit>
        <trans-unit id="fa67fe88be62afc80adeb10ce9e92a9b5f6f9cf4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../base/math/index#Base.max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; are the equivalent of &lt;code&gt;pmax&lt;/code&gt; and &lt;code&gt;pmin&lt;/code&gt; respectively in R, but both arguments need to have the same dimensions. While &lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; replace &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; in R, there are important differences.</source>
          <target state="translated">Julia的&lt;a href=&quot;../../base/math/index#Base.max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/math/index#Base.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt;分别等于R中的 &lt;code&gt;pmax&lt;/code&gt; 和 &lt;code&gt;pmin&lt;/code&gt; ，但是两个参数都必须具有相同的尺寸。虽然&lt;a href=&quot;../../base/collections/index#Base.maximum&quot;&gt; &lt;code&gt;maximum&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/collections/index#Base.minimum&quot;&gt; &lt;code&gt;minimum&lt;/code&gt; &lt;/a&gt;替换了R中的 &lt;code&gt;max&lt;/code&gt; 和 &lt;code&gt;min&lt;/code&gt; ，但有一些重要的区别。</target>
        </trans-unit>
        <trans-unit id="948bcc3b1298520e6e2ce90508494e37d41ff33b" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; is designed for the case where each function call does a large amount of work. In contrast, &lt;code&gt;@distributed for&lt;/code&gt; can handle situations where each iteration is tiny, perhaps merely summing two numbers. Only worker processes are used by both &lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt;&lt;code&gt;pmap&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;@distributed for&lt;/code&gt; for the parallel computation. In case of &lt;code&gt;@distributed for&lt;/code&gt;, the final reduction is done on the calling process.</source>
          <target state="translated">Julia的&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;是为每个函数调用都需要大量工作的情况而设计的。相反， &lt;code&gt;@distributed for&lt;/code&gt; 可以处理每次迭代很小的情况，也许只需将两个数字求和即可。&lt;a href=&quot;../../stdlib/distributed/index#Distributed.pmap&quot;&gt; &lt;code&gt;pmap&lt;/code&gt; &lt;/a&gt;和 &lt;code&gt;@distributed for&lt;/code&gt; 仅将工作进程用于并行计算。对于 &lt;code&gt;@distributed for&lt;/code&gt; ，最后的减少是在调用过程中完成的。</target>
        </trans-unit>
        <trans-unit id="1dee74c8ab40f9a1e425f6d177c82bc6b08fa25e" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt;&lt;code&gt;diag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt;&lt;code&gt;diagm&lt;/code&gt;&lt;/a&gt; are not like R's.</source>
          <target state="translated">Julia的&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diag&quot;&gt; &lt;code&gt;diag&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.diagm&quot;&gt; &lt;code&gt;diagm&lt;/code&gt; &lt;/a&gt;并不如R的。</target>
        </trans-unit>
        <trans-unit id="05bb4ea25c67464af30f3b1789a99b7d0ce690d4" translate="yes" xml:space="preserve">
          <source>Julia's &lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt;&lt;code&gt;svd&lt;/code&gt;&lt;/a&gt; returns singular values as a vector instead of as a dense diagonal matrix.</source>
          <target state="translated">朱莉娅的&lt;a href=&quot;../../stdlib/linearalgebra/index#LinearAlgebra.svd&quot;&gt; &lt;code&gt;svd&lt;/code&gt; &lt;/a&gt;将奇异值作为向量而不是密集的对角矩阵返回。</target>
        </trans-unit>
        <trans-unit id="aa13bfca9375abd93cb6c7683cece63cd5fd2582" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;*&lt;/code&gt; operator can perform matrix multiplication, unlike in R. If &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are matrices, then &lt;code&gt;A * B&lt;/code&gt; denotes a matrix multiplication in Julia, equivalent to R's &lt;code&gt;A %*% B&lt;/code&gt;. In R, this same notation would perform an element-wise (Hadamard) product. To get the element-wise multiplication operation, you need to write &lt;code&gt;A .* B&lt;/code&gt; in Julia.</source>
          <target state="translated">与R不同，Julia的 &lt;code&gt;*&lt;/code&gt; 运算符可以执行矩阵乘法。如果 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 是矩阵，则 &lt;code&gt;A * B&lt;/code&gt; 表示Julia中的矩阵乘法，等效于R的 &lt;code&gt;A %*% B&lt;/code&gt; 。在R中，相同的表示法将执行元素级（Hadamard）乘积。要获得按元素的乘法运算，您需要在Julia中编写 &lt;code&gt;A .* B&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb6c182bb057e6aaee719738d353d529a33805be" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function, it does not access a member via a pointer.</source>
          <target state="translated">Julia's- &lt;code&gt;-&amp;gt;&lt;/code&gt; 创建一个匿名函数，它不通过指针访问成员。</target>
        </trans-unit>
        <trans-unit id="0862128440ff742c36348e2d0db0ca8e8f8925ae" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;-&amp;gt;&lt;/code&gt; creates an anonymous function.</source>
          <target state="translated">朱莉娅的 &lt;code&gt;-&amp;gt;&lt;/code&gt; 创建一个匿名函数。</target>
        </trans-unit>
        <trans-unit id="5ae5cdad8a8956ce245f1722cb08571c8a10bd0f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;Char&lt;/code&gt; type is 32 bits, which is not the same as the wide character type (&lt;code&gt;wchar_t&lt;/code&gt; or &lt;code&gt;wint_t&lt;/code&gt;) on all platforms.</source>
          <target state="translated">Julia的 &lt;code&gt;Char&lt;/code&gt; 类型为32位，与所有平台上的宽字符类型（ &lt;code&gt;wchar_t&lt;/code&gt; 或 &lt;code&gt;wint_t&lt;/code&gt; ）不同。</target>
        </trans-unit>
        <trans-unit id="b385c4d6332873c3dcd00293c1c25f1adc3ec233" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;^&lt;/code&gt; is exponentiation (pow), not bitwise XOR as in C/C++ (use &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;⊻&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt;, in Julia)</source>
          <target state="translated">Julia的 &lt;code&gt;^&lt;/code&gt; 是幂（pow），而不是C / C ++中的按位XOR（在Julia中使用&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;⊻&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="b992e2bb2c187c81d565dd2576257e75a4ff2ac1" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. blocks are terminated by the &lt;code&gt;end&lt;/code&gt; keyword. Indentation level is not significant as it is in Python.</source>
          <target state="translated">Julia的 &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 等等块以 &lt;code&gt;end&lt;/code&gt; 关键字终止。缩进级别并不像Python中那样重要。</target>
        </trans-unit>
        <trans-unit id="4f389c4a1d318e9dd00a0e8de7e401cb98f80629" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc. blocks are terminated by the &lt;code&gt;end&lt;/code&gt; keyword. Indentation level is not significant as it is in Python. Unlike Python, Julia has no &lt;code&gt;pass&lt;/code&gt; keyword.</source>
          <target state="translated">Julia的 &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 等等块以 &lt;code&gt;end&lt;/code&gt; 关键字终止。缩进级别并不像在Python中那样重要。与Python不同，Julia没有 &lt;code&gt;pass&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="4a5e37d3fa53f0bf640b0dba96a1ab8faecfac9f" translate="yes" xml:space="preserve">
          <source>Julia's &lt;code&gt;struct&lt;/code&gt;s do not support dynamically adding fields at runtime, unlike MATLAB's &lt;code&gt;class&lt;/code&gt;es. Instead, use a &lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt;&lt;code&gt;Dict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Julia的 &lt;code&gt;struct&lt;/code&gt; ■不要在运行时动态支持添加字段，不像MATLAB的 &lt;code&gt;class&lt;/code&gt; 上课。而是使用&lt;a href=&quot;../../base/collections/index#Base.Dict&quot;&gt; &lt;code&gt;Dict&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f4b03ee02a08f7deb55748f11f6cdeb8e4ae72ba" translate="yes" xml:space="preserve">
          <source>Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to &lt;code&gt;REPL.setup_interface&lt;/code&gt;. The keys of this dictionary may be characters or strings. The key &lt;code&gt;'*'&lt;/code&gt; refers to the default action. Control plus character &lt;code&gt;x&lt;/code&gt; bindings are indicated with &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. Meta plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\M-x&quot;&lt;/code&gt; or &lt;code&gt;&quot;\ex&quot;&lt;/code&gt;, and Control plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\C-x&quot;&lt;/code&gt; or &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. The values of the custom keymap must be &lt;code&gt;nothing&lt;/code&gt; (indicating that the input should be ignored) or functions that accept the signature &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt;. The &lt;code&gt;REPL.setup_interface&lt;/code&gt; function must be called before the REPL is initialized, by registering the operation with &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">通过将字典传递给 &lt;code&gt;REPL.setup_interface&lt;/code&gt; ,可以完全根据用户的喜好自定义Julia的REPL键绑定。该词典的键可以是字符或字符串。键 &lt;code&gt;'*'&lt;/code&gt; 是指默认操作。控件加字符 &lt;code&gt;x&lt;/code&gt; 的绑定用 &lt;code&gt;&quot;^x&quot;&lt;/code&gt; 。 Meta plus &lt;code&gt;x&lt;/code&gt; 可以写为 &lt;code&gt;&quot;\\M-x&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;\ex&quot;&lt;/code&gt; ，Control plus &lt;code&gt;x&lt;/code&gt; 可以写为 &lt;code&gt;&quot;\\C-x&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;^x&quot;&lt;/code&gt; 。自定义键映射的值必须为 &lt;code&gt;nothing&lt;/code&gt; （指示应忽略输入）或接受签名的函数 &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt; 。所述 &lt;code&gt;REPL.setup_interface&lt;/code&gt; 的REPL初始化之前，通过与登记操作函数必须被调用&lt;a href=&quot;#Base.atreplinit&quot;&gt; &lt;code&gt;atreplinit&lt;/code&gt; &lt;/a&gt;。例如，要绑定上下箭头键在历史记录中移动而无需前缀搜索，可以将以下代码放入 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="eb62051205cdc85bbd2ca3341a23ca3df8234a6b" translate="yes" xml:space="preserve">
          <source>Julia's REPL keybindings may be fully customized to a user's preferences by passing a dictionary to &lt;code&gt;REPL.setup_interface&lt;/code&gt;. The keys of this dictionary may be characters or strings. The key &lt;code&gt;'*'&lt;/code&gt; refers to the default action. Control plus character &lt;code&gt;x&lt;/code&gt; bindings are indicated with &lt;code&gt;&quot;^x&quot;&lt;/code&gt;. Meta plus &lt;code&gt;x&lt;/code&gt; can be written &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt;. The values of the custom keymap must be &lt;code&gt;nothing&lt;/code&gt; (indicating that the input should be ignored) or functions that accept the signature &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt;. The &lt;code&gt;REPL.setup_interface&lt;/code&gt; function must be called before the REPL is initialized, by registering the operation with &lt;a href=&quot;#Base.atreplinit&quot;&gt;&lt;code&gt;atreplinit&lt;/code&gt;&lt;/a&gt; . For example, to bind the up and down arrow keys to move through history without prefix search, one could put the following code in &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;:</source>
          <target state="translated">通过将字典传递给 &lt;code&gt;REPL.setup_interface&lt;/code&gt; ,可以完全根据用户的喜好自定义Julia的REPL键绑定。该词典的键可以是字符或字符串。键 &lt;code&gt;'*'&lt;/code&gt; 是指默认操作。控件加字符 &lt;code&gt;x&lt;/code&gt; 的绑定用 &lt;code&gt;&quot;^x&quot;&lt;/code&gt; 。 Meta plus &lt;code&gt;x&lt;/code&gt; 可以写为 &lt;code&gt;&quot;\\Mx&quot;&lt;/code&gt; 。自定义键映射的值必须为 &lt;code&gt;nothing&lt;/code&gt; （指示应忽略输入）或接受签名的函数 &lt;code&gt;(PromptState, AbstractREPL, Char)&lt;/code&gt; 。所述 &lt;code&gt;REPL.setup_interface&lt;/code&gt; 的REPL初始化之前函数必须被调用，通过与登记操作&lt;a href=&quot;#Base.atreplinit&quot;&gt; &lt;code&gt;atreplinit&lt;/code&gt; &lt;/a&gt;。例如，要绑定上下箭头键以浏览历史记录而无需前缀搜索，可以将以下代码放入 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5dfc06368777a16cdc231cc0f47af0adaed5f388" translate="yes" xml:space="preserve">
          <source>Julia's advantage is that good performance is not limited to a small subset of &amp;ldquo;built-in&amp;rdquo; types and operations, and one can write high-level type-generic code that works on arbitrary user-defined types while remaining fast and memory-efficient. Types in languages like Python simply don't provide enough information to the compiler for similar capabilities, so as soon as you used those languages as a Julia front-end you would be stuck.</source>
          <target state="translated">Julia的优势在于，良好的性能不仅限于一小部分&amp;ldquo;内置&amp;rdquo;类型和操作，而且可以编写适用于任意用户定义类型的高级类型通用代码，同时保持快速且高效的内存。像Python这样的语言中的类型根本无法向编译器提供足够的信息来提供类似的功能，因此，一旦将这些语言用作Julia前端，您就会陷入困境。</target>
        </trans-unit>
        <trans-unit id="ff3f30910627d9bc09b7bdaeca1a62844f17b994" translate="yes" xml:space="preserve">
          <source>Julia's base library has a an internal &lt;code&gt;sub2ind&lt;/code&gt; function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index &lt;code&gt;i&lt;/code&gt; that can be used to index into an array &lt;code&gt;A&lt;/code&gt; using &lt;code&gt;A[i]&lt;/code&gt;, instead of &lt;code&gt;A[x,y,z,...]&lt;/code&gt;. One possible implementation is the following:</source>
          <target state="translated">Julia的基本库具有一个内部 &lt;code&gt;sub2ind&lt;/code&gt; 函数来计算的线性索引到一个n维阵列的基础上，一组N个多线性指数-换句话说，计算出索引 &lt;code&gt;i&lt;/code&gt; 可用于索引到一个数组 &lt;code&gt;A&lt;/code&gt; 使用 &lt;code&gt;A[i]&lt;/code&gt; ，而不是 &lt;code&gt;A[x,y,z,...]&lt;/code&gt; 。一种可能的实现如下：</target>
        </trans-unit>
        <trans-unit id="c2b028dd5553cdb221b0a0e50311b3fadf26a8fa" translate="yes" xml:space="preserve">
          <source>Julia's base library has an internal &lt;code&gt;sub2ind&lt;/code&gt; function to calculate a linear index into an n-dimensional array, based on a set of n multilinear indices - in other words, to calculate the index &lt;code&gt;i&lt;/code&gt; that can be used to index into an array &lt;code&gt;A&lt;/code&gt; using &lt;code&gt;A[i]&lt;/code&gt;, instead of &lt;code&gt;A[x,y,z,...]&lt;/code&gt;. One possible implementation is the following:</source>
          <target state="translated">Julia的基础库具有一个内部 &lt;code&gt;sub2ind&lt;/code&gt; 函数，用于基于一组n个多线性索引来计算n维数组中的线性索引-换句话说，计算可用于使用 &lt;code&gt;A[i]&lt;/code&gt; 索引到数组 &lt;code&gt;A&lt;/code&gt; 中的索引 &lt;code&gt;i&lt;/code&gt; [i]，而不是 &lt;code&gt;A[x,y,z,...]&lt;/code&gt; 。一种可能的实现如下：</target>
        </trans-unit>
        <trans-unit id="a8c2555d21a070c01d642324e7f2023f9aae7e60" translate="yes" xml:space="preserve">
          <source>Julia's compiler specializes code for argument types at function boundaries, so in the original implementation it does not know the type of &lt;code&gt;a&lt;/code&gt; during the loop (since it is chosen randomly). Therefore the second version is generally faster since the inner loop can be recompiled as part of &lt;code&gt;fill_twos!&lt;/code&gt; for different types of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Julia的编译器专门用于参数类型的代码在功能边界，所以在最初的实现，它不知道的类型， &lt;code&gt;a&lt;/code&gt; 在循环过程（因为它是随机选择）。因此，第二个版本通常更快，因为可以将内部循环作为 &lt;code&gt;fill_twos!&lt;/code&gt; 一部分重新编译！针对不同类型的 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="33f4b2b5366e275dc9d4f8493361eee0738216e2" translate="yes" xml:space="preserve">
          <source>Julia's implementation of message passing is different from other environments such as MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</source>
          <target state="translated">Julia的消息传递实现不同于MPI &lt;a href=&quot;#footnote-1&quot;&gt;[1]&lt;/a&gt;等其他环境。 Julia中的通信通常是&amp;ldquo;单边的&amp;rdquo;，这意味着程序员仅需要在两进程操作中显式管理一个进程。此外，这些操作通常看起来不像&amp;ldquo;消息发送&amp;rdquo;和&amp;ldquo;消息接收&amp;rdquo;，而是类似于更高级别的操作，例如对用户函数的调用。</target>
        </trans-unit>
        <trans-unit id="6c32163901432dfb93ac8223e9799a51677fe0b8" translate="yes" xml:space="preserve">
          <source>Julia's implementation of message passing is different from other environments such as MPI&lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Communication in Julia is generally &quot;one-sided&quot;, meaning that the programmer needs to explicitly manage only one process in a two-process operation. Furthermore, these operations typically do not look like &quot;message send&quot; and &quot;message receive&quot; but rather resemble higher-level operations like calls to user functions.</source>
          <target state="translated">Julia的消息传递实现不同于MPI &lt;sup&gt;&lt;a href=&quot;#footnote-1&quot; id=&quot;citeref-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;等其他环境。 Julia中的通信通常是&amp;ldquo;单边的&amp;rdquo;，这意味着程序员仅需要在两进程操作中显式地管理一个进程。此外，这些操作通常看起来不像&amp;ldquo;消息发送&amp;rdquo;和&amp;ldquo;消息接收&amp;rdquo;，而是类似于更高级别的操作，例如对用户函数的调用。</target>
        </trans-unit>
        <trans-unit id="2d95266cdef29852b478ae12f711e31b88ca02d5" translate="yes" xml:space="preserve">
          <source>Julia's internal indexing machinery will automatically (and invisibly) convert all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</source>
          <target state="translated">Julia的内部索引机制将自动(而且是隐形的)将所有的索引操作转换为首选的样式。这使得用户可以使用任何索引样式来访问数组中的元素,即使没有提供明确的方法。</target>
        </trans-unit>
        <trans-unit id="e29a0ad9426578653cfa0a913517c4cd61d66687" translate="yes" xml:space="preserve">
          <source>Julia's internal indexing machinery will automatically (and invisibly) recompute all indexing operations into the preferred style. This allows users to access elements of your array using any indexing style, even when explicit methods have not been provided.</source>
          <target state="translated">茱莉亚的内部索引机制将自动(而且是隐形的)将所有的索引操作重新计算成首选的样式。这使得用户可以使用任何索引样式来访问数组中的元素,即使没有提供明确的方法。</target>
        </trans-unit>
        <trans-unit id="63b1a2fb20181eebd075a05851e2cc85e0131235" translate="yes" xml:space="preserve">
          <source>Julia's macro expander solves these problems in the following way. First, variables within a macro result are classified as either local or global. A variable is considered local if it is assigned to (and not declared global), declared local, or used as a function argument name. Otherwise, it is considered global. Local variables are then renamed to be unique (using the &lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt;&lt;code&gt;gensym&lt;/code&gt;&lt;/a&gt; function, which generates new symbols), and global variables are resolved within the macro definition environment. Therefore both of the above concerns are handled; the macro's locals will not conflict with any user variables, and &lt;code&gt;time&lt;/code&gt; and &lt;code&gt;println&lt;/code&gt; will refer to the Julia Base definitions.</source>
          <target state="translated">Julia的宏扩展器通过以下方式解决了这些问题。首先，宏结果中的变量分为本地变量或全局变量。如果将变量分配给变量（而不是声明为全局变量），声明为局部变量或用作函数参数名称，则将其视为局部变量。否则，它被认为是全局的。然后将局部变量重命名为唯一的（使用生成新符号的&lt;a href=&quot;../../base/base/index#Base.gensym&quot;&gt; &lt;code&gt;gensym&lt;/code&gt; &lt;/a&gt;函数），并在宏定义环境中解析全局变量。因此，以上两个问题都得到了解决。宏的本地变量不会与任何用户变量冲突， &lt;code&gt;time&lt;/code&gt; 和 &lt;code&gt;println&lt;/code&gt; 将引用Julia基定义。</target>
        </trans-unit>
        <trans-unit id="86edf724d95c13484ea1286ad4816e866d0db9af" translate="yes" xml:space="preserve">
          <source>Julia's markdown supports interpolation in a very similar way to basic string literals, with the difference that it will store the object itself in the Markdown tree (as opposed to converting it to a string). When the Markdown content is rendered the usual &lt;code&gt;show&lt;/code&gt; methods will be called, and these can be overridden as usual. This design allows the Markdown to be extended with arbitrarily complex features (such as references) without cluttering the basic syntax.</source>
          <target state="translated">Julia的markdown以与基本字符串文字非常相似的方式支持插值，区别在于它将对象本身存储在Markdown树中（而不是将其转换为字符串）。呈现Markdown内容时，将调用常规的 &lt;code&gt;show&lt;/code&gt; 方法，并且可以照常覆盖这些方法。这种设计使Markdown可以扩展为具有任意复杂功能（例如引用）的基本语法。</target>
        </trans-unit>
        <trans-unit id="f193759d498fbc023e5548ecbd3efb90a55de4f4" translate="yes" xml:space="preserve">
          <source>Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for &lt;a href=&quot;#man-ambiguities&quot;&gt;ambiguities&lt;/a&gt; to arise.</source>
          <target state="translated">Julia的方法多态性是其最强大的功能之一，但是利用这种功能可能会带来设计挑战。特别是，在更复杂的方法层次结构中，出现&lt;a href=&quot;#man-ambiguities&quot;&gt;歧义&lt;/a&gt;并不罕见。</target>
        </trans-unit>
        <trans-unit id="0901cb4cceb0fa7182b9eca38ef424535bdbefb3" translate="yes" xml:space="preserve">
          <source>Julia's method polymorphism is one of its most powerful features, yet exploiting this power can pose design challenges. In particular, in more complex method hierarchies it is not uncommon for &lt;a href=&quot;#man-ambiguities-1&quot;&gt;ambiguities&lt;/a&gt; to arise.</source>
          <target state="translated">Julia的方法多态性是其最强大的功能之一，但是利用这种功能可能会带来设计挑战。特别是，在更复杂的方法层次结构中，出现&lt;a href=&quot;#man-ambiguities-1&quot;&gt;歧义&lt;/a&gt;并不罕见。</target>
        </trans-unit>
        <trans-unit id="23f2c84d6fee04af47b767e6d6e002d54d481014" translate="yes" xml:space="preserve">
          <source>Julia's multidimensional arrays are stored in memory in column-major order. Here is some code that creates a 2D array and accesses its properties:</source>
          <target state="translated">Julia的多维数组是以列-大顺序存储在内存中的。下面是一些创建二维数组并访问其属性的代码。</target>
        </trans-unit>
        <trans-unit id="5f52e87d6645fc0ed7cad30b976ecccc50cc320e" translate="yes" xml:space="preserve">
          <source>Julia's parallel programming platform uses &lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;Tasks (aka Coroutines)&lt;/a&gt; to switch among multiple computations. To express an order of execution between lightweight threads communication primitives are necessary. Julia offers &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; that creates a new task from &lt;code&gt;func&lt;/code&gt;, binds it to a new channel of type &lt;code&gt;ctype&lt;/code&gt; and size &lt;code&gt;csize&lt;/code&gt; and schedule the task. &lt;code&gt;Channels&lt;/code&gt; can serve as a way to communicate between tasks, as &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; creates a buffered channel of type &lt;code&gt;T&lt;/code&gt; and size &lt;code&gt;sz&lt;/code&gt;. Whenever code performs a communication operation like &lt;code&gt;fetch&lt;/code&gt; or &lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt;, the current task is suspended and a scheduler picks another task to run. A task is restarted when the event it is waiting for completes.</source>
          <target state="translated">Julia的并行编程平台使用&lt;a href=&quot;../control-flow/index#man-tasks-1&quot;&gt;Tasks（又名协程）&lt;/a&gt;在多个计算之间进行切换。为了表达轻量级线程之间的执行顺序，需要通信原语。 Julia提供了 &lt;code&gt;Channel(func::Function, ctype=Any, csize=0, taskref=nothing)&lt;/code&gt; ，该 &lt;code&gt;func&lt;/code&gt; 从func创建新任务，并将其绑定到 &lt;code&gt;ctype&lt;/code&gt; 和size &lt;code&gt;csize&lt;/code&gt; 类型的新通道并调度任务。 &lt;code&gt;Channels&lt;/code&gt; 可以用作任务之间通信的一种方式，因为 &lt;code&gt;Channel{T}(sz::Int)&lt;/code&gt; 创建一个类型为 &lt;code&gt;T&lt;/code&gt; 且大小为 &lt;code&gt;sz&lt;/code&gt; 的缓冲通道。每当代码执行诸如 &lt;code&gt;fetch&lt;/code&gt; 或&lt;a href=&quot;../../base/parallel/index#Base.wait&quot;&gt; &lt;code&gt;wait&lt;/code&gt; &lt;/a&gt;，当前任务被挂起，调度程序选择另一个任务来运行。等待任务完成的任务会重新启动。</target>
        </trans-unit>
        <trans-unit id="8fbc199e2173262fbbf9a789a4bc09af6495b0ec" translate="yes" xml:space="preserve">
          <source>Julia's promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;Conversion and Promotion&lt;/a&gt; for details of the promotion system.</source>
          <target state="translated">Julia的提升系统使对参数类型混合的算术运算自然而自动地&amp;ldquo;起作用&amp;rdquo;。有关升级系统的详细信息，请参见&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion&quot;&gt;转换和升级&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b466bf8ce3736bba15b2ecdae9872de461ea3a56" translate="yes" xml:space="preserve">
          <source>Julia's promotion system makes arithmetic operations on mixtures of argument types &quot;just work&quot; naturally and automatically. See &lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;Conversion and Promotion&lt;/a&gt; for details of the promotion system.</source>
          <target state="translated">Julia的晋升系统自然而自动地对参数类型混合的算术运算&amp;ldquo;起作用&amp;rdquo;。有关升级系统的详细信息，请参见&lt;a href=&quot;../conversion-and-promotion/index#conversion-and-promotion-1&quot;&gt;转换和升级&lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="34b8049f71f2dca17e15f3a691f349cd09ad4d7f" translate="yes" xml:space="preserve">
          <source>Julia's range indexing has the format of &lt;code&gt;x[start:step:stop]&lt;/code&gt;, whereas Python's format is &lt;code&gt;x[start:(stop+1):step]&lt;/code&gt;. Hence, &lt;code&gt;x[0:10:2]&lt;/code&gt; in Python is equivalent to &lt;code&gt;x[1:2:10]&lt;/code&gt; in Julia. Similarly, &lt;code&gt;x[::-1]&lt;/code&gt; in Python, which refers to the reversed array, is equivalent to &lt;code&gt;x[end:-1:1]&lt;/code&gt; in Julia.</source>
          <target state="translated">Julia的范围索引的格式为 &lt;code&gt;x[start:step:stop]&lt;/code&gt; ，而Python的格式为 &lt;code&gt;x[start:(stop+1):step]&lt;/code&gt; 。因此，Python中的 &lt;code&gt;x[0:10:2]&lt;/code&gt; 等效于Julia中的 &lt;code&gt;x[1:2:10]&lt;/code&gt; 。同样，Python中的 &lt;code&gt;x[::-1]&lt;/code&gt; 表示反向数组，等效于Julia中的 &lt;code&gt;x[end:-1:1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4c3a6166fa4f354bffc12e579d7219f7b110624c" translate="yes" xml:space="preserve">
          <source>Julia's single quotes enclose characters, not strings.</source>
          <target state="translated">茱莉亚的单引号括的是字符,而不是字符串。</target>
        </trans-unit>
        <trans-unit id="5826232507a46053a3ad6eca3433bcfcdddedfd4" translate="yes" xml:space="preserve">
          <source>Julia's slice indexing includes the last element, unlike in Python. &lt;code&gt;a[2:3]&lt;/code&gt; in Julia is &lt;code&gt;a[1:3]&lt;/code&gt; in Python.</source>
          <target state="translated">与Python不同，Julia的切片索引包括最后一个元素。 &lt;code&gt;a[2:3]&lt;/code&gt; 在Julia是 &lt;code&gt;a[1:3]&lt;/code&gt; 在Python。</target>
        </trans-unit>
        <trans-unit id="d3f2b1b2df721c7080cd008996870d53e3376216" translate="yes" xml:space="preserve">
          <source>Julia's type system is designed to be powerful and expressive, yet clear, intuitive and unobtrusive. Many Julia programmers may never feel the need to write code that explicitly uses types. Some kinds of programming, however, become clearer, simpler, faster and more robust with declared types.</source>
          <target state="translated">Julia的类型系统被设计成功能强大、表现力强,但又清晰、直观、不显眼。许多Julia程序员可能永远不会觉得需要编写明确使用类型的代码。然而,有些类型的编程,在声明类型的情况下会变得更清晰、更简单、更快速、更健壮。</target>
        </trans-unit>
        <trans-unit id="328e404443e1e3ee36bbd28ef0bec3925e10b36e" translate="yes" xml:space="preserve">
          <source>Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in &lt;a href=&quot;../methods/index#Methods&quot;&gt;Methods&lt;/a&gt;, but is rooted in the type system presented here.</source>
          <target state="translated">朱莉娅的类型系统是动态的，但是通过表明某些值属于特定类型，可以获得静态类型系统的某些优点。这对于生成有效的代码可能有很大的帮助，但更重要的是，它允许对函数参数类型的方法分派与该语言进行深度集成。在&lt;a href=&quot;../methods/index#Methods&quot;&gt;方法&lt;/a&gt;中详细探讨了方法分配，但是它派生于此处介绍的类型系统。</target>
        </trans-unit>
        <trans-unit id="2601bca815fd3b23be75d3eb7a5f70824d2baba0" translate="yes" xml:space="preserve">
          <source>Julia's type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in &lt;a href=&quot;../methods/index#Methods-1&quot;&gt;Methods&lt;/a&gt;, but is rooted in the type system presented here.</source>
          <target state="translated">朱莉娅的类型系统是动态的，但是通过表明某些值属于特定类型，可以获得静态类型系统的某些优点。这对于生成有效的代码可能有很大的帮助，但更重要的是，它允许对函数参数类型的方法分派与该语言进行深度集成。在&lt;a href=&quot;../methods/index#Methods-1&quot;&gt;方法&lt;/a&gt;中详细探讨了方法分配，但它扎根于此处介绍的类型系统。</target>
        </trans-unit>
        <trans-unit id="452075601195cf61defe5474343bae547d7dc931" translate="yes" xml:space="preserve">
          <source>Julia's updating operators (e.g. &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, ...) are &lt;em&gt;not in-place&lt;/em&gt; whereas NumPy's are. This means &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; doesn't change values in &lt;code&gt;A&lt;/code&gt;, it rather rebinds the name &lt;code&gt;B&lt;/code&gt; to the result of the right-hand side &lt;code&gt;B = B + 3&lt;/code&gt;, which is a new array. For in-place operation, use &lt;code&gt;B .+= 3&lt;/code&gt; (see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;dot operators&lt;/a&gt;), explicit loops, or &lt;code&gt;InplaceOps.jl&lt;/code&gt;.</source>
          <target state="translated">Julia的更新运算符（例如 &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; ，...）&lt;em&gt;不在位，&lt;/em&gt;而NumPy则&lt;em&gt;在位&lt;/em&gt;。这意味着 &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; 不会更改 &lt;code&gt;A&lt;/code&gt; 中的值，而是将名称 &lt;code&gt;B&lt;/code&gt; 重新绑定到右侧 &lt;code&gt;B = B + 3&lt;/code&gt; ，这是一个新数组。对于就地操作，请使用 &lt;code&gt;B .+= 3&lt;/code&gt; （另请参阅&lt;a href=&quot;../mathematical-operations/index#man-dot-operators&quot;&gt;点运算符&lt;/a&gt;），显式循环或 &lt;code&gt;InplaceOps.jl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="060a807b9436918cd4c19176ffcd9bf4c0ffdec4" translate="yes" xml:space="preserve">
          <source>Julia's updating operators (e.g. &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, ...) are &lt;em&gt;not in-place&lt;/em&gt; whereas NumPy's are. This means &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; doesn't change values in &lt;code&gt;A&lt;/code&gt;, it rather rebinds the name &lt;code&gt;B&lt;/code&gt; to the result of the right-hand side &lt;code&gt;B = B + 3&lt;/code&gt;, which is a new array. For in-place operation, use &lt;code&gt;B .+= 3&lt;/code&gt; (see also &lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;dot operators&lt;/a&gt;), explicit loops, or &lt;code&gt;InplaceOps.jl&lt;/code&gt;.</source>
          <target state="translated">Julia的更新运算符（例如 &lt;code&gt;+=&lt;/code&gt; ， &lt;code&gt;-=&lt;/code&gt; ，...）&lt;em&gt;不在位，&lt;/em&gt;而NumPy则&lt;em&gt;在位&lt;/em&gt;。这意味着 &lt;code&gt;A = [1, 1]; B = A; B += [3, 3]&lt;/code&gt; 不会更改 &lt;code&gt;A&lt;/code&gt; 中的值，而是将名称 &lt;code&gt;B&lt;/code&gt; 重新绑定到右侧 &lt;code&gt;B = B + 3&lt;/code&gt; ，这是一个新数组。对于就地操作，请使用 &lt;code&gt;B .+= 3&lt;/code&gt; （另请参阅&lt;a href=&quot;../mathematical-operations/index#man-dot-operators-1&quot;&gt;点运算符&lt;/a&gt;），显式循环或 &lt;code&gt;InplaceOps.jl&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="bd01ffb3135bea5db94d9c0cd4c8376ed4d4ff72" translate="yes" xml:space="preserve">
          <source>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../interfaces/index#man-interface-array&quot;&gt;manual section on the AbstractArray interface&lt;/a&gt; for more details on implementing a custom array type.</source>
          <target state="translated">像大多数技术计算语言一样，Julia提供了一流的数组实现。大多数技术计算语言都以牺牲其他容器为代价，对其阵列实现给予了极大的关注。 Julia不以任何特殊方式对待数组。数组库几乎完全在Julia本身中实现，并且像在Julia中编写的任何其他代码一样，从编译器获得其性能。这样，也可以通过继承&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;来定义自定义数组类型。有关实现自定义数组类型的更多详细信息，请参见&lt;a href=&quot;../interfaces/index#man-interface-array&quot;&gt;AbstractArray接口上&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="29157447971e1b4b6b81d91fd76c285c2b275482" translate="yes" xml:space="preserve">
          <source>Julia, like most technical computing languages, provides a first-class array implementation. Most technical computing languages pay a lot of attention to their array implementation at the expense of other containers. Julia does not treat arrays in any special way. The array library is implemented almost completely in Julia itself, and derives its performance from the compiler, just like any other code written in Julia. As such, it's also possible to define custom array types by inheriting from &lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt;&lt;code&gt;AbstractArray&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;manual section on the AbstractArray interface&lt;/a&gt; for more details on implementing a custom array type.</source>
          <target state="translated">像大多数技术计算语言一样，Julia提供了一流的数组实现。大多数技术计算语言都以牺牲其他容器为代价来关注其数组实现。 Julia不以任何特殊方式对待数组。数组库几乎完全在Julia本身中实现，并且像在Julia中编写的任何其他代码一样，从编译器获得其性能。这样，也可以通过继承&lt;a href=&quot;../../base/arrays/index#Core.AbstractArray&quot;&gt; &lt;code&gt;AbstractArray&lt;/code&gt; &lt;/a&gt;来定义自定义数组类型。有关实现自定义数组类型的更多详细信息，请参见&lt;a href=&quot;../interfaces/index#man-interface-array-1&quot;&gt;AbstractArray接口上&lt;/a&gt;的手册部分。</target>
        </trans-unit>
        <trans-unit id="88d1577dcc4f245ab6ce133765fe78bb8913aa7f" translate="yes" xml:space="preserve">
          <source>Jupiter</source>
          <target state="translated">Jupiter</target>
        </trans-unit>
        <trans-unit id="baa896b33786524acff2009a8d27bd6b3009cef2" translate="yes" xml:space="preserve">
          <source>Just as &lt;code&gt;^R&lt;/code&gt; is a reverse search, &lt;code&gt;^S&lt;/code&gt; is a forward search, with the prompt &lt;code&gt;(i-search)`':&lt;/code&gt;. The two may be used in conjunction with each other to move through the previous or next matching results, respectively.</source>
          <target state="translated">正如 &lt;code&gt;^R&lt;/code&gt; 是反向搜索， &lt;code&gt;^S&lt;/code&gt; 是一个前向搜索，与提示 &lt;code&gt;(i-search)`':&lt;/code&gt; 。两者可以相互结合使用，以分别遍历前一个或下一个匹配结果。</target>
        </trans-unit>
        <trans-unit id="9365c41bee7315e2eb3ab59d3b982ca7ca4bb4b9" translate="yes" xml:space="preserve">
          <source>Just as help mode is useful for quick access to documentation, another common task is to use the system shell to execute system commands. Just as &lt;code&gt;?&lt;/code&gt; entered help mode when at the beginning of the line, a semicolon (&lt;code&gt;;&lt;/code&gt;) will enter the shell mode. And it can be exited by pressing backspace at the beginning of the line.</source>
          <target state="translated">正如帮助模式对于快速访问文档很有用，另一个常见任务是使用系统外壳执行系统命令。一样 &lt;code&gt;?&lt;/code&gt; 在该行的开头进入帮助模式时，分号（ &lt;code&gt;;&lt;/code&gt; ）将进入shell模式。可以通过在行首按退格键退出。</target>
        </trans-unit>
        <trans-unit id="456f4e9fab32e1339e01f38c693667415e6a7374" translate="yes" xml:space="preserve">
          <source>Just as in &lt;a href=&quot;#man-array-indexing&quot;&gt;Indexing&lt;/a&gt;, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">就像在&lt;a href=&quot;#man-array-indexing&quot;&gt;Indexing中一样&lt;/a&gt;， &lt;code&gt;end&lt;/code&gt; 关键字可以用来表示索引括号内每个维的最后一个索引，该索引由分配给其中的数组的大小确定。没有 &lt;code&gt;end&lt;/code&gt; 关键字的索引赋值语法等效于对&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;的调用！：</target>
        </trans-unit>
        <trans-unit id="e330a59e23d168a0ce147528d526c6c70e235165" translate="yes" xml:space="preserve">
          <source>Just as in &lt;a href=&quot;#man-array-indexing-1&quot;&gt;Indexing&lt;/a&gt;, the &lt;code&gt;end&lt;/code&gt; keyword may be used to represent the last index of each dimension within the indexing brackets, as determined by the size of the array being assigned into. Indexed assignment syntax without the &lt;code&gt;end&lt;/code&gt; keyword is equivalent to a call to &lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">就像在&lt;a href=&quot;#man-array-indexing-1&quot;&gt;Indexing中一样&lt;/a&gt;， &lt;code&gt;end&lt;/code&gt; 关键字可以用来表示索引括号内每个维度的最后一个索引，这由分配给数组的大小确定。没有 &lt;code&gt;end&lt;/code&gt; 关键字的索引赋值语法等效于对&lt;a href=&quot;../../base/collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;的调用！：</target>
        </trans-unit>
        <trans-unit id="129fdfb9651f86a9c5a6d204baf7fd51a6f897e9" translate="yes" xml:space="preserve">
          <source>Just as text output is performed by &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; and user-defined types can indicate their textual representation by overloading &lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</source>
          <target state="translated">正如文本输出是通过&lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;执行的，用户定义的类型可以通过&lt;a href=&quot;#Base.show-Tuple%7BAny%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;的重载来指示其文本表示一样，Julia提供了一种标准化的机制来实现丰富的多媒体输出（例如图像，带格式的文本，甚至是音频和视频），该机制由三部分组成：</target>
        </trans-unit>
        <trans-unit id="03d45fce37a205fcf4faeb89d82409711b9d7cca" translate="yes" xml:space="preserve">
          <source>Just as text output is performed by &lt;a href=&quot;#Base.print&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt; and user-defined types can indicate their textual representation by overloading &lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt;&lt;code&gt;show&lt;/code&gt;&lt;/a&gt;, Julia provides a standardized mechanism for rich multimedia output (such as images, formatted text, or even audio and video), consisting of three parts:</source>
          <target state="translated">正如文本输出是通过&lt;a href=&quot;#Base.print&quot;&gt; &lt;code&gt;print&lt;/code&gt; &lt;/a&gt;执行的，并且用户定义的类型可以通过&lt;a href=&quot;#Base.show-Tuple%7BIO,Any%7D&quot;&gt; &lt;code&gt;show&lt;/code&gt; &lt;/a&gt;的重载来指示其文本表示一样，Julia提供了一种标准化的机制来实现丰富的多媒体输出（例如图像，带格式的文本，甚至是音频和视频），该机制由三部分组成：</target>
        </trans-unit>
        <trans-unit id="45c6961e570c4d224922a2a92f75eca4d8e9afac" translate="yes" xml:space="preserve">
          <source>Just as you can put subtype constraints on type parameters in type declarations (see &lt;a href=&quot;../types/index#Parametric-Types&quot;&gt;Parametric Types&lt;/a&gt;), you can also constrain type parameters of methods:</source>
          <target state="translated">就像您可以在类型声明中将子类型约束放在类型参数上一样（请参见&lt;a href=&quot;../types/index#Parametric-Types&quot;&gt;Parametric Types&lt;/a&gt;），您也可以约束方法的类型参数：</target>
        </trans-unit>
        <trans-unit id="f31418705dc05a56f9681110f63d545eb15e8a22" translate="yes" xml:space="preserve">
          <source>Just as you can put subtype constraints on type parameters in type declarations (see &lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt;), you can also constrain type parameters of methods:</source>
          <target state="translated">正如您可以在类型声明中将子类型约束放置在类型参数上一样（请参阅&lt;a href=&quot;../types/index#Parametric-Types-1&quot;&gt;Parametric Types&lt;/a&gt;），您也可以约束方法的类型参数：</target>
        </trans-unit>
        <trans-unit id="3a5b8319210d6e829092640e9c9931c8b6b93159" translate="yes" xml:space="preserve">
          <source>Just like condition expressions used in &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;elseif&lt;/code&gt; or the ternary operator, the operands of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; must be boolean values (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;). Using a non-boolean value anywhere except for the last entry in a conditional chain is an error:</source>
          <target state="translated">就像 &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;elseif&lt;/code&gt; 或三元运算符中使用的条件表达式一样， &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 或 &lt;code&gt;||&lt;/code&gt; 的操作数 必须为布尔值（ &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; ）。在条件链中最后一个条目以外的任何地方使用非布尔值是一个错误：</target>
        </trans-unit>
        <trans-unit id="89b905a2ec6630efe24e67a128976a957febd0eb" translate="yes" xml:space="preserve">
          <source>Juxtaposed literal coefficient syntax may conflict with two numeric literal syntaxes: hexadecimal integer literals and engineering notation for floating-point literals. Here are some situations where syntactic conflicts arise:</source>
          <target state="translated">并列的文字系数语法可能会与两种数字文字语法发生冲突:十六进制整数文字和浮点文字的工程符号。下面是一些出现语法冲突的情况。</target>
        </trans-unit>
        <trans-unit id="9ec40672083b66df6ef7fbca9db99f5cc01dc9d5" translate="yes" xml:space="preserve">
          <source>Keep in mind that some Julia features are not currently supported by CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt; , especially some functions like &lt;code&gt;sin&lt;/code&gt; will need to be replaced with &lt;code&gt;CUDAnative.sin&lt;/code&gt;(cc: @maleadt).</source>
          <target state="translated">请记住，CUDAnative.jl &lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;当前不支持某些Julia功能，尤其是诸如 &lt;code&gt;sin&lt;/code&gt; 之类的某些功能需要替换为 &lt;code&gt;CUDAnative.sin&lt;/code&gt; （cc：@maleadt）。</target>
        </trans-unit>
        <trans-unit id="ed1dc2aa59f2bcc19af822ca3015689f0776b65a" translate="yes" xml:space="preserve">
          <source>Keep in mind that some Julia features are not currently supported by CUDAnative.jl&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; , especially some functions like &lt;code&gt;sin&lt;/code&gt; will need to be replaced with &lt;code&gt;CUDAnative.sin&lt;/code&gt;(cc: @maleadt).</source>
          <target state="translated">请记住，CUDAnative.jl &lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;当前不支持某些Julia功能，尤其是诸如 &lt;code&gt;sin&lt;/code&gt; 之类的某些功能需要替换为 &lt;code&gt;CUDAnative.sin&lt;/code&gt; （cc：@maleadt）。</target>
        </trans-unit>
        <trans-unit id="c67dd20ee842986086a0a915ddc2a279490130ed" translate="yes" xml:space="preserve">
          <source>Key</source>
          <target state="translated">Key</target>
        </trans-unit>
        <trans-unit id="2f019ec46ab9548a295fae40fb32bbf280932bb8" translate="yes" xml:space="preserve">
          <source>Key bindings</source>
          <target state="translated">钥匙扣</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="23f6f8047d85e8db9b2a5eaadf76de7dfe565d74" translate="yes" xml:space="preserve">
          <source>Keybinding</source>
          <target state="translated">Keybinding</target>
        </trans-unit>
        <trans-unit id="59ba1e5a90c9cfee0b263032ac6574298fc3c42e" translate="yes" xml:space="preserve">
          <source>Keycap Ten</source>
          <target state="translated">钥匙帽十</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="db32172db3cd21ae36313d815fba0dd39bd7127a" translate="yes" xml:space="preserve">
          <source>Keyword Arguments</source>
          <target state="translated">關鍵字參數</target>
        </trans-unit>
        <trans-unit id="37a1398f40ad5a5758f3118ecb2e0028c1f656ac" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;debuginfo&lt;/code&gt; may be one of &lt;code&gt;:source&lt;/code&gt; or &lt;code&gt;:none&lt;/code&gt; (default), to specify the verbosity of code comments.</source>
          <target state="translated">关键字参数 &lt;code&gt;debuginfo&lt;/code&gt; 可以是 &lt;code&gt;:source&lt;/code&gt; 或 &lt;code&gt;:none&lt;/code&gt; （默认值）之一，以指定代码注释的详细程度。</target>
        </trans-unit>
        <trans-unit id="64ff3dfa226c767a3f6429283e3a4ecc260532b6" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;init&lt;/code&gt; is added in Julia 1.5.</source>
          <target state="translated">关键字参数 &lt;code&gt;init&lt;/code&gt; 是在Julia 1.5中添加的。</target>
        </trans-unit>
        <trans-unit id="4eec148d4683d6a5be8244fa8544e4bc73995042" translate="yes" xml:space="preserve">
          <source>Keyword argument &lt;code&gt;lazy=true|false&lt;/code&gt; only affects &lt;code&gt;topology&lt;/code&gt; option &lt;code&gt;:all_to_all&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, the cluster starts off with the master connected to all workers. Specific worker-worker connections are established at the first remote invocation between two workers. This helps in reducing initial resources allocated for intra-cluster communication. Connections are setup depending on the runtime requirements of a parallel program. Default value for &lt;code&gt;lazy&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">关键字参数 &lt;code&gt;lazy=true|false&lt;/code&gt; 仅影响 &lt;code&gt;topology&lt;/code&gt; 选项 &lt;code&gt;:all_to_all&lt;/code&gt; 。如果为 &lt;code&gt;true&lt;/code&gt; ，则集群在主服务器连接到所有工作服务器的情况下启动。在两个工作人员之间的第一次远程调用时，将建立特定的工作人员－工作人员连接。这有助于减少分配给集群内通信的初始资源。根据并行程序的运行时要求来建立连接。为默认值 &lt;code&gt;lazy&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a85841ebcc4fbb3f6bb0af53f5f74a1d1107441b" translate="yes" xml:space="preserve">
          <source>Keyword argument default values are evaluated only when necessary (when a corresponding keyword argument is not passed), and in left-to-right order. Therefore default expressions may refer to prior keyword arguments.</source>
          <target state="translated">关键字参数的缺省值仅在必要时(当没有传递相应的关键字参数时)才会被评估,并且按照从左到右的顺序。因此默认表达式可能会参考之前的关键字参数。</target>
        </trans-unit>
        <trans-unit id="cd222673b8a5eeb28c17fea40269820af080e4d5" translate="yes" xml:space="preserve">
          <source>Keyword arguments behave quite differently from ordinary positional arguments. In particular, they do not participate in method dispatch. Methods are dispatched based only on positional arguments, with keyword arguments processed after the matching method is identified.</source>
          <target state="translated">关键字参数的行为与普通的位置参数完全不同。特别是,它们不参与方法的调度。方法的调度只基于位置参数,关键字参数在匹配的方法被识别后进行处理。</target>
        </trans-unit>
        <trans-unit id="a802505edaa907c65ced69e373b2128c6752ff80" translate="yes" xml:space="preserve">
          <source>Keyword arguments can also be used in varargs functions:</source>
          <target state="translated">关键字参数也可以在varargs函数中使用。</target>
        </trans-unit>
        <trans-unit id="e1f80b2c92c551f95f3994cdc90a44e035d56013" translate="yes" xml:space="preserve">
          <source>Keyword arguments, if any, are passed through to &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">关键字参数（如果有）将传递给 &lt;code&gt;f&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8804a97595c6605af997f797488e9f7a887cea7" translate="yes" xml:space="preserve">
          <source>Keyword arguments:</source>
          <target state="translated">嵉论。</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="e42f478ffbc394a252424af959d3abd0a98e41e6" translate="yes" xml:space="preserve">
          <source>Keywords are also displayed in the suggested methods after &lt;code&gt;;&lt;/code&gt;, see below line where &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;keepempty&lt;/code&gt; are keyword arguments:</source>
          <target state="translated">关键字也显示在建议的方法之后 &lt;code&gt;;&lt;/code&gt; ，请参见以下行，其中 &lt;code&gt;limit&lt;/code&gt; 和 &lt;code&gt;keepempty&lt;/code&gt; 是关键字参数：</target>
        </trans-unit>
        <trans-unit id="924acc699e5835f0f13e0c55c14fdfbfa6ba40d8" translate="yes" xml:space="preserve">
          <source>Kimono</source>
          <target state="translated">Kimono</target>
        </trans-unit>
        <trans-unit id="4dbc43957024c86f07374b147dcca5a43c62318b" translate="yes" xml:space="preserve">
          <source>Kiss</source>
          <target state="translated">Kiss</target>
        </trans-unit>
        <trans-unit id="23d1162dbd548a5b7ebb3cb6c2092223a1165283" translate="yes" xml:space="preserve">
          <source>Kiss Mark</source>
          <target state="translated">吻痕</target>
        </trans-unit>
        <trans-unit id="bc19b3dfb9379c314c1b8e3bb9dc5e6a2b26f09b" translate="yes" xml:space="preserve">
          <source>Kissing Cat Face With Closed Eyes</source>
          <target state="translated">闭目养神的猫咪</target>
        </trans-unit>
        <trans-unit id="b58aa4e85bf24740360e2d6b347305a564dca4a1" translate="yes" xml:space="preserve">
          <source>Kissing Face</source>
          <target state="translated">吻脸</target>
        </trans-unit>
        <trans-unit id="2fe6ec1bfe77e7354379b52c0bee899a96c21add" translate="yes" xml:space="preserve">
          <source>Kissing Face With Closed Eyes</source>
          <target state="translated">闭眼吻脸</target>
        </trans-unit>
        <trans-unit id="fcaff6a193904e107dc7d4aa4f3190493c405457" translate="yes" xml:space="preserve">
          <source>Kissing Face With Smiling Eyes</source>
          <target state="translated">吻脸与微笑的眼睛</target>
        </trans-unit>
        <trans-unit id="74ae77190d30e9483b1024a2bf19d64715a77757" translate="yes" xml:space="preserve">
          <source>Koala</source>
          <target state="translated">Koala</target>
        </trans-unit>
        <trans-unit id="9afe7e71a0cd3f5b45d3038779f47e6ab11c4a9d" translate="yes" xml:space="preserve">
          <source>Konstantinos Konstantinides and Kung Yao, &quot;Statistical analysis of effective singular values in matrix rank determination&quot;, IEEE Transactions on Acoustics, Speech and Signal Processing, 36(5), 1988, 757-763. &lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;doi:10.1109/29.1585&lt;/a&gt;</source>
          <target state="translated">Konstantinos Konstantinides和Kung Yao，&amp;ldquo;矩阵秩确定中有效奇异值的统计分析&amp;rdquo;，IEEE声学，语音和信号处理学报，36（5），1988，757-763。&lt;a href=&quot;https://doi.org/10.1109/29.1585&quot;&gt;doi：10.1109 / 29.1585&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4a94c6e095d242bfd65b4080bf588284c946f8c" translate="yes" xml:space="preserve">
          <source>Kronecker tensor product of two vectors or two matrices.</source>
          <target state="translated">两个向量或两个矩阵的Kronecker张量积。</target>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="d4e9710203cf5806e211a4382bda892c104cc46d" translate="yes" xml:space="preserve">
          <source>LAPACK Functions</source>
          <target state="translated">LAPACK功能</target>
        </trans-unit>
        <trans-unit id="d12a2cf0b16bda2d0e8799f01c41ee6d60d4d6a5" translate="yes" xml:space="preserve">
          <source>LAPACK functions</source>
          <target state="translated">LAPACK功能</target>
        </trans-unit>
        <trans-unit id="a7f1b6f39a46d5337c0aad867bbe073b5b049053" translate="yes" xml:space="preserve">
          <source>LDL(T) factorization</source>
          <target state="translated">LDL(T)因子化</target>
        </trans-unit>
        <trans-unit id="b4aff6bdb4998cc3553c7001845a94833e9f4e43" translate="yes" xml:space="preserve">
          <source>LDLt (see &lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt;&lt;code&gt;ldlt&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LDLt（请参阅&lt;a href=&quot;#LinearAlgebra.ldlt&quot;&gt; &lt;code&gt;ldlt&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="26214decf703290192f10270d6b0b515c7511762" translate="yes" xml:space="preserve">
          <source>LLVM Interface</source>
          <target state="translated">LLVM接口</target>
        </trans-unit>
        <trans-unit id="f5f4f14ed2c38473c6c2d9123249c93ff3ece227" translate="yes" xml:space="preserve">
          <source>LOAD_PATH</source>
          <target state="translated">LOAD_PATH</target>
        </trans-unit>
        <trans-unit id="160e7ef90659bedaf209eec44edbbe3caf988121" translate="yes" xml:space="preserve">
          <source>LU (see &lt;a href=&quot;#LinearAlgebra.lu&quot;&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">LU（请参阅&lt;a href=&quot;#LinearAlgebra.lu&quot;&gt; &lt;code&gt;lu&lt;/code&gt; &lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="23dbe335a346e4f78af48a087f0c1292440d8cc7" translate="yes" xml:space="preserve">
          <source>LU factorization</source>
          <target state="translated">LU因子化</target>
        </trans-unit>
        <trans-unit id="a905567226043f1b393e816a77aec998343c78b4" translate="yes" xml:space="preserve">
          <source>LU factorization for &lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt;&lt;code&gt;Tridiagonal&lt;/code&gt;&lt;/a&gt; matrices</source>
          <target state="translated">&lt;a href=&quot;#LinearAlgebra.Tridiagonal&quot;&gt; &lt;code&gt;Tridiagonal&lt;/code&gt; &lt;/a&gt;矩阵的LU分解</target>
        </trans-unit>
        <trans-unit id="366152a7d098555665a4453404d639ac8b476b7a" translate="yes" xml:space="preserve">
          <source>Labels a statement with the symbolic label &lt;code&gt;name&lt;/code&gt;. The label marks the end-point of an unconditional jump with &lt;a href=&quot;#Base.@goto&quot;&gt;&lt;code&gt;@goto name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">用符号标签 &lt;code&gt;name&lt;/code&gt; 标记语句。标签使用&lt;a href=&quot;#Base.@goto&quot;&gt; &lt;code&gt;@goto name&lt;/code&gt; &lt;/a&gt;标记无条件跳转的终点。</target>
        </trans-unit>
        <trans-unit id="ff8f52e27fbdf435514705d351e8d01e3dd57b73" translate="yes" xml:space="preserve">
          <source>Lady Beetle</source>
          <target state="translated">甲虫夫人</target>
        </trans-unit>
        <trans-unit id="4dee08e75e78fb7f2ea26537626acf062390bc00" translate="yes" xml:space="preserve">
          <source>Large $\LaTeX$ equations that do not fit inline within a paragraph may be written as display equations using a fenced code block with the &quot;language&quot; &lt;code&gt;math&lt;/code&gt; as in the example below.</source>
          <target state="translated">不能在段落中内联的较大的$ \ LaTeX $方程式可以使用带有&amp;ldquo;语言&amp;rdquo; &lt;code&gt;math&lt;/code&gt; 的围栏代码块作为显示方程式编写，如下例所示。</target>
        </trans-unit>
        <trans-unit id="8f95211a940e3d08b42c29bbf9dbc496ccfe208b" translate="yes" xml:space="preserve">
          <source>Large Blue Circle</source>
          <target state="translated">大蓝圈</target>
        </trans-unit>
        <trans-unit id="68e7dfd86e1bad5177b243cce59909605d2d63ff" translate="yes" xml:space="preserve">
          <source>Large Blue Diamond</source>
          <target state="translated">大号蓝钻</target>
        </trans-unit>
        <trans-unit id="1489faea46cdb0a914888faa83aaccbf1a1018b6" translate="yes" xml:space="preserve">
          <source>Large Circle</source>
          <target state="translated">大圆</target>
        </trans-unit>
        <trans-unit id="47d39efcf737a8cb7cff31b45c3eae3b9768a070" translate="yes" xml:space="preserve">
          <source>Large Down Tack</source>
          <target state="translated">大羽绒服</target>
        </trans-unit>
        <trans-unit id="19d1a6d4bde006ab21ff3b1a9ce0c5b1f656efbe" translate="yes" xml:space="preserve">
          <source>Large Orange Diamond</source>
          <target state="translated">橙色大钻石</target>
        </trans-unit>
        <trans-unit id="2be06620aa858eeb1cfd65e452ba545d7194c263" translate="yes" xml:space="preserve">
          <source>Large Red Circle</source>
          <target state="translated">大红圈</target>
        </trans-unit>
        <trans-unit id="93780c9bf758bfc5b064c94682265b362eac13d6" translate="yes" xml:space="preserve">
          <source>Large Up Tack</source>
          <target state="translated">大号鞋带</target>
        </trans-unit>
        <trans-unit id="c567cf1fe685a9b85ba876a5fdec9645963ce55b" translate="yes" xml:space="preserve">
          <source>Large modules can take several seconds to load because executing all of the statements in a module often involves compiling a large amount of code. Julia creates precompiled caches of the module to reduce this time.</source>
          <target state="translated">大型模块可能需要几秒钟的时间来加载,因为执行一个模块中的所有语句往往需要编译大量的代码。Julia创建了模块的预编译缓存来减少这个时间。</target>
        </trans-unit>
        <trans-unit id="836cd86751bc175f6a1c3513d9545f0269900a32" translate="yes" xml:space="preserve">
          <source>Larger Than</source>
          <target state="translated">大于</target>
        </trans-unit>
        <trans-unit id="8fc4e576fc574f75bb7c600973def67858d8bb40" translate="yes" xml:space="preserve">
          <source>Larger Than Or Equal To</source>
          <target state="translated">大于或等于</target>
        </trans-unit>
        <trans-unit id="d737eee8172d65bba64271f9c8b335b8b815d284" translate="yes" xml:space="preserve">
          <source>Larger integer literals that cannot be represented using only 32 bits but can be represented in 64 bits always create 64-bit integers, regardless of the system type:</source>
          <target state="translated">不能只用32位来表示,但可以用64位来表示的较大的整数字元总是创建64位整数,不管系统类型如何。</target>
        </trans-unit>
        <trans-unit id="2c5201c8ea16b6383c4f6c269ee86f7c5d37bb84" translate="yes" xml:space="preserve">
          <source>Largest integer less than or equal to &lt;code&gt;x/y&lt;/code&gt;.</source>
          <target state="translated">小于或等于 &lt;code&gt;x/y&lt;/code&gt; 的最大整数。</target>
        </trans-unit>
        <trans-unit id="b1b42ea4b0b1e511fffb01ce016fa0bdcff72dd5" translate="yes" xml:space="preserve">
          <source>Largest integer less than or equal to &lt;code&gt;x/y&lt;/code&gt;. Equivalent to &lt;code&gt;div(x, y, RoundDown)&lt;/code&gt;.</source>
          <target state="translated">小于或等于 &lt;code&gt;x/y&lt;/code&gt; 的最大整数。等效于 &lt;code&gt;div(x, y, RoundDown)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="45e54723a9bf0cd3ba0bd2155ce7b7bac5bfafd9" translate="yes" xml:space="preserve">
          <source>Largest value</source>
          <target state="translated">最大值</target>
        </trans-unit>
        <trans-unit id="af72fbc94064a4c9a0a644731e497dc5dc7beff9" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon</source>
          <target state="translated">最后一刻月</target>
        </trans-unit>
        <trans-unit id="4d7f319a09451056e084d65cad158f125e2020cc" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon Symbol</source>
          <target state="translated">最后一个季度的月亮符号</target>
        </trans-unit>
        <trans-unit id="a7b4069351f71ce4f08da44121a5414042cbca4b" translate="yes" xml:space="preserve">
          <source>Last Quarter Moon With Face</source>
          <target state="translated">最后一刻月与脸</target>
        </trans-unit>
        <trans-unit id="18cf37d7758974150aba5efc169a132701c98591" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter A With Ring Above / Latin Capital Letter A Ring</source>
          <target state="translated">拉丁字母A环以上/拉丁字母A环以上</target>
        </trans-unit>
        <trans-unit id="387186c7a8fff866e6fbacb8a7a99c078e963118" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Ae / Latin Capital Letter A E</source>
          <target state="translated">拉丁文大写字母Ae/拉丁文大写字母A E.</target>
        </trans-unit>
        <trans-unit id="f2c0864bdd70eeadaffc0e4bf8122d6178ff53bb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter D With Stroke / Latin Capital Letter D Bar</source>
          <target state="translated">拉丁文大写字母D带笔画/拉丁文大写字母D条带笔画</target>
        </trans-unit>
        <trans-unit id="18ee11f5dfc96b5ea1e522af1744aced409d9ff1" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eng</source>
          <target state="translated">拉丁文大写字母英文</target>
        </trans-unit>
        <trans-unit id="7e38029cb2d0c6ce87bf45f5170886022a280556" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Eth</source>
          <target state="translated">拉丁字母Eth</target>
        </trans-unit>
        <trans-unit id="261b92b2c69498043ebd035666aae447dd5fc40c" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter L With Stroke / Latin Capital Letter L Slash</source>
          <target state="translated">拉丁文大写字母L带笔画/拉丁文大写字母L斜线部分</target>
        </trans-unit>
        <trans-unit id="81f5aedd8e8fccac1ab8a6bc67c43be5b7c7e7f6" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter O With Stroke / Latin Capital Letter O Slash</source>
          <target state="translated">拉丁文大写字母O带笔画/拉丁文大写字母O斜线部分</target>
        </trans-unit>
        <trans-unit id="3e1d1bce5c9a11240957721f8ef29a635e048ab3" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Thorn</source>
          <target state="translated">拉丁文大写字母荆棘</target>
        </trans-unit>
        <trans-unit id="4b4cf2ef98d43801be6875ab83c9e3c993eddbbb" translate="yes" xml:space="preserve">
          <source>Latin Capital Letter Z With Stroke / Latin Capital Letter Z Bar</source>
          <target state="translated">拉丁文大写字母Z加笔画/拉丁文大写字母Z吧</target>
        </trans-unit>
        <trans-unit id="5ae3e818634045d7a9130d2b676f3527521e0150" translate="yes" xml:space="preserve">
          <source>Latin Capital Ligature Oe / Latin Capital Letter O E</source>
          <target state="translated">拉丁文大写字母Oe/拉丁文大写字母O E .</target>
        </trans-unit>
        <trans-unit id="957520bb4ae3c78ec831bd317cdfd85081025ee6" translate="yes" xml:space="preserve">
          <source>Latin Letter Alveolar Click / Latin Letter Pipe Double Bar</source>
          <target state="translated">拉丁字母牙槽点击/拉丁字母管子双条形</target>
        </trans-unit>
        <trans-unit id="43073b60cf8171df59d1497357356aa7115c7db3" translate="yes" xml:space="preserve">
          <source>Latin Letter Glottal Stop</source>
          <target state="translated">拉丁字母喉结</target>
        </trans-unit>
        <trans-unit id="fc36244b6362ae3e3d6d20e2d335c02a7af88997" translate="yes" xml:space="preserve">
          <source>Latin Letter Inverted Glottal Stop</source>
          <target state="translated">拉丁字母倒置喉头停顿</target>
        </trans-unit>
        <trans-unit id="680f41038e731ff5fdc7bf24ce99313a70d99990" translate="yes" xml:space="preserve">
          <source>Latin Letter Pharyngeal Voiced Fricative / Latin Letter Reversed Glottal Stop</source>
          <target state="translated">拉丁字母咽喉发声擦音/拉丁字母反转喉停音</target>
        </trans-unit>
        <trans-unit id="7e9e2bfa072cd28ac12f89b807c22a2d9b6b5f07" translate="yes" xml:space="preserve">
          <source>Latin Small Letter A With Ring Above / Latin Small Letter A Ring</source>
          <target state="translated">拉丁文小字母A上面有环/拉丁文小字母A环</target>
        </trans-unit>
        <trans-unit id="aeaa4f1f1687667c2f5fc22a10bca6a0268c7e52" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ae / Latin Small Letter A E</source>
          <target state="translated">拉丁文小字Ae/拉丁文小字A E .</target>
        </trans-unit>
        <trans-unit id="bd81bee974151364620b17177c4955612e0e03fa" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Closed Omega</source>
          <target state="translated">拉丁文小字封闭式欧米茄</target>
        </trans-unit>
        <trans-unit id="c4abfd40c74b3eb74040658788c6847cb7128777" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Stroke / Latin Small Letter D Bar</source>
          <target state="translated">拉丁文小字D(带笔画)/拉丁文小字D条(带笔画)</target>
        </trans-unit>
        <trans-unit id="79664c84e38ddc705c095d22df17f6ba110cb657" translate="yes" xml:space="preserve">
          <source>Latin Small Letter D With Tail / Latin Small Letter D Retroflex Hook</source>
          <target state="translated">拉丁语小字母D带尾巴/拉丁语小字母D反折钩。</target>
        </trans-unit>
        <trans-unit id="0bae965510de34e4507ca1c9f6442e6f063065a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dezh Digraph / Latin Small Letter D Yogh</source>
          <target state="translated">拉丁文小字Dezh Digraph/拉丁文小字D Yogh (Yogh)</target>
        </trans-unit>
        <trans-unit id="93c7ebd3f43b49c98f8c0737391432699e082aa6" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless I</source>
          <target state="translated">拉丁文小字无点I</target>
        </trans-unit>
        <trans-unit id="0639f709a04d29a7d92f491504f4b15becbc375e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Dotless J</source>
          <target state="translated">拉丁文小字无点J</target>
        </trans-unit>
        <trans-unit id="cf365327a81aadb5e405df4d0f48b32472c24b2e" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eng</source>
          <target state="translated">拉丁文小字英文</target>
        </trans-unit>
        <trans-unit id="93c2ec38cecdf8e443b85db5de563a216ffd9d34" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Esh</source>
          <target state="translated">拉丁文小字Esh</target>
        </trans-unit>
        <trans-unit id="2e8a26241b482f37e00adb250b979246ca85beea" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Eth</source>
          <target state="translated">拉丁文小字Eth</target>
        </trans-unit>
        <trans-unit id="40104027bfc2f3a58be7509f94be97c17e39f2f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Ezh / Latin Small Letter Yogh</source>
          <target state="translated">拉丁文小字Ezh/拉丁文小字Yogh(Yogh)</target>
        </trans-unit>
        <trans-unit id="f9e515806fd1b60b14e5fc8f3af7f90ac6e9364a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Gamma</source>
          <target state="translated">拉丁语小字Gamma</target>
        </trans-unit>
        <trans-unit id="97085caf81a24ef927fdc386fc6b04e27e1f72b9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter H With Stroke / Latin Small Letter H Bar</source>
          <target state="translated">拉丁文小字H(带笔画)/拉丁文小字H条(带笔画)</target>
        </trans-unit>
        <trans-unit id="399d282443390fef914db664bba2883747b928af" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Hv / Latin Small Letter H V</source>
          <target state="translated">拉丁文小字Hv/拉丁文小字H V</target>
        </trans-unit>
        <trans-unit id="2422e4f11c03b366715aa80ec860fc60eae0c461" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Belt / Latin Small Letter L Belt</source>
          <target state="translated">拉丁文小字L型腰带/拉丁文小字L型腰带。</target>
        </trans-unit>
        <trans-unit id="82d31c79255d3b522eb37fa11b7bb67ebf6d75a1" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Retroflex Hook / Latin Small Letter L Retroflex Hook</source>
          <target state="translated">拉丁语小字L带折返钩/拉丁语小字L折返钩。</target>
        </trans-unit>
        <trans-unit id="432e37bd3e31540f66f1af3dfdcfd97516ca52f9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter L With Stroke / Latin Small Letter L Slash</source>
          <target state="translated">拉丁文小字L(带笔画)/拉丁文小字L(斜线)</target>
        </trans-unit>
        <trans-unit id="c6dc1b09cb591ac95922c661ff9481278d4d2de7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter M With Hook / Latin Small Letter M Hook</source>
          <target state="translated">拉丁文小字母M带钩/拉丁文小字母M带钩</target>
        </trans-unit>
        <trans-unit id="0218525707cb4bb564235a036cc2842ec67b0748" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Left Hook / Latin Small Letter N Hook</source>
          <target state="translated">拉丁文小字N(左鉤)/拉丁文小字N鉤</target>
        </trans-unit>
        <trans-unit id="b20690f24cf5bf99ca0c7018eee110ebe0e15a04" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Long Right Leg</source>
          <target state="translated">拉丁文小字N,右腿长</target>
        </trans-unit>
        <trans-unit id="31ec66aaa00a79d775f1c857d59f5c7a74247d09" translate="yes" xml:space="preserve">
          <source>Latin Small Letter N With Retroflex Hook / Latin Small Letter N Retroflex Hook</source>
          <target state="translated">拉丁语小字母N带折返钩/拉丁语小字母N折返钩。</target>
        </trans-unit>
        <trans-unit id="7874ede875d3c7ae94e73df07ed062477861ae44" translate="yes" xml:space="preserve">
          <source>Latin Small Letter O With Stroke / Latin Small Letter O Slash</source>
          <target state="translated">拉丁文小字母O加笔画/拉丁文小字母O斜线</target>
        </trans-unit>
        <trans-unit id="07add9523a52497c0c262c0382ad46de39eb16bd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Open O</source>
          <target state="translated">拉丁语小字开口O</target>
        </trans-unit>
        <trans-unit id="1b7b0f5e96e58726dfbb7a30f8602204b9a71f82" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Phi</source>
          <target state="translated">拉丁语小字Phi</target>
        </trans-unit>
        <trans-unit id="ff12afa374c372c8fc23589cff50c4ee6f2f6cde" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Fishhook / Latin Small Letter Fishhook R</source>
          <target state="translated">拉丁文小字R与鱼钩/拉丁文小字鱼钩R在一起。</target>
        </trans-unit>
        <trans-unit id="591234998559d2fb9e34782769a6a85e552ca14a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Long Leg</source>
          <target state="translated">拉丁语小字母R配长腿</target>
        </trans-unit>
        <trans-unit id="c1a50f7f5584c407c2b721281ea3abe4e34d13d4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter R With Tail / Latin Small Letter R Hook</source>
          <target state="translated">拉丁文小字母R带尾巴/拉丁文小字母R钩。</target>
        </trans-unit>
        <trans-unit id="ef19cd34955161980d339367d254aafdd02b4cb7" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Rams Horn / Latin Small Letter Baby Gamma</source>
          <target state="translated">拉丁文小字公羊角/拉丁文小字宝贝Gamma号。</target>
        </trans-unit>
        <trans-unit id="bf1d74257f1f62e2e52e3dc8b76fe85f6a2c3e96" translate="yes" xml:space="preserve">
          <source>Latin Small Letter S With Hook / Latin Small Letter S Hook</source>
          <target state="translated">拉丁文小字S挂钩/拉丁文小字S挂钩</target>
        </trans-unit>
        <trans-unit id="f17b9219c1288784e62e066762b90b3f1e0e55a8" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Schwa</source>
          <target state="translated">拉丁文小字Schwa</target>
        </trans-unit>
        <trans-unit id="19e904077d5fb0771a0c4bf22aebcb8d18879d02" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Sharp S</source>
          <target state="translated">拉丁文小字锐S</target>
        </trans-unit>
        <trans-unit id="4e3c130c920943099dd727660677e4cfb89ea723" translate="yes" xml:space="preserve">
          <source>Latin Small Letter T With Retroflex Hook / Latin Small Letter T Retroflex Hook</source>
          <target state="translated">拉丁小字T型反折钩/拉丁小字T型反折钩。</target>
        </trans-unit>
        <trans-unit id="b4aa5dce4f194d4f86cea8db7ef720a452c10472" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Tesh Digraph / Latin Small Letter T Esh</source>
          <target state="translated">拉丁文小字 Tesh Digraph/拉丁文小字 T Esh</target>
        </trans-unit>
        <trans-unit id="9a88a6a40f3264cff644fc36d6ea39b7e80dee4b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Thorn</source>
          <target state="translated">拉丁文小字荆棘</target>
        </trans-unit>
        <trans-unit id="206fdfa3558c503d9e843533aa39ca8750c5100a" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned A</source>
          <target state="translated">拉丁文小字转A</target>
        </trans-unit>
        <trans-unit id="44391e675633f27178e360e38182fb1c89dcc786" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Alpha / Latin Small Letter Turned Script A</source>
          <target state="translated">拉丁文小字转为字母/拉丁文小字转为字母A</target>
        </trans-unit>
        <trans-unit id="a45dfaa69d6b3db6daa54b07a19c0a16bc93f9c4" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned H</source>
          <target state="translated">拉丁文小字转H</target>
        </trans-unit>
        <trans-unit id="d0a8378f24aaa4a7fd08ad76eab02d85f9db34c3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned K</source>
          <target state="translated">拉丁语小字转K</target>
        </trans-unit>
        <trans-unit id="f60605b6d90f4154d38bac9031c2a73d3e7fb2fd" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M</source>
          <target state="translated">拉丁文小字转M</target>
        </trans-unit>
        <trans-unit id="80870744996553dd1a355c5c68035612071c93d5" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned M With Long Leg</source>
          <target state="translated">拉丁文小字长腿转M</target>
        </trans-unit>
        <trans-unit id="4e330127b9bd74c3ac0ed39785e51192a2a6804b" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R</source>
          <target state="translated">拉丁文小字转R</target>
        </trans-unit>
        <trans-unit id="7f2283c2045b7461f57d11ba1b67518361b943d3" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Hook / Latin Small Letter Turned R Hook</source>
          <target state="translated">拉丁文小字转R钩/拉丁文小字转R钩</target>
        </trans-unit>
        <trans-unit id="78ca75233c25b210f82d0fa683b1e829340273d9" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned R With Long Leg</source>
          <target state="translated">拉丁文小字转R长腿</target>
        </trans-unit>
        <trans-unit id="b693ad995bba90f1295c3eb3fa51e43c784b64eb" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned T</source>
          <target state="translated">拉丁文小字转T</target>
        </trans-unit>
        <trans-unit id="5209a0d49366580ead3e1dad9d6ff2475775f51f" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned V</source>
          <target state="translated">拉丁文小字转V</target>
        </trans-unit>
        <trans-unit id="450f985cc65d78122edf815571e08094f13be358" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned W</source>
          <target state="translated">拉丁文小字转W</target>
        </trans-unit>
        <trans-unit id="d4b68356f1e5f3312b5bc8059eb8f75757a7c22d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Turned Y</source>
          <target state="translated">拉丁文小字转Y</target>
        </trans-unit>
        <trans-unit id="1c50afa8247e2b596bb5484c0bdf31af4356cb8d" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Upsilon</source>
          <target state="translated">拉丁文小字Upsilon</target>
        </trans-unit>
        <trans-unit id="cf80e9e2586cd62109287c1d07560fe914a80d16" translate="yes" xml:space="preserve">
          <source>Latin Small Letter V With Hook / Latin Small Letter Script V</source>
          <target state="translated">拉丁文小字V(带钩)/拉丁文小字书法V(带钩)</target>
        </trans-unit>
        <trans-unit id="6a5f81b7b582dc216e4c1f24b62d26cf5af68967" translate="yes" xml:space="preserve">
          <source>Latin Small Letter Z With Retroflex Hook / Latin Small Letter Z Retroflex Hook</source>
          <target state="translated">拉丁语小字母Z带回形钩/拉丁语小字母Z回形钩</target>
        </trans-unit>
        <trans-unit id="e2c17f6ce613463c3e30d1a4aed82bceb3d0bf26" translate="yes" xml:space="preserve">
          <source>Latin Small Ligature Oe / Latin Small Letter O E</source>
          <target state="translated">拉丁文小字Oe/拉丁文小字O E.</target>
        </trans-unit>
        <trans-unit id="ab095c443113e11acf431c2bb30a86ce8ce57bb6" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter A</source>
          <target state="translated">拉丁文下标小字母A</target>
        </trans-unit>
        <trans-unit id="fff77fcf01dc719ec1ab77e81e213e93b8d0115a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter E</source>
          <target state="translated">拉丁文下标小字母E</target>
        </trans-unit>
        <trans-unit id="363c386941760c298d65628800930f8354b1c700" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter H</source>
          <target state="translated">拉丁字母小字H</target>
        </trans-unit>
        <trans-unit id="982401be038720a241d1e68deecf4cf7746b55ab" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter I</source>
          <target state="translated">拉丁文下标小字母I</target>
        </trans-unit>
        <trans-unit id="f36b34411ebc69050abaa08db12014b29b018b19" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter J</source>
          <target state="translated">拉丁文下标小字母J</target>
        </trans-unit>
        <trans-unit id="5d9192cce944b6338e9e19cf0e5aff75bc6458e0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter K</source>
          <target state="translated">拉丁文下标小字母K</target>
        </trans-unit>
        <trans-unit id="98e7def8db7a6c66ec697114dd36225f86e432d0" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter L</source>
          <target state="translated">拉丁字母小字L</target>
        </trans-unit>
        <trans-unit id="c88fe2a6e8d4931c9b29a2de9c39672213e2a09e" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter M</source>
          <target state="translated">拉丁字母小字M</target>
        </trans-unit>
        <trans-unit id="09020dd38fd21fc2f0e9c9b2f5cd4719b876181a" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter N</source>
          <target state="translated">拉丁文下标小字母N</target>
        </trans-unit>
        <trans-unit id="bf874a171794f22663d7decf77255804ee48a4b5" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter O</source>
          <target state="translated">拉丁文下标小字母O</target>
        </trans-unit>
        <trans-unit id="2f2d68aab8bef5631b7658f2f25cb157fe1312d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter P</source>
          <target state="translated">拉丁字母小字P</target>
        </trans-unit>
        <trans-unit id="6ae5998c63d2b847c715037212f1596e577e11d8" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter R</source>
          <target state="translated">拉丁字母小字R</target>
        </trans-unit>
        <trans-unit id="cbfb24f449387bbaf3bab5247af9c1ad7c5a2e87" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter S</source>
          <target state="translated">拉丁字母小字S</target>
        </trans-unit>
        <trans-unit id="54984068e00469db35d3a41626ebb9a634073396" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter Schwa</source>
          <target state="translated">拉丁文下标小字Schwa</target>
        </trans-unit>
        <trans-unit id="24e9ea8cb7bc17431bfd5069bebcda4cd2e0d7f4" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter T</source>
          <target state="translated">拉丁字母小字T</target>
        </trans-unit>
        <trans-unit id="c11091f07852038d224bf6a198262288070ac4af" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter U</source>
          <target state="translated">拉丁字母小字U</target>
        </trans-unit>
        <trans-unit id="59e0fc501529d38b3e42a1402845967ae6868b9c" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter V</source>
          <target state="translated">拉丁文下标小字母V</target>
        </trans-unit>
        <trans-unit id="87def54837d4f750a3ac2cc91c670222eecf573b" translate="yes" xml:space="preserve">
          <source>Latin Subscript Small Letter X</source>
          <target state="translated">拉丁字母小字X</target>
        </trans-unit>
        <trans-unit id="96f66def5d4a8c399dd4712422d81130f5b17cc9" translate="yes" xml:space="preserve">
          <source>Launches worker processes via the specified cluster manager.</source>
          <target state="translated">通过指定的群集管理器启动工人进程。</target>
        </trans-unit>
        <trans-unit id="230ffdc98fdacb0f873a14dccabfdda12422305b" translate="yes" xml:space="preserve">
          <source>Launches workers using the in-built &lt;code&gt;LocalManager&lt;/code&gt; which only launches workers on the local host. This can be used to take advantage of multiple cores. &lt;code&gt;addprocs(4)&lt;/code&gt; will add 4 processes on the local machine. If &lt;code&gt;restrict&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, binding is restricted to &lt;code&gt;127.0.0.1&lt;/code&gt;. Keyword args &lt;code&gt;dir&lt;/code&gt;, &lt;code&gt;exename&lt;/code&gt;, &lt;code&gt;exeflags&lt;/code&gt;, &lt;code&gt;topology&lt;/code&gt;, &lt;code&gt;lazy&lt;/code&gt; and &lt;code&gt;enable_threaded_blas&lt;/code&gt; have the same effect as documented for &lt;code&gt;addprocs(machines)&lt;/code&gt;.</source>
          <target state="translated">使用内置的 &lt;code&gt;LocalManager&lt;/code&gt; 启动工作程序，该程序仅在本地主机上启动工作程序。这可用于利用多个内核。 &lt;code&gt;addprocs(4)&lt;/code&gt; 将在本地计算机上添加4个进程。如果 &lt;code&gt;restrict&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则绑定限制为 &lt;code&gt;127.0.0.1&lt;/code&gt; 。关键字args &lt;code&gt;dir&lt;/code&gt; ， &lt;code&gt;exename&lt;/code&gt; ， &lt;code&gt;exeflags&lt;/code&gt; ， &lt;code&gt;topology&lt;/code&gt; ， &lt;code&gt;lazy&lt;/code&gt; 和 &lt;code&gt;enable_threaded_blas&lt;/code&gt; 具有与 &lt;code&gt;addprocs(machines)&lt;/code&gt; 相同的效果。</target>
        </trans-unit>
        <trans-unit id="5651fa0fd68350a3db0e0ce46acc644a6f99f032" translate="yes" xml:space="preserve">
          <source>Lazy adjoint (conjugate transposition) (also postfix &lt;code&gt;'&lt;/code&gt;). Note that &lt;code&gt;adjoint&lt;/code&gt; is applied recursively to elements.</source>
          <target state="translated">懒惰伴随（共轭换位）（也是后缀 &lt;code&gt;'&lt;/code&gt; ）。请注意， &lt;code&gt;adjoint&lt;/code&gt; 是递归地应用于元素。</target>
        </trans-unit>
        <trans-unit id="1a484bd65bd99903b9e6433e56a7ce5feb1a88b4" translate="yes" xml:space="preserve">
          <source>Lazy adjoint (conjugate transposition). Note that &lt;code&gt;adjoint&lt;/code&gt; is applied recursively to elements.</source>
          <target state="translated">懒惰的伴随（共轭换位）。请注意， &lt;code&gt;adjoint&lt;/code&gt; 是递归地应用于元素。</target>
        </trans-unit>
        <trans-unit id="4dabe105e2961d8642efb76e1ebd7539fca5122b" translate="yes" xml:space="preserve">
          <source>Lazy transpose. Mutating the returned object should appropriately mutate &lt;code&gt;A&lt;/code&gt;. Often, but not always, yields &lt;code&gt;Transpose(A)&lt;/code&gt;, where &lt;code&gt;Transpose&lt;/code&gt; is a lazy transpose wrapper. Note that this operation is recursive.</source>
          <target state="translated">懒惰转置。变异返回的对象应该适当地发生变异 &lt;code&gt;A&lt;/code&gt; 。通常但并非总是产生 &lt;code&gt;Transpose(A)&lt;/code&gt; ，其中 &lt;code&gt;Transpose&lt;/code&gt; 是一个懒惰的转置包装器。请注意，此操作是递归的。</target>
        </trans-unit>
        <trans-unit id="52790bab6c96ca4ca79f6c9dcbc5f04f90742a02" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for a transpose view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Transpose&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">底层线性代数对象的转置视图的惰性包装器类型，通常是 &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; ，但也可以包含一些 &lt;code&gt;Factorization&lt;/code&gt; 。通常，不应直接调用 &lt;code&gt;Transpose&lt;/code&gt; 构造函数，而应使用&lt;a href=&quot;#Base.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; &lt;/a&gt;。要实现视图，请使用&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="ea87c3f92c6c2a81bda14868b1fa3651e1788be6" translate="yes" xml:space="preserve">
          <source>Lazy wrapper type for an adjoint view of the underlying linear algebra object, usually an &lt;code&gt;AbstractVector&lt;/code&gt;/&lt;code&gt;AbstractMatrix&lt;/code&gt;, but also some &lt;code&gt;Factorization&lt;/code&gt;, for instance. Usually, the &lt;code&gt;Adjoint&lt;/code&gt; constructor should not be called directly, use &lt;a href=&quot;#Base.adjoint&quot;&gt;&lt;code&gt;adjoint&lt;/code&gt;&lt;/a&gt; instead. To materialize the view use &lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">底层线性代数对象的伴随视图的惰性包装类型，例如通常是 &lt;code&gt;AbstractVector&lt;/code&gt; / &lt;code&gt;AbstractMatrix&lt;/code&gt; ，但也可以包含一些 &lt;code&gt;Factorization&lt;/code&gt; 。通常，不应直接调用 &lt;code&gt;Adjoint&lt;/code&gt; 构造函数，而应使用&lt;a href=&quot;#Base.adjoint&quot;&gt; &lt;code&gt;adjoint&lt;/code&gt; &lt;/a&gt;。要实现视图，请使用&lt;a href=&quot;../../base/base/index#Base.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="c31303ce475bc8493699e997a666b0db70d41d90" translate="yes" xml:space="preserve">
          <source>Leaf Fluttering In Wind</source>
          <target state="translated">叶子在风中飞舞</target>
        </trans-unit>
        <trans-unit id="22d214839b787ba0cbf83b35c8637e398eb00b60" translate="yes" xml:space="preserve">
          <source>Least common (non-negative) multiple.</source>
          <target state="translated">最不常见的(非负数)倍数。</target>
        </trans-unit>
        <trans-unit id="df7cd86f236b8cca642b834576ccdcaabf497db7" translate="yes" xml:space="preserve">
          <source>Least common (non-negative) multiple. The arguments may be integer and rational numbers.</source>
          <target state="translated">最小公倍数(非负数)。参数可以是整数和有理数。</target>
        </trans-unit>
        <trans-unit id="1aa2f31ee7ccbdf2fc8c6c567cdca2fb29dac2a6" translate="yes" xml:space="preserve">
          <source>Ledger</source>
          <target state="translated">Ledger</target>
        </trans-unit>
        <trans-unit id="8ae1c34bd37fad49cc5f8e02da648a78e89c3ed8" translate="yes" xml:space="preserve">
          <source>Left</source>
          <target state="translated">Left</target>
        </trans-unit>
        <trans-unit id="75d0899e95136f2da4eac284be2b987384e5c533" translate="yes" xml:space="preserve">
          <source>Left Arrow With Circled Plus</source>
          <target state="translated">左箭头带圆圈加号</target>
        </trans-unit>
        <trans-unit id="72aee17ac3f066d41059e365fe7ffff8c87f2b40" translate="yes" xml:space="preserve">
          <source>Left Arrow With Small Circle</source>
          <target state="translated">左箭头带小圆圈</target>
        </trans-unit>
        <trans-unit id="e4186034491319e4fea56b94c110018858b681a3" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Down Harpoon</source>
          <target state="translated">左侧倒钩向下 右侧倒钩向下 鱼叉</target>
        </trans-unit>
        <trans-unit id="ae21e1eb75451dd870d85a61a1cfa6bc8df2ba78" translate="yes" xml:space="preserve">
          <source>Left Barb Down Right Barb Up Harpoon</source>
          <target state="translated">左倒钩向下 右倒钩向上 鱼叉</target>
        </trans-unit>
        <trans-unit id="bcae4f39e04c712debc4107f48695498ba926272" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Down Harpoon</source>
          <target state="translated">左侧倒钩向上 右侧倒钩向下 鱼叉</target>
        </trans-unit>
        <trans-unit id="f15664f5c11100645f7ec0fc503d10e242c811c4" translate="yes" xml:space="preserve">
          <source>Left Barb Up Right Barb Up Harpoon</source>
          <target state="translated">左侧倒钩向上 右侧倒钩向上 鱼叉</target>
        </trans-unit>
        <trans-unit id="a3c4bf704acbb06ce3404e8185007c7d40dd50dc" translate="yes" xml:space="preserve">
          <source>Left Ceiling</source>
          <target state="translated">左天花板</target>
        </trans-unit>
        <trans-unit id="72a9f53c8c863fcc58b749c2d802910b9dd69204" translate="yes" xml:space="preserve">
          <source>Left Double Quotation Mark / Double Turned Comma Quotation Mark</source>
          <target state="translated">左侧双引号/双转逗号引号</target>
        </trans-unit>
        <trans-unit id="33ab45e60f973d03d477e320c9c21d10102209f2" translate="yes" xml:space="preserve">
          <source>Left Floor</source>
          <target state="translated">左层</target>
        </trans-unit>
        <trans-unit id="acdcba05803275d77a8ff9d944d257c2f355cc32" translate="yes" xml:space="preserve">
          <source>Left Half Black Circle</source>
          <target state="translated">左半边黑色圆环</target>
        </trans-unit>
        <trans-unit id="98f2260c432833cdcda74a0d3fd1bcf7149895fd" translate="yes" xml:space="preserve">
          <source>Left Half Block</source>
          <target state="translated">左半块</target>
        </trans-unit>
        <trans-unit id="b2d1cb4617e2395b9bcddfaba836b4ff2e6e68a3" translate="yes" xml:space="preserve">
          <source>Left Luggage</source>
          <target state="translated">左侧行李箱</target>
        </trans-unit>
        <trans-unit id="6fc8b4239d1345e60f61ab6561b7d80a0e196edc" translate="yes" xml:space="preserve">
          <source>Left Normal Factor Semidirect Product</source>
          <target state="translated">左法向系数半间接产品</target>
        </trans-unit>
        <trans-unit id="a759ee17e030c9538e681ee56e56b5128b9fcd58" translate="yes" xml:space="preserve">
          <source>Left Outer Join</source>
          <target state="translated">左外侧加入</target>
        </trans-unit>
        <trans-unit id="bea5ba9ebfbff15c8175b8c30772408ad172251f" translate="yes" xml:space="preserve">
          <source>Left Right Arrow</source>
          <target state="translated">左右箭头</target>
        </trans-unit>
        <trans-unit id="92b57eec514e84ae8d71456c14f7cff82b10a548" translate="yes" xml:space="preserve">
          <source>Left Right Arrow Through Small Circle</source>
          <target state="translated">左右箭头穿过小圆圈</target>
        </trans-unit>
        <trans-unit id="8f9b98c29f15c9b6eaf2eadce9578f5dc5b96041" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Double Vertical Stroke</source>
          <target state="translated">左右箭头双竖笔</target>
        </trans-unit>
        <trans-unit id="09fe21e697a5fa104980be3384a847b808e4d81a" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Stroke</source>
          <target state="translated">左右箭头与笔画</target>
        </trans-unit>
        <trans-unit id="c3c516b47151666dadcf1dd0a1b3b7ab23f3f3ab" translate="yes" xml:space="preserve">
          <source>Left Right Arrow With Vertical Stroke</source>
          <target state="translated">左右箭头与垂直笔画</target>
        </trans-unit>
        <trans-unit id="4f5213e5966d1dc7812d67e6434bf47c9574b0b4" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow</source>
          <target state="translated">左右双箭头</target>
        </trans-unit>
        <trans-unit id="83ed63f2653f9ec7aef827c095dc0fd80a9657f8" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Stroke</source>
          <target state="translated">左右双箭头加笔画</target>
        </trans-unit>
        <trans-unit id="a2ff1377f747643672f8858987628f93747b7eb2" translate="yes" xml:space="preserve">
          <source>Left Right Double Arrow With Vertical Stroke</source>
          <target state="translated">左右双箭头垂直划线</target>
        </trans-unit>
        <trans-unit id="172365e73cff74845a1277eb1fb198684eed94bd" translate="yes" xml:space="preserve">
          <source>Left Right Open-Headed Arrow</source>
          <target state="translated">左 右 开头箭头</target>
        </trans-unit>
        <trans-unit id="8055689a32aa93576b189b393a7f7e70b68fbc3d" translate="yes" xml:space="preserve">
          <source>Left Right Wave Arrow</source>
          <target state="translated">左右波浪箭</target>
        </trans-unit>
        <trans-unit id="37d876c1c2c475cd47f27703a88e7f2f9166fd62" translate="yes" xml:space="preserve">
          <source>Left Semidirect Product</source>
          <target state="translated">左半间接产品</target>
        </trans-unit>
        <trans-unit id="62324b102cc4b4bf016fb9203c38bec07856133a" translate="yes" xml:space="preserve">
          <source>Left Single Quotation Mark / Single Turned Comma Quotation Mark</source>
          <target state="translated">左侧单引号/单转逗号引号</target>
        </trans-unit>
        <trans-unit id="19e4168df09f34516f6fddcc4e445fc021594bcb" translate="yes" xml:space="preserve">
          <source>Left Square Bracket Lower Corner</source>
          <target state="translated">左方托架下角</target>
        </trans-unit>
        <trans-unit id="ac1fd430a7759464f468517dfa51418639f0abf8" translate="yes" xml:space="preserve">
          <source>Left Tack</source>
          <target state="translated">左后卫</target>
        </trans-unit>
        <trans-unit id="07241f21177a787dd3313c67746b03f50c2d9592" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar</source>
          <target state="translated">竖条旁的左三角</target>
        </trans-unit>
        <trans-unit id="3b3a0479d1df49711a0b5dda01c8a9f250ee53e9" translate="yes" xml:space="preserve">
          <source>Left Triangle Beside Vertical Bar + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">竖条旁的左三角+组合长实心叠加/无间隔长斜线叠加。</target>
        </trans-unit>
        <trans-unit id="24f6c1c79f67d997809b3110481aa58d9f740e6a" translate="yes" xml:space="preserve">
          <source>Left Vertical Box Line</source>
          <target state="translated">左侧垂直框线</target>
        </trans-unit>
        <trans-unit id="e2e904284d118de6f14c002567a428193497055e" translate="yes" xml:space="preserve">
          <source>Left arrow, &lt;code&gt;^B&lt;/code&gt;</source>
          <target state="translated">左箭头 &lt;code&gt;^B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43c75bdc1fa38ddb43ed3abfdf3e4dda383f45ac" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;B&lt;/code&gt; with elements shifted &lt;code&gt;n&lt;/code&gt; positions backwards, filling with &lt;code&gt;false&lt;/code&gt; values. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, elements are shifted forwards. Equivalent to &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">左移位运算符 &lt;code&gt;B &amp;lt;&amp;lt; n&lt;/code&gt; 。当 &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; ，结果为 &lt;code&gt;B&lt;/code&gt; ，元素向后移动 &lt;code&gt;n&lt;/code&gt; 个位置，并填充 &lt;code&gt;false&lt;/code&gt; 值。如果 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; ，则元素向前移动。等效于 &lt;code&gt;B &amp;gt;&amp;gt; -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="700db7c2e4663e2dc271d4c36173f17b6c63b025" translate="yes" xml:space="preserve">
          <source>Left bit shift operator, &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt;. For &lt;code&gt;n &amp;gt;= 0&lt;/code&gt;, the result is &lt;code&gt;x&lt;/code&gt; shifted left by &lt;code&gt;n&lt;/code&gt; bits, filling with &lt;code&gt;0&lt;/code&gt;s. This is equivalent to &lt;code&gt;x * 2^n&lt;/code&gt;. For &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, this is equivalent to &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt;.</source>
          <target state="translated">左移位运算符， &lt;code&gt;x &amp;lt;&amp;lt; n&lt;/code&gt; 。对于 &lt;code&gt;n &amp;gt;= 0&lt;/code&gt; ，结果将 &lt;code&gt;x&lt;/code&gt; 左移 &lt;code&gt;n&lt;/code&gt; 位，以 &lt;code&gt;0&lt;/code&gt; s 填充。这等效于 &lt;code&gt;x * 2^n&lt;/code&gt; 。对于 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; ，这等效于 &lt;code&gt;x &amp;gt;&amp;gt; -n&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="47e029a3c897df6f4c0de3d067011451de3151f3" translate="yes" xml:space="preserve">
          <source>Left division operator: multiplication of &lt;code&gt;y&lt;/code&gt; by the inverse of &lt;code&gt;x&lt;/code&gt; on the left. Gives floating-point results for integer arguments.</source>
          <target state="translated">左除法运算符： &lt;code&gt;y&lt;/code&gt; 乘以左边 &lt;code&gt;x&lt;/code&gt; 的倒数。给出整数参数的浮点结果。</target>
        </trans-unit>
        <trans-unit id="5ddde4aec1f53e97b5a1f34009e407e1cb187578" translate="yes" xml:space="preserve">
          <source>Left-Pointing Magnifying Glass</source>
          <target state="translated">左旋式放大镜</target>
        </trans-unit>
        <trans-unit id="35088a4f27322015e328e0637be16cff0df478d9" translate="yes" xml:space="preserve">
          <source>Left-rotate matrix &lt;code&gt;A&lt;/code&gt; 90 degrees counterclockwise an integer &lt;code&gt;k&lt;/code&gt; number of times. If &lt;code&gt;k&lt;/code&gt; is a multiple of four (including zero), this is equivalent to a &lt;code&gt;copy&lt;/code&gt;.</source>
          <target state="translated">左旋转矩阵 &lt;code&gt;A&lt;/code&gt; 逆时针旋转90度，整数倍 &lt;code&gt;k&lt;/code&gt; 次。如果 &lt;code&gt;k&lt;/code&gt; 是4的倍数（包括零），则等效于 &lt;code&gt;copy&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="af413d32c0aefe9e0a6c5345832116ac3819cfc9" translate="yes" xml:space="preserve">
          <source>Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</source>
          <target state="translated">Left&lt;a href=&quot;#footnote-2&quot;&gt;[2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="927f085de46b51d7752a0f754c30861f6cbe6126" translate="yes" xml:space="preserve">
          <source>Left&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Left&lt;sup&gt;&lt;a href=&quot;#footnote-2&quot; id=&quot;citeref-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="8b0da9967a31e27b91c5f79f61cda48210161da5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow / Left Arrow</source>
          <target state="translated">向左箭头/左箭头</target>
        </trans-unit>
        <trans-unit id="bb62e777d053b849a3960927799605c68d6f5eca" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Almost Equal To</source>
          <target state="translated">向左上方的箭头几乎等于</target>
        </trans-unit>
        <trans-unit id="c453288b80fc56c56e06ba24b30f84f5dac9e172" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Almost Equal To</source>
          <target state="translated">反面上方的左向箭头几乎等于</target>
        </trans-unit>
        <trans-unit id="c80976998c602bbf7e0960e57864b997e7fa3170" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Above Reverse Tilde Operator</source>
          <target state="translated">反向倾斜操作器上方的向左箭头。</target>
        </trans-unit>
        <trans-unit id="b339bc529a24441191ee0d608b29a79c5db84b52" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar / Left Arrow From Bar</source>
          <target state="translated">向左箭头从栏杆开始/向左箭头从栏杆开始</target>
        </trans-unit>
        <trans-unit id="1e84d429549228a5c098aec3446031d7ead6505a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow From Bar To Black Diamond</source>
          <target state="translated">向左箭头从酒吧到黑钻石</target>
        </trans-unit>
        <trans-unit id="3b47b1dfc544dad6abdaf2ebcb4206c54487efc5" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Over Rightwards Arrow / Left Arrow Over Right Arrow</source>
          <target state="translated">向左箭头高于向右箭头/向左箭头高于向右箭头。</target>
        </trans-unit>
        <trans-unit id="ae9989b5442d5772a5dadc97fcf089e63cd8bb1f" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow Through X</source>
          <target state="translated">向左箭头穿过X</target>
        </trans-unit>
        <trans-unit id="ae63102c5c00038eb021088d9b27a739caf11f6e" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar / Left Arrow To Bar</source>
          <target state="translated">向左箭头到栏杆/向左箭头到栏杆</target>
        </trans-unit>
        <trans-unit id="ba54e194d48c6e6846ca63e167eaa511daf10b83" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Bar Over Rightwards Arrow To Bar / Left Arrow To Bar Over Right Arrow To Bar</source>
          <target state="translated">向左箭头转杠高于向右箭头转杠/向左箭头转杠高于向右箭头转杠。</target>
        </trans-unit>
        <trans-unit id="352323837c59795cd0e83f313a7f1aad09357b67" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow To Black Diamond</source>
          <target state="translated">向左箭头至黑钻石</target>
        </trans-unit>
        <trans-unit id="0dbfe3aca18f61d6f1a6e05b8ae3c26d1725c775" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Dotted Stem</source>
          <target state="translated">向左箭头,带点状茎</target>
        </trans-unit>
        <trans-unit id="b5f4b7ef2746d70757e6dc984fb3961f86960c29" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Double Vertical Stroke</source>
          <target state="translated">向左箭头,双垂直笔画</target>
        </trans-unit>
        <trans-unit id="42e353d97e79c0c1b091dc7d9378f532aaef3b3d" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Hook / Left Arrow With Hook</source>
          <target state="translated">向左箭头带钩/左箭头带钩</target>
        </trans-unit>
        <trans-unit id="023d9a3502015dcd3b3f76fa14c946cbbc2d6f32" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Loop / Left Arrow With Loop</source>
          <target state="translated">向左箭头带环/向左箭头带环。</target>
        </trans-unit>
        <trans-unit id="9e22f7f96528d90c3397d6b157c1fdc2594ea742" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Plus Below</source>
          <target state="translated">向左箭头,下方为加号</target>
        </trans-unit>
        <trans-unit id="cc480573c42bb17cb0e2940abfedd3c8ea38e8ea" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Stroke / Left Arrow With Stroke</source>
          <target state="translated">向左箭头加笔画/左箭头加笔画。</target>
        </trans-unit>
        <trans-unit id="52d1604edf7ef87df0bdda8c2b40df8871c49a60" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail / Left Arrow With Tail</source>
          <target state="translated">向左箭尾/向左箭尾</target>
        </trans-unit>
        <trans-unit id="88f9604cfadba8964cc29be77251abe676f9051a" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">向左箭头,带尾巴,双垂直行程。</target>
        </trans-unit>
        <trans-unit id="390234b436d1a22d91a1f9368ac90420d25a50f9" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Tail With Vertical Stroke</source>
          <target state="translated">向左箭头,尾部有垂直行程</target>
        </trans-unit>
        <trans-unit id="11ebeb1eafd67ffeeffad131d7ac82c3b52085be" translate="yes" xml:space="preserve">
          <source>Leftwards Arrow With Vertical Stroke</source>
          <target state="translated">向左箭头与垂直行程</target>
        </trans-unit>
        <trans-unit id="c87c24a3eb1d8323b9fa96777c93ec260174835d" translate="yes" xml:space="preserve">
          <source>Leftwards Black Arrow</source>
          <target state="translated">左向黑箭</target>
        </trans-unit>
        <trans-unit id="33cfca8919d0753ef59ada74348c2a4c4b3bf344" translate="yes" xml:space="preserve">
          <source>Leftwards Dashed Arrow / Left Dashed Arrow</source>
          <target state="translated">向左虚线/向左虚线</target>
        </trans-unit>
        <trans-unit id="8a19ba0a75d89ee68704a7ebb90ffd71f1e1b278" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow / Left Double Arrow</source>
          <target state="translated">向左双箭头/左双箭头</target>
        </trans-unit>
        <trans-unit id="60c9a06f1f5b3ab83b89088f525d893f40459a8e" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow From Bar</source>
          <target state="translated">向左转双箭头 从酒吧</target>
        </trans-unit>
        <trans-unit id="0d8615420d5ad768b1f26184a0a7a40704148a7d" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Stroke / Left Double Arrow With Stroke</source>
          <target state="translated">向左双箭头加笔画/向左双箭头加笔画。</target>
        </trans-unit>
        <trans-unit id="4f6b99ebd5ed363e088c4f88602ef903b8e06f64" translate="yes" xml:space="preserve">
          <source>Leftwards Double Arrow With Vertical Stroke</source>
          <target state="translated">向左的双箭头,带垂直笔画</target>
        </trans-unit>
        <trans-unit id="4f794063524482bcc21c38eae616ca798ede37a8" translate="yes" xml:space="preserve">
          <source>Leftwards Double Dash Arrow</source>
          <target state="translated">向左双冲箭头</target>
        </trans-unit>
        <trans-unit id="39e96a986704f562e46fbf1d03e4f9e54add9f77" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon Over Rightwards Harpoon / Left Harpoon Over Right Harpoon</source>
          <target state="translated">向左鱼叉胜向右鱼叉/向左鱼叉胜向右鱼叉。</target>
        </trans-unit>
        <trans-unit id="690c48df2218ae792864eaf9456cf6955b424427" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Above Rightwards Harpoon With Barb Down</source>
          <target state="translated">向左的鱼叉,上面有倒刺 向右的鱼叉,下面有倒刺。</target>
        </trans-unit>
        <trans-unit id="2a8c5adb9efda04b9d2fabf980287f590ba155e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down Below Long Dash</source>
          <target state="translated">左向鱼叉带倒钩下长冲程</target>
        </trans-unit>
        <trans-unit id="d60c5396df85f38cca433173bdcae8dd56a90b18" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down From Bar</source>
          <target state="translated">左向鱼叉,带倒钩,从棒子上向下。</target>
        </trans-unit>
        <trans-unit id="93c5200b6461e9ba3314eb9a0b244de1ac0949de" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Down To Bar</source>
          <target state="translated">左向鱼叉,带倒钩,下至棒状物</target>
        </trans-unit>
        <trans-unit id="b6d93e8905d73cadcac079a3790b467b97f9e3ec" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Downwards / Left Harpoon With Barb Down</source>
          <target state="translated">向左的鱼叉带倒刺向下/向左的鱼叉带倒刺向下。</target>
        </trans-unit>
        <trans-unit id="662b3d2cbb862798f1987f0dd2c11e4c77a5182f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Leftwards Harpoon With Barb Down</source>
          <target state="translated">左向鱼叉,上方有倒钩 左向鱼叉,下方有倒钩</target>
        </trans-unit>
        <trans-unit id="b0567c46db77bd91abd63923235b4420e5bd82e5" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Long Dash</source>
          <target state="translated">向左的鱼叉,带倒钩的长冲程以上。</target>
        </trans-unit>
        <trans-unit id="0084ef3852a19447620ab7c0dfc2d2b12aeeb77d" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up Above Rightwards Harpoon With Barb Up</source>
          <target state="translated">左向鱼叉,上面有倒钩 右向鱼叉,上面有倒钩</target>
        </trans-unit>
        <trans-unit id="730216336dfd2e32435830075fdb2df0dfaa397f" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up From Bar</source>
          <target state="translated">左向鱼叉,带倒钩,从棒子上起</target>
        </trans-unit>
        <trans-unit id="4cbc38b13463300c356dd264e992f7457f26d5f3" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Up To Bar</source>
          <target state="translated">向左的鱼叉,带倒钩,向上至棒状物</target>
        </trans-unit>
        <trans-unit id="42c26ac6b35b0c13895bf055d9cecb545b0ec09a" translate="yes" xml:space="preserve">
          <source>Leftwards Harpoon With Barb Upwards / Left Harpoon With Barb Up</source>
          <target state="translated">向左的鱼叉与向上的倒钩/向左的鱼叉与向上的倒钩。</target>
        </trans-unit>
        <trans-unit id="5439409c437a7e20e57d117b3dc53bfc59be5b1e" translate="yes" xml:space="preserve">
          <source>Leftwards Open-Headed Arrow</source>
          <target state="translated">向左开头箭头</target>
        </trans-unit>
        <trans-unit id="fb802d31c4d84700fe501788c56f0616bde89895" translate="yes" xml:space="preserve">
          <source>Leftwards Paired Arrows / Left Paired Arrows</source>
          <target state="translated">左向成对箭头/左向成对箭头。</target>
        </trans-unit>
        <trans-unit id="1e30b6357af1b8210adc5e8500513f1780a44b86" translate="yes" xml:space="preserve">
          <source>Leftwards Quadruple Arrow</source>
          <target state="translated">向左四箭头</target>
        </trans-unit>
        <trans-unit id="e990b5a5a1b8966a349729643a9904c9a464f8f2" translate="yes" xml:space="preserve">
          <source>Leftwards Squiggle Arrow / Left Squiggle Arrow</source>
          <target state="translated">向左曲折箭头/向左曲折箭头。</target>
        </trans-unit>
        <trans-unit id="40ef7c42edfad6e4a2b0c741f7a2e57b2d0a3d17" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Arrow / Left Triple Arrow</source>
          <target state="translated">向左三箭头/左三箭头</target>
        </trans-unit>
        <trans-unit id="e443b0f54a32ffe38d3c2940e3150615527deb02" translate="yes" xml:space="preserve">
          <source>Leftwards Triple Dash Arrow</source>
          <target state="translated">向左三冲箭头</target>
        </trans-unit>
        <trans-unit id="0e6ace611eb46c42c60ebf869526d6d80107ee54" translate="yes" xml:space="preserve">
          <source>Leftwards Two Headed Arrow / Left Two Headed Arrow</source>
          <target state="translated">向左双头箭/向左双头箭。</target>
        </trans-unit>
        <trans-unit id="73e956493780be5029f93be5ee242950d63a7b37" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow From Bar</source>
          <target state="translated">向左的双头箭头 从酒吧</target>
        </trans-unit>
        <trans-unit id="c8fe728344df16251ef3411400150ba0b2c50044" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Double Vertical Stroke</source>
          <target state="translated">向左的双头箭,双垂直行程。</target>
        </trans-unit>
        <trans-unit id="19a7c2f943c6a266d93318b4faccd25877a453bc" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail</source>
          <target state="translated">向左的双头尾箭</target>
        </trans-unit>
        <trans-unit id="fad45cb4bffed0212e02a7dd5b2b9636aeff862a" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Double Vertical Stroke</source>
          <target state="translated">左向双头箭,尾部有双垂直行程</target>
        </trans-unit>
        <trans-unit id="5354b323327ab9574144f2502eac42843f5fcc1b" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Tail With Vertical Stroke</source>
          <target state="translated">向左的双头箭,尾部有垂直行程</target>
        </trans-unit>
        <trans-unit id="be95b8e9e0c8c9337712cb0f314c9ab2a05f3613" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Arrow With Vertical Stroke</source>
          <target state="translated">向左的双头箭,竖直笔画</target>
        </trans-unit>
        <trans-unit id="43f10f58eb0471f466412a154b6c2de8a4b85793" translate="yes" xml:space="preserve">
          <source>Leftwards Two-Headed Triple Dash Arrow</source>
          <target state="translated">向左的双头三冲箭头</target>
        </trans-unit>
        <trans-unit id="54be3ecc08f6dfc79a630a29d3be179ecc6e1de9" translate="yes" xml:space="preserve">
          <source>Leftwards Wave Arrow / Left Wave Arrow</source>
          <target state="translated">向左波浪箭/左波浪箭</target>
        </trans-unit>
        <trans-unit id="a8988dc4aff78fbf3d6dec72ae6a15340f71c39b" translate="yes" xml:space="preserve">
          <source>Leftwards White Arrow / White Left Arrow</source>
          <target state="translated">左向白箭/左向白箭</target>
        </trans-unit>
        <trans-unit id="53789e63c0a26b06f6ee3389f57916b3259c1e85" translate="yes" xml:space="preserve">
          <source>Legend:</source>
          <target state="translated">Legend:</target>
        </trans-unit>
        <trans-unit id="4459b791a680572873dc2cf033487dc21edfcb9c" translate="yes" xml:space="preserve">
          <source>Lemon</source>
          <target state="translated">Lemon</target>
        </trans-unit>
        <trans-unit id="cfaf50ac3721461bd3a2d27ef5f35e144901fbb6" translate="yes" xml:space="preserve">
          <source>Leo</source>
          <target state="translated">Leo</target>
        </trans-unit>
        <trans-unit id="3ee924e59f48f89881e4cde275cb373a5ca3ccb1" translate="yes" xml:space="preserve">
          <source>Leopard</source>
          <target state="translated">Leopard</target>
        </trans-unit>
        <trans-unit id="2b515baec988fd996a77420ccdf808df339479aa" translate="yes" xml:space="preserve">
          <source>Less-Than Above Double-Line Equal Above Greater-Than</source>
          <target state="translated">小于双线以上 平于大线以上</target>
        </trans-unit>
        <trans-unit id="5132ce6dbd42eef8696f2795c98fbde608c55ddc" translate="yes" xml:space="preserve">
          <source>Less-Than Above Greater-Than Above Double-Line Equal</source>
          <target state="translated">小于以上 大于以上 双线相等</target>
        </trans-unit>
        <trans-unit id="0996bf12be96a0c9cfd35d9c3d1cd4d7ae0dc489" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Above Greater-Than</source>
          <target state="translated">小于以上 类似以上 大于以上</target>
        </trans-unit>
        <trans-unit id="f47dca757b69c3cbb5c4318a3148b185aa51ad59" translate="yes" xml:space="preserve">
          <source>Less-Than Above Similar Or Equal</source>
          <target state="translated">少于或高于类似或相等</target>
        </trans-unit>
        <trans-unit id="d46f5f3bf1beaa31682309e60c70c4c4589a153d" translate="yes" xml:space="preserve">
          <source>Less-Than Above Slanted Equal Above Greater-Than Above Slanted Equal</source>
          <target state="translated">小于等于斜上方 大于等于斜上方</target>
        </trans-unit>
        <trans-unit id="713b9a189c39738ac2705479504dc75c64634c14" translate="yes" xml:space="preserve">
          <source>Less-Than And Not Approximate</source>
          <target state="translated">小于且非近似值</target>
        </trans-unit>
        <trans-unit id="2796bb948b259786fd87ad28f516271749c20d52" translate="yes" xml:space="preserve">
          <source>Less-Than And Single-Line Not Equal To</source>
          <target state="translated">少线和单线不等于单线。</target>
        </trans-unit>
        <trans-unit id="709360d5eb9bea213909aadcf59a29aa892cbe75" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To</source>
          <target state="translated">小于但不等于/小于但不等于的标准。</target>
        </trans-unit>
        <trans-unit id="e453412818d96e7a4f420ee26bac5ea434246d68" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equal To / Less Than But Not Equal To + Variation Selector-1</source>
          <target state="translated">小于但不等于/小于但不等于+变量选择器-1。</target>
        </trans-unit>
        <trans-unit id="2f4b9cde7d599f1fdfcdcd2d149da1761281cf59" translate="yes" xml:space="preserve">
          <source>Less-Than But Not Equivalent To / Less Than But Not Equivalent To</source>
          <target state="translated">小于但不等于/小于但不等于......。</target>
        </trans-unit>
        <trans-unit id="d47b00bfbef46bd9077401979c412c7c9f4f06db" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve</source>
          <target state="translated">小于闭合曲线</target>
        </trans-unit>
        <trans-unit id="e9bc15ca0894be74c91d83dd7307ed3d4d198f47" translate="yes" xml:space="preserve">
          <source>Less-Than Closed By Curve Above Slanted Equal</source>
          <target state="translated">小于闭合的曲线上面的斜面相等</target>
        </trans-unit>
        <trans-unit id="22c4db9e780b7f321b3a098f0b550b5d05360802" translate="yes" xml:space="preserve">
          <source>Less-Than Equal To Or Greater-Than / Less Than Equal To Or Greater Than</source>
          <target state="translated">小于等于或大于等于/小于等于或大于大于</target>
        </trans-unit>
        <trans-unit id="125980c6753f24cfef91a7aee66e7177aefa9911" translate="yes" xml:space="preserve">
          <source>Less-Than Or Approximate</source>
          <target state="translated">小于或近似</target>
        </trans-unit>
        <trans-unit id="c6b5679738cc00d2db14ba6a2056c401ded59619" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equal To / Less Than Or Equal To</source>
          <target state="translated">少于或等于/少于或等于</target>
        </trans-unit>
        <trans-unit id="35d27cfb30206b75fdeb27b601c10d1aad047c85" translate="yes" xml:space="preserve">
          <source>Less-Than Or Equivalent To / Less Than Or Equivalent To</source>
          <target state="translated">小于或等同于/小于或等同于</target>
        </trans-unit>
        <trans-unit id="b9b477ee81eb35999da4d54deb44ce4b860fe5f0" translate="yes" xml:space="preserve">
          <source>Less-Than Or Greater-Than / Less Than Or Greater Than</source>
          <target state="translated">小于或大于/小于或大于</target>
        </trans-unit>
        <trans-unit id="cfd32ee1a60232f0de86d5e566782496b87faa45" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To</source>
          <target state="translated">小于或斜于</target>
        </trans-unit>
        <trans-unit id="c2210b5afd5a3271bd637771d340007b9651af50" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To + Combining Long Solidus Overlay / Non-Spacing Long Slash Overlay</source>
          <target state="translated">小于或斜于+组合长实心叠加/无间隔长斜线叠加。</target>
        </trans-unit>
        <trans-unit id="a5250f1e7fd00d514cf7de98b151fff6e960ca41" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above</source>
          <target state="translated">小于或斜于等于与点以上</target>
        </trans-unit>
        <trans-unit id="08ee594bef0f1ebfc9a347365790474b8aa06aae" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Above Right</source>
          <target state="translated">小于或斜于等于右上角有点的地方</target>
        </trans-unit>
        <trans-unit id="6028a8d9f280a98196c48a63aa608f95a5002030" translate="yes" xml:space="preserve">
          <source>Less-Than Or Slanted Equal To With Dot Inside</source>
          <target state="translated">小于或斜于等于带点内侧。</target>
        </trans-unit>
        <trans-unit id="a654d5c89ef59a82d905f082b763c64619e9d053" translate="yes" xml:space="preserve">
          <source>Less-Than Over Equal To / Less Than Over Equal To</source>
          <target state="translated">低于等于以上/小于等于以上的部分</target>
        </trans-unit>
        <trans-unit id="3cd5d177f863b189035a69ddc7dc355152c827d7" translate="yes" xml:space="preserve">
          <source>Less-Than With Circle Inside</source>
          <target state="translated">小于圆圈内侧</target>
        </trans-unit>
        <trans-unit id="f5f82e2a0d06ff7d257c2989f80e7e63fdfcc406" translate="yes" xml:space="preserve">
          <source>Less-Than With Dot / Less Than With Dot</source>
          <target state="translated">小于点/小于点</target>
        </trans-unit>
        <trans-unit id="e8d2d29dc34fdea25f29dead5f22ec63a8a158fd" translate="yes" xml:space="preserve">
          <source>Less-Than With Question Mark Above</source>
          <target state="translated">小于,上面有问号</target>
        </trans-unit>
        <trans-unit id="98215ce56f609905c57ffcaa9fd368bd9a664b9f" translate="yes" xml:space="preserve">
          <source>Less-than comparison operator. Falls back to &lt;a href=&quot;../base/index#Base.isless&quot;&gt;&lt;code&gt;isless&lt;/code&gt;&lt;/a&gt;. Because of the behavior of floating-point NaN values, this operator implements a partial order.</source>
          <target state="translated">小于比较运算符。回落到&lt;a href=&quot;../base/index#Base.isless&quot;&gt; &lt;code&gt;isless&lt;/code&gt; &lt;/a&gt;。由于浮点NaN值的行为，此运算符实现了部分顺序。</target>
        </trans-unit>
        <trans-unit id="6b17017e386fc2cfd407cedbcefdc1a56529ec61" translate="yes" xml:space="preserve">
          <source>Less-than-or-equals comparison operator. Falls back to &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt;.</source>
          <target state="translated">小于等于比较运算符。回落到 &lt;code&gt;(x &amp;lt; y) | (x == y)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7223264dca9d07a87ce4ee4c3f4c203febf05b3c" translate="yes" xml:space="preserve">
          <source>Let Blocks</source>
          <target state="translated">让块</target>
        </trans-unit>
        <trans-unit id="7a4b5aa264a12a56a65beda1765bedfd0c0c5b4a" translate="yes" xml:space="preserve">
          <source>Let us explore the low level construct &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; to understand how task switching works. &lt;code&gt;yieldto(task,value)&lt;/code&gt; suspends the current task, switches to the specified &lt;code&gt;task&lt;/code&gt;, and causes that task's last &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; call to return the specified &lt;code&gt;value&lt;/code&gt;. Notice that &lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt;&lt;code&gt;yieldto&lt;/code&gt;&lt;/a&gt; is the only operation required to use task-style control flow; instead of calling and returning we are always just switching to a different task. This is why this feature is also called &quot;symmetric coroutines&quot;; each task is switched to and from using the same mechanism.</source>
          <target state="translated">让我们探索底层构造的&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;以了解任务切换的工作原理。 &lt;code&gt;yieldto(task,value)&lt;/code&gt; 挂起当前任务，切换到指定的 &lt;code&gt;task&lt;/code&gt; ，并使该任务的最后一个&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;调用返回指定的 &lt;code&gt;value&lt;/code&gt; 。注意&lt;a href=&quot;../../base/parallel/index#Base.yieldto&quot;&gt; &lt;code&gt;yieldto&lt;/code&gt; &lt;/a&gt;是使用任务样式的控制流所需的唯一操作。而不是调用并返回，我们始终只是切换到其他任务。这就是为什么此功能也称为&amp;ldquo;对称协程&amp;rdquo;的原因。每个任务都使用相同的机制来回切换。</target>
        </trans-unit>
        <trans-unit id="67246c5c8735d7e8441000a86e3cb7192688e453" translate="yes" xml:space="preserve">
          <source>Let us illustrate this principle with the logical &quot;or&quot; operator &lt;code&gt;|&lt;/code&gt;. Following the rules of boolean logic, if one of the operands is &lt;code&gt;true&lt;/code&gt;, the value of the other operand does not have an influence on the result, which will always be &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">让我们用逻辑&amp;ldquo;或&amp;rdquo;运算符说明这一原理 &lt;code&gt;|&lt;/code&gt; 。遵循布尔逻辑规则，如果一个操作数为 &lt;code&gt;true&lt;/code&gt; ，则另一个操作数的值不会影响结果，该结果将始终为 &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5989117a8f456835a0f1be3863e508fbd507b1e1" translate="yes" xml:space="preserve">
          <source>Let us operate on this array simultaneously using 4 threads. We'll have each thread write its thread ID into each location.</source>
          <target state="translated">让我们用4个线程同时对这个数组进行操作。我们将让每个线程把它的线程ID写入每个位置。</target>
        </trans-unit>
        <trans-unit id="6183c7c4afe71ef5b8231a90fffb2c5978fa45fa" translate="yes" xml:space="preserve">
          <source>Let's consider some of the abstract types that make up Julia's numerical hierarchy:</source>
          <target state="translated">让我们考虑一下构成Julia数值层次结构的一些抽象类型。</target>
        </trans-unit>
        <trans-unit id="01a2c551d7b29ee2d56fdf88a3feffacdd9828c3" translate="yes" xml:space="preserve">
          <source>Let's define a producer task, which produces values via the &lt;code&gt;put!&lt;/code&gt; call. To consume values, we need to schedule the producer to run in a new task. A special &lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;&lt;/a&gt; constructor which accepts a 1-arg function as an argument can be used to run a task bound to a channel. We can then &lt;code&gt;take!&lt;/code&gt; values repeatedly from the channel object:</source>
          <target state="translated">让我们定义一个生产者任务，该任务通过 &lt;code&gt;put!&lt;/code&gt; 产生价值！呼叫。要消耗值，我们需要安排生产者在新任务中运行。接受1-arg函数作为参数的特殊&lt;a href=&quot;../../base/parallel/index#Base.Channel&quot;&gt; &lt;code&gt;Channel&lt;/code&gt; &lt;/a&gt;构造函数可用于运行绑定到Channel的任务。然后，我们可以 &lt;code&gt;take!&lt;/code&gt; 通道对象重复的值：</target>
        </trans-unit>
        <trans-unit id="d05f0c73a4331f267ffda8d64fbec89860b0ccf5" translate="yes" xml:space="preserve">
          <source>Let's dig into the fact that the &lt;code&gt;for&lt;/code&gt; loop body has its own scope for a second by writing a slightly more verbose variation which we'll call &lt;code&gt;sum_to&amp;prime;&lt;/code&gt;, in which we save the sum &lt;code&gt;s + i&lt;/code&gt; in a variable &lt;code&gt;t&lt;/code&gt; before updating &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">让我们深入研究以下事实： &lt;code&gt;for&lt;/code&gt; 循环体具有自己的作用域，方法是编写一个稍微冗长的变体，我们将其称为 &lt;code&gt;sum_to&amp;prime;&lt;/code&gt; ，在该变体中，在更新 &lt;code&gt;s&lt;/code&gt; 之前将和 &lt;code&gt;s + i&lt;/code&gt; 保存在变量 &lt;code&gt;t&lt;/code&gt; 中：</target>
        </trans-unit>
        <trans-unit id="9df15ca83d0947dbf1751a612bf2340b275f4ac4" translate="yes" xml:space="preserve">
          <source>Let's first discuss the two positional arguments, and later the keyword arguments:</source>
          <target state="translated">我们先讨论两个位置论点,后面再讨论关键词论点。</target>
        </trans-unit>
        <trans-unit id="6418114a78265d3efb7f605d5f750649435cf8a7" translate="yes" xml:space="preserve">
          <source>Let's jump right in with a simple example involving TCP sockets. This functionality is in a standard library package called &lt;code&gt;Sockets&lt;/code&gt;. Let's first create a simple server:</source>
          <target state="translated">让我们直接看一个涉及TCP套接字的简单示例。此功能在称为 &lt;code&gt;Sockets&lt;/code&gt; 的标准库包中。首先创建一个简单的服务器：</target>
        </trans-unit>
        <trans-unit id="9d1274ee3906a8208793462a30f6e28d1823afa2" translate="yes" xml:space="preserve">
          <source>Let's move onto some more ambiguous cases covered by the soft scope rule. We'll explore this by extracting the bodies of the &lt;code&gt;greet&lt;/code&gt; and &lt;code&gt;sum_to&amp;prime;&lt;/code&gt; functions into soft scope contexts. First, let's put the body of &lt;code&gt;greet&lt;/code&gt; in a &lt;code&gt;for&lt;/code&gt; loop&amp;mdash;which is soft, rather than hard&amp;mdash;and evaluate it in the REPL:</source>
          <target state="translated">让我们继续讨论一下软作用域规则所涵盖的一些更模糊的情况。我们将通过将 &lt;code&gt;greet&lt;/code&gt; 和 &lt;code&gt;sum_to&amp;prime;&lt;/code&gt; 函数的主体提取到软作用域上下文中来进行探索。首先，让我们将 &lt;code&gt;greet&lt;/code&gt; 放入一个 &lt;code&gt;for&lt;/code&gt; 循环中（它是软的，而不是硬的），并在REPL中对其进行评估：</target>
        </trans-unit>
        <trans-unit id="1122c34c203c69e459bc638ef4ea480a5b8130e2" translate="yes" xml:space="preserve">
          <source>Let's say you want to create an &lt;code&gt;N&lt;/code&gt;-dimensional array that has size 3 along each axis. Such arrays can be created like this:</source>
          <target state="translated">假设您要创建一个 &lt;code&gt;N&lt;/code&gt; 维数组，每个轴的大小为3。这样的数组可以这样创建：</target>
        </trans-unit>
        <trans-unit id="8748cf620bf48795063bf239466aafbea94faee0" translate="yes" xml:space="preserve">
          <source>Let's set up a new environment so we may experiment. To set the active environment, use &lt;code&gt;activate&lt;/code&gt;:</source>
          <target state="translated">让我们建立一个新的环境，以便我们进行实验。要设置活动环境，请使用 &lt;code&gt;activate&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="c76b2235d981c65461960877af26f1dbe64a8ee1" translate="yes" xml:space="preserve">
          <source>Let's start with a simple example of a C wrapper that returns a &lt;code&gt;Ptr&lt;/code&gt; type:</source>
          <target state="translated">让我们从返回 &lt;code&gt;Ptr&lt;/code&gt; 类型的C包装器的简单示例开始：</target>
        </trans-unit>
        <trans-unit id="1df8e39d6c6cb9f345698606b67ad54d1b7ae227" translate="yes" xml:space="preserve">
          <source>Let's take the following example: we implement a &lt;code&gt;Die&lt;/code&gt; type, with a variable number &lt;code&gt;n&lt;/code&gt; of sides, numbered from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. We want &lt;code&gt;rand(Die)&lt;/code&gt; to produce a &lt;code&gt;Die&lt;/code&gt; with a random number of up to 20 sides (and at least 4):</source>
          <target state="translated">让我们以下面的示例为例：我们实现一个 &lt;code&gt;Die&lt;/code&gt; 类型，其侧面的变量数为 &lt;code&gt;n&lt;/code&gt; ，从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 进行编号。我们希望 &lt;code&gt;rand(Die)&lt;/code&gt; 生成一个随机数最多为20面（且至少为4面）的 &lt;code&gt;Die&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="71ba98ed632749544ae49e36ff83983c01e402b0" translate="yes" xml:space="preserve">
          <source>Let's take the following example: we implement a &lt;code&gt;Die&lt;/code&gt; type, with a variable number &lt;code&gt;n&lt;/code&gt; of sides, numbered from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;n&lt;/code&gt;. We want &lt;code&gt;rand(Die)&lt;/code&gt; to produce a die with a random number of up to 20 sides (and at least 4):</source>
          <target state="translated">让我们以下面的示例为例：我们实现一个 &lt;code&gt;Die&lt;/code&gt; 类型，其边数为 &lt;code&gt;n&lt;/code&gt; ，从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 进行编号。我们希望 &lt;code&gt;rand(Die)&lt;/code&gt; 产生一个随机数最多20面（至少4面）的模具：</target>
        </trans-unit>
        <trans-unit id="f3530d6febbeb3af1b1c75ff5864143019e5c7e9" translate="yes" xml:space="preserve">
          <source>Let's try it out. First we modify the file at &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; and add a simple function:</source>
          <target state="translated">让我们尝试一下。首先，我们在 &lt;code&gt;tutorial/dev/Example/src/Example.jl&lt;/code&gt; 中修改文件，并添加一个简单的函数：</target>
        </trans-unit>
        <trans-unit id="d9f3d5d59e7aa3d7e910a3c03fcdc92c22584287" translate="yes" xml:space="preserve">
          <source>Let's try this out. Starting with &lt;code&gt;julia -p n&lt;/code&gt; provides &lt;code&gt;n&lt;/code&gt; worker processes on the local machine. Generally it makes sense for &lt;code&gt;n&lt;/code&gt; to equal the number of CPU threads (logical cores) on the machine. Note that the &lt;code&gt;-p&lt;/code&gt; argument implicitly loads module &lt;code&gt;Distributed&lt;/code&gt;.</source>
          <target state="translated">让我们尝试一下。以 &lt;code&gt;julia -p n&lt;/code&gt; ，在本地计算机上提供了 &lt;code&gt;n&lt;/code&gt; 个工作进程。通常，将 &lt;code&gt;n&lt;/code&gt; 等于机器上的CPU线程（逻辑内核）数量是有意义的。注意， &lt;code&gt;-p&lt;/code&gt; 参数隐式加载模块 &lt;code&gt;Distributed&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b446a4746adc500fc9039decd4f98dd1f28494be" translate="yes" xml:space="preserve">
          <source>Let's verify there are 4 threads at our disposal.</source>
          <target state="translated">让我们来验证一下有4条线在我们手上。</target>
        </trans-unit>
        <trans-unit id="a857063978f61fa4bd1f41b325d1aa75b04e9d5e" translate="yes" xml:space="preserve">
          <source>Let's work a simple example using our native threads. Let us create an array of zeros:</source>
          <target state="translated">让我们用我们的本地线程来做一个简单的例子。让我们创建一个0数组。</target>
        </trans-unit>
        <trans-unit id="01ca76f755ba1afdf88a6b78abbe4839783a3a4d" translate="yes" xml:space="preserve">
          <source>Let's work with a simple test case:</source>
          <target state="translated">让我们用一个简单的测试案例来工作。</target>
        </trans-unit>
        <trans-unit id="7dd0810d04c75d2aee9682c9c0e389c01969f9df" translate="yes" xml:space="preserve">
          <source>Lets start Julia with 4 threads:</source>
          <target state="translated">让我们用4条线开始朱莉娅。</target>
        </trans-unit>
        <trans-unit id="ee8556898b2b9f9b2564fd6a9f4e2eeba1821894" translate="yes" xml:space="preserve">
          <source>LibGit2</source>
          <target state="translated">LibGit2</target>
        </trans-unit>
        <trans-unit id="76b53f15ef89ba2bfb2e2f62f34201129332b916" translate="yes" xml:space="preserve">
          <source>Libc</source>
          <target state="translated">Libc</target>
        </trans-unit>
        <trans-unit id="60368a5f4bc52be83598e88566f2089a47f21a35" translate="yes" xml:space="preserve">
          <source>Libc.FormatMessage()</source>
          <target state="translated">Libc.FormatMessage()</target>
        </trans-unit>
        <trans-unit id="41585a339c2503f89fb1f9aa92fdc8fb9adcdd4d" translate="yes" xml:space="preserve">
          <source>Libc.GetLastError()</source>
          <target state="translated">Libc.GetLastError()</target>
        </trans-unit>
        <trans-unit id="a85a19153d65e87480d301d0383428f7125ed99b" translate="yes" xml:space="preserve">
          <source>Libc.RawFD</source>
          <target state="translated">Libc.RawFD</target>
        </trans-unit>
        <trans-unit id="b9d6e139e984d53b5bcde695421e487faedd7c51" translate="yes" xml:space="preserve">
          <source>Libc.TmStruct</source>
          <target state="translated">Libc.TmStruct</target>
        </trans-unit>
        <trans-unit id="bc871e61e3ca821c6cfe4accdd2d8e0693a588e4" translate="yes" xml:space="preserve">
          <source>Libc.calloc()</source>
          <target state="translated">Libc.calloc()</target>
        </trans-unit>
        <trans-unit id="1f4d269c85f0cdd9201cbed97992b84adebdf595" translate="yes" xml:space="preserve">
          <source>Libc.errno()</source>
          <target state="translated">Libc.errno()</target>
        </trans-unit>
        <trans-unit id="0848e3c16acc14bb2ec577b598d650c18e77b315" translate="yes" xml:space="preserve">
          <source>Libc.flush_cstdio()</source>
          <target state="translated">Libc.flush_cstdio()</target>
        </trans-unit>
        <trans-unit id="3ce556c3b59d7aa2c3af19ecb0b6877f650470df" translate="yes" xml:space="preserve">
          <source>Libc.free()</source>
          <target state="translated">Libc.free()</target>
        </trans-unit>
        <trans-unit id="b0704af4d5eaf445364159bc7d46c36ac0dd99b9" translate="yes" xml:space="preserve">
          <source>Libc.gethostname()</source>
          <target state="translated">Libc.gethostname()</target>
        </trans-unit>
        <trans-unit id="34f021f7afa28bfc40d0c964b655d57537eeeb56" translate="yes" xml:space="preserve">
          <source>Libc.getpid()</source>
          <target state="translated">Libc.getpid()</target>
        </trans-unit>
        <trans-unit id="b3ae4ddcce36b5e6214d98b8603cc79d72f7795f" translate="yes" xml:space="preserve">
          <source>Libc.malloc()</source>
          <target state="translated">Libc.malloc()</target>
        </trans-unit>
        <trans-unit id="755d16743ca50b746f3e9f832dc2d5638fe7b1d4" translate="yes" xml:space="preserve">
          <source>Libc.realloc()</source>
          <target state="translated">Libc.realloc()</target>
        </trans-unit>
        <trans-unit id="189c473490df982a84b81ce12725d8d1b054705a" translate="yes" xml:space="preserve">
          <source>Libc.strerror()</source>
          <target state="translated">Libc.strerror()</target>
        </trans-unit>
        <trans-unit id="9c2a2e1ec6af2d38549c677ba7248e856a349879" translate="yes" xml:space="preserve">
          <source>Libc.strftime()</source>
          <target state="translated">Libc.strftime()</target>
        </trans-unit>
        <trans-unit id="291439a5e7bded77e555ba7822b85155ea0e9ab9" translate="yes" xml:space="preserve">
          <source>Libc.strptime()</source>
          <target state="translated">Libc.strptime()</target>
        </trans-unit>
        <trans-unit id="50e854ed1dcc836eb5e225047ee11442a2f80cd3" translate="yes" xml:space="preserve">
          <source>Libc.systemsleep()</source>
          <target state="translated">Libc.systemsleep()</target>
        </trans-unit>
        <trans-unit id="81d6424efbc87c9c17b0813b0c148152bd3c2475" translate="yes" xml:space="preserve">
          <source>Libc.time()</source>
          <target state="translated">Libc.time()</target>
        </trans-unit>
        <trans-unit id="f9ac7f64b772b55f84e761baea56c702c55005b2" translate="yes" xml:space="preserve">
          <source>Libdl.RTLD_NOW</source>
          <target state="translated">Libdl.RTLD_NOW</target>
        </trans-unit>
        <trans-unit id="754e38c44e40a9e9cb516d0f693c9b5afa0d7ec7" translate="yes" xml:space="preserve">
          <source>Libdl.dlclose()</source>
          <target state="translated">Libdl.dlclose()</target>
        </trans-unit>
        <trans-unit id="b20c01d11dde97a5fa90df2ec685adbcf15207ab" translate="yes" xml:space="preserve">
          <source>Libdl.dlext</source>
          <target state="translated">Libdl.dlext</target>
        </trans-unit>
        <trans-unit id="bbe848e2a374e3e28b9be1468210bde354760df9" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen()</source>
          <target state="translated">Libdl.dlopen()</target>
        </trans-unit>
        <trans-unit id="bc44712bf06d7cde2930672cea24ac5283dc04d2" translate="yes" xml:space="preserve">
          <source>Libdl.dlopen_e()</source>
          <target state="translated">Libdl.dlopen_e()</target>
        </trans-unit>
        <trans-unit id="f76c025cd327748a8ae48ab21c1d0d6937ee6cf3" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym()</source>
          <target state="translated">Libdl.dlsym()</target>
        </trans-unit>
        <trans-unit id="ddc83875e28b579f9ad7f02bee458a0c03e115cf" translate="yes" xml:space="preserve">
          <source>Libdl.dlsym_e()</source>
          <target state="translated">Libdl.dlsym_e()</target>
        </trans-unit>
        <trans-unit id="e5858af9f095388c617c420aefd6c16e0594c3bf" translate="yes" xml:space="preserve">
          <source>Libdl.find_library()</source>
          <target state="translated">Libdl.find_library()</target>
        </trans-unit>
        <trans-unit id="cb8e2b307865af7fc3116bd1827bf102132b7b87" translate="yes" xml:space="preserve">
          <source>Libra</source>
          <target state="translated">Libra</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">根据麻省理工学院许可证授权。</target>
        </trans-unit>
        <trans-unit id="8a1bb5e870bb9b77202596bab439b6db423dbba2" translate="yes" xml:space="preserve">
          <source>Light Rail</source>
          <target state="translated">轻轨</target>
        </trans-unit>
        <trans-unit id="4944819e2ca85d61a3c9e24619e3eb246b5a52a9" translate="yes" xml:space="preserve">
          <source>Light Shade</source>
          <target state="translated">灯罩</target>
        </trans-unit>
        <trans-unit id="9921ca32d9a43716da2c222cd03f37ec5fd109a5" translate="yes" xml:space="preserve">
          <source>Lightweight &quot;green&quot; threading (&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;coroutines&lt;/a&gt;)</source>
          <target state="translated">轻量级的&amp;ldquo;绿色&amp;rdquo;线程（&lt;a href=&quot;https://en.wikipedia.org/wiki/Coroutine&quot;&gt;协程&lt;/a&gt;）</target>
        </trans-unit>
        <trans-unit id="8a26ac5926eeae89368f7fb44a40e4b026751c42" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt;, but store the result of &lt;code&gt;broadcast(f, As...)&lt;/code&gt; in the &lt;code&gt;dest&lt;/code&gt; array. Note that &lt;code&gt;dest&lt;/code&gt; is only used to store the result, and does not supply arguments to &lt;code&gt;f&lt;/code&gt; unless it is also listed in the &lt;code&gt;As&lt;/code&gt;, as in &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; to perform &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt;.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.Broadcast.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt;，但是将 &lt;code&gt;broadcast(f, As...)&lt;/code&gt; 的结果存储在 &lt;code&gt;dest&lt;/code&gt; 数组中。请注意， &lt;code&gt;dest&lt;/code&gt; 仅用于存储结果，并且不提供 &lt;code&gt;f&lt;/code&gt; 的参数，除非它也在 &lt;code&gt;As&lt;/code&gt; 中列出，如 &lt;code&gt;broadcast!(f, A, A, B)&lt;/code&gt; 执行 &lt;code&gt;A[:] = broadcast(f, A, B)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b1bc834338e49af8951a520f98a93394195b34a0" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions for people who neither own the file nor are a member of the group owning the file</source>
          <target state="translated">像&lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; &lt;/a&gt;一样，但获得了既不拥有文件也不是拥有文件的组成员的权限</target>
        </trans-unit>
        <trans-unit id="52da4e2a0d663a1dbba38c505be636c82ff3a124" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt;&lt;code&gt;uperm&lt;/code&gt;&lt;/a&gt; but gets the permissions of the group owning the file.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.Filesystem.uperm&quot;&gt; &lt;code&gt;uperm&lt;/code&gt; ,&lt;/a&gt;但获得拥有该文件的组的权限。</target>
        </trans-unit>
        <trans-unit id="28e1f410620d4fc1c47d7926e96c9bea23f8d4c1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt;&lt;code&gt;partialsortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt; the same size as &lt;code&gt;v&lt;/code&gt;, which is used to store (a permutation of) the indices of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt; &lt;code&gt;partialsortperm&lt;/code&gt; &lt;/a&gt;类似，但是接受与 &lt;code&gt;v&lt;/code&gt; 大小相同的预分配索引向量 &lt;code&gt;ix&lt;/code&gt; ,该向量用于存储 &lt;code&gt;v&lt;/code&gt; 的索引（的排列）。</target>
        </trans-unit>
        <trans-unit id="55b69ac4b886c93cd981119d2156a08505ea6f20" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt;&lt;code&gt;partialsortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(ix)&lt;/code&gt;.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.Sort.partialsortperm&quot;&gt; &lt;code&gt;partialsortperm&lt;/code&gt; &lt;/a&gt;，但是接受预分配的索引向量 &lt;code&gt;ix&lt;/code&gt; 。如果 &lt;code&gt;initialized&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; （默认值），则将 &lt;code&gt;ix&lt;/code&gt; 初始化为包含值 &lt;code&gt;1:length(ix)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="529e4e84127591bc458006a7c31028da87258a93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.asyncmap&quot;&gt;&lt;code&gt;asyncmap&lt;/code&gt;&lt;/a&gt;, but stores output in &lt;code&gt;results&lt;/code&gt; rather than returning a collection.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.asyncmap&quot;&gt; &lt;code&gt;asyncmap&lt;/code&gt; &lt;/a&gt;，但是将输出存储在 &lt;code&gt;results&lt;/code&gt; 而不是返回集合。</target>
        </trans-unit>
        <trans-unit id="06d62bd10c05ce2bf6e378f3ac0cebfd0dc1f43e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, except reads code from the given string rather than from a file.</source>
          <target state="translated">与&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;一样，区别在于从给定的字符串而不是文件中读取代码。</target>
        </trans-unit>
        <trans-unit id="33fc1f575b86086215aa1689af4abbedb592d014" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt;, but stores the result in &lt;code&gt;destination&lt;/code&gt; rather than a new collection. &lt;code&gt;destination&lt;/code&gt; must be at least as large as the first collection.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt;，但是将结果存储在 &lt;code&gt;destination&lt;/code&gt; 而不是新集合中。 &lt;code&gt;destination&lt;/code&gt; 必须至少与第一个集合一样大。</target>
        </trans-unit>
        <trans-unit id="9053e0f6dd39d888ac2c2e819878de129f87dfec" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity, as in &lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldl&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">就像&lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt;一样，但是具有保证的左关联性，就像在&lt;a href=&quot;#Base.foldl-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldl&lt;/code&gt; 中一样&lt;/a&gt;。如果提供，关键字参数 &lt;code&gt;init&lt;/code&gt; 将只使用一次。通常，有必要提供 &lt;code&gt;init&lt;/code&gt; 来处理空集合。</target>
        </trans-unit>
        <trans-unit id="ffe977f18117519aca83d726747101ffed876b72" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt;&lt;code&gt;mapreduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity, as in &lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;foldr&lt;/code&gt;&lt;/a&gt;. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.mapreduce-Tuple%7BAny,Any,Any%7D&quot;&gt; &lt;code&gt;mapreduce&lt;/code&gt; &lt;/a&gt;，但是具有正确的关联性，如&lt;a href=&quot;#Base.foldr-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;foldr&lt;/code&gt; 中所示&lt;/a&gt;。如果提供，关键字参数 &lt;code&gt;init&lt;/code&gt; 将只使用一次。通常，有必要提供 &lt;code&gt;init&lt;/code&gt; 来处理空集合。</target>
        </trans-unit>
        <trans-unit id="9d8eaa8363c2e7fc8a90587868e4968a125caadc" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.parse&quot;&gt;&lt;code&gt;parse&lt;/code&gt;&lt;/a&gt;, but returns either a value of the requested type, or &lt;a href=&quot;../constants/index#Core.nothing&quot;&gt;&lt;code&gt;nothing&lt;/code&gt;&lt;/a&gt; if the string does not contain a valid number.</source>
          <target state="translated">像&lt;a href=&quot;#Base.parse&quot;&gt; &lt;code&gt;parse&lt;/code&gt; &lt;/a&gt;，但要么返回请求类型的值，或者&lt;a href=&quot;../constants/index#Core.nothing&quot;&gt; &lt;code&gt;nothing&lt;/code&gt; &lt;/a&gt;，如果字符串不包含有效数字。</target>
        </trans-unit>
        <trans-unit id="51eaec3c8abd237c8d9e9bba6cf07e3a4cb08010" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt;&lt;code&gt;permute!&lt;/code&gt;&lt;/a&gt;, but the inverse of the given permutation is applied.</source>
          <target state="translated">喜欢&lt;a href=&quot;#Base.permute!-Tuple%7BAny,AbstractArray%7BT,1%7D%20where%20T%7D&quot;&gt; &lt;code&gt;permute!&lt;/code&gt; &lt;/a&gt;，但应用给定排列的倒数。</target>
        </trans-unit>
        <trans-unit id="4756a006313f096261885c0ef2037e8fe0a50c17" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt;，但对于&lt;a href=&quot;#Base.stderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="f085d340882a97bb66329f21bdf7b61cf3ba9878" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;. Note that the order of the return tuple is still &lt;code&gt;(rd, wr)&lt;/code&gt;, i.e. data to be read from &lt;a href=&quot;#Base.stdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; may be written to &lt;code&gt;wr&lt;/code&gt;.</source>
          <target state="translated">像&lt;a href=&quot;#Base.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout&lt;/code&gt; &lt;/a&gt;一样，但是对于&lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;。请注意，返回元组的顺序仍然是 &lt;code&gt;(rd, wr)&lt;/code&gt; ，即可以将从&lt;a href=&quot;#Base.stdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt;读取的数据写入 &lt;code&gt;wr&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5f5dd7f815a4d7bf1a89e4740bb5b8ac9a464da9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed left associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;，但是保证了左联想性。如果提供，关键字参数 &lt;code&gt;init&lt;/code&gt; 将只使用一次。通常，有必要提供 &lt;code&gt;init&lt;/code&gt; 来处理空集合。</target>
        </trans-unit>
        <trans-unit id="024595a61bd923552b757965d3ba72515fa95986" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but with guaranteed right associativity. If provided, the keyword argument &lt;code&gt;init&lt;/code&gt; will be used exactly once. In general, it will be necessary to provide &lt;code&gt;init&lt;/code&gt; to work with empty collections.</source>
          <target state="translated">像&lt;a href=&quot;#Base.reduce-Tuple%7BAny,Any%7D&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt;一样，但是具有正确的关联性。如果提供，关键字参数 &lt;code&gt;init&lt;/code&gt; 将只使用一次。通常，有必要提供 &lt;code&gt;init&lt;/code&gt; 来处理空集合。</target>
        </trans-unit>
        <trans-unit id="1ef0876ab486f437b72ce65e44751d3b6dbccac7" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.sortperm&quot;&gt;&lt;code&gt;sortperm&lt;/code&gt;&lt;/a&gt;, but accepts a preallocated index vector &lt;code&gt;ix&lt;/code&gt;. If &lt;code&gt;initialized&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default), &lt;code&gt;ix&lt;/code&gt; is initialized to contain the values &lt;code&gt;1:length(v)&lt;/code&gt;.</source>
          <target state="translated">类似于&lt;a href=&quot;#Base.sortperm&quot;&gt; &lt;code&gt;sortperm&lt;/code&gt; &lt;/a&gt;，但是接受预分配的索引向量 &lt;code&gt;ix&lt;/code&gt; 。如果 &lt;code&gt;initialized&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; （默认值），则将 &lt;code&gt;ix&lt;/code&gt; 初始化为包含值 &lt;code&gt;1:length(v)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="08026f6d5cc67e6a499233d241ca672fd865f4fa" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt;, but for symbolic links gets the info for the link itself rather than the file it refers to. This function must be called on a file path rather than a file object or a file descriptor.</source>
          <target state="translated">像&lt;a href=&quot;#Base.stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt;一样，但是对于符号链接，它获取链接本身的信息，而不是它所引用的文件。必须在文件路径而不是文件对象或文件描述符上调用此函数。</target>
        </trans-unit>
        <trans-unit id="f60e04278b9015f6c3e9ffaf7e10b12cd6419309" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Base.systemerror&quot;&gt;&lt;code&gt;systemerror&lt;/code&gt;&lt;/a&gt;, but for Windows API functions that use &lt;a href=&quot;../libc/index#Base.Libc.GetLastError&quot;&gt;&lt;code&gt;GetLastError&lt;/code&gt;&lt;/a&gt; to return an error code instead of setting &lt;a href=&quot;../libc/index#Base.Libc.errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">与&lt;a href=&quot;#Base.systemerror&quot;&gt; &lt;code&gt;systemerror&lt;/code&gt; &lt;/a&gt;类似，但对于Windows API函数，该函数使用&lt;a href=&quot;../libc/index#Base.Libc.GetLastError&quot;&gt; &lt;code&gt;GetLastError&lt;/code&gt; &lt;/a&gt;返回错误代码，而不是设置&lt;a href=&quot;../libc/index#Base.Libc.errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt;。</target>
        </trans-unit>
        <trans-unit id="b3086501e29c75ea565e72a0019576b980b02fe5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Random.randsubseq&quot;&gt;&lt;code&gt;randsubseq&lt;/code&gt;&lt;/a&gt;, but the results are stored in &lt;code&gt;S&lt;/code&gt; (which is resized as needed).</source>
          <target state="translated">和&lt;a href=&quot;#Random.randsubseq&quot;&gt; &lt;code&gt;randsubseq&lt;/code&gt; &lt;/a&gt;一样，但是结果存储在 &lt;code&gt;S&lt;/code&gt; 中（根据需要调整大小）。</target>
        </trans-unit>
        <trans-unit id="eb969f16d7c8b092d782534c60f5aa57438f02b4" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#Statistics.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, but may overwrite the input vector.</source>
          <target state="translated">类似于&lt;a href=&quot;#Statistics.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt;，但可能会覆盖输入向量。</target>
        </trans-unit>
        <trans-unit id="c740cd8f4daa963edb800319e0b46fdd4c9b8a9e" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent array &lt;code&gt;A&lt;/code&gt; with the given indices instead of making a copy. Calling &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt;&lt;code&gt;setindex!&lt;/code&gt;&lt;/a&gt; on the returned &lt;code&gt;SubArray&lt;/code&gt; computes the indices to the parent array on the fly without checking bounds.</source>
          <target state="translated">类似于&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;，但是返回具有给定索引的父数组 &lt;code&gt;A&lt;/code&gt; 的视图，而不是进行复制。调用&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;../collections/index#Base.setindex!&quot;&gt; &lt;code&gt;setindex!&lt;/code&gt; &lt;/a&gt;在返回的 &lt;code&gt;SubArray&lt;/code&gt; 上，无需检查边界即可动态计算父数组的索引。</target>
        </trans-unit>
        <trans-unit id="a4ecbe47eb2e0c87296b762b01d3e9398f50b6c5" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;../collections/index#Base.getindex&quot;&gt;&lt;code&gt;getindex&lt;/code&gt;&lt;/a&gt;, but returns a view into the parent string &lt;code&gt;s&lt;/code&gt; within range &lt;code&gt;i:j&lt;/code&gt; or &lt;code&gt;r&lt;/code&gt; respectively instead of making a copy.</source>
          <target state="translated">类似于&lt;a href=&quot;../collections/index#Base.getindex&quot;&gt; &lt;code&gt;getindex&lt;/code&gt; &lt;/a&gt;，但返回分别在 &lt;code&gt;i:j&lt;/code&gt; 或 &lt;code&gt;r&lt;/code&gt; 范围内的父字符串 &lt;code&gt;s&lt;/code&gt; 的视图，而不是进行复制。</target>
        </trans-unit>
        <trans-unit id="c974955b45097854e43f11799b1b6bcc9d8f3eee" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;SamplerDie&lt;/code&gt;, any custom sampler must be a subtype of &lt;code&gt;Sampler{T}&lt;/code&gt; where &lt;code&gt;T&lt;/code&gt; is the type of the generated values. Note that &lt;code&gt;SamplerSimple(x, data) isa Sampler{eltype(x)}&lt;/code&gt;, so this constrains what the first argument to &lt;code&gt;SamplerSimple&lt;/code&gt; can be (it's recommended to use &lt;code&gt;SamplerSimple&lt;/code&gt; like in the &lt;code&gt;Die&lt;/code&gt; example, where &lt;code&gt;x&lt;/code&gt; is simply forwarded while defining a &lt;code&gt;Sampler&lt;/code&gt; method). Similarly, &lt;code&gt;SamplerTrivial(x) isa Sampler{eltype(x)}&lt;/code&gt;.</source>
          <target state="translated">像 &lt;code&gt;SamplerDie&lt;/code&gt; 一样，任何自定义采样器都必须是 &lt;code&gt;Sampler{T}&lt;/code&gt; 的子类型，其中 &lt;code&gt;T&lt;/code&gt; 是所生成值的类型。请注意， &lt;code&gt;SamplerSimple(x, data) isa Sampler{eltype(x)}&lt;/code&gt; ，因此这限制了 &lt;code&gt;SamplerSimple&lt;/code&gt; 的第一个参数是什么（建议像在 &lt;code&gt;Die&lt;/code&gt; 示例中一样使用 &lt;code&gt;SamplerSimple&lt;/code&gt; ，其中 &lt;code&gt;x&lt;/code&gt; 在定义 &lt;code&gt;Sampler&lt;/code&gt; 方法时简单地转发）。同样， &lt;code&gt;SamplerTrivial(x) isa Sampler{eltype(x)}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="807404638eb67f1a49cc813e53a998bea5df9d33" translate="yes" xml:space="preserve">
          <source>Like C and Java, but unlike most dynamic languages, Julia has a first-class type for representing a single character, called &lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt;&lt;code&gt;AbstractChar&lt;/code&gt;&lt;/a&gt;. The built-in &lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt; subtype of &lt;code&gt;AbstractChar&lt;/code&gt; is a 32-bit primitive type that can represent any Unicode character (and which is based on the UTF-8 encoding).</source>
          <target state="translated">像C和Java一样，但与大多数动态语言不同，Julia具有用于表示单个字符的一流类型，称为&lt;a href=&quot;../../base/strings/index#Core.AbstractChar&quot;&gt; &lt;code&gt;AbstractChar&lt;/code&gt; &lt;/a&gt;。内置的&lt;a href=&quot;../../base/strings/index#Core.Char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt;子类型 &lt;code&gt;AbstractChar&lt;/code&gt; 是32位基本类型，可以表示任何Unicode字符（并且基于UTF-8编码）。</target>
        </trans-unit>
        <trans-unit id="b144d1ab3b4daafe713dd1906d84dd6576675e14" translate="yes" xml:space="preserve">
          <source>Like ccall, all of these arguments will be evaluated at compile-time, when the containing method is defined.</source>
          <target state="translated">和 ccall 一样,所有这些参数都将在编译时,当包含方法被定义时被评估。</target>
        </trans-unit>
        <trans-unit id="d14af23f7b07876d0e17dec387b3e911da07b564" translate="yes" xml:space="preserve">
          <source>Like many languages, Julia does not always allow operations on vectors of different lengths, unlike R where the vectors only need to share a common index range. For example, &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; is valid R but the equivalent &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; will throw an error in Julia.</source>
          <target state="translated">像许多语言一样，Julia并不总是允许对不同长度的向量进行运算，这与R中的向量只需要共享一个公共索引范围不同。例如， &lt;code&gt;c(1, 2, 3, 4) + c(1, 2)&lt;/code&gt; 是有效的R，但是等效项 &lt;code&gt;[1, 2, 3, 4] + [1, 2]&lt;/code&gt; 将在Julia中引发错误。</target>
        </trans-unit>
        <trans-unit id="76129ab650b5177af08ad48252475d8daddeec47" translate="yes" xml:space="preserve">
          <source>Like many other environments, Julia has an &lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; function, which takes a filename and returns an &lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt;&lt;code&gt;IOStream&lt;/code&gt;&lt;/a&gt; object that you can use to read and write things from the file. For example, if we have a file, &lt;code&gt;hello.txt&lt;/code&gt;, whose contents are &lt;code&gt;Hello, World!&lt;/code&gt;:</source>
          <target state="translated">像许多其他环境一样，Julia具有一个&lt;a href=&quot;../../base/io-network/index#Base.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt;函数，该函数需要一个文件名并返回一个&lt;a href=&quot;../../base/io-network/index#Base.IOStream&quot;&gt; &lt;code&gt;IOStream&lt;/code&gt; &lt;/a&gt;对象，您可以使用该对象读取和写入文件中的内容。例如，如果我们有一个文件 &lt;code&gt;hello.txt&lt;/code&gt; ，其内容为 &lt;code&gt;Hello, World!&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1f57deb1de610f6542b69d3ee454e00aa561ce8c" translate="yes" xml:space="preserve">
          <source>Like non-standard string literals, non-standard command literals exist using a prefixed variant of the command literal syntax. The command literal &lt;code&gt;custom`literal`&lt;/code&gt; is parsed as &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt;. Julia itself does not contain any non-standard command literals, but packages can make use of this syntax. Aside from the different syntax and the &lt;code&gt;_cmd&lt;/code&gt; suffix instead of the &lt;code&gt;_str&lt;/code&gt; suffix, non-standard command literals behave exactly like non-standard string literals.</source>
          <target state="translated">像非标准字符串文字一样，使用命令文字语法的前缀变体也存在非标准命令文字。命令文字 &lt;code&gt;custom`literal`&lt;/code&gt; 被解析为 &lt;code&gt;@custom_cmd &quot;literal&quot;&lt;/code&gt; 。Julia本身不包含任何非标准命令文字，但是程序包可以使用此语法。除了不同的语法和 &lt;code&gt;_cmd&lt;/code&gt; 后缀，而不是 &lt;code&gt;_str&lt;/code&gt; 后缀，非标准指令的文字完全一样的非标准字符串文字。</target>
        </trans-unit>
        <trans-unit id="ca04337635b1b8ca769f7475dd5bb9a710a07316" translate="yes" xml:space="preserve">
          <source>Like remote references, shared arrays are also dependent on garbage collection on the creating node to release references from all participating workers. Code which creates many short lived shared array objects would benefit from explicitly finalizing these objects as soon as possible. This results in both memory and file handles mapping the shared segment being released sooner.</source>
          <target state="translated">和远程引用一样,共享数组也依赖于创建节点上的垃圾收集,以释放所有参与工作者的引用。创建许多短暂的共享数组对象的代码将受益于尽快明确地最终确定这些对象。这将导致映射共享段的内存和文件句柄都能更快释放。</target>
        </trans-unit>
        <trans-unit id="bc02118fe44dfd1db0138406f1b30a59afe69954" translate="yes" xml:space="preserve">
          <source>Likewise, the global variable &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; determines a relative path to the configuration file directory. Then Julia searches for a &lt;code&gt;startup.jl&lt;/code&gt; file at</source>
          <target state="translated">同样，全局变量 &lt;code&gt;Base.SYSCONFDIR&lt;/code&gt; 确定配置文件目录的相对路径。然后Julia在以下位置搜索 &lt;code&gt;startup.jl&lt;/code&gt; 文件</target>
        </trans-unit>
        <trans-unit id="40654ee5f02852c7196e6e2f00f07fee2fb0ef03" translate="yes" xml:space="preserve">
          <source>Limit usage of CPU features up to &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt;; set to &lt;code&gt;help&lt;/code&gt; to see the available options</source>
          <target state="translated">将CPU功能的使用限制为 &lt;code&gt;&amp;lt;target&amp;gt;&lt;/code&gt; ; 设置以 &lt;code&gt;help&lt;/code&gt; 查看可用选项</target>
        </trans-unit>
        <trans-unit id="8d96ce8bb4e79cb43743b90921151985b53e510c" translate="yes" xml:space="preserve">
          <source>LinRange</source>
          <target state="translated">LinRange</target>
        </trans-unit>
        <trans-unit id="d937e9c2df56b1e58e5b8819252e720563fa79ea" translate="yes" xml:space="preserve">
          <source>Line 3 of &lt;code&gt;myfunc&lt;/code&gt; contains the call to &lt;code&gt;maximum&lt;/code&gt;, and there were 28 (out of 80) backtraces taken here. Below that, you can see the specific places in &lt;code&gt;base/reduce.jl&lt;/code&gt; that carry out the time-consuming operations in the &lt;code&gt;maximum&lt;/code&gt; function for this type of input data.</source>
          <target state="translated">&lt;code&gt;myfunc&lt;/code&gt; 的第3行包含对 &lt;code&gt;maximum&lt;/code&gt; 的调用，并且在此处进行了28条（总共80条）回溯。下面，你可以看到具体的地方在 &lt;code&gt;base/reduce.jl&lt;/code&gt; 是进行耗时的操作的 &lt;code&gt;maximum&lt;/code&gt; 功能为这种类型的输入数据。</target>
        </trans-unit>
        <trans-unit id="677b9ff91279f2c92df14e8f98feaaad0ff02671" translate="yes" xml:space="preserve">
          <source>Line Integration Not Including The Pole</source>
          <target state="translated">不包括极点的线路整合</target>
        </trans-unit>
        <trans-unit id="aa862b80ca648d32974899a07b490c840367365f" translate="yes" xml:space="preserve">
          <source>Line Integration With Rectangular Path Around Pole</source>
          <target state="translated">带矩形路径的绕极线积分</target>
        </trans-unit>
        <trans-unit id="cd235d8e390a116750618564e9fef4ddd8d815c0" translate="yes" xml:space="preserve">
          <source>Line Integration With Semicircular Path Around Pole</source>
          <target state="translated">带半圆路径的绕极线积分法</target>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="translated">线性代数</target>
        </trans-unit>
        <trans-unit id="3ab90484838b94648400b6fcaea9c0833f594271" translate="yes" xml:space="preserve">
          <source>Linear algebra functions in Julia are largely implemented by calling functions from &lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK&lt;/a&gt;. Sparse factorizations call functions from &lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse&lt;/a&gt;.</source>
          <target state="translated">Julia中的线性代数函数主要通过调用&lt;a href=&quot;http://www.netlib.org/lapack/&quot;&gt;LAPACK来实现&lt;/a&gt;。&lt;a href=&quot;http://faculty.cse.tamu.edu/davis/suitesparse.html&quot;&gt;SuiteSparse中的&lt;/a&gt;稀疏分解调用函数。</target>
        </trans-unit>
        <trans-unit id="d1c65bd6bdbd1cc3a07c925c8d1f63a9ef479713" translate="yes" xml:space="preserve">
          <source>Linear index to cartesian index conversion exploits the fact that a &lt;code&gt;CartesianIndices&lt;/code&gt; is an &lt;code&gt;AbstractArray&lt;/code&gt; and can be indexed linearly:</source>
          <target state="translated">线性索引到笛卡尔索引转换利用了这样一个事实 &lt;code&gt;CartesianIndices&lt;/code&gt; 是 &lt;code&gt;AbstractArray&lt;/code&gt; 和可线性索引：</target>
        </trans-unit>
        <trans-unit id="c1c4acc4812d010d9f4c5b8b2c947ad6bf3a9bbc" translate="yes" xml:space="preserve">
          <source>Linear indexing</source>
          <target state="translated">线性指数化</target>
        </trans-unit>
        <trans-unit id="a4c16b0102a66cf314085c9fb0015204063e6fd3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Adjoint</source>
          <target state="translated">LinearAlgebra.Adjoint</target>
        </trans-unit>
        <trans-unit id="f15dbf32eea38f12565a79b8c505de8f87a92ec9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS</source>
          <target state="translated">LinearAlgebra.BLAS</target>
        </trans-unit>
        <trans-unit id="e45107bca3f2265e5d9c85ca1c9fec27cc17de1c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.asum()</source>
          <target state="translated">LinearAlgebra.BLAS.asum()</target>
        </trans-unit>
        <trans-unit id="0372d64ede3f868ef8099f9d2d0ba0d26301cae5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.blascopy!()</source>
          <target state="translated">LinearAlgebra.BLAS.blascopy!()</target>
        </trans-unit>
        <trans-unit id="d13717e84d8e032e30650fc47582fb7cd32b85c2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotc()</source>
          <target state="translated">LinearAlgebra.BLAS.dotc()</target>
        </trans-unit>
        <trans-unit id="80b561d6fb654a4f5dbc4d039a743babeb78f05a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.dotu()</source>
          <target state="translated">LinearAlgebra.BLAS.dotu()</target>
        </trans-unit>
        <trans-unit id="182543675c48dfba38aa5478d8ce3279d26d4ef4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv!()</target>
        </trans-unit>
        <trans-unit id="6cec9f631b39a94bb3001b07c15c7364aacddbae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.gbmv()</target>
        </trans-unit>
        <trans-unit id="59202f7fad0ff0f17101364487458d9228718112" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm!()</target>
        </trans-unit>
        <trans-unit id="a90dea0e894e7db5d100f0da8dd99eb55becb11a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemm()</source>
          <target state="translated">LinearAlgebra.BLAS.gemm()</target>
        </trans-unit>
        <trans-unit id="9c43130d6006aefdd06d70d7199a76e138e6d41f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv!()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv!()</target>
        </trans-unit>
        <trans-unit id="9e7d057213847eff9fcee5278de6f9c65c129248" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.gemv()</source>
          <target state="translated">LinearAlgebra.BLAS.gemv()</target>
        </trans-unit>
        <trans-unit id="7de983e341dd493a6005bdeccd16b2008abe1b4c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.ger!()</source>
          <target state="translated">LinearAlgebra.BLAS.ger!()</target>
        </trans-unit>
        <trans-unit id="c508786b30abc595e3c001798b77caf3e83ceab1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.her!()</source>
          <target state="translated">LinearAlgebra.BLAS.her!()</target>
        </trans-unit>
        <trans-unit id="01f3abbc9926c6680a10dada97213576f68220e4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk!()</source>
          <target state="translated">LinearAlgebra.BLAS.herk!()</target>
        </trans-unit>
        <trans-unit id="7ca416ce67850358cd75772ae19bf13edb1e3145" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.herk()</source>
          <target state="translated">LinearAlgebra.BLAS.herk()</target>
        </trans-unit>
        <trans-unit id="ae660954410680fe7bf17073b8a5a13e3d858105" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.iamax()</source>
          <target state="translated">LinearAlgebra.BLAS.iamax()</target>
        </trans-unit>
        <trans-unit id="cd1a2671bbd0fd5d0123954f4b697032be1e635c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.nrm2()</source>
          <target state="translated">LinearAlgebra.BLAS.nrm2()</target>
        </trans-unit>
        <trans-unit id="e90dcf81b0d3bcd42a1f41c82cba29bfcb9a2dc1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv!()</target>
        </trans-unit>
        <trans-unit id="726229488f087bf6f4b29c015474123c38acb7e3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.sbmv()</source>
          <target state="translated">LinearAlgebra.BLAS.sbmv()</target>
        </trans-unit>
        <trans-unit id="e38b1b5860121c691bed2ff0a82bb4bddb43aeda" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal!()</source>
          <target state="translated">LinearAlgebra.BLAS.scal!()</target>
        </trans-unit>
        <trans-unit id="4a5ae3b0e35b9b56d0ca4f544caed75fc4410c97" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.scal()</source>
          <target state="translated">LinearAlgebra.BLAS.scal()</target>
        </trans-unit>
        <trans-unit id="bd2ae45b248f17f2163a416ae8b1b8f316599548" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.set_num_threads()</source>
          <target state="translated">LinearAlgebra.BLAS.set_num_threads()</target>
        </trans-unit>
        <trans-unit id="0ee907ef539363efacff8c904278837def446859" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm!()</source>
          <target state="translated">LinearAlgebra.BLAS.symm!()</target>
        </trans-unit>
        <trans-unit id="2ca89af9829c4450e1da15d694b423f02feaf2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symm()</source>
          <target state="translated">LinearAlgebra.BLAS.symm()</target>
        </trans-unit>
        <trans-unit id="c4ff899252dc161c59c729ece50db7c6e510be1f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv!()</source>
          <target state="translated">LinearAlgebra.BLAS.symv!()</target>
        </trans-unit>
        <trans-unit id="c3f814d8d8c968ce7e35bf9e0c795e7503d54b00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.symv()</source>
          <target state="translated">LinearAlgebra.BLAS.symv()</target>
        </trans-unit>
        <trans-unit id="5668a0235a5cc16113ef6c829d5f4f3cb946eb77" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syr!()</source>
          <target state="translated">LinearAlgebra.BLAS.syr!()</target>
        </trans-unit>
        <trans-unit id="0ea3ba86e685fafe1804ca06ce2cc0aa30792e4d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk!()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk!()</target>
        </trans-unit>
        <trans-unit id="2910b73b192710f5034193e1b67ded6bb10699b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.syrk()</source>
          <target state="translated">LinearAlgebra.BLAS.syrk()</target>
        </trans-unit>
        <trans-unit id="c657c078868b4b49e269336d3ff46af071f8fa01" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm!()</target>
        </trans-unit>
        <trans-unit id="04b9bf86a921535849558977a38bc7efdcdd3272" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmm()</source>
          <target state="translated">LinearAlgebra.BLAS.trmm()</target>
        </trans-unit>
        <trans-unit id="9d8cb1ea03abc954f9254445e2db3781f49756de" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv!()</target>
        </trans-unit>
        <trans-unit id="72558d3ed3ecbb2cf81ea6ad3401440af8b8f050" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trmv()</source>
          <target state="translated">LinearAlgebra.BLAS.trmv()</target>
        </trans-unit>
        <trans-unit id="218cea369dcdb92ba6f1e8b45bda62d05efdb29f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm!()</target>
        </trans-unit>
        <trans-unit id="05197b08bc46d65744a62e5816cecfcc72ef9983" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsm()</source>
          <target state="translated">LinearAlgebra.BLAS.trsm()</target>
        </trans-unit>
        <trans-unit id="a147ea56a9e55d82d2590cd764be5c11a28ac42c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv!()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv!()</target>
        </trans-unit>
        <trans-unit id="3205efa3be1bef6bfc936054e89c97d514d48dc9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.BLAS.trsv()</source>
          <target state="translated">LinearAlgebra.BLAS.trsv()</target>
        </trans-unit>
        <trans-unit id="6364f45353271734da7f68207b58b49b90c519aa" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Bidiagonal</source>
          <target state="translated">LinearAlgebra.Bidiagonal</target>
        </trans-unit>
        <trans-unit id="b0cf658cc297affd7bac8f29cb18f8d5898c988a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Diagonal</source>
          <target state="translated">LinearAlgebra.Diagonal</target>
        </trans-unit>
        <trans-unit id="1b39c6247cb769989ac9ddbddb50b7a2c7340d63" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Givens</source>
          <target state="translated">LinearAlgebra.Givens</target>
        </trans-unit>
        <trans-unit id="202cd7384296c88f891bea55496b32195e848e3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Hermitian</source>
          <target state="translated">LinearAlgebra.Hermitian</target>
        </trans-unit>
        <trans-unit id="79fc319c7c269772fed2f361672bd676a3520fae" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.I</source>
          <target state="translated">LinearAlgebra.I</target>
        </trans-unit>
        <trans-unit id="2a1626ced0dce6995c5f58e8d3def911fe7d751f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK</source>
          <target state="translated">LinearAlgebra.LAPACK</target>
        </trans-unit>
        <trans-unit id="6952bafd874a0b24bee2d594a25adae4924e4368" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsdc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsdc!()</target>
        </trans-unit>
        <trans-unit id="8d0c6a0d204bac9380f45220c8b25a01fbcacfc6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.bdsqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.bdsqr!()</target>
        </trans-unit>
        <trans-unit id="21f727539d33d03dc8b986b7ecf7ebc53925b185" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrf!()</target>
        </trans-unit>
        <trans-unit id="2bb72a67df1d100e66f590117e79a6b1fe23456f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gbtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gbtrs!()</target>
        </trans-unit>
        <trans-unit id="042b17e7fbbcced06624b5d18cecc1aa4880dfbf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebak!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebak!()</target>
        </trans-unit>
        <trans-unit id="5d6511493ba85c27c966c3e62df9148d39254215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebal!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebal!()</target>
        </trans-unit>
        <trans-unit id="3f829c89a9fa98bb138c195dfc567bcd88556869" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gebrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gebrd!()</target>
        </trans-unit>
        <trans-unit id="7b9eae4d91dc7949a3ab26f80620c6913329a279" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gecon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gecon!()</target>
        </trans-unit>
        <trans-unit id="bb09b2b974d5f60b025547cb0fa46b9c45f6eabf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gees!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gees!()</target>
        </trans-unit>
        <trans-unit id="4adfdd0d27bb95b254d684fb07bba4182c2a0a10" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geev!()</target>
        </trans-unit>
        <trans-unit id="f5fc1d59d033c8ca0452a21a055c7e9b2cdc3409" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geevx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geevx!()</target>
        </trans-unit>
        <trans-unit id="4162f14b7f241061ff814adad6bc4880eae0e215" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gehrd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gehrd!()</target>
        </trans-unit>
        <trans-unit id="8e52c2ea87a7196909af8b847322a690fcef6a4f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelqf!()</target>
        </trans-unit>
        <trans-unit id="b7bb54e5159886ceee34f20483cdbbf42f4c1539" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gels!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gels!()</target>
        </trans-unit>
        <trans-unit id="7f10b1dc3cf7af9a395a67850e24907c94936d00" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsd!()</target>
        </trans-unit>
        <trans-unit id="80af9020ee1658e044f9880edaa420f6156e7344" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gelsy!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gelsy!()</target>
        </trans-unit>
        <trans-unit id="0287631b489ed93feb1a00a1ebe340392e903cd8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gemqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gemqrt!()</target>
        </trans-unit>
        <trans-unit id="756fb9e8e80236b54ccbf1725c3d3d72fe14d0a7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqlf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqlf!()</target>
        </trans-unit>
        <trans-unit id="0fa233b136691bcd50a971792940b70a927e194d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqp3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqp3!()</target>
        </trans-unit>
        <trans-unit id="965cf80f5d69f9b2fe0863a82cdd4b368ed4eba1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrf!()</target>
        </trans-unit>
        <trans-unit id="47893a6fd6bd1458706a0673e1d64d54be6d20ec" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt!()</target>
        </trans-unit>
        <trans-unit id="94f19bfcd3971a4989d673487abd3bd487d293d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.geqrt3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.geqrt3!()</target>
        </trans-unit>
        <trans-unit id="19ff37cfcf822fda7f988e77f92c195943446d8b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gerqf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gerqf!()</target>
        </trans-unit>
        <trans-unit id="c47fe5b7f34f49ec65d1767c07d0c357d6c12e20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesdd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesdd!()</target>
        </trans-unit>
        <trans-unit id="5abf4ebce7739a88e07c58cc2ab150c8e79b9a6f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesv!()</target>
        </trans-unit>
        <trans-unit id="f900ac3ce3ebbd4997a5abaafa85072405326271" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvd!()</target>
        </trans-unit>
        <trans-unit id="3a69b9c0d56562dd7ea697ae7f5eea3c3217e8c4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gesvx!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gesvx!()</target>
        </trans-unit>
        <trans-unit id="997ad4b85fe561bd14fecda4a9185c9be5de7367" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrf!()</target>
        </trans-unit>
        <trans-unit id="d93427849097672e5ca2dd0b81aead36db3bffe6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getri!()</target>
        </trans-unit>
        <trans-unit id="46614120fda23ffee34b46ef06a4d2717d89fb72" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.getrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.getrs!()</target>
        </trans-unit>
        <trans-unit id="3d14f5edf2f52561c8b1cfcc015d4eefd5e8344a" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gges!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gges!()</target>
        </trans-unit>
        <trans-unit id="7a73e7bdeb2ad0938d68fd93e6f27345108ba8b1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggev!()</target>
        </trans-unit>
        <trans-unit id="3ae17e2685021efceba3fcfa226528ce1e41d6a9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gglse!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gglse!()</target>
        </trans-unit>
        <trans-unit id="3100382b56a5f6703f1da34614842b2f9fd9e2ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd!()</target>
        </trans-unit>
        <trans-unit id="61dfaab553dd3ccfaacf89bcaa2704beb947b945" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ggsvd3!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ggsvd3!()</target>
        </trans-unit>
        <trans-unit id="db05e9a4a5c735805bf40092dca7033de637b064" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gtsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gtsv!()</target>
        </trans-unit>
        <trans-unit id="9b6b3e96efd10abaf039016da8b07d6fdefa2dac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrf!()</target>
        </trans-unit>
        <trans-unit id="7d5b231fee9480951dc3ad4ba6239425f9a1a69e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.gttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.gttrs!()</target>
        </trans-unit>
        <trans-unit id="56b45916f3c5b6ccae7d5897efff708c77670fe9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hesv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hesv!()</target>
        </trans-unit>
        <trans-unit id="1dd5d2c561afecfbda18ff5f8f3e44ea02e6d2fc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrf!()</target>
        </trans-unit>
        <trans-unit id="cf6a921b989ce1adbf03be52e76504708a3db4ac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetri!()</target>
        </trans-unit>
        <trans-unit id="a535b2e2552fdefb2e31ef5cf705c68b406e0e4e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.hetrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.hetrs!()</target>
        </trans-unit>
        <trans-unit id="3c7e4832c831bf40fdec955ad64e7df4981b628e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orghr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orghr!()</target>
        </trans-unit>
        <trans-unit id="9afd9979936c6db6319fad409953eb23f579d5ca" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orglq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orglq!()</target>
        </trans-unit>
        <trans-unit id="72fc39a42e1ba3ec988e4e34aca8961c7d4dd43b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgql!()</target>
        </trans-unit>
        <trans-unit id="3f36d991b78dd60e8ba960e3ddf5db19bd097fb8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgqr!()</target>
        </trans-unit>
        <trans-unit id="18eb3015f314ddb831889efa958dd72893b66864" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.orgrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.orgrq!()</target>
        </trans-unit>
        <trans-unit id="ee585149aad96671646932b1d3634278142c13f9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormlq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormlq!()</target>
        </trans-unit>
        <trans-unit id="bdfbc8d40444d8bafd90c67f455d3b34e73228cf" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormql!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormql!()</target>
        </trans-unit>
        <trans-unit id="1087b8488a465127e32826863adc779bd9d1327c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormqr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormqr!()</target>
        </trans-unit>
        <trans-unit id="a2fb188b73bde57195bb1d824030a4ed0bbd608b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrq!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrq!()</target>
        </trans-unit>
        <trans-unit id="ffa8283f30595d57d465f23f206871d42b88b987" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ormrz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ormrz!()</target>
        </trans-unit>
        <trans-unit id="c7253e7d1bd1dce84f707a9c7bb94c23529af18b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.posv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.posv!()</target>
        </trans-unit>
        <trans-unit id="9686f05e5f67aa477b854f99ab98169e47b19084" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrf!()</target>
        </trans-unit>
        <trans-unit id="a162ea4f7602eae7842c83604fa469aeb77c3bfd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potri!()</target>
        </trans-unit>
        <trans-unit id="22fdc042984e65bbd42e11f87af366faeef74622" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.potrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.potrs!()</target>
        </trans-unit>
        <trans-unit id="2e152451a9c97ebf916e592216ff01087a6982bd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pstrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pstrf!()</target>
        </trans-unit>
        <trans-unit id="9a048d5b8589397c46ecf7dd3a023271382559b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.ptsv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.ptsv!()</target>
        </trans-unit>
        <trans-unit id="6bd4c3257dbbd4280e5dfb016628a7275adf1a33" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrf!()</target>
        </trans-unit>
        <trans-unit id="959a9d0a79a973f313fff6fc55c623c797c6c7f7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.pttrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.pttrs!()</target>
        </trans-unit>
        <trans-unit id="6d7e0b67347ba1e8b9a711859117ac575684e8e1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stebz!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stebz!()</target>
        </trans-unit>
        <trans-unit id="e4c4102de134bdf1c8c27920913760be8971f8a2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stegr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stegr!()</target>
        </trans-unit>
        <trans-unit id="09e672928c1ecc7dda3783503f4b5dded92b9673" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stein!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stein!()</target>
        </trans-unit>
        <trans-unit id="eace3492602beabe1f2ab7981e7d9209cfc2204c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.stev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.stev!()</target>
        </trans-unit>
        <trans-unit id="66d07521e84ded0664c8e6d24cb062cfa0abf44c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syconv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syconv!()</target>
        </trans-unit>
        <trans-unit id="e37c017154e2c1fa3c47a038f981c9a2f9b128ad" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syev!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syev!()</target>
        </trans-unit>
        <trans-unit id="371acb573fdc2cfe58acc84371e930aa7f66f883" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.syevr!()</source>
          <target state="translated">LinearAlgebra.LAPACK.syevr!()</target>
        </trans-unit>
        <trans-unit id="4489b4eba27fe6a94403f8fc257631ee4a85b0d1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sygvd!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sygvd!()</target>
        </trans-unit>
        <trans-unit id="f6128668d243c8ac355a7d5c46c06adfedbfe0c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sysv!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sysv!()</target>
        </trans-unit>
        <trans-unit id="022ac6bcea134ce5fe3a89f3bf4383107b51b2a0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrf!()</target>
        </trans-unit>
        <trans-unit id="a8bb80be7fdb78fb2ac23b9a1ad4b26eace9add4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytri!()</target>
        </trans-unit>
        <trans-unit id="9d2a23098c970b0a82d03a2a452ca8118a4c74c0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.sytrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.sytrs!()</target>
        </trans-unit>
        <trans-unit id="83c634bcfc2f6365a7a5ab5dac799d6cefa5dae1" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tgsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tgsen!()</target>
        </trans-unit>
        <trans-unit id="b190b8b87f953db3f01614e0cef9f46ab8ddef6c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trcon!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trcon!()</target>
        </trans-unit>
        <trans-unit id="81c93a5fe65faa5e18e25557226f1e29499c9834" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trevc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trevc!()</target>
        </trans-unit>
        <trans-unit id="0fde83f3dc9a18889586b82aefe631e75f1ca0a5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trexc!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trexc!()</target>
        </trans-unit>
        <trans-unit id="e0a6fb5f31ac808c6c4c2d58c9bd3c8bf4547c3c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trrfs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trrfs!()</target>
        </trans-unit>
        <trans-unit id="b4a63b08edea3206f96883f52f887e335290d30c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsen!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsen!()</target>
        </trans-unit>
        <trans-unit id="0981f544b1017b88401f0c0d727a8512e3a16911" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trsyl!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trsyl!()</target>
        </trans-unit>
        <trans-unit id="0dd13d83537af1986304c93341975314e0a3cb92" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtri!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtri!()</target>
        </trans-unit>
        <trans-unit id="6ace8e21c229caf81f057c6691dc06ea1d7feacb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.trtrs!()</source>
          <target state="translated">LinearAlgebra.LAPACK.trtrs!()</target>
        </trans-unit>
        <trans-unit id="9f4a95aa5cd6a48d65dcce0dfbc0c2104db08ddb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LAPACK.tzrzf!()</source>
          <target state="translated">LinearAlgebra.LAPACK.tzrzf!()</target>
        </trans-unit>
        <trans-unit id="8dc3928b7aacf4bc69fb8fb480397c2bd0754291" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.LowerTriangular</source>
          <target state="translated">LinearAlgebra.LowerTriangular</target>
        </trans-unit>
        <trans-unit id="d296a34551600570579f05eb52f68d858500b6d0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.PosDefException</source>
          <target state="translated">LinearAlgebra.PosDefException</target>
        </trans-unit>
        <trans-unit id="1a5ee969e2fda57a234091ffc7169bb0717b4b55" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QR</source>
          <target state="translated">LinearAlgebra.QR</target>
        </trans-unit>
        <trans-unit id="f252432902b3e7d2b6f5a1f541fab2b2b837e497" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRCompactWY</source>
          <target state="translated">LinearAlgebra.QRCompactWY</target>
        </trans-unit>
        <trans-unit id="f69a9de928f655bcff2c3bb620374afc9c7adc36" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.QRPivoted</source>
          <target state="translated">LinearAlgebra.QRPivoted</target>
        </trans-unit>
        <trans-unit id="91c43501578d11cc7b806496b694bc7fb0798c40" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SingularException</source>
          <target state="translated">LinearAlgebra.SingularException</target>
        </trans-unit>
        <trans-unit id="21fa708b4606d3744276dbdb6504d1d33fb0880d" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.SymTridiagonal</source>
          <target state="translated">LinearAlgebra.SymTridiagonal</target>
        </trans-unit>
        <trans-unit id="c49662dfefa654d140f37c4f501e68d902dc9896" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Symmetric</source>
          <target state="translated">LinearAlgebra.Symmetric</target>
        </trans-unit>
        <trans-unit id="0b7bcff88afd509726e928a1da4371d5aad48e96" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Transpose</source>
          <target state="translated">LinearAlgebra.Transpose</target>
        </trans-unit>
        <trans-unit id="2f6e7904ca2d80d08fecb44ff694e5529ca8a0d2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.Tridiagonal</source>
          <target state="translated">LinearAlgebra.Tridiagonal</target>
        </trans-unit>
        <trans-unit id="bcd3cd958cfc2292b170f7eb25170c03f9af2ed5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UniformScaling</source>
          <target state="translated">LinearAlgebra.UniformScaling</target>
        </trans-unit>
        <trans-unit id="5441959246e16a93a832c57343376624fe880467" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitLowerTriangular</source>
          <target state="translated">LinearAlgebra.UnitLowerTriangular</target>
        </trans-unit>
        <trans-unit id="828cc10c694c730e1acddbbb4fe2c09ed2dca433" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UnitUpperTriangular</source>
          <target state="translated">LinearAlgebra.UnitUpperTriangular</target>
        </trans-unit>
        <trans-unit id="fa757c0838038ffc2a6e801a13ed5a7b6a193380" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.UpperTriangular</source>
          <target state="translated">LinearAlgebra.UpperTriangular</target>
        </trans-unit>
        <trans-unit id="738beaba8ed2df6f31a673ee2db8f7e43295d515" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.adjoint!()</source>
          <target state="translated">LinearAlgebra.adjoint!()</target>
        </trans-unit>
        <trans-unit id="9920d50dc92a459847aa3353d4531d0f64c48729" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.axpy!()</source>
          <target state="translated">LinearAlgebra.axpy!()</target>
        </trans-unit>
        <trans-unit id="8382532f0eba26f9bafb22dc5faa9989630741b4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman!()</source>
          <target state="translated">LinearAlgebra.bunchkaufman!()</target>
        </trans-unit>
        <trans-unit id="f1ff255591a788d659f39c668b504aff71f28694" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.bunchkaufman()</source>
          <target state="translated">LinearAlgebra.bunchkaufman()</target>
        </trans-unit>
        <trans-unit id="49b3835122bf27c1a5c23bc1f6af4df7016dfd20" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.checksquare()</source>
          <target state="translated">LinearAlgebra.checksquare()</target>
        </trans-unit>
        <trans-unit id="f296f09ff80bdc588b439135e7b625bce1f0d744" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky!()</source>
          <target state="translated">LinearAlgebra.cholesky!()</target>
        </trans-unit>
        <trans-unit id="2614d615a16d87a3a50db7af9f3788e4b71855b0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cholesky()</source>
          <target state="translated">LinearAlgebra.cholesky()</target>
        </trans-unit>
        <trans-unit id="848b264dd28237efb792aa43901c5f8f5aab83f0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cond()</source>
          <target state="translated">LinearAlgebra.cond()</target>
        </trans-unit>
        <trans-unit id="763a7ceb07efeb8156da716b3ef8c72573b2e7a4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.condskeel()</source>
          <target state="translated">LinearAlgebra.condskeel()</target>
        </trans-unit>
        <trans-unit id="639f206bebf5466d93a4ba2c03f4c4a29b6d5ea5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.cross()</source>
          <target state="translated">LinearAlgebra.cross()</target>
        </trans-unit>
        <trans-unit id="d362f85f49e425d14c9978220ba2468f026a4067" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.det()</source>
          <target state="translated">LinearAlgebra.det()</target>
        </trans-unit>
        <trans-unit id="9abda27c81a472d3c63a1a657c4bee31686d49bc" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diag()</source>
          <target state="translated">LinearAlgebra.diag()</target>
        </trans-unit>
        <trans-unit id="a7c7cacbbacea0c74222541b31910df567bdb6fb" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diagind()</source>
          <target state="translated">LinearAlgebra.diagind()</target>
        </trans-unit>
        <trans-unit id="1aef8c46a780d7765016e06dcf0a60d28ea11f98" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.diagm()</source>
          <target state="translated">LinearAlgebra.diagm()</target>
        </trans-unit>
        <trans-unit id="a943f01470875cdccf0a181e83dd06c730b15424" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.dot()</source>
          <target state="translated">LinearAlgebra.dot()</target>
        </trans-unit>
        <trans-unit id="03ea5670e94fee3cdb29e27ac132cc775f5e56ba" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigen!()</source>
          <target state="translated">LinearAlgebra.eigen!()</target>
        </trans-unit>
        <trans-unit id="cc8ed4ca720004997b29c2c20ec5efc0988c78b6" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigen()</source>
          <target state="translated">LinearAlgebra.eigen()</target>
        </trans-unit>
        <trans-unit id="2006a7e56e96f08e8b101a5a98e0ce5438f051fd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigmax()</source>
          <target state="translated">LinearAlgebra.eigmax()</target>
        </trans-unit>
        <trans-unit id="495e81e9aba12ed4873afb4fbfc9910161c06935" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigmin()</source>
          <target state="translated">LinearAlgebra.eigmin()</target>
        </trans-unit>
        <trans-unit id="26373fb486681d828210b9eb0ada3db569ae5c9f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvals!()</source>
          <target state="translated">LinearAlgebra.eigvals!()</target>
        </trans-unit>
        <trans-unit id="0ea943b4827b5ab3ec563686a13cb3fa1fff55de" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvals()</source>
          <target state="translated">LinearAlgebra.eigvals()</target>
        </trans-unit>
        <trans-unit id="28aa4c8f8bdda4caedf38b6c3a8bdcbdcb929bd5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.eigvecs()</source>
          <target state="translated">LinearAlgebra.eigvecs()</target>
        </trans-unit>
        <trans-unit id="c1f95e8750fd563a65769748339ff1021d07a664" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.factorize()</source>
          <target state="translated">LinearAlgebra.factorize()</target>
        </trans-unit>
        <trans-unit id="245f91f9f7fc9cc2df2bdf9c6e80f2d0014ba521" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.givens()</source>
          <target state="translated">LinearAlgebra.givens()</target>
        </trans-unit>
        <trans-unit id="42383aca01a3095d7de60dfdd23a34e7aff90f64" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.hessenberg!()</source>
          <target state="translated">LinearAlgebra.hessenberg!()</target>
        </trans-unit>
        <trans-unit id="4470ba44b04e09b558f06c669c830f27803c6604" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.hessenberg()</source>
          <target state="translated">LinearAlgebra.hessenberg()</target>
        </trans-unit>
        <trans-unit id="6c9988c8648ff7a78199a102f477a45b0d53eb2c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isdiag()</source>
          <target state="translated">LinearAlgebra.isdiag()</target>
        </trans-unit>
        <trans-unit id="86f33205a580fff63ee19ac4843205922d3b8fbe" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ishermitian()</source>
          <target state="translated">LinearAlgebra.ishermitian()</target>
        </trans-unit>
        <trans-unit id="bad9e76616b147a9a6b22ef39daed46e374592df" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isposdef!()</source>
          <target state="translated">LinearAlgebra.isposdef!()</target>
        </trans-unit>
        <trans-unit id="a3eff21980aaad7c0e8ab2571fde20cb7f9a4ac3" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.isposdef()</source>
          <target state="translated">LinearAlgebra.isposdef()</target>
        </trans-unit>
        <trans-unit id="f184fbce8f26db2479a19308ee554a971eb91845" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.issuccess()</source>
          <target state="translated">LinearAlgebra.issuccess()</target>
        </trans-unit>
        <trans-unit id="3b45090c87a6e9b6490c1b86caef6bc289e9811b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.issymmetric()</source>
          <target state="translated">LinearAlgebra.issymmetric()</target>
        </trans-unit>
        <trans-unit id="27361a0db065863449e5514f392695a8843c50d2" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.istril()</source>
          <target state="translated">LinearAlgebra.istril()</target>
        </trans-unit>
        <trans-unit id="154536c971d912aac5c55987e04b500058382262" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.istriu()</source>
          <target state="translated">LinearAlgebra.istriu()</target>
        </trans-unit>
        <trans-unit id="8702b95d8a1b1c5f29f2af932f7b339f131fc979" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldiv!()</source>
          <target state="translated">LinearAlgebra.ldiv!()</target>
        </trans-unit>
        <trans-unit id="f628486016bf8bb2592d19dea3a4ef558655d6d8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldlt!()</source>
          <target state="translated">LinearAlgebra.ldlt!()</target>
        </trans-unit>
        <trans-unit id="c666984e1b5f4107efe1cc308dd23df3742d794b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ldlt()</source>
          <target state="translated">LinearAlgebra.ldlt()</target>
        </trans-unit>
        <trans-unit id="87445caeed19ddaad799f1582737a52e40bde9e9" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lmul!()</source>
          <target state="translated">LinearAlgebra.lmul!()</target>
        </trans-unit>
        <trans-unit id="f5e67426386e0244313c54bbe9e11137664a7611" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.logabsdet()</source>
          <target state="translated">LinearAlgebra.logabsdet()</target>
        </trans-unit>
        <trans-unit id="a6c4efc9dcb4f29a594919d0a4a0c4ecc1b0eb49" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.logdet()</source>
          <target state="translated">LinearAlgebra.logdet()</target>
        </trans-unit>
        <trans-unit id="aed69ea345782519298a7b83289a6fd2a0d20a22" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankdowndate!()</source>
          <target state="translated">LinearAlgebra.lowrankdowndate!()</target>
        </trans-unit>
        <trans-unit id="065afe0c96edc42ef451662159895201fbe9f74e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankdowndate()</source>
          <target state="translated">LinearAlgebra.lowrankdowndate()</target>
        </trans-unit>
        <trans-unit id="10584a564acc8cafcbd880790d5a3223c614e997" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankupdate!()</source>
          <target state="translated">LinearAlgebra.lowrankupdate!()</target>
        </trans-unit>
        <trans-unit id="952be3b610fe2e74216ee89053ff75f7419d4b28" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lowrankupdate()</source>
          <target state="translated">LinearAlgebra.lowrankupdate()</target>
        </trans-unit>
        <trans-unit id="47c1af320726090525f6d61978444c2ea6c9d0ab" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lq!()</source>
          <target state="translated">LinearAlgebra.lq!()</target>
        </trans-unit>
        <trans-unit id="5375dc727ff35daa144ad173772170766a77fc84" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lq()</source>
          <target state="translated">LinearAlgebra.lq()</target>
        </trans-unit>
        <trans-unit id="19c721bb8412a08453cd493f076ec151ec21919f" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lu!()</source>
          <target state="translated">LinearAlgebra.lu!()</target>
        </trans-unit>
        <trans-unit id="416610984f232609e5a5300d47b309939683e378" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lu()</source>
          <target state="translated">LinearAlgebra.lu()</target>
        </trans-unit>
        <trans-unit id="e5fa084cafc39d82b66f8c8dc2e12353e03f3704" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.lyap()</source>
          <target state="translated">LinearAlgebra.lyap()</target>
        </trans-unit>
        <trans-unit id="7c99824c12d49750627f623ddd871e015e24c8c8" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.mul!()</source>
          <target state="translated">LinearAlgebra.mul!()</target>
        </trans-unit>
        <trans-unit id="24933f7d1d932d73149fe8820b01ff0b8033488b" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.norm()</source>
          <target state="translated">LinearAlgebra.norm()</target>
        </trans-unit>
        <trans-unit id="1639614f72f390991f3c415b26fb661709818686" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.normalize!()</source>
          <target state="translated">LinearAlgebra.normalize!()</target>
        </trans-unit>
        <trans-unit id="bfa13b34d43df925bb276eb2b2712a5d9852eb7e" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.normalize()</source>
          <target state="translated">LinearAlgebra.normalize()</target>
        </trans-unit>
        <trans-unit id="123d380f57ea839fe9386bdced9ecbd4bfa56d19" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.nullspace()</source>
          <target state="translated">LinearAlgebra.nullspace()</target>
        </trans-unit>
        <trans-unit id="c473c4d32b408a10287aa2043ce1410d94d0f8ba" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.opnorm()</source>
          <target state="translated">LinearAlgebra.opnorm()</target>
        </trans-unit>
        <trans-unit id="27873174504747d088813d705a5c2057e78a6fa4" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ordschur!()</source>
          <target state="translated">LinearAlgebra.ordschur!()</target>
        </trans-unit>
        <trans-unit id="a0cf19c8a32916092aead5343f54d5c29799bf44" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.ordschur()</source>
          <target state="translated">LinearAlgebra.ordschur()</target>
        </trans-unit>
        <trans-unit id="f7c256ca3b590fa1c68a6c5c968889de72035a1c" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.peakflops()</source>
          <target state="translated">LinearAlgebra.peakflops()</target>
        </trans-unit>
        <trans-unit id="3b416155a9648251a3dab2c1f86f654cbc45f766" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.pinv()</source>
          <target state="translated">LinearAlgebra.pinv()</target>
        </trans-unit>
        <trans-unit id="24a51a0a6b9a091503d04d18751653ab70e63907" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.qr!()</source>
          <target state="translated">LinearAlgebra.qr!()</target>
        </trans-unit>
        <trans-unit id="32cd922076c561139a5133388ff3de86aee2f838" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.qr()</source>
          <target state="translated">LinearAlgebra.qr()</target>
        </trans-unit>
        <trans-unit id="25c16b6062a5721edfc89f6f1b58866c9999fd30" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rank()</source>
          <target state="translated">LinearAlgebra.rank()</target>
        </trans-unit>
        <trans-unit id="292d72424657c4aa082122899b52a2ca37500f51" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rdiv!()</source>
          <target state="translated">LinearAlgebra.rdiv!()</target>
        </trans-unit>
        <trans-unit id="12f33b8246f53c039178bae0493a696a7aff5605" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.rmul!()</source>
          <target state="translated">LinearAlgebra.rmul!()</target>
        </trans-unit>
        <trans-unit id="3ce18ca8ac025f0f6376582ad516bf09b60beb97" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.schur!()</source>
          <target state="translated">LinearAlgebra.schur!()</target>
        </trans-unit>
        <trans-unit id="d1c7d7a7be766a0227fceaaeba6b125494ecacc5" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.schur()</source>
          <target state="translated">LinearAlgebra.schur()</target>
        </trans-unit>
        <trans-unit id="875a6969d0c4c9e685666728e0a075eb8c05fd34" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.stride1()</source>
          <target state="translated">LinearAlgebra.stride1()</target>
        </trans-unit>
        <trans-unit id="e830629f4eb2b2f684c386f2e83c4cd8d40d08c7" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svd!()</source>
          <target state="translated">LinearAlgebra.svd!()</target>
        </trans-unit>
        <trans-unit id="9ac0ee09de07e5d20a225d6487f69df6607076ac" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svd()</source>
          <target state="translated">LinearAlgebra.svd()</target>
        </trans-unit>
        <trans-unit id="988da18329a53e16de1bd6da5c1f8e417469db10" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svdvals!()</source>
          <target state="translated">LinearAlgebra.svdvals!()</target>
        </trans-unit>
        <trans-unit id="5f88c1d8eeb98c086bcbe1a4efbb1ecfea5359dd" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.svdvals()</source>
          <target state="translated">LinearAlgebra.svdvals()</target>
        </trans-unit>
        <trans-unit id="08228eabf0d0dbc8efbc58ae8f1948646134de59" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.sylvester()</source>
          <target state="translated">LinearAlgebra.sylvester()</target>
        </trans-unit>
        <trans-unit id="b64e39526f66a386113f15a1ffcc6de69561a7ea" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tr()</source>
          <target state="translated">LinearAlgebra.tr()</target>
        </trans-unit>
        <trans-unit id="421907594b9500deaf9ebf0a78b09e30e97d0969" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.transpose!()</source>
          <target state="translated">LinearAlgebra.transpose!()</target>
        </trans-unit>
        <trans-unit id="9e11fafcc7c6da90f84fe85de7b987df1ab51a50" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tril!()</source>
          <target state="translated">LinearAlgebra.tril!()</target>
        </trans-unit>
        <trans-unit id="943eef9228abf32d3acece710a792a24018ad5d0" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.tril()</source>
          <target state="translated">LinearAlgebra.tril()</target>
        </trans-unit>
        <trans-unit id="a45cd5a2a1e79b5eba2cf22f01b2ab8a64dcfeec" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.triu!()</source>
          <target state="translated">LinearAlgebra.triu!()</target>
        </trans-unit>
        <trans-unit id="6fa6a88dc15e19a67b21c0de2d88e00b6f996707" translate="yes" xml:space="preserve">
          <source>LinearAlgebra.triu()</source>
          <target state="translated">LinearAlgebra.triu()</target>
        </trans-unit>
        <trans-unit id="3c8e04f396865f7c2a68d63b51786aa52075e28e" translate="yes" xml:space="preserve">
          <source>LinearIndices</source>
          <target state="translated">LinearIndices</target>
        </trans-unit>
        <trans-unit id="97539d497456e8ae64ab21e30e72713379418284" translate="yes" xml:space="preserve">
          <source>Link Symbol</source>
          <target state="translated">链接符号</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="6b94a7684e8c9e36ac262755ad390b4f84d2ef0f" translate="yes" xml:space="preserve">
          <source>Links to each of these download types can be found on the download page at &lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;. Note that not all versions of Julia are available for all platforms.</source>
          <target state="translated">可以在&lt;a href=&quot;https://julialang.org/downloads/&quot;&gt;https://julialang.org/downloads/&lt;/a&gt;的下载页面上找到每种下载类型的链接。请注意，并非所有版本的Julia都适用于所有平台。</target>
        </trans-unit>
        <trans-unit id="0bd309fe8c158ca93bf01439f879abad96a2d9ae" translate="yes" xml:space="preserve">
          <source>Links to either external or internal addresses can be written using the following syntax, where the text enclosed in square brackets, &lt;code&gt;[ ]&lt;/code&gt;, is the name of the link and the text enclosed in parentheses, &lt;code&gt;( )&lt;/code&gt;, is the URL.</source>
          <target state="translated">可以使用以下语法编写到外部或内部地址的链接，其中用方括号 &lt;code&gt;[ ]&lt;/code&gt; 括起来的文本是链接的名称，用括号 &lt;code&gt;( )&lt;/code&gt; 括起来的文本是URL。</target>
        </trans-unit>
        <trans-unit id="800618f12f938e53d9c627356df00435b9a51301" translate="yes" xml:space="preserve">
          <source>Links to either external or internal targets can be written using the following syntax, where the text enclosed in square brackets, &lt;code&gt;[ ]&lt;/code&gt;, is the name of the link and the text enclosed in parentheses, &lt;code&gt;( )&lt;/code&gt;, is the URL.</source>
          <target state="translated">可以使用以下语法编写到外部或内部目标的链接，其中用方括号 &lt;code&gt;[ ]&lt;/code&gt; 括起来的文本是链接的名称，用括号 &lt;code&gt;( )&lt;/code&gt; 括起来的文本是URL。</target>
        </trans-unit>
        <trans-unit id="f988d8955026b4558444945785c9b5dbc82a7b4f" translate="yes" xml:space="preserve">
          <source>Lipstick</source>
          <target state="translated">Lipstick</target>
        </trans-unit>
        <trans-unit id="97c285fe5eb710455fe67ecf43ec5d1858f0c7b3" translate="yes" xml:space="preserve">
          <source>Lisp-like macros and other metaprogramming facilities</source>
          <target state="translated">类似Lisp的宏和其他元编程设施</target>
        </trans-unit>
        <trans-unit id="17810a1438ef5dd3fd5dc6cdd00bf4fbecb5795c" translate="yes" xml:space="preserve">
          <source>List the number of revisions between &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt; (committish OIDs in string form). Since &lt;code&gt;commit1&lt;/code&gt; and &lt;code&gt;commit2&lt;/code&gt; may be on different branches, &lt;code&gt;revcount&lt;/code&gt; performs a &quot;left-right&quot; revision list (and count), returning a tuple of &lt;code&gt;Int&lt;/code&gt;s - the number of left and right commits, respectively. A left (or right) commit refers to which side of a symmetric difference in a tree the commit is reachable from.</source>
          <target state="translated">列出 &lt;code&gt;commit1&lt;/code&gt; 和 &lt;code&gt;commit2&lt;/code&gt; 之间的修订版本号（字符串形式的Commitish OID）。由于 &lt;code&gt;commit1&lt;/code&gt; 和 &lt;code&gt;commit2&lt;/code&gt; 可以在不同的分支， &lt;code&gt;revcount&lt;/code&gt; 执行&amp;ldquo;左，右&amp;rdquo;的修改单（和计数），返回的元组 &lt;code&gt;Int&lt;/code&gt; 秒-分别为左，右提交的数目。左（或右）提交是指从树中对称差异的哪一侧可以到达该提交。</target>
        </trans-unit>
        <trans-unit id="388721610609dc9098cd8f36e62807e84d1fade7" translate="yes" xml:space="preserve">
          <source>Listen on port on the address specified by &lt;code&gt;addr&lt;/code&gt;. By default this listens on &lt;code&gt;localhost&lt;/code&gt; only. To listen on all interfaces pass &lt;code&gt;IPv4(0)&lt;/code&gt; or &lt;code&gt;IPv6(0)&lt;/code&gt; as appropriate. &lt;code&gt;backlog&lt;/code&gt; determines how many connections can be pending (not having called &lt;a href=&quot;#Sockets.accept&quot;&gt;&lt;code&gt;accept&lt;/code&gt;&lt;/a&gt;) before the server will begin to reject them. The default value of &lt;code&gt;backlog&lt;/code&gt; is 511.</source>
          <target state="translated">在 &lt;code&gt;addr&lt;/code&gt; 指定的地址上侦听端口。默认情况下，它仅侦听 &lt;code&gt;localhost&lt;/code&gt; 。要在所有接口上进行侦听，请根据需要传递 &lt;code&gt;IPv4(0)&lt;/code&gt; 或 &lt;code&gt;IPv6(0)&lt;/code&gt; 。 &lt;code&gt;backlog&lt;/code&gt; 确定在服务器开始拒绝连接之前可以挂起多少个连接（未调用&lt;a href=&quot;#Sockets.accept&quot;&gt; &lt;code&gt;accept&lt;/code&gt; &lt;/a&gt;）。 &lt;code&gt;backlog&lt;/code&gt; 的默认值为511。</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="8aa67be98327d7646247b7e62d87af940b94fc8a" translate="yes" xml:space="preserve">
          <source>Lists can contain other nested toplevel elements such as lists, code blocks, or quoteblocks. A blank line should be left between each list item when including any toplevel elements within a list.</source>
          <target state="translated">列表可以包含其他嵌套的toplevel元素,如列表、代码块或引号块。当在一个列表中包含任何toplevel元素时,每个列表项之间应该留有空行。</target>
        </trans-unit>
        <trans-unit id="4c9fcbea9e81be568fdc5a4af6993f666806fde2" translate="yes" xml:space="preserve">
          <source>Literal floating-point numbers are represented in the standard formats, using &lt;a href=&quot;https://en.wikipedia.org/wiki/Scientific_notation#E-notation&quot;&gt;E-notation&lt;/a&gt; when necessary:</source>
          <target state="translated">文字浮点数以标准格式&lt;a href=&quot;https://en.wikipedia.org/wiki/Scientific_notation#E-notation&quot;&gt;表示&lt;/a&gt;，必要时使用E表示法：</target>
        </trans-unit>
        <trans-unit id="3562cae13eedce4e4d416c818141141826f44ea7" translate="yes" xml:space="preserve">
          <source>Literal integers are represented in the standard manner:</source>
          <target state="translated">字面整数以标准方式表示。</target>
        </trans-unit>
        <trans-unit id="2ab27329d47948b21415226c577e214e77fab191" translate="yes" xml:space="preserve">
          <source>Literal one of type &lt;code&gt;x&lt;/code&gt; or type of variable &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">类型 &lt;code&gt;x&lt;/code&gt; 或变量 &lt;code&gt;x&lt;/code&gt; 的文字之一</target>
        </trans-unit>
        <trans-unit id="a585d71445ba7f9e68c5da186d786f4437873367" translate="yes" xml:space="preserve">
          <source>Literal zero and one</source>
          <target state="translated">零和一的字面意义</target>
        </trans-unit>
        <trans-unit id="24e8678ee4be704fc611c4a474de77fa54f1d95f" translate="yes" xml:space="preserve">
          <source>Literal zero of type &lt;code&gt;x&lt;/code&gt; or type of variable &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 类型或变量 &lt;code&gt;x&lt;/code&gt; 类型的字面零</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="c6a4e1f3b4978cbaedfb2e99a34a61a5e64f4b8d" translate="yes" xml:space="preserve">
          <source>Literals should be used when writing text that refers to names of variables, functions, or other parts of a Julia program.</source>
          <target state="translated">在编写提及变量、函数或Julia程序其他部分名称的文本时,应该使用字符。</target>
        </trans-unit>
        <trans-unit id="cccfebf2b6bb84af7b7416c30102f0fb5345d20a" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; immediately on all processors</source>
          <target state="translated">立即在所有处理器上加载 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="221a8e52842df5b19245cbcdd992a3dedaa109d5" translate="yes" xml:space="preserve">
          <source>Load &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;</source>
          <target state="translated">加载 &lt;code&gt;~/.julia/config/startup.jl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea8d49a8f75a3b101a94caadd4a63e8ab235d750" translate="yes" xml:space="preserve">
          <source>Load a shared library, returning an opaque handle.</source>
          <target state="translated">加载一个共享库,返回一个不透明的句柄。</target>
        </trans-unit>
        <trans-unit id="c25f7156c983ea8a18f757a2b60fb37dd817a64d" translate="yes" xml:space="preserve">
          <source>Load a value of type &lt;code&gt;T&lt;/code&gt; from the address of the &lt;code&gt;i&lt;/code&gt;th element (1-indexed) starting at &lt;code&gt;p&lt;/code&gt;. This is equivalent to the C expression &lt;code&gt;p[i-1]&lt;/code&gt;.</source>
          <target state="translated">从第 &lt;code&gt;p&lt;/code&gt; 个元素的第 &lt;code&gt;i&lt;/code&gt; 个元素的地址（索引为1的索引）加载类型 &lt;code&gt;T&lt;/code&gt; 的值。这等效于C表达式 &lt;code&gt;p[i-1]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37f3c2f4c2bbe8c48d77f7372d4681f5071a6c1b" translate="yes" xml:space="preserve">
          <source>Load or save history</source>
          <target state="translated">加载或保存历史记录</target>
        </trans-unit>
        <trans-unit id="2a3d64c128591f94e5fcdc12bbe22bc691844af1" translate="yes" xml:space="preserve">
          <source>Load the file using &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;, evaluate all expressions, and return the value of the last one.</source>
          <target state="translated">使用&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; &lt;/a&gt;加载文件，评估所有表达式，并返回最后一个表达式的值。</target>
        </trans-unit>
        <trans-unit id="1c25d02a3443b64be0a5e8874e859825f3a072cf" translate="yes" xml:space="preserve">
          <source>Loads a source file, in the context of the &lt;code&gt;Main&lt;/code&gt; module, on every active node, searching standard locations for files. &lt;code&gt;require&lt;/code&gt; is considered a top-level operation, so it sets the current &lt;code&gt;include&lt;/code&gt; path but does not use it to search for files (see help for &lt;a href=&quot;#Base.include&quot;&gt;&lt;code&gt;include&lt;/code&gt;&lt;/a&gt;). This function is typically used to load library code, and is implicitly called by &lt;code&gt;using&lt;/code&gt; to load packages.</source>
          <target state="translated">在 &lt;code&gt;Main&lt;/code&gt; 模块的上下文中，在每个活动节点上加载源文件，在标准位置中搜索文件。 &lt;code&gt;require&lt;/code&gt; 被认为是顶级操作，因此它设置了当前 &lt;code&gt;include&lt;/code&gt; 路径，但不使用它来搜索文件（有关&lt;a href=&quot;#Base.include&quot;&gt; &lt;code&gt;include&lt;/code&gt; 的信息,&lt;/a&gt;请参阅帮助）。该函数通常用于加载库代码，并通过 &lt;code&gt;using&lt;/code&gt; 隐式调用来加载程序包。</target>
        </trans-unit>
        <trans-unit id="2aaca902d4d3758e11a3b458199407392409931c" translate="yes" xml:space="preserve">
          <source>Local Scope</source>
          <target state="translated">当地范围</target>
        </trans-unit>
        <trans-unit id="53e6be3ba94721357dc8f1cd8a4a35bc46260d53" translate="yes" xml:space="preserve">
          <source>Local constants are quite different. The compiler is able to determine automatically when a local variable is constant, so local constant declarations are not necessary, and in fact are currently not supported.</source>
          <target state="translated">局部常量则完全不同。编译器能够自动判断局部变量是常数,所以局部常数的声明是没有必要的,事实上目前也不支持。</target>
        </trans-unit>
        <trans-unit id="7bc74c802188a5ae5dd86ce1121ca4599d93af45" translate="yes" xml:space="preserve">
          <source>Local invocations</source>
          <target state="translated">本地调用</target>
        </trans-unit>
        <trans-unit id="aea223f531a712477fac84f8fcf490b4f65ae3a6" translate="yes" xml:space="preserve">
          <source>Local invocations(@id man-distributed-local-invocations)</source>
          <target state="translated">本地调用(@id man-distributed-local-invocations)</target>
        </trans-unit>
        <trans-unit id="40051a807238da75ab231f8a8a71c830f614ed27" translate="yes" xml:space="preserve">
          <source>Local variable &lt;code&gt;x&lt;/code&gt; starts as an integer, and after one loop iteration becomes a floating-point number (the result of &lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt;&lt;code&gt;/&lt;/code&gt;&lt;/a&gt; operator). This makes it more difficult for the compiler to optimize the body of the loop. There are several possible fixes:</source>
          <target state="translated">局部变量 &lt;code&gt;x&lt;/code&gt; 以整数开始，并且在一个循环迭代后变为浮点数（&lt;a href=&quot;../../base/math/index#Base.:/&quot;&gt; &lt;code&gt;/&lt;/code&gt; &lt;/a&gt;运算符的结果）。这使编译器更难于优化循环的主体。有几种可能的修复：</target>
        </trans-unit>
        <trans-unit id="891ebccd5baa32daed16fb5a0825ca7a4464931f" translate="yes" xml:space="preserve">
          <source>Lock</source>
          <target state="translated">Lock</target>
        </trans-unit>
        <trans-unit id="7e9d4e021d5117e7b0d661a7918f799df5c20541" translate="yes" xml:space="preserve">
          <source>Lock With Ink Pen</source>
          <target state="translated">墨笔锁</target>
        </trans-unit>
        <trans-unit id="2d7a18ee66cedde04088fccb894adfaa5d0be6f1" translate="yes" xml:space="preserve">
          <source>Log a message to &lt;code&gt;logger&lt;/code&gt; at &lt;code&gt;level&lt;/code&gt;. The logical location at which the message was generated is given by module &lt;code&gt;_module&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;; the source location by &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;id&lt;/code&gt; is an arbitrary unique &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt; to be used as a key to identify the log statement when filtering.</source>
          <target state="translated">将消息 &lt;code&gt;logger&lt;/code&gt; 到 &lt;code&gt;level&lt;/code&gt; 记录器。生成消息的逻辑位置由模块 &lt;code&gt;_module&lt;/code&gt; 和 &lt;code&gt;group&lt;/code&gt; 给出；按 &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; 的源位置。 &lt;code&gt;id&lt;/code&gt; 是一个任意的唯一&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;，用作过滤时标识日志语句的键。</target>
        </trans-unit>
        <trans-unit id="2db3a05837e9b250facfd93e1fe4f8c7f938c9cc" translate="yes" xml:space="preserve">
          <source>Log a message to &lt;code&gt;logger&lt;/code&gt; at &lt;code&gt;level&lt;/code&gt;. The logical location at which the message was generated is given by module &lt;code&gt;_module&lt;/code&gt; and &lt;code&gt;group&lt;/code&gt;; the source location by &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt;. &lt;code&gt;id&lt;/code&gt; is an arbitrary unique value (typically a &lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt;&lt;code&gt;Symbol&lt;/code&gt;&lt;/a&gt;) to be used as a key to identify the log statement when filtering.</source>
          <target state="translated">将消息 &lt;code&gt;logger&lt;/code&gt; 到 &lt;code&gt;level&lt;/code&gt; 记录器中。生成消息的逻辑位置由模块 &lt;code&gt;_module&lt;/code&gt; 和 &lt;code&gt;group&lt;/code&gt; 给出；按 &lt;code&gt;file&lt;/code&gt; 和 &lt;code&gt;line&lt;/code&gt; 的源位置。 &lt;code&gt;id&lt;/code&gt; 是一个任意的唯一值（通常是&lt;a href=&quot;../../base/base/index#Core.Symbol&quot;&gt; &lt;code&gt;Symbol&lt;/code&gt; &lt;/a&gt;），用作过滤时标识日志语句的键。</target>
        </trans-unit>
        <trans-unit id="d4ccff841d7f5fb35e7f3223eae831d879121ed8" translate="yes" xml:space="preserve">
          <source>Log event structure</source>
          <target state="translated">日志事件结构</target>
        </trans-unit>
        <trans-unit id="5de4f5e761f85511e1c9dded76464677e6b5b91b" translate="yes" xml:space="preserve">
          <source>Log events are a side effect of running normal code, but you might find yourself wanting to test particular informational messages and warnings. The &lt;code&gt;Test&lt;/code&gt; module provides a &lt;a href=&quot;../test/index#Test.@test_logs&quot;&gt;&lt;code&gt;@test_logs&lt;/code&gt;&lt;/a&gt; macro that can be used to pattern match against the log event stream.</source>
          <target state="translated">日志事件是运行常规代码的副作用，但是您可能会发现自己想要测试特定的信息性消息和警告。所述 &lt;code&gt;Test&lt;/code&gt; 模块提供了&lt;a href=&quot;../test/index#Test.@test_logs&quot;&gt; &lt;code&gt;@test_logs&lt;/code&gt; &lt;/a&gt;其可以用来对日志事件流模式匹配宏。</target>
        </trans-unit>
        <trans-unit id="39e0c0b6171a5e937cc4b913037f6617883ef778" translate="yes" xml:space="preserve">
          <source>Log levels less than &lt;code&gt;min_level&lt;/code&gt; are filtered out.</source>
          <target state="translated">小于 &lt;code&gt;min_level&lt;/code&gt; 的日志级别被过滤掉。</target>
        </trans-unit>
        <trans-unit id="b95a88cbf9b7104d12a1c6e6be0a2df585c9c414" translate="yes" xml:space="preserve">
          <source>Log of absolute value of matrix determinant. Equivalent to &lt;code&gt;(log(abs(det(M))), sign(det(M)))&lt;/code&gt;, but may provide increased accuracy and/or speed.</source>
          <target state="translated">矩阵行列式绝对值的对数。等效于 &lt;code&gt;(log(abs(det(M))), sign(det(M)))&lt;/code&gt; ，但可以提供更高的准确性和/或速度。</target>
        </trans-unit>
        <trans-unit id="25e0bc59a9512a0f503efed371b6e58c737cb2b5" translate="yes" xml:space="preserve">
          <source>Log of matrix determinant. Equivalent to &lt;code&gt;log(det(M))&lt;/code&gt;, but may provide increased accuracy and/or speed.</source>
          <target state="translated">矩阵行列式的对数。等效于 &lt;code&gt;log(det(M))&lt;/code&gt; ，但可以提供更高的准确性和/或速度。</target>
        </trans-unit>
        <trans-unit id="09b41ebbca90f28e72616fb548aed5c2cdb190af" translate="yes" xml:space="preserve">
          <source>Logger installation and inspection:</source>
          <target state="translated">记录仪安装和检查。</target>
        </trans-unit>
        <trans-unit id="3e0a58fce8ac790c3d3776b2f9cb69da4b8e968b" translate="yes" xml:space="preserve">
          <source>Logger which disables all messages and produces no output - the logger equivalent of /dev/null.</source>
          <target state="translated">禁用所有消息且不产生任何输出的记录仪--相当于/dev/null的记录仪。</target>
        </trans-unit>
        <trans-unit id="c489f7460af4426236655b519a2e843c0796afcf" translate="yes" xml:space="preserve">
          <source>Logger with formatting optimized for readability in a text console, for example interactive work with the Julia REPL.</source>
          <target state="translated">具有优化格式的记录器,可在文本控制台中读取,例如与Julia REPL的交互式工作。</target>
        </trans-unit>
        <trans-unit id="012294fbc07fc652fdbbd3b8b48183b6e7925dda" translate="yes" xml:space="preserve">
          <source>Loggers</source>
          <target state="translated">Loggers</target>
        </trans-unit>
        <trans-unit id="ab6dfdab464b019150c40525f7d8fef7f42317d8" translate="yes" xml:space="preserve">
          <source>Loggers that are supplied with the system:</source>
          <target state="translated">随系统提供的记录仪。</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="84dd6708d003df0c49c9ba90e02bb2e238e90fae" translate="yes" xml:space="preserve">
          <source>Logging module</source>
          <target state="translated">记录模块</target>
        </trans-unit>
        <trans-unit id="89da04acc02b6d97d3dda5b51691b7f2df8ab3f2" translate="yes" xml:space="preserve">
          <source>Logical (or boolean) operators &lt;code&gt;|&lt;/code&gt;, &lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/a&gt; are another special case, as they only propagate &lt;code&gt;missing&lt;/code&gt; values when it is logically required. For these operators, whether or not the result is uncertain depends on the particular operation, following the well-established rules of &lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;&lt;em&gt;three-valued logic&lt;/em&gt;&lt;/a&gt; which are also implemented by &lt;code&gt;NULL&lt;/code&gt; in SQL and &lt;code&gt;NA&lt;/code&gt; in R. This abstract definition actually corresponds to a relatively natural behavior which is best explained via concrete examples.</source>
          <target state="translated">逻辑（或布尔）运算符 &lt;code&gt;|&lt;/code&gt; ，&lt;a href=&quot;../../base/math/index#Base.:&amp;amp;&quot;&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;../../base/math/index#Base.xor&quot;&gt; &lt;code&gt;xor&lt;/code&gt; &lt;/a&gt;是另一种特殊情况，因为它们仅在逻辑上需要时才传播 &lt;code&gt;missing&lt;/code&gt; 值。对于这些运算符，结果的不确定性取决于特定的运算，遵循公认的&lt;a href=&quot;https://en.wikipedia.org/wiki/Three-valued_logic&quot;&gt;&lt;em&gt;三值逻辑&lt;/em&gt;&lt;/a&gt;规则，这些规则也由SQL中的 &lt;code&gt;NULL&lt;/code&gt; 和R中的 &lt;code&gt;NA&lt;/code&gt; 来实现。此抽象定义实际上对应于一个相对自然的最好通过具体示例来解释行为。</target>
        </trans-unit>
        <trans-unit id="786908e4097f50192db248aa36b5528e31277867" translate="yes" xml:space="preserve">
          <source>Logical And</source>
          <target state="translated">逻辑和</target>
        </trans-unit>
        <trans-unit id="67c3357e4a7007cce9dad8abe1e464a6faaed6cf" translate="yes" xml:space="preserve">
          <source>Logical And With Dot Above</source>
          <target state="translated">逻辑和上面的点</target>
        </trans-unit>
        <trans-unit id="ad73258bccc391936166d8f628d173e6ce3c7d3d" translate="yes" xml:space="preserve">
          <source>Logical And With Double Overbar</source>
          <target state="translated">逻辑和双过杆</target>
        </trans-unit>
        <trans-unit id="3a27d20134d696f264e94d803f411cd413383e05" translate="yes" xml:space="preserve">
          <source>Logical And With Double Underbar</source>
          <target state="translated">逻辑性强,带双下杠</target>
        </trans-unit>
        <trans-unit id="cb54d54f9d2ab29ccd05e2998f6679b7b0a51e55" translate="yes" xml:space="preserve">
          <source>Logical And With Horizontal Dash</source>
          <target state="translated">逻辑和水平破折号</target>
        </trans-unit>
        <trans-unit id="f6e1b3f2c2e3537f4121f6786ee7d2f1fdcc7214" translate="yes" xml:space="preserve">
          <source>Logical And With Middle Stem</source>
          <target state="translated">有逻辑和中轴</target>
        </trans-unit>
        <trans-unit id="cee1bd132c4db9d40b5015470294a3309557d652" translate="yes" xml:space="preserve">
          <source>Logical And With Underbar</source>
          <target state="translated">逻辑性和带下杠</target>
        </trans-unit>
        <trans-unit id="fed4dc8cd8f466453469c24bdf945b136419ffef" translate="yes" xml:space="preserve">
          <source>Logical Operations on Arrays</source>
          <target state="translated">数组的逻辑运算</target>
        </trans-unit>
        <trans-unit id="6b4765205b7632c3acd6f4b0016fe8b785f2d3e7" translate="yes" xml:space="preserve">
          <source>Logical Or</source>
          <target state="translated">逻辑或</target>
        </trans-unit>
        <trans-unit id="090611a42c7037c3c2bfae57153874d16efc59fb" translate="yes" xml:space="preserve">
          <source>Logical Or With Dot Above</source>
          <target state="translated">逻辑或上面有点</target>
        </trans-unit>
        <trans-unit id="563b798880b958c47070de3da511383e45a77828" translate="yes" xml:space="preserve">
          <source>Logical Or With Double Overbar</source>
          <target state="translated">逻辑或带双过杆</target>
        </trans-unit>
        <trans-unit id="7d683350404e6e9be8c9e2e65c1b673dedd263fb" translate="yes" xml:space="preserve">
          <source>Logical Or With Double Underbar</source>
          <target state="translated">逻辑或带双下杠</target>
        </trans-unit>
        <trans-unit id="66977fa56bf367cf9edb7c775c7703db1cb43216" translate="yes" xml:space="preserve">
          <source>Logical Or With Horizontal Dash</source>
          <target state="translated">逻辑或带水平破折号</target>
        </trans-unit>
        <trans-unit id="04ee9b0a538e88f1af58f8f182ea27dfc50a851f" translate="yes" xml:space="preserve">
          <source>Logical Or With Middle Stem</source>
          <target state="translated">逻辑或带中轴</target>
        </trans-unit>
        <trans-unit id="daaabe581776a9024a83133896be28214c21d330" translate="yes" xml:space="preserve">
          <source>Logical indexing</source>
          <target state="translated">逻辑索引</target>
        </trans-unit>
        <trans-unit id="a5da835bb3de6e8855950138a28dea23921e5aaa" translate="yes" xml:space="preserve">
          <source>Logical operators</source>
          <target state="translated">逻辑运算符</target>
        </trans-unit>
        <trans-unit id="621d5dc0716b80a4b24a2ab36703beb47f8e9970" translate="yes" xml:space="preserve">
          <source>Lollipop</source>
          <target state="translated">Lollipop</target>
        </trans-unit>
        <trans-unit id="3dd8963fe38f95d47b45ad8afdc61266eb3c705b" translate="yes" xml:space="preserve">
          <source>Long Left Right Arrow</source>
          <target state="translated">左右长箭头</target>
        </trans-unit>
        <trans-unit id="c35393bc1526e081d6c45ef1fbb48cf17d0c8bf0" translate="yes" xml:space="preserve">
          <source>Long Left Right Double Arrow</source>
          <target state="translated">左长右短双箭头</target>
        </trans-unit>
        <trans-unit id="e284c1dcf57b9e16654ce906eebd4ade05f805b3" translate="yes" xml:space="preserve">
          <source>Long Leftwards Arrow</source>
          <target state="translated">向左长箭头</target>
        </trans-unit>
        <trans-unit id="0b53faa1153d8df2a62532b492821e710a37aaad" translate="yes" xml:space="preserve">
          <source>Long Leftwards Arrow From Bar</source>
          <target state="translated">长长的向左箭头从酒吧</target>
        </trans-unit>
        <trans-unit id="88125db03adc91c18e4b911d1e8543cb06fb2b1b" translate="yes" xml:space="preserve">
          <source>Long Leftwards Double Arrow</source>
          <target state="translated">向左长双箭头</target>
        </trans-unit>
        <trans-unit id="f84697639bf777eba1549b50e7d78fe9fc6c3b1a" translate="yes" xml:space="preserve">
          <source>Long Leftwards Double Arrow From Bar</source>
          <target state="translated">长长的向左双箭头从酒吧</target>
        </trans-unit>
        <trans-unit id="b98fbfea9069a23125b4969bdb4539cfde1d985c" translate="yes" xml:space="preserve">
          <source>Long Leftwards Squiggle Arrow</source>
          <target state="translated">向左长箭头</target>
        </trans-unit>
        <trans-unit id="ea5233fe4b9cd95205a27a4dce0a7bbfb8aae26f" translate="yes" xml:space="preserve">
          <source>Long Rightwards Arrow</source>
          <target state="translated">向右长箭头</target>
        </trans-unit>
        <trans-unit id="529625a98773524bc52c828a69957fbaaca9fd91" translate="yes" xml:space="preserve">
          <source>Long Rightwards Arrow From Bar</source>
          <target state="translated">长长的向右箭头从酒吧</target>
        </trans-unit>
        <trans-unit id="0e2515e3d0dae9c81aaf0c44bf451d94396badbf" translate="yes" xml:space="preserve">
          <source>Long Rightwards Double Arrow</source>
          <target state="translated">向右长双箭头</target>
        </trans-unit>
        <trans-unit id="1278f556f7a008b8d9f849c9d7f07ad7d2fda02a" translate="yes" xml:space="preserve">
          <source>Long Rightwards Double Arrow From Bar</source>
          <target state="translated">长长的向右双箭头从酒吧</target>
        </trans-unit>
        <trans-unit id="3c3264b81769074f17253d6ac449ae0214eb0511" translate="yes" xml:space="preserve">
          <source>Long Rightwards Squiggle Arrow</source>
          <target state="translated">向右长箭头</target>
        </trans-unit>
        <trans-unit id="f9731487237a7d36eb57c97e02893eb0fcbe12b9" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using its name and URL. Uses the default fetch refspec.</source>
          <target state="translated">使用远程 git 仓库的名称和 URL 查找它。使用默认的fetch refspec。</target>
        </trans-unit>
        <trans-unit id="f3e71ff4dab9481f1e14a82514827c17c83dee43" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using only its URL, not its name.</source>
          <target state="translated">只用URL而不是名称来查找远程git仓库。</target>
        </trans-unit>
        <trans-unit id="6d614bcd7bb6dd66d43226d39894a37944a369ee" translate="yes" xml:space="preserve">
          <source>Look up a remote git repository using the repository's name and URL, as well as specifications for how to fetch from the remote (e.g. which remote branch to fetch from).</source>
          <target state="translated">使用仓库的名称和 URL,以及如何从远程获取的规范(例如从哪个远程分支获取),查找一个远程 git 仓库。</target>
        </trans-unit>
        <trans-unit id="297e4906774f5b0f9f9ea2352dd36b66f2c9d575" translate="yes" xml:space="preserve">
          <source>Look up a symbol from a shared library handle, return callable function pointer on success.</source>
          <target state="translated">从共享库句柄中查找一个符号,成功后返回可调用函数指针。</target>
        </trans-unit>
        <trans-unit id="b2554c797a77ef5cd564f4094822fce342e2ced7" translate="yes" xml:space="preserve">
          <source>Look up a symbol from a shared library handle, silently return &lt;code&gt;C_NULL&lt;/code&gt; on lookup failure. This method is now deprecated in favor of &lt;code&gt;dlsym(handle, sym; throw_error=false)&lt;/code&gt;.</source>
          <target state="translated">从共享库句柄中查找 &lt;code&gt;C_NULL&lt;/code&gt; ，查找失败时静默返回C_NULL。现在不推荐使用此方法，而推荐使用 &lt;code&gt;dlsym(handle, sym; throw_error=false)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c18a26a0372be6990fb3f7d9280fb8a4395903a4" translate="yes" xml:space="preserve">
          <source>Look up the value of a key in the current task's task-local storage.</source>
          <target state="translated">在当前任务的任务本地存储中查找键的值。</target>
        </trans-unit>
        <trans-unit id="1a5964da6a0276ac045eacedf1ca054ba281575e" translate="yes" xml:space="preserve">
          <source>Lookup the name of the current HEAD of git repository &lt;code&gt;repo&lt;/code&gt;. If &lt;code&gt;repo&lt;/code&gt; is currently detached, return the name of the HEAD it's detached from.</source>
          <target state="translated">查找git repository &lt;code&gt;repo&lt;/code&gt; 的当前HEAD的名称。如果 &lt;code&gt;repo&lt;/code&gt; 当前已分离，则返回与其分离的HEAD的名称。</target>
        </trans-unit>
        <trans-unit id="c7d22d27b21054a2d862fb3e778055ec62497845" translate="yes" xml:space="preserve">
          <source>Lookup the object id of the current HEAD of git repository &lt;code&gt;repo&lt;/code&gt;.</source>
          <target state="translated">查找git repository &lt;code&gt;repo&lt;/code&gt; 当前HEAD的对象ID 。</target>
        </trans-unit>
        <trans-unit id="2897343d4dfca50b3dbd880e6b406397dfc276be" translate="yes" xml:space="preserve">
          <source>Lookup the status of the file at &lt;code&gt;path&lt;/code&gt; in the git repository &lt;code&gt;repo&lt;/code&gt;. For instance, this can be used to check if the file at &lt;code&gt;path&lt;/code&gt; has been modified and needs to be staged and committed.</source>
          <target state="translated">在git仓库 &lt;code&gt;repo&lt;/code&gt; 中的 &lt;code&gt;path&lt;/code&gt; 处查找文件的状态。例如，它可用于检查 &lt;code&gt;path&lt;/code&gt; 的文件是否已被修改以及是否需要暂存和提交。</target>
        </trans-unit>
        <trans-unit id="e83f1c0d81e570990421db9c6c5103dd52bab5e9" translate="yes" xml:space="preserve">
          <source>Loops and Comprehensions</source>
          <target state="translated">循环和理解</target>
        </trans-unit>
        <trans-unit id="292714b14a57c3b911bea2bc02c843a11e53cd72" translate="yes" xml:space="preserve">
          <source>Loudly Crying Face</source>
          <target state="translated">大声哭泣的脸</target>
        </trans-unit>
        <trans-unit id="68479172d96d6399ed79d6c3cc2275a9e4cb417d" translate="yes" xml:space="preserve">
          <source>Love Hotel</source>
          <target state="translated">爱情酒店</target>
        </trans-unit>
        <trans-unit id="e8ed5bf829210dcfddc85b2455095cf9764bc443" translate="yes" xml:space="preserve">
          <source>Love Letter</source>
          <target state="translated">情书</target>
        </trans-unit>
        <trans-unit id="1e20259076165d87571f777f8f501c9eec6cf077" translate="yes" xml:space="preserve">
          <source>Low Brightness Symbol</source>
          <target state="translated">低亮度符号</target>
        </trans-unit>
        <trans-unit id="3c768d286c3fa1a1be3b0b32968dce7e2bf6df5f" translate="yes" xml:space="preserve">
          <source>Low-level (C kernel) based operations &lt;a href=&quot;https://github.com/JuliaGPU/OpenCL.jl&quot;&gt;OpenCL.jl&lt;/a&gt; and &lt;a href=&quot;https://github.com/JuliaGPU/CUDAdrv.jl&quot;&gt;CUDAdrv.jl&lt;/a&gt; which are respectively an OpenCL interface and a CUDA wrapper.</source>
          <target state="translated">基于低级（C内核）的操作&lt;a href=&quot;https://github.com/JuliaGPU/OpenCL.jl&quot;&gt;OpenCL.jl&lt;/a&gt;和&lt;a href=&quot;https://github.com/JuliaGPU/CUDAdrv.jl&quot;&gt;CUDAdrv.jl&lt;/a&gt;分别是OpenCL接口和CUDA包装器。</target>
        </trans-unit>
        <trans-unit id="0d470f206b953bd94a63cddee039b55b43eb02d8" translate="yes" xml:space="preserve">
          <source>Low-level (Julia Kernel) interfaces like &lt;a href=&quot;https://github.com/JuliaGPU/CUDAnative.jl&quot;&gt;CUDAnative.jl&lt;/a&gt; which is a Julia native CUDA implementation.</source>
          <target state="translated">低级（Julia内核）接口，如&lt;a href=&quot;https://github.com/JuliaGPU/CUDAnative.jl&quot;&gt;CUDAnative.jl&lt;/a&gt;，它是Julia的CUDA实现。</target>
        </trans-unit>
        <trans-unit id="8a939192d22d6941f17735b112fcce8351ea8eba" translate="yes" xml:space="preserve">
          <source>Low-level macro used to mark expressions returned by a macro that should be documented. If more than one expression is marked then the same docstring is applied to each expression.</source>
          <target state="translated">低级宏用于标记宏返回的应被记录的表达式。如果标记了多个表达式,那么就会对每个表达式使用相同的 docstring。</target>
        </trans-unit>
        <trans-unit id="93d0030ec86c684d10a9c49e09b2634f0ca13492" translate="yes" xml:space="preserve">
          <source>Low-level matrix operations</source>
          <target state="translated">低级矩阵操作</target>
        </trans-unit>
        <trans-unit id="c33ae1bfbf8999a2bc79cecceab734ada1f32053" translate="yes" xml:space="preserve">
          <source>Low-level synchronization primitives</source>
          <target state="translated">低级同步基元</target>
        </trans-unit>
        <trans-unit id="69c6e547fabb23ad635ac8fe93ede5712392e080" translate="yes" xml:space="preserve">
          <source>Lower &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;triangular matrix&lt;/a&gt;</source>
          <target state="translated">下&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;三角矩阵&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23a4f4335d144fa2497d4fe37f2b528b18f4e240" translate="yes" xml:space="preserve">
          <source>Lower &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;triangular matrix&lt;/a&gt; with unit diagonal</source>
          <target state="translated">下&lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_matrix&quot;&gt;三角矩阵&lt;/a&gt;，对角线单位</target>
        </trans-unit>
        <trans-unit id="e67838aee8be4e7755da1c297ec68ae6e282902c" translate="yes" xml:space="preserve">
          <source>Lower Half Block</source>
          <target state="translated">下半区</target>
        </trans-unit>
        <trans-unit id="b7bfddef31a484ac690f541d1587c0a82f9ea2c7" translate="yes" xml:space="preserve">
          <source>Lower Half Circle</source>
          <target state="translated">下半圈</target>
        </trans-unit>
        <trans-unit id="0a46dc7d5d38dbb0f9593bbac09bb5a5e1168df1" translate="yes" xml:space="preserve">
          <source>Lower Half Inverse White Circle</source>
          <target state="translated">下半部逆白圈</target>
        </trans-unit>
        <trans-unit id="19c077435147598603f42bc8543d280b80283f3c" translate="yes" xml:space="preserve">
          <source>Lower Left Quadrant Circular Arc</source>
          <target state="translated">左下象限圆弧</target>
        </trans-unit>
        <trans-unit id="a3a82cb0d0923582f86a3cfde8b8e51e4ca1a96a" translate="yes" xml:space="preserve">
          <source>Lower Left Triangle</source>
          <target state="translated">左下角三角形</target>
        </trans-unit>
        <trans-unit id="01b22a0cc9e2a392fdb90f606abf5d1b88f864a7" translate="yes" xml:space="preserve">
          <source>Lower Right Quadrant Circular Arc</source>
          <target state="translated">右下象限圆弧</target>
        </trans-unit>
        <trans-unit id="70aee1ac83a2f1a5579bf9159c07bceb364ffd0e" translate="yes" xml:space="preserve">
          <source>Lower Right Triangle</source>
          <target state="translated">右下角三角形</target>
        </trans-unit>
        <trans-unit id="fe9cd1617eaf77e57754425b931c1afef95157bf" translate="yes" xml:space="preserve">
          <source>Lower bound for log level of accepted events</source>
          <target state="translated">已接受事件的对数水平的下限</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
